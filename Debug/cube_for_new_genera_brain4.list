
cube_for_new_genera_brain4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         0000000c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0002b5fc  00008010  00008010  00008010  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .fini         0000000c  0003360c  0003360c  0003360c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000229d8  00033618  00033618  00033618  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.exidx    00000008  00055ff0  00055ff0  00055ff0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .eh_frame     00000004  00055ff8  00055ff8  00055ff8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .init_array   00000004  00065ffc  00065ffc  00055ffc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  00066000  00066000  00056000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000499  00066004  00066004  00056004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .RAM_D2       000015e8  000664a0  000664a0  000564a0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 10 .RAM_D1       0007eb58  00067aa0  00067aa0  00057aa0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 11 .SDRAM        02000000  000e6600  000e6600  000d6600  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 12 .RAM_D3       00000201  020e6600  020e6600  020d6600  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00019030  020e6808  020e6808  020d6801  2**3
                  ALLOC
 14 .comment      0000007b  00000000  00000000  020d6801  2**0
                  CONTENTS, READONLY
 15 .debug_aranges 000042d8  00000000  00000000  020d687c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_info   000c2977  00000000  00000000  020dab54  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_abbrev 00010f1f  00000000  00000000  0219d4cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   00052577  00000000  00000000  021ae3ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  00010158  00000000  00000000  02200964  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    0018cc41  00000000  00000000  02210abc  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    000615fe  00000000  00000000  0239d6fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 00010778  00000000  00000000  023fecfb  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  0004905c  00000000  00000000  0240f473  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .ARM.attributes 0000002e  00000000  00000000  024584cf  2**0
                  CONTENTS, READONLY

Disassembly of section .init:

00008000 <_init>:
    8000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8002:	bf00      	nop
    8004:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8006:	bc08      	pop	{r3}
    8008:	469e      	mov	lr, r3
    800a:	4770      	bx	lr

Disassembly of section .text:

00008010 <exit>:
    8010:	b508      	push	{r3, lr}
    8012:	4b07      	ldr	r3, [pc, #28]	; (8030 <exit+0x20>)
    8014:	4604      	mov	r4, r0
    8016:	b113      	cbz	r3, 801e <exit+0xe>
    8018:	2100      	movs	r1, #0
    801a:	f3af 8000 	nop.w
    801e:	4b05      	ldr	r3, [pc, #20]	; (8034 <exit+0x24>)
    8020:	6818      	ldr	r0, [r3, #0]
    8022:	6a83      	ldr	r3, [r0, #40]	; 0x28
    8024:	b103      	cbz	r3, 8028 <exit+0x18>
    8026:	4798      	blx	r3
    8028:	4620      	mov	r0, r4
    802a:	f01c fca5 	bl	24978 <_exit>
    802e:	bf00      	nop
    8030:	00000000 	.word	0x00000000
    8034:	0005568c 	.word	0x0005568c

00008038 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
    8038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* USER CODE BEGIN 1 */
  MPU_Conf();
    803a:	f012 ffb1 	bl	1afa0 <MPU_Conf>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    803e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8042:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8046:	f44f 446d 	mov.w	r4, #60672	; 0xed00
    804a:	2500      	movs	r5, #0
    804c:	f2ce 0400 	movt	r4, #57344	; 0xe000
    8050:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    8054:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8058:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
    805c:	6963      	ldr	r3, [r4, #20]
    805e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    8062:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    8064:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8068:	f3bf 8f6f 	isb	sy

  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
    806c:	f012 fe4e 	bl	1ad0c <SCB_EnableDCache>

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
    8070:	f000 f9b0 	bl	83d4 <HAL_Init>
  __ASM volatile ("dsb 0xF":::"memory");
    8074:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8078:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_DisableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
    807c:	6963      	ldr	r3, [r4, #20]
    807e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    8082:	6163      	str	r3, [r4, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8084:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    8088:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    808c:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
    8090:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    8094:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
    8098:	6963      	ldr	r3, [r4, #20]
    809a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    809e:	6163      	str	r3, [r4, #20]
    80a0:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
    80a4:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
                                            /* clean & invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80a8:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
    80ac:	f3c3 06c9 	ubfx	r6, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    80b0:	f3c3 334e 	ubfx	r3, r3, #13, #15
    80b4:	07b7      	lsls	r7, r6, #30
    80b6:	0158      	lsls	r0, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80b8:	ea00 050c 	and.w	r5, r0, ip
    80bc:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
    80be:	4632      	mov	r2, r6
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80c0:	ea41 0305 	orr.w	r3, r1, r5
                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
    80c4:	3a01      	subs	r2, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80c6:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
    80ca:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
      } while (ways-- != 0U);
    80ce:	1c53      	adds	r3, r2, #1
    80d0:	d1f6      	bne.n	80c0 <main+0x88>
    80d2:	3820      	subs	r0, #32
    } while(sets-- != 0U);
    80d4:	f110 0f20 	cmn.w	r0, #32
    80d8:	d1ee      	bne.n	80b8 <main+0x80>
    80da:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    80de:	f3bf 8f6f 	isb	sy
  /* Enable D-Cache---------------------------------------------------------*/
  SCB_DisableDCache();
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
    80e2:	f012 fe45 	bl	1ad70 <SystemClock_Config>


  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
    80e6:	f012 fb6b 	bl	1a7c0 <MX_GPIO_Init>
  MX_BDMA_Init();
    80ea:	f010 fe45 	bl	18d78 <MX_BDMA_Init>
  MX_DMA_Init();
    80ee:	f010 ff5d 	bl	18fac <MX_DMA_Init>
  MX_FMC_Init();
    80f2:	f011 fb77 	bl	197e4 <MX_FMC_Init>
  MX_ADC1_Init();
    80f6:	f00f ffc1 	bl	1807c <MX_ADC1_Init>
  MX_I2C2_Init();
    80fa:	f012 fc93 	bl	1aa24 <MX_I2C2_Init>
  MX_SDMMC1_SD_Init();
    80fe:	f013 ff9f 	bl	1c040 <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
    8102:	f011 fb4f 	bl	197a4 <MX_FATFS_Init>
  MX_SAI1_Init();
    8106:	f013 fdf1 	bl	1bcec <MX_SAI1_Init>
  MX_RNG_Init();
    810a:	f013 fdbd 	bl	1bc88 <MX_RNG_Init>
  MX_I2C4_Init();
    810e:	f012 fcc1 	bl	1aa94 <MX_I2C4_Init>
  MX_USB_HOST_Init();
    8112:	f01e fc7d 	bl	26a10 <MX_USB_HOST_Init>
  MX_TIM3_Init();
    8116:	f01c fc35 	bl	24984 <MX_TIM3_Init>
  MX_TIM4_Init();
    811a:	f01c fcc3 	bl	24aa4 <MX_TIM4_Init>
  __ASM volatile ("dsb 0xF":::"memory");
    811e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8122:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8126:	2500      	movs	r5, #0
    8128:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    812c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8130:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
    8134:	6963      	ldr	r3, [r4, #20]
    8136:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    813a:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    813c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8140:	f3bf 8f6f 	isb	sy
  // otherwise turning on -o3 optimization causes unreliable behavior where it's not set up correctly and never reaches the USB interrupt for connection
  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
    8144:	f012 fde2 	bl	1ad0c <SCB_EnableDCache>


  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
    8148:	f64e 2018 	movw	r0, #59928	; 0xea18
    814c:	2104      	movs	r1, #4
    814e:	f2c0 200f 	movt	r0, #527	; 0x20f
    8152:	f00b fcd7 	bl	13b04 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
    8156:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
    815a:	4629      	mov	r1, r5
    815c:	f2c0 200f 	movt	r0, #527	; 0x20f
    8160:	f00b fcd0 	bl	13b04 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
    8164:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
    8168:	2104      	movs	r1, #4
    816a:	f2c0 200f 	movt	r0, #527	; 0x20f
    816e:	f00b fcc9 	bl	13b04 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);
    8172:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
    8176:	2108      	movs	r1, #8
    8178:	f2c0 200f 	movt	r0, #527	; 0x20f
    817c:	f00b fcc2 	bl	13b04 <HAL_TIM_PWM_Start>

  //HAL_Delay(1);
  // Emulated EEPROM Init
  HAL_FLASH_Unlock();
    8180:	f003 ffbe 	bl	c100 <HAL_FLASH_Unlock>
  if( EE_Init() != EE_OK)
    8184:	f010 ffa8 	bl	190d8 <EE_Init>
    8188:	4605      	mov	r5, r0
    818a:	b100      	cbz	r0, 818e <main+0x156>
    818c:	e7fe      	b.n	818c <main+0x154>
  {
    Error_Handler();
  }
  if((EE_ReadVariable(VirtAddVarTab[0],  &VarDataTab)) != HAL_OK) // read what the preset was before last power-off
    818e:	f246 041c 	movw	r4, #24604	; 0x601c
    8192:	f646 0170 	movw	r1, #26736	; 0x6870
    8196:	f2c0 0406 	movt	r4, #6
    819a:	f2c0 210e 	movt	r1, #526	; 0x20e
    819e:	8820      	ldrh	r0, [r4, #0]
    81a0:	f011 f9a0 	bl	194e4 <EE_ReadVariable>
    81a4:	2800      	cmp	r0, #0
    81a6:	d163      	bne.n	8270 <main+0x238>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
	{
		Error_Handler();
	}
  }
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    81a8:	f646 0370 	movw	r3, #26736	; 0x6870
    81ac:	f646 11b9 	movw	r1, #27065	; 0x69b9

/* helper function to initialize measuring unit (cycle counter) */
static void CycleCounterInit( void )
{
  /* Enable TRC */
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    81b0:	f64e 52f0 	movw	r2, #60912	; 0xedf0

  /* Unlock DWT registers */
  if ((*(uint32_t*)0xE0001FB4) & 1)
    81b4:	f641 70b4 	movw	r0, #8116	; 0x1fb4
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    81b8:	f2c0 230e 	movt	r3, #526	; 0x20e
    81bc:	f2c0 210e 	movt	r1, #526	; 0x20e
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    81c0:	f2ce 0200 	movt	r2, #57344	; 0xe000
  if ((*(uint32_t*)0xE0001FB4) & 1)
    81c4:	f2ce 0000 	movt	r0, #57344	; 0xe000
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    81c8:	881b      	ldrh	r3, [r3, #0]
    81ca:	2b12      	cmp	r3, #18
    81cc:	bf28      	it	cs
    81ce:	2300      	movcs	r3, #0
    81d0:	700b      	strb	r3, [r1, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    81d2:	68d3      	ldr	r3, [r2, #12]
    81d4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    81d8:	60d3      	str	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
    81da:	6803      	ldr	r3, [r0, #0]
    81dc:	07db      	lsls	r3, r3, #31
    81de:	d508      	bpl.n	81f2 <main+0x1ba>
    *(uint32_t*)0xE0001FB0 = 0xC5ACCE55;
    81e0:	f641 73b0 	movw	r3, #8112	; 0x1fb0
    81e4:	f64c 6255 	movw	r2, #52821	; 0xce55
    81e8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    81ec:	f2cc 52ac 	movt	r2, #50604	; 0xc5ac
    81f0:	601a      	str	r2, [r3, #0]

  /* clear the cycle counter */
  DWT->CYCCNT = 0;
    81f2:	f44f 5280 	mov.w	r2, #4096	; 0x1000

  /* start the cycle counter */
  DWT->CTRL = 0x40000001;
    81f6:	2101      	movs	r1, #1

  for (int i = 0; i < 4; i++)
  {
	  cycleCountAverages[i][0] = 0.0f;
    81f8:	f64b 03c8 	movw	r3, #47304	; 0xb8c8
    81fc:	2400      	movs	r4, #0
  DWT->CYCCNT = 0;
    81fe:	f2ce 0200 	movt	r2, #57344	; 0xe000
  DWT->CTRL = 0x40000001;
    8202:	f2c4 0100 	movt	r1, #16384	; 0x4000
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    8206:	f44f 6000 	mov.w	r0, #2048	; 0x800
	  cycleCountAverages[i][0] = 0.0f;
    820a:	f2c0 230f 	movt	r3, #527	; 0x20f
  DWT->CYCCNT = 0;
    820e:	6054      	str	r4, [r2, #4]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    8210:	f6c5 0002 	movt	r0, #22530	; 0x5802
  DWT->CTRL = 0x40000001;
    8214:	6011      	str	r1, [r2, #0]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    8216:	4622      	mov	r2, r4
    8218:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	  cycleCountAverages[i][0] = 0.0f;
    821c:	601c      	str	r4, [r3, #0]
	  cycleCountAverages[i][1] = 0.0f;
    821e:	605c      	str	r4, [r3, #4]
	  cycleCountAverages[i][2] = 0.0f;
    8220:	609c      	str	r4, [r3, #8]
	  cycleCountAverages[i][0] = 0.0f;
    8222:	60dc      	str	r4, [r3, #12]
	  cycleCountAverages[i][1] = 0.0f;
    8224:	611c      	str	r4, [r3, #16]
	  cycleCountAverages[i][2] = 0.0f;
    8226:	615c      	str	r4, [r3, #20]
	  cycleCountAverages[i][0] = 0.0f;
    8228:	619c      	str	r4, [r3, #24]
	  cycleCountAverages[i][1] = 0.0f;
    822a:	61dc      	str	r4, [r3, #28]
	  cycleCountAverages[i][2] = 0.0f;
    822c:	621c      	str	r4, [r3, #32]
	  cycleCountAverages[i][0] = 0.0f;
    822e:	625c      	str	r4, [r3, #36]	; 0x24
	  cycleCountAverages[i][1] = 0.0f;
    8230:	629c      	str	r4, [r3, #40]	; 0x28
	  cycleCountAverages[i][2] = 0.0f;
    8232:	62dc      	str	r4, [r3, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    8234:	f004 fd5a 	bl	ccec <HAL_GPIO_WritePin>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
    8238:	eef1 3a10 	vmrs	r3, fpscr
  tempFPURegisterVal |= (1<<24); // set the FTZ (flush-to-zero) bit in the FPU control register  // this makes checking for denormals not necessary as they are automatically set to zero by the hardware
    823c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    8240:	eee1 3a10 	vmsr	fpscr, r3
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
    8244:	f646 2074 	movw	r0, #27252	; 0x6a74
    8248:	4621      	mov	r1, r4
    824a:	f240 72ff 	movw	r2, #2047	; 0x7ff
    824e:	f2c0 200e 	movt	r0, #526	; 0x20e
    8252:	f001 fb7d 	bl	9950 <HAL_ADCEx_Calibration_Start>
  if (HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_values, NUM_ADC_CHANNELS) != HAL_OK)
    8256:	f247 5120 	movw	r1, #29984	; 0x7520
    825a:	f646 2074 	movw	r0, #27252	; 0x6a74
    825e:	2206      	movs	r2, #6
    8260:	f2c0 0106 	movt	r1, #6
    8264:	f2c0 200e 	movt	r0, #526	; 0x20e
    8268:	f000 f928 	bl	84bc <HAL_ADC_Start_DMA>
    826c:	b138      	cbz	r0, 827e <main+0x246>
    826e:	e7fe      	b.n	826e <main+0x236>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
    8270:	4629      	mov	r1, r5
    8272:	8820      	ldrh	r0, [r4, #0]
    8274:	f011 f976 	bl	19564 <EE_WriteVariable>
    8278:	2800      	cmp	r0, #0
    827a:	d095      	beq.n	81a8 <main+0x170>
    827c:	e7fe      	b.n	827c <main+0x244>
    827e:	f24b 34ac 	movw	r4, #45996	; 0xb3ac
  HAL_Delay(10);
    8282:	200a      	movs	r0, #10
    8284:	f000 f8e2 	bl	844c <HAL_Delay>
    8288:	f2c0 240f 	movt	r4, #527	; 0x20f
  OLED_init(&hi2c4);
    828c:	4620      	mov	r0, r4
    828e:	f013 f85d 	bl	1b34c <OLED_init>
  SDRAM_Initialization_sequence();
    8292:	f012 fe11 	bl	1aeb8 <SDRAM_Initialization_sequence>
  audioInit(&hi2c2, &hsai_BlockA1, &hsai_BlockB1);
    8296:	f64b 2210 	movw	r2, #47632	; 0xba10
    829a:	f64b 3198 	movw	r1, #48024	; 0xbb98
    829e:	f24b 30f8 	movw	r0, #46072	; 0xb3f8
    82a2:	f2c0 220f 	movt	r2, #527	; 0x20f
    82a6:	f2c0 210f 	movt	r1, #527	; 0x20f
    82aa:	f2c0 200f 	movt	r0, #527	; 0x20f
    82ae:	f010 fc51 	bl	18b54 <audioInit>
  OLED_writePreset();
    82b2:	f012 ffaf 	bl	1b214 <OLED_writePreset>
    MX_USB_HOST_Process();
    82b6:	f01e fbef 	bl	26a98 <MX_USB_HOST_Process>
    OLED_process(); // process what to write to the screen but don't actually draw
    82ba:	f013 fc5d 	bl	1bb78 <OLED_process>
 	if (hi2c4.State == HAL_I2C_STATE_READY)
    82be:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    82c2:	2b20      	cmp	r3, #32
    82c4:	d1f7      	bne.n	82b6 <main+0x27e>
	  OLED_draw();
    82c6:	f013 f9d3 	bl	1b670 <OLED_draw>
    82ca:	e7f4      	b.n	82b6 <main+0x27e>

000082cc <__do_global_dtors_aux>:
    82cc:	b510      	push	{r4, lr}
    82ce:	4c05      	ldr	r4, [pc, #20]	; (82e4 <__do_global_dtors_aux+0x18>)
    82d0:	7823      	ldrb	r3, [r4, #0]
    82d2:	b933      	cbnz	r3, 82e2 <__do_global_dtors_aux+0x16>
    82d4:	4b04      	ldr	r3, [pc, #16]	; (82e8 <__do_global_dtors_aux+0x1c>)
    82d6:	b113      	cbz	r3, 82de <__do_global_dtors_aux+0x12>
    82d8:	4804      	ldr	r0, [pc, #16]	; (82ec <__do_global_dtors_aux+0x20>)
    82da:	f3af 8000 	nop.w
    82de:	2301      	movs	r3, #1
    82e0:	7023      	strb	r3, [r4, #0]
    82e2:	bd10      	pop	{r4, pc}
    82e4:	020e6808 	.word	0x020e6808
    82e8:	00000000 	.word	0x00000000
    82ec:	00055ff8 	.word	0x00055ff8

000082f0 <frame_dummy>:
    82f0:	b508      	push	{r3, lr}
    82f2:	4b03      	ldr	r3, [pc, #12]	; (8300 <frame_dummy+0x10>)
    82f4:	b11b      	cbz	r3, 82fe <frame_dummy+0xe>
    82f6:	4903      	ldr	r1, [pc, #12]	; (8304 <frame_dummy+0x14>)
    82f8:	4803      	ldr	r0, [pc, #12]	; (8308 <frame_dummy+0x18>)
    82fa:	f3af 8000 	nop.w
    82fe:	bd08      	pop	{r3, pc}
    8300:	00000000 	.word	0x00000000
    8304:	020e680c 	.word	0x020e680c
    8308:	00055ff8 	.word	0x00055ff8

0000830c <_mainCRTStartup>:
    830c:	4b15      	ldr	r3, [pc, #84]	; (8364 <_mainCRTStartup+0x58>)
    830e:	2b00      	cmp	r3, #0
    8310:	bf08      	it	eq
    8312:	4b13      	ldreq	r3, [pc, #76]	; (8360 <_mainCRTStartup+0x54>)
    8314:	469d      	mov	sp, r3
    8316:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
    831a:	2100      	movs	r1, #0
    831c:	468b      	mov	fp, r1
    831e:	460f      	mov	r7, r1
    8320:	4813      	ldr	r0, [pc, #76]	; (8370 <_mainCRTStartup+0x64>)
    8322:	4a14      	ldr	r2, [pc, #80]	; (8374 <_mainCRTStartup+0x68>)
    8324:	1a12      	subs	r2, r2, r0
    8326:	f027 ff44 	bl	301b2 <memset>
    832a:	4b0f      	ldr	r3, [pc, #60]	; (8368 <_mainCRTStartup+0x5c>)
    832c:	2b00      	cmp	r3, #0
    832e:	d000      	beq.n	8332 <_mainCRTStartup+0x26>
    8330:	4798      	blx	r3
    8332:	4b0e      	ldr	r3, [pc, #56]	; (836c <_mainCRTStartup+0x60>)
    8334:	2b00      	cmp	r3, #0
    8336:	d000      	beq.n	833a <_mainCRTStartup+0x2e>
    8338:	4798      	blx	r3
    833a:	2000      	movs	r0, #0
    833c:	2100      	movs	r1, #0
    833e:	0004      	movs	r4, r0
    8340:	000d      	movs	r5, r1
    8342:	480d      	ldr	r0, [pc, #52]	; (8378 <_mainCRTStartup+0x6c>)
    8344:	2800      	cmp	r0, #0
    8346:	d002      	beq.n	834e <_mainCRTStartup+0x42>
    8348:	480c      	ldr	r0, [pc, #48]	; (837c <_mainCRTStartup+0x70>)
    834a:	f3af 8000 	nop.w
    834e:	f027 fee7 	bl	30120 <__libc_init_array>
    8352:	0020      	movs	r0, r4
    8354:	0029      	movs	r1, r5
    8356:	f7ff fe6f 	bl	8038 <main>
    835a:	f7ff fe59 	bl	8010 <exit>
    835e:	bf00      	nop
    8360:	00080000 	.word	0x00080000
	...
    8370:	020e6801 	.word	0x020e6801
    8374:	020ff838 	.word	0x020ff838
	...

00008380 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
    8380:	f246 0304 	movw	r3, #24580	; 0x6004
    8384:	f2c0 0306 	movt	r3, #6
    8388:	781b      	ldrb	r3, [r3, #0]
    838a:	b90b      	cbnz	r3, 8390 <HAL_InitTick+0x10>
  {
    return HAL_ERROR;
    838c:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
    838e:	4770      	bx	lr
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
    8390:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8394:	f246 21b4 	movw	r1, #25268	; 0x62b4
    8398:	fbb2 f3f3 	udiv	r3, r2, r3
    839c:	f2c0 0106 	movt	r1, #6
{
    83a0:	b510      	push	{r4, lr}
    83a2:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
    83a4:	6808      	ldr	r0, [r1, #0]
    83a6:	fbb0 f0f3 	udiv	r0, r0, r3
    83aa:	f001 fce9 	bl	9d80 <HAL_SYSTICK_Config>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
    83ae:	2c0f      	cmp	r4, #15
    83b0:	d800      	bhi.n	83b4 <HAL_InitTick+0x34>
    83b2:	b108      	cbz	r0, 83b8 <HAL_InitTick+0x38>
    return HAL_ERROR;
    83b4:	2001      	movs	r0, #1
}
    83b6:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    83b8:	2200      	movs	r2, #0
    83ba:	4621      	mov	r1, r4
    83bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    83c0:	f001 fc5c 	bl	9c7c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
    83c4:	f246 0308 	movw	r3, #24584	; 0x6008
    83c8:	2000      	movs	r0, #0
    83ca:	f2c0 0306 	movt	r3, #6
    83ce:	601c      	str	r4, [r3, #0]
}
    83d0:	bd10      	pop	{r4, pc}
    83d2:	bf00      	nop

000083d4 <HAL_Init>:
{
    83d4:	b530      	push	{r4, r5, lr}
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83d6:	f44f 4588 	mov.w	r5, #17408	; 0x4400
{
    83da:	b083      	sub	sp, #12
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    83dc:	2003      	movs	r0, #3
  SystemCoreClock = common_system_clock;
    83de:	f246 24b4 	movw	r4, #25268	; 0x62b4
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83e2:	f6c5 0502 	movt	r5, #22530	; 0x5802
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    83e6:	f001 fc2b 	bl	9c40 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83ea:	f007 f8a1 	bl	f530 <HAL_RCC_GetSysClockFreq>
    83ee:	f244 72c4 	movw	r2, #18372	; 0x47c4
    83f2:	69ab      	ldr	r3, [r5, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83f4:	f246 21b8 	movw	r1, #25272	; 0x62b8
    83f8:	69ad      	ldr	r5, [r5, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83fa:	f2c0 0203 	movt	r2, #3
    83fe:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    8402:	f2c0 0106 	movt	r1, #6
    8406:	f005 050f 	and.w	r5, r5, #15
  SystemCoreClock = common_system_clock;
    840a:	f2c0 0406 	movt	r4, #6
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    840e:	5cd3      	ldrb	r3, [r2, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    8410:	5d52      	ldrb	r2, [r2, r5]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    8412:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    8416:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    841a:	fa20 f303 	lsr.w	r3, r0, r3
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
    841e:	2000      	movs	r0, #0
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    8420:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
    8424:	6023      	str	r3, [r4, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    8426:	600a      	str	r2, [r1, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
    8428:	f7ff ffaa 	bl	8380 <HAL_InitTick>
    842c:	b110      	cbz	r0, 8434 <HAL_Init+0x60>
    return HAL_ERROR;
    842e:	2001      	movs	r0, #1
}
    8430:	b003      	add	sp, #12
    8432:	bd30      	pop	{r4, r5, pc}
    8434:	9001      	str	r0, [sp, #4]
  HAL_MspInit();
    8436:	f01c fa8b 	bl	24950 <HAL_MspInit>
  return HAL_OK;
    843a:	9801      	ldr	r0, [sp, #4]
}
    843c:	b003      	add	sp, #12
    843e:	bd30      	pop	{r4, r5, pc}

00008440 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
    8440:	f646 13c4 	movw	r3, #27076	; 0x69c4
    8444:	f2c0 230e 	movt	r3, #526	; 0x20e
    8448:	6818      	ldr	r0, [r3, #0]
}
    844a:	4770      	bx	lr

0000844c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
    844c:	b538      	push	{r3, r4, r5, lr}
    844e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
    8450:	f7ff fff6 	bl	8440 <HAL_GetTick>
    8454:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
    8456:	1c63      	adds	r3, r4, #1
    8458:	d005      	beq.n	8466 <HAL_Delay+0x1a>
  {
    wait += (uint32_t)(uwTickFreq);
    845a:	f246 0304 	movw	r3, #24580	; 0x6004
    845e:	f2c0 0306 	movt	r3, #6
    8462:	781b      	ldrb	r3, [r3, #0]
    8464:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
    8466:	f7ff ffeb 	bl	8440 <HAL_GetTick>
    846a:	1b40      	subs	r0, r0, r5
    846c:	42a0      	cmp	r0, r4
    846e:	d3fa      	bcc.n	8466 <HAL_Delay+0x1a>
  {
  }
}
    8470:	bd38      	pop	{r3, r4, r5, pc}
    8472:	bf00      	nop

00008474 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
    8474:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    8478:	f6c5 4300 	movt	r3, #23552	; 0x5c00
    847c:	6818      	ldr	r0, [r3, #0]
}
    847e:	0c00      	lsrs	r0, r0, #16
    8480:	4770      	bx	lr
    8482:	bf00      	nop

00008484 <HAL_SetFMCMemorySwappingConfig>:
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    8484:	f030 7380 	bics.w	r3, r0, #16777216	; 0x1000000
{
    8488:	b510      	push	{r4, lr}
    848a:	4604      	mov	r4, r0
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    848c:	d002      	beq.n	8494 <HAL_SetFMCMemorySwappingConfig+0x10>
    848e:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
    8492:	d109      	bne.n	84a8 <HAL_SetFMCMemorySwappingConfig+0x24>
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
    8494:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    8498:	f2c5 2300 	movt	r3, #20992	; 0x5200
    849c:	6818      	ldr	r0, [r3, #0]
    849e:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
    84a2:	4320      	orrs	r0, r4
    84a4:	6018      	str	r0, [r3, #0]
}
    84a6:	bd10      	pop	{r4, pc}
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    84a8:	f243 6018 	movw	r0, #13848	; 0x3618
    84ac:	f44f 6181 	mov.w	r1, #1032	; 0x408
    84b0:	f2c0 0003 	movt	r0, #3
    84b4:	f012 fdfc 	bl	1b0b0 <assert_failed>
    84b8:	e7ec      	b.n	8494 <HAL_SetFMCMemorySwappingConfig+0x10>
    84ba:	bf00      	nop

000084bc <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
    84bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    84c0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
    84c4:	460e      	mov	r6, r1
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    84c6:	6801      	ldr	r1, [r0, #0]
{
    84c8:	4604      	mov	r4, r0
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    84ca:	f2c4 0302 	movt	r3, #16386	; 0x4002
{
    84ce:	4690      	mov	r8, r2
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    84d0:	4299      	cmp	r1, r3
    84d2:	d047      	beq.n	8564 <HAL_ADC_Start_DMA+0xa8>
    84d4:	f44f 5304 	mov.w	r3, #8448	; 0x2100
    84d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    84dc:	4299      	cmp	r1, r3
    84de:	d041      	beq.n	8564 <HAL_ADC_Start_DMA+0xa8>
    84e0:	f44f 43c6 	mov.w	r3, #25344	; 0x6300
    84e4:	f6c5 0302 	movt	r3, #22530	; 0x5802

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    84e8:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    84ec:	f44f 5004 	mov.w	r0, #8448	; 0x2100
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    84f0:	689d      	ldr	r5, [r3, #8]
    84f2:	f2c4 0702 	movt	r7, #16386	; 0x4002
    84f6:	f2c4 0002 	movt	r0, #16386	; 0x4002
    84fa:	42b9      	cmp	r1, r7
    84fc:	bf18      	it	ne
    84fe:	4281      	cmpne	r1, r0
    8500:	d005      	beq.n	850e <HAL_ADC_Start_DMA+0x52>
    8502:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    8506:	f6c5 0302 	movt	r3, #22530	; 0x5802
    850a:	4299      	cmp	r1, r3
    850c:	d12f      	bne.n	856e <HAL_ADC_Start_DMA+0xb2>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    850e:	688b      	ldr	r3, [r1, #8]
    8510:	075b      	lsls	r3, r3, #29
    8512:	d438      	bmi.n	8586 <HAL_ADC_Start_DMA+0xca>

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* Process locked */
    __HAL_LOCK(hadc);
    8514:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    8518:	2b01      	cmp	r3, #1
    851a:	d034      	beq.n	8586 <HAL_ADC_Start_DMA+0xca>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    851c:	f005 051f 	and.w	r5, r5, #31
    8520:	2301      	movs	r3, #1

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    8522:	2d09      	cmp	r5, #9
    __HAL_LOCK(hadc);
    8524:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    8528:	d905      	bls.n	8536 <HAL_ADC_Start_DMA+0x7a>
        LL_ADC_REG_StartConversion(hadc->Instance);
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
    852a:	2300      	movs	r3, #0
    852c:	2001      	movs	r0, #1
    852e:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    tmp_hal_status = HAL_BUSY;
  }

  /* Return function status */
  return tmp_hal_status;
}
    8532:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    8536:	f240 2321 	movw	r3, #545	; 0x221
    853a:	40eb      	lsrs	r3, r5
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
    853c:	07df      	lsls	r7, r3, #31
    853e:	d5f4      	bpl.n	852a <HAL_ADC_Start_DMA+0x6e>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8540:	688b      	ldr	r3, [r1, #8]
    8542:	07d8      	lsls	r0, r3, #31
    8544:	d422      	bmi.n	858c <HAL_ADC_Start_DMA+0xd0>
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    8546:	233f      	movs	r3, #63	; 0x3f
    8548:	688a      	ldr	r2, [r1, #8]
    854a:	f2c8 0300 	movt	r3, #32768	; 0x8000
    854e:	421a      	tst	r2, r3
    8550:	d073      	beq.n	863a <HAL_ADC_Start_DMA+0x17e>
        }

        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    8552:	6d63      	ldr	r3, [r4, #84]	; 0x54
    8554:	f043 0310 	orr.w	r3, r3, #16
    8558:	6563      	str	r3, [r4, #84]	; 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    855a:	6da3      	ldr	r3, [r4, #88]	; 0x58
    855c:	f043 0301 	orr.w	r3, r3, #1
    8560:	65a3      	str	r3, [r4, #88]	; 0x58
    8562:	e7e2      	b.n	852a <HAL_ADC_Start_DMA+0x6e>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8564:	f44f 530c 	mov.w	r3, #8960	; 0x2300
    8568:	f2c4 0302 	movt	r3, #16386	; 0x4002
    856c:	e7bc      	b.n	84e8 <HAL_ADC_Start_DMA+0x2c>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    856e:	f243 604c 	movw	r0, #13900	; 0x364c
    8572:	f240 71a7 	movw	r1, #1959	; 0x7a7
    8576:	f2c0 0003 	movt	r0, #3
    857a:	f012 fd99 	bl	1b0b0 <assert_failed>
    857e:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    8580:	688b      	ldr	r3, [r1, #8]
    8582:	075b      	lsls	r3, r3, #29
    8584:	d5c6      	bpl.n	8514 <HAL_ADC_Start_DMA+0x58>
    tmp_hal_status = HAL_BUSY;
    8586:	2002      	movs	r0, #2
}
    8588:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    858c:	f44f 5304 	mov.w	r3, #8448	; 0x2100
    8590:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8594:	1ac9      	subs	r1, r1, r3
    8596:	bf18      	it	ne
    8598:	2101      	movne	r1, #1
        ADC_STATE_CLR_SET(hadc->State,
    859a:	f24f 03fe 	movw	r3, #61694	; 0xf0fe
    859e:	6d62      	ldr	r2, [r4, #84]	; 0x54
    85a0:	f6cf 73ff 	movt	r3, #65535	; 0xffff
    85a4:	4013      	ands	r3, r2
    85a6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    85aa:	6563      	str	r3, [r4, #84]	; 0x54
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    85ac:	b105      	cbz	r5, 85b0 <HAL_ADC_Start_DMA+0xf4>
    85ae:	b119      	cbz	r1, 85b8 <HAL_ADC_Start_DMA+0xfc>
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
    85b0:	6d63      	ldr	r3, [r4, #84]	; 0x54
    85b2:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    85b6:	6563      	str	r3, [r4, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
    85b8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    85ba:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    85be:	d03a      	beq.n	8636 <HAL_ADC_Start_DMA+0x17a>
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
    85c0:	6da3      	ldr	r3, [r4, #88]	; 0x58
    85c2:	f023 0306 	bic.w	r3, r3, #6
    85c6:	65a3      	str	r3, [r4, #88]	; 0x58
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    85c8:	f248 67fd 	movw	r7, #34557	; 0x86fd
    85cc:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    85ce:	f248 60ed 	movw	r0, #34541	; 0x86ed
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    85d2:	f248 7165 	movw	r1, #34661	; 0x8765
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    85d6:	f2c0 0700 	movt	r7, #0
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    85da:	4632      	mov	r2, r6
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    85dc:	f2c0 0000 	movt	r0, #0
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    85e0:	f2c0 0100 	movt	r1, #0
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    85e4:	63ef      	str	r7, [r5, #60]	; 0x3c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
    85e6:	261c      	movs	r6, #28
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    85e8:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    85ea:	4643      	mov	r3, r8
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    85ec:	6428      	str	r0, [r5, #64]	; 0x40
        __HAL_UNLOCK(hadc);
    85ee:	2500      	movs	r5, #0
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    85f0:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    85f2:	64c1      	str	r1, [r0, #76]	; 0x4c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
    85f4:	6821      	ldr	r1, [r4, #0]
    85f6:	600e      	str	r6, [r1, #0]
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    85f8:	6820      	ldr	r0, [r4, #0]
        __HAL_UNLOCK(hadc);
    85fa:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    85fe:	6841      	ldr	r1, [r0, #4]
    8600:	f041 0110 	orr.w	r1, r1, #16
    8604:	6041      	str	r1, [r0, #4]
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
    8606:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
    8608:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    860a:	68c1      	ldr	r1, [r0, #12]
    860c:	f021 0103 	bic.w	r1, r1, #3
    8610:	4329      	orrs	r1, r5
    8612:	60c1      	str	r1, [r0, #12]
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    8614:	6821      	ldr	r1, [r4, #0]
    8616:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    8618:	3140      	adds	r1, #64	; 0x40
    861a:	f002 fd5d 	bl	b0d8 <HAL_DMA_Start_IT>
        LL_ADC_REG_StartConversion(hadc->Instance);
    861e:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
    8620:	f64f 73c0 	movw	r3, #65472	; 0xffc0
    8624:	6891      	ldr	r1, [r2, #8]
    8626:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
    862a:	400b      	ands	r3, r1
    862c:	f043 0304 	orr.w	r3, r3, #4
    8630:	6093      	str	r3, [r2, #8]
}
    8632:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          ADC_CLEAR_ERRORCODE(hadc);
    8636:	65a3      	str	r3, [r4, #88]	; 0x58
    8638:	e7c6      	b.n	85c8 <HAL_ADC_Start_DMA+0x10c>
  MODIFY_REG(ADCx->CR,
    863a:	f64f 73c0 	movw	r3, #65472	; 0xffc0
    863e:	688a      	ldr	r2, [r1, #8]
    8640:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
    8644:	4013      	ands	r3, r2
    8646:	f043 0301 	orr.w	r3, r3, #1
    864a:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
    864c:	f7ff fef8 	bl	8440 <HAL_GetTick>
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8650:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    8654:	6823      	ldr	r3, [r4, #0]
    tickstart = HAL_GetTick();
    8656:	4607      	mov	r7, r0
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8658:	f2c4 0202 	movt	r2, #16386	; 0x4002
    865c:	4293      	cmp	r3, r2
    865e:	d028      	beq.n	86b2 <HAL_ADC_Start_DMA+0x1f6>
    8660:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    8664:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8668:	4293      	cmp	r3, r2
    866a:	d022      	beq.n	86b2 <HAL_ADC_Start_DMA+0x1f6>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    866c:	f44f 42c6 	mov.w	r2, #25344	; 0x6300
    8670:	f6c5 0202 	movt	r2, #22530	; 0x5802
    8674:	6892      	ldr	r2, [r2, #8]
  MODIFY_REG(ADCx->CR,
    8676:	f64f 79c0 	movw	r9, #65472	; 0xffc0
    867a:	f6c7 79ff 	movt	r9, #32767	; 0x7fff
    867e:	e00c      	b.n	869a <HAL_ADC_Start_DMA+0x1de>
    8680:	689a      	ldr	r2, [r3, #8]
    8682:	ea02 0209 	and.w	r2, r2, r9
    8686:	f042 0201 	orr.w	r2, r2, #1
    868a:	609a      	str	r2, [r3, #8]
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
    868c:	f7ff fed8 	bl	8440 <HAL_GetTick>
    8690:	1bc0      	subs	r0, r0, r7
    8692:	2802      	cmp	r0, #2
    8694:	f63f af5d 	bhi.w	8552 <HAL_ADC_Start_DMA+0x96>
    8698:	6823      	ldr	r3, [r4, #0]
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
    869a:	681a      	ldr	r2, [r3, #0]
    869c:	07d2      	lsls	r2, r2, #31
    869e:	d41d      	bmi.n	86dc <HAL_ADC_Start_DMA+0x220>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    86a0:	689a      	ldr	r2, [r3, #8]
    86a2:	07d1      	lsls	r1, r2, #31
    86a4:	d5ec      	bpl.n	8680 <HAL_ADC_Start_DMA+0x1c4>
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
    86a6:	f7ff fecb 	bl	8440 <HAL_GetTick>
    86aa:	1bc0      	subs	r0, r0, r7
    86ac:	2802      	cmp	r0, #2
    86ae:	d9f3      	bls.n	8698 <HAL_ADC_Start_DMA+0x1dc>
    86b0:	e74f      	b.n	8552 <HAL_ADC_Start_DMA+0x96>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    86b2:	f44f 510c 	mov.w	r1, #8960	; 0x2300
    if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
    86b6:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    86ba:	f2c4 0102 	movt	r1, #16386	; 0x4002
    86be:	f2c4 0202 	movt	r2, #16386	; 0x4002
    86c2:	6889      	ldr	r1, [r1, #8]
         || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    86c4:	f011 0f1f 	tst.w	r1, #31
    86c8:	bf0c      	ite	eq
    86ca:	2101      	moveq	r1, #1
    86cc:	2100      	movne	r1, #0
    86ce:	4293      	cmp	r3, r2
    86d0:	bf18      	it	ne
    86d2:	f041 0101 	orrne.w	r1, r1, #1
    86d6:	2900      	cmp	r1, #0
    86d8:	d1cd      	bne.n	8676 <HAL_ADC_Start_DMA+0x1ba>
    86da:	e75e      	b.n	859a <HAL_ADC_Start_DMA+0xde>
    86dc:	f44f 5104 	mov.w	r1, #8448	; 0x2100
    86e0:	f2c4 0102 	movt	r1, #16386	; 0x4002
    86e4:	1a59      	subs	r1, r3, r1
    86e6:	bf18      	it	ne
    86e8:	2101      	movne	r1, #1
    86ea:	e756      	b.n	859a <HAL_ADC_Start_DMA+0xde>

000086ec <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
    86ec:	b508      	push	{r3, lr}

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
    86ee:	6b80      	ldr	r0, [r0, #56]	; 0x38
    86f0:	f012 fbe0 	bl	1aeb4 <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
    86f4:	bd08      	pop	{r3, pc}
    86f6:	bf00      	nop

000086f8 <HAL_ADC_ErrorCallback>:
    86f8:	4770      	bx	lr
    86fa:	bf00      	nop

000086fc <ADC_DMAConvCplt>:
{
    86fc:	b510      	push	{r4, lr}
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
    86fe:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
    8700:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8702:	f012 0f50 	tst.w	r2, #80	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
    8706:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
    8708:	d11d      	bne.n	8746 <ADC_DMAConvCplt+0x4a>
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
    870a:	6819      	ldr	r1, [r3, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
    870c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    8710:	655a      	str	r2, [r3, #84]	; 0x54
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
    8712:	680a      	ldr	r2, [r1, #0]
    8714:	f012 0f08 	tst.w	r2, #8
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
    8718:	68ca      	ldr	r2, [r1, #12]
    871a:	d01b      	beq.n	8754 <ADC_DMAConvCplt+0x58>
    871c:	f412 6f40 	tst.w	r2, #3072	; 0xc00
    8720:	d10d      	bne.n	873e <ADC_DMAConvCplt+0x42>
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
    8722:	68ca      	ldr	r2, [r1, #12]
    8724:	0494      	lsls	r4, r2, #18
    8726:	d40a      	bmi.n	873e <ADC_DMAConvCplt+0x42>
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
    8728:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    872a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    872e:	655a      	str	r2, [r3, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
    8730:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8732:	04d1      	lsls	r1, r2, #19
    8734:	d403      	bmi.n	873e <ADC_DMAConvCplt+0x42>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
    8736:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8738:	f042 0201 	orr.w	r2, r2, #1
    873c:	655a      	str	r2, [r3, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
    873e:	4618      	mov	r0, r3
    8740:	f012 fbb6 	bl	1aeb0 <HAL_ADC_ConvCpltCallback>
}
    8744:	bd10      	pop	{r4, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
    8746:	06d2      	lsls	r2, r2, #27
    8748:	d407      	bmi.n	875a <ADC_DMAConvCplt+0x5e>
      hadc->DMA_Handle->XferErrorCallback(hdma);
    874a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
    874c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      hadc->DMA_Handle->XferErrorCallback(hdma);
    8750:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    8752:	4718      	bx	r3
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
    8754:	0790      	lsls	r0, r2, #30
    8756:	d1f2      	bne.n	873e <ADC_DMAConvCplt+0x42>
    8758:	e7e6      	b.n	8728 <ADC_DMAConvCplt+0x2c>
      HAL_ADC_ErrorCallback(hadc);
    875a:	4618      	mov	r0, r3
    875c:	f7ff ffcc 	bl	86f8 <HAL_ADC_ErrorCallback>
}
    8760:	bd10      	pop	{r4, pc}
    8762:	bf00      	nop

00008764 <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
    8764:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
    8766:	6b83      	ldr	r3, [r0, #56]	; 0x38

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
    8768:	6d5a      	ldr	r2, [r3, #84]	; 0x54

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
    876a:	4618      	mov	r0, r3
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
    876c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    8770:	655a      	str	r2, [r3, #84]	; 0x54
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
    8772:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    8774:	f042 0204 	orr.w	r2, r2, #4
    8778:	659a      	str	r2, [r3, #88]	; 0x58
  HAL_ADC_ErrorCallback(hadc);
    877a:	f7ff ffbd 	bl	86f8 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
    877e:	bd08      	pop	{r3, pc}

00008780 <HAL_ADC_ConfigChannel>:
{
    8780:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    8782:	f44f 5204 	mov.w	r2, #8448	; 0x2100
{
    8786:	4605      	mov	r5, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    8788:	f44f 5000 	mov.w	r0, #8192	; 0x2000
{
    878c:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    878e:	682b      	ldr	r3, [r5, #0]
    8790:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8794:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __IO uint32_t wait_loop_index = 0;
    8798:	2600      	movs	r6, #0
{
    879a:	460c      	mov	r4, r1
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    879c:	4283      	cmp	r3, r0
    879e:	bf18      	it	ne
    87a0:	4293      	cmpne	r3, r2
  __IO uint32_t wait_loop_index = 0;
    87a2:	9601      	str	r6, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    87a4:	d006      	beq.n	87b4 <HAL_ADC_ConfigChannel+0x34>
    87a6:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    87aa:	f6c5 0202 	movt	r2, #22530	; 0x5802
    87ae:	4293      	cmp	r3, r2
    87b0:	f040 8234 	bne.w	8c1c <HAL_ADC_ConfigChannel+0x49c>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    87b4:	6862      	ldr	r2, [r4, #4]
    87b6:	f422 7340 	bic.w	r3, r2, #768	; 0x300
    87ba:	f422 7180 	bic.w	r1, r2, #256	; 0x100
    87be:	1f98      	subs	r0, r3, #6
    87c0:	bf18      	it	ne
    87c2:	2001      	movne	r0, #1
    87c4:	2918      	cmp	r1, #24
    87c6:	f240 8147 	bls.w	8a58 <HAL_ADC_ConfigChannel+0x2d8>
    87ca:	2301      	movs	r3, #1
    87cc:	f422 7600 	bic.w	r6, r2, #512	; 0x200
    87d0:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
    87d4:	f5b6 7680 	subs.w	r6, r6, #256	; 0x100
    87d8:	bf18      	it	ne
    87da:	2601      	movne	r6, #1
    87dc:	2918      	cmp	r1, #24
    87de:	f240 8132 	bls.w	8a46 <HAL_ADC_ConfigChannel+0x2c6>
    87e2:	2201      	movs	r2, #1
    87e4:	4003      	ands	r3, r0
    87e6:	421e      	tst	r6, r3
    87e8:	d002      	beq.n	87f0 <HAL_ADC_ConfigChannel+0x70>
    87ea:	2a00      	cmp	r2, #0
    87ec:	f040 846f 	bne.w	90ce <HAL_ADC_ConfigChannel+0x94e>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
    87f0:	68a3      	ldr	r3, [r4, #8]
    87f2:	2b07      	cmp	r3, #7
    87f4:	f200 829f 	bhi.w	8d36 <HAL_ADC_ConfigChannel+0x5b6>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
    87f8:	68e3      	ldr	r3, [r4, #12]
    87fa:	f240 72ff 	movw	r2, #2047	; 0x7ff
    87fe:	4293      	cmp	r3, r2
    8800:	d005      	beq.n	880e <HAL_ADC_ConfigChannel+0x8e>
    8802:	2200      	movs	r2, #0
    8804:	f2c4 72ff 	movt	r2, #18431	; 0x47ff
    8808:	4293      	cmp	r3, r2
    880a:	f040 8145 	bne.w	8a98 <HAL_ADC_ConfigChannel+0x318>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
    880e:	6923      	ldr	r3, [r4, #16]
    8810:	2b04      	cmp	r3, #4
    8812:	f200 814d 	bhi.w	8ab0 <HAL_ADC_ConfigChannel+0x330>
  if (hadc->Init.OversamplingMode == ENABLE)
    8816:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    881a:	6961      	ldr	r1, [r4, #20]
    881c:	2b01      	cmp	r3, #1
    881e:	682a      	ldr	r2, [r5, #0]
    8820:	f000 8155 	beq.w	8ace <HAL_ADC_ConfigChannel+0x34e>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
    8824:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    8828:	f6c5 4300 	movt	r3, #23552	; 0x5c00
    882c:	681b      	ldr	r3, [r3, #0]
    882e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
    8832:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8836:	f040 81e9 	bne.w	8c0c <HAL_ADC_ConfigChannel+0x48c>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
    883a:	68d2      	ldr	r2, [r2, #12]
    883c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8840:	0852      	lsrs	r2, r2, #1
    8842:	f002 020e 	and.w	r2, r2, #14
    8846:	40d3      	lsrs	r3, r2
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
    8848:	4299      	cmp	r1, r3
    884a:	f200 81f0 	bhi.w	8c2e <HAL_ADC_ConfigChannel+0x4ae>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
    884e:	2300      	movs	r3, #0
    8850:	68e2      	ldr	r2, [r4, #12]
    8852:	f2c4 73ff 	movt	r3, #18431	; 0x47ff
    8856:	429a      	cmp	r2, r3
    8858:	f000 8165 	beq.w	8b26 <HAL_ADC_ConfigChannel+0x3a6>
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
    885c:	2302      	movs	r3, #2
    885e:	6822      	ldr	r2, [r4, #0]
    8860:	2604      	movs	r6, #4
    8862:	2108      	movs	r1, #8
    8864:	f2c0 4330 	movt	r3, #1072	; 0x430
    8868:	2010      	movs	r0, #16
    886a:	f6c0 0660 	movt	r6, #2144	; 0x860
    886e:	f6c0 4190 	movt	r1, #3216	; 0xc90
    8872:	2a01      	cmp	r2, #1
    8874:	bf18      	it	ne
    8876:	429a      	cmpne	r2, r3
    8878:	f2c1 00c0 	movt	r0, #4288	; 0x10c0
    887c:	bf14      	ite	ne
    887e:	2301      	movne	r3, #1
    8880:	2300      	moveq	r3, #0
    8882:	42b2      	cmp	r2, r6
    8884:	bf0c      	ite	eq
    8886:	2300      	moveq	r3, #0
    8888:	f003 0301 	andne.w	r3, r3, #1
    888c:	2640      	movs	r6, #64	; 0x40
    888e:	428a      	cmp	r2, r1
    8890:	bf0c      	ite	eq
    8892:	2300      	moveq	r3, #0
    8894:	f003 0301 	andne.w	r3, r3, #1
    8898:	2120      	movs	r1, #32
    889a:	f6c1 1620 	movt	r6, #6432	; 0x1920
    889e:	4282      	cmp	r2, r0
    88a0:	bf0c      	ite	eq
    88a2:	2300      	moveq	r3, #0
    88a4:	f003 0301 	andne.w	r3, r3, #1
    88a8:	f2c1 41f0 	movt	r1, #5360	; 0x14f0
    88ac:	f44f 7080 	mov.w	r0, #256	; 0x100
    88b0:	428a      	cmp	r2, r1
    88b2:	bf0c      	ite	eq
    88b4:	2300      	moveq	r3, #0
    88b6:	f003 0301 	andne.w	r3, r3, #1
    88ba:	2180      	movs	r1, #128	; 0x80
    88bc:	f2c2 1080 	movt	r0, #8576	; 0x2180
    88c0:	42b2      	cmp	r2, r6
    88c2:	bf0c      	ite	eq
    88c4:	2300      	moveq	r3, #0
    88c6:	f003 0301 	andne.w	r3, r3, #1
    88ca:	f6c1 5150 	movt	r1, #7504	; 0x1d50
    88ce:	f44f 6680 	mov.w	r6, #1024	; 0x400
    88d2:	428a      	cmp	r2, r1
    88d4:	bf0c      	ite	eq
    88d6:	2300      	moveq	r3, #0
    88d8:	f003 0301 	andne.w	r3, r3, #1
    88dc:	f44f 7100 	mov.w	r1, #512	; 0x200
    88e0:	f6c2 2600 	movt	r6, #10752	; 0x2a00
    88e4:	4282      	cmp	r2, r0
    88e6:	bf0c      	ite	eq
    88e8:	2300      	moveq	r3, #0
    88ea:	f003 0301 	andne.w	r3, r3, #1
    88ee:	f2c2 51b0 	movt	r1, #9648	; 0x25b0
    88f2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    88f6:	428a      	cmp	r2, r1
    88f8:	bf0c      	ite	eq
    88fa:	2300      	moveq	r3, #0
    88fc:	f003 0301 	andne.w	r3, r3, #1
    8900:	f44f 6100 	mov.w	r1, #2048	; 0x800
    8904:	f2c3 2060 	movt	r0, #12896	; 0x3260
    8908:	42b2      	cmp	r2, r6
    890a:	bf0c      	ite	eq
    890c:	2300      	moveq	r3, #0
    890e:	f003 0301 	andne.w	r3, r3, #1
    8912:	f6c2 6130 	movt	r1, #11824	; 0x2e30
    8916:	f44f 4680 	mov.w	r6, #16384	; 0x4000
    891a:	428a      	cmp	r2, r1
    891c:	bf0c      	ite	eq
    891e:	2300      	moveq	r3, #0
    8920:	f003 0301 	andne.w	r3, r3, #1
    8924:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    8928:	f6c3 26c0 	movt	r6, #15040	; 0x3ac0
    892c:	4282      	cmp	r2, r0
    892e:	bf0c      	ite	eq
    8930:	2300      	moveq	r3, #0
    8932:	f003 0301 	andne.w	r3, r3, #1
    8936:	f2c3 6190 	movt	r1, #13968	; 0x3690
    893a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    893e:	428a      	cmp	r2, r1
    8940:	bf0c      	ite	eq
    8942:	2300      	moveq	r3, #0
    8944:	f003 0301 	andne.w	r3, r3, #1
    8948:	2100      	movs	r1, #0
    894a:	f6c3 60f0 	movt	r0, #16112	; 0x3ef0
    894e:	42b2      	cmp	r2, r6
    8950:	bf0c      	ite	eq
    8952:	2300      	moveq	r3, #0
    8954:	f003 0301 	andne.w	r3, r3, #1
    8958:	f2c4 3121 	movt	r1, #17185	; 0x4321
    895c:	4282      	cmp	r2, r0
    895e:	bf0c      	ite	eq
    8960:	2300      	moveq	r3, #0
    8962:	f003 0301 	andne.w	r3, r3, #1
    8966:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    896a:	2000      	movs	r0, #0
    896c:	428a      	cmp	r2, r1
    896e:	bf0c      	ite	eq
    8970:	2300      	moveq	r3, #0
    8972:	f003 0301 	andne.w	r3, r3, #1
    8976:	4601      	mov	r1, r0
    8978:	f2c4 7052 	movt	r0, #18258	; 0x4752
    897c:	f6c4 3184 	movt	r1, #19332	; 0x4b84
    8980:	4282      	cmp	r2, r0
    8982:	bf0c      	ite	eq
    8984:	2300      	moveq	r3, #0
    8986:	f003 0301 	andne.w	r3, r3, #1
    898a:	428a      	cmp	r2, r1
    898c:	bf0c      	ite	eq
    898e:	2300      	moveq	r3, #0
    8990:	f003 0301 	andne.w	r3, r3, #1
    8994:	2b00      	cmp	r3, #0
    8996:	d171      	bne.n	8a7c <HAL_ADC_ConfigChannel+0x2fc>
  __HAL_LOCK(hadc);
    8998:	f895 3050 	ldrb.w	r3, [r5, #80]	; 0x50
    899c:	2b01      	cmp	r3, #1
    899e:	f000 82c8 	beq.w	8f32 <HAL_ADC_ConfigChannel+0x7b2>
    89a2:	2001      	movs	r0, #1
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
    89a4:	682a      	ldr	r2, [r5, #0]
  __HAL_LOCK(hadc);
    89a6:	f885 0050 	strb.w	r0, [r5, #80]	; 0x50
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    89aa:	6893      	ldr	r3, [r2, #8]
    89ac:	075b      	lsls	r3, r3, #29
    89ae:	d45c      	bmi.n	8a6a <HAL_ADC_ConfigChannel+0x2ea>
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
    89b0:	6823      	ldr	r3, [r4, #0]
    89b2:	f3c3 0113 	ubfx	r1, r3, #0, #20
    89b6:	2900      	cmp	r1, #0
    89b8:	f040 81c8 	bne.w	8d4c <HAL_ADC_ConfigChannel+0x5cc>
    89bc:	f3c3 6384 	ubfx	r3, r3, #26, #5
    89c0:	4098      	lsls	r0, r3
    89c2:	69d3      	ldr	r3, [r2, #28]
  MODIFY_REG(*preg,
    89c4:	271f      	movs	r7, #31
    89c6:	4318      	orrs	r0, r3
    89c8:	61d0      	str	r0, [r2, #28]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
    89ca:	6862      	ldr	r2, [r4, #4]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
    89cc:	6829      	ldr	r1, [r5, #0]
    89ce:	0990      	lsrs	r0, r2, #6
  MODIFY_REG(*preg,
    89d0:	6823      	ldr	r3, [r4, #0]
    89d2:	403a      	ands	r2, r7
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
    89d4:	3130      	adds	r1, #48	; 0x30
    89d6:	f000 000c 	and.w	r0, r0, #12
  MODIFY_REG(*preg,
    89da:	f3c3 6384 	ubfx	r3, r3, #26, #5
    89de:	4097      	lsls	r7, r2
    89e0:	5846      	ldr	r6, [r0, r1]
    89e2:	4093      	lsls	r3, r2
    89e4:	ea26 0207 	bic.w	r2, r6, r7
    89e8:	4313      	orrs	r3, r2
    89ea:	5043      	str	r3, [r0, r1]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
    89ec:	682b      	ldr	r3, [r5, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    89ee:	689a      	ldr	r2, [r3, #8]
    89f0:	0757      	lsls	r7, r2, #29
    89f2:	f100 81a9 	bmi.w	8d48 <HAL_ADC_ConfigChannel+0x5c8>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    89f6:	689e      	ldr	r6, [r3, #8]
    89f8:	f016 0608 	ands.w	r6, r6, #8
    89fc:	f000 8129 	beq.w	8c52 <HAL_ADC_ConfigChannel+0x4d2>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8a00:	689a      	ldr	r2, [r3, #8]
    8a02:	07d6      	lsls	r6, r2, #31
    8a04:	d41d      	bmi.n	8a42 <HAL_ADC_ConfigChannel+0x2c2>
  MODIFY_REG(ADCx->DIFSEL,
    8a06:	68e1      	ldr	r1, [r4, #12]
    8a08:	f64f 72ff 	movw	r2, #65535	; 0xffff
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
    8a0c:	6826      	ldr	r6, [r4, #0]
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
    8a0e:	2000      	movs	r0, #0
    8a10:	f001 0118 	and.w	r1, r1, #24
    8a14:	f2c0 020f 	movt	r2, #15
    8a18:	f3c6 0713 	ubfx	r7, r6, #0, #20
    8a1c:	f2c4 70ff 	movt	r0, #18431	; 0x47ff
    8a20:	40ca      	lsrs	r2, r1
    8a22:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    8a26:	4032      	ands	r2, r6
    8a28:	ea21 0107 	bic.w	r1, r1, r7
    8a2c:	430a      	orrs	r2, r1
    8a2e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    8a32:	68e3      	ldr	r3, [r4, #12]
    8a34:	4283      	cmp	r3, r0
    8a36:	f000 823d 	beq.w	8eb4 <HAL_ADC_ConfigChannel+0x734>
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
    8a3a:	6822      	ldr	r2, [r4, #0]
    8a3c:	2a00      	cmp	r2, #0
    8a3e:	f2c0 81e9 	blt.w	8e14 <HAL_ADC_ConfigChannel+0x694>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8a42:	2000      	movs	r0, #0
    8a44:	e015      	b.n	8a72 <HAL_ADC_ConfigChannel+0x2f2>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    8a46:	f241 0201 	movw	r2, #4097	; 0x1001
    8a4a:	f2c0 1204 	movt	r2, #260	; 0x104
    8a4e:	40ca      	lsrs	r2, r1
    8a50:	43d2      	mvns	r2, r2
    8a52:	f002 0201 	and.w	r2, r2, #1
    8a56:	e6c5      	b.n	87e4 <HAL_ADC_ConfigChannel+0x64>
    8a58:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    8a5c:	f2c0 1304 	movt	r3, #260	; 0x104
    8a60:	40cb      	lsrs	r3, r1
    8a62:	43db      	mvns	r3, r3
    8a64:	f003 0301 	and.w	r3, r3, #1
    8a68:	e6b0      	b.n	87cc <HAL_ADC_ConfigChannel+0x4c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    8a6a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    8a6c:	f043 0320 	orr.w	r3, r3, #32
    8a70:	656b      	str	r3, [r5, #84]	; 0x54
  __HAL_UNLOCK(hadc);
    8a72:	2300      	movs	r3, #0
    8a74:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
}
    8a78:	b003      	add	sp, #12
    8a7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
    8a7c:	2300      	movs	r3, #0
    8a7e:	f6c4 73b8 	movt	r3, #20408	; 0x4fb8
    8a82:	429a      	cmp	r2, r3
    8a84:	d088      	beq.n	8998 <HAL_ADC_ConfigChannel+0x218>
    8a86:	f243 604c 	movw	r0, #13900	; 0x364c
    8a8a:	f640 2174 	movw	r1, #2676	; 0xa74
    8a8e:	f2c0 0003 	movt	r0, #3
    8a92:	f012 fb0d 	bl	1b0b0 <assert_failed>
    8a96:	e77f      	b.n	8998 <HAL_ADC_ConfigChannel+0x218>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
    8a98:	f243 604c 	movw	r0, #13900	; 0x364c
    8a9c:	f640 2161 	movw	r1, #2657	; 0xa61
    8aa0:	f2c0 0003 	movt	r0, #3
    8aa4:	f012 fb04 	bl	1b0b0 <assert_failed>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
    8aa8:	6923      	ldr	r3, [r4, #16]
    8aaa:	2b04      	cmp	r3, #4
    8aac:	f67f aeb3 	bls.w	8816 <HAL_ADC_ConfigChannel+0x96>
    8ab0:	f243 604c 	movw	r0, #13900	; 0x364c
    8ab4:	f640 2162 	movw	r1, #2658	; 0xa62
    8ab8:	f2c0 0003 	movt	r0, #3
    8abc:	f012 faf8 	bl	1b0b0 <assert_failed>
  if (hadc->Init.OversamplingMode == ENABLE)
    8ac0:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    8ac4:	6961      	ldr	r1, [r4, #20]
    8ac6:	2b01      	cmp	r3, #1
    8ac8:	682a      	ldr	r2, [r5, #0]
    8aca:	f47f aeab 	bne.w	8824 <HAL_ADC_ConfigChannel+0xa4>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
    8ace:	f44f 5680 	mov.w	r6, #4096	; 0x1000
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
    8ad2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    8ad4:	f6c5 4600 	movt	r6, #23552	; 0x5c00
    8ad8:	1c58      	adds	r0, r3, #1
    8ada:	6833      	ldr	r3, [r6, #0]
    8adc:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
    8ae0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8ae4:	fbb1 f1f0 	udiv	r1, r1, r0
    8ae8:	f040 8138 	bne.w	8d5c <HAL_ADC_ConfigChannel+0x5dc>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
    8aec:	68d2      	ldr	r2, [r2, #12]
    8aee:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8af2:	0852      	lsrs	r2, r2, #1
    8af4:	f002 020e 	and.w	r2, r2, #14
    8af8:	40d3      	lsrs	r3, r2
    8afa:	4299      	cmp	r1, r3
    8afc:	f200 821c 	bhi.w	8f38 <HAL_ADC_ConfigChannel+0x7b8>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
    8b00:	6923      	ldr	r3, [r4, #16]
    8b02:	2b04      	cmp	r3, #4
    8b04:	f43f aea3 	beq.w	884e <HAL_ADC_ConfigChannel+0xce>
    8b08:	f243 604c 	movw	r0, #13900	; 0x364c
    8b0c:	f640 216f 	movw	r1, #2671	; 0xa6f
    8b10:	f2c0 0003 	movt	r0, #3
    8b14:	f012 facc 	bl	1b0b0 <assert_failed>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
    8b18:	2300      	movs	r3, #0
    8b1a:	68e2      	ldr	r2, [r4, #12]
    8b1c:	f2c4 73ff 	movt	r3, #18431	; 0x47ff
    8b20:	429a      	cmp	r2, r3
    8b22:	f47f ae9b 	bne.w	885c <HAL_ADC_ConfigChannel+0xdc>
    if (hadc->Instance == ADC1)
    8b26:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    8b2a:	682b      	ldr	r3, [r5, #0]
    8b2c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b30:	4293      	cmp	r3, r2
    8b32:	f000 820a 	beq.w	8f4a <HAL_ADC_ConfigChannel+0x7ca>
    if (hadc->Instance == ADC2)
    8b36:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    8b3a:	f2c4 0202 	movt	r2, #16386	; 0x4002
    8b3e:	4293      	cmp	r3, r2
    8b40:	f000 8114 	beq.w	8d6c <HAL_ADC_ConfigChannel+0x5ec>
    if (hadc->Instance == ADC3)
    8b44:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    8b48:	f6c5 0202 	movt	r2, #22530	; 0x5802
    8b4c:	4293      	cmp	r3, r2
    8b4e:	f47f af23 	bne.w	8998 <HAL_ADC_ConfigChannel+0x218>
      assert_param(IS_ADC3_DIFF_CHANNEL(sConfig->Channel));
    8b52:	2302      	movs	r3, #2
    8b54:	2104      	movs	r1, #4
    8b56:	6822      	ldr	r2, [r4, #0]
    8b58:	2008      	movs	r0, #8
    8b5a:	f2c0 4330 	movt	r3, #1072	; 0x430
    8b5e:	f6c0 0160 	movt	r1, #2144	; 0x860
    8b62:	f6c0 4090 	movt	r0, #3216	; 0xc90
    8b66:	2620      	movs	r6, #32
    8b68:	429a      	cmp	r2, r3
    8b6a:	bf18      	it	ne
    8b6c:	428a      	cmpne	r2, r1
    8b6e:	f04f 0110 	mov.w	r1, #16
    8b72:	f2c1 46f0 	movt	r6, #5360	; 0x14f0
    8b76:	bf14      	ite	ne
    8b78:	2301      	movne	r3, #1
    8b7a:	2300      	moveq	r3, #0
    8b7c:	f2c1 01c0 	movt	r1, #4288	; 0x10c0
    8b80:	4282      	cmp	r2, r0
    8b82:	bf0c      	ite	eq
    8b84:	2300      	moveq	r3, #0
    8b86:	f003 0301 	andne.w	r3, r3, #1
    8b8a:	f44f 6080 	mov.w	r0, #1024	; 0x400
    8b8e:	428a      	cmp	r2, r1
    8b90:	bf0c      	ite	eq
    8b92:	2300      	moveq	r3, #0
    8b94:	f003 0301 	andne.w	r3, r3, #1
    8b98:	f6c2 2000 	movt	r0, #10752	; 0x2a00
    8b9c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    8ba0:	42b2      	cmp	r2, r6
    8ba2:	bf0c      	ite	eq
    8ba4:	2300      	moveq	r3, #0
    8ba6:	f003 0301 	andne.w	r3, r3, #1
    8baa:	f6c2 6130 	movt	r1, #11824	; 0x2e30
    8bae:	4282      	cmp	r2, r0
    8bb0:	bf0c      	ite	eq
    8bb2:	2300      	moveq	r3, #0
    8bb4:	f003 0301 	andne.w	r3, r3, #1
    8bb8:	f44f 5000 	mov.w	r0, #8192	; 0x2000
    8bbc:	428a      	cmp	r2, r1
    8bbe:	bf0c      	ite	eq
    8bc0:	2300      	moveq	r3, #0
    8bc2:	f003 0301 	andne.w	r3, r3, #1
    8bc6:	f2c3 6090 	movt	r0, #13968	; 0x3690
    8bca:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    8bce:	4282      	cmp	r2, r0
    8bd0:	bf0c      	ite	eq
    8bd2:	2300      	moveq	r3, #0
    8bd4:	f003 0301 	andne.w	r3, r3, #1
    8bd8:	f6c3 21c0 	movt	r1, #15040	; 0x3ac0
    8bdc:	428a      	cmp	r2, r1
    8bde:	bf0c      	ite	eq
    8be0:	2300      	moveq	r3, #0
    8be2:	f003 0301 	andne.w	r3, r3, #1
    8be6:	2b00      	cmp	r3, #0
    8be8:	f43f aed6 	beq.w	8998 <HAL_ADC_ConfigChannel+0x218>
    8bec:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    8bf0:	f6c3 63f0 	movt	r3, #16112	; 0x3ef0
    8bf4:	429a      	cmp	r2, r3
    8bf6:	f43f aecf 	beq.w	8998 <HAL_ADC_ConfigChannel+0x218>
    8bfa:	f243 604c 	movw	r0, #13900	; 0x364c
    8bfe:	f640 2184 	movw	r1, #2692	; 0xa84
    8c02:	f2c0 0003 	movt	r0, #3
    8c06:	f012 fa53 	bl	1b0b0 <assert_failed>
    8c0a:	e6c5      	b.n	8998 <HAL_ADC_ConfigChannel+0x218>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
    8c0c:	68d3      	ldr	r3, [r2, #12]
    8c0e:	f003 031c 	and.w	r3, r3, #28
    8c12:	2b1c      	cmp	r3, #28
    8c14:	f47f ae11 	bne.w	883a <HAL_ADC_ConfigChannel+0xba>
    8c18:	23ff      	movs	r3, #255	; 0xff
    8c1a:	e615      	b.n	8848 <HAL_ADC_ConfigChannel+0xc8>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    8c1c:	f243 604c 	movw	r0, #13900	; 0x364c
    8c20:	f640 215e 	movw	r1, #2654	; 0xa5e
    8c24:	f2c0 0003 	movt	r0, #3
    8c28:	f012 fa42 	bl	1b0b0 <assert_failed>
    8c2c:	e5c2      	b.n	87b4 <HAL_ADC_ConfigChannel+0x34>
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
    8c2e:	f243 604c 	movw	r0, #13900	; 0x364c
    8c32:	f640 216a 	movw	r1, #2666	; 0xa6a
    8c36:	f2c0 0003 	movt	r0, #3
    8c3a:	f012 fa39 	bl	1b0b0 <assert_failed>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
    8c3e:	6923      	ldr	r3, [r4, #16]
    8c40:	2b04      	cmp	r3, #4
    8c42:	f43f ae04 	beq.w	884e <HAL_ADC_ConfigChannel+0xce>
    8c46:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    8c4a:	2b01      	cmp	r3, #1
    8c4c:	f47f adff 	bne.w	884e <HAL_ADC_ConfigChannel+0xce>
    8c50:	e75a      	b.n	8b08 <HAL_ADC_ConfigChannel+0x388>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
    8c52:	6821      	ldr	r1, [r4, #0]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8c54:	3314      	adds	r3, #20
  MODIFY_REG(*preg,
    8c56:	2207      	movs	r2, #7
    8c58:	68a7      	ldr	r7, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8c5a:	0dc8      	lsrs	r0, r1, #23
  MODIFY_REG(*preg,
    8c5c:	f3c1 5104 	ubfx	r1, r1, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8c60:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
    8c64:	fa02 fc01 	lsl.w	ip, r2, r1
    8c68:	fa07 f101 	lsl.w	r1, r7, r1
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8c6c:	f44f 5780 	mov.w	r7, #4096	; 0x1000
    8c70:	58c2      	ldr	r2, [r0, r3]
    8c72:	f6c5 4700 	movt	r7, #23552	; 0x5c00
    8c76:	ea22 020c 	bic.w	r2, r2, ip
    8c7a:	430a      	orrs	r2, r1
    8c7c:	50c2      	str	r2, [r0, r3]
    8c7e:	683b      	ldr	r3, [r7, #0]
    8c80:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
    8c84:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8c88:	f000 810b 	beq.w	8ea2 <HAL_ADC_ConfigChannel+0x722>
    8c8c:	682b      	ldr	r3, [r5, #0]
    8c8e:	6962      	ldr	r2, [r4, #20]
    8c90:	68d9      	ldr	r1, [r3, #12]
    8c92:	f011 0f10 	tst.w	r1, #16
    8c96:	68d9      	ldr	r1, [r3, #12]
    8c98:	f040 81cf 	bne.w	903a <HAL_ADC_ConfigChannel+0x8ba>
    8c9c:	f3c1 0182 	ubfx	r1, r1, #2, #3
    8ca0:	0049      	lsls	r1, r1, #1
    8ca2:	fa02 f101 	lsl.w	r1, r2, r1
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
    8ca6:	6920      	ldr	r0, [r4, #16]
    8ca8:	6822      	ldr	r2, [r4, #0]
    8caa:	2804      	cmp	r0, #4
    8cac:	f000 81a9 	beq.w	9002 <HAL_ADC_ConfigChannel+0x882>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
    8cb0:	3360      	adds	r3, #96	; 0x60
  MODIFY_REG(*preg,
    8cb2:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
    8cb6:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
    8cba:	430a      	orrs	r2, r1
    8cbc:	f007 4100 	and.w	r1, r7, #2147483648	; 0x80000000
    8cc0:	430a      	orrs	r2, r1
    8cc2:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
    8cc6:	7e63      	ldrb	r3, [r4, #25]
    8cc8:	2b01      	cmp	r3, #1
    8cca:	d908      	bls.n	8cde <HAL_ADC_ConfigChannel+0x55e>
    8ccc:	f243 604c 	movw	r0, #13900	; 0x364c
    8cd0:	f640 21b2 	movw	r1, #2738	; 0xab2
    8cd4:	f2c0 0003 	movt	r0, #3
    8cd8:	f012 f9ea 	bl	1b0b0 <assert_failed>
    8cdc:	7e63      	ldrb	r3, [r4, #25]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
    8cde:	682a      	ldr	r2, [r5, #0]
    8ce0:	2b01      	cmp	r3, #1
    8ce2:	6921      	ldr	r1, [r4, #16]
   register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
    8ce4:	f102 0260 	add.w	r2, r2, #96	; 0x60
    8ce8:	bf14      	ite	ne
    8cea:	2000      	movne	r0, #0
    8cec:	f04f 4000 	moveq.w	r0, #2147483648	; 0x80000000
   MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
    8cf0:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    8cf4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    8cf8:	4303      	orrs	r3, r0
    8cfa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
    8cfe:	7e23      	ldrb	r3, [r4, #24]
    8d00:	2b01      	cmp	r3, #1
    8d02:	d908      	bls.n	8d16 <HAL_ADC_ConfigChannel+0x596>
    8d04:	f243 604c 	movw	r0, #13900	; 0x364c
    8d08:	f640 21b6 	movw	r1, #2742	; 0xab6
    8d0c:	f2c0 0003 	movt	r0, #3
    8d10:	f012 f9ce 	bl	1b0b0 <assert_failed>
    8d14:	7e23      	ldrb	r3, [r4, #24]
        LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
    8d16:	2b01      	cmp	r3, #1
    8d18:	682a      	ldr	r2, [r5, #0]
    8d1a:	6921      	ldr	r1, [r4, #16]
    8d1c:	d104      	bne.n	8d28 <HAL_ADC_ConfigChannel+0x5a8>
    8d1e:	f001 011f 	and.w	r1, r1, #31
    8d22:	f44f 6600 	mov.w	r6, #2048	; 0x800
    8d26:	408e      	lsls	r6, r1
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
    8d28:	6913      	ldr	r3, [r2, #16]
    8d2a:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    8d2e:	431e      	orrs	r6, r3
    8d30:	6116      	str	r6, [r2, #16]
    8d32:	682b      	ldr	r3, [r5, #0]
    8d34:	e664      	b.n	8a00 <HAL_ADC_ConfigChannel+0x280>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
    8d36:	f243 604c 	movw	r0, #13900	; 0x364c
    8d3a:	f44f 6126 	mov.w	r1, #2656	; 0xa60
    8d3e:	f2c0 0003 	movt	r0, #3
    8d42:	f012 f9b5 	bl	1b0b0 <assert_failed>
    8d46:	e557      	b.n	87f8 <HAL_ADC_ConfigChannel+0x78>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    8d48:	689a      	ldr	r2, [r3, #8]
    8d4a:	e659      	b.n	8a00 <HAL_ADC_ConfigChannel+0x280>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    8d4c:	fa93 f3a3 	rbit	r3, r3
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
    8d50:	fab3 f383 	clz	r3, r3
    8d54:	f003 031f 	and.w	r3, r3, #31
    8d58:	4098      	lsls	r0, r3
    8d5a:	e632      	b.n	89c2 <HAL_ADC_ConfigChannel+0x242>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
    8d5c:	68d3      	ldr	r3, [r2, #12]
    8d5e:	f003 031c 	and.w	r3, r3, #28
    8d62:	2b1c      	cmp	r3, #28
    8d64:	f47f aec2 	bne.w	8aec <HAL_ADC_ConfigChannel+0x36c>
    8d68:	23ff      	movs	r3, #255	; 0xff
    8d6a:	e6c6      	b.n	8afa <HAL_ADC_ConfigChannel+0x37a>
      assert_param(IS_ADC2_DIFF_CHANNEL(sConfig->Channel));
    8d6c:	2302      	movs	r3, #2
    8d6e:	2104      	movs	r1, #4
    8d70:	6822      	ldr	r2, [r4, #0]
    8d72:	2008      	movs	r0, #8
    8d74:	f2c0 4330 	movt	r3, #1072	; 0x430
    8d78:	f6c0 0160 	movt	r1, #2144	; 0x860
    8d7c:	f6c0 4090 	movt	r0, #3216	; 0xc90
    8d80:	2620      	movs	r6, #32
    8d82:	429a      	cmp	r2, r3
    8d84:	bf18      	it	ne
    8d86:	428a      	cmpne	r2, r1
    8d88:	f04f 0110 	mov.w	r1, #16
    8d8c:	f2c1 46f0 	movt	r6, #5360	; 0x14f0
    8d90:	bf14      	ite	ne
    8d92:	2301      	movne	r3, #1
    8d94:	2300      	moveq	r3, #0
    8d96:	f2c1 01c0 	movt	r1, #4288	; 0x10c0
    8d9a:	4282      	cmp	r2, r0
    8d9c:	bf0c      	ite	eq
    8d9e:	2300      	moveq	r3, #0
    8da0:	f003 0301 	andne.w	r3, r3, #1
    8da4:	f44f 6000 	mov.w	r0, #2048	; 0x800
    8da8:	428a      	cmp	r2, r1
    8daa:	bf0c      	ite	eq
    8dac:	2300      	moveq	r3, #0
    8dae:	f003 0301 	andne.w	r3, r3, #1
    8db2:	f44f 6180 	mov.w	r1, #1024	; 0x400
    8db6:	f6c2 6030 	movt	r0, #11824	; 0x2e30
    8dba:	f6c2 2100 	movt	r1, #10752	; 0x2a00
    8dbe:	42b2      	cmp	r2, r6
    8dc0:	bf0c      	ite	eq
    8dc2:	2300      	moveq	r3, #0
    8dc4:	f003 0301 	andne.w	r3, r3, #1
    8dc8:	428a      	cmp	r2, r1
    8dca:	bf0c      	ite	eq
    8dcc:	2300      	moveq	r3, #0
    8dce:	f003 0301 	andne.w	r3, r3, #1
    8dd2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    8dd6:	4282      	cmp	r2, r0
    8dd8:	bf0c      	ite	eq
    8dda:	2300      	moveq	r3, #0
    8ddc:	f003 0301 	andne.w	r3, r3, #1
    8de0:	f2c3 2160 	movt	r1, #12896	; 0x3260
    8de4:	428a      	cmp	r2, r1
    8de6:	bf0c      	ite	eq
    8de8:	2300      	moveq	r3, #0
    8dea:	f003 0301 	andne.w	r3, r3, #1
    8dee:	2b00      	cmp	r3, #0
    8df0:	f43f add2 	beq.w	8998 <HAL_ADC_ConfigChannel+0x218>
    8df4:	2300      	movs	r3, #0
    8df6:	f6c4 3384 	movt	r3, #19332	; 0x4b84
    8dfa:	429a      	cmp	r2, r3
    8dfc:	f43f adcc 	beq.w	8998 <HAL_ADC_ConfigChannel+0x218>
    8e00:	f243 604c 	movw	r0, #13900	; 0x364c
    8e04:	f640 217e 	movw	r1, #2686	; 0xa7e
    8e08:	f2c0 0003 	movt	r0, #3
    8e0c:	f012 f950 	bl	1b0b0 <assert_failed>
    8e10:	682b      	ldr	r3, [r5, #0]
    8e12:	e697      	b.n	8b44 <HAL_ADC_ConfigChannel+0x3c4>
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8e14:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    8e18:	6828      	ldr	r0, [r5, #0]
    8e1a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8e1e:	4298      	cmp	r0, r3
    8e20:	f000 813e 	beq.w	90a0 <HAL_ADC_ConfigChannel+0x920>
    8e24:	f44f 5304 	mov.w	r3, #8448	; 0x2100
    8e28:	f2c4 0302 	movt	r3, #16386	; 0x4002
    8e2c:	4298      	cmp	r0, r3
    8e2e:	f000 8137 	beq.w	90a0 <HAL_ADC_ConfigChannel+0x920>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8e32:	f44f 43c6 	mov.w	r3, #25344	; 0x6300
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8e36:	f44f 46c0 	mov.w	r6, #24576	; 0x6000
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8e3a:	f6c5 0302 	movt	r3, #22530	; 0x5802
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8e3e:	f6c5 0602 	movt	r6, #22530	; 0x5802
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8e42:	689c      	ldr	r4, [r3, #8]
    8e44:	4619      	mov	r1, r3
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8e46:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8e48:	f004 76e0 	and.w	r6, r4, #29360128	; 0x1c00000
    8e4c:	43db      	mvns	r3, r3
    8e4e:	f003 0301 	and.w	r3, r3, #1
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    8e52:	2b00      	cmp	r3, #0
    8e54:	f000 8145 	beq.w	90e2 <HAL_ADC_ConfigChannel+0x962>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
    8e58:	2300      	movs	r3, #0
    8e5a:	f6cc 3384 	movt	r3, #52100	; 0xcb84
    8e5e:	429a      	cmp	r2, r3
    8e60:	f000 8162 	beq.w	9128 <HAL_ADC_ConfigChannel+0x9a8>
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
    8e64:	2300      	movs	r3, #0
    8e66:	f2cc 7352 	movt	r3, #51026	; 0xc752
    8e6a:	429a      	cmp	r2, r3
    8e6c:	f000 8187 	beq.w	917e <HAL_ADC_ConfigChannel+0x9fe>
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
    8e70:	2300      	movs	r3, #0
    8e72:	f6cc 73b8 	movt	r3, #53176	; 0xcfb8
    8e76:	429a      	cmp	r2, r3
    8e78:	f47f ade3 	bne.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
            if (ADC_VREFINT_INSTANCE(hadc))
    8e7c:	0263      	lsls	r3, r4, #9
    8e7e:	f53f ade0 	bmi.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
    8e82:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    8e86:	f6c5 0302 	movt	r3, #22530	; 0x5802
    8e8a:	4298      	cmp	r0, r3
    8e8c:	f47f add9 	bne.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
    8e90:	688a      	ldr	r2, [r1, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
    8e92:	f446 0380 	orr.w	r3, r6, #4194304	; 0x400000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8e96:	2000      	movs	r0, #0
    8e98:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
    8e9c:	4313      	orrs	r3, r2
    8e9e:	608b      	str	r3, [r1, #8]
    8ea0:	e5e7      	b.n	8a72 <HAL_ADC_ConfigChannel+0x2f2>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8ea2:	682b      	ldr	r3, [r5, #0]
    8ea4:	6962      	ldr	r2, [r4, #20]
    8ea6:	68d9      	ldr	r1, [r3, #12]
    8ea8:	f3c1 0182 	ubfx	r1, r1, #2, #3
    8eac:	0049      	lsls	r1, r1, #1
    8eae:	fa02 f101 	lsl.w	r1, r2, r1
    8eb2:	e6f8      	b.n	8ca6 <HAL_ADC_ConfigChannel+0x526>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8eb4:	6822      	ldr	r2, [r4, #0]
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8eb6:	6829      	ldr	r1, [r5, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8eb8:	f3c2 0313 	ubfx	r3, r2, #0, #20
    8ebc:	2b00      	cmp	r3, #0
    8ebe:	f000 80c2 	beq.w	9046 <HAL_ADC_ConfigChannel+0x8c6>
    8ec2:	fa92 f3a2 	rbit	r3, r2
    8ec6:	fab3 f383 	clz	r3, r3
    8eca:	3301      	adds	r3, #1
    8ecc:	f003 031f 	and.w	r3, r3, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8ed0:	2b09      	cmp	r3, #9
    8ed2:	f200 810c 	bhi.w	90ee <HAL_ADC_ConfigChannel+0x96e>
    8ed6:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8eda:	fab3 f383 	clz	r3, r3
    8ede:	fa92 f0a2 	rbit	r0, r2
    8ee2:	2601      	movs	r6, #1
    8ee4:	fab0 f080 	clz	r0, r0
    8ee8:	3301      	adds	r3, #1
    8eea:	4430      	add	r0, r6
    8eec:	069b      	lsls	r3, r3, #26
    8eee:	f000 001f 	and.w	r0, r0, #31
    8ef2:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
    8ef6:	fa06 f000 	lsl.w	r0, r6, r0
    8efa:	4303      	orrs	r3, r0
    8efc:	fa92 f2a2 	rbit	r2, r2
    8f00:	fab2 f282 	clz	r2, r2
    8f04:	4432      	add	r2, r6
    8f06:	f002 021f 	and.w	r2, r2, #31
    8f0a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8f0e:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8f10:	431a      	orrs	r2, r3
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8f12:	3114      	adds	r1, #20
  MODIFY_REG(*preg,
    8f14:	2707      	movs	r7, #7
    8f16:	68a3      	ldr	r3, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8f18:	0dd6      	lsrs	r6, r2, #23
  MODIFY_REG(*preg,
    8f1a:	f3c2 5204 	ubfx	r2, r2, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8f1e:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
    8f22:	4097      	lsls	r7, r2
    8f24:	4093      	lsls	r3, r2
    8f26:	5870      	ldr	r0, [r6, r1]
    8f28:	ea20 0207 	bic.w	r2, r0, r7
    8f2c:	431a      	orrs	r2, r3
    8f2e:	5072      	str	r2, [r6, r1]
    8f30:	e583      	b.n	8a3a <HAL_ADC_ConfigChannel+0x2ba>
  __HAL_LOCK(hadc);
    8f32:	2002      	movs	r0, #2
}
    8f34:	b003      	add	sp, #12
    8f36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
    8f38:	f243 604c 	movw	r0, #13900	; 0x364c
    8f3c:	f640 2166 	movw	r1, #2662	; 0xa66
    8f40:	f2c0 0003 	movt	r0, #3
    8f44:	f012 f8b4 	bl	1b0b0 <assert_failed>
    8f48:	e679      	b.n	8c3e <HAL_ADC_ConfigChannel+0x4be>
      assert_param(IS_ADC1_DIFF_CHANNEL(sConfig->Channel));
    8f4a:	2302      	movs	r3, #2
    8f4c:	2104      	movs	r1, #4
    8f4e:	6822      	ldr	r2, [r4, #0]
    8f50:	2008      	movs	r0, #8
    8f52:	f2c0 4330 	movt	r3, #1072	; 0x430
    8f56:	f6c0 0160 	movt	r1, #2144	; 0x860
    8f5a:	f6c0 4090 	movt	r0, #3216	; 0xc90
    8f5e:	2620      	movs	r6, #32
    8f60:	429a      	cmp	r2, r3
    8f62:	bf18      	it	ne
    8f64:	428a      	cmpne	r2, r1
    8f66:	f04f 0110 	mov.w	r1, #16
    8f6a:	f2c1 46f0 	movt	r6, #5360	; 0x14f0
    8f6e:	bf14      	ite	ne
    8f70:	2301      	movne	r3, #1
    8f72:	2300      	moveq	r3, #0
    8f74:	f2c1 01c0 	movt	r1, #4288	; 0x10c0
    8f78:	4282      	cmp	r2, r0
    8f7a:	bf0c      	ite	eq
    8f7c:	2300      	moveq	r3, #0
    8f7e:	f003 0301 	andne.w	r3, r3, #1
    8f82:	f44f 6080 	mov.w	r0, #1024	; 0x400
    8f86:	428a      	cmp	r2, r1
    8f88:	bf0c      	ite	eq
    8f8a:	2300      	moveq	r3, #0
    8f8c:	f003 0301 	andne.w	r3, r3, #1
    8f90:	f6c2 2000 	movt	r0, #10752	; 0x2a00
    8f94:	f44f 6100 	mov.w	r1, #2048	; 0x800
    8f98:	42b2      	cmp	r2, r6
    8f9a:	bf0c      	ite	eq
    8f9c:	2300      	moveq	r3, #0
    8f9e:	f003 0301 	andne.w	r3, r3, #1
    8fa2:	f6c2 6130 	movt	r1, #11824	; 0x2e30
    8fa6:	4282      	cmp	r2, r0
    8fa8:	bf0c      	ite	eq
    8faa:	2300      	moveq	r3, #0
    8fac:	f003 0301 	andne.w	r3, r3, #1
    8fb0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    8fb4:	428a      	cmp	r2, r1
    8fb6:	bf0c      	ite	eq
    8fb8:	2300      	moveq	r3, #0
    8fba:	f003 0301 	andne.w	r3, r3, #1
    8fbe:	f2c3 2060 	movt	r0, #12896	; 0x3260
    8fc2:	2100      	movs	r1, #0
    8fc4:	4282      	cmp	r2, r0
    8fc6:	bf0c      	ite	eq
    8fc8:	2300      	moveq	r3, #0
    8fca:	f003 0301 	andne.w	r3, r3, #1
    8fce:	f2c4 3121 	movt	r1, #17185	; 0x4321
    8fd2:	428a      	cmp	r2, r1
    8fd4:	bf0c      	ite	eq
    8fd6:	2300      	moveq	r3, #0
    8fd8:	f003 0301 	andne.w	r3, r3, #1
    8fdc:	2b00      	cmp	r3, #0
    8fde:	f43f acdb 	beq.w	8998 <HAL_ADC_ConfigChannel+0x218>
    8fe2:	2300      	movs	r3, #0
    8fe4:	f6c4 3384 	movt	r3, #19332	; 0x4b84
    8fe8:	429a      	cmp	r2, r3
    8fea:	f43f acd5 	beq.w	8998 <HAL_ADC_ConfigChannel+0x218>
    8fee:	f243 604c 	movw	r0, #13900	; 0x364c
    8ff2:	f640 217a 	movw	r1, #2682	; 0xa7a
    8ff6:	f2c0 0003 	movt	r0, #3
    8ffa:	f012 f859 	bl	1b0b0 <assert_failed>
    8ffe:	682b      	ldr	r3, [r5, #0]
    9000:	e599      	b.n	8b36 <HAL_ADC_ConfigChannel+0x3b6>
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    9002:	6e19      	ldr	r1, [r3, #96]	; 0x60
    9004:	0692      	lsls	r2, r2, #26
    9006:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    900a:	4291      	cmp	r1, r2
    900c:	d040      	beq.n	9090 <HAL_ADC_ConfigChannel+0x910>
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    900e:	6e59      	ldr	r1, [r3, #100]	; 0x64
    9010:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    9014:	4291      	cmp	r1, r2
    9016:	d033      	beq.n	9080 <HAL_ADC_ConfigChannel+0x900>
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    9018:	6e99      	ldr	r1, [r3, #104]	; 0x68
    901a:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    901e:	4291      	cmp	r1, r2
    9020:	d026      	beq.n	9070 <HAL_ADC_ConfigChannel+0x8f0>
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    9022:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
    9024:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    9028:	4291      	cmp	r1, r2
    902a:	f47f ace9 	bne.w	8a00 <HAL_ADC_ConfigChannel+0x280>
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
    902e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    9030:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    9034:	66da      	str	r2, [r3, #108]	; 0x6c
    9036:	682b      	ldr	r3, [r5, #0]
    9038:	e4e2      	b.n	8a00 <HAL_ADC_ConfigChannel+0x280>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    903a:	0849      	lsrs	r1, r1, #1
    903c:	f001 0108 	and.w	r1, r1, #8
    9040:	fa02 f101 	lsl.w	r1, r2, r1
    9044:	e62f      	b.n	8ca6 <HAL_ADC_ConfigChannel+0x526>
    9046:	2601      	movs	r6, #1
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    9048:	0e92      	lsrs	r2, r2, #26
    904a:	4432      	add	r2, r6
    904c:	f002 001f 	and.w	r0, r2, #31
    9050:	0693      	lsls	r3, r2, #26
    9052:	4086      	lsls	r6, r0
    9054:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    9058:	2809      	cmp	r0, #9
    905a:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    905e:	ea43 0306 	orr.w	r3, r3, r6
    9062:	f67f af54 	bls.w	8f0e <HAL_ADC_ConfigChannel+0x78e>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    9066:	3a1e      	subs	r2, #30
    9068:	0512      	lsls	r2, r2, #20
    906a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    906e:	e74f      	b.n	8f10 <HAL_ADC_ConfigChannel+0x790>
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
    9070:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    9072:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    9076:	669a      	str	r2, [r3, #104]	; 0x68
    9078:	6822      	ldr	r2, [r4, #0]
    907a:	682b      	ldr	r3, [r5, #0]
    907c:	0692      	lsls	r2, r2, #26
    907e:	e7d0      	b.n	9022 <HAL_ADC_ConfigChannel+0x8a2>
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
    9080:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    9082:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    9086:	665a      	str	r2, [r3, #100]	; 0x64
    9088:	6822      	ldr	r2, [r4, #0]
    908a:	682b      	ldr	r3, [r5, #0]
    908c:	0692      	lsls	r2, r2, #26
    908e:	e7c3      	b.n	9018 <HAL_ADC_ConfigChannel+0x898>
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
    9090:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    9092:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    9096:	661a      	str	r2, [r3, #96]	; 0x60
    9098:	6822      	ldr	r2, [r4, #0]
    909a:	682b      	ldr	r3, [r5, #0]
    909c:	0692      	lsls	r2, r2, #26
    909e:	e7b6      	b.n	900e <HAL_ADC_ConfigChannel+0x88e>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    90a0:	f44f 530c 	mov.w	r3, #8960	; 0x2300
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    90a4:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    90a8:	f44f 5604 	mov.w	r6, #8448	; 0x2100
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    90ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    90b0:	f2c4 0702 	movt	r7, #16386	; 0x4002
    90b4:	f2c4 0602 	movt	r6, #16386	; 0x4002
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    90b8:	689c      	ldr	r4, [r3, #8]
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    90ba:	4619      	mov	r1, r3
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    90bc:	68bf      	ldr	r7, [r7, #8]
    90be:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    90c0:	f004 76e0 	and.w	r6, r4, #29360128	; 0x1c00000
    90c4:	433b      	orrs	r3, r7
    90c6:	43db      	mvns	r3, r3
    90c8:	f003 0301 	and.w	r3, r3, #1
    90cc:	e6c1      	b.n	8e52 <HAL_ADC_ConfigChannel+0x6d2>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    90ce:	f243 604c 	movw	r0, #13900	; 0x364c
    90d2:	f640 215f 	movw	r1, #2655	; 0xa5f
    90d6:	f2c0 0003 	movt	r0, #3
    90da:	f011 ffe9 	bl	1b0b0 <assert_failed>
    90de:	f7ff bb87 	b.w	87f0 <HAL_ADC_ConfigChannel+0x70>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    90e2:	6d6b      	ldr	r3, [r5, #84]	; 0x54
          tmp_hal_status = HAL_ERROR;
    90e4:	2001      	movs	r0, #1
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    90e6:	f043 0320 	orr.w	r3, r3, #32
    90ea:	656b      	str	r3, [r5, #84]	; 0x54
    90ec:	e4c1      	b.n	8a72 <HAL_ADC_ConfigChannel+0x2f2>
    90ee:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    90f2:	fab3 f383 	clz	r3, r3
    90f6:	fa92 f0a2 	rbit	r0, r2
    90fa:	2601      	movs	r6, #1
    90fc:	fab0 f080 	clz	r0, r0
    9100:	3301      	adds	r3, #1
    9102:	4430      	add	r0, r6
    9104:	069b      	lsls	r3, r3, #26
    9106:	f000 001f 	and.w	r0, r0, #31
    910a:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
    910e:	fa06 f000 	lsl.w	r0, r6, r0
    9112:	4303      	orrs	r3, r0
    9114:	fa92 f2a2 	rbit	r2, r2
    9118:	fab2 f282 	clz	r2, r2
    911c:	4432      	add	r2, r6
    911e:	f002 021f 	and.w	r2, r2, #31
    9122:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    9126:	e79e      	b.n	9066 <HAL_ADC_ConfigChannel+0x8e6>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
    9128:	0224      	lsls	r4, r4, #8
    912a:	f53f ac8a 	bmi.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
    912e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    9132:	f6c5 0302 	movt	r3, #22530	; 0x5802
    9136:	4298      	cmp	r0, r3
    9138:	f47f ac83 	bne.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    913c:	f246 23b4 	movw	r3, #25268	; 0x62b4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
    9140:	6888      	ldr	r0, [r1, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
    9142:	f446 0200 	orr.w	r2, r6, #8388608	; 0x800000
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    9146:	f642 5463 	movw	r4, #11619	; 0x2d63
    914a:	f2c0 0306 	movt	r3, #6
    914e:	f020 70e0 	bic.w	r0, r0, #29360128	; 0x1c00000
    9152:	f2c0 543e 	movt	r4, #1342	; 0x53e
    9156:	681b      	ldr	r3, [r3, #0]
    9158:	4302      	orrs	r2, r0
    915a:	099b      	lsrs	r3, r3, #6
    915c:	608a      	str	r2, [r1, #8]
    915e:	fba4 2303 	umull	r2, r3, r4, r3
    9162:	099b      	lsrs	r3, r3, #6
    9164:	005b      	lsls	r3, r3, #1
    9166:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
    9168:	9b01      	ldr	r3, [sp, #4]
    916a:	2b00      	cmp	r3, #0
    916c:	f43f ac69 	beq.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
                wait_loop_index--;
    9170:	9b01      	ldr	r3, [sp, #4]
    9172:	3b01      	subs	r3, #1
    9174:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
    9176:	9b01      	ldr	r3, [sp, #4]
    9178:	2b00      	cmp	r3, #0
    917a:	d1f9      	bne.n	9170 <HAL_ADC_ConfigChannel+0x9f0>
    917c:	e461      	b.n	8a42 <HAL_ADC_ConfigChannel+0x2c2>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
    917e:	01e2      	lsls	r2, r4, #7
    9180:	f53f ac5f 	bmi.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
    9184:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    9188:	f6c5 0302 	movt	r3, #22530	; 0x5802
    918c:	4298      	cmp	r0, r3
    918e:	f47f ac58 	bne.w	8a42 <HAL_ADC_ConfigChannel+0x2c2>
    9192:	688a      	ldr	r2, [r1, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
    9194:	f046 7380 	orr.w	r3, r6, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9198:	2000      	movs	r0, #0
    919a:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
    919e:	4313      	orrs	r3, r2
    91a0:	608b      	str	r3, [r1, #8]
    91a2:	e466      	b.n	8a72 <HAL_ADC_ConfigChannel+0x2f2>

000091a4 <ADC_Disable>:
{
    91a4:	b538      	push	{r3, r4, r5, lr}
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
    91a6:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
    91a8:	6899      	ldr	r1, [r3, #8]
    91aa:	0789      	lsls	r1, r1, #30
    91ac:	d502      	bpl.n	91b4 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    91ae:	689b      	ldr	r3, [r3, #8]
  return HAL_OK;
    91b0:	2000      	movs	r0, #0
}
    91b2:	bd38      	pop	{r3, r4, r5, pc}
    91b4:	6899      	ldr	r1, [r3, #8]
    91b6:	07ca      	lsls	r2, r1, #31
    91b8:	d527      	bpl.n	920a <ADC_Disable+0x66>
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
    91ba:	6899      	ldr	r1, [r3, #8]
    91bc:	4604      	mov	r4, r0
    91be:	f001 010d 	and.w	r1, r1, #13
    91c2:	2901      	cmp	r1, #1
    91c4:	d008      	beq.n	91d8 <ADC_Disable+0x34>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    91c6:	6d63      	ldr	r3, [r4, #84]	; 0x54
        return HAL_ERROR;
    91c8:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    91ca:	f043 0310 	orr.w	r3, r3, #16
    91ce:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    91d0:	6da3      	ldr	r3, [r4, #88]	; 0x58
    91d2:	4303      	orrs	r3, r0
    91d4:	65a3      	str	r3, [r4, #88]	; 0x58
}
    91d6:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
    91d8:	f64f 72c0 	movw	r2, #65472	; 0xffc0
    91dc:	6898      	ldr	r0, [r3, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
    91de:	2103      	movs	r1, #3
    91e0:	f6c7 72ff 	movt	r2, #32767	; 0x7fff
    91e4:	4002      	ands	r2, r0
    91e6:	f042 0202 	orr.w	r2, r2, #2
    91ea:	609a      	str	r2, [r3, #8]
    91ec:	6823      	ldr	r3, [r4, #0]
    91ee:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
    91f0:	f7ff f926 	bl	8440 <HAL_GetTick>
    91f4:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
    91f6:	e004      	b.n	9202 <ADC_Disable+0x5e>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
    91f8:	f7ff f922 	bl	8440 <HAL_GetTick>
    91fc:	1b40      	subs	r0, r0, r5
    91fe:	2802      	cmp	r0, #2
    9200:	d8e1      	bhi.n	91c6 <ADC_Disable+0x22>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
    9202:	6823      	ldr	r3, [r4, #0]
    9204:	689b      	ldr	r3, [r3, #8]
    9206:	07db      	lsls	r3, r3, #31
    9208:	d4f6      	bmi.n	91f8 <ADC_Disable+0x54>
  return HAL_OK;
    920a:	2000      	movs	r0, #0
}
    920c:	bd38      	pop	{r3, r4, r5, pc}
    920e:	bf00      	nop

00009210 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef* hadc)
{
    9210:	b538      	push	{r3, r4, r5, lr}
  uint32_t freq;
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    9212:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    9216:	6802      	ldr	r2, [r0, #0]
{
    9218:	4605      	mov	r5, r0
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    921a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    921e:	429a      	cmp	r2, r3
    9220:	d030      	beq.n	9284 <ADC_ConfigureBoostMode+0x74>
    9222:	f44f 5304 	mov.w	r3, #8448	; 0x2100
    9226:	f2c4 0302 	movt	r3, #16386	; 0x4002
    922a:	429a      	cmp	r2, r3
    922c:	d02a      	beq.n	9284 <ADC_ConfigureBoostMode+0x74>
    922e:	f44f 43c6 	mov.w	r3, #25344	; 0x6300
    9232:	f6c5 0302 	movt	r3, #22530	; 0x5802
    9236:	689b      	ldr	r3, [r3, #8]
    9238:	f413 3f40 	tst.w	r3, #196608	; 0x30000
    923c:	bf14      	ite	ne
    923e:	2301      	movne	r3, #1
    9240:	2300      	moveq	r3, #0
    9242:	b35b      	cbz	r3, 929c <ADC_ConfigureBoostMode+0x8c>
  {
    freq = HAL_RCC_GetHCLKFreq();
    9244:	f006 fc98 	bl	fb78 <HAL_RCC_GetHCLKFreq>
    switch(hadc->Init.ClockPrescaler)
    9248:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCC_GetHCLKFreq();
    924a:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
    924c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    9250:	d072      	beq.n	9338 <ADC_ConfigureBoostMode+0x128>
    9252:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
    9256:	f000 8082 	beq.w	935e <ADC_ConfigureBoostMode+0x14e>
    925a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    925e:	d06b      	beq.n	9338 <ADC_ConfigureBoostMode+0x128>
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
    9260:	f7ff f908 	bl	8474 <HAL_GetREVID>
    9264:	f241 0303 	movw	r3, #4099	; 0x1003
    9268:	4298      	cmp	r0, r3
    926a:	d838      	bhi.n	92de <ADC_ConfigureBoostMode+0xce>
  {
    if(freq > 20000000UL)
    926c:	f44f 5234 	mov.w	r2, #11520	; 0x2d00
    9270:	682b      	ldr	r3, [r5, #0]
    9272:	f2c0 1231 	movt	r2, #305	; 0x131
    9276:	4294      	cmp	r4, r2
    9278:	d92b      	bls.n	92d2 <ADC_ConfigureBoostMode+0xc2>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
    927a:	689a      	ldr	r2, [r3, #8]
    927c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    9280:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
    9282:	bd38      	pop	{r3, r4, r5, pc}
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    9284:	f44f 530c 	mov.w	r3, #8960	; 0x2300
    9288:	f2c4 0302 	movt	r3, #16386	; 0x4002
    928c:	689b      	ldr	r3, [r3, #8]
    928e:	f413 3f40 	tst.w	r3, #196608	; 0x30000
    9292:	bf14      	ite	ne
    9294:	2301      	movne	r3, #1
    9296:	2300      	moveq	r3, #0
    9298:	2b00      	cmp	r3, #0
    929a:	d1d3      	bne.n	9244 <ADC_ConfigureBoostMode+0x34>
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    929c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    92a0:	f008 f838 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
    switch(hadc->Init.ClockPrescaler)
    92a4:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    92a6:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
    92a8:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
    92ac:	d052      	beq.n	9354 <ADC_ConfigureBoostMode+0x144>
    92ae:	d947      	bls.n	9340 <ADC_ConfigureBoostMode+0x130>
    92b0:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
    92b4:	d057      	beq.n	9366 <ADC_ConfigureBoostMode+0x156>
    92b6:	d930      	bls.n	931a <ADC_ConfigureBoostMode+0x10a>
    92b8:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
    92bc:	d051      	beq.n	9362 <ADC_ConfigureBoostMode+0x152>
    92be:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
    92c2:	d1cd      	bne.n	9260 <ADC_ConfigureBoostMode+0x50>
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
    92c4:	f7ff f8d6 	bl	8474 <HAL_GetREVID>
    92c8:	f241 0303 	movw	r3, #4099	; 0x1003
    92cc:	4298      	cmp	r0, r3
    92ce:	d805      	bhi.n	92dc <ADC_ConfigureBoostMode+0xcc>
    92d0:	682b      	ldr	r3, [r5, #0]
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
    92d2:	689a      	ldr	r2, [r3, #8]
    92d4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    92d8:	609a      	str	r2, [r3, #8]
}
    92da:	bd38      	pop	{r3, r4, r5, pc}
        freq /= 256UL;
    92dc:	0a24      	lsrs	r4, r4, #8
    if (freq <= 6250000UL)
    92de:	f645 6310 	movw	r3, #24080	; 0x5e10
    freq /= 2U; /* divider by 2 for Rev.V */
    92e2:	0864      	lsrs	r4, r4, #1
    92e4:	682a      	ldr	r2, [r5, #0]
    if (freq <= 6250000UL)
    92e6:	f2c0 035f 	movt	r3, #95	; 0x5f
    92ea:	429c      	cmp	r4, r3
    92ec:	d910      	bls.n	9310 <ADC_ConfigureBoostMode+0x100>
    else if(freq <= 12500000UL)
    92ee:	f64b 4320 	movw	r3, #48160	; 0xbc20
    92f2:	f2c0 03be 	movt	r3, #190	; 0xbe
    92f6:	429c      	cmp	r4, r3
    92f8:	d917      	bls.n	932a <ADC_ConfigureBoostMode+0x11a>
    else if(freq <= 25000000UL)
    92fa:	f647 0340 	movw	r3, #30784	; 0x7840
    92fe:	f2c0 137d 	movt	r3, #381	; 0x17d
    9302:	429c      	cmp	r4, r3
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
    9304:	6893      	ldr	r3, [r2, #8]
    else if(freq <= 25000000UL)
    9306:	d932      	bls.n	936e <ADC_ConfigureBoostMode+0x15e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    9308:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    930c:	6093      	str	r3, [r2, #8]
}
    930e:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
    9310:	6893      	ldr	r3, [r2, #8]
    9312:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    9316:	6093      	str	r3, [r2, #8]
}
    9318:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
    931a:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
    931e:	d024      	beq.n	936a <ADC_ConfigureBoostMode+0x15a>
    9320:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
    9324:	d19c      	bne.n	9260 <ADC_ConfigureBoostMode+0x50>
        freq /= 32UL;
    9326:	0944      	lsrs	r4, r0, #5
        break;
    9328:	e79a      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
    932a:	6893      	ldr	r3, [r2, #8]
    932c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    9330:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    9334:	6093      	str	r3, [r2, #8]
}
    9336:	bd38      	pop	{r3, r4, r5, pc}
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
    9338:	0c1b      	lsrs	r3, r3, #16
    933a:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
    933e:	e78f      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
    switch(hadc->Init.ClockPrescaler)
    9340:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
    9344:	d006      	beq.n	9354 <ADC_ConfigureBoostMode+0x144>
    9346:	d818      	bhi.n	937a <ADC_ConfigureBoostMode+0x16a>
    9348:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    934c:	d002      	beq.n	9354 <ADC_ConfigureBoostMode+0x144>
    934e:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
    9352:	d185      	bne.n	9260 <ADC_ConfigureBoostMode+0x50>
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
    9354:	0c9b      	lsrs	r3, r3, #18
    9356:	005b      	lsls	r3, r3, #1
    9358:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
    935c:	e780      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
        freq /= 4UL;
    935e:	0884      	lsrs	r4, r0, #2
        break;
    9360:	e77e      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
        freq /= 128UL;
    9362:	09c4      	lsrs	r4, r0, #7
        break;
    9364:	e77c      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
        freq /= 64UL;
    9366:	0984      	lsrs	r4, r0, #6
        break;
    9368:	e77a      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
        freq /= 16UL;
    936a:	0904      	lsrs	r4, r0, #4
      break;
    936c:	e778      	b.n	9260 <ADC_ConfigureBoostMode+0x50>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
    936e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    9372:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    9376:	6093      	str	r3, [r2, #8]
}
    9378:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
    937a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    937e:	d0e9      	beq.n	9354 <ADC_ConfigureBoostMode+0x144>
    9380:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
    9384:	f47f af6c 	bne.w	9260 <ADC_ConfigureBoostMode+0x50>
    9388:	e7e4      	b.n	9354 <ADC_ConfigureBoostMode+0x144>
    938a:	bf00      	nop

0000938c <HAL_ADC_Init>:
{
    938c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0UL;
    938e:	2300      	movs	r3, #0
{
    9390:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
    9392:	9301      	str	r3, [sp, #4]
  if (hadc == NULL)
    9394:	2800      	cmp	r0, #0
    9396:	f000 81d7 	beq.w	9748 <HAL_ADC_Init+0x3bc>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    939a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    939e:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    93a2:	6803      	ldr	r3, [r0, #0]
    93a4:	4604      	mov	r4, r0
    93a6:	f2c4 0102 	movt	r1, #16386	; 0x4002
    93aa:	f2c4 0202 	movt	r2, #16386	; 0x4002
    93ae:	428b      	cmp	r3, r1
    93b0:	bf18      	it	ne
    93b2:	4293      	cmpne	r3, r2
    93b4:	d006      	beq.n	93c4 <HAL_ADC_Init+0x38>
    93b6:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    93ba:	f6c5 0202 	movt	r2, #22530	; 0x5802
    93be:	4293      	cmp	r3, r2
    93c0:	f040 81d6 	bne.w	9770 <HAL_ADC_Init+0x3e4>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    93c4:	6862      	ldr	r2, [r4, #4]
    93c6:	f422 2300 	bic.w	r3, r2, #524288	; 0x80000
    93ca:	f422 3540 	bic.w	r5, r2, #196608	; 0x30000
    93ce:	f422 1080 	bic.w	r0, r2, #1048576	; 0x100000
    93d2:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
    93d6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    93da:	bf18      	it	ne
    93dc:	2d00      	cmpne	r5, #0
    93de:	bf14      	ite	ne
    93e0:	2301      	movne	r3, #1
    93e2:	2300      	moveq	r3, #0
    93e4:	f5b2 1fe0 	cmp.w	r2, #1835008	; 0x1c0000
    93e8:	bf0c      	ite	eq
    93ea:	2300      	moveq	r3, #0
    93ec:	f003 0301 	andne.w	r3, r3, #1
    93f0:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
    93f4:	bf0c      	ite	eq
    93f6:	2300      	moveq	r3, #0
    93f8:	f003 0301 	andne.w	r3, r3, #1
    93fc:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    9400:	bf0c      	ite	eq
    9402:	2300      	moveq	r3, #0
    9404:	f003 0301 	andne.w	r3, r3, #1
    9408:	b12b      	cbz	r3, 9416 <HAL_ADC_Init+0x8a>
    940a:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
    940e:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    9412:	f040 8221 	bne.w	9858 <HAL_ADC_Init+0x4cc>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    9416:	68a2      	ldr	r2, [r4, #8]
    9418:	2a10      	cmp	r2, #16
    941a:	f200 81a0 	bhi.w	975e <HAL_ADC_Init+0x3d2>
    941e:	f241 1311 	movw	r3, #4369	; 0x1111
    9422:	f2c0 0301 	movt	r3, #1
    9426:	40d3      	lsrs	r3, r2
    9428:	07de      	lsls	r6, r3, #31
    942a:	f140 8198 	bpl.w	975e <HAL_ADC_Init+0x3d2>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    942e:	68e3      	ldr	r3, [r4, #12]
    9430:	2b01      	cmp	r3, #1
    9432:	f200 80ff 	bhi.w	9634 <HAL_ADC_Init+0x2a8>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9436:	7d63      	ldrb	r3, [r4, #21]
    9438:	2b01      	cmp	r3, #1
    943a:	f200 80e5 	bhi.w	9608 <HAL_ADC_Init+0x27c>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    943e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9440:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    9444:	f040 80ed 	bne.w	9622 <HAL_ADC_Init+0x296>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    9448:	6a62      	ldr	r2, [r4, #36]	; 0x24
    944a:	f5b2 6fd0 	cmp.w	r2, #1664	; 0x680
    944e:	bf18      	it	ne
    9450:	f5b2 6fb8 	cmpne.w	r2, #1472	; 0x5c0
    9454:	f022 0040 	bic.w	r0, r2, #64	; 0x40
    9458:	f022 0180 	bic.w	r1, r2, #128	; 0x80
    945c:	f422 7590 	bic.w	r5, r2, #288	; 0x120
    9460:	bf14      	ite	ne
    9462:	2301      	movne	r3, #1
    9464:	2300      	moveq	r3, #0
    9466:	f5b0 6f84 	cmp.w	r0, #1056	; 0x420
    946a:	bf0c      	ite	eq
    946c:	2300      	moveq	r3, #0
    946e:	f003 0301 	andne.w	r3, r3, #1
    9472:	f422 7080 	bic.w	r0, r2, #256	; 0x100
    9476:	f5b1 6f88 	cmp.w	r1, #1088	; 0x440
    947a:	bf0c      	ite	eq
    947c:	2300      	moveq	r3, #0
    947e:	f003 0301 	andne.w	r3, r3, #1
    9482:	f022 0160 	bic.w	r1, r2, #96	; 0x60
    9486:	f5b5 6f90 	cmp.w	r5, #1152	; 0x480
    948a:	bf0c      	ite	eq
    948c:	2300      	moveq	r3, #0
    948e:	f003 0301 	andne.w	r3, r3, #1
    9492:	f5b0 6f9c 	cmp.w	r0, #1248	; 0x4e0
    9496:	bf0c      	ite	eq
    9498:	2300      	moveq	r3, #0
    949a:	f003 0301 	andne.w	r3, r3, #1
    949e:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    94a2:	bf0c      	ite	eq
    94a4:	2300      	moveq	r3, #0
    94a6:	f003 0301 	andne.w	r3, r3, #1
    94aa:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    94ae:	bf0c      	ite	eq
    94b0:	2300      	moveq	r3, #0
    94b2:	f003 0301 	andne.w	r3, r3, #1
    94b6:	b11b      	cbz	r3, 94c0 <HAL_ADC_Init+0x134>
    94b8:	f432 6380 	bics.w	r3, r2, #1024	; 0x400
    94bc:	f040 81d5 	bne.w	986a <HAL_ADC_Init+0x4de>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
    94c0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    94c2:	2b03      	cmp	r3, #3
    94c4:	f200 8194 	bhi.w	97f0 <HAL_ADC_Init+0x464>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
    94c8:	6923      	ldr	r3, [r4, #16]
    94ca:	2b04      	cmp	r3, #4
    94cc:	d009      	beq.n	94e2 <HAL_ADC_Init+0x156>
    94ce:	2b08      	cmp	r3, #8
    94d0:	d007      	beq.n	94e2 <HAL_ADC_Init+0x156>
    94d2:	f243 604c 	movw	r0, #13900	; 0x364c
    94d6:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
    94da:	f2c0 0003 	movt	r0, #3
    94de:	f011 fde7 	bl	1b0b0 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
    94e2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    94e4:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
    94e8:	f040 80b1 	bne.w	964e <HAL_ADC_Init+0x2c2>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    94ec:	7d23      	ldrb	r3, [r4, #20]
    94ee:	2b01      	cmp	r3, #1
    94f0:	d87c      	bhi.n	95ec <HAL_ADC_Init+0x260>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    94f2:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    94f6:	2b01      	cmp	r3, #1
    94f8:	d86c      	bhi.n	95d4 <HAL_ADC_Init+0x248>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    94fa:	68e3      	ldr	r3, [r4, #12]
    94fc:	2b00      	cmp	r3, #0
    94fe:	d14d      	bne.n	959c <HAL_ADC_Init+0x210>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
    9500:	7f23      	ldrb	r3, [r4, #28]
    9502:	2b01      	cmp	r3, #1
    9504:	d05a      	beq.n	95bc <HAL_ADC_Init+0x230>
  if (hadc->State == HAL_ADC_STATE_RESET)
    9506:	6d65      	ldr	r5, [r4, #84]	; 0x54
    9508:	2d00      	cmp	r5, #0
    950a:	f000 8121 	beq.w	9750 <HAL_ADC_Init+0x3c4>
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
    950e:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
    9510:	689a      	ldr	r2, [r3, #8]
    9512:	0095      	lsls	r5, r2, #2
    9514:	d507      	bpl.n	9526 <HAL_ADC_Init+0x19a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
    9516:	f64f 72c0 	movw	r2, #65472	; 0xffc0
    951a:	6899      	ldr	r1, [r3, #8]
    951c:	f6c5 72ff 	movt	r2, #24575	; 0x5fff
    9520:	400a      	ands	r2, r1
    9522:	609a      	str	r2, [r3, #8]
    9524:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
    9526:	689a      	ldr	r2, [r3, #8]
    9528:	00d0      	lsls	r0, r2, #3
    952a:	d41f      	bmi.n	956c <HAL_ADC_Init+0x1e0>
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    952c:	f246 20b4 	movw	r0, #25268	; 0x62b4
    9530:	f642 5563 	movw	r5, #11619	; 0x2d63
  MODIFY_REG(ADCx->CR,
    9534:	f64f 71c0 	movw	r1, #65472	; 0xffc0
    9538:	689e      	ldr	r6, [r3, #8]
    953a:	f2c0 0006 	movt	r0, #6
    953e:	f2c0 553e 	movt	r5, #1342	; 0x53e
    9542:	f6c6 71ff 	movt	r1, #28671	; 0x6fff
    9546:	6802      	ldr	r2, [r0, #0]
    9548:	4031      	ands	r1, r6
    954a:	0992      	lsrs	r2, r2, #6
    954c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
    9550:	fba5 0202 	umull	r0, r2, r5, r2
    9554:	6099      	str	r1, [r3, #8]
    9556:	0992      	lsrs	r2, r2, #6
    9558:	9201      	str	r2, [sp, #4]
    while (wait_loop_index != 0UL)
    955a:	9b01      	ldr	r3, [sp, #4]
    955c:	b12b      	cbz	r3, 956a <HAL_ADC_Init+0x1de>
      wait_loop_index--;
    955e:	9b01      	ldr	r3, [sp, #4]
    9560:	3b01      	subs	r3, #1
    9562:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
    9564:	9b01      	ldr	r3, [sp, #4]
    9566:	2b00      	cmp	r3, #0
    9568:	d1f9      	bne.n	955e <HAL_ADC_Init+0x1d2>
    956a:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
    956c:	689a      	ldr	r2, [r3, #8]
    956e:	00d1      	lsls	r1, r2, #3
    9570:	f100 80e8 	bmi.w	9744 <HAL_ADC_Init+0x3b8>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9574:	6d62      	ldr	r2, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    9576:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9578:	f042 0210 	orr.w	r2, r2, #16
    957c:	6562      	str	r2, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    957e:	6da2      	ldr	r2, [r4, #88]	; 0x58
    9580:	432a      	orrs	r2, r5
    9582:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    9584:	689a      	ldr	r2, [r3, #8]
    9586:	0752      	lsls	r2, r2, #29
    9588:	d56e      	bpl.n	9668 <HAL_ADC_Init+0x2dc>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
    958a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    958c:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    958e:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9590:	f043 0310 	orr.w	r3, r3, #16
}
    9594:	4628      	mov	r0, r5
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9596:	6563      	str	r3, [r4, #84]	; 0x54
}
    9598:	b003      	add	sp, #12
    959a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    959c:	69a3      	ldr	r3, [r4, #24]
    959e:	3b01      	subs	r3, #1
    95a0:	2b0f      	cmp	r3, #15
    95a2:	f200 811c 	bhi.w	97de <HAL_ADC_Init+0x452>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    95a6:	7f23      	ldrb	r3, [r4, #28]
    95a8:	2b01      	cmp	r3, #1
    95aa:	f200 80ea 	bhi.w	9782 <HAL_ADC_Init+0x3f6>
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    95ae:	2b01      	cmp	r3, #1
    95b0:	d1a9      	bne.n	9506 <HAL_ADC_Init+0x17a>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    95b2:	6a23      	ldr	r3, [r4, #32]
    95b4:	3b01      	subs	r3, #1
    95b6:	2b07      	cmp	r3, #7
    95b8:	f200 8132 	bhi.w	9820 <HAL_ADC_Init+0x494>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
    95bc:	7d63      	ldrb	r3, [r4, #21]
    95be:	2b01      	cmp	r3, #1
    95c0:	d1a1      	bne.n	9506 <HAL_ADC_Init+0x17a>
    95c2:	f243 604c 	movw	r0, #13900	; 0x364c
    95c6:	f240 11bf 	movw	r1, #447	; 0x1bf
    95ca:	f2c0 0003 	movt	r0, #3
    95ce:	f011 fd6f 	bl	1b0b0 <assert_failed>
    95d2:	e798      	b.n	9506 <HAL_ADC_Init+0x17a>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    95d4:	f243 604c 	movw	r0, #13900	; 0x364c
    95d8:	f240 11b1 	movw	r1, #433	; 0x1b1
    95dc:	f2c0 0003 	movt	r0, #3
    95e0:	f011 fd66 	bl	1b0b0 <assert_failed>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    95e4:	68e3      	ldr	r3, [r4, #12]
    95e6:	2b00      	cmp	r3, #0
    95e8:	d08a      	beq.n	9500 <HAL_ADC_Init+0x174>
    95ea:	e7d7      	b.n	959c <HAL_ADC_Init+0x210>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    95ec:	f243 604c 	movw	r0, #13900	; 0x364c
    95f0:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
    95f4:	f2c0 0003 	movt	r0, #3
    95f8:	f011 fd5a 	bl	1b0b0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    95fc:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    9600:	2b01      	cmp	r3, #1
    9602:	f67f af7a 	bls.w	94fa <HAL_ADC_Init+0x16e>
    9606:	e7e5      	b.n	95d4 <HAL_ADC_Init+0x248>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9608:	f243 604c 	movw	r0, #13900	; 0x364c
    960c:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
    9610:	f2c0 0003 	movt	r0, #3
    9614:	f011 fd4c 	bl	1b0b0 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    9618:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    961a:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    961e:	f43f af13 	beq.w	9448 <HAL_ADC_Init+0xbc>
    9622:	f243 604c 	movw	r0, #13900	; 0x364c
    9626:	f240 11ab 	movw	r1, #427	; 0x1ab
    962a:	f2c0 0003 	movt	r0, #3
    962e:	f011 fd3f 	bl	1b0b0 <assert_failed>
    9632:	e709      	b.n	9448 <HAL_ADC_Init+0xbc>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    9634:	f243 604c 	movw	r0, #13900	; 0x364c
    9638:	f240 11a9 	movw	r1, #425	; 0x1a9
    963c:	f2c0 0003 	movt	r0, #3
    9640:	f011 fd36 	bl	1b0b0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9644:	7d63      	ldrb	r3, [r4, #21]
    9646:	2b01      	cmp	r3, #1
    9648:	f67f aef9 	bls.w	943e <HAL_ADC_Init+0xb2>
    964c:	e7dc      	b.n	9608 <HAL_ADC_Init+0x27c>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
    964e:	f243 604c 	movw	r0, #13900	; 0x364c
    9652:	f240 11af 	movw	r1, #431	; 0x1af
    9656:	f2c0 0003 	movt	r0, #3
    965a:	f011 fd29 	bl	1b0b0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    965e:	7d23      	ldrb	r3, [r4, #20]
    9660:	2b01      	cmp	r3, #1
    9662:	f67f af46 	bls.w	94f2 <HAL_ADC_Init+0x166>
    9666:	e7c1      	b.n	95ec <HAL_ADC_Init+0x260>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
    9668:	6d62      	ldr	r2, [r4, #84]	; 0x54
    966a:	06d7      	lsls	r7, r2, #27
    966c:	d48e      	bmi.n	958c <HAL_ADC_Init+0x200>
    ADC_STATE_CLR_SET(hadc->State,
    966e:	6d62      	ldr	r2, [r4, #84]	; 0x54
    9670:	f422 7281 	bic.w	r2, r2, #258	; 0x102
    9674:	f042 0202 	orr.w	r2, r2, #2
    9678:	6562      	str	r2, [r4, #84]	; 0x54
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    967a:	689a      	ldr	r2, [r3, #8]
    967c:	07d6      	lsls	r6, r2, #31
    967e:	d41e      	bmi.n	96be <HAL_ADC_Init+0x332>
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    9680:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    9684:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9688:	4293      	cmp	r3, r2
    968a:	f000 80d2 	beq.w	9832 <HAL_ADC_Init+0x4a6>
    968e:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    9692:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9696:	4293      	cmp	r3, r2
    9698:	f000 80cb 	beq.w	9832 <HAL_ADC_Init+0x4a6>
    969c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    96a0:	f6c5 0302 	movt	r3, #22530	; 0x5802
    96a4:	689b      	ldr	r3, [r3, #8]
    96a6:	07d9      	lsls	r1, r3, #31
    96a8:	d409      	bmi.n	96be <HAL_ADC_Init+0x332>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
    96aa:	f44f 42c6 	mov.w	r2, #25344	; 0x6300
    96ae:	f6c5 0202 	movt	r2, #22530	; 0x5802
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
    96b2:	6893      	ldr	r3, [r2, #8]
    96b4:	6861      	ldr	r1, [r4, #4]
    96b6:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
    96ba:	430b      	orrs	r3, r1
    96bc:	6093      	str	r3, [r2, #8]
    if((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
    96be:	f7fe fed9 	bl	8474 <HAL_GetREVID>
    96c2:	f241 0303 	movw	r3, #4099	; 0x1003
    96c6:	4298      	cmp	r0, r3
    96c8:	f240 809b 	bls.w	9802 <HAL_ADC_Init+0x476>
    96cc:	68a2      	ldr	r2, [r4, #8]
    96ce:	7d61      	ldrb	r1, [r4, #21]
    96d0:	7f20      	ldrb	r0, [r4, #28]
    96d2:	2a10      	cmp	r2, #16
    96d4:	ea4f 3141 	mov.w	r1, r1, lsl #13
    96d8:	6b26      	ldr	r6, [r4, #48]	; 0x30
    96da:	ea4f 4300 	mov.w	r3, r0, lsl #16
    96de:	f000 810d 	beq.w	98fc <HAL_ADC_Init+0x570>
                  hadc->Init.Overrun                                                    |
    96e2:	430a      	orrs	r2, r1
    96e4:	4332      	orrs	r2, r6
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
    96e6:	431a      	orrs	r2, r3
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    96e8:	2801      	cmp	r0, #1
    96ea:	d103      	bne.n	96f4 <HAL_ADC_Init+0x368>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
    96ec:	6a23      	ldr	r3, [r4, #32]
    96ee:	3b01      	subs	r3, #1
    96f0:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
    96f4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    96f6:	b123      	cbz	r3, 9702 <HAL_ADC_Init+0x376>
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
    96f8:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
    96fc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    96fe:	430b      	orrs	r3, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
    9700:	431a      	orrs	r2, r3
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
    9702:	6821      	ldr	r1, [r4, #0]
    9704:	f24c 0303 	movw	r3, #49155	; 0xc003
    9708:	68c8      	ldr	r0, [r1, #12]
    970a:	f6cf 73f0 	movt	r3, #65520	; 0xfff0
    970e:	4003      	ands	r3, r0
    9710:	4313      	orrs	r3, r2
    9712:	60cb      	str	r3, [r1, #12]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
    9714:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    9716:	689a      	ldr	r2, [r3, #8]
    9718:	f012 0f04 	tst.w	r2, #4
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    971c:	689a      	ldr	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    971e:	d101      	bne.n	9724 <HAL_ADC_Init+0x398>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    9720:	0712      	lsls	r2, r2, #28
    9722:	d53b      	bpl.n	979c <HAL_ADC_Init+0x410>
    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
    9724:	68e2      	ldr	r2, [r4, #12]
    9726:	2a01      	cmp	r2, #1
    9728:	d072      	beq.n	9810 <HAL_ADC_Init+0x484>
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
    972a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    972c:	f022 020f 	bic.w	r2, r2, #15
    9730:	631a      	str	r2, [r3, #48]	; 0x30
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
    9732:	6d63      	ldr	r3, [r4, #84]	; 0x54
}
    9734:	4628      	mov	r0, r5
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
    9736:	f023 0303 	bic.w	r3, r3, #3
    973a:	f043 0301 	orr.w	r3, r3, #1
    973e:	6563      	str	r3, [r4, #84]	; 0x54
}
    9740:	b003      	add	sp, #12
    9742:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9744:	2500      	movs	r5, #0
    9746:	e71d      	b.n	9584 <HAL_ADC_Init+0x1f8>
    return HAL_ERROR;
    9748:	2501      	movs	r5, #1
}
    974a:	4628      	mov	r0, r5
    974c:	b003      	add	sp, #12
    974e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
    9750:	4620      	mov	r0, r4
    9752:	f00e fd53 	bl	181fc <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
    9756:	65a5      	str	r5, [r4, #88]	; 0x58
    hadc->Lock = HAL_UNLOCKED;
    9758:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    975c:	e6d7      	b.n	950e <HAL_ADC_Init+0x182>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    975e:	f243 604c 	movw	r0, #13900	; 0x364c
    9762:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
    9766:	f2c0 0003 	movt	r0, #3
    976a:	f011 fca1 	bl	1b0b0 <assert_failed>
    976e:	e65e      	b.n	942e <HAL_ADC_Init+0xa2>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9770:	f243 604c 	movw	r0, #13900	; 0x364c
    9774:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
    9778:	f2c0 0003 	movt	r0, #3
    977c:	f011 fc98 	bl	1b0b0 <assert_failed>
    9780:	e620      	b.n	93c4 <HAL_ADC_Init+0x38>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    9782:	f243 604c 	movw	r0, #13900	; 0x364c
    9786:	f44f 71db 	mov.w	r1, #438	; 0x1b6
    978a:	f2c0 0003 	movt	r0, #3
    978e:	f011 fc8f 	bl	1b0b0 <assert_failed>
    9792:	7f23      	ldrb	r3, [r4, #28]
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    9794:	2b01      	cmp	r3, #1
    9796:	f47f aeb6 	bne.w	9506 <HAL_ADC_Init+0x17a>
    979a:	e70a      	b.n	95b2 <HAL_ADC_Init+0x226>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
    979c:	f64b 72fc 	movw	r2, #49148	; 0xbffc
    97a0:	68de      	ldr	r6, [r3, #12]
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
    97a2:	7d20      	ldrb	r0, [r4, #20]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
    97a4:	f6cf 72ff 	movt	r2, #65535	; 0xffff
    97a8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    97aa:	4032      	ands	r2, r6
    97ac:	ea42 3280 	orr.w	r2, r2, r0, lsl #14
    97b0:	430a      	orrs	r2, r1
    97b2:	60da      	str	r2, [r3, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
    97b4:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    97b8:	2b01      	cmp	r3, #1
    97ba:	d05f      	beq.n	987c <HAL_ADC_Init+0x4f0>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
    97bc:	6822      	ldr	r2, [r4, #0]
    97be:	6913      	ldr	r3, [r2, #16]
    97c0:	f023 0301 	bic.w	r3, r3, #1
    97c4:	6113      	str	r3, [r2, #16]
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
    97c6:	6822      	ldr	r2, [r4, #0]
      ADC_ConfigureBoostMode(hadc);
    97c8:	4620      	mov	r0, r4
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
    97ca:	6b61      	ldr	r1, [r4, #52]	; 0x34
    97cc:	6913      	ldr	r3, [r2, #16]
    97ce:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    97d2:	430b      	orrs	r3, r1
    97d4:	6113      	str	r3, [r2, #16]
      ADC_ConfigureBoostMode(hadc);
    97d6:	f7ff fd1b 	bl	9210 <ADC_ConfigureBoostMode>
    97da:	6823      	ldr	r3, [r4, #0]
    97dc:	e7a2      	b.n	9724 <HAL_ADC_Init+0x398>
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    97de:	f243 604c 	movw	r0, #13900	; 0x364c
    97e2:	f240 11b5 	movw	r1, #437	; 0x1b5
    97e6:	f2c0 0003 	movt	r0, #3
    97ea:	f011 fc61 	bl	1b0b0 <assert_failed>
    97ee:	e6da      	b.n	95a6 <HAL_ADC_Init+0x21a>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
    97f0:	f243 604c 	movw	r0, #13900	; 0x364c
    97f4:	f240 11ad 	movw	r1, #429	; 0x1ad
    97f8:	f2c0 0003 	movt	r0, #3
    97fc:	f011 fc58 	bl	1b0b0 <assert_failed>
    9800:	e662      	b.n	94c8 <HAL_ADC_Init+0x13c>
    9802:	7d62      	ldrb	r2, [r4, #21]
    9804:	7f20      	ldrb	r0, [r4, #28]
    9806:	0351      	lsls	r1, r2, #13
    9808:	6b26      	ldr	r6, [r4, #48]	; 0x30
    980a:	68a2      	ldr	r2, [r4, #8]
    980c:	0403      	lsls	r3, r0, #16
    980e:	e768      	b.n	96e2 <HAL_ADC_Init+0x356>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    9810:	6b19      	ldr	r1, [r3, #48]	; 0x30
    9812:	69a2      	ldr	r2, [r4, #24]
    9814:	f021 010f 	bic.w	r1, r1, #15
    9818:	3a01      	subs	r2, #1
    981a:	430a      	orrs	r2, r1
    981c:	631a      	str	r2, [r3, #48]	; 0x30
    981e:	e788      	b.n	9732 <HAL_ADC_Init+0x3a6>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    9820:	f243 604c 	movw	r0, #13900	; 0x364c
    9824:	f44f 71dd 	mov.w	r1, #442	; 0x1ba
    9828:	f2c0 0003 	movt	r0, #3
    982c:	f011 fc40 	bl	1b0b0 <assert_failed>
    9830:	e666      	b.n	9500 <HAL_ADC_Init+0x174>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    9832:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    9836:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    983a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    983e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9842:	6899      	ldr	r1, [r3, #8]
    9844:	6893      	ldr	r3, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    9846:	430b      	orrs	r3, r1
    9848:	07d8      	lsls	r0, r3, #31
    984a:	f53f af38 	bmi.w	96be <HAL_ADC_Init+0x332>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
    984e:	f44f 520c 	mov.w	r2, #8960	; 0x2300
    9852:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9856:	e72c      	b.n	96b2 <HAL_ADC_Init+0x326>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    9858:	f243 604c 	movw	r0, #13900	; 0x364c
    985c:	f240 11a7 	movw	r1, #423	; 0x1a7
    9860:	f2c0 0003 	movt	r0, #3
    9864:	f011 fc24 	bl	1b0b0 <assert_failed>
    9868:	e5d5      	b.n	9416 <HAL_ADC_Init+0x8a>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    986a:	f243 604c 	movw	r0, #13900	; 0x364c
    986e:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
    9872:	f2c0 0003 	movt	r0, #3
    9876:	f011 fc1b 	bl	1b0b0 <assert_failed>
    987a:	e621      	b.n	94c0 <HAL_ADC_Init+0x134>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
    987c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    987e:	3b01      	subs	r3, #1
    9880:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    9884:	d251      	bcs.n	992a <HAL_ADC_Init+0x59e>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
    9886:	6c22      	ldr	r2, [r4, #64]	; 0x40
    9888:	f032 0160 	bics.w	r1, r2, #96	; 0x60
    988c:	bf14      	ite	ne
    988e:	2301      	movne	r3, #1
    9890:	2300      	moveq	r3, #0
    9892:	2980      	cmp	r1, #128	; 0x80
    9894:	bf0c      	ite	eq
    9896:	2300      	moveq	r3, #0
    9898:	f003 0301 	andne.w	r3, r3, #1
    989c:	b113      	cbz	r3, 98a4 <HAL_ADC_Init+0x518>
    989e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    98a2:	d14b      	bne.n	993c <HAL_ADC_Init+0x5b0>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
    98a4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    98a6:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    98aa:	d135      	bne.n	9918 <HAL_ADC_Init+0x58c>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
    98ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    98ae:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    98b2:	2b01      	cmp	r3, #1
    98b4:	d127      	bne.n	9906 <HAL_ADC_Init+0x57a>
      if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
    98b6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    98b8:	6c66      	ldr	r6, [r4, #68]	; 0x44
    98ba:	b10b      	cbz	r3, 98c0 <HAL_ADC_Init+0x534>
            || (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
    98bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    98be:	b94b      	cbnz	r3, 98d4 <HAL_ADC_Init+0x548>
          assert_param((hadc->Init.Oversampling.TriggeredMode == ADC_TRIGGEREDMODE_SINGLE_TRIGGER));
    98c0:	b146      	cbz	r6, 98d4 <HAL_ADC_Init+0x548>
    98c2:	f243 604c 	movw	r0, #13900	; 0x364c
    98c6:	f240 218b 	movw	r1, #651	; 0x28b
    98ca:	f2c0 0003 	movt	r0, #3
    98ce:	f011 fbef 	bl	1b0b0 <assert_failed>
    98d2:	6c66      	ldr	r6, [r4, #68]	; 0x44
       MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
    98d4:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    98d6:	f64f 021e 	movw	r2, #63518	; 0xf81e
    98da:	6820      	ldr	r0, [r4, #0]
    98dc:	6c23      	ldr	r3, [r4, #64]	; 0x40
    98de:	f6cf 4200 	movt	r2, #64512	; 0xfc00
    98e2:	6907      	ldr	r7, [r0, #16]
    98e4:	430b      	orrs	r3, r1
    98e6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    98e8:	403a      	ands	r2, r7
    98ea:	f043 0301 	orr.w	r3, r3, #1
    98ee:	3901      	subs	r1, #1
    98f0:	4313      	orrs	r3, r2
    98f2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    98f6:	4333      	orrs	r3, r6
    98f8:	6103      	str	r3, [r0, #16]
    98fa:	e764      	b.n	97c6 <HAL_ADC_Init+0x43a>
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
    98fc:	f046 021c 	orr.w	r2, r6, #28
    9900:	430a      	orrs	r2, r1
    9902:	431a      	orrs	r2, r3
    9904:	e6f0      	b.n	96e8 <HAL_ADC_Init+0x35c>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
    9906:	f243 604c 	movw	r0, #13900	; 0x364c
    990a:	f240 2185 	movw	r1, #645	; 0x285
    990e:	f2c0 0003 	movt	r0, #3
    9912:	f011 fbcd 	bl	1b0b0 <assert_failed>
    9916:	e7ce      	b.n	98b6 <HAL_ADC_Init+0x52a>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
    9918:	f243 604c 	movw	r0, #13900	; 0x364c
    991c:	f44f 7121 	mov.w	r1, #644	; 0x284
    9920:	f2c0 0003 	movt	r0, #3
    9924:	f011 fbc4 	bl	1b0b0 <assert_failed>
    9928:	e7c0      	b.n	98ac <HAL_ADC_Init+0x520>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
    992a:	f243 604c 	movw	r0, #13900	; 0x364c
    992e:	f240 2182 	movw	r1, #642	; 0x282
    9932:	f2c0 0003 	movt	r0, #3
    9936:	f011 fbbb 	bl	1b0b0 <assert_failed>
    993a:	e7a4      	b.n	9886 <HAL_ADC_Init+0x4fa>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
    993c:	f243 604c 	movw	r0, #13900	; 0x364c
    9940:	f240 2183 	movw	r1, #643	; 0x283
    9944:	f2c0 0003 	movt	r0, #3
    9948:	f011 fbb2 	bl	1b0b0 <assert_failed>
    994c:	e7aa      	b.n	98a4 <HAL_ADC_Init+0x518>
    994e:	bf00      	nop

00009950 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
    9950:	b5f0      	push	{r4, r5, r6, r7, lr}
    9952:	4604      	mov	r4, r0
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9954:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    9958:	f44f 5004 	mov.w	r0, #8448	; 0x2100
{
    995c:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    995e:	6823      	ldr	r3, [r4, #0]
    9960:	f2c4 0702 	movt	r7, #16386	; 0x4002
    9964:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __IO uint32_t wait_loop_index = 0UL;
    9968:	f04f 0c00 	mov.w	ip, #0
{
    996c:	460d      	mov	r5, r1
    996e:	4616      	mov	r6, r2
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9970:	42bb      	cmp	r3, r7
    9972:	bf18      	it	ne
    9974:	4283      	cmpne	r3, r0
  __IO uint32_t wait_loop_index = 0UL;
    9976:	f8cd c004 	str.w	ip, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    997a:	d005      	beq.n	9988 <HAL_ADCEx_Calibration_Start+0x38>
    997c:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    9980:	f6c5 0202 	movt	r2, #22530	; 0x5802
    9984:	4293      	cmp	r3, r2
    9986:	d159      	bne.n	9a3c <HAL_ADCEx_Calibration_Start+0xec>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
    9988:	f240 73ff 	movw	r3, #2047	; 0x7ff
    998c:	429e      	cmp	r6, r3
    998e:	d004      	beq.n	999a <HAL_ADCEx_Calibration_Start+0x4a>
    9990:	2300      	movs	r3, #0
    9992:	f2c4 73ff 	movt	r3, #18431	; 0x47ff
    9996:	429e      	cmp	r6, r3
    9998:	d142      	bne.n	9a20 <HAL_ADCEx_Calibration_Start+0xd0>

  /* Process locked */
  __HAL_LOCK(hadc);
    999a:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    999e:	2b01      	cmp	r3, #1
    99a0:	d049      	beq.n	9a36 <HAL_ADCEx_Calibration_Start+0xe6>
    99a2:	2301      	movs	r3, #1

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
    99a4:	4620      	mov	r0, r4
  __HAL_LOCK(hadc);
    99a6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tmp_hal_status = ADC_Disable(hadc);
    99aa:	f7ff fbfb 	bl	91a4 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
    99ae:	bb70      	cbnz	r0, 9a0e <HAL_ADCEx_Calibration_Start+0xbe>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
    99b0:	f64e 61fd 	movw	r1, #61181	; 0xeefd
    99b4:	6d62      	ldr	r2, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
    99b6:	f405 3380 	and.w	r3, r5, #65536	; 0x10000
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance , CalibrationMode, SingleDiff );
    99ba:	6827      	ldr	r7, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
    99bc:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    99c0:	f64f 75c0 	movw	r5, #65472	; 0xffc0
    99c4:	f006 4680 	and.w	r6, r6, #1073741824	; 0x40000000
    99c8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    99cc:	4011      	ands	r1, r2
    99ce:	f6c3 75fe 	movt	r5, #16382	; 0x3ffe
    99d2:	4333      	orrs	r3, r6

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    99d4:	f24f 72ff 	movw	r2, #63487	; 0xf7ff
    ADC_STATE_CLR_SET(hadc->State,
    99d8:	f041 0102 	orr.w	r1, r1, #2
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    99dc:	f2c2 52c3 	movt	r2, #9667	; 0x25c3
    ADC_STATE_CLR_SET(hadc->State,
    99e0:	6561      	str	r1, [r4, #84]	; 0x54
    99e2:	68b9      	ldr	r1, [r7, #8]
    99e4:	400d      	ands	r5, r1
    99e6:	432b      	orrs	r3, r5
    99e8:	60bb      	str	r3, [r7, #8]
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    99ea:	6821      	ldr	r1, [r4, #0]
    99ec:	e005      	b.n	99fa <HAL_ADCEx_Calibration_Start+0xaa>
      wait_loop_index++;
    99ee:	9b01      	ldr	r3, [sp, #4]
    99f0:	3301      	adds	r3, #1
    99f2:	9301      	str	r3, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    99f4:	9b01      	ldr	r3, [sp, #4]
    99f6:	4293      	cmp	r3, r2
    99f8:	d828      	bhi.n	9a4c <HAL_ADCEx_Calibration_Start+0xfc>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
    99fa:	688b      	ldr	r3, [r1, #8]
    99fc:	2b00      	cmp	r3, #0
    99fe:	dbf6      	blt.n	99ee <HAL_ADCEx_Calibration_Start+0x9e>
        return HAL_ERROR;
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
    9a00:	6d63      	ldr	r3, [r4, #84]	; 0x54
    9a02:	f023 0303 	bic.w	r3, r3, #3
    9a06:	f043 0301 	orr.w	r3, r3, #1
    9a0a:	6563      	str	r3, [r4, #84]	; 0x54
    9a0c:	e003      	b.n	9a16 <HAL_ADCEx_Calibration_Start+0xc6>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9a0e:	6d63      	ldr	r3, [r4, #84]	; 0x54
    9a10:	f043 0310 	orr.w	r3, r3, #16
    9a14:	6563      	str	r3, [r4, #84]	; 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
    9a16:	2300      	movs	r3, #0
    9a18:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
}
    9a1c:	b003      	add	sp, #12
    9a1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
    9a20:	f243 6084 	movw	r0, #13956	; 0x3684
    9a24:	218f      	movs	r1, #143	; 0x8f
    9a26:	f2c0 0003 	movt	r0, #3
    9a2a:	f011 fb41 	bl	1b0b0 <assert_failed>
  __HAL_LOCK(hadc);
    9a2e:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    9a32:	2b01      	cmp	r3, #1
    9a34:	d1b5      	bne.n	99a2 <HAL_ADCEx_Calibration_Start+0x52>
    9a36:	2002      	movs	r0, #2
}
    9a38:	b003      	add	sp, #12
    9a3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9a3c:	f243 6084 	movw	r0, #13956	; 0x3684
    9a40:	218e      	movs	r1, #142	; 0x8e
    9a42:	f2c0 0003 	movt	r0, #3
    9a46:	f011 fb33 	bl	1b0b0 <assert_failed>
    9a4a:	e79d      	b.n	9988 <HAL_ADCEx_Calibration_Start+0x38>
        ADC_STATE_CLR_SET(hadc->State,
    9a4c:	6d63      	ldr	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hadc);
    9a4e:	2200      	movs	r2, #0
        return HAL_ERROR;
    9a50:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
    9a52:	f023 0312 	bic.w	r3, r3, #18
        __HAL_UNLOCK(hadc);
    9a56:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        ADC_STATE_CLR_SET(hadc->State,
    9a5a:	f043 0310 	orr.w	r3, r3, #16
    9a5e:	6563      	str	r3, [r4, #84]	; 0x54
}
    9a60:	b003      	add	sp, #12
    9a62:	bdf0      	pop	{r4, r5, r6, r7, pc}

00009a64 <HAL_ADCEx_MultiModeConfigChannel>:
  ADC_Common_TypeDef *tmpADC_Common;
  ADC_HandleTypeDef  tmphadcSlave;
  uint32_t tmphadcSlave_conversion_on_going;

  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9a64:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
    9a68:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9a6a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9a6e:	6802      	ldr	r2, [r0, #0]
{
    9a70:	4604      	mov	r4, r0
    9a72:	460d      	mov	r5, r1
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9a74:	429a      	cmp	r2, r3
    9a76:	d007      	beq.n	9a88 <HAL_ADCEx_MultiModeConfigChannel+0x24>
    9a78:	f243 6084 	movw	r0, #13956	; 0x3684
    9a7c:	f640 01bd 	movw	r1, #2237	; 0x8bd
    9a80:	f2c0 0003 	movt	r0, #3
    9a84:	f011 fb14 	bl	1b0b0 <assert_failed>
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
    9a88:	682b      	ldr	r3, [r5, #0]
    9a8a:	2b09      	cmp	r3, #9
    9a8c:	d93a      	bls.n	9b04 <HAL_ADCEx_MultiModeConfigChannel+0xa0>
    9a8e:	f243 6084 	movw	r0, #13956	; 0x3684
    9a92:	f640 01be 	movw	r1, #2238	; 0x8be
    9a96:	f2c0 0003 	movt	r0, #3
    9a9a:	f011 fb09 	bl	1b0b0 <assert_failed>
    9a9e:	682b      	ldr	r3, [r5, #0]
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
    9aa0:	b1d3      	cbz	r3, 9ad8 <HAL_ADCEx_MultiModeConfigChannel+0x74>
  {
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    9aa2:	686b      	ldr	r3, [r5, #4]
    9aa4:	f433 4200 	bics.w	r2, r3, #32768	; 0x8000
    9aa8:	d002      	beq.n	9ab0 <HAL_ADCEx_MultiModeConfigChannel+0x4c>
    9aaa:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
    9aae:	d16f      	bne.n	9b90 <HAL_ADCEx_MultiModeConfigChannel+0x12c>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    9ab0:	68ab      	ldr	r3, [r5, #8]
    9ab2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    9ab6:	bf18      	it	ne
    9ab8:	f5b3 6fe0 	cmpne.w	r3, #1792	; 0x700
    9abc:	bf14      	ite	ne
    9abe:	2201      	movne	r2, #1
    9ac0:	2200      	moveq	r2, #0
    9ac2:	f433 7140 	bics.w	r1, r3, #768	; 0x300
    9ac6:	bf08      	it	eq
    9ac8:	2200      	moveq	r2, #0
    9aca:	b12a      	cbz	r2, 9ad8 <HAL_ADCEx_MultiModeConfigChannel+0x74>
    9acc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    9ad0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    9ad4:	f040 80a8 	bne.w	9c28 <HAL_ADCEx_MultiModeConfigChannel+0x1c4>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
    9ad8:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    9adc:	2b01      	cmp	r3, #1
    9ade:	d060      	beq.n	9ba2 <HAL_ADCEx_MultiModeConfigChannel+0x13e>

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9ae0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    9ae4:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(hadc);
    9ae6:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9ae8:	f2c4 0302 	movt	r3, #16386	; 0x4002
  __HAL_LOCK(hadc);
    9aec:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9af0:	429a      	cmp	r2, r3
    9af2:	d00d      	beq.n	9b10 <HAL_ADCEx_MultiModeConfigChannel+0xac>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9af4:	6d63      	ldr	r3, [r4, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
    9af6:	2200      	movs	r2, #0
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9af8:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
    9afc:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9b00:	6563      	str	r3, [r4, #84]	; 0x54
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
    9b02:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
    9b04:	f240 22ef 	movw	r2, #751	; 0x2ef
    9b08:	40da      	lsrs	r2, r3
    9b0a:	07d6      	lsls	r6, r2, #31
    9b0c:	d4c8      	bmi.n	9aa0 <HAL_ADCEx_MultiModeConfigChannel+0x3c>
    9b0e:	e7be      	b.n	9a8e <HAL_ADCEx_MultiModeConfigChannel+0x2a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    9b10:	f44f 5304 	mov.w	r3, #8448	; 0x2100
    9b14:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9b18:	6899      	ldr	r1, [r3, #8]
    9b1a:	0749      	lsls	r1, r1, #29
    9b1c:	d509      	bpl.n	9b32 <HAL_ADCEx_MultiModeConfigChannel+0xce>
    9b1e:	6893      	ldr	r3, [r2, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9b20:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    9b22:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9b24:	f043 0320 	orr.w	r3, r3, #32
    9b28:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
    9b2a:	2300      	movs	r3, #0
    9b2c:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
    9b30:	bd70      	pop	{r4, r5, r6, pc}
    9b32:	6891      	ldr	r1, [r2, #8]
    9b34:	0748      	lsls	r0, r1, #29
    9b36:	d4f3      	bmi.n	9b20 <HAL_ADCEx_MultiModeConfigChannel+0xbc>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
    9b38:	6829      	ldr	r1, [r5, #0]
    9b3a:	b3a1      	cbz	r1, 9ba6 <HAL_ADCEx_MultiModeConfigChannel+0x142>
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
    9b3c:	f44f 500c 	mov.w	r0, #8960	; 0x2300
    9b40:	686e      	ldr	r6, [r5, #4]
    9b42:	f2c4 0002 	movt	r0, #16386	; 0x4002
    9b46:	6881      	ldr	r1, [r0, #8]
    9b48:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    9b4c:	4331      	orrs	r1, r6
    9b4e:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    9b50:	6821      	ldr	r1, [r4, #0]
    9b52:	4291      	cmp	r1, r2
    9b54:	d059      	beq.n	9c0a <HAL_ADCEx_MultiModeConfigChannel+0x1a6>
    9b56:	4299      	cmp	r1, r3
    9b58:	d057      	beq.n	9c0a <HAL_ADCEx_MultiModeConfigChannel+0x1a6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    9b5a:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    9b5e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    9b62:	689b      	ldr	r3, [r3, #8]
    9b64:	43db      	mvns	r3, r3
    9b66:	f003 0301 	and.w	r3, r3, #1
    9b6a:	2b00      	cmp	r3, #0
    9b6c:	d065      	beq.n	9c3a <HAL_ADCEx_MultiModeConfigChannel+0x1d6>
        MODIFY_REG(tmpADC_Common->CCR,
    9b6e:	f44f 510c 	mov.w	r1, #8960	; 0x2300
    9b72:	f24f 02e0 	movw	r2, #61664	; 0xf0e0
    9b76:	68a8      	ldr	r0, [r5, #8]
    9b78:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9b7c:	682b      	ldr	r3, [r5, #0]
    9b7e:	f6cf 72ff 	movt	r2, #65535	; 0xffff
    9b82:	688d      	ldr	r5, [r1, #8]
    9b84:	4303      	orrs	r3, r0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9b86:	2000      	movs	r0, #0
        MODIFY_REG(tmpADC_Common->CCR,
    9b88:	402a      	ands	r2, r5
    9b8a:	4313      	orrs	r3, r2
    9b8c:	608b      	str	r3, [r1, #8]
    9b8e:	e7cc      	b.n	9b2a <HAL_ADCEx_MultiModeConfigChannel+0xc6>
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    9b90:	f243 6084 	movw	r0, #13956	; 0x3684
    9b94:	f640 01c1 	movw	r1, #2241	; 0x8c1
    9b98:	f2c0 0003 	movt	r0, #3
    9b9c:	f011 fa88 	bl	1b0b0 <assert_failed>
    9ba0:	e786      	b.n	9ab0 <HAL_ADCEx_MultiModeConfigChannel+0x4c>
  __HAL_LOCK(hadc);
    9ba2:	2002      	movs	r0, #2
}
    9ba4:	bd70      	pop	{r4, r5, r6, pc}
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
    9ba6:	f44f 510c 	mov.w	r1, #8960	; 0x2300
    9baa:	f2c4 0102 	movt	r1, #16386	; 0x4002
    9bae:	6888      	ldr	r0, [r1, #8]
    9bb0:	f420 4040 	bic.w	r0, r0, #49152	; 0xc000
    9bb4:	6088      	str	r0, [r1, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    9bb6:	6821      	ldr	r1, [r4, #0]
    9bb8:	4291      	cmp	r1, r2
    9bba:	d017      	beq.n	9bec <HAL_ADCEx_MultiModeConfigChannel+0x188>
    9bbc:	4299      	cmp	r1, r3
    9bbe:	d015      	beq.n	9bec <HAL_ADCEx_MultiModeConfigChannel+0x188>
    9bc0:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    9bc4:	f6c5 0302 	movt	r3, #22530	; 0x5802
    9bc8:	689b      	ldr	r3, [r3, #8]
    9bca:	43db      	mvns	r3, r3
    9bcc:	f003 0301 	and.w	r3, r3, #1
    9bd0:	b39b      	cbz	r3, 9c3a <HAL_ADCEx_MultiModeConfigChannel+0x1d6>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
    9bd2:	f44f 520c 	mov.w	r2, #8960	; 0x2300
    9bd6:	f24f 03e0 	movw	r3, #61664	; 0xf0e0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9bda:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
    9bdc:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9be0:	f6cf 73ff 	movt	r3, #65535	; 0xffff
    9be4:	6891      	ldr	r1, [r2, #8]
    9be6:	400b      	ands	r3, r1
    9be8:	6093      	str	r3, [r2, #8]
    9bea:	e79e      	b.n	9b2a <HAL_ADCEx_MultiModeConfigChannel+0xc6>
    9bec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    9bf0:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    9bf4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9bf8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9bfc:	6899      	ldr	r1, [r3, #8]
    9bfe:	6893      	ldr	r3, [r2, #8]
    9c00:	430b      	orrs	r3, r1
    9c02:	43db      	mvns	r3, r3
    9c04:	f003 0301 	and.w	r3, r3, #1
    9c08:	e7e2      	b.n	9bd0 <HAL_ADCEx_MultiModeConfigChannel+0x16c>
    9c0a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    9c0e:	f44f 5204 	mov.w	r2, #8448	; 0x2100
    9c12:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9c16:	f2c4 0202 	movt	r2, #16386	; 0x4002
    9c1a:	6899      	ldr	r1, [r3, #8]
    9c1c:	6893      	ldr	r3, [r2, #8]
    9c1e:	430b      	orrs	r3, r1
    9c20:	43db      	mvns	r3, r3
    9c22:	f003 0301 	and.w	r3, r3, #1
    9c26:	e7a0      	b.n	9b6a <HAL_ADCEx_MultiModeConfigChannel+0x106>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    9c28:	f243 6084 	movw	r0, #13956	; 0x3684
    9c2c:	f640 01c2 	movw	r1, #2242	; 0x8c2
    9c30:	f2c0 0003 	movt	r0, #3
    9c34:	f011 fa3c 	bl	1b0b0 <assert_failed>
    9c38:	e74e      	b.n	9ad8 <HAL_ADCEx_MultiModeConfigChannel+0x74>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9c3a:	2000      	movs	r0, #0
    9c3c:	e775      	b.n	9b2a <HAL_ADCEx_MultiModeConfigChannel+0xc6>
    9c3e:	bf00      	nop

00009c40 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
    9c40:	1ec3      	subs	r3, r0, #3
    9c42:	2b04      	cmp	r3, #4
{
    9c44:	b510      	push	{r4, lr}
    9c46:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
    9c48:	d906      	bls.n	9c58 <HAL_NVIC_SetPriorityGrouping+0x18>
    9c4a:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9c4e:	2192      	movs	r1, #146	; 0x92
    9c50:	f2c0 0003 	movt	r0, #3
    9c54:	f011 fa2c 	bl	1b0b0 <assert_failed>
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    9c58:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
    9c5c:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
    9c60:	2300      	movs	r3, #0
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
    9c62:	0224      	lsls	r4, r4, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    9c64:	f2ce 0200 	movt	r2, #57344	; 0xe000
    9c68:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
    9c6c:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    9c70:	68d1      	ldr	r1, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
    9c72:	4001      	ands	r1, r0
    9c74:	430b      	orrs	r3, r1
  reg_value  =  (reg_value                                   |
    9c76:	431c      	orrs	r4, r3
  SCB->AIRCR =  reg_value;
    9c78:	60d4      	str	r4, [r2, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
    9c7a:	bd10      	pop	{r4, pc}

00009c7c <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    9c7c:	2a0f      	cmp	r2, #15
{
    9c7e:	b570      	push	{r4, r5, r6, lr}
    9c80:	4616      	mov	r6, r2
    9c82:	4605      	mov	r5, r0
    9c84:	460c      	mov	r4, r1
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    9c86:	d841      	bhi.n	9d0c <HAL_NVIC_SetPriority+0x90>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    9c88:	2c0f      	cmp	r4, #15
    9c8a:	d837      	bhi.n	9cfc <HAL_NVIC_SetPriority+0x80>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
    9c8c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
    9c90:	f2ce 0300 	movt	r3, #57344	; 0xe000
    9c94:	68db      	ldr	r3, [r3, #12]
    9c96:	f3c3 2302 	ubfx	r3, r3, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
    9c9a:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    9c9e:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
    9ca0:	2904      	cmp	r1, #4
    9ca2:	bf28      	it	cs
    9ca4:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    9ca6:	2a06      	cmp	r2, #6
    9ca8:	d91c      	bls.n	9ce4 <HAL_NVIC_SetPriority+0x68>
    9caa:	3b03      	subs	r3, #3
    9cac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9cb0:	409a      	lsls	r2, r3
    9cb2:	ea26 0602 	bic.w	r6, r6, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
    9cb6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
    9cba:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
    9cbc:	fa02 f201 	lsl.w	r2, r2, r1
    9cc0:	ea24 0202 	bic.w	r2, r4, r2
    9cc4:	fa02 f203 	lsl.w	r2, r2, r3
    9cc8:	ea42 0206 	orr.w	r2, r2, r6
    9ccc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9cd0:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
    9cd2:	db0a      	blt.n	9cea <HAL_NVIC_SetPriority+0x6e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9cd4:	f44f 4361 	mov.w	r3, #57600	; 0xe100
    9cd8:	f2ce 0300 	movt	r3, #57344	; 0xe000
    9cdc:	442b      	add	r3, r5
    9cde:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
    9ce2:	bd70      	pop	{r4, r5, r6, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    9ce4:	2600      	movs	r6, #0
    9ce6:	4633      	mov	r3, r6
    9ce8:	e7e5      	b.n	9cb6 <HAL_NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9cea:	f64e 43fc 	movw	r3, #60668	; 0xecfc
    9cee:	f005 050f 	and.w	r5, r5, #15
    9cf2:	f2ce 0300 	movt	r3, #57344	; 0xe000
    9cf6:	442b      	add	r3, r5
    9cf8:	761a      	strb	r2, [r3, #24]
    9cfa:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    9cfc:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9d00:	21ab      	movs	r1, #171	; 0xab
    9d02:	f2c0 0003 	movt	r0, #3
    9d06:	f011 f9d3 	bl	1b0b0 <assert_failed>
    9d0a:	e7bf      	b.n	9c8c <HAL_NVIC_SetPriority+0x10>
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    9d0c:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9d10:	21aa      	movs	r1, #170	; 0xaa
    9d12:	f2c0 0003 	movt	r0, #3
    9d16:	f011 f9cb 	bl	1b0b0 <assert_failed>
    9d1a:	e7b5      	b.n	9c88 <HAL_NVIC_SetPriority+0xc>

00009d1c <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9d1c:	2800      	cmp	r0, #0
    9d1e:	db0b      	blt.n	9d38 <HAL_NVIC_EnableIRQ+0x1c>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9d20:	f000 011f 	and.w	r1, r0, #31
    9d24:	2301      	movs	r3, #1
    9d26:	f44f 4261 	mov.w	r2, #57600	; 0xe100
    9d2a:	0940      	lsrs	r0, r0, #5
    9d2c:	408b      	lsls	r3, r1
    9d2e:	f2ce 0200 	movt	r2, #57344	; 0xe000
    9d32:	f842 3020 	str.w	r3, [r2, r0, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
    9d36:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9d38:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9d3c:	21be      	movs	r1, #190	; 0xbe
    9d3e:	f2c0 0003 	movt	r0, #3
    9d42:	f011 b9b5 	b.w	1b0b0 <assert_failed>
    9d46:	bf00      	nop

00009d48 <HAL_NVIC_DisableIRQ>:
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9d48:	2800      	cmp	r0, #0
    9d4a:	db11      	blt.n	9d70 <HAL_NVIC_DisableIRQ+0x28>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9d4c:	0943      	lsrs	r3, r0, #5
    9d4e:	2201      	movs	r2, #1
    9d50:	f000 001f 	and.w	r0, r0, #31
    9d54:	f44f 4161 	mov.w	r1, #57600	; 0xe100
    9d58:	3320      	adds	r3, #32
    9d5a:	fa02 f000 	lsl.w	r0, r2, r0
    9d5e:	f2ce 0100 	movt	r1, #57344	; 0xe000
    9d62:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    9d66:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9d6a:	f3bf 8f6f 	isb	sy

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
    9d6e:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9d70:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9d74:	21ce      	movs	r1, #206	; 0xce
    9d76:	f2c0 0003 	movt	r0, #3
    9d7a:	f011 b999 	b.w	1b0b0 <assert_failed>
    9d7e:	bf00      	nop

00009d80 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    9d80:	3801      	subs	r0, #1
    9d82:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    9d86:	d213      	bcs.n	9db0 <HAL_SYSTICK_Config+0x30>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9d88:	f24e 0310 	movw	r3, #57360	; 0xe010
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9d8c:	f44f 416d 	mov.w	r1, #60672	; 0xed00
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9d90:	2200      	movs	r2, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9d92:	f2ce 0300 	movt	r3, #57344	; 0xe000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9d96:	f2ce 0100 	movt	r1, #57344	; 0xe000
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
    9d9a:	b430      	push	{r4, r5}
    9d9c:	25f0      	movs	r5, #240	; 0xf0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9d9e:	2407      	movs	r4, #7
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9da0:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
    9da2:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9da4:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9da8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9daa:	601c      	str	r4, [r3, #0]
   return SysTick_Config(TicksNumb);
}
    9dac:	bc30      	pop	{r4, r5}
    9dae:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
    9db0:	2001      	movs	r0, #1
    9db2:	4770      	bx	lr

00009db4 <HAL_MPU_Disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    9db4:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9db8:	f44f 436d 	mov.w	r3, #60672	; 0xed00

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
    9dbc:	f64e 5190 	movw	r1, #60816	; 0xed90
    9dc0:	2000      	movs	r0, #0
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9dc2:	f2ce 0300 	movt	r3, #57344	; 0xe000
  MPU->CTRL = 0;
    9dc6:	f2ce 0100 	movt	r1, #57344	; 0xe000
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9dca:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    9dcc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    9dd0:	625a      	str	r2, [r3, #36]	; 0x24
  MPU->CTRL = 0;
    9dd2:	6048      	str	r0, [r1, #4]
}
    9dd4:	4770      	bx	lr
    9dd6:	bf00      	nop

00009dd8 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
    9dd8:	f64e 5290 	movw	r2, #60816	; 0xed90

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9ddc:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
    9de0:	f040 0001 	orr.w	r0, r0, #1
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9de4:	f2ce 0300 	movt	r3, #57344	; 0xe000
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
    9de8:	f2ce 0200 	movt	r2, #57344	; 0xe000
    9dec:	6050      	str	r0, [r2, #4]
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9dee:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    9df0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    9df4:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
    9df6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9dfa:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
    9dfe:	4770      	bx	lr

00009e00 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
    9e00:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9e02:	7843      	ldrb	r3, [r0, #1]
{
    9e04:	4604      	mov	r4, r0
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9e06:	2b0f      	cmp	r3, #15
    9e08:	f200 8087 	bhi.w	9f1a <HAL_MPU_ConfigRegion+0x11a>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
    9e0c:	7823      	ldrb	r3, [r4, #0]
    9e0e:	2b01      	cmp	r3, #1
    9e10:	d907      	bls.n	9e22 <HAL_MPU_ConfigRegion+0x22>
    9e12:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9e16:	f44f 7197 	mov.w	r1, #302	; 0x12e
    9e1a:	f2c0 0003 	movt	r0, #3
    9e1e:	f011 f947 	bl	1b0b0 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
    9e22:	f64e 5390 	movw	r3, #60816	; 0xed90
    9e26:	7862      	ldrb	r2, [r4, #1]
    9e28:	f2ce 0300 	movt	r3, #57344	; 0xe000
    9e2c:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
    9e2e:	7822      	ldrb	r2, [r4, #0]
    9e30:	2a00      	cmp	r2, #0
    9e32:	d03e      	beq.n	9eb2 <HAL_MPU_ConfigRegion+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    9e34:	7b23      	ldrb	r3, [r4, #12]
    9e36:	2b01      	cmp	r3, #1
    9e38:	d83e      	bhi.n	9eb8 <HAL_MPU_ConfigRegion+0xb8>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9e3a:	7ae3      	ldrb	r3, [r4, #11]
    9e3c:	1f5a      	subs	r2, r3, #5
    9e3e:	2a01      	cmp	r2, #1
    9e40:	d902      	bls.n	9e48 <HAL_MPU_ConfigRegion+0x48>
    9e42:	2b03      	cmp	r3, #3
    9e44:	f200 8088 	bhi.w	9f58 <HAL_MPU_ConfigRegion+0x158>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9e48:	7aa3      	ldrb	r3, [r4, #10]
    9e4a:	2b02      	cmp	r3, #2
    9e4c:	d877      	bhi.n	9f3e <HAL_MPU_ConfigRegion+0x13e>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9e4e:	7b63      	ldrb	r3, [r4, #13]
    9e50:	2b01      	cmp	r3, #1
    9e52:	d856      	bhi.n	9f02 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9e54:	7ba3      	ldrb	r3, [r4, #14]
    9e56:	2b01      	cmp	r3, #1
    9e58:	d847      	bhi.n	9eea <HAL_MPU_ConfigRegion+0xea>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9e5a:	7be3      	ldrb	r3, [r4, #15]
    9e5c:	2b01      	cmp	r3, #1
    9e5e:	d838      	bhi.n	9ed2 <HAL_MPU_ConfigRegion+0xd2>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9e60:	7a63      	ldrb	r3, [r4, #9]
    9e62:	2bff      	cmp	r3, #255	; 0xff
    9e64:	f000 8085 	beq.w	9f72 <HAL_MPU_ConfigRegion+0x172>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9e68:	7a23      	ldrb	r3, [r4, #8]
    9e6a:	3b04      	subs	r3, #4
    9e6c:	2b1b      	cmp	r3, #27
    9e6e:	d85d      	bhi.n	9f2c <HAL_MPU_ConfigRegion+0x12c>

    MPU->RBAR = MPU_Init->BaseAddress;
    9e70:	f64e 5290 	movw	r2, #60816	; 0xed90
    9e74:	6863      	ldr	r3, [r4, #4]
    9e76:	f2ce 0200 	movt	r2, #57344	; 0xe000
    9e7a:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    9e7c:	7ae3      	ldrb	r3, [r4, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9e7e:	7b21      	ldrb	r1, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    9e80:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
    9e82:	7825      	ldrb	r5, [r4, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
    9e84:	7aa0      	ldrb	r0, [r4, #10]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9e86:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
    9e8a:	7b61      	ldrb	r1, [r4, #13]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
    9e8c:	7ba6      	ldrb	r6, [r4, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9e8e:	432b      	orrs	r3, r5
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
    9e90:	7be5      	ldrb	r5, [r4, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9e92:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
    9e96:	7a60      	ldrb	r0, [r4, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9e98:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
    9e9c:	7a21      	ldrb	r1, [r4, #8]
    9e9e:	ea43 4346 	orr.w	r3, r3, r6, lsl #17
    9ea2:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
    9ea6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    9eaa:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9eae:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
    9eb0:	bd70      	pop	{r4, r5, r6, pc}
    MPU->RBAR = 0x00;
    9eb2:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
    9eb4:	611a      	str	r2, [r3, #16]
}
    9eb6:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    9eb8:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9ebc:	f44f 719b 	mov.w	r1, #310	; 0x136
    9ec0:	f2c0 0003 	movt	r0, #3
    9ec4:	f011 f8f4 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9ec8:	7ae3      	ldrb	r3, [r4, #11]
    9eca:	1f5a      	subs	r2, r3, #5
    9ecc:	2a01      	cmp	r2, #1
    9ece:	d8b8      	bhi.n	9e42 <HAL_MPU_ConfigRegion+0x42>
    9ed0:	e7ba      	b.n	9e48 <HAL_MPU_ConfigRegion+0x48>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9ed2:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9ed6:	f240 113b 	movw	r1, #315	; 0x13b
    9eda:	f2c0 0003 	movt	r0, #3
    9ede:	f011 f8e7 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9ee2:	7a63      	ldrb	r3, [r4, #9]
    9ee4:	2bff      	cmp	r3, #255	; 0xff
    9ee6:	d1bf      	bne.n	9e68 <HAL_MPU_ConfigRegion+0x68>
    9ee8:	e043      	b.n	9f72 <HAL_MPU_ConfigRegion+0x172>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9eea:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9eee:	f44f 719d 	mov.w	r1, #314	; 0x13a
    9ef2:	f2c0 0003 	movt	r0, #3
    9ef6:	f011 f8db 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9efa:	7be3      	ldrb	r3, [r4, #15]
    9efc:	2b01      	cmp	r3, #1
    9efe:	d9af      	bls.n	9e60 <HAL_MPU_ConfigRegion+0x60>
    9f00:	e7e7      	b.n	9ed2 <HAL_MPU_ConfigRegion+0xd2>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9f02:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9f06:	f240 1139 	movw	r1, #313	; 0x139
    9f0a:	f2c0 0003 	movt	r0, #3
    9f0e:	f011 f8cf 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9f12:	7ba3      	ldrb	r3, [r4, #14]
    9f14:	2b01      	cmp	r3, #1
    9f16:	d9a0      	bls.n	9e5a <HAL_MPU_ConfigRegion+0x5a>
    9f18:	e7e7      	b.n	9eea <HAL_MPU_ConfigRegion+0xea>
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9f1a:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9f1e:	f240 112d 	movw	r1, #301	; 0x12d
    9f22:	f2c0 0003 	movt	r0, #3
    9f26:	f011 f8c3 	bl	1b0b0 <assert_failed>
    9f2a:	e76f      	b.n	9e0c <HAL_MPU_ConfigRegion+0xc>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9f2c:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9f30:	f240 113d 	movw	r1, #317	; 0x13d
    9f34:	f2c0 0003 	movt	r0, #3
    9f38:	f011 f8ba 	bl	1b0b0 <assert_failed>
    9f3c:	e798      	b.n	9e70 <HAL_MPU_ConfigRegion+0x70>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9f3e:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9f42:	f44f 719c 	mov.w	r1, #312	; 0x138
    9f46:	f2c0 0003 	movt	r0, #3
    9f4a:	f011 f8b1 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9f4e:	7b63      	ldrb	r3, [r4, #13]
    9f50:	2b01      	cmp	r3, #1
    9f52:	f67f af7f 	bls.w	9e54 <HAL_MPU_ConfigRegion+0x54>
    9f56:	e7d4      	b.n	9f02 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9f58:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9f5c:	f240 1137 	movw	r1, #311	; 0x137
    9f60:	f2c0 0003 	movt	r0, #3
    9f64:	f011 f8a4 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9f68:	7aa3      	ldrb	r3, [r4, #10]
    9f6a:	2b02      	cmp	r3, #2
    9f6c:	f67f af6f 	bls.w	9e4e <HAL_MPU_ConfigRegion+0x4e>
    9f70:	e7e5      	b.n	9f3e <HAL_MPU_ConfigRegion+0x13e>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9f72:	f243 60c0 	movw	r0, #14016	; 0x36c0
    9f76:	f44f 719e 	mov.w	r1, #316	; 0x13c
    9f7a:	f2c0 0003 	movt	r0, #3
    9f7e:	f011 f897 	bl	1b0b0 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9f82:	7a23      	ldrb	r3, [r4, #8]
    9f84:	3b04      	subs	r3, #4
    9f86:	2b1b      	cmp	r3, #27
    9f88:	f67f af72 	bls.w	9e70 <HAL_MPU_ConfigRegion+0x70>
    9f8c:	e7ce      	b.n	9f2c <HAL_MPU_ConfigRegion+0x12c>
    9f8e:	bf00      	nop

00009f90 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
    9f90:	b430      	push	{r4, r5}
    9f92:	4601      	mov	r1, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9f94:	2310      	movs	r3, #16
    9f96:	2428      	movs	r4, #40	; 0x28
    9f98:	2040      	movs	r0, #64	; 0x40
    9f9a:	680a      	ldr	r2, [r1, #0]
    9f9c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    9fa0:	f2c4 0402 	movt	r4, #16386	; 0x4002
    9fa4:	f2c4 0002 	movt	r0, #16386	; 0x4002
    9fa8:	2558      	movs	r5, #88	; 0x58
    9faa:	42a2      	cmp	r2, r4
    9fac:	bf18      	it	ne
    9fae:	429a      	cmpne	r2, r3
    9fb0:	f04f 0470 	mov.w	r4, #112	; 0x70
    9fb4:	f2c4 0502 	movt	r5, #16386	; 0x4002
    9fb8:	bf0c      	ite	eq
    9fba:	2301      	moveq	r3, #1
    9fbc:	2300      	movne	r3, #0
    9fbe:	f2c4 0402 	movt	r4, #16386	; 0x4002
    9fc2:	4282      	cmp	r2, r0
    9fc4:	bf08      	it	eq
    9fc6:	f043 0301 	orreq.w	r3, r3, #1
    9fca:	2088      	movs	r0, #136	; 0x88
    9fcc:	42aa      	cmp	r2, r5
    9fce:	bf08      	it	eq
    9fd0:	f043 0301 	orreq.w	r3, r3, #1
    9fd4:	f2c4 0002 	movt	r0, #16386	; 0x4002
    9fd8:	25a0      	movs	r5, #160	; 0xa0
    9fda:	42a2      	cmp	r2, r4
    9fdc:	bf08      	it	eq
    9fde:	f043 0301 	orreq.w	r3, r3, #1
    9fe2:	24b8      	movs	r4, #184	; 0xb8
    9fe4:	f2c4 0502 	movt	r5, #16386	; 0x4002
    9fe8:	4282      	cmp	r2, r0
    9fea:	bf08      	it	eq
    9fec:	f043 0301 	orreq.w	r3, r3, #1
    9ff0:	f2c4 0402 	movt	r4, #16386	; 0x4002
    9ff4:	f44f 6082 	mov.w	r0, #1040	; 0x410
    9ff8:	42aa      	cmp	r2, r5
    9ffa:	bf08      	it	eq
    9ffc:	f043 0301 	orreq.w	r3, r3, #1
    a000:	f44f 6585 	mov.w	r5, #1064	; 0x428
    a004:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a008:	42a2      	cmp	r2, r4
    a00a:	bf08      	it	eq
    a00c:	f043 0301 	orreq.w	r3, r3, #1
    a010:	f2c4 0502 	movt	r5, #16386	; 0x4002
    a014:	f44f 6488 	mov.w	r4, #1088	; 0x440
    a018:	4282      	cmp	r2, r0
    a01a:	bf08      	it	eq
    a01c:	f043 0301 	orreq.w	r3, r3, #1
    a020:	f44f 608b 	mov.w	r0, #1112	; 0x458
    a024:	f2c4 0402 	movt	r4, #16386	; 0x4002
    a028:	42aa      	cmp	r2, r5
    a02a:	bf08      	it	eq
    a02c:	f043 0301 	orreq.w	r3, r3, #1
    a030:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a034:	f44f 658e 	mov.w	r5, #1136	; 0x470
    a038:	42a2      	cmp	r2, r4
    a03a:	bf08      	it	eq
    a03c:	f043 0301 	orreq.w	r3, r3, #1
    a040:	f44f 6491 	mov.w	r4, #1160	; 0x488
    a044:	f2c4 0502 	movt	r5, #16386	; 0x4002
    a048:	4282      	cmp	r2, r0
    a04a:	bf08      	it	eq
    a04c:	f043 0301 	orreq.w	r3, r3, #1
    a050:	f2c4 0402 	movt	r4, #16386	; 0x4002
    a054:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
    a058:	42aa      	cmp	r2, r5
    a05a:	bf08      	it	eq
    a05c:	f043 0301 	orreq.w	r3, r3, #1
    a060:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a064:	42a2      	cmp	r2, r4
    a066:	bf08      	it	eq
    a068:	f043 0301 	orreq.w	r3, r3, #1
    a06c:	4282      	cmp	r2, r0
    a06e:	bf08      	it	eq
    a070:	f043 0301 	orreq.w	r3, r3, #1
    a074:	b92b      	cbnz	r3, a082 <DMA_CalcBaseAndBitshift+0xf2>
    a076:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    a07a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    a07e:	429a      	cmp	r2, r3
    a080:	d11b      	bne.n	a0ba <DMA_CalcBaseAndBitshift+0x12a>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a082:	b2d3      	uxtb	r3, r2
    a084:	f64a 25ab 	movw	r5, #43691	; 0xaaab
    a088:	f44f 407c 	mov.w	r0, #64512	; 0xfc00

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a08c:	f243 7434 	movw	r4, #14132	; 0x3734
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a090:	3b10      	subs	r3, #16
    a092:	f6ca 25aa 	movt	r5, #43690	; 0xaaaa
    a096:	f6cf 70ff 	movt	r0, #65535	; 0xffff
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a09a:	f2c0 0403 	movt	r4, #3
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a09e:	fba5 5303 	umull	r5, r3, r5, r3
    a0a2:	4010      	ands	r0, r2
    a0a4:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a0a6:	f003 0207 	and.w	r2, r3, #7

    if (stream_number > 3U)
    a0aa:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a0ac:	5ca2      	ldrb	r2, [r4, r2]
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
    a0ae:	bf88      	it	hi
    a0b0:	3004      	addhi	r0, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a0b2:	65ca      	str	r2, [r1, #92]	; 0x5c
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
    a0b4:	6588      	str	r0, [r1, #88]	; 0x58
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
  }

  return hdma->StreamBaseAddress;
}
    a0b6:	bc30      	pop	{r4, r5}
    a0b8:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
    a0ba:	f022 00ff 	bic.w	r0, r2, #255	; 0xff
    a0be:	6588      	str	r0, [r1, #88]	; 0x58
    a0c0:	e7f9      	b.n	a0b6 <DMA_CalcBaseAndBitshift+0x126>
    a0c2:	bf00      	nop

0000a0c4 <HAL_DMA_Init>:
{
    a0c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a0c8:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
    a0ca:	f7fe f9b9 	bl	8440 <HAL_GetTick>
  if(hdma == NULL)
    a0ce:	2d00      	cmp	r5, #0
    a0d0:	f000 835c 	beq.w	a78c <HAL_DMA_Init+0x6c8>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    a0d4:	2310      	movs	r3, #16
    a0d6:	2128      	movs	r1, #40	; 0x28
    a0d8:	682a      	ldr	r2, [r5, #0]
    a0da:	4604      	mov	r4, r0
    a0dc:	f2c4 0302 	movt	r3, #16386	; 0x4002
    a0e0:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a0e4:	2040      	movs	r0, #64	; 0x40
    a0e6:	2670      	movs	r6, #112	; 0x70
    a0e8:	429a      	cmp	r2, r3
    a0ea:	bf18      	it	ne
    a0ec:	428a      	cmpne	r2, r1
    a0ee:	f04f 0158 	mov.w	r1, #88	; 0x58
    a0f2:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a0f6:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a0fa:	bf14      	ite	ne
    a0fc:	2301      	movne	r3, #1
    a0fe:	2300      	moveq	r3, #0
    a100:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a104:	4282      	cmp	r2, r0
    a106:	bf0c      	ite	eq
    a108:	2300      	moveq	r3, #0
    a10a:	f003 0301 	andne.w	r3, r3, #1
    a10e:	20a0      	movs	r0, #160	; 0xa0
    a110:	428a      	cmp	r2, r1
    a112:	bf0c      	ite	eq
    a114:	2300      	moveq	r3, #0
    a116:	f003 0301 	andne.w	r3, r3, #1
    a11a:	2188      	movs	r1, #136	; 0x88
    a11c:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a120:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a124:	42b2      	cmp	r2, r6
    a126:	bf0c      	ite	eq
    a128:	2300      	moveq	r3, #0
    a12a:	f003 0301 	andne.w	r3, r3, #1
    a12e:	f44f 6682 	mov.w	r6, #1040	; 0x410
    a132:	428a      	cmp	r2, r1
    a134:	bf0c      	ite	eq
    a136:	2300      	moveq	r3, #0
    a138:	f003 0301 	andne.w	r3, r3, #1
    a13c:	21b8      	movs	r1, #184	; 0xb8
    a13e:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a142:	4282      	cmp	r2, r0
    a144:	bf0c      	ite	eq
    a146:	2300      	moveq	r3, #0
    a148:	f003 0301 	andne.w	r3, r3, #1
    a14c:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a150:	f44f 6088 	mov.w	r0, #1088	; 0x440
    a154:	428a      	cmp	r2, r1
    a156:	bf0c      	ite	eq
    a158:	2300      	moveq	r3, #0
    a15a:	f003 0301 	andne.w	r3, r3, #1
    a15e:	f44f 6185 	mov.w	r1, #1064	; 0x428
    a162:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a166:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a16a:	42b2      	cmp	r2, r6
    a16c:	bf0c      	ite	eq
    a16e:	2300      	moveq	r3, #0
    a170:	f003 0301 	andne.w	r3, r3, #1
    a174:	f44f 668e 	mov.w	r6, #1136	; 0x470
    a178:	428a      	cmp	r2, r1
    a17a:	bf0c      	ite	eq
    a17c:	2300      	moveq	r3, #0
    a17e:	f003 0301 	andne.w	r3, r3, #1
    a182:	f44f 618b 	mov.w	r1, #1112	; 0x458
    a186:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a18a:	4282      	cmp	r2, r0
    a18c:	bf0c      	ite	eq
    a18e:	2300      	moveq	r3, #0
    a190:	f003 0301 	andne.w	r3, r3, #1
    a194:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a198:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
    a19c:	428a      	cmp	r2, r1
    a19e:	bf0c      	ite	eq
    a1a0:	2300      	moveq	r3, #0
    a1a2:	f003 0301 	andne.w	r3, r3, #1
    a1a6:	f44f 6191 	mov.w	r1, #1160	; 0x488
    a1aa:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a1ae:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a1b2:	42b2      	cmp	r2, r6
    a1b4:	bf0c      	ite	eq
    a1b6:	2300      	moveq	r3, #0
    a1b8:	f003 0301 	andne.w	r3, r3, #1
    a1bc:	f245 4608 	movw	r6, #21512	; 0x5408
    a1c0:	428a      	cmp	r2, r1
    a1c2:	bf0c      	ite	eq
    a1c4:	2300      	moveq	r3, #0
    a1c6:	f003 0301 	andne.w	r3, r3, #1
    a1ca:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
    a1ce:	f6c5 0602 	movt	r6, #22530	; 0x5802
    a1d2:	4282      	cmp	r2, r0
    a1d4:	bf0c      	ite	eq
    a1d6:	2300      	moveq	r3, #0
    a1d8:	f003 0301 	andne.w	r3, r3, #1
    a1dc:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a1e0:	f245 4030 	movw	r0, #21552	; 0x5430
    a1e4:	428a      	cmp	r2, r1
    a1e6:	bf0c      	ite	eq
    a1e8:	2300      	moveq	r3, #0
    a1ea:	f003 0301 	andne.w	r3, r3, #1
    a1ee:	f245 411c 	movw	r1, #21532	; 0x541c
    a1f2:	f6c5 0002 	movt	r0, #22530	; 0x5802
    a1f6:	f6c5 0102 	movt	r1, #22530	; 0x5802
    a1fa:	42b2      	cmp	r2, r6
    a1fc:	bf0c      	ite	eq
    a1fe:	2300      	moveq	r3, #0
    a200:	f003 0301 	andne.w	r3, r3, #1
    a204:	f245 4658 	movw	r6, #21592	; 0x5458
    a208:	428a      	cmp	r2, r1
    a20a:	bf0c      	ite	eq
    a20c:	2300      	moveq	r3, #0
    a20e:	f003 0301 	andne.w	r3, r3, #1
    a212:	f245 4144 	movw	r1, #21572	; 0x5444
    a216:	f6c5 0602 	movt	r6, #22530	; 0x5802
    a21a:	4282      	cmp	r2, r0
    a21c:	bf0c      	ite	eq
    a21e:	2300      	moveq	r3, #0
    a220:	f003 0301 	andne.w	r3, r3, #1
    a224:	f6c5 0102 	movt	r1, #22530	; 0x5802
    a228:	f245 406c 	movw	r0, #21612	; 0x546c
    a22c:	428a      	cmp	r2, r1
    a22e:	bf0c      	ite	eq
    a230:	2300      	moveq	r3, #0
    a232:	f003 0301 	andne.w	r3, r3, #1
    a236:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
    a23a:	f6c5 0002 	movt	r0, #22530	; 0x5802
    a23e:	42b2      	cmp	r2, r6
    a240:	bf0c      	ite	eq
    a242:	2300      	moveq	r3, #0
    a244:	f003 0301 	andne.w	r3, r3, #1
    a248:	f6c5 0102 	movt	r1, #22530	; 0x5802
    a24c:	4282      	cmp	r2, r0
    a24e:	bf0c      	ite	eq
    a250:	2300      	moveq	r3, #0
    a252:	f003 0301 	andne.w	r3, r3, #1
    a256:	428a      	cmp	r2, r1
    a258:	bf0c      	ite	eq
    a25a:	2300      	moveq	r3, #0
    a25c:	f003 0301 	andne.w	r3, r3, #1
    a260:	b133      	cbz	r3, a270 <HAL_DMA_Init+0x1ac>
    a262:	f245 4394 	movw	r3, #21652	; 0x5494
    a266:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a26a:	429a      	cmp	r2, r3
    a26c:	f040 840e 	bne.w	aa8c <HAL_DMA_Init+0x9c8>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    a270:	68ab      	ldr	r3, [r5, #8]
    a272:	f033 0240 	bics.w	r2, r3, #64	; 0x40
    a276:	d002      	beq.n	a27e <HAL_DMA_Init+0x1ba>
    a278:	2b80      	cmp	r3, #128	; 0x80
    a27a:	f040 828a 	bne.w	a792 <HAL_DMA_Init+0x6ce>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a27e:	68eb      	ldr	r3, [r5, #12]
    a280:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    a284:	f040 8136 	bne.w	a4f4 <HAL_DMA_Init+0x430>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a288:	692b      	ldr	r3, [r5, #16]
    a28a:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
    a28e:	f040 8124 	bne.w	a4da <HAL_DMA_Init+0x416>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a292:	696b      	ldr	r3, [r5, #20]
    a294:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
    a298:	d003      	beq.n	a2a2 <HAL_DMA_Init+0x1de>
    a29a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    a29e:	f040 8285 	bne.w	a7ac <HAL_DMA_Init+0x6e8>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    a2a2:	69ab      	ldr	r3, [r5, #24]
    a2a4:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
    a2a8:	d003      	beq.n	a2b2 <HAL_DMA_Init+0x1ee>
    a2aa:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    a2ae:	f040 828a 	bne.w	a7c6 <HAL_DMA_Init+0x702>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
    a2b2:	69ea      	ldr	r2, [r5, #28]
    a2b4:	f032 0320 	bics.w	r3, r2, #32
    a2b8:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
    a2bc:	bf14      	ite	ne
    a2be:	2301      	movne	r3, #1
    a2c0:	2300      	moveq	r3, #0
    a2c2:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
    a2c6:	bf0c      	ite	eq
    a2c8:	2300      	moveq	r3, #0
    a2ca:	f003 0301 	andne.w	r3, r3, #1
    a2ce:	b11b      	cbz	r3, a2d8 <HAL_DMA_Init+0x214>
    a2d0:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    a2d4:	f040 827f 	bne.w	a7d6 <HAL_DMA_Init+0x712>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    a2d8:	6a2b      	ldr	r3, [r5, #32]
    a2da:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
    a2de:	f040 829c 	bne.w	a81a <HAL_DMA_Init+0x756>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a2e2:	2310      	movs	r3, #16
    a2e4:	2128      	movs	r1, #40	; 0x28
    a2e6:	682a      	ldr	r2, [r5, #0]
    a2e8:	2040      	movs	r0, #64	; 0x40
    a2ea:	f2c4 0302 	movt	r3, #16386	; 0x4002
    a2ee:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a2f2:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a2f6:	2670      	movs	r6, #112	; 0x70
    a2f8:	428a      	cmp	r2, r1
    a2fa:	bf18      	it	ne
    a2fc:	429a      	cmpne	r2, r3
    a2fe:	f04f 0158 	mov.w	r1, #88	; 0x58
    a302:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a306:	bf0c      	ite	eq
    a308:	2301      	moveq	r3, #1
    a30a:	2300      	movne	r3, #0
    a30c:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a310:	4282      	cmp	r2, r0
    a312:	bf08      	it	eq
    a314:	f043 0301 	orreq.w	r3, r3, #1
    a318:	20a0      	movs	r0, #160	; 0xa0
    a31a:	428a      	cmp	r2, r1
    a31c:	bf08      	it	eq
    a31e:	f043 0301 	orreq.w	r3, r3, #1
    a322:	2188      	movs	r1, #136	; 0x88
    a324:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a328:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a32c:	42b2      	cmp	r2, r6
    a32e:	bf08      	it	eq
    a330:	f043 0301 	orreq.w	r3, r3, #1
    a334:	f44f 6682 	mov.w	r6, #1040	; 0x410
    a338:	428a      	cmp	r2, r1
    a33a:	bf08      	it	eq
    a33c:	f043 0301 	orreq.w	r3, r3, #1
    a340:	21b8      	movs	r1, #184	; 0xb8
    a342:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a346:	4282      	cmp	r2, r0
    a348:	bf08      	it	eq
    a34a:	f043 0301 	orreq.w	r3, r3, #1
    a34e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a352:	f44f 6088 	mov.w	r0, #1088	; 0x440
    a356:	428a      	cmp	r2, r1
    a358:	bf08      	it	eq
    a35a:	f043 0301 	orreq.w	r3, r3, #1
    a35e:	f44f 6185 	mov.w	r1, #1064	; 0x428
    a362:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a366:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a36a:	42b2      	cmp	r2, r6
    a36c:	bf08      	it	eq
    a36e:	f043 0301 	orreq.w	r3, r3, #1
    a372:	f44f 668e 	mov.w	r6, #1136	; 0x470
    a376:	428a      	cmp	r2, r1
    a378:	bf08      	it	eq
    a37a:	f043 0301 	orreq.w	r3, r3, #1
    a37e:	f44f 618b 	mov.w	r1, #1112	; 0x458
    a382:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a386:	4282      	cmp	r2, r0
    a388:	bf08      	it	eq
    a38a:	f043 0301 	orreq.w	r3, r3, #1
    a38e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a392:	f44f 6091 	mov.w	r0, #1160	; 0x488
    a396:	428a      	cmp	r2, r1
    a398:	bf08      	it	eq
    a39a:	f043 0301 	orreq.w	r3, r3, #1
    a39e:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
    a3a2:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a3a6:	42b2      	cmp	r2, r6
    a3a8:	bf08      	it	eq
    a3aa:	f043 0301 	orreq.w	r3, r3, #1
    a3ae:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a3b2:	4282      	cmp	r2, r0
    a3b4:	bf08      	it	eq
    a3b6:	f043 0301 	orreq.w	r3, r3, #1
    a3ba:	428a      	cmp	r2, r1
    a3bc:	bf08      	it	eq
    a3be:	f043 0301 	orreq.w	r3, r3, #1
    a3c2:	b933      	cbnz	r3, a3d2 <HAL_DMA_Init+0x30e>
    a3c4:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    a3c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    a3cc:	429a      	cmp	r2, r3
    a3ce:	f040 82b0 	bne.w	a932 <HAL_DMA_Init+0x86e>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
    a3d2:	686b      	ldr	r3, [r5, #4]
    a3d4:	2b73      	cmp	r3, #115	; 0x73
    a3d6:	f200 809a 	bhi.w	a50e <HAL_DMA_Init+0x44a>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    a3da:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a3dc:	f033 0204 	bics.w	r2, r3, #4
    a3e0:	f040 80a1 	bne.w	a526 <HAL_DMA_Init+0x462>
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    a3e4:	b16b      	cbz	r3, a402 <HAL_DMA_Init+0x33e>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    a3e6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    a3e8:	2b03      	cmp	r3, #3
    a3ea:	f200 820e 	bhi.w	a80a <HAL_DMA_Init+0x746>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    a3ee:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    a3f0:	f033 73c0 	bics.w	r3, r3, #25165824	; 0x1800000
    a3f4:	f040 8272 	bne.w	a8dc <HAL_DMA_Init+0x818>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    a3f8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    a3fa:	f433 03c0 	bics.w	r3, r3, #6291456	; 0x600000
    a3fe:	f040 81f2 	bne.w	a7e6 <HAL_DMA_Init+0x722>
    __HAL_DMA_DISABLE(hdma);
    a402:	682a      	ldr	r2, [r5, #0]
    __HAL_UNLOCK(hdma);
    a404:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_BUSY;
    a406:	2102      	movs	r1, #2
    __HAL_UNLOCK(hdma);
    a408:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
    a40c:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
    a410:	6813      	ldr	r3, [r2, #0]
    a412:	f023 0301 	bic.w	r3, r3, #1
    a416:	6013      	str	r3, [r2, #0]
    a418:	e005      	b.n	a426 <HAL_DMA_Init+0x362>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
    a41a:	f7fe f811 	bl	8440 <HAL_GetTick>
    a41e:	1b00      	subs	r0, r0, r4
    a420:	2805      	cmp	r0, #5
    a422:	f200 81ab 	bhi.w	a77c <HAL_DMA_Init+0x6b8>
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
    a426:	682b      	ldr	r3, [r5, #0]
    a428:	681a      	ldr	r2, [r3, #0]
    a42a:	07d0      	lsls	r0, r2, #31
    a42c:	d4f5      	bmi.n	a41a <HAL_DMA_Init+0x356>
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a42e:	e9d5 2403 	ldrd	r2, r4, [r5, #12]
    registerValue |=  hdma->Init.Direction           |
    a432:	68a9      	ldr	r1, [r5, #8]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    a434:	f248 003f 	movw	r0, #32831	; 0x803f
    registerValue |=  hdma->Init.Direction           |
    a438:	430a      	orrs	r2, r1
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a43a:	6969      	ldr	r1, [r5, #20]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    a43c:	f6cf 6010 	movt	r0, #65040	; 0xfe10
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a440:	4322      	orrs	r2, r4
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a442:	69ac      	ldr	r4, [r5, #24]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a444:	430a      	orrs	r2, r1
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a446:	69e9      	ldr	r1, [r5, #28]
    a448:	4322      	orrs	r2, r4
            hdma->Init.Mode                | hdma->Init.Priority;
    a44a:	6a2c      	ldr	r4, [r5, #32]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a44c:	430a      	orrs	r2, r1
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
    a44e:	6819      	ldr	r1, [r3, #0]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    a450:	4008      	ands	r0, r1
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a452:	6a69      	ldr	r1, [r5, #36]	; 0x24
            hdma->Init.Mode                | hdma->Init.Priority;
    a454:	4322      	orrs	r2, r4
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a456:	2904      	cmp	r1, #4
    registerValue |=  hdma->Init.Direction           |
    a458:	ea42 0200 	orr.w	r2, r2, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a45c:	d103      	bne.n	a466 <HAL_DMA_Init+0x3a2>
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
    a45e:	e9d5 100b 	ldrd	r1, r0, [r5, #44]	; 0x2c
    a462:	4301      	orrs	r1, r0
    a464:	430a      	orrs	r2, r1
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
    a466:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    a46a:	2100      	movs	r1, #0
    a46c:	f6c5 4000 	movt	r0, #23552	; 0x5c00
    a470:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    a474:	6800      	ldr	r0, [r0, #0]
    a476:	4001      	ands	r1, r0
    a478:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    a47c:	d30a      	bcc.n	a494 <HAL_DMA_Init+0x3d0>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
    a47e:	6868      	ldr	r0, [r5, #4]
    a480:	f1a0 0429 	sub.w	r4, r0, #41	; 0x29
    a484:	2c1f      	cmp	r4, #31
    a486:	f240 81b6 	bls.w	a7f6 <HAL_DMA_Init+0x732>
    a48a:	384f      	subs	r0, #79	; 0x4f
    a48c:	2803      	cmp	r0, #3
    a48e:	d801      	bhi.n	a494 <HAL_DMA_Init+0x3d0>
        registerValue |= DMA_SxCR_TRBUFF;
    a490:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
    a494:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
    a496:	6829      	ldr	r1, [r5, #0]
    registerValue |= hdma->Init.FIFOMode;
    a498:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
    a49a:	694b      	ldr	r3, [r1, #20]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a49c:	2a04      	cmp	r2, #4
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    a49e:	f023 0307 	bic.w	r3, r3, #7
    registerValue |= hdma->Init.FIFOMode;
    a4a2:	ea43 0302 	orr.w	r3, r3, r2
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a4a6:	d150      	bne.n	a54a <HAL_DMA_Init+0x486>
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    a4a8:	e9d5 200a 	ldrd	r2, r0, [r5, #40]	; 0x28
      registerValue |= hdma->Init.FIFOThreshold;
    a4ac:	4313      	orrs	r3, r2
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    a4ae:	2800      	cmp	r0, #0
    a4b0:	d04b      	beq.n	a54a <HAL_DMA_Init+0x486>
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
    a4b2:	69ac      	ldr	r4, [r5, #24]
    a4b4:	2c00      	cmp	r4, #0
    a4b6:	d042      	beq.n	a53e <HAL_DMA_Init+0x47a>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    a4b8:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
    a4bc:	f000 82ba 	beq.w	aa34 <HAL_DMA_Init+0x970>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
    a4c0:	2a02      	cmp	r2, #2
    a4c2:	d903      	bls.n	a4cc <HAL_DMA_Init+0x408>
    a4c4:	2a03      	cmp	r2, #3
    a4c6:	d140      	bne.n	a54a <HAL_DMA_Init+0x486>
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;

      case DMA_FIFO_THRESHOLD_FULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
    a4c8:	01c2      	lsls	r2, r0, #7
    a4ca:	d53e      	bpl.n	a54a <HAL_DMA_Init+0x486>
          hdma->State = HAL_DMA_STATE_READY;
    a4cc:	2301      	movs	r3, #1
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a4ce:	2240      	movs	r2, #64	; 0x40
          return HAL_ERROR;
    a4d0:	4618      	mov	r0, r3
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a4d2:	656a      	str	r2, [r5, #84]	; 0x54
          hdma->State = HAL_DMA_STATE_READY;
    a4d4:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
          return HAL_ERROR;
    a4d8:	e14e      	b.n	a778 <HAL_DMA_Init+0x6b4>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a4da:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a4de:	21e4      	movs	r1, #228	; 0xe4
    a4e0:	f2c0 0003 	movt	r0, #3
    a4e4:	f010 fde4 	bl	1b0b0 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a4e8:	696b      	ldr	r3, [r5, #20]
    a4ea:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
    a4ee:	f47f aed4 	bne.w	a29a <HAL_DMA_Init+0x1d6>
    a4f2:	e6d6      	b.n	a2a2 <HAL_DMA_Init+0x1de>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a4f4:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a4f8:	21e3      	movs	r1, #227	; 0xe3
    a4fa:	f2c0 0003 	movt	r0, #3
    a4fe:	f010 fdd7 	bl	1b0b0 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a502:	692b      	ldr	r3, [r5, #16]
    a504:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
    a508:	f43f aec3 	beq.w	a292 <HAL_DMA_Init+0x1ce>
    a50c:	e7e5      	b.n	a4da <HAL_DMA_Init+0x416>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
    a50e:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a512:	21ec      	movs	r1, #236	; 0xec
    a514:	f2c0 0003 	movt	r0, #3
    a518:	f010 fdca 	bl	1b0b0 <assert_failed>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    a51c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a51e:	f033 0204 	bics.w	r2, r3, #4
    a522:	f43f af5f 	beq.w	a3e4 <HAL_DMA_Init+0x320>
    a526:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a52a:	21ed      	movs	r1, #237	; 0xed
    a52c:	f2c0 0003 	movt	r0, #3
    a530:	f010 fdbe 	bl	1b0b0 <assert_failed>
    a534:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    a536:	2b00      	cmp	r3, #0
    a538:	f43f af63 	beq.w	a402 <HAL_DMA_Init+0x33e>
    a53c:	e753      	b.n	a3e6 <HAL_DMA_Init+0x322>
    switch (hdma->Init.FIFOThreshold)
    a53e:	2a01      	cmp	r2, #1
    a540:	f000 8273 	beq.w	aa2a <HAL_DMA_Init+0x966>
    a544:	d3c0      	bcc.n	a4c8 <HAL_DMA_Init+0x404>
    a546:	2a02      	cmp	r2, #2
    a548:	d0be      	beq.n	a4c8 <HAL_DMA_Init+0x404>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
    a54a:	614b      	str	r3, [r1, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a54c:	4628      	mov	r0, r5
    a54e:	f7ff fd1f 	bl	9f90 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    a552:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    a554:	233f      	movs	r3, #63	; 0x3f
    a556:	f002 021f 	and.w	r2, r2, #31
    a55a:	4093      	lsls	r3, r2
    a55c:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    a55e:	2310      	movs	r3, #16
    a560:	2028      	movs	r0, #40	; 0x28
    a562:	682a      	ldr	r2, [r5, #0]
    a564:	2740      	movs	r7, #64	; 0x40
    a566:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a56a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    a56e:	f2c4 0702 	movt	r7, #16386	; 0x4002
    a572:	2658      	movs	r6, #88	; 0x58
    a574:	4282      	cmp	r2, r0
    a576:	bf18      	it	ne
    a578:	429a      	cmpne	r2, r3
    a57a:	f04f 0470 	mov.w	r4, #112	; 0x70
    a57e:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a582:	f04f 0188 	mov.w	r1, #136	; 0x88
    a586:	bf0c      	ite	eq
    a588:	2001      	moveq	r0, #1
    a58a:	2000      	movne	r0, #0
    a58c:	f2c4 0402 	movt	r4, #16386	; 0x4002
    a590:	f2c4 0102 	movt	r1, #16386	; 0x4002
    a594:	42ba      	cmp	r2, r7
    a596:	bf08      	it	eq
    a598:	f040 0001 	orreq.w	r0, r0, #1
    a59c:	f04f 0ea0 	mov.w	lr, #160	; 0xa0
    a5a0:	f04f 0cb8 	mov.w	ip, #184	; 0xb8
    a5a4:	f44f 6782 	mov.w	r7, #1040	; 0x410
    a5a8:	42b2      	cmp	r2, r6
    a5aa:	bf08      	it	eq
    a5ac:	f040 0001 	orreq.w	r0, r0, #1
    a5b0:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    a5b4:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    a5b8:	f2c4 0702 	movt	r7, #16386	; 0x4002
    a5bc:	42a2      	cmp	r2, r4
    a5be:	bf08      	it	eq
    a5c0:	f040 0001 	orreq.w	r0, r0, #1
    a5c4:	f44f 6685 	mov.w	r6, #1064	; 0x428
    a5c8:	f44f 6488 	mov.w	r4, #1088	; 0x440
    a5cc:	f44f 638b 	mov.w	r3, #1112	; 0x458
    a5d0:	428a      	cmp	r2, r1
    a5d2:	bf14      	ite	ne
    a5d4:	4601      	movne	r1, r0
    a5d6:	f040 0101 	orreq.w	r1, r0, #1
    a5da:	f2c4 0602 	movt	r6, #16386	; 0x4002
    a5de:	f2c4 0402 	movt	r4, #16386	; 0x4002
    a5e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    a5e6:	4572      	cmp	r2, lr
    a5e8:	bf08      	it	eq
    a5ea:	f041 0101 	orreq.w	r1, r1, #1
    a5ee:	f44f 608e 	mov.w	r0, #1136	; 0x470
    a5f2:	f44f 6991 	mov.w	r9, #1160	; 0x488
    a5f6:	f245 4e08 	movw	lr, #21512	; 0x5408
    a5fa:	4562      	cmp	r2, ip
    a5fc:	bf08      	it	eq
    a5fe:	f041 0101 	orreq.w	r1, r1, #1
    a602:	f2c4 0002 	movt	r0, #16386	; 0x4002
    a606:	f44f 6894 	mov.w	r8, #1184	; 0x4a0
    a60a:	f2c4 0902 	movt	r9, #16386	; 0x4002
    a60e:	42ba      	cmp	r2, r7
    a610:	bf08      	it	eq
    a612:	f041 0101 	orreq.w	r1, r1, #1
    a616:	f6c5 0e02 	movt	lr, #22530	; 0x5802
    a61a:	f245 471c 	movw	r7, #21532	; 0x541c
    a61e:	f2c4 0802 	movt	r8, #16386	; 0x4002
    a622:	42b2      	cmp	r2, r6
    a624:	bf08      	it	eq
    a626:	f041 0101 	orreq.w	r1, r1, #1
    a62a:	f44f 6c97 	mov.w	ip, #1208	; 0x4b8
    a62e:	f6c5 0702 	movt	r7, #22530	; 0x5802
    a632:	f245 4630 	movw	r6, #21552	; 0x5430
    a636:	42a2      	cmp	r2, r4
    a638:	bf08      	it	eq
    a63a:	f041 0101 	orreq.w	r1, r1, #1
    a63e:	eba2 0e0e 	sub.w	lr, r2, lr
    a642:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    a646:	1bd7      	subs	r7, r2, r7
    a648:	429a      	cmp	r2, r3
    a64a:	bf14      	ite	ne
    a64c:	460b      	movne	r3, r1
    a64e:	f041 0301 	orreq.w	r3, r1, #1
    a652:	fabe fe8e 	clz	lr, lr
    a656:	f6c5 0602 	movt	r6, #22530	; 0x5802
    a65a:	f245 4444 	movw	r4, #21572	; 0x5444
    a65e:	4282      	cmp	r2, r0
    a660:	bf08      	it	eq
    a662:	f043 0301 	orreq.w	r3, r3, #1
    a666:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
    a66a:	fab7 f787 	clz	r7, r7
    a66e:	1b96      	subs	r6, r2, r6
    a670:	454a      	cmp	r2, r9
    a672:	bf08      	it	eq
    a674:	f043 0301 	orreq.w	r3, r3, #1
    a678:	f245 4058 	movw	r0, #21592	; 0x5458
    a67c:	f6c5 0402 	movt	r4, #22530	; 0x5802
    a680:	097f      	lsrs	r7, r7, #5
    a682:	4542      	cmp	r2, r8
    a684:	bf08      	it	eq
    a686:	f043 0301 	orreq.w	r3, r3, #1
    a68a:	fab6 f686 	clz	r6, r6
    a68e:	f6c5 0002 	movt	r0, #22530	; 0x5802
    a692:	f245 416c 	movw	r1, #21612	; 0x546c
    a696:	4562      	cmp	r2, ip
    a698:	bf08      	it	eq
    a69a:	f043 0301 	orreq.w	r3, r3, #1
    a69e:	1b14      	subs	r4, r2, r4
    a6a0:	0976      	lsrs	r6, r6, #5
    a6a2:	1a10      	subs	r0, r2, r0
    a6a4:	ea4e 0303 	orr.w	r3, lr, r3
    a6a8:	fab4 f484 	clz	r4, r4
    a6ac:	f6c5 0102 	movt	r1, #22530	; 0x5802
    a6b0:	f44f 4ca9 	mov.w	ip, #21632	; 0x5480
    a6b4:	433b      	orrs	r3, r7
    a6b6:	0964      	lsrs	r4, r4, #5
    a6b8:	fab0 f080 	clz	r0, r0
    a6bc:	1a51      	subs	r1, r2, r1
    a6be:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    a6c2:	4333      	orrs	r3, r6
    a6c4:	0940      	lsrs	r0, r0, #5
    a6c6:	fab1 f181 	clz	r1, r1
    a6ca:	f245 4894 	movw	r8, #21652	; 0x5494
    a6ce:	eba2 0c0c 	sub.w	ip, r2, ip
    a6d2:	4323      	orrs	r3, r4
    a6d4:	0949      	lsrs	r1, r1, #5
    a6d6:	f6c5 0802 	movt	r8, #22530	; 0x5802
    a6da:	fabc fc8c 	clz	ip, ip
    a6de:	4303      	orrs	r3, r0
    a6e0:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    a6e4:	eba2 0808 	sub.w	r8, r2, r8
    a6e8:	430b      	orrs	r3, r1
    a6ea:	fab8 f888 	clz	r8, r8
    a6ee:	ea5c 0303 	orrs.w	r3, ip, r3
    a6f2:	ea4f 1858 	mov.w	r8, r8, lsr #5
    a6f6:	d102      	bne.n	a6fe <HAL_DMA_Init+0x63a>
    a6f8:	f1b8 0f00 	cmp.w	r8, #0
    a6fc:	d037      	beq.n	a76e <HAL_DMA_Init+0x6aa>
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a6fe:	ea47 070e 	orr.w	r7, r7, lr
    a702:	b2d3      	uxtb	r3, r2
    a704:	433e      	orrs	r6, r7
    a706:	4334      	orrs	r4, r6
    a708:	4320      	orrs	r0, r4
    a70a:	4301      	orrs	r1, r0
    a70c:	ea5c 0101 	orrs.w	r1, ip, r1
    a710:	d103      	bne.n	a71a <HAL_DMA_Init+0x656>
    a712:	f1b8 0f00 	cmp.w	r8, #0
    a716:	f000 80e9 	beq.w	a8ec <HAL_DMA_Init+0x828>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a71a:	f64c 44cd 	movw	r4, #52429	; 0xcccd
    a71e:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a720:	f44f 4216 	mov.w	r2, #38400	; 0x9600
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a724:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a726:	f6cc 44cc 	movt	r4, #52428	; 0xcccc
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a72a:	f44f 40b1 	mov.w	r0, #22656	; 0x5880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a72e:	f2c1 6200 	movt	r2, #5632	; 0x1600
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a732:	fba4 4303 	umull	r4, r3, r4, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a736:	f6c5 0002 	movt	r0, #22530	; 0x5802
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a73a:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a73c:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a73e:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a740:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a744:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a746:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a74a:	662a      	str	r2, [r5, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a74c:	66ab      	str	r3, [r5, #104]	; 0x68
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
    a74e:	68ab      	ldr	r3, [r5, #8]
    a750:	2b80      	cmp	r3, #128	; 0x80
    a752:	d06a      	beq.n	a82a <HAL_DMA_Init+0x766>
    a754:	792b      	ldrb	r3, [r5, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
    a756:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    a758:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	; 0x64
    a75c:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
    a75e:	6868      	ldr	r0, [r5, #4]
    a760:	1e41      	subs	r1, r0, #1
    a762:	2907      	cmp	r1, #7
    a764:	d965      	bls.n	a832 <HAL_DMA_Init+0x76e>
      hdma->DMAmuxRequestGen = 0U;
    a766:	2300      	movs	r3, #0
      hdma->DMAmuxRequestGenStatus = 0U;
    a768:	e9c5 331b 	strd	r3, r3, [r5, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
    a76c:	676b      	str	r3, [r5, #116]	; 0x74
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a76e:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
    a770:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a772:	6568      	str	r0, [r5, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
    a774:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
    a778:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    a77c:	2220      	movs	r2, #32
        hdma->State = HAL_DMA_STATE_ERROR;
    a77e:	2303      	movs	r3, #3
        return HAL_ERROR;
    a780:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    a782:	656a      	str	r2, [r5, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
    a784:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
    a788:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return HAL_ERROR;
    a78c:	2001      	movs	r0, #1
}
    a78e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    a792:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a796:	21e2      	movs	r1, #226	; 0xe2
    a798:	f2c0 0003 	movt	r0, #3
    a79c:	f010 fc88 	bl	1b0b0 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a7a0:	68eb      	ldr	r3, [r5, #12]
    a7a2:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    a7a6:	f43f ad6f 	beq.w	a288 <HAL_DMA_Init+0x1c4>
    a7aa:	e6a3      	b.n	a4f4 <HAL_DMA_Init+0x430>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a7ac:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a7b0:	21e5      	movs	r1, #229	; 0xe5
    a7b2:	f2c0 0003 	movt	r0, #3
    a7b6:	f010 fc7b 	bl	1b0b0 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    a7ba:	69ab      	ldr	r3, [r5, #24]
    a7bc:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
    a7c0:	f47f ad73 	bne.w	a2aa <HAL_DMA_Init+0x1e6>
    a7c4:	e575      	b.n	a2b2 <HAL_DMA_Init+0x1ee>
    a7c6:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a7ca:	21e6      	movs	r1, #230	; 0xe6
    a7cc:	f2c0 0003 	movt	r0, #3
    a7d0:	f010 fc6e 	bl	1b0b0 <assert_failed>
    a7d4:	e56d      	b.n	a2b2 <HAL_DMA_Init+0x1ee>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
    a7d6:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a7da:	21e7      	movs	r1, #231	; 0xe7
    a7dc:	f2c0 0003 	movt	r0, #3
    a7e0:	f010 fc66 	bl	1b0b0 <assert_failed>
    a7e4:	e578      	b.n	a2d8 <HAL_DMA_Init+0x214>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    a7e6:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a7ea:	21f4      	movs	r1, #244	; 0xf4
    a7ec:	f2c0 0003 	movt	r0, #3
    a7f0:	f010 fc5e 	bl	1b0b0 <assert_failed>
    a7f4:	e605      	b.n	a402 <HAL_DMA_Init+0x33e>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
    a7f6:	213f      	movs	r1, #63	; 0x3f
    a7f8:	f2cc 31c0 	movt	r1, #50112	; 0xc3c0
    a7fc:	40e1      	lsrs	r1, r4
    a7fe:	07c9      	lsls	r1, r1, #31
    a800:	f57f ae43 	bpl.w	a48a <HAL_DMA_Init+0x3c6>
        registerValue |= DMA_SxCR_TRBUFF;
    a804:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    a808:	e644      	b.n	a494 <HAL_DMA_Init+0x3d0>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    a80a:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a80e:	21f2      	movs	r1, #242	; 0xf2
    a810:	f2c0 0003 	movt	r0, #3
    a814:	f010 fc4c 	bl	1b0b0 <assert_failed>
    a818:	e5e9      	b.n	a3ee <HAL_DMA_Init+0x32a>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    a81a:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a81e:	21e8      	movs	r1, #232	; 0xe8
    a820:	f2c0 0003 	movt	r0, #3
    a824:	f010 fc44 	bl	1b0b0 <assert_failed>
    a828:	e55b      	b.n	a2e2 <HAL_DMA_Init+0x21e>
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
    a82a:	2100      	movs	r1, #0
    a82c:	460b      	mov	r3, r1
    a82e:	6069      	str	r1, [r5, #4]
    a830:	e791      	b.n	a756 <HAL_DMA_Init+0x692>
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a832:	f245 4308 	movw	r3, #21512	; 0x5408
    a836:	f245 441c 	movw	r4, #21532	; 0x541c
    a83a:	682a      	ldr	r2, [r5, #0]
    a83c:	f245 4630 	movw	r6, #21552	; 0x5430
    a840:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a844:	f6c5 0402 	movt	r4, #22530	; 0x5802
    a848:	f6c5 0602 	movt	r6, #22530	; 0x5802
    a84c:	f245 4758 	movw	r7, #21592	; 0x5458
    a850:	42a2      	cmp	r2, r4
    a852:	bf18      	it	ne
    a854:	429a      	cmpne	r2, r3
    a856:	f245 4444 	movw	r4, #21572	; 0x5444
    a85a:	f6c5 0702 	movt	r7, #22530	; 0x5802
    a85e:	bf0c      	ite	eq
    a860:	2301      	moveq	r3, #1
    a862:	2300      	movne	r3, #0
    a864:	f6c5 0402 	movt	r4, #22530	; 0x5802
    a868:	42b2      	cmp	r2, r6
    a86a:	bf08      	it	eq
    a86c:	f043 0301 	orreq.w	r3, r3, #1
    a870:	f245 466c 	movw	r6, #21612	; 0x546c
    a874:	42a2      	cmp	r2, r4
    a876:	bf08      	it	eq
    a878:	f043 0301 	orreq.w	r3, r3, #1
    a87c:	f6c5 0602 	movt	r6, #22530	; 0x5802
    a880:	f44f 44a9 	mov.w	r4, #21632	; 0x5480
    a884:	42ba      	cmp	r2, r7
    a886:	bf08      	it	eq
    a888:	f043 0301 	orreq.w	r3, r3, #1
    a88c:	f6c5 0402 	movt	r4, #22530	; 0x5802
    a890:	42b2      	cmp	r2, r6
    a892:	bf08      	it	eq
    a894:	f043 0301 	orreq.w	r3, r3, #1
    a898:	42a2      	cmp	r2, r4
    a89a:	bf08      	it	eq
    a89c:	f043 0301 	orreq.w	r3, r3, #1
    a8a0:	b933      	cbnz	r3, a8b0 <HAL_DMA_Init+0x7ec>
    a8a2:	f245 4394 	movw	r3, #21652	; 0x5494
    a8a6:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a8aa:	429a      	cmp	r2, r3
    a8ac:	f040 80d0 	bne.w	aa50 <HAL_DMA_Init+0x98c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a8b0:	f249 633f 	movw	r3, #38463	; 0x963f

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    a8b4:	f645 1440 	movw	r4, #22848	; 0x5940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a8b8:	f2c1 6300 	movt	r3, #5632	; 0x1600
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    a8bc:	f6c5 0402 	movt	r4, #22530	; 0x5802
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a8c0:	4403      	add	r3, r0
    a8c2:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a8c4:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a8c6:	2000      	movs	r0, #0
    a8c8:	672c      	str	r4, [r5, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a8ca:	fa02 f101 	lsl.w	r1, r2, r1
    a8ce:	66eb      	str	r3, [r5, #108]	; 0x6c
    a8d0:	6769      	str	r1, [r5, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a8d2:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    a8d4:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	; 0x70
    a8d8:	605a      	str	r2, [r3, #4]
    a8da:	e748      	b.n	a76e <HAL_DMA_Init+0x6aa>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    a8dc:	f243 60fc 	movw	r0, #14076	; 0x36fc
    a8e0:	21f3      	movs	r1, #243	; 0xf3
    a8e2:	f2c0 0003 	movt	r0, #3
    a8e6:	f010 fbe3 	bl	1b0b0 <assert_failed>
    a8ea:	e585      	b.n	a3f8 <HAL_DMA_Init+0x334>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a8ec:	f64f 31f0 	movw	r1, #64496	; 0xfbf0
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a8f0:	f64a 20ab 	movw	r0, #43691	; 0xaaab
    a8f4:	3b10      	subs	r3, #16
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a8f6:	f6cb 71fd 	movt	r1, #49149	; 0xbffd
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a8fa:	f6ca 20aa 	movt	r0, #43690	; 0xaaaa
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a8fe:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a900:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a904:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a906:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a90a:	d800      	bhi.n	a90e <HAL_DMA_Init+0x84a>
      stream_number += 8U;
    a90c:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a90e:	f44f 4202 	mov.w	r2, #33280	; 0x8200
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a912:	f003 041f 	and.w	r4, r3, #31
    a916:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a918:	f44f 6008 	mov.w	r0, #2176	; 0x880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a91c:	f2c1 0200 	movt	r2, #4096	; 0x1000
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a920:	40a1      	lsls	r1, r4
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a922:	f2c4 0002 	movt	r0, #16386	; 0x4002
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a926:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a928:	66a9      	str	r1, [r5, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a92a:	0092      	lsls	r2, r2, #2
    a92c:	e9c5 2018 	strd	r2, r0, [r5, #96]	; 0x60
    a930:	e70d      	b.n	a74e <HAL_DMA_Init+0x68a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    a932:	f245 4308 	movw	r3, #21512	; 0x5408
    a936:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a93a:	429a      	cmp	r2, r3
    a93c:	d032      	beq.n	a9a4 <HAL_DMA_Init+0x8e0>
    a93e:	f245 431c 	movw	r3, #21532	; 0x541c
    a942:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a946:	429a      	cmp	r2, r3
    a948:	d02c      	beq.n	a9a4 <HAL_DMA_Init+0x8e0>
    a94a:	f245 4330 	movw	r3, #21552	; 0x5430
    a94e:	f245 4144 	movw	r1, #21572	; 0x5444
    a952:	f245 4458 	movw	r4, #21592	; 0x5458
    a956:	f245 406c 	movw	r0, #21612	; 0x546c
    a95a:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a95e:	f6c5 0102 	movt	r1, #22530	; 0x5802
    a962:	f6c5 0402 	movt	r4, #22530	; 0x5802
    a966:	f6c5 0002 	movt	r0, #22530	; 0x5802
    a96a:	428a      	cmp	r2, r1
    a96c:	bf18      	it	ne
    a96e:	429a      	cmpne	r2, r3
    a970:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
    a974:	bf0c      	ite	eq
    a976:	2301      	moveq	r3, #1
    a978:	2300      	movne	r3, #0
    a97a:	f6c5 0102 	movt	r1, #22530	; 0x5802
    a97e:	42a2      	cmp	r2, r4
    a980:	bf08      	it	eq
    a982:	f043 0301 	orreq.w	r3, r3, #1
    a986:	4282      	cmp	r2, r0
    a988:	bf08      	it	eq
    a98a:	f043 0301 	orreq.w	r3, r3, #1
    a98e:	428a      	cmp	r2, r1
    a990:	bf08      	it	eq
    a992:	f043 0301 	orreq.w	r3, r3, #1
    a996:	b92b      	cbnz	r3, a9a4 <HAL_DMA_Init+0x8e0>
    a998:	f245 4394 	movw	r3, #21652	; 0x5494
    a99c:	f6c5 0302 	movt	r3, #22530	; 0x5802
    a9a0:	429a      	cmp	r2, r3
    a9a2:	d16c      	bne.n	aa7e <HAL_DMA_Init+0x9ba>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    a9a4:	686b      	ldr	r3, [r5, #4]
    a9a6:	2b11      	cmp	r3, #17
    a9a8:	d85f      	bhi.n	aa6a <HAL_DMA_Init+0x9a6>
    hdma->State = HAL_DMA_STATE_BUSY;
    a9aa:	2102      	movs	r1, #2
    __HAL_UNLOCK(hdma);
    a9ac:	2400      	movs	r4, #0
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a9ae:	200f      	movs	r0, #15
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a9b0:	68ab      	ldr	r3, [r5, #8]
    __HAL_UNLOCK(hdma);
    a9b2:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
    a9b6:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a9ba:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
    a9be:	6811      	ldr	r1, [r2, #0]
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a9c0:	2b40      	cmp	r3, #64	; 0x40
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a9c2:	ea00 0001 	and.w	r0, r0, r1
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a9c6:	d04e      	beq.n	aa66 <HAL_DMA_Init+0x9a2>
    a9c8:	2b80      	cmp	r3, #128	; 0x80
    a9ca:	bf08      	it	eq
    a9cc:	f44f 4480 	moveq.w	r4, #16384	; 0x4000
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
    a9d0:	692b      	ldr	r3, [r5, #16]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a9d2:	f64a 31f8 	movw	r1, #44024	; 0xabf8
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
    a9d6:	68ee      	ldr	r6, [r5, #12]
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
    a9d8:	08db      	lsrs	r3, r3, #3
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a9da:	f2ca 71fd 	movt	r1, #43005	; 0xa7fd
    a9de:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
    a9e2:	696e      	ldr	r6, [r5, #20]
    a9e4:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
    a9e8:	69ae      	ldr	r6, [r5, #24]
    a9ea:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
    a9ee:	69ee      	ldr	r6, [r5, #28]
    a9f0:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
    a9f4:	6a2e      	ldr	r6, [r5, #32]
    a9f6:	ea43 1316 	orr.w	r3, r3, r6, lsr #4
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a9fa:	f64c 46cd 	movw	r6, #52429	; 0xcccd
    a9fe:	4303      	orrs	r3, r0
    aa00:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    aa04:	4628      	mov	r0, r5
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    aa06:	4323      	orrs	r3, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
    aa08:	6013      	str	r3, [r2, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    aa0a:	682b      	ldr	r3, [r5, #0]
    aa0c:	4419      	add	r1, r3
    aa0e:	fba6 2301 	umull	r2, r3, r6, r1
    aa12:	091b      	lsrs	r3, r3, #4
    aa14:	009b      	lsls	r3, r3, #2
    aa16:	65eb      	str	r3, [r5, #92]	; 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    aa18:	f7ff faba 	bl	9f90 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    aa1c:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    aa1e:	2301      	movs	r3, #1
    aa20:	f002 021f 	and.w	r2, r2, #31
    aa24:	4093      	lsls	r3, r2
    aa26:	6043      	str	r3, [r0, #4]
    aa28:	e599      	b.n	a55e <HAL_DMA_Init+0x49a>
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
    aa2a:	f1b0 7fc0 	cmp.w	r0, #25165824	; 0x1800000
    aa2e:	f47f ad8c 	bne.w	a54a <HAL_DMA_Init+0x486>
    aa32:	e54b      	b.n	a4cc <HAL_DMA_Init+0x408>
    switch (hdma->Init.FIFOThreshold)
    aa34:	2a03      	cmp	r2, #3
    aa36:	f63f ad88 	bhi.w	a54a <HAL_DMA_Init+0x486>
    aa3a:	a401      	add	r4, pc, #4	; (adr r4, aa40 <HAL_DMA_Init+0x97c>)
    aa3c:	f854 f022 	ldr.w	pc, [r4, r2, lsl #2]
    aa40:	0000a4cd 	.word	0x0000a4cd
    aa44:	0000a4c9 	.word	0x0000a4c9
    aa48:	0000a4cd 	.word	0x0000a4cd
    aa4c:	0000aa2b 	.word	0x0000aa2b
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa50:	f248 233f 	movw	r3, #33343	; 0x823f
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    aa54:	f44f 6414 	mov.w	r4, #2368	; 0x940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa58:	f2c1 0300 	movt	r3, #4096	; 0x1000
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    aa5c:	f2c4 0402 	movt	r4, #16386	; 0x4002
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa60:	4403      	add	r3, r0
    aa62:	009b      	lsls	r3, r3, #2
    aa64:	e72e      	b.n	a8c4 <HAL_DMA_Init+0x800>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    aa66:	2410      	movs	r4, #16
    aa68:	e7b2      	b.n	a9d0 <HAL_DMA_Init+0x90c>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    aa6a:	f243 60fc 	movw	r0, #14076	; 0x36fc
    aa6e:	f44f 71b3 	mov.w	r1, #358	; 0x166
    aa72:	f2c0 0003 	movt	r0, #3
    aa76:	f010 fb1b 	bl	1b0b0 <assert_failed>
    aa7a:	682a      	ldr	r2, [r5, #0]
    aa7c:	e795      	b.n	a9aa <HAL_DMA_Init+0x8e6>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    aa7e:	2240      	movs	r2, #64	; 0x40
    hdma->State     = HAL_DMA_STATE_ERROR;
    aa80:	2303      	movs	r3, #3
    return HAL_ERROR;
    aa82:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    aa84:	656a      	str	r2, [r5, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
    aa86:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    return HAL_ERROR;
    aa8a:	e675      	b.n	a778 <HAL_DMA_Init+0x6b4>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    aa8c:	f243 60fc 	movw	r0, #14076	; 0x36fc
    aa90:	21e1      	movs	r1, #225	; 0xe1
    aa92:	f2c0 0003 	movt	r0, #3
    aa96:	f010 fb0b 	bl	1b0b0 <assert_failed>
    aa9a:	f7ff bbe9 	b.w	a270 <HAL_DMA_Init+0x1ac>
    aa9e:	bf00      	nop

0000aaa0 <HAL_DMA_DeInit>:
  if(hdma == NULL)
    aaa0:	2800      	cmp	r0, #0
    aaa2:	f000 82b2 	beq.w	b00a <HAL_DMA_DeInit+0x56a>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    aaa6:	2140      	movs	r1, #64	; 0x40
{
    aaa8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_DMA_DISABLE(hdma);
    aaac:	6802      	ldr	r2, [r0, #0]
    aaae:	4604      	mov	r4, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    aab0:	2028      	movs	r0, #40	; 0x28
    aab2:	f2c4 0102 	movt	r1, #16386	; 0x4002
  __HAL_DMA_DISABLE(hdma);
    aab6:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    aab8:	2558      	movs	r5, #88	; 0x58
    aaba:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __HAL_DMA_DISABLE(hdma);
    aabe:	f023 0301 	bic.w	r3, r3, #1
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    aac2:	f2c4 0502 	movt	r5, #16386	; 0x4002
  __HAL_DMA_DISABLE(hdma);
    aac6:	6013      	str	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    aac8:	2310      	movs	r3, #16
    aaca:	6822      	ldr	r2, [r4, #0]
    aacc:	f2c4 0302 	movt	r3, #16386	; 0x4002
    aad0:	4282      	cmp	r2, r0
    aad2:	bf18      	it	ne
    aad4:	429a      	cmpne	r2, r3
    aad6:	f04f 0070 	mov.w	r0, #112	; 0x70
    aada:	bf0c      	ite	eq
    aadc:	2301      	moveq	r3, #1
    aade:	2300      	movne	r3, #0
    aae0:	f2c4 0002 	movt	r0, #16386	; 0x4002
    aae4:	428a      	cmp	r2, r1
    aae6:	bf08      	it	eq
    aae8:	f043 0301 	orreq.w	r3, r3, #1
    aaec:	2188      	movs	r1, #136	; 0x88
    aaee:	42aa      	cmp	r2, r5
    aaf0:	bf08      	it	eq
    aaf2:	f043 0301 	orreq.w	r3, r3, #1
    aaf6:	f2c4 0102 	movt	r1, #16386	; 0x4002
    aafa:	25a0      	movs	r5, #160	; 0xa0
    aafc:	4282      	cmp	r2, r0
    aafe:	bf08      	it	eq
    ab00:	f043 0301 	orreq.w	r3, r3, #1
    ab04:	20b8      	movs	r0, #184	; 0xb8
    ab06:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ab0a:	428a      	cmp	r2, r1
    ab0c:	bf08      	it	eq
    ab0e:	f043 0301 	orreq.w	r3, r3, #1
    ab12:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ab16:	f44f 6182 	mov.w	r1, #1040	; 0x410
    ab1a:	42aa      	cmp	r2, r5
    ab1c:	bf08      	it	eq
    ab1e:	f043 0301 	orreq.w	r3, r3, #1
    ab22:	f44f 6585 	mov.w	r5, #1064	; 0x428
    ab26:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ab2a:	4282      	cmp	r2, r0
    ab2c:	bf08      	it	eq
    ab2e:	f043 0301 	orreq.w	r3, r3, #1
    ab32:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ab36:	f44f 6088 	mov.w	r0, #1088	; 0x440
    ab3a:	428a      	cmp	r2, r1
    ab3c:	bf08      	it	eq
    ab3e:	f043 0301 	orreq.w	r3, r3, #1
    ab42:	f44f 618b 	mov.w	r1, #1112	; 0x458
    ab46:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ab4a:	42aa      	cmp	r2, r5
    ab4c:	bf08      	it	eq
    ab4e:	f043 0301 	orreq.w	r3, r3, #1
    ab52:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ab56:	f44f 658e 	mov.w	r5, #1136	; 0x470
    ab5a:	4282      	cmp	r2, r0
    ab5c:	bf08      	it	eq
    ab5e:	f043 0301 	orreq.w	r3, r3, #1
    ab62:	f44f 6091 	mov.w	r0, #1160	; 0x488
    ab66:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ab6a:	428a      	cmp	r2, r1
    ab6c:	bf08      	it	eq
    ab6e:	f043 0301 	orreq.w	r3, r3, #1
    ab72:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ab76:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
    ab7a:	42aa      	cmp	r2, r5
    ab7c:	bf08      	it	eq
    ab7e:	f043 0301 	orreq.w	r3, r3, #1
    ab82:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ab86:	4282      	cmp	r2, r0
    ab88:	bf08      	it	eq
    ab8a:	f043 0301 	orreq.w	r3, r3, #1
    ab8e:	428a      	cmp	r2, r1
    ab90:	bf08      	it	eq
    ab92:	f043 0301 	orreq.w	r3, r3, #1
    ab96:	b933      	cbnz	r3, aba6 <HAL_DMA_DeInit+0x106>
    ab98:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    ab9c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    aba0:	429a      	cmp	r2, r3
    aba2:	f040 8234 	bne.w	b00e <HAL_DMA_DeInit+0x56e>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
    aba6:	2100      	movs	r1, #0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    aba8:	2021      	movs	r0, #33	; 0x21
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abaa:	2310      	movs	r3, #16
    abac:	2728      	movs	r7, #40	; 0x28
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
    abae:	6011      	str	r1, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abb0:	2640      	movs	r6, #64	; 0x40
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
    abb2:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abb4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    abb8:	f2c4 0702 	movt	r7, #16386	; 0x4002
    abbc:	f2c4 0602 	movt	r6, #16386	; 0x4002
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
    abc0:	6051      	str	r1, [r2, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abc2:	2558      	movs	r5, #88	; 0x58
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
    abc4:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abc6:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
    abca:	6091      	str	r1, [r2, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
    abcc:	6822      	ldr	r2, [r4, #0]
    abce:	60d1      	str	r1, [r2, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
    abd0:	6822      	ldr	r2, [r4, #0]
    abd2:	6111      	str	r1, [r2, #16]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abd4:	2188      	movs	r1, #136	; 0x88
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    abd6:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abd8:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    abdc:	6150      	str	r0, [r2, #20]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    abde:	2070      	movs	r0, #112	; 0x70
    abe0:	6822      	ldr	r2, [r4, #0]
    abe2:	f2c4 0002 	movt	r0, #16386	; 0x4002
    abe6:	42ba      	cmp	r2, r7
    abe8:	bf18      	it	ne
    abea:	429a      	cmpne	r2, r3
    abec:	bf0c      	ite	eq
    abee:	2301      	moveq	r3, #1
    abf0:	2300      	movne	r3, #0
    abf2:	42b2      	cmp	r2, r6
    abf4:	bf08      	it	eq
    abf6:	f043 0301 	orreq.w	r3, r3, #1
    abfa:	42aa      	cmp	r2, r5
    abfc:	bf08      	it	eq
    abfe:	f043 0301 	orreq.w	r3, r3, #1
    ac02:	25a0      	movs	r5, #160	; 0xa0
    ac04:	4282      	cmp	r2, r0
    ac06:	bf08      	it	eq
    ac08:	f043 0301 	orreq.w	r3, r3, #1
    ac0c:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ac10:	20b8      	movs	r0, #184	; 0xb8
    ac12:	428a      	cmp	r2, r1
    ac14:	bf08      	it	eq
    ac16:	f043 0301 	orreq.w	r3, r3, #1
    ac1a:	f44f 6182 	mov.w	r1, #1040	; 0x410
    ac1e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ac22:	42aa      	cmp	r2, r5
    ac24:	bf08      	it	eq
    ac26:	f043 0301 	orreq.w	r3, r3, #1
    ac2a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ac2e:	f44f 6585 	mov.w	r5, #1064	; 0x428
    ac32:	4282      	cmp	r2, r0
    ac34:	bf08      	it	eq
    ac36:	f043 0301 	orreq.w	r3, r3, #1
    ac3a:	f44f 6088 	mov.w	r0, #1088	; 0x440
    ac3e:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ac42:	428a      	cmp	r2, r1
    ac44:	bf08      	it	eq
    ac46:	f043 0301 	orreq.w	r3, r3, #1
    ac4a:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ac4e:	f44f 618b 	mov.w	r1, #1112	; 0x458
    ac52:	42aa      	cmp	r2, r5
    ac54:	bf08      	it	eq
    ac56:	f043 0301 	orreq.w	r3, r3, #1
    ac5a:	f44f 658e 	mov.w	r5, #1136	; 0x470
    ac5e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ac62:	4282      	cmp	r2, r0
    ac64:	bf08      	it	eq
    ac66:	f043 0301 	orreq.w	r3, r3, #1
    ac6a:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ac6e:	f44f 6091 	mov.w	r0, #1160	; 0x488
    ac72:	428a      	cmp	r2, r1
    ac74:	bf08      	it	eq
    ac76:	f043 0301 	orreq.w	r3, r3, #1
    ac7a:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
    ac7e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ac82:	42aa      	cmp	r2, r5
    ac84:	bf08      	it	eq
    ac86:	f043 0301 	orreq.w	r3, r3, #1
    ac8a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ac8e:	4282      	cmp	r2, r0
    ac90:	bf08      	it	eq
    ac92:	f043 0301 	orreq.w	r3, r3, #1
    ac96:	428a      	cmp	r2, r1
    ac98:	bf08      	it	eq
    ac9a:	f043 0301 	orreq.w	r3, r3, #1
    ac9e:	b933      	cbnz	r3, acae <HAL_DMA_DeInit+0x20e>
    aca0:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    aca4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    aca8:	429a      	cmp	r2, r3
    acaa:	f040 8201 	bne.w	b0b0 <HAL_DMA_DeInit+0x610>
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    acae:	b2d3      	uxtb	r3, r2
    acb0:	f64a 25ab 	movw	r5, #43691	; 0xaaab
    acb4:	f44f 417c 	mov.w	r1, #64512	; 0xfc00
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    acb8:	f243 7034 	movw	r0, #14132	; 0x3734
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    acbc:	3b10      	subs	r3, #16
    acbe:	f6ca 25aa 	movt	r5, #43690	; 0xaaaa
    acc2:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    acc6:	f2c0 0003 	movt	r0, #3
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    acca:	fba5 5303 	umull	r5, r3, r5, r3
    acce:	4011      	ands	r1, r2
    acd0:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    acd2:	f003 0207 	and.w	r2, r3, #7
    if (stream_number > 3U)
    acd6:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    acd8:	5c82      	ldrb	r2, [r0, r2]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
    acda:	bf88      	it	hi
    acdc:	3104      	addhi	r1, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    acde:	65e2      	str	r2, [r4, #92]	; 0x5c
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
    ace0:	65a1      	str	r1, [r4, #88]	; 0x58
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    ace2:	f002 021f 	and.w	r2, r2, #31
    ace6:	233f      	movs	r3, #63	; 0x3f
    ace8:	fa03 f202 	lsl.w	r2, r3, r2
    acec:	608a      	str	r2, [r1, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    acee:	2310      	movs	r3, #16
    acf0:	2028      	movs	r0, #40	; 0x28
    acf2:	6822      	ldr	r2, [r4, #0]
    acf4:	2740      	movs	r7, #64	; 0x40
    acf6:	f2c4 0002 	movt	r0, #16386	; 0x4002
    acfa:	f2c4 0302 	movt	r3, #16386	; 0x4002
    acfe:	f2c4 0702 	movt	r7, #16386	; 0x4002
    ad02:	2658      	movs	r6, #88	; 0x58
    ad04:	4282      	cmp	r2, r0
    ad06:	bf18      	it	ne
    ad08:	429a      	cmpne	r2, r3
    ad0a:	f04f 0570 	mov.w	r5, #112	; 0x70
    ad0e:	f2c4 0602 	movt	r6, #16386	; 0x4002
    ad12:	f04f 0188 	mov.w	r1, #136	; 0x88
    ad16:	bf0c      	ite	eq
    ad18:	2001      	moveq	r0, #1
    ad1a:	2000      	movne	r0, #0
    ad1c:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ad20:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ad24:	42ba      	cmp	r2, r7
    ad26:	bf08      	it	eq
    ad28:	f040 0001 	orreq.w	r0, r0, #1
    ad2c:	f04f 0ca0 	mov.w	ip, #160	; 0xa0
    ad30:	27b8      	movs	r7, #184	; 0xb8
    ad32:	f44f 638b 	mov.w	r3, #1112	; 0x458
    ad36:	42b2      	cmp	r2, r6
    ad38:	bf08      	it	eq
    ad3a:	f040 0001 	orreq.w	r0, r0, #1
    ad3e:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    ad42:	f2c4 0702 	movt	r7, #16386	; 0x4002
    ad46:	f44f 6682 	mov.w	r6, #1040	; 0x410
    ad4a:	42aa      	cmp	r2, r5
    ad4c:	bf08      	it	eq
    ad4e:	f040 0001 	orreq.w	r0, r0, #1
    ad52:	f44f 6585 	mov.w	r5, #1064	; 0x428
    ad56:	f2c4 0602 	movt	r6, #16386	; 0x4002
    ad5a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    ad5e:	428a      	cmp	r2, r1
    ad60:	bf14      	ite	ne
    ad62:	4601      	movne	r1, r0
    ad64:	f040 0101 	orreq.w	r1, r0, #1
    ad68:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ad6c:	f44f 6088 	mov.w	r0, #1088	; 0x440
    ad70:	f44f 6a8e 	mov.w	sl, #1136	; 0x470
    ad74:	4562      	cmp	r2, ip
    ad76:	bf08      	it	eq
    ad78:	f041 0101 	orreq.w	r1, r1, #1
    ad7c:	f44f 6991 	mov.w	r9, #1160	; 0x488
    ad80:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ad84:	f2c4 0a02 	movt	sl, #16386	; 0x4002
    ad88:	42ba      	cmp	r2, r7
    ad8a:	bf08      	it	eq
    ad8c:	f041 0101 	orreq.w	r1, r1, #1
    ad90:	f245 4e08 	movw	lr, #21512	; 0x5408
    ad94:	f44f 6894 	mov.w	r8, #1184	; 0x4a0
    ad98:	f2c4 0902 	movt	r9, #16386	; 0x4002
    ad9c:	42b2      	cmp	r2, r6
    ad9e:	bf08      	it	eq
    ada0:	f041 0101 	orreq.w	r1, r1, #1
    ada4:	f245 471c 	movw	r7, #21532	; 0x541c
    ada8:	f6c5 0e02 	movt	lr, #22530	; 0x5802
    adac:	f2c4 0802 	movt	r8, #16386	; 0x4002
    adb0:	42aa      	cmp	r2, r5
    adb2:	bf08      	it	eq
    adb4:	f041 0101 	orreq.w	r1, r1, #1
    adb8:	f44f 6c97 	mov.w	ip, #1208	; 0x4b8
    adbc:	f6c5 0702 	movt	r7, #22530	; 0x5802
    adc0:	f245 4630 	movw	r6, #21552	; 0x5430
    adc4:	4282      	cmp	r2, r0
    adc6:	bf08      	it	eq
    adc8:	f041 0101 	orreq.w	r1, r1, #1
    adcc:	eba2 0e0e 	sub.w	lr, r2, lr
    add0:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    add4:	1bd7      	subs	r7, r2, r7
    add6:	429a      	cmp	r2, r3
    add8:	bf14      	ite	ne
    adda:	460b      	movne	r3, r1
    addc:	f041 0301 	orreq.w	r3, r1, #1
    ade0:	fabe fe8e 	clz	lr, lr
    ade4:	f6c5 0602 	movt	r6, #22530	; 0x5802
    ade8:	f245 4544 	movw	r5, #21572	; 0x5444
    adec:	4552      	cmp	r2, sl
    adee:	bf08      	it	eq
    adf0:	f043 0301 	orreq.w	r3, r3, #1
    adf4:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
    adf8:	fab7 f787 	clz	r7, r7
    adfc:	1b96      	subs	r6, r2, r6
    adfe:	454a      	cmp	r2, r9
    ae00:	bf08      	it	eq
    ae02:	f043 0301 	orreq.w	r3, r3, #1
    ae06:	f245 4058 	movw	r0, #21592	; 0x5458
    ae0a:	f6c5 0502 	movt	r5, #22530	; 0x5802
    ae0e:	097f      	lsrs	r7, r7, #5
    ae10:	4542      	cmp	r2, r8
    ae12:	bf08      	it	eq
    ae14:	f043 0301 	orreq.w	r3, r3, #1
    ae18:	fab6 f686 	clz	r6, r6
    ae1c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    ae20:	f245 416c 	movw	r1, #21612	; 0x546c
    ae24:	4562      	cmp	r2, ip
    ae26:	bf08      	it	eq
    ae28:	f043 0301 	orreq.w	r3, r3, #1
    ae2c:	1b55      	subs	r5, r2, r5
    ae2e:	0976      	lsrs	r6, r6, #5
    ae30:	1a10      	subs	r0, r2, r0
    ae32:	ea4e 0303 	orr.w	r3, lr, r3
    ae36:	fab5 f585 	clz	r5, r5
    ae3a:	f6c5 0102 	movt	r1, #22530	; 0x5802
    ae3e:	f44f 4ca9 	mov.w	ip, #21632	; 0x5480
    ae42:	433b      	orrs	r3, r7
    ae44:	096d      	lsrs	r5, r5, #5
    ae46:	fab0 f080 	clz	r0, r0
    ae4a:	1a51      	subs	r1, r2, r1
    ae4c:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    ae50:	4333      	orrs	r3, r6
    ae52:	0940      	lsrs	r0, r0, #5
    ae54:	fab1 f181 	clz	r1, r1
    ae58:	f245 4894 	movw	r8, #21652	; 0x5494
    ae5c:	eba2 0c0c 	sub.w	ip, r2, ip
    ae60:	432b      	orrs	r3, r5
    ae62:	0949      	lsrs	r1, r1, #5
    ae64:	f6c5 0802 	movt	r8, #22530	; 0x5802
    ae68:	fabc fc8c 	clz	ip, ip
    ae6c:	4303      	orrs	r3, r0
    ae6e:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    ae72:	eba2 0808 	sub.w	r8, r2, r8
    ae76:	430b      	orrs	r3, r1
    ae78:	fab8 f888 	clz	r8, r8
    ae7c:	ea5c 0303 	orrs.w	r3, ip, r3
    ae80:	ea4f 1858 	mov.w	r8, r8, lsr #5
    ae84:	d102      	bne.n	ae8c <HAL_DMA_DeInit+0x3ec>
    ae86:	f1b8 0f00 	cmp.w	r8, #0
    ae8a:	d037      	beq.n	aefc <HAL_DMA_DeInit+0x45c>
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    ae8c:	ea47 070e 	orr.w	r7, r7, lr
    ae90:	fa5f f982 	uxtb.w	r9, r2
    ae94:	433e      	orrs	r6, r7
    ae96:	4335      	orrs	r5, r6
    ae98:	4328      	orrs	r0, r5
    ae9a:	4301      	orrs	r1, r0
    ae9c:	ea5c 0301 	orrs.w	r3, ip, r1
    aea0:	d103      	bne.n	aeaa <HAL_DMA_DeInit+0x40a>
    aea2:	f1b8 0f00 	cmp.w	r8, #0
    aea6:	f000 808c 	beq.w	afc2 <HAL_DMA_DeInit+0x522>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    aeaa:	f64c 45cd 	movw	r5, #52429	; 0xcccd
    aeae:	f1a9 0308 	sub.w	r3, r9, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    aeb2:	f44f 4216 	mov.w	r2, #38400	; 0x9600
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aeb6:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    aeb8:	f6cc 45cc 	movt	r5, #52428	; 0xcccc
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    aebc:	f44f 40b1 	mov.w	r0, #22656	; 0x5880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    aec0:	f2c1 6200 	movt	r2, #5632	; 0x1600
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    aec4:	fba5 5303 	umull	r5, r3, r5, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    aec8:	f6c5 0002 	movt	r0, #22530	; 0x5802
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    aecc:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    aece:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    aed0:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aed2:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    aed6:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aed8:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    aedc:	6622      	str	r2, [r4, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aede:	66a3      	str	r3, [r4, #104]	; 0x68
    if(hdma->DMAmuxChannel != 0U)
    aee0:	b122      	cbz	r2, aeec <HAL_DMA_DeInit+0x44c>
      hdma->DMAmuxChannel->CCR = 0U;
    aee2:	2300      	movs	r3, #0
    aee4:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    aee6:	e9d4 3219 	ldrd	r3, r2, [r4, #100]	; 0x64
    aeea:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
    aeec:	6860      	ldr	r0, [r4, #4]
    aeee:	1e41      	subs	r1, r0, #1
    aef0:	2907      	cmp	r1, #7
    aef2:	d912      	bls.n	af1a <HAL_DMA_DeInit+0x47a>
    hdma->DMAmuxRequestGen = 0U;
    aef4:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
    aef6:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatusMask = 0U;
    aefa:	6763      	str	r3, [r4, #116]	; 0x74
  hdma->XferCpltCallback       = NULL;
    aefc:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    aefe:	6563      	str	r3, [r4, #84]	; 0x54
  return HAL_OK;
    af00:	4618      	mov	r0, r3
  hdma->State = HAL_DMA_STATE_RESET;
    af02:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
    af06:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->XferHalfCpltCallback   = NULL;
    af0a:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
    af0e:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
  hdma->XferAbortCallback      = NULL;
    af12:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
}
    af16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    af1a:	f245 4308 	movw	r3, #21512	; 0x5408
    af1e:	f245 451c 	movw	r5, #21532	; 0x541c
    af22:	6822      	ldr	r2, [r4, #0]
    af24:	f245 4630 	movw	r6, #21552	; 0x5430
    af28:	f6c5 0302 	movt	r3, #22530	; 0x5802
    af2c:	f6c5 0502 	movt	r5, #22530	; 0x5802
    af30:	f6c5 0602 	movt	r6, #22530	; 0x5802
    af34:	f245 4758 	movw	r7, #21592	; 0x5458
    af38:	42aa      	cmp	r2, r5
    af3a:	bf18      	it	ne
    af3c:	429a      	cmpne	r2, r3
    af3e:	f245 4544 	movw	r5, #21572	; 0x5444
    af42:	f6c5 0702 	movt	r7, #22530	; 0x5802
    af46:	bf0c      	ite	eq
    af48:	2301      	moveq	r3, #1
    af4a:	2300      	movne	r3, #0
    af4c:	f6c5 0502 	movt	r5, #22530	; 0x5802
    af50:	42b2      	cmp	r2, r6
    af52:	bf08      	it	eq
    af54:	f043 0301 	orreq.w	r3, r3, #1
    af58:	f245 466c 	movw	r6, #21612	; 0x546c
    af5c:	42aa      	cmp	r2, r5
    af5e:	bf08      	it	eq
    af60:	f043 0301 	orreq.w	r3, r3, #1
    af64:	f6c5 0602 	movt	r6, #22530	; 0x5802
    af68:	f44f 45a9 	mov.w	r5, #21632	; 0x5480
    af6c:	42ba      	cmp	r2, r7
    af6e:	bf08      	it	eq
    af70:	f043 0301 	orreq.w	r3, r3, #1
    af74:	f6c5 0502 	movt	r5, #22530	; 0x5802
    af78:	42b2      	cmp	r2, r6
    af7a:	bf08      	it	eq
    af7c:	f043 0301 	orreq.w	r3, r3, #1
    af80:	42aa      	cmp	r2, r5
    af82:	bf08      	it	eq
    af84:	f043 0301 	orreq.w	r3, r3, #1
    af88:	b933      	cbnz	r3, af98 <HAL_DMA_DeInit+0x4f8>
    af8a:	f245 4394 	movw	r3, #21652	; 0x5494
    af8e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    af92:	429a      	cmp	r2, r3
    af94:	f040 8094 	bne.w	b0c0 <HAL_DMA_DeInit+0x620>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    af98:	f249 633f 	movw	r3, #38463	; 0x963f
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    af9c:	f645 1540 	movw	r5, #22848	; 0x5940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    afa0:	f2c1 6300 	movt	r3, #5632	; 0x1600
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    afa4:	f6c5 0502 	movt	r5, #22530	; 0x5802
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    afa8:	4403      	add	r3, r0
    afaa:	009b      	lsls	r3, r3, #2
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    afac:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
    afae:	2000      	movs	r0, #0
    afb0:	6725      	str	r5, [r4, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    afb2:	fa02 f101 	lsl.w	r1, r2, r1
    afb6:	6761      	str	r1, [r4, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
    afb8:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    afba:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
    afbe:	605a      	str	r2, [r3, #4]
    afc0:	e798      	b.n	aef4 <HAL_DMA_DeInit+0x454>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    afc2:	f64f 31f0 	movw	r1, #64496	; 0xfbf0
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    afc6:	f64a 20ab 	movw	r0, #43691	; 0xaaab
    afca:	f1a9 0310 	sub.w	r3, r9, #16
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    afce:	f6cb 71fd 	movt	r1, #49149	; 0xbffd
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    afd2:	f6ca 20aa 	movt	r0, #43690	; 0xaaaa
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    afd6:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    afd8:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    afdc:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    afde:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    afe2:	d800      	bhi.n	afe6 <HAL_DMA_DeInit+0x546>
      stream_number += 8U;
    afe4:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    afe6:	f44f 4202 	mov.w	r2, #33280	; 0x8200
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    afea:	f003 051f 	and.w	r5, r3, #31
    afee:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    aff0:	f44f 6008 	mov.w	r0, #2176	; 0x880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    aff4:	f2c1 0200 	movt	r2, #4096	; 0x1000
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aff8:	40a9      	lsls	r1, r5
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    affa:	f2c4 0002 	movt	r0, #16386	; 0x4002
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    affe:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    b000:	66a1      	str	r1, [r4, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    b002:	0092      	lsls	r2, r2, #2
    b004:	e9c4 2018 	strd	r2, r0, [r4, #96]	; 0x60
    b008:	e76a      	b.n	aee0 <HAL_DMA_DeInit+0x440>
    return HAL_ERROR;
    b00a:	2001      	movs	r0, #1
}
    b00c:	4770      	bx	lr
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    b00e:	f245 4308 	movw	r3, #21512	; 0x5408
    b012:	f245 451c 	movw	r5, #21532	; 0x541c
    b016:	f245 4030 	movw	r0, #21552	; 0x5430
    b01a:	f245 4144 	movw	r1, #21572	; 0x5444
    b01e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b022:	f6c5 0502 	movt	r5, #22530	; 0x5802
    b026:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b02a:	f6c5 0102 	movt	r1, #22530	; 0x5802
    b02e:	42aa      	cmp	r2, r5
    b030:	bf18      	it	ne
    b032:	429a      	cmpne	r2, r3
    b034:	f245 4558 	movw	r5, #21592	; 0x5458
    b038:	bf0c      	ite	eq
    b03a:	2301      	moveq	r3, #1
    b03c:	2300      	movne	r3, #0
    b03e:	f6c5 0502 	movt	r5, #22530	; 0x5802
    b042:	4282      	cmp	r2, r0
    b044:	bf08      	it	eq
    b046:	f043 0301 	orreq.w	r3, r3, #1
    b04a:	f245 406c 	movw	r0, #21612	; 0x546c
    b04e:	428a      	cmp	r2, r1
    b050:	bf08      	it	eq
    b052:	f043 0301 	orreq.w	r3, r3, #1
    b056:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b05a:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
    b05e:	42aa      	cmp	r2, r5
    b060:	bf08      	it	eq
    b062:	f043 0301 	orreq.w	r3, r3, #1
    b066:	f6c5 0102 	movt	r1, #22530	; 0x5802
    b06a:	4282      	cmp	r2, r0
    b06c:	bf08      	it	eq
    b06e:	f043 0301 	orreq.w	r3, r3, #1
    b072:	428a      	cmp	r2, r1
    b074:	bf08      	it	eq
    b076:	f043 0301 	orreq.w	r3, r3, #1
    b07a:	b92b      	cbnz	r3, b088 <HAL_DMA_DeInit+0x5e8>
    b07c:	f245 4394 	movw	r3, #21652	; 0x5494
    b080:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b084:	429a      	cmp	r2, r3
    b086:	d118      	bne.n	b0ba <HAL_DMA_DeInit+0x61a>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
    b088:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    b08a:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
    b08c:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
    b08e:	6822      	ldr	r2, [r4, #0]
    b090:	6053      	str	r3, [r2, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
    b092:	6822      	ldr	r2, [r4, #0]
    b094:	6093      	str	r3, [r2, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
    b096:	6822      	ldr	r2, [r4, #0]
    b098:	60d3      	str	r3, [r2, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
    b09a:	6822      	ldr	r2, [r4, #0]
    b09c:	6113      	str	r3, [r2, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    b09e:	f7fe ff77 	bl	9f90 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    b0a2:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    b0a4:	2301      	movs	r3, #1
    b0a6:	f002 021f 	and.w	r2, r2, #31
    b0aa:	4093      	lsls	r3, r2
    b0ac:	6043      	str	r3, [r0, #4]
    b0ae:	e61e      	b.n	acee <HAL_DMA_DeInit+0x24e>
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
    b0b0:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
    b0b4:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    b0b6:	65a1      	str	r1, [r4, #88]	; 0x58
    b0b8:	e613      	b.n	ace2 <HAL_DMA_DeInit+0x242>
    return HAL_ERROR;
    b0ba:	2001      	movs	r0, #1
}
    b0bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    b0c0:	f248 233f 	movw	r3, #33343	; 0x823f
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    b0c4:	f44f 6514 	mov.w	r5, #2368	; 0x940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    b0c8:	f2c1 0300 	movt	r3, #4096	; 0x1000
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    b0cc:	f2c4 0502 	movt	r5, #16386	; 0x4002
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    b0d0:	4403      	add	r3, r0
    b0d2:	009b      	lsls	r3, r3, #2
    b0d4:	e76a      	b.n	afac <HAL_DMA_DeInit+0x50c>
    b0d6:	bf00      	nop

0000b0d8 <HAL_DMA_Start_IT>:
{
    b0d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b0da:	461d      	mov	r5, r3
    b0dc:	460e      	mov	r6, r1
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    b0de:	f64f 73fe 	movw	r3, #65534	; 0xfffe
{
    b0e2:	4604      	mov	r4, r0
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    b0e4:	1e69      	subs	r1, r5, #1
{
    b0e6:	4617      	mov	r7, r2
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    b0e8:	4299      	cmp	r1, r3
    b0ea:	d813      	bhi.n	b114 <HAL_DMA_Start_IT+0x3c>
  if(hdma == NULL)
    b0ec:	b1e4      	cbz	r4, b128 <HAL_DMA_Start_IT+0x50>
  __HAL_LOCK(hdma);
    b0ee:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    b0f2:	2b01      	cmp	r3, #1
    b0f4:	f000 8346 	beq.w	b784 <HAL_DMA_Start_IT+0x6ac>
    b0f8:	2001      	movs	r0, #1
  if(HAL_DMA_STATE_READY == hdma->State)
    b0fa:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    b0fe:	4283      	cmp	r3, r0
  __HAL_LOCK(hdma);
    b100:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
    b104:	d012      	beq.n	b12c <HAL_DMA_Start_IT+0x54>
    __HAL_UNLOCK(hdma);
    b106:	2200      	movs	r2, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    b108:	f44f 6300 	mov.w	r3, #2048	; 0x800
    __HAL_UNLOCK(hdma);
    b10c:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    b110:	6563      	str	r3, [r4, #84]	; 0x54
}
    b112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    b114:	f243 60fc 	movw	r0, #14076	; 0x36fc
    b118:	f240 21a7 	movw	r1, #679	; 0x2a7
    b11c:	f2c0 0003 	movt	r0, #3
    b120:	f00f ffc6 	bl	1b0b0 <assert_failed>
  if(hdma == NULL)
    b124:	2c00      	cmp	r4, #0
    b126:	d1e2      	bne.n	b0ee <HAL_DMA_Start_IT+0x16>
    return HAL_ERROR;
    b128:	2001      	movs	r0, #1
}
    b12a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_DMA_DISABLE(hdma);
    b12c:	6822      	ldr	r2, [r4, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
    b12e:	2002      	movs	r0, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    b130:	2100      	movs	r1, #0
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b132:	f04f 0c70 	mov.w	ip, #112	; 0x70
    hdma->State = HAL_DMA_STATE_BUSY;
    b136:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b13a:	2010      	movs	r0, #16
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    b13c:	6561      	str	r1, [r4, #84]	; 0x54
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b13e:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    __HAL_DMA_DISABLE(hdma);
    b142:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b144:	f2c4 0002 	movt	r0, #16386	; 0x4002
    __HAL_DMA_DISABLE(hdma);
    b148:	f023 0301 	bic.w	r3, r3, #1
    b14c:	6013      	str	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b14e:	2328      	movs	r3, #40	; 0x28
    b150:	6821      	ldr	r1, [r4, #0]
    b152:	2240      	movs	r2, #64	; 0x40
    b154:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b158:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b15c:	4299      	cmp	r1, r3
    b15e:	bf18      	it	ne
    b160:	4281      	cmpne	r1, r0
    b162:	f04f 0358 	mov.w	r3, #88	; 0x58
    b166:	bf0c      	ite	eq
    b168:	2001      	moveq	r0, #1
    b16a:	2000      	movne	r0, #0
    b16c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b170:	4291      	cmp	r1, r2
    b172:	bf08      	it	eq
    b174:	f040 0001 	orreq.w	r0, r0, #1
    b178:	22a0      	movs	r2, #160	; 0xa0
    b17a:	4299      	cmp	r1, r3
    b17c:	bf08      	it	eq
    b17e:	f040 0001 	orreq.w	r0, r0, #1
    b182:	2388      	movs	r3, #136	; 0x88
    b184:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b188:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b18c:	4561      	cmp	r1, ip
    b18e:	bf08      	it	eq
    b190:	f040 0001 	orreq.w	r0, r0, #1
    b194:	f44f 6c82 	mov.w	ip, #1040	; 0x410
    b198:	4299      	cmp	r1, r3
    b19a:	bf08      	it	eq
    b19c:	f040 0001 	orreq.w	r0, r0, #1
    b1a0:	23b8      	movs	r3, #184	; 0xb8
    b1a2:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b1a6:	4291      	cmp	r1, r2
    b1a8:	bf08      	it	eq
    b1aa:	f040 0001 	orreq.w	r0, r0, #1
    b1ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b1b2:	f44f 6288 	mov.w	r2, #1088	; 0x440
    b1b6:	4299      	cmp	r1, r3
    b1b8:	bf08      	it	eq
    b1ba:	f040 0001 	orreq.w	r0, r0, #1
    b1be:	f44f 6385 	mov.w	r3, #1064	; 0x428
    b1c2:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b1c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b1ca:	4561      	cmp	r1, ip
    b1cc:	bf08      	it	eq
    b1ce:	f040 0001 	orreq.w	r0, r0, #1
    b1d2:	f44f 6c8e 	mov.w	ip, #1136	; 0x470
    b1d6:	4299      	cmp	r1, r3
    b1d8:	bf08      	it	eq
    b1da:	f040 0001 	orreq.w	r0, r0, #1
    b1de:	f44f 638b 	mov.w	r3, #1112	; 0x458
    b1e2:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b1e6:	4291      	cmp	r1, r2
    b1e8:	bf08      	it	eq
    b1ea:	f040 0001 	orreq.w	r0, r0, #1
    b1ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b1f2:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
    b1f6:	4299      	cmp	r1, r3
    b1f8:	bf08      	it	eq
    b1fa:	f040 0001 	orreq.w	r0, r0, #1
    b1fe:	f44f 6391 	mov.w	r3, #1160	; 0x488
    b202:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b206:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b20a:	4561      	cmp	r1, ip
    b20c:	bf08      	it	eq
    b20e:	f040 0001 	orreq.w	r0, r0, #1
    b212:	f245 4c08 	movw	ip, #21512	; 0x5408
    b216:	4299      	cmp	r1, r3
    b218:	bf08      	it	eq
    b21a:	f040 0001 	orreq.w	r0, r0, #1
    b21e:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    b222:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    b226:	4291      	cmp	r1, r2
    b228:	bf08      	it	eq
    b22a:	f040 0001 	orreq.w	r0, r0, #1
    b22e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b232:	f245 4230 	movw	r2, #21552	; 0x5430
    b236:	4299      	cmp	r1, r3
    b238:	bf08      	it	eq
    b23a:	f040 0001 	orreq.w	r0, r0, #1
    b23e:	f245 431c 	movw	r3, #21532	; 0x541c
    b242:	f6c5 0202 	movt	r2, #22530	; 0x5802
    b246:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b24a:	4561      	cmp	r1, ip
    b24c:	bf08      	it	eq
    b24e:	f040 0001 	orreq.w	r0, r0, #1
    b252:	f245 4c58 	movw	ip, #21592	; 0x5458
    b256:	4299      	cmp	r1, r3
    b258:	bf08      	it	eq
    b25a:	f040 0001 	orreq.w	r0, r0, #1
    b25e:	f245 4344 	movw	r3, #21572	; 0x5444
    b262:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    b266:	4291      	cmp	r1, r2
    b268:	bf08      	it	eq
    b26a:	f040 0001 	orreq.w	r0, r0, #1
    b26e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b272:	f245 426c 	movw	r2, #21612	; 0x546c
    b276:	4299      	cmp	r1, r3
    b278:	bf08      	it	eq
    b27a:	f040 0001 	orreq.w	r0, r0, #1
    b27e:	f44f 43a9 	mov.w	r3, #21632	; 0x5480
    b282:	f6c5 0202 	movt	r2, #22530	; 0x5802
    b286:	4561      	cmp	r1, ip
    b288:	bf08      	it	eq
    b28a:	f040 0001 	orreq.w	r0, r0, #1
    b28e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b292:	4291      	cmp	r1, r2
    b294:	bf08      	it	eq
    b296:	f040 0001 	orreq.w	r0, r0, #1
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
    b29a:	6da2      	ldr	r2, [r4, #88]	; 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b29c:	4299      	cmp	r1, r3
    b29e:	bf08      	it	eq
    b2a0:	f040 0001 	orreq.w	r0, r0, #1
    b2a4:	b928      	cbnz	r0, b2b2 <HAL_DMA_Start_IT+0x1da>
    b2a6:	f245 4394 	movw	r3, #21652	; 0x5494
    b2aa:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b2ae:	4299      	cmp	r1, r3
    b2b0:	d108      	bne.n	b2c4 <HAL_DMA_Start_IT+0x1ec>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    b2b2:	e9d4 3119 	ldrd	r3, r1, [r4, #100]	; 0x64
    b2b6:	6059      	str	r1, [r3, #4]
    if(hdma->DMAmuxRequestGen != 0U)
    b2b8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    b2ba:	b113      	cbz	r3, b2c2 <HAL_DMA_Start_IT+0x1ea>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    b2bc:	e9d4 311c 	ldrd	r3, r1, [r4, #112]	; 0x70
    b2c0:	6059      	str	r1, [r3, #4]
    b2c2:	6821      	ldr	r1, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b2c4:	2310      	movs	r3, #16
    b2c6:	2028      	movs	r0, #40	; 0x28
    b2c8:	f04f 0c40 	mov.w	ip, #64	; 0x40
    b2cc:	f04f 0e70 	mov.w	lr, #112	; 0x70
    b2d0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b2d4:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b2d8:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b2dc:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    b2e0:	4281      	cmp	r1, r0
    b2e2:	bf18      	it	ne
    b2e4:	4299      	cmpne	r1, r3
    b2e6:	f04f 0058 	mov.w	r0, #88	; 0x58
    b2ea:	bf0c      	ite	eq
    b2ec:	2301      	moveq	r3, #1
    b2ee:	2300      	movne	r3, #0
    b2f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b2f4:	4561      	cmp	r1, ip
    b2f6:	bf08      	it	eq
    b2f8:	f043 0301 	orreq.w	r3, r3, #1
    b2fc:	f04f 0ca0 	mov.w	ip, #160	; 0xa0
    b300:	4281      	cmp	r1, r0
    b302:	bf08      	it	eq
    b304:	f043 0301 	orreq.w	r3, r3, #1
    b308:	2088      	movs	r0, #136	; 0x88
    b30a:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b30e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b312:	4571      	cmp	r1, lr
    b314:	bf08      	it	eq
    b316:	f043 0301 	orreq.w	r3, r3, #1
    b31a:	f44f 6e82 	mov.w	lr, #1040	; 0x410
    b31e:	4281      	cmp	r1, r0
    b320:	bf08      	it	eq
    b322:	f043 0301 	orreq.w	r3, r3, #1
    b326:	20b8      	movs	r0, #184	; 0xb8
    b328:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    b32c:	4561      	cmp	r1, ip
    b32e:	bf08      	it	eq
    b330:	f043 0301 	orreq.w	r3, r3, #1
    b334:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b338:	f44f 6c88 	mov.w	ip, #1088	; 0x440
    b33c:	4281      	cmp	r1, r0
    b33e:	bf08      	it	eq
    b340:	f043 0301 	orreq.w	r3, r3, #1
    b344:	f44f 6085 	mov.w	r0, #1064	; 0x428
    b348:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b34c:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b350:	4571      	cmp	r1, lr
    b352:	bf08      	it	eq
    b354:	f043 0301 	orreq.w	r3, r3, #1
    b358:	f44f 6e8e 	mov.w	lr, #1136	; 0x470
    b35c:	4281      	cmp	r1, r0
    b35e:	bf08      	it	eq
    b360:	f043 0301 	orreq.w	r3, r3, #1
    b364:	f44f 608b 	mov.w	r0, #1112	; 0x458
    b368:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    b36c:	4561      	cmp	r1, ip
    b36e:	bf08      	it	eq
    b370:	f043 0301 	orreq.w	r3, r3, #1
    b374:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b378:	f44f 6c91 	mov.w	ip, #1160	; 0x488
    b37c:	4281      	cmp	r1, r0
    b37e:	bf08      	it	eq
    b380:	f043 0301 	orreq.w	r3, r3, #1
    b384:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
    b388:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b38c:	4571      	cmp	r1, lr
    b38e:	bf08      	it	eq
    b390:	f043 0301 	orreq.w	r3, r3, #1
    b394:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b398:	4561      	cmp	r1, ip
    b39a:	bf08      	it	eq
    b39c:	f043 0301 	orreq.w	r3, r3, #1
    b3a0:	4281      	cmp	r1, r0
    b3a2:	bf08      	it	eq
    b3a4:	f043 0301 	orreq.w	r3, r3, #1
    b3a8:	b933      	cbnz	r3, b3b8 <HAL_DMA_Start_IT+0x2e0>
    b3aa:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    b3ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b3b2:	4299      	cmp	r1, r3
    b3b4:	f040 81e8 	bne.w	b788 <HAL_DMA_Start_IT+0x6b0>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    b3b8:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    b3ba:	233f      	movs	r3, #63	; 0x3f
    b3bc:	f001 011f 	and.w	r1, r1, #31
    b3c0:	408b      	lsls	r3, r1
    b3c2:	6093      	str	r3, [r2, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
    b3c4:	6822      	ldr	r2, [r4, #0]
    b3c6:	6813      	ldr	r3, [r2, #0]
    b3c8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    b3cc:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
    b3ce:	6823      	ldr	r3, [r4, #0]
    b3d0:	605d      	str	r5, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    b3d2:	68a3      	ldr	r3, [r4, #8]
    b3d4:	2b40      	cmp	r3, #64	; 0x40
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
    b3d6:	6823      	ldr	r3, [r4, #0]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    b3d8:	f000 81cf 	beq.w	b77a <HAL_DMA_Start_IT+0x6a2>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
    b3dc:	609e      	str	r6, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
    b3de:	6823      	ldr	r3, [r4, #0]
    b3e0:	60df      	str	r7, [r3, #12]
    b3e2:	6821      	ldr	r1, [r4, #0]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b3e4:	2310      	movs	r3, #16
    b3e6:	2028      	movs	r0, #40	; 0x28
    b3e8:	2240      	movs	r2, #64	; 0x40
    b3ea:	2558      	movs	r5, #88	; 0x58
    b3ec:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b3f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b3f4:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b3f8:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b3fc:	4281      	cmp	r1, r0
    b3fe:	bf18      	it	ne
    b400:	4299      	cmpne	r1, r3
    b402:	f04f 0070 	mov.w	r0, #112	; 0x70
    b406:	bf0c      	ite	eq
    b408:	2301      	moveq	r3, #1
    b40a:	2300      	movne	r3, #0
    b40c:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b410:	4291      	cmp	r1, r2
    b412:	bf08      	it	eq
    b414:	f043 0301 	orreq.w	r3, r3, #1
    b418:	2288      	movs	r2, #136	; 0x88
    b41a:	42a9      	cmp	r1, r5
    b41c:	bf08      	it	eq
    b41e:	f043 0301 	orreq.w	r3, r3, #1
    b422:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b426:	25a0      	movs	r5, #160	; 0xa0
    b428:	4281      	cmp	r1, r0
    b42a:	bf08      	it	eq
    b42c:	f043 0301 	orreq.w	r3, r3, #1
    b430:	20b8      	movs	r0, #184	; 0xb8
    b432:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b436:	4291      	cmp	r1, r2
    b438:	bf08      	it	eq
    b43a:	f043 0301 	orreq.w	r3, r3, #1
    b43e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b442:	f44f 6282 	mov.w	r2, #1040	; 0x410
    b446:	42a9      	cmp	r1, r5
    b448:	bf08      	it	eq
    b44a:	f043 0301 	orreq.w	r3, r3, #1
    b44e:	f44f 6585 	mov.w	r5, #1064	; 0x428
    b452:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b456:	4281      	cmp	r1, r0
    b458:	bf08      	it	eq
    b45a:	f043 0301 	orreq.w	r3, r3, #1
    b45e:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b462:	f44f 6088 	mov.w	r0, #1088	; 0x440
    b466:	4291      	cmp	r1, r2
    b468:	bf08      	it	eq
    b46a:	f043 0301 	orreq.w	r3, r3, #1
    b46e:	f44f 628b 	mov.w	r2, #1112	; 0x458
    b472:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b476:	42a9      	cmp	r1, r5
    b478:	bf08      	it	eq
    b47a:	f043 0301 	orreq.w	r3, r3, #1
    b47e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b482:	f44f 658e 	mov.w	r5, #1136	; 0x470
    b486:	4281      	cmp	r1, r0
    b488:	bf08      	it	eq
    b48a:	f043 0301 	orreq.w	r3, r3, #1
    b48e:	f44f 6091 	mov.w	r0, #1160	; 0x488
    b492:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b496:	4291      	cmp	r1, r2
    b498:	bf08      	it	eq
    b49a:	f043 0301 	orreq.w	r3, r3, #1
    b49e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b4a2:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
    b4a6:	42a9      	cmp	r1, r5
    b4a8:	bf08      	it	eq
    b4aa:	f043 0301 	orreq.w	r3, r3, #1
    b4ae:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b4b2:	4281      	cmp	r1, r0
    b4b4:	bf08      	it	eq
    b4b6:	f043 0301 	orreq.w	r3, r3, #1
    b4ba:	4291      	cmp	r1, r2
    b4bc:	bf08      	it	eq
    b4be:	f043 0301 	orreq.w	r3, r3, #1
    b4c2:	b933      	cbnz	r3, b4d2 <HAL_DMA_Start_IT+0x3fa>
    b4c4:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    b4c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b4cc:	4299      	cmp	r1, r3
    b4ce:	f040 81a5 	bne.w	b81c <HAL_DMA_Start_IT+0x744>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
    b4d2:	680b      	ldr	r3, [r1, #0]
    b4d4:	f023 031e 	bic.w	r3, r3, #30
    b4d8:	f043 0316 	orr.w	r3, r3, #22
    b4dc:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
    b4de:	6c23      	ldr	r3, [r4, #64]	; 0x40
    b4e0:	b123      	cbz	r3, b4ec <HAL_DMA_Start_IT+0x414>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
    b4e2:	6822      	ldr	r2, [r4, #0]
    b4e4:	6813      	ldr	r3, [r2, #0]
    b4e6:	f043 0308 	orr.w	r3, r3, #8
    b4ea:	6013      	str	r3, [r2, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b4ec:	2310      	movs	r3, #16
    b4ee:	2228      	movs	r2, #40	; 0x28
    b4f0:	6821      	ldr	r1, [r4, #0]
    b4f2:	2540      	movs	r5, #64	; 0x40
    b4f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b4f8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b4fc:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b500:	2058      	movs	r0, #88	; 0x58
    b502:	4291      	cmp	r1, r2
    b504:	bf18      	it	ne
    b506:	4299      	cmpne	r1, r3
    b508:	f04f 0270 	mov.w	r2, #112	; 0x70
    b50c:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b510:	bf0c      	ite	eq
    b512:	2301      	moveq	r3, #1
    b514:	2300      	movne	r3, #0
    b516:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b51a:	42a9      	cmp	r1, r5
    b51c:	bf08      	it	eq
    b51e:	f043 0301 	orreq.w	r3, r3, #1
    b522:	2588      	movs	r5, #136	; 0x88
    b524:	4281      	cmp	r1, r0
    b526:	bf08      	it	eq
    b528:	f043 0301 	orreq.w	r3, r3, #1
    b52c:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b530:	20a0      	movs	r0, #160	; 0xa0
    b532:	4291      	cmp	r1, r2
    b534:	bf08      	it	eq
    b536:	f043 0301 	orreq.w	r3, r3, #1
    b53a:	22b8      	movs	r2, #184	; 0xb8
    b53c:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b540:	42a9      	cmp	r1, r5
    b542:	bf08      	it	eq
    b544:	f043 0301 	orreq.w	r3, r3, #1
    b548:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b54c:	f44f 6582 	mov.w	r5, #1040	; 0x410
    b550:	4281      	cmp	r1, r0
    b552:	bf08      	it	eq
    b554:	f043 0301 	orreq.w	r3, r3, #1
    b558:	f44f 6085 	mov.w	r0, #1064	; 0x428
    b55c:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b560:	4291      	cmp	r1, r2
    b562:	bf08      	it	eq
    b564:	f043 0301 	orreq.w	r3, r3, #1
    b568:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b56c:	f44f 6288 	mov.w	r2, #1088	; 0x440
    b570:	42a9      	cmp	r1, r5
    b572:	bf08      	it	eq
    b574:	f043 0301 	orreq.w	r3, r3, #1
    b578:	f44f 658b 	mov.w	r5, #1112	; 0x458
    b57c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b580:	4281      	cmp	r1, r0
    b582:	bf08      	it	eq
    b584:	f043 0301 	orreq.w	r3, r3, #1
    b588:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b58c:	f44f 608e 	mov.w	r0, #1136	; 0x470
    b590:	4291      	cmp	r1, r2
    b592:	bf08      	it	eq
    b594:	f043 0301 	orreq.w	r3, r3, #1
    b598:	f44f 6291 	mov.w	r2, #1160	; 0x488
    b59c:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b5a0:	42a9      	cmp	r1, r5
    b5a2:	bf08      	it	eq
    b5a4:	f043 0301 	orreq.w	r3, r3, #1
    b5a8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b5ac:	f44f 6594 	mov.w	r5, #1184	; 0x4a0
    b5b0:	4281      	cmp	r1, r0
    b5b2:	bf08      	it	eq
    b5b4:	f043 0301 	orreq.w	r3, r3, #1
    b5b8:	f44f 6097 	mov.w	r0, #1208	; 0x4b8
    b5bc:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b5c0:	4291      	cmp	r1, r2
    b5c2:	bf08      	it	eq
    b5c4:	f043 0301 	orreq.w	r3, r3, #1
    b5c8:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b5cc:	f245 4208 	movw	r2, #21512	; 0x5408
    b5d0:	42a9      	cmp	r1, r5
    b5d2:	bf08      	it	eq
    b5d4:	f043 0301 	orreq.w	r3, r3, #1
    b5d8:	f245 451c 	movw	r5, #21532	; 0x541c
    b5dc:	f6c5 0202 	movt	r2, #22530	; 0x5802
    b5e0:	4281      	cmp	r1, r0
    b5e2:	bf08      	it	eq
    b5e4:	f043 0301 	orreq.w	r3, r3, #1
    b5e8:	f6c5 0502 	movt	r5, #22530	; 0x5802
    b5ec:	f245 4030 	movw	r0, #21552	; 0x5430
    b5f0:	4291      	cmp	r1, r2
    b5f2:	bf08      	it	eq
    b5f4:	f043 0301 	orreq.w	r3, r3, #1
    b5f8:	f245 4244 	movw	r2, #21572	; 0x5444
    b5fc:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b600:	42a9      	cmp	r1, r5
    b602:	bf08      	it	eq
    b604:	f043 0301 	orreq.w	r3, r3, #1
    b608:	f6c5 0202 	movt	r2, #22530	; 0x5802
    b60c:	f245 4558 	movw	r5, #21592	; 0x5458
    b610:	4281      	cmp	r1, r0
    b612:	bf08      	it	eq
    b614:	f043 0301 	orreq.w	r3, r3, #1
    b618:	f245 406c 	movw	r0, #21612	; 0x546c
    b61c:	f6c5 0502 	movt	r5, #22530	; 0x5802
    b620:	4291      	cmp	r1, r2
    b622:	bf08      	it	eq
    b624:	f043 0301 	orreq.w	r3, r3, #1
    b628:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b62c:	f44f 42a9 	mov.w	r2, #21632	; 0x5480
    b630:	42a9      	cmp	r1, r5
    b632:	bf08      	it	eq
    b634:	f043 0301 	orreq.w	r3, r3, #1
    b638:	f6c5 0202 	movt	r2, #22530	; 0x5802
    b63c:	4281      	cmp	r1, r0
    b63e:	bf08      	it	eq
    b640:	f043 0301 	orreq.w	r3, r3, #1
    b644:	4291      	cmp	r1, r2
    b646:	bf08      	it	eq
    b648:	f043 0301 	orreq.w	r3, r3, #1
    b64c:	b92b      	cbnz	r3, b65a <HAL_DMA_Start_IT+0x582>
    b64e:	f245 4394 	movw	r3, #21652	; 0x5494
    b652:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b656:	4299      	cmp	r1, r3
    b658:	d10e      	bne.n	b678 <HAL_DMA_Start_IT+0x5a0>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
    b65a:	6e23      	ldr	r3, [r4, #96]	; 0x60
    b65c:	681a      	ldr	r2, [r3, #0]
    b65e:	03d2      	lsls	r2, r2, #15
    b660:	d503      	bpl.n	b66a <HAL_DMA_Start_IT+0x592>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
    b662:	681a      	ldr	r2, [r3, #0]
    b664:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    b668:	601a      	str	r2, [r3, #0]
      if(hdma->DMAmuxRequestGen != 0U)
    b66a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    b66c:	b11b      	cbz	r3, b676 <HAL_DMA_Start_IT+0x59e>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
    b66e:	681a      	ldr	r2, [r3, #0]
    b670:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    b674:	601a      	str	r2, [r3, #0]
    b676:	6821      	ldr	r1, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
    b678:	2310      	movs	r3, #16
    b67a:	2028      	movs	r0, #40	; 0x28
    b67c:	2240      	movs	r2, #64	; 0x40
    b67e:	2558      	movs	r5, #88	; 0x58
    b680:	f2c4 0302 	movt	r3, #16386	; 0x4002
    b684:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b688:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b68c:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b690:	4281      	cmp	r1, r0
    b692:	bf18      	it	ne
    b694:	4299      	cmpne	r1, r3
    b696:	f04f 0470 	mov.w	r4, #112	; 0x70
    b69a:	f04f 0088 	mov.w	r0, #136	; 0x88
    b69e:	bf0c      	ite	eq
    b6a0:	2301      	moveq	r3, #1
    b6a2:	2300      	movne	r3, #0
    b6a4:	f2c4 0402 	movt	r4, #16386	; 0x4002
    b6a8:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b6ac:	4291      	cmp	r1, r2
    b6ae:	bf08      	it	eq
    b6b0:	f043 0301 	orreq.w	r3, r3, #1
    b6b4:	22a0      	movs	r2, #160	; 0xa0
    b6b6:	42a9      	cmp	r1, r5
    b6b8:	bf08      	it	eq
    b6ba:	f043 0301 	orreq.w	r3, r3, #1
    b6be:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b6c2:	25b8      	movs	r5, #184	; 0xb8
    b6c4:	42a1      	cmp	r1, r4
    b6c6:	bf08      	it	eq
    b6c8:	f043 0301 	orreq.w	r3, r3, #1
    b6cc:	f44f 6482 	mov.w	r4, #1040	; 0x410
    b6d0:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b6d4:	4281      	cmp	r1, r0
    b6d6:	bf08      	it	eq
    b6d8:	f043 0301 	orreq.w	r3, r3, #1
    b6dc:	f2c4 0402 	movt	r4, #16386	; 0x4002
    b6e0:	f44f 6085 	mov.w	r0, #1064	; 0x428
    b6e4:	4291      	cmp	r1, r2
    b6e6:	bf08      	it	eq
    b6e8:	f043 0301 	orreq.w	r3, r3, #1
    b6ec:	f44f 6288 	mov.w	r2, #1088	; 0x440
    b6f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b6f4:	42a9      	cmp	r1, r5
    b6f6:	bf08      	it	eq
    b6f8:	f043 0301 	orreq.w	r3, r3, #1
    b6fc:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b700:	f44f 658b 	mov.w	r5, #1112	; 0x458
    b704:	42a1      	cmp	r1, r4
    b706:	bf08      	it	eq
    b708:	f043 0301 	orreq.w	r3, r3, #1
    b70c:	f44f 648e 	mov.w	r4, #1136	; 0x470
    b710:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b714:	4281      	cmp	r1, r0
    b716:	bf08      	it	eq
    b718:	f043 0301 	orreq.w	r3, r3, #1
    b71c:	f2c4 0402 	movt	r4, #16386	; 0x4002
    b720:	f44f 6091 	mov.w	r0, #1160	; 0x488
    b724:	4291      	cmp	r1, r2
    b726:	bf08      	it	eq
    b728:	f043 0301 	orreq.w	r3, r3, #1
    b72c:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
    b730:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b734:	42a9      	cmp	r1, r5
    b736:	bf08      	it	eq
    b738:	f043 0301 	orreq.w	r3, r3, #1
    b73c:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b740:	42a1      	cmp	r1, r4
    b742:	bf08      	it	eq
    b744:	f043 0301 	orreq.w	r3, r3, #1
    b748:	4281      	cmp	r1, r0
    b74a:	bf08      	it	eq
    b74c:	f043 0301 	orreq.w	r3, r3, #1
    b750:	4291      	cmp	r1, r2
    b752:	bf08      	it	eq
    b754:	f043 0301 	orreq.w	r3, r3, #1
    b758:	b94b      	cbnz	r3, b76e <HAL_DMA_Start_IT+0x696>
    b75a:	f44f 6097 	mov.w	r0, #1208	; 0x4b8
    b75e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b762:	1a08      	subs	r0, r1, r0
    b764:	fab0 f080 	clz	r0, r0
    b768:	0940      	lsrs	r0, r0, #5
    b76a:	2800      	cmp	r0, #0
    b76c:	d051      	beq.n	b812 <HAL_DMA_Start_IT+0x73a>
    b76e:	680b      	ldr	r3, [r1, #0]
  HAL_StatusTypeDef status = HAL_OK;
    b770:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
    b772:	f043 0301 	orr.w	r3, r3, #1
    b776:	600b      	str	r3, [r1, #0]
}
    b778:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
    b77a:	609f      	str	r7, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
    b77c:	6823      	ldr	r3, [r4, #0]
    b77e:	60de      	str	r6, [r3, #12]
    b780:	6821      	ldr	r1, [r4, #0]
    b782:	e62f      	b.n	b3e4 <HAL_DMA_Start_IT+0x30c>
  __HAL_LOCK(hdma);
    b784:	2002      	movs	r0, #2
}
    b786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    b788:	f245 4308 	movw	r3, #21512	; 0x5408
    b78c:	f245 401c 	movw	r0, #21532	; 0x541c
    b790:	f245 4c30 	movw	ip, #21552	; 0x5430
    b794:	f245 4e58 	movw	lr, #21592	; 0x5458
    b798:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b79c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b7a0:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    b7a4:	f6c5 0e02 	movt	lr, #22530	; 0x5802
    b7a8:	4281      	cmp	r1, r0
    b7aa:	bf18      	it	ne
    b7ac:	4299      	cmpne	r1, r3
    b7ae:	f245 4044 	movw	r0, #21572	; 0x5444
    b7b2:	bf0c      	ite	eq
    b7b4:	2301      	moveq	r3, #1
    b7b6:	2300      	movne	r3, #0
    b7b8:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b7bc:	4561      	cmp	r1, ip
    b7be:	bf08      	it	eq
    b7c0:	f043 0301 	orreq.w	r3, r3, #1
    b7c4:	f245 4c6c 	movw	ip, #21612	; 0x546c
    b7c8:	4281      	cmp	r1, r0
    b7ca:	bf08      	it	eq
    b7cc:	f043 0301 	orreq.w	r3, r3, #1
    b7d0:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    b7d4:	f44f 40a9 	mov.w	r0, #21632	; 0x5480
    b7d8:	4571      	cmp	r1, lr
    b7da:	bf08      	it	eq
    b7dc:	f043 0301 	orreq.w	r3, r3, #1
    b7e0:	f6c5 0002 	movt	r0, #22530	; 0x5802
    b7e4:	4561      	cmp	r1, ip
    b7e6:	bf08      	it	eq
    b7e8:	f043 0301 	orreq.w	r3, r3, #1
    b7ec:	4281      	cmp	r1, r0
    b7ee:	bf08      	it	eq
    b7f0:	f043 0301 	orreq.w	r3, r3, #1
    b7f4:	b933      	cbnz	r3, b804 <HAL_DMA_Start_IT+0x72c>
    b7f6:	f245 4394 	movw	r3, #21652	; 0x5494
    b7fa:	f6c5 0302 	movt	r3, #22530	; 0x5802
    b7fe:	4299      	cmp	r1, r3
    b800:	f47f adf0 	bne.w	b3e4 <HAL_DMA_Start_IT+0x30c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
    b804:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    b806:	2301      	movs	r3, #1
    b808:	f001 011f 	and.w	r1, r1, #31
    b80c:	408b      	lsls	r3, r1
    b80e:	6053      	str	r3, [r2, #4]
    b810:	e5dd      	b.n	b3ce <HAL_DMA_Start_IT+0x2f6>
    __HAL_DMA_ENABLE(hdma);
    b812:	680b      	ldr	r3, [r1, #0]
    b814:	f043 0301 	orr.w	r3, r3, #1
    b818:	600b      	str	r3, [r1, #0]
}
    b81a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
    b81c:	680b      	ldr	r3, [r1, #0]
    b81e:	f023 030e 	bic.w	r3, r3, #14
    b822:	f043 030a 	orr.w	r3, r3, #10
    b826:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
    b828:	6c23      	ldr	r3, [r4, #64]	; 0x40
    b82a:	2b00      	cmp	r3, #0
    b82c:	f43f ae5e 	beq.w	b4ec <HAL_DMA_Start_IT+0x414>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
    b830:	6822      	ldr	r2, [r4, #0]
    b832:	6813      	ldr	r3, [r2, #0]
    b834:	f043 0304 	orr.w	r3, r3, #4
    b838:	6013      	str	r3, [r2, #0]
    b83a:	e657      	b.n	b4ec <HAL_DMA_Start_IT+0x414>

0000b83c <HAL_DMA_Abort_IT>:
  if(hdma == NULL)
    b83c:	2800      	cmp	r0, #0
    b83e:	f000 809d 	beq.w	b97c <HAL_DMA_Abort_IT+0x140>
  if(hdma->State != HAL_DMA_STATE_BUSY)
    b842:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    b846:	4603      	mov	r3, r0
    b848:	2a02      	cmp	r2, #2
    b84a:	d003      	beq.n	b854 <HAL_DMA_Abort_IT+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
    b84c:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
    b84e:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
    b850:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
    b852:	4770      	bx	lr
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b854:	2110      	movs	r1, #16
{
    b856:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b85a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    b85e:	6802      	ldr	r2, [r0, #0]
{
    b860:	b087      	sub	sp, #28
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b862:	428a      	cmp	r2, r1
    b864:	d07f      	beq.n	b966 <HAL_DMA_Abort_IT+0x12a>
    b866:	2028      	movs	r0, #40	; 0x28
    b868:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b86c:	4282      	cmp	r2, r0
    b86e:	d07a      	beq.n	b966 <HAL_DMA_Abort_IT+0x12a>
    b870:	f04f 0858 	mov.w	r8, #88	; 0x58
    b874:	f04f 0940 	mov.w	r9, #64	; 0x40
    b878:	f04f 0e70 	mov.w	lr, #112	; 0x70
    b87c:	f04f 0c88 	mov.w	ip, #136	; 0x88
    b880:	f2c4 0802 	movt	r8, #16386	; 0x4002
    b884:	f2c4 0902 	movt	r9, #16386	; 0x4002
    b888:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    b88c:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    b890:	454a      	cmp	r2, r9
    b892:	bf18      	it	ne
    b894:	4542      	cmpne	r2, r8
    b896:	f04f 07a0 	mov.w	r7, #160	; 0xa0
    b89a:	f44f 6582 	mov.w	r5, #1040	; 0x410
    b89e:	f44f 6b88 	mov.w	fp, #1088	; 0x440
    b8a2:	bf0c      	ite	eq
    b8a4:	f04f 0a01 	moveq.w	sl, #1
    b8a8:	f04f 0a00 	movne.w	sl, #0
    b8ac:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b8b0:	24b8      	movs	r4, #184	; 0xb8
    b8b2:	4572      	cmp	r2, lr
    b8b4:	bf08      	it	eq
    b8b6:	f04a 0a01 	orreq.w	sl, sl, #1
    b8ba:	f2c4 0702 	movt	r7, #16386	; 0x4002
    b8be:	f44f 6685 	mov.w	r6, #1064	; 0x428
    b8c2:	f2c4 0402 	movt	r4, #16386	; 0x4002
    b8c6:	4562      	cmp	r2, ip
    b8c8:	bf08      	it	eq
    b8ca:	f04a 0a01 	orreq.w	sl, sl, #1
    b8ce:	9502      	str	r5, [sp, #8]
    b8d0:	f2c4 0602 	movt	r6, #16386	; 0x4002
    b8d4:	465d      	mov	r5, fp
    b8d6:	42ba      	cmp	r2, r7
    b8d8:	bf08      	it	eq
    b8da:	f04a 0a01 	orreq.w	sl, sl, #1
    b8de:	f44f 6b8b 	mov.w	fp, #1112	; 0x458
    b8e2:	9603      	str	r6, [sp, #12]
    b8e4:	462e      	mov	r6, r5
    b8e6:	42a2      	cmp	r2, r4
    b8e8:	bf08      	it	eq
    b8ea:	f04a 0a01 	orreq.w	sl, sl, #1
    b8ee:	9d02      	ldr	r5, [sp, #8]
    b8f0:	f2c4 0602 	movt	r6, #16386	; 0x4002
    b8f4:	f2c4 0b02 	movt	fp, #16386	; 0x4002
    b8f8:	42aa      	cmp	r2, r5
    b8fa:	bf08      	it	eq
    b8fc:	f04a 0a01 	orreq.w	sl, sl, #1
    b900:	f44f 6591 	mov.w	r5, #1160	; 0x488
    b904:	9604      	str	r6, [sp, #16]
    b906:	f44f 668e 	mov.w	r6, #1136	; 0x470
    b90a:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b90e:	9405      	str	r4, [sp, #20]
    b910:	f2c4 0602 	movt	r6, #16386	; 0x4002
    b914:	f44f 6494 	mov.w	r4, #1184	; 0x4a0
    b918:	9501      	str	r5, [sp, #4]
    b91a:	9d03      	ldr	r5, [sp, #12]
    b91c:	f2c4 0402 	movt	r4, #16386	; 0x4002
    b920:	42aa      	cmp	r2, r5
    b922:	bf08      	it	eq
    b924:	f04a 0a01 	orreq.w	sl, sl, #1
    b928:	9d04      	ldr	r5, [sp, #16]
    b92a:	42aa      	cmp	r2, r5
    b92c:	bf08      	it	eq
    b92e:	f04a 0a01 	orreq.w	sl, sl, #1
    b932:	9d01      	ldr	r5, [sp, #4]
    b934:	455a      	cmp	r2, fp
    b936:	bf08      	it	eq
    b938:	f04a 0a01 	orreq.w	sl, sl, #1
    b93c:	42b2      	cmp	r2, r6
    b93e:	bf08      	it	eq
    b940:	f04a 0a01 	orreq.w	sl, sl, #1
    b944:	42aa      	cmp	r2, r5
    b946:	bf08      	it	eq
    b948:	f04a 0a01 	orreq.w	sl, sl, #1
    b94c:	42a2      	cmp	r2, r4
    b94e:	bf08      	it	eq
    b950:	f04a 0a01 	orreq.w	sl, sl, #1
    b954:	f1ba 0f00 	cmp.w	sl, #0
    b958:	d105      	bne.n	b966 <HAL_DMA_Abort_IT+0x12a>
    b95a:	f44f 6a97 	mov.w	sl, #1208	; 0x4b8
    b95e:	f2c4 0a02 	movt	sl, #16386	; 0x4002
    b962:	4552      	cmp	r2, sl
    b964:	d10c      	bne.n	b980 <HAL_DMA_Abort_IT+0x144>
      hdma->State = HAL_DMA_STATE_ABORT;
    b966:	2104      	movs	r1, #4
  return HAL_OK;
    b968:	2000      	movs	r0, #0
      hdma->State = HAL_DMA_STATE_ABORT;
    b96a:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
    b96e:	6813      	ldr	r3, [r2, #0]
    b970:	f023 0301 	bic.w	r3, r3, #1
    b974:	6013      	str	r3, [r2, #0]
}
    b976:	b007      	add	sp, #28
    b978:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_ERROR;
    b97c:	2001      	movs	r0, #1
}
    b97e:	4770      	bx	lr
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b980:	6815      	ldr	r5, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b982:	2028      	movs	r0, #40	; 0x28
    b984:	2458      	movs	r4, #88	; 0x58
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b986:	f025 050e 	bic.w	r5, r5, #14
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b98a:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b98e:	f2c4 0402 	movt	r4, #16386	; 0x4002
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b992:	6015      	str	r5, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b994:	2540      	movs	r5, #64	; 0x40
      __HAL_DMA_DISABLE(hdma);
    b996:	681a      	ldr	r2, [r3, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b998:	f2c4 0502 	movt	r5, #16386	; 0x4002
      __HAL_DMA_DISABLE(hdma);
    b99c:	6811      	ldr	r1, [r2, #0]
    b99e:	f021 0101 	bic.w	r1, r1, #1
    b9a2:	6011      	str	r1, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b9a4:	2210      	movs	r2, #16
    b9a6:	6819      	ldr	r1, [r3, #0]
    b9a8:	f2c4 0202 	movt	r2, #16386	; 0x4002
    b9ac:	4281      	cmp	r1, r0
    b9ae:	bf18      	it	ne
    b9b0:	4291      	cmpne	r1, r2
    b9b2:	f04f 0070 	mov.w	r0, #112	; 0x70
    b9b6:	bf0c      	ite	eq
    b9b8:	2201      	moveq	r2, #1
    b9ba:	2200      	movne	r2, #0
    b9bc:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b9c0:	42a9      	cmp	r1, r5
    b9c2:	bf08      	it	eq
    b9c4:	f042 0201 	orreq.w	r2, r2, #1
    b9c8:	2588      	movs	r5, #136	; 0x88
    b9ca:	42a1      	cmp	r1, r4
    b9cc:	bf08      	it	eq
    b9ce:	f042 0201 	orreq.w	r2, r2, #1
    b9d2:	f2c4 0502 	movt	r5, #16386	; 0x4002
    b9d6:	24a0      	movs	r4, #160	; 0xa0
    b9d8:	4281      	cmp	r1, r0
    b9da:	bf08      	it	eq
    b9dc:	f042 0201 	orreq.w	r2, r2, #1
    b9e0:	20b8      	movs	r0, #184	; 0xb8
    b9e2:	f2c4 0402 	movt	r4, #16386	; 0x4002
    b9e6:	42a9      	cmp	r1, r5
    b9e8:	bf08      	it	eq
    b9ea:	f042 0201 	orreq.w	r2, r2, #1
    b9ee:	f2c4 0002 	movt	r0, #16386	; 0x4002
    b9f2:	f44f 6582 	mov.w	r5, #1040	; 0x410
    b9f6:	42a1      	cmp	r1, r4
    b9f8:	bf08      	it	eq
    b9fa:	f042 0201 	orreq.w	r2, r2, #1
    b9fe:	f44f 6485 	mov.w	r4, #1064	; 0x428
    ba02:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ba06:	4281      	cmp	r1, r0
    ba08:	bf08      	it	eq
    ba0a:	f042 0201 	orreq.w	r2, r2, #1
    ba0e:	f2c4 0402 	movt	r4, #16386	; 0x4002
    ba12:	f44f 6088 	mov.w	r0, #1088	; 0x440
    ba16:	42a9      	cmp	r1, r5
    ba18:	bf08      	it	eq
    ba1a:	f042 0201 	orreq.w	r2, r2, #1
    ba1e:	f44f 658b 	mov.w	r5, #1112	; 0x458
    ba22:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ba26:	42a1      	cmp	r1, r4
    ba28:	bf08      	it	eq
    ba2a:	f042 0201 	orreq.w	r2, r2, #1
    ba2e:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ba32:	f44f 648e 	mov.w	r4, #1136	; 0x470
    ba36:	4281      	cmp	r1, r0
    ba38:	bf08      	it	eq
    ba3a:	f042 0201 	orreq.w	r2, r2, #1
    ba3e:	f44f 6091 	mov.w	r0, #1160	; 0x488
    ba42:	f2c4 0402 	movt	r4, #16386	; 0x4002
    ba46:	42a9      	cmp	r1, r5
    ba48:	bf08      	it	eq
    ba4a:	f042 0201 	orreq.w	r2, r2, #1
    ba4e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    ba52:	f44f 6594 	mov.w	r5, #1184	; 0x4a0
    ba56:	42a1      	cmp	r1, r4
    ba58:	bf08      	it	eq
    ba5a:	f042 0201 	orreq.w	r2, r2, #1
    ba5e:	f44f 6497 	mov.w	r4, #1208	; 0x4b8
    ba62:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ba66:	4281      	cmp	r1, r0
    ba68:	bf08      	it	eq
    ba6a:	f042 0201 	orreq.w	r2, r2, #1
    ba6e:	f2c4 0402 	movt	r4, #16386	; 0x4002
    ba72:	f245 4008 	movw	r0, #21512	; 0x5408
    ba76:	42a9      	cmp	r1, r5
    ba78:	bf08      	it	eq
    ba7a:	f042 0201 	orreq.w	r2, r2, #1
    ba7e:	f245 451c 	movw	r5, #21532	; 0x541c
    ba82:	f6c5 0002 	movt	r0, #22530	; 0x5802
    ba86:	42a1      	cmp	r1, r4
    ba88:	bf08      	it	eq
    ba8a:	f042 0201 	orreq.w	r2, r2, #1
    ba8e:	f6c5 0502 	movt	r5, #22530	; 0x5802
    ba92:	f245 4430 	movw	r4, #21552	; 0x5430
    ba96:	4281      	cmp	r1, r0
    ba98:	bf08      	it	eq
    ba9a:	f042 0201 	orreq.w	r2, r2, #1
    ba9e:	f245 4044 	movw	r0, #21572	; 0x5444
    baa2:	f6c5 0402 	movt	r4, #22530	; 0x5802
    baa6:	42a9      	cmp	r1, r5
    baa8:	bf08      	it	eq
    baaa:	f042 0201 	orreq.w	r2, r2, #1
    baae:	f6c5 0002 	movt	r0, #22530	; 0x5802
    bab2:	f245 4558 	movw	r5, #21592	; 0x5458
    bab6:	42a1      	cmp	r1, r4
    bab8:	bf08      	it	eq
    baba:	f042 0201 	orreq.w	r2, r2, #1
    babe:	f245 446c 	movw	r4, #21612	; 0x546c
    bac2:	f6c5 0502 	movt	r5, #22530	; 0x5802
    bac6:	4281      	cmp	r1, r0
    bac8:	bf08      	it	eq
    baca:	f042 0201 	orreq.w	r2, r2, #1
    bace:	f6c5 0402 	movt	r4, #22530	; 0x5802
    bad2:	f44f 40a9 	mov.w	r0, #21632	; 0x5480
    bad6:	42a9      	cmp	r1, r5
    bad8:	bf08      	it	eq
    bada:	f042 0201 	orreq.w	r2, r2, #1
    bade:	f6c5 0002 	movt	r0, #22530	; 0x5802
    bae2:	42a1      	cmp	r1, r4
    bae4:	bf08      	it	eq
    bae6:	f042 0201 	orreq.w	r2, r2, #1
    baea:	4281      	cmp	r1, r0
    baec:	bf08      	it	eq
    baee:	f042 0201 	orreq.w	r2, r2, #1
    baf2:	b92a      	cbnz	r2, bb00 <HAL_DMA_Abort_IT+0x2c4>
    baf4:	f245 4294 	movw	r2, #21652	; 0x5494
    baf8:	f6c5 0202 	movt	r2, #22530	; 0x5802
    bafc:	4291      	cmp	r1, r2
    bafe:	d117      	bne.n	bb30 <HAL_DMA_Abort_IT+0x2f4>
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
    bb00:	6e18      	ldr	r0, [r3, #96]	; 0x60
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    bb02:	2201      	movs	r2, #1
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
    bb04:	6801      	ldr	r1, [r0, #0]
    bb06:	f421 7180 	bic.w	r1, r1, #256	; 0x100
    bb0a:	6001      	str	r1, [r0, #0]
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
    bb0c:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	; 0x58
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    bb10:	f001 011f 	and.w	r1, r1, #31
    bb14:	408a      	lsls	r2, r1
    bb16:	6042      	str	r2, [r0, #4]
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    bb18:	e9d3 2119 	ldrd	r2, r1, [r3, #100]	; 0x64
    bb1c:	6051      	str	r1, [r2, #4]
        if(hdma->DMAmuxRequestGen != 0U)
    bb1e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    bb20:	b132      	cbz	r2, bb30 <HAL_DMA_Abort_IT+0x2f4>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
    bb22:	6811      	ldr	r1, [r2, #0]
    bb24:	f421 7180 	bic.w	r1, r1, #256	; 0x100
    bb28:	6011      	str	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    bb2a:	e9d3 211c 	ldrd	r2, r1, [r3, #112]	; 0x70
    bb2e:	6051      	str	r1, [r2, #4]
      __HAL_UNLOCK(hdma);
    bb30:	2400      	movs	r4, #0
      hdma->State = HAL_DMA_STATE_READY;
    bb32:	2101      	movs	r1, #1
      if(hdma->XferAbortCallback != NULL)
    bb34:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      __HAL_UNLOCK(hdma);
    bb36:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
    bb3a:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      if(hdma->XferAbortCallback != NULL)
    bb3e:	b11a      	cbz	r2, bb48 <HAL_DMA_Abort_IT+0x30c>
    bb40:	4618      	mov	r0, r3
        hdma->XferAbortCallback(hdma);
    bb42:	4790      	blx	r2
  return HAL_OK;
    bb44:	4620      	mov	r0, r4
    bb46:	e716      	b.n	b976 <HAL_DMA_Abort_IT+0x13a>
    bb48:	4610      	mov	r0, r2
    bb4a:	e714      	b.n	b976 <HAL_DMA_Abort_IT+0x13a>

0000bb4c <HAL_DMA_GetState>:
  return hdma->State;
    bb4c:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
    bb50:	4770      	bx	lr
    bb52:	bf00      	nop

0000bb54 <HAL_DMA_GetError>:
  return hdma->ErrorCode;
    bb54:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
    bb56:	4770      	bx	lr

0000bb58 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
    bb58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bb5a:	4605      	mov	r5, r0
  uint32_t syncSignalID = 0;
  uint32_t syncPolarity = 0;

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    bb5c:	2310      	movs	r3, #16
    bb5e:	2628      	movs	r6, #40	; 0x28
    bb60:	2040      	movs	r0, #64	; 0x40
    bb62:	682a      	ldr	r2, [r5, #0]
    bb64:	f2c4 0302 	movt	r3, #16386	; 0x4002
    bb68:	f2c4 0602 	movt	r6, #16386	; 0x4002
    bb6c:	f2c4 0002 	movt	r0, #16386	; 0x4002
{
    bb70:	460c      	mov	r4, r1
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    bb72:	2158      	movs	r1, #88	; 0x58
    bb74:	429a      	cmp	r2, r3
    bb76:	bf18      	it	ne
    bb78:	42b2      	cmpne	r2, r6
    bb7a:	f04f 0670 	mov.w	r6, #112	; 0x70
    bb7e:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bb82:	bf14      	ite	ne
    bb84:	2301      	movne	r3, #1
    bb86:	2300      	moveq	r3, #0
    bb88:	f2c4 0602 	movt	r6, #16386	; 0x4002
    bb8c:	4282      	cmp	r2, r0
    bb8e:	bf0c      	ite	eq
    bb90:	2300      	moveq	r3, #0
    bb92:	f003 0301 	andne.w	r3, r3, #1
    bb96:	20a0      	movs	r0, #160	; 0xa0
    bb98:	428a      	cmp	r2, r1
    bb9a:	bf0c      	ite	eq
    bb9c:	2300      	moveq	r3, #0
    bb9e:	f003 0301 	andne.w	r3, r3, #1
    bba2:	2188      	movs	r1, #136	; 0x88
    bba4:	f2c4 0002 	movt	r0, #16386	; 0x4002
    bba8:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bbac:	42b2      	cmp	r2, r6
    bbae:	bf0c      	ite	eq
    bbb0:	2300      	moveq	r3, #0
    bbb2:	f003 0301 	andne.w	r3, r3, #1
    bbb6:	f44f 6682 	mov.w	r6, #1040	; 0x410
    bbba:	428a      	cmp	r2, r1
    bbbc:	bf0c      	ite	eq
    bbbe:	2300      	moveq	r3, #0
    bbc0:	f003 0301 	andne.w	r3, r3, #1
    bbc4:	21b8      	movs	r1, #184	; 0xb8
    bbc6:	f2c4 0602 	movt	r6, #16386	; 0x4002
    bbca:	4282      	cmp	r2, r0
    bbcc:	bf0c      	ite	eq
    bbce:	2300      	moveq	r3, #0
    bbd0:	f003 0301 	andne.w	r3, r3, #1
    bbd4:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bbd8:	f44f 6088 	mov.w	r0, #1088	; 0x440
    bbdc:	428a      	cmp	r2, r1
    bbde:	bf0c      	ite	eq
    bbe0:	2300      	moveq	r3, #0
    bbe2:	f003 0301 	andne.w	r3, r3, #1
    bbe6:	f44f 6185 	mov.w	r1, #1064	; 0x428
    bbea:	f2c4 0002 	movt	r0, #16386	; 0x4002
    bbee:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bbf2:	42b2      	cmp	r2, r6
    bbf4:	bf0c      	ite	eq
    bbf6:	2300      	moveq	r3, #0
    bbf8:	f003 0301 	andne.w	r3, r3, #1
    bbfc:	f44f 668e 	mov.w	r6, #1136	; 0x470
    bc00:	428a      	cmp	r2, r1
    bc02:	bf0c      	ite	eq
    bc04:	2300      	moveq	r3, #0
    bc06:	f003 0301 	andne.w	r3, r3, #1
    bc0a:	f44f 618b 	mov.w	r1, #1112	; 0x458
    bc0e:	f2c4 0602 	movt	r6, #16386	; 0x4002
    bc12:	4282      	cmp	r2, r0
    bc14:	bf0c      	ite	eq
    bc16:	2300      	moveq	r3, #0
    bc18:	f003 0301 	andne.w	r3, r3, #1
    bc1c:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bc20:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
    bc24:	428a      	cmp	r2, r1
    bc26:	bf0c      	ite	eq
    bc28:	2300      	moveq	r3, #0
    bc2a:	f003 0301 	andne.w	r3, r3, #1
    bc2e:	f44f 6191 	mov.w	r1, #1160	; 0x488
    bc32:	f2c4 0002 	movt	r0, #16386	; 0x4002
    bc36:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bc3a:	42b2      	cmp	r2, r6
    bc3c:	bf0c      	ite	eq
    bc3e:	2300      	moveq	r3, #0
    bc40:	f003 0301 	andne.w	r3, r3, #1
    bc44:	f245 4608 	movw	r6, #21512	; 0x5408
    bc48:	428a      	cmp	r2, r1
    bc4a:	bf0c      	ite	eq
    bc4c:	2300      	moveq	r3, #0
    bc4e:	f003 0301 	andne.w	r3, r3, #1
    bc52:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
    bc56:	f6c5 0602 	movt	r6, #22530	; 0x5802
    bc5a:	4282      	cmp	r2, r0
    bc5c:	bf0c      	ite	eq
    bc5e:	2300      	moveq	r3, #0
    bc60:	f003 0301 	andne.w	r3, r3, #1
    bc64:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bc68:	f245 4030 	movw	r0, #21552	; 0x5430
    bc6c:	428a      	cmp	r2, r1
    bc6e:	bf0c      	ite	eq
    bc70:	2300      	moveq	r3, #0
    bc72:	f003 0301 	andne.w	r3, r3, #1
    bc76:	f245 411c 	movw	r1, #21532	; 0x541c
    bc7a:	f6c5 0002 	movt	r0, #22530	; 0x5802
    bc7e:	f6c5 0102 	movt	r1, #22530	; 0x5802
    bc82:	42b2      	cmp	r2, r6
    bc84:	bf0c      	ite	eq
    bc86:	2300      	moveq	r3, #0
    bc88:	f003 0301 	andne.w	r3, r3, #1
    bc8c:	f245 4658 	movw	r6, #21592	; 0x5458
    bc90:	428a      	cmp	r2, r1
    bc92:	bf0c      	ite	eq
    bc94:	2300      	moveq	r3, #0
    bc96:	f003 0301 	andne.w	r3, r3, #1
    bc9a:	f245 4144 	movw	r1, #21572	; 0x5444
    bc9e:	f6c5 0602 	movt	r6, #22530	; 0x5802
    bca2:	4282      	cmp	r2, r0
    bca4:	bf0c      	ite	eq
    bca6:	2300      	moveq	r3, #0
    bca8:	f003 0301 	andne.w	r3, r3, #1
    bcac:	f6c5 0102 	movt	r1, #22530	; 0x5802
    bcb0:	f245 406c 	movw	r0, #21612	; 0x546c
    bcb4:	428a      	cmp	r2, r1
    bcb6:	bf0c      	ite	eq
    bcb8:	2300      	moveq	r3, #0
    bcba:	f003 0301 	andne.w	r3, r3, #1
    bcbe:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
    bcc2:	f6c5 0002 	movt	r0, #22530	; 0x5802
    bcc6:	42b2      	cmp	r2, r6
    bcc8:	bf0c      	ite	eq
    bcca:	2300      	moveq	r3, #0
    bccc:	f003 0301 	andne.w	r3, r3, #1
    bcd0:	f6c5 0102 	movt	r1, #22530	; 0x5802
    bcd4:	4282      	cmp	r2, r0
    bcd6:	bf0c      	ite	eq
    bcd8:	2300      	moveq	r3, #0
    bcda:	f003 0301 	andne.w	r3, r3, #1
    bcde:	428a      	cmp	r2, r1
    bce0:	bf0c      	ite	eq
    bce2:	2300      	moveq	r3, #0
    bce4:	f003 0301 	andne.w	r3, r3, #1
    bce8:	b133      	cbz	r3, bcf8 <HAL_DMAEx_ConfigMuxSync+0x1a0>
    bcea:	f245 4394 	movw	r3, #21652	; 0x5494
    bcee:	f6c5 0302 	movt	r3, #22530	; 0x5802
    bcf2:	429a      	cmp	r2, r3
    bcf4:	f040 80f9 	bne.w	beea <HAL_DMAEx_ConfigMuxSync+0x392>
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
    bcf8:	7a23      	ldrb	r3, [r4, #8]
    bcfa:	2b01      	cmp	r3, #1
    bcfc:	d907      	bls.n	bd0e <HAL_DMAEx_ConfigMuxSync+0x1b6>
    bcfe:	f243 703c 	movw	r0, #14140	; 0x373c
    bd02:	f44f 71ca 	mov.w	r1, #404	; 0x194
    bd06:	f2c0 0003 	movt	r0, #3
    bd0a:	f00f f9d1 	bl	1b0b0 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
    bd0e:	7a63      	ldrb	r3, [r4, #9]
    bd10:	2b01      	cmp	r3, #1
    bd12:	d907      	bls.n	bd24 <HAL_DMAEx_ConfigMuxSync+0x1cc>
    bd14:	f243 703c 	movw	r0, #14140	; 0x373c
    bd18:	f240 1195 	movw	r1, #405	; 0x195
    bd1c:	f2c0 0003 	movt	r0, #3
    bd20:	f00f f9c6 	bl	1b0b0 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
    bd24:	68e3      	ldr	r3, [r4, #12]
    bd26:	3b01      	subs	r3, #1
    bd28:	2b1f      	cmp	r3, #31
    bd2a:	f200 80b4 	bhi.w	be96 <HAL_DMAEx_ConfigMuxSync+0x33e>

  if(pSyncConfig->SyncEnable == ENABLE)
    bd2e:	7a23      	ldrb	r3, [r4, #8]
    bd30:	2b01      	cmp	r3, #1
    bd32:	d02f      	beq.n	bd94 <HAL_DMAEx_ConfigMuxSync+0x23c>
  uint32_t syncPolarity = 0;
    bd34:	2200      	movs	r2, #0
  uint32_t syncSignalID = 0;
    bd36:	4611      	mov	r1, r2
    syncSignalID = pSyncConfig->SyncSignalID;
    syncPolarity = pSyncConfig->SyncPolarity;
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
    bd38:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
    bd3c:	b2db      	uxtb	r3, r3
    bd3e:	2b01      	cmp	r3, #1
    bd40:	d004      	beq.n	bd4c <HAL_DMAEx_ConfigMuxSync+0x1f4>
    return HAL_OK;
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    bd42:	f44f 6300 	mov.w	r3, #2048	; 0x800

    /* Return error status */
    return HAL_ERROR;
    bd46:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    bd48:	656b      	str	r3, [r5, #84]	; 0x54
  }
}
    bd4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hdma);
    bd4c:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
    bd50:	2801      	cmp	r0, #1
    bd52:	f000 80b3 	beq.w	bebc <HAL_DMAEx_ConfigMuxSync+0x364>
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    bd56:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    __HAL_UNLOCK(hdma);
    bd58:	2600      	movs	r6, #0
    __HAL_LOCK(hdma);
    bd5a:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    bd5e:	683b      	ldr	r3, [r7, #0]
    return HAL_OK;
    bd60:	4630      	mov	r0, r6
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    bd62:	f423 3381 	bic.w	r3, r3, #66048	; 0x10200
    bd66:	603b      	str	r3, [r7, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
    bd68:	68e7      	ldr	r7, [r4, #12]
    bd6a:	7a23      	ldrb	r3, [r4, #8]
    bd6c:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
    bd70:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    bd72:	041b      	lsls	r3, r3, #16
    bd74:	f894 e009 	ldrb.w	lr, [r4, #9]
    bd78:	683c      	ldr	r4, [r7, #0]
    bd7a:	ea43 43cc 	orr.w	r3, r3, ip, lsl #19
    bd7e:	b2e4      	uxtb	r4, r4
    bd80:	ea43 234e 	orr.w	r3, r3, lr, lsl #9
    bd84:	4323      	orrs	r3, r4
    bd86:	4313      	orrs	r3, r2
    bd88:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    bd8c:	603b      	str	r3, [r7, #0]
    __HAL_UNLOCK(hdma);
    bd8e:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
}
    bd92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
    bd94:	6863      	ldr	r3, [r4, #4]
    bd96:	f433 23c0 	bics.w	r3, r3, #393216	; 0x60000
    bd9a:	f040 8091 	bne.w	bec0 <HAL_DMAEx_ConfigMuxSync+0x368>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    bd9e:	2310      	movs	r3, #16
    bda0:	2128      	movs	r1, #40	; 0x28
    bda2:	682a      	ldr	r2, [r5, #0]
    bda4:	2040      	movs	r0, #64	; 0x40
    bda6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    bdaa:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bdae:	f2c4 0002 	movt	r0, #16386	; 0x4002
    bdb2:	2670      	movs	r6, #112	; 0x70
    bdb4:	428a      	cmp	r2, r1
    bdb6:	bf18      	it	ne
    bdb8:	429a      	cmpne	r2, r3
    bdba:	f04f 0158 	mov.w	r1, #88	; 0x58
    bdbe:	f2c4 0602 	movt	r6, #16386	; 0x4002
    bdc2:	bf0c      	ite	eq
    bdc4:	2301      	moveq	r3, #1
    bdc6:	2300      	movne	r3, #0
    bdc8:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bdcc:	4282      	cmp	r2, r0
    bdce:	bf08      	it	eq
    bdd0:	f043 0301 	orreq.w	r3, r3, #1
    bdd4:	20a0      	movs	r0, #160	; 0xa0
    bdd6:	428a      	cmp	r2, r1
    bdd8:	bf08      	it	eq
    bdda:	f043 0301 	orreq.w	r3, r3, #1
    bdde:	2188      	movs	r1, #136	; 0x88
    bde0:	f2c4 0002 	movt	r0, #16386	; 0x4002
    bde4:	f2c4 0102 	movt	r1, #16386	; 0x4002
    bde8:	42b2      	cmp	r2, r6
    bdea:	bf08      	it	eq
    bdec:	f043 0301 	orreq.w	r3, r3, #1
    bdf0:	f44f 6682 	mov.w	r6, #1040	; 0x410
    bdf4:	428a      	cmp	r2, r1
    bdf6:	bf08      	it	eq
    bdf8:	f043 0301 	orreq.w	r3, r3, #1
    bdfc:	21b8      	movs	r1, #184	; 0xb8
    bdfe:	f2c4 0602 	movt	r6, #16386	; 0x4002
    be02:	4282      	cmp	r2, r0
    be04:	bf08      	it	eq
    be06:	f043 0301 	orreq.w	r3, r3, #1
    be0a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    be0e:	f44f 6088 	mov.w	r0, #1088	; 0x440
    be12:	428a      	cmp	r2, r1
    be14:	bf08      	it	eq
    be16:	f043 0301 	orreq.w	r3, r3, #1
    be1a:	f44f 6185 	mov.w	r1, #1064	; 0x428
    be1e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    be22:	f2c4 0102 	movt	r1, #16386	; 0x4002
    be26:	42b2      	cmp	r2, r6
    be28:	bf08      	it	eq
    be2a:	f043 0301 	orreq.w	r3, r3, #1
    be2e:	f44f 668e 	mov.w	r6, #1136	; 0x470
    be32:	428a      	cmp	r2, r1
    be34:	bf08      	it	eq
    be36:	f043 0301 	orreq.w	r3, r3, #1
    be3a:	f44f 618b 	mov.w	r1, #1112	; 0x458
    be3e:	f2c4 0602 	movt	r6, #16386	; 0x4002
    be42:	4282      	cmp	r2, r0
    be44:	bf08      	it	eq
    be46:	f043 0301 	orreq.w	r3, r3, #1
    be4a:	f2c4 0102 	movt	r1, #16386	; 0x4002
    be4e:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
    be52:	428a      	cmp	r2, r1
    be54:	bf08      	it	eq
    be56:	f043 0301 	orreq.w	r3, r3, #1
    be5a:	f44f 6191 	mov.w	r1, #1160	; 0x488
    be5e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    be62:	f2c4 0102 	movt	r1, #16386	; 0x4002
    be66:	42b2      	cmp	r2, r6
    be68:	bf08      	it	eq
    be6a:	f043 0301 	orreq.w	r3, r3, #1
    be6e:	428a      	cmp	r2, r1
    be70:	bf08      	it	eq
    be72:	f043 0301 	orreq.w	r3, r3, #1
    be76:	6821      	ldr	r1, [r4, #0]
    be78:	4282      	cmp	r2, r0
    be7a:	bf08      	it	eq
    be7c:	f043 0301 	orreq.w	r3, r3, #1
    be80:	b92b      	cbnz	r3, be8e <HAL_DMAEx_ConfigMuxSync+0x336>
    be82:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
    be86:	f2c4 0302 	movt	r3, #16386	; 0x4002
    be8a:	429a      	cmp	r2, r3
    be8c:	d121      	bne.n	bed2 <HAL_DMAEx_ConfigMuxSync+0x37a>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    be8e:	2907      	cmp	r1, #7
    be90:	d80a      	bhi.n	bea8 <HAL_DMAEx_ConfigMuxSync+0x350>
    syncPolarity = pSyncConfig->SyncPolarity;
    be92:	6862      	ldr	r2, [r4, #4]
    be94:	e750      	b.n	bd38 <HAL_DMAEx_ConfigMuxSync+0x1e0>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
    be96:	f243 703c 	movw	r0, #14140	; 0x373c
    be9a:	f44f 71cb 	mov.w	r1, #406	; 0x196
    be9e:	f2c0 0003 	movt	r0, #3
    bea2:	f00f f905 	bl	1b0b0 <assert_failed>
    bea6:	e742      	b.n	bd2e <HAL_DMAEx_ConfigMuxSync+0x1d6>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    bea8:	f243 703c 	movw	r0, #14140	; 0x373c
    beac:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    beb0:	f2c0 0003 	movt	r0, #3
    beb4:	f00f f8fc 	bl	1b0b0 <assert_failed>
    beb8:	6821      	ldr	r1, [r4, #0]
    beba:	e7ea      	b.n	be92 <HAL_DMAEx_ConfigMuxSync+0x33a>
    __HAL_LOCK(hdma);
    bebc:	2002      	movs	r0, #2
}
    bebe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
    bec0:	f243 703c 	movw	r0, #14140	; 0x373c
    bec4:	f44f 71cd 	mov.w	r1, #410	; 0x19a
    bec8:	f2c0 0003 	movt	r0, #3
    becc:	f00f f8f0 	bl	1b0b0 <assert_failed>
    bed0:	e765      	b.n	bd9e <HAL_DMAEx_ConfigMuxSync+0x246>
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    bed2:	290f      	cmp	r1, #15
    bed4:	d9dd      	bls.n	be92 <HAL_DMAEx_ConfigMuxSync+0x33a>
    bed6:	f243 703c 	movw	r0, #14140	; 0x373c
    beda:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
    bede:	f2c0 0003 	movt	r0, #3
    bee2:	f00f f8e5 	bl	1b0b0 <assert_failed>
    bee6:	6821      	ldr	r1, [r4, #0]
    bee8:	e7d3      	b.n	be92 <HAL_DMAEx_ConfigMuxSync+0x33a>
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    beea:	f243 703c 	movw	r0, #14140	; 0x373c
    beee:	f240 1193 	movw	r1, #403	; 0x193
    bef2:	f2c0 0003 	movt	r0, #3
    bef6:	f00f f8db 	bl	1b0b0 <assert_failed>
    befa:	e6fd      	b.n	bcf8 <HAL_DMAEx_ConfigMuxSync+0x1a0>

0000befc <FLASH_WaitForLastOperation.constprop.3>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
    befc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    befe:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
    bf00:	f7fc fa9e 	bl	8440 <HAL_GetTick>
    bf04:	4606      	mov	r6, r0

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    bf06:	1e6b      	subs	r3, r5, #1
    bf08:	2b01      	cmp	r3, #1
    bf0a:	d811      	bhi.n	bf30 <FLASH_WaitForLastOperation.constprop.3+0x34>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
    bf0c:	2d01      	cmp	r5, #1
    bf0e:	d117      	bne.n	bf40 <FLASH_WaitForLastOperation.constprop.3+0x44>
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
    bf10:	f44f 5400 	mov.w	r4, #8192	; 0x2000
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    bf14:	f24c 3550 	movw	r5, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    bf18:	f2c5 2400 	movt	r4, #20992	; 0x5200
    bf1c:	6923      	ldr	r3, [r4, #16]
    bf1e:	075b      	lsls	r3, r3, #29
    bf20:	d548      	bpl.n	bfb4 <FLASH_WaitForLastOperation.constprop.3+0xb8>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    bf22:	f7fc fa8d 	bl	8440 <HAL_GetTick>
    bf26:	1b80      	subs	r0, r0, r6
    bf28:	42a8      	cmp	r0, r5
    bf2a:	d9f7      	bls.n	bf1c <FLASH_WaitForLastOperation.constprop.3+0x20>
      {
        return HAL_TIMEOUT;
    bf2c:	2003      	movs	r0, #3
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }

  return HAL_OK;
}
    bf2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    bf30:	f243 7078 	movw	r0, #14200	; 0x3778
    bf34:	f240 3192 	movw	r1, #914	; 0x392
    bf38:	f2c0 0003 	movt	r0, #3
    bf3c:	f00f f8b8 	bl	1b0b0 <assert_failed>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    bf40:	f44f 5400 	mov.w	r4, #8192	; 0x2000
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    bf44:	f24c 3750 	movw	r7, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    bf48:	f2c5 2400 	movt	r4, #20992	; 0x5200
    bf4c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    bf50:	075a      	lsls	r2, r3, #29
    bf52:	d508      	bpl.n	bf66 <FLASH_WaitForLastOperation.constprop.3+0x6a>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    bf54:	f7fc fa74 	bl	8440 <HAL_GetTick>
    bf58:	1b80      	subs	r0, r0, r6
    bf5a:	42b8      	cmp	r0, r7
    bf5c:	d8e6      	bhi.n	bf2c <FLASH_WaitForLastOperation.constprop.3+0x30>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    bf5e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    bf62:	075a      	lsls	r2, r3, #29
    bf64:	d4f6      	bmi.n	bf54 <FLASH_WaitForLastOperation.constprop.3+0x58>
  if (Bank == FLASH_BANK_1)
    bf66:	2d01      	cmp	r5, #1
    bf68:	d024      	beq.n	bfb4 <FLASH_WaitForLastOperation.constprop.3+0xb8>
  if((errorflag & 0x7DFFFFFFU) != 0U)
    bf6a:	2300      	movs	r3, #0
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    bf6c:	f8d4 2110 	ldr.w	r2, [r4, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
    bf70:	f2c1 53ee 	movt	r3, #5614	; 0x15ee
    bf74:	ea12 0003 	ands.w	r0, r2, r3
    bf78:	d010      	beq.n	bf9c <FLASH_WaitForLastOperation.constprop.3+0xa0>
    pFlash.ErrorCode |= errorflag;
    bf7a:	f646 11c8 	movw	r1, #27080	; 0x69c8
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    bf7e:	2500      	movs	r5, #0
    return HAL_ERROR;
    bf80:	2001      	movs	r0, #1
    pFlash.ErrorCode |= errorflag;
    bf82:	f2c0 210e 	movt	r1, #526	; 0x20e
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    bf86:	f2c1 75ee 	movt	r5, #6126	; 0x17ee
    pFlash.ErrorCode |= errorflag;
    bf8a:	698b      	ldr	r3, [r1, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    bf8c:	402a      	ands	r2, r5
    pFlash.ErrorCode |= errorflag;
    bf8e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    bf92:	4313      	orrs	r3, r2
    bf94:	618b      	str	r3, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    bf96:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
}
    bf9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
    bf9c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    bfa0:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    bfa4:	d004      	beq.n	bfb0 <FLASH_WaitForLastOperation.constprop.3+0xb4>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    bfa6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    bfaa:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
    bfae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
    bfb0:	4618      	mov	r0, r3
}
    bfb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    bfb4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  if((errorflag & 0x7DFFFFFFU) != 0U)
    bfb8:	2000      	movs	r0, #0
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    bfba:	f2c5 2200 	movt	r2, #20992	; 0x5200
  if((errorflag & 0x7DFFFFFFU) != 0U)
    bfbe:	f2c1 50ee 	movt	r0, #5614	; 0x15ee
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    bfc2:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
    bfc4:	4018      	ands	r0, r3
    bfc6:	d107      	bne.n	bfd8 <FLASH_WaitForLastOperation.constprop.3+0xdc>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
    bfc8:	6913      	ldr	r3, [r2, #16]
    bfca:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    bfce:	d0ef      	beq.n	bfb0 <FLASH_WaitForLastOperation.constprop.3+0xb4>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
    bfd0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    bfd4:	6153      	str	r3, [r2, #20]
}
    bfd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    bfd8:	2400      	movs	r4, #0
    pFlash.ErrorCode |= errorflag;
    bfda:	f646 11c8 	movw	r1, #27080	; 0x69c8
    return HAL_ERROR;
    bfde:	2001      	movs	r0, #1
    pFlash.ErrorCode |= errorflag;
    bfe0:	f2c0 210e 	movt	r1, #526	; 0x20e
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    bfe4:	f2c1 74ee 	movt	r4, #6126	; 0x17ee
    bfe8:	4023      	ands	r3, r4
    pFlash.ErrorCode |= errorflag;
    bfea:	698c      	ldr	r4, [r1, #24]
    bfec:	431c      	orrs	r4, r3
    bfee:	618c      	str	r4, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    bff0:	6153      	str	r3, [r2, #20]
}
    bff2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000bff4 <HAL_FLASH_Program>:
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    bff4:	2801      	cmp	r0, #1
{
    bff6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bffa:	460d      	mov	r5, r1
    bffc:	4616      	mov	r6, r2
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    bffe:	d006      	beq.n	c00e <HAL_FLASH_Program+0x1a>
    c000:	f243 7078 	movw	r0, #14200	; 0x3778
    c004:	219b      	movs	r1, #155	; 0x9b
    c006:	f2c0 0003 	movt	r0, #3
    c00a:	f00f f851 	bl	1b0b0 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    c00e:	f105 4778 	add.w	r7, r5, #4160749568	; 0xf8000000
    c012:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
    c016:	d25c      	bcs.n	c0d2 <HAL_FLASH_Program+0xde>
  __HAL_LOCK(&pFlash);
    c018:	f646 14c8 	movw	r4, #27080	; 0x69c8
    c01c:	f2c0 240e 	movt	r4, #526	; 0x20e
    c020:	7d23      	ldrb	r3, [r4, #20]
    c022:	2b01      	cmp	r3, #1
    c024:	d063      	beq.n	c0ee <HAL_FLASH_Program+0xfa>
    c026:	f04f 0801 	mov.w	r8, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    c02a:	f5b7 1f80 	cmp.w	r7, #1048576	; 0x100000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    c02e:	f04f 0300 	mov.w	r3, #0
  __HAL_LOCK(&pFlash);
    c032:	f884 8014 	strb.w	r8, [r4, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    c036:	d33d      	bcc.n	c0b4 <HAL_FLASH_Program+0xc0>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    c038:	2002      	movs	r0, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    c03a:	61a3      	str	r3, [r4, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    c03c:	f7ff ff5e 	bl	befc <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
    c040:	2800      	cmp	r0, #0
    c042:	d133      	bne.n	c0ac <HAL_FLASH_Program+0xb8>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
    c044:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    bank = FLASH_BANK_2;
    c048:	f04f 0802 	mov.w	r8, #2
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
    c04c:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c050:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c054:	ea42 0208 	orr.w	r2, r2, r8
    c058:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    c05c:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    c060:	f3bf 8f4f 	dsb	sy
        *dest_addr = *src_addr;
    c064:	6833      	ldr	r3, [r6, #0]
    c066:	602b      	str	r3, [r5, #0]
    c068:	6873      	ldr	r3, [r6, #4]
    c06a:	606b      	str	r3, [r5, #4]
    c06c:	68b3      	ldr	r3, [r6, #8]
    c06e:	60ab      	str	r3, [r5, #8]
    c070:	68f3      	ldr	r3, [r6, #12]
    c072:	60eb      	str	r3, [r5, #12]
    c074:	6933      	ldr	r3, [r6, #16]
    c076:	612b      	str	r3, [r5, #16]
    c078:	6973      	ldr	r3, [r6, #20]
    c07a:	616b      	str	r3, [r5, #20]
    c07c:	69b3      	ldr	r3, [r6, #24]
    c07e:	61ab      	str	r3, [r5, #24]
    c080:	69f3      	ldr	r3, [r6, #28]
    c082:	61eb      	str	r3, [r5, #28]
  __ASM volatile ("isb 0xF":::"memory");
    c084:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    c088:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    c08c:	4640      	mov	r0, r8
    c08e:	f7ff ff35 	bl	befc <FLASH_WaitForLastOperation.constprop.3>
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    c092:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      if(bank == FLASH_BANK_1)
    c096:	f1b8 0f01 	cmp.w	r8, #1
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    c09a:	f2c5 2300 	movt	r3, #20992	; 0x5200
      if(bank == FLASH_BANK_1)
    c09e:	d029      	beq.n	c0f4 <HAL_FLASH_Program+0x100>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
    c0a0:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c0a4:	f022 0202 	bic.w	r2, r2, #2
    c0a8:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  __HAL_UNLOCK(&pFlash);
    c0ac:	2300      	movs	r3, #0
    c0ae:	7523      	strb	r3, [r4, #20]
}
    c0b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    c0b4:	4640      	mov	r0, r8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    c0b6:	61a3      	str	r3, [r4, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    c0b8:	f7ff ff20 	bl	befc <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
    c0bc:	2800      	cmp	r0, #0
    c0be:	d1f5      	bne.n	c0ac <HAL_FLASH_Program+0xb8>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
    c0c0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c0c4:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c0c8:	68da      	ldr	r2, [r3, #12]
    c0ca:	f042 0202 	orr.w	r2, r2, #2
    c0ce:	60da      	str	r2, [r3, #12]
    c0d0:	e7c4      	b.n	c05c <HAL_FLASH_Program+0x68>
  __HAL_LOCK(&pFlash);
    c0d2:	f646 14c8 	movw	r4, #27080	; 0x69c8
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    c0d6:	f243 7078 	movw	r0, #14200	; 0x3778
    c0da:	219c      	movs	r1, #156	; 0x9c
  __HAL_LOCK(&pFlash);
    c0dc:	f2c0 240e 	movt	r4, #526	; 0x20e
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    c0e0:	f2c0 0003 	movt	r0, #3
    c0e4:	f00e ffe4 	bl	1b0b0 <assert_failed>
  __HAL_LOCK(&pFlash);
    c0e8:	7d23      	ldrb	r3, [r4, #20]
    c0ea:	2b01      	cmp	r3, #1
    c0ec:	d19b      	bne.n	c026 <HAL_FLASH_Program+0x32>
    c0ee:	2002      	movs	r0, #2
}
    c0f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    c0f4:	68da      	ldr	r2, [r3, #12]
    c0f6:	f022 0202 	bic.w	r2, r2, #2
    c0fa:	60da      	str	r2, [r3, #12]
    c0fc:	e7d6      	b.n	c0ac <HAL_FLASH_Program+0xb8>
    c0fe:	bf00      	nop

0000c100 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
    c100:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c104:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c108:	68da      	ldr	r2, [r3, #12]
    c10a:	07d2      	lsls	r2, r2, #31
    c10c:	d50c      	bpl.n	c128 <HAL_FLASH_Unlock+0x28>
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    c10e:	f240 1123 	movw	r1, #291	; 0x123
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    c112:	f648 12ab 	movw	r2, #35243	; 0x89ab
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    c116:	f2c4 5167 	movt	r1, #17767	; 0x4567
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    c11a:	f6cc 52ef 	movt	r2, #52719	; 0xcdef
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    c11e:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    c120:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
    c122:	68db      	ldr	r3, [r3, #12]
    c124:	07db      	lsls	r3, r3, #31
    c126:	d41a      	bmi.n	c15e <HAL_FLASH_Unlock+0x5e>
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
    c128:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c12c:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c130:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    c134:	f010 0001 	ands.w	r0, r0, #1
    c138:	d010      	beq.n	c15c <HAL_FLASH_Unlock+0x5c>
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    c13a:	f240 1123 	movw	r1, #291	; 0x123
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    c13e:	f648 12ab 	movw	r2, #35243	; 0x89ab
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    c142:	f2c4 5167 	movt	r1, #17767	; 0x4567
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    c146:	f6cc 52ef 	movt	r2, #52719	; 0xcdef
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    c14a:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    c14e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
    c152:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
      return HAL_ERROR;
    c156:	f000 0001 	and.w	r0, r0, #1
    c15a:	4770      	bx	lr
    c15c:	4770      	bx	lr
    c15e:	2001      	movs	r0, #1
}
    c160:	4770      	bx	lr
    c162:	bf00      	nop

0000c164 <FLASH_WaitForLastOperation>:
{
    c164:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c168:	460d      	mov	r5, r1
    c16a:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
    c16c:	f7fc f968 	bl	8440 <HAL_GetTick>
    c170:	4680      	mov	r8, r0
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    c172:	1e6b      	subs	r3, r5, #1
    c174:	2b01      	cmp	r3, #1
    c176:	d872      	bhi.n	c25e <FLASH_WaitForLastOperation+0xfa>
    bsyflag = FLASH_FLAG_QW_BANK2;
    c178:	2404      	movs	r4, #4
    c17a:	2d01      	cmp	r5, #1
    c17c:	f2c8 0400 	movt	r4, #32768	; 0x8000
    c180:	bf08      	it	eq
    c182:	2404      	moveq	r4, #4
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    c184:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    c188:	f2c5 2700 	movt	r7, #20992	; 0x5200
    c18c:	2c04      	cmp	r4, #4
    c18e:	d03b      	beq.n	c208 <FLASH_WaitForLastOperation+0xa4>
    c190:	1c70      	adds	r0, r6, #1
    c192:	d129      	bne.n	c1e8 <FLASH_WaitForLastOperation+0x84>
    c194:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    c198:	f2c5 2200 	movt	r2, #20992	; 0x5200
    c19c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
    c1a0:	ea24 0303 	bic.w	r3, r4, r3
    c1a4:	0759      	lsls	r1, r3, #29
    c1a6:	d5f9      	bpl.n	c19c <FLASH_WaitForLastOperation+0x38>
  if (Bank == FLASH_BANK_1)
    c1a8:	2d01      	cmp	r5, #1
    c1aa:	d038      	beq.n	c21e <FLASH_WaitForLastOperation+0xba>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    c1ac:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  if((errorflag & 0x7DFFFFFFU) != 0U)
    c1b0:	2300      	movs	r3, #0
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    c1b2:	f2c5 2100 	movt	r1, #20992	; 0x5200
  if((errorflag & 0x7DFFFFFFU) != 0U)
    c1b6:	f2c1 53ee 	movt	r3, #5614	; 0x15ee
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    c1ba:	f8d1 2110 	ldr.w	r2, [r1, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
    c1be:	ea12 0003 	ands.w	r0, r2, r3
    c1c2:	d03e      	beq.n	c242 <FLASH_WaitForLastOperation+0xde>
    pFlash.ErrorCode |= errorflag;
    c1c4:	f646 14c8 	movw	r4, #27080	; 0x69c8
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    c1c8:	2500      	movs	r5, #0
    return HAL_ERROR;
    c1ca:	2001      	movs	r0, #1
    pFlash.ErrorCode |= errorflag;
    c1cc:	f2c0 240e 	movt	r4, #526	; 0x20e
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    c1d0:	f2c1 75ee 	movt	r5, #6126	; 0x17ee
    pFlash.ErrorCode |= errorflag;
    c1d4:	69a3      	ldr	r3, [r4, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    c1d6:	402a      	ands	r2, r5
    pFlash.ErrorCode |= errorflag;
    c1d8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    c1dc:	4313      	orrs	r3, r2
    c1de:	61a3      	str	r3, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    c1e0:	f8c1 2114 	str.w	r2, [r1, #276]	; 0x114
}
    c1e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    c1e8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
    c1ec:	ea24 0303 	bic.w	r3, r4, r3
    c1f0:	075b      	lsls	r3, r3, #29
    c1f2:	d4d9      	bmi.n	c1a8 <FLASH_WaitForLastOperation+0x44>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    c1f4:	f7fc f924 	bl	8440 <HAL_GetTick>
    c1f8:	eba0 0008 	sub.w	r0, r0, r8
    c1fc:	42b0      	cmp	r0, r6
    c1fe:	d801      	bhi.n	c204 <FLASH_WaitForLastOperation+0xa0>
    c200:	2e00      	cmp	r6, #0
    c202:	d1c3      	bne.n	c18c <FLASH_WaitForLastOperation+0x28>
        return HAL_TIMEOUT;
    c204:	2003      	movs	r0, #3
    c206:	e7ed      	b.n	c1e4 <FLASH_WaitForLastOperation+0x80>
    c208:	1c70      	adds	r0, r6, #1
    c20a:	d134      	bne.n	c276 <FLASH_WaitForLastOperation+0x112>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    c20c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    c210:	f2c5 2200 	movt	r2, #20992	; 0x5200
    c214:	6913      	ldr	r3, [r2, #16]
    c216:	0759      	lsls	r1, r3, #29
    c218:	d4fc      	bmi.n	c214 <FLASH_WaitForLastOperation+0xb0>
  if (Bank == FLASH_BANK_1)
    c21a:	2d01      	cmp	r5, #1
    c21c:	d1c6      	bne.n	c1ac <FLASH_WaitForLastOperation+0x48>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    c21e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  if((errorflag & 0x7DFFFFFFU) != 0U)
    c222:	2000      	movs	r0, #0
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    c224:	f2c5 2200 	movt	r2, #20992	; 0x5200
  if((errorflag & 0x7DFFFFFFU) != 0U)
    c228:	f2c1 50ee 	movt	r0, #5614	; 0x15ee
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    c22c:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
    c22e:	4018      	ands	r0, r3
    c230:	d125      	bne.n	c27e <FLASH_WaitForLastOperation+0x11a>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
    c232:	6915      	ldr	r5, [r2, #16]
    c234:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
    c238:	d00e      	beq.n	c258 <FLASH_WaitForLastOperation+0xf4>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
    c23a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    c23e:	6153      	str	r3, [r2, #20]
    c240:	e7d0      	b.n	c1e4 <FLASH_WaitForLastOperation+0x80>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
    c242:	f8d1 5110 	ldr.w	r5, [r1, #272]	; 0x110
    c246:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
    c24a:	d005      	beq.n	c258 <FLASH_WaitForLastOperation+0xf4>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    c24c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    c250:	f8c1 3114 	str.w	r3, [r1, #276]	; 0x114
}
    c254:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return HAL_OK;
    c258:	4628      	mov	r0, r5
}
    c25a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    c25e:	f243 7078 	movw	r0, #14200	; 0x3778
    bsyflag = FLASH_FLAG_QW_BANK2;
    c262:	2404      	movs	r4, #4
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    c264:	f240 3192 	movw	r1, #914	; 0x392
    c268:	f2c0 0003 	movt	r0, #3
    bsyflag = FLASH_FLAG_QW_BANK2;
    c26c:	f2c8 0400 	movt	r4, #32768	; 0x8000
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    c270:	f00e ff1e 	bl	1b0b0 <assert_failed>
    c274:	e786      	b.n	c184 <FLASH_WaitForLastOperation+0x20>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    c276:	693b      	ldr	r3, [r7, #16]
    c278:	075b      	lsls	r3, r3, #29
    c27a:	d4bb      	bmi.n	c1f4 <FLASH_WaitForLastOperation+0x90>
    c27c:	e794      	b.n	c1a8 <FLASH_WaitForLastOperation+0x44>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    c27e:	2400      	movs	r4, #0
    pFlash.ErrorCode |= errorflag;
    c280:	f646 11c8 	movw	r1, #27080	; 0x69c8
    return HAL_ERROR;
    c284:	4628      	mov	r0, r5
    pFlash.ErrorCode |= errorflag;
    c286:	f2c0 210e 	movt	r1, #526	; 0x20e
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    c28a:	f2c1 74ee 	movt	r4, #6126	; 0x17ee
    c28e:	4023      	ands	r3, r4
    pFlash.ErrorCode |= errorflag;
    c290:	698c      	ldr	r4, [r1, #24]
    c292:	431c      	orrs	r4, r3
    c294:	618c      	str	r4, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    c296:	6153      	str	r3, [r2, #20]
}
    c298:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000c29c <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
    c29c:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    c29e:	f030 0330 	bics.w	r3, r0, #48	; 0x30
{
    c2a2:	4605      	mov	r5, r0
    c2a4:	460c      	mov	r4, r1
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    c2a6:	d007      	beq.n	c2b8 <FLASH_MassErase+0x1c>
    c2a8:	f243 70b4 	movw	r0, #14260	; 0x37b4
    c2ac:	f44f 7144 	mov.w	r1, #784	; 0x310
    c2b0:	f2c0 0003 	movt	r0, #3
    c2b4:	f00e fefc 	bl	1b0b0 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));
    c2b8:	1e63      	subs	r3, r4, #1
    c2ba:	2b02      	cmp	r3, #2
    c2bc:	d82c      	bhi.n	c318 <FLASH_MassErase+0x7c>

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
    c2be:	f004 0303 	and.w	r3, r4, #3
    c2c2:	2b03      	cmp	r3, #3
    c2c4:	d034      	beq.n	c330 <FLASH_MassErase+0x94>
    FLASH->OPTCR |= FLASH_OPTCR_MER;
  }
  else
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
    c2c6:	07e2      	lsls	r2, r4, #31
    c2c8:	d50e      	bpl.n	c2e8 <FLASH_MassErase+0x4c>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
    c2ca:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c2ce:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c2d2:	68da      	ldr	r2, [r3, #12]
    c2d4:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    c2d8:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
    c2da:	68da      	ldr	r2, [r3, #12]
    c2dc:	432a      	orrs	r2, r5
    c2de:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
    c2e0:	68da      	ldr	r2, [r3, #12]
    c2e2:	f042 0288 	orr.w	r2, r2, #136	; 0x88
    c2e6:	60da      	str	r2, [r3, #12]
    }
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c2e8:	07a3      	lsls	r3, r4, #30
    c2ea:	d514      	bpl.n	c316 <FLASH_MassErase+0x7a>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
    c2ec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c2f0:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c2f4:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c2f8:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    c2fc:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
    c300:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c304:	4315      	orrs	r5, r2
    c306:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    c30a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c30e:	f042 0288 	orr.w	r2, r2, #136	; 0x88
    c312:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    }
  }
}
    c316:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FLASH_BANK(Banks));
    c318:	f243 70b4 	movw	r0, #14260	; 0x37b4
    c31c:	f44f 7145 	mov.w	r1, #788	; 0x314
    c320:	f2c0 0003 	movt	r0, #3
    c324:	f00e fec4 	bl	1b0b0 <assert_failed>
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
    c328:	f004 0303 	and.w	r3, r4, #3
    c32c:	2b03      	cmp	r3, #3
    c32e:	d1ca      	bne.n	c2c6 <FLASH_MassErase+0x2a>
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
    c330:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c334:	f2c5 2300 	movt	r3, #20992	; 0x5200
    c338:	68da      	ldr	r2, [r3, #12]
    c33a:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    c33e:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
    c340:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c344:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    c348:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    FLASH->CR1 |= VoltageRange;
    c34c:	68da      	ldr	r2, [r3, #12]
    c34e:	432a      	orrs	r2, r5
    c350:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
    c352:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    c356:	4315      	orrs	r5, r2
    c358:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
    FLASH->OPTCR |= FLASH_OPTCR_MER;
    c35c:	699a      	ldr	r2, [r3, #24]
    c35e:	f042 0210 	orr.w	r2, r2, #16
    c362:	619a      	str	r2, [r3, #24]
}
    c364:	bd38      	pop	{r3, r4, r5, pc}
    c366:	bf00      	nop

0000c368 <HAL_FLASHEx_Erase>:
{
    c368:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    c36c:	6803      	ldr	r3, [r0, #0]
{
    c36e:	b083      	sub	sp, #12
    c370:	4604      	mov	r4, r0
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    c372:	2b01      	cmp	r3, #1
{
    c374:	9100      	str	r1, [sp, #0]
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    c376:	d906      	bls.n	c386 <HAL_FLASHEx_Erase+0x1e>
    c378:	f243 70b4 	movw	r0, #14260	; 0x37b4
    c37c:	21ac      	movs	r1, #172	; 0xac
    c37e:	f2c0 0003 	movt	r0, #3
    c382:	f00e fe95 	bl	1b0b0 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    c386:	6863      	ldr	r3, [r4, #4]
    c388:	3b01      	subs	r3, #1
    c38a:	2b02      	cmp	r3, #2
    c38c:	f200 80a8 	bhi.w	c4e0 <HAL_FLASHEx_Erase+0x178>
  __HAL_LOCK(&pFlash);
    c390:	f646 17c8 	movw	r7, #27080	; 0x69c8
    c394:	f2c0 270e 	movt	r7, #526	; 0x20e
    c398:	7d3b      	ldrb	r3, [r7, #20]
    c39a:	2b01      	cmp	r3, #1
    c39c:	f000 80af 	beq.w	c4fe <HAL_FLASHEx_Erase+0x196>
    c3a0:	2501      	movs	r5, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    c3a2:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
    c3a4:	753d      	strb	r5, [r7, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    c3a6:	61bb      	str	r3, [r7, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    c3a8:	6862      	ldr	r2, [r4, #4]
    c3aa:	07d0      	lsls	r0, r2, #31
    c3ac:	f100 80ac 	bmi.w	c508 <HAL_FLASHEx_Erase+0x1a0>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c3b0:	0793      	lsls	r3, r2, #30
    c3b2:	d50c      	bpl.n	c3ce <HAL_FLASHEx_Erase+0x66>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    c3b4:	2102      	movs	r1, #2
    c3b6:	f24c 3050 	movw	r0, #50000	; 0xc350
    c3ba:	f7ff fed3 	bl	c164 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
    c3be:	b130      	cbz	r0, c3ce <HAL_FLASHEx_Erase+0x66>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    c3c0:	2301      	movs	r3, #1
  __HAL_UNLOCK(&pFlash);
    c3c2:	2200      	movs	r2, #0
}
    c3c4:	4618      	mov	r0, r3
  __HAL_UNLOCK(&pFlash);
    c3c6:	753a      	strb	r2, [r7, #20]
}
    c3c8:	b003      	add	sp, #12
    c3ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
    c3ce:	6825      	ldr	r5, [r4, #0]
    c3d0:	2d01      	cmp	r5, #1
    c3d2:	f000 80af 	beq.w	c534 <HAL_FLASHEx_Erase+0x1cc>
      *SectorError = 0xFFFFFFFFU;
    c3d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c3da:	9a00      	ldr	r2, [sp, #0]
    c3dc:	6013      	str	r3, [r2, #0]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
    c3de:	e9d4 6302 	ldrd	r6, r3, [r4, #8]
    c3e2:	4433      	add	r3, r6
    c3e4:	42b3      	cmp	r3, r6
    c3e6:	f240 80a3 	bls.w	c530 <HAL_FLASHEx_Erase+0x1c8>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c3ea:	f64f 03fb 	movw	r3, #63739	; 0xf8fb
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
  assert_param(IS_FLASH_SECTOR(Sector));
    c3ee:	f243 79b4 	movw	r9, #14260	; 0x37b4

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    c3f2:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    c3f6:	ea4f 2806 	mov.w	r8, r6, lsl #8
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c3fa:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  assert_param(IS_FLASH_SECTOR(Sector));
    c3fe:	f2c0 0903 	movt	r9, #3
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    c402:	f2c5 2500 	movt	r5, #20992	; 0x5200
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c406:	9301      	str	r3, [sp, #4]
    c408:	e03f      	b.n	c48a <HAL_FLASHEx_Erase+0x122>
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));
    c40a:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    c40e:	2901      	cmp	r1, #1
    c410:	d904      	bls.n	c41c <HAL_FLASHEx_Erase+0xb4>
    c412:	f240 3157 	movw	r1, #855	; 0x357
    c416:	4648      	mov	r0, r9
    c418:	f00e fe4a 	bl	1b0b0 <assert_failed>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    c41c:	f03b 0330 	bics.w	r3, fp, #48	; 0x30
    c420:	d004      	beq.n	c42c <HAL_FLASHEx_Erase+0xc4>
    c422:	f240 3159 	movw	r1, #857	; 0x359
    c426:	4648      	mov	r0, r9
    c428:	f00e fe42 	bl	1b0b0 <assert_failed>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
    c42c:	f01a 0f01 	tst.w	sl, #1
    c430:	d00b      	beq.n	c44a <HAL_FLASHEx_Erase+0xe2>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    c432:	68e9      	ldr	r1, [r5, #12]
    c434:	f421 61e6 	bic.w	r1, r1, #1840	; 0x730
    c438:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
    c43a:	68e9      	ldr	r1, [r5, #12]
    c43c:	f041 0184 	orr.w	r1, r1, #132	; 0x84
    c440:	ea41 010b 	orr.w	r1, r1, fp
    c444:	ea41 0108 	orr.w	r1, r1, r8
    c448:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c44a:	f01a 0f02 	tst.w	sl, #2
    c44e:	d00f      	beq.n	c470 <HAL_FLASHEx_Erase+0x108>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    c450:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    c454:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
    c458:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
    c45c:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    c460:	f043 0384 	orr.w	r3, r3, #132	; 0x84
    c464:	ea43 030b 	orr.w	r3, r3, fp
    c468:	ea43 0308 	orr.w	r3, r3, r8
    c46c:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    c470:	6863      	ldr	r3, [r4, #4]
    c472:	07da      	lsls	r2, r3, #31
    c474:	d415      	bmi.n	c4a2 <HAL_FLASHEx_Erase+0x13a>
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c476:	0798      	lsls	r0, r3, #30
    c478:	d425      	bmi.n	c4c6 <HAL_FLASHEx_Erase+0x15e>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
    c47a:	68e3      	ldr	r3, [r4, #12]
    c47c:	3601      	adds	r6, #1
    c47e:	68a2      	ldr	r2, [r4, #8]
    c480:	f508 7880 	add.w	r8, r8, #256	; 0x100
    c484:	4413      	add	r3, r2
    c486:	42b3      	cmp	r3, r6
    c488:	d952      	bls.n	c530 <HAL_FLASHEx_Erase+0x1c8>
  assert_param(IS_FLASH_SECTOR(Sector));
    c48a:	2e07      	cmp	r6, #7
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
    c48c:	f8d4 a004 	ldr.w	sl, [r4, #4]
    c490:	f8d4 b010 	ldr.w	fp, [r4, #16]
  assert_param(IS_FLASH_SECTOR(Sector));
    c494:	d9b9      	bls.n	c40a <HAL_FLASHEx_Erase+0xa2>
    c496:	f240 3156 	movw	r1, #854	; 0x356
    c49a:	4648      	mov	r0, r9
    c49c:	f00e fe08 	bl	1b0b0 <assert_failed>
    c4a0:	e7b3      	b.n	c40a <HAL_FLASHEx_Erase+0xa2>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
    c4a2:	2101      	movs	r1, #1
    c4a4:	f24c 3050 	movw	r0, #50000	; 0xc350
    c4a8:	f7ff fe5c 	bl	c164 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c4ac:	9901      	ldr	r1, [sp, #4]
    c4ae:	68ea      	ldr	r2, [r5, #12]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
    c4b0:	4603      	mov	r3, r0
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c4b2:	400a      	ands	r2, r1
    c4b4:	60ea      	str	r2, [r5, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c4b6:	6862      	ldr	r2, [r4, #4]
    c4b8:	0791      	lsls	r1, r2, #30
    c4ba:	d404      	bmi.n	c4c6 <HAL_FLASHEx_Erase+0x15e>
        if(status != HAL_OK)
    c4bc:	2b00      	cmp	r3, #0
    c4be:	d0dc      	beq.n	c47a <HAL_FLASHEx_Erase+0x112>
          *SectorError = sector_index;
    c4c0:	9a00      	ldr	r2, [sp, #0]
    c4c2:	6016      	str	r6, [r2, #0]
          break;
    c4c4:	e77d      	b.n	c3c2 <HAL_FLASHEx_Erase+0x5a>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
    c4c6:	2102      	movs	r1, #2
    c4c8:	f24c 3050 	movw	r0, #50000	; 0xc350
    c4cc:	f7ff fe4a 	bl	c164 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c4d0:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
    c4d4:	9901      	ldr	r1, [sp, #4]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
    c4d6:	4603      	mov	r3, r0
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    c4d8:	400a      	ands	r2, r1
    c4da:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
    c4de:	e7ed      	b.n	c4bc <HAL_FLASHEx_Erase+0x154>
  __HAL_LOCK(&pFlash);
    c4e0:	f646 17c8 	movw	r7, #27080	; 0x69c8
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    c4e4:	f243 70b4 	movw	r0, #14260	; 0x37b4
    c4e8:	21ad      	movs	r1, #173	; 0xad
  __HAL_LOCK(&pFlash);
    c4ea:	f2c0 270e 	movt	r7, #526	; 0x20e
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    c4ee:	f2c0 0003 	movt	r0, #3
    c4f2:	f00e fddd 	bl	1b0b0 <assert_failed>
  __HAL_LOCK(&pFlash);
    c4f6:	7d3b      	ldrb	r3, [r7, #20]
    c4f8:	2b01      	cmp	r3, #1
    c4fa:	f47f af51 	bne.w	c3a0 <HAL_FLASHEx_Erase+0x38>
    c4fe:	2302      	movs	r3, #2
}
    c500:	4618      	mov	r0, r3
    c502:	b003      	add	sp, #12
    c504:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
    c508:	4629      	mov	r1, r5
    c50a:	f24c 3050 	movw	r0, #50000	; 0xc350
    c50e:	f7ff fe29 	bl	c164 <FLASH_WaitForLastOperation>
    c512:	b158      	cbz	r0, c52c <HAL_FLASHEx_Erase+0x1c4>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c514:	6863      	ldr	r3, [r4, #4]
    c516:	079a      	lsls	r2, r3, #30
    c518:	f57f af52 	bpl.w	c3c0 <HAL_FLASHEx_Erase+0x58>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    c51c:	2102      	movs	r1, #2
    c51e:	f24c 3050 	movw	r0, #50000	; 0xc350
    c522:	9500      	str	r5, [sp, #0]
    c524:	f7ff fe1e 	bl	c164 <FLASH_WaitForLastOperation>
    c528:	9b00      	ldr	r3, [sp, #0]
    c52a:	e74a      	b.n	c3c2 <HAL_FLASHEx_Erase+0x5a>
    c52c:	6862      	ldr	r2, [r4, #4]
    c52e:	e73f      	b.n	c3b0 <HAL_FLASHEx_Erase+0x48>
    c530:	2300      	movs	r3, #0
    c532:	e746      	b.n	c3c2 <HAL_FLASHEx_Erase+0x5a>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
    c534:	6861      	ldr	r1, [r4, #4]
    c536:	6920      	ldr	r0, [r4, #16]
    c538:	f7ff feb0 	bl	c29c <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    c53c:	6862      	ldr	r2, [r4, #4]
    c53e:	f012 0301 	ands.w	r3, r2, #1
    c542:	d117      	bne.n	c574 <HAL_FLASHEx_Erase+0x20c>
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    c544:	0791      	lsls	r1, r2, #30
    c546:	f57f af3c 	bpl.w	c3c2 <HAL_FLASHEx_Erase+0x5a>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    c54a:	2102      	movs	r1, #2
    c54c:	f24c 3050 	movw	r0, #50000	; 0xc350
    c550:	9300      	str	r3, [sp, #0]
    c552:	f7ff fe07 	bl	c164 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
    c556:	f44f 5200 	mov.w	r2, #8192	; 0x2000
          status = HAL_ERROR;
    c55a:	2800      	cmp	r0, #0
    c55c:	9b00      	ldr	r3, [sp, #0]
        FLASH->CR2 &= (~FLASH_CR_BER);
    c55e:	f2c5 2200 	movt	r2, #20992	; 0x5200
          status = HAL_ERROR;
    c562:	bf18      	it	ne
    c564:	2301      	movne	r3, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
    c566:	f8d2 110c 	ldr.w	r1, [r2, #268]	; 0x10c
    c56a:	f021 0108 	bic.w	r1, r1, #8
    c56e:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
    c572:	e726      	b.n	c3c2 <HAL_FLASHEx_Erase+0x5a>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
    c574:	4629      	mov	r1, r5
    c576:	f24c 3050 	movw	r0, #50000	; 0xc350
    c57a:	f7ff fdf3 	bl	c164 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
    c57e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
          status = HAL_ERROR;
    c582:	1c03      	adds	r3, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
    c584:	f2c5 2200 	movt	r2, #20992	; 0x5200
          status = HAL_ERROR;
    c588:	bf18      	it	ne
    c58a:	2301      	movne	r3, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
    c58c:	68d1      	ldr	r1, [r2, #12]
    c58e:	f021 0108 	bic.w	r1, r1, #8
    c592:	60d1      	str	r1, [r2, #12]
    c594:	6862      	ldr	r2, [r4, #4]
    c596:	e7d5      	b.n	c544 <HAL_FLASHEx_Erase+0x1dc>

0000c598 <HAL_GPIO_Init>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    c598:	2200      	movs	r2, #0
    c59a:	f44f 6380 	mov.w	r3, #1024	; 0x400
    c59e:	f6c5 0202 	movt	r2, #22530	; 0x5802
    c5a2:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c5a6:	4290      	cmp	r0, r2
    c5a8:	bf18      	it	ne
    c5aa:	4298      	cmpne	r0, r3
{
    c5ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    c5b0:	bf18      	it	ne
    c5b2:	2301      	movne	r3, #1
{
    c5b4:	b08b      	sub	sp, #44	; 0x2c
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    c5b6:	bf08      	it	eq
    c5b8:	2300      	moveq	r3, #0
{
    c5ba:	4607      	mov	r7, r0
    c5bc:	4689      	mov	r9, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    c5be:	9301      	str	r3, [sp, #4]
    c5c0:	d03c      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c5c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
    c5c6:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c5ca:	4298      	cmp	r0, r3
    c5cc:	d036      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c5ce:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    c5d2:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c5d6:	4298      	cmp	r0, r3
    c5d8:	d030      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c5da:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    c5de:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c5e2:	4298      	cmp	r0, r3
    c5e4:	d02a      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c5e6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
    c5ea:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c5ee:	4298      	cmp	r0, r3
    c5f0:	d024      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c5f2:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
    c5f6:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c5fa:	4298      	cmp	r0, r3
    c5fc:	d01e      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c5fe:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    c602:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c606:	4298      	cmp	r0, r3
    c608:	d018      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c60a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    c60e:	f44f 5310 	mov.w	r3, #9216	; 0x2400
    c612:	f6c5 0202 	movt	r2, #22530	; 0x5802
    c616:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c61a:	4290      	cmp	r0, r2
    c61c:	bf18      	it	ne
    c61e:	4298      	cmpne	r0, r3
    c620:	d00c      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c622:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    c626:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c62a:	4298      	cmp	r0, r3
    c62c:	d006      	beq.n	c63c <HAL_GPIO_Init+0xa4>
    c62e:	f243 70f4 	movw	r0, #14324	; 0x37f4
    c632:	21bb      	movs	r1, #187	; 0xbb
    c634:	f2c0 0003 	movt	r0, #3
    c638:	f00e fd3a 	bl	1b0b0 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    c63c:	f8d9 2000 	ldr.w	r2, [r9]
    c640:	b293      	uxth	r3, r2
    c642:	2b00      	cmp	r3, #0
    c644:	f000 8184 	beq.w	c950 <HAL_GPIO_Init+0x3b8>
    c648:	2300      	movs	r3, #0
    c64a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
    c64e:	4013      	ands	r3, r2
    c650:	2b00      	cmp	r3, #0
    c652:	f040 817d 	bne.w	c950 <HAL_GPIO_Init+0x3b8>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    c656:	2300      	movs	r3, #0
    c658:	f8d9 2004 	ldr.w	r2, [r9, #4]
    c65c:	4618      	mov	r0, r3
    c65e:	4619      	mov	r1, r3
    c660:	f2c1 1321 	movt	r3, #4385	; 0x1121
    c664:	f1a2 0411 	sub.w	r4, r2, #17
    c668:	f2c1 1022 	movt	r0, #4386	; 0x1122
    c66c:	f2c1 1111 	movt	r1, #4369	; 0x1111
    c670:	429a      	cmp	r2, r3
    c672:	bf18      	it	ne
    c674:	2a03      	cmpne	r2, #3
    c676:	bf8c      	ite	hi
    c678:	2301      	movhi	r3, #1
    c67a:	2300      	movls	r3, #0
    c67c:	4282      	cmp	r2, r0
    c67e:	bf0c      	ite	eq
    c680:	2300      	moveq	r3, #0
    c682:	f003 0301 	andne.w	r3, r3, #1
    c686:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
    c68a:	2c01      	cmp	r4, #1
    c68c:	bf94      	ite	ls
    c68e:	2300      	movls	r3, #0
    c690:	f003 0301 	andhi.w	r3, r3, #1
    c694:	428a      	cmp	r2, r1
    c696:	bf0c      	ite	eq
    c698:	2300      	moveq	r3, #0
    c69a:	f003 0301 	andne.w	r3, r3, #1
    c69e:	b12b      	cbz	r3, c6ac <HAL_GPIO_Init+0x114>
    c6a0:	2300      	movs	r3, #0
    c6a2:	f2c1 1312 	movt	r3, #4370	; 0x1112
    c6a6:	429a      	cmp	r2, r3
    c6a8:	f040 81ae 	bne.w	ca08 <HAL_GPIO_Init+0x470>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    c6ac:	f8d9 3008 	ldr.w	r3, [r9, #8]
    c6b0:	2b02      	cmp	r3, #2
    c6b2:	f200 8188 	bhi.w	c9c6 <HAL_GPIO_Init+0x42e>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
    c6b6:	f8d9 1000 	ldr.w	r1, [r9]
    c6ba:	2900      	cmp	r1, #0
    c6bc:	f000 8145 	beq.w	c94a <HAL_GPIO_Init+0x3b2>

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c6c0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c6c4:	f44f 5810 	mov.w	r8, #9216	; 0x2400
    c6c8:	f44f 5220 	mov.w	r2, #10240	; 0x2800
    c6cc:	f44f 6e00 	mov.w	lr, #2048	; 0x800
    c6d0:	f6c5 0302 	movt	r3, #22530	; 0x5802
    c6d4:	f6c5 0802 	movt	r8, #22530	; 0x5802
    c6d8:	f44f 6c40 	mov.w	ip, #3072	; 0xc00
    c6dc:	f6c5 0202 	movt	r2, #22530	; 0x5802
    c6e0:	429f      	cmp	r7, r3
    c6e2:	bf18      	it	ne
    c6e4:	4547      	cmpne	r7, r8
    c6e6:	f44f 5680 	mov.w	r6, #4096	; 0x1000
    c6ea:	f44f 55a0 	mov.w	r5, #5120	; 0x1400
    c6ee:	f6c5 0e02 	movt	lr, #22530	; 0x5802
    c6f2:	bf14      	ite	ne
    c6f4:	2301      	movne	r3, #1
    c6f6:	2300      	moveq	r3, #0
    c6f8:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    c6fc:	f6c5 0502 	movt	r5, #22530	; 0x5802
    c700:	4297      	cmp	r7, r2
    c702:	bf0c      	ite	eq
    c704:	2300      	moveq	r3, #0
    c706:	f003 0301 	andne.w	r3, r3, #1
    c70a:	f44f 54c0 	mov.w	r4, #6144	; 0x1800
    c70e:	4577      	cmp	r7, lr
    c710:	bf18      	it	ne
    c712:	4567      	cmpne	r7, ip
    c714:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
    c718:	f6c5 0602 	movt	r6, #22530	; 0x5802
    c71c:	9307      	str	r3, [sp, #28]
    c71e:	f6c5 0002 	movt	r0, #22530	; 0x5802
    c722:	bf14      	ite	ne
    c724:	2301      	movne	r3, #1
    c726:	2300      	moveq	r3, #0
    c728:	f6c5 0402 	movt	r4, #22530	; 0x5802
    c72c:	42b7      	cmp	r7, r6
    c72e:	bf18      	it	ne
    c730:	42af      	cmpne	r7, r5
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c732:	f44f 4b88 	mov.w	fp, #17408	; 0x4400
    c736:	f44f 6280 	mov.w	r2, #1024	; 0x400
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c73a:	9303      	str	r3, [sp, #12]
    c73c:	bf14      	ite	ne
    c73e:	2501      	movne	r5, #1
    c740:	2500      	moveq	r5, #0

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    c742:	2300      	movs	r3, #0
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c744:	42a7      	cmp	r7, r4
    c746:	bf18      	it	ne
    c748:	4287      	cmpne	r7, r0
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c74a:	f6c5 0b02 	movt	fp, #22530	; 0x5802
    c74e:	f6c5 0200 	movt	r2, #22528	; 0x5800
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c752:	bf14      	ite	ne
    c754:	2001      	movne	r0, #1
    c756:	2000      	moveq	r0, #0
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    c758:	f6c5 0302 	movt	r3, #22530	; 0x5802
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c75c:	f04f 0800 	mov.w	r8, #0
    c760:	9504      	str	r5, [sp, #16]
    c762:	9006      	str	r0, [sp, #24]
    c764:	9302      	str	r3, [sp, #8]
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
    c766:	2401      	movs	r4, #1
    c768:	fa04 f408 	lsl.w	r4, r4, r8
    if (iocurrent != 0x00U)
    c76c:	ea14 0a01 	ands.w	sl, r4, r1
    c770:	f000 80e5 	beq.w	c93e <HAL_GPIO_Init+0x3a6>
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    c774:	f8d9 1004 	ldr.w	r1, [r9, #4]
    c778:	ea4f 0648 	mov.w	r6, r8, lsl #1
    c77c:	2503      	movs	r5, #3
    c77e:	f021 0110 	bic.w	r1, r1, #16
    c782:	40b5      	lsls	r5, r6
    c784:	3901      	subs	r1, #1
    c786:	43ed      	mvns	r5, r5
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    c788:	2901      	cmp	r1, #1
    c78a:	d814      	bhi.n	c7b6 <HAL_GPIO_Init+0x21e>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    c78c:	f8d9 100c 	ldr.w	r1, [r9, #12]
    c790:	2903      	cmp	r1, #3
    c792:	f200 80e5 	bhi.w	c960 <HAL_GPIO_Init+0x3c8>
        temp = GPIOx->OSPEEDR;
    c796:	68b8      	ldr	r0, [r7, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
    c798:	40b1      	lsls	r1, r6
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    c79a:	4028      	ands	r0, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
    c79c:	4301      	orrs	r1, r0
        GPIOx->OSPEEDR = temp;
    c79e:	60b9      	str	r1, [r7, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    c7a0:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = GPIOx->OTYPER;
    c7a4:	6878      	ldr	r0, [r7, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    c7a6:	f3c1 1100 	ubfx	r1, r1, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
    c7aa:	ea20 0004 	bic.w	r0, r0, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    c7ae:	fa01 f408 	lsl.w	r4, r1, r8
    c7b2:	4304      	orrs	r4, r0
        GPIOx->OTYPER = temp;
    c7b4:	607c      	str	r4, [r7, #4]
      temp = GPIOx->PUPDR;
    c7b6:	68f8      	ldr	r0, [r7, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
    c7b8:	f8d9 1008 	ldr.w	r1, [r9, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    c7bc:	4028      	ands	r0, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
    c7be:	40b1      	lsls	r1, r6
    c7c0:	4301      	orrs	r1, r0
      GPIOx->PUPDR = temp;
    c7c2:	60f9      	str	r1, [r7, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    c7c4:	f8d9 1004 	ldr.w	r1, [r9, #4]
    c7c8:	f021 0010 	bic.w	r0, r1, #16
    c7cc:	2802      	cmp	r0, #2
    c7ce:	d11e      	bne.n	c80e <HAL_GPIO_Init+0x276>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c7d0:	9b01      	ldr	r3, [sp, #4]
    c7d2:	b11b      	cbz	r3, c7dc <HAL_GPIO_Init+0x244>
    c7d4:	9b03      	ldr	r3, [sp, #12]
    c7d6:	2b00      	cmp	r3, #0
    c7d8:	f040 80ce 	bne.w	c978 <HAL_GPIO_Init+0x3e0>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    c7dc:	f8d9 3010 	ldr.w	r3, [r9, #16]
    c7e0:	2b0f      	cmp	r3, #15
    c7e2:	f200 80e4 	bhi.w	c9ae <HAL_GPIO_Init+0x416>
        temp = GPIOx->AFR[position >> 3U];
    c7e6:	ea4f 00d8 	mov.w	r0, r8, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    c7ea:	f008 0107 	and.w	r1, r8, #7
    c7ee:	f04f 0c0f 	mov.w	ip, #15
    c7f2:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    c7f6:	0089      	lsls	r1, r1, #2
        temp = GPIOx->AFR[position >> 3U];
    c7f8:	6a04      	ldr	r4, [r0, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    c7fa:	fa0c fc01 	lsl.w	ip, ip, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    c7fe:	fa03 f101 	lsl.w	r1, r3, r1
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    c802:	ea24 040c 	bic.w	r4, r4, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    c806:	4321      	orrs	r1, r4
        GPIOx->AFR[position >> 3U] = temp;
    c808:	6201      	str	r1, [r0, #32]
    c80a:	f8d9 1004 	ldr.w	r1, [r9, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    c80e:	f001 0103 	and.w	r1, r1, #3
      temp = GPIOx->MODER;
    c812:	6838      	ldr	r0, [r7, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    c814:	fa01 f606 	lsl.w	r6, r1, r6
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
    c818:	4005      	ands	r5, r0
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    c81a:	4335      	orrs	r5, r6
      GPIOx->MODER = temp;
    c81c:	603d      	str	r5, [r7, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
    c81e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    c822:	00ce      	lsls	r6, r1, #3
    c824:	f140 8089 	bpl.w	c93a <HAL_GPIO_Init+0x3a2>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c828:	f8db 50f4 	ldr.w	r5, [fp, #244]	; 0xf4
    c82c:	f028 0403 	bic.w	r4, r8, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    c830:	f008 0103 	and.w	r1, r8, #3
    c834:	200f      	movs	r0, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c836:	f045 0502 	orr.w	r5, r5, #2
    c83a:	4414      	add	r4, r2
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    c83c:	0089      	lsls	r1, r1, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c83e:	f8cb 50f4 	str.w	r5, [fp, #244]	; 0xf4
    c842:	f8db 50f4 	ldr.w	r5, [fp, #244]	; 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    c846:	4088      	lsls	r0, r1
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    c848:	9b02      	ldr	r3, [sp, #8]
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c84a:	f005 0502 	and.w	r5, r5, #2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    c84e:	429f      	cmp	r7, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    c850:	9509      	str	r5, [sp, #36]	; 0x24
    c852:	9d09      	ldr	r5, [sp, #36]	; 0x24
        temp = SYSCFG->EXTICR[position >> 2U];
    c854:	68a5      	ldr	r5, [r4, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    c856:	ea25 0000 	bic.w	r0, r5, r0
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    c85a:	d036      	beq.n	c8ca <HAL_GPIO_Init+0x332>
    c85c:	9b01      	ldr	r3, [sp, #4]
    c85e:	2b00      	cmp	r3, #0
    c860:	f000 80b9 	beq.w	c9d6 <HAL_GPIO_Init+0x43e>
    c864:	f44f 6500 	mov.w	r5, #2048	; 0x800
    c868:	f6c5 0502 	movt	r5, #22530	; 0x5802
    c86c:	42af      	cmp	r7, r5
    c86e:	f000 8099 	beq.w	c9a4 <HAL_GPIO_Init+0x40c>
    c872:	9b03      	ldr	r3, [sp, #12]
    c874:	2b00      	cmp	r3, #0
    c876:	f000 80b8 	beq.w	c9ea <HAL_GPIO_Init+0x452>
    c87a:	f44f 5580 	mov.w	r5, #4096	; 0x1000
    c87e:	f6c5 0502 	movt	r5, #22530	; 0x5802
    c882:	42af      	cmp	r7, r5
    c884:	f000 80b6 	beq.w	c9f4 <HAL_GPIO_Init+0x45c>
    c888:	9b04      	ldr	r3, [sp, #16]
    c88a:	2b00      	cmp	r3, #0
    c88c:	f000 80a8 	beq.w	c9e0 <HAL_GPIO_Init+0x448>
    c890:	f44f 55c0 	mov.w	r5, #6144	; 0x1800
    c894:	f6c5 0502 	movt	r5, #22530	; 0x5802
    c898:	42af      	cmp	r7, r5
    c89a:	f000 80b0 	beq.w	c9fe <HAL_GPIO_Init+0x466>
    c89e:	9b06      	ldr	r3, [sp, #24]
    c8a0:	2b00      	cmp	r3, #0
    c8a2:	f000 80b9 	beq.w	ca18 <HAL_GPIO_Init+0x480>
    c8a6:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    c8aa:	f6c5 0502 	movt	r5, #22530	; 0x5802
    c8ae:	42af      	cmp	r7, r5
    c8b0:	f000 80b7 	beq.w	ca22 <HAL_GPIO_Init+0x48a>
    c8b4:	f44f 5510 	mov.w	r5, #9216	; 0x2400
    c8b8:	f6c5 0502 	movt	r5, #22530	; 0x5802
    c8bc:	42af      	cmp	r7, r5
    c8be:	bf0c      	ite	eq
    c8c0:	2509      	moveq	r5, #9
    c8c2:	250a      	movne	r5, #10
    c8c4:	fa05 f101 	lsl.w	r1, r5, r1
    c8c8:	4308      	orrs	r0, r1
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
    c8ca:	2580      	movs	r5, #128	; 0x80
        SYSCFG->EXTICR[position >> 2U] = temp;
    c8cc:	60a0      	str	r0, [r4, #8]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    c8ce:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp &= ~(iocurrent);
    c8d2:	ea6f 040a 	mvn.w	r4, sl
        temp = EXTI_CurrentCPU->IMR1;
    c8d6:	f6c5 0500 	movt	r5, #22528	; 0x5800
    c8da:	6828      	ldr	r0, [r5, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    c8dc:	03cd      	lsls	r5, r1, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
    c8de:	f04f 0180 	mov.w	r1, #128	; 0x80
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
    c8e2:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    c8e6:	bf54      	ite	pl
    c8e8:	4020      	andpl	r0, r4
          temp |= iocurrent;
    c8ea:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI_CurrentCPU->IMR1 = temp;
    c8ee:	f6c5 0100 	movt	r1, #22528	; 0x5800
    c8f2:	6008      	str	r0, [r1, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    c8f4:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->EMR1;
    c8f8:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    c8fa:	0380      	lsls	r0, r0, #14
        EXTI_CurrentCPU->EMR1 = temp;
    c8fc:	f04f 0080 	mov.w	r0, #128	; 0x80
        temp &= ~(iocurrent);
    c900:	bf54      	ite	pl
    c902:	4021      	andpl	r1, r4
          temp |= iocurrent;
    c904:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->EMR1 = temp;
    c908:	f6c5 0000 	movt	r0, #22528	; 0x5800
    c90c:	6041      	str	r1, [r0, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    c90e:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = EXTI->RTSR1;
    c912:	6828      	ldr	r0, [r5, #0]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    c914:	02c9      	lsls	r1, r1, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
    c916:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    c91a:	bf54      	ite	pl
    c91c:	4020      	andpl	r0, r4
          temp |= iocurrent;
    c91e:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI->RTSR1 = temp;
    c922:	6008      	str	r0, [r1, #0]

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    c924:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI->FTSR1;
    c928:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    c92a:	0283      	lsls	r3, r0, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
    c92c:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    c930:	bf54      	ite	pl
    c932:	4021      	andpl	r1, r4
          temp |= iocurrent;
    c934:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI->FTSR1 = temp;
    c938:	6041      	str	r1, [r0, #4]
    c93a:	f8d9 1000 	ldr.w	r1, [r9]
      }
    }

    position++;
    c93e:	f108 0801 	add.w	r8, r8, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
    c942:	fa31 f308 	lsrs.w	r3, r1, r8
    c946:	f47f af0e 	bne.w	c766 <HAL_GPIO_Init+0x1ce>
  }
}
    c94a:	b00b      	add	sp, #44	; 0x2c
    c94c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    c950:	f243 70f4 	movw	r0, #14324	; 0x37f4
    c954:	21bc      	movs	r1, #188	; 0xbc
    c956:	f2c0 0003 	movt	r0, #3
    c95a:	f00e fba9 	bl	1b0b0 <assert_failed>
    c95e:	e67a      	b.n	c656 <HAL_GPIO_Init+0xbe>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    c960:	f243 70f4 	movw	r0, #14324	; 0x37f4
    c964:	21ce      	movs	r1, #206	; 0xce
    c966:	9205      	str	r2, [sp, #20]
    c968:	f2c0 0003 	movt	r0, #3
    c96c:	f00e fba0 	bl	1b0b0 <assert_failed>
    c970:	f8d9 100c 	ldr.w	r1, [r9, #12]
    c974:	9a05      	ldr	r2, [sp, #20]
    c976:	e70e      	b.n	c796 <HAL_GPIO_Init+0x1fe>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    c978:	9b04      	ldr	r3, [sp, #16]
    c97a:	2b00      	cmp	r3, #0
    c97c:	f43f af2e 	beq.w	c7dc <HAL_GPIO_Init+0x244>
    c980:	9b06      	ldr	r3, [sp, #24]
    c982:	2b00      	cmp	r3, #0
    c984:	f43f af2a 	beq.w	c7dc <HAL_GPIO_Init+0x244>
    c988:	9b07      	ldr	r3, [sp, #28]
    c98a:	2b00      	cmp	r3, #0
    c98c:	f43f af26 	beq.w	c7dc <HAL_GPIO_Init+0x244>
    c990:	f243 70f4 	movw	r0, #14324	; 0x37f4
    c994:	21e6      	movs	r1, #230	; 0xe6
    c996:	9205      	str	r2, [sp, #20]
    c998:	f2c0 0003 	movt	r0, #3
    c99c:	f00e fb88 	bl	1b0b0 <assert_failed>
    c9a0:	9a05      	ldr	r2, [sp, #20]
    c9a2:	e71b      	b.n	c7dc <HAL_GPIO_Init+0x244>
    c9a4:	2502      	movs	r5, #2
    c9a6:	fa05 f101 	lsl.w	r1, r5, r1
    c9aa:	4308      	orrs	r0, r1
    c9ac:	e78d      	b.n	c8ca <HAL_GPIO_Init+0x332>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    c9ae:	f243 70f4 	movw	r0, #14324	; 0x37f4
    c9b2:	21e7      	movs	r1, #231	; 0xe7
    c9b4:	9205      	str	r2, [sp, #20]
    c9b6:	f2c0 0003 	movt	r0, #3
    c9ba:	f00e fb79 	bl	1b0b0 <assert_failed>
    c9be:	f8d9 3010 	ldr.w	r3, [r9, #16]
    c9c2:	9a05      	ldr	r2, [sp, #20]
    c9c4:	e70f      	b.n	c7e6 <HAL_GPIO_Init+0x24e>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    c9c6:	f243 70f4 	movw	r0, #14324	; 0x37f4
    c9ca:	21be      	movs	r1, #190	; 0xbe
    c9cc:	f2c0 0003 	movt	r0, #3
    c9d0:	f00e fb6e 	bl	1b0b0 <assert_failed>
    c9d4:	e66f      	b.n	c6b6 <HAL_GPIO_Init+0x11e>
    c9d6:	2501      	movs	r5, #1
    c9d8:	fa05 f101 	lsl.w	r1, r5, r1
    c9dc:	4308      	orrs	r0, r1
    c9de:	e774      	b.n	c8ca <HAL_GPIO_Init+0x332>
    c9e0:	2505      	movs	r5, #5
    c9e2:	fa05 f101 	lsl.w	r1, r5, r1
    c9e6:	4308      	orrs	r0, r1
    c9e8:	e76f      	b.n	c8ca <HAL_GPIO_Init+0x332>
    c9ea:	2503      	movs	r5, #3
    c9ec:	fa05 f101 	lsl.w	r1, r5, r1
    c9f0:	4308      	orrs	r0, r1
    c9f2:	e76a      	b.n	c8ca <HAL_GPIO_Init+0x332>
    c9f4:	2504      	movs	r5, #4
    c9f6:	fa05 f101 	lsl.w	r1, r5, r1
    c9fa:	4308      	orrs	r0, r1
    c9fc:	e765      	b.n	c8ca <HAL_GPIO_Init+0x332>
    c9fe:	2506      	movs	r5, #6
    ca00:	fa05 f101 	lsl.w	r1, r5, r1
    ca04:	4308      	orrs	r0, r1
    ca06:	e760      	b.n	c8ca <HAL_GPIO_Init+0x332>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    ca08:	f243 70f4 	movw	r0, #14324	; 0x37f4
    ca0c:	21bd      	movs	r1, #189	; 0xbd
    ca0e:	f2c0 0003 	movt	r0, #3
    ca12:	f00e fb4d 	bl	1b0b0 <assert_failed>
    ca16:	e649      	b.n	c6ac <HAL_GPIO_Init+0x114>
    ca18:	2507      	movs	r5, #7
    ca1a:	fa05 f101 	lsl.w	r1, r5, r1
    ca1e:	4308      	orrs	r0, r1
    ca20:	e753      	b.n	c8ca <HAL_GPIO_Init+0x332>
    ca22:	2508      	movs	r5, #8
    ca24:	fa05 f101 	lsl.w	r1, r5, r1
    ca28:	4308      	orrs	r0, r1
    ca2a:	e74e      	b.n	c8ca <HAL_GPIO_Init+0x332>

0000ca2c <HAL_GPIO_DeInit>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    ca2c:	2200      	movs	r2, #0
    ca2e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ca32:	f6c5 0202 	movt	r2, #22530	; 0x5802
    ca36:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca3a:	4290      	cmp	r0, r2
    ca3c:	bf18      	it	ne
    ca3e:	4298      	cmpne	r0, r3
{
    ca40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    ca44:	bf18      	it	ne
    ca46:	2301      	movne	r3, #1
{
    ca48:	b089      	sub	sp, #36	; 0x24
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    ca4a:	bf08      	it	eq
    ca4c:	2300      	moveq	r3, #0
{
    ca4e:	4604      	mov	r4, r0
    ca50:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    ca52:	9302      	str	r3, [sp, #8]
    ca54:	d03d      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca56:	f44f 6300 	mov.w	r3, #2048	; 0x800
    ca5a:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca5e:	4298      	cmp	r0, r3
    ca60:	d037      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca62:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    ca66:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca6a:	4298      	cmp	r0, r3
    ca6c:	d031      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca6e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    ca72:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca76:	4298      	cmp	r0, r3
    ca78:	d02b      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca7a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
    ca7e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca82:	4298      	cmp	r0, r3
    ca84:	d025      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca86:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
    ca8a:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca8e:	4298      	cmp	r0, r3
    ca90:	d01f      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca92:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    ca96:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ca9a:	4298      	cmp	r0, r3
    ca9c:	d019      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    ca9e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    caa2:	f44f 5310 	mov.w	r3, #9216	; 0x2400
    caa6:	f6c5 0202 	movt	r2, #22530	; 0x5802
    caaa:	f6c5 0302 	movt	r3, #22530	; 0x5802
    caae:	4290      	cmp	r0, r2
    cab0:	bf18      	it	ne
    cab2:	4298      	cmpne	r0, r3
    cab4:	d00d      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    cab6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    caba:	f6c5 0302 	movt	r3, #22530	; 0x5802
    cabe:	4298      	cmp	r0, r3
    cac0:	d007      	beq.n	cad2 <HAL_GPIO_DeInit+0xa6>
    cac2:	f243 70f4 	movw	r0, #14324	; 0x37f4
    cac6:	f240 113f 	movw	r1, #319	; 0x13f
    caca:	f2c0 0003 	movt	r0, #3
    cace:	f00e faef 	bl	1b0b0 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    cad2:	b2ab      	uxth	r3, r5
    cad4:	2b00      	cmp	r3, #0
    cad6:	d072      	beq.n	cbbe <HAL_GPIO_DeInit+0x192>
    cad8:	2300      	movs	r3, #0
    cada:	f6cf 73ff 	movt	r3, #65535	; 0xffff
    cade:	402b      	ands	r3, r5
    cae0:	2b00      	cmp	r3, #0
    cae2:	d16c      	bne.n	cbbe <HAL_GPIO_DeInit+0x192>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    cae4:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    cae8:	f44f 6a80 	mov.w	sl, #1024	; 0x400
    caec:	f04f 0900 	mov.w	r9, #0
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    caf0:	f04f 0880 	mov.w	r8, #128	; 0x80
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    caf4:	f6c5 0302 	movt	r3, #22530	; 0x5802
    caf8:	f44f 6b00 	mov.w	fp, #2048	; 0x800
    cafc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    cb00:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
    cb04:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
    cb08:	f44f 56e0 	mov.w	r6, #7168	; 0x1c00
    cb0c:	9303      	str	r3, [sp, #12]
    cb0e:	f6c5 0202 	movt	r2, #22530	; 0x5802
    cb12:	f6c5 0102 	movt	r1, #22530	; 0x5802
    cb16:	f6c5 0002 	movt	r0, #22530	; 0x5802
    cb1a:	f6c5 0602 	movt	r6, #22530	; 0x5802
    cb1e:	f6c5 0a00 	movt	sl, #22528	; 0x5800
    cb22:	f6c5 0902 	movt	r9, #22530	; 0x5802
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    cb26:	f6c5 0800 	movt	r8, #22528	; 0x5800
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    cb2a:	f6c5 0b02 	movt	fp, #22530	; 0x5802
{
    cb2e:	2300      	movs	r3, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    cb30:	9204      	str	r2, [sp, #16]
    cb32:	9105      	str	r1, [sp, #20]
    cb34:	9006      	str	r0, [sp, #24]
    cb36:	9607      	str	r6, [sp, #28]
    iocurrent = GPIO_Pin & (1UL << position) ;
    cb38:	f04f 0c01 	mov.w	ip, #1
    cb3c:	fa0c f103 	lsl.w	r1, ip, r3
    if (iocurrent != 0x00U)
    cb40:	ea11 0205 	ands.w	r2, r1, r5
    cb44:	9201      	str	r2, [sp, #4]
    cb46:	f000 808c 	beq.w	cc62 <HAL_GPIO_DeInit+0x236>
    cb4a:	f023 0603 	bic.w	r6, r3, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    cb4e:	f003 0203 	and.w	r2, r3, #3
    cb52:	270f      	movs	r7, #15
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    cb54:	454c      	cmp	r4, r9
    cb56:	4456      	add	r6, sl
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    cb58:	ea4f 0282 	mov.w	r2, r2, lsl #2
      tmp = SYSCFG->EXTICR[position >> 2U];
    cb5c:	f8d6 e008 	ldr.w	lr, [r6, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    cb60:	fa07 f702 	lsl.w	r7, r7, r2
    cb64:	ea07 0e0e 	and.w	lr, r7, lr
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    cb68:	d036      	beq.n	cbd8 <HAL_GPIO_DeInit+0x1ac>
    cb6a:	9802      	ldr	r0, [sp, #8]
    cb6c:	b320      	cbz	r0, cbb8 <HAL_GPIO_DeInit+0x18c>
    cb6e:	455c      	cmp	r4, fp
    cb70:	f000 8084 	beq.w	cc7c <HAL_GPIO_DeInit+0x250>
    cb74:	9803      	ldr	r0, [sp, #12]
    cb76:	4284      	cmp	r4, r0
    cb78:	f000 8085 	beq.w	cc86 <HAL_GPIO_DeInit+0x25a>
    cb7c:	9804      	ldr	r0, [sp, #16]
    cb7e:	4284      	cmp	r4, r0
    cb80:	d077      	beq.n	cc72 <HAL_GPIO_DeInit+0x246>
    cb82:	9805      	ldr	r0, [sp, #20]
    cb84:	4284      	cmp	r4, r0
    cb86:	f000 8088 	beq.w	cc9a <HAL_GPIO_DeInit+0x26e>
    cb8a:	9806      	ldr	r0, [sp, #24]
    cb8c:	4284      	cmp	r4, r0
    cb8e:	f000 8089 	beq.w	cca4 <HAL_GPIO_DeInit+0x278>
    cb92:	9807      	ldr	r0, [sp, #28]
    cb94:	4284      	cmp	r4, r0
    cb96:	d07b      	beq.n	cc90 <HAL_GPIO_DeInit+0x264>
    cb98:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
    cb9c:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    cba0:	4564      	cmp	r4, ip
    cba2:	f000 8084 	beq.w	ccae <HAL_GPIO_DeInit+0x282>
    cba6:	f44f 5c10 	mov.w	ip, #9216	; 0x2400
    cbaa:	f6c5 0c02 	movt	ip, #22530	; 0x5802
    cbae:	4564      	cmp	r4, ip
    cbb0:	f000 8082 	beq.w	ccb8 <HAL_GPIO_DeInit+0x28c>
    cbb4:	f04f 0c0a 	mov.w	ip, #10
    cbb8:	fa0c fc02 	lsl.w	ip, ip, r2
    cbbc:	e00e      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    cbbe:	f243 70f4 	movw	r0, #14324	; 0x37f4
    cbc2:	f44f 71a0 	mov.w	r1, #320	; 0x140
    cbc6:	f2c0 0003 	movt	r0, #3
    cbca:	f00e fa71 	bl	1b0b0 <assert_failed>
  while ((GPIO_Pin >> position) != 0x00U)
    cbce:	2d00      	cmp	r5, #0
    cbd0:	d188      	bne.n	cae4 <HAL_GPIO_DeInit+0xb8>
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    }

    position++;
  }
}
    cbd2:	b009      	add	sp, #36	; 0x24
    cbd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cbd8:	f04f 0c00 	mov.w	ip, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    cbdc:	45e6      	cmp	lr, ip
    cbde:	d11e      	bne.n	cc1e <HAL_GPIO_DeInit+0x1f2>
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    cbe0:	9a01      	ldr	r2, [sp, #4]
    cbe2:	f8d8 c000 	ldr.w	ip, [r8]
    cbe6:	43d0      	mvns	r0, r2
        EXTI->RTSR1 &= ~(iocurrent);
    cbe8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    cbec:	ea0c 0c00 	and.w	ip, ip, r0
    cbf0:	f8c8 c000 	str.w	ip, [r8]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
    cbf4:	f8d8 c004 	ldr.w	ip, [r8, #4]
    cbf8:	ea00 0c0c 	and.w	ip, r0, ip
    cbfc:	f8c8 c004 	str.w	ip, [r8, #4]
        EXTI->RTSR1 &= ~(iocurrent);
    cc00:	f8d2 c000 	ldr.w	ip, [r2]
    cc04:	ea00 0c0c 	and.w	ip, r0, ip
    cc08:	f8c2 c000 	str.w	ip, [r2]
        EXTI->FTSR1 &= ~(iocurrent);
    cc0c:	f8d2 c004 	ldr.w	ip, [r2, #4]
    cc10:	ea00 000c 	and.w	r0, r0, ip
    cc14:	6050      	str	r0, [r2, #4]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
    cc16:	68b2      	ldr	r2, [r6, #8]
    cc18:	ea22 0707 	bic.w	r7, r2, r7
    cc1c:	60b7      	str	r7, [r6, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    cc1e:	2603      	movs	r6, #3
    cc20:	005a      	lsls	r2, r3, #1
    cc22:	f8d4 c000 	ldr.w	ip, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    cc26:	270f      	movs	r7, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    cc28:	fa06 f202 	lsl.w	r2, r6, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    cc2c:	fa23 f006 	lsr.w	r0, r3, r6
    cc30:	f003 0607 	and.w	r6, r3, #7
    cc34:	eb04 0080 	add.w	r0, r4, r0, lsl #2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    cc38:	ea4c 0c02 	orr.w	ip, ip, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    cc3c:	00b6      	lsls	r6, r6, #2
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    cc3e:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    cc40:	f8c4 c000 	str.w	ip, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    cc44:	40b7      	lsls	r7, r6
    cc46:	6a06      	ldr	r6, [r0, #32]
    cc48:	ea26 0607 	bic.w	r6, r6, r7
    cc4c:	6206      	str	r6, [r0, #32]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    cc4e:	68e0      	ldr	r0, [r4, #12]
    cc50:	4010      	ands	r0, r2
    cc52:	60e0      	str	r0, [r4, #12]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
    cc54:	6860      	ldr	r0, [r4, #4]
    cc56:	ea20 0101 	bic.w	r1, r0, r1
    cc5a:	6061      	str	r1, [r4, #4]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    cc5c:	68a1      	ldr	r1, [r4, #8]
    cc5e:	400a      	ands	r2, r1
    cc60:	60a2      	str	r2, [r4, #8]
    position++;
    cc62:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00U)
    cc64:	fa35 f203 	lsrs.w	r2, r5, r3
    cc68:	f47f af66 	bne.w	cb38 <HAL_GPIO_DeInit+0x10c>
}
    cc6c:	b009      	add	sp, #36	; 0x24
    cc6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cc72:	f04f 0c04 	mov.w	ip, #4
    cc76:	fa0c fc02 	lsl.w	ip, ip, r2
    cc7a:	e7af      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    cc7c:	f04f 0c02 	mov.w	ip, #2
    cc80:	fa0c fc02 	lsl.w	ip, ip, r2
    cc84:	e7aa      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    cc86:	f04f 0c03 	mov.w	ip, #3
    cc8a:	fa0c fc02 	lsl.w	ip, ip, r2
    cc8e:	e7a5      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    cc90:	f04f 0c07 	mov.w	ip, #7
    cc94:	fa0c fc02 	lsl.w	ip, ip, r2
    cc98:	e7a0      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    cc9a:	f04f 0c05 	mov.w	ip, #5
    cc9e:	fa0c fc02 	lsl.w	ip, ip, r2
    cca2:	e79b      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    cca4:	f04f 0c06 	mov.w	ip, #6
    cca8:	fa0c fc02 	lsl.w	ip, ip, r2
    ccac:	e796      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    ccae:	f04f 0c08 	mov.w	ip, #8
    ccb2:	fa0c fc02 	lsl.w	ip, ip, r2
    ccb6:	e791      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    ccb8:	f04f 0c09 	mov.w	ip, #9
    ccbc:	fa0c fc02 	lsl.w	ip, ip, r2
    ccc0:	e78c      	b.n	cbdc <HAL_GPIO_DeInit+0x1b0>
    ccc2:	bf00      	nop

0000ccc4 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
    ccc4:	b538      	push	{r3, r4, r5, lr}
    ccc6:	4605      	mov	r5, r0
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    ccc8:	460c      	mov	r4, r1
    ccca:	b129      	cbz	r1, ccd8 <HAL_GPIO_ReadPin+0x14>

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
    cccc:	692b      	ldr	r3, [r5, #16]
    ccce:	421c      	tst	r4, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
    ccd0:	bf14      	ite	ne
    ccd2:	2001      	movne	r0, #1
    ccd4:	2000      	moveq	r0, #0
    ccd6:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    ccd8:	f243 70f4 	movw	r0, #14324	; 0x37f4
    ccdc:	f240 118d 	movw	r1, #397	; 0x18d
    cce0:	f2c0 0003 	movt	r0, #3
    cce4:	f00e f9e4 	bl	1b0b0 <assert_failed>
    cce8:	e7f0      	b.n	cccc <HAL_GPIO_ReadPin+0x8>
    ccea:	bf00      	nop

0000ccec <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
    ccec:	b570      	push	{r4, r5, r6, lr}
    ccee:	4606      	mov	r6, r0
    ccf0:	4615      	mov	r5, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    ccf2:	460c      	mov	r4, r1
    ccf4:	b179      	cbz	r1, cd16 <HAL_GPIO_WritePin+0x2a>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
    ccf6:	2d01      	cmp	r5, #1
    ccf8:	d803      	bhi.n	cd02 <HAL_GPIO_WritePin+0x16>

  if (PinState != GPIO_PIN_RESET)
    ccfa:	b905      	cbnz	r5, ccfe <HAL_GPIO_WritePin+0x12>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    ccfc:	0424      	lsls	r4, r4, #16
    ccfe:	61b4      	str	r4, [r6, #24]
  }
}
    cd00:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN_ACTION(PinState));
    cd02:	f243 70f4 	movw	r0, #14324	; 0x37f4
    cd06:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
    cd0a:	f2c0 0003 	movt	r0, #3
    cd0e:	f00e f9cf 	bl	1b0b0 <assert_failed>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    cd12:	61b4      	str	r4, [r6, #24]
}
    cd14:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    cd16:	f243 70f4 	movw	r0, #14324	; 0x37f4
    cd1a:	f240 11ad 	movw	r1, #429	; 0x1ad
    cd1e:	f2c0 0003 	movt	r0, #3
    cd22:	f00e f9c5 	bl	1b0b0 <assert_failed>
    cd26:	e7e6      	b.n	ccf6 <HAL_GPIO_WritePin+0xa>

0000cd28 <HAL_HCD_HC_Init>:
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps)
{
    cd28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
    cd2c:	f890 42b8 	ldrb.w	r4, [r0, #696]	; 0x2b8
{
    cd30:	b085      	sub	sp, #20
  __HAL_LOCK(hhcd);
    cd32:	2c01      	cmp	r4, #1
{
    cd34:	f89d c038 	ldrb.w	ip, [sp, #56]	; 0x38
    cd38:	f89d e03c 	ldrb.w	lr, [sp, #60]	; 0x3c
    cd3c:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
  __HAL_LOCK(hhcd);
    cd40:	d029      	beq.n	cd96 <HAL_HCD_HC_Init+0x6e>
    cd42:	4605      	mov	r5, r0
  hhcd->hc[ch_num].do_ping = 0U;
    cd44:	eb01 0481 	add.w	r4, r1, r1, lsl #2
  __HAL_LOCK(hhcd);
    cd48:	f04f 0801 	mov.w	r8, #1
  hhcd->hc[ch_num].max_packet = mps;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;

  if ((epnum & 0x80U) == 0x80U)
    cd4c:	09d0      	lsrs	r0, r2, #7
  hhcd->hc[ch_num].do_ping = 0U;
    cd4e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
    cd52:	f002 0a7f 	and.w	sl, r2, #127	; 0x7f
  __HAL_LOCK(hhcd);
    cd56:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8
  hhcd->hc[ch_num].do_ping = 0U;
    cd5a:	f04f 0800 	mov.w	r8, #0
  hhcd->hc[ch_num].dev_addr = dev_address;
    cd5e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hhcd->hc[ch_num].max_packet = mps;
    cd62:	f8a4 9040 	strh.w	r9, [r4, #64]	; 0x40
  hhcd->hc[ch_num].ch_num = ch_num;
    cd66:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  hhcd->hc[ch_num].ep_type = ep_type;
    cd6a:	f884 e03f 	strb.w	lr, [r4, #63]	; 0x3f
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
  }

  hhcd->hc[ch_num].speed = speed;
    cd6e:	f884 c03c 	strb.w	ip, [r4, #60]	; 0x3c
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
    cd72:	f884 a03a 	strb.w	sl, [r4, #58]	; 0x3a
    cd76:	f884 003b 	strb.w	r0, [r4, #59]	; 0x3b
  hhcd->hc[ch_num].do_ping = 0U;
    cd7a:	f884 803d 	strb.w	r8, [r4, #61]	; 0x3d

  status =  USB_HC_Init(hhcd->Instance,
    cd7e:	6828      	ldr	r0, [r5, #0]
    cd80:	f8cd c000 	str.w	ip, [sp]
    cd84:	e9cd e901 	strd	lr, r9, [sp, #4]
    cd88:	f009 fa60 	bl	1624c <USB_HC_Init>
                        epnum,
                        dev_address,
                        speed,
                        ep_type,
                        mps);
  __HAL_UNLOCK(hhcd);
    cd8c:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8

  return status;
}
    cd90:	b005      	add	sp, #20
    cd92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(hhcd);
    cd96:	2002      	movs	r0, #2
}
    cd98:	b005      	add	sp, #20
    cd9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd9e:	bf00      	nop

0000cda0 <HAL_HCD_HC_Halt>:
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  HAL_StatusTypeDef status = HAL_OK;

  __HAL_LOCK(hhcd);
    cda0:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    cda4:	2b01      	cmp	r3, #1
    cda6:	d00b      	beq.n	cdc0 <HAL_HCD_HC_Halt+0x20>
    cda8:	2301      	movs	r3, #1
{
    cdaa:	b510      	push	{r4, lr}
    cdac:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
    cdae:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    cdb0:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
    cdb4:	f009 fba2 	bl	164fc <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
    cdb8:	2000      	movs	r0, #0
    cdba:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return status;
}
    cdbe:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
    cdc0:	2002      	movs	r0, #2
}
    cdc2:	4770      	bx	lr

0000cdc4 <HAL_HCD_Init>:
  if (hhcd == NULL)
    cdc4:	2800      	cmp	r0, #0
    cdc6:	d05d      	beq.n	ce84 <HAL_HCD_Init+0xc0>
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    cdc8:	2300      	movs	r3, #0
{
    cdca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    cdce:	f2c4 0308 	movt	r3, #16392	; 0x4008
    cdd2:	6804      	ldr	r4, [r0, #0]
{
    cdd4:	b08a      	sub	sp, #40	; 0x28
    cdd6:	4607      	mov	r7, r0
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    cdd8:	429c      	cmp	r4, r3
    cdda:	d00c      	beq.n	cdf6 <HAL_HCD_Init+0x32>
    cddc:	2300      	movs	r3, #0
    cdde:	f2c4 0304 	movt	r3, #16388	; 0x4004
    cde2:	429c      	cmp	r4, r3
    cde4:	d007      	beq.n	cdf6 <HAL_HCD_Init+0x32>
    cde6:	f643 0030 	movw	r0, #14384	; 0x3830
    cdea:	217a      	movs	r1, #122	; 0x7a
    cdec:	f2c0 0003 	movt	r0, #3
    cdf0:	f00e f95e 	bl	1b0b0 <assert_failed>
    cdf4:	683c      	ldr	r4, [r7, #0]
  if (hhcd->State == HAL_HCD_STATE_RESET)
    cdf6:	f897 32b9 	ldrb.w	r3, [r7, #697]	; 0x2b9
    cdfa:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    cdfe:	2b00      	cmp	r3, #0
    ce00:	d039      	beq.n	ce76 <HAL_HCD_Init+0xb2>
    ce02:	4620      	mov	r0, r4
  hhcd->State = HAL_HCD_STATE_BUSY;
    ce04:	2303      	movs	r3, #3
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    ce06:	466d      	mov	r5, sp
    ce08:	f107 0804 	add.w	r8, r7, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
    ce0c:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
  if ((USBx->CID & (0x1U << 8)) == 0U)
    ce10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    ce12:	463c      	mov	r4, r7
  if ((USBx->CID & (0x1U << 8)) == 0U)
    ce14:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hhcd->Init.dma_enable = 0U;
    ce18:	bf08      	it	eq
    ce1a:	613b      	streq	r3, [r7, #16]
  __HAL_HCD_DISABLE(hhcd);
    ce1c:	f009 f90a 	bl	16034 <USB_DisableGlobalInt>
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    ce20:	f854 6b10 	ldr.w	r6, [r4], #16
    ce24:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    ce26:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    ce28:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    ce2a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    ce2c:	e894 0003 	ldmia.w	r4, {r0, r1}
    ce30:	e885 0003 	stmia.w	r5, {r0, r1}
    ce34:	4630      	mov	r0, r6
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
    ce36:	463e      	mov	r6, r7
    ce38:	466d      	mov	r5, sp
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    ce3a:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    ce3e:	f009 f87b 	bl	15f38 <USB_CoreInit>
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
    ce42:	2101      	movs	r1, #1
    ce44:	6838      	ldr	r0, [r7, #0]
    ce46:	f009 f8fd 	bl	16044 <USB_SetCurrentMode>
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
    ce4a:	f856 cb10 	ldr.w	ip, [r6], #16
    ce4e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    ce50:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    ce52:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    ce54:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    ce56:	e894 0003 	ldmia.w	r4, {r0, r1}
    ce5a:	e885 0003 	stmia.w	r5, {r0, r1}
    ce5e:	4660      	mov	r0, ip
    ce60:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    ce64:	f009 f906 	bl	16074 <USB_HostInit>
  hhcd->State = HAL_HCD_STATE_READY;
    ce68:	2301      	movs	r3, #1
  return HAL_OK;
    ce6a:	2000      	movs	r0, #0
  hhcd->State = HAL_HCD_STATE_READY;
    ce6c:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
}
    ce70:	b00a      	add	sp, #40	; 0x28
    ce72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_HCD_MspInit(hhcd);
    ce76:	4638      	mov	r0, r7
    hhcd->Lock = HAL_UNLOCKED;
    ce78:	f887 22b8 	strb.w	r2, [r7, #696]	; 0x2b8
    HAL_HCD_MspInit(hhcd);
    ce7c:	f019 ffa0 	bl	26dc0 <HAL_HCD_MspInit>
    ce80:	6838      	ldr	r0, [r7, #0]
    ce82:	e7bf      	b.n	ce04 <HAL_HCD_Init+0x40>
    return HAL_ERROR;
    ce84:	2001      	movs	r0, #1
}
    ce86:	4770      	bx	lr

0000ce88 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
    ce88:	b5f0      	push	{r4, r5, r6, r7, lr}
    ce8a:	460c      	mov	r4, r1
  hhcd->hc[ch_num].ep_is_in = direction;
    ce8c:	0089      	lsls	r1, r1, #2
{
    ce8e:	f89d c014 	ldrb.w	ip, [sp, #20]
  hhcd->hc[ch_num].ep_is_in = direction;
    ce92:	190d      	adds	r5, r1, r4
{
    ce94:	9f06      	ldr	r7, [sp, #24]
    ce96:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
    ce9a:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
{
    ce9e:	f89d e020 	ldrb.w	lr, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
    cea2:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
  hhcd->hc[ch_num].ep_type  = ep_type;
    cea6:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f

  if (token == 0U)
    ceaa:	f1bc 0f00 	cmp.w	ip, #0
    ceae:	d137      	bne.n	cf20 <HAL_HCD_HC_SubmitRequest+0x98>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    hhcd->hc[ch_num].do_ping = do_ping;
    ceb0:	f885 e03d 	strb.w	lr, [r5, #61]	; 0x3d
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    ceb4:	f04f 0e03 	mov.w	lr, #3
    ceb8:	190d      	adds	r5, r1, r4
    ceba:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
    cebe:	f885 e042 	strb.w	lr, [r5, #66]	; 0x42
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
  }

  /* Manage Data Toggle */
  switch (ep_type)
    cec2:	2b03      	cmp	r3, #3
    cec4:	d815      	bhi.n	cef2 <HAL_HCD_HC_SubmitRequest+0x6a>
    cec6:	e8df f003 	tbb	[pc, r3]
    ceca:	3902      	.short	0x3902
    cecc:	2e2e      	.short	0x2e2e
  {
    case EP_TYPE_CTRL:
      if ((token == 1U) && (direction == 0U)) /*send data */
    cece:	f1bc 0f01 	cmp.w	ip, #1
    ced2:	d10e      	bne.n	cef2 <HAL_HCD_HC_SubmitRequest+0x6a>
    ced4:	b96a      	cbnz	r2, cef2 <HAL_HCD_HC_SubmitRequest+0x6a>
      {
        if (length == 0U)
        {
          /* For Status OUT stage, Length==0, Status Out PID = 1 */
          hhcd->hc[ch_num].toggle_out = 1U;
    ced6:	190b      	adds	r3, r1, r4
        if (length == 0U)
    ced8:	2e00      	cmp	r6, #0
    ceda:	d13e      	bne.n	cf5a <HAL_HCD_HC_SubmitRequest+0xd2>
          hhcd->hc[ch_num].toggle_out = 1U;
    cedc:	2201      	movs	r2, #1
    cede:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    cee2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
        }
        else
        {
          /* Put the PID 1 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    cee6:	190b      	adds	r3, r1, r4
    cee8:	2202      	movs	r2, #2
    ceea:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    ceee:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    default:
      break;
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
    cef2:	190b      	adds	r3, r1, r4
  hhcd->hc[ch_num].urb_state = URB_IDLE;
  hhcd->hc[ch_num].xfer_count = 0U;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].state = HC_IDLE;

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    cef4:	2128      	movs	r1, #40	; 0x28
  hhcd->hc[ch_num].urb_state = URB_IDLE;
    cef6:	2200      	movs	r2, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
    cef8:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    cefc:	fb01 0104 	mla	r1, r1, r4, r0
  hhcd->hc[ch_num].xfer_buff = pbuff;
    cf00:	645f      	str	r7, [r3, #68]	; 0x44
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    cf02:	3138      	adds	r1, #56	; 0x38
  hhcd->hc[ch_num].xfer_len  = length;
    cf04:	649e      	str	r6, [r3, #72]	; 0x48
  hhcd->hc[ch_num].ch_num = ch_num;
    cf06:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39
  hhcd->hc[ch_num].urb_state = URB_IDLE;
    cf0a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  hhcd->hc[ch_num].xfer_count = 0U;
    cf0e:	64da      	str	r2, [r3, #76]	; 0x4c
  hhcd->hc[ch_num].state = HC_IDLE;
    cf10:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    cf14:	7c02      	ldrb	r2, [r0, #16]
    cf16:	6800      	ldr	r0, [r0, #0]
}
    cf18:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    cf1c:	f009 ba32 	b.w	16384 <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    cf20:	f04f 0e02 	mov.w	lr, #2
    cf24:	e7c8      	b.n	ceb8 <HAL_HCD_HC_SubmitRequest+0x30>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    cf26:	190b      	adds	r3, r1, r4
    cf28:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
      if (direction == 0U)
    cf2c:	b96a      	cbnz	r2, cf4a <HAL_HCD_HC_SubmitRequest+0xc2>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    cf2e:	f893 5051 	ldrb.w	r5, [r3, #81]	; 0x51
    cf32:	b13d      	cbz	r5, cf44 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    cf34:	2202      	movs	r2, #2
    cf36:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    cf3a:	e7da      	b.n	cef2 <HAL_HCD_HC_SubmitRequest+0x6a>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    cf3c:	190b      	adds	r3, r1, r4
    cf3e:	2200      	movs	r2, #0
    cf40:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    cf44:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      break;
    cf48:	e7d3      	b.n	cef2 <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_in == 0U)
    cf4a:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
    cf4e:	2a00      	cmp	r2, #0
    cf50:	d0f8      	beq.n	cf44 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    cf52:	2202      	movs	r2, #2
    cf54:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    cf58:	e7cb      	b.n	cef2 <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    cf5a:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    cf5e:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
    cf62:	2a00      	cmp	r2, #0
    cf64:	d0ee      	beq.n	cf44 <HAL_HCD_HC_SubmitRequest+0xbc>
    cf66:	e7be      	b.n	cee6 <HAL_HCD_HC_SubmitRequest+0x5e>

0000cf68 <HAL_HCD_Start>:
  * @brief  Start the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
{
    cf68:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hhcd);
    cf6a:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    cf6e:	2b01      	cmp	r3, #1
    cf70:	d00e      	beq.n	cf90 <HAL_HCD_Start+0x28>
    cf72:	4604      	mov	r4, r0
    cf74:	2501      	movs	r5, #1
  __HAL_HCD_ENABLE(hhcd);
    cf76:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    cf78:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
  __HAL_HCD_ENABLE(hhcd);
    cf7c:	f009 f852 	bl	16024 <USB_EnableGlobalInt>
  (void)USB_DriveVbus(hhcd->Instance, 1U);
    cf80:	4629      	mov	r1, r5
    cf82:	6820      	ldr	r0, [r4, #0]
    cf84:	f009 f92c 	bl	161e0 <USB_DriveVbus>
  __HAL_UNLOCK(hhcd);
    cf88:	2000      	movs	r0, #0
    cf8a:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return HAL_OK;
}
    cf8e:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hhcd);
    cf90:	2002      	movs	r0, #2
}
    cf92:	bd38      	pop	{r3, r4, r5, pc}

0000cf94 <HAL_HCD_Stop>:
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
{
  __HAL_LOCK(hhcd);
    cf94:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    cf98:	2b01      	cmp	r3, #1
    cf9a:	d00b      	beq.n	cfb4 <HAL_HCD_Stop+0x20>
    cf9c:	2301      	movs	r3, #1
{
    cf9e:	b510      	push	{r4, lr}
    cfa0:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
    cfa2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    cfa4:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_StopHost(hhcd->Instance);
    cfa8:	f009 fb00 	bl	165ac <USB_StopHost>
  __HAL_UNLOCK(hhcd);
    cfac:	2000      	movs	r0, #0
    cfae:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return HAL_OK;
}
    cfb2:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
    cfb4:	2002      	movs	r0, #2
}
    cfb6:	4770      	bx	lr

0000cfb8 <HAL_HCD_ResetPort>:
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
  return (USB_ResetPort(hhcd->Instance));
    cfb8:	6800      	ldr	r0, [r0, #0]
    cfba:	f009 b8f1 	b.w	161a0 <USB_ResetPort>
    cfbe:	bf00      	nop

0000cfc0 <HAL_HCD_HC_GetURBState>:
  *            URB_ERROR/
  *            URB_STALL
  */
HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
  return hhcd->hc[chnum].urb_state;
    cfc0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    cfc4:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
    cfc8:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
    cfcc:	4770      	bx	lr
    cfce:	bf00      	nop

0000cfd0 <HAL_HCD_HC_GetXferCount>:
  *         This parameter can be a value from 1 to 15
  * @retval last transfer size in byte
  */
uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
  return hhcd->hc[chnum].xfer_count;
    cfd0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    cfd4:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
    cfd8:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
    cfda:	4770      	bx	lr

0000cfdc <HAL_HCD_GetCurrentFrame>:
  * @param  hhcd HCD handle
  * @retval Current Host frame number
  */
uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
{
  return (USB_GetCurrentFrame(hhcd->Instance));
    cfdc:	6800      	ldr	r0, [r0, #0]
    cfde:	f009 b92f 	b.w	16240 <USB_GetCurrentFrame>
    cfe2:	bf00      	nop

0000cfe4 <HAL_HCD_GetCurrentSpeed>:
  * @param  hhcd HCD handle
  * @retval Enumeration speed
  */
uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
{
  return (USB_GetHostSpeed(hhcd->Instance));
    cfe4:	6800      	ldr	r0, [r0, #0]
    cfe6:	f009 b91f 	b.w	16228 <USB_GetHostSpeed>
    cfea:	bf00      	nop

0000cfec <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
    cfec:	b570      	push	{r4, r5, r6, lr}
    cfee:	4604      	mov	r4, r0
    cff0:	460d      	mov	r5, r1
    cff2:	4616      	mov	r6, r2
    cff4:	1c6b      	adds	r3, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    cff6:	6822      	ldr	r2, [r4, #0]
    cff8:	d131      	bne.n	d05e <I2C_WaitOnTXISFlagUntilTimeout+0x72>
    cffa:	6993      	ldr	r3, [r2, #24]
    cffc:	0798      	lsls	r0, r3, #30
    cffe:	d431      	bmi.n	d064 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    d000:	6993      	ldr	r3, [r2, #24]
    d002:	06d9      	lsls	r1, r3, #27
    d004:	d5f9      	bpl.n	cffa <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    d006:	6993      	ldr	r3, [r2, #24]
    d008:	069d      	lsls	r5, r3, #26
    d00a:	d5fc      	bpl.n	d006 <I2C_WaitOnTXISFlagUntilTimeout+0x1a>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d00c:	2310      	movs	r3, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d00e:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d010:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d012:	6823      	ldr	r3, [r4, #0]
    d014:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d016:	6823      	ldr	r3, [r4, #0]
    d018:	699a      	ldr	r2, [r3, #24]
    d01a:	0791      	lsls	r1, r2, #30
    d01c:	d502      	bpl.n	d024 <I2C_WaitOnTXISFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
    d01e:	2200      	movs	r2, #0
    d020:	629a      	str	r2, [r3, #40]	; 0x28
    d022:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d024:	699a      	ldr	r2, [r3, #24]
    d026:	07d2      	lsls	r2, r2, #31
    d028:	d404      	bmi.n	d034 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d02a:	699a      	ldr	r2, [r3, #24]
    d02c:	f042 0201 	orr.w	r2, r2, #1
    d030:	619a      	str	r2, [r3, #24]
    d032:	6823      	ldr	r3, [r4, #0]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    d034:	f44f 4568 	mov.w	r5, #59392	; 0xe800
    d038:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
    d03a:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_READY;
    d03c:	2620      	movs	r6, #32
    I2C_RESET_CR2(hi2c);
    d03e:	f6cf 6500 	movt	r5, #65024	; 0xfe00
      return HAL_ERROR;
    d042:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
    d044:	402a      	ands	r2, r5
    d046:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d048:	6c63      	ldr	r3, [r4, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    d04a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d04e:	f043 0304 	orr.w	r3, r3, #4
    d052:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    d054:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
    d058:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
    d05c:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    d05e:	6993      	ldr	r3, [r2, #24]
    d060:	079b      	lsls	r3, r3, #30
    d062:	d501      	bpl.n	d068 <I2C_WaitOnTXISFlagUntilTimeout+0x7c>
  return HAL_OK;
    d064:	2000      	movs	r0, #0
}
    d066:	bd70      	pop	{r4, r5, r6, pc}
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    d068:	6993      	ldr	r3, [r2, #24]
    d06a:	06db      	lsls	r3, r3, #27
    d06c:	d407      	bmi.n	d07e <I2C_WaitOnTXISFlagUntilTimeout+0x92>
    d06e:	e00a      	b.n	d086 <I2C_WaitOnTXISFlagUntilTimeout+0x9a>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    d070:	f7fb f9e6 	bl	8440 <HAL_GetTick>
    d074:	1b80      	subs	r0, r0, r6
    d076:	4285      	cmp	r5, r0
    d078:	d30c      	bcc.n	d094 <I2C_WaitOnTXISFlagUntilTimeout+0xa8>
    d07a:	b15d      	cbz	r5, d094 <I2C_WaitOnTXISFlagUntilTimeout+0xa8>
    d07c:	6822      	ldr	r2, [r4, #0]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    d07e:	6993      	ldr	r3, [r2, #24]
    d080:	0698      	lsls	r0, r3, #26
    d082:	d5f5      	bpl.n	d070 <I2C_WaitOnTXISFlagUntilTimeout+0x84>
    d084:	e7c2      	b.n	d00c <I2C_WaitOnTXISFlagUntilTimeout+0x20>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    d086:	f7fb f9db 	bl	8440 <HAL_GetTick>
    d08a:	1b80      	subs	r0, r0, r6
    d08c:	42a8      	cmp	r0, r5
    d08e:	d801      	bhi.n	d094 <I2C_WaitOnTXISFlagUntilTimeout+0xa8>
    d090:	2d00      	cmp	r5, #0
    d092:	d1af      	bne.n	cff4 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d094:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    d096:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    d098:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
    d09a:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d09c:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    d09e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d0a2:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    d0a4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    d0a8:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    d0ac:	bd70      	pop	{r4, r5, r6, pc}
    d0ae:	bf00      	nop

0000d0b0 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
    d0b0:	b570      	push	{r4, r5, r6, lr}
    d0b2:	4604      	mov	r4, r0
    d0b4:	460d      	mov	r5, r1
    d0b6:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    d0b8:	6822      	ldr	r2, [r4, #0]
    d0ba:	6993      	ldr	r3, [r2, #24]
    d0bc:	069b      	lsls	r3, r3, #26
    d0be:	d450      	bmi.n	d162 <I2C_WaitOnSTOPFlagUntilTimeout+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    d0c0:	6993      	ldr	r3, [r2, #24]
    d0c2:	06d9      	lsls	r1, r3, #27
    d0c4:	d52d      	bpl.n	d122 <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
    d0c6:	1c6b      	adds	r3, r5, #1
    d0c8:	d13f      	bne.n	d14a <I2C_WaitOnSTOPFlagUntilTimeout+0x9a>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    d0ca:	6993      	ldr	r3, [r2, #24]
    d0cc:	069d      	lsls	r5, r3, #26
    d0ce:	d5fc      	bpl.n	d0ca <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d0d0:	2310      	movs	r3, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d0d2:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d0d4:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d0d6:	6823      	ldr	r3, [r4, #0]
    d0d8:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d0da:	6823      	ldr	r3, [r4, #0]
    d0dc:	699a      	ldr	r2, [r3, #24]
    d0de:	0791      	lsls	r1, r2, #30
    d0e0:	d502      	bpl.n	d0e8 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
    d0e2:	2200      	movs	r2, #0
    d0e4:	629a      	str	r2, [r3, #40]	; 0x28
    d0e6:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d0e8:	699a      	ldr	r2, [r3, #24]
    d0ea:	07d2      	lsls	r2, r2, #31
    d0ec:	d404      	bmi.n	d0f8 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d0ee:	699a      	ldr	r2, [r3, #24]
    d0f0:	f042 0201 	orr.w	r2, r2, #1
    d0f4:	619a      	str	r2, [r3, #24]
    d0f6:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
    d0f8:	f44f 4568 	mov.w	r5, #59392	; 0xe800
    d0fc:	685a      	ldr	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
    d0fe:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_READY;
    d100:	2620      	movs	r6, #32
    I2C_RESET_CR2(hi2c);
    d102:	f6cf 6500 	movt	r5, #65024	; 0xfe00
      return HAL_ERROR;
    d106:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
    d108:	402a      	ands	r2, r5
    d10a:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d10c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
    d10e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d112:	f043 0304 	orr.w	r3, r3, #4
    d116:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    d118:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
    d11c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
    d120:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    d122:	f7fb f98d 	bl	8440 <HAL_GetTick>
    d126:	1b80      	subs	r0, r0, r6
    d128:	42a8      	cmp	r0, r5
    d12a:	d801      	bhi.n	d130 <I2C_WaitOnSTOPFlagUntilTimeout+0x80>
    d12c:	2d00      	cmp	r5, #0
    d12e:	d1c3      	bne.n	d0b8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d130:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    d132:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    d134:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
    d136:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d138:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    d13a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d13e:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    d140:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    d144:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    d148:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    d14a:	6993      	ldr	r3, [r2, #24]
    d14c:	0698      	lsls	r0, r3, #26
    d14e:	d4bf      	bmi.n	d0d0 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    d150:	f7fb f976 	bl	8440 <HAL_GetTick>
    d154:	1b80      	subs	r0, r0, r6
    d156:	4285      	cmp	r5, r0
    d158:	d3ea      	bcc.n	d130 <I2C_WaitOnSTOPFlagUntilTimeout+0x80>
    d15a:	2d00      	cmp	r5, #0
    d15c:	d0e8      	beq.n	d130 <I2C_WaitOnSTOPFlagUntilTimeout+0x80>
    d15e:	6822      	ldr	r2, [r4, #0]
    d160:	e7b1      	b.n	d0c6 <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
    d162:	2000      	movs	r0, #0
}
    d164:	bd70      	pop	{r4, r5, r6, pc}
    d166:	bf00      	nop

0000d168 <HAL_I2C_Init>:
  if (hi2c == NULL)
    d168:	2800      	cmp	r0, #0
    d16a:	f000 80fb 	beq.w	d364 <HAL_I2C_Init+0x1fc>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d16e:	f44f 41b8 	mov.w	r1, #23552	; 0x5c00
{
    d172:	b538      	push	{r3, r4, r5, lr}
    d174:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d176:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
    d17a:	f44f 40b0 	mov.w	r0, #22528	; 0x5800
    d17e:	f2c4 0100 	movt	r1, #16384	; 0x4000
    d182:	f2c4 0300 	movt	r3, #16384	; 0x4000
    d186:	6822      	ldr	r2, [r4, #0]
    d188:	f2c4 0000 	movt	r0, #16384	; 0x4000
    d18c:	429a      	cmp	r2, r3
    d18e:	bf18      	it	ne
    d190:	4282      	cmpne	r2, r0
    d192:	bf14      	ite	ne
    d194:	2301      	movne	r3, #1
    d196:	2300      	moveq	r3, #0
    d198:	428a      	cmp	r2, r1
    d19a:	bf0c      	ite	eq
    d19c:	2300      	moveq	r3, #0
    d19e:	f003 0301 	andne.w	r3, r3, #1
    d1a2:	b133      	cbz	r3, d1b2 <HAL_I2C_Init+0x4a>
    d1a4:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    d1a8:	f6c5 0300 	movt	r3, #22528	; 0x5800
    d1ac:	429a      	cmp	r2, r3
    d1ae:	f040 80db 	bne.w	d368 <HAL_I2C_Init+0x200>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    d1b2:	68a3      	ldr	r3, [r4, #8]
    d1b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    d1b8:	d27a      	bcs.n	d2b0 <HAL_I2C_Init+0x148>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    d1ba:	68e3      	ldr	r3, [r4, #12]
    d1bc:	3b01      	subs	r3, #1
    d1be:	2b01      	cmp	r3, #1
    d1c0:	d864      	bhi.n	d28c <HAL_I2C_Init+0x124>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    d1c2:	6923      	ldr	r3, [r4, #16]
    d1c4:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    d1c8:	f040 808d 	bne.w	d2e6 <HAL_I2C_Init+0x17e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    d1cc:	6963      	ldr	r3, [r4, #20]
    d1ce:	2bff      	cmp	r3, #255	; 0xff
    d1d0:	d87c      	bhi.n	d2cc <HAL_I2C_Init+0x164>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    d1d2:	69a3      	ldr	r3, [r4, #24]
    d1d4:	2b07      	cmp	r3, #7
    d1d6:	f200 80b7 	bhi.w	d348 <HAL_I2C_Init+0x1e0>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    d1da:	69e3      	ldr	r3, [r4, #28]
    d1dc:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
    d1e0:	f040 80a4 	bne.w	d32c <HAL_I2C_Init+0x1c4>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    d1e4:	6a23      	ldr	r3, [r4, #32]
    d1e6:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
    d1ea:	f040 808f 	bne.w	d30c <HAL_I2C_Init+0x1a4>
  if (hi2c->State == HAL_I2C_STATE_RESET)
    d1ee:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d1f2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    d1f6:	2b00      	cmp	r3, #0
    d1f8:	f000 8082 	beq.w	d300 <HAL_I2C_Init+0x198>
  __HAL_I2C_DISABLE(hi2c);
    d1fc:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
    d1fe:	2324      	movs	r3, #36	; 0x24
    d200:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
    d204:	6813      	ldr	r3, [r2, #0]
    d206:	f023 0301 	bic.w	r3, r3, #1
    d20a:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
    d20c:	e9d4 2300 	ldrd	r2, r3, [r4]
    d210:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    d214:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
    d216:	6822      	ldr	r2, [r4, #0]
    d218:	6893      	ldr	r3, [r2, #8]
    d21a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    d21e:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    d220:	68e3      	ldr	r3, [r4, #12]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    d222:	6822      	ldr	r2, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    d224:	2b01      	cmp	r3, #1
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    d226:	68a3      	ldr	r3, [r4, #8]
    d228:	bf0c      	ite	eq
    d22a:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
    d22e:	f443 4304 	orrne.w	r3, r3, #33792	; 0x8400
    d232:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    d234:	68e3      	ldr	r3, [r4, #12]
    d236:	6825      	ldr	r5, [r4, #0]
    d238:	2b02      	cmp	r3, #2
    d23a:	d034      	beq.n	d2a6 <HAL_I2C_Init+0x13e>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    d23c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    d240:	6868      	ldr	r0, [r5, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    d242:	2200      	movs	r2, #0
  hi2c->State = HAL_I2C_STATE_READY;
    d244:	2120      	movs	r1, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    d246:	f2c0 2300 	movt	r3, #512	; 0x200
    d24a:	4303      	orrs	r3, r0
  return HAL_OK;
    d24c:	4610      	mov	r0, r2
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    d24e:	606b      	str	r3, [r5, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
    d250:	6825      	ldr	r5, [r4, #0]
    d252:	68eb      	ldr	r3, [r5, #12]
    d254:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    d258:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
    d25a:	e9d4 3504 	ldrd	r3, r5, [r4, #16]
    d25e:	432b      	orrs	r3, r5
    d260:	69a5      	ldr	r5, [r4, #24]
    d262:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    d266:	6825      	ldr	r5, [r4, #0]
    d268:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
    d26a:	e9d4 3507 	ldrd	r3, r5, [r4, #28]
    d26e:	432b      	orrs	r3, r5
    d270:	6825      	ldr	r5, [r4, #0]
    d272:	602b      	str	r3, [r5, #0]
  __HAL_I2C_ENABLE(hi2c);
    d274:	6825      	ldr	r5, [r4, #0]
    d276:	682b      	ldr	r3, [r5, #0]
    d278:	f043 0301 	orr.w	r3, r3, #1
    d27c:	602b      	str	r3, [r5, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    d27e:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
    d280:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
    d284:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d286:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    d28a:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    d28c:	f643 0068 	movw	r0, #14440	; 0x3868
    d290:	f240 11e3 	movw	r1, #483	; 0x1e3
    d294:	f2c0 0003 	movt	r0, #3
    d298:	f00d ff0a 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    d29c:	6923      	ldr	r3, [r4, #16]
    d29e:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    d2a2:	d093      	beq.n	d1cc <HAL_I2C_Init+0x64>
    d2a4:	e01f      	b.n	d2e6 <HAL_I2C_Init+0x17e>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
    d2a6:	f44f 6300 	mov.w	r3, #2048	; 0x800
    d2aa:	606b      	str	r3, [r5, #4]
    d2ac:	6825      	ldr	r5, [r4, #0]
    d2ae:	e7c5      	b.n	d23c <HAL_I2C_Init+0xd4>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    d2b0:	f643 0068 	movw	r0, #14440	; 0x3868
    d2b4:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
    d2b8:	f2c0 0003 	movt	r0, #3
    d2bc:	f00d fef8 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    d2c0:	68e3      	ldr	r3, [r4, #12]
    d2c2:	3b01      	subs	r3, #1
    d2c4:	2b01      	cmp	r3, #1
    d2c6:	f67f af7c 	bls.w	d1c2 <HAL_I2C_Init+0x5a>
    d2ca:	e7df      	b.n	d28c <HAL_I2C_Init+0x124>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    d2cc:	f643 0068 	movw	r0, #14440	; 0x3868
    d2d0:	f240 11e5 	movw	r1, #485	; 0x1e5
    d2d4:	f2c0 0003 	movt	r0, #3
    d2d8:	f00d feea 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    d2dc:	69a3      	ldr	r3, [r4, #24]
    d2de:	2b07      	cmp	r3, #7
    d2e0:	f67f af7b 	bls.w	d1da <HAL_I2C_Init+0x72>
    d2e4:	e030      	b.n	d348 <HAL_I2C_Init+0x1e0>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    d2e6:	f643 0068 	movw	r0, #14440	; 0x3868
    d2ea:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
    d2ee:	f2c0 0003 	movt	r0, #3
    d2f2:	f00d fedd 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    d2f6:	6963      	ldr	r3, [r4, #20]
    d2f8:	2bff      	cmp	r3, #255	; 0xff
    d2fa:	f67f af6a 	bls.w	d1d2 <HAL_I2C_Init+0x6a>
    d2fe:	e7e5      	b.n	d2cc <HAL_I2C_Init+0x164>
    hi2c->Lock = HAL_UNLOCKED;
    d300:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
    d304:	4620      	mov	r0, r4
    d306:	f00d fbfd 	bl	1ab04 <HAL_I2C_MspInit>
    d30a:	e777      	b.n	d1fc <HAL_I2C_Init+0x94>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    d30c:	f643 0068 	movw	r0, #14440	; 0x3868
    d310:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
    d314:	f2c0 0003 	movt	r0, #3
    d318:	f00d feca 	bl	1b0b0 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
    d31c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d320:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    d324:	2b00      	cmp	r3, #0
    d326:	f47f af69 	bne.w	d1fc <HAL_I2C_Init+0x94>
    d32a:	e7e9      	b.n	d300 <HAL_I2C_Init+0x198>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    d32c:	f643 0068 	movw	r0, #14440	; 0x3868
    d330:	f240 11e7 	movw	r1, #487	; 0x1e7
    d334:	f2c0 0003 	movt	r0, #3
    d338:	f00d feba 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    d33c:	6a23      	ldr	r3, [r4, #32]
    d33e:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
    d342:	f43f af54 	beq.w	d1ee <HAL_I2C_Init+0x86>
    d346:	e7e1      	b.n	d30c <HAL_I2C_Init+0x1a4>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    d348:	f643 0068 	movw	r0, #14440	; 0x3868
    d34c:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
    d350:	f2c0 0003 	movt	r0, #3
    d354:	f00d feac 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    d358:	69e3      	ldr	r3, [r4, #28]
    d35a:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
    d35e:	f43f af41 	beq.w	d1e4 <HAL_I2C_Init+0x7c>
    d362:	e7e3      	b.n	d32c <HAL_I2C_Init+0x1c4>
    return HAL_ERROR;
    d364:	2001      	movs	r0, #1
}
    d366:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d368:	f643 0068 	movw	r0, #14440	; 0x3868
    d36c:	f240 11e1 	movw	r1, #481	; 0x1e1
    d370:	f2c0 0003 	movt	r0, #3
    d374:	f00d fe9c 	bl	1b0b0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    d378:	68a3      	ldr	r3, [r4, #8]
    d37a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    d37e:	f4ff af1c 	bcc.w	d1ba <HAL_I2C_Init+0x52>
    d382:	e795      	b.n	d2b0 <HAL_I2C_Init+0x148>

0000d384 <HAL_I2C_Master_Transmit>:
{
    d384:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
    d388:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
    d38c:	9e08      	ldr	r6, [sp, #32]
  if (hi2c->State == HAL_I2C_STATE_READY)
    d38e:	2c20      	cmp	r4, #32
    d390:	f040 80c6 	bne.w	d520 <HAL_I2C_Master_Transmit+0x19c>
    __HAL_LOCK(hi2c);
    d394:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
    d398:	2c01      	cmp	r4, #1
    d39a:	f000 80c1 	beq.w	d520 <HAL_I2C_Master_Transmit+0x19c>
    d39e:	4698      	mov	r8, r3
    d3a0:	2301      	movs	r3, #1
    d3a2:	4691      	mov	r9, r2
    d3a4:	460f      	mov	r7, r1
    d3a6:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    d3aa:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
    d3ac:	f7fb f848 	bl	8440 <HAL_GetTick>
    d3b0:	4605      	mov	r5, r0
    d3b2:	e005      	b.n	d3c0 <HAL_I2C_Master_Transmit+0x3c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    d3b4:	f7fb f844 	bl	8440 <HAL_GetTick>
    d3b8:	1b40      	subs	r0, r0, r5
    d3ba:	2819      	cmp	r0, #25
    d3bc:	f200 80d1 	bhi.w	d562 <HAL_I2C_Master_Transmit+0x1de>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    d3c0:	6823      	ldr	r3, [r4, #0]
    d3c2:	6998      	ldr	r0, [r3, #24]
    d3c4:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
    d3c8:	d1f4      	bne.n	d3b4 <HAL_I2C_Master_Transmit+0x30>
    d3ca:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
    d3ce:	f44f 41a8 	mov.w	r1, #21504	; 0x5400
    d3d2:	f44f 4cb0 	mov.w	ip, #22528	; 0x5800
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
    d3d6:	f04f 0e21 	mov.w	lr, #33	; 0x21
    d3da:	f2c4 0200 	movt	r2, #16384	; 0x4000
    d3de:	f2c4 0100 	movt	r1, #16384	; 0x4000
    d3e2:	f2c4 0c00 	movt	ip, #16384	; 0x4000
    d3e6:	f884 e041 	strb.w	lr, [r4, #65]	; 0x41
    d3ea:	4293      	cmp	r3, r2
    d3ec:	bf18      	it	ne
    d3ee:	428b      	cmpne	r3, r1
    d3f0:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    d3f4:	f04f 0e10 	mov.w	lr, #16
    hi2c->pBuffPtr  = pData;
    d3f8:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    d3fc:	bf14      	ite	ne
    d3fe:	2201      	movne	r2, #1
    d400:	2200      	moveq	r2, #0
    d402:	f6c5 0100 	movt	r1, #22528	; 0x5800
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    d406:	f884 e042 	strb.w	lr, [r4, #66]	; 0x42
    d40a:	4563      	cmp	r3, ip
    d40c:	bf0c      	ite	eq
    d40e:	2200      	moveq	r2, #0
    d410:	f002 0201 	andne.w	r2, r2, #1
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    d414:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
    d416:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    d41a:	428b      	cmp	r3, r1
    d41c:	bf0c      	ite	eq
    d41e:	2200      	moveq	r2, #0
    d420:	f002 0201 	andne.w	r2, r2, #1
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d424:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
    d426:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d428:	29ff      	cmp	r1, #255	; 0xff
    d42a:	d87c      	bhi.n	d526 <HAL_I2C_Master_Transmit+0x1a2>
      hi2c->XferSize = hi2c->XferCount;
    d42c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    d42e:	b289      	uxth	r1, r1
    d430:	8521      	strh	r1, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    d432:	fa5f f881 	uxtb.w	r8, r1
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d436:	2a00      	cmp	r2, #0
    d438:	f040 80e1 	bne.w	d5fe <HAL_I2C_Master_Transmit+0x27a>
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d43c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    d440:	f3c7 0709 	ubfx	r7, r7, #0, #10
    d444:	f44f 4018 	mov.w	r0, #38912	; 0x9800
    d448:	6859      	ldr	r1, [r3, #4]
    d44a:	f2c8 2200 	movt	r2, #33280	; 0x8200
    d44e:	f6cf 4000 	movt	r0, #64512	; 0xfc00
    d452:	433a      	orrs	r2, r7
    d454:	4001      	ands	r1, r0
    d456:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
    d45a:	430a      	orrs	r2, r1
    d45c:	605a      	str	r2, [r3, #4]
    d45e:	f04f 0800 	mov.w	r8, #0
    d462:	f44f 49a8 	mov.w	r9, #21504	; 0x5400
    d466:	f2c0 18ff 	movt	r8, #511	; 0x1ff
    d46a:	f2c4 0900 	movt	r9, #16384	; 0x4000
    d46e:	ea47 0808 	orr.w	r8, r7, r8
    while (hi2c->XferCount > 0U)
    d472:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    d474:	462a      	mov	r2, r5
    d476:	4631      	mov	r1, r6
    d478:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
    d47a:	b29b      	uxth	r3, r3
    d47c:	2b00      	cmp	r3, #0
    d47e:	f000 8094 	beq.w	d5aa <HAL_I2C_Master_Transmit+0x226>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    d482:	f7ff fdb3 	bl	cfec <I2C_WaitOnTXISFlagUntilTimeout>
    d486:	2800      	cmp	r0, #0
    d488:	f040 808c 	bne.w	d5a4 <HAL_I2C_Master_Transmit+0x220>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    d48c:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d48e:	6823      	ldr	r3, [r4, #0]
    d490:	7812      	ldrb	r2, [r2, #0]
    d492:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    d494:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d496:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d498:	3901      	subs	r1, #1
      hi2c->pBuffPtr++;
    d49a:	6a62      	ldr	r2, [r4, #36]	; 0x24
      hi2c->XferSize--;
    d49c:	3b01      	subs	r3, #1
      hi2c->XferCount--;
    d49e:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
    d4a0:	3201      	adds	r2, #1
      hi2c->XferSize--;
    d4a2:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
    d4a4:	8561      	strh	r1, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    d4a6:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d4a8:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    d4aa:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
    d4ac:	6262      	str	r2, [r4, #36]	; 0x24
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    d4ae:	2b00      	cmp	r3, #0
    d4b0:	d1df      	bne.n	d472 <HAL_I2C_Master_Transmit+0xee>
    d4b2:	2900      	cmp	r1, #0
    d4b4:	d0dd      	beq.n	d472 <HAL_I2C_Master_Transmit+0xee>
    d4b6:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    d4b8:	6822      	ldr	r2, [r4, #0]
    d4ba:	d148      	bne.n	d54e <HAL_I2C_Master_Transmit+0x1ca>
    d4bc:	6993      	ldr	r3, [r2, #24]
    d4be:	0619      	lsls	r1, r3, #24
    d4c0:	d5fc      	bpl.n	d4bc <HAL_I2C_Master_Transmit+0x138>
    d4c2:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    d4c6:	f44f 40b0 	mov.w	r0, #22528	; 0x5800
    d4ca:	f44f 41b8 	mov.w	r1, #23552	; 0x5c00
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4ce:	f8b4 c02a 	ldrh.w	ip, [r4, #42]	; 0x2a
    d4d2:	f6c5 0300 	movt	r3, #22528	; 0x5800
    d4d6:	f2c4 0000 	movt	r0, #16384	; 0x4000
    d4da:	f2c4 0100 	movt	r1, #16384	; 0x4000
    d4de:	454a      	cmp	r2, r9
    d4e0:	bf18      	it	ne
    d4e2:	429a      	cmpne	r2, r3
    d4e4:	bf14      	ite	ne
    d4e6:	2301      	movne	r3, #1
    d4e8:	2300      	moveq	r3, #0
    d4ea:	4282      	cmp	r2, r0
    d4ec:	bf0c      	ite	eq
    d4ee:	2300      	moveq	r3, #0
    d4f0:	f003 0301 	andne.w	r3, r3, #1
    d4f4:	428a      	cmp	r2, r1
    d4f6:	bf0c      	ite	eq
    d4f8:	2300      	moveq	r3, #0
    d4fa:	f003 0301 	andne.w	r3, r3, #1
    d4fe:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    d502:	d93c      	bls.n	d57e <HAL_I2C_Master_Transmit+0x1fa>
          hi2c->XferSize = MAX_NBYTE_SIZE;
    d504:	21ff      	movs	r1, #255	; 0xff
    d506:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d508:	2b00      	cmp	r3, #0
    d50a:	d164      	bne.n	d5d6 <HAL_I2C_Master_Transmit+0x252>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d50c:	f44f 411c 	mov.w	r1, #39936	; 0x9c00
    d510:	6853      	ldr	r3, [r2, #4]
    d512:	f6cf 4100 	movt	r1, #64512	; 0xfc00
    d516:	400b      	ands	r3, r1
    d518:	ea43 0308 	orr.w	r3, r3, r8
    d51c:	6053      	str	r3, [r2, #4]
    d51e:	e7a8      	b.n	d472 <HAL_I2C_Master_Transmit+0xee>
    return HAL_BUSY;
    d520:	2002      	movs	r0, #2
}
    d522:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
    d526:	21ff      	movs	r1, #255	; 0xff
    d528:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d52a:	2a00      	cmp	r2, #0
    d52c:	d171      	bne.n	d612 <HAL_I2C_Master_Transmit+0x28e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d52e:	f44f 4018 	mov.w	r0, #38912	; 0x9800
    d532:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    d536:	685a      	ldr	r2, [r3, #4]
    d538:	f3c7 0709 	ubfx	r7, r7, #0, #10
    d53c:	f6cf 4000 	movt	r0, #64512	; 0xfc00
    d540:	f2c8 11ff 	movt	r1, #33279	; 0x81ff
    d544:	4002      	ands	r2, r0
    d546:	4339      	orrs	r1, r7
    d548:	430a      	orrs	r2, r1
    d54a:	605a      	str	r2, [r3, #4]
    d54c:	e787      	b.n	d45e <HAL_I2C_Master_Transmit+0xda>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    d54e:	6993      	ldr	r3, [r2, #24]
    d550:	061b      	lsls	r3, r3, #24
    d552:	d4b6      	bmi.n	d4c2 <HAL_I2C_Master_Transmit+0x13e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    d554:	f7fa ff74 	bl	8440 <HAL_GetTick>
    d558:	1b40      	subs	r0, r0, r5
    d55a:	4286      	cmp	r6, r0
    d55c:	d301      	bcc.n	d562 <HAL_I2C_Master_Transmit+0x1de>
    d55e:	2e00      	cmp	r6, #0
    d560:	d1a9      	bne.n	d4b6 <HAL_I2C_Master_Transmit+0x132>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d562:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    d564:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    d566:	2200      	movs	r2, #0
          return HAL_ERROR;
    d568:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d56a:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    d56c:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    d570:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    d572:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    d576:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    d57a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          hi2c->XferSize = hi2c->XferCount;
    d57e:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    d580:	b289      	uxth	r1, r1
    d582:	8521      	strh	r1, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    d584:	fa5f fa81 	uxtb.w	sl, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d588:	bb7b      	cbnz	r3, d5ea <HAL_I2C_Master_Transmit+0x266>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d58a:	f44f 401c 	mov.w	r0, #39936	; 0x9c00
    d58e:	6851      	ldr	r1, [r2, #4]
    d590:	ea47 430a 	orr.w	r3, r7, sl, lsl #16
    d594:	f6cf 4000 	movt	r0, #64512	; 0xfc00
    d598:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    d59c:	4001      	ands	r1, r0
    d59e:	430b      	orrs	r3, r1
    d5a0:	6053      	str	r3, [r2, #4]
    d5a2:	e766      	b.n	d472 <HAL_I2C_Master_Transmit+0xee>
        return HAL_ERROR;
    d5a4:	2001      	movs	r0, #1
}
    d5a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    d5aa:	f7ff fd81 	bl	d0b0 <I2C_WaitOnSTOPFlagUntilTimeout>
    d5ae:	2800      	cmp	r0, #0
    d5b0:	d1f8      	bne.n	d5a4 <HAL_I2C_Master_Transmit+0x220>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d5b2:	6823      	ldr	r3, [r4, #0]
    d5b4:	2220      	movs	r2, #32
    I2C_RESET_CR2(hi2c);
    d5b6:	f44f 4568 	mov.w	r5, #59392	; 0xe800
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d5ba:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
    d5bc:	6821      	ldr	r1, [r4, #0]
    d5be:	f6cf 6500 	movt	r5, #65024	; 0xfe00
    d5c2:	684b      	ldr	r3, [r1, #4]
    d5c4:	402b      	ands	r3, r5
    d5c6:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
    d5c8:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    d5cc:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
    d5d0:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
    d5d4:	e7a5      	b.n	d522 <HAL_I2C_Master_Transmit+0x19e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d5d6:	f643 0068 	movw	r0, #14440	; 0x3868
    d5da:	f641 1131 	movw	r1, #6449	; 0x1931
    d5de:	f2c0 0003 	movt	r0, #3
    d5e2:	f00d fd65 	bl	1b0b0 <assert_failed>
    d5e6:	6822      	ldr	r2, [r4, #0]
    d5e8:	e790      	b.n	d50c <HAL_I2C_Master_Transmit+0x188>
    d5ea:	f643 0068 	movw	r0, #14440	; 0x3868
    d5ee:	f641 1131 	movw	r1, #6449	; 0x1931
    d5f2:	f2c0 0003 	movt	r0, #3
    d5f6:	f00d fd5b 	bl	1b0b0 <assert_failed>
    d5fa:	6822      	ldr	r2, [r4, #0]
    d5fc:	e7c5      	b.n	d58a <HAL_I2C_Master_Transmit+0x206>
    d5fe:	f643 0068 	movw	r0, #14440	; 0x3868
    d602:	f641 1131 	movw	r1, #6449	; 0x1931
    d606:	f2c0 0003 	movt	r0, #3
    d60a:	f00d fd51 	bl	1b0b0 <assert_failed>
    d60e:	6823      	ldr	r3, [r4, #0]
    d610:	e714      	b.n	d43c <HAL_I2C_Master_Transmit+0xb8>
    d612:	f643 0068 	movw	r0, #14440	; 0x3868
    d616:	f641 1131 	movw	r1, #6449	; 0x1931
    d61a:	f2c0 0003 	movt	r0, #3
    d61e:	f00d fd47 	bl	1b0b0 <assert_failed>
    d622:	6823      	ldr	r3, [r4, #0]
    d624:	e783      	b.n	d52e <HAL_I2C_Master_Transmit+0x1aa>
    d626:	bf00      	nop

0000d628 <HAL_I2C_Master_Transmit_DMA>:
{
    d628:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
    d62c:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
    d630:	2c20      	cmp	r4, #32
    d632:	d152      	bne.n	d6da <HAL_I2C_Master_Transmit_DMA+0xb2>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
    d634:	6807      	ldr	r7, [r0, #0]
    d636:	69bd      	ldr	r5, [r7, #24]
    d638:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
    d63c:	d14d      	bne.n	d6da <HAL_I2C_Master_Transmit_DMA+0xb2>
    __HAL_LOCK(hi2c);
    d63e:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
    d642:	2c01      	cmp	r4, #1
    d644:	d049      	beq.n	d6da <HAL_I2C_Master_Transmit_DMA+0xb2>
    d646:	460e      	mov	r6, r1
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d648:	2100      	movs	r1, #0
    d64a:	4604      	mov	r4, r0
    hi2c->pBuffPtr    = pData;
    d64c:	6242      	str	r2, [r0, #36]	; 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
    d64e:	f04f 0c21 	mov.w	ip, #33	; 0x21
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
    d652:	2010      	movs	r0, #16
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d654:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    d658:	f24e 6895 	movw	r8, #59029	; 0xe695
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
    d65c:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
    d660:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    d664:	f2c0 0800 	movt	r8, #0
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    d668:	6465      	str	r5, [r4, #68]	; 0x44
    __HAL_LOCK(hi2c);
    d66a:	2001      	movs	r0, #1
    hi2c->XferCount   = Size;
    d66c:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d66e:	62e1      	str	r1, [r4, #44]	; 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d670:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    d672:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d676:	2bff      	cmp	r3, #255	; 0xff
    __HAL_LOCK(hi2c);
    d678:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d67c:	d931      	bls.n	d6e2 <HAL_I2C_Master_Transmit_DMA+0xba>
    d67e:	23ff      	movs	r3, #255	; 0xff
      xfermode = I2C_RELOAD_MODE;
    d680:	f04f 7980 	mov.w	r9, #16777216	; 0x1000000
    d684:	8523      	strh	r3, [r4, #40]	; 0x28
      if (hi2c->hdmatx != NULL)
    d686:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d688:	2b00      	cmp	r3, #0
    d68a:	d076      	beq.n	d77a <HAL_I2C_Master_Transmit_DMA+0x152>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    d68c:	f24e 0569 	movw	r5, #57449	; 0xe069
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    d690:	f64e 1061 	movw	r0, #59745	; 0xe961
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
    d694:	2700      	movs	r7, #0
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    d696:	4611      	mov	r1, r2
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    d698:	f2c0 0500 	movt	r5, #0
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    d69c:	f2c0 0000 	movt	r0, #0
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    d6a0:	63dd      	str	r5, [r3, #60]	; 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    d6a2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d6a4:	64d8      	str	r0, [r3, #76]	; 0x4c
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
    d6a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d6a8:	641f      	str	r7, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
    d6aa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d6ac:	651f      	str	r7, [r3, #80]	; 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    d6ae:	6822      	ldr	r2, [r4, #0]
    d6b0:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    d6b2:	3228      	adds	r2, #40	; 0x28
    d6b4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    d6b6:	f7fd fd0f 	bl	b0d8 <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
    d6ba:	4605      	mov	r5, r0
    d6bc:	2800      	cmp	r0, #0
    d6be:	d076      	beq.n	d7ae <HAL_I2C_Master_Transmit_DMA+0x186>
        hi2c->State     = HAL_I2C_STATE_READY;
    d6c0:	2320      	movs	r3, #32
        __HAL_UNLOCK(hi2c);
    d6c2:	f884 7040 	strb.w	r7, [r4, #64]	; 0x40
        return HAL_ERROR;
    d6c6:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
    d6c8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
    d6cc:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
    d6d0:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d6d2:	f043 0310 	orr.w	r3, r3, #16
    d6d6:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
    d6d8:	e000      	b.n	d6dc <HAL_I2C_Master_Transmit_DMA+0xb4>
    return HAL_BUSY;
    d6da:	2502      	movs	r5, #2
}
    d6dc:	4628      	mov	r0, r5
    d6de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hi2c->XferSize = hi2c->XferCount;
    d6e2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d6e4:	b29b      	uxth	r3, r3
    d6e6:	8523      	strh	r3, [r4, #40]	; 0x28
    if (hi2c->XferSize > 0U)
    d6e8:	2b00      	cmp	r3, #0
    d6ea:	d153      	bne.n	d794 <HAL_I2C_Master_Transmit_DMA+0x16c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d6ec:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
    d6f0:	f44f 42b0 	mov.w	r2, #22528	; 0x5800
    d6f4:	f44f 41b8 	mov.w	r1, #23552	; 0x5c00
    d6f8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    d6fc:	f2c4 0200 	movt	r2, #16384	; 0x4000
    d700:	f2c4 0100 	movt	r1, #16384	; 0x4000
    d704:	429f      	cmp	r7, r3
    d706:	bf18      	it	ne
    d708:	4297      	cmpne	r7, r2
      hi2c->XferISR = I2C_Master_ISR_IT;
    d70a:	f24e 3295 	movw	r2, #58261	; 0xe395
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d70e:	bf14      	ite	ne
    d710:	2301      	movne	r3, #1
    d712:	2300      	moveq	r3, #0
      hi2c->XferISR = I2C_Master_ISR_IT;
    d714:	f2c0 0200 	movt	r2, #0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d718:	428f      	cmp	r7, r1
    d71a:	bf0c      	ite	eq
    d71c:	2300      	moveq	r3, #0
    d71e:	f003 0301 	andne.w	r3, r3, #1
      hi2c->XferISR = I2C_Master_ISR_IT;
    d722:	6362      	str	r2, [r4, #52]	; 0x34
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d724:	b12b      	cbz	r3, d732 <HAL_I2C_Master_Transmit_DMA+0x10a>
    d726:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    d72a:	f6c5 0300 	movt	r3, #22528	; 0x5800
    d72e:	429f      	cmp	r7, r3
    d730:	d133      	bne.n	d79a <HAL_I2C_Master_Transmit_DMA+0x172>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d732:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    d736:	f44f 4018 	mov.w	r0, #38912	; 0x9800
    d73a:	687a      	ldr	r2, [r7, #4]
    d73c:	f3c6 0109 	ubfx	r1, r6, #0, #10
    d740:	f2c8 2300 	movt	r3, #33280	; 0x8200
    d744:	f6cf 4000 	movt	r0, #64512	; 0xfc00
    d748:	430b      	orrs	r3, r1
    d74a:	4002      	ands	r2, r0
      __HAL_UNLOCK(hi2c);
    d74c:	2100      	movs	r1, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d74e:	4313      	orrs	r3, r2
    d750:	607b      	str	r3, [r7, #4]
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d752:	6b62      	ldr	r2, [r4, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
    d754:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d758:	4542      	cmp	r2, r8
    d75a:	d007      	beq.n	d76c <HAL_I2C_Master_Transmit_DMA+0x144>
    d75c:	f64d 63a5 	movw	r3, #56997	; 0xdea5
    d760:	f2c0 0300 	movt	r3, #0
    d764:	429a      	cmp	r2, r3
    d766:	d001      	beq.n	d76c <HAL_I2C_Master_Transmit_DMA+0x144>
    d768:	21f2      	movs	r1, #242	; 0xf2
    d76a:	e000      	b.n	d76e <HAL_I2C_Master_Transmit_DMA+0x146>
    d76c:	2100      	movs	r1, #0
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d76e:	6822      	ldr	r2, [r4, #0]
    return HAL_OK;
    d770:	2500      	movs	r5, #0
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d772:	6813      	ldr	r3, [r2, #0]
    d774:	430b      	orrs	r3, r1
    d776:	6013      	str	r3, [r2, #0]
    d778:	e7b0      	b.n	d6dc <HAL_I2C_Master_Transmit_DMA+0xb4>
        hi2c->State     = HAL_I2C_STATE_READY;
    d77a:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
    d77c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
    d780:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
    d782:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
    d786:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
    d78a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d78c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    d790:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
    d792:	e7a3      	b.n	d6dc <HAL_I2C_Master_Transmit_DMA+0xb4>
      xfermode = I2C_AUTOEND_MODE;
    d794:	f04f 7900 	mov.w	r9, #33554432	; 0x2000000
    d798:	e775      	b.n	d686 <HAL_I2C_Master_Transmit_DMA+0x5e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d79a:	f643 0068 	movw	r0, #14440	; 0x3868
    d79e:	f641 1131 	movw	r1, #6449	; 0x1931
    d7a2:	f2c0 0003 	movt	r0, #3
    d7a6:	f00d fc83 	bl	1b0b0 <assert_failed>
    d7aa:	6827      	ldr	r7, [r4, #0]
    d7ac:	e7c1      	b.n	d732 <HAL_I2C_Master_Transmit_DMA+0x10a>
    d7ae:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
    d7b2:	f44f 41b0 	mov.w	r1, #22528	; 0x5800
    d7b6:	6820      	ldr	r0, [r4, #0]
    d7b8:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
    d7bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    d7c0:	f2c4 0100 	movt	r1, #16384	; 0x4000
    d7c4:	f2c4 0200 	movt	r2, #16384	; 0x4000
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
    d7c8:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d7cc:	4298      	cmp	r0, r3
    d7ce:	bf18      	it	ne
    d7d0:	4288      	cmpne	r0, r1
    d7d2:	bf14      	ite	ne
    d7d4:	2301      	movne	r3, #1
    d7d6:	2300      	moveq	r3, #0
    d7d8:	4290      	cmp	r0, r2
    d7da:	bf0c      	ite	eq
    d7dc:	2200      	moveq	r2, #0
    d7de:	f003 0201 	andne.w	r2, r3, #1
    d7e2:	b12a      	cbz	r2, d7f0 <HAL_I2C_Master_Transmit_DMA+0x1c8>
    d7e4:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    d7e8:	f6c5 0300 	movt	r3, #22528	; 0x5800
    d7ec:	4298      	cmp	r0, r3
    d7ee:	d134      	bne.n	d85a <HAL_I2C_Master_Transmit_DMA+0x232>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d7f0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    d7f4:	f44f 4c18 	mov.w	ip, #38912	; 0x9800
    d7f8:	6842      	ldr	r2, [r0, #4]
    d7fa:	f3c6 0109 	ubfx	r1, r6, #0, #10
    d7fe:	f2c8 0300 	movt	r3, #32768	; 0x8000
    d802:	f6cf 4c00 	movt	ip, #64512	; 0xfc00
        __HAL_UNLOCK(hi2c);
    d806:	2600      	movs	r6, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d808:	430b      	orrs	r3, r1
    d80a:	ea02 020c 	and.w	r2, r2, ip
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d80e:	f64d 61a5 	movw	r1, #56997	; 0xdea5
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d812:	4313      	orrs	r3, r2
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d814:	f2c0 0100 	movt	r1, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d818:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
    d81c:	ea43 0309 	orr.w	r3, r3, r9
    d820:	6043      	str	r3, [r0, #4]
        hi2c->XferCount -= hi2c->XferSize;
    d822:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    d824:	8d20      	ldrh	r0, [r4, #40]	; 0x28
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d826:	6b63      	ldr	r3, [r4, #52]	; 0x34
        hi2c->XferCount -= hi2c->XferSize;
    d828:	1a12      	subs	r2, r2, r0
        __HAL_UNLOCK(hi2c);
    d82a:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d82e:	428b      	cmp	r3, r1
        hi2c->XferCount -= hi2c->XferSize;
    d830:	b292      	uxth	r2, r2
    d832:	8562      	strh	r2, [r4, #42]	; 0x2a
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d834:	d00f      	beq.n	d856 <HAL_I2C_Master_Transmit_DMA+0x22e>
    d836:	eba3 0308 	sub.w	r3, r3, r8
    d83a:	fab3 f383 	clz	r3, r3
    d83e:	095b      	lsrs	r3, r3, #5
    d840:	b94b      	cbnz	r3, d856 <HAL_I2C_Master_Transmit_DMA+0x22e>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d842:	6821      	ldr	r1, [r4, #0]
    d844:	680a      	ldr	r2, [r1, #0]
    d846:	4313      	orrs	r3, r2
    d848:	600b      	str	r3, [r1, #0]
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
    d84a:	6822      	ldr	r2, [r4, #0]
    d84c:	6813      	ldr	r3, [r2, #0]
    d84e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    d852:	6013      	str	r3, [r2, #0]
    d854:	e742      	b.n	d6dc <HAL_I2C_Master_Transmit_DMA+0xb4>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d856:	2390      	movs	r3, #144	; 0x90
    d858:	e7f3      	b.n	d842 <HAL_I2C_Master_Transmit_DMA+0x21a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d85a:	f643 0068 	movw	r0, #14440	; 0x3868
    d85e:	f641 1131 	movw	r1, #6449	; 0x1931
    d862:	f2c0 0003 	movt	r0, #3
    d866:	f00d fc23 	bl	1b0b0 <assert_failed>
    d86a:	6820      	ldr	r0, [r4, #0]
    d86c:	e7c0      	b.n	d7f0 <HAL_I2C_Master_Transmit_DMA+0x1c8>
    d86e:	bf00      	nop

0000d870 <HAL_I2C_MasterTxCpltCallback>:
    d870:	4770      	bx	lr
    d872:	bf00      	nop

0000d874 <HAL_I2C_MasterRxCpltCallback>:
    d874:	4770      	bx	lr
    d876:	bf00      	nop

0000d878 <HAL_I2C_SlaveTxCpltCallback>:
    d878:	4770      	bx	lr
    d87a:	bf00      	nop

0000d87c <HAL_I2C_SlaveRxCpltCallback>:
    d87c:	4770      	bx	lr
    d87e:	bf00      	nop

0000d880 <I2C_ITSlaveSeqCplt>:
{
    d880:	b538      	push	{r3, r4, r5, lr}
    d882:	4603      	mov	r3, r0
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d884:	2000      	movs	r0, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    d886:	681a      	ldr	r2, [r3, #0]
    d888:	6811      	ldr	r1, [r2, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d88a:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
    d88e:	0448      	lsls	r0, r1, #17
    d890:	d50c      	bpl.n	d8ac <I2C_ITSlaveSeqCplt+0x2c>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    d892:	6811      	ldr	r1, [r2, #0]
    d894:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
    d898:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
    d89a:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    d89e:	2a29      	cmp	r2, #41	; 0x29
    d8a0:	d00e      	beq.n	d8c0 <I2C_ITSlaveSeqCplt+0x40>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
    d8a2:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    d8a6:	2a2a      	cmp	r2, #42	; 0x2a
    d8a8:	d024      	beq.n	d8f4 <I2C_ITSlaveSeqCplt+0x74>
}
    d8aa:	bd38      	pop	{r3, r4, r5, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
    d8ac:	0409      	lsls	r1, r1, #16
    d8ae:	d5f4      	bpl.n	d89a <I2C_ITSlaveSeqCplt+0x1a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    d8b0:	6811      	ldr	r1, [r2, #0]
    d8b2:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
    d8b6:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
    d8b8:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    d8bc:	2a29      	cmp	r2, #41	; 0x29
    d8be:	d1f0      	bne.n	d8a2 <I2C_ITSlaveSeqCplt+0x22>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d8c0:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    d8c2:	2221      	movs	r2, #33	; 0x21
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d8c4:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
    d8c6:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d8c8:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    d8cc:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    d8ce:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d8d0:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d8d4:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d8d6:	f001 0128 	and.w	r1, r1, #40	; 0x28
    d8da:	2928      	cmp	r1, #40	; 0x28
    d8dc:	bf14      	ite	ne
    d8de:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
    d8e2:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d8e6:	400a      	ands	r2, r1
    d8e8:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
    d8ea:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    d8ee:	f7ff ffc3 	bl	d878 <HAL_I2C_SlaveTxCpltCallback>
}
    d8f2:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d8f4:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    d8f6:	2222      	movs	r2, #34	; 0x22
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d8f8:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
    d8fa:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d8fc:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    d900:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    d902:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d904:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d908:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d90a:	f001 0128 	and.w	r1, r1, #40	; 0x28
    d90e:	2928      	cmp	r1, #40	; 0x28
    d910:	bf14      	ite	ne
    d912:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    d916:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d91a:	400a      	ands	r2, r1
    d91c:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
    d91e:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    d922:	f7ff ffab 	bl	d87c <HAL_I2C_SlaveRxCpltCallback>
}
    d926:	bd38      	pop	{r3, r4, r5, pc}

0000d928 <HAL_I2C_AddrCallback>:
}
    d928:	4770      	bx	lr
    d92a:	bf00      	nop

0000d92c <I2C_ITAddrCplt.isra.9.part.10>:
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
    d92c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    transferdirection = I2C_GET_DIR(hi2c);
    d92e:	6804      	ldr	r4, [r0, #0]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    d930:	68c3      	ldr	r3, [r0, #12]
    transferdirection = I2C_GET_DIR(hi2c);
    d932:	69a1      	ldr	r1, [r4, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    d934:	69a2      	ldr	r2, [r4, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    d936:	2b02      	cmp	r3, #2
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
    d938:	68a6      	ldr	r6, [r4, #8]
    transferdirection = I2C_GET_DIR(hi2c);
    d93a:	f3c1 4100 	ubfx	r1, r1, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    d93e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
    d942:	68e7      	ldr	r7, [r4, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    d944:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    d948:	d10d      	bne.n	d966 <I2C_ITAddrCplt.isra.9.part.10+0x3a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
    d94a:	f3c6 0609 	ubfx	r6, r6, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
    d94e:	ea82 13d6 	eor.w	r3, r2, r6, lsr #7
    d952:	f013 0306 	ands.w	r3, r3, #6
    d956:	d110      	bne.n	d97a <I2C_ITAddrCplt.isra.9.part.10+0x4e>
        hi2c->AddrEventCount++;
    d958:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d95a:	3201      	adds	r2, #1
    d95c:	6482      	str	r2, [r0, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
    d95e:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d960:	2a02      	cmp	r2, #2
    d962:	d016      	beq.n	d992 <I2C_ITAddrCplt.isra.9.part.10+0x66>
}
    d964:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d966:	6823      	ldr	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
    d968:	2600      	movs	r6, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d96a:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
    d96e:	6023      	str	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
    d970:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    d974:	f7ff ffd8 	bl	d928 <HAL_I2C_AddrCallback>
}
    d978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d97a:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
    d97c:	2600      	movs	r6, #0
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    d97e:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d982:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
    d986:	6023      	str	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
    d988:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    d98c:	f7ff ffcc 	bl	d928 <HAL_I2C_AddrCallback>
}
    d990:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d992:	2708      	movs	r7, #8
          hi2c->AddrEventCount = 0U;
    d994:	6483      	str	r3, [r0, #72]	; 0x48
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    d996:	4632      	mov	r2, r6
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d998:	61e7      	str	r7, [r4, #28]
          __HAL_UNLOCK(hi2c);
    d99a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    d99e:	f7ff ffc3 	bl	d928 <HAL_I2C_AddrCallback>
}
    d9a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000d9a4 <HAL_I2C_ListenCpltCallback>:
    d9a4:	4770      	bx	lr
    d9a6:	bf00      	nop

0000d9a8 <HAL_I2C_MemTxCpltCallback>:
    d9a8:	4770      	bx	lr
    d9aa:	bf00      	nop

0000d9ac <HAL_I2C_MemRxCpltCallback>:
    d9ac:	4770      	bx	lr
    d9ae:	bf00      	nop

0000d9b0 <HAL_I2C_ErrorCallback>:
    d9b0:	4770      	bx	lr
    d9b2:	bf00      	nop

0000d9b4 <HAL_I2C_AbortCpltCallback>:
    d9b4:	4770      	bx	lr
    d9b6:	bf00      	nop

0000d9b8 <I2C_DMAAbort>:
{
    d9b8:	b508      	push	{r3, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    d9ba:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
    d9bc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    d9be:	b10a      	cbz	r2, d9c4 <I2C_DMAAbort+0xc>
    hi2c->hdmatx->XferAbortCallback = NULL;
    d9c0:	2100      	movs	r1, #0
    d9c2:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->hdmarx != NULL)
    d9c4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    d9c6:	b10a      	cbz	r2, d9cc <I2C_DMAAbort+0x14>
    hi2c->hdmarx->XferAbortCallback = NULL;
    d9c8:	2100      	movs	r1, #0
    d9ca:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    d9cc:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    d9d0:	2a60      	cmp	r2, #96	; 0x60
    d9d2:	d007      	beq.n	d9e4 <I2C_DMAAbort+0x2c>
    hi2c->PreviousState = I2C_STATE_NONE;
    d9d4:	2200      	movs	r2, #0
    HAL_I2C_ErrorCallback(hi2c);
    d9d6:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_NONE;
    d9d8:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    d9da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    d9de:	f7ff ffe7 	bl	d9b0 <HAL_I2C_ErrorCallback>
}
    d9e2:	bd08      	pop	{r3, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
    d9e4:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
    d9e6:	2120      	movs	r1, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    d9e8:	4618      	mov	r0, r3
    hi2c->State = HAL_I2C_STATE_READY;
    d9ea:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    d9ee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    d9f2:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    d9f4:	f7ff ffde 	bl	d9b4 <HAL_I2C_AbortCpltCallback>
}
    d9f8:	bd08      	pop	{r3, pc}
    d9fa:	bf00      	nop

0000d9fc <I2C_ITError>:
{
    d9fc:	b570      	push	{r4, r5, r6, lr}
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d9fe:	2500      	movs	r5, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    da00:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
    da04:	4604      	mov	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    da06:	462a      	mov	r2, r5
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    da08:	f6cf 75ff 	movt	r5, #65535	; 0xffff
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    da0c:	3b28      	subs	r3, #40	; 0x28
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    da0e:	f880 2042 	strb.w	r2, [r0, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    da12:	62c5      	str	r5, [r0, #44]	; 0x2c
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    da14:	2b02      	cmp	r3, #2
  hi2c->XferCount     = 0U;
    da16:	8542      	strh	r2, [r0, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    da18:	6c42      	ldr	r2, [r0, #68]	; 0x44
    da1a:	6800      	ldr	r0, [r0, #0]
    da1c:	ea41 0102 	orr.w	r1, r1, r2
    da20:	6461      	str	r1, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    da22:	d833      	bhi.n	da8c <I2C_ITError+0x90>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da24:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    da28:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da2a:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    da2e:	f64d 43fd 	movw	r3, #56573	; 0xdcfd
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da32:	4032      	ands	r2, r6
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da34:	4035      	ands	r5, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    da36:	f2c0 0300 	movt	r3, #0
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da3a:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    da3c:	6802      	ldr	r2, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da3e:	bf14      	ite	ne
    da40:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
    da44:	f06f 0146 	mvneq.w	r1, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da48:	42b5      	cmp	r5, r6
    da4a:	bf18      	it	ne
    da4c:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    da50:	400a      	ands	r2, r1
    da52:	6002      	str	r2, [r0, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    da54:	6363      	str	r3, [r4, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    da56:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    da5a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    da5c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    da5e:	b118      	cbz	r0, da68 <I2C_ITError+0x6c>
    da60:	2b11      	cmp	r3, #17
    da62:	d025      	beq.n	dab0 <I2C_ITError+0xb4>
    da64:	2b21      	cmp	r3, #33	; 0x21
    da66:	d023      	beq.n	dab0 <I2C_ITError+0xb4>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    da68:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    da6a:	b118      	cbz	r0, da74 <I2C_ITError+0x78>
    da6c:	2b12      	cmp	r3, #18
    da6e:	d03a      	beq.n	dae6 <I2C_ITError+0xea>
    da70:	2b22      	cmp	r3, #34	; 0x22
    da72:	d038      	beq.n	dae6 <I2C_ITError+0xea>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    da74:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    da78:	2b60      	cmp	r3, #96	; 0x60
    da7a:	d05a      	beq.n	db32 <I2C_ITError+0x136>
    hi2c->PreviousState = I2C_STATE_NONE;
    da7c:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    da7e:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
    da80:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    da82:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    da86:	f7ff ff93 	bl	d9b0 <HAL_I2C_ErrorCallback>
}
    da8a:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da8c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    da90:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    da94:	6803      	ldr	r3, [r0, #0]
    da96:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    da9a:	6003      	str	r3, [r0, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    da9c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    daa0:	2b60      	cmp	r3, #96	; 0x60
    daa2:	d002      	beq.n	daaa <I2C_ITError+0xae>
      hi2c->State         = HAL_I2C_STATE_READY;
    daa4:	2320      	movs	r3, #32
    daa6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    daaa:	2300      	movs	r3, #0
    daac:	6363      	str	r3, [r4, #52]	; 0x34
    daae:	e7d4      	b.n	da5a <I2C_ITError+0x5e>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    dab0:	6823      	ldr	r3, [r4, #0]
    dab2:	681a      	ldr	r2, [r3, #0]
    dab4:	0451      	lsls	r1, r2, #17
    dab6:	d436      	bmi.n	db26 <I2C_ITError+0x12a>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    dab8:	f7fe f848 	bl	bb4c <HAL_DMA_GetState>
    dabc:	2801      	cmp	r0, #1
    dabe:	d0d9      	beq.n	da74 <I2C_ITError+0x78>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    dac0:	f64d 13b9 	movw	r3, #55737	; 0xd9b9
    dac4:	6ba1      	ldr	r1, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    dac6:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    dac8:	f2c0 0300 	movt	r3, #0
    dacc:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    dace:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    dad2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    dad4:	f7fd feb2 	bl	b83c <HAL_DMA_Abort_IT>
    dad8:	2800      	cmp	r0, #0
    dada:	d0d6      	beq.n	da8a <I2C_ITError+0x8e>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    dadc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
    dade:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    dae2:	6d03      	ldr	r3, [r0, #80]	; 0x50
    dae4:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    dae6:	6823      	ldr	r3, [r4, #0]
    dae8:	681a      	ldr	r2, [r3, #0]
    daea:	0412      	lsls	r2, r2, #16
    daec:	d504      	bpl.n	daf8 <I2C_ITError+0xfc>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    daee:	681a      	ldr	r2, [r3, #0]
    daf0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    daf4:	601a      	str	r2, [r3, #0]
    daf6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    daf8:	f7fe f828 	bl	bb4c <HAL_DMA_GetState>
    dafc:	2801      	cmp	r0, #1
    dafe:	d0b9      	beq.n	da74 <I2C_ITError+0x78>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    db00:	f64d 13b9 	movw	r3, #55737	; 0xd9b9
    db04:	6be1      	ldr	r1, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    db06:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    db08:	f2c0 0300 	movt	r3, #0
    db0c:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    db0e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    db12:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    db14:	f7fd fe92 	bl	b83c <HAL_DMA_Abort_IT>
    db18:	2800      	cmp	r0, #0
    db1a:	d0b6      	beq.n	da8a <I2C_ITError+0x8e>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    db1c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
    db1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    db22:	6d03      	ldr	r3, [r0, #80]	; 0x50
    db24:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    db26:	681a      	ldr	r2, [r3, #0]
    db28:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    db2c:	601a      	str	r2, [r3, #0]
    db2e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    db30:	e7c2      	b.n	dab8 <I2C_ITError+0xbc>
    hi2c->PreviousState = I2C_STATE_NONE;
    db32:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    db34:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    db36:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    db38:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    db3c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    db40:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    db42:	f7ff ff37 	bl	d9b4 <HAL_I2C_AbortCpltCallback>
}
    db46:	bd70      	pop	{r4, r5, r6, pc}

0000db48 <I2C_ITSlaveCplt>:
{
    db48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    db4a:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    db4c:	2020      	movs	r0, #32
{
    db4e:	460d      	mov	r5, r1
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    db50:	6822      	ldr	r2, [r4, #0]
    db52:	6816      	ldr	r6, [r2, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    db54:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    db58:	61d0      	str	r0, [r2, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    db5a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    db5e:	6821      	ldr	r1, [r4, #0]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    db60:	2b21      	cmp	r3, #33	; 0x21
    db62:	d16b      	bne.n	dc3c <I2C_ITSlaveCplt+0xf4>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    db64:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    db68:	680a      	ldr	r2, [r1, #0]
    db6a:	f022 02fa 	bic.w	r2, r2, #250	; 0xfa
    db6e:	600a      	str	r2, [r1, #0]
    db70:	6821      	ldr	r1, [r4, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    db72:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    db74:	684a      	ldr	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
    db76:	f44f 4068 	mov.w	r0, #59392	; 0xe800
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    db7a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  I2C_RESET_CR2(hi2c);
    db7e:	f6cf 6000 	movt	r0, #65024	; 0xfe00
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    db82:	604a      	str	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
    db84:	6822      	ldr	r2, [r4, #0]
    db86:	6853      	ldr	r3, [r2, #4]
    db88:	4003      	ands	r3, r0
    db8a:	6053      	str	r3, [r2, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    db8c:	6823      	ldr	r3, [r4, #0]
    db8e:	699a      	ldr	r2, [r3, #24]
    db90:	0791      	lsls	r1, r2, #30
    db92:	d502      	bpl.n	db9a <I2C_ITSlaveCplt+0x52>
    hi2c->Instance->TXDR = 0x00U;
    db94:	2200      	movs	r2, #0
    db96:	629a      	str	r2, [r3, #40]	; 0x28
    db98:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    db9a:	699a      	ldr	r2, [r3, #24]
    db9c:	07d2      	lsls	r2, r2, #31
    db9e:	d403      	bmi.n	dba8 <I2C_ITSlaveCplt+0x60>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    dba0:	699a      	ldr	r2, [r3, #24]
    dba2:	f042 0201 	orr.w	r2, r2, #1
    dba6:	619a      	str	r2, [r3, #24]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
    dba8:	0477      	lsls	r7, r6, #17
    dbaa:	d53c      	bpl.n	dc26 <I2C_ITSlaveCplt+0xde>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    dbac:	6822      	ldr	r2, [r4, #0]
    dbae:	6813      	ldr	r3, [r2, #0]
    dbb0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    dbb4:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmatx != NULL)
    dbb6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    dbb8:	b11a      	cbz	r2, dbc2 <I2C_ITSlaveCplt+0x7a>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
    dbba:	6812      	ldr	r2, [r2, #0]
    dbbc:	6853      	ldr	r3, [r2, #4]
    dbbe:	b29b      	uxth	r3, r3
    dbc0:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
    dbc2:	0769      	lsls	r1, r5, #29
    dbc4:	d50b      	bpl.n	dbde <I2C_ITSlaveCplt+0x96>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    dbc6:	6822      	ldr	r2, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
    dbc8:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    dbcc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dbce:	6a52      	ldr	r2, [r2, #36]	; 0x24
    dbd0:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    dbd2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    dbd4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    dbd6:	3301      	adds	r3, #1
    dbd8:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    dbda:	2a00      	cmp	r2, #0
    dbdc:	d147      	bne.n	dc6e <I2C_ITSlaveCplt+0x126>
  if (hi2c->XferCount != 0U)
    dbde:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    dbe0:	b29b      	uxth	r3, r3
    dbe2:	b11b      	cbz	r3, dbec <I2C_ITSlaveCplt+0xa4>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    dbe4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    dbe6:	f043 0304 	orr.w	r3, r3, #4
    dbea:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
    dbec:	2700      	movs	r7, #0
    dbee:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    dbf2:	6c66      	ldr	r6, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
    dbf4:	6367      	str	r7, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    dbf6:	2e00      	cmp	r6, #0
    dbf8:	d140      	bne.n	dc7c <I2C_ITSlaveCplt+0x134>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    dbfa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dbfc:	2500      	movs	r5, #0
    dbfe:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
    dc02:	f6cf 75ff 	movt	r5, #65535	; 0xffff
    dc06:	d124      	bne.n	dc52 <I2C_ITSlaveCplt+0x10a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    dc08:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    dc0c:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
    dc0e:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    dc12:	2b22      	cmp	r3, #34	; 0x22
    hi2c->State = HAL_I2C_STATE_READY;
    dc14:	f04f 0320 	mov.w	r3, #32
    dc18:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    dc1c:	6326      	str	r6, [r4, #48]	; 0x30
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    dc1e:	d068      	beq.n	dcf2 <I2C_ITSlaveCplt+0x1aa>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    dc20:	f7ff fe2a 	bl	d878 <HAL_I2C_SlaveTxCpltCallback>
}
    dc24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
    dc26:	0430      	lsls	r0, r6, #16
    dc28:	d5cb      	bpl.n	dbc2 <I2C_ITSlaveCplt+0x7a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    dc2a:	6822      	ldr	r2, [r4, #0]
    dc2c:	6813      	ldr	r3, [r2, #0]
    dc2e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    dc32:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmarx != NULL)
    dc34:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    dc36:	2a00      	cmp	r2, #0
    dc38:	d1bf      	bne.n	dbba <I2C_ITSlaveCplt+0x72>
    dc3a:	e7c2      	b.n	dbc2 <I2C_ITSlaveCplt+0x7a>
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
    dc3c:	2b22      	cmp	r3, #34	; 0x22
    dc3e:	d199      	bne.n	db74 <I2C_ITSlaveCplt+0x2c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc40:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc44:	680a      	ldr	r2, [r1, #0]
    dc46:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
    dc4a:	600a      	str	r2, [r1, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    dc4c:	6323      	str	r3, [r4, #48]	; 0x30
    dc4e:	6821      	ldr	r1, [r4, #0]
    dc50:	e790      	b.n	db74 <I2C_ITSlaveCplt+0x2c>
    I2C_ITSlaveSeqCplt(hi2c);
    dc52:	4620      	mov	r0, r4
    dc54:	f7ff fe14 	bl	d880 <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
    dc58:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    dc5a:	62e5      	str	r5, [r4, #44]	; 0x2c
    HAL_I2C_ListenCpltCallback(hi2c);
    dc5c:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    dc5e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    dc62:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    dc66:	6326      	str	r6, [r4, #48]	; 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
    dc68:	f7ff fe9c 	bl	d9a4 <HAL_I2C_ListenCpltCallback>
}
    dc6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->XferCount--;
    dc6e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    dc70:	3a01      	subs	r2, #1
      hi2c->XferCount--;
    dc72:	3b01      	subs	r3, #1
      hi2c->XferSize--;
    dc74:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    dc76:	b29b      	uxth	r3, r3
    dc78:	8563      	strh	r3, [r4, #42]	; 0x2a
    dc7a:	e7b0      	b.n	dbde <I2C_ITSlaveCplt+0x96>
    I2C_ITError(hi2c, hi2c->ErrorCode);
    dc7c:	6c61      	ldr	r1, [r4, #68]	; 0x44
    dc7e:	4620      	mov	r0, r4
    dc80:	f7ff febc 	bl	d9fc <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
    dc84:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dc88:	2b28      	cmp	r3, #40	; 0x28
    dc8a:	d1cb      	bne.n	dc24 <I2C_ITSlaveCplt+0xdc>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    dc8c:	463a      	mov	r2, r7
  hi2c->State = HAL_I2C_STATE_READY;
    dc8e:	2120      	movs	r1, #32
  hi2c->XferISR = NULL;
    dc90:	6367      	str	r7, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    dc92:	f6cf 72ff 	movt	r2, #65535	; 0xffff
    dc96:	6823      	ldr	r3, [r4, #0]
    dc98:	62e2      	str	r2, [r4, #44]	; 0x2c
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    dc9a:	076a      	lsls	r2, r5, #29
  hi2c->PreviousState = I2C_STATE_NONE;
    dc9c:	6327      	str	r7, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    dc9e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    dca2:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    dca6:	d512      	bpl.n	dcce <I2C_ITSlaveCplt+0x186>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    dca8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    dcaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dcac:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    dcae:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    dcb0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    dcb2:	3301      	adds	r3, #1
    dcb4:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    dcb6:	b1fa      	cbz	r2, dcf8 <I2C_ITSlaveCplt+0x1b0>
      hi2c->XferCount--;
    dcb8:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    dcba:	3a01      	subs	r2, #1
    dcbc:	6823      	ldr	r3, [r4, #0]
      hi2c->XferCount--;
    dcbe:	3901      	subs	r1, #1
      hi2c->XferSize--;
    dcc0:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    dcc2:	b28a      	uxth	r2, r1
    dcc4:	8562      	strh	r2, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    dcc6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    dcc8:	f042 0204 	orr.w	r2, r2, #4
    dccc:	6462      	str	r2, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dcce:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dcd2:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dcd4:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    dcd8:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dcda:	681a      	ldr	r2, [r3, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    dcdc:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dcde:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
    dce2:	601a      	str	r2, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dce4:	6823      	ldr	r3, [r4, #0]
    dce6:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    dce8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    dcec:	f7ff fe5a 	bl	d9a4 <HAL_I2C_ListenCpltCallback>
}
    dcf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    dcf2:	f7ff fdc3 	bl	d87c <HAL_I2C_SlaveRxCpltCallback>
}
    dcf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dcf8:	6823      	ldr	r3, [r4, #0]
    dcfa:	e7e8      	b.n	dcce <I2C_ITSlaveCplt+0x186>

0000dcfc <I2C_Slave_ISR_IT>:
{
    dcfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
    dcfe:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
    dd02:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
    dd04:	2b01      	cmp	r3, #1
    dd06:	d07f      	beq.n	de08 <I2C_Slave_ISR_IT+0x10c>
    dd08:	4616      	mov	r6, r2
    dd0a:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    dd0c:	068a      	lsls	r2, r1, #26
    dd0e:	4604      	mov	r4, r0
    dd10:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
    dd12:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    dd16:	d501      	bpl.n	dd1c <I2C_Slave_ISR_IT+0x20>
    dd18:	06b3      	lsls	r3, r6, #26
    dd1a:	d462      	bmi.n	dde2 <I2C_Slave_ISR_IT+0xe6>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dd1c:	06ea      	lsls	r2, r5, #27
    dd1e:	d51b      	bpl.n	dd58 <I2C_Slave_ISR_IT+0x5c>
    dd20:	06f3      	lsls	r3, r6, #27
    dd22:	d519      	bpl.n	dd58 <I2C_Slave_ISR_IT+0x5c>
    if (hi2c->XferCount == 0U)
    dd24:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    dd26:	6822      	ldr	r2, [r4, #0]
    dd28:	b29b      	uxth	r3, r3
    dd2a:	2b00      	cmp	r3, #0
    dd2c:	d15e      	bne.n	ddec <I2C_Slave_ISR_IT+0xf0>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
    dd2e:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    dd32:	2928      	cmp	r1, #40	; 0x28
    dd34:	d102      	bne.n	dd3c <I2C_Slave_ISR_IT+0x40>
    dd36:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    dd3a:	d07a      	beq.n	de32 <I2C_Slave_ISR_IT+0x136>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    dd3c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dd40:	2b29      	cmp	r3, #41	; 0x29
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dd42:	f04f 0310 	mov.w	r3, #16
    dd46:	61d3      	str	r3, [r2, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    dd48:	d102      	bne.n	dd50 <I2C_Slave_ISR_IT+0x54>
    dd4a:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    dd4e:	d161      	bne.n	de14 <I2C_Slave_ISR_IT+0x118>
  __HAL_UNLOCK(hi2c);
    dd50:	2000      	movs	r0, #0
    dd52:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    dd56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    dd58:	076a      	lsls	r2, r5, #29
    dd5a:	d40e      	bmi.n	dd7a <I2C_Slave_ISR_IT+0x7e>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
    dd5c:	0728      	lsls	r0, r5, #28
    dd5e:	d52a      	bpl.n	ddb6 <I2C_Slave_ISR_IT+0xba>
    dd60:	0731      	lsls	r1, r6, #28
    dd62:	d528      	bpl.n	ddb6 <I2C_Slave_ISR_IT+0xba>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
    dd64:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dd68:	f003 0328 	and.w	r3, r3, #40	; 0x28
    dd6c:	2b28      	cmp	r3, #40	; 0x28
    dd6e:	f000 8092 	beq.w	de96 <I2C_Slave_ISR_IT+0x19a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    dd72:	6823      	ldr	r3, [r4, #0]
    dd74:	2208      	movs	r2, #8
    dd76:	61da      	str	r2, [r3, #28]
    dd78:	e7ea      	b.n	dd50 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    dd7a:	0773      	lsls	r3, r6, #29
    dd7c:	d5ee      	bpl.n	dd5c <I2C_Slave_ISR_IT+0x60>
    if (hi2c->XferCount > 0U)
    dd7e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    dd80:	b29b      	uxth	r3, r3
    dd82:	b16b      	cbz	r3, dda0 <I2C_Slave_ISR_IT+0xa4>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    dd84:	6822      	ldr	r2, [r4, #0]
    dd86:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dd88:	6a52      	ldr	r2, [r2, #36]	; 0x24
    dd8a:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
    dd8c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
    dd8e:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
    dd90:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    dd92:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
    dd94:	3101      	adds	r1, #1
      hi2c->XferCount--;
    dd96:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
    dd98:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
    dd9a:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
    dd9c:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    dd9e:	8522      	strh	r2, [r4, #40]	; 0x28
    if ((hi2c->XferCount == 0U) && \
    dda0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    dda2:	b29b      	uxth	r3, r3
    dda4:	2b00      	cmp	r3, #0
    dda6:	d1d3      	bne.n	dd50 <I2C_Slave_ISR_IT+0x54>
    dda8:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    ddac:	d0d0      	beq.n	dd50 <I2C_Slave_ISR_IT+0x54>
        I2C_ITSlaveSeqCplt(hi2c);
    ddae:	4620      	mov	r0, r4
    ddb0:	f7ff fd66 	bl	d880 <I2C_ITSlaveSeqCplt>
    ddb4:	e7cc      	b.n	dd50 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
    ddb6:	07aa      	lsls	r2, r5, #30
    ddb8:	d5ca      	bpl.n	dd50 <I2C_Slave_ISR_IT+0x54>
    ddba:	07b3      	lsls	r3, r6, #30
    ddbc:	d5c8      	bpl.n	dd50 <I2C_Slave_ISR_IT+0x54>
    if (hi2c->XferCount > 0U)
    ddbe:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    ddc0:	b29b      	uxth	r3, r3
    ddc2:	b31b      	cbz	r3, de0c <I2C_Slave_ISR_IT+0x110>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    ddc4:	6a62      	ldr	r2, [r4, #36]	; 0x24
    ddc6:	6823      	ldr	r3, [r4, #0]
    ddc8:	7812      	ldrb	r2, [r2, #0]
    ddca:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    ddcc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
    ddce:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
    ddd0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    ddd2:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
    ddd4:	3101      	adds	r1, #1
      hi2c->XferCount--;
    ddd6:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
    ddd8:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
    ddda:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
    dddc:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    ddde:	8522      	strh	r2, [r4, #40]	; 0x28
    dde0:	e7b6      	b.n	dd50 <I2C_Slave_ISR_IT+0x54>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
    dde2:	f7ff feb1 	bl	db48 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dde6:	06ea      	lsls	r2, r5, #27
    dde8:	d5b6      	bpl.n	dd58 <I2C_Slave_ISR_IT+0x5c>
    ddea:	e799      	b.n	dd20 <I2C_Slave_ISR_IT+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    ddec:	2310      	movs	r3, #16
    ddee:	61d3      	str	r3, [r2, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    ddf0:	6c63      	ldr	r3, [r4, #68]	; 0x44
    ddf2:	f043 0304 	orr.w	r3, r3, #4
    ddf6:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    ddf8:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
    ddfc:	d1a8      	bne.n	dd50 <I2C_Slave_ISR_IT+0x54>
        I2C_ITError(hi2c, hi2c->ErrorCode);
    ddfe:	6c61      	ldr	r1, [r4, #68]	; 0x44
    de00:	4620      	mov	r0, r4
    de02:	f7ff fdfb 	bl	d9fc <I2C_ITError>
    de06:	e7a3      	b.n	dd50 <I2C_Slave_ISR_IT+0x54>
  __HAL_LOCK(hi2c);
    de08:	2002      	movs	r0, #2
}
    de0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
    de0c:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
    de10:	d19e      	bne.n	dd50 <I2C_Slave_ISR_IT+0x54>
    de12:	e7cc      	b.n	ddae <I2C_Slave_ISR_IT+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    de14:	6823      	ldr	r3, [r4, #0]
    de16:	699a      	ldr	r2, [r3, #24]
    de18:	0790      	lsls	r0, r2, #30
    de1a:	d502      	bpl.n	de22 <I2C_Slave_ISR_IT+0x126>
    hi2c->Instance->TXDR = 0x00U;
    de1c:	2200      	movs	r2, #0
    de1e:	629a      	str	r2, [r3, #40]	; 0x28
    de20:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    de22:	699a      	ldr	r2, [r3, #24]
    de24:	07d1      	lsls	r1, r2, #31
    de26:	d4c2      	bmi.n	ddae <I2C_Slave_ISR_IT+0xb2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    de28:	699a      	ldr	r2, [r3, #24]
    de2a:	f042 0201 	orr.w	r2, r2, #1
    de2e:	619a      	str	r2, [r3, #24]
    de30:	e7bd      	b.n	ddae <I2C_Slave_ISR_IT+0xb2>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    de32:	2100      	movs	r1, #0
  hi2c->State = HAL_I2C_STATE_READY;
    de34:	2020      	movs	r0, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    de36:	076d      	lsls	r5, r5, #29
  hi2c->XferISR = NULL;
    de38:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    de3a:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    de3e:	62e1      	str	r1, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
    de40:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    de42:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    de46:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    de4a:	d512      	bpl.n	de72 <I2C_Slave_ISR_IT+0x176>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    de4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    de4e:	6a52      	ldr	r2, [r2, #36]	; 0x24
    de50:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    de52:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    de54:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    de56:	3301      	adds	r3, #1
    de58:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    de5a:	b301      	cbz	r1, de9e <I2C_Slave_ISR_IT+0x1a2>
      hi2c->XferCount--;
    de5c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    de5e:	3901      	subs	r1, #1
    de60:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
    de62:	3b01      	subs	r3, #1
      hi2c->XferSize--;
    de64:	8521      	strh	r1, [r4, #40]	; 0x28
      hi2c->XferCount--;
    de66:	b29b      	uxth	r3, r3
    de68:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    de6a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    de6c:	f043 0304 	orr.w	r3, r3, #4
    de70:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de72:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    de76:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de78:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    de7c:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de7e:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    de80:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de82:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    de86:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    de88:	6823      	ldr	r3, [r4, #0]
    de8a:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    de8c:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    de90:	f7ff fd88 	bl	d9a4 <HAL_I2C_ListenCpltCallback>
    de94:	e75c      	b.n	dd50 <I2C_Slave_ISR_IT+0x54>
    de96:	4620      	mov	r0, r4
    de98:	f7ff fd48 	bl	d92c <I2C_ITAddrCplt.isra.9.part.10>
    de9c:	e758      	b.n	dd50 <I2C_Slave_ISR_IT+0x54>
    de9e:	6822      	ldr	r2, [r4, #0]
    dea0:	e7e7      	b.n	de72 <I2C_Slave_ISR_IT+0x176>
    dea2:	bf00      	nop

0000dea4 <I2C_Slave_ISR_DMA>:
{
    dea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(hi2c);
    dea8:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
    deac:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
    deae:	2b01      	cmp	r3, #1
    deb0:	f000 80ae 	beq.w	e010 <I2C_Slave_ISR_DMA+0x16c>
    deb4:	2301      	movs	r3, #1
    deb6:	4604      	mov	r4, r0
    deb8:	460e      	mov	r6, r1
    deba:	4615      	mov	r5, r2
    debc:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    dec0:	068b      	lsls	r3, r1, #26
    dec2:	d501      	bpl.n	dec8 <I2C_Slave_ISR_DMA+0x24>
    dec4:	06aa      	lsls	r2, r5, #26
    dec6:	d47f      	bmi.n	dfc8 <I2C_Slave_ISR_DMA+0x124>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dec8:	06f3      	lsls	r3, r6, #27
    deca:	d56f      	bpl.n	dfac <I2C_Slave_ISR_DMA+0x108>
    decc:	06e8      	lsls	r0, r5, #27
    dece:	d56d      	bpl.n	dfac <I2C_Slave_ISR_DMA+0x108>
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
    ded0:	0bab      	lsrs	r3, r5, #14
    ded2:	6822      	ldr	r2, [r4, #0]
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
    ded4:	0bed      	lsrs	r5, r5, #15
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
    ded6:	f003 0001 	and.w	r0, r3, #1
    deda:	432b      	orrs	r3, r5
    dedc:	07d9      	lsls	r1, r3, #31
    dede:	d578      	bpl.n	dfd2 <I2C_Slave_ISR_DMA+0x12e>
    dee0:	e9d4 1c0e 	ldrd	r1, ip, [r4, #56]	; 0x38
      if (hi2c->hdmarx != NULL)
    dee4:	f1bc 0f00 	cmp.w	ip, #0
    dee8:	d00e      	beq.n	df08 <I2C_Slave_ISR_DMA+0x64>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
    deea:	07eb      	lsls	r3, r5, #31
    deec:	d50c      	bpl.n	df08 <I2C_Slave_ISR_DMA+0x64>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
    deee:	f8dc 5000 	ldr.w	r5, [ip]
    def2:	f44f 6e91 	mov.w	lr, #1160	; 0x488
    def6:	686b      	ldr	r3, [r5, #4]
    def8:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    defc:	fab3 f383 	clz	r3, r3
    df00:	095b      	lsrs	r3, r3, #5
    df02:	2b00      	cmp	r3, #0
    df04:	f040 80a1 	bne.w	e04a <I2C_Slave_ISR_DMA+0x1a6>
      if (hi2c->hdmatx != NULL)
    df08:	2900      	cmp	r1, #0
    df0a:	f000 8086 	beq.w	e01a <I2C_Slave_ISR_DMA+0x176>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
    df0e:	2800      	cmp	r0, #0
    df10:	f000 8083 	beq.w	e01a <I2C_Slave_ISR_DMA+0x176>
    df14:	2000      	movs	r0, #0
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
    df16:	6809      	ldr	r1, [r1, #0]
    df18:	f44f 6e8e 	mov.w	lr, #1136	; 0x470
    df1c:	684b      	ldr	r3, [r1, #4]
    df1e:	f2c4 0e02 	movt	lr, #16386	; 0x4002
    df22:	fab3 f383 	clz	r3, r3
    df26:	095b      	lsrs	r3, r3, #5
    df28:	2b00      	cmp	r3, #0
    df2a:	d074      	beq.n	e016 <I2C_Slave_ISR_DMA+0x172>
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
    df2c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    df30:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    df34:	b2db      	uxtb	r3, r3
    df36:	d14f      	bne.n	dfd8 <I2C_Slave_ISR_DMA+0x134>
    df38:	2b28      	cmp	r3, #40	; 0x28
    df3a:	d14d      	bne.n	dfd8 <I2C_Slave_ISR_DMA+0x134>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    df3c:	2100      	movs	r1, #0
  hi2c->State = HAL_I2C_STATE_READY;
    df3e:	2020      	movs	r0, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    df40:	0775      	lsls	r5, r6, #29
  hi2c->PreviousState = I2C_STATE_NONE;
    df42:	460b      	mov	r3, r1
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    df44:	f6cf 71ff 	movt	r1, #65535	; 0xffff
  hi2c->XferISR = NULL;
    df48:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    df4a:	62e1      	str	r1, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
    df4c:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    df4e:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    df52:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    df56:	d513      	bpl.n	df80 <I2C_Slave_ISR_DMA+0xdc>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    df58:	6a52      	ldr	r2, [r2, #36]	; 0x24
    df5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    df5c:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    df5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    df60:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    df62:	3301      	adds	r3, #1
    df64:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    df66:	2a00      	cmp	r2, #0
    df68:	d07b      	beq.n	e062 <I2C_Slave_ISR_DMA+0x1be>
      hi2c->XferCount--;
    df6a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    df6c:	1e53      	subs	r3, r2, #1
    df6e:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
    df70:	3901      	subs	r1, #1
      hi2c->XferSize--;
    df72:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
    df74:	b28b      	uxth	r3, r1
    df76:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    df78:	6c63      	ldr	r3, [r4, #68]	; 0x44
    df7a:	f043 0304 	orr.w	r3, r3, #4
    df7e:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    df80:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    df84:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    df86:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    df8a:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    df8c:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    df8e:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    df90:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    df94:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    df96:	6823      	ldr	r3, [r4, #0]
    df98:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    df9a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    df9e:	f7ff fd01 	bl	d9a4 <HAL_I2C_ListenCpltCallback>
  __HAL_UNLOCK(hi2c);
    dfa2:	2000      	movs	r0, #0
    dfa4:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    dfa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
    dfac:	0732      	lsls	r2, r6, #28
    dfae:	d5f8      	bpl.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
    dfb0:	072b      	lsls	r3, r5, #28
    dfb2:	d5f6      	bpl.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
    dfb4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dfb8:	f003 0328 	and.w	r3, r3, #40	; 0x28
    dfbc:	2b28      	cmp	r3, #40	; 0x28
    dfbe:	d04c      	beq.n	e05a <I2C_Slave_ISR_DMA+0x1b6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    dfc0:	6823      	ldr	r3, [r4, #0]
    dfc2:	2208      	movs	r2, #8
    dfc4:	61da      	str	r2, [r3, #28]
    dfc6:	e7ec      	b.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
    I2C_ITSlaveCplt(hi2c, ITFlags);
    dfc8:	f7ff fdbe 	bl	db48 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dfcc:	06f3      	lsls	r3, r6, #27
    dfce:	d5ed      	bpl.n	dfac <I2C_Slave_ISR_DMA+0x108>
    dfd0:	e77c      	b.n	decc <I2C_Slave_ISR_DMA+0x28>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dfd2:	2310      	movs	r3, #16
    dfd4:	61d3      	str	r3, [r2, #28]
    dfd6:	e7e4      	b.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    dfd8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dfdc:	2b29      	cmp	r3, #41	; 0x29
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dfde:	f04f 0310 	mov.w	r3, #16
    dfe2:	61d3      	str	r3, [r2, #28]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    dfe4:	d1dd      	bne.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
    dfe6:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    dfea:	d0da      	beq.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    dfec:	6823      	ldr	r3, [r4, #0]
    dfee:	699a      	ldr	r2, [r3, #24]
    dff0:	0790      	lsls	r0, r2, #30
    dff2:	d502      	bpl.n	dffa <I2C_Slave_ISR_DMA+0x156>
    hi2c->Instance->TXDR = 0x00U;
    dff4:	2200      	movs	r2, #0
    dff6:	629a      	str	r2, [r3, #40]	; 0x28
    dff8:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    dffa:	699a      	ldr	r2, [r3, #24]
    dffc:	07d1      	lsls	r1, r2, #31
    dffe:	d403      	bmi.n	e008 <I2C_Slave_ISR_DMA+0x164>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    e000:	699a      	ldr	r2, [r3, #24]
    e002:	f042 0201 	orr.w	r2, r2, #1
    e006:	619a      	str	r2, [r3, #24]
          I2C_ITSlaveSeqCplt(hi2c);
    e008:	4620      	mov	r0, r4
    e00a:	f7ff fc39 	bl	d880 <I2C_ITSlaveSeqCplt>
    e00e:	e7c8      	b.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
  __HAL_LOCK(hi2c);
    e010:	2002      	movs	r0, #2
}
    e012:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (treatdmanack == 1U)
    e016:	2800      	cmp	r0, #0
    e018:	d188      	bne.n	df2c <I2C_Slave_ISR_DMA+0x88>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    e01a:	2310      	movs	r3, #16
    e01c:	61d3      	str	r3, [r2, #28]
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    e01e:	f037 7280 	bics.w	r2, r7, #16777216	; 0x1000000
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e022:	6c63      	ldr	r3, [r4, #68]	; 0x44
    e024:	f043 0304 	orr.w	r3, r3, #4
    e028:	6463      	str	r3, [r4, #68]	; 0x44
        tmpstate = hi2c->State;
    e02a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    e02e:	b2db      	uxtb	r3, r3
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    e030:	d1b7      	bne.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    e032:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    e036:	2b21      	cmp	r3, #33	; 0x21
    e038:	d001      	beq.n	e03e <I2C_Slave_ISR_DMA+0x19a>
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
    e03a:	2b22      	cmp	r3, #34	; 0x22
    e03c:	d100      	bne.n	e040 <I2C_Slave_ISR_DMA+0x19c>
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    e03e:	6323      	str	r3, [r4, #48]	; 0x30
          I2C_ITError(hi2c, hi2c->ErrorCode);
    e040:	6c61      	ldr	r1, [r4, #68]	; 0x44
    e042:	4620      	mov	r0, r4
    e044:	f7ff fcda 	bl	d9fc <I2C_ITError>
    e048:	e7ab      	b.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
      if (hi2c->hdmatx != NULL)
    e04a:	2900      	cmp	r1, #0
    e04c:	f43f af6e 	beq.w	df2c <I2C_Slave_ISR_DMA+0x88>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
    e050:	2800      	cmp	r0, #0
    e052:	f43f af6b 	beq.w	df2c <I2C_Slave_ISR_DMA+0x88>
            treatdmanack = 1U;
    e056:	2001      	movs	r0, #1
    e058:	e75d      	b.n	df16 <I2C_Slave_ISR_DMA+0x72>
    e05a:	4620      	mov	r0, r4
    e05c:	f7ff fc66 	bl	d92c <I2C_ITAddrCplt.isra.9.part.10>
    e060:	e79f      	b.n	dfa2 <I2C_Slave_ISR_DMA+0xfe>
    e062:	6822      	ldr	r2, [r4, #0]
    e064:	e78c      	b.n	df80 <I2C_Slave_ISR_DMA+0xdc>
    e066:	bf00      	nop

0000e068 <I2C_DMAMasterTransmitCplt>:
{
    e068:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    e06a:	6b84      	ldr	r4, [r0, #56]	; 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    e06c:	6822      	ldr	r2, [r4, #0]
    e06e:	6813      	ldr	r3, [r2, #0]
    e070:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    e074:	6013      	str	r3, [r2, #0]
  if (hi2c->XferCount == 0U)
    e076:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e078:	b29b      	uxth	r3, r3
    e07a:	b993      	cbnz	r3, e0a2 <I2C_DMAMasterTransmitCplt+0x3a>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e07c:	f64d 63a5 	movw	r3, #56997	; 0xdea5
    e080:	6b62      	ldr	r2, [r4, #52]	; 0x34
    e082:	f2c0 0300 	movt	r3, #0
    e086:	429a      	cmp	r2, r3
    e088:	d034      	beq.n	e0f4 <I2C_DMAMasterTransmitCplt+0x8c>
    e08a:	f24e 6395 	movw	r3, #59029	; 0xe695
    e08e:	f2c0 0300 	movt	r3, #0
    e092:	429a      	cmp	r2, r3
    e094:	d02e      	beq.n	e0f4 <I2C_DMAMasterTransmitCplt+0x8c>
      tmpisr |= I2C_IT_STOPI;
    e096:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    e098:	6822      	ldr	r2, [r4, #0]
    e09a:	6813      	ldr	r3, [r2, #0]
    e09c:	430b      	orrs	r3, r1
    e09e:	6013      	str	r3, [r2, #0]
}
    e0a0:	bd10      	pop	{r4, pc}
    hi2c->pBuffPtr += hi2c->XferSize;
    e0a2:	6a61      	ldr	r1, [r4, #36]	; 0x24
    e0a4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    e0a6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr += hi2c->XferSize;
    e0a8:	4411      	add	r1, r2
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    e0aa:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr += hi2c->XferSize;
    e0ac:	6261      	str	r1, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    e0ae:	d81e      	bhi.n	e0ee <I2C_DMAMasterTransmitCplt+0x86>
      hi2c->XferSize = hi2c->XferCount;
    e0b0:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    e0b2:	b280      	uxth	r0, r0
    e0b4:	4603      	mov	r3, r0
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
    e0b6:	6822      	ldr	r2, [r4, #0]
    e0b8:	8520      	strh	r0, [r4, #40]	; 0x28
    e0ba:	3228      	adds	r2, #40	; 0x28
    e0bc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    e0be:	f7fd f80b 	bl	b0d8 <HAL_DMA_Start_IT>
    e0c2:	b9f8      	cbnz	r0, e104 <I2C_DMAMasterTransmitCplt+0x9c>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e0c4:	f24e 6295 	movw	r2, #59029	; 0xe695
    e0c8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    e0ca:	f2c0 0200 	movt	r2, #0
    e0ce:	4293      	cmp	r3, r2
    e0d0:	d012      	beq.n	e0f8 <I2C_DMAMasterTransmitCplt+0x90>
    e0d2:	f64d 62a5 	movw	r2, #56997	; 0xdea5
    e0d6:	f2c0 0200 	movt	r2, #0
    e0da:	1a9b      	subs	r3, r3, r2
    e0dc:	fab3 f383 	clz	r3, r3
    e0e0:	095b      	lsrs	r3, r3, #5
    e0e2:	b94b      	cbnz	r3, e0f8 <I2C_DMAMasterTransmitCplt+0x90>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    e0e4:	6821      	ldr	r1, [r4, #0]
    e0e6:	680a      	ldr	r2, [r1, #0]
    e0e8:	4313      	orrs	r3, r2
    e0ea:	600b      	str	r3, [r1, #0]
}
    e0ec:	bd10      	pop	{r4, pc}
    e0ee:	23ff      	movs	r3, #255	; 0xff
      hi2c->XferSize = MAX_NBYTE_SIZE;
    e0f0:	4618      	mov	r0, r3
    e0f2:	e7e0      	b.n	e0b6 <I2C_DMAMasterTransmitCplt+0x4e>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e0f4:	2160      	movs	r1, #96	; 0x60
    e0f6:	e7cf      	b.n	e098 <I2C_DMAMasterTransmitCplt+0x30>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    e0f8:	6821      	ldr	r1, [r4, #0]
      tmpisr |= I2C_IT_TCI;
    e0fa:	2340      	movs	r3, #64	; 0x40
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    e0fc:	680a      	ldr	r2, [r1, #0]
    e0fe:	4313      	orrs	r3, r2
    e100:	600b      	str	r3, [r1, #0]
    e102:	e7f3      	b.n	e0ec <I2C_DMAMasterTransmitCplt+0x84>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
    e104:	4620      	mov	r0, r4
    e106:	2110      	movs	r1, #16
}
    e108:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
    e10c:	f7ff bc76 	b.w	d9fc <I2C_ITError>

0000e110 <I2C_ITMasterCplt>:
{
    e110:	b570      	push	{r4, r5, r6, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    e112:	2220      	movs	r2, #32
    e114:	6803      	ldr	r3, [r0, #0]
{
    e116:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    e118:	61da      	str	r2, [r3, #28]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    e11a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e11e:	2b21      	cmp	r3, #33	; 0x21
    e120:	f000 80b3 	beq.w	e28a <I2C_ITMasterCplt+0x17a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    e124:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    e128:	2b22      	cmp	r3, #34	; 0x22
    e12a:	f000 8098 	beq.w	e25e <I2C_ITMasterCplt+0x14e>
  I2C_RESET_CR2(hi2c);
    e12e:	6820      	ldr	r0, [r4, #0]
    e130:	f44f 4568 	mov.w	r5, #59392	; 0xe800
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e134:	2200      	movs	r2, #0
  I2C_RESET_CR2(hi2c);
    e136:	6843      	ldr	r3, [r0, #4]
    e138:	f6cf 6500 	movt	r5, #65024	; 0xfe00
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e13c:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  I2C_RESET_CR2(hi2c);
    e140:	402b      	ands	r3, r5
  hi2c->XferISR       = NULL;
    e142:	2500      	movs	r5, #0
  I2C_RESET_CR2(hi2c);
    e144:	6043      	str	r3, [r0, #4]
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
    e146:	06cb      	lsls	r3, r1, #27
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e148:	62e2      	str	r2, [r4, #44]	; 0x2c
  hi2c->XferISR       = NULL;
    e14a:	6365      	str	r5, [r4, #52]	; 0x34
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
    e14c:	d506      	bpl.n	e15c <I2C_ITMasterCplt+0x4c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    e14e:	6823      	ldr	r3, [r4, #0]
    e150:	2210      	movs	r2, #16
    e152:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e154:	6c63      	ldr	r3, [r4, #68]	; 0x44
    e156:	f043 0304 	orr.w	r3, r3, #4
    e15a:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
    e15c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    e160:	6823      	ldr	r3, [r4, #0]
    e162:	2a60      	cmp	r2, #96	; 0x60
    e164:	f000 808c 	beq.w	e280 <I2C_ITMasterCplt+0x170>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    e168:	699a      	ldr	r2, [r3, #24]
    e16a:	0795      	lsls	r5, r2, #30
    e16c:	d502      	bpl.n	e174 <I2C_ITMasterCplt+0x64>
    hi2c->Instance->TXDR = 0x00U;
    e16e:	2200      	movs	r2, #0
    e170:	629a      	str	r2, [r3, #40]	; 0x28
    e172:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    e174:	699a      	ldr	r2, [r3, #24]
    e176:	07d0      	lsls	r0, r2, #31
    e178:	d403      	bmi.n	e182 <I2C_ITMasterCplt+0x72>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    e17a:	699a      	ldr	r2, [r3, #24]
    e17c:	f042 0201 	orr.w	r2, r2, #1
    e180:	619a      	str	r2, [r3, #24]
  tmperror = hi2c->ErrorCode;
    e182:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
    e184:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    e188:	2a60      	cmp	r2, #96	; 0x60
    e18a:	d00e      	beq.n	e1aa <I2C_ITMasterCplt+0x9a>
    e18c:	3300      	adds	r3, #0
    e18e:	bf18      	it	ne
    e190:	2301      	movne	r3, #1
    e192:	b953      	cbnz	r3, e1aa <I2C_ITMasterCplt+0x9a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    e194:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    e198:	2a21      	cmp	r2, #33	; 0x21
    e19a:	f000 80da 	beq.w	e352 <I2C_ITMasterCplt+0x242>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    e19e:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    e1a2:	2a22      	cmp	r2, #34	; 0x22
    e1a4:	f000 8082 	beq.w	e2ac <I2C_ITMasterCplt+0x19c>
}
    e1a8:	bd70      	pop	{r4, r5, r6, pc}
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e1aa:	2000      	movs	r0, #0
    I2C_ITError(hi2c, hi2c->ErrorCode);
    e1ac:	6c62      	ldr	r2, [r4, #68]	; 0x44
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    e1ae:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    e1b2:	4601      	mov	r1, r0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e1b4:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    e1b8:	3b28      	subs	r3, #40	; 0x28
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    e1ba:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e1be:	62e0      	str	r0, [r4, #44]	; 0x2c
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    e1c0:	2b02      	cmp	r3, #2
  hi2c->XferCount     = 0U;
    e1c2:	8561      	strh	r1, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    e1c4:	6c60      	ldr	r0, [r4, #68]	; 0x44
    e1c6:	6821      	ldr	r1, [r4, #0]
    e1c8:	ea42 0200 	orr.w	r2, r2, r0
    e1cc:	6462      	str	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    e1ce:	d834      	bhi.n	e23a <I2C_ITMasterCplt+0x12a>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1d0:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    e1d4:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1d6:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    e1da:	f64d 43fd 	movw	r3, #56573	; 0xdcfd
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1de:	4032      	ands	r2, r6
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1e0:	4035      	ands	r5, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    e1e2:	f2c0 0300 	movt	r3, #0
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1e6:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e1e8:	680a      	ldr	r2, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1ea:	bf14      	ite	ne
    e1ec:	f06f 00f6 	mvnne.w	r0, #246	; 0xf6
    e1f0:	f06f 0046 	mvneq.w	r0, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e1f4:	42b5      	cmp	r5, r6
    e1f6:	bf18      	it	ne
    e1f8:	f06f 00f6 	mvnne.w	r0, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e1fc:	4002      	ands	r2, r0
    e1fe:	600a      	str	r2, [r1, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    e200:	6363      	str	r3, [r4, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    e202:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    e206:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    e208:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    e20a:	b118      	cbz	r0, e214 <I2C_ITMasterCplt+0x104>
    e20c:	2b11      	cmp	r3, #17
    e20e:	d05d      	beq.n	e2cc <I2C_ITMasterCplt+0x1bc>
    e210:	2b21      	cmp	r3, #33	; 0x21
    e212:	d05b      	beq.n	e2cc <I2C_ITMasterCplt+0x1bc>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    e214:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    e216:	b118      	cbz	r0, e220 <I2C_ITMasterCplt+0x110>
    e218:	2b12      	cmp	r3, #18
    e21a:	d078      	beq.n	e30e <I2C_ITMasterCplt+0x1fe>
    e21c:	2b22      	cmp	r3, #34	; 0x22
    e21e:	d076      	beq.n	e30e <I2C_ITMasterCplt+0x1fe>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    e220:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    e224:	2b60      	cmp	r3, #96	; 0x60
    e226:	f000 80a4 	beq.w	e372 <I2C_ITMasterCplt+0x262>
    hi2c->PreviousState = I2C_STATE_NONE;
    e22a:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    e22c:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
    e22e:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    e230:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    e234:	f7ff fbbc 	bl	d9b0 <HAL_I2C_ErrorCallback>
}
    e238:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e23a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e23e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e242:	680b      	ldr	r3, [r1, #0]
    e244:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    e248:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    e24a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    e24e:	2b60      	cmp	r3, #96	; 0x60
    e250:	d002      	beq.n	e258 <I2C_ITMasterCplt+0x148>
      hi2c->State         = HAL_I2C_STATE_READY;
    e252:	2320      	movs	r3, #32
    e254:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e258:	2300      	movs	r3, #0
    e25a:	6363      	str	r3, [r4, #52]	; 0x34
    e25c:	e7d3      	b.n	e206 <I2C_ITMasterCplt+0xf6>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e25e:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e262:	2512      	movs	r5, #18
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e264:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e266:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e26a:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e26c:	2a28      	cmp	r2, #40	; 0x28
    e26e:	bf14      	ite	ne
    e270:	f06f 02f4 	mvnne.w	r2, #244	; 0xf4
    e274:	f06f 0244 	mvneq.w	r2, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e278:	4013      	ands	r3, r2
    e27a:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e27c:	6325      	str	r5, [r4, #48]	; 0x30
    e27e:	e756      	b.n	e12e <I2C_ITMasterCplt+0x1e>
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
    e280:	074e      	lsls	r6, r1, #29
    e282:	f57f af71 	bpl.w	e168 <I2C_ITMasterCplt+0x58>
    tmp = (uint8_t)hi2c->Instance->RXDR;
    e286:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    e288:	e76e      	b.n	e168 <I2C_ITMasterCplt+0x58>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e28a:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    e28e:	2511      	movs	r5, #17
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e290:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e292:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e296:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e298:	2a28      	cmp	r2, #40	; 0x28
    e29a:	bf14      	ite	ne
    e29c:	f06f 02f2 	mvnne.w	r2, #242	; 0xf2
    e2a0:	f06f 0242 	mvneq.w	r2, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e2a4:	4013      	ands	r3, r2
    e2a6:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    e2a8:	6325      	str	r5, [r4, #48]	; 0x30
    e2aa:	e740      	b.n	e12e <I2C_ITMasterCplt+0x1e>
    hi2c->State = HAL_I2C_STATE_READY;
    e2ac:	2220      	movs	r2, #32
      HAL_I2C_MemRxCpltCallback(hi2c);
    e2ae:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
    e2b0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
    e2b4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    e2b8:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    e2ba:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
    e2be:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    e2c2:	2a40      	cmp	r2, #64	; 0x40
    e2c4:	d063      	beq.n	e38e <I2C_ITMasterCplt+0x27e>
      HAL_I2C_MasterRxCpltCallback(hi2c);
    e2c6:	f7ff fad5 	bl	d874 <HAL_I2C_MasterRxCpltCallback>
}
    e2ca:	bd70      	pop	{r4, r5, r6, pc}
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    e2cc:	6823      	ldr	r3, [r4, #0]
    e2ce:	681a      	ldr	r2, [r3, #0]
    e2d0:	0451      	lsls	r1, r2, #17
    e2d2:	d504      	bpl.n	e2de <I2C_ITMasterCplt+0x1ce>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    e2d4:	681a      	ldr	r2, [r3, #0]
    e2d6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    e2da:	601a      	str	r2, [r3, #0]
    e2dc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    e2de:	f7fd fc35 	bl	bb4c <HAL_DMA_GetState>
    e2e2:	2801      	cmp	r0, #1
    e2e4:	d09c      	beq.n	e220 <I2C_ITMasterCplt+0x110>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    e2e6:	f64d 13b9 	movw	r3, #55737	; 0xd9b9
    e2ea:	6ba1      	ldr	r1, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    e2ec:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    e2ee:	f2c0 0300 	movt	r3, #0
    e2f2:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    e2f4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    e2f8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    e2fa:	f7fd fa9f 	bl	b83c <HAL_DMA_Abort_IT>
    e2fe:	2800      	cmp	r0, #0
    e300:	f43f af52 	beq.w	e1a8 <I2C_ITMasterCplt+0x98>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    e304:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
    e306:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    e30a:	6d03      	ldr	r3, [r0, #80]	; 0x50
    e30c:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    e30e:	6823      	ldr	r3, [r4, #0]
    e310:	681a      	ldr	r2, [r3, #0]
    e312:	0412      	lsls	r2, r2, #16
    e314:	d504      	bpl.n	e320 <I2C_ITMasterCplt+0x210>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    e316:	681a      	ldr	r2, [r3, #0]
    e318:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    e31c:	601a      	str	r2, [r3, #0]
    e31e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    e320:	f7fd fc14 	bl	bb4c <HAL_DMA_GetState>
    e324:	2801      	cmp	r0, #1
    e326:	f43f af7b 	beq.w	e220 <I2C_ITMasterCplt+0x110>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    e32a:	f64d 13b9 	movw	r3, #55737	; 0xd9b9
    e32e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    e330:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    e332:	f2c0 0300 	movt	r3, #0
    e336:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    e338:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    e33c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    e33e:	f7fd fa7d 	bl	b83c <HAL_DMA_Abort_IT>
    e342:	2800      	cmp	r0, #0
    e344:	f43f af30 	beq.w	e1a8 <I2C_ITMasterCplt+0x98>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    e348:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
    e34a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    e34e:	6d03      	ldr	r3, [r0, #80]	; 0x50
    e350:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
    e352:	2220      	movs	r2, #32
      HAL_I2C_MemTxCpltCallback(hi2c);
    e354:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
    e356:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
    e35a:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    e35e:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    e360:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
    e364:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    e368:	2a40      	cmp	r2, #64	; 0x40
    e36a:	d00d      	beq.n	e388 <I2C_ITMasterCplt+0x278>
      HAL_I2C_MasterTxCpltCallback(hi2c);
    e36c:	f7ff fa80 	bl	d870 <HAL_I2C_MasterTxCpltCallback>
}
    e370:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
    e372:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    e374:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    e376:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    e378:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    e37c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    e380:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    e382:	f7ff fb17 	bl	d9b4 <HAL_I2C_AbortCpltCallback>
}
    e386:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemTxCpltCallback(hi2c);
    e388:	f7ff fb0e 	bl	d9a8 <HAL_I2C_MemTxCpltCallback>
}
    e38c:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemRxCpltCallback(hi2c);
    e38e:	f7ff fb0d 	bl	d9ac <HAL_I2C_MemRxCpltCallback>
}
    e392:	bd70      	pop	{r4, r5, r6, pc}

0000e394 <I2C_Master_ISR_IT>:
  __HAL_LOCK(hi2c);
    e394:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e398:	2b01      	cmp	r3, #1
    e39a:	f000 80e8 	beq.w	e56e <I2C_Master_ISR_IT+0x1da>
    e39e:	2301      	movs	r3, #1
{
    e3a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    e3a4:	06cf      	lsls	r7, r1, #27
{
    e3a6:	b082      	sub	sp, #8
    e3a8:	4604      	mov	r4, r0
    e3aa:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
    e3ac:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    e3b0:	d51e      	bpl.n	e3f0 <I2C_Master_ISR_IT+0x5c>
    e3b2:	06d6      	lsls	r6, r2, #27
    e3b4:	d51c      	bpl.n	e3f0 <I2C_Master_ISR_IT+0x5c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    e3b6:	6803      	ldr	r3, [r0, #0]
    e3b8:	2110      	movs	r1, #16
    e3ba:	61d9      	str	r1, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e3bc:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    e3be:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e3c0:	f041 0104 	orr.w	r1, r1, #4
    e3c4:	6441      	str	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    e3c6:	6999      	ldr	r1, [r3, #24]
    e3c8:	0788      	lsls	r0, r1, #30
    e3ca:	d502      	bpl.n	e3d2 <I2C_Master_ISR_IT+0x3e>
    hi2c->Instance->TXDR = 0x00U;
    e3cc:	2100      	movs	r1, #0
    e3ce:	6299      	str	r1, [r3, #40]	; 0x28
    e3d0:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    e3d2:	6999      	ldr	r1, [r3, #24]
    e3d4:	07c9      	lsls	r1, r1, #31
    e3d6:	f140 8097 	bpl.w	e508 <I2C_Master_ISR_IT+0x174>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    e3da:	06a9      	lsls	r1, r5, #26
    e3dc:	d502      	bpl.n	e3e4 <I2C_Master_ISR_IT+0x50>
    e3de:	0693      	lsls	r3, r2, #26
    e3e0:	f100 80c7 	bmi.w	e572 <I2C_Master_ISR_IT+0x1de>
  __HAL_UNLOCK(hi2c);
    e3e4:	2000      	movs	r0, #0
    e3e6:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    e3ea:	b002      	add	sp, #8
    e3ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    e3f0:	076f      	lsls	r7, r5, #29
    e3f2:	d408      	bmi.n	e406 <I2C_Master_ISR_IT+0x72>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
    e3f4:	07a8      	lsls	r0, r5, #30
    e3f6:	d519      	bpl.n	e42c <I2C_Master_ISR_IT+0x98>
    e3f8:	0791      	lsls	r1, r2, #30
    e3fa:	d517      	bpl.n	e42c <I2C_Master_ISR_IT+0x98>
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    e3fc:	6a61      	ldr	r1, [r4, #36]	; 0x24
    e3fe:	6823      	ldr	r3, [r4, #0]
    e400:	7809      	ldrb	r1, [r1, #0]
    e402:	6299      	str	r1, [r3, #40]	; 0x28
    e404:	e007      	b.n	e416 <I2C_Master_ISR_IT+0x82>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    e406:	0756      	lsls	r6, r2, #29
    e408:	d5f4      	bpl.n	e3f4 <I2C_Master_ISR_IT+0x60>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    e40a:	6821      	ldr	r1, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
    e40c:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    e410:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e412:	6a49      	ldr	r1, [r1, #36]	; 0x24
    e414:	7019      	strb	r1, [r3, #0]
    hi2c->XferCount--;
    e416:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr++;
    e418:	6a60      	ldr	r0, [r4, #36]	; 0x24
    hi2c->XferSize--;
    e41a:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
    e41c:	3b01      	subs	r3, #1
    hi2c->pBuffPtr++;
    e41e:	3001      	adds	r0, #1
    hi2c->XferCount--;
    e420:	b29b      	uxth	r3, r3
    hi2c->XferSize--;
    e422:	3901      	subs	r1, #1
    hi2c->pBuffPtr++;
    e424:	6260      	str	r0, [r4, #36]	; 0x24
    hi2c->XferCount--;
    e426:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferSize--;
    e428:	8521      	strh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
    e42a:	e7d6      	b.n	e3da <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    e42c:	062b      	lsls	r3, r5, #24
    e42e:	d417      	bmi.n	e460 <I2C_Master_ISR_IT+0xcc>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    e430:	066e      	lsls	r6, r5, #25
    e432:	d5d2      	bpl.n	e3da <I2C_Master_ISR_IT+0x46>
    e434:	0650      	lsls	r0, r2, #25
    e436:	d5d0      	bpl.n	e3da <I2C_Master_ISR_IT+0x46>
    if (hi2c->XferCount == 0U)
    e438:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e43a:	b29b      	uxth	r3, r3
    e43c:	2b00      	cmp	r3, #0
    e43e:	f040 808f 	bne.w	e560 <I2C_Master_ISR_IT+0x1cc>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    e442:	6821      	ldr	r1, [r4, #0]
    e444:	684b      	ldr	r3, [r1, #4]
    e446:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    e44a:	d1c6      	bne.n	e3da <I2C_Master_ISR_IT+0x46>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
    e44c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    e44e:	f510 3f80 	cmn.w	r0, #65536	; 0x10000
    e452:	f040 80b1 	bne.w	e5b8 <I2C_Master_ISR_IT+0x224>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
    e456:	684b      	ldr	r3, [r1, #4]
    e458:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    e45c:	604b      	str	r3, [r1, #4]
    e45e:	e7bc      	b.n	e3da <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    e460:	0657      	lsls	r7, r2, #25
    e462:	d5ba      	bpl.n	e3da <I2C_Master_ISR_IT+0x46>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    e464:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e466:	6821      	ldr	r1, [r4, #0]
    e468:	b29b      	uxth	r3, r3
    e46a:	2b00      	cmp	r3, #0
    e46c:	d051      	beq.n	e512 <I2C_Master_ISR_IT+0x17e>
    e46e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    e470:	2b00      	cmp	r3, #0
    e472:	d14e      	bne.n	e512 <I2C_Master_ISR_IT+0x17e>
    e474:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
    e478:	f44f 46b0 	mov.w	r6, #22528	; 0x5800
    e47c:	f44f 47b8 	mov.w	r7, #23552	; 0x5c00
    e480:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
    e484:	f2c4 0300 	movt	r3, #16384	; 0x4000
    e488:	f2c4 0600 	movt	r6, #16384	; 0x4000
    e48c:	f2c4 0700 	movt	r7, #16384	; 0x4000
    e490:	f6c5 0000 	movt	r0, #22528	; 0x5800
    e494:	4299      	cmp	r1, r3
    e496:	bf18      	it	ne
    e498:	42b1      	cmpne	r1, r6
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    e49a:	684e      	ldr	r6, [r1, #4]
    e49c:	bf14      	ite	ne
    e49e:	2301      	movne	r3, #1
    e4a0:	2300      	moveq	r3, #0
    e4a2:	f3c6 0609 	ubfx	r6, r6, #0, #10
    e4a6:	42b9      	cmp	r1, r7
    e4a8:	bf0c      	ite	eq
    e4aa:	2300      	moveq	r3, #0
    e4ac:	f003 0301 	andne.w	r3, r3, #1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    e4b0:	8d67      	ldrh	r7, [r4, #42]	; 0x2a
    e4b2:	4281      	cmp	r1, r0
    e4b4:	bf0c      	ite	eq
    e4b6:	2300      	moveq	r3, #0
    e4b8:	f003 0301 	andne.w	r3, r3, #1
    e4bc:	2fff      	cmp	r7, #255	; 0xff
    e4be:	f200 809c 	bhi.w	e5fa <I2C_Master_ISR_IT+0x266>
        hi2c->XferSize = hi2c->XferCount;
    e4c2:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    e4c4:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
    e4c6:	b280      	uxth	r0, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    e4c8:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
    e4cc:	8520      	strh	r0, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
    e4ce:	b2c7      	uxtb	r7, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    e4d0:	f000 80a3 	beq.w	e61a <I2C_Master_ISR_IT+0x286>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
    e4d4:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e4d8:	2b00      	cmp	r3, #0
    e4da:	f040 80ad 	bne.w	e638 <I2C_Master_ISR_IT+0x2a4>
  assert_param(IS_TRANSFER_MODE(Mode));
    e4de:	f038 7380 	bics.w	r3, r8, #16777216	; 0x1000000
    e4e2:	d003      	beq.n	e4ec <I2C_Master_ISR_IT+0x158>
    e4e4:	f1b8 7f00 	cmp.w	r8, #33554432	; 0x2000000
    e4e8:	f040 80b1 	bne.w	e64e <I2C_Master_ISR_IT+0x2ba>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    e4ec:	6823      	ldr	r3, [r4, #0]
    e4ee:	f44f 411c 	mov.w	r1, #39936	; 0x9c00
    e4f2:	6858      	ldr	r0, [r3, #4]
    e4f4:	f6cf 4100 	movt	r1, #64512	; 0xfc00
    e4f8:	4008      	ands	r0, r1
    e4fa:	ea40 0008 	orr.w	r0, r0, r8
    e4fe:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    e502:	4306      	orrs	r6, r0
    e504:	605e      	str	r6, [r3, #4]
    e506:	e768      	b.n	e3da <I2C_Master_ISR_IT+0x46>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    e508:	6999      	ldr	r1, [r3, #24]
    e50a:	f041 0101 	orr.w	r1, r1, #1
    e50e:	6199      	str	r1, [r3, #24]
    e510:	e763      	b.n	e3da <I2C_Master_ISR_IT+0x46>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    e512:	684b      	ldr	r3, [r1, #4]
    e514:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    e518:	d122      	bne.n	e560 <I2C_Master_ISR_IT+0x1cc>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    e51a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    e51e:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    e520:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    e524:	9201      	str	r2, [sp, #4]
    e526:	2821      	cmp	r0, #33	; 0x21
    e528:	d02d      	beq.n	e586 <I2C_Master_ISR_IT+0x1f2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e52a:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    e52c:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e530:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e532:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e534:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e536:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e53a:	f8d1 c000 	ldr.w	ip, [r1]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e53e:	f007 0728 	and.w	r7, r7, #40	; 0x28
    e542:	2f28      	cmp	r7, #40	; 0x28
    e544:	bf14      	ite	ne
    e546:	f06f 06f4 	mvnne.w	r6, #244	; 0xf4
    e54a:	f06f 0644 	mvneq.w	r6, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e54e:	ea06 060c 	and.w	r6, r6, ip
    e552:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    e554:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e558:	f7ff f98c 	bl	d874 <HAL_I2C_MasterRxCpltCallback>
    e55c:	9a01      	ldr	r2, [sp, #4]
    e55e:	e73c      	b.n	e3da <I2C_Master_ISR_IT+0x46>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
    e560:	2140      	movs	r1, #64	; 0x40
    e562:	4620      	mov	r0, r4
    e564:	9201      	str	r2, [sp, #4]
    e566:	f7ff fa49 	bl	d9fc <I2C_ITError>
    e56a:	9a01      	ldr	r2, [sp, #4]
    e56c:	e735      	b.n	e3da <I2C_Master_ISR_IT+0x46>
  __HAL_LOCK(hi2c);
    e56e:	2002      	movs	r0, #2
}
    e570:	4770      	bx	lr
    I2C_ITMasterCplt(hi2c, tmpITFlags);
    e572:	4620      	mov	r0, r4
    e574:	4629      	mov	r1, r5
    e576:	f7ff fdcb 	bl	e110 <I2C_ITMasterCplt>
  __HAL_UNLOCK(hi2c);
    e57a:	2000      	movs	r0, #0
    e57c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    e580:	b002      	add	sp, #8
    e582:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    e586:	2611      	movs	r6, #17
    hi2c->State         = HAL_I2C_STATE_READY;
    e588:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e58c:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
    e58e:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    e590:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e592:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e596:	680f      	ldr	r7, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e598:	f006 0628 	and.w	r6, r6, #40	; 0x28
    e59c:	2e28      	cmp	r6, #40	; 0x28
    e59e:	bf14      	ite	ne
    e5a0:	f06f 06f2 	mvnne.w	r6, #242	; 0xf2
    e5a4:	f06f 0642 	mvneq.w	r6, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e5a8:	403e      	ands	r6, r7
    e5aa:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    e5ac:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
    e5b0:	f7ff f95e 	bl	d870 <HAL_I2C_MasterTxCpltCallback>
    e5b4:	9a01      	ldr	r2, [sp, #4]
    e5b6:	e710      	b.n	e3da <I2C_Master_ISR_IT+0x46>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    e5b8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    e5bc:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    e5be:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    e5c2:	9201      	str	r2, [sp, #4]
    e5c4:	2821      	cmp	r0, #33	; 0x21
    e5c6:	d0de      	beq.n	e586 <I2C_Master_ISR_IT+0x1f2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e5c8:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    e5ca:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e5ce:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e5d0:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e5d2:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e5d4:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e5d8:	680e      	ldr	r6, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e5da:	f007 0728 	and.w	r7, r7, #40	; 0x28
    e5de:	2f28      	cmp	r7, #40	; 0x28
    e5e0:	bf14      	ite	ne
    e5e2:	f06f 07f4 	mvnne.w	r7, #244	; 0xf4
    e5e6:	f06f 0744 	mvneq.w	r7, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e5ea:	403e      	ands	r6, r7
    e5ec:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    e5ee:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e5f2:	f7ff f93f 	bl	d874 <HAL_I2C_MasterRxCpltCallback>
    e5f6:	9a01      	ldr	r2, [sp, #4]
    e5f8:	e6ef      	b.n	e3da <I2C_Master_ISR_IT+0x46>
        hi2c->XferSize = MAX_NBYTE_SIZE;
    e5fa:	20ff      	movs	r0, #255	; 0xff
    e5fc:	8520      	strh	r0, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e5fe:	bb8b      	cbnz	r3, e664 <I2C_Master_ISR_IT+0x2d0>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    e600:	f44f 471c 	mov.w	r7, #39936	; 0x9c00
    e604:	2000      	movs	r0, #0
    e606:	684b      	ldr	r3, [r1, #4]
    e608:	f6cf 4700 	movt	r7, #64512	; 0xfc00
    e60c:	f2c0 10ff 	movt	r0, #511	; 0x1ff
    e610:	403b      	ands	r3, r7
    e612:	4330      	orrs	r0, r6
    e614:	4303      	orrs	r3, r0
    e616:	604b      	str	r3, [r1, #4]
    e618:	e6df      	b.n	e3da <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e61a:	bb7b      	cbnz	r3, e67c <I2C_Master_ISR_IT+0x2e8>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    e61c:	f44f 4c1c 	mov.w	ip, #39936	; 0x9c00
    e620:	6848      	ldr	r0, [r1, #4]
    e622:	ea46 4307 	orr.w	r3, r6, r7, lsl #16
    e626:	f6cf 4c00 	movt	ip, #64512	; 0xfc00
    e62a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    e62e:	ea00 000c 	and.w	r0, r0, ip
    e632:	4303      	orrs	r3, r0
    e634:	604b      	str	r3, [r1, #4]
    e636:	e6d0      	b.n	e3da <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e638:	f643 0068 	movw	r0, #14440	; 0x3868
    e63c:	f641 1131 	movw	r1, #6449	; 0x1931
    e640:	9201      	str	r2, [sp, #4]
    e642:	f2c0 0003 	movt	r0, #3
    e646:	f00c fd33 	bl	1b0b0 <assert_failed>
    e64a:	9a01      	ldr	r2, [sp, #4]
    e64c:	e747      	b.n	e4de <I2C_Master_ISR_IT+0x14a>
  assert_param(IS_TRANSFER_MODE(Mode));
    e64e:	f643 0068 	movw	r0, #14440	; 0x3868
    e652:	f641 1132 	movw	r1, #6450	; 0x1932
    e656:	9201      	str	r2, [sp, #4]
    e658:	f2c0 0003 	movt	r0, #3
    e65c:	f00c fd28 	bl	1b0b0 <assert_failed>
    e660:	9a01      	ldr	r2, [sp, #4]
    e662:	e743      	b.n	e4ec <I2C_Master_ISR_IT+0x158>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e664:	f643 0068 	movw	r0, #14440	; 0x3868
    e668:	f641 1131 	movw	r1, #6449	; 0x1931
    e66c:	9201      	str	r2, [sp, #4]
    e66e:	f2c0 0003 	movt	r0, #3
    e672:	f00c fd1d 	bl	1b0b0 <assert_failed>
    e676:	6821      	ldr	r1, [r4, #0]
    e678:	9a01      	ldr	r2, [sp, #4]
    e67a:	e7c1      	b.n	e600 <I2C_Master_ISR_IT+0x26c>
    e67c:	f643 0068 	movw	r0, #14440	; 0x3868
    e680:	f641 1131 	movw	r1, #6449	; 0x1931
    e684:	9201      	str	r2, [sp, #4]
    e686:	f2c0 0003 	movt	r0, #3
    e68a:	f00c fd11 	bl	1b0b0 <assert_failed>
    e68e:	6821      	ldr	r1, [r4, #0]
    e690:	9a01      	ldr	r2, [sp, #4]
    e692:	e7c3      	b.n	e61c <I2C_Master_ISR_IT+0x288>

0000e694 <I2C_Master_ISR_DMA>:
  __HAL_LOCK(hi2c);
    e694:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    e698:	2b01      	cmp	r3, #1
    e69a:	f000 80b7 	beq.w	e80c <I2C_Master_ISR_DMA+0x178>
    e69e:	2301      	movs	r3, #1
{
    e6a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    e6a4:	06cd      	lsls	r5, r1, #27
    e6a6:	4604      	mov	r4, r0
  __HAL_LOCK(hi2c);
    e6a8:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    e6ac:	d52f      	bpl.n	e70e <I2C_Master_ISR_DMA+0x7a>
    e6ae:	06d0      	lsls	r0, r2, #27
    e6b0:	d52d      	bpl.n	e70e <I2C_Master_ISR_DMA+0x7a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    e6b2:	6822      	ldr	r2, [r4, #0]
    e6b4:	2110      	movs	r1, #16
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e6b6:	f64d 63a5 	movw	r3, #56997	; 0xdea5
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    e6ba:	61d1      	str	r1, [r2, #28]
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e6bc:	f2c0 0300 	movt	r3, #0
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e6c0:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e6c2:	6b61      	ldr	r1, [r4, #52]	; 0x34
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e6c4:	f042 0204 	orr.w	r2, r2, #4
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e6c8:	4299      	cmp	r1, r3
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    e6ca:	6462      	str	r2, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e6cc:	f000 809c 	beq.w	e808 <I2C_Master_ISR_DMA+0x174>
    e6d0:	f24e 6395 	movw	r3, #59029	; 0xe695
    e6d4:	f2c0 0300 	movt	r3, #0
    e6d8:	4299      	cmp	r1, r3
    e6da:	f000 8095 	beq.w	e808 <I2C_Master_ISR_DMA+0x174>
      tmpisr |= I2C_IT_STOPI;
    e6de:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    e6e0:	6822      	ldr	r2, [r4, #0]
    e6e2:	6813      	ldr	r3, [r2, #0]
    e6e4:	430b      	orrs	r3, r1
    e6e6:	6013      	str	r3, [r2, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    e6e8:	6823      	ldr	r3, [r4, #0]
    e6ea:	699a      	ldr	r2, [r3, #24]
    e6ec:	0791      	lsls	r1, r2, #30
    e6ee:	d502      	bpl.n	e6f6 <I2C_Master_ISR_DMA+0x62>
    hi2c->Instance->TXDR = 0x00U;
    e6f0:	2200      	movs	r2, #0
    e6f2:	629a      	str	r2, [r3, #40]	; 0x28
    e6f4:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    e6f6:	699a      	ldr	r2, [r3, #24]
    e6f8:	07d2      	lsls	r2, r2, #31
    e6fa:	d403      	bmi.n	e704 <I2C_Master_ISR_DMA+0x70>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    e6fc:	699a      	ldr	r2, [r3, #24]
    e6fe:	f042 0201 	orr.w	r2, r2, #1
    e702:	619a      	str	r2, [r3, #24]
  __HAL_UNLOCK(hi2c);
    e704:	2000      	movs	r0, #0
    e706:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    e70a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    e70e:	060f      	lsls	r7, r1, #24
    e710:	d55c      	bpl.n	e7cc <I2C_Master_ISR_DMA+0x138>
    e712:	0656      	lsls	r6, r2, #25
    e714:	d570      	bpl.n	e7f8 <I2C_Master_ISR_DMA+0x164>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
    e716:	6822      	ldr	r2, [r4, #0]
    e718:	6813      	ldr	r3, [r2, #0]
    e71a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    e71e:	6013      	str	r3, [r2, #0]
    if (hi2c->XferCount != 0U)
    e720:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e722:	b29b      	uxth	r3, r3
    e724:	2b00      	cmp	r3, #0
    e726:	d073      	beq.n	e810 <I2C_Master_ISR_DMA+0x17c>
    e728:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
    e72c:	f44f 42b0 	mov.w	r2, #22528	; 0x5800
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    e730:	6820      	ldr	r0, [r4, #0]
    e732:	f2c4 0300 	movt	r3, #16384	; 0x4000
    e736:	f2c4 0200 	movt	r2, #16384	; 0x4000
    e73a:	6846      	ldr	r6, [r0, #4]
    e73c:	4601      	mov	r1, r0
    e73e:	4298      	cmp	r0, r3
    e740:	bf18      	it	ne
    e742:	4290      	cmpne	r0, r2
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    e744:	8d67      	ldrh	r7, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    e746:	f3c6 0609 	ubfx	r6, r6, #0, #10
    e74a:	bf14      	ite	ne
    e74c:	2301      	movne	r3, #1
    e74e:	2300      	moveq	r3, #0
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    e750:	2fff      	cmp	r7, #255	; 0xff
    e752:	f200 8086 	bhi.w	e862 <I2C_Master_ISR_DMA+0x1ce>
        hi2c->XferSize = hi2c->XferCount;
    e756:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    e758:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
    e75a:	b292      	uxth	r2, r2
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    e75c:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
    e760:	8522      	strh	r2, [r4, #40]	; 0x28
    e762:	b2d2      	uxtb	r2, r2
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    e764:	f000 80d3 	beq.w	e90e <I2C_Master_ISR_DMA+0x27a>
          xfermode = hi2c->XferOptions;
    e768:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    e76a:	0415      	lsls	r5, r2, #16
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e76c:	2b00      	cmp	r3, #0
    e76e:	f040 80dc 	bne.w	e92a <I2C_Master_ISR_DMA+0x296>
    e772:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
    e776:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    e77a:	bf18      	it	ne
    e77c:	f1b8 0f00 	cmpne.w	r8, #0
    e780:	bf14      	ite	ne
    e782:	f04f 0801 	movne.w	r8, #1
    e786:	f04f 0800 	moveq.w	r8, #0
  assert_param(IS_TRANSFER_MODE(Mode));
    e78a:	f1b8 0f00 	cmp.w	r8, #0
    e78e:	f040 80c2 	bne.w	e916 <I2C_Master_ISR_DMA+0x282>
    e792:	6820      	ldr	r0, [r4, #0]
    e794:	4601      	mov	r1, r0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    e796:	f44f 421c 	mov.w	r2, #39936	; 0x9c00
    e79a:	684b      	ldr	r3, [r1, #4]
    e79c:	433d      	orrs	r5, r7
    e79e:	f6cf 4200 	movt	r2, #64512	; 0xfc00
    e7a2:	4335      	orrs	r5, r6
    e7a4:	4013      	ands	r3, r2
    e7a6:	431d      	orrs	r5, r3
    e7a8:	604d      	str	r5, [r1, #4]
      hi2c->XferCount -= hi2c->XferSize;
    e7aa:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e7ac:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    e7ae:	1a9b      	subs	r3, r3, r2
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
    e7b0:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
    e7b2:	b29b      	uxth	r3, r3
    e7b4:	8563      	strh	r3, [r4, #42]	; 0x2a
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    e7b6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    e7ba:	2b22      	cmp	r3, #34	; 0x22
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
    e7bc:	6813      	ldr	r3, [r2, #0]
    e7be:	bf0c      	ite	eq
    e7c0:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
    e7c4:	f443 4380 	orrne.w	r3, r3, #16384	; 0x4000
    e7c8:	6013      	str	r3, [r2, #0]
    e7ca:	e79b      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    e7cc:	064d      	lsls	r5, r1, #25
    e7ce:	d513      	bpl.n	e7f8 <I2C_Master_ISR_DMA+0x164>
    e7d0:	0650      	lsls	r0, r2, #25
    e7d2:	d511      	bpl.n	e7f8 <I2C_Master_ISR_DMA+0x164>
    if (hi2c->XferCount == 0U)
    e7d4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e7d6:	b29b      	uxth	r3, r3
    e7d8:	2b00      	cmp	r3, #0
    e7da:	d13d      	bne.n	e858 <I2C_Master_ISR_DMA+0x1c4>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    e7dc:	6822      	ldr	r2, [r4, #0]
    e7de:	6853      	ldr	r3, [r2, #4]
    e7e0:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    e7e4:	d18e      	bne.n	e704 <I2C_Master_ISR_DMA+0x70>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
    e7e6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    e7e8:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    e7ec:	d170      	bne.n	e8d0 <I2C_Master_ISR_DMA+0x23c>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
    e7ee:	6853      	ldr	r3, [r2, #4]
    e7f0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    e7f4:	6053      	str	r3, [r2, #4]
    e7f6:	e785      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    e7f8:	068b      	lsls	r3, r1, #26
    e7fa:	d583      	bpl.n	e704 <I2C_Master_ISR_DMA+0x70>
    e7fc:	0692      	lsls	r2, r2, #26
    e7fe:	d581      	bpl.n	e704 <I2C_Master_ISR_DMA+0x70>
    I2C_ITMasterCplt(hi2c, ITFlags);
    e800:	4620      	mov	r0, r4
    e802:	f7ff fc85 	bl	e110 <I2C_ITMasterCplt>
    e806:	e77d      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    e808:	2160      	movs	r1, #96	; 0x60
    e80a:	e769      	b.n	e6e0 <I2C_Master_ISR_DMA+0x4c>
  __HAL_LOCK(hi2c);
    e80c:	2002      	movs	r0, #2
}
    e80e:	4770      	bx	lr
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    e810:	6822      	ldr	r2, [r4, #0]
    e812:	6853      	ldr	r3, [r2, #4]
    e814:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    e818:	d11e      	bne.n	e858 <I2C_Master_ISR_DMA+0x1c4>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    e81a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    e81e:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    e820:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    e824:	2921      	cmp	r1, #33	; 0x21
    e826:	d03b      	beq.n	e8a0 <I2C_Master_ISR_DMA+0x20c>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e828:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    e82a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e82e:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e830:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e832:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e834:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e838:	6816      	ldr	r6, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e83a:	f005 0528 	and.w	r5, r5, #40	; 0x28
    e83e:	2d28      	cmp	r5, #40	; 0x28
    e840:	bf14      	ite	ne
    e842:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    e846:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e84a:	4031      	ands	r1, r6
    e84c:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    e84e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e852:	f7ff f80f 	bl	d874 <HAL_I2C_MasterRxCpltCallback>
    e856:	e755      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
    e858:	2140      	movs	r1, #64	; 0x40
    e85a:	4620      	mov	r0, r4
    e85c:	f7ff f8ce 	bl	d9fc <I2C_ITError>
    e860:	e750      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
        hi2c->XferSize = MAX_NBYTE_SIZE;
    e862:	22ff      	movs	r2, #255	; 0xff
    e864:	f44f 057f 	mov.w	r5, #16711680	; 0xff0000
        xfermode = I2C_RELOAD_MODE;
    e868:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
        hi2c->XferSize = MAX_NBYTE_SIZE;
    e86c:	8522      	strh	r2, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e86e:	2b00      	cmp	r3, #0
    e870:	d091      	beq.n	e796 <I2C_Master_ISR_DMA+0x102>
    e872:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    e876:	f6c5 0300 	movt	r3, #22528	; 0x5800
    e87a:	4298      	cmp	r0, r3
    e87c:	d08a      	beq.n	e794 <I2C_Master_ISR_DMA+0x100>
    e87e:	f44f 43b8 	mov.w	r3, #23552	; 0x5c00
    e882:	f2c4 0300 	movt	r3, #16384	; 0x4000
    e886:	4298      	cmp	r0, r3
    e888:	d084      	beq.n	e794 <I2C_Master_ISR_DMA+0x100>
    e88a:	f04f 0800 	mov.w	r8, #0
    e88e:	f643 0068 	movw	r0, #14440	; 0x3868
    e892:	f641 1131 	movw	r1, #6449	; 0x1931
    e896:	f2c0 0003 	movt	r0, #3
    e89a:	f00c fc09 	bl	1b0b0 <assert_failed>
    e89e:	e774      	b.n	e78a <I2C_Master_ISR_DMA+0xf6>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    e8a0:	2111      	movs	r1, #17
    hi2c->State         = HAL_I2C_STATE_READY;
    e8a2:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e8a6:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
    e8a8:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    e8aa:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e8ac:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e8b0:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e8b2:	f001 0128 	and.w	r1, r1, #40	; 0x28
    e8b6:	2928      	cmp	r1, #40	; 0x28
    e8b8:	bf14      	ite	ne
    e8ba:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
    e8be:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e8c2:	4029      	ands	r1, r5
    e8c4:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    e8c6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
    e8ca:	f7fe ffd1 	bl	d870 <HAL_I2C_MasterTxCpltCallback>
    e8ce:	e719      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    e8d0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    e8d4:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    e8d6:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    e8da:	2921      	cmp	r1, #33	; 0x21
    e8dc:	d0e0      	beq.n	e8a0 <I2C_Master_ISR_DMA+0x20c>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e8de:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    e8e0:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e8e4:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e8e6:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    e8e8:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e8ea:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e8ee:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e8f0:	f001 0128 	and.w	r1, r1, #40	; 0x28
    e8f4:	2928      	cmp	r1, #40	; 0x28
    e8f6:	bf14      	ite	ne
    e8f8:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    e8fc:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e900:	4029      	ands	r1, r5
    e902:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    e904:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    e908:	f7fe ffb4 	bl	d874 <HAL_I2C_MasterRxCpltCallback>
    e90c:	e6fa      	b.n	e704 <I2C_Master_ISR_DMA+0x70>
          xfermode = I2C_AUTOEND_MODE;
    e90e:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
    e912:	0415      	lsls	r5, r2, #16
    e914:	e7ab      	b.n	e86e <I2C_Master_ISR_DMA+0x1da>
  assert_param(IS_TRANSFER_MODE(Mode));
    e916:	f643 0068 	movw	r0, #14440	; 0x3868
    e91a:	f641 1132 	movw	r1, #6450	; 0x1932
    e91e:	f2c0 0003 	movt	r0, #3
    e922:	f00c fbc5 	bl	1b0b0 <assert_failed>
    e926:	6821      	ldr	r1, [r4, #0]
    e928:	e735      	b.n	e796 <I2C_Master_ISR_DMA+0x102>
    e92a:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e92e:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    e932:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    e936:	bf18      	it	ne
    e938:	f1b8 0f00 	cmpne.w	r8, #0
    e93c:	f6c5 0300 	movt	r3, #22528	; 0x5800
    e940:	bf14      	ite	ne
    e942:	f04f 0801 	movne.w	r8, #1
    e946:	f04f 0800 	moveq.w	r8, #0
    e94a:	4298      	cmp	r0, r3
    e94c:	f43f af1d 	beq.w	e78a <I2C_Master_ISR_DMA+0xf6>
    e950:	f44f 43b8 	mov.w	r3, #23552	; 0x5c00
    e954:	f2c4 0300 	movt	r3, #16384	; 0x4000
    e958:	4298      	cmp	r0, r3
    e95a:	d198      	bne.n	e88e <I2C_Master_ISR_DMA+0x1fa>
    e95c:	e715      	b.n	e78a <I2C_Master_ISR_DMA+0xf6>
    e95e:	bf00      	nop

0000e960 <I2C_DMAError>:
{
    e960:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    e964:	6b85      	ldr	r5, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
    e966:	6bac      	ldr	r4, [r5, #56]	; 0x38
    e968:	b124      	cbz	r4, e974 <I2C_DMAError+0x14>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
    e96a:	6822      	ldr	r2, [r4, #0]
    e96c:	6854      	ldr	r4, [r2, #4]
    e96e:	fab4 f484 	clz	r4, r4
    e972:	0964      	lsrs	r4, r4, #5
  if (hi2c->hdmarx != NULL)
    e974:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    e976:	2a00      	cmp	r2, #0
    e978:	d04c      	beq.n	ea14 <I2C_DMAError+0xb4>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
    e97a:	6812      	ldr	r2, [r2, #0]
    e97c:	6853      	ldr	r3, [r2, #4]
    e97e:	fab3 f383 	clz	r3, r3
    e982:	095b      	lsrs	r3, r3, #5
    e984:	2b00      	cmp	r3, #0
    e986:	d045      	beq.n	ea14 <I2C_DMAError+0xb4>
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
    e988:	f7fd f8e4 	bl	bb54 <HAL_DMA_GetError>
    e98c:	2802      	cmp	r0, #2
    e98e:	d03f      	beq.n	ea10 <I2C_DMAError+0xb0>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    e990:	6828      	ldr	r0, [r5, #0]
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e992:	2100      	movs	r1, #0
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    e994:	6843      	ldr	r3, [r0, #4]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    e996:	460a      	mov	r2, r1
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e998:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    e99c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    e9a0:	6043      	str	r3, [r0, #4]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    e9a2:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    e9a6:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    e9aa:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    e9ac:	62e9      	str	r1, [r5, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    e9ae:	856a      	strh	r2, [r5, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    e9b0:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    e9b2:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
    e9b4:	f042 0210 	orr.w	r2, r2, #16
    e9b8:	646a      	str	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    e9ba:	d933      	bls.n	ea24 <I2C_DMAError+0xc4>
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e9bc:	682a      	ldr	r2, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e9be:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    e9c2:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    e9c6:	6813      	ldr	r3, [r2, #0]
    e9c8:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    e9cc:	6013      	str	r3, [r2, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    e9ce:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e9d2:	2b60      	cmp	r3, #96	; 0x60
    e9d4:	d002      	beq.n	e9dc <I2C_DMAError+0x7c>
      hi2c->State         = HAL_I2C_STATE_READY;
    e9d6:	2320      	movs	r3, #32
    e9d8:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
    hi2c->XferISR       = NULL;
    e9dc:	2300      	movs	r3, #0
    e9de:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    e9e0:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    e9e2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    e9e4:	b118      	cbz	r0, e9ee <I2C_DMAError+0x8e>
    e9e6:	2b11      	cmp	r3, #17
    e9e8:	d039      	beq.n	ea5e <I2C_DMAError+0xfe>
    e9ea:	2b21      	cmp	r3, #33	; 0x21
    e9ec:	d037      	beq.n	ea5e <I2C_DMAError+0xfe>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    e9ee:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    e9f0:	b118      	cbz	r0, e9fa <I2C_DMAError+0x9a>
    e9f2:	2b12      	cmp	r3, #18
    e9f4:	d04e      	beq.n	ea94 <I2C_DMAError+0x134>
    e9f6:	2b22      	cmp	r3, #34	; 0x22
    e9f8:	d04c      	beq.n	ea94 <I2C_DMAError+0x134>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    e9fa:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    e9fe:	2b60      	cmp	r3, #96	; 0x60
    ea00:	d06e      	beq.n	eae0 <I2C_DMAError+0x180>
    hi2c->PreviousState = I2C_STATE_NONE;
    ea02:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    ea04:	4628      	mov	r0, r5
    hi2c->PreviousState = I2C_STATE_NONE;
    ea06:	632b      	str	r3, [r5, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    ea08:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    ea0c:	f7fe ffd0 	bl	d9b0 <HAL_I2C_ErrorCallback>
}
    ea10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
    ea14:	f7fd f89e 	bl	bb54 <HAL_DMA_GetError>
    ea18:	2802      	cmp	r0, #2
    ea1a:	d0f9      	beq.n	ea10 <I2C_DMAError+0xb0>
    ea1c:	07e0      	lsls	r0, r4, #31
    ea1e:	d4b7      	bmi.n	e990 <I2C_DMAError+0x30>
}
    ea20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea24:	f895 2041 	ldrb.w	r2, [r5, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    ea28:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea2a:	f895 0041 	ldrb.w	r0, [r5, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ea2e:	f64d 43fd 	movw	r3, #56573	; 0xdcfd
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea32:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ea34:	682c      	ldr	r4, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea36:	4030      	ands	r0, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ea38:	f2c0 0300 	movt	r3, #0
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea3c:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ea3e:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea40:	bf14      	ite	ne
    ea42:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
    ea46:	f06f 0146 	mvneq.w	r1, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ea4a:	42b0      	cmp	r0, r6
    ea4c:	bf18      	it	ne
    ea4e:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ea52:	400a      	ands	r2, r1
    ea54:	6022      	str	r2, [r4, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ea56:	636b      	str	r3, [r5, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    ea58:	f885 6041 	strb.w	r6, [r5, #65]	; 0x41
    ea5c:	e7c0      	b.n	e9e0 <I2C_DMAError+0x80>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    ea5e:	682b      	ldr	r3, [r5, #0]
    ea60:	681a      	ldr	r2, [r3, #0]
    ea62:	0451      	lsls	r1, r2, #17
    ea64:	d436      	bmi.n	ead4 <I2C_DMAError+0x174>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    ea66:	f7fd f871 	bl	bb4c <HAL_DMA_GetState>
    ea6a:	2801      	cmp	r0, #1
    ea6c:	d0c5      	beq.n	e9fa <I2C_DMAError+0x9a>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    ea6e:	f64d 13b9 	movw	r3, #55737	; 0xd9b9
    ea72:	6ba9      	ldr	r1, [r5, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    ea74:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    ea76:	f2c0 0300 	movt	r3, #0
    ea7a:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    ea7c:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    ea80:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    ea82:	f7fc fedb 	bl	b83c <HAL_DMA_Abort_IT>
    ea86:	2800      	cmp	r0, #0
    ea88:	d0c2      	beq.n	ea10 <I2C_DMAError+0xb0>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    ea8a:	6ba8      	ldr	r0, [r5, #56]	; 0x38
}
    ea8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    ea90:	6d03      	ldr	r3, [r0, #80]	; 0x50
    ea92:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    ea94:	682b      	ldr	r3, [r5, #0]
    ea96:	681a      	ldr	r2, [r3, #0]
    ea98:	0412      	lsls	r2, r2, #16
    ea9a:	d504      	bpl.n	eaa6 <I2C_DMAError+0x146>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    ea9c:	681a      	ldr	r2, [r3, #0]
    ea9e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    eaa2:	601a      	str	r2, [r3, #0]
    eaa4:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    eaa6:	f7fd f851 	bl	bb4c <HAL_DMA_GetState>
    eaaa:	2801      	cmp	r0, #1
    eaac:	d0a5      	beq.n	e9fa <I2C_DMAError+0x9a>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    eaae:	f64d 13b9 	movw	r3, #55737	; 0xd9b9
    eab2:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    eab4:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    eab6:	f2c0 0300 	movt	r3, #0
    eaba:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    eabc:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    eac0:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    eac2:	f7fc febb 	bl	b83c <HAL_DMA_Abort_IT>
    eac6:	2800      	cmp	r0, #0
    eac8:	d0a2      	beq.n	ea10 <I2C_DMAError+0xb0>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    eaca:	6be8      	ldr	r0, [r5, #60]	; 0x3c
}
    eacc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    ead0:	6d03      	ldr	r3, [r0, #80]	; 0x50
    ead2:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    ead4:	681a      	ldr	r2, [r3, #0]
    ead6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    eada:	601a      	str	r2, [r3, #0]
    eadc:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    eade:	e7c2      	b.n	ea66 <I2C_DMAError+0x106>
    hi2c->PreviousState = I2C_STATE_NONE;
    eae0:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    eae2:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    eae4:	4628      	mov	r0, r5
    hi2c->State = HAL_I2C_STATE_READY;
    eae6:	f885 2041 	strb.w	r2, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    eaea:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    eaee:	632b      	str	r3, [r5, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    eaf0:	f7fe ff60 	bl	d9b4 <HAL_I2C_AbortCpltCallback>
    eaf4:	e78c      	b.n	ea10 <I2C_DMAError+0xb0>
    eaf6:	bf00      	nop

0000eaf8 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
    eaf8:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    eafa:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
{
    eafe:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    eb00:	f44f 45b0 	mov.w	r5, #22528	; 0x5800
    eb04:	f44f 40b8 	mov.w	r0, #23552	; 0x5c00
    eb08:	f2c4 0300 	movt	r3, #16384	; 0x4000
    eb0c:	6822      	ldr	r2, [r4, #0]
    eb0e:	f2c4 0500 	movt	r5, #16384	; 0x4000
    eb12:	f2c4 0000 	movt	r0, #16384	; 0x4000
{
    eb16:	460e      	mov	r6, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    eb18:	429a      	cmp	r2, r3
    eb1a:	bf18      	it	ne
    eb1c:	42aa      	cmpne	r2, r5
    eb1e:	bf14      	ite	ne
    eb20:	2301      	movne	r3, #1
    eb22:	2300      	moveq	r3, #0
    eb24:	4282      	cmp	r2, r0
    eb26:	bf0c      	ite	eq
    eb28:	2300      	moveq	r3, #0
    eb2a:	f003 0301 	andne.w	r3, r3, #1
    eb2e:	b12b      	cbz	r3, eb3c <HAL_I2CEx_ConfigAnalogFilter+0x44>
    eb30:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    eb34:	f6c5 0300 	movt	r3, #22528	; 0x5800
    eb38:	429a      	cmp	r2, r3
    eb3a:	d135      	bne.n	eba8 <HAL_I2CEx_ConfigAnalogFilter+0xb0>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
    eb3c:	f436 5380 	bics.w	r3, r6, #4096	; 0x1000
    eb40:	d12a      	bne.n	eb98 <HAL_I2CEx_ConfigAnalogFilter+0xa0>

  if (hi2c->State == HAL_I2C_STATE_READY)
    eb42:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    eb46:	b2db      	uxtb	r3, r3
    eb48:	2b20      	cmp	r3, #32
    eb4a:	d123      	bne.n	eb94 <HAL_I2CEx_ConfigAnalogFilter+0x9c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    eb4c:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
    eb50:	2a01      	cmp	r2, #1
    eb52:	d01f      	beq.n	eb94 <HAL_I2CEx_ConfigAnalogFilter+0x9c>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    eb54:	6825      	ldr	r5, [r4, #0]
    __HAL_LOCK(hi2c);
    eb56:	2101      	movs	r1, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
    eb58:	2224      	movs	r2, #36	; 0x24
    __HAL_LOCK(hi2c);
    eb5a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    eb5e:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
    eb60:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
    eb64:	682a      	ldr	r2, [r5, #0]

    return HAL_OK;
    eb66:	4608      	mov	r0, r1
    __HAL_I2C_DISABLE(hi2c);
    eb68:	f022 0201 	bic.w	r2, r2, #1
    eb6c:	602a      	str	r2, [r5, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
    eb6e:	6825      	ldr	r5, [r4, #0]
    eb70:	682a      	ldr	r2, [r5, #0]
    eb72:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    eb76:	602a      	str	r2, [r5, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
    eb78:	6825      	ldr	r5, [r4, #0]
    eb7a:	682a      	ldr	r2, [r5, #0]
    eb7c:	4316      	orrs	r6, r2
    eb7e:	602e      	str	r6, [r5, #0]
    __HAL_I2C_ENABLE(hi2c);
    eb80:	6825      	ldr	r5, [r4, #0]
    eb82:	682a      	ldr	r2, [r5, #0]
    eb84:	f042 0201 	orr.w	r2, r2, #1
    eb88:	602a      	str	r2, [r5, #0]
    hi2c->State = HAL_I2C_STATE_READY;
    eb8a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    eb8e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
    eb92:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
    eb94:	2002      	movs	r0, #2
}
    eb96:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
    eb98:	f643 00a0 	movw	r0, #14496	; 0x38a0
    eb9c:	2165      	movs	r1, #101	; 0x65
    eb9e:	f2c0 0003 	movt	r0, #3
    eba2:	f00c fa85 	bl	1b0b0 <assert_failed>
    eba6:	e7cc      	b.n	eb42 <HAL_I2CEx_ConfigAnalogFilter+0x4a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    eba8:	f643 00a0 	movw	r0, #14496	; 0x38a0
    ebac:	2164      	movs	r1, #100	; 0x64
    ebae:	f2c0 0003 	movt	r0, #3
    ebb2:	f00c fa7d 	bl	1b0b0 <assert_failed>
    ebb6:	e7c1      	b.n	eb3c <HAL_I2CEx_ConfigAnalogFilter+0x44>

0000ebb8 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
    ebb8:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ebba:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
{
    ebbe:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ebc0:	f44f 45b0 	mov.w	r5, #22528	; 0x5800
    ebc4:	f44f 40b8 	mov.w	r0, #23552	; 0x5c00
    ebc8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    ebcc:	6822      	ldr	r2, [r4, #0]
    ebce:	f2c4 0500 	movt	r5, #16384	; 0x4000
    ebd2:	f2c4 0000 	movt	r0, #16384	; 0x4000
{
    ebd6:	460e      	mov	r6, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ebd8:	429a      	cmp	r2, r3
    ebda:	bf18      	it	ne
    ebdc:	42aa      	cmpne	r2, r5
    ebde:	bf14      	ite	ne
    ebe0:	2301      	movne	r3, #1
    ebe2:	2300      	moveq	r3, #0
    ebe4:	4282      	cmp	r2, r0
    ebe6:	bf0c      	ite	eq
    ebe8:	2300      	moveq	r3, #0
    ebea:	f003 0301 	andne.w	r3, r3, #1
    ebee:	b12b      	cbz	r3, ebfc <HAL_I2CEx_ConfigDigitalFilter+0x44>
    ebf0:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
    ebf4:	f6c5 0300 	movt	r3, #22528	; 0x5800
    ebf8:	429a      	cmp	r2, r3
    ebfa:	d132      	bne.n	ec62 <HAL_I2CEx_ConfigDigitalFilter+0xaa>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
    ebfc:	2e0f      	cmp	r6, #15
    ebfe:	d828      	bhi.n	ec52 <HAL_I2CEx_ConfigDigitalFilter+0x9a>

  if (hi2c->State == HAL_I2C_STATE_READY)
    ec00:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    ec04:	b2db      	uxtb	r3, r3
    ec06:	2b20      	cmp	r3, #32
    ec08:	d121      	bne.n	ec4e <HAL_I2CEx_ConfigDigitalFilter+0x96>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    ec0a:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
    ec0e:	2a01      	cmp	r2, #1
    ec10:	d01d      	beq.n	ec4e <HAL_I2CEx_ConfigDigitalFilter+0x96>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    ec12:	6821      	ldr	r1, [r4, #0]
    __HAL_LOCK(hi2c);
    ec14:	2001      	movs	r0, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
    ec16:	2224      	movs	r2, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    ec18:	2500      	movs	r5, #0
    __HAL_LOCK(hi2c);
    ec1a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_BUSY;
    ec1e:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41

    return HAL_OK;
    ec22:	4628      	mov	r0, r5
    __HAL_I2C_DISABLE(hi2c);
    ec24:	680a      	ldr	r2, [r1, #0]
    ec26:	f022 0201 	bic.w	r2, r2, #1
    ec2a:	600a      	str	r2, [r1, #0]
    tmpreg = hi2c->Instance->CR1;
    ec2c:	6822      	ldr	r2, [r4, #0]
    ec2e:	6811      	ldr	r1, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
    ec30:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
    tmpreg |= DigitalFilter << 8U;
    ec34:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
    hi2c->Instance->CR1 = tmpreg;
    ec38:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
    ec3a:	6821      	ldr	r1, [r4, #0]
    ec3c:	680a      	ldr	r2, [r1, #0]
    ec3e:	f042 0201 	orr.w	r2, r2, #1
    ec42:	600a      	str	r2, [r1, #0]
    hi2c->State = HAL_I2C_STATE_READY;
    ec44:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    ec48:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
    ec4c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
    ec4e:	2002      	movs	r0, #2
}
    ec50:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
    ec52:	f643 00a0 	movw	r0, #14496	; 0x38a0
    ec56:	2193      	movs	r1, #147	; 0x93
    ec58:	f2c0 0003 	movt	r0, #3
    ec5c:	f00c fa28 	bl	1b0b0 <assert_failed>
    ec60:	e7ce      	b.n	ec00 <HAL_I2CEx_ConfigDigitalFilter+0x48>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ec62:	f643 00a0 	movw	r0, #14496	; 0x38a0
    ec66:	2192      	movs	r1, #146	; 0x92
    ec68:	f2c0 0003 	movt	r0, #3
    ec6c:	f00c fa20 	bl	1b0b0 <assert_failed>
    ec70:	e7c4      	b.n	ebfc <HAL_I2CEx_ConfigDigitalFilter+0x44>
    ec72:	bf00      	nop

0000ec74 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
    ec74:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
    ec76:	1e43      	subs	r3, r0, #1
{
    ec78:	4604      	mov	r4, r0
  assert_param (IS_PWR_SUPPLY (SupplySource));
    ec7a:	2b01      	cmp	r3, #1
    ec7c:	d907      	bls.n	ec8e <HAL_PWREx_ConfigSupply+0x1a>
    ec7e:	f643 00dc 	movw	r0, #14556	; 0x38dc
    ec82:	f44f 719d 	mov.w	r1, #314	; 0x13a
    ec86:	f2c0 0003 	movt	r0, #3
    ec8a:	f00c fa11 	bl	1b0b0 <assert_failed>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
    ec8e:	f44f 4390 	mov.w	r3, #18432	; 0x4800
    ec92:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ec96:	68da      	ldr	r2, [r3, #12]
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
    ec98:	68d8      	ldr	r0, [r3, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
    ec9a:	0752      	lsls	r2, r2, #29
    ec9c:	d405      	bmi.n	ecaa <HAL_PWREx_ConfigSupply+0x36>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
    ec9e:	f000 0007 	and.w	r0, r0, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
    eca2:	1b00      	subs	r0, r0, r4
    eca4:	bf18      	it	ne
    eca6:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
    eca8:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
    ecaa:	f020 0007 	bic.w	r0, r0, #7
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    ecae:	461d      	mov	r5, r3
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
    ecb0:	4320      	orrs	r0, r4
    ecb2:	60d8      	str	r0, [r3, #12]
  tickstart = HAL_GetTick ();
    ecb4:	f7f9 fbc4 	bl	8440 <HAL_GetTick>
    ecb8:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    ecba:	e005      	b.n	ecc8 <HAL_PWREx_ConfigSupply+0x54>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
    ecbc:	f7f9 fbc0 	bl	8440 <HAL_GetTick>
    ecc0:	1b00      	subs	r0, r0, r4
    ecc2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
    ecc6:	d804      	bhi.n	ecd2 <HAL_PWREx_ConfigSupply+0x5e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    ecc8:	686b      	ldr	r3, [r5, #4]
    ecca:	049b      	lsls	r3, r3, #18
    eccc:	d5f6      	bpl.n	ecbc <HAL_PWREx_ConfigSupply+0x48>
  return HAL_OK;
    ecce:	2000      	movs	r0, #0
}
    ecd0:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
    ecd2:	2001      	movs	r0, #1
}
    ecd4:	bd38      	pop	{r3, r4, r5, pc}
    ecd6:	bf00      	nop

0000ecd8 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
    ecd8:	f44f 4390 	mov.w	r3, #18432	; 0x4800
    ecdc:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ece0:	68da      	ldr	r2, [r3, #12]
    ece2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    ece6:	60da      	str	r2, [r3, #12]
}
    ece8:	4770      	bx	lr
    ecea:	bf00      	nop

0000ecec <HAL_PWREx_DisableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
    ecec:	f44f 4390 	mov.w	r3, #18432	; 0x4800
    ecf0:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ecf4:	68da      	ldr	r2, [r3, #12]
    ecf6:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    ecfa:	60da      	str	r2, [r3, #12]
}
    ecfc:	4770      	bx	lr
    ecfe:	bf00      	nop

0000ed00 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
    ed00:	2800      	cmp	r0, #0
    ed02:	f000 8287 	beq.w	f214 <HAL_RCC_OscConfig+0x514>
{
    ed06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    ed08:	6803      	ldr	r3, [r0, #0]
    ed0a:	4604      	mov	r4, r0
    ed0c:	2b00      	cmp	r3, #0
    ed0e:	f000 80c1 	beq.w	ee94 <HAL_RCC_OscConfig+0x194>
    ed12:	0698      	lsls	r0, r3, #26
    ed14:	f000 8265 	beq.w	f1e2 <HAL_RCC_OscConfig+0x4e2>
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
    ed18:	07d9      	lsls	r1, r3, #31
    ed1a:	d53f      	bpl.n	ed9c <HAL_RCC_OscConfig+0x9c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    ed1c:	6863      	ldr	r3, [r4, #4]
    ed1e:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
    ed22:	d003      	beq.n	ed2c <HAL_RCC_OscConfig+0x2c>
    ed24:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
    ed28:	f040 8220 	bne.w	f16c <HAL_RCC_OscConfig+0x46c>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    ed2c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    ed30:	f6c5 0202 	movt	r2, #22530	; 0x5802
    ed34:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    ed36:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    ed38:	f003 0338 	and.w	r3, r3, #56	; 0x38
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
    ed3c:	2b10      	cmp	r3, #16
    ed3e:	f000 822d 	beq.w	f19c <HAL_RCC_OscConfig+0x49c>
    ed42:	2b18      	cmp	r3, #24
    ed44:	f000 8225 	beq.w	f192 <HAL_RCC_OscConfig+0x492>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    ed48:	6863      	ldr	r3, [r4, #4]
    ed4a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    ed4e:	f000 8233 	beq.w	f1b8 <HAL_RCC_OscConfig+0x4b8>
    ed52:	2b00      	cmp	r3, #0
    ed54:	f040 82c1 	bne.w	f2da <HAL_RCC_OscConfig+0x5da>
    ed58:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    ed5c:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ed60:	681a      	ldr	r2, [r3, #0]
    ed62:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    ed66:	601a      	str	r2, [r3, #0]
    ed68:	681a      	ldr	r2, [r3, #0]
    ed6a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
    ed6e:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
    ed70:	6863      	ldr	r3, [r4, #4]
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ed72:	f44f 4588 	mov.w	r5, #17408	; 0x4400
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
    ed76:	2b00      	cmp	r3, #0
    ed78:	f000 823d 	beq.w	f1f6 <HAL_RCC_OscConfig+0x4f6>
        tickstart = HAL_GetTick();
    ed7c:	f7f9 fb60 	bl	8440 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ed80:	f6c5 0502 	movt	r5, #22530	; 0x5802
        tickstart = HAL_GetTick();
    ed84:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ed86:	e005      	b.n	ed94 <HAL_RCC_OscConfig+0x94>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    ed88:	f7f9 fb5a 	bl	8440 <HAL_GetTick>
    ed8c:	1b80      	subs	r0, r0, r6
    ed8e:	2864      	cmp	r0, #100	; 0x64
    ed90:	f200 8225 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ed94:	682b      	ldr	r3, [r5, #0]
    ed96:	039b      	lsls	r3, r3, #14
    ed98:	d5f6      	bpl.n	ed88 <HAL_RCC_OscConfig+0x88>
    ed9a:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
    ed9c:	0798      	lsls	r0, r3, #30
    ed9e:	d537      	bpl.n	ee10 <HAL_RCC_OscConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    eda0:	68e2      	ldr	r2, [r4, #12]
    eda2:	2a19      	cmp	r2, #25
    eda4:	f200 82e5 	bhi.w	f372 <HAL_RCC_OscConfig+0x672>
    eda8:	f240 2303 	movw	r3, #515	; 0x203
    edac:	f2c0 2302 	movt	r3, #514	; 0x202
    edb0:	40d3      	lsrs	r3, r2
    edb2:	07d9      	lsls	r1, r3, #31
    edb4:	f140 82dd 	bpl.w	f372 <HAL_RCC_OscConfig+0x672>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    edb8:	6923      	ldr	r3, [r4, #16]
    edba:	2b7f      	cmp	r3, #127	; 0x7f
    edbc:	f200 81cd 	bhi.w	f15a <HAL_RCC_OscConfig+0x45a>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    edc0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    edc4:	f6c5 0202 	movt	r2, #22530	; 0x5802
    edc8:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    edca:	6a92      	ldr	r2, [r2, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    edcc:	f013 0338 	ands.w	r3, r3, #56	; 0x38
    edd0:	f040 8196 	bne.w	f100 <HAL_RCC_OscConfig+0x400>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
    edd4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    edd8:	f6c5 0302 	movt	r3, #22530	; 0x5802
    eddc:	681b      	ldr	r3, [r3, #0]
    edde:	075b      	lsls	r3, r3, #29
    ede0:	d503      	bpl.n	edea <HAL_RCC_OscConfig+0xea>
    ede2:	68e3      	ldr	r3, [r4, #12]
    ede4:	2b00      	cmp	r3, #0
    ede6:	f000 81e5 	beq.w	f1b4 <HAL_RCC_OscConfig+0x4b4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    edea:	f7f9 fb43 	bl	8474 <HAL_GetREVID>
    edee:	f241 0303 	movw	r3, #4099	; 0x1003
    edf2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    edf6:	6921      	ldr	r1, [r4, #16]
    edf8:	4298      	cmp	r0, r3
    edfa:	f6c5 0202 	movt	r2, #22530	; 0x5802
    edfe:	6853      	ldr	r3, [r2, #4]
    ee00:	f200 82ac 	bhi.w	f35c <HAL_RCC_OscConfig+0x65c>
    ee04:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    ee08:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    ee0c:	6053      	str	r3, [r2, #4]
    ee0e:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
    ee10:	06d9      	lsls	r1, r3, #27
    ee12:	d53f      	bpl.n	ee94 <HAL_RCC_OscConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    ee14:	69e3      	ldr	r3, [r4, #28]
    ee16:	f033 0380 	bics.w	r3, r3, #128	; 0x80
    ee1a:	f040 823f 	bne.w	f29c <HAL_RCC_OscConfig+0x59c>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    ee1e:	6a23      	ldr	r3, [r4, #32]
    ee20:	2b3f      	cmp	r3, #63	; 0x3f
    ee22:	f200 8232 	bhi.w	f28a <HAL_RCC_OscConfig+0x58a>

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    ee26:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    ee2a:	f6c5 0202 	movt	r2, #22530	; 0x5802
    ee2e:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    ee30:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    ee32:	f003 0338 	and.w	r3, r3, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
    ee36:	2b08      	cmp	r3, #8
    ee38:	f000 81f3 	beq.w	f222 <HAL_RCC_OscConfig+0x522>
    ee3c:	2b18      	cmp	r3, #24
    ee3e:	f000 81eb 	beq.w	f218 <HAL_RCC_OscConfig+0x518>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
    ee42:	69e3      	ldr	r3, [r4, #28]
    ee44:	2b00      	cmp	r3, #0
    ee46:	f000 8259 	beq.w	f2fc <HAL_RCC_OscConfig+0x5fc>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
    ee4a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    ee4e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ee52:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    ee54:	461d      	mov	r5, r3
        __HAL_RCC_CSI_ENABLE();
    ee56:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    ee5a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    ee5c:	f7f9 faf0 	bl	8440 <HAL_GetTick>
    ee60:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    ee62:	e005      	b.n	ee70 <HAL_RCC_OscConfig+0x170>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    ee64:	f7f9 faec 	bl	8440 <HAL_GetTick>
    ee68:	1b80      	subs	r0, r0, r6
    ee6a:	2802      	cmp	r0, #2
    ee6c:	f200 81b7 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    ee70:	682b      	ldr	r3, [r5, #0]
    ee72:	05db      	lsls	r3, r3, #23
    ee74:	d5f6      	bpl.n	ee64 <HAL_RCC_OscConfig+0x164>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    ee76:	f7f9 fafd 	bl	8474 <HAL_GetREVID>
    ee7a:	f241 0303 	movw	r3, #4099	; 0x1003
    ee7e:	4298      	cmp	r0, r3
    ee80:	f200 8307 	bhi.w	f492 <HAL_RCC_OscConfig+0x792>
    ee84:	686b      	ldr	r3, [r5, #4]
    ee86:	6a22      	ldr	r2, [r4, #32]
    ee88:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
    ee8c:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
    ee90:	606b      	str	r3, [r5, #4]
    ee92:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
    ee94:	071d      	lsls	r5, r3, #28
    ee96:	d51d      	bpl.n	eed4 <HAL_RCC_OscConfig+0x1d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    ee98:	6963      	ldr	r3, [r4, #20]
    ee9a:	2b01      	cmp	r3, #1
    ee9c:	f200 816f 	bhi.w	f17e <HAL_RCC_OscConfig+0x47e>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
    eea0:	2b00      	cmp	r3, #0
    eea2:	f000 81dc 	beq.w	f25e <HAL_RCC_OscConfig+0x55e>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
    eea6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    eeaa:	f6c5 0302 	movt	r3, #22530	; 0x5802
    eeae:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    eeb0:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
    eeb2:	f042 0201 	orr.w	r2, r2, #1
    eeb6:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
    eeb8:	f7f9 fac2 	bl	8440 <HAL_GetTick>
    eebc:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    eebe:	e005      	b.n	eecc <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    eec0:	f7f9 fabe 	bl	8440 <HAL_GetTick>
    eec4:	1b80      	subs	r0, r0, r6
    eec6:	2802      	cmp	r0, #2
    eec8:	f200 8189 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    eecc:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    eece:	0798      	lsls	r0, r3, #30
    eed0:	d5f6      	bpl.n	eec0 <HAL_RCC_OscConfig+0x1c0>
    eed2:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
    eed4:	069a      	lsls	r2, r3, #26
    eed6:	d51d      	bpl.n	ef14 <HAL_RCC_OscConfig+0x214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    eed8:	69a3      	ldr	r3, [r4, #24]
    eeda:	2b01      	cmp	r3, #1
    eedc:	f200 8175 	bhi.w	f1ca <HAL_RCC_OscConfig+0x4ca>

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
    eee0:	2b00      	cmp	r3, #0
    eee2:	f000 81e4 	beq.w	f2ae <HAL_RCC_OscConfig+0x5ae>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
    eee6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    eeea:	f6c5 0302 	movt	r3, #22530	; 0x5802
    eeee:	681a      	ldr	r2, [r3, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    eef0:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_ENABLE();
    eef2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    eef6:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
    eef8:	f7f9 faa2 	bl	8440 <HAL_GetTick>
    eefc:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    eefe:	e005      	b.n	ef0c <HAL_RCC_OscConfig+0x20c>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    ef00:	f7f9 fa9e 	bl	8440 <HAL_GetTick>
    ef04:	1b80      	subs	r0, r0, r6
    ef06:	2802      	cmp	r0, #2
    ef08:	f200 8169 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    ef0c:	682b      	ldr	r3, [r5, #0]
    ef0e:	049f      	lsls	r7, r3, #18
    ef10:	d5f6      	bpl.n	ef00 <HAL_RCC_OscConfig+0x200>
    ef12:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
    ef14:	0759      	lsls	r1, r3, #29
    ef16:	d545      	bpl.n	efa4 <HAL_RCC_OscConfig+0x2a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    ef18:	68a3      	ldr	r3, [r4, #8]
    ef1a:	2b01      	cmp	r3, #1
    ef1c:	d902      	bls.n	ef24 <HAL_RCC_OscConfig+0x224>
    ef1e:	2b05      	cmp	r3, #5
    ef20:	f040 823a 	bne.w	f398 <HAL_RCC_OscConfig+0x698>

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
    ef24:	f44f 4390 	mov.w	r3, #18432	; 0x4800
    ef28:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ef2c:	681a      	ldr	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    ef2e:	461d      	mov	r5, r3
    PWR->CR1 |= PWR_CR1_DBP;
    ef30:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    ef34:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    ef36:	f7f9 fa83 	bl	8440 <HAL_GetTick>
    ef3a:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    ef3c:	e005      	b.n	ef4a <HAL_RCC_OscConfig+0x24a>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
    ef3e:	f7f9 fa7f 	bl	8440 <HAL_GetTick>
    ef42:	1b80      	subs	r0, r0, r6
    ef44:	2864      	cmp	r0, #100	; 0x64
    ef46:	f200 814a 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    ef4a:	682b      	ldr	r3, [r5, #0]
    ef4c:	05da      	lsls	r2, r3, #23
    ef4e:	d5f6      	bpl.n	ef3e <HAL_RCC_OscConfig+0x23e>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    ef50:	68a3      	ldr	r3, [r4, #8]
    ef52:	2b01      	cmp	r3, #1
    ef54:	f000 825f 	beq.w	f416 <HAL_RCC_OscConfig+0x716>
    ef58:	2b00      	cmp	r3, #0
    ef5a:	f040 828a 	bne.w	f472 <HAL_RCC_OscConfig+0x772>
    ef5e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    ef62:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ef66:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    ef68:	f022 0201 	bic.w	r2, r2, #1
    ef6c:	671a      	str	r2, [r3, #112]	; 0x70
    ef6e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    ef70:	f022 0204 	bic.w	r2, r2, #4
    ef74:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    ef76:	68a3      	ldr	r3, [r4, #8]
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    ef78:	f44f 4588 	mov.w	r5, #17408	; 0x4400
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    ef7c:	2b00      	cmp	r3, #0
    ef7e:	f000 8253 	beq.w	f428 <HAL_RCC_OscConfig+0x728>
      tickstart = HAL_GetTick();
    ef82:	f7f9 fa5d 	bl	8440 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    ef86:	f6c5 0502 	movt	r5, #22530	; 0x5802
      tickstart = HAL_GetTick();
    ef8a:	4607      	mov	r7, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    ef8c:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    ef90:	e005      	b.n	ef9e <HAL_RCC_OscConfig+0x29e>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    ef92:	f7f9 fa55 	bl	8440 <HAL_GetTick>
    ef96:	1bc0      	subs	r0, r0, r7
    ef98:	42b0      	cmp	r0, r6
    ef9a:	f200 8120 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    ef9e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    efa0:	079b      	lsls	r3, r3, #30
    efa2:	d5f6      	bpl.n	ef92 <HAL_RCC_OscConfig+0x292>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    efa4:	6a60      	ldr	r0, [r4, #36]	; 0x24
    efa6:	2802      	cmp	r0, #2
    efa8:	f200 81ec 	bhi.w	f384 <HAL_RCC_OscConfig+0x684>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
    efac:	2800      	cmp	r0, #0
    efae:	f000 80a5 	beq.w	f0fc <HAL_RCC_OscConfig+0x3fc>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
    efb2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    efb6:	f6c5 0302 	movt	r3, #22530	; 0x5802
    efba:	691a      	ldr	r2, [r3, #16]
    efbc:	f002 0238 	and.w	r2, r2, #56	; 0x38
    efc0:	2a18      	cmp	r2, #24
    efc2:	f000 81fa 	beq.w	f3ba <HAL_RCC_OscConfig+0x6ba>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
    efc6:	2802      	cmp	r0, #2
    efc8:	f040 8240 	bne.w	f44c <HAL_RCC_OscConfig+0x74c>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    efcc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    efce:	2b03      	cmp	r3, #3
    efd0:	f200 82a5 	bhi.w	f51e <HAL_RCC_OscConfig+0x81e>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    efd4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    efd6:	3b01      	subs	r3, #1
    efd8:	2b3e      	cmp	r3, #62	; 0x3e
    efda:	f200 8273 	bhi.w	f4c4 <HAL_RCC_OscConfig+0x7c4>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    efde:	6b23      	ldr	r3, [r4, #48]	; 0x30
    efe0:	3b04      	subs	r3, #4
    efe2:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    efe6:	f200 8264 	bhi.w	f4b2 <HAL_RCC_OscConfig+0x7b2>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    efea:	6b63      	ldr	r3, [r4, #52]	; 0x34
    efec:	3b01      	subs	r3, #1
    efee:	2b7f      	cmp	r3, #127	; 0x7f
    eff0:	f200 828c 	bhi.w	f50c <HAL_RCC_OscConfig+0x80c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    eff4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    eff6:	3b01      	subs	r3, #1
    eff8:	2b7f      	cmp	r3, #127	; 0x7f
    effa:	f200 827e 	bhi.w	f4fa <HAL_RCC_OscConfig+0x7fa>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    effe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    f000:	3b01      	subs	r3, #1
    f002:	2b7f      	cmp	r3, #127	; 0x7f
    f004:	f200 8270 	bhi.w	f4e8 <HAL_RCC_OscConfig+0x7e8>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    f008:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    f00a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    f00e:	f080 8262 	bcs.w	f4d6 <HAL_RCC_OscConfig+0x7d6>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
    f012:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f016:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f01a:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    f01c:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
    f01e:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    f022:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    f024:	f7f9 fa0c 	bl	8440 <HAL_GetTick>
    f028:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    f02a:	e005      	b.n	f038 <HAL_RCC_OscConfig+0x338>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    f02c:	f7f9 fa08 	bl	8440 <HAL_GetTick>
    f030:	1b80      	subs	r0, r0, r6
    f032:	2802      	cmp	r0, #2
    f034:	f200 80d3 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    f038:	682b      	ldr	r3, [r5, #0]
    f03a:	0199      	lsls	r1, r3, #6
    f03c:	d4f6      	bmi.n	f02c <HAL_RCC_OscConfig+0x32c>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    f03e:	f64f 430c 	movw	r3, #64524	; 0xfc0c
    f042:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    f044:	6aa0      	ldr	r0, [r4, #40]	; 0x28

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    f046:	2207      	movs	r2, #7
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    f048:	f6cf 73ff 	movt	r3, #65535	; 0xffff

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    f04c:	f44f 4688 	mov.w	r6, #17408	; 0x4400
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    f050:	f6cf 72ff 	movt	r2, #65535	; 0xffff
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    f054:	400b      	ands	r3, r1
    f056:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    f058:	f6c5 0602 	movt	r6, #22530	; 0x5802
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    f05c:	4303      	orrs	r3, r0
    f05e:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
    f062:	62ab      	str	r3, [r5, #40]	; 0x28
    f064:	6b27      	ldr	r7, [r4, #48]	; 0x30
    f066:	e9d4 310d 	ldrd	r3, r1, [r4, #52]	; 0x34
    f06a:	3f01      	subs	r7, #1
    f06c:	1e48      	subs	r0, r1, #1
    f06e:	3b01      	subs	r3, #1
    f070:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    f072:	f3c7 0708 	ubfx	r7, r7, #0, #9
    f076:	025b      	lsls	r3, r3, #9
    f078:	0400      	lsls	r0, r0, #16
    f07a:	3901      	subs	r1, #1
    f07c:	b29b      	uxth	r3, r3
    f07e:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    f082:	0609      	lsls	r1, r1, #24
    f084:	4303      	orrs	r3, r0
    f086:	f001 41fe 	and.w	r1, r1, #2130706432	; 0x7f000000
    f08a:	433b      	orrs	r3, r7
    f08c:	430b      	orrs	r3, r1
    f08e:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
    f090:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f092:	f023 0301 	bic.w	r3, r3, #1
    f096:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    f098:	6b69      	ldr	r1, [r5, #52]	; 0x34
    f09a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    f09c:	400a      	ands	r2, r1
    f09e:	ea42 02c3 	orr.w	r2, r2, r3, lsl #3
    f0a2:	636a      	str	r2, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
    f0a4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f0a6:	6c22      	ldr	r2, [r4, #64]	; 0x40
    f0a8:	f023 030c 	bic.w	r3, r3, #12
    f0ac:	4313      	orrs	r3, r2
    f0ae:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
    f0b0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f0b2:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f0b4:	f023 0302 	bic.w	r3, r3, #2
    f0b8:	4313      	orrs	r3, r2
    f0ba:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
    f0bc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f0be:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    f0c2:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    f0c4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f0c6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    f0ca:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
    f0cc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f0ce:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    f0d2:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
    f0d4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f0d6:	f043 0301 	orr.w	r3, r3, #1
    f0da:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
    f0dc:	682b      	ldr	r3, [r5, #0]
    f0de:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    f0e2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
    f0e4:	f7f9 f9ac 	bl	8440 <HAL_GetTick>
    f0e8:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    f0ea:	e004      	b.n	f0f6 <HAL_RCC_OscConfig+0x3f6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    f0ec:	f7f9 f9a8 	bl	8440 <HAL_GetTick>
    f0f0:	1b00      	subs	r0, r0, r4
    f0f2:	2802      	cmp	r0, #2
    f0f4:	d873      	bhi.n	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    f0f6:	6833      	ldr	r3, [r6, #0]
    f0f8:	019a      	lsls	r2, r3, #6
    f0fa:	d5f7      	bpl.n	f0ec <HAL_RCC_OscConfig+0x3ec>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
    f0fc:	2000      	movs	r0, #0
}
    f0fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    f100:	2b18      	cmp	r3, #24
    f102:	f000 8132 	beq.w	f36a <HAL_RCC_OscConfig+0x66a>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
    f106:	68e2      	ldr	r2, [r4, #12]
    f108:	2a00      	cmp	r2, #0
    f10a:	f000 810f 	beq.w	f32c <HAL_RCC_OscConfig+0x62c>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    f10e:	f44f 4188 	mov.w	r1, #17408	; 0x4400
    f112:	f6c5 0102 	movt	r1, #22530	; 0x5802
    f116:	680b      	ldr	r3, [r1, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    f118:	460d      	mov	r5, r1
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    f11a:	f023 0319 	bic.w	r3, r3, #25
    f11e:	4313      	orrs	r3, r2
    f120:	600b      	str	r3, [r1, #0]
        tickstart = HAL_GetTick();
    f122:	f7f9 f98d 	bl	8440 <HAL_GetTick>
    f126:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    f128:	e004      	b.n	f134 <HAL_RCC_OscConfig+0x434>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    f12a:	f7f9 f989 	bl	8440 <HAL_GetTick>
    f12e:	1b80      	subs	r0, r0, r6
    f130:	2802      	cmp	r0, #2
    f132:	d854      	bhi.n	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    f134:	682b      	ldr	r3, [r5, #0]
    f136:	075f      	lsls	r7, r3, #29
    f138:	d5f7      	bpl.n	f12a <HAL_RCC_OscConfig+0x42a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    f13a:	f7f9 f99b 	bl	8474 <HAL_GetREVID>
    f13e:	f241 0303 	movw	r3, #4099	; 0x1003
    f142:	6922      	ldr	r2, [r4, #16]
    f144:	4298      	cmp	r0, r3
    f146:	686b      	ldr	r3, [r5, #4]
    f148:	f200 81ac 	bhi.w	f4a4 <HAL_RCC_OscConfig+0x7a4>
    f14c:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    f150:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    f154:	606b      	str	r3, [r5, #4]
    f156:	6823      	ldr	r3, [r4, #0]
    f158:	e65a      	b.n	ee10 <HAL_RCC_OscConfig+0x110>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    f15a:	f643 1018 	movw	r0, #14616	; 0x3918
    f15e:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
    f162:	f2c0 0003 	movt	r0, #3
    f166:	f00b ffa3 	bl	1b0b0 <assert_failed>
    f16a:	e629      	b.n	edc0 <HAL_RCC_OscConfig+0xc0>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    f16c:	f643 1018 	movw	r0, #14616	; 0x3918
    f170:	f240 11a3 	movw	r1, #419	; 0x1a3
    f174:	f2c0 0003 	movt	r0, #3
    f178:	f00b ff9a 	bl	1b0b0 <assert_failed>
    f17c:	e5d6      	b.n	ed2c <HAL_RCC_OscConfig+0x2c>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    f17e:	f643 1018 	movw	r0, #14616	; 0x3918
    f182:	f44f 7117 	mov.w	r1, #604	; 0x25c
    f186:	f2c0 0003 	movt	r0, #3
    f18a:	f00b ff91 	bl	1b0b0 <assert_failed>
    f18e:	6963      	ldr	r3, [r4, #20]
    f190:	e686      	b.n	eea0 <HAL_RCC_OscConfig+0x1a0>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
    f192:	f002 0203 	and.w	r2, r2, #3
    f196:	2a02      	cmp	r2, #2
    f198:	f47f add6 	bne.w	ed48 <HAL_RCC_OscConfig+0x48>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
    f19c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f1a0:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f1a4:	681b      	ldr	r3, [r3, #0]
    f1a6:	039a      	lsls	r2, r3, #14
    f1a8:	f57f adf7 	bpl.w	ed9a <HAL_RCC_OscConfig+0x9a>
    f1ac:	6863      	ldr	r3, [r4, #4]
    f1ae:	2b00      	cmp	r3, #0
    f1b0:	f47f adf3 	bne.w	ed9a <HAL_RCC_OscConfig+0x9a>
        return HAL_ERROR;
    f1b4:	2001      	movs	r0, #1
}
    f1b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    f1b8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f1bc:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f1c0:	681a      	ldr	r2, [r3, #0]
    f1c2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    f1c6:	601a      	str	r2, [r3, #0]
    f1c8:	e5d2      	b.n	ed70 <HAL_RCC_OscConfig+0x70>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    f1ca:	f643 1018 	movw	r0, #14616	; 0x3918
    f1ce:	f240 2187 	movw	r1, #647	; 0x287
    f1d2:	f2c0 0003 	movt	r0, #3
    f1d6:	f00b ff6b 	bl	1b0b0 <assert_failed>
    f1da:	69a3      	ldr	r3, [r4, #24]
    f1dc:	e680      	b.n	eee0 <HAL_RCC_OscConfig+0x1e0>
            return HAL_TIMEOUT;
    f1de:	2003      	movs	r0, #3
}
    f1e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    f1e2:	f643 1018 	movw	r0, #14616	; 0x3918
    f1e6:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    f1ea:	f2c0 0003 	movt	r0, #3
    f1ee:	f00b ff5f 	bl	1b0b0 <assert_failed>
    f1f2:	6823      	ldr	r3, [r4, #0]
    f1f4:	e590      	b.n	ed18 <HAL_RCC_OscConfig+0x18>
        tickstart = HAL_GetTick();
    f1f6:	f7f9 f923 	bl	8440 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    f1fa:	f6c5 0502 	movt	r5, #22530	; 0x5802
        tickstart = HAL_GetTick();
    f1fe:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    f200:	e004      	b.n	f20c <HAL_RCC_OscConfig+0x50c>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    f202:	f7f9 f91d 	bl	8440 <HAL_GetTick>
    f206:	1b80      	subs	r0, r0, r6
    f208:	2864      	cmp	r0, #100	; 0x64
    f20a:	d8e8      	bhi.n	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    f20c:	682b      	ldr	r3, [r5, #0]
    f20e:	039f      	lsls	r7, r3, #14
    f210:	d4f7      	bmi.n	f202 <HAL_RCC_OscConfig+0x502>
    f212:	e5c2      	b.n	ed9a <HAL_RCC_OscConfig+0x9a>
    return HAL_ERROR;
    f214:	2001      	movs	r0, #1
}
    f216:	4770      	bx	lr
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
    f218:	f002 0203 	and.w	r2, r2, #3
    f21c:	2a01      	cmp	r2, #1
    f21e:	f47f ae10 	bne.w	ee42 <HAL_RCC_OscConfig+0x142>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
    f222:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f226:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f22a:	681b      	ldr	r3, [r3, #0]
    f22c:	05da      	lsls	r2, r3, #23
    f22e:	d502      	bpl.n	f236 <HAL_RCC_OscConfig+0x536>
    f230:	69e3      	ldr	r3, [r4, #28]
    f232:	2b80      	cmp	r3, #128	; 0x80
    f234:	d1be      	bne.n	f1b4 <HAL_RCC_OscConfig+0x4b4>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    f236:	f7f9 f91d 	bl	8474 <HAL_GetREVID>
    f23a:	f241 0303 	movw	r3, #4099	; 0x1003
    f23e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f242:	6a21      	ldr	r1, [r4, #32]
    f244:	4298      	cmp	r0, r3
    f246:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f24a:	f200 80ae 	bhi.w	f3aa <HAL_RCC_OscConfig+0x6aa>
    f24e:	6853      	ldr	r3, [r2, #4]
    f250:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
    f254:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
    f258:	6053      	str	r3, [r2, #4]
    f25a:	6823      	ldr	r3, [r4, #0]
    f25c:	e61a      	b.n	ee94 <HAL_RCC_OscConfig+0x194>
      __HAL_RCC_LSI_DISABLE();
    f25e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f262:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f266:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    f268:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
    f26a:	f022 0201 	bic.w	r2, r2, #1
    f26e:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
    f270:	f7f9 f8e6 	bl	8440 <HAL_GetTick>
    f274:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    f276:	e004      	b.n	f282 <HAL_RCC_OscConfig+0x582>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    f278:	f7f9 f8e2 	bl	8440 <HAL_GetTick>
    f27c:	1b80      	subs	r0, r0, r6
    f27e:	2802      	cmp	r0, #2
    f280:	d8ad      	bhi.n	f1de <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    f282:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    f284:	0799      	lsls	r1, r3, #30
    f286:	d4f7      	bmi.n	f278 <HAL_RCC_OscConfig+0x578>
    f288:	e623      	b.n	eed2 <HAL_RCC_OscConfig+0x1d2>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    f28a:	f643 1018 	movw	r0, #14616	; 0x3918
    f28e:	f240 211b 	movw	r1, #539	; 0x21b
    f292:	f2c0 0003 	movt	r0, #3
    f296:	f00b ff0b 	bl	1b0b0 <assert_failed>
    f29a:	e5c4      	b.n	ee26 <HAL_RCC_OscConfig+0x126>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    f29c:	f643 1018 	movw	r0, #14616	; 0x3918
    f2a0:	f240 211a 	movw	r1, #538	; 0x21a
    f2a4:	f2c0 0003 	movt	r0, #3
    f2a8:	f00b ff02 	bl	1b0b0 <assert_failed>
    f2ac:	e5b7      	b.n	ee1e <HAL_RCC_OscConfig+0x11e>
      __HAL_RCC_HSI48_DISABLE();
    f2ae:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f2b2:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f2b6:	681a      	ldr	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    f2b8:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_DISABLE();
    f2ba:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    f2be:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
    f2c0:	f7f9 f8be 	bl	8440 <HAL_GetTick>
    f2c4:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    f2c6:	e004      	b.n	f2d2 <HAL_RCC_OscConfig+0x5d2>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    f2c8:	f7f9 f8ba 	bl	8440 <HAL_GetTick>
    f2cc:	1b80      	subs	r0, r0, r6
    f2ce:	2802      	cmp	r0, #2
    f2d0:	d885      	bhi.n	f1de <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    f2d2:	682b      	ldr	r3, [r5, #0]
    f2d4:	0498      	lsls	r0, r3, #18
    f2d6:	d4f7      	bmi.n	f2c8 <HAL_RCC_OscConfig+0x5c8>
    f2d8:	e61b      	b.n	ef12 <HAL_RCC_OscConfig+0x212>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    f2da:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
    f2de:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f2e2:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f2e6:	681a      	ldr	r2, [r3, #0]
    f2e8:	f47f ad3b 	bne.w	ed62 <HAL_RCC_OscConfig+0x62>
    f2ec:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
    f2f0:	601a      	str	r2, [r3, #0]
    f2f2:	681a      	ldr	r2, [r3, #0]
    f2f4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    f2f8:	601a      	str	r2, [r3, #0]
    f2fa:	e539      	b.n	ed70 <HAL_RCC_OscConfig+0x70>
        __HAL_RCC_CSI_DISABLE();
    f2fc:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f300:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f304:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    f306:	461d      	mov	r5, r3
        __HAL_RCC_CSI_DISABLE();
    f308:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    f30c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    f30e:	f7f9 f897 	bl	8440 <HAL_GetTick>
    f312:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    f314:	e005      	b.n	f322 <HAL_RCC_OscConfig+0x622>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    f316:	f7f9 f893 	bl	8440 <HAL_GetTick>
    f31a:	1b80      	subs	r0, r0, r6
    f31c:	2802      	cmp	r0, #2
    f31e:	f63f af5e 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    f322:	682b      	ldr	r3, [r5, #0]
    f324:	05df      	lsls	r7, r3, #23
    f326:	d4f6      	bmi.n	f316 <HAL_RCC_OscConfig+0x616>
    f328:	6823      	ldr	r3, [r4, #0]
    f32a:	e5b3      	b.n	ee94 <HAL_RCC_OscConfig+0x194>
        __HAL_RCC_HSI_DISABLE();
    f32c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f330:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f334:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    f336:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
    f338:	f022 0201 	bic.w	r2, r2, #1
    f33c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    f33e:	f7f9 f87f 	bl	8440 <HAL_GetTick>
    f342:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    f344:	e005      	b.n	f352 <HAL_RCC_OscConfig+0x652>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    f346:	f7f9 f87b 	bl	8440 <HAL_GetTick>
    f34a:	1b80      	subs	r0, r0, r6
    f34c:	2802      	cmp	r0, #2
    f34e:	f63f af46 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    f352:	682b      	ldr	r3, [r5, #0]
    f354:	0758      	lsls	r0, r3, #29
    f356:	d4f6      	bmi.n	f346 <HAL_RCC_OscConfig+0x646>
    f358:	6823      	ldr	r3, [r4, #0]
    f35a:	e559      	b.n	ee10 <HAL_RCC_OscConfig+0x110>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    f35c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    f360:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    f364:	6053      	str	r3, [r2, #4]
    f366:	6823      	ldr	r3, [r4, #0]
    f368:	e552      	b.n	ee10 <HAL_RCC_OscConfig+0x110>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    f36a:	0792      	lsls	r2, r2, #30
    f36c:	f47f aecb 	bne.w	f106 <HAL_RCC_OscConfig+0x406>
    f370:	e530      	b.n	edd4 <HAL_RCC_OscConfig+0xd4>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    f372:	f643 1018 	movw	r0, #14616	; 0x3918
    f376:	f240 11d7 	movw	r1, #471	; 0x1d7
    f37a:	f2c0 0003 	movt	r0, #3
    f37e:	f00b fe97 	bl	1b0b0 <assert_failed>
    f382:	e519      	b.n	edb8 <HAL_RCC_OscConfig+0xb8>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    f384:	f643 1018 	movw	r0, #14616	; 0x3918
    f388:	f240 21e3 	movw	r1, #739	; 0x2e3
    f38c:	f2c0 0003 	movt	r0, #3
    f390:	f00b fe8e 	bl	1b0b0 <assert_failed>
    f394:	6a60      	ldr	r0, [r4, #36]	; 0x24
    f396:	e609      	b.n	efac <HAL_RCC_OscConfig+0x2ac>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    f398:	f643 1018 	movw	r0, #14616	; 0x3918
    f39c:	f240 21b1 	movw	r1, #689	; 0x2b1
    f3a0:	f2c0 0003 	movt	r0, #3
    f3a4:	f00b fe84 	bl	1b0b0 <assert_failed>
    f3a8:	e5bc      	b.n	ef24 <HAL_RCC_OscConfig+0x224>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    f3aa:	68d3      	ldr	r3, [r2, #12]
    f3ac:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
    f3b0:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    f3b4:	60d3      	str	r3, [r2, #12]
    f3b6:	6823      	ldr	r3, [r4, #0]
    f3b8:	e56c      	b.n	ee94 <HAL_RCC_OscConfig+0x194>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    f3ba:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
    f3bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
    f3be:	6b1d      	ldr	r5, [r3, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    f3c0:	f43f ae9d 	beq.w	f0fe <HAL_RCC_OscConfig+0x3fe>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    f3c4:	f002 0303 	and.w	r3, r2, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    f3c8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    f3ca:	428b      	cmp	r3, r1
    f3cc:	f47f aef2 	bne.w	f1b4 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    f3d0:	f3c2 1205 	ubfx	r2, r2, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    f3d4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f3d6:	429a      	cmp	r2, r3
    f3d8:	f47f aeec 	bne.w	f1b4 <HAL_RCC_OscConfig+0x4b4>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    f3dc:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f3de:	f3c5 0208 	ubfx	r2, r5, #0, #9
    f3e2:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    f3e4:	429a      	cmp	r2, r3
    f3e6:	f47f aee5 	bne.w	f1b4 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    f3ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
    f3ec:	f3c5 2246 	ubfx	r2, r5, #9, #7
    f3f0:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    f3f2:	429a      	cmp	r2, r3
    f3f4:	f47f aede 	bne.w	f1b4 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
    f3f8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    f3fa:	f3c5 4206 	ubfx	r2, r5, #16, #7
    f3fe:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    f400:	429a      	cmp	r2, r3
    f402:	f47f aed7 	bne.w	f1b4 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
    f406:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    f408:	f3c5 6506 	ubfx	r5, r5, #24, #7
    f40c:	3801      	subs	r0, #1
    return HAL_ERROR;
    f40e:	1a28      	subs	r0, r5, r0
    f410:	bf18      	it	ne
    f412:	2001      	movne	r0, #1
    f414:	e673      	b.n	f0fe <HAL_RCC_OscConfig+0x3fe>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    f416:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f41a:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f41e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    f420:	f042 0201 	orr.w	r2, r2, #1
    f424:	671a      	str	r2, [r3, #112]	; 0x70
    f426:	e5a6      	b.n	ef76 <HAL_RCC_OscConfig+0x276>
      tickstart = HAL_GetTick();
    f428:	f7f9 f80a 	bl	8440 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    f42c:	f6c5 0502 	movt	r5, #22530	; 0x5802
      tickstart = HAL_GetTick();
    f430:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    f432:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    f436:	e005      	b.n	f444 <HAL_RCC_OscConfig+0x744>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    f438:	f7f9 f802 	bl	8440 <HAL_GetTick>
    f43c:	1bc0      	subs	r0, r0, r7
    f43e:	42b0      	cmp	r0, r6
    f440:	f63f aecd 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    f444:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    f446:	0798      	lsls	r0, r3, #30
    f448:	d4f6      	bmi.n	f438 <HAL_RCC_OscConfig+0x738>
    f44a:	e5ab      	b.n	efa4 <HAL_RCC_OscConfig+0x2a4>
        __HAL_RCC_PLL_DISABLE();
    f44c:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    f44e:	461c      	mov	r4, r3
        __HAL_RCC_PLL_DISABLE();
    f450:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    f454:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    f456:	f7f8 fff3 	bl	8440 <HAL_GetTick>
    f45a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    f45c:	e005      	b.n	f46a <HAL_RCC_OscConfig+0x76a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    f45e:	f7f8 ffef 	bl	8440 <HAL_GetTick>
    f462:	1b40      	subs	r0, r0, r5
    f464:	2802      	cmp	r0, #2
    f466:	f63f aeba 	bhi.w	f1de <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    f46a:	6823      	ldr	r3, [r4, #0]
    f46c:	019b      	lsls	r3, r3, #6
    f46e:	d4f6      	bmi.n	f45e <HAL_RCC_OscConfig+0x75e>
    f470:	e644      	b.n	f0fc <HAL_RCC_OscConfig+0x3fc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    f472:	2b05      	cmp	r3, #5
    f474:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f478:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f47c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    f47e:	f47f ad73 	bne.w	ef68 <HAL_RCC_OscConfig+0x268>
    f482:	f042 0204 	orr.w	r2, r2, #4
    f486:	671a      	str	r2, [r3, #112]	; 0x70
    f488:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    f48a:	f042 0201 	orr.w	r2, r2, #1
    f48e:	671a      	str	r2, [r3, #112]	; 0x70
    f490:	e571      	b.n	ef76 <HAL_RCC_OscConfig+0x276>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    f492:	68eb      	ldr	r3, [r5, #12]
    f494:	6a22      	ldr	r2, [r4, #32]
    f496:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
    f49a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    f49e:	60eb      	str	r3, [r5, #12]
    f4a0:	6823      	ldr	r3, [r4, #0]
    f4a2:	e4f7      	b.n	ee94 <HAL_RCC_OscConfig+0x194>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    f4a4:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    f4a8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    f4ac:	606b      	str	r3, [r5, #4]
    f4ae:	6823      	ldr	r3, [r4, #0]
    f4b0:	e4ae      	b.n	ee10 <HAL_RCC_OscConfig+0x110>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    f4b2:	f643 1018 	movw	r0, #14616	; 0x3918
    f4b6:	f240 21ee 	movw	r1, #750	; 0x2ee
    f4ba:	f2c0 0003 	movt	r0, #3
    f4be:	f00b fdf7 	bl	1b0b0 <assert_failed>
    f4c2:	e592      	b.n	efea <HAL_RCC_OscConfig+0x2ea>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    f4c4:	f643 1018 	movw	r0, #14616	; 0x3918
    f4c8:	f240 21ed 	movw	r1, #749	; 0x2ed
    f4cc:	f2c0 0003 	movt	r0, #3
    f4d0:	f00b fdee 	bl	1b0b0 <assert_failed>
    f4d4:	e583      	b.n	efde <HAL_RCC_OscConfig+0x2de>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    f4d6:	f643 1018 	movw	r0, #14616	; 0x3918
    f4da:	f240 21f2 	movw	r1, #754	; 0x2f2
    f4de:	f2c0 0003 	movt	r0, #3
    f4e2:	f00b fde5 	bl	1b0b0 <assert_failed>
    f4e6:	e594      	b.n	f012 <HAL_RCC_OscConfig+0x312>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    f4e8:	f643 1018 	movw	r0, #14616	; 0x3918
    f4ec:	f240 21f1 	movw	r1, #753	; 0x2f1
    f4f0:	f2c0 0003 	movt	r0, #3
    f4f4:	f00b fddc 	bl	1b0b0 <assert_failed>
    f4f8:	e586      	b.n	f008 <HAL_RCC_OscConfig+0x308>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    f4fa:	f643 1018 	movw	r0, #14616	; 0x3918
    f4fe:	f44f 713c 	mov.w	r1, #752	; 0x2f0
    f502:	f2c0 0003 	movt	r0, #3
    f506:	f00b fdd3 	bl	1b0b0 <assert_failed>
    f50a:	e578      	b.n	effe <HAL_RCC_OscConfig+0x2fe>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    f50c:	f643 1018 	movw	r0, #14616	; 0x3918
    f510:	f240 21ef 	movw	r1, #751	; 0x2ef
    f514:	f2c0 0003 	movt	r0, #3
    f518:	f00b fdca 	bl	1b0b0 <assert_failed>
    f51c:	e56a      	b.n	eff4 <HAL_RCC_OscConfig+0x2f4>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    f51e:	f643 1018 	movw	r0, #14616	; 0x3918
    f522:	f44f 713b 	mov.w	r1, #748	; 0x2ec
    f526:	f2c0 0003 	movt	r0, #3
    f52a:	f00b fdc1 	bl	1b0b0 <assert_failed>
    f52e:	e551      	b.n	efd4 <HAL_RCC_OscConfig+0x2d4>

0000f530 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
    f530:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f534:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f538:	6913      	ldr	r3, [r2, #16]
    f53a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    f53e:	2b10      	cmp	r3, #16
    f540:	d05c      	beq.n	f5fc <HAL_RCC_GetSysClockFreq+0xcc>
    f542:	2b18      	cmp	r3, #24
    f544:	d011      	beq.n	f56a <HAL_RCC_GetSysClockFreq+0x3a>
    f546:	b123      	cbz	r3, f552 <HAL_RCC_GetSysClockFreq+0x22>
      }

    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
    f548:	f44f 6010 	mov.w	r0, #2304	; 0x900
    f54c:	f2c0 003d 	movt	r0, #61	; 0x3d
    f550:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    f552:	6813      	ldr	r3, [r2, #0]
    f554:	0699      	lsls	r1, r3, #26
    f556:	d556      	bpl.n	f606 <HAL_RCC_GetSysClockFreq+0xd6>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    f558:	6813      	ldr	r3, [r2, #0]
    f55a:	f44f 4010 	mov.w	r0, #36864	; 0x9000
    f55e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    f562:	f2c0 30d0 	movt	r0, #976	; 0x3d0
    f566:	40d8      	lsrs	r0, r3
    f568:	4770      	bx	lr
{
    f56a:	b410      	push	{r4}
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    f56c:	6a91      	ldr	r1, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    f56e:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    f570:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    f572:	f3c0 1005 	ubfx	r0, r0, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    f576:	6b54      	ldr	r4, [r2, #52]	; 0x34

    if (pllm != 0U)
    f578:	b3e8      	cbz	r0, f5f6 <HAL_RCC_GetSysClockFreq+0xc6>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    f57a:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    f57e:	f003 0301 	and.w	r3, r3, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    f582:	f001 0103 	and.w	r1, r1, #3
    f586:	ee07 0a90 	vmov	s15, r0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    f58a:	fb03 f304 	mul.w	r3, r3, r4
    {
      switch (pllsource)
    f58e:	2901      	cmp	r1, #1
    f590:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    f594:	ee07 3a10 	vmov	s14, r3
    f598:	eeba 7ae9 	vcvt.f32.s32	s14, s14, #13
      switch (pllsource)
    f59c:	d002      	beq.n	f5a4 <HAL_RCC_GetSysClockFreq+0x74>
    f59e:	d33f      	bcc.n	f620 <HAL_RCC_GetSysClockFreq+0xf0>
    f5a0:	2902      	cmp	r1, #2
    f5a2:	d035      	beq.n	f610 <HAL_RCC_GetSysClockFreq+0xe0>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    f5a4:	f44f 5110 	mov.w	r1, #9216	; 0x2400
    f5a8:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    f5ac:	6b13      	ldr	r3, [r2, #48]	; 0x30
    f5ae:	f6c4 2174 	movt	r1, #19060	; 0x4a74
    f5b2:	ee06 1a10 	vmov	s12, r1
    f5b6:	f3c3 0308 	ubfx	r3, r3, #0, #9
    f5ba:	eec6 5a27 	vdiv.f32	s11, s12, s15
    f5be:	ee06 3a90 	vmov	s13, r3
    f5c2:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    f5c6:	ee76 7a85 	vadd.f32	s15, s13, s10
    f5ca:	ee37 7a87 	vadd.f32	s14, s15, s14
    f5ce:	ee27 7a25 	vmul.f32	s14, s14, s11
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
    f5d2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f5d6:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f5da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    f5dc:	f3c3 2346 	ubfx	r3, r3, #9, #7
    f5e0:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    f5e2:	ee07 3a90 	vmov	s15, r3
    f5e6:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    f5ea:	eec7 7a26 	vdiv.f32	s15, s14, s13
    f5ee:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    f5f2:	ee17 0a90 	vmov	r0, s15
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
    f5f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    f5fa:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
    f5fc:	f647 0040 	movw	r0, #30784	; 0x7840
    f600:	f2c0 107d 	movt	r0, #381	; 0x17d
    f604:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
    f606:	f44f 4010 	mov.w	r0, #36864	; 0x9000
    f60a:	f2c0 30d0 	movt	r0, #976	; 0x3d0
}
    f60e:	4770      	bx	lr
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    f610:	f64b 4120 	movw	r1, #48160	; 0xbc20
    f614:	6b13      	ldr	r3, [r2, #48]	; 0x30
    f616:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    f61a:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
    f61e:	e7c8      	b.n	f5b2 <HAL_RCC_GetSysClockFreq+0x82>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    f620:	6813      	ldr	r3, [r2, #0]
    f622:	069b      	lsls	r3, r3, #26
    f624:	d51d      	bpl.n	f662 <HAL_RCC_GetSysClockFreq+0x132>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    f626:	6810      	ldr	r0, [r2, #0]
    f628:	f44f 4110 	mov.w	r1, #36864	; 0x9000
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    f62c:	6b13      	ldr	r3, [r2, #48]	; 0x30
    f62e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    f632:	f3c0 02c1 	ubfx	r2, r0, #3, #2
    f636:	f2c0 31d0 	movt	r1, #976	; 0x3d0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    f63a:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    f63e:	40d1      	lsrs	r1, r2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    f640:	ee06 3a10 	vmov	s12, r3
    f644:	ee05 1a90 	vmov	s11, r1
    f648:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
    f64c:	eef8 5ae5 	vcvt.f32.s32	s11, s11
    f650:	ee36 6a26 	vadd.f32	s12, s12, s13
    f654:	eec5 6aa7 	vdiv.f32	s13, s11, s15
    f658:	ee36 7a07 	vadd.f32	s14, s12, s14
    f65c:	ee26 7a87 	vmul.f32	s14, s13, s14
    f660:	e7b7      	b.n	f5d2 <HAL_RCC_GetSysClockFreq+0xa2>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    f662:	f44f 5110 	mov.w	r1, #9216	; 0x2400
    f666:	6b13      	ldr	r3, [r2, #48]	; 0x30
    f668:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    f66c:	f6c4 4174 	movt	r1, #19572	; 0x4c74
    f670:	e79f      	b.n	f5b2 <HAL_RCC_GetSysClockFreq+0x82>
    f672:	bf00      	nop

0000f674 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
    f674:	2800      	cmp	r0, #0
    f676:	f000 822b 	beq.w	fad0 <HAL_RCC_ClockConfig+0x45c>
{
    f67a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    f67e:	6803      	ldr	r3, [r0, #0]
    f680:	4604      	mov	r4, r0
    f682:	460d      	mov	r5, r1
    f684:	3b01      	subs	r3, #1
    f686:	2b3e      	cmp	r3, #62	; 0x3e
    f688:	f200 8209 	bhi.w	fa9e <HAL_RCC_ClockConfig+0x42a>
  assert_param(IS_FLASH_LATENCY(FLatency));
    f68c:	2d0f      	cmp	r5, #15
    f68e:	f200 81f0 	bhi.w	fa72 <HAL_RCC_ClockConfig+0x3fe>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
    f692:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    f696:	f2c5 2200 	movt	r2, #20992	; 0x5200
    f69a:	6813      	ldr	r3, [r2, #0]
    f69c:	f003 030f 	and.w	r3, r3, #15
    f6a0:	42ab      	cmp	r3, r5
    f6a2:	f0c0 8217 	bcc.w	fad4 <HAL_RCC_ClockConfig+0x460>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
    f6a6:	6823      	ldr	r3, [r4, #0]
    f6a8:	075e      	lsls	r6, r3, #29
    f6aa:	d518      	bpl.n	f6de <HAL_RCC_ClockConfig+0x6a>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    f6ac:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f6b0:	6921      	ldr	r1, [r4, #16]
    f6b2:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f6b6:	6992      	ldr	r2, [r2, #24]
    f6b8:	f002 0270 	and.w	r2, r2, #112	; 0x70
    f6bc:	4291      	cmp	r1, r2
    f6be:	d90e      	bls.n	f6de <HAL_RCC_ClockConfig+0x6a>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    f6c0:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    f6c4:	2b40      	cmp	r3, #64	; 0x40
    f6c6:	f040 822e 	bne.w	fb26 <HAL_RCC_ClockConfig+0x4b2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    f6ca:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f6ce:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f6d2:	6993      	ldr	r3, [r2, #24]
    f6d4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    f6d8:	4319      	orrs	r1, r3
    f6da:	6191      	str	r1, [r2, #24]
    f6dc:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    f6de:	0718      	lsls	r0, r3, #28
    f6e0:	d518      	bpl.n	f714 <HAL_RCC_ClockConfig+0xa0>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    f6e2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f6e6:	6961      	ldr	r1, [r4, #20]
    f6e8:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f6ec:	69d2      	ldr	r2, [r2, #28]
    f6ee:	f002 0270 	and.w	r2, r2, #112	; 0x70
    f6f2:	4291      	cmp	r1, r2
    f6f4:	d90e      	bls.n	f714 <HAL_RCC_ClockConfig+0xa0>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    f6f6:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    f6fa:	2b40      	cmp	r3, #64	; 0x40
    f6fc:	f040 821d 	bne.w	fb3a <HAL_RCC_ClockConfig+0x4c6>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    f700:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f704:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f708:	69d3      	ldr	r3, [r2, #28]
    f70a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    f70e:	4319      	orrs	r1, r3
    f710:	61d1      	str	r1, [r2, #28]
    f712:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    f714:	06d9      	lsls	r1, r3, #27
    f716:	d519      	bpl.n	f74c <HAL_RCC_ClockConfig+0xd8>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    f718:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f71c:	69a1      	ldr	r1, [r4, #24]
    f71e:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f722:	69d2      	ldr	r2, [r2, #28]
    f724:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    f728:	4291      	cmp	r1, r2
    f72a:	d90f      	bls.n	f74c <HAL_RCC_ClockConfig+0xd8>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    f72c:	f421 7340 	bic.w	r3, r1, #768	; 0x300
    f730:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    f734:	f040 820b 	bne.w	fb4e <HAL_RCC_ClockConfig+0x4da>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    f738:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f73c:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f740:	69d3      	ldr	r3, [r2, #28]
    f742:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    f746:	4319      	orrs	r1, r3
    f748:	61d1      	str	r1, [r2, #28]
    f74a:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
    f74c:	069a      	lsls	r2, r3, #26
    f74e:	d518      	bpl.n	f782 <HAL_RCC_ClockConfig+0x10e>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    f750:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f754:	69e1      	ldr	r1, [r4, #28]
    f756:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f75a:	6a12      	ldr	r2, [r2, #32]
    f75c:	f002 0270 	and.w	r2, r2, #112	; 0x70
    f760:	4291      	cmp	r1, r2
    f762:	d90e      	bls.n	f782 <HAL_RCC_ClockConfig+0x10e>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    f764:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    f768:	2b40      	cmp	r3, #64	; 0x40
    f76a:	f040 81d2 	bne.w	fb12 <HAL_RCC_ClockConfig+0x49e>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    f76e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f772:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f776:	6a13      	ldr	r3, [r2, #32]
    f778:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    f77c:	4319      	orrs	r1, r3
    f77e:	6211      	str	r1, [r2, #32]
    f780:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    f782:	079f      	lsls	r7, r3, #30
    f784:	d518      	bpl.n	f7b8 <HAL_RCC_ClockConfig+0x144>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
    f786:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f78a:	68e1      	ldr	r1, [r4, #12]
    f78c:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f790:	6992      	ldr	r2, [r2, #24]
    f792:	f002 020f 	and.w	r2, r2, #15
    f796:	4291      	cmp	r1, r2
    f798:	d90e      	bls.n	f7b8 <HAL_RCC_ClockConfig+0x144>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    f79a:	f1a1 0308 	sub.w	r3, r1, #8
    f79e:	2b07      	cmp	r3, #7
    f7a0:	f200 81df 	bhi.w	fb62 <HAL_RCC_ClockConfig+0x4ee>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    f7a4:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f7a8:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f7ac:	6993      	ldr	r3, [r2, #24]
    f7ae:	f023 030f 	bic.w	r3, r3, #15
    f7b2:	4319      	orrs	r1, r3
    f7b4:	6191      	str	r1, [r2, #24]
    f7b6:	6823      	ldr	r3, [r4, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    f7b8:	07de      	lsls	r6, r3, #31
    f7ba:	d55c      	bpl.n	f876 <HAL_RCC_ClockConfig+0x202>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    f7bc:	68a2      	ldr	r2, [r4, #8]
    f7be:	f432 6300 	bics.w	r3, r2, #2048	; 0x800
    f7c2:	f422 7000 	bic.w	r0, r2, #512	; 0x200
    f7c6:	f422 6180 	bic.w	r1, r2, #1024	; 0x400
    f7ca:	bf14      	ite	ne
    f7cc:	2301      	movne	r3, #1
    f7ce:	2300      	moveq	r3, #0
    f7d0:	f5b0 6f10 	cmp.w	r0, #2304	; 0x900
    f7d4:	bf0c      	ite	eq
    f7d6:	2300      	moveq	r3, #0
    f7d8:	f003 0301 	andne.w	r3, r3, #1
    f7dc:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
    f7e0:	bf0c      	ite	eq
    f7e2:	2300      	moveq	r3, #0
    f7e4:	f003 0301 	andne.w	r3, r3, #1
    f7e8:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
    f7ec:	bf0c      	ite	eq
    f7ee:	2300      	moveq	r3, #0
    f7f0:	f003 0301 	andne.w	r3, r3, #1
    f7f4:	b12b      	cbz	r3, f802 <HAL_RCC_ClockConfig+0x18e>
    f7f6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    f7fa:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
    f7fe:	f040 817b 	bne.w	faf8 <HAL_RCC_ClockConfig+0x484>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    f802:	6863      	ldr	r3, [r4, #4]
    f804:	2b03      	cmp	r3, #3
    f806:	f200 815a 	bhi.w	fabe <HAL_RCC_ClockConfig+0x44a>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
    f80a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f80e:	68a1      	ldr	r1, [r4, #8]
    f810:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f814:	6993      	ldr	r3, [r2, #24]
    f816:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
    f81a:	430b      	orrs	r3, r1
    f81c:	6193      	str	r3, [r2, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    f81e:	6863      	ldr	r3, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    f820:	6812      	ldr	r2, [r2, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    f822:	2b02      	cmp	r3, #2
    f824:	f000 8147 	beq.w	fab6 <HAL_RCC_ClockConfig+0x442>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    f828:	2b03      	cmp	r3, #3
    f82a:	f000 8161 	beq.w	faf0 <HAL_RCC_ClockConfig+0x47c>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
    f82e:	2b01      	cmp	r3, #1
    f830:	f000 816b 	beq.w	fb0a <HAL_RCC_ClockConfig+0x496>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    f834:	0757      	lsls	r7, r2, #29
    f836:	f140 812f 	bpl.w	fa98 <HAL_RCC_ClockConfig+0x424>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    f83a:	f44f 4188 	mov.w	r1, #17408	; 0x4400
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    f83e:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    f842:	f6c5 0102 	movt	r1, #22530	; 0x5802
    f846:	690a      	ldr	r2, [r1, #16]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    f848:	460e      	mov	r6, r1
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    f84a:	f022 0207 	bic.w	r2, r2, #7
    f84e:	4313      	orrs	r3, r2
    f850:	610b      	str	r3, [r1, #16]
      tickstart = HAL_GetTick();
    f852:	f7f8 fdf5 	bl	8440 <HAL_GetTick>
    f856:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    f858:	e005      	b.n	f866 <HAL_RCC_ClockConfig+0x1f2>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    f85a:	f7f8 fdf1 	bl	8440 <HAL_GetTick>
    f85e:	1bc0      	subs	r0, r0, r7
    f860:	4540      	cmp	r0, r8
    f862:	f200 8143 	bhi.w	faec <HAL_RCC_ClockConfig+0x478>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    f866:	6933      	ldr	r3, [r6, #16]
    f868:	6862      	ldr	r2, [r4, #4]
    f86a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    f86e:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
    f872:	d1f2      	bne.n	f85a <HAL_RCC_ClockConfig+0x1e6>
    f874:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    f876:	079e      	lsls	r6, r3, #30
    f878:	d520      	bpl.n	f8bc <HAL_RCC_ClockConfig+0x248>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
    f87a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f87e:	68e2      	ldr	r2, [r4, #12]
    f880:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f884:	699b      	ldr	r3, [r3, #24]
    f886:	f003 030f 	and.w	r3, r3, #15
    f88a:	429a      	cmp	r2, r3
    f88c:	d216      	bcs.n	f8bc <HAL_RCC_ClockConfig+0x248>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    f88e:	f1a2 0308 	sub.w	r3, r2, #8
    f892:	2b06      	cmp	r3, #6
    f894:	d909      	bls.n	f8aa <HAL_RCC_ClockConfig+0x236>
    f896:	b142      	cbz	r2, f8aa <HAL_RCC_ClockConfig+0x236>
    f898:	f643 1018 	movw	r0, #14616	; 0x3918
    f89c:	f240 4136 	movw	r1, #1078	; 0x436
    f8a0:	f2c0 0003 	movt	r0, #3
    f8a4:	f00b fc04 	bl	1b0b0 <assert_failed>
    f8a8:	68e2      	ldr	r2, [r4, #12]
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    f8aa:	f44f 4188 	mov.w	r1, #17408	; 0x4400
    f8ae:	f6c5 0102 	movt	r1, #22530	; 0x5802
    f8b2:	698b      	ldr	r3, [r1, #24]
    f8b4:	f023 030f 	bic.w	r3, r3, #15
    f8b8:	431a      	orrs	r2, r3
    f8ba:	618a      	str	r2, [r1, #24]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
    f8bc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    f8c0:	f2c5 2300 	movt	r3, #20992	; 0x5200
    f8c4:	681a      	ldr	r2, [r3, #0]
    f8c6:	f002 020f 	and.w	r2, r2, #15
    f8ca:	42aa      	cmp	r2, r5
    f8cc:	d90a      	bls.n	f8e4 <HAL_RCC_ClockConfig+0x270>
    __HAL_FLASH_SET_LATENCY(FLatency);
    f8ce:	681a      	ldr	r2, [r3, #0]
    f8d0:	f022 020f 	bic.w	r2, r2, #15
    f8d4:	432a      	orrs	r2, r5
    f8d6:	601a      	str	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    f8d8:	681b      	ldr	r3, [r3, #0]
    f8da:	f003 030f 	and.w	r3, r3, #15
    f8de:	42ab      	cmp	r3, r5
    f8e0:	f040 80da 	bne.w	fa98 <HAL_RCC_ClockConfig+0x424>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
    f8e4:	6823      	ldr	r3, [r4, #0]
    f8e6:	0758      	lsls	r0, r3, #29
    f8e8:	d523      	bpl.n	f932 <HAL_RCC_ClockConfig+0x2be>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    f8ea:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f8ee:	6921      	ldr	r1, [r4, #16]
    f8f0:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f8f4:	6992      	ldr	r2, [r2, #24]
    f8f6:	f002 0270 	and.w	r2, r2, #112	; 0x70
    f8fa:	4291      	cmp	r1, r2
    f8fc:	d219      	bcs.n	f932 <HAL_RCC_ClockConfig+0x2be>
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    f8fe:	2950      	cmp	r1, #80	; 0x50
    f900:	bf18      	it	ne
    f902:	2960      	cmpne	r1, #96	; 0x60
    f904:	d00b      	beq.n	f91e <HAL_RCC_ClockConfig+0x2aa>
    f906:	f031 0340 	bics.w	r3, r1, #64	; 0x40
    f90a:	d008      	beq.n	f91e <HAL_RCC_ClockConfig+0x2aa>
    f90c:	f643 1018 	movw	r0, #14616	; 0x3918
    f910:	f240 4157 	movw	r1, #1111	; 0x457
    f914:	f2c0 0003 	movt	r0, #3
    f918:	f00b fbca 	bl	1b0b0 <assert_failed>
    f91c:	6921      	ldr	r1, [r4, #16]
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    f91e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f922:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f926:	6993      	ldr	r3, [r2, #24]
    f928:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    f92c:	4319      	orrs	r1, r3
    f92e:	6191      	str	r1, [r2, #24]
    f930:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    f932:	0719      	lsls	r1, r3, #28
    f934:	d523      	bpl.n	f97e <HAL_RCC_ClockConfig+0x30a>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    f936:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f93a:	6961      	ldr	r1, [r4, #20]
    f93c:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f940:	69d2      	ldr	r2, [r2, #28]
    f942:	f002 0270 	and.w	r2, r2, #112	; 0x70
    f946:	4291      	cmp	r1, r2
    f948:	d219      	bcs.n	f97e <HAL_RCC_ClockConfig+0x30a>
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    f94a:	2950      	cmp	r1, #80	; 0x50
    f94c:	bf18      	it	ne
    f94e:	2960      	cmpne	r1, #96	; 0x60
    f950:	d00b      	beq.n	f96a <HAL_RCC_ClockConfig+0x2f6>
    f952:	f031 0340 	bics.w	r3, r1, #64	; 0x40
    f956:	d008      	beq.n	f96a <HAL_RCC_ClockConfig+0x2f6>
    f958:	f643 1018 	movw	r0, #14616	; 0x3918
    f95c:	f240 4169 	movw	r1, #1129	; 0x469
    f960:	f2c0 0003 	movt	r0, #3
    f964:	f00b fba4 	bl	1b0b0 <assert_failed>
    f968:	6961      	ldr	r1, [r4, #20]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    f96a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f96e:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f972:	69d3      	ldr	r3, [r2, #28]
    f974:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    f978:	4319      	orrs	r1, r3
    f97a:	61d1      	str	r1, [r2, #28]
    f97c:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    f97e:	06da      	lsls	r2, r3, #27
    f980:	d525      	bpl.n	f9ce <HAL_RCC_ClockConfig+0x35a>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    f982:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f986:	69a1      	ldr	r1, [r4, #24]
    f988:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f98c:	69d2      	ldr	r2, [r2, #28]
    f98e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    f992:	4291      	cmp	r1, r2
    f994:	d21b      	bcs.n	f9ce <HAL_RCC_ClockConfig+0x35a>
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    f996:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    f99a:	bf18      	it	ne
    f99c:	f5b1 6fa0 	cmpne.w	r1, #1280	; 0x500
    f9a0:	d00b      	beq.n	f9ba <HAL_RCC_ClockConfig+0x346>
    f9a2:	f431 6380 	bics.w	r3, r1, #1024	; 0x400
    f9a6:	d008      	beq.n	f9ba <HAL_RCC_ClockConfig+0x346>
    f9a8:	f643 1018 	movw	r0, #14616	; 0x3918
    f9ac:	f240 417b 	movw	r1, #1147	; 0x47b
    f9b0:	f2c0 0003 	movt	r0, #3
    f9b4:	f00b fb7c 	bl	1b0b0 <assert_failed>
    f9b8:	69a1      	ldr	r1, [r4, #24]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    f9ba:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    f9be:	f6c5 0202 	movt	r2, #22530	; 0x5802
    f9c2:	69d3      	ldr	r3, [r2, #28]
    f9c4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    f9c8:	4319      	orrs	r1, r3
    f9ca:	61d1      	str	r1, [r2, #28]
    f9cc:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
    f9ce:	069b      	lsls	r3, r3, #26
    f9d0:	d522      	bpl.n	fa18 <HAL_RCC_ClockConfig+0x3a4>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    f9d2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    f9d6:	69e2      	ldr	r2, [r4, #28]
    f9d8:	f6c5 0302 	movt	r3, #22530	; 0x5802
    f9dc:	6a1b      	ldr	r3, [r3, #32]
    f9de:	f003 0370 	and.w	r3, r3, #112	; 0x70
    f9e2:	429a      	cmp	r2, r3
    f9e4:	d218      	bcs.n	fa18 <HAL_RCC_ClockConfig+0x3a4>
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    f9e6:	2a50      	cmp	r2, #80	; 0x50
    f9e8:	bf18      	it	ne
    f9ea:	2a60      	cmpne	r2, #96	; 0x60
    f9ec:	d00b      	beq.n	fa06 <HAL_RCC_ClockConfig+0x392>
    f9ee:	f032 0340 	bics.w	r3, r2, #64	; 0x40
    f9f2:	d008      	beq.n	fa06 <HAL_RCC_ClockConfig+0x392>
    f9f4:	f643 1018 	movw	r0, #14616	; 0x3918
    f9f8:	f240 418d 	movw	r1, #1165	; 0x48d
    f9fc:	f2c0 0003 	movt	r0, #3
    fa00:	f00b fb56 	bl	1b0b0 <assert_failed>
    fa04:	69e2      	ldr	r2, [r4, #28]
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    fa06:	f44f 4188 	mov.w	r1, #17408	; 0x4400
    fa0a:	f6c5 0102 	movt	r1, #22530	; 0x5802
    fa0e:	6a0b      	ldr	r3, [r1, #32]
    fa10:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    fa14:	431a      	orrs	r2, r3
    fa16:	620a      	str	r2, [r1, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa18:	f44f 4488 	mov.w	r4, #17408	; 0x4400
    fa1c:	f7ff fd88 	bl	f530 <HAL_RCC_GetSysClockFreq>
    fa20:	f244 72c4 	movw	r2, #18372	; 0x47c4
  halstatus = HAL_InitTick (uwTickPrio);
    fa24:	f246 0508 	movw	r5, #24584	; 0x6008
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa28:	f6c5 0402 	movt	r4, #22530	; 0x5802
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa2c:	f246 21b8 	movw	r1, #25272	; 0x62b8
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa30:	f2c0 0203 	movt	r2, #3
  halstatus = HAL_InitTick (uwTickPrio);
    fa34:	f2c0 0506 	movt	r5, #6
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa38:	69a3      	ldr	r3, [r4, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa3a:	f2c0 0106 	movt	r1, #6
    fa3e:	69a4      	ldr	r4, [r4, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa40:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa44:	f004 040f 	and.w	r4, r4, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa48:	5cd3      	ldrb	r3, [r2, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa4a:	5d12      	ldrb	r2, [r2, r4]
  SystemCoreClock = common_system_clock;
    fa4c:	f246 24b4 	movw	r4, #25268	; 0x62b4
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa50:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa54:	f002 021f 	and.w	r2, r2, #31
  SystemCoreClock = common_system_clock;
    fa58:	f2c0 0406 	movt	r4, #6
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    fa5c:	fa20 f303 	lsr.w	r3, r0, r3
  halstatus = HAL_InitTick (uwTickPrio);
    fa60:	6828      	ldr	r0, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa62:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
    fa66:	6023      	str	r3, [r4, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fa68:	600a      	str	r2, [r1, #0]
}
    fa6a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
    fa6e:	f7f8 bc87 	b.w	8380 <HAL_InitTick>
  assert_param(IS_FLASH_LATENCY(FLatency));
    fa72:	f643 1018 	movw	r0, #14616	; 0x3918
    fa76:	f44f 7160 	mov.w	r1, #896	; 0x380
    fa7a:	f2c0 0003 	movt	r0, #3
    fa7e:	f00b fb17 	bl	1b0b0 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
    fa82:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    fa86:	f2c5 2300 	movt	r3, #20992	; 0x5200
    fa8a:	681a      	ldr	r2, [r3, #0]
    __HAL_FLASH_SET_LATENCY(FLatency);
    fa8c:	6819      	ldr	r1, [r3, #0]
    fa8e:	f021 010f 	bic.w	r1, r1, #15
    fa92:	430d      	orrs	r5, r1
    fa94:	601d      	str	r5, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    fa96:	681b      	ldr	r3, [r3, #0]
    return HAL_ERROR;
    fa98:	2001      	movs	r0, #1
}
    fa9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    fa9e:	f643 1018 	movw	r0, #14616	; 0x3918
    faa2:	f240 317f 	movw	r1, #895	; 0x37f
    faa6:	f2c0 0003 	movt	r0, #3
    faaa:	f00b fb01 	bl	1b0b0 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
    faae:	2d0f      	cmp	r5, #15
    fab0:	f67f adef 	bls.w	f692 <HAL_RCC_ClockConfig+0x1e>
    fab4:	e7dd      	b.n	fa72 <HAL_RCC_ClockConfig+0x3fe>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    fab6:	0390      	lsls	r0, r2, #14
    fab8:	f53f aebf 	bmi.w	f83a <HAL_RCC_ClockConfig+0x1c6>
    fabc:	e7ec      	b.n	fa98 <HAL_RCC_ClockConfig+0x424>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    fabe:	f643 1018 	movw	r0, #14616	; 0x3918
    fac2:	f240 31f5 	movw	r1, #1013	; 0x3f5
    fac6:	f2c0 0003 	movt	r0, #3
    faca:	f00b faf1 	bl	1b0b0 <assert_failed>
    face:	e69c      	b.n	f80a <HAL_RCC_ClockConfig+0x196>
    return HAL_ERROR;
    fad0:	2001      	movs	r0, #1
}
    fad2:	4770      	bx	lr
    __HAL_FLASH_SET_LATENCY(FLatency);
    fad4:	6813      	ldr	r3, [r2, #0]
    fad6:	f023 030f 	bic.w	r3, r3, #15
    fada:	432b      	orrs	r3, r5
    fadc:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    fade:	6813      	ldr	r3, [r2, #0]
    fae0:	f003 030f 	and.w	r3, r3, #15
    fae4:	42ab      	cmp	r3, r5
    fae6:	f43f adde 	beq.w	f6a6 <HAL_RCC_ClockConfig+0x32>
    faea:	e7d5      	b.n	fa98 <HAL_RCC_ClockConfig+0x424>
            return HAL_TIMEOUT;
    faec:	2003      	movs	r0, #3
    faee:	e7d4      	b.n	fa9a <HAL_RCC_ClockConfig+0x426>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    faf0:	0191      	lsls	r1, r2, #6
    faf2:	f53f aea2 	bmi.w	f83a <HAL_RCC_ClockConfig+0x1c6>
    faf6:	e7cf      	b.n	fa98 <HAL_RCC_ClockConfig+0x424>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    faf8:	f643 1018 	movw	r0, #14616	; 0x3918
    fafc:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
    fb00:	f2c0 0003 	movt	r0, #3
    fb04:	f00b fad4 	bl	1b0b0 <assert_failed>
    fb08:	e67b      	b.n	f802 <HAL_RCC_ClockConfig+0x18e>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    fb0a:	05d2      	lsls	r2, r2, #23
    fb0c:	f53f ae95 	bmi.w	f83a <HAL_RCC_ClockConfig+0x1c6>
    fb10:	e7c2      	b.n	fa98 <HAL_RCC_ClockConfig+0x424>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    fb12:	f643 1018 	movw	r0, #14616	; 0x3918
    fb16:	f240 31d1 	movw	r1, #977	; 0x3d1
    fb1a:	f2c0 0003 	movt	r0, #3
    fb1e:	f00b fac7 	bl	1b0b0 <assert_failed>
    fb22:	69e1      	ldr	r1, [r4, #28]
    fb24:	e623      	b.n	f76e <HAL_RCC_ClockConfig+0xfa>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    fb26:	f643 1018 	movw	r0, #14616	; 0x3918
    fb2a:	f44f 7167 	mov.w	r1, #924	; 0x39c
    fb2e:	f2c0 0003 	movt	r0, #3
    fb32:	f00b fabd 	bl	1b0b0 <assert_failed>
    fb36:	6921      	ldr	r1, [r4, #16]
    fb38:	e5c7      	b.n	f6ca <HAL_RCC_ClockConfig+0x56>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    fb3a:	f643 1018 	movw	r0, #14616	; 0x3918
    fb3e:	f240 31ae 	movw	r1, #942	; 0x3ae
    fb42:	f2c0 0003 	movt	r0, #3
    fb46:	f00b fab3 	bl	1b0b0 <assert_failed>
    fb4a:	6961      	ldr	r1, [r4, #20]
    fb4c:	e5d8      	b.n	f700 <HAL_RCC_ClockConfig+0x8c>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    fb4e:	f643 1018 	movw	r0, #14616	; 0x3918
    fb52:	f240 31bf 	movw	r1, #959	; 0x3bf
    fb56:	f2c0 0003 	movt	r0, #3
    fb5a:	f00b faa9 	bl	1b0b0 <assert_failed>
    fb5e:	69a1      	ldr	r1, [r4, #24]
    fb60:	e5ea      	b.n	f738 <HAL_RCC_ClockConfig+0xc4>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    fb62:	f643 1018 	movw	r0, #14616	; 0x3918
    fb66:	f44f 7179 	mov.w	r1, #996	; 0x3e4
    fb6a:	f2c0 0003 	movt	r0, #3
    fb6e:	f00b fa9f 	bl	1b0b0 <assert_failed>
    fb72:	68e1      	ldr	r1, [r4, #12]
    fb74:	e616      	b.n	f7a4 <HAL_RCC_ClockConfig+0x130>
    fb76:	bf00      	nop

0000fb78 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
    fb78:	f44f 4288 	mov.w	r2, #17408	; 0x4400
    fb7c:	f6c5 0202 	movt	r2, #22530	; 0x5802
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
    fb80:	b430      	push	{r4, r5}
  switch (RCC->CFGR & RCC_CFGR_SWS)
    fb82:	6913      	ldr	r3, [r2, #16]
    fb84:	f003 0338 	and.w	r3, r3, #56	; 0x38
    fb88:	2b10      	cmp	r3, #16
    fb8a:	d07d      	beq.n	fc88 <HAL_RCC_GetHCLKFreq+0x110>
    fb8c:	2b18      	cmp	r3, #24
    fb8e:	d034      	beq.n	fbfa <HAL_RCC_GetHCLKFreq+0x82>
    fb90:	b333      	cbz	r3, fbe0 <HAL_RCC_GetHCLKFreq+0x68>
    sysclockfreq = CSI_VALUE;
    fb92:	f44f 6310 	mov.w	r3, #2304	; 0x900
    fb96:	f2c0 033d 	movt	r3, #61	; 0x3d
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fb9a:	f44f 4088 	mov.w	r0, #17408	; 0x4400
    fb9e:	f244 72c4 	movw	r2, #18372	; 0x47c4
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fba2:	f246 21b8 	movw	r1, #25272	; 0x62b8
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
    fba6:	f246 24b4 	movw	r4, #25268	; 0x62b4
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fbaa:	f6c5 0002 	movt	r0, #22530	; 0x5802
    fbae:	f2c0 0203 	movt	r2, #3
  SystemCoreClock = common_system_clock;
    fbb2:	f2c0 0406 	movt	r4, #6
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbb6:	f2c0 0106 	movt	r1, #6
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fbba:	6985      	ldr	r5, [r0, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbbc:	6980      	ldr	r0, [r0, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fbbe:	f3c5 2503 	ubfx	r5, r5, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbc2:	f000 000f 	and.w	r0, r0, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fbc6:	5d55      	ldrb	r5, [r2, r5]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbc8:	5c10      	ldrb	r0, [r2, r0]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fbca:	f005 021f 	and.w	r2, r5, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbce:	f000 001f 	and.w	r0, r0, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    fbd2:	40d3      	lsrs	r3, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbd4:	fa23 f000 	lsr.w	r0, r3, r0
  SystemCoreClock = common_system_clock;
    fbd8:	6023      	str	r3, [r4, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    fbda:	6008      	str	r0, [r1, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
    fbdc:	bc30      	pop	{r4, r5}
    fbde:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    fbe0:	6813      	ldr	r3, [r2, #0]
    fbe2:	0699      	lsls	r1, r3, #26
    fbe4:	d555      	bpl.n	fc92 <HAL_RCC_GetHCLKFreq+0x11a>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    fbe6:	6813      	ldr	r3, [r2, #0]
    fbe8:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    fbec:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    fbf0:	f2c0 32d0 	movt	r2, #976	; 0x3d0
    fbf4:	fa22 f303 	lsr.w	r3, r2, r3
    fbf8:	e7cf      	b.n	fb9a <HAL_RCC_GetHCLKFreq+0x22>
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    fbfa:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    fbfc:	6a93      	ldr	r3, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    fbfe:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    fc00:	f3c3 1305 	ubfx	r3, r3, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    fc04:	6b54      	ldr	r4, [r2, #52]	; 0x34
    if (pllm != 0U)
    fc06:	2b00      	cmp	r3, #0
    fc08:	d0c7      	beq.n	fb9a <HAL_RCC_GetHCLKFreq+0x22>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    fc0a:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    fc0e:	f001 0101 	and.w	r1, r1, #1
    fc12:	ee07 3a90 	vmov	s15, r3
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    fc16:	f000 0003 	and.w	r0, r0, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    fc1a:	fb01 f304 	mul.w	r3, r1, r4
    fc1e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
      switch (pllsource)
    fc22:	2801      	cmp	r0, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    fc24:	ee07 3a90 	vmov	s15, r3
    fc28:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
      switch (pllsource)
    fc2c:	d002      	beq.n	fc34 <HAL_RCC_GetHCLKFreq+0xbc>
    fc2e:	d33d      	bcc.n	fcac <HAL_RCC_GetHCLKFreq+0x134>
    fc30:	2802      	cmp	r0, #2
    fc32:	d033      	beq.n	fc9c <HAL_RCC_GetHCLKFreq+0x124>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    fc34:	f44f 5110 	mov.w	r1, #9216	; 0x2400
    fc38:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    fc3c:	6b13      	ldr	r3, [r2, #48]	; 0x30
    fc3e:	f6c4 2174 	movt	r1, #19060	; 0x4a74
    fc42:	ee06 1a10 	vmov	s12, r1
    fc46:	f3c3 0308 	ubfx	r3, r3, #0, #9
    fc4a:	eec6 5a26 	vdiv.f32	s11, s12, s13
    fc4e:	ee07 3a10 	vmov	s14, r3
    fc52:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    fc56:	ee37 7a05 	vadd.f32	s14, s14, s10
    fc5a:	ee77 7a27 	vadd.f32	s15, s14, s15
    fc5e:	ee67 7aa5 	vmul.f32	s15, s15, s11
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
    fc62:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    fc66:	f6c5 0302 	movt	r3, #22530	; 0x5802
    fc6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    fc6c:	f3c3 2346 	ubfx	r3, r3, #9, #7
    fc70:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    fc72:	ee07 3a10 	vmov	s14, r3
    fc76:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    fc7a:	eec7 6a87 	vdiv.f32	s13, s15, s14
    fc7e:	eefc 7ae6 	vcvt.u32.f32	s15, s13
    fc82:	ee17 3a90 	vmov	r3, s15
    fc86:	e788      	b.n	fb9a <HAL_RCC_GetHCLKFreq+0x22>
    sysclockfreq = HSE_VALUE;
    fc88:	f647 0340 	movw	r3, #30784	; 0x7840
    fc8c:	f2c0 137d 	movt	r3, #381	; 0x17d
    fc90:	e783      	b.n	fb9a <HAL_RCC_GetHCLKFreq+0x22>
        sysclockfreq = (uint32_t) HSI_VALUE;
    fc92:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    fc96:	f2c0 33d0 	movt	r3, #976	; 0x3d0
    fc9a:	e77e      	b.n	fb9a <HAL_RCC_GetHCLKFreq+0x22>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    fc9c:	f64b 4120 	movw	r1, #48160	; 0xbc20
    fca0:	6b13      	ldr	r3, [r2, #48]	; 0x30
    fca2:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    fca6:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
    fcaa:	e7ca      	b.n	fc42 <HAL_RCC_GetHCLKFreq+0xca>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    fcac:	6813      	ldr	r3, [r2, #0]
    fcae:	069b      	lsls	r3, r3, #26
    fcb0:	d51d      	bpl.n	fcee <HAL_RCC_GetHCLKFreq+0x176>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    fcb2:	6810      	ldr	r0, [r2, #0]
    fcb4:	f44f 4110 	mov.w	r1, #36864	; 0x9000
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    fcb8:	6b13      	ldr	r3, [r2, #48]	; 0x30
    fcba:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    fcbe:	f3c0 02c1 	ubfx	r2, r0, #3, #2
    fcc2:	f2c0 31d0 	movt	r1, #976	; 0x3d0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    fcc6:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    fcca:	40d1      	lsrs	r1, r2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    fccc:	ee06 3a10 	vmov	s12, r3
    fcd0:	ee05 1a90 	vmov	s11, r1
    fcd4:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
    fcd8:	eef8 5ae5 	vcvt.f32.s32	s11, s11
    fcdc:	ee36 6a07 	vadd.f32	s12, s12, s14
    fce0:	ee85 7aa6 	vdiv.f32	s14, s11, s13
    fce4:	ee76 7a27 	vadd.f32	s15, s12, s15
    fce8:	ee67 7a27 	vmul.f32	s15, s14, s15
    fcec:	e7b9      	b.n	fc62 <HAL_RCC_GetHCLKFreq+0xea>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    fcee:	f44f 5110 	mov.w	r1, #9216	; 0x2400
    fcf2:	6b13      	ldr	r3, [r2, #48]	; 0x30
    fcf4:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    fcf8:	f6c4 4174 	movt	r1, #19572	; 0x4c74
    fcfc:	e7a1      	b.n	fc42 <HAL_RCC_GetHCLKFreq+0xca>
    fcfe:	bf00      	nop

0000fd00 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
    fd00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    fd02:	6803      	ldr	r3, [r0, #0]
{
    fd04:	4604      	mov	r4, r0
    fd06:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    fd08:	3b01      	subs	r3, #1
    fd0a:	2b3e      	cmp	r3, #62	; 0x3e
    fd0c:	f200 80a6 	bhi.w	fe5c <RCCEx_PLL2_Config+0x15c>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
    fd10:	6863      	ldr	r3, [r4, #4]
    fd12:	3b04      	subs	r3, #4
    fd14:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    fd18:	f200 80ae 	bhi.w	fe78 <RCCEx_PLL2_Config+0x178>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
    fd1c:	68a3      	ldr	r3, [r4, #8]
    fd1e:	3b01      	subs	r3, #1
    fd20:	2b7f      	cmp	r3, #127	; 0x7f
    fd22:	f200 80b6 	bhi.w	fe92 <RCCEx_PLL2_Config+0x192>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
    fd26:	6923      	ldr	r3, [r4, #16]
    fd28:	3b01      	subs	r3, #1
    fd2a:	2b7f      	cmp	r3, #127	; 0x7f
    fd2c:	f200 80be 	bhi.w	feac <RCCEx_PLL2_Config+0x1ac>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
    fd30:	68e3      	ldr	r3, [r4, #12]
    fd32:	3b01      	subs	r3, #1
    fd34:	2b7f      	cmp	r3, #127	; 0x7f
    fd36:	f200 80c6 	bhi.w	fec6 <RCCEx_PLL2_Config+0x1c6>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
    fd3a:	6963      	ldr	r3, [r4, #20]
    fd3c:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
    fd40:	f040 80ce 	bne.w	fee0 <RCCEx_PLL2_Config+0x1e0>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
    fd44:	69a3      	ldr	r3, [r4, #24]
    fd46:	f033 0320 	bics.w	r3, r3, #32
    fd4a:	f040 80d6 	bne.w	fefa <RCCEx_PLL2_Config+0x1fa>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
    fd4e:	69e3      	ldr	r3, [r4, #28]
    fd50:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    fd54:	d279      	bcs.n	fe4a <RCCEx_PLL2_Config+0x14a>

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
    fd56:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    fd5a:	f6c5 0302 	movt	r3, #22530	; 0x5802
    fd5e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    fd60:	f002 0203 	and.w	r2, r2, #3
    fd64:	2a03      	cmp	r2, #3
    fd66:	d06c      	beq.n	fe42 <RCCEx_PLL2_Config+0x142>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
    fd68:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    fd6a:	461d      	mov	r5, r3
    __HAL_RCC_PLL2_DISABLE();
    fd6c:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
    fd70:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    fd72:	f7f8 fb65 	bl	8440 <HAL_GetTick>
    fd76:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    fd78:	e004      	b.n	fd84 <RCCEx_PLL2_Config+0x84>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    fd7a:	f7f8 fb61 	bl	8440 <HAL_GetTick>
    fd7e:	1bc0      	subs	r0, r0, r7
    fd80:	2802      	cmp	r0, #2
    fd82:	d860      	bhi.n	fe46 <RCCEx_PLL2_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    fd84:	682b      	ldr	r3, [r5, #0]
    fd86:	011a      	lsls	r2, r3, #4
    fd88:	d4f7      	bmi.n	fd7a <RCCEx_PLL2_Config+0x7a>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    fd8a:	6aab      	ldr	r3, [r5, #40]	; 0x28

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    fd8c:	2107      	movs	r1, #7
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    fd8e:	6822      	ldr	r2, [r4, #0]
    fd90:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    fd94:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    fd98:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    fd9c:	62ab      	str	r3, [r5, #40]	; 0x28
    fd9e:	6867      	ldr	r7, [r4, #4]
    fda0:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    fda4:	3f01      	subs	r7, #1
    fda6:	1e50      	subs	r0, r2, #1
    fda8:	3b01      	subs	r3, #1
    fdaa:	6922      	ldr	r2, [r4, #16]
    fdac:	f3c7 0708 	ubfx	r7, r7, #0, #9
    fdb0:	025b      	lsls	r3, r3, #9
    fdb2:	0400      	lsls	r0, r0, #16
    fdb4:	3a01      	subs	r2, #1
    fdb6:	b29b      	uxth	r3, r3
    fdb8:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    fdbc:	0612      	lsls	r2, r2, #24
    fdbe:	4303      	orrs	r3, r0
    fdc0:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    fdc4:	433b      	orrs	r3, r7
    fdc6:	4313      	orrs	r3, r2
    fdc8:	63ab      	str	r3, [r5, #56]	; 0x38
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
    fdca:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fdcc:	6962      	ldr	r2, [r4, #20]
    fdce:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    fdd2:	4313      	orrs	r3, r2
    fdd4:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
    fdd6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fdd8:	69a2      	ldr	r2, [r4, #24]
    fdda:	f023 0320 	bic.w	r3, r3, #32
    fdde:	4313      	orrs	r3, r2
    fde0:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_DISABLE();
    fde2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fde4:	f023 0310 	bic.w	r3, r3, #16
    fde8:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    fdea:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    fdec:	69e3      	ldr	r3, [r4, #28]
    fdee:	4011      	ands	r1, r2
    fdf0:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    fdf4:	63e9      	str	r1, [r5, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
    fdf6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fdf8:	f043 0310 	orr.w	r3, r3, #16
    fdfc:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
    fdfe:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
    fe00:	2e00      	cmp	r6, #0
    fe02:	f000 8083 	beq.w	ff0c <RCCEx_PLL2_Config+0x20c>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
    fe06:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
    fe08:	bf0c      	ite	eq
    fe0a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
    fe0e:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
    fe12:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
    fe14:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    fe18:	f6c5 0302 	movt	r3, #22530	; 0x5802
    fe1c:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    fe1e:	461c      	mov	r4, r3
    __HAL_RCC_PLL2_ENABLE();
    fe20:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    fe24:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    fe26:	f7f8 fb0b 	bl	8440 <HAL_GetTick>
    fe2a:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    fe2c:	e004      	b.n	fe38 <RCCEx_PLL2_Config+0x138>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    fe2e:	f7f8 fb07 	bl	8440 <HAL_GetTick>
    fe32:	1b40      	subs	r0, r0, r5
    fe34:	2802      	cmp	r0, #2
    fe36:	d806      	bhi.n	fe46 <RCCEx_PLL2_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    fe38:	6823      	ldr	r3, [r4, #0]
    fe3a:	011b      	lsls	r3, r3, #4
    fe3c:	d5f7      	bpl.n	fe2e <RCCEx_PLL2_Config+0x12e>
    }

  }


  return status;
    fe3e:	2000      	movs	r0, #0
}
    fe40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
    fe42:	2001      	movs	r0, #1
}
    fe44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
    fe46:	2003      	movs	r0, #3
}
    fe48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
    fe4a:	f643 1050 	movw	r0, #14672	; 0x3950
    fe4e:	f640 4186 	movw	r1, #3206	; 0xc86
    fe52:	f2c0 0003 	movt	r0, #3
    fe56:	f00b f92b 	bl	1b0b0 <assert_failed>
    fe5a:	e77c      	b.n	fd56 <RCCEx_PLL2_Config+0x56>
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    fe5c:	f643 1050 	movw	r0, #14672	; 0x3950
    fe60:	f640 417f 	movw	r1, #3199	; 0xc7f
    fe64:	f2c0 0003 	movt	r0, #3
    fe68:	f00b f922 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
    fe6c:	6863      	ldr	r3, [r4, #4]
    fe6e:	3b04      	subs	r3, #4
    fe70:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    fe74:	f67f af52 	bls.w	fd1c <RCCEx_PLL2_Config+0x1c>
    fe78:	f643 1050 	movw	r0, #14672	; 0x3950
    fe7c:	f44f 6148 	mov.w	r1, #3200	; 0xc80
    fe80:	f2c0 0003 	movt	r0, #3
    fe84:	f00b f914 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
    fe88:	68a3      	ldr	r3, [r4, #8]
    fe8a:	3b01      	subs	r3, #1
    fe8c:	2b7f      	cmp	r3, #127	; 0x7f
    fe8e:	f67f af4a 	bls.w	fd26 <RCCEx_PLL2_Config+0x26>
    fe92:	f643 1050 	movw	r0, #14672	; 0x3950
    fe96:	f640 4181 	movw	r1, #3201	; 0xc81
    fe9a:	f2c0 0003 	movt	r0, #3
    fe9e:	f00b f907 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
    fea2:	6923      	ldr	r3, [r4, #16]
    fea4:	3b01      	subs	r3, #1
    fea6:	2b7f      	cmp	r3, #127	; 0x7f
    fea8:	f67f af42 	bls.w	fd30 <RCCEx_PLL2_Config+0x30>
    feac:	f643 1050 	movw	r0, #14672	; 0x3950
    feb0:	f640 4182 	movw	r1, #3202	; 0xc82
    feb4:	f2c0 0003 	movt	r0, #3
    feb8:	f00b f8fa 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
    febc:	68e3      	ldr	r3, [r4, #12]
    febe:	3b01      	subs	r3, #1
    fec0:	2b7f      	cmp	r3, #127	; 0x7f
    fec2:	f67f af3a 	bls.w	fd3a <RCCEx_PLL2_Config+0x3a>
    fec6:	f643 1050 	movw	r0, #14672	; 0x3950
    feca:	f640 4183 	movw	r1, #3203	; 0xc83
    fece:	f2c0 0003 	movt	r0, #3
    fed2:	f00b f8ed 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
    fed6:	6963      	ldr	r3, [r4, #20]
    fed8:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
    fedc:	f43f af32 	beq.w	fd44 <RCCEx_PLL2_Config+0x44>
    fee0:	f643 1050 	movw	r0, #14672	; 0x3950
    fee4:	f640 4184 	movw	r1, #3204	; 0xc84
    fee8:	f2c0 0003 	movt	r0, #3
    feec:	f00b f8e0 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
    fef0:	69a3      	ldr	r3, [r4, #24]
    fef2:	f033 0320 	bics.w	r3, r3, #32
    fef6:	f43f af2a 	beq.w	fd4e <RCCEx_PLL2_Config+0x4e>
    fefa:	f643 1050 	movw	r0, #14672	; 0x3950
    fefe:	f640 4185 	movw	r1, #3205	; 0xc85
    ff02:	f2c0 0003 	movt	r0, #3
    ff06:	f00b f8d3 	bl	1b0b0 <assert_failed>
    ff0a:	e720      	b.n	fd4e <RCCEx_PLL2_Config+0x4e>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
    ff0c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    ff10:	62eb      	str	r3, [r5, #44]	; 0x2c
    ff12:	e77f      	b.n	fe14 <RCCEx_PLL2_Config+0x114>

0000ff14 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
    ff14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    ff16:	6803      	ldr	r3, [r0, #0]
{
    ff18:	4604      	mov	r4, r0
    ff1a:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    ff1c:	3b01      	subs	r3, #1
    ff1e:	2b3e      	cmp	r3, #62	; 0x3e
    ff20:	f200 80a6 	bhi.w	10070 <RCCEx_PLL3_Config+0x15c>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
    ff24:	6863      	ldr	r3, [r4, #4]
    ff26:	3b04      	subs	r3, #4
    ff28:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    ff2c:	f200 80ae 	bhi.w	1008c <RCCEx_PLL3_Config+0x178>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
    ff30:	68a3      	ldr	r3, [r4, #8]
    ff32:	3b01      	subs	r3, #1
    ff34:	2b7f      	cmp	r3, #127	; 0x7f
    ff36:	f200 80b6 	bhi.w	100a6 <RCCEx_PLL3_Config+0x192>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
    ff3a:	6923      	ldr	r3, [r4, #16]
    ff3c:	3b01      	subs	r3, #1
    ff3e:	2b7f      	cmp	r3, #127	; 0x7f
    ff40:	f200 80be 	bhi.w	100c0 <RCCEx_PLL3_Config+0x1ac>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
    ff44:	68e3      	ldr	r3, [r4, #12]
    ff46:	3b01      	subs	r3, #1
    ff48:	2b7f      	cmp	r3, #127	; 0x7f
    ff4a:	f200 80c6 	bhi.w	100da <RCCEx_PLL3_Config+0x1c6>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
    ff4e:	6963      	ldr	r3, [r4, #20]
    ff50:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    ff54:	f040 80ce 	bne.w	100f4 <RCCEx_PLL3_Config+0x1e0>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
    ff58:	69a3      	ldr	r3, [r4, #24]
    ff5a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    ff5e:	f040 80d6 	bne.w	1010e <RCCEx_PLL3_Config+0x1fa>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
    ff62:	69e3      	ldr	r3, [r4, #28]
    ff64:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    ff68:	d279      	bcs.n	1005e <RCCEx_PLL3_Config+0x14a>

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
    ff6a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    ff6e:	f6c5 0302 	movt	r3, #22530	; 0x5802
    ff72:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    ff74:	f002 0203 	and.w	r2, r2, #3
    ff78:	2a03      	cmp	r2, #3
    ff7a:	d06c      	beq.n	10056 <RCCEx_PLL3_Config+0x142>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
    ff7c:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    ff7e:	461d      	mov	r5, r3
    __HAL_RCC_PLL3_DISABLE();
    ff80:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
    ff84:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    ff86:	f7f8 fa5b 	bl	8440 <HAL_GetTick>
    ff8a:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    ff8c:	e004      	b.n	ff98 <RCCEx_PLL3_Config+0x84>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
    ff8e:	f7f8 fa57 	bl	8440 <HAL_GetTick>
    ff92:	1bc0      	subs	r0, r0, r7
    ff94:	2802      	cmp	r0, #2
    ff96:	d860      	bhi.n	1005a <RCCEx_PLL3_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    ff98:	682b      	ldr	r3, [r5, #0]
    ff9a:	009a      	lsls	r2, r3, #2
    ff9c:	d4f7      	bmi.n	ff8e <RCCEx_PLL3_Config+0x7a>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    ff9e:	6aab      	ldr	r3, [r5, #40]	; 0x28

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    ffa0:	2107      	movs	r1, #7
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    ffa2:	6822      	ldr	r2, [r4, #0]
    ffa4:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    ffa8:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    ffac:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    ffb0:	62ab      	str	r3, [r5, #40]	; 0x28
    ffb2:	6867      	ldr	r7, [r4, #4]
    ffb4:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    ffb8:	3f01      	subs	r7, #1
    ffba:	1e50      	subs	r0, r2, #1
    ffbc:	3b01      	subs	r3, #1
    ffbe:	6922      	ldr	r2, [r4, #16]
    ffc0:	f3c7 0708 	ubfx	r7, r7, #0, #9
    ffc4:	025b      	lsls	r3, r3, #9
    ffc6:	0400      	lsls	r0, r0, #16
    ffc8:	3a01      	subs	r2, #1
    ffca:	b29b      	uxth	r3, r3
    ffcc:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    ffd0:	0612      	lsls	r2, r2, #24
    ffd2:	4303      	orrs	r3, r0
    ffd4:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    ffd8:	433b      	orrs	r3, r7
    ffda:	4313      	orrs	r3, r2
    ffdc:	642b      	str	r3, [r5, #64]	; 0x40
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
    ffde:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ffe0:	6962      	ldr	r2, [r4, #20]
    ffe2:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
    ffe6:	4313      	orrs	r3, r2
    ffe8:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
    ffea:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ffec:	69a2      	ldr	r2, [r4, #24]
    ffee:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    fff2:	4313      	orrs	r3, r2
    fff4:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_DISABLE();
    fff6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fff8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    fffc:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    fffe:	6c6a      	ldr	r2, [r5, #68]	; 0x44
   10000:	69e3      	ldr	r3, [r4, #28]
   10002:	4011      	ands	r1, r2
   10004:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
   10008:	6469      	str	r1, [r5, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
   1000a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1000c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10010:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
   10012:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
   10014:	2e00      	cmp	r6, #0
   10016:	f000 8083 	beq.w	10120 <RCCEx_PLL3_Config+0x20c>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
   1001a:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
   1001c:	bf0c      	ite	eq
   1001e:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
   10022:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
   10026:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
   10028:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   1002c:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10030:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
   10032:	461c      	mov	r4, r3
    __HAL_RCC_PLL3_ENABLE();
   10034:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   10038:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
   1003a:	f7f8 fa01 	bl	8440 <HAL_GetTick>
   1003e:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
   10040:	e004      	b.n	1004c <RCCEx_PLL3_Config+0x138>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
   10042:	f7f8 f9fd 	bl	8440 <HAL_GetTick>
   10046:	1b40      	subs	r0, r0, r5
   10048:	2802      	cmp	r0, #2
   1004a:	d806      	bhi.n	1005a <RCCEx_PLL3_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
   1004c:	6823      	ldr	r3, [r4, #0]
   1004e:	009b      	lsls	r3, r3, #2
   10050:	d5f7      	bpl.n	10042 <RCCEx_PLL3_Config+0x12e>
    }

  }


  return status;
   10052:	2000      	movs	r0, #0
}
   10054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
   10056:	2001      	movs	r0, #1
}
   10058:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
   1005a:	2003      	movs	r0, #3
}
   1005c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
   1005e:	f643 1050 	movw	r0, #14672	; 0x3950
   10062:	f640 41ee 	movw	r1, #3310	; 0xcee
   10066:	f2c0 0003 	movt	r0, #3
   1006a:	f00b f821 	bl	1b0b0 <assert_failed>
   1006e:	e77c      	b.n	ff6a <RCCEx_PLL3_Config+0x56>
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
   10070:	f643 1050 	movw	r0, #14672	; 0x3950
   10074:	f640 41e7 	movw	r1, #3303	; 0xce7
   10078:	f2c0 0003 	movt	r0, #3
   1007c:	f00b f818 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
   10080:	6863      	ldr	r3, [r4, #4]
   10082:	3b04      	subs	r3, #4
   10084:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
   10088:	f67f af52 	bls.w	ff30 <RCCEx_PLL3_Config+0x1c>
   1008c:	f643 1050 	movw	r0, #14672	; 0x3950
   10090:	f640 41e8 	movw	r1, #3304	; 0xce8
   10094:	f2c0 0003 	movt	r0, #3
   10098:	f00b f80a 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
   1009c:	68a3      	ldr	r3, [r4, #8]
   1009e:	3b01      	subs	r3, #1
   100a0:	2b7f      	cmp	r3, #127	; 0x7f
   100a2:	f67f af4a 	bls.w	ff3a <RCCEx_PLL3_Config+0x26>
   100a6:	f643 1050 	movw	r0, #14672	; 0x3950
   100aa:	f640 41e9 	movw	r1, #3305	; 0xce9
   100ae:	f2c0 0003 	movt	r0, #3
   100b2:	f00a fffd 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
   100b6:	6923      	ldr	r3, [r4, #16]
   100b8:	3b01      	subs	r3, #1
   100ba:	2b7f      	cmp	r3, #127	; 0x7f
   100bc:	f67f af42 	bls.w	ff44 <RCCEx_PLL3_Config+0x30>
   100c0:	f643 1050 	movw	r0, #14672	; 0x3950
   100c4:	f640 41ea 	movw	r1, #3306	; 0xcea
   100c8:	f2c0 0003 	movt	r0, #3
   100cc:	f00a fff0 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
   100d0:	68e3      	ldr	r3, [r4, #12]
   100d2:	3b01      	subs	r3, #1
   100d4:	2b7f      	cmp	r3, #127	; 0x7f
   100d6:	f67f af3a 	bls.w	ff4e <RCCEx_PLL3_Config+0x3a>
   100da:	f643 1050 	movw	r0, #14672	; 0x3950
   100de:	f640 41eb 	movw	r1, #3307	; 0xceb
   100e2:	f2c0 0003 	movt	r0, #3
   100e6:	f00a ffe3 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
   100ea:	6963      	ldr	r3, [r4, #20]
   100ec:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
   100f0:	f43f af32 	beq.w	ff58 <RCCEx_PLL3_Config+0x44>
   100f4:	f643 1050 	movw	r0, #14672	; 0x3950
   100f8:	f640 41ec 	movw	r1, #3308	; 0xcec
   100fc:	f2c0 0003 	movt	r0, #3
   10100:	f00a ffd6 	bl	1b0b0 <assert_failed>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
   10104:	69a3      	ldr	r3, [r4, #24]
   10106:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1010a:	f43f af2a 	beq.w	ff62 <RCCEx_PLL3_Config+0x4e>
   1010e:	f643 1050 	movw	r0, #14672	; 0x3950
   10112:	f640 41ed 	movw	r1, #3309	; 0xced
   10116:	f2c0 0003 	movt	r0, #3
   1011a:	f00a ffc9 	bl	1b0b0 <assert_failed>
   1011e:	e720      	b.n	ff62 <RCCEx_PLL3_Config+0x4e>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
   10120:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   10124:	62eb      	str	r3, [r5, #44]	; 0x2c
   10126:	e77f      	b.n	10028 <RCCEx_PLL3_Config+0x114>

00010128 <HAL_RCCEx_PeriphCLKConfig>:
{
   10128:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
   1012c:	6803      	ldr	r3, [r0, #0]
{
   1012e:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
   10130:	f013 6600 	ands.w	r6, r3, #134217728	; 0x8000000
   10134:	d019      	beq.n	1016a <HAL_RCCEx_PeriphCLKConfig+0x42>
    switch(PeriphClkInit->SpdifrxClockSelection)
   10136:	6e42      	ldr	r2, [r0, #100]	; 0x64
   10138:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
   1013c:	f000 85a7 	beq.w	10c8e <HAL_RCCEx_PeriphCLKConfig+0xb66>
   10140:	f240 86bb 	bls.w	10eba <HAL_RCCEx_PeriphCLKConfig+0xd92>
   10144:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
   10148:	f000 85e1 	beq.w	10d0e <HAL_RCCEx_PeriphCLKConfig+0xbe6>
   1014c:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
   10150:	f040 86dc 	bne.w	10f0c <HAL_RCCEx_PeriphCLKConfig+0xde4>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
   10154:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   10158:	2600      	movs	r6, #0
   1015a:	f6c5 0102 	movt	r1, #22530	; 0x5802
   1015e:	6d0b      	ldr	r3, [r1, #80]	; 0x50
   10160:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
   10164:	431a      	orrs	r2, r3
   10166:	650a      	str	r2, [r1, #80]	; 0x50
   10168:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
   1016a:	05dd      	lsls	r5, r3, #23
   1016c:	d50a      	bpl.n	10184 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    switch(PeriphClkInit->Sai1ClockSelection)
   1016e:	6d62      	ldr	r2, [r4, #84]	; 0x54
   10170:	2a04      	cmp	r2, #4
   10172:	d806      	bhi.n	10182 <HAL_RCCEx_PeriphCLKConfig+0x5a>
   10174:	e8df f012 	tbh	[pc, r2, lsl #1]
   10178:	0537051f 	.word	0x0537051f
   1017c:	04fb053d 	.word	0x04fb053d
   10180:	04fb      	.short	0x04fb
      ret = HAL_ERROR;
   10182:	2601      	movs	r6, #1
   10184:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
   10186:	0598      	lsls	r0, r3, #22
   10188:	d515      	bpl.n	101b6 <HAL_RCCEx_PeriphCLKConfig+0x8e>
    switch(PeriphClkInit->Sai23ClockSelection)
   1018a:	6da2      	ldr	r2, [r4, #88]	; 0x58
   1018c:	2a80      	cmp	r2, #128	; 0x80
   1018e:	f000 8589 	beq.w	10ca4 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
   10192:	f200 8687 	bhi.w	10ea4 <HAL_RCCEx_PeriphCLKConfig+0xd7c>
   10196:	2a00      	cmp	r2, #0
   10198:	f000 85bf 	beq.w	10d1a <HAL_RCCEx_PeriphCLKConfig+0xbf2>
   1019c:	2a40      	cmp	r2, #64	; 0x40
   1019e:	f040 8688 	bne.w	10eb2 <HAL_RCCEx_PeriphCLKConfig+0xd8a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   101a2:	2100      	movs	r1, #0
   101a4:	1d20      	adds	r0, r4, #4
   101a6:	f7ff fdab 	bl	fd00 <RCCEx_PLL2_Config>
   101aa:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   101ac:	2d00      	cmp	r5, #0
   101ae:	f000 8582 	beq.w	10cb6 <HAL_RCCEx_PeriphCLKConfig+0xb8e>
   101b2:	6823      	ldr	r3, [r4, #0]
   101b4:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
   101b6:	0559      	lsls	r1, r3, #21
   101b8:	d518      	bpl.n	101ec <HAL_RCCEx_PeriphCLKConfig+0xc4>
    switch(PeriphClkInit->Sai4AClockSelection)
   101ba:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
   101be:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
   101c2:	f000 8585 	beq.w	10cd0 <HAL_RCCEx_PeriphCLKConfig+0xba8>
   101c6:	f200 8661 	bhi.w	10e8c <HAL_RCCEx_PeriphCLKConfig+0xd64>
   101ca:	2a00      	cmp	r2, #0
   101cc:	f000 85b9 	beq.w	10d42 <HAL_RCCEx_PeriphCLKConfig+0xc1a>
   101d0:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
   101d4:	f040 8662 	bne.w	10e9c <HAL_RCCEx_PeriphCLKConfig+0xd74>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   101d8:	2100      	movs	r1, #0
   101da:	1d20      	adds	r0, r4, #4
   101dc:	f7ff fd90 	bl	fd00 <RCCEx_PLL2_Config>
   101e0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   101e2:	2d00      	cmp	r5, #0
   101e4:	f000 857d 	beq.w	10ce2 <HAL_RCCEx_PeriphCLKConfig+0xbba>
   101e8:	6823      	ldr	r3, [r4, #0]
   101ea:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
   101ec:	051a      	lsls	r2, r3, #20
   101ee:	d518      	bpl.n	10222 <HAL_RCCEx_PeriphCLKConfig+0xfa>
    switch(PeriphClkInit->Sai4BClockSelection)
   101f0:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
   101f4:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
   101f8:	f000 8581 	beq.w	10cfe <HAL_RCCEx_PeriphCLKConfig+0xbd6>
   101fc:	f200 8675 	bhi.w	10eea <HAL_RCCEx_PeriphCLKConfig+0xdc2>
   10200:	2a00      	cmp	r2, #0
   10202:	f000 852b 	beq.w	10c5c <HAL_RCCEx_PeriphCLKConfig+0xb34>
   10206:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
   1020a:	f040 8676 	bne.w	10efa <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   1020e:	2100      	movs	r1, #0
   10210:	1d20      	adds	r0, r4, #4
   10212:	f7ff fd75 	bl	fd00 <RCCEx_PLL2_Config>
   10216:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10218:	2d00      	cmp	r5, #0
   1021a:	f000 852a 	beq.w	10c72 <HAL_RCCEx_PeriphCLKConfig+0xb4a>
   1021e:	6823      	ldr	r3, [r4, #0]
   10220:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
   10222:	019f      	lsls	r7, r3, #6
   10224:	d50d      	bpl.n	10242 <HAL_RCCEx_PeriphCLKConfig+0x11a>
    switch(PeriphClkInit->QspiClockSelection)
   10226:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   10228:	2a10      	cmp	r2, #16
   1022a:	f000 845f 	beq.w	10aec <HAL_RCCEx_PeriphCLKConfig+0x9c4>
   1022e:	f240 8668 	bls.w	10f02 <HAL_RCCEx_PeriphCLKConfig+0xdda>
   10232:	2a20      	cmp	r2, #32
   10234:	f000 8467 	beq.w	10b06 <HAL_RCCEx_PeriphCLKConfig+0x9de>
   10238:	2a30      	cmp	r2, #48	; 0x30
   1023a:	f000 845f 	beq.w	10afc <HAL_RCCEx_PeriphCLKConfig+0x9d4>
      ret = HAL_ERROR;
   1023e:	2601      	movs	r6, #1
   10240:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
   10242:	04d8      	lsls	r0, r3, #19
   10244:	d517      	bpl.n	10276 <HAL_RCCEx_PeriphCLKConfig+0x14e>
    switch(PeriphClkInit->Spi123ClockSelection)
   10246:	6de2      	ldr	r2, [r4, #92]	; 0x5c
   10248:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
   1024c:	f000 84f0 	beq.w	10c30 <HAL_RCCEx_PeriphCLKConfig+0xb08>
   10250:	f200 863f 	bhi.w	10ed2 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
   10254:	2a00      	cmp	r2, #0
   10256:	f000 856a 	beq.w	10d2e <HAL_RCCEx_PeriphCLKConfig+0xc06>
   1025a:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
   1025e:	f040 8640 	bne.w	10ee2 <HAL_RCCEx_PeriphCLKConfig+0xdba>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   10262:	2100      	movs	r1, #0
   10264:	1d20      	adds	r0, r4, #4
   10266:	f7ff fd4b 	bl	fd00 <RCCEx_PLL2_Config>
   1026a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   1026c:	2d00      	cmp	r5, #0
   1026e:	f000 84e8 	beq.w	10c42 <HAL_RCCEx_PeriphCLKConfig+0xb1a>
   10272:	6823      	ldr	r3, [r4, #0]
   10274:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
   10276:	0499      	lsls	r1, r3, #18
   10278:	d51e      	bpl.n	102b8 <HAL_RCCEx_PeriphCLKConfig+0x190>
    switch(PeriphClkInit->Spi45ClockSelection)
   1027a:	6e22      	ldr	r2, [r4, #96]	; 0x60
   1027c:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
   10280:	f000 8455 	beq.w	10b2e <HAL_RCCEx_PeriphCLKConfig+0xa06>
   10284:	f200 85c2 	bhi.w	10e0c <HAL_RCCEx_PeriphCLKConfig+0xce4>
   10288:	b142      	cbz	r2, 1029c <HAL_RCCEx_PeriphCLKConfig+0x174>
   1028a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
   1028e:	f040 85c9 	bne.w	10e24 <HAL_RCCEx_PeriphCLKConfig+0xcfc>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
   10292:	2101      	movs	r1, #1
   10294:	1d20      	adds	r0, r4, #4
   10296:	f7ff fd33 	bl	fd00 <RCCEx_PLL2_Config>
   1029a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   1029c:	2d00      	cmp	r5, #0
   1029e:	f040 8389 	bne.w	109b4 <HAL_RCCEx_PeriphCLKConfig+0x88c>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
   102a2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   102a6:	6e21      	ldr	r1, [r4, #96]	; 0x60
   102a8:	f6c5 0202 	movt	r2, #22530	; 0x5802
   102ac:	6d13      	ldr	r3, [r2, #80]	; 0x50
   102ae:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
   102b2:	430b      	orrs	r3, r1
   102b4:	6513      	str	r3, [r2, #80]	; 0x50
   102b6:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
   102b8:	045a      	lsls	r2, r3, #17
   102ba:	d520      	bpl.n	102fe <HAL_RCCEx_PeriphCLKConfig+0x1d6>
    switch(PeriphClkInit->Spi6ClockSelection)
   102bc:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
   102c0:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   102c4:	f000 843d 	beq.w	10b42 <HAL_RCCEx_PeriphCLKConfig+0xa1a>
   102c8:	f200 85c0 	bhi.w	10e4c <HAL_RCCEx_PeriphCLKConfig+0xd24>
   102cc:	b142      	cbz	r2, 102e0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
   102ce:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
   102d2:	f040 85c7 	bne.w	10e64 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
   102d6:	2101      	movs	r1, #1
   102d8:	1d20      	adds	r0, r4, #4
   102da:	f7ff fd11 	bl	fd00 <RCCEx_PLL2_Config>
   102de:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   102e0:	2d00      	cmp	r5, #0
   102e2:	f040 8364 	bne.w	109ae <HAL_RCCEx_PeriphCLKConfig+0x886>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
   102e6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   102ea:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
   102ee:	f6c5 0202 	movt	r2, #22530	; 0x5802
   102f2:	6d93      	ldr	r3, [r2, #88]	; 0x58
   102f4:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
   102f8:	430b      	orrs	r3, r1
   102fa:	6593      	str	r3, [r2, #88]	; 0x58
   102fc:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
   102fe:	041f      	lsls	r7, r3, #16
   10300:	d50d      	bpl.n	1031e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    switch(PeriphClkInit->FdcanClockSelection)
   10302:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
   10304:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
   10308:	f000 8425 	beq.w	10b56 <HAL_RCCEx_PeriphCLKConfig+0xa2e>
   1030c:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   10310:	f000 82db 	beq.w	108ca <HAL_RCCEx_PeriphCLKConfig+0x7a2>
   10314:	2a00      	cmp	r2, #0
   10316:	f000 82dd 	beq.w	108d4 <HAL_RCCEx_PeriphCLKConfig+0x7ac>
      ret = HAL_ERROR;
   1031a:	2601      	movs	r6, #1
   1031c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
   1031e:	01d8      	lsls	r0, r3, #7
   10320:	d50a      	bpl.n	10338 <HAL_RCCEx_PeriphCLKConfig+0x210>
    switch(PeriphClkInit->FmcClockSelection)
   10322:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10324:	2a03      	cmp	r2, #3
   10326:	d805      	bhi.n	10334 <HAL_RCCEx_PeriphCLKConfig+0x20c>
   10328:	e8df f012 	tbh	[pc, r2, lsl #1]
   1032c:	038d02ac 	.word	0x038d02ac
   10330:	02ac02a7 	.word	0x02ac02a7
      ret = HAL_ERROR;
   10334:	2601      	movs	r6, #1
   10336:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
   10338:	0259      	lsls	r1, r3, #9
   1033a:	f140 80e3 	bpl.w	10504 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
   1033e:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
   10342:	f44f 7740 	mov.w	r7, #768	; 0x300
   10346:	f44f 4c86 	mov.w	ip, #17152	; 0x4300
   1034a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   1034e:	bf18      	it	ne
   10350:	f5b2 7f00 	cmpne.w	r2, #512	; 0x200
   10354:	f422 41a0 	bic.w	r1, r2, #20480	; 0x5000
   10358:	f422 4010 	bic.w	r0, r2, #36864	; 0x9000
   1035c:	f422 3e88 	bic.w	lr, r2, #69632	; 0x11000
   10360:	bf14      	ite	ne
   10362:	2301      	movne	r3, #1
   10364:	2300      	moveq	r3, #0
   10366:	f2c0 0701 	movt	r7, #1
   1036a:	f2c0 0c01 	movt	ip, #1
   1036e:	f5b1 5f0c 	cmp.w	r1, #8960	; 0x2300
   10372:	bf0c      	ite	eq
   10374:	2300      	moveq	r3, #0
   10376:	f003 0301 	andne.w	r3, r3, #1
   1037a:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
   1037e:	f5b0 4f86 	cmp.w	r0, #17152	; 0x4300
   10382:	bf0c      	ite	eq
   10384:	2300      	moveq	r3, #0
   10386:	f003 0301 	andne.w	r3, r3, #1
   1038a:	f44f 4003 	mov.w	r0, #33536	; 0x8300
   1038e:	f5b1 4f03 	cmp.w	r1, #33536	; 0x8300
   10392:	bf0c      	ite	eq
   10394:	2300      	moveq	r3, #0
   10396:	f003 0301 	andne.w	r3, r3, #1
   1039a:	f2c0 0001 	movt	r0, #1
   1039e:	f5be 4f63 	cmp.w	lr, #58112	; 0xe300
   103a2:	bf0c      	ite	eq
   103a4:	2300      	moveq	r3, #0
   103a6:	f003 0301 	andne.w	r3, r3, #1
   103aa:	42b9      	cmp	r1, r7
   103ac:	bf0c      	ite	eq
   103ae:	2300      	moveq	r3, #0
   103b0:	f003 0301 	andne.w	r3, r3, #1
   103b4:	f44f 4743 	mov.w	r7, #49920	; 0xc300
   103b8:	4561      	cmp	r1, ip
   103ba:	bf0c      	ite	eq
   103bc:	2300      	moveq	r3, #0
   103be:	f003 0301 	andne.w	r3, r3, #1
   103c2:	f2c0 0701 	movt	r7, #1
   103c6:	f422 3c04 	bic.w	ip, r2, #135168	; 0x21000
   103ca:	4281      	cmp	r1, r0
   103cc:	bf0c      	ite	eq
   103ce:	2300      	moveq	r3, #0
   103d0:	f003 0301 	andne.w	r3, r3, #1
   103d4:	f44f 7040 	mov.w	r0, #768	; 0x300
   103d8:	45bc      	cmp	ip, r7
   103da:	bf0c      	ite	eq
   103dc:	2300      	moveq	r3, #0
   103de:	f003 0301 	andne.w	r3, r3, #1
   103e2:	f2c0 0002 	movt	r0, #2
   103e6:	f44f 4c86 	mov.w	ip, #17152	; 0x4300
   103ea:	f44f 4703 	mov.w	r7, #33536	; 0x8300
   103ee:	4281      	cmp	r1, r0
   103f0:	bf0c      	ite	eq
   103f2:	2300      	moveq	r3, #0
   103f4:	f003 0301 	andne.w	r3, r3, #1
   103f8:	f44f 4043 	mov.w	r0, #49920	; 0xc300
   103fc:	f2c0 0c02 	movt	ip, #2
   10400:	f2c0 0702 	movt	r7, #2
   10404:	f2c0 0002 	movt	r0, #2
   10408:	4561      	cmp	r1, ip
   1040a:	bf0c      	ite	eq
   1040c:	2300      	moveq	r3, #0
   1040e:	f003 0301 	andne.w	r3, r3, #1
   10412:	f44f 7c40 	mov.w	ip, #768	; 0x300
   10416:	42b9      	cmp	r1, r7
   10418:	bf0c      	ite	eq
   1041a:	2300      	moveq	r3, #0
   1041c:	f003 0301 	andne.w	r3, r3, #1
   10420:	f2c0 0c03 	movt	ip, #3
   10424:	f44f 4786 	mov.w	r7, #17152	; 0x4300
   10428:	4281      	cmp	r1, r0
   1042a:	bf0c      	ite	eq
   1042c:	2300      	moveq	r3, #0
   1042e:	f003 0301 	andne.w	r3, r3, #1
   10432:	f44f 4003 	mov.w	r0, #33536	; 0x8300
   10436:	f2c0 0703 	movt	r7, #3
   1043a:	4561      	cmp	r1, ip
   1043c:	bf0c      	ite	eq
   1043e:	2300      	moveq	r3, #0
   10440:	f003 0301 	andne.w	r3, r3, #1
   10444:	f2c0 0003 	movt	r0, #3
   10448:	42b9      	cmp	r1, r7
   1044a:	bf0c      	ite	eq
   1044c:	2300      	moveq	r3, #0
   1044e:	f003 0301 	andne.w	r3, r3, #1
   10452:	4281      	cmp	r1, r0
   10454:	bf0c      	ite	eq
   10456:	2300      	moveq	r3, #0
   10458:	f003 0301 	andne.w	r3, r3, #1
   1045c:	2b00      	cmp	r3, #0
   1045e:	f040 81cf 	bne.w	10800 <HAL_RCCEx_PeriphCLKConfig+0x6d8>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
   10462:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   10466:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1046a:	681a      	ldr	r2, [r3, #0]
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
   1046c:	461f      	mov	r7, r3
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
   1046e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   10472:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
   10474:	f7f7 ffe4 	bl	8440 <HAL_GetTick>
   10478:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
   1047a:	e006      	b.n	1048a <HAL_RCCEx_PeriphCLKConfig+0x362>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   1047c:	f7f7 ffe0 	bl	8440 <HAL_GetTick>
   10480:	eba0 0008 	sub.w	r0, r0, r8
   10484:	2864      	cmp	r0, #100	; 0x64
   10486:	f200 827c 	bhi.w	10982 <HAL_RCCEx_PeriphCLKConfig+0x85a>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
   1048a:	683b      	ldr	r3, [r7, #0]
   1048c:	05da      	lsls	r2, r3, #23
   1048e:	d5f5      	bpl.n	1047c <HAL_RCCEx_PeriphCLKConfig+0x354>
    if(ret == HAL_OK)
   10490:	2d00      	cmp	r5, #0
   10492:	f040 854f 	bne.w	10f34 <HAL_RCCEx_PeriphCLKConfig+0xe0c>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
   10496:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   1049a:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
   1049e:	f6c5 0302 	movt	r3, #22530	; 0x5802
   104a2:	6f19      	ldr	r1, [r3, #112]	; 0x70
   104a4:	4051      	eors	r1, r2
   104a6:	f411 7f40 	tst.w	r1, #768	; 0x300
   104aa:	d00d      	beq.n	104c8 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
   104ac:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
   104ae:	6f19      	ldr	r1, [r3, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
   104b0:	f422 7240 	bic.w	r2, r2, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
   104b4:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
   104b8:	6719      	str	r1, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
   104ba:	6f19      	ldr	r1, [r3, #112]	; 0x70
   104bc:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
   104c0:	6719      	str	r1, [r3, #112]	; 0x70
        RCC->BDCR = tmpreg;
   104c2:	671a      	str	r2, [r3, #112]	; 0x70
   104c4:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
   104c8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   104cc:	f000 8477 	beq.w	10dbe <HAL_RCCEx_PeriphCLKConfig+0xc96>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
   104d0:	f402 7340 	and.w	r3, r2, #768	; 0x300
   104d4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
   104d8:	f000 851b 	beq.w	10f12 <HAL_RCCEx_PeriphCLKConfig+0xdea>
   104dc:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   104e0:	f6c5 0302 	movt	r3, #22530	; 0x5802
   104e4:	691a      	ldr	r2, [r3, #16]
   104e6:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
   104ea:	611a      	str	r2, [r3, #16]
   104ec:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   104f0:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
   104f4:	f6c5 0202 	movt	r2, #22530	; 0x5802
   104f8:	f3c3 030b 	ubfx	r3, r3, #0, #12
   104fc:	6f11      	ldr	r1, [r2, #112]	; 0x70
   104fe:	430b      	orrs	r3, r1
   10500:	6713      	str	r3, [r2, #112]	; 0x70
   10502:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
   10504:	07df      	lsls	r7, r3, #31
   10506:	d52f      	bpl.n	10568 <HAL_RCCEx_PeriphCLKConfig+0x440>
    switch(PeriphClkInit->Usart16ClockSelection)
   10508:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   1050a:	2a28      	cmp	r2, #40	; 0x28
   1050c:	d82a      	bhi.n	10564 <HAL_RCCEx_PeriphCLKConfig+0x43c>
   1050e:	e8df f012 	tbh	[pc, r2, lsl #1]
   10512:	01ce      	.short	0x01ce
   10514:	00290029 	.word	0x00290029
   10518:	00290029 	.word	0x00290029
   1051c:	00290029 	.word	0x00290029
   10520:	02d00029 	.word	0x02d00029
   10524:	00290029 	.word	0x00290029
   10528:	00290029 	.word	0x00290029
   1052c:	00290029 	.word	0x00290029
   10530:	01c80029 	.word	0x01c80029
   10534:	00290029 	.word	0x00290029
   10538:	00290029 	.word	0x00290029
   1053c:	00290029 	.word	0x00290029
   10540:	01ce0029 	.word	0x01ce0029
   10544:	00290029 	.word	0x00290029
   10548:	00290029 	.word	0x00290029
   1054c:	00290029 	.word	0x00290029
   10550:	01ce0029 	.word	0x01ce0029
   10554:	00290029 	.word	0x00290029
   10558:	00290029 	.word	0x00290029
   1055c:	00290029 	.word	0x00290029
   10560:	01ce0029 	.word	0x01ce0029
      ret = HAL_ERROR;
   10564:	2601      	movs	r6, #1
   10566:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
   10568:	0798      	lsls	r0, r3, #30
   1056a:	d50c      	bpl.n	10586 <HAL_RCCEx_PeriphCLKConfig+0x45e>
    switch(PeriphClkInit->Usart234578ClockSelection)
   1056c:	6f62      	ldr	r2, [r4, #116]	; 0x74
   1056e:	2a05      	cmp	r2, #5
   10570:	d807      	bhi.n	10582 <HAL_RCCEx_PeriphCLKConfig+0x45a>
   10572:	e8df f012 	tbh	[pc, r2, lsl #1]
   10576:	0173      	.short	0x0173
   10578:	016d0256 	.word	0x016d0256
   1057c:	01730173 	.word	0x01730173
   10580:	0173      	.short	0x0173
      ret = HAL_ERROR;
   10582:	2601      	movs	r6, #1
   10584:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
   10586:	0759      	lsls	r1, r3, #29
   10588:	d50d      	bpl.n	105a6 <HAL_RCCEx_PeriphCLKConfig+0x47e>
    switch(PeriphClkInit->Lpuart1ClockSelection)
   1058a:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   1058e:	2a05      	cmp	r2, #5
   10590:	d807      	bhi.n	105a2 <HAL_RCCEx_PeriphCLKConfig+0x47a>
   10592:	e8df f012 	tbh	[pc, r2, lsl #1]
   10596:	014d      	.short	0x014d
   10598:	0147024f 	.word	0x0147024f
   1059c:	014d014d 	.word	0x014d014d
   105a0:	014d      	.short	0x014d
      ret = HAL_ERROR;
   105a2:	2601      	movs	r6, #1
   105a4:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
   105a6:	069a      	lsls	r2, r3, #26
   105a8:	d520      	bpl.n	105ec <HAL_RCCEx_PeriphCLKConfig+0x4c4>
    switch(PeriphClkInit->Lptim1ClockSelection)
   105aa:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
   105ae:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   105b2:	f000 82f6 	beq.w	10ba2 <HAL_RCCEx_PeriphCLKConfig+0xa7a>
   105b6:	f200 8439 	bhi.w	10e2c <HAL_RCCEx_PeriphCLKConfig+0xd04>
   105ba:	b142      	cbz	r2, 105ce <HAL_RCCEx_PeriphCLKConfig+0x4a6>
   105bc:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
   105c0:	f040 8440 	bne.w	10e44 <HAL_RCCEx_PeriphCLKConfig+0xd1c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   105c4:	2100      	movs	r1, #0
   105c6:	1d20      	adds	r0, r4, #4
   105c8:	f7ff fb9a 	bl	fd00 <RCCEx_PLL2_Config>
   105cc:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   105ce:	2d00      	cmp	r5, #0
   105d0:	f040 81f9 	bne.w	109c6 <HAL_RCCEx_PeriphCLKConfig+0x89e>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
   105d4:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   105d8:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
   105dc:	f6c5 0202 	movt	r2, #22530	; 0x5802
   105e0:	6d53      	ldr	r3, [r2, #84]	; 0x54
   105e2:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
   105e6:	430b      	orrs	r3, r1
   105e8:	6553      	str	r3, [r2, #84]	; 0x54
   105ea:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
   105ec:	065f      	lsls	r7, r3, #25
   105ee:	d520      	bpl.n	10632 <HAL_RCCEx_PeriphCLKConfig+0x50a>
    switch(PeriphClkInit->Lptim2ClockSelection)
   105f0:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
   105f4:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   105f8:	f000 82c9 	beq.w	10b8e <HAL_RCCEx_PeriphCLKConfig+0xa66>
   105fc:	f200 8436 	bhi.w	10e6c <HAL_RCCEx_PeriphCLKConfig+0xd44>
   10600:	b142      	cbz	r2, 10614 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
   10602:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
   10606:	f040 843d 	bne.w	10e84 <HAL_RCCEx_PeriphCLKConfig+0xd5c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   1060a:	2100      	movs	r1, #0
   1060c:	1d20      	adds	r0, r4, #4
   1060e:	f7ff fb77 	bl	fd00 <RCCEx_PLL2_Config>
   10612:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10614:	2d00      	cmp	r5, #0
   10616:	f040 81d3 	bne.w	109c0 <HAL_RCCEx_PeriphCLKConfig+0x898>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
   1061a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   1061e:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
   10622:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10626:	6d93      	ldr	r3, [r2, #88]	; 0x58
   10628:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
   1062c:	430b      	orrs	r3, r1
   1062e:	6593      	str	r3, [r2, #88]	; 0x58
   10630:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
   10632:	0618      	lsls	r0, r3, #24
   10634:	d520      	bpl.n	10678 <HAL_RCCEx_PeriphCLKConfig+0x550>
    switch(PeriphClkInit->Lptim345ClockSelection)
   10636:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
   1063a:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
   1063e:	f000 829c 	beq.w	10b7a <HAL_RCCEx_PeriphCLKConfig+0xa52>
   10642:	f200 83d4 	bhi.w	10dee <HAL_RCCEx_PeriphCLKConfig+0xcc6>
   10646:	b142      	cbz	r2, 1065a <HAL_RCCEx_PeriphCLKConfig+0x532>
   10648:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
   1064c:	f040 83db 	bne.w	10e06 <HAL_RCCEx_PeriphCLKConfig+0xcde>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   10650:	2100      	movs	r1, #0
   10652:	1d20      	adds	r0, r4, #4
   10654:	f7ff fb54 	bl	fd00 <RCCEx_PLL2_Config>
   10658:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   1065a:	2d00      	cmp	r5, #0
   1065c:	f040 81ad 	bne.w	109ba <HAL_RCCEx_PeriphCLKConfig+0x892>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
   10660:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10664:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
   10668:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1066c:	6d93      	ldr	r3, [r2, #88]	; 0x58
   1066e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
   10672:	430b      	orrs	r3, r1
   10674:	6593      	str	r3, [r2, #88]	; 0x58
   10676:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
   10678:	0719      	lsls	r1, r3, #28
   1067a:	d513      	bpl.n	106a4 <HAL_RCCEx_PeriphCLKConfig+0x57c>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
   1067c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   10680:	f432 5340 	bics.w	r3, r2, #12288	; 0x3000
   10684:	f040 8385 	bne.w	10d92 <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
   10688:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
   1068c:	f000 82b8 	beq.w	10c00 <HAL_RCCEx_PeriphCLKConfig+0xad8>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
   10690:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   10694:	f6c5 0102 	movt	r1, #22530	; 0x5802
   10698:	6d4b      	ldr	r3, [r1, #84]	; 0x54
   1069a:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
   1069e:	4313      	orrs	r3, r2
   106a0:	654b      	str	r3, [r1, #84]	; 0x54
   106a2:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
   106a4:	06da      	lsls	r2, r3, #27
   106a6:	d519      	bpl.n	106dc <HAL_RCCEx_PeriphCLKConfig+0x5b4>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
   106a8:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   106ac:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   106b0:	bf18      	it	ne
   106b2:	f5b2 5f40 	cmpne.w	r2, #12288	; 0x3000
   106b6:	d003      	beq.n	106c0 <HAL_RCCEx_PeriphCLKConfig+0x598>
   106b8:	f432 7380 	bics.w	r3, r2, #256	; 0x100
   106bc:	f040 8374 	bne.w	10da8 <HAL_RCCEx_PeriphCLKConfig+0xc80>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
   106c0:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   106c4:	f000 82a8 	beq.w	10c18 <HAL_RCCEx_PeriphCLKConfig+0xaf0>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
   106c8:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   106cc:	f6c5 0102 	movt	r1, #22530	; 0x5802
   106d0:	6d8b      	ldr	r3, [r1, #88]	; 0x58
   106d2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   106d6:	4313      	orrs	r3, r2
   106d8:	658b      	str	r3, [r1, #88]	; 0x58
   106da:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
   106dc:	031f      	lsls	r7, r3, #12
   106de:	d50e      	bpl.n	106fe <HAL_RCCEx_PeriphCLKConfig+0x5d6>
    switch(PeriphClkInit->AdcClockSelection)
   106e0:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
   106e4:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
   106e8:	f000 8102 	beq.w	108f0 <HAL_RCCEx_PeriphCLKConfig+0x7c8>
   106ec:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
   106f0:	f000 8104 	beq.w	108fc <HAL_RCCEx_PeriphCLKConfig+0x7d4>
   106f4:	2900      	cmp	r1, #0
   106f6:	f000 8338 	beq.w	10d6a <HAL_RCCEx_PeriphCLKConfig+0xc42>
      ret = HAL_ERROR;
   106fa:	2601      	movs	r6, #1
   106fc:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
   106fe:	0358      	lsls	r0, r3, #13
   10700:	d50f      	bpl.n	10722 <HAL_RCCEx_PeriphCLKConfig+0x5fa>
    switch(PeriphClkInit->UsbClockSelection)
   10702:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
   10706:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
   1070a:	f000 8106 	beq.w	1091a <HAL_RCCEx_PeriphCLKConfig+0x7f2>
   1070e:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
   10712:	f000 8108 	beq.w	10926 <HAL_RCCEx_PeriphCLKConfig+0x7fe>
   10716:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
   1071a:	f000 832e 	beq.w	10d7a <HAL_RCCEx_PeriphCLKConfig+0xc52>
      ret = HAL_ERROR;
   1071e:	2601      	movs	r6, #1
   10720:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
   10722:	03d9      	lsls	r1, r3, #15
   10724:	d515      	bpl.n	10752 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
   10726:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   10728:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
   1072c:	f040 81a1 	bne.w	10a72 <HAL_RCCEx_PeriphCLKConfig+0x94a>
    switch(PeriphClkInit->SdmmcClockSelection)
   10730:	2b00      	cmp	r3, #0
   10732:	f000 815f 	beq.w	109f4 <HAL_RCCEx_PeriphCLKConfig+0x8cc>
   10736:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   1073a:	f040 814a 	bne.w	109d2 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
   1073e:	2102      	movs	r1, #2
   10740:	1d20      	adds	r0, r4, #4
   10742:	f7ff fadd 	bl	fd00 <RCCEx_PLL2_Config>
   10746:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10748:	2d00      	cmp	r5, #0
   1074a:	f000 815e 	beq.w	10a0a <HAL_RCCEx_PeriphCLKConfig+0x8e2>
   1074e:	6823      	ldr	r3, [r4, #0]
   10750:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
   10752:	009a      	lsls	r2, r3, #2
   10754:	f100 810a 	bmi.w	1096c <HAL_RCCEx_PeriphCLKConfig+0x844>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
   10758:	039f      	lsls	r7, r3, #14
   1075a:	d440      	bmi.n	107de <HAL_RCCEx_PeriphCLKConfig+0x6b6>
   1075c:	3600      	adds	r6, #0
   1075e:	bf18      	it	ne
   10760:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
   10762:	02d8      	lsls	r0, r3, #11
   10764:	d50e      	bpl.n	10784 <HAL_RCCEx_PeriphCLKConfig+0x65c>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
   10766:	6f21      	ldr	r1, [r4, #112]	; 0x70
   10768:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   1076c:	f040 8177 	bne.w	10a5e <HAL_RCCEx_PeriphCLKConfig+0x936>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
   10770:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10774:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10778:	6d13      	ldr	r3, [r2, #80]	; 0x50
   1077a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   1077e:	430b      	orrs	r3, r1
   10780:	6513      	str	r3, [r2, #80]	; 0x50
   10782:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
   10784:	0299      	lsls	r1, r3, #10
   10786:	d50e      	bpl.n	107a6 <HAL_RCCEx_PeriphCLKConfig+0x67e>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
   10788:	6ea1      	ldr	r1, [r4, #104]	; 0x68
   1078a:	f031 7380 	bics.w	r3, r1, #16777216	; 0x1000000
   1078e:	f040 817d 	bne.w	10a8c <HAL_RCCEx_PeriphCLKConfig+0x964>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
   10792:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10796:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1079a:	6d13      	ldr	r3, [r2, #80]	; 0x50
   1079c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   107a0:	430b      	orrs	r3, r1
   107a2:	6513      	str	r3, [r2, #80]	; 0x50
   107a4:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
   107a6:	005a      	lsls	r2, r3, #1
   107a8:	d513      	bpl.n	107d2 <HAL_RCCEx_PeriphCLKConfig+0x6aa>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
   107aa:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
   107ae:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
   107b2:	f040 8175 	bne.w	10aa0 <HAL_RCCEx_PeriphCLKConfig+0x978>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
   107b6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   107ba:	f6c5 0302 	movt	r3, #22530	; 0x5802
   107be:	691a      	ldr	r2, [r3, #16]
   107c0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   107c4:	611a      	str	r2, [r3, #16]
   107c6:	691a      	ldr	r2, [r3, #16]
   107c8:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
   107cc:	430a      	orrs	r2, r1
   107ce:	611a      	str	r2, [r3, #16]
   107d0:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
   107d2:	2b00      	cmp	r3, #0
   107d4:	f2c0 80b6 	blt.w	10944 <HAL_RCCEx_PeriphCLKConfig+0x81c>
}
   107d8:	4630      	mov	r0, r6
   107da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->RngClockSelection)
   107de:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
   107e0:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   107e4:	f000 80f9 	beq.w	109da <HAL_RCCEx_PeriphCLKConfig+0x8b2>
   107e8:	f240 816c 	bls.w	10ac4 <HAL_RCCEx_PeriphCLKConfig+0x99c>
   107ec:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   107f0:	f000 80fb 	beq.w	109ea <HAL_RCCEx_PeriphCLKConfig+0x8c2>
   107f4:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
   107f8:	f000 80f7 	beq.w	109ea <HAL_RCCEx_PeriphCLKConfig+0x8c2>
   107fc:	2601      	movs	r6, #1
   107fe:	e7b0      	b.n	10762 <HAL_RCCEx_PeriphCLKConfig+0x63a>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
   10800:	f44f 4363 	mov.w	r3, #58112	; 0xe300
   10804:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
   10808:	f2c0 0303 	movt	r3, #3
   1080c:	429a      	cmp	r2, r3
   1080e:	f43f ae28 	beq.w	10462 <HAL_RCCEx_PeriphCLKConfig+0x33a>
   10812:	f643 1050 	movw	r0, #14672	; 0x3950
   10816:	f44f 715a 	mov.w	r1, #872	; 0x368
   1081a:	f2c0 0003 	movt	r0, #3
   1081e:	f00a fc47 	bl	1b0b0 <assert_failed>
   10822:	e61e      	b.n	10462 <HAL_RCCEx_PeriphCLKConfig+0x33a>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
   10824:	2101      	movs	r1, #1
   10826:	f104 0024 	add.w	r0, r4, #36	; 0x24
   1082a:	f7ff fb73 	bl	ff14 <RCCEx_PLL3_Config>
   1082e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10830:	2d00      	cmp	r5, #0
   10832:	f040 80b0 	bne.w	10996 <HAL_RCCEx_PeriphCLKConfig+0x86e>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
   10836:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   1083a:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   1083e:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10842:	6d93      	ldr	r3, [r2, #88]	; 0x58
   10844:	f023 0307 	bic.w	r3, r3, #7
   10848:	430b      	orrs	r3, r1
   1084a:	6593      	str	r3, [r2, #88]	; 0x58
   1084c:	6823      	ldr	r3, [r4, #0]
   1084e:	e6aa      	b.n	105a6 <HAL_RCCEx_PeriphCLKConfig+0x47e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
   10850:	2101      	movs	r1, #1
   10852:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10856:	f7ff fb5d 	bl	ff14 <RCCEx_PLL3_Config>
   1085a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   1085c:	2d00      	cmp	r5, #0
   1085e:	f040 809d 	bne.w	1099c <HAL_RCCEx_PeriphCLKConfig+0x874>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
   10862:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10866:	6f61      	ldr	r1, [r4, #116]	; 0x74
   10868:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1086c:	6d53      	ldr	r3, [r2, #84]	; 0x54
   1086e:	f023 0307 	bic.w	r3, r3, #7
   10872:	430b      	orrs	r3, r1
   10874:	6553      	str	r3, [r2, #84]	; 0x54
   10876:	6823      	ldr	r3, [r4, #0]
   10878:	e685      	b.n	10586 <HAL_RCCEx_PeriphCLKConfig+0x45e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
   1087a:	2102      	movs	r1, #2
   1087c:	1d20      	adds	r0, r4, #4
   1087e:	f7ff fa3f 	bl	fd00 <RCCEx_PLL2_Config>
   10882:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10884:	2d00      	cmp	r5, #0
   10886:	f040 8083 	bne.w	10990 <HAL_RCCEx_PeriphCLKConfig+0x868>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
   1088a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   1088e:	6c61      	ldr	r1, [r4, #68]	; 0x44
   10890:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10894:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
   10896:	f023 0303 	bic.w	r3, r3, #3
   1089a:	430b      	orrs	r3, r1
   1089c:	64d3      	str	r3, [r2, #76]	; 0x4c
   1089e:	6823      	ldr	r3, [r4, #0]
   108a0:	e54a      	b.n	10338 <HAL_RCCEx_PeriphCLKConfig+0x210>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
   108a2:	2101      	movs	r1, #1
   108a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   108a8:	f7ff fb34 	bl	ff14 <RCCEx_PLL3_Config>
   108ac:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   108ae:	2d00      	cmp	r5, #0
   108b0:	d16b      	bne.n	1098a <HAL_RCCEx_PeriphCLKConfig+0x862>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
   108b2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   108b6:	6fa1      	ldr	r1, [r4, #120]	; 0x78
   108b8:	f6c5 0202 	movt	r2, #22530	; 0x5802
   108bc:	6d53      	ldr	r3, [r2, #84]	; 0x54
   108be:	f023 0338 	bic.w	r3, r3, #56	; 0x38
   108c2:	430b      	orrs	r3, r1
   108c4:	6553      	str	r3, [r2, #84]	; 0x54
   108c6:	6823      	ldr	r3, [r4, #0]
   108c8:	e64e      	b.n	10568 <HAL_RCCEx_PeriphCLKConfig+0x440>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
   108ca:	2101      	movs	r1, #1
   108cc:	1d20      	adds	r0, r4, #4
   108ce:	f7ff fa17 	bl	fd00 <RCCEx_PLL2_Config>
   108d2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   108d4:	2d00      	cmp	r5, #0
   108d6:	d179      	bne.n	109cc <HAL_RCCEx_PeriphCLKConfig+0x8a4>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
   108d8:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   108dc:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
   108de:	f6c5 0202 	movt	r2, #22530	; 0x5802
   108e2:	6d13      	ldr	r3, [r2, #80]	; 0x50
   108e4:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
   108e8:	430b      	orrs	r3, r1
   108ea:	6513      	str	r3, [r2, #80]	; 0x50
   108ec:	6823      	ldr	r3, [r4, #0]
   108ee:	e516      	b.n	1031e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
   108f0:	2102      	movs	r1, #2
   108f2:	f104 0024 	add.w	r0, r4, #36	; 0x24
   108f6:	f7ff fb0d 	bl	ff14 <RCCEx_PLL3_Config>
   108fa:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   108fc:	2d00      	cmp	r5, #0
   108fe:	d153      	bne.n	109a8 <HAL_RCCEx_PeriphCLKConfig+0x880>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
   10900:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10904:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
   10908:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1090c:	6d93      	ldr	r3, [r2, #88]	; 0x58
   1090e:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
   10912:	430b      	orrs	r3, r1
   10914:	6593      	str	r3, [r2, #88]	; 0x58
   10916:	6823      	ldr	r3, [r4, #0]
   10918:	e6f1      	b.n	106fe <HAL_RCCEx_PeriphCLKConfig+0x5d6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
   1091a:	2101      	movs	r1, #1
   1091c:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10920:	f7ff faf8 	bl	ff14 <RCCEx_PLL3_Config>
   10924:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10926:	2d00      	cmp	r5, #0
   10928:	d13b      	bne.n	109a2 <HAL_RCCEx_PeriphCLKConfig+0x87a>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
   1092a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   1092e:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
   10932:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10936:	6d53      	ldr	r3, [r2, #84]	; 0x54
   10938:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
   1093c:	430b      	orrs	r3, r1
   1093e:	6553      	str	r3, [r2, #84]	; 0x54
   10940:	6823      	ldr	r3, [r4, #0]
   10942:	e6ee      	b.n	10722 <HAL_RCCEx_PeriphCLKConfig+0x5fa>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
   10944:	6d21      	ldr	r1, [r4, #80]	; 0x50
   10946:	f031 5380 	bics.w	r3, r1, #268435456	; 0x10000000
   1094a:	d003      	beq.n	10954 <HAL_RCCEx_PeriphCLKConfig+0x82c>
   1094c:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   10950:	f040 8201 	bne.w	10d56 <HAL_RCCEx_PeriphCLKConfig+0xc2e>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
   10954:	f44f 4288 	mov.w	r2, #17408	; 0x4400
}
   10958:	4630      	mov	r0, r6
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
   1095a:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1095e:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
   10960:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
   10964:	430b      	orrs	r3, r1
   10966:	64d3      	str	r3, [r2, #76]	; 0x4c
}
   10968:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
   1096c:	2102      	movs	r1, #2
   1096e:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10972:	f7ff facf 	bl	ff14 <RCCEx_PLL3_Config>
   10976:	6823      	ldr	r3, [r4, #0]
   10978:	2800      	cmp	r0, #0
   1097a:	f43f aeed 	beq.w	10758 <HAL_RCCEx_PeriphCLKConfig+0x630>
      status=HAL_ERROR;
   1097e:	2601      	movs	r6, #1
   10980:	e6ea      	b.n	10758 <HAL_RCCEx_PeriphCLKConfig+0x630>
            ret = HAL_TIMEOUT;
   10982:	2603      	movs	r6, #3
   10984:	6823      	ldr	r3, [r4, #0]
   10986:	4635      	mov	r5, r6
   10988:	e5bc      	b.n	10504 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
   1098a:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   1098c:	462e      	mov	r6, r5
   1098e:	e5eb      	b.n	10568 <HAL_RCCEx_PeriphCLKConfig+0x440>
   10990:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   10992:	462e      	mov	r6, r5
   10994:	e4d0      	b.n	10338 <HAL_RCCEx_PeriphCLKConfig+0x210>
   10996:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   10998:	462e      	mov	r6, r5
   1099a:	e604      	b.n	105a6 <HAL_RCCEx_PeriphCLKConfig+0x47e>
   1099c:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   1099e:	462e      	mov	r6, r5
   109a0:	e5f1      	b.n	10586 <HAL_RCCEx_PeriphCLKConfig+0x45e>
   109a2:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109a4:	462e      	mov	r6, r5
   109a6:	e6bc      	b.n	10722 <HAL_RCCEx_PeriphCLKConfig+0x5fa>
   109a8:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109aa:	462e      	mov	r6, r5
   109ac:	e6a7      	b.n	106fe <HAL_RCCEx_PeriphCLKConfig+0x5d6>
   109ae:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109b0:	462e      	mov	r6, r5
   109b2:	e4a4      	b.n	102fe <HAL_RCCEx_PeriphCLKConfig+0x1d6>
   109b4:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109b6:	462e      	mov	r6, r5
   109b8:	e47e      	b.n	102b8 <HAL_RCCEx_PeriphCLKConfig+0x190>
   109ba:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109bc:	462e      	mov	r6, r5
   109be:	e65b      	b.n	10678 <HAL_RCCEx_PeriphCLKConfig+0x550>
   109c0:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109c2:	462e      	mov	r6, r5
   109c4:	e635      	b.n	10632 <HAL_RCCEx_PeriphCLKConfig+0x50a>
   109c6:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109c8:	462e      	mov	r6, r5
   109ca:	e60f      	b.n	105ec <HAL_RCCEx_PeriphCLKConfig+0x4c4>
   109cc:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   109ce:	462e      	mov	r6, r5
   109d0:	e4a5      	b.n	1031e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
      ret = HAL_ERROR;
   109d2:	2601      	movs	r6, #1
   109d4:	6823      	ldr	r3, [r4, #0]
   109d6:	4635      	mov	r5, r6
   109d8:	e6bb      	b.n	10752 <HAL_RCCEx_PeriphCLKConfig+0x62a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   109da:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   109de:	f6c5 0302 	movt	r3, #22530	; 0x5802
   109e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   109e4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   109e8:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   109ea:	2d00      	cmp	r5, #0
   109ec:	d06f      	beq.n	10ace <HAL_RCCEx_PeriphCLKConfig+0x9a6>
   109ee:	6823      	ldr	r3, [r4, #0]
   109f0:	2601      	movs	r6, #1
   109f2:	e6b6      	b.n	10762 <HAL_RCCEx_PeriphCLKConfig+0x63a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   109f4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   109f8:	f6c5 0302 	movt	r3, #22530	; 0x5802
   109fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   109fe:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10a02:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10a04:	2d00      	cmp	r5, #0
   10a06:	f47f aea2 	bne.w	1074e <HAL_RCCEx_PeriphCLKConfig+0x626>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
   10a0a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10a0e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
   10a10:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10a14:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
   10a16:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   10a1a:	430b      	orrs	r3, r1
   10a1c:	64d3      	str	r3, [r2, #76]	; 0x4c
   10a1e:	6823      	ldr	r3, [r4, #0]
   10a20:	e697      	b.n	10752 <HAL_RCCEx_PeriphCLKConfig+0x62a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
   10a22:	2101      	movs	r1, #1
   10a24:	1d20      	adds	r0, r4, #4
   10a26:	f7ff f96b 	bl	fd00 <RCCEx_PLL2_Config>
   10a2a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10a2c:	2d00      	cmp	r5, #0
   10a2e:	f43f af18 	beq.w	10862 <HAL_RCCEx_PeriphCLKConfig+0x73a>
   10a32:	e7b3      	b.n	1099c <HAL_RCCEx_PeriphCLKConfig+0x874>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
   10a34:	2101      	movs	r1, #1
   10a36:	1d20      	adds	r0, r4, #4
   10a38:	f7ff f962 	bl	fd00 <RCCEx_PLL2_Config>
   10a3c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10a3e:	2d00      	cmp	r5, #0
   10a40:	f43f aef9 	beq.w	10836 <HAL_RCCEx_PeriphCLKConfig+0x70e>
   10a44:	e7a7      	b.n	10996 <HAL_RCCEx_PeriphCLKConfig+0x86e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10a46:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10a4a:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10a4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10a50:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10a54:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10a56:	2d00      	cmp	r5, #0
   10a58:	f43f af17 	beq.w	1088a <HAL_RCCEx_PeriphCLKConfig+0x762>
   10a5c:	e798      	b.n	10990 <HAL_RCCEx_PeriphCLKConfig+0x868>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
   10a5e:	f643 1050 	movw	r0, #14672	; 0x3950
   10a62:	f240 51bd 	movw	r1, #1469	; 0x5bd
   10a66:	f2c0 0003 	movt	r0, #3
   10a6a:	f00a fb21 	bl	1b0b0 <assert_failed>
   10a6e:	6f21      	ldr	r1, [r4, #112]	; 0x70
   10a70:	e67e      	b.n	10770 <HAL_RCCEx_PeriphCLKConfig+0x648>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
   10a72:	f643 1050 	movw	r0, #14672	; 0x3950
   10a76:	f240 515e 	movw	r1, #1374	; 0x55e
   10a7a:	f2c0 0003 	movt	r0, #3
   10a7e:	f00a fb17 	bl	1b0b0 <assert_failed>
   10a82:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    switch(PeriphClkInit->SdmmcClockSelection)
   10a84:	2b00      	cmp	r3, #0
   10a86:	f47f ae56 	bne.w	10736 <HAL_RCCEx_PeriphCLKConfig+0x60e>
   10a8a:	e7b3      	b.n	109f4 <HAL_RCCEx_PeriphCLKConfig+0x8cc>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
   10a8c:	f643 1050 	movw	r0, #14672	; 0x3950
   10a90:	f240 51d1 	movw	r1, #1489	; 0x5d1
   10a94:	f2c0 0003 	movt	r0, #3
   10a98:	f00a fb0a 	bl	1b0b0 <assert_failed>
   10a9c:	6ea1      	ldr	r1, [r4, #104]	; 0x68
   10a9e:	e678      	b.n	10792 <HAL_RCCEx_PeriphCLKConfig+0x66a>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
   10aa0:	f643 1050 	movw	r0, #14672	; 0x3950
   10aa4:	f240 51e7 	movw	r1, #1511	; 0x5e7
   10aa8:	f2c0 0003 	movt	r0, #3
   10aac:	f00a fb00 	bl	1b0b0 <assert_failed>
   10ab0:	e681      	b.n	107b6 <HAL_RCCEx_PeriphCLKConfig+0x68e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
   10ab2:	2101      	movs	r1, #1
   10ab4:	1d20      	adds	r0, r4, #4
   10ab6:	f7ff f923 	bl	fd00 <RCCEx_PLL2_Config>
   10aba:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10abc:	2d00      	cmp	r5, #0
   10abe:	f43f aef8 	beq.w	108b2 <HAL_RCCEx_PeriphCLKConfig+0x78a>
   10ac2:	e762      	b.n	1098a <HAL_RCCEx_PeriphCLKConfig+0x862>
    switch(PeriphClkInit->RngClockSelection)
   10ac4:	2a00      	cmp	r2, #0
   10ac6:	f47f ae99 	bne.w	107fc <HAL_RCCEx_PeriphCLKConfig+0x6d4>
    if(ret == HAL_OK)
   10aca:	2d00      	cmp	r5, #0
   10acc:	d18f      	bne.n	109ee <HAL_RCCEx_PeriphCLKConfig+0x8c6>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
   10ace:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10ad2:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
   10ad4:	3600      	adds	r6, #0
   10ad6:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10ada:	bf18      	it	ne
   10adc:	2601      	movne	r6, #1
   10ade:	6d53      	ldr	r3, [r2, #84]	; 0x54
   10ae0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   10ae4:	430b      	orrs	r3, r1
   10ae6:	6553      	str	r3, [r2, #84]	; 0x54
   10ae8:	6823      	ldr	r3, [r4, #0]
   10aea:	e63a      	b.n	10762 <HAL_RCCEx_PeriphCLKConfig+0x63a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10aec:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10af0:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10af4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10af6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10afa:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10afc:	b155      	cbz	r5, 10b14 <HAL_RCCEx_PeriphCLKConfig+0x9ec>
   10afe:	6823      	ldr	r3, [r4, #0]
   10b00:	462e      	mov	r6, r5
   10b02:	f7ff bb9e 	b.w	10242 <HAL_RCCEx_PeriphCLKConfig+0x11a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
   10b06:	2102      	movs	r1, #2
   10b08:	1d20      	adds	r0, r4, #4
   10b0a:	f7ff f8f9 	bl	fd00 <RCCEx_PLL2_Config>
   10b0e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10b10:	2d00      	cmp	r5, #0
   10b12:	d1f4      	bne.n	10afe <HAL_RCCEx_PeriphCLKConfig+0x9d6>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
   10b14:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10b18:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   10b1a:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10b1e:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
   10b20:	f023 0330 	bic.w	r3, r3, #48	; 0x30
   10b24:	430b      	orrs	r3, r1
   10b26:	64d3      	str	r3, [r2, #76]	; 0x4c
   10b28:	6823      	ldr	r3, [r4, #0]
   10b2a:	f7ff bb8a 	b.w	10242 <HAL_RCCEx_PeriphCLKConfig+0x11a>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
   10b2e:	2101      	movs	r1, #1
   10b30:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10b34:	f7ff f9ee 	bl	ff14 <RCCEx_PLL3_Config>
   10b38:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10b3a:	2d00      	cmp	r5, #0
   10b3c:	f43f abb1 	beq.w	102a2 <HAL_RCCEx_PeriphCLKConfig+0x17a>
   10b40:	e738      	b.n	109b4 <HAL_RCCEx_PeriphCLKConfig+0x88c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
   10b42:	2101      	movs	r1, #1
   10b44:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10b48:	f7ff f9e4 	bl	ff14 <RCCEx_PLL3_Config>
   10b4c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10b4e:	2d00      	cmp	r5, #0
   10b50:	f43f abc9 	beq.w	102e6 <HAL_RCCEx_PeriphCLKConfig+0x1be>
   10b54:	e72b      	b.n	109ae <HAL_RCCEx_PeriphCLKConfig+0x886>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10b56:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10b5a:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10b5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10b60:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10b64:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10b66:	2d00      	cmp	r5, #0
   10b68:	f43f aeb6 	beq.w	108d8 <HAL_RCCEx_PeriphCLKConfig+0x7b0>
   10b6c:	e72e      	b.n	109cc <HAL_RCCEx_PeriphCLKConfig+0x8a4>
    switch(PeriphClkInit->Sai1ClockSelection)
   10b6e:	4635      	mov	r5, r6
    if(ret == HAL_OK)
   10b70:	b365      	cbz	r5, 10bcc <HAL_RCCEx_PeriphCLKConfig+0xaa4>
   10b72:	6823      	ldr	r3, [r4, #0]
   10b74:	462e      	mov	r6, r5
   10b76:	f7ff bb06 	b.w	10186 <HAL_RCCEx_PeriphCLKConfig+0x5e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
   10b7a:	2102      	movs	r1, #2
   10b7c:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10b80:	f7ff f9c8 	bl	ff14 <RCCEx_PLL3_Config>
   10b84:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10b86:	2d00      	cmp	r5, #0
   10b88:	f43f ad6a 	beq.w	10660 <HAL_RCCEx_PeriphCLKConfig+0x538>
   10b8c:	e715      	b.n	109ba <HAL_RCCEx_PeriphCLKConfig+0x892>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
   10b8e:	2102      	movs	r1, #2
   10b90:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10b94:	f7ff f9be 	bl	ff14 <RCCEx_PLL3_Config>
   10b98:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10b9a:	2d00      	cmp	r5, #0
   10b9c:	f43f ad3d 	beq.w	1061a <HAL_RCCEx_PeriphCLKConfig+0x4f2>
   10ba0:	e70e      	b.n	109c0 <HAL_RCCEx_PeriphCLKConfig+0x898>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
   10ba2:	2102      	movs	r1, #2
   10ba4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10ba8:	f7ff f9b4 	bl	ff14 <RCCEx_PLL3_Config>
   10bac:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10bae:	2d00      	cmp	r5, #0
   10bb0:	f43f ad10 	beq.w	105d4 <HAL_RCCEx_PeriphCLKConfig+0x4ac>
   10bb4:	e707      	b.n	109c6 <HAL_RCCEx_PeriphCLKConfig+0x89e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10bb6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
      break;
   10bba:	4635      	mov	r5, r6
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10bbc:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10bc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10bc2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10bc6:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10bc8:	2d00      	cmp	r5, #0
   10bca:	d1d2      	bne.n	10b72 <HAL_RCCEx_PeriphCLKConfig+0xa4a>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
   10bcc:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10bd0:	6d61      	ldr	r1, [r4, #84]	; 0x54
   10bd2:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10bd6:	6d13      	ldr	r3, [r2, #80]	; 0x50
   10bd8:	f023 0307 	bic.w	r3, r3, #7
   10bdc:	430b      	orrs	r3, r1
   10bde:	6513      	str	r3, [r2, #80]	; 0x50
   10be0:	6823      	ldr	r3, [r4, #0]
   10be2:	f7ff bad0 	b.w	10186 <HAL_RCCEx_PeriphCLKConfig+0x5e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   10be6:	2100      	movs	r1, #0
   10be8:	1d20      	adds	r0, r4, #4
   10bea:	f7ff f889 	bl	fd00 <RCCEx_PLL2_Config>
   10bee:	4605      	mov	r5, r0
      break;
   10bf0:	e7be      	b.n	10b70 <HAL_RCCEx_PeriphCLKConfig+0xa48>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
   10bf2:	2100      	movs	r1, #0
   10bf4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10bf8:	f7ff f98c 	bl	ff14 <RCCEx_PLL3_Config>
   10bfc:	4605      	mov	r5, r0
      break;
   10bfe:	e7b7      	b.n	10b70 <HAL_RCCEx_PeriphCLKConfig+0xa48>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
   10c00:	2102      	movs	r1, #2
   10c02:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10c06:	f7ff f985 	bl	ff14 <RCCEx_PLL3_Config>
   10c0a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   10c0e:	2800      	cmp	r0, #0
   10c10:	f43f ad3e 	beq.w	10690 <HAL_RCCEx_PeriphCLKConfig+0x568>
          status = HAL_ERROR;
   10c14:	2601      	movs	r6, #1
   10c16:	e53b      	b.n	10690 <HAL_RCCEx_PeriphCLKConfig+0x568>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
   10c18:	2102      	movs	r1, #2
   10c1a:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10c1e:	f7ff f979 	bl	ff14 <RCCEx_PLL3_Config>
   10c22:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   10c26:	2800      	cmp	r0, #0
   10c28:	f43f ad4e 	beq.w	106c8 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
        status = HAL_ERROR;
   10c2c:	2601      	movs	r6, #1
   10c2e:	e54b      	b.n	106c8 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
   10c30:	2100      	movs	r1, #0
   10c32:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10c36:	f7ff f96d 	bl	ff14 <RCCEx_PLL3_Config>
   10c3a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10c3c:	2d00      	cmp	r5, #0
   10c3e:	f47f ab18 	bne.w	10272 <HAL_RCCEx_PeriphCLKConfig+0x14a>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
   10c42:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10c46:	6de1      	ldr	r1, [r4, #92]	; 0x5c
   10c48:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10c4c:	6d13      	ldr	r3, [r2, #80]	; 0x50
   10c4e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
   10c52:	430b      	orrs	r3, r1
   10c54:	6513      	str	r3, [r2, #80]	; 0x50
   10c56:	6823      	ldr	r3, [r4, #0]
   10c58:	f7ff bb0d 	b.w	10276 <HAL_RCCEx_PeriphCLKConfig+0x14e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10c5c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10c60:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10c64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10c66:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10c6a:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10c6c:	2d00      	cmp	r5, #0
   10c6e:	f47f aad6 	bne.w	1021e <HAL_RCCEx_PeriphCLKConfig+0xf6>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
   10c72:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10c76:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
   10c7a:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10c7e:	6d93      	ldr	r3, [r2, #88]	; 0x58
   10c80:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
   10c84:	430b      	orrs	r3, r1
   10c86:	6593      	str	r3, [r2, #88]	; 0x58
   10c88:	6823      	ldr	r3, [r4, #0]
   10c8a:	f7ff baca 	b.w	10222 <HAL_RCCEx_PeriphCLKConfig+0xfa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
   10c8e:	2102      	movs	r1, #2
   10c90:	3004      	adds	r0, #4
   10c92:	f7ff f835 	bl	fd00 <RCCEx_PLL2_Config>
   10c96:	4606      	mov	r6, r0
    if(ret == HAL_OK)
   10c98:	2e00      	cmp	r6, #0
   10c9a:	f47f aa65 	bne.w	10168 <HAL_RCCEx_PeriphCLKConfig+0x40>
   10c9e:	6e62      	ldr	r2, [r4, #100]	; 0x64
   10ca0:	f7ff ba58 	b.w	10154 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
   10ca4:	2100      	movs	r1, #0
   10ca6:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10caa:	f7ff f933 	bl	ff14 <RCCEx_PLL3_Config>
   10cae:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10cb0:	2d00      	cmp	r5, #0
   10cb2:	f47f aa7e 	bne.w	101b2 <HAL_RCCEx_PeriphCLKConfig+0x8a>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
   10cb6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10cba:	6da1      	ldr	r1, [r4, #88]	; 0x58
   10cbc:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10cc0:	6d13      	ldr	r3, [r2, #80]	; 0x50
   10cc2:	f423 73e0 	bic.w	r3, r3, #448	; 0x1c0
   10cc6:	430b      	orrs	r3, r1
   10cc8:	6513      	str	r3, [r2, #80]	; 0x50
   10cca:	6823      	ldr	r3, [r4, #0]
   10ccc:	f7ff ba73 	b.w	101b6 <HAL_RCCEx_PeriphCLKConfig+0x8e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
   10cd0:	2100      	movs	r1, #0
   10cd2:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10cd6:	f7ff f91d 	bl	ff14 <RCCEx_PLL3_Config>
   10cda:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10cdc:	2d00      	cmp	r5, #0
   10cde:	f47f aa83 	bne.w	101e8 <HAL_RCCEx_PeriphCLKConfig+0xc0>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
   10ce2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10ce6:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
   10cea:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10cee:	6d93      	ldr	r3, [r2, #88]	; 0x58
   10cf0:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
   10cf4:	430b      	orrs	r3, r1
   10cf6:	6593      	str	r3, [r2, #88]	; 0x58
   10cf8:	6823      	ldr	r3, [r4, #0]
   10cfa:	f7ff ba77 	b.w	101ec <HAL_RCCEx_PeriphCLKConfig+0xc4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
   10cfe:	2100      	movs	r1, #0
   10d00:	f104 0024 	add.w	r0, r4, #36	; 0x24
   10d04:	f7ff f906 	bl	ff14 <RCCEx_PLL3_Config>
   10d08:	4605      	mov	r5, r0
      break;
   10d0a:	f7ff ba85 	b.w	10218 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
   10d0e:	2102      	movs	r1, #2
   10d10:	3024      	adds	r0, #36	; 0x24
   10d12:	f7ff f8ff 	bl	ff14 <RCCEx_PLL3_Config>
   10d16:	4606      	mov	r6, r0
      break;
   10d18:	e7be      	b.n	10c98 <HAL_RCCEx_PeriphCLKConfig+0xb70>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10d1a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10d1e:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10d22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10d24:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10d28:	62da      	str	r2, [r3, #44]	; 0x2c
      break;
   10d2a:	f7ff ba3f 	b.w	101ac <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10d2e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10d32:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10d36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10d38:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10d3c:	62da      	str	r2, [r3, #44]	; 0x2c
      break;
   10d3e:	f7ff ba95 	b.w	1026c <HAL_RCCEx_PeriphCLKConfig+0x144>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10d42:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10d46:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10d4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10d4c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10d50:	62da      	str	r2, [r3, #44]	; 0x2c
      break;
   10d52:	f7ff ba46 	b.w	101e2 <HAL_RCCEx_PeriphCLKConfig+0xba>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
   10d56:	f643 1050 	movw	r0, #14672	; 0x3950
   10d5a:	f240 51f1 	movw	r1, #1521	; 0x5f1
   10d5e:	f2c0 0003 	movt	r0, #3
   10d62:	f00a f9a5 	bl	1b0b0 <assert_failed>
   10d66:	6d21      	ldr	r1, [r4, #80]	; 0x50
   10d68:	e5f4      	b.n	10954 <HAL_RCCEx_PeriphCLKConfig+0x82c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
   10d6a:	1d20      	adds	r0, r4, #4
   10d6c:	f7fe ffc8 	bl	fd00 <RCCEx_PLL2_Config>
   10d70:	4605      	mov	r5, r0
    if(ret == HAL_OK)
   10d72:	2d00      	cmp	r5, #0
   10d74:	f43f adc4 	beq.w	10900 <HAL_RCCEx_PeriphCLKConfig+0x7d8>
   10d78:	e616      	b.n	109a8 <HAL_RCCEx_PeriphCLKConfig+0x880>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10d7a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10d7e:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10d82:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10d84:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10d88:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
   10d8a:	2d00      	cmp	r5, #0
   10d8c:	f43f adcd 	beq.w	1092a <HAL_RCCEx_PeriphCLKConfig+0x802>
   10d90:	e607      	b.n	109a2 <HAL_RCCEx_PeriphCLKConfig+0x87a>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
   10d92:	f643 1050 	movw	r0, #14672	; 0x3950
   10d96:	f240 41e6 	movw	r1, #1254	; 0x4e6
   10d9a:	f2c0 0003 	movt	r0, #3
   10d9e:	f00a f987 	bl	1b0b0 <assert_failed>
   10da2:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   10da6:	e46f      	b.n	10688 <HAL_RCCEx_PeriphCLKConfig+0x560>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
   10da8:	f643 1050 	movw	r0, #14672	; 0x3950
   10dac:	f44f 619f 	mov.w	r1, #1272	; 0x4f8
   10db0:	f2c0 0003 	movt	r0, #3
   10db4:	f00a f97c 	bl	1b0b0 <assert_failed>
   10db8:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   10dbc:	e480      	b.n	106c0 <HAL_RCCEx_PeriphCLKConfig+0x598>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
   10dbe:	f44f 4788 	mov.w	r7, #17408	; 0x4400
        tickstart = HAL_GetTick();
   10dc2:	f7f7 fb3d 	bl	8440 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
   10dc6:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
   10dca:	4681      	mov	r9, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
   10dcc:	f6c5 0702 	movt	r7, #22530	; 0x5802
   10dd0:	e006      	b.n	10de0 <HAL_RCCEx_PeriphCLKConfig+0xcb8>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
   10dd2:	f7f7 fb35 	bl	8440 <HAL_GetTick>
   10dd6:	eba0 0009 	sub.w	r0, r0, r9
   10dda:	4540      	cmp	r0, r8
   10ddc:	f63f add1 	bhi.w	10982 <HAL_RCCEx_PeriphCLKConfig+0x85a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
   10de0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   10de2:	079b      	lsls	r3, r3, #30
   10de4:	d5f5      	bpl.n	10dd2 <HAL_RCCEx_PeriphCLKConfig+0xcaa>
   10de6:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
   10dea:	f7ff bb71 	b.w	104d0 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
    switch(PeriphClkInit->Lptim345ClockSelection)
   10dee:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   10df2:	f43f ac32 	beq.w	1065a <HAL_RCCEx_PeriphCLKConfig+0x532>
   10df6:	f5b2 4f20 	cmp.w	r2, #40960	; 0xa000
   10dfa:	f43f ac2e 	beq.w	1065a <HAL_RCCEx_PeriphCLKConfig+0x532>
   10dfe:	f5b2 4fc0 	cmp.w	r2, #24576	; 0x6000
   10e02:	f43f ac2a 	beq.w	1065a <HAL_RCCEx_PeriphCLKConfig+0x532>
      ret = HAL_ERROR;
   10e06:	2601      	movs	r6, #1
   10e08:	4635      	mov	r5, r6
   10e0a:	e435      	b.n	10678 <HAL_RCCEx_PeriphCLKConfig+0x550>
    switch(PeriphClkInit->Spi45ClockSelection)
   10e0c:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
   10e10:	f43f aa44 	beq.w	1029c <HAL_RCCEx_PeriphCLKConfig+0x174>
   10e14:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
   10e18:	f43f aa40 	beq.w	1029c <HAL_RCCEx_PeriphCLKConfig+0x174>
   10e1c:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
   10e20:	f43f aa3c 	beq.w	1029c <HAL_RCCEx_PeriphCLKConfig+0x174>
      ret = HAL_ERROR;
   10e24:	2601      	movs	r6, #1
   10e26:	4635      	mov	r5, r6
   10e28:	f7ff ba46 	b.w	102b8 <HAL_RCCEx_PeriphCLKConfig+0x190>
    switch(PeriphClkInit->Lptim1ClockSelection)
   10e2c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   10e30:	f43f abcd 	beq.w	105ce <HAL_RCCEx_PeriphCLKConfig+0x4a6>
   10e34:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
   10e38:	f43f abc9 	beq.w	105ce <HAL_RCCEx_PeriphCLKConfig+0x4a6>
   10e3c:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
   10e40:	f43f abc5 	beq.w	105ce <HAL_RCCEx_PeriphCLKConfig+0x4a6>
      ret = HAL_ERROR;
   10e44:	2601      	movs	r6, #1
   10e46:	4635      	mov	r5, r6
   10e48:	f7ff bbd0 	b.w	105ec <HAL_RCCEx_PeriphCLKConfig+0x4c4>
    switch(PeriphClkInit->Spi6ClockSelection)
   10e4c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   10e50:	f43f aa46 	beq.w	102e0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
   10e54:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
   10e58:	f43f aa42 	beq.w	102e0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
   10e5c:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
   10e60:	f43f aa3e 	beq.w	102e0 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
      ret = HAL_ERROR;
   10e64:	2601      	movs	r6, #1
   10e66:	4635      	mov	r5, r6
   10e68:	f7ff ba49 	b.w	102fe <HAL_RCCEx_PeriphCLKConfig+0x1d6>
    switch(PeriphClkInit->Lptim2ClockSelection)
   10e6c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
   10e70:	f43f abd0 	beq.w	10614 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
   10e74:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
   10e78:	f43f abcc 	beq.w	10614 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
   10e7c:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
   10e80:	f43f abc8 	beq.w	10614 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
      ret = HAL_ERROR;
   10e84:	2601      	movs	r6, #1
   10e86:	4635      	mov	r5, r6
   10e88:	f7ff bbd3 	b.w	10632 <HAL_RCCEx_PeriphCLKConfig+0x50a>
    switch(PeriphClkInit->Sai4AClockSelection)
   10e8c:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
   10e90:	f43f a9a7 	beq.w	101e2 <HAL_RCCEx_PeriphCLKConfig+0xba>
   10e94:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   10e98:	f43f a9a3 	beq.w	101e2 <HAL_RCCEx_PeriphCLKConfig+0xba>
      ret = HAL_ERROR;
   10e9c:	2601      	movs	r6, #1
   10e9e:	4635      	mov	r5, r6
   10ea0:	f7ff b9a4 	b.w	101ec <HAL_RCCEx_PeriphCLKConfig+0xc4>
    switch(PeriphClkInit->Sai23ClockSelection)
   10ea4:	2ac0      	cmp	r2, #192	; 0xc0
   10ea6:	f43f a981 	beq.w	101ac <HAL_RCCEx_PeriphCLKConfig+0x84>
   10eaa:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
   10eae:	f43f a97d 	beq.w	101ac <HAL_RCCEx_PeriphCLKConfig+0x84>
      ret = HAL_ERROR;
   10eb2:	2601      	movs	r6, #1
   10eb4:	4635      	mov	r5, r6
   10eb6:	f7ff b97e 	b.w	101b6 <HAL_RCCEx_PeriphCLKConfig+0x8e>
    switch(PeriphClkInit->SpdifrxClockSelection)
   10eba:	bb3a      	cbnz	r2, 10f0c <HAL_RCCEx_PeriphCLKConfig+0xde4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   10ebc:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   10ec0:	f6c5 0302 	movt	r3, #22530	; 0x5802
   10ec4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   10ec6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   10eca:	62da      	str	r2, [r3, #44]	; 0x2c
   10ecc:	6e42      	ldr	r2, [r0, #100]	; 0x64
   10ece:	f7ff b941 	b.w	10154 <HAL_RCCEx_PeriphCLKConfig+0x2c>
    switch(PeriphClkInit->Spi123ClockSelection)
   10ed2:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
   10ed6:	f43f a9c9 	beq.w	1026c <HAL_RCCEx_PeriphCLKConfig+0x144>
   10eda:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
   10ede:	f43f a9c5 	beq.w	1026c <HAL_RCCEx_PeriphCLKConfig+0x144>
      ret = HAL_ERROR;
   10ee2:	2601      	movs	r6, #1
   10ee4:	4635      	mov	r5, r6
   10ee6:	f7ff b9c6 	b.w	10276 <HAL_RCCEx_PeriphCLKConfig+0x14e>
    switch(PeriphClkInit->Sai4BClockSelection)
   10eea:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
   10eee:	f43f a993 	beq.w	10218 <HAL_RCCEx_PeriphCLKConfig+0xf0>
   10ef2:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
   10ef6:	f43f a98f 	beq.w	10218 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      ret = HAL_ERROR;
   10efa:	2601      	movs	r6, #1
   10efc:	4635      	mov	r5, r6
   10efe:	f7ff b990 	b.w	10222 <HAL_RCCEx_PeriphCLKConfig+0xfa>
    switch(PeriphClkInit->QspiClockSelection)
   10f02:	2a00      	cmp	r2, #0
   10f04:	f43f adfa 	beq.w	10afc <HAL_RCCEx_PeriphCLKConfig+0x9d4>
   10f08:	f7ff b999 	b.w	1023e <HAL_RCCEx_PeriphCLKConfig+0x116>
      ret = HAL_ERROR;
   10f0c:	2601      	movs	r6, #1
   10f0e:	f7ff b92c 	b.w	1016a <HAL_RCCEx_PeriphCLKConfig+0x42>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
   10f12:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   10f16:	f64f 73cf 	movw	r3, #65487	; 0xffcf
   10f1a:	f6c5 0102 	movt	r1, #22530	; 0x5802
   10f1e:	f2c0 03ff 	movt	r3, #255	; 0xff
   10f22:	6908      	ldr	r0, [r1, #16]
   10f24:	ea03 1312 	and.w	r3, r3, r2, lsr #4
   10f28:	f420 527c 	bic.w	r2, r0, #16128	; 0x3f00
   10f2c:	4313      	orrs	r3, r2
   10f2e:	610b      	str	r3, [r1, #16]
   10f30:	f7ff badc 	b.w	104ec <HAL_RCCEx_PeriphCLKConfig+0x3c4>
   10f34:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
   10f36:	462e      	mov	r6, r5
   10f38:	f7ff bae4 	b.w	10504 <HAL_RCCEx_PeriphCLKConfig+0x3dc>

00010f3c <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10f3c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10f40:	f6c5 0202 	movt	r2, #22530	; 0x5802
{
   10f44:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10f46:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
   10f48:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
   10f4a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
   10f4c:	f3c3 3305 	ubfx	r3, r3, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
   10f50:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
  if (pll2m != 0U)
   10f52:	2b00      	cmp	r3, #0
   10f54:	d060      	beq.n	11018 <HAL_RCCEx_GetPLL2ClockFreq+0xdc>
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
   10f56:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
   10f5a:	f3c1 1100 	ubfx	r1, r1, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10f5e:	f004 0403 	and.w	r4, r4, #3
   10f62:	ee07 3a90 	vmov	s15, r3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
   10f66:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   10f6a:	2c01      	cmp	r4, #1
   10f6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10f70:	ee06 1a90 	vmov	s13, r1
   10f74:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   10f78:	d002      	beq.n	10f80 <HAL_RCCEx_GetPLL2ClockFreq+0x44>
   10f7a:	d35a      	bcc.n	11032 <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
   10f7c:	2c02      	cmp	r4, #2
   10f7e:	d050      	beq.n	11022 <HAL_RCCEx_GetPLL2ClockFreq+0xe6>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   10f80:	f44f 5110 	mov.w	r1, #9216	; 0x2400
   10f84:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   10f88:	6b93      	ldr	r3, [r2, #56]	; 0x38
   10f8a:	f6c4 2174 	movt	r1, #19060	; 0x4a74
   10f8e:	ee06 1a10 	vmov	s12, r1
   10f92:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10f96:	eec6 5a27 	vdiv.f32	s11, s12, s15
   10f9a:	ee07 3a10 	vmov	s14, r3
   10f9e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   10fa2:	ee37 7a05 	vadd.f32	s14, s14, s10
   10fa6:	ee77 7a26 	vadd.f32	s15, s14, s13
   10faa:	ee67 7aa5 	vmul.f32	s15, s15, s11
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
   10fae:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   10fb2:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   10fb6:	f6c5 0202 	movt	r2, #22530	; 0x5802
   10fba:	6b93      	ldr	r3, [r2, #56]	; 0x38
   10fbc:	f3c3 2346 	ubfx	r3, r3, #9, #7
   10fc0:	ee06 3a90 	vmov	s13, r3
   10fc4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   10fc8:	bc30      	pop	{r4, r5}
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
   10fca:	ee76 6a86 	vadd.f32	s13, s13, s12
   10fce:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   10fd2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   10fd6:	ed80 7a00 	vstr	s14, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
   10fda:	6b93      	ldr	r3, [r2, #56]	; 0x38
   10fdc:	f3c3 4306 	ubfx	r3, r3, #16, #7
   10fe0:	ee06 3a90 	vmov	s13, r3
   10fe4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   10fe8:	ee76 6a86 	vadd.f32	s13, s13, s12
   10fec:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   10ff0:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   10ff4:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
   10ff8:	6b93      	ldr	r3, [r2, #56]	; 0x38
   10ffa:	f3c3 6306 	ubfx	r3, r3, #24, #7
   10ffe:	ee07 3a10 	vmov	s14, r3
   11002:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   11006:	ee37 7a06 	vadd.f32	s14, s14, s12
   1100a:	eec7 6a87 	vdiv.f32	s13, s15, s14
   1100e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   11012:	edc0 6a02 	vstr	s13, [r0, #8]
}
   11016:	4770      	bx	lr
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
   11018:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
   1101c:	6083      	str	r3, [r0, #8]
}
   1101e:	bc30      	pop	{r4, r5}
   11020:	4770      	bx	lr
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   11022:	f64b 4120 	movw	r1, #48160	; 0xbc20
   11026:	6b93      	ldr	r3, [r2, #56]	; 0x38
   11028:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   1102c:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
   11030:	e7ad      	b.n	10f8e <HAL_RCCEx_GetPLL2ClockFreq+0x52>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   11032:	6813      	ldr	r3, [r2, #0]
   11034:	069b      	lsls	r3, r3, #26
   11036:	d51d      	bpl.n	11074 <HAL_RCCEx_GetPLL2ClockFreq+0x138>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   11038:	6814      	ldr	r4, [r2, #0]
   1103a:	f44f 4110 	mov.w	r1, #36864	; 0x9000
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   1103e:	6b93      	ldr	r3, [r2, #56]	; 0x38
   11040:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   11044:	f3c4 02c1 	ubfx	r2, r4, #3, #2
   11048:	f2c0 31d0 	movt	r1, #976	; 0x3d0
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   1104c:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   11050:	40d1      	lsrs	r1, r2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   11052:	ee06 3a10 	vmov	s12, r3
   11056:	ee05 1a90 	vmov	s11, r1
   1105a:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   1105e:	eef8 5ae5 	vcvt.f32.s32	s11, s11
   11062:	ee36 6a07 	vadd.f32	s12, s12, s14
   11066:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   1106a:	ee76 7a26 	vadd.f32	s15, s12, s13
   1106e:	ee67 7a27 	vmul.f32	s15, s14, s15
   11072:	e79c      	b.n	10fae <HAL_RCCEx_GetPLL2ClockFreq+0x72>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   11074:	f44f 5110 	mov.w	r1, #9216	; 0x2400
   11078:	6b93      	ldr	r3, [r2, #56]	; 0x38
   1107a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   1107e:	f6c4 4174 	movt	r1, #19572	; 0x4c74
   11082:	e784      	b.n	10f8e <HAL_RCCEx_GetPLL2ClockFreq+0x52>

00011084 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   11084:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   11088:	f6c5 0202 	movt	r2, #22530	; 0x5802
{
   1108c:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   1108e:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
   11090:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
   11092:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
   11094:	f3c3 5305 	ubfx	r3, r3, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   11098:	6c55      	ldr	r5, [r2, #68]	; 0x44
  if (pll3m != 0U)
   1109a:	2b00      	cmp	r3, #0
   1109c:	d060      	beq.n	11160 <HAL_RCCEx_GetPLL3ClockFreq+0xdc>
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   1109e:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
   110a2:	f3c1 2100 	ubfx	r1, r1, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   110a6:	f004 0403 	and.w	r4, r4, #3
   110aa:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   110ae:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   110b2:	2c01      	cmp	r4, #1
   110b4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   110b8:	ee06 1a90 	vmov	s13, r1
   110bc:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   110c0:	d002      	beq.n	110c8 <HAL_RCCEx_GetPLL3ClockFreq+0x44>
   110c2:	d35a      	bcc.n	1117a <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
   110c4:	2c02      	cmp	r4, #2
   110c6:	d050      	beq.n	1116a <HAL_RCCEx_GetPLL3ClockFreq+0xe6>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   110c8:	f44f 5110 	mov.w	r1, #9216	; 0x2400
   110cc:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   110d0:	6c13      	ldr	r3, [r2, #64]	; 0x40
   110d2:	f6c4 2174 	movt	r1, #19060	; 0x4a74
   110d6:	ee06 1a10 	vmov	s12, r1
   110da:	f3c3 0308 	ubfx	r3, r3, #0, #9
   110de:	eec6 5a27 	vdiv.f32	s11, s12, s15
   110e2:	ee07 3a10 	vmov	s14, r3
   110e6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   110ea:	ee37 7a05 	vadd.f32	s14, s14, s10
   110ee:	ee77 7a26 	vadd.f32	s15, s14, s13
   110f2:	ee67 7aa5 	vmul.f32	s15, s15, s11
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
   110f6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   110fa:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   110fe:	f6c5 0202 	movt	r2, #22530	; 0x5802
   11102:	6c13      	ldr	r3, [r2, #64]	; 0x40
   11104:	f3c3 2346 	ubfx	r3, r3, #9, #7
   11108:	ee06 3a90 	vmov	s13, r3
   1110c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   11110:	bc30      	pop	{r4, r5}
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
   11112:	ee76 6a86 	vadd.f32	s13, s13, s12
   11116:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   1111a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   1111e:	ed80 7a00 	vstr	s14, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
   11122:	6c13      	ldr	r3, [r2, #64]	; 0x40
   11124:	f3c3 4306 	ubfx	r3, r3, #16, #7
   11128:	ee06 3a90 	vmov	s13, r3
   1112c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   11130:	ee76 6a86 	vadd.f32	s13, s13, s12
   11134:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   11138:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   1113c:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
   11140:	6c13      	ldr	r3, [r2, #64]	; 0x40
   11142:	f3c3 6306 	ubfx	r3, r3, #24, #7
   11146:	ee07 3a10 	vmov	s14, r3
   1114a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1114e:	ee37 7a06 	vadd.f32	s14, s14, s12
   11152:	eec7 6a87 	vdiv.f32	s13, s15, s14
   11156:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   1115a:	edc0 6a02 	vstr	s13, [r0, #8]
}
   1115e:	4770      	bx	lr
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
   11160:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
   11164:	6083      	str	r3, [r0, #8]
}
   11166:	bc30      	pop	{r4, r5}
   11168:	4770      	bx	lr
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   1116a:	f64b 4120 	movw	r1, #48160	; 0xbc20
   1116e:	6c13      	ldr	r3, [r2, #64]	; 0x40
   11170:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   11174:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
   11178:	e7ad      	b.n	110d6 <HAL_RCCEx_GetPLL3ClockFreq+0x52>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   1117a:	6813      	ldr	r3, [r2, #0]
   1117c:	069b      	lsls	r3, r3, #26
   1117e:	d51d      	bpl.n	111bc <HAL_RCCEx_GetPLL3ClockFreq+0x138>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   11180:	6814      	ldr	r4, [r2, #0]
   11182:	f44f 4110 	mov.w	r1, #36864	; 0x9000
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   11186:	6c13      	ldr	r3, [r2, #64]	; 0x40
   11188:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   1118c:	f3c4 02c1 	ubfx	r2, r4, #3, #2
   11190:	f2c0 31d0 	movt	r1, #976	; 0x3d0
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   11194:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   11198:	40d1      	lsrs	r1, r2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   1119a:	ee06 3a10 	vmov	s12, r3
   1119e:	ee05 1a90 	vmov	s11, r1
   111a2:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   111a6:	eef8 5ae5 	vcvt.f32.s32	s11, s11
   111aa:	ee36 6a07 	vadd.f32	s12, s12, s14
   111ae:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   111b2:	ee76 7a26 	vadd.f32	s15, s12, s13
   111b6:	ee67 7a27 	vmul.f32	s15, s14, s15
   111ba:	e79c      	b.n	110f6 <HAL_RCCEx_GetPLL3ClockFreq+0x72>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   111bc:	f44f 5110 	mov.w	r1, #9216	; 0x2400
   111c0:	6c13      	ldr	r3, [r2, #64]	; 0x40
   111c2:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   111c6:	f6c4 4174 	movt	r1, #19572	; 0x4c74
   111ca:	e784      	b.n	110d6 <HAL_RCCEx_GetPLL3ClockFreq+0x52>

000111cc <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   111cc:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   111d0:	f6c5 0202 	movt	r2, #22530	; 0x5802
{
   111d4:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   111d6:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
   111d8:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
   111da:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
   111dc:	f3c3 1305 	ubfx	r3, r3, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   111e0:	6b55      	ldr	r5, [r2, #52]	; 0x34
  if (pll1m != 0U)
   111e2:	2b00      	cmp	r3, #0
   111e4:	d060      	beq.n	112a8 <HAL_RCCEx_GetPLL1ClockFreq+0xdc>
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   111e6:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
   111ea:	f001 0101 	and.w	r1, r1, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   111ee:	f004 0403 	and.w	r4, r4, #3
   111f2:	ee07 3a90 	vmov	s15, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   111f6:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   111fa:	2c01      	cmp	r4, #1
   111fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11200:	ee06 1a90 	vmov	s13, r1
   11204:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   11208:	d002      	beq.n	11210 <HAL_RCCEx_GetPLL1ClockFreq+0x44>
   1120a:	d35a      	bcc.n	112c2 <HAL_RCCEx_GetPLL1ClockFreq+0xf6>
   1120c:	2c02      	cmp	r4, #2
   1120e:	d050      	beq.n	112b2 <HAL_RCCEx_GetPLL1ClockFreq+0xe6>
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   11210:	f44f 5110 	mov.w	r1, #9216	; 0x2400
   11214:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   11218:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1121a:	f6c4 2174 	movt	r1, #19060	; 0x4a74
   1121e:	ee06 1a10 	vmov	s12, r1
   11222:	f3c3 0308 	ubfx	r3, r3, #0, #9
   11226:	eec6 5a27 	vdiv.f32	s11, s12, s15
   1122a:	ee07 3a10 	vmov	s14, r3
   1122e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   11232:	ee37 7a05 	vadd.f32	s14, s14, s10
   11236:	ee77 7a26 	vadd.f32	s15, s14, s13
   1123a:	ee67 7aa5 	vmul.f32	s15, s15, s11
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
   1123e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   11242:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   11246:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1124a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1124c:	f3c3 2346 	ubfx	r3, r3, #9, #7
   11250:	ee06 3a90 	vmov	s13, r3
   11254:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   11258:	bc30      	pop	{r4, r5}
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
   1125a:	ee76 6a86 	vadd.f32	s13, s13, s12
   1125e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   11262:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   11266:	ed80 7a00 	vstr	s14, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
   1126a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1126c:	f3c3 4306 	ubfx	r3, r3, #16, #7
   11270:	ee06 3a90 	vmov	s13, r3
   11274:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   11278:	ee76 6a86 	vadd.f32	s13, s13, s12
   1127c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   11280:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   11284:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
   11288:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1128a:	f3c3 6306 	ubfx	r3, r3, #24, #7
   1128e:	ee07 3a10 	vmov	s14, r3
   11292:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   11296:	ee37 7a06 	vadd.f32	s14, s14, s12
   1129a:	eec7 6a87 	vdiv.f32	s13, s15, s14
   1129e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   112a2:	edc0 6a02 	vstr	s13, [r0, #8]
}
   112a6:	4770      	bx	lr
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
   112a8:	e9c0 3300 	strd	r3, r3, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
   112ac:	6083      	str	r3, [r0, #8]
}
   112ae:	bc30      	pop	{r4, r5}
   112b0:	4770      	bx	lr
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   112b2:	f64b 4120 	movw	r1, #48160	; 0xbc20
   112b6:	6b13      	ldr	r3, [r2, #48]	; 0x30
   112b8:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   112bc:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
   112c0:	e7ad      	b.n	1121e <HAL_RCCEx_GetPLL1ClockFreq+0x52>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   112c2:	6813      	ldr	r3, [r2, #0]
   112c4:	069b      	lsls	r3, r3, #26
   112c6:	d51d      	bpl.n	11304 <HAL_RCCEx_GetPLL1ClockFreq+0x138>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   112c8:	6814      	ldr	r4, [r2, #0]
   112ca:	f44f 4110 	mov.w	r1, #36864	; 0x9000
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   112ce:	6b13      	ldr	r3, [r2, #48]	; 0x30
   112d0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   112d4:	f3c4 02c1 	ubfx	r2, r4, #3, #2
   112d8:	f2c0 31d0 	movt	r1, #976	; 0x3d0
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   112dc:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   112e0:	40d1      	lsrs	r1, r2
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   112e2:	ee06 3a10 	vmov	s12, r3
   112e6:	ee05 1a90 	vmov	s11, r1
   112ea:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   112ee:	eef8 5ae5 	vcvt.f32.s32	s11, s11
   112f2:	ee36 6a07 	vadd.f32	s12, s12, s14
   112f6:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   112fa:	ee76 7a26 	vadd.f32	s15, s12, s13
   112fe:	ee67 7a27 	vmul.f32	s15, s14, s15
   11302:	e79c      	b.n	1123e <HAL_RCCEx_GetPLL1ClockFreq+0x72>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   11304:	f44f 5110 	mov.w	r1, #9216	; 0x2400
   11308:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1130a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   1130e:	f6c4 4174 	movt	r1, #19572	; 0x4c74
   11312:	e784      	b.n	1121e <HAL_RCCEx_GetPLL1ClockFreq+0x52>

00011314 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
   11314:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
{
   11318:	b500      	push	{lr}
   1131a:	b085      	sub	sp, #20
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
   1131c:	d031      	beq.n	11382 <HAL_RCCEx_GetPeriphCLKFreq+0x6e>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
   1131e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   11322:	d018      	beq.n	11356 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
   11324:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   11328:	d05c      	beq.n	113e4 <HAL_RCCEx_GetPeriphCLKFreq+0xd0>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
   1132a:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
   1132e:	d03f      	beq.n	113b0 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
   11330:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   11334:	f000 80aa 	beq.w	1148c <HAL_RCCEx_GetPeriphCLKFreq+0x178>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
   11338:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
   1133c:	f000 80d0 	beq.w	114e0 <HAL_RCCEx_GetPeriphCLKFreq+0x1cc>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
   11340:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
   11344:	f000 80dd 	beq.w	11502 <HAL_RCCEx_GetPeriphCLKFreq+0x1ee>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
   11348:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
   1134c:	d079      	beq.n	11442 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
          frequency = 0;
   1134e:	2000      	movs	r0, #0
}
   11350:	b005      	add	sp, #20
   11352:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
   11356:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   1135a:	f6c5 0202 	movt	r2, #22530	; 0x5802
   1135e:	6d13      	ldr	r3, [r2, #80]	; 0x50
   11360:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
      switch (saiclocksource)
   11364:	2b80      	cmp	r3, #128	; 0x80
   11366:	d051      	beq.n	1140c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
   11368:	f200 8085 	bhi.w	11476 <HAL_RCCEx_GetPeriphCLKFreq+0x162>
   1136c:	2b00      	cmp	r3, #0
   1136e:	d046      	beq.n	113fe <HAL_RCCEx_GetPeriphCLKFreq+0xea>
   11370:	2b40      	cmp	r3, #64	; 0x40
   11372:	d1ec      	bne.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   11374:	a801      	add	r0, sp, #4
   11376:	f7ff fde1 	bl	10f3c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
   1137a:	9801      	ldr	r0, [sp, #4]
}
   1137c:	b005      	add	sp, #20
   1137e:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
   11382:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   11386:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1138a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   1138c:	f003 0307 	and.w	r3, r3, #7
      switch (saiclocksource)
   11390:	2b04      	cmp	r3, #4
   11392:	d8dc      	bhi.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   11394:	a201      	add	r2, pc, #4	; (adr r2, 1139c <HAL_RCCEx_GetPeriphCLKFreq+0x88>)
   11396:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1139a:	bf00      	nop
   1139c:	000113ff 	.word	0x000113ff
   113a0:	00011375 	.word	0x00011375
   113a4:	0001140d 	.word	0x0001140d
   113a8:	000113d7 	.word	0x000113d7
   113ac:	0001141b 	.word	0x0001141b
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
   113b0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   113b4:	f6c5 0202 	movt	r2, #22530	; 0x5802
   113b8:	6d93      	ldr	r3, [r2, #88]	; 0x58
   113ba:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
      switch (saiclocksource)
   113be:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   113c2:	d023      	beq.n	1140c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
   113c4:	d874      	bhi.n	114b0 <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
   113c6:	b1d3      	cbz	r3, 113fe <HAL_RCCEx_GetPeriphCLKFreq+0xea>
   113c8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   113cc:	d0d2      	beq.n	11374 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
   113ce:	e7be      	b.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   113d0:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
   113d4:	d173      	bne.n	114be <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
          frequency = EXTERNAL_CLOCK_VALUE;
   113d6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   113da:	f2c0 00bb 	movt	r0, #187	; 0xbb
}
   113de:	b005      	add	sp, #20
   113e0:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
   113e4:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   113e8:	f6c5 0202 	movt	r2, #22530	; 0x5802
   113ec:	6d93      	ldr	r3, [r2, #88]	; 0x58
   113ee:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
      switch (saiclocksource)
   113f2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   113f6:	d009      	beq.n	1140c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
   113f8:	d8ea      	bhi.n	113d0 <HAL_RCCEx_GetPeriphCLKFreq+0xbc>
   113fa:	2b00      	cmp	r3, #0
   113fc:	d163      	bne.n	114c6 <HAL_RCCEx_GetPeriphCLKFreq+0x1b2>
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   113fe:	a801      	add	r0, sp, #4
   11400:	f7ff fee4 	bl	111cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
   11404:	9802      	ldr	r0, [sp, #8]
}
   11406:	b005      	add	sp, #20
   11408:	f85d fb04 	ldr.w	pc, [sp], #4
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   1140c:	a801      	add	r0, sp, #4
   1140e:	f7ff fe39 	bl	11084 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
   11412:	9801      	ldr	r0, [sp, #4]
}
   11414:	b005      	add	sp, #20
   11416:	f85d fb04 	ldr.w	pc, [sp], #4
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
   1141a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   1141e:	f6c5 0302 	movt	r3, #22530	; 0x5802
   11422:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
   11424:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
   11428:	d020      	beq.n	1146c <HAL_RCCEx_GetPeriphCLKFreq+0x158>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
   1142a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   1142e:	d079      	beq.n	11524 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
            frequency = HSE_VALUE;
   11430:	f647 0040 	movw	r0, #30784	; 0x7840
   11434:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   11438:	f2c0 107d 	movt	r0, #381	; 0x17d
   1143c:	bf18      	it	ne
   1143e:	2000      	movne	r0, #0
   11440:	e786      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
   11442:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   11446:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1144a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   1144c:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
      switch (srcclk)
   11450:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   11454:	d07f      	beq.n	11556 <HAL_RCCEx_GetPeriphCLKFreq+0x242>
   11456:	d96f      	bls.n	11538 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
   11458:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
   1145c:	d062      	beq.n	11524 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
   1145e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
   11462:	d073      	beq.n	1154c <HAL_RCCEx_GetPeriphCLKFreq+0x238>
   11464:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   11468:	f47f af71 	bne.w	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
            frequency = HSI_VALUE;
   1146c:	f44f 4010 	mov.w	r0, #36864	; 0x9000
   11470:	f2c0 30d0 	movt	r0, #976	; 0x3d0
   11474:	e76c      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (saiclocksource)
   11476:	2bc0      	cmp	r3, #192	; 0xc0
   11478:	d0ad      	beq.n	113d6 <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
   1147a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1147e:	f47f af66 	bne.w	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
   11482:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
   11484:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
   11488:	d1cf      	bne.n	1142a <HAL_RCCEx_GetPeriphCLKFreq+0x116>
   1148a:	e7ef      	b.n	1146c <HAL_RCCEx_GetPeriphCLKFreq+0x158>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
   1148c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   11490:	f6c5 0202 	movt	r2, #22530	; 0x5802
   11494:	6d13      	ldr	r3, [r2, #80]	; 0x50
   11496:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
      switch (srcclk)
   1149a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   1149e:	d0b5      	beq.n	1140c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
   114a0:	d816      	bhi.n	114d0 <HAL_RCCEx_GetPeriphCLKFreq+0x1bc>
   114a2:	2b00      	cmp	r3, #0
   114a4:	d0ab      	beq.n	113fe <HAL_RCCEx_GetPeriphCLKFreq+0xea>
   114a6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   114aa:	f43f af63 	beq.w	11374 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
   114ae:	e74e      	b.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   114b0:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
   114b4:	d08f      	beq.n	113d6 <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
   114b6:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
   114ba:	d0e2      	beq.n	11482 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
   114bc:	e747      	b.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   114be:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   114c2:	d0de      	beq.n	11482 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
   114c4:	e743      	b.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   114c6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
   114ca:	f43f af53 	beq.w	11374 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
   114ce:	e73e      	b.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (srcclk)
   114d0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
   114d4:	f43f af7f 	beq.w	113d6 <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
   114d8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   114dc:	d0d1      	beq.n	11482 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
   114de:	e736      	b.n	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
   114e0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   114e4:	f6c5 0202 	movt	r2, #22530	; 0x5802
   114e8:	6d93      	ldr	r3, [r2, #88]	; 0x58
   114ea:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
      switch (srcclk)
   114ee:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   114f2:	d01c      	beq.n	1152e <HAL_RCCEx_GetPeriphCLKFreq+0x21a>
   114f4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   114f8:	d0c3      	beq.n	11482 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
   114fa:	2b00      	cmp	r3, #0
   114fc:	f47f af27 	bne.w	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   11500:	e738      	b.n	11374 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
   11502:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   11506:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1150a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
      switch (srcclk)
   1150c:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   11510:	f43f af75 	beq.w	113fe <HAL_RCCEx_GetPeriphCLKFreq+0xea>
   11514:	2b00      	cmp	r3, #0
   11516:	f43f af1a 	beq.w	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   1151a:	a801      	add	r0, sp, #4
   1151c:	f7ff fd0e 	bl	10f3c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
   11520:	9803      	ldr	r0, [sp, #12]
          break;
   11522:	e715      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
            frequency = CSI_VALUE;
   11524:	f44f 6010 	mov.w	r0, #2304	; 0x900
   11528:	f2c0 003d 	movt	r0, #61	; 0x3d
   1152c:	e710      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   1152e:	a801      	add	r0, sp, #4
   11530:	f7ff fda8 	bl	11084 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
   11534:	9803      	ldr	r0, [sp, #12]
          break;
   11536:	e70b      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (srcclk)
   11538:	b193      	cbz	r3, 11560 <HAL_RCCEx_GetPeriphCLKFreq+0x24c>
   1153a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   1153e:	f47f af06 	bne.w	1134e <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   11542:	a801      	add	r0, sp, #4
   11544:	f7ff fcfa 	bl	10f3c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
   11548:	9802      	ldr	r0, [sp, #8]
          break;
   1154a:	e701      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          frequency = HSE_VALUE;
   1154c:	f647 0040 	movw	r0, #30784	; 0x7840
   11550:	f2c0 107d 	movt	r0, #381	; 0x17d
          break;
   11554:	e6fc      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   11556:	a801      	add	r0, sp, #4
   11558:	f7ff fd94 	bl	11084 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
   1155c:	9802      	ldr	r0, [sp, #8]
          break;
   1155e:	e6f7      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
   11560:	f7fe fb0a 	bl	fb78 <HAL_RCC_GetHCLKFreq>
   11564:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   11568:	f244 72c4 	movw	r2, #18372	; 0x47c4
   1156c:	f6c5 0302 	movt	r3, #22530	; 0x5802
   11570:	f2c0 0203 	movt	r2, #3
   11574:	6a1b      	ldr	r3, [r3, #32]
   11576:	f3c3 1302 	ubfx	r3, r3, #4, #3
   1157a:	5cd3      	ldrb	r3, [r2, r3]
   1157c:	f003 031f 	and.w	r3, r3, #31
   11580:	40d8      	lsrs	r0, r3
          break;
   11582:	e6e5      	b.n	11350 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>

00011584 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
   11584:	2800      	cmp	r0, #0
   11586:	d052      	beq.n	1162e <HAL_RNG_Init+0xaa>
{
   11588:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_RNG_ALL_INSTANCE(hrng->Instance));
   1158a:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   1158e:	6802      	ldr	r2, [r0, #0]
   11590:	4604      	mov	r4, r0
   11592:	f6c4 0302 	movt	r3, #18434	; 0x4802
   11596:	429a      	cmp	r2, r3
   11598:	d006      	beq.n	115a8 <HAL_RNG_Init+0x24>
   1159a:	f643 108c 	movw	r0, #14732	; 0x398c
   1159e:	21b1      	movs	r1, #177	; 0xb1
   115a0:	f2c0 0003 	movt	r0, #3
   115a4:	f009 fd84 	bl	1b0b0 <assert_failed>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
   115a8:	6863      	ldr	r3, [r4, #4]
   115aa:	f033 0320 	bics.w	r3, r3, #32
   115ae:	d131      	bne.n	11614 <HAL_RNG_Init+0x90>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
   115b0:	7a63      	ldrb	r3, [r4, #9]
   115b2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   115b6:	b343      	cbz	r3, 1160a <HAL_RNG_Init+0x86>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
   115b8:	2302      	movs	r3, #2
      return HAL_ERROR;
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
   115ba:	e9d4 2100 	ldrd	r2, r1, [r4]
  hrng->State = HAL_RNG_STATE_BUSY;
   115be:	7263      	strb	r3, [r4, #9]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
   115c0:	6813      	ldr	r3, [r2, #0]
   115c2:	f023 0320 	bic.w	r3, r3, #32
   115c6:	430b      	orrs	r3, r1
   115c8:	6013      	str	r3, [r2, #0]
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
   115ca:	6822      	ldr	r2, [r4, #0]
   115cc:	6813      	ldr	r3, [r2, #0]
   115ce:	f043 0304 	orr.w	r3, r3, #4
   115d2:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
   115d4:	6823      	ldr	r3, [r4, #0]
   115d6:	685b      	ldr	r3, [r3, #4]
   115d8:	065b      	lsls	r3, r3, #25
   115da:	d503      	bpl.n	115e4 <HAL_RNG_Init+0x60>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
   115dc:	2304      	movs	r3, #4
    return HAL_ERROR;
   115de:	2001      	movs	r0, #1
    hrng->State = HAL_RNG_STATE_ERROR;
   115e0:	7263      	strb	r3, [r4, #9]
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
   115e2:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
   115e4:	f7f6 ff2c 	bl	8440 <HAL_GetTick>
   115e8:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
   115ea:	e004      	b.n	115f6 <HAL_RNG_Init+0x72>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
   115ec:	f7f6 ff28 	bl	8440 <HAL_GetTick>
   115f0:	1b40      	subs	r0, r0, r5
   115f2:	2802      	cmp	r0, #2
   115f4:	d81d      	bhi.n	11632 <HAL_RNG_Init+0xae>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
   115f6:	6823      	ldr	r3, [r4, #0]
   115f8:	685b      	ldr	r3, [r3, #4]
   115fa:	f013 0304 	ands.w	r3, r3, #4
   115fe:	d1f5      	bne.n	115ec <HAL_RNG_Init+0x68>
  hrng->State = HAL_RNG_STATE_READY;
   11600:	2201      	movs	r2, #1
  return HAL_OK;
   11602:	4618      	mov	r0, r3
  hrng->State = HAL_RNG_STATE_READY;
   11604:	7262      	strb	r2, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
   11606:	60e3      	str	r3, [r4, #12]
}
   11608:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
   1160a:	7222      	strb	r2, [r4, #8]
    HAL_RNG_MspInit(hrng);
   1160c:	4620      	mov	r0, r4
   1160e:	f00a fb51 	bl	1bcb4 <HAL_RNG_MspInit>
   11612:	e7d1      	b.n	115b8 <HAL_RNG_Init+0x34>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
   11614:	f643 108c 	movw	r0, #14732	; 0x398c
   11618:	21b2      	movs	r1, #178	; 0xb2
   1161a:	f2c0 0003 	movt	r0, #3
   1161e:	f009 fd47 	bl	1b0b0 <assert_failed>
  if (hrng->State == HAL_RNG_STATE_RESET)
   11622:	7a63      	ldrb	r3, [r4, #9]
   11624:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   11628:	2b00      	cmp	r3, #0
   1162a:	d1c5      	bne.n	115b8 <HAL_RNG_Init+0x34>
   1162c:	e7ed      	b.n	1160a <HAL_RNG_Init+0x86>
    return HAL_ERROR;
   1162e:	2001      	movs	r0, #1
}
   11630:	4770      	bx	lr
      hrng->State = HAL_RNG_STATE_ERROR;
   11632:	2204      	movs	r2, #4
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   11634:	2302      	movs	r3, #2
      return HAL_ERROR;
   11636:	2001      	movs	r0, #1
      hrng->State = HAL_RNG_STATE_ERROR;
   11638:	7262      	strb	r2, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   1163a:	60e3      	str	r3, [r4, #12]
}
   1163c:	bd38      	pop	{r3, r4, r5, pc}
   1163e:	bf00      	nop

00011640 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
   11640:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
   11642:	7a03      	ldrb	r3, [r0, #8]
   11644:	2b01      	cmp	r3, #1
   11646:	d00b      	beq.n	11660 <HAL_RNG_GenerateRandomNumber+0x20>
   11648:	4604      	mov	r4, r0
   1164a:	2001      	movs	r0, #1
   1164c:	460e      	mov	r6, r1

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
   1164e:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng);
   11650:	7220      	strb	r0, [r4, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
   11652:	4283      	cmp	r3, r0
   11654:	d006      	beq.n	11664 <HAL_RNG_GenerateRandomNumber+0x24>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
   11656:	2304      	movs	r3, #4
   11658:	60e3      	str	r3, [r4, #12]
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
   1165a:	2300      	movs	r3, #0
   1165c:	7223      	strb	r3, [r4, #8]

  return status;
}
   1165e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrng);
   11660:	2002      	movs	r0, #2
}
   11662:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
   11664:	2302      	movs	r3, #2
   11666:	7263      	strb	r3, [r4, #9]
    tickstart = HAL_GetTick();
   11668:	f7f6 feea 	bl	8440 <HAL_GetTick>
   1166c:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
   1166e:	e004      	b.n	1167a <HAL_RNG_GenerateRandomNumber+0x3a>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
   11670:	f7f6 fee6 	bl	8440 <HAL_GetTick>
   11674:	1bc0      	subs	r0, r0, r7
   11676:	2802      	cmp	r0, #2
   11678:	d80b      	bhi.n	11692 <HAL_RNG_GenerateRandomNumber+0x52>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
   1167a:	6822      	ldr	r2, [r4, #0]
   1167c:	6855      	ldr	r5, [r2, #4]
   1167e:	f015 0501 	ands.w	r5, r5, #1
   11682:	d0f5      	beq.n	11670 <HAL_RNG_GenerateRandomNumber+0x30>
    hrng->RandomNumber = hrng->Instance->DR;
   11684:	6893      	ldr	r3, [r2, #8]
    hrng->State = HAL_RNG_STATE_READY;
   11686:	2201      	movs	r2, #1
  HAL_StatusTypeDef status = HAL_OK;
   11688:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
   1168a:	6123      	str	r3, [r4, #16]
    *random32bit = hrng->RandomNumber;
   1168c:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
   1168e:	7262      	strb	r2, [r4, #9]
   11690:	e7e3      	b.n	1165a <HAL_RNG_GenerateRandomNumber+0x1a>
        hrng->State = HAL_RNG_STATE_READY;
   11692:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   11694:	2302      	movs	r3, #2
        __HAL_UNLOCK(hrng);
   11696:	7225      	strb	r5, [r4, #8]
        hrng->State = HAL_RNG_STATE_READY;
   11698:	7260      	strb	r0, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   1169a:	60e3      	str	r3, [r4, #12]
}
   1169c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1169e:	bf00      	nop

000116a0 <HAL_SAI_InitProtocol>:
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
  HAL_StatusTypeDef status;

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   116a0:	2904      	cmp	r1, #4
{
   116a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   116a4:	460d      	mov	r5, r1
   116a6:	4604      	mov	r4, r0
   116a8:	4617      	mov	r7, r2
   116aa:	461e      	mov	r6, r3
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   116ac:	f200 8089 	bhi.w	117c2 <HAL_SAI_InitProtocol+0x122>
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   116b0:	2f03      	cmp	r7, #3
   116b2:	d87d      	bhi.n	117b0 <HAL_SAI_InitProtocol+0x110>

  switch (protocol)
   116b4:	2d04      	cmp	r5, #4
   116b6:	d831      	bhi.n	1171c <HAL_SAI_InitProtocol+0x7c>
   116b8:	e8df f005 	tbb	[pc, r5]
   116bc:	32555555 	.word	0x32555555
   116c0:	32          	.byte	0x32
   116c1:	00          	.byte	0x00

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
   116c2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   116c4:	3b01      	subs	r3, #1
   116c6:	2b02      	cmp	r3, #2
   116c8:	d907      	bls.n	116da <HAL_SAI_InitProtocol+0x3a>
   116ca:	f643 10c4 	movw	r0, #14788	; 0x39c4
   116ce:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   116d2:	f2c0 0003 	movt	r0, #3
   116d6:	f009 fceb 	bl	1b0b0 <assert_failed>
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
   116da:	6c23      	ldr	r3, [r4, #64]	; 0x40
   116dc:	b113      	cbz	r3, 116e4 <HAL_SAI_InitProtocol+0x44>
   116de:	f433 7340 	bics.w	r3, r3, #768	; 0x300
   116e2:	d007      	beq.n	116f4 <HAL_SAI_InitProtocol+0x54>
   116e4:	f643 10c4 	movw	r0, #14788	; 0x39c4
   116e8:	f240 11af 	movw	r1, #431	; 0x1af
   116ec:	f2c0 0003 	movt	r0, #3
   116f0:	f009 fcde 	bl	1b0b0 <assert_failed>
    /* Check that SAI sub-block is SAI1 or SAI4 sub-block A, in master RX mode with free protocol */
#if defined(SAI4)
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
   116f4:	f645 0204 	movw	r2, #22532	; 0x5804
   116f8:	6823      	ldr	r3, [r4, #0]
   116fa:	f2c4 0201 	movt	r2, #16385	; 0x4001
   116fe:	4293      	cmp	r3, r2
   11700:	d005      	beq.n	1170e <HAL_SAI_InitProtocol+0x6e>
   11702:	f245 4204 	movw	r2, #21508	; 0x5404
   11706:	f6c5 0200 	movt	r2, #22528	; 0x5800
   1170a:	4293      	cmp	r3, r2
   1170c:	d106      	bne.n	1171c <HAL_SAI_InitProtocol+0x7c>
   1170e:	6862      	ldr	r2, [r4, #4]
   11710:	2a01      	cmp	r2, #1
   11712:	d103      	bne.n	1171c <HAL_SAI_InitProtocol+0x7c>
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
   11714:	6c62      	ldr	r2, [r4, #68]	; 0x44
   11716:	2a00      	cmp	r2, #0
   11718:	f000 8197 	beq.w	11a4a <HAL_SAI_InitProtocol+0x3aa>
  hsai->SlotInit.SlotNumber      = nbslot;

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
  {
    return HAL_ERROR;
   1171c:	2001      	movs	r0, #1
}
   1171e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef status = HAL_OK;

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11720:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   11722:	2300      	movs	r3, #0
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
   11724:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   11728:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1172c:	f032 0202 	bics.w	r2, r2, #2
  hsai->SlotInit.FirstBitOffset  = 0;
  hsai->SlotInit.SlotNumber      = nbslot;
   11730:	6726      	str	r6, [r4, #112]	; 0x70
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   11732:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11734:	bf0c      	ite	eq
   11736:	2201      	moveq	r2, #1
   11738:	461a      	movne	r2, r3
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;

  if (protocol == SAI_PCM_SHORT)
  {
      hsai->FrameInit.ActiveFrameLength = 1;
   1173a:	2d04      	cmp	r5, #4
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1173c:	64e3      	str	r3, [r4, #76]	; 0x4c
   1173e:	6522      	str	r2, [r4, #80]	; 0x50
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   11740:	f64f 72ff 	movw	r2, #65535	; 0xffff
      hsai->FrameInit.ActiveFrameLength = 1;
   11744:	bf14      	ite	ne
   11746:	250d      	movne	r5, #13
   11748:	2501      	moveq	r5, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
   1174a:	65e3      	str	r3, [r4, #92]	; 0x5c
   1174c:	65a5      	str	r5, [r4, #88]	; 0x58
  hsai->SlotInit.FirstBitOffset  = 0;
   1174e:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   11750:	6762      	str	r2, [r4, #116]	; 0x74
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   11752:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
  {
    /* SAI_PCM_LONG */
      hsai->FrameInit.ActiveFrameLength = 13;
  }

  switch (datasize)
   11756:	2f03      	cmp	r7, #3
   11758:	d8e0      	bhi.n	1171c <HAL_SAI_InitProtocol+0x7c>
   1175a:	e8df f017 	tbh	[pc, r7, lsl #1]
   1175e:	01b6      	.short	0x01b6
   11760:	01bd01b0 	.word	0x01bd01b0
   11764:	003b      	.short	0x003b
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11766:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   11768:	2300      	movs	r3, #0
  hsai->SlotInit.SlotNumber      = nbslot;
   1176a:	6726      	str	r6, [r4, #112]	; 0x70
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1176c:	f032 0202 	bics.w	r2, r2, #2
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   11770:	6463      	str	r3, [r4, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   11772:	64e3      	str	r3, [r4, #76]	; 0x4c
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   11774:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11778:	bf08      	it	eq
   1177a:	4619      	moveq	r1, r3
  hsai->SlotInit.FirstBitOffset  = 0;
   1177c:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1177e:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11782:	bf18      	it	ne
   11784:	2101      	movne	r1, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   11786:	65e2      	str	r2, [r4, #92]	; 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   11788:	6763      	str	r3, [r4, #116]	; 0x74
  if ((nbslot & 0x1U) != 0U)
   1178a:	f016 0301 	ands.w	r3, r6, #1
   1178e:	6521      	str	r1, [r4, #80]	; 0x50
   11790:	d1c4      	bne.n	1171c <HAL_SAI_InitProtocol+0x7c>
  if (protocol == SAI_I2S_STANDARD)
   11792:	2d00      	cmp	r5, #0
   11794:	f000 81a7 	beq.w	11ae6 <HAL_SAI_InitProtocol+0x446>
   11798:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1179c:	e9c4 2318 	strd	r2, r3, [r4, #96]	; 0x60
  switch (datasize)
   117a0:	2f03      	cmp	r7, #3
   117a2:	d8bb      	bhi.n	1171c <HAL_SAI_InitProtocol+0x7c>
   117a4:	e8df f017 	tbh	[pc, r7, lsl #1]
   117a8:	02b602c6 	.word	0x02b602c6
   117ac:	029b02a5 	.word	0x029b02a5
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   117b0:	f643 10c4 	movw	r0, #14788	; 0x39c4
   117b4:	f44f 71a9 	mov.w	r1, #338	; 0x152
   117b8:	f2c0 0003 	movt	r0, #3
   117bc:	f009 fc78 	bl	1b0b0 <assert_failed>
   117c0:	e778      	b.n	116b4 <HAL_SAI_InitProtocol+0x14>
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   117c2:	f643 10c4 	movw	r0, #14788	; 0x39c4
   117c6:	f240 1151 	movw	r1, #337	; 0x151
   117ca:	f2c0 0003 	movt	r0, #3
   117ce:	f009 fc6f 	bl	1b0b0 <assert_failed>
   117d2:	e76d      	b.n	116b0 <HAL_SAI_InitProtocol+0x10>
      hsai->FrameInit.FrameLength = 32U * nbslot;
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
      break;
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
      hsai->FrameInit.FrameLength = 32U * nbslot;
   117d4:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_32;
   117d6:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   117d8:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   117da:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_32;
   117dc:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   117de:	66e2      	str	r2, [r4, #108]	; 0x6c
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
   117e0:	f645 0304 	movw	r3, #22532	; 0x5804
   117e4:	f645 0524 	movw	r5, #22564	; 0x5824
   117e8:	6822      	ldr	r2, [r4, #0]
   117ea:	f645 4004 	movw	r0, #23556	; 0x5c04
   117ee:	f2c4 0301 	movt	r3, #16385	; 0x4001
   117f2:	f2c4 0501 	movt	r5, #16385	; 0x4001
   117f6:	f2c4 0001 	movt	r0, #16385	; 0x4001
   117fa:	f645 4124 	movw	r1, #23588	; 0x5c24
   117fe:	429a      	cmp	r2, r3
   11800:	bf18      	it	ne
   11802:	42aa      	cmpne	r2, r5
   11804:	f246 0504 	movw	r5, #24580	; 0x6004
   11808:	f2c4 0101 	movt	r1, #16385	; 0x4001
   1180c:	bf14      	ite	ne
   1180e:	2301      	movne	r3, #1
   11810:	2300      	moveq	r3, #0
   11812:	f2c4 0501 	movt	r5, #16385	; 0x4001
   11816:	4282      	cmp	r2, r0
   11818:	bf0c      	ite	eq
   1181a:	2300      	moveq	r3, #0
   1181c:	f003 0301 	andne.w	r3, r3, #1
   11820:	f246 0024 	movw	r0, #24612	; 0x6024
   11824:	428a      	cmp	r2, r1
   11826:	bf0c      	ite	eq
   11828:	2300      	moveq	r3, #0
   1182a:	f003 0301 	andne.w	r3, r3, #1
   1182e:	f2c4 0001 	movt	r0, #16385	; 0x4001
   11832:	f245 4104 	movw	r1, #21508	; 0x5404
   11836:	42aa      	cmp	r2, r5
   11838:	bf0c      	ite	eq
   1183a:	2300      	moveq	r3, #0
   1183c:	f003 0301 	andne.w	r3, r3, #1
   11840:	f6c5 0100 	movt	r1, #22528	; 0x5800
   11844:	4282      	cmp	r2, r0
   11846:	bf0c      	ite	eq
   11848:	2300      	moveq	r3, #0
   1184a:	f003 0301 	andne.w	r3, r3, #1
   1184e:	428a      	cmp	r2, r1
   11850:	bf0c      	ite	eq
   11852:	2300      	moveq	r3, #0
   11854:	f003 0301 	andne.w	r3, r3, #1
   11858:	b133      	cbz	r3, 11868 <HAL_SAI_InitProtocol+0x1c8>
   1185a:	f245 4324 	movw	r3, #21540	; 0x5424
   1185e:	f6c5 0300 	movt	r3, #22528	; 0x5800
   11862:	429a      	cmp	r2, r3
   11864:	f040 83de 	bne.w	12024 <HAL_SAI_InitProtocol+0x984>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
   11868:	f44f 436e 	mov.w	r3, #60928	; 0xee00
   1186c:	f44f 41ee 	mov.w	r1, #30464	; 0x7700
   11870:	6a22      	ldr	r2, [r4, #32]
   11872:	f64b 3680 	movw	r6, #48000	; 0xbb80
   11876:	f2c0 0302 	movt	r3, #2
   1187a:	f2c0 0101 	movt	r1, #1
   1187e:	f64a 4544 	movw	r5, #44100	; 0xac44
   11882:	f245 6022 	movw	r0, #22050	; 0x5622
   11886:	429a      	cmp	r2, r3
   11888:	bf18      	it	ne
   1188a:	428a      	cmpne	r2, r1
   1188c:	f642 3111 	movw	r1, #11025	; 0x2b11
   11890:	bf14      	ite	ne
   11892:	2301      	movne	r3, #1
   11894:	2300      	moveq	r3, #0
   11896:	42b2      	cmp	r2, r6
   11898:	bf0c      	ite	eq
   1189a:	2300      	moveq	r3, #0
   1189c:	f003 0301 	andne.w	r3, r3, #1
   118a0:	42aa      	cmp	r2, r5
   118a2:	bf0c      	ite	eq
   118a4:	2300      	moveq	r3, #0
   118a6:	f003 0301 	andne.w	r3, r3, #1
   118aa:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
   118ae:	bf0c      	ite	eq
   118b0:	2300      	moveq	r3, #0
   118b2:	f003 0301 	andne.w	r3, r3, #1
   118b6:	4282      	cmp	r2, r0
   118b8:	bf0c      	ite	eq
   118ba:	2300      	moveq	r3, #0
   118bc:	f003 0301 	andne.w	r3, r3, #1
   118c0:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
   118c4:	bf0c      	ite	eq
   118c6:	2300      	moveq	r3, #0
   118c8:	f003 0301 	andne.w	r3, r3, #1
   118cc:	428a      	cmp	r2, r1
   118ce:	bf0c      	ite	eq
   118d0:	2300      	moveq	r3, #0
   118d2:	f003 0301 	andne.w	r3, r3, #1
   118d6:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
   118da:	bf0c      	ite	eq
   118dc:	2300      	moveq	r3, #0
   118de:	f003 0301 	andne.w	r3, r3, #1
   118e2:	b113      	cbz	r3, 118ea <HAL_SAI_InitProtocol+0x24a>
   118e4:	2a00      	cmp	r2, #0
   118e6:	f040 83b1 	bne.w	1204c <HAL_SAI_InitProtocol+0x9ac>
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
   118ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
   118ec:	f033 0204 	bics.w	r2, r3, #4
   118f0:	d009      	beq.n	11906 <HAL_SAI_InitProtocol+0x266>
   118f2:	2b08      	cmp	r3, #8
   118f4:	d007      	beq.n	11906 <HAL_SAI_InitProtocol+0x266>
   118f6:	f643 10c4 	movw	r0, #14788	; 0x39c4
   118fa:	f240 1185 	movw	r1, #389	; 0x185
   118fe:	f2c0 0003 	movt	r0, #3
   11902:	f009 fbd5 	bl	1b0b0 <assert_failed>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
   11906:	6863      	ldr	r3, [r4, #4]
   11908:	2b03      	cmp	r3, #3
   1190a:	f200 8197 	bhi.w	11c3c <HAL_SAI_InitProtocol+0x59c>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
   1190e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   11910:	f023 0220 	bic.w	r2, r3, #32
   11914:	2a80      	cmp	r2, #128	; 0x80
   11916:	d004      	beq.n	11922 <HAL_SAI_InitProtocol+0x282>
   11918:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
   1191c:	2b40      	cmp	r3, #64	; 0x40
   1191e:	f040 835c 	bne.w	11fda <HAL_SAI_InitProtocol+0x93a>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
   11922:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   11924:	f433 7380 	bics.w	r3, r3, #256	; 0x100
   11928:	f040 817f 	bne.w	11c2a <HAL_SAI_InitProtocol+0x58a>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
   1192c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1192e:	2b01      	cmp	r3, #1
   11930:	d907      	bls.n	11942 <HAL_SAI_InitProtocol+0x2a2>
   11932:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11936:	f240 1189 	movw	r1, #393	; 0x189
   1193a:	f2c0 0003 	movt	r0, #3
   1193e:	f009 fbb7 	bl	1b0b0 <assert_failed>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
   11942:	68a3      	ldr	r3, [r4, #8]
   11944:	2b05      	cmp	r3, #5
   11946:	f200 8167 	bhi.w	11c18 <HAL_SAI_InitProtocol+0x578>
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   1194a:	f7f6 fd93 	bl	8474 <HAL_GetREVID>
   1194e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
   11952:	d304      	bcc.n	1195e <HAL_SAI_InitProtocol+0x2be>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
   11954:	6923      	ldr	r3, [r4, #16]
   11956:	f033 6300 	bics.w	r3, r3, #134217728	; 0x8000000
   1195a:	f040 82fd 	bne.w	11f58 <HAL_SAI_InitProtocol+0x8b8>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
   1195e:	6963      	ldr	r3, [r4, #20]
   11960:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
   11964:	f040 814f 	bne.w	11c06 <HAL_SAI_InitProtocol+0x566>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
   11968:	69a3      	ldr	r3, [r4, #24]
   1196a:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
   1196e:	f040 81ad 	bne.w	11ccc <HAL_SAI_InitProtocol+0x62c>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
   11972:	69e3      	ldr	r3, [r4, #28]
   11974:	2b04      	cmp	r3, #4
   11976:	f200 81a0 	bhi.w	11cba <HAL_SAI_InitProtocol+0x61a>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
   1197a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1197c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   11980:	f040 8192 	bne.w	11ca8 <HAL_SAI_InitProtocol+0x608>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
   11984:	6b23      	ldr	r3, [r4, #48]	; 0x30
   11986:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
   1198a:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
   1198e:	f5b1 4f20 	cmp.w	r1, #40960	; 0xa000
   11992:	bf18      	it	ne
   11994:	2a00      	cmpne	r2, #0
   11996:	d003      	beq.n	119a0 <HAL_SAI_InitProtocol+0x300>
   11998:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
   1199c:	f040 830f 	bne.w	11fbe <HAL_SAI_InitProtocol+0x91e>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
   119a0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   119a2:	f033 0310 	bics.w	r3, r3, #16
   119a6:	f040 8176 	bne.w	11c96 <HAL_SAI_InitProtocol+0x5f6>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
   119aa:	68e3      	ldr	r3, [r4, #12]
   119ac:	2b02      	cmp	r3, #2
   119ae:	f200 8169 	bhi.w	11c84 <HAL_SAI_InitProtocol+0x5e4>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
   119b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   119b4:	f033 6380 	bics.w	r3, r3, #67108864	; 0x4000000
   119b8:	f040 815b 	bne.w	11c72 <HAL_SAI_InitProtocol+0x5d2>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
   119bc:	6d63      	ldr	r3, [r4, #84]	; 0x54
   119be:	3b08      	subs	r3, #8
   119c0:	2bf8      	cmp	r3, #248	; 0xf8
   119c2:	f200 814d 	bhi.w	11c60 <HAL_SAI_InitProtocol+0x5c0>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
   119c6:	6da3      	ldr	r3, [r4, #88]	; 0x58
   119c8:	3b01      	subs	r3, #1
   119ca:	2b7f      	cmp	r3, #127	; 0x7f
   119cc:	f200 813f 	bhi.w	11c4e <HAL_SAI_InitProtocol+0x5ae>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
   119d0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   119d2:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
   119d6:	f040 810d 	bne.w	11bf4 <HAL_SAI_InitProtocol+0x554>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
   119da:	6e23      	ldr	r3, [r4, #96]	; 0x60
   119dc:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   119e0:	f040 80ff 	bne.w	11be2 <HAL_SAI_InitProtocol+0x542>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
   119e4:	6e63      	ldr	r3, [r4, #100]	; 0x64
   119e6:	f433 2380 	bics.w	r3, r3, #262144	; 0x40000
   119ea:	f040 80f1 	bne.w	11bd0 <HAL_SAI_InitProtocol+0x530>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
   119ee:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   119f0:	2b18      	cmp	r3, #24
   119f2:	f200 80e4 	bhi.w	11bbe <HAL_SAI_InitProtocol+0x51e>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
   119f6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   119f8:	f033 0240 	bics.w	r2, r3, #64	; 0x40
   119fc:	d009      	beq.n	11a12 <HAL_SAI_InitProtocol+0x372>
   119fe:	2b80      	cmp	r3, #128	; 0x80
   11a00:	d007      	beq.n	11a12 <HAL_SAI_InitProtocol+0x372>
   11a02:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11a06:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
   11a0a:	f2c0 0003 	movt	r0, #3
   11a0e:	f009 fb4f 	bl	1b0b0 <assert_failed>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
   11a12:	6f23      	ldr	r3, [r4, #112]	; 0x70
   11a14:	3b01      	subs	r3, #1
   11a16:	2b0f      	cmp	r3, #15
   11a18:	f200 80c8 	bhi.w	11bac <HAL_SAI_InitProtocol+0x50c>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
   11a1c:	6f63      	ldr	r3, [r4, #116]	; 0x74
   11a1e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   11a22:	f080 80ba 	bcs.w	11b9a <HAL_SAI_InitProtocol+0x4fa>
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
   11a26:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   11a2a:	2b01      	cmp	r3, #1
   11a2c:	d909      	bls.n	11a42 <HAL_SAI_InitProtocol+0x3a2>
   11a2e:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11a32:	f240 11ab 	movw	r1, #427	; 0x1ab
   11a36:	f2c0 0003 	movt	r0, #3
   11a3a:	f009 fb39 	bl	1b0b0 <assert_failed>
   11a3e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
  if (hsai->Init.PdmInit.Activation == ENABLE)
   11a42:	2b01      	cmp	r3, #1
   11a44:	f43f ae3d 	beq.w	116c2 <HAL_SAI_InitProtocol+0x22>
   11a48:	6823      	ldr	r3, [r4, #0]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
   11a4a:	f645 0204 	movw	r2, #22532	; 0x5804
   11a4e:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11a52:	4293      	cmp	r3, r2
   11a54:	d054      	beq.n	11b00 <HAL_SAI_InitProtocol+0x460>
   11a56:	f645 0224 	movw	r2, #22564	; 0x5824
   11a5a:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11a5e:	4293      	cmp	r3, r2
   11a60:	d04e      	beq.n	11b00 <HAL_SAI_InitProtocol+0x460>
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
   11a62:	f645 4204 	movw	r2, #23556	; 0x5c04
   11a66:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11a6a:	4293      	cmp	r3, r2
   11a6c:	f000 8171 	beq.w	11d52 <HAL_SAI_InitProtocol+0x6b2>
   11a70:	f645 4224 	movw	r2, #23588	; 0x5c24
   11a74:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11a78:	4293      	cmp	r3, r2
   11a7a:	f000 816a 	beq.w	11d52 <HAL_SAI_InitProtocol+0x6b2>
  else if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
   11a7e:	f246 0204 	movw	r2, #24580	; 0x6004
   11a82:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11a86:	4293      	cmp	r3, r2
   11a88:	f000 82a2 	beq.w	11fd0 <HAL_SAI_InitProtocol+0x930>
   11a8c:	f246 0224 	movw	r2, #24612	; 0x6024
   11a90:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11a94:	4293      	cmp	r3, r2
   11a96:	f000 829b 	beq.w	11fd0 <HAL_SAI_InitProtocol+0x930>
  else if ((hsai->Instance == SAI4_Block_A) || (hsai->Instance == SAI4_Block_B))
   11a9a:	f245 4204 	movw	r2, #21508	; 0x5404
   11a9e:	f6c5 0200 	movt	r2, #22528	; 0x5800
   11aa2:	4293      	cmp	r3, r2
   11aa4:	d006      	beq.n	11ab4 <HAL_SAI_InitProtocol+0x414>
   11aa6:	f245 4224 	movw	r2, #21540	; 0x5424
   11aaa:	f6c5 0200 	movt	r2, #22528	; 0x5800
   11aae:	4293      	cmp	r3, r2
   11ab0:	f47f ae34 	bne.w	1171c <HAL_SAI_InitProtocol+0x7c>
    SaiBaseAddress = SAI4;
   11ab4:	f44f 45a8 	mov.w	r5, #21504	; 0x5400
   11ab8:	f6c5 0500 	movt	r5, #22528	; 0x5800
   11abc:	e024      	b.n	11b08 <HAL_SAI_InitProtocol+0x468>
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11abe:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   11ac0:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11ac2:	64a2      	str	r2, [r4, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
   11ac4:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11ac6:	66e2      	str	r2, [r4, #108]	; 0x6c
   11ac8:	e68a      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 16U * nbslot;
   11aca:	0136      	lsls	r6, r6, #4
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11acc:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   11ace:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 16U * nbslot;
   11ad0:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11ad2:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   11ad4:	66e2      	str	r2, [r4, #108]	; 0x6c
   11ad6:	e683      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 32U * nbslot;
   11ad8:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_24;
   11ada:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11adc:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   11ade:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_24;
   11ae0:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11ae2:	66e2      	str	r2, [r4, #108]	; 0x6c
   11ae4:	e67c      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
   11ae6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   11aea:	e9c4 5318 	strd	r5, r3, [r4, #96]	; 0x60
  switch (datasize)
   11aee:	2f03      	cmp	r7, #3
   11af0:	f63f ae14 	bhi.w	1171c <HAL_SAI_InitProtocol+0x7c>
   11af4:	e8df f017 	tbh	[pc, r7, lsl #1]
   11af8:	010e011e 	.word	0x010e011e
   11afc:	00f300fd 	.word	0x00f300fd
    SaiBaseAddress = SAI1;
   11b00:	f44f 45b0 	mov.w	r5, #22528	; 0x5800
   11b04:	f2c4 0501 	movt	r5, #16385	; 0x4001
  if (hsai->State == HAL_SAI_STATE_RESET)
   11b08:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
   11b0c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   11b10:	2a00      	cmp	r2, #0
   11b12:	f000 821a 	beq.w	11f4a <HAL_SAI_InitProtocol+0x8aa>
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11b16:	f246 20b4 	movw	r0, #25268	; 0x62b4
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
   11b1a:	6819      	ldr	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11b1c:	f64e 461b 	movw	r6, #60443	; 0xec1b
   11b20:	f2c0 0006 	movt	r0, #6
  __HAL_SAI_DISABLE(hsai);
   11b24:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11b28:	f2c9 56cb 	movt	r6, #38347	; 0x95cb
   11b2c:	6802      	ldr	r2, [r0, #0]
  __HAL_SAI_DISABLE(hsai);
   11b2e:	6019      	str	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11b30:	fba6 3202 	umull	r3, r2, r6, r2
   11b34:	0b12      	lsrs	r2, r2, #12

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
   11b36:	0093      	lsls	r3, r2, #2
   11b38:	b33a      	cbz	r2, 11b8a <HAL_SAI_InitProtocol+0x4ea>
      status = HAL_TIMEOUT;
      break;
    }
    count--;
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11b3a:	6821      	ldr	r1, [r4, #0]
    count--;
   11b3c:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11b3e:	680a      	ldr	r2, [r1, #0]
   11b40:	03d7      	lsls	r7, r2, #15
   11b42:	d504      	bpl.n	11b4e <HAL_SAI_InitProtocol+0x4ae>
    if (count == 0U)
   11b44:	b30b      	cbz	r3, 11b8a <HAL_SAI_InitProtocol+0x4ea>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11b46:	680a      	ldr	r2, [r1, #0]
    count--;
   11b48:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11b4a:	03d2      	lsls	r2, r2, #15
   11b4c:	d4fa      	bmi.n	11b44 <HAL_SAI_InitProtocol+0x4a4>
  switch (hsai->Init.SynchroExt)
   11b4e:	68e3      	ldr	r3, [r4, #12]
  hsai->State = HAL_SAI_STATE_BUSY;
   11b50:	2202      	movs	r2, #2
  switch (hsai->Init.SynchroExt)
   11b52:	2b01      	cmp	r3, #1
  hsai->State = HAL_SAI_STATE_BUSY;
   11b54:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
  switch (hsai->Init.SynchroExt)
   11b58:	f000 80f6 	beq.w	11d48 <HAL_SAI_InitProtocol+0x6a8>
   11b5c:	4293      	cmp	r3, r2
   11b5e:	bf15      	itete	ne
   11b60:	4610      	movne	r0, r2
   11b62:	2123      	moveq	r1, #35	; 0x23
   11b64:	2103      	movne	r1, #3
   11b66:	2022      	moveq	r0, #34	; 0x22
   11b68:	bf0b      	itete	eq
   11b6a:	2621      	moveq	r6, #33	; 0x21
   11b6c:	2601      	movne	r6, #1
   11b6e:	2220      	moveq	r2, #32
   11b70:	2200      	movne	r2, #0
  switch (hsai->Init.Synchro)
   11b72:	68a3      	ldr	r3, [r4, #8]
   11b74:	3b01      	subs	r3, #1
   11b76:	2b04      	cmp	r3, #4
   11b78:	f200 81e1 	bhi.w	11f3e <HAL_SAI_InitProtocol+0x89e>
   11b7c:	e8df f013 	tbh	[pc, r3, lsl #1]
   11b80:	00ef01dc 	.word	0x00ef01dc
   11b84:	00ee01e1 	.word	0x00ee01e1
   11b88:	023c      	.short	0x023c
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   11b8a:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    return HAL_ERROR;
   11b8e:	2001      	movs	r0, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   11b90:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   11b94:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
   11b98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
   11b9a:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11b9e:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
   11ba2:	f2c0 0003 	movt	r0, #3
   11ba6:	f009 fa83 	bl	1b0b0 <assert_failed>
   11baa:	e73c      	b.n	11a26 <HAL_SAI_InitProtocol+0x386>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
   11bac:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11bb0:	f240 11a7 	movw	r1, #423	; 0x1a7
   11bb4:	f2c0 0003 	movt	r0, #3
   11bb8:	f009 fa7a 	bl	1b0b0 <assert_failed>
   11bbc:	e72e      	b.n	11a1c <HAL_SAI_InitProtocol+0x37c>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
   11bbe:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11bc2:	f240 11a5 	movw	r1, #421	; 0x1a5
   11bc6:	f2c0 0003 	movt	r0, #3
   11bca:	f009 fa71 	bl	1b0b0 <assert_failed>
   11bce:	e712      	b.n	119f6 <HAL_SAI_InitProtocol+0x356>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
   11bd0:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11bd4:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
   11bd8:	f2c0 0003 	movt	r0, #3
   11bdc:	f009 fa68 	bl	1b0b0 <assert_failed>
   11be0:	e705      	b.n	119ee <HAL_SAI_InitProtocol+0x34e>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
   11be2:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11be6:	f240 11a1 	movw	r1, #417	; 0x1a1
   11bea:	f2c0 0003 	movt	r0, #3
   11bee:	f009 fa5f 	bl	1b0b0 <assert_failed>
   11bf2:	e6f7      	b.n	119e4 <HAL_SAI_InitProtocol+0x344>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
   11bf4:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11bf8:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
   11bfc:	f2c0 0003 	movt	r0, #3
   11c00:	f009 fa56 	bl	1b0b0 <assert_failed>
   11c04:	e6e9      	b.n	119da <HAL_SAI_InitProtocol+0x33a>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
   11c06:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c0a:	f44f 71ca 	mov.w	r1, #404	; 0x194
   11c0e:	f2c0 0003 	movt	r0, #3
   11c12:	f009 fa4d 	bl	1b0b0 <assert_failed>
   11c16:	e6a7      	b.n	11968 <HAL_SAI_InitProtocol+0x2c8>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
   11c18:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c1c:	f44f 71c5 	mov.w	r1, #394	; 0x18a
   11c20:	f2c0 0003 	movt	r0, #3
   11c24:	f009 fa44 	bl	1b0b0 <assert_failed>
   11c28:	e68f      	b.n	1194a <HAL_SAI_InitProtocol+0x2aa>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
   11c2a:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c2e:	f44f 71c4 	mov.w	r1, #392	; 0x188
   11c32:	f2c0 0003 	movt	r0, #3
   11c36:	f009 fa3b 	bl	1b0b0 <assert_failed>
   11c3a:	e677      	b.n	1192c <HAL_SAI_InitProtocol+0x28c>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
   11c3c:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c40:	f44f 71c3 	mov.w	r1, #390	; 0x186
   11c44:	f2c0 0003 	movt	r0, #3
   11c48:	f009 fa32 	bl	1b0b0 <assert_failed>
   11c4c:	e65f      	b.n	1190e <HAL_SAI_InitProtocol+0x26e>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
   11c4e:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c52:	f240 119f 	movw	r1, #415	; 0x19f
   11c56:	f2c0 0003 	movt	r0, #3
   11c5a:	f009 fa29 	bl	1b0b0 <assert_failed>
   11c5e:	e6b7      	b.n	119d0 <HAL_SAI_InitProtocol+0x330>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
   11c60:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c64:	f44f 71cf 	mov.w	r1, #414	; 0x19e
   11c68:	f2c0 0003 	movt	r0, #3
   11c6c:	f009 fa20 	bl	1b0b0 <assert_failed>
   11c70:	e6a9      	b.n	119c6 <HAL_SAI_InitProtocol+0x326>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
   11c72:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c76:	f240 119b 	movw	r1, #411	; 0x19b
   11c7a:	f2c0 0003 	movt	r0, #3
   11c7e:	f009 fa17 	bl	1b0b0 <assert_failed>
   11c82:	e69b      	b.n	119bc <HAL_SAI_InitProtocol+0x31c>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
   11c84:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c88:	f44f 71cd 	mov.w	r1, #410	; 0x19a
   11c8c:	f2c0 0003 	movt	r0, #3
   11c90:	f009 fa0e 	bl	1b0b0 <assert_failed>
   11c94:	e68d      	b.n	119b2 <HAL_SAI_InitProtocol+0x312>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
   11c96:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11c9a:	f240 1199 	movw	r1, #409	; 0x199
   11c9e:	f2c0 0003 	movt	r0, #3
   11ca2:	f009 fa05 	bl	1b0b0 <assert_failed>
   11ca6:	e680      	b.n	119aa <HAL_SAI_InitProtocol+0x30a>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
   11ca8:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11cac:	f240 1197 	movw	r1, #407	; 0x197
   11cb0:	f2c0 0003 	movt	r0, #3
   11cb4:	f009 f9fc 	bl	1b0b0 <assert_failed>
   11cb8:	e664      	b.n	11984 <HAL_SAI_InitProtocol+0x2e4>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
   11cba:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11cbe:	f44f 71cb 	mov.w	r1, #406	; 0x196
   11cc2:	f2c0 0003 	movt	r0, #3
   11cc6:	f009 f9f3 	bl	1b0b0 <assert_failed>
   11cca:	e656      	b.n	1197a <HAL_SAI_InitProtocol+0x2da>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
   11ccc:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11cd0:	f240 1195 	movw	r1, #405	; 0x195
   11cd4:	f2c0 0003 	movt	r0, #3
   11cd8:	f009 f9ea 	bl	1b0b0 <assert_failed>
   11cdc:	e649      	b.n	11972 <HAL_SAI_InitProtocol+0x2d2>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   11cde:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_32;
   11ce0:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11ce2:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   11ce4:	01b3      	lsls	r3, r6, #6
      hsai->Init.DataSize = SAI_DATASIZE_32;
   11ce6:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   11ce8:	0176      	lsls	r6, r6, #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11cea:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   11cec:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
   11cf0:	e576      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   11cf2:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_24;
   11cf4:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11cf6:	2280      	movs	r2, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   11cf8:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   11cfa:	ea4f 1386 	mov.w	r3, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_24;
   11cfe:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   11d00:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11d04:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   11d06:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   11d0a:	f47f ad69 	bne.w	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->SlotInit.FirstBitOffset = 8;
   11d0e:	2308      	movs	r3, #8
   11d10:	66a3      	str	r3, [r4, #104]	; 0x68
   11d12:	e565      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   11d14:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11d16:	2380      	movs	r3, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   11d18:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   11d1a:	ea4f 1286 	mov.w	r2, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11d1e:	64a3      	str	r3, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   11d20:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   11d24:	66e3      	str	r3, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   11d26:	e9c4 2615 	strd	r2, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   11d2a:	f47f ad59 	bne.w	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->SlotInit.FirstBitOffset = 16;
   11d2e:	2310      	movs	r3, #16
   11d30:	66a3      	str	r3, [r4, #104]	; 0x68
   11d32:	e555      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
   11d34:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11d36:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   11d38:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
   11d3a:	0173      	lsls	r3, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
   11d3c:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
   11d3e:	0136      	lsls	r6, r6, #4
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   11d40:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
   11d42:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
   11d46:	e54b      	b.n	117e0 <HAL_SAI_InitProtocol+0x140>
  switch (hsai->Init.SynchroExt)
   11d48:	2113      	movs	r1, #19
   11d4a:	2012      	movs	r0, #18
   11d4c:	2611      	movs	r6, #17
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
   11d4e:	2210      	movs	r2, #16
   11d50:	e70f      	b.n	11b72 <HAL_SAI_InitProtocol+0x4d2>
    SaiBaseAddress = SAI2;
   11d52:	f44f 45b8 	mov.w	r5, #23552	; 0x5c00
   11d56:	f2c4 0501 	movt	r5, #16385	; 0x4001
   11d5a:	e6d5      	b.n	11b08 <HAL_SAI_InitProtocol+0x468>
      tmpregisterGCR |= SAI_GCR_SYNCIN_1;
   11d5c:	4602      	mov	r2, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
   11d5e:	f44f 6600 	mov.w	r6, #2048	; 0x800
  SaiBaseAddress->GCR = tmpregisterGCR;
   11d62:	602a      	str	r2, [r5, #0]
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
   11d64:	6a23      	ldr	r3, [r4, #32]
   11d66:	2b00      	cmp	r3, #0
   11d68:	d060      	beq.n	11e2c <HAL_SAI_InitProtocol+0x78c>
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
   11d6a:	f645 0204 	movw	r2, #22532	; 0x5804
   11d6e:	6823      	ldr	r3, [r4, #0]
   11d70:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11d74:	4293      	cmp	r3, r2
   11d76:	f000 814f 	beq.w	12018 <HAL_SAI_InitProtocol+0x978>
   11d7a:	f645 0024 	movw	r0, #22564	; 0x5824
   11d7e:	f2c4 0001 	movt	r0, #16385	; 0x4001
   11d82:	1a18      	subs	r0, r3, r0
   11d84:	fab0 f080 	clz	r0, r0
   11d88:	0940      	lsrs	r0, r0, #5
   11d8a:	2800      	cmp	r0, #0
   11d8c:	f040 8144 	bne.w	12018 <HAL_SAI_InitProtocol+0x978>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
   11d90:	f645 4204 	movw	r2, #23556	; 0x5c04
   11d94:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11d98:	4293      	cmp	r3, r2
   11d9a:	f000 8137 	beq.w	1200c <HAL_SAI_InitProtocol+0x96c>
   11d9e:	f645 4224 	movw	r2, #23588	; 0x5c24
   11da2:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11da6:	4293      	cmp	r3, r2
   11da8:	f000 8130 	beq.w	1200c <HAL_SAI_InitProtocol+0x96c>
    if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
   11dac:	f246 0204 	movw	r2, #24580	; 0x6004
   11db0:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11db4:	4293      	cmp	r3, r2
   11db6:	f000 8123 	beq.w	12000 <HAL_SAI_InitProtocol+0x960>
   11dba:	f246 0224 	movw	r2, #24612	; 0x6024
   11dbe:	f2c4 0201 	movt	r2, #16385	; 0x4001
   11dc2:	4293      	cmp	r3, r2
   11dc4:	f000 811c 	beq.w	12000 <HAL_SAI_InitProtocol+0x960>
    if (hsai->Instance == SAI4_Block_A)
   11dc8:	f245 4204 	movw	r2, #21508	; 0x5404
   11dcc:	f6c5 0200 	movt	r2, #22528	; 0x5800
   11dd0:	4293      	cmp	r3, r2
   11dd2:	f000 8135 	beq.w	12040 <HAL_SAI_InitProtocol+0x9a0>
    if (hsai->Instance == SAI4_Block_B)
   11dd6:	f245 4224 	movw	r2, #21540	; 0x5424
   11dda:	f6c5 0200 	movt	r2, #22528	; 0x5800
   11dde:	4293      	cmp	r3, r2
   11de0:	f000 8129 	beq.w	12036 <HAL_SAI_InitProtocol+0x996>
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
   11de4:	69a2      	ldr	r2, [r4, #24]
   11de6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   11dea:	6a23      	ldr	r3, [r4, #32]
   11dec:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
   11df0:	ea4f 0040 	mov.w	r0, r0, lsl #1
   11df4:	f000 80fa 	beq.w	11fec <HAL_SAI_InitProtocol+0x94c>
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
   11df8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
   11dfa:	021b      	lsls	r3, r3, #8
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
   11dfc:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
   11e00:	bf14      	ite	ne
   11e02:	2201      	movne	r2, #1
   11e04:	2202      	moveq	r2, #2
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
   11e06:	fb02 f303 	mul.w	r3, r2, r3
   11e0a:	fbb0 f3f3 	udiv	r3, r0, r3
    hsai->Init.Mckdiv = tmpval / 10U;
   11e0e:	f64c 42cd 	movw	r2, #52429	; 0xcccd
   11e12:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
   11e16:	fba2 1203 	umull	r1, r2, r2, r3
   11e1a:	08d2      	lsrs	r2, r2, #3
    if ((tmpval % 10U) > 8U)
   11e1c:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   11e20:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
   11e24:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv += 1U;
   11e26:	bf08      	it	eq
   11e28:	3201      	addeq	r2, #1
   11e2a:	6262      	str	r2, [r4, #36]	; 0x24
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11e2c:	6863      	ldr	r3, [r4, #4]
   11e2e:	6d22      	ldr	r2, [r4, #80]	; 0x50
   11e30:	f033 0702 	bics.w	r7, r3, #2
   11e34:	f040 80bd 	bne.w	11fb2 <HAL_SAI_InitProtocol+0x912>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
   11e38:	2a01      	cmp	r2, #1
   11e3a:	bf18      	it	ne
   11e3c:	f44f 7700 	movne.w	r7, #512	; 0x200
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   11e40:	f7f6 fb18 	bl	8474 <HAL_GetREVID>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   11e44:	6822      	ldr	r2, [r4, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   11e46:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   11e4a:	f24c 0310 	movw	r3, #49168	; 0xc010
   11e4e:	6811      	ldr	r1, [r2, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   11e50:	f0c0 809e 	bcc.w	11f90 <HAL_SAI_InitProtocol+0x8f0>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   11e54:	f2cf 0305 	movt	r3, #61445	; 0xf005
   11e58:	400b      	ands	r3, r1
   11e5a:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   11e5c:	6863      	ldr	r3, [r4, #4]
   11e5e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
   11e60:	e9d4 1211 	ldrd	r1, r2, [r4, #68]	; 0x44
   11e64:	430b      	orrs	r3, r1
   11e66:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   11e68:	4313      	orrs	r3, r2
   11e6a:	6962      	ldr	r2, [r4, #20]
   11e6c:	4303      	orrs	r3, r0
   11e6e:	69a0      	ldr	r0, [r4, #24]
   11e70:	430b      	orrs	r3, r1
   11e72:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   11e74:	4313      	orrs	r3, r2
   11e76:	6922      	ldr	r2, [r4, #16]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   11e78:	4303      	orrs	r3, r0
   11e7a:	6820      	ldr	r0, [r4, #0]
   11e7c:	430b      	orrs	r3, r1
   11e7e:	6801      	ldr	r1, [r0, #0]
   11e80:	4313      	orrs	r3, r2
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
   11e82:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   11e84:	430b      	orrs	r3, r1
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
   11e86:	f24f 0120 	movw	r1, #61472	; 0xf020
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   11e8a:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
   11e8e:	4333      	orrs	r3, r6
   11e90:	433b      	orrs	r3, r7
   11e92:	6003      	str	r3, [r0, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   11e94:	f641 73f0 	movw	r3, #8176	; 0x1ff0
   11e98:	6826      	ldr	r6, [r4, #0]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   11e9a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   11e9e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
   11ea2:	6872      	ldr	r2, [r6, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   11ea4:	f6cf 70f8 	movt	r0, #65528	; 0xfff8
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   11ea8:	4013      	ands	r3, r2
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   11eaa:	f645 0204 	movw	r2, #22532	; 0x5804
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   11eae:	6073      	str	r3, [r6, #4]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   11eb0:	f2c4 0201 	movt	r2, #16385	; 0x4001
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
   11eb4:	69e3      	ldr	r3, [r4, #28]
   11eb6:	e9d4 760c 	ldrd	r7, r6, [r4, #48]	; 0x30
   11eba:	433b      	orrs	r3, r7
   11ebc:	6827      	ldr	r7, [r4, #0]
   11ebe:	4333      	orrs	r3, r6
   11ec0:	687e      	ldr	r6, [r7, #4]
   11ec2:	4333      	orrs	r3, r6
   11ec4:	607b      	str	r3, [r7, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   11ec6:	6823      	ldr	r3, [r4, #0]
   11ec8:	689e      	ldr	r6, [r3, #8]
   11eca:	4030      	ands	r0, r6
   11ecc:	6098      	str	r0, [r3, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   11ece:	6e63      	ldr	r3, [r4, #100]	; 0x64
   11ed0:	6827      	ldr	r7, [r4, #0]
   11ed2:	e9d4 6017 	ldrd	r6, r0, [r4, #92]	; 0x5c
   11ed6:	4333      	orrs	r3, r6
   11ed8:	6d66      	ldr	r6, [r4, #84]	; 0x54
   11eda:	4303      	orrs	r3, r0
   11edc:	68b8      	ldr	r0, [r7, #8]
   11ede:	3e01      	subs	r6, #1
   11ee0:	4303      	orrs	r3, r0
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
   11ee2:	6da0      	ldr	r0, [r4, #88]	; 0x58
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   11ee4:	4333      	orrs	r3, r6
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
   11ee6:	3801      	subs	r0, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   11ee8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   11eec:	60bb      	str	r3, [r7, #8]
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
   11eee:	6820      	ldr	r0, [r4, #0]
   11ef0:	68c3      	ldr	r3, [r0, #12]
   11ef2:	4019      	ands	r1, r3
   11ef4:	60c1      	str	r1, [r0, #12]
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   11ef6:	6820      	ldr	r0, [r4, #0]
   11ef8:	e9d4 361a 	ldrd	r3, r6, [r4, #104]	; 0x68
   11efc:	68c1      	ldr	r1, [r0, #12]
   11efe:	4333      	orrs	r3, r6
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   11f00:	6f66      	ldr	r6, [r4, #116]	; 0x74
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   11f02:	430b      	orrs	r3, r1
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   11f04:	6f21      	ldr	r1, [r4, #112]	; 0x70
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   11f06:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   11f0a:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   11f0c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   11f10:	60c3      	str	r3, [r0, #12]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   11f12:	6823      	ldr	r3, [r4, #0]
   11f14:	4293      	cmp	r3, r2
   11f16:	d028      	beq.n	11f6a <HAL_SAI_InitProtocol+0x8ca>
   11f18:	f245 4204 	movw	r2, #21508	; 0x5404
   11f1c:	f6c5 0200 	movt	r2, #22528	; 0x5800
   11f20:	4293      	cmp	r3, r2
   11f22:	d022      	beq.n	11f6a <HAL_SAI_InitProtocol+0x8ca>
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   11f24:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
   11f26:	2201      	movs	r2, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   11f28:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  return HAL_OK;
   11f2c:	4618      	mov	r0, r3
  __HAL_UNLOCK(hsai);
   11f2e:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
  hsai->State = HAL_SAI_STATE_READY;
   11f32:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
}
   11f36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      syncen_bits = SAI_xCR1_SYNCEN_0;
   11f38:	f44f 6680 	mov.w	r6, #1024	; 0x400
   11f3c:	e711      	b.n	11d62 <HAL_SAI_InitProtocol+0x6c2>
      syncen_bits = 0;
   11f3e:	2600      	movs	r6, #0
   11f40:	e70f      	b.n	11d62 <HAL_SAI_InitProtocol+0x6c2>
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
   11f42:	4632      	mov	r2, r6
      syncen_bits = SAI_xCR1_SYNCEN_1;
   11f44:	f44f 6600 	mov.w	r6, #2048	; 0x800
   11f48:	e70b      	b.n	11d62 <HAL_SAI_InitProtocol+0x6c2>
    hsai->Lock = HAL_UNLOCKED;
   11f4a:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
    HAL_SAI_MspInit(hsai);
   11f4e:	4620      	mov	r0, r4
   11f50:	f009 ff0e 	bl	1bd70 <HAL_SAI_MspInit>
   11f54:	6823      	ldr	r3, [r4, #0]
   11f56:	e5de      	b.n	11b16 <HAL_SAI_InitProtocol+0x476>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
   11f58:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11f5c:	f240 118f 	movw	r1, #399	; 0x18f
   11f60:	f2c0 0003 	movt	r0, #3
   11f64:	f009 f8a4 	bl	1b0b0 <assert_failed>
   11f68:	e4f9      	b.n	1195e <HAL_SAI_InitProtocol+0x2be>
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
   11f6a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   11f6c:	f023 0301 	bic.w	r3, r3, #1
   11f70:	646b      	str	r3, [r5, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
   11f72:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   11f76:	2b01      	cmp	r3, #1
   11f78:	d1d4      	bne.n	11f24 <HAL_SAI_InitProtocol+0x884>
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
   11f7a:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
   11f7e:	3a01      	subs	r2, #1
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
   11f80:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
   11f84:	646b      	str	r3, [r5, #68]	; 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
   11f86:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   11f88:	f043 0301 	orr.w	r3, r3, #1
   11f8c:	646b      	str	r3, [r5, #68]	; 0x44
   11f8e:	e7c9      	b.n	11f24 <HAL_SAI_InitProtocol+0x884>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   11f90:	f6cf 0305 	movt	r3, #63493	; 0xf805
   11f94:	400b      	ands	r3, r1
   11f96:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   11f98:	6863      	ldr	r3, [r4, #4]
   11f9a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
   11f9c:	e9d4 2011 	ldrd	r2, r0, [r4, #68]	; 0x44
   11fa0:	4313      	orrs	r3, r2
   11fa2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   11fa4:	4303      	orrs	r3, r0
   11fa6:	6960      	ldr	r0, [r4, #20]
   11fa8:	430b      	orrs	r3, r1
   11faa:	69a1      	ldr	r1, [r4, #24]
   11fac:	4313      	orrs	r3, r2
   11fae:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   11fb0:	e762      	b.n	11e78 <HAL_SAI_InitProtocol+0x7d8>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
   11fb2:	2a01      	cmp	r2, #1
   11fb4:	bf14      	ite	ne
   11fb6:	2700      	movne	r7, #0
   11fb8:	f44f 7700 	moveq.w	r7, #512	; 0x200
   11fbc:	e740      	b.n	11e40 <HAL_SAI_InitProtocol+0x7a0>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
   11fbe:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11fc2:	f44f 71cc 	mov.w	r1, #408	; 0x198
   11fc6:	f2c0 0003 	movt	r0, #3
   11fca:	f009 f871 	bl	1b0b0 <assert_failed>
   11fce:	e4e7      	b.n	119a0 <HAL_SAI_InitProtocol+0x300>
    SaiBaseAddress = SAI3;
   11fd0:	f44f 45c0 	mov.w	r5, #24576	; 0x6000
   11fd4:	f2c4 0501 	movt	r5, #16385	; 0x4001
   11fd8:	e596      	b.n	11b08 <HAL_SAI_InitProtocol+0x468>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
   11fda:	f643 10c4 	movw	r0, #14788	; 0x39c4
   11fde:	f240 1187 	movw	r1, #391	; 0x187
   11fe2:	f2c0 0003 	movt	r0, #3
   11fe6:	f009 f863 	bl	1b0b0 <assert_failed>
   11fea:	e49a      	b.n	11922 <HAL_SAI_InitProtocol+0x282>
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * hsai->FrameInit.FrameLength);
   11fec:	6d62      	ldr	r2, [r4, #84]	; 0x54
   11fee:	fb02 f303 	mul.w	r3, r2, r3
   11ff2:	fbb0 f3f3 	udiv	r3, r0, r3
   11ff6:	e70a      	b.n	11e0e <HAL_SAI_InitProtocol+0x76e>
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
   11ff8:	460a      	mov	r2, r1
      syncen_bits = SAI_xCR1_SYNCEN_1;
   11ffa:	f44f 6600 	mov.w	r6, #2048	; 0x800
   11ffe:	e6b0      	b.n	11d62 <HAL_SAI_InitProtocol+0x6c2>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI3);
   12000:	f44f 7000 	mov.w	r0, #512	; 0x200
   12004:	f7ff f986 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
   12008:	6823      	ldr	r3, [r4, #0]
   1200a:	e6dd      	b.n	11dc8 <HAL_SAI_InitProtocol+0x728>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
   1200c:	f44f 7000 	mov.w	r0, #512	; 0x200
   12010:	f7ff f980 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
   12014:	6823      	ldr	r3, [r4, #0]
   12016:	e6c9      	b.n	11dac <HAL_SAI_InitProtocol+0x70c>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
   12018:	f44f 7080 	mov.w	r0, #256	; 0x100
   1201c:	f7ff f97a 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
   12020:	6823      	ldr	r3, [r4, #0]
   12022:	e6b5      	b.n	11d90 <HAL_SAI_InitProtocol+0x6f0>
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
   12024:	f643 10c4 	movw	r0, #14788	; 0x39c4
   12028:	f240 1181 	movw	r1, #385	; 0x181
   1202c:	f2c0 0003 	movt	r0, #3
   12030:	f009 f83e 	bl	1b0b0 <assert_failed>
   12034:	e418      	b.n	11868 <HAL_SAI_InitProtocol+0x1c8>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4B);
   12036:	f44f 6000 	mov.w	r0, #2048	; 0x800
   1203a:	f7ff f96b 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
   1203e:	e6d1      	b.n	11de4 <HAL_SAI_InitProtocol+0x744>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4A);
   12040:	f44f 6080 	mov.w	r0, #1024	; 0x400
   12044:	f7ff f966 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
   12048:	6823      	ldr	r3, [r4, #0]
   1204a:	e6c4      	b.n	11dd6 <HAL_SAI_InitProtocol+0x736>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
   1204c:	f643 10c4 	movw	r0, #14788	; 0x39c4
   12050:	f44f 71c2 	mov.w	r1, #388	; 0x184
   12054:	f2c0 0003 	movt	r0, #3
   12058:	f009 f82a 	bl	1b0b0 <assert_failed>
   1205c:	e445      	b.n	118ea <HAL_SAI_InitProtocol+0x24a>
   1205e:	bf00      	nop

00012060 <HAL_SAI_Transmit_DMA>:
{
   12060:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12064:	460f      	mov	r7, r1
   12066:	4604      	mov	r4, r0
   12068:	4691      	mov	r9, r2
  uint32_t tickstart = HAL_GetTick();
   1206a:	f7f6 f9e9 	bl	8440 <HAL_GetTick>
  if ((pData == NULL) || (Size == 0U))
   1206e:	2f00      	cmp	r7, #0
   12070:	d06e      	beq.n	12150 <HAL_SAI_Transmit_DMA+0xf0>
   12072:	fab9 f589 	clz	r5, r9
   12076:	096d      	lsrs	r5, r5, #5
   12078:	2d00      	cmp	r5, #0
   1207a:	d169      	bne.n	12150 <HAL_SAI_Transmit_DMA+0xf0>
  if (hsai->State == HAL_SAI_STATE_READY)
   1207c:	f894 6091 	ldrb.w	r6, [r4, #145]	; 0x91
   12080:	b2f6      	uxtb	r6, r6
   12082:	2e01      	cmp	r6, #1
   12084:	d160      	bne.n	12148 <HAL_SAI_Transmit_DMA+0xe8>
    __HAL_LOCK(hsai);
   12086:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
   1208a:	2b01      	cmp	r3, #1
   1208c:	d05c      	beq.n	12148 <HAL_SAI_Transmit_DMA+0xe8>
   1208e:	4680      	mov	r8, r0
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   12090:	f242 20d5 	movw	r0, #8917	; 0x22d5
   12094:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_TX;
   12098:	f04f 0c12 	mov.w	ip, #18
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   1209c:	f2c0 0001 	movt	r0, #1
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   120a0:	f242 2171 	movw	r1, #8817	; 0x2271
    hsai->pBuffPtr = pData;
   120a4:	67a7      	str	r7, [r4, #120]	; 0x78
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   120a6:	f242 3351 	movw	r3, #9041	; 0x2351
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   120aa:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   120ae:	f2c0 0101 	movt	r1, #1
    hsai->XferSize = Size;
   120b2:	f8a4 907c 	strh.w	r9, [r4, #124]	; 0x7c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   120b6:	f2c0 0301 	movt	r3, #1
    __HAL_LOCK(hsai);
   120ba:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->XferCount = Size;
   120be:	f8a4 907e 	strh.w	r9, [r4, #126]	; 0x7e
    hsai->State = HAL_SAI_STATE_BUSY_TX;
   120c2:	f884 c091 	strb.w	ip, [r4, #145]	; 0x91
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   120c6:	6410      	str	r0, [r2, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   120c8:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   120cc:	63d1      	str	r1, [r2, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   120ce:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
   120d2:	64d3      	str	r3, [r2, #76]	; 0x4c
    hsai->hdmatx->XferAbortCallback = NULL;
   120d4:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   120d8:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
   120da:	6822      	ldr	r2, [r4, #0]
   120dc:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   120e0:	321c      	adds	r2, #28
   120e2:	6fa1      	ldr	r1, [r4, #120]	; 0x78
   120e4:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
   120e8:	f7f8 fff6 	bl	b0d8 <HAL_DMA_Start_IT>
   120ec:	4607      	mov	r7, r0
   120ee:	2800      	cmp	r0, #0
   120f0:	d132      	bne.n	12158 <HAL_SAI_Transmit_DMA+0xf8>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   120f2:	6c62      	ldr	r2, [r4, #68]	; 0x44
   120f4:	6863      	ldr	r3, [r4, #4]
   120f6:	2a08      	cmp	r2, #8
   120f8:	d03c      	beq.n	12174 <HAL_SAI_Transmit_DMA+0x114>
   120fa:	2005      	movs	r0, #5
   120fc:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   120fe:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   12100:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
   12102:	2b01      	cmp	r3, #1
   12104:	bf88      	it	hi
   12106:	4602      	movhi	r2, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   12108:	690b      	ldr	r3, [r1, #16]
   1210a:	4313      	orrs	r3, r2
   1210c:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   1210e:	6822      	ldr	r2, [r4, #0]
   12110:	6813      	ldr	r3, [r2, #0]
   12112:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   12116:	6013      	str	r3, [r2, #0]
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
   12118:	e006      	b.n	12128 <HAL_SAI_Transmit_DMA+0xc8>
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
   1211a:	f7f6 f991 	bl	8440 <HAL_GetTick>
   1211e:	eba0 0008 	sub.w	r0, r0, r8
   12122:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   12126:	d81b      	bhi.n	12160 <HAL_SAI_Transmit_DMA+0x100>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
   12128:	6822      	ldr	r2, [r4, #0]
   1212a:	6955      	ldr	r5, [r2, #20]
   1212c:	f415 25e0 	ands.w	r5, r5, #458752	; 0x70000
   12130:	d0f3      	beq.n	1211a <HAL_SAI_Transmit_DMA+0xba>
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
   12132:	6813      	ldr	r3, [r2, #0]
   12134:	03db      	lsls	r3, r3, #15
   12136:	d403      	bmi.n	12140 <HAL_SAI_Transmit_DMA+0xe0>
      __HAL_SAI_ENABLE(hsai);
   12138:	6813      	ldr	r3, [r2, #0]
   1213a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1213e:	6013      	str	r3, [r2, #0]
    __HAL_UNLOCK(hsai);
   12140:	2300      	movs	r3, #0
   12142:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    return HAL_OK;
   12146:	e000      	b.n	1214a <HAL_SAI_Transmit_DMA+0xea>
    return HAL_BUSY;
   12148:	2702      	movs	r7, #2
}
   1214a:	4638      	mov	r0, r7
   1214c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return  HAL_ERROR;
   12150:	2701      	movs	r7, #1
}
   12152:	4638      	mov	r0, r7
   12154:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      __HAL_UNLOCK(hsai);
   12158:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
   1215c:	4637      	mov	r7, r6
   1215e:	e7f4      	b.n	1214a <HAL_SAI_Transmit_DMA+0xea>
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   12160:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
   12164:	2703      	movs	r7, #3
        __HAL_UNLOCK(hsai);
   12166:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   1216a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1216e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
   12172:	e7ea      	b.n	1214a <HAL_SAI_Transmit_DMA+0xea>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   12174:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   12178:	2a01      	cmp	r2, #1
   1217a:	bf0b      	itete	eq
   1217c:	2015      	moveq	r0, #21
   1217e:	2005      	movne	r0, #5
   12180:	2271      	moveq	r2, #113	; 0x71
   12182:	2261      	movne	r2, #97	; 0x61
   12184:	e7bb      	b.n	120fe <HAL_SAI_Transmit_DMA+0x9e>
   12186:	bf00      	nop

00012188 <HAL_SAI_Receive_DMA>:
  if ((pData == NULL) || (Size == 0U))
   12188:	2900      	cmp	r1, #0
   1218a:	d061      	beq.n	12250 <HAL_SAI_Receive_DMA+0xc8>
{
   1218c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((pData == NULL) || (Size == 0U))
   1218e:	fab2 f582 	clz	r5, r2
   12192:	096d      	lsrs	r5, r5, #5
   12194:	2d00      	cmp	r5, #0
   12196:	d159      	bne.n	1224c <HAL_SAI_Receive_DMA+0xc4>
  if (hsai->State == HAL_SAI_STATE_READY)
   12198:	f890 6091 	ldrb.w	r6, [r0, #145]	; 0x91
   1219c:	b2f6      	uxtb	r6, r6
   1219e:	2e01      	cmp	r6, #1
   121a0:	d152      	bne.n	12248 <HAL_SAI_Receive_DMA+0xc0>
    __HAL_LOCK(hsai);
   121a2:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
   121a6:	2b01      	cmp	r3, #1
   121a8:	d04e      	beq.n	12248 <HAL_SAI_Receive_DMA+0xc0>
   121aa:	4604      	mov	r4, r0
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   121ac:	f242 3745 	movw	r7, #9029	; 0x2345
    hsai->State = HAL_SAI_STATE_BUSY_RX;
   121b0:	f04f 0e22 	mov.w	lr, #34	; 0x22
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   121b4:	f242 20e1 	movw	r0, #8929	; 0x22e1
    hsai->XferSize = Size;
   121b8:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   121bc:	f2c0 0701 	movt	r7, #1
    hsai->XferCount = Size;
   121c0:	f8a4 207e 	strh.w	r2, [r4, #126]	; 0x7e
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   121c4:	f2c0 0001 	movt	r0, #1
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   121c8:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   121cc:	f242 3351 	movw	r3, #9041	; 0x2351
    hsai->pBuffPtr = pData;
   121d0:	67a1      	str	r1, [r4, #120]	; 0x78
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   121d2:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   121d6:	f2c0 0301 	movt	r3, #1
    __HAL_LOCK(hsai);
   121da:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->State = HAL_SAI_STATE_BUSY_RX;
   121de:	f884 e091 	strb.w	lr, [r4, #145]	; 0x91
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   121e2:	6417      	str	r7, [r2, #64]	; 0x40
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   121e4:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
   121e8:	63d0      	str	r0, [r2, #60]	; 0x3c
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   121ea:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
   121ee:	64d3      	str	r3, [r2, #76]	; 0x4c
    hsai->hdmarx->XferAbortCallback = NULL;
   121f0:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   121f4:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
   121f6:	6821      	ldr	r1, [r4, #0]
   121f8:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   121fc:	311c      	adds	r1, #28
   121fe:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   12200:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
   12204:	f7f8 ff68 	bl	b0d8 <HAL_DMA_Start_IT>
   12208:	bb20      	cbnz	r0, 12254 <HAL_SAI_Receive_DMA+0xcc>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1220a:	6c62      	ldr	r2, [r4, #68]	; 0x44
   1220c:	6863      	ldr	r3, [r4, #4]
   1220e:	2a08      	cmp	r2, #8
   12210:	d024      	beq.n	1225c <HAL_SAI_Receive_DMA+0xd4>
   12212:	2505      	movs	r5, #5
   12214:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   12216:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   12218:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
   1221a:	2b01      	cmp	r3, #1
   1221c:	bf88      	it	hi
   1221e:	462a      	movhi	r2, r5
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   12220:	690b      	ldr	r3, [r1, #16]
   12222:	4313      	orrs	r3, r2
   12224:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   12226:	6822      	ldr	r2, [r4, #0]
   12228:	6813      	ldr	r3, [r2, #0]
   1222a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1222e:	6013      	str	r3, [r2, #0]
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
   12230:	6823      	ldr	r3, [r4, #0]
   12232:	681a      	ldr	r2, [r3, #0]
   12234:	03d2      	lsls	r2, r2, #15
   12236:	d403      	bmi.n	12240 <HAL_SAI_Receive_DMA+0xb8>
      __HAL_SAI_ENABLE(hsai);
   12238:	681a      	ldr	r2, [r3, #0]
   1223a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   1223e:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
   12240:	2300      	movs	r3, #0
   12242:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
}
   12246:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
   12248:	2002      	movs	r0, #2
}
   1224a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
   1224c:	2001      	movs	r0, #1
}
   1224e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
   12250:	2001      	movs	r0, #1
}
   12252:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
   12254:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
   12258:	4630      	mov	r0, r6
}
   1225a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   1225c:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   12260:	2a01      	cmp	r2, #1
   12262:	bf0b      	itete	eq
   12264:	2515      	moveq	r5, #21
   12266:	2505      	movne	r5, #5
   12268:	2271      	moveq	r2, #113	; 0x71
   1226a:	2261      	movne	r2, #97	; 0x61
   1226c:	e7d3      	b.n	12216 <HAL_SAI_Receive_DMA+0x8e>
   1226e:	bf00      	nop

00012270 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
   12270:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
   12272:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   12274:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
   12276:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1227a:	d01a      	beq.n	122b2 <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;
   1227c:	2300      	movs	r3, #0

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   1227e:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
   12280:	f8a0 307e 	strh.w	r3, [r0, #126]	; 0x7e
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   12284:	6813      	ldr	r3, [r2, #0]
   12286:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1228a:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1228c:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1228e:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   12290:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   12292:	d011      	beq.n	122b8 <SAI_DMATxCplt+0x48>
   12294:	f06f 0261 	mvn.w	r2, #97	; 0x61
   12298:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1229c:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   1229e:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
   122a0:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   122a2:	42a3      	cmp	r3, r4
   122a4:	bf88      	it	hi
   122a6:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   122a8:	690b      	ldr	r3, [r1, #16]
   122aa:	4013      	ands	r3, r2
   122ac:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
   122ae:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
   122b2:	f006 fd55 	bl	18d60 <HAL_SAI_TxCpltCallback>
#endif
}
   122b6:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   122b8:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   122bc:	2a01      	cmp	r2, #1
   122be:	bf0b      	itete	eq
   122c0:	f06f 0271 	mvneq.w	r2, #113	; 0x71
   122c4:	f06f 0261 	mvnne.w	r2, #97	; 0x61
   122c8:	f06f 0515 	mvneq.w	r5, #21
   122cc:	f06f 0505 	mvnne.w	r5, #5
   122d0:	e7e4      	b.n	1229c <SAI_DMATxCplt+0x2c>
   122d2:	bf00      	nop

000122d4 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
   122d4:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
   122d6:	6b80      	ldr	r0, [r0, #56]	; 0x38
   122d8:	f006 fd44 	bl	18d64 <HAL_SAI_TxHalfCpltCallback>
#endif
}
   122dc:	bd08      	pop	{r3, pc}
   122de:	bf00      	nop

000122e0 <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
   122e0:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
   122e2:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   122e4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
   122e6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   122ea:	d01a      	beq.n	12322 <SAI_DMARxCplt+0x42>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   122ec:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
   122ee:	2100      	movs	r1, #0
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   122f0:	6813      	ldr	r3, [r2, #0]
   122f2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   122f6:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   122f8:	6c43      	ldr	r3, [r0, #68]	; 0x44
    hsai->XferCount = 0;
   122fa:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   122fe:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   12300:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   12302:	d011      	beq.n	12328 <SAI_DMARxCplt+0x48>
   12304:	f06f 0261 	mvn.w	r2, #97	; 0x61
   12308:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1230c:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   1230e:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
   12310:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   12312:	42a3      	cmp	r3, r4
   12314:	bf88      	it	hi
   12316:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   12318:	690b      	ldr	r3, [r1, #16]
   1231a:	4013      	ands	r3, r2
   1231c:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
   1231e:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
   12322:	f006 fd21 	bl	18d68 <HAL_SAI_RxCpltCallback>
#endif
}
   12326:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   12328:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1232c:	2a01      	cmp	r2, #1
   1232e:	bf0b      	itete	eq
   12330:	f06f 0271 	mvneq.w	r2, #113	; 0x71
   12334:	f06f 0261 	mvnne.w	r2, #97	; 0x61
   12338:	f06f 0515 	mvneq.w	r5, #21
   1233c:	f06f 0505 	mvnne.w	r5, #5
   12340:	e7e4      	b.n	1230c <SAI_DMARxCplt+0x2c>
   12342:	bf00      	nop

00012344 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
   12344:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
   12346:	6b80      	ldr	r0, [r0, #56]	; 0x38
   12348:	f006 fd12 	bl	18d70 <HAL_SAI_RxHalfCpltCallback>
#endif
}
   1234c:	bd08      	pop	{r3, pc}
   1234e:	bf00      	nop

00012350 <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
   12350:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   12352:	6b84      	ldr	r4, [r0, #56]	; 0x38

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
   12354:	f7f9 fbfe 	bl	bb54 <HAL_DMA_GetError>
   12358:	2802      	cmp	r0, #2
   1235a:	d030      	beq.n	123be <SAI_DMAError+0x6e>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   1235c:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   12360:	f246 23b4 	movw	r3, #25268	; 0x62b4

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   12364:	6822      	ldr	r2, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   12366:	f64e 451b 	movw	r5, #60443	; 0xec1b
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   1236a:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   1236e:	f2c0 0306 	movt	r3, #6
   12372:	f2c9 55cb 	movt	r5, #38347	; 0x95cb
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   12376:	f8c4 1094 	str.w	r1, [r4, #148]	; 0x94
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   1237a:	6811      	ldr	r1, [r2, #0]
   1237c:	f421 3100 	bic.w	r1, r1, #131072	; 0x20000
   12380:	6011      	str	r1, [r2, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   12382:	681a      	ldr	r2, [r3, #0]
  __HAL_SAI_DISABLE(hsai);
   12384:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   12386:	fba5 3202 	umull	r3, r2, r5, r2
  __HAL_SAI_DISABLE(hsai);
   1238a:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   1238c:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
   1238e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    if (count == 0U)
   12392:	0093      	lsls	r3, r2, #2
  __HAL_SAI_DISABLE(hsai);
   12394:	6001      	str	r1, [r0, #0]
    if (count == 0U)
   12396:	b19a      	cbz	r2, 123c0 <SAI_DMAError+0x70>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   12398:	6821      	ldr	r1, [r4, #0]
    count--;
   1239a:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   1239c:	680a      	ldr	r2, [r1, #0]
   1239e:	03d0      	lsls	r0, r2, #15
   123a0:	d504      	bpl.n	123ac <SAI_DMAError+0x5c>
    if (count == 0U)
   123a2:	b16b      	cbz	r3, 123c0 <SAI_DMAError+0x70>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   123a4:	680a      	ldr	r2, [r1, #0]
    count--;
   123a6:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   123a8:	03d2      	lsls	r2, r2, #15
   123aa:	d4fa      	bmi.n	123a2 <SAI_DMAError+0x52>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
   123ac:	2201      	movs	r2, #1

    /* Initialize XferCount */
    hsai->XferCount = 0U;
   123ae:	2300      	movs	r3, #0

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
   123b0:	4620      	mov	r0, r4
    hsai->State = HAL_SAI_STATE_READY;
   123b2:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
    hsai->XferCount = 0U;
   123b6:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    HAL_SAI_ErrorCallback(hsai);
   123ba:	f006 fccd 	bl	18d58 <HAL_SAI_ErrorCallback>
#endif
  }
}
   123be:	bd38      	pop	{r3, r4, r5, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   123c0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   123c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   123c8:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
   123cc:	e7ee      	b.n	123ac <SAI_DMAError+0x5c>
   123ce:	bf00      	nop

000123d0 <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
   123d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   123d4:	4605      	mov	r5, r0
   123d6:	b087      	sub	sp, #28
   123d8:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
   123da:	f7f6 f831 	bl	8440 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
   123de:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
   123e0:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
   123e2:	6828      	ldr	r0, [r5, #0]
   123e4:	f003 f878 	bl	154d8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   123e8:	4604      	mov	r4, r0
   123ea:	b118      	cbz	r0, 123f4 <SD_FindSCR+0x24>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
   123ec:	4620      	mov	r0, r4
   123ee:	b007      	add	sp, #28
   123f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
   123f4:	6ca9      	ldr	r1, [r5, #72]	; 0x48
   123f6:	6828      	ldr	r0, [r5, #0]
   123f8:	0409      	lsls	r1, r1, #16
   123fa:	f003 faeb 	bl	159d4 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
   123fe:	4604      	mov	r4, r0
   12400:	2800      	cmp	r0, #0
   12402:	d1f3      	bne.n	123ec <SD_FindSCR+0x1c>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   12404:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 8U;
   12408:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
   1240a:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   1240c:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   1240e:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   12410:	2202      	movs	r2, #2
  config.DataLength    = 8U;
   12412:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   12414:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
   12416:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   12418:	4669      	mov	r1, sp
   1241a:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   1241c:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   1241e:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   12420:	f002 fff0 	bl	15404 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
   12424:	6828      	ldr	r0, [r5, #0]
   12426:	f003 fb99 	bl	15b5c <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   1242a:	4604      	mov	r4, r0
   1242c:	2800      	cmp	r0, #0
   1242e:	d1dd      	bne.n	123ec <SD_FindSCR+0x1c>
  uint32_t index = 0U;
   12430:	4681      	mov	r9, r0
  uint32_t tempscr[2U] = {0UL, 0UL};
   12432:	4683      	mov	fp, r0
   12434:	4682      	mov	sl, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   12436:	f240 582a 	movw	r8, #1322	; 0x52a
   1243a:	e004      	b.n	12446 <SD_FindSCR+0x76>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   1243c:	f7f6 f800 	bl	8440 <HAL_GetTick>
   12440:	1b80      	subs	r0, r0, r6
   12442:	3001      	adds	r0, #1
   12444:	d028      	beq.n	12498 <SD_FindSCR+0xc8>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   12446:	6828      	ldr	r0, [r5, #0]
   12448:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1244a:	ea13 0f08 	tst.w	r3, r8
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
   1244e:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   12450:	d10e      	bne.n	12470 <SD_FindSCR+0xa0>
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
   12452:	031b      	lsls	r3, r3, #12
   12454:	d4f2      	bmi.n	1243c <SD_FindSCR+0x6c>
   12456:	f1b9 0f00 	cmp.w	r9, #0
   1245a:	d1ef      	bne.n	1243c <SD_FindSCR+0x6c>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
   1245c:	f002 ffaa 	bl	153b4 <SDMMC_ReadFIFO>
   12460:	4682      	mov	sl, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
   12462:	6828      	ldr	r0, [r5, #0]
      index++;
   12464:	f04f 0901 	mov.w	r9, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
   12468:	f002 ffa4 	bl	153b4 <SDMMC_ReadFIFO>
   1246c:	4683      	mov	fp, r0
   1246e:	e7e5      	b.n	1243c <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   12470:	0719      	lsls	r1, r3, #28
   12472:	d414      	bmi.n	1249e <SD_FindSCR+0xce>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   12474:	6b43      	ldr	r3, [r0, #52]	; 0x34
   12476:	079a      	lsls	r2, r3, #30
   12478:	d414      	bmi.n	124a4 <SD_FindSCR+0xd4>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   1247a:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1247c:	069b      	lsls	r3, r3, #26
   1247e:	d414      	bmi.n	124aa <SD_FindSCR+0xda>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   12480:	f640 713a 	movw	r1, #3898	; 0xf3a
   12484:	fa9b f28b 	rev.w	r2, fp
   12488:	fa9a f38a 	rev.w	r3, sl
   1248c:	f6c1 0100 	movt	r1, #6144	; 0x1800
   12490:	6381      	str	r1, [r0, #56]	; 0x38
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
   12492:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
   12496:	e7a9      	b.n	123ec <SD_FindSCR+0x1c>
      return HAL_SD_ERROR_TIMEOUT;
   12498:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   1249c:	e7a6      	b.n	123ec <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
   1249e:	2408      	movs	r4, #8
   124a0:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
   124a2:	e7a3      	b.n	123ec <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
   124a4:	2402      	movs	r4, #2
   124a6:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
   124a8:	e7a0      	b.n	123ec <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
   124aa:	2420      	movs	r4, #32
   124ac:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
   124ae:	e79d      	b.n	123ec <SD_FindSCR+0x1c>

000124b0 <HAL_SD_ReadBlocks>:
{
   124b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   124b4:	460d      	mov	r5, r1
   124b6:	b086      	sub	sp, #24
   124b8:	4604      	mov	r4, r0
   124ba:	4690      	mov	r8, r2
   124bc:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
   124be:	f7f5 ffbf 	bl	8440 <HAL_GetTick>
  if(NULL == pData)
   124c2:	2d00      	cmp	r5, #0
   124c4:	d071      	beq.n	125aa <HAL_SD_ReadBlocks+0xfa>
   124c6:	4607      	mov	r7, r0
  if(hsd->State == HAL_SD_STATE_READY)
   124c8:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
   124cc:	b2c0      	uxtb	r0, r0
   124ce:	2801      	cmp	r0, #1
   124d0:	d007      	beq.n	124e2 <HAL_SD_ReadBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   124d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   124d4:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   124d6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   124da:	63a3      	str	r3, [r4, #56]	; 0x38
}
   124dc:	b006      	add	sp, #24
   124de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   124e2:	eb08 0306 	add.w	r3, r8, r6
   124e6:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   124e8:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   124ea:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   124ec:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   124ee:	d864      	bhi.n	125ba <HAL_SD_ReadBlocks+0x10a>
    hsd->Instance->DCTRL = 0U;
   124f0:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
   124f2:	2203      	movs	r2, #3
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   124f4:	f04f 0902 	mov.w	r9, #2
    hsd->State = HAL_SD_STATE_BUSY;
   124f8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   124fc:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
   124fe:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   12500:	0271      	lsls	r1, r6, #9
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   12502:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   12504:	9101      	str	r1, [sp, #4]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   12506:	4669      	mov	r1, sp
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   12508:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   1250a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   1250e:	6820      	ldr	r0, [r4, #0]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   12510:	9300      	str	r3, [sp, #0]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   12512:	f04f 0300 	mov.w	r3, #0
      add *= 512U;
   12516:	bf18      	it	ne
   12518:	ea4f 2848 	movne.w	r8, r8, lsl #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   1251c:	9202      	str	r2, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
   1251e:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   12520:	e9cd 9303 	strd	r9, r3, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   12524:	f002 ff6e 	bl	15404 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   12528:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
   1252a:	2e01      	cmp	r6, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   1252c:	68d3      	ldr	r3, [r2, #12]
   1252e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12532:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
   12534:	d957      	bls.n	125e6 <HAL_SD_ReadBlocks+0x136>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
   12536:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
   1253a:	4641      	mov	r1, r8
   1253c:	6820      	ldr	r0, [r4, #0]
   1253e:	f003 f857 	bl	155f0 <SDMMC_CmdReadMultiBlock>
   12542:	4602      	mov	r2, r0
   12544:	6823      	ldr	r3, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
   12546:	2a00      	cmp	r2, #0
   12548:	d13e      	bne.n	125c8 <HAL_SD_ReadBlocks+0x118>
    dataremaining = config.DataLength;
   1254a:	f8dd 9004 	ldr.w	r9, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1254e:	e006      	b.n	1255e <HAL_SD_ReadBlocks+0xae>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
   12550:	f7f5 ff76 	bl	8440 <HAL_GetTick>
   12554:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12556:	1bc0      	subs	r0, r0, r7
   12558:	4298      	cmp	r0, r3
   1255a:	d27b      	bcs.n	12654 <HAL_SD_ReadBlocks+0x1a4>
   1255c:	6823      	ldr	r3, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1255e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12560:	f412 7f95 	tst.w	r2, #298	; 0x12a
   12564:	d147      	bne.n	125f6 <HAL_SD_ReadBlocks+0x146>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= 32U))
   12566:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12568:	0411      	lsls	r1, r2, #16
   1256a:	d5f1      	bpl.n	12550 <HAL_SD_ReadBlocks+0xa0>
   1256c:	f1b9 0f1f 	cmp.w	r9, #31
   12570:	d9ee      	bls.n	12550 <HAL_SD_ReadBlocks+0xa0>
   12572:	f105 0a04 	add.w	sl, r5, #4
   12576:	f105 0824 	add.w	r8, r5, #36	; 0x24
   1257a:	e000      	b.n	1257e <HAL_SD_ReadBlocks+0xce>
   1257c:	6823      	ldr	r3, [r4, #0]
          data = SDMMC_ReadFIFO(hsd->Instance);
   1257e:	4618      	mov	r0, r3
   12580:	f10a 0a04 	add.w	sl, sl, #4
   12584:	f002 ff16 	bl	153b4 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
   12588:	f80a 0c08 	strb.w	r0, [sl, #-8]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
   1258c:	0a02      	lsrs	r2, r0, #8
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
   1258e:	0c03      	lsrs	r3, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
   12590:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
   12592:	f80a 2c07 	strb.w	r2, [sl, #-7]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
   12596:	f80a 3c06 	strb.w	r3, [sl, #-6]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
   1259a:	f80a 0c05 	strb.w	r0, [sl, #-5]
        for(count = 0U; count < 8U; count++)
   1259e:	45c2      	cmp	sl, r8
   125a0:	d1ec      	bne.n	1257c <HAL_SD_ReadBlocks+0xcc>
   125a2:	3520      	adds	r5, #32
        dataremaining -= 32U;
   125a4:	f1a9 0920 	sub.w	r9, r9, #32
   125a8:	e7d2      	b.n	12550 <HAL_SD_ReadBlocks+0xa0>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   125aa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   125ac:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   125ae:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   125b2:	63a3      	str	r3, [r4, #56]	; 0x38
}
   125b4:	b006      	add	sp, #24
   125b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
   125ba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   125bc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   125c0:	63a3      	str	r3, [r4, #56]	; 0x38
}
   125c2:	b006      	add	sp, #24
   125c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   125c8:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   125cc:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
   125ce:	2600      	movs	r6, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   125d0:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
   125d4:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   125d6:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
   125d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   125da:	431a      	orrs	r2, r3
   125dc:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   125de:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   125e2:	6326      	str	r6, [r4, #48]	; 0x30
      return HAL_ERROR;
   125e4:	e77a      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
   125e6:	2301      	movs	r3, #1
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
   125e8:	4641      	mov	r1, r8
   125ea:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
   125ec:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
   125ee:	f002 ffb9 	bl	15564 <SDMMC_CmdReadSingleBlock>
   125f2:	4602      	mov	r2, r0
   125f4:	e7a6      	b.n	12544 <HAL_SD_ReadBlocks+0x94>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
   125f6:	68da      	ldr	r2, [r3, #12]
   125f8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   125fc:	60da      	str	r2, [r3, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
   125fe:	6823      	ldr	r3, [r4, #0]
   12600:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12602:	05d2      	lsls	r2, r2, #23
   12604:	d50b      	bpl.n	1261e <HAL_SD_ReadBlocks+0x16e>
   12606:	2e01      	cmp	r6, #1
   12608:	d909      	bls.n	1261e <HAL_SD_ReadBlocks+0x16e>
      if(hsd->SdCard.CardType != CARD_SECURED)
   1260a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   1260c:	2a03      	cmp	r2, #3
   1260e:	d006      	beq.n	1261e <HAL_SD_ReadBlocks+0x16e>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
   12610:	4618      	mov	r0, r3
   12612:	f003 f8bf 	bl	15794 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
   12616:	4603      	mov	r3, r0
   12618:	2800      	cmp	r0, #0
   1261a:	d154      	bne.n	126c6 <HAL_SD_ReadBlocks+0x216>
   1261c:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   1261e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12620:	f012 0208 	ands.w	r2, r2, #8
   12624:	d127      	bne.n	12676 <HAL_SD_ReadBlocks+0x1c6>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   12626:	6b59      	ldr	r1, [r3, #52]	; 0x34
   12628:	f011 0102 	ands.w	r1, r1, #2
   1262c:	d133      	bne.n	12696 <HAL_SD_ReadBlocks+0x1e6>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   1262e:	6b58      	ldr	r0, [r3, #52]	; 0x34
   12630:	f010 0020 	ands.w	r0, r0, #32
   12634:	d03e      	beq.n	126b4 <HAL_SD_ReadBlocks+0x204>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12636:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   1263a:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1263c:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
   12640:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12642:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
   12644:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12646:	f043 0320 	orr.w	r3, r3, #32
   1264a:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1264c:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   12650:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   12652:	e743      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12654:	f640 73ff 	movw	r3, #4095	; 0xfff
   12658:	6825      	ldr	r5, [r4, #0]
        hsd->State= HAL_SD_STATE_READY;
   1265a:	2101      	movs	r1, #1
        hsd->Context = SD_CONTEXT_NONE;
   1265c:	2200      	movs	r2, #0
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1265e:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
        return HAL_TIMEOUT;
   12662:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12664:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
   12666:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12668:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1266c:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
   1266e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
   12672:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
   12674:	e732      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12676:	f640 71ff 	movw	r1, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   1267a:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
   1267c:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1267e:	f6c1 71e0 	movt	r1, #8160	; 0x1fe0
      return HAL_ERROR;
   12682:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12684:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
   12686:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12688:	f043 0308 	orr.w	r3, r3, #8
   1268c:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1268e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   12692:	6325      	str	r5, [r4, #48]	; 0x30
      return HAL_ERROR;
   12694:	e722      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12696:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   1269a:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1269c:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
   126a0:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   126a2:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
   126a4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   126a6:	f043 0302 	orr.w	r3, r3, #2
   126aa:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   126ac:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   126b0:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
   126b2:	e713      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   126b4:	f640 723a 	movw	r2, #3898	; 0xf3a
    hsd->State = HAL_SD_STATE_READY;
   126b8:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   126ba:	f6c1 0200 	movt	r2, #6144	; 0x1800
   126be:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   126c0:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    return HAL_OK;
   126c4:	e70a      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   126c6:	f640 72ff 	movw	r2, #4095	; 0xfff
   126ca:	6820      	ldr	r0, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
   126cc:	2101      	movs	r1, #1
          hsd->Context = SD_CONTEXT_NONE;
   126ce:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   126d0:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
   126d4:	6382      	str	r2, [r0, #56]	; 0x38
          return HAL_ERROR;
   126d6:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
   126d8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   126da:	4313      	orrs	r3, r2
   126dc:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
   126de:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
   126e2:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
   126e4:	e6fa      	b.n	124dc <HAL_SD_ReadBlocks+0x2c>
   126e6:	bf00      	nop

000126e8 <HAL_SD_WriteBlocks>:
{
   126e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   126ec:	460d      	mov	r5, r1
   126ee:	b089      	sub	sp, #36	; 0x24
   126f0:	4604      	mov	r4, r0
   126f2:	4616      	mov	r6, r2
   126f4:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
   126f6:	f7f5 fea3 	bl	8440 <HAL_GetTick>
  if(NULL == pData)
   126fa:	2d00      	cmp	r5, #0
   126fc:	d05f      	beq.n	127be <HAL_SD_WriteBlocks+0xd6>
   126fe:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
   12700:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
   12704:	b2c0      	uxtb	r0, r0
   12706:	2801      	cmp	r0, #1
   12708:	d007      	beq.n	1271a <HAL_SD_WriteBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   1270a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   1270c:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   1270e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   12712:	63a3      	str	r3, [r4, #56]	; 0x38
}
   12714:	b009      	add	sp, #36	; 0x24
   12716:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   1271a:	19f3      	adds	r3, r6, r7
   1271c:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   1271e:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   12720:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   12722:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   12724:	d853      	bhi.n	127ce <HAL_SD_WriteBlocks+0xe6>
    hsd->Instance->DCTRL = 0U;
   12726:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
   12728:	2203      	movs	r2, #3
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   1272a:	0278      	lsls	r0, r7, #9
    hsd->State = HAL_SD_STATE_BUSY;
   1272c:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   12730:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
   12732:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   12734:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   12738:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   1273a:	9102      	str	r1, [sp, #8]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   1273c:	a902      	add	r1, sp, #8
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   1273e:	2b01      	cmp	r3, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
   12740:	f04f 0300 	mov.w	r3, #0
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   12744:	e9cd 0203 	strd	r0, r2, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   12748:	6820      	ldr	r0, [r4, #0]
      add *= 512U;
   1274a:	bf18      	it	ne
   1274c:	0276      	lslne	r6, r6, #9
    config.DPSM          = SDMMC_DPSM_DISABLE;
   1274e:	9307      	str	r3, [sp, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   12750:	e9cd 3305 	strd	r3, r3, [sp, #20]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   12754:	f002 fe56 	bl	15404 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   12758:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
   1275a:	2f01      	cmp	r7, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   1275c:	68d3      	ldr	r3, [r2, #12]
   1275e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12762:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
   12764:	d949      	bls.n	127fa <HAL_SD_WriteBlocks+0x112>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
   12766:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
   12768:	4631      	mov	r1, r6
   1276a:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
   1276c:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
   1276e:	f002 ffcb 	bl	15708 <SDMMC_CmdWriteMultiBlock>
   12772:	4602      	mov	r2, r0
   12774:	6823      	ldr	r3, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
   12776:	2a00      	cmp	r2, #0
   12778:	d130      	bne.n	127dc <HAL_SD_WriteBlocks+0xf4>
    dataremaining = config.DataLength;
   1277a:	9e03      	ldr	r6, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1277c:	e007      	b.n	1278e <HAL_SD_WriteBlocks+0xa6>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
   1277e:	f7f5 fe5f 	bl	8440 <HAL_GetTick>
   12782:	9b10      	ldr	r3, [sp, #64]	; 0x40
   12784:	eba0 0008 	sub.w	r0, r0, r8
   12788:	4298      	cmp	r0, r3
   1278a:	d26d      	bcs.n	12868 <HAL_SD_WriteBlocks+0x180>
   1278c:	6823      	ldr	r3, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1278e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12790:	f412 7f8d 	tst.w	r2, #282	; 0x11a
   12794:	d139      	bne.n	1280a <HAL_SD_WriteBlocks+0x122>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= 32U))
   12796:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12798:	0451      	lsls	r1, r2, #17
   1279a:	d5f0      	bpl.n	1277e <HAL_SD_WriteBlocks+0x96>
   1279c:	2e1f      	cmp	r6, #31
   1279e:	d9ee      	bls.n	1277e <HAL_SD_WriteBlocks+0x96>
   127a0:	f105 0920 	add.w	r9, r5, #32
   127a4:	e000      	b.n	127a8 <HAL_SD_WriteBlocks+0xc0>
   127a6:	6823      	ldr	r3, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
   127a8:	f855 2b04 	ldr.w	r2, [r5], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
   127ac:	4618      	mov	r0, r3
   127ae:	a901      	add	r1, sp, #4
          data |= ((uint32_t)(*tempbuff) << 24U);
   127b0:	9201      	str	r2, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
   127b2:	f002 fe03 	bl	153bc <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
   127b6:	454d      	cmp	r5, r9
   127b8:	d1f5      	bne.n	127a6 <HAL_SD_WriteBlocks+0xbe>
        dataremaining -= 32U;
   127ba:	3e20      	subs	r6, #32
   127bc:	e7df      	b.n	1277e <HAL_SD_WriteBlocks+0x96>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   127be:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   127c0:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   127c2:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   127c6:	63a3      	str	r3, [r4, #56]	; 0x38
}
   127c8:	b009      	add	sp, #36	; 0x24
   127ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
   127ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   127d0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   127d4:	63a3      	str	r3, [r4, #56]	; 0x38
}
   127d6:	b009      	add	sp, #36	; 0x24
   127d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   127dc:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   127e0:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
   127e2:	2600      	movs	r6, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   127e4:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
   127e8:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   127ea:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
   127ec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   127ee:	431a      	orrs	r2, r3
   127f0:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   127f2:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   127f6:	6326      	str	r6, [r4, #48]	; 0x30
      return HAL_ERROR;
   127f8:	e78c      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
   127fa:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
   127fc:	4631      	mov	r1, r6
   127fe:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
   12800:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
   12802:	f002 ff3b 	bl	1567c <SDMMC_CmdWriteSingleBlock>
   12806:	4602      	mov	r2, r0
   12808:	e7b4      	b.n	12774 <HAL_SD_WriteBlocks+0x8c>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
   1280a:	68da      	ldr	r2, [r3, #12]
   1280c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   12810:	60da      	str	r2, [r3, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
   12812:	6823      	ldr	r3, [r4, #0]
   12814:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12816:	05d2      	lsls	r2, r2, #23
   12818:	d50b      	bpl.n	12832 <HAL_SD_WriteBlocks+0x14a>
   1281a:	2f01      	cmp	r7, #1
   1281c:	d909      	bls.n	12832 <HAL_SD_WriteBlocks+0x14a>
      if(hsd->SdCard.CardType != CARD_SECURED)
   1281e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   12820:	2a03      	cmp	r2, #3
   12822:	d006      	beq.n	12832 <HAL_SD_WriteBlocks+0x14a>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
   12824:	4618      	mov	r0, r3
   12826:	f002 ffb5 	bl	15794 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
   1282a:	4603      	mov	r3, r0
   1282c:	2800      	cmp	r0, #0
   1282e:	d152      	bne.n	128d6 <HAL_SD_WriteBlocks+0x1ee>
   12830:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   12832:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12834:	f012 0208 	ands.w	r2, r2, #8
   12838:	d125      	bne.n	12886 <HAL_SD_WriteBlocks+0x19e>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   1283a:	6b59      	ldr	r1, [r3, #52]	; 0x34
   1283c:	f011 0102 	ands.w	r1, r1, #2
   12840:	d131      	bne.n	128a6 <HAL_SD_WriteBlocks+0x1be>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
   12842:	6b58      	ldr	r0, [r3, #52]	; 0x34
   12844:	f010 0010 	ands.w	r0, r0, #16
   12848:	d03c      	beq.n	128c4 <HAL_SD_WriteBlocks+0x1dc>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1284a:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   1284e:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12850:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
   12854:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12856:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
   12858:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1285a:	f043 0310 	orr.w	r3, r3, #16
   1285e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   12860:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   12864:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   12866:	e755      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12868:	f640 73ff 	movw	r3, #4095	; 0xfff
   1286c:	6825      	ldr	r5, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
   1286e:	2101      	movs	r1, #1
        hsd->Context = SD_CONTEXT_NONE;
   12870:	2200      	movs	r2, #0
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12872:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
        return HAL_TIMEOUT;
   12876:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12878:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
   1287a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1287c:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
   1287e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
   12882:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
   12884:	e746      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12886:	f640 71ff 	movw	r1, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   1288a:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
   1288c:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1288e:	f6c1 71e0 	movt	r1, #8160	; 0x1fe0
      return HAL_ERROR;
   12892:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12894:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
   12896:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12898:	f043 0308 	orr.w	r3, r3, #8
   1289c:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1289e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   128a2:	6325      	str	r5, [r4, #48]	; 0x30
      return HAL_ERROR;
   128a4:	e736      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   128a6:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
   128aa:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   128ac:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
   128b0:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   128b2:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
   128b4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   128b6:	f043 0302 	orr.w	r3, r3, #2
   128ba:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   128bc:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   128c0:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
   128c2:	e727      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   128c4:	f640 723a 	movw	r2, #3898	; 0xf3a
    hsd->State = HAL_SD_STATE_READY;
   128c8:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   128ca:	f6c1 0200 	movt	r2, #6144	; 0x1800
   128ce:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   128d0:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    return HAL_OK;
   128d4:	e71e      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   128d6:	f640 72ff 	movw	r2, #4095	; 0xfff
   128da:	6820      	ldr	r0, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
   128dc:	2101      	movs	r1, #1
          hsd->Context = SD_CONTEXT_NONE;
   128de:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   128e0:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
   128e4:	6382      	str	r2, [r0, #56]	; 0x38
          return HAL_ERROR;
   128e6:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
   128e8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   128ea:	4313      	orrs	r3, r2
   128ec:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
   128ee:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
   128f2:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
   128f4:	e70e      	b.n	12714 <HAL_SD_WriteBlocks+0x2c>
   128f6:	bf00      	nop

000128f8 <HAL_SD_DriveTransceiver_1_8V_Callback>:
}
   128f8:	4770      	bx	lr
   128fa:	bf00      	nop

000128fc <HAL_SD_GetCardCSD>:
{
   128fc:	4603      	mov	r3, r0
  pCSD->Reserved2 = 0U; /*!< Reserved */
   128fe:	2000      	movs	r0, #0
{
   12900:	b430      	push	{r4, r5}
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
   12902:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   12904:	0f92      	lsrs	r2, r2, #30
   12906:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
   12908:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1290a:	f3c2 6283 	ubfx	r2, r2, #26, #4
   1290e:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
   12910:	f893 2063 	ldrb.w	r2, [r3, #99]	; 0x63
   12914:	f002 0203 	and.w	r2, r2, #3
   12918:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
   1291a:	f893 2062 	ldrb.w	r2, [r3, #98]	; 0x62
   1291e:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
   12920:	f893 2061 	ldrb.w	r2, [r3, #97]	; 0x61
   12924:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
   12926:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   1292a:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
   1292c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   1292e:	0d12      	lsrs	r2, r2, #20
   12930:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
   12932:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
   12936:	f002 020f 	and.w	r2, r2, #15
   1293a:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
   1293c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   1293e:	f3c2 32c0 	ubfx	r2, r2, #15, #1
   12942:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
   12944:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   12946:	f3c2 3280 	ubfx	r2, r2, #14, #1
   1294a:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
   1294c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   1294e:	f3c2 3240 	ubfx	r2, r2, #13, #1
   12952:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
   12954:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   12956:	f3c2 3200 	ubfx	r2, r2, #12, #1
   1295a:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
   1295c:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
   1295e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   12960:	2a00      	cmp	r2, #0
   12962:	f040 8086 	bne.w	12a72 <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   12966:	6e5d      	ldr	r5, [r3, #100]	; 0x64
   12968:	f640 72fc 	movw	r2, #4092	; 0xffc
   1296c:	6e98      	ldr	r0, [r3, #104]	; 0x68
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   1296e:	2401      	movs	r4, #1
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   12970:	ea02 0285 	and.w	r2, r2, r5, lsl #2
    hsd->SdCard.LogBlockSize = 512U;
   12974:	f44f 7500 	mov.w	r5, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   12978:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
   1297c:	610a      	str	r2, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
   1297e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   12980:	f3c2 62c2 	ubfx	r2, r2, #27, #3
   12984:	750a      	strb	r2, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
   12986:	f893 206b 	ldrb.w	r2, [r3, #107]	; 0x6b
   1298a:	f002 0207 	and.w	r2, r2, #7
   1298e:	754a      	strb	r2, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
   12990:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   12992:	f3c2 5242 	ubfx	r2, r2, #21, #3
   12996:	758a      	strb	r2, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
   12998:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   1299a:	f3c2 4282 	ubfx	r2, r2, #18, #3
   1299e:	75ca      	strb	r2, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
   129a0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   129a2:	f3c2 32c2 	ubfx	r2, r2, #15, #3
   129a6:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
   129a8:	690a      	ldr	r2, [r1, #16]
   129aa:	4422      	add	r2, r4
   129ac:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
   129ae:	7e08      	ldrb	r0, [r1, #24]
   129b0:	f000 0007 	and.w	r0, r0, #7
   129b4:	3002      	adds	r0, #2
   129b6:	4082      	lsls	r2, r0
   129b8:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   129ba:	7a08      	ldrb	r0, [r1, #8]
    hsd->SdCard.LogBlockSize = 512U;
   129bc:	659d      	str	r5, [r3, #88]	; 0x58
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   129be:	f000 000f 	and.w	r0, r0, #15
   129c2:	fa04 f000 	lsl.w	r0, r4, r0
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
   129c6:	0a44      	lsrs	r4, r0, #9
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   129c8:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
   129ca:	fb02 f204 	mul.w	r2, r2, r4
   129ce:	655a      	str	r2, [r3, #84]	; 0x54
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   129d0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  pCSD->Reserved3 = 0;
   129d2:	2500      	movs	r5, #0
  pCSD->Reserved4 = 1;
   129d4:	2401      	movs	r4, #1
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   129d6:	f3c2 3280 	ubfx	r2, r2, #14, #1
  return HAL_OK;
   129da:	4628      	mov	r0, r5
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   129dc:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
   129de:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   129e0:	f3c2 12c6 	ubfx	r2, r2, #7, #7
   129e4:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
   129e6:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   129e8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   129ec:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
   129ee:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   129f0:	0fd2      	lsrs	r2, r2, #31
   129f2:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
   129f4:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   129f6:	f3c2 7241 	ubfx	r2, r2, #29, #2
   129fa:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
   129fc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   129fe:	f3c2 6282 	ubfx	r2, r2, #26, #3
   12a02:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
   12a04:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a06:	f3c2 5283 	ubfx	r2, r2, #22, #4
   12a0a:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
   12a0c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a0e:	f3c2 5240 	ubfx	r2, r2, #21, #1
   12a12:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->Reserved3 = 0;
   12a16:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
   12a1a:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
   12a1e:	4022      	ands	r2, r4
   12a20:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
   12a24:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a26:	f3c2 32c0 	ubfx	r2, r2, #15, #1
   12a2a:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
   12a2e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a30:	f3c2 3280 	ubfx	r2, r2, #14, #1
   12a34:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
   12a38:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a3a:	f3c2 3240 	ubfx	r2, r2, #13, #1
   12a3e:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
   12a42:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a44:	f3c2 3200 	ubfx	r2, r2, #12, #1
   12a48:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
   12a4c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a4e:	f3c2 2281 	ubfx	r2, r2, #10, #2
   12a52:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
   12a56:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   12a58:	f3c2 2201 	ubfx	r2, r2, #8, #2
   12a5c:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
   12a60:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   12a62:	f3c3 0346 	ubfx	r3, r3, #1, #7
   12a66:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
   12a6a:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
}
   12a6e:	bc30      	pop	{r4, r5}
   12a70:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
   12a72:	2a01      	cmp	r2, #1
   12a74:	d00f      	beq.n	12a96 <HAL_SD_GetCardCSD+0x19a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12a76:	f640 72ff 	movw	r2, #4095	; 0xfff
   12a7a:	681c      	ldr	r4, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
   12a7c:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12a7e:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
    return HAL_ERROR;
   12a82:	4608      	mov	r0, r1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12a84:	63a2      	str	r2, [r4, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   12a86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   12a88:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   12a8c:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   12a8e:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
}
   12a92:	bc30      	pop	{r4, r5}
   12a94:	4770      	bx	lr
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
   12a96:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    hsd->SdCard.BlockSize = 512U;
   12a98:	f44f 7000 	mov.w	r0, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
   12a9c:	f8b3 406a 	ldrh.w	r4, [r3, #106]	; 0x6a
   12aa0:	0412      	lsls	r2, r2, #16
   12aa2:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
   12aa6:	4322      	orrs	r2, r4
   12aa8:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   12aaa:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
   12aac:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   12aae:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
   12ab0:	6598      	str	r0, [r3, #88]	; 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   12ab2:	0292      	lsls	r2, r2, #10
   12ab4:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
   12ab6:	655a      	str	r2, [r3, #84]	; 0x54
   12ab8:	e78a      	b.n	129d0 <HAL_SD_GetCardCSD+0xd4>
   12aba:	bf00      	nop

00012abc <HAL_SD_InitCard>:
{
   12abc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   12ac0:	6982      	ldr	r2, [r0, #24]
{
   12ac2:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
   12ac4:	2300      	movs	r3, #0
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
   12ac6:	21fa      	movs	r1, #250	; 0xfa
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   12ac8:	2a02      	cmp	r2, #2
{
   12aca:	4604      	mov	r4, r0
   12acc:	6805      	ldr	r5, [r0, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
   12ace:	910b      	str	r1, [sp, #44]	; 0x2c
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
   12ad0:	e9cd 3307 	strd	r3, r3, [sp, #28]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
   12ad4:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   12ad8:	d104      	bne.n	12ae4 <HAL_SD_InitCard+0x28>
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
   12ada:	682b      	ldr	r3, [r5, #0]
   12adc:	f043 0310 	orr.w	r3, r3, #16
   12ae0:	602b      	str	r3, [r5, #0]
   12ae2:	6805      	ldr	r5, [r0, #0]
  (void)SDMMC_Init(hsd->Instance, Init);
   12ae4:	aa0a      	add	r2, sp, #40	; 0x28
   12ae6:	ab07      	add	r3, sp, #28
   12ae8:	ca07      	ldmia	r2, {r0, r1, r2}
   12aea:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   12aee:	4628      	mov	r0, r5
   12af0:	cb0e      	ldmia	r3, {r1, r2, r3}
   12af2:	f002 fbed 	bl	152d0 <SDMMC_Init>
  (void)SDMMC_PowerState_ON(hsd->Instance);
   12af6:	6820      	ldr	r0, [r4, #0]
   12af8:	f002 fc66 	bl	153c8 <SDMMC_PowerState_ON>
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC)/(2U*SDMMC_INIT_CLK_DIV);
   12afc:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   12b00:	f7fe fc08 	bl	11314 <HAL_RCCEx_GetPeriphCLKFreq>
   12b04:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   12b08:	f2c1 0362 	movt	r3, #4194	; 0x1062
   12b0c:	fba3 3000 	umull	r3, r0, r3, r0
  if(sdmmc_clk != 0U)
   12b10:	0940      	lsrs	r0, r0, #5
   12b12:	d01c      	beq.n	12b4e <HAL_SD_InitCard+0x92>
    HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
   12b14:	f242 1310 	movw	r3, #8464	; 0x2110
   12b18:	f2c0 0301 	movt	r3, #1
   12b1c:	fbb3 f0f0 	udiv	r0, r3, r0
   12b20:	3001      	adds	r0, #1
   12b22:	f7f5 fc93 	bl	844c <HAL_Delay>
  __IO uint32_t count = 0U;
   12b26:	2300      	movs	r3, #0
   12b28:	9306      	str	r3, [sp, #24]
  uint32_t tickstart = HAL_GetTick();
   12b2a:	f7f5 fc89 	bl	8440 <HAL_GetTick>
   12b2e:	4680      	mov	r8, r0
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
   12b30:	6820      	ldr	r0, [r4, #0]
   12b32:	f002 fedd 	bl	158f0 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
   12b36:	4605      	mov	r5, r0
   12b38:	b168      	cbz	r0, 12b56 <HAL_SD_InitCard+0x9a>
    hsd->State = HAL_SD_STATE_READY;
   12b3a:	2601      	movs	r6, #1
   12b3c:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
   12b40:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12b42:	431d      	orrs	r5, r3
   12b44:	63a5      	str	r5, [r4, #56]	; 0x38
}
   12b46:	4630      	mov	r0, r6
   12b48:	b018      	add	sp, #96	; 0x60
   12b4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_Delay(2U);
   12b4e:	2002      	movs	r0, #2
   12b50:	f7f5 fc7c 	bl	844c <HAL_Delay>
   12b54:	e7e7      	b.n	12b26 <HAL_SD_InitCard+0x6a>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
   12b56:	6820      	ldr	r0, [r4, #0]
   12b58:	f002 fefa 	bl	15950 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
   12b5c:	2800      	cmp	r0, #0
   12b5e:	d17e      	bne.n	12c5e <HAL_SD_InitCard+0x1a2>
    hsd->SdCard.CardVersion = CARD_V2_X;
   12b60:	2301      	movs	r3, #1
   12b62:	6423      	str	r3, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
   12b64:	2100      	movs	r1, #0
   12b66:	6820      	ldr	r0, [r4, #0]
   12b68:	f002 ff34 	bl	159d4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   12b6c:	bb18      	cbnz	r0, 12bb6 <HAL_SD_InitCard+0xfa>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   12b6e:	9b06      	ldr	r3, [sp, #24]
   12b70:	f64f 76fe 	movw	r6, #65534	; 0xfffe
   12b74:	42b3      	cmp	r3, r6
   12b76:	f200 810f 	bhi.w	12d98 <HAL_SD_InitCard+0x2dc>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   12b7a:	2700      	movs	r7, #0
   12b7c:	f2cc 1710 	movt	r7, #49424	; 0xc110
   12b80:	e00c      	b.n	12b9c <HAL_SD_InitCard+0xe0>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   12b82:	4601      	mov	r1, r0
   12b84:	6820      	ldr	r0, [r4, #0]
   12b86:	f002 fc2b 	bl	153e0 <SDMMC_GetResponse>
    count++;
   12b8a:	9b06      	ldr	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   12b8c:	1e02      	subs	r2, r0, #0
    count++;
   12b8e:	f103 0301 	add.w	r3, r3, #1
   12b92:	9306      	str	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   12b94:	9b06      	ldr	r3, [sp, #24]
   12b96:	db11      	blt.n	12bbc <HAL_SD_InitCard+0x100>
   12b98:	42b3      	cmp	r3, r6
   12b9a:	d80f      	bhi.n	12bbc <HAL_SD_InitCard+0x100>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
   12b9c:	2100      	movs	r1, #0
   12b9e:	6820      	ldr	r0, [r4, #0]
   12ba0:	f002 ff18 	bl	159d4 <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   12ba4:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
   12ba6:	4605      	mov	r5, r0
   12ba8:	2800      	cmp	r0, #0
   12baa:	d1c6      	bne.n	12b3a <HAL_SD_InitCard+0x7e>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   12bac:	6820      	ldr	r0, [r4, #0]
   12bae:	f002 ff57 	bl	15a60 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   12bb2:	2800      	cmp	r0, #0
   12bb4:	d0e5      	beq.n	12b82 <HAL_SD_InitCard+0xc6>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   12bb6:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   12bba:	e7be      	b.n	12b3a <HAL_SD_InitCard+0x7e>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
   12bbc:	9906      	ldr	r1, [sp, #24]
   12bbe:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   12bc2:	4299      	cmp	r1, r3
   12bc4:	f200 80a1 	bhi.w	12d0a <HAL_SD_InitCard+0x24e>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
   12bc8:	0057      	lsls	r7, r2, #1
   12bca:	6820      	ldr	r0, [r4, #0]
   12bcc:	d504      	bpl.n	12bd8 <HAL_SD_InitCard+0x11c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   12bce:	69a3      	ldr	r3, [r4, #24]
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
   12bd0:	2101      	movs	r1, #1
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   12bd2:	2b02      	cmp	r3, #2
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
   12bd4:	63e1      	str	r1, [r4, #60]	; 0x3c
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   12bd6:	d055      	beq.n	12c84 <HAL_SD_InitCard+0x1c8>
  uint16_t sd_rca = 1U;
   12bd8:	2301      	movs	r3, #1
   12bda:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
   12bde:	f002 fbfb 	bl	153d8 <SDMMC_GetPowerState>
   12be2:	2800      	cmp	r0, #0
   12be4:	d048      	beq.n	12c78 <HAL_SD_InitCard+0x1bc>
  if(hsd->SdCard.CardType != CARD_SECURED)
   12be6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   12be8:	6823      	ldr	r3, [r4, #0]
   12bea:	2a03      	cmp	r2, #3
   12bec:	d128      	bne.n	12c40 <HAL_SD_InitCard+0x184>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   12bee:	4618      	mov	r0, r3
   12bf0:	2104      	movs	r1, #4
   12bf2:	f002 fbf5 	bl	153e0 <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   12bf6:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   12bf8:	0d03      	lsrs	r3, r0, #20
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   12bfa:	4620      	mov	r0, r4
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   12bfc:	6463      	str	r3, [r4, #68]	; 0x44
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   12bfe:	f7ff fe7d 	bl	128fc <HAL_SD_GetCardCSD>
   12c02:	4606      	mov	r6, r0
   12c04:	2800      	cmp	r0, #0
   12c06:	d13a      	bne.n	12c7e <HAL_SD_InitCard+0x1c2>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
   12c08:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   12c0a:	4603      	mov	r3, r0
   12c0c:	6820      	ldr	r0, [r4, #0]
   12c0e:	0412      	lsls	r2, r2, #16
   12c10:	f002 fe28 	bl	15864 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
   12c14:	b9c8      	cbnz	r0, 12c4a <HAL_SD_InitCard+0x18e>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   12c16:	f44f 7100 	mov.w	r1, #512	; 0x200
   12c1a:	6820      	ldr	r0, [r4, #0]
   12c1c:	f002 fc5c 	bl	154d8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   12c20:	2800      	cmp	r0, #0
   12c22:	d090      	beq.n	12b46 <HAL_SD_InitCard+0x8a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12c24:	f640 73ff 	movw	r3, #4095	; 0xfff
   12c28:	6821      	ldr	r1, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
   12c2a:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12c2c:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
    return HAL_ERROR;
   12c30:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12c32:	638b      	str	r3, [r1, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   12c34:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12c36:	4318      	orrs	r0, r3
   12c38:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   12c3a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_ERROR;
   12c3e:	e782      	b.n	12b46 <HAL_SD_InitCard+0x8a>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
   12c40:	4618      	mov	r0, r3
   12c42:	f002 ffd3 	bl	15bec <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
   12c46:	2800      	cmp	r0, #0
   12c48:	d062      	beq.n	12d10 <HAL_SD_InitCard+0x254>
    hsd->State = HAL_SD_STATE_READY;
   12c4a:	2601      	movs	r6, #1
   12c4c:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
   12c50:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   12c52:	4308      	orrs	r0, r1
   12c54:	63a0      	str	r0, [r4, #56]	; 0x38
}
   12c56:	4630      	mov	r0, r6
   12c58:	b018      	add	sp, #96	; 0x60
   12c5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->SdCard.CardVersion = CARD_V1_X;
   12c5e:	6425      	str	r5, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
   12c60:	6820      	ldr	r0, [r4, #0]
   12c62:	f002 fe45 	bl	158f0 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
   12c66:	4605      	mov	r5, r0
   12c68:	2800      	cmp	r0, #0
   12c6a:	f47f af66 	bne.w	12b3a <HAL_SD_InitCard+0x7e>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
   12c6e:	6c23      	ldr	r3, [r4, #64]	; 0x40
   12c70:	2b01      	cmp	r3, #1
   12c72:	f47f af7c 	bne.w	12b6e <HAL_SD_InitCard+0xb2>
   12c76:	e775      	b.n	12b64 <HAL_SD_InitCard+0xa8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
   12c78:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   12c7c:	e7e5      	b.n	12c4a <HAL_SD_InitCard+0x18e>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   12c7e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
   12c82:	e7e2      	b.n	12c4a <HAL_SD_InitCard+0x18e>
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
   12c84:	01d6      	lsls	r6, r2, #7
   12c86:	d5a7      	bpl.n	12bd8 <HAL_SD_InitCard+0x11c>
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
   12c88:	f44f 7300 	mov.w	r3, #512	; 0x200
   12c8c:	65e3      	str	r3, [r4, #92]	; 0x5c
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
   12c8e:	6803      	ldr	r3, [r0, #0]
   12c90:	f043 0308 	orr.w	r3, r3, #8
   12c94:	6003      	str	r3, [r0, #0]
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
   12c96:	6820      	ldr	r0, [r4, #0]
   12c98:	f003 f906 	bl	15ea8 <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
   12c9c:	4605      	mov	r5, r0
   12c9e:	b130      	cbz	r0, 12cae <HAL_SD_InitCard+0x1f2>
   12ca0:	e74b      	b.n	12b3a <HAL_SD_InitCard+0x7e>
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   12ca2:	f7f5 fbcd 	bl	8440 <HAL_GetTick>
   12ca6:	eba0 0008 	sub.w	r0, r0, r8
   12caa:	3001      	adds	r0, #1
   12cac:	d079      	beq.n	12da2 <HAL_SD_InitCard+0x2e6>
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
   12cae:	6823      	ldr	r3, [r4, #0]
   12cb0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12cb2:	0155      	lsls	r5, r2, #5
   12cb4:	d5f5      	bpl.n	12ca2 <HAL_SD_InitCard+0x1e6>
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
   12cb6:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   12cba:	639a      	str	r2, [r3, #56]	; 0x38
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
   12cbc:	6823      	ldr	r3, [r4, #0]
   12cbe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   12cc0:	02d8      	lsls	r0, r3, #11
   12cc2:	f57f af78 	bpl.w	12bb6 <HAL_SD_InitCard+0xfa>
          HAL_SD_DriveTransceiver_1_8V_Callback(SET);
   12cc6:	2001      	movs	r0, #1
   12cc8:	f7ff fe16 	bl	128f8 <HAL_SD_DriveTransceiver_1_8V_Callback>
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
   12ccc:	6822      	ldr	r2, [r4, #0]
   12cce:	6813      	ldr	r3, [r2, #0]
   12cd0:	f043 0304 	orr.w	r3, r3, #4
   12cd4:	6013      	str	r3, [r2, #0]
   12cd6:	e005      	b.n	12ce4 <HAL_SD_InitCard+0x228>
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   12cd8:	f7f5 fbb2 	bl	8440 <HAL_GetTick>
   12cdc:	eba0 0008 	sub.w	r0, r0, r8
   12ce0:	3001      	adds	r0, #1
   12ce2:	d05e      	beq.n	12da2 <HAL_SD_InitCard+0x2e6>
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
   12ce4:	6823      	ldr	r3, [r4, #0]
   12ce6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12ce8:	0191      	lsls	r1, r2, #6
   12cea:	d5f5      	bpl.n	12cd8 <HAL_SD_InitCard+0x21c>
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
   12cec:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   12cf0:	639a      	str	r2, [r3, #56]	; 0x38
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
   12cf2:	6823      	ldr	r3, [r4, #0]
   12cf4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12cf6:	02d2      	lsls	r2, r2, #11
   12cf8:	d407      	bmi.n	12d0a <HAL_SD_InitCard+0x24e>
          hsd->Instance->POWER = 0x13U;
   12cfa:	2113      	movs	r1, #19
          hsd->Instance->ICR = 0xFFFFFFFFU;
   12cfc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          hsd->Instance->POWER = 0x13U;
   12d00:	6019      	str	r1, [r3, #0]
          hsd->Instance->ICR = 0xFFFFFFFFU;
   12d02:	6823      	ldr	r3, [r4, #0]
   12d04:	639a      	str	r2, [r3, #56]	; 0x38
   12d06:	6820      	ldr	r0, [r4, #0]
   12d08:	e766      	b.n	12bd8 <HAL_SD_InitCard+0x11c>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
   12d0a:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
   12d0e:	e714      	b.n	12b3a <HAL_SD_InitCard+0x7e>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   12d10:	4601      	mov	r1, r0
   12d12:	6820      	ldr	r0, [r4, #0]
   12d14:	f002 fb64 	bl	153e0 <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   12d18:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   12d1a:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   12d1c:	6820      	ldr	r0, [r4, #0]
   12d1e:	f002 fb5f 	bl	153e0 <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   12d22:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   12d24:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   12d26:	6820      	ldr	r0, [r4, #0]
   12d28:	f002 fb5a 	bl	153e0 <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   12d2c:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   12d2e:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   12d30:	6820      	ldr	r0, [r4, #0]
   12d32:	f002 fb55 	bl	153e0 <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
   12d36:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   12d38:	67e0      	str	r0, [r4, #124]	; 0x7c
  if(hsd->SdCard.CardType != CARD_SECURED)
   12d3a:	2b03      	cmp	r3, #3
   12d3c:	d034      	beq.n	12da8 <HAL_SD_InitCard+0x2ec>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
   12d3e:	f10d 0116 	add.w	r1, sp, #22
   12d42:	6820      	ldr	r0, [r4, #0]
   12d44:	f002 ffcc 	bl	15ce0 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
   12d48:	2800      	cmp	r0, #0
   12d4a:	f47f af7e 	bne.w	12c4a <HAL_SD_InitCard+0x18e>
  if(hsd->SdCard.CardType != CARD_SECURED)
   12d4e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   12d50:	6823      	ldr	r3, [r4, #0]
   12d52:	2a03      	cmp	r2, #3
   12d54:	f43f af4b 	beq.w	12bee <HAL_SD_InitCard+0x132>
    hsd->SdCard.RelCardAdd = sd_rca;
   12d58:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   12d5c:	4618      	mov	r0, r3
    hsd->SdCard.RelCardAdd = sd_rca;
   12d5e:	64a1      	str	r1, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   12d60:	0409      	lsls	r1, r1, #16
   12d62:	f002 ff81 	bl	15c68 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
   12d66:	2800      	cmp	r0, #0
   12d68:	f47f af6f 	bne.w	12c4a <HAL_SD_InitCard+0x18e>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   12d6c:	4601      	mov	r1, r0
   12d6e:	6820      	ldr	r0, [r4, #0]
   12d70:	f002 fb36 	bl	153e0 <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   12d74:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   12d76:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   12d78:	6820      	ldr	r0, [r4, #0]
   12d7a:	f002 fb31 	bl	153e0 <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   12d7e:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   12d80:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   12d82:	6820      	ldr	r0, [r4, #0]
   12d84:	f002 fb2c 	bl	153e0 <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   12d88:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   12d8a:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   12d8c:	6820      	ldr	r0, [r4, #0]
   12d8e:	f002 fb27 	bl	153e0 <SDMMC_GetResponse>
   12d92:	6823      	ldr	r3, [r4, #0]
   12d94:	66e0      	str	r0, [r4, #108]	; 0x6c
   12d96:	e72a      	b.n	12bee <HAL_SD_InitCard+0x132>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
   12d98:	9b06      	ldr	r3, [sp, #24]
   12d9a:	42b3      	cmp	r3, r6
   12d9c:	d8b5      	bhi.n	12d0a <HAL_SD_InitCard+0x24e>
   12d9e:	6820      	ldr	r0, [r4, #0]
   12da0:	e71a      	b.n	12bd8 <HAL_SD_InitCard+0x11c>
            return HAL_SD_ERROR_TIMEOUT;
   12da2:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   12da6:	e6c8      	b.n	12b3a <HAL_SD_InitCard+0x7e>
   12da8:	6823      	ldr	r3, [r4, #0]
   12daa:	e720      	b.n	12bee <HAL_SD_InitCard+0x132>

00012dac <HAL_SD_GetCardStatus>:
{
   12dac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12db0:	4604      	mov	r4, r0
   12db2:	b096      	sub	sp, #88	; 0x58
   12db4:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
   12db6:	f7f5 fb43 	bl	8440 <HAL_GetTick>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   12dba:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
   12dbc:	4680      	mov	r8, r0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   12dbe:	6820      	ldr	r0, [r4, #0]
   12dc0:	f002 fb0e 	bl	153e0 <SDMMC_GetResponse>
   12dc4:	0187      	lsls	r7, r0, #6
   12dc6:	d428      	bmi.n	12e1a <HAL_SD_GetCardStatus+0x6e>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
   12dc8:	2140      	movs	r1, #64	; 0x40
   12dca:	6820      	ldr	r0, [r4, #0]
   12dcc:	f002 fb84 	bl	154d8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   12dd0:	b338      	cbz	r0, 12e22 <HAL_SD_GetCardStatus+0x76>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
   12dd2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12dd4:	63a3      	str	r3, [r4, #56]	; 0x38
   12dd6:	6823      	ldr	r3, [r4, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12dd8:	f640 71ff 	movw	r1, #4095	; 0xfff
    hsd->State = HAL_SD_STATE_READY;
   12ddc:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12dde:	f6c1 71e0 	movt	r1, #8160	; 0x1fe0
    status = HAL_ERROR;
   12de2:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12de4:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   12de6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   12de8:	4318      	orrs	r0, r3
   12dea:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   12dec:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   12df0:	f44f 7100 	mov.w	r1, #512	; 0x200
   12df4:	6820      	ldr	r0, [r4, #0]
   12df6:	f002 fb6f 	bl	154d8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   12dfa:	b150      	cbz	r0, 12e12 <HAL_SD_GetCardStatus+0x66>
    hsd->State = HAL_SD_STATE_READY;
   12dfc:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12dfe:	f640 72ff 	movw	r2, #4095	; 0xfff
   12e02:	6821      	ldr	r1, [r4, #0]
   12e04:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
    status = HAL_ERROR;
   12e08:	461e      	mov	r6, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12e0a:	638a      	str	r2, [r1, #56]	; 0x38
    hsd->ErrorCode = errorstate;
   12e0c:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   12e0e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
   12e12:	4630      	mov	r0, r6
   12e14:	b016      	add	sp, #88	; 0x58
   12e16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12e1a:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
   12e1c:	f44f 6000 	mov.w	r0, #2048	; 0x800
   12e20:	e7da      	b.n	12dd8 <HAL_SD_GetCardStatus+0x2c>
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   12e22:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   12e24:	6820      	ldr	r0, [r4, #0]
   12e26:	0409      	lsls	r1, r1, #16
   12e28:	f002 fdd4 	bl	159d4 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
   12e2c:	2800      	cmp	r0, #0
   12e2e:	d1d0      	bne.n	12dd2 <HAL_SD_GetCardStatus+0x26>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   12e30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 64U;
   12e34:	2340      	movs	r3, #64	; 0x40
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
   12e36:	2160      	movs	r1, #96	; 0x60
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   12e38:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   12e3a:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   12e3c:	2202      	movs	r2, #2
  config.DataLength    = 64U;
   12e3e:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   12e40:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
   12e42:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   12e44:	4669      	mov	r1, sp
   12e46:	6820      	ldr	r0, [r4, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   12e48:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   12e4a:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   12e4c:	f002 fada 	bl	15404 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
   12e50:	6820      	ldr	r0, [r4, #0]
   12e52:	f002 ffe1 	bl	15e18 <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
   12e56:	2800      	cmp	r0, #0
   12e58:	d1bb      	bne.n	12dd2 <HAL_SD_GetCardStatus+0x26>
  uint32_t *pData = pSDstatus;
   12e5a:	af06      	add	r7, sp, #24
   12e5c:	e005      	b.n	12e6a <HAL_SD_GetCardStatus+0xbe>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   12e5e:	f7f5 faef 	bl	8440 <HAL_GetTick>
   12e62:	eba0 0008 	sub.w	r0, r0, r8
   12e66:	3001      	adds	r0, #1
   12e68:	d013      	beq.n	12e92 <HAL_SD_GetCardStatus+0xe6>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   12e6a:	6823      	ldr	r3, [r4, #0]
   12e6c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12e6e:	f412 7f95 	tst.w	r2, #298	; 0x12a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
   12e72:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   12e74:	d110      	bne.n	12e98 <HAL_SD_GetCardStatus+0xec>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
   12e76:	0416      	lsls	r6, r2, #16
   12e78:	d5f1      	bpl.n	12e5e <HAL_SD_GetCardStatus+0xb2>
   12e7a:	f107 0620 	add.w	r6, r7, #32
   12e7e:	e000      	b.n	12e82 <HAL_SD_GetCardStatus+0xd6>
   12e80:	6823      	ldr	r3, [r4, #0]
        *pData = SDMMC_ReadFIFO(hsd->Instance);
   12e82:	4618      	mov	r0, r3
   12e84:	f002 fa96 	bl	153b4 <SDMMC_ReadFIFO>
   12e88:	f847 0b04 	str.w	r0, [r7], #4
      for(count = 0U; count < 8U; count++)
   12e8c:	42b7      	cmp	r7, r6
   12e8e:	d1f7      	bne.n	12e80 <HAL_SD_GetCardStatus+0xd4>
   12e90:	e7e5      	b.n	12e5e <HAL_SD_GetCardStatus+0xb2>
      return HAL_SD_ERROR_TIMEOUT;
   12e92:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
   12e96:	e79e      	b.n	12dd6 <HAL_SD_GetCardStatus+0x2a>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   12e98:	0710      	lsls	r0, r2, #28
   12e9a:	d455      	bmi.n	12f48 <HAL_SD_GetCardStatus+0x19c>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   12e9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12e9e:	0791      	lsls	r1, r2, #30
   12ea0:	d454      	bmi.n	12f4c <HAL_SD_GetCardStatus+0x1a0>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   12ea2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   12ea4:	0692      	lsls	r2, r2, #26
   12ea6:	d50b      	bpl.n	12ec0 <HAL_SD_GetCardStatus+0x114>
   12ea8:	e052      	b.n	12f50 <HAL_SD_GetCardStatus+0x1a4>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
   12eaa:	f002 fa83 	bl	153b4 <SDMMC_ReadFIFO>
   12eae:	f847 0b04 	str.w	r0, [r7], #4
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   12eb2:	f7f5 fac5 	bl	8440 <HAL_GetTick>
   12eb6:	eba0 0008 	sub.w	r0, r0, r8
   12eba:	3001      	adds	r0, #1
   12ebc:	d0e9      	beq.n	12e92 <HAL_SD_GetCardStatus+0xe6>
   12ebe:	6823      	ldr	r3, [r4, #0]
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
   12ec0:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    *pData = SDMMC_ReadFIFO(hsd->Instance);
   12ec2:	4618      	mov	r0, r3
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
   12ec4:	f416 5680 	ands.w	r6, r6, #4096	; 0x1000
   12ec8:	d1ef      	bne.n	12eaa <HAL_SD_GetCardStatus+0xfe>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   12eca:	9f06      	ldr	r7, [sp, #24]
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   12ecc:	f640 7e3a 	movw	lr, #3898	; 0xf3a
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   12ed0:	9808      	ldr	r0, [sp, #32]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   12ed2:	0a39      	lsrs	r1, r7, #8
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   12ed4:	f6c1 0e00 	movt	lr, #6144	; 0x1800
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   12ed8:	9a09      	ldr	r2, [sp, #36]	; 0x24
   12eda:	ea4f 4c10 	mov.w	ip, r0, lsr #16
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   12ede:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   12ee2:	f8c3 e038 	str.w	lr, [r3, #56]	; 0x38
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   12ee6:	f3c7 1e81 	ubfx	lr, r7, #6, #2
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   12eea:	f02c 0cff 	bic.w	ip, ip, #255	; 0xff
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   12eee:	ea41 6317 	orr.w	r3, r1, r7, lsr #24
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
   12ef2:	f3c7 1740 	ubfx	r7, r7, #5, #1
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   12ef6:	f885 e000 	strb.w	lr, [r5]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   12efa:	fa5f fe82 	uxtb.w	lr, r2
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   12efe:	b29b      	uxth	r3, r3
   12f00:	9907      	ldr	r1, [sp, #28]
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
   12f02:	706f      	strb	r7, [r5, #1]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   12f04:	ea4c 070e 	orr.w	r7, ip, lr
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   12f08:	806b      	strh	r3, [r5, #2]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   12f0a:	fa5f fc80 	uxtb.w	ip, r0
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
   12f0e:	f3c0 2307 	ubfx	r3, r0, #8, #8
   12f12:	ba09      	rev	r1, r1
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
   12f14:	f3c2 2e85 	ubfx	lr, r2, #10, #6
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
   12f18:	f3c0 5003 	ubfx	r0, r0, #20, #4
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
   12f1c:	6069      	str	r1, [r5, #4]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
   12f1e:	f3c2 1103 	ubfx	r1, r2, #4, #4
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   12f22:	f885 c008 	strb.w	ip, [r5, #8]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
   12f26:	f3c2 2c01 	ubfx	ip, r2, #8, #2
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
   12f2a:	726b      	strb	r3, [r5, #9]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
   12f2c:	f002 020f 	and.w	r2, r2, #15
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
   12f30:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
   12f34:	72a8      	strb	r0, [r5, #10]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   12f36:	81af      	strh	r7, [r5, #12]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
   12f38:	f885 e00e 	strb.w	lr, [r5, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
   12f3c:	f885 c00f 	strb.w	ip, [r5, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
   12f40:	7429      	strb	r1, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
   12f42:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
   12f44:	74ab      	strb	r3, [r5, #18]
   12f46:	e753      	b.n	12df0 <HAL_SD_GetCardStatus+0x44>
    return HAL_SD_ERROR_DATA_TIMEOUT;
   12f48:	2008      	movs	r0, #8
   12f4a:	e745      	b.n	12dd8 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_DATA_CRC_FAIL;
   12f4c:	2002      	movs	r0, #2
   12f4e:	e743      	b.n	12dd8 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_RX_OVERRUN;
   12f50:	2020      	movs	r0, #32
   12f52:	e741      	b.n	12dd8 <HAL_SD_GetCardStatus+0x2c>

00012f54 <HAL_SD_GetCardInfo>:
{
   12f54:	4603      	mov	r3, r0
}
   12f56:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
   12f58:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   12f5a:	600a      	str	r2, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
   12f5c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   12f5e:	604a      	str	r2, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
   12f60:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   12f62:	608a      	str	r2, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
   12f64:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   12f66:	60ca      	str	r2, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
   12f68:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   12f6a:	610a      	str	r2, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
   12f6c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   12f6e:	614a      	str	r2, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
   12f70:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   12f72:	618a      	str	r2, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
   12f74:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   12f76:	61cb      	str	r3, [r1, #28]
}
   12f78:	4770      	bx	lr
   12f7a:	bf00      	nop

00012f7c <HAL_SD_ConfigWideBusOperation>:
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   12f7c:	f431 4380 	bics.w	r3, r1, #16384	; 0x4000
{
   12f80:	b570      	push	{r4, r5, r6, lr}
   12f82:	460d      	mov	r5, r1
   12f84:	b08a      	sub	sp, #40	; 0x28
   12f86:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   12f88:	d002      	beq.n	12f90 <HAL_SD_ConfigWideBusOperation+0x14>
   12f8a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   12f8e:	d158      	bne.n	13042 <HAL_SD_ConfigWideBusOperation+0xc6>
  hsd->State = HAL_SD_STATE_BUSY;
   12f90:	2103      	movs	r1, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
   12f92:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   12f94:	6823      	ldr	r3, [r4, #0]
   12f96:	428a      	cmp	r2, r1
  hsd->State = HAL_SD_STATE_BUSY;
   12f98:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
   12f9c:	d025      	beq.n	12fea <HAL_SD_ConfigWideBusOperation+0x6e>
    if(WideMode == SDMMC_BUS_WIDE_8B)
   12f9e:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   12fa2:	d022      	beq.n	12fea <HAL_SD_ConfigWideBusOperation+0x6e>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
   12fa4:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
   12fa8:	d074      	beq.n	13094 <HAL_SD_ConfigWideBusOperation+0x118>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
   12faa:	2d00      	cmp	r5, #0
   12fac:	d052      	beq.n	13054 <HAL_SD_ConfigWideBusOperation+0xd8>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   12fae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12fb0:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
   12fb4:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
   12fb6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12fb8:	b9f2      	cbnz	r2, 12ff8 <HAL_SD_ConfigWideBusOperation+0x7c>
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   12fba:	6962      	ldr	r2, [r4, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   12fbc:	6921      	ldr	r1, [r4, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   12fbe:	2a03      	cmp	r2, #3
    Init.BusWide             = WideMode;
   12fc0:	9506      	str	r5, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   12fc2:	9107      	str	r1, [sp, #28]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
   12fc4:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
   12fc8:	e9cd 6004 	strd	r6, r0, [sp, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   12fcc:	d930      	bls.n	13030 <HAL_SD_ConfigWideBusOperation+0xb4>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
   12fce:	9208      	str	r2, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
   12fd0:	aa0a      	add	r2, sp, #40	; 0x28
   12fd2:	ae04      	add	r6, sp, #16
  HAL_StatusTypeDef status = HAL_OK;
   12fd4:	2500      	movs	r5, #0
    (void)SDMMC_Init(hsd->Instance, Init);
   12fd6:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   12fda:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   12fde:	4618      	mov	r0, r3
   12fe0:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
   12fe4:	f002 f974 	bl	152d0 <SDMMC_Init>
   12fe8:	e00c      	b.n	13004 <HAL_SD_ConfigWideBusOperation+0x88>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   12fea:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12fec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   12ff0:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
   12ff2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12ff4:	2a00      	cmp	r2, #0
   12ff6:	d0e0      	beq.n	12fba <HAL_SD_ConfigWideBusOperation+0x3e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12ff8:	f640 72ff 	movw	r2, #4095	; 0xfff
    status = HAL_ERROR;
   12ffc:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   12ffe:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
   13002:	639a      	str	r2, [r3, #56]	; 0x38
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   13004:	f44f 7100 	mov.w	r1, #512	; 0x200
   13008:	6820      	ldr	r0, [r4, #0]
   1300a:	f002 fa65 	bl	154d8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   1300e:	b148      	cbz	r0, 13024 <HAL_SD_ConfigWideBusOperation+0xa8>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   13010:	f640 73ff 	movw	r3, #4095	; 0xfff
   13014:	6822      	ldr	r2, [r4, #0]
    status = HAL_ERROR;
   13016:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   13018:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
   1301c:	6393      	str	r3, [r2, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   1301e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   13020:	4318      	orrs	r0, r3
   13022:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
   13024:	2301      	movs	r3, #1
}
   13026:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
   13028:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
   1302c:	b00a      	add	sp, #40	; 0x28
   1302e:	bd70      	pop	{r4, r5, r6, pc}
    else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
   13030:	6de1      	ldr	r1, [r4, #92]	; 0x5c
   13032:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   13036:	d0ca      	beq.n	12fce <HAL_SD_ConfigWideBusOperation+0x52>
    else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
   13038:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   1303c:	d037      	beq.n	130ae <HAL_SD_ConfigWideBusOperation+0x132>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
   1303e:	2204      	movs	r2, #4
   13040:	e7c5      	b.n	12fce <HAL_SD_ConfigWideBusOperation+0x52>
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   13042:	f643 10fc 	movw	r0, #14844	; 0x39fc
   13046:	f640 1149 	movw	r1, #2377	; 0x949
   1304a:	f2c0 0003 	movt	r0, #3
   1304e:	f008 f82f 	bl	1b0b0 <assert_failed>
   13052:	e79d      	b.n	12f90 <HAL_SD_ConfigWideBusOperation+0x14>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   13054:	4629      	mov	r1, r5
   13056:	4618      	mov	r0, r3
  uint32_t scr[2U] = {0UL, 0UL};
   13058:	e9cd 5504 	strd	r5, r5, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   1305c:	f002 f9c0 	bl	153e0 <SDMMC_GetResponse>
   13060:	0181      	lsls	r1, r0, #6
   13062:	d420      	bmi.n	130a6 <HAL_SD_ConfigWideBusOperation+0x12a>
  errorstate = SD_FindSCR(hsd, scr);
   13064:	a904      	add	r1, sp, #16
   13066:	4620      	mov	r0, r4
   13068:	f7ff f9b2 	bl	123d0 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   1306c:	b968      	cbnz	r0, 1308a <HAL_SD_ConfigWideBusOperation+0x10e>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
   1306e:	9a05      	ldr	r2, [sp, #20]
   13070:	6823      	ldr	r3, [r4, #0]
   13072:	03d2      	lsls	r2, r2, #15
   13074:	d534      	bpl.n	130e0 <HAL_SD_ConfigWideBusOperation+0x164>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   13076:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   13078:	4618      	mov	r0, r3
   1307a:	0409      	lsls	r1, r1, #16
   1307c:	f002 fcaa 	bl	159d4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   13080:	b918      	cbnz	r0, 1308a <HAL_SD_ConfigWideBusOperation+0x10e>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
   13082:	4629      	mov	r1, r5
   13084:	6820      	ldr	r0, [r4, #0]
   13086:	f002 fd23 	bl	15ad0 <SDMMC_CmdBusWidth>
   1308a:	6823      	ldr	r3, [r4, #0]
      hsd->ErrorCode |= errorstate;
   1308c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   1308e:	4310      	orrs	r0, r2
   13090:	63a0      	str	r0, [r4, #56]	; 0x38
   13092:	e7ae      	b.n	12ff2 <HAL_SD_ConfigWideBusOperation+0x76>
  uint32_t scr[2U] = {0UL, 0UL};
   13094:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   13096:	4618      	mov	r0, r3
   13098:	4611      	mov	r1, r2
  uint32_t scr[2U] = {0UL, 0UL};
   1309a:	e9cd 2204 	strd	r2, r2, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   1309e:	f002 f99f 	bl	153e0 <SDMMC_GetResponse>
   130a2:	0186      	lsls	r6, r0, #6
   130a4:	d506      	bpl.n	130b4 <HAL_SD_ConfigWideBusOperation+0x138>
   130a6:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
   130a8:	f44f 6000 	mov.w	r0, #2048	; 0x800
   130ac:	e7ee      	b.n	1308c <HAL_SD_ConfigWideBusOperation+0x110>
      Init.ClockDiv = SDMMC_HSpeed_CLK_DIV;
   130ae:	2202      	movs	r2, #2
   130b0:	9208      	str	r2, [sp, #32]
   130b2:	e78d      	b.n	12fd0 <HAL_SD_ConfigWideBusOperation+0x54>
  errorstate = SD_FindSCR(hsd, scr);
   130b4:	a904      	add	r1, sp, #16
   130b6:	4620      	mov	r0, r4
   130b8:	f7ff f98a 	bl	123d0 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   130bc:	2800      	cmp	r0, #0
   130be:	d1e4      	bne.n	1308a <HAL_SD_ConfigWideBusOperation+0x10e>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
   130c0:	9a05      	ldr	r2, [sp, #20]
   130c2:	6823      	ldr	r3, [r4, #0]
   130c4:	0350      	lsls	r0, r2, #13
   130c6:	d50b      	bpl.n	130e0 <HAL_SD_ConfigWideBusOperation+0x164>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   130c8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   130ca:	4618      	mov	r0, r3
   130cc:	0409      	lsls	r1, r1, #16
   130ce:	f002 fc81 	bl	159d4 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   130d2:	2800      	cmp	r0, #0
   130d4:	d1d9      	bne.n	1308a <HAL_SD_ConfigWideBusOperation+0x10e>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
   130d6:	2102      	movs	r1, #2
   130d8:	6820      	ldr	r0, [r4, #0]
   130da:	f002 fcf9 	bl	15ad0 <SDMMC_CmdBusWidth>
   130de:	e7d4      	b.n	1308a <HAL_SD_ConfigWideBusOperation+0x10e>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
   130e0:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   130e4:	e7d2      	b.n	1308c <HAL_SD_ConfigWideBusOperation+0x110>
   130e6:	bf00      	nop

000130e8 <HAL_SD_Init>:
{
   130e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   130ea:	b087      	sub	sp, #28
  if(hsd == NULL)
   130ec:	2800      	cmp	r0, #0
   130ee:	d042      	beq.n	13176 <HAL_SD_Init+0x8e>
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));
   130f0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
   130f4:	6802      	ldr	r2, [r0, #0]
   130f6:	4604      	mov	r4, r0
   130f8:	f2c5 2300 	movt	r3, #20992	; 0x5200
   130fc:	429a      	cmp	r2, r3
   130fe:	d00d      	beq.n	1311c <HAL_SD_Init+0x34>
   13100:	f44f 5310 	mov.w	r3, #9216	; 0x2400
   13104:	f6c4 0302 	movt	r3, #18434	; 0x4802
   13108:	429a      	cmp	r2, r3
   1310a:	d007      	beq.n	1311c <HAL_SD_Init+0x34>
   1310c:	f643 10fc 	movw	r0, #14844	; 0x39fc
   13110:	f240 115b 	movw	r1, #347	; 0x15b
   13114:	f2c0 0003 	movt	r0, #3
   13118:	f007 ffca 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
   1311c:	6863      	ldr	r3, [r4, #4]
   1311e:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
   13122:	f040 8081 	bne.w	13228 <HAL_SD_Init+0x140>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   13126:	68a3      	ldr	r3, [r4, #8]
   13128:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   1312c:	d16f      	bne.n	1320e <HAL_SD_Init+0x126>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   1312e:	68e3      	ldr	r3, [r4, #12]
   13130:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
   13134:	d003      	beq.n	1313e <HAL_SD_Init+0x56>
   13136:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1313a:	f040 8091 	bne.w	13260 <HAL_SD_Init+0x178>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   1313e:	6923      	ldr	r3, [r4, #16]
   13140:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   13144:	d17e      	bne.n	13244 <HAL_SD_Init+0x15c>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   13146:	6963      	ldr	r3, [r4, #20]
   13148:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1314c:	d250      	bcs.n	131f0 <HAL_SD_Init+0x108>
  if(hsd->State == HAL_SD_STATE_RESET)
   1314e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   13152:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   13156:	b93b      	cbnz	r3, 13168 <HAL_SD_Init+0x80>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
   13158:	69a3      	ldr	r3, [r4, #24]
    hsd->Lock = HAL_UNLOCKED;
   1315a:	7722      	strb	r2, [r4, #28]
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
   1315c:	b90b      	cbnz	r3, 13162 <HAL_SD_Init+0x7a>
      hsd->Init.TranceiverPresent = SDMMC_TRANSCEIVER_PRESENT;
   1315e:	2302      	movs	r3, #2
   13160:	61a3      	str	r3, [r4, #24]
    HAL_SD_MspInit(hsd);
   13162:	4620      	mov	r0, r4
   13164:	f008 ff84 	bl	1c070 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
   13168:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
   1316a:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
   1316c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
   13170:	f7ff fca4 	bl	12abc <HAL_SD_InitCard>
   13174:	b118      	cbz	r0, 1317e <HAL_SD_Init+0x96>
    return HAL_ERROR;
   13176:	2501      	movs	r5, #1
}
   13178:	4628      	mov	r0, r5
   1317a:	b007      	add	sp, #28
   1317c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
   1317e:	a901      	add	r1, sp, #4
   13180:	4620      	mov	r0, r4
   13182:	f7ff fe13 	bl	12dac <HAL_SD_GetCardStatus>
   13186:	2800      	cmp	r0, #0
   13188:	d1f5      	bne.n	13176 <HAL_SD_Init+0x8e>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   1318a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  speedgrade = CardStatus.UhsSpeedGrade;
   1318c:	f89d 2014 	ldrb.w	r2, [sp, #20]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   13190:	2901      	cmp	r1, #1
  unitsize = CardStatus.UhsAllocationUnitSize;
   13192:	f89d 3015 	ldrb.w	r3, [sp, #21]
  speedgrade = CardStatus.UhsSpeedGrade;
   13196:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
   13198:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   1319a:	d06f      	beq.n	1327c <HAL_SD_Init+0x194>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
   1319c:	65e0      	str	r0, [r4, #92]	; 0x5c
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
   1319e:	68e1      	ldr	r1, [r4, #12]
   131a0:	4620      	mov	r0, r4
   131a2:	f7ff feeb 	bl	12f7c <HAL_SD_ConfigWideBusOperation>
   131a6:	4605      	mov	r5, r0
   131a8:	2800      	cmp	r0, #0
   131aa:	d1e4      	bne.n	13176 <HAL_SD_Init+0x8e>
  tickstart = HAL_GetTick();
   131ac:	f7f5 f948 	bl	8440 <HAL_GetTick>
   131b0:	4607      	mov	r7, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
   131b2:	e007      	b.n	131c4 <HAL_SD_Init+0xdc>
    hsd->ErrorCode |= errorstate;
   131b4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   131b6:	431e      	orrs	r6, r3
   131b8:	63a6      	str	r6, [r4, #56]	; 0x38
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
   131ba:	f7f5 f941 	bl	8440 <HAL_GetTick>
   131be:	1bc0      	subs	r0, r0, r7
   131c0:	3001      	adds	r0, #1
   131c2:	d063      	beq.n	1328c <HAL_SD_Init+0x1a4>
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   131c4:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   131c6:	6820      	ldr	r0, [r4, #0]
   131c8:	0409      	lsls	r1, r1, #16
   131ca:	f002 fddf 	bl	15d8c <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
   131ce:	4606      	mov	r6, r0
   131d0:	2800      	cmp	r0, #0
   131d2:	d1ef      	bne.n	131b4 <HAL_SD_Init+0xcc>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   131d4:	4601      	mov	r1, r0
   131d6:	6820      	ldr	r0, [r4, #0]
   131d8:	f002 f902 	bl	153e0 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
   131dc:	f3c0 2043 	ubfx	r0, r0, #9, #4
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
   131e0:	2804      	cmp	r0, #4
   131e2:	d1ea      	bne.n	131ba <HAL_SD_Init+0xd2>
  hsd->State = HAL_SD_STATE_READY;
   131e4:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
   131e6:	63a6      	str	r6, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
   131e8:	6326      	str	r6, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
   131ea:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
   131ee:	e7c3      	b.n	13178 <HAL_SD_Init+0x90>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   131f0:	f643 10fc 	movw	r0, #14844	; 0x39fc
   131f4:	f44f 71b0 	mov.w	r1, #352	; 0x160
   131f8:	f2c0 0003 	movt	r0, #3
   131fc:	f007 ff58 	bl	1b0b0 <assert_failed>
  if(hsd->State == HAL_SD_STATE_RESET)
   13200:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   13204:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   13208:	2b00      	cmp	r3, #0
   1320a:	d1ad      	bne.n	13168 <HAL_SD_Init+0x80>
   1320c:	e7a4      	b.n	13158 <HAL_SD_Init+0x70>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   1320e:	f643 10fc 	movw	r0, #14844	; 0x39fc
   13212:	f240 115d 	movw	r1, #349	; 0x15d
   13216:	f2c0 0003 	movt	r0, #3
   1321a:	f007 ff49 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   1321e:	68e3      	ldr	r3, [r4, #12]
   13220:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
   13224:	d187      	bne.n	13136 <HAL_SD_Init+0x4e>
   13226:	e78a      	b.n	1313e <HAL_SD_Init+0x56>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
   13228:	f643 10fc 	movw	r0, #14844	; 0x39fc
   1322c:	f44f 71ae 	mov.w	r1, #348	; 0x15c
   13230:	f2c0 0003 	movt	r0, #3
   13234:	f007 ff3c 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   13238:	68a3      	ldr	r3, [r4, #8]
   1323a:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   1323e:	f43f af76 	beq.w	1312e <HAL_SD_Init+0x46>
   13242:	e7e4      	b.n	1320e <HAL_SD_Init+0x126>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   13244:	f643 10fc 	movw	r0, #14844	; 0x39fc
   13248:	f240 115f 	movw	r1, #351	; 0x15f
   1324c:	f2c0 0003 	movt	r0, #3
   13250:	f007 ff2e 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   13254:	6963      	ldr	r3, [r4, #20]
   13256:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1325a:	f4ff af78 	bcc.w	1314e <HAL_SD_Init+0x66>
   1325e:	e7c7      	b.n	131f0 <HAL_SD_Init+0x108>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   13260:	f643 10fc 	movw	r0, #14844	; 0x39fc
   13264:	f44f 71af 	mov.w	r1, #350	; 0x15e
   13268:	f2c0 0003 	movt	r0, #3
   1326c:	f007 ff20 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   13270:	6923      	ldr	r3, [r4, #16]
   13272:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   13276:	f43f af66 	beq.w	13146 <HAL_SD_Init+0x5e>
   1327a:	e7e3      	b.n	13244 <HAL_SD_Init+0x15c>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   1327c:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
   1327e:	bf14      	ite	ne
   13280:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
   13284:	f44f 7380 	moveq.w	r3, #256	; 0x100
   13288:	65e3      	str	r3, [r4, #92]	; 0x5c
   1328a:	e788      	b.n	1319e <HAL_SD_Init+0xb6>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
   1328c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
      hsd->State= HAL_SD_STATE_READY;
   13290:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
   13292:	2503      	movs	r5, #3
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
   13294:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
   13296:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
   1329a:	e76d      	b.n	13178 <HAL_SD_Init+0x90>

0001329c <HAL_SD_GetCardState>:
{
   1329c:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   1329e:	6c81      	ldr	r1, [r0, #72]	; 0x48
{
   132a0:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   132a2:	6800      	ldr	r0, [r0, #0]
   132a4:	0409      	lsls	r1, r1, #16
   132a6:	f002 fd71 	bl	15d8c <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
   132aa:	4601      	mov	r1, r0
   132ac:	b120      	cbz	r0, 132b8 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
   132ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   132b0:	2000      	movs	r0, #0
   132b2:	4319      	orrs	r1, r3
   132b4:	63a1      	str	r1, [r4, #56]	; 0x38
}
   132b6:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   132b8:	6820      	ldr	r0, [r4, #0]
   132ba:	f002 f891 	bl	153e0 <SDMMC_GetResponse>
   132be:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
   132c2:	bd10      	pop	{r4, pc}

000132c4 <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
   132c4:	b328      	cbz	r0, 13312 <HAL_SDRAM_Init+0x4e>
{
   132c6:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
   132c8:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   132cc:	4604      	mov	r4, r0
   132ce:	460d      	mov	r5, r1
   132d0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   132d4:	b1c3      	cbz	r3, 13308 <HAL_SDRAM_Init+0x44>
    HAL_SDRAM_MspInit(hsdram);
#endif
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
   132d6:	2302      	movs	r3, #2

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   132d8:	1d21      	adds	r1, r4, #4
   132da:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
   132dc:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   132e0:	f001 fd64 	bl	14dac <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
   132e4:	4629      	mov	r1, r5
   132e6:	e9d4 0200 	ldrd	r0, r2, [r4]
   132ea:	f001 fe49 	bl	14f80 <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
   132ee:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
   132f2:	2101      	movs	r1, #1

  return HAL_OK;
   132f4:	2000      	movs	r0, #0
  __FMC_ENABLE();
   132f6:	f2c5 2300 	movt	r3, #20992	; 0x5200
   132fa:	681a      	ldr	r2, [r3, #0]
   132fc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   13300:	601a      	str	r2, [r3, #0]
  hsdram->State = HAL_SDRAM_STATE_READY;
   13302:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
}
   13306:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
   13308:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
   1330c:	f006 faa2 	bl	19854 <HAL_SDRAM_MspInit>
   13310:	e7e1      	b.n	132d6 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
   13312:	2001      	movs	r0, #1
}
   13314:	4770      	bx	lr
   13316:	bf00      	nop

00013318 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  HAL_SDRAM_StateTypeDef state = hsdram->State;
   13318:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   1331c:	b2db      	uxtb	r3, r3
  
  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
   1331e:	2b02      	cmp	r3, #2
   13320:	d015      	beq.n	1334e <HAL_SDRAM_SendCommand+0x36>
{
   13322:	b570      	push	{r4, r5, r6, lr}
  {
    return HAL_BUSY;
  }
  else if((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
   13324:	f003 04fb 	and.w	r4, r3, #251	; 0xfb
   13328:	2c01      	cmp	r4, #1
   1332a:	d001      	beq.n	13330 <HAL_SDRAM_SendCommand+0x18>
      hsdram->State = HAL_SDRAM_STATE_READY;
    }
  }
  else
  {
    return HAL_ERROR;
   1332c:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
   1332e:	bd70      	pop	{r4, r5, r6, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   13330:	2302      	movs	r3, #2
   13332:	4605      	mov	r5, r0
   13334:	460e      	mov	r6, r1
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   13336:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   13338:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   1333c:	f001 fee4 	bl	15108 <FMC_SDRAM_SendCommand>
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
   13340:	6833      	ldr	r3, [r6, #0]
   13342:	2b02      	cmp	r3, #2
   13344:	d005      	beq.n	13352 <HAL_SDRAM_SendCommand+0x3a>
      hsdram->State = HAL_SDRAM_STATE_READY;
   13346:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  return HAL_OK;
   1334a:	2000      	movs	r0, #0
}
   1334c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
   1334e:	4618      	mov	r0, r3
}
   13350:	4770      	bx	lr
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   13352:	2305      	movs	r3, #5
  return HAL_OK;
   13354:	2000      	movs	r0, #0
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   13356:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
}
   1335a:	bd70      	pop	{r4, r5, r6, pc}

0001335c <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
   1335c:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
   1335e:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   13362:	b2db      	uxtb	r3, r3
   13364:	2b02      	cmp	r3, #2
   13366:	d006      	beq.n	13376 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
   13368:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
   1336c:	b2ed      	uxtb	r5, r5
   1336e:	2d01      	cmp	r5, #1
   13370:	d003      	beq.n	1337a <HAL_SDRAM_ProgramRefreshRate+0x1e>
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  else
  {
    return HAL_ERROR;
   13372:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
   13374:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
   13376:	4618      	mov	r0, r3
}
   13378:	bd38      	pop	{r3, r4, r5, pc}
   1337a:	4604      	mov	r4, r0
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   1337c:	2302      	movs	r3, #2
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
   1337e:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   13380:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
   13384:	f001 ff18 	bl	151b8 <FMC_SDRAM_ProgramRefreshRate>
    hsdram->State = HAL_SDRAM_STATE_READY;
   13388:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
  return HAL_OK;
   1338c:	2000      	movs	r0, #0
}
   1338e:	bd38      	pop	{r3, r4, r5, pc}

00013390 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
   13390:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
   13394:	6a02      	ldr	r2, [r0, #32]
{
   13396:	460f      	mov	r7, r1
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   13398:	f64f 738c 	movw	r3, #65420	; 0xff8c
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   1339c:	2100      	movs	r1, #0
  TIMx->CCER &= ~TIM_CCER_CC1E;
   1339e:	f022 0201 	bic.w	r2, r2, #1
{
   133a2:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   133a4:	f6cf 73fe 	movt	r3, #65534	; 0xfffe
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   133a8:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC1E;
   133ac:	6202      	str	r2, [r0, #32]
  tmpccer = TIMx->CCER;
   133ae:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   133b0:	428c      	cmp	r4, r1
  tmpcr2 =  TIMx->CR2;
   133b2:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
   133b6:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC1P;
   133b8:	f025 0502 	bic.w	r5, r5, #2
  tmpccer |= OC_Config->OCPolarity;
   133bc:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   133be:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= OC_Config->OCMode;
   133c2:	683e      	ldr	r6, [r7, #0]
  tmpccer |= OC_Config->OCPolarity;
   133c4:	ea45 0502 	orr.w	r5, r5, r2
  tmpccmrx |= OC_Config->OCMode;
   133c8:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   133cc:	d055      	beq.n	1347a <TIM_OC1_SetConfig+0xea>
   133ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
   133d2:	f2c4 0301 	movt	r3, #16385	; 0x4001
   133d6:	429c      	cmp	r4, r3
   133d8:	d04f      	beq.n	1347a <TIM_OC1_SetConfig+0xea>
   133da:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   133de:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   133e2:	f2c4 0201 	movt	r2, #16385	; 0x4001
   133e6:	f2c4 0301 	movt	r3, #16385	; 0x4001
   133ea:	429c      	cmp	r4, r3
   133ec:	bf18      	it	ne
   133ee:	4294      	cmpne	r4, r2
   133f0:	d005      	beq.n	133fe <TIM_OC1_SetConfig+0x6e>
   133f2:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   133f6:	f2c4 0301 	movt	r3, #16385	; 0x4001
   133fa:	429c      	cmp	r4, r3
   133fc:	d155      	bne.n	134aa <TIM_OC1_SetConfig+0x11a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   133fe:	68fb      	ldr	r3, [r7, #12]
   13400:	f025 0508 	bic.w	r5, r5, #8
   13404:	f033 0208 	bics.w	r2, r3, #8
   13408:	d03d      	beq.n	13486 <TIM_OC1_SetConfig+0xf6>
   1340a:	f643 2034 	movw	r0, #14900	; 0x3a34
   1340e:	f641 0106 	movw	r1, #6150	; 0x1806
   13412:	f2c0 0003 	movt	r0, #3
   13416:	f007 fe4b 	bl	1b0b0 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1341a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1341e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    tmpccer |= OC_Config->OCNPolarity;
   13422:	68f9      	ldr	r1, [r7, #12]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13424:	f2c4 0201 	movt	r2, #16385	; 0x4001
   13428:	f2c4 0301 	movt	r3, #16385	; 0x4001
    tmpccer |= OC_Config->OCNPolarity;
   1342c:	430d      	orrs	r5, r1
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1342e:	429c      	cmp	r4, r3
   13430:	bf18      	it	ne
   13432:	4294      	cmpne	r4, r2
    tmpccer &= ~TIM_CCER_CC1NE;
   13434:	f025 0504 	bic.w	r5, r5, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13438:	d028      	beq.n	1348c <TIM_OC1_SetConfig+0xfc>
   1343a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   1343e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13442:	429c      	cmp	r4, r3
   13444:	d131      	bne.n	134aa <TIM_OC1_SetConfig+0x11a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   13446:	69bb      	ldr	r3, [r7, #24]
   13448:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1344c:	d022      	beq.n	13494 <TIM_OC1_SetConfig+0x104>
   1344e:	f643 2034 	movw	r0, #14900	; 0x3a34
   13452:	f641 0113 	movw	r1, #6163	; 0x1813
   13456:	f2c0 0003 	movt	r0, #3
   1345a:	f007 fe29 	bl	1b0b0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1345e:	697b      	ldr	r3, [r7, #20]
   13460:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   13464:	d01a      	beq.n	1349c <TIM_OC1_SetConfig+0x10c>
   13466:	f643 2034 	movw	r0, #14900	; 0x3a34
   1346a:	f641 0114 	movw	r1, #6164	; 0x1814
   1346e:	f2c0 0003 	movt	r0, #3
   13472:	f007 fe1d 	bl	1b0b0 <assert_failed>
   13476:	697b      	ldr	r3, [r7, #20]
   13478:	e010      	b.n	1349c <TIM_OC1_SetConfig+0x10c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   1347a:	68fb      	ldr	r3, [r7, #12]
   1347c:	f025 0508 	bic.w	r5, r5, #8
   13480:	f033 0208 	bics.w	r2, r3, #8
   13484:	d119      	bne.n	134ba <TIM_OC1_SetConfig+0x12a>
    tmpccer |= OC_Config->OCNPolarity;
   13486:	431d      	orrs	r5, r3
    tmpccer &= ~TIM_CCER_CC1NE;
   13488:	f025 0504 	bic.w	r5, r5, #4
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   1348c:	69bb      	ldr	r3, [r7, #24]
   1348e:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   13492:	d1dc      	bne.n	1344e <TIM_OC1_SetConfig+0xbe>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   13494:	697b      	ldr	r3, [r7, #20]
   13496:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   1349a:	d1e4      	bne.n	13466 <TIM_OC1_SetConfig+0xd6>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
   1349c:	f428 7840 	bic.w	r8, r8, #768	; 0x300
   134a0:	69ba      	ldr	r2, [r7, #24]
   134a2:	ea48 0802 	orr.w	r8, r8, r2
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
   134a6:	ea48 0803 	orr.w	r8, r8, r3
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
   134aa:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
   134ae:	61a6      	str	r6, [r4, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
   134b0:	687b      	ldr	r3, [r7, #4]
   134b2:	6363      	str	r3, [r4, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
   134b4:	6225      	str	r5, [r4, #32]
}
   134b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   134ba:	f643 2034 	movw	r0, #14900	; 0x3a34
   134be:	f641 0106 	movw	r1, #6150	; 0x1806
   134c2:	f2c0 0003 	movt	r0, #3
   134c6:	f007 fdf3 	bl	1b0b0 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
   134ca:	68fb      	ldr	r3, [r7, #12]
   134cc:	e7db      	b.n	13486 <TIM_OC1_SetConfig+0xf6>
   134ce:	bf00      	nop

000134d0 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
   134d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
   134d4:	6a03      	ldr	r3, [r0, #32]
{
   134d6:	460f      	mov	r7, r1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   134d8:	2100      	movs	r1, #0
{
   134da:	4604      	mov	r4, r0
  TIMx->CCER &= ~TIM_CCER_CC3E;
   134dc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   134e0:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC3E;
   134e4:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
   134e6:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   134e8:	4288      	cmp	r0, r1
  tmpcr2 =  TIMx->CR2;
   134ea:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
   134ee:	69c6      	ldr	r6, [r0, #28]
  tmpccer &= ~TIM_CCER_CC3P;
   134f0:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
   134f4:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
   134f6:	f026 0673 	bic.w	r6, r6, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
   134fa:	683b      	ldr	r3, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
   134fc:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccmrx |= OC_Config->OCMode;
   13500:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   13504:	d02e      	beq.n	13564 <TIM_OC3_SetConfig+0x94>
   13506:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1350a:	f2c4 0301 	movt	r3, #16385	; 0x4001
   1350e:	4298      	cmp	r0, r3
   13510:	d028      	beq.n	13564 <TIM_OC3_SetConfig+0x94>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13512:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   13516:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   1351a:	f2c4 0201 	movt	r2, #16385	; 0x4001
   1351e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13522:	4298      	cmp	r0, r3
   13524:	bf18      	it	ne
   13526:	4290      	cmpne	r0, r2
   13528:	d005      	beq.n	13536 <TIM_OC3_SetConfig+0x66>
   1352a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   1352e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13532:	4298      	cmp	r0, r3
   13534:	d10e      	bne.n	13554 <TIM_OC3_SetConfig+0x84>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   13536:	69bb      	ldr	r3, [r7, #24]
   13538:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1353c:	d120      	bne.n	13580 <TIM_OC3_SetConfig+0xb0>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1353e:	697b      	ldr	r3, [r7, #20]
   13540:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   13544:	d128      	bne.n	13598 <TIM_OC3_SetConfig+0xc8>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
   13546:	f428 5840 	bic.w	r8, r8, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   1354a:	69ba      	ldr	r2, [r7, #24]
   1354c:	ea48 1802 	orr.w	r8, r8, r2, lsl #4
   13550:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
   13554:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
   13558:	61e6      	str	r6, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
   1355a:	687b      	ldr	r3, [r7, #4]
   1355c:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
   1355e:	6225      	str	r5, [r4, #32]
}
   13560:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   13564:	68fb      	ldr	r3, [r7, #12]
   13566:	f033 0208 	bics.w	r2, r3, #8
   1356a:	d11f      	bne.n	135ac <TIM_OC3_SetConfig+0xdc>
    tmpccer &= ~TIM_CCER_CC3NP;
   1356c:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
   13570:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
   13574:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   13578:	69bb      	ldr	r3, [r7, #24]
   1357a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1357e:	d0de      	beq.n	1353e <TIM_OC3_SetConfig+0x6e>
   13580:	f643 2034 	movw	r0, #14900	; 0x3a34
   13584:	f641 01a9 	movw	r1, #6313	; 0x18a9
   13588:	f2c0 0003 	movt	r0, #3
   1358c:	f007 fd90 	bl	1b0b0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   13590:	697b      	ldr	r3, [r7, #20]
   13592:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   13596:	d0d6      	beq.n	13546 <TIM_OC3_SetConfig+0x76>
   13598:	f643 2034 	movw	r0, #14900	; 0x3a34
   1359c:	f641 01aa 	movw	r1, #6314	; 0x18aa
   135a0:	f2c0 0003 	movt	r0, #3
   135a4:	f007 fd84 	bl	1b0b0 <assert_failed>
   135a8:	697b      	ldr	r3, [r7, #20]
   135aa:	e7cc      	b.n	13546 <TIM_OC3_SetConfig+0x76>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   135ac:	f643 2034 	movw	r0, #14900	; 0x3a34
   135b0:	f641 019c 	movw	r1, #6300	; 0x189c
    tmpccer &= ~TIM_CCER_CC3NP;
   135b4:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   135b8:	f2c0 0003 	movt	r0, #3
   135bc:	f007 fd78 	bl	1b0b0 <assert_failed>
   135c0:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
   135c2:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
   135c6:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
   135ca:	e7d5      	b.n	13578 <TIM_OC3_SetConfig+0xa8>

000135cc <HAL_TIM_Base_Init>:
  if (htim == NULL)
   135cc:	2800      	cmp	r0, #0
   135ce:	f000 811c 	beq.w	1380a <HAL_TIM_Base_Init+0x23e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   135d2:	2300      	movs	r3, #0
   135d4:	f44f 6100 	mov.w	r1, #2048	; 0x800
   135d8:	f2c4 0301 	movt	r3, #16385	; 0x4001
   135dc:	f2c4 0100 	movt	r1, #16384	; 0x4000
{
   135e0:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   135e2:	6802      	ldr	r2, [r0, #0]
   135e4:	4604      	mov	r4, r0
   135e6:	f44f 6080 	mov.w	r0, #1024	; 0x400
   135ea:	f44f 6540 	mov.w	r5, #3072	; 0xc00
   135ee:	429a      	cmp	r2, r3
   135f0:	bf18      	it	ne
   135f2:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   135f6:	f2c4 0000 	movt	r0, #16384	; 0x4000
   135fa:	f2c4 0500 	movt	r5, #16384	; 0x4000
   135fe:	bf14      	ite	ne
   13600:	2301      	movne	r3, #1
   13602:	2300      	moveq	r3, #0
   13604:	4282      	cmp	r2, r0
   13606:	bf0c      	ite	eq
   13608:	2300      	moveq	r3, #0
   1360a:	f003 0301 	andne.w	r3, r3, #1
   1360e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   13612:	428a      	cmp	r2, r1
   13614:	bf0c      	ite	eq
   13616:	2300      	moveq	r3, #0
   13618:	f003 0301 	andne.w	r3, r3, #1
   1361c:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13620:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
   13624:	42aa      	cmp	r2, r5
   13626:	bf0c      	ite	eq
   13628:	2300      	moveq	r3, #0
   1362a:	f003 0301 	andne.w	r3, r3, #1
   1362e:	f44f 6580 	mov.w	r5, #1024	; 0x400
   13632:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13636:	4282      	cmp	r2, r0
   13638:	bf0c      	ite	eq
   1363a:	2300      	moveq	r3, #0
   1363c:	f003 0301 	andne.w	r3, r3, #1
   13640:	f2c4 0501 	movt	r5, #16385	; 0x4001
   13644:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
   13648:	428a      	cmp	r2, r1
   1364a:	bf0c      	ite	eq
   1364c:	2300      	moveq	r3, #0
   1364e:	f003 0301 	andne.w	r3, r3, #1
   13652:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
   13656:	f2c4 0000 	movt	r0, #16384	; 0x4000
   1365a:	42aa      	cmp	r2, r5
   1365c:	bf0c      	ite	eq
   1365e:	2300      	moveq	r3, #0
   13660:	f003 0301 	andne.w	r3, r3, #1
   13664:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13668:	f44f 5500 	mov.w	r5, #8192	; 0x2000
   1366c:	4282      	cmp	r2, r0
   1366e:	bf0c      	ite	eq
   13670:	2300      	moveq	r3, #0
   13672:	f003 0301 	andne.w	r3, r3, #1
   13676:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   1367a:	f2c4 0500 	movt	r5, #16384	; 0x4000
   1367e:	428a      	cmp	r2, r1
   13680:	bf0c      	ite	eq
   13682:	2300      	moveq	r3, #0
   13684:	f003 0301 	andne.w	r3, r3, #1
   13688:	f2c4 0001 	movt	r0, #16385	; 0x4001
   1368c:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   13690:	42aa      	cmp	r2, r5
   13692:	bf0c      	ite	eq
   13694:	2300      	moveq	r3, #0
   13696:	f003 0301 	andne.w	r3, r3, #1
   1369a:	f2c4 0101 	movt	r1, #16385	; 0x4001
   1369e:	4282      	cmp	r2, r0
   136a0:	bf0c      	ite	eq
   136a2:	2300      	moveq	r3, #0
   136a4:	f003 0301 	andne.w	r3, r3, #1
   136a8:	428a      	cmp	r2, r1
   136aa:	bf0c      	ite	eq
   136ac:	2300      	moveq	r3, #0
   136ae:	f003 0301 	andne.w	r3, r3, #1
   136b2:	b133      	cbz	r3, 136c2 <HAL_TIM_Base_Init+0xf6>
   136b4:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   136b8:	f2c4 0301 	movt	r3, #16385	; 0x4001
   136bc:	429a      	cmp	r2, r3
   136be:	f040 80ca 	bne.w	13856 <HAL_TIM_Base_Init+0x28a>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   136c2:	68a3      	ldr	r3, [r4, #8]
   136c4:	f023 0140 	bic.w	r1, r3, #64	; 0x40
   136c8:	f023 0210 	bic.w	r2, r3, #16
   136cc:	2920      	cmp	r1, #32
   136ce:	bf18      	it	ne
   136d0:	2a00      	cmpne	r2, #0
   136d2:	d002      	beq.n	136da <HAL_TIM_Base_Init+0x10e>
   136d4:	2b40      	cmp	r3, #64	; 0x40
   136d6:	f040 80a8 	bne.w	1382a <HAL_TIM_Base_Init+0x25e>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   136da:	6923      	ldr	r3, [r4, #16]
   136dc:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   136e0:	d003      	beq.n	136ea <HAL_TIM_Base_Init+0x11e>
   136e2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   136e6:	f040 8092 	bne.w	1380e <HAL_TIM_Base_Init+0x242>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   136ea:	69a3      	ldr	r3, [r4, #24]
   136ec:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   136f0:	d17b      	bne.n	137ea <HAL_TIM_Base_Init+0x21e>
  if (htim->State == HAL_TIM_STATE_RESET)
   136f2:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   136f6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   136fa:	2b00      	cmp	r3, #0
   136fc:	d06f      	beq.n	137de <HAL_TIM_Base_Init+0x212>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   136fe:	2100      	movs	r1, #0
   13700:	f44f 6380 	mov.w	r3, #1024	; 0x400
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
   13704:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
   13706:	2002      	movs	r0, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   13708:	f2c4 0101 	movt	r1, #16385	; 0x4001
   1370c:	f2c4 0301 	movt	r3, #16385	; 0x4001
  htim->State = HAL_TIM_STATE_BUSY;
   13710:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   13714:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   13718:	eba2 0001 	sub.w	r0, r2, r1
   1371c:	eba2 0103 	sub.w	r1, r2, r3
  tmpcr1 = TIMx->CR1;
   13720:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   13722:	fab0 f080 	clz	r0, r0
   13726:	fab1 f181 	clz	r1, r1
   1372a:	ea4f 1050 	mov.w	r0, r0, lsr #5
   1372e:	ea4f 1151 	mov.w	r1, r1, lsr #5
   13732:	d027      	beq.n	13784 <HAL_TIM_Base_Init+0x1b8>
   13734:	bb30      	cbnz	r0, 13784 <HAL_TIM_Base_Init+0x1b8>
   13736:	f44f 6580 	mov.w	r5, #1024	; 0x400
   1373a:	f2c4 0500 	movt	r5, #16384	; 0x4000
   1373e:	42aa      	cmp	r2, r5
   13740:	d020      	beq.n	13784 <HAL_TIM_Base_Init+0x1b8>
   13742:	f44f 6500 	mov.w	r5, #2048	; 0x800
   13746:	f2c4 0500 	movt	r5, #16384	; 0x4000
   1374a:	42aa      	cmp	r2, r5
   1374c:	d01a      	beq.n	13784 <HAL_TIM_Base_Init+0x1b8>
   1374e:	f44f 6540 	mov.w	r5, #3072	; 0xc00
   13752:	f2c4 0500 	movt	r5, #16384	; 0x4000
   13756:	42aa      	cmp	r2, r5
   13758:	d070      	beq.n	1383c <HAL_TIM_Base_Init+0x270>
   1375a:	2900      	cmp	r1, #0
   1375c:	d16e      	bne.n	1383c <HAL_TIM_Base_Init+0x270>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   1375e:	f44f 4680 	mov.w	r6, #16384	; 0x4000
   13762:	f44f 4588 	mov.w	r5, #17408	; 0x4400
   13766:	f2c4 0601 	movt	r6, #16385	; 0x4001
   1376a:	f2c4 0501 	movt	r5, #16385	; 0x4001
   1376e:	42aa      	cmp	r2, r5
   13770:	bf18      	it	ne
   13772:	42b2      	cmpne	r2, r6
   13774:	d00a      	beq.n	1378c <HAL_TIM_Base_Init+0x1c0>
   13776:	f44f 4590 	mov.w	r5, #18432	; 0x4800
   1377a:	f2c4 0501 	movt	r5, #16385	; 0x4001
   1377e:	42aa      	cmp	r2, r5
   13780:	d108      	bne.n	13794 <HAL_TIM_Base_Init+0x1c8>
   13782:	e003      	b.n	1378c <HAL_TIM_Base_Init+0x1c0>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   13784:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   13788:	68a5      	ldr	r5, [r4, #8]
   1378a:	432b      	orrs	r3, r5
    tmpcr1 &= ~TIM_CR1_CKD;
   1378c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
   13790:	6925      	ldr	r5, [r4, #16]
   13792:	432b      	orrs	r3, r5
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   13794:	69a5      	ldr	r5, [r4, #24]
   13796:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1379a:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
   1379c:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
   1379e:	68e3      	ldr	r3, [r4, #12]
   137a0:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
   137a2:	6863      	ldr	r3, [r4, #4]
   137a4:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   137a6:	b990      	cbnz	r0, 137ce <HAL_TIM_Base_Init+0x202>
   137a8:	b989      	cbnz	r1, 137ce <HAL_TIM_Base_Init+0x202>
   137aa:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   137ae:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   137b2:	f2c4 0101 	movt	r1, #16385	; 0x4001
   137b6:	f2c4 0301 	movt	r3, #16385	; 0x4001
   137ba:	429a      	cmp	r2, r3
   137bc:	bf18      	it	ne
   137be:	428a      	cmpne	r2, r1
   137c0:	d005      	beq.n	137ce <HAL_TIM_Base_Init+0x202>
   137c2:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   137c6:	f2c4 0301 	movt	r3, #16385	; 0x4001
   137ca:	429a      	cmp	r2, r3
   137cc:	d101      	bne.n	137d2 <HAL_TIM_Base_Init+0x206>
    TIMx->RCR = Structure->RepetitionCounter;
   137ce:	6963      	ldr	r3, [r4, #20]
   137d0:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
   137d2:	2301      	movs	r3, #1
  return HAL_OK;
   137d4:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
   137d6:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
   137d8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
   137dc:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
   137de:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
   137e2:	4620      	mov	r0, r4
   137e4:	f011 fa44 	bl	24c70 <HAL_TIM_Base_MspInit>
   137e8:	e789      	b.n	136fe <HAL_TIM_Base_Init+0x132>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   137ea:	f643 2034 	movw	r0, #14900	; 0x3a34
   137ee:	f44f 718c 	mov.w	r1, #280	; 0x118
   137f2:	f2c0 0003 	movt	r0, #3
   137f6:	f007 fc5b 	bl	1b0b0 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
   137fa:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   137fe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   13802:	2b00      	cmp	r3, #0
   13804:	f47f af7b 	bne.w	136fe <HAL_TIM_Base_Init+0x132>
   13808:	e7e9      	b.n	137de <HAL_TIM_Base_Init+0x212>
    return HAL_ERROR;
   1380a:	2001      	movs	r0, #1
}
   1380c:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1380e:	f643 2034 	movw	r0, #14900	; 0x3a34
   13812:	f240 1117 	movw	r1, #279	; 0x117
   13816:	f2c0 0003 	movt	r0, #3
   1381a:	f007 fc49 	bl	1b0b0 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1381e:	69a3      	ldr	r3, [r4, #24]
   13820:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   13824:	f43f af65 	beq.w	136f2 <HAL_TIM_Base_Init+0x126>
   13828:	e7df      	b.n	137ea <HAL_TIM_Base_Init+0x21e>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1382a:	f643 2034 	movw	r0, #14900	; 0x3a34
   1382e:	f44f 718b 	mov.w	r1, #278	; 0x116
   13832:	f2c0 0003 	movt	r0, #3
   13836:	f007 fc3b 	bl	1b0b0 <assert_failed>
   1383a:	e74e      	b.n	136da <HAL_TIM_Base_Init+0x10e>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   1383c:	f44f 6540 	mov.w	r5, #3072	; 0xc00
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   13840:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   13844:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   13846:	f2c4 0500 	movt	r5, #16384	; 0x4000
    tmpcr1 |= Structure->CounterMode;
   1384a:	4333      	orrs	r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   1384c:	42aa      	cmp	r2, r5
   1384e:	d09d      	beq.n	1378c <HAL_TIM_Base_Init+0x1c0>
   13850:	2900      	cmp	r1, #0
   13852:	d19b      	bne.n	1378c <HAL_TIM_Base_Init+0x1c0>
   13854:	e783      	b.n	1375e <HAL_TIM_Base_Init+0x192>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   13856:	f643 2034 	movw	r0, #14900	; 0x3a34
   1385a:	f240 1115 	movw	r1, #277	; 0x115
   1385e:	f2c0 0003 	movt	r0, #3
   13862:	f007 fc25 	bl	1b0b0 <assert_failed>
   13866:	e72c      	b.n	136c2 <HAL_TIM_Base_Init+0xf6>

00013868 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
   13868:	2800      	cmp	r0, #0
   1386a:	f000 811c 	beq.w	13aa6 <HAL_TIM_PWM_Init+0x23e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   1386e:	2300      	movs	r3, #0
   13870:	f44f 6100 	mov.w	r1, #2048	; 0x800
   13874:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13878:	f2c4 0100 	movt	r1, #16384	; 0x4000
{
   1387c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   1387e:	6802      	ldr	r2, [r0, #0]
   13880:	4604      	mov	r4, r0
   13882:	f44f 6080 	mov.w	r0, #1024	; 0x400
   13886:	f44f 6540 	mov.w	r5, #3072	; 0xc00
   1388a:	429a      	cmp	r2, r3
   1388c:	bf18      	it	ne
   1388e:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   13892:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13896:	f2c4 0500 	movt	r5, #16384	; 0x4000
   1389a:	bf14      	ite	ne
   1389c:	2301      	movne	r3, #1
   1389e:	2300      	moveq	r3, #0
   138a0:	4282      	cmp	r2, r0
   138a2:	bf0c      	ite	eq
   138a4:	2300      	moveq	r3, #0
   138a6:	f003 0301 	andne.w	r3, r3, #1
   138aa:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   138ae:	428a      	cmp	r2, r1
   138b0:	bf0c      	ite	eq
   138b2:	2300      	moveq	r3, #0
   138b4:	f003 0301 	andne.w	r3, r3, #1
   138b8:	f2c4 0000 	movt	r0, #16384	; 0x4000
   138bc:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
   138c0:	42aa      	cmp	r2, r5
   138c2:	bf0c      	ite	eq
   138c4:	2300      	moveq	r3, #0
   138c6:	f003 0301 	andne.w	r3, r3, #1
   138ca:	f44f 6580 	mov.w	r5, #1024	; 0x400
   138ce:	f2c4 0100 	movt	r1, #16384	; 0x4000
   138d2:	4282      	cmp	r2, r0
   138d4:	bf0c      	ite	eq
   138d6:	2300      	moveq	r3, #0
   138d8:	f003 0301 	andne.w	r3, r3, #1
   138dc:	f2c4 0501 	movt	r5, #16385	; 0x4001
   138e0:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
   138e4:	428a      	cmp	r2, r1
   138e6:	bf0c      	ite	eq
   138e8:	2300      	moveq	r3, #0
   138ea:	f003 0301 	andne.w	r3, r3, #1
   138ee:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
   138f2:	f2c4 0000 	movt	r0, #16384	; 0x4000
   138f6:	42aa      	cmp	r2, r5
   138f8:	bf0c      	ite	eq
   138fa:	2300      	moveq	r3, #0
   138fc:	f003 0301 	andne.w	r3, r3, #1
   13900:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13904:	f44f 5500 	mov.w	r5, #8192	; 0x2000
   13908:	4282      	cmp	r2, r0
   1390a:	bf0c      	ite	eq
   1390c:	2300      	moveq	r3, #0
   1390e:	f003 0301 	andne.w	r3, r3, #1
   13912:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   13916:	f2c4 0500 	movt	r5, #16384	; 0x4000
   1391a:	428a      	cmp	r2, r1
   1391c:	bf0c      	ite	eq
   1391e:	2300      	moveq	r3, #0
   13920:	f003 0301 	andne.w	r3, r3, #1
   13924:	f2c4 0001 	movt	r0, #16385	; 0x4001
   13928:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   1392c:	42aa      	cmp	r2, r5
   1392e:	bf0c      	ite	eq
   13930:	2300      	moveq	r3, #0
   13932:	f003 0301 	andne.w	r3, r3, #1
   13936:	f2c4 0101 	movt	r1, #16385	; 0x4001
   1393a:	4282      	cmp	r2, r0
   1393c:	bf0c      	ite	eq
   1393e:	2300      	moveq	r3, #0
   13940:	f003 0301 	andne.w	r3, r3, #1
   13944:	428a      	cmp	r2, r1
   13946:	bf0c      	ite	eq
   13948:	2300      	moveq	r3, #0
   1394a:	f003 0301 	andne.w	r3, r3, #1
   1394e:	b133      	cbz	r3, 1395e <HAL_TIM_PWM_Init+0xf6>
   13950:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   13954:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13958:	429a      	cmp	r2, r3
   1395a:	f040 80ca 	bne.w	13af2 <HAL_TIM_PWM_Init+0x28a>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1395e:	68a3      	ldr	r3, [r4, #8]
   13960:	f023 0140 	bic.w	r1, r3, #64	; 0x40
   13964:	f023 0210 	bic.w	r2, r3, #16
   13968:	2920      	cmp	r1, #32
   1396a:	bf18      	it	ne
   1396c:	2a00      	cmpne	r2, #0
   1396e:	d002      	beq.n	13976 <HAL_TIM_PWM_Init+0x10e>
   13970:	2b40      	cmp	r3, #64	; 0x40
   13972:	f040 80a8 	bne.w	13ac6 <HAL_TIM_PWM_Init+0x25e>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   13976:	6923      	ldr	r3, [r4, #16]
   13978:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   1397c:	d003      	beq.n	13986 <HAL_TIM_PWM_Init+0x11e>
   1397e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   13982:	f040 8092 	bne.w	13aaa <HAL_TIM_PWM_Init+0x242>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   13986:	69a3      	ldr	r3, [r4, #24]
   13988:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   1398c:	d17b      	bne.n	13a86 <HAL_TIM_PWM_Init+0x21e>
  if (htim->State == HAL_TIM_STATE_RESET)
   1398e:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   13992:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   13996:	2b00      	cmp	r3, #0
   13998:	d06f      	beq.n	13a7a <HAL_TIM_PWM_Init+0x212>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   1399a:	2100      	movs	r1, #0
   1399c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
   139a0:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
   139a2:	2002      	movs	r0, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   139a4:	f2c4 0101 	movt	r1, #16385	; 0x4001
   139a8:	f2c4 0301 	movt	r3, #16385	; 0x4001
  htim->State = HAL_TIM_STATE_BUSY;
   139ac:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   139b0:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   139b4:	eba2 0001 	sub.w	r0, r2, r1
   139b8:	eba2 0103 	sub.w	r1, r2, r3
  tmpcr1 = TIMx->CR1;
   139bc:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   139be:	fab0 f080 	clz	r0, r0
   139c2:	fab1 f181 	clz	r1, r1
   139c6:	ea4f 1050 	mov.w	r0, r0, lsr #5
   139ca:	ea4f 1151 	mov.w	r1, r1, lsr #5
   139ce:	d027      	beq.n	13a20 <HAL_TIM_PWM_Init+0x1b8>
   139d0:	bb30      	cbnz	r0, 13a20 <HAL_TIM_PWM_Init+0x1b8>
   139d2:	f44f 6580 	mov.w	r5, #1024	; 0x400
   139d6:	f2c4 0500 	movt	r5, #16384	; 0x4000
   139da:	42aa      	cmp	r2, r5
   139dc:	d020      	beq.n	13a20 <HAL_TIM_PWM_Init+0x1b8>
   139de:	f44f 6500 	mov.w	r5, #2048	; 0x800
   139e2:	f2c4 0500 	movt	r5, #16384	; 0x4000
   139e6:	42aa      	cmp	r2, r5
   139e8:	d01a      	beq.n	13a20 <HAL_TIM_PWM_Init+0x1b8>
   139ea:	f44f 6540 	mov.w	r5, #3072	; 0xc00
   139ee:	f2c4 0500 	movt	r5, #16384	; 0x4000
   139f2:	42aa      	cmp	r2, r5
   139f4:	d070      	beq.n	13ad8 <HAL_TIM_PWM_Init+0x270>
   139f6:	2900      	cmp	r1, #0
   139f8:	d16e      	bne.n	13ad8 <HAL_TIM_PWM_Init+0x270>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   139fa:	f44f 4680 	mov.w	r6, #16384	; 0x4000
   139fe:	f44f 4588 	mov.w	r5, #17408	; 0x4400
   13a02:	f2c4 0601 	movt	r6, #16385	; 0x4001
   13a06:	f2c4 0501 	movt	r5, #16385	; 0x4001
   13a0a:	42aa      	cmp	r2, r5
   13a0c:	bf18      	it	ne
   13a0e:	42b2      	cmpne	r2, r6
   13a10:	d00a      	beq.n	13a28 <HAL_TIM_PWM_Init+0x1c0>
   13a12:	f44f 4590 	mov.w	r5, #18432	; 0x4800
   13a16:	f2c4 0501 	movt	r5, #16385	; 0x4001
   13a1a:	42aa      	cmp	r2, r5
   13a1c:	d108      	bne.n	13a30 <HAL_TIM_PWM_Init+0x1c8>
   13a1e:	e003      	b.n	13a28 <HAL_TIM_PWM_Init+0x1c0>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   13a20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   13a24:	68a5      	ldr	r5, [r4, #8]
   13a26:	432b      	orrs	r3, r5
    tmpcr1 &= ~TIM_CR1_CKD;
   13a28:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
   13a2c:	6925      	ldr	r5, [r4, #16]
   13a2e:	432b      	orrs	r3, r5
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   13a30:	69a5      	ldr	r5, [r4, #24]
   13a32:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13a36:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
   13a38:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
   13a3a:	68e3      	ldr	r3, [r4, #12]
   13a3c:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
   13a3e:	6863      	ldr	r3, [r4, #4]
   13a40:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   13a42:	b990      	cbnz	r0, 13a6a <HAL_TIM_PWM_Init+0x202>
   13a44:	b989      	cbnz	r1, 13a6a <HAL_TIM_PWM_Init+0x202>
   13a46:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   13a4a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   13a4e:	f2c4 0101 	movt	r1, #16385	; 0x4001
   13a52:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13a56:	429a      	cmp	r2, r3
   13a58:	bf18      	it	ne
   13a5a:	428a      	cmpne	r2, r1
   13a5c:	d005      	beq.n	13a6a <HAL_TIM_PWM_Init+0x202>
   13a5e:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   13a62:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13a66:	429a      	cmp	r2, r3
   13a68:	d101      	bne.n	13a6e <HAL_TIM_PWM_Init+0x206>
    TIMx->RCR = Structure->RepetitionCounter;
   13a6a:	6963      	ldr	r3, [r4, #20]
   13a6c:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
   13a6e:	2301      	movs	r3, #1
  return HAL_OK;
   13a70:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
   13a72:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
   13a74:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
   13a78:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
   13a7a:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
   13a7e:	4620      	mov	r0, r4
   13a80:	f011 f8da 	bl	24c38 <HAL_TIM_PWM_MspInit>
   13a84:	e789      	b.n	1399a <HAL_TIM_PWM_Init+0x132>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   13a86:	f643 2034 	movw	r0, #14900	; 0x3a34
   13a8a:	f240 41a5 	movw	r1, #1189	; 0x4a5
   13a8e:	f2c0 0003 	movt	r0, #3
   13a92:	f007 fb0d 	bl	1b0b0 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
   13a96:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   13a9a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   13a9e:	2b00      	cmp	r3, #0
   13aa0:	f47f af7b 	bne.w	1399a <HAL_TIM_PWM_Init+0x132>
   13aa4:	e7e9      	b.n	13a7a <HAL_TIM_PWM_Init+0x212>
    return HAL_ERROR;
   13aa6:	2001      	movs	r0, #1
}
   13aa8:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   13aaa:	f643 2034 	movw	r0, #14900	; 0x3a34
   13aae:	f240 41a4 	movw	r1, #1188	; 0x4a4
   13ab2:	f2c0 0003 	movt	r0, #3
   13ab6:	f007 fafb 	bl	1b0b0 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   13aba:	69a3      	ldr	r3, [r4, #24]
   13abc:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   13ac0:	f43f af65 	beq.w	1398e <HAL_TIM_PWM_Init+0x126>
   13ac4:	e7df      	b.n	13a86 <HAL_TIM_PWM_Init+0x21e>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   13ac6:	f643 2034 	movw	r0, #14900	; 0x3a34
   13aca:	f240 41a3 	movw	r1, #1187	; 0x4a3
   13ace:	f2c0 0003 	movt	r0, #3
   13ad2:	f007 faed 	bl	1b0b0 <assert_failed>
   13ad6:	e74e      	b.n	13976 <HAL_TIM_PWM_Init+0x10e>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   13ad8:	f44f 6540 	mov.w	r5, #3072	; 0xc00
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   13adc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   13ae0:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   13ae2:	f2c4 0500 	movt	r5, #16384	; 0x4000
    tmpcr1 |= Structure->CounterMode;
   13ae6:	4333      	orrs	r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   13ae8:	42aa      	cmp	r2, r5
   13aea:	d09d      	beq.n	13a28 <HAL_TIM_PWM_Init+0x1c0>
   13aec:	2900      	cmp	r1, #0
   13aee:	d19b      	bne.n	13a28 <HAL_TIM_PWM_Init+0x1c0>
   13af0:	e783      	b.n	139fa <HAL_TIM_PWM_Init+0x192>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   13af2:	f643 2034 	movw	r0, #14900	; 0x3a34
   13af6:	f240 41a2 	movw	r1, #1186	; 0x4a2
   13afa:	f2c0 0003 	movt	r0, #3
   13afe:	f007 fad7 	bl	1b0b0 <assert_failed>
   13b02:	e72c      	b.n	1395e <HAL_TIM_PWM_Init+0xf6>

00013b04 <HAL_TIM_PWM_Start>:
{
   13b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   13b06:	2300      	movs	r3, #0
   13b08:	6804      	ldr	r4, [r0, #0]
{
   13b0a:	4606      	mov	r6, r0
   13b0c:	460d      	mov	r5, r1
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   13b0e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13b12:	429c      	cmp	r4, r3
   13b14:	f000 80d5 	beq.w	13cc2 <HAL_TIM_PWM_Start+0x1be>
   13b18:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   13b1c:	f000 80ca 	beq.w	13cb4 <HAL_TIM_PWM_Start+0x1b0>
   13b20:	f44f 6380 	mov.w	r3, #1024	; 0x400
   13b24:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13b28:	429c      	cmp	r4, r3
   13b2a:	f000 80c3 	beq.w	13cb4 <HAL_TIM_PWM_Start+0x1b0>
   13b2e:	f44f 6300 	mov.w	r3, #2048	; 0x800
   13b32:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13b36:	429c      	cmp	r4, r3
   13b38:	f000 80bc 	beq.w	13cb4 <HAL_TIM_PWM_Start+0x1b0>
   13b3c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
   13b40:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13b44:	429c      	cmp	r4, r3
   13b46:	f000 80b5 	beq.w	13cb4 <HAL_TIM_PWM_Start+0x1b0>
   13b4a:	f44f 6380 	mov.w	r3, #1024	; 0x400
   13b4e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13b52:	429c      	cmp	r4, r3
   13b54:	f000 80d2 	beq.w	13cfc <HAL_TIM_PWM_Start+0x1f8>
   13b58:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   13b5c:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13b60:	429c      	cmp	r4, r3
   13b62:	f000 80d6 	beq.w	13d12 <HAL_TIM_PWM_Start+0x20e>
   13b66:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
   13b6a:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13b6e:	429c      	cmp	r4, r3
   13b70:	f040 80d4 	bne.w	13d1c <HAL_TIM_PWM_Start+0x218>
   13b74:	b345      	cbz	r5, 13bc8 <HAL_TIM_PWM_Start+0xc4>
   13b76:	f643 2034 	movw	r0, #14900	; 0x3a34
   13b7a:	f240 511c 	movw	r1, #1308	; 0x51c
   13b7e:	f2c0 0003 	movt	r0, #3
   13b82:	f007 fa95 	bl	1b0b0 <assert_failed>
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   13b86:	2300      	movs	r3, #0
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   13b88:	6834      	ldr	r4, [r6, #0]
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   13b8a:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13b8e:	429c      	cmp	r4, r3
   13b90:	d046      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13b92:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   13b96:	d043      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13b98:	f44f 6380 	mov.w	r3, #1024	; 0x400
   13b9c:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13ba0:	429c      	cmp	r4, r3
   13ba2:	d03d      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13ba4:	f44f 6300 	mov.w	r3, #2048	; 0x800
   13ba8:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13bac:	429c      	cmp	r4, r3
   13bae:	d037      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13bb0:	f44f 6340 	mov.w	r3, #3072	; 0xc00
   13bb4:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13bb8:	429c      	cmp	r4, r3
   13bba:	d031      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13bbc:	f44f 6380 	mov.w	r3, #1024	; 0x400
   13bc0:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13bc4:	429c      	cmp	r4, r3
   13bc6:	d02b      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13bc8:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   13bcc:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13bd0:	429c      	cmp	r4, r3
   13bd2:	d025      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13bd4:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
   13bd8:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13bdc:	429c      	cmp	r4, r3
   13bde:	d01f      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13be0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   13be4:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13be8:	429c      	cmp	r4, r3
   13bea:	d019      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13bec:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   13bf0:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13bf4:	429c      	cmp	r4, r3
   13bf6:	d013      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13bf8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   13bfc:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13c00:	429c      	cmp	r4, r3
   13c02:	d00d      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13c04:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   13c08:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13c0c:	429c      	cmp	r4, r3
   13c0e:	d007      	beq.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13c10:	f643 2034 	movw	r0, #14900	; 0x3a34
   13c14:	f641 3154 	movw	r1, #6996	; 0x1b54
   13c18:	f2c0 0003 	movt	r0, #3
   13c1c:	f007 fa48 	bl	1b0b0 <assert_failed>
  assert_param(IS_TIM_CHANNELS(Channel));
   13c20:	2d14      	cmp	r5, #20
   13c22:	d959      	bls.n	13cd8 <HAL_TIM_PWM_Start+0x1d4>
   13c24:	2d3c      	cmp	r5, #60	; 0x3c
   13c26:	d160      	bne.n	13cea <HAL_TIM_PWM_Start+0x1e6>

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   13c28:	2301      	movs	r3, #1
   13c2a:	f005 051f 	and.w	r5, r5, #31

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
   13c2e:	6a21      	ldr	r1, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   13c30:	2200      	movs	r2, #0
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   13c32:	fa03 f505 	lsl.w	r5, r3, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   13c36:	f44f 6780 	mov.w	r7, #1024	; 0x400
   13c3a:	f2c4 0201 	movt	r2, #16385	; 0x4001
   13c3e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  TIMx->CCER &= ~tmp;
   13c42:	ea21 0105 	bic.w	r1, r1, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   13c46:	f2c4 0701 	movt	r7, #16385	; 0x4001
   13c4a:	f2c4 0001 	movt	r0, #16385	; 0x4001
  TIMx->CCER &= ~tmp;
   13c4e:	6221      	str	r1, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   13c50:	f44f 4188 	mov.w	r1, #17408	; 0x4400

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   13c54:	6a23      	ldr	r3, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   13c56:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   13c5a:	431d      	orrs	r5, r3
   13c5c:	6225      	str	r5, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   13c5e:	6833      	ldr	r3, [r6, #0]
   13c60:	42bb      	cmp	r3, r7
   13c62:	bf18      	it	ne
   13c64:	4293      	cmpne	r3, r2
   13c66:	bf0c      	ite	eq
   13c68:	2201      	moveq	r2, #1
   13c6a:	2200      	movne	r2, #0
   13c6c:	4283      	cmp	r3, r0
   13c6e:	bf08      	it	eq
   13c70:	f042 0201 	orreq.w	r2, r2, #1
   13c74:	428b      	cmp	r3, r1
   13c76:	bf08      	it	eq
   13c78:	f042 0201 	orreq.w	r2, r2, #1
   13c7c:	b92a      	cbnz	r2, 13c8a <HAL_TIM_PWM_Start+0x186>
   13c7e:	f44f 4290 	mov.w	r2, #18432	; 0x4800
   13c82:	f2c4 0201 	movt	r2, #16385	; 0x4001
   13c86:	4293      	cmp	r3, r2
   13c88:	d104      	bne.n	13c94 <HAL_TIM_PWM_Start+0x190>
    __HAL_TIM_MOE_ENABLE(htim);
   13c8a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   13c8c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   13c90:	645a      	str	r2, [r3, #68]	; 0x44
   13c92:	6833      	ldr	r3, [r6, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   13c94:	2207      	movs	r2, #7
   13c96:	6899      	ldr	r1, [r3, #8]
   13c98:	f2c0 0201 	movt	r2, #1
   13c9c:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   13c9e:	2a06      	cmp	r2, #6
   13ca0:	d006      	beq.n	13cb0 <HAL_TIM_PWM_Start+0x1ac>
   13ca2:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
   13ca6:	d003      	beq.n	13cb0 <HAL_TIM_PWM_Start+0x1ac>
    __HAL_TIM_ENABLE(htim);
   13ca8:	681a      	ldr	r2, [r3, #0]
   13caa:	f042 0201 	orr.w	r2, r2, #1
   13cae:	601a      	str	r2, [r3, #0]
}
   13cb0:	2000      	movs	r0, #0
   13cb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   13cb4:	f035 030c 	bics.w	r3, r5, #12
   13cb8:	f47f af5d 	bne.w	13b76 <HAL_TIM_PWM_Start+0x72>
  assert_param(IS_TIM_CHANNELS(Channel));
   13cbc:	2d14      	cmp	r5, #20
   13cbe:	d8b1      	bhi.n	13c24 <HAL_TIM_PWM_Start+0x120>
   13cc0:	e00a      	b.n	13cd8 <HAL_TIM_PWM_Start+0x1d4>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   13cc2:	2914      	cmp	r1, #20
   13cc4:	f63f af57 	bhi.w	13b76 <HAL_TIM_PWM_Start+0x72>
   13cc8:	f241 1311 	movw	r3, #4369	; 0x1111
   13ccc:	f2c0 0311 	movt	r3, #17
   13cd0:	40cb      	lsrs	r3, r1
   13cd2:	07d9      	lsls	r1, r3, #31
   13cd4:	f57f af4f 	bpl.w	13b76 <HAL_TIM_PWM_Start+0x72>
  assert_param(IS_TIM_CHANNELS(Channel));
   13cd8:	f241 1311 	movw	r3, #4369	; 0x1111
   13cdc:	f2c0 0311 	movt	r3, #17
   13ce0:	40eb      	lsrs	r3, r5
   13ce2:	07db      	lsls	r3, r3, #31
   13ce4:	d4a0      	bmi.n	13c28 <HAL_TIM_PWM_Start+0x124>
   13ce6:	2d3c      	cmp	r5, #60	; 0x3c
   13ce8:	d09e      	beq.n	13c28 <HAL_TIM_PWM_Start+0x124>
   13cea:	f643 2034 	movw	r0, #14900	; 0x3a34
   13cee:	f641 3155 	movw	r1, #6997	; 0x1b55
   13cf2:	f2c0 0003 	movt	r0, #3
   13cf6:	f007 f9db 	bl	1b0b0 <assert_failed>
   13cfa:	e795      	b.n	13c28 <HAL_TIM_PWM_Start+0x124>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   13cfc:	2914      	cmp	r1, #20
   13cfe:	f63f af3a 	bhi.w	13b76 <HAL_TIM_PWM_Start+0x72>
   13d02:	f241 1311 	movw	r3, #4369	; 0x1111
   13d06:	f2c0 0311 	movt	r3, #17
   13d0a:	40cb      	lsrs	r3, r1
   13d0c:	07da      	lsls	r2, r3, #31
   13d0e:	d487      	bmi.n	13c20 <HAL_TIM_PWM_Start+0x11c>
   13d10:	e731      	b.n	13b76 <HAL_TIM_PWM_Start+0x72>
   13d12:	f035 0304 	bics.w	r3, r5, #4
   13d16:	f47f af2e 	bne.w	13b76 <HAL_TIM_PWM_Start+0x72>
   13d1a:	e755      	b.n	13bc8 <HAL_TIM_PWM_Start+0xc4>
   13d1c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   13d20:	f2c4 0300 	movt	r3, #16384	; 0x4000
   13d24:	429c      	cmp	r4, r3
   13d26:	f43f af25 	beq.w	13b74 <HAL_TIM_PWM_Start+0x70>
   13d2a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   13d2e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13d32:	429c      	cmp	r4, r3
   13d34:	d0ed      	beq.n	13d12 <HAL_TIM_PWM_Start+0x20e>
   13d36:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   13d3a:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13d3e:	429c      	cmp	r4, r3
   13d40:	f43f af18 	beq.w	13b74 <HAL_TIM_PWM_Start+0x70>
   13d44:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   13d48:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13d4c:	429c      	cmp	r4, r3
   13d4e:	f47f af12 	bne.w	13b76 <HAL_TIM_PWM_Start+0x72>
   13d52:	2900      	cmp	r1, #0
   13d54:	f47f af0f 	bne.w	13b76 <HAL_TIM_PWM_Start+0x72>
   13d58:	461c      	mov	r4, r3
   13d5a:	e729      	b.n	13bb0 <HAL_TIM_PWM_Start+0xac>

00013d5c <HAL_TIM_ConfigClockSource>:
{
   13d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
   13d5e:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
   13d62:	2b01      	cmp	r3, #1
   13d64:	f000 81d7 	beq.w	14116 <HAL_TIM_ConfigClockSource+0x3ba>
   13d68:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
   13d6a:	2302      	movs	r3, #2
   13d6c:	460d      	mov	r5, r1
   13d6e:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
   13d70:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
   13d74:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   13d78:	680b      	ldr	r3, [r1, #0]
   13d7a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   13d7e:	bf18      	it	ne
   13d80:	f5b3 5f00 	cmpne.w	r3, #8192	; 0x2000
   13d84:	bf14      	ite	ne
   13d86:	2201      	movne	r2, #1
   13d88:	2200      	moveq	r2, #0
   13d8a:	f033 0330 	bics.w	r3, r3, #48	; 0x30
   13d8e:	bf08      	it	eq
   13d90:	2200      	moveq	r2, #0
   13d92:	b112      	cbz	r2, 13d9a <HAL_TIM_ConfigClockSource+0x3e>
   13d94:	2b40      	cmp	r3, #64	; 0x40
   13d96:	f040 82de 	bne.w	14356 <HAL_TIM_ConfigClockSource+0x5fa>
  tmpsmcr = htim->Instance->SMCR;
   13d9a:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   13d9c:	2388      	movs	r3, #136	; 0x88
  tmpsmcr = htim->Instance->SMCR;
   13d9e:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   13da0:	f6cf 73ce 	movt	r3, #65486	; 0xffce
   13da4:	400b      	ands	r3, r1
  htim->Instance->SMCR = tmpsmcr;
   13da6:	6093      	str	r3, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
   13da8:	682b      	ldr	r3, [r5, #0]
   13daa:	2b70      	cmp	r3, #112	; 0x70
   13dac:	f000 81b5 	beq.w	1411a <HAL_TIM_ConfigClockSource+0x3be>
   13db0:	d86e      	bhi.n	13e90 <HAL_TIM_ConfigClockSource+0x134>
   13db2:	2b30      	cmp	r3, #48	; 0x30
   13db4:	f000 826b 	beq.w	1428e <HAL_TIM_ConfigClockSource+0x532>
   13db8:	f240 8262 	bls.w	14280 <HAL_TIM_ConfigClockSource+0x524>
   13dbc:	2b50      	cmp	r3, #80	; 0x50
   13dbe:	f000 81fe 	beq.w	141be <HAL_TIM_ConfigClockSource+0x462>
   13dc2:	2b60      	cmp	r3, #96	; 0x60
   13dc4:	f000 80f3 	beq.w	13fae <HAL_TIM_ConfigClockSource+0x252>
   13dc8:	2b40      	cmp	r3, #64	; 0x40
   13dca:	f040 80e8 	bne.w	13f9e <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   13dce:	2300      	movs	r3, #0
   13dd0:	6822      	ldr	r2, [r4, #0]
   13dd2:	f44f 6680 	mov.w	r6, #1024	; 0x400
   13dd6:	f44f 6100 	mov.w	r1, #2048	; 0x800
   13dda:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13dde:	f44f 6040 	mov.w	r0, #3072	; 0xc00
   13de2:	f2c4 0600 	movt	r6, #16384	; 0x4000
   13de6:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13dea:	429a      	cmp	r2, r3
   13dec:	bf18      	it	ne
   13dee:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   13df2:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13df6:	bf14      	ite	ne
   13df8:	2301      	movne	r3, #1
   13dfa:	2300      	moveq	r3, #0
   13dfc:	42b2      	cmp	r2, r6
   13dfe:	bf0c      	ite	eq
   13e00:	2300      	moveq	r3, #0
   13e02:	f003 0301 	andne.w	r3, r3, #1
   13e06:	428a      	cmp	r2, r1
   13e08:	bf0c      	ite	eq
   13e0a:	2300      	moveq	r3, #0
   13e0c:	f003 0301 	andne.w	r3, r3, #1
   13e10:	f44f 6180 	mov.w	r1, #1024	; 0x400
   13e14:	4282      	cmp	r2, r0
   13e16:	bf0c      	ite	eq
   13e18:	2300      	moveq	r3, #0
   13e1a:	f003 0301 	andne.w	r3, r3, #1
   13e1e:	f2c4 0101 	movt	r1, #16385	; 0x4001
   13e22:	428a      	cmp	r2, r1
   13e24:	bf0c      	ite	eq
   13e26:	2300      	moveq	r3, #0
   13e28:	f003 0301 	andne.w	r3, r3, #1
   13e2c:	b133      	cbz	r3, 13e3c <HAL_TIM_ConfigClockSource+0xe0>
   13e2e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   13e32:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13e36:	429a      	cmp	r2, r3
   13e38:	f040 82e0 	bne.w	143fc <HAL_TIM_ConfigClockSource+0x6a0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   13e3c:	686b      	ldr	r3, [r5, #4]
   13e3e:	2b0a      	cmp	r3, #10
   13e40:	bf18      	it	ne
   13e42:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   13e46:	d003      	beq.n	13e50 <HAL_TIM_ConfigClockSource+0xf4>
   13e48:	f033 0302 	bics.w	r3, r3, #2
   13e4c:	f040 828c 	bne.w	14368 <HAL_TIM_ConfigClockSource+0x60c>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   13e50:	68ef      	ldr	r7, [r5, #12]
   13e52:	2f0f      	cmp	r7, #15
   13e54:	f200 8303 	bhi.w	1445e <HAL_TIM_ConfigClockSource+0x702>
      TIM_TI1_ConfigInputStage(htim->Instance,
   13e58:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
   13e5a:	f64f 738f 	movw	r3, #65423	; 0xff8f
      TIM_TI1_ConfigInputStage(htim->Instance,
   13e5e:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
   13e60:	6a16      	ldr	r6, [r2, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
   13e62:	f6cf 73cf 	movt	r3, #65487	; 0xffcf
  TIMx->CCER &= ~TIM_CCER_CC1E;
   13e66:	6a15      	ldr	r5, [r2, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   13e68:	f026 060a 	bic.w	r6, r6, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
   13e6c:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
   13e70:	4330      	orrs	r0, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
   13e72:	6215      	str	r5, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
   13e74:	6991      	ldr	r1, [r2, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
   13e76:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
   13e7a:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1;
   13e7e:	6191      	str	r1, [r2, #24]
  TIMx->CCER = tmpccer;
   13e80:	6210      	str	r0, [r2, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   13e82:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   13e84:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   13e86:	400b      	ands	r3, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   13e88:	f043 0347 	orr.w	r3, r3, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
   13e8c:	6093      	str	r3, [r2, #8]
   13e8e:	e086      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
  switch (sClockSourceConfig->ClockSource)
   13e90:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
   13e94:	f000 81fb 	beq.w	1428e <HAL_TIM_ConfigClockSource+0x532>
   13e98:	f200 823a 	bhi.w	14310 <HAL_TIM_ConfigClockSource+0x5b4>
   13e9c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   13ea0:	f000 80e7 	beq.w	14072 <HAL_TIM_ConfigClockSource+0x316>
   13ea4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   13ea8:	f000 81f1 	beq.w	1428e <HAL_TIM_ConfigClockSource+0x532>
   13eac:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   13eb0:	d175      	bne.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
   13eb2:	2300      	movs	r3, #0
   13eb4:	6822      	ldr	r2, [r4, #0]
   13eb6:	f44f 6080 	mov.w	r0, #1024	; 0x400
   13eba:	f44f 6100 	mov.w	r1, #2048	; 0x800
   13ebe:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13ec2:	f44f 6540 	mov.w	r5, #3072	; 0xc00
   13ec6:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13eca:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13ece:	429a      	cmp	r2, r3
   13ed0:	bf18      	it	ne
   13ed2:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   13ed6:	f2c4 0500 	movt	r5, #16384	; 0x4000
   13eda:	bf14      	ite	ne
   13edc:	2301      	movne	r3, #1
   13ede:	2300      	moveq	r3, #0
   13ee0:	4282      	cmp	r2, r0
   13ee2:	bf0c      	ite	eq
   13ee4:	2300      	moveq	r3, #0
   13ee6:	f003 0301 	andne.w	r3, r3, #1
   13eea:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   13eee:	428a      	cmp	r2, r1
   13ef0:	bf0c      	ite	eq
   13ef2:	2300      	moveq	r3, #0
   13ef4:	f003 0301 	andne.w	r3, r3, #1
   13ef8:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13efc:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
   13f00:	42aa      	cmp	r2, r5
   13f02:	bf0c      	ite	eq
   13f04:	2300      	moveq	r3, #0
   13f06:	f003 0301 	andne.w	r3, r3, #1
   13f0a:	f44f 6580 	mov.w	r5, #1024	; 0x400
   13f0e:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13f12:	4282      	cmp	r2, r0
   13f14:	bf0c      	ite	eq
   13f16:	2300      	moveq	r3, #0
   13f18:	f003 0301 	andne.w	r3, r3, #1
   13f1c:	f2c4 0501 	movt	r5, #16385	; 0x4001
   13f20:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
   13f24:	428a      	cmp	r2, r1
   13f26:	bf0c      	ite	eq
   13f28:	2300      	moveq	r3, #0
   13f2a:	f003 0301 	andne.w	r3, r3, #1
   13f2e:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
   13f32:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13f36:	42aa      	cmp	r2, r5
   13f38:	bf0c      	ite	eq
   13f3a:	2300      	moveq	r3, #0
   13f3c:	f003 0301 	andne.w	r3, r3, #1
   13f40:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13f44:	f44f 5500 	mov.w	r5, #8192	; 0x2000
   13f48:	4282      	cmp	r2, r0
   13f4a:	bf0c      	ite	eq
   13f4c:	2300      	moveq	r3, #0
   13f4e:	f003 0301 	andne.w	r3, r3, #1
   13f52:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   13f56:	f2c4 0500 	movt	r5, #16384	; 0x4000
   13f5a:	428a      	cmp	r2, r1
   13f5c:	bf0c      	ite	eq
   13f5e:	2300      	moveq	r3, #0
   13f60:	f003 0301 	andne.w	r3, r3, #1
   13f64:	f2c4 0001 	movt	r0, #16385	; 0x4001
   13f68:	f44f 4188 	mov.w	r1, #17408	; 0x4400
   13f6c:	42aa      	cmp	r2, r5
   13f6e:	bf0c      	ite	eq
   13f70:	2300      	moveq	r3, #0
   13f72:	f003 0301 	andne.w	r3, r3, #1
   13f76:	f2c4 0101 	movt	r1, #16385	; 0x4001
   13f7a:	4282      	cmp	r2, r0
   13f7c:	bf0c      	ite	eq
   13f7e:	2300      	moveq	r3, #0
   13f80:	f003 0301 	andne.w	r3, r3, #1
   13f84:	428a      	cmp	r2, r1
   13f86:	bf0c      	ite	eq
   13f88:	2300      	moveq	r3, #0
   13f8a:	f003 0301 	andne.w	r3, r3, #1
   13f8e:	b133      	cbz	r3, 13f9e <HAL_TIM_ConfigClockSource+0x242>
   13f90:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   13f94:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13f98:	429a      	cmp	r2, r3
   13f9a:	f040 827c 	bne.w	14496 <HAL_TIM_ConfigClockSource+0x73a>
  __HAL_UNLOCK(htim);
   13f9e:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   13fa0:	2201      	movs	r2, #1
  return HAL_OK;
   13fa2:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   13fa4:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   13fa8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   13fac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   13fae:	2300      	movs	r3, #0
   13fb0:	6822      	ldr	r2, [r4, #0]
   13fb2:	f44f 6680 	mov.w	r6, #1024	; 0x400
   13fb6:	f44f 6100 	mov.w	r1, #2048	; 0x800
   13fba:	f2c4 0301 	movt	r3, #16385	; 0x4001
   13fbe:	f44f 6040 	mov.w	r0, #3072	; 0xc00
   13fc2:	f2c4 0600 	movt	r6, #16384	; 0x4000
   13fc6:	f2c4 0100 	movt	r1, #16384	; 0x4000
   13fca:	429a      	cmp	r2, r3
   13fcc:	bf18      	it	ne
   13fce:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   13fd2:	f2c4 0000 	movt	r0, #16384	; 0x4000
   13fd6:	bf14      	ite	ne
   13fd8:	2301      	movne	r3, #1
   13fda:	2300      	moveq	r3, #0
   13fdc:	42b2      	cmp	r2, r6
   13fde:	bf0c      	ite	eq
   13fe0:	2300      	moveq	r3, #0
   13fe2:	f003 0301 	andne.w	r3, r3, #1
   13fe6:	428a      	cmp	r2, r1
   13fe8:	bf0c      	ite	eq
   13fea:	2300      	moveq	r3, #0
   13fec:	f003 0301 	andne.w	r3, r3, #1
   13ff0:	f44f 6180 	mov.w	r1, #1024	; 0x400
   13ff4:	4282      	cmp	r2, r0
   13ff6:	bf0c      	ite	eq
   13ff8:	2300      	moveq	r3, #0
   13ffa:	f003 0301 	andne.w	r3, r3, #1
   13ffe:	f2c4 0101 	movt	r1, #16385	; 0x4001
   14002:	428a      	cmp	r2, r1
   14004:	bf0c      	ite	eq
   14006:	2300      	moveq	r3, #0
   14008:	f003 0301 	andne.w	r3, r3, #1
   1400c:	b133      	cbz	r3, 1401c <HAL_TIM_ConfigClockSource+0x2c0>
   1400e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   14012:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14016:	429a      	cmp	r2, r3
   14018:	f040 81e7 	bne.w	143ea <HAL_TIM_ConfigClockSource+0x68e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1401c:	686b      	ldr	r3, [r5, #4]
   1401e:	2b0a      	cmp	r3, #10
   14020:	bf18      	it	ne
   14022:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   14026:	d003      	beq.n	14030 <HAL_TIM_ConfigClockSource+0x2d4>
   14028:	f033 0302 	bics.w	r3, r3, #2
   1402c:	f040 81a5 	bne.w	1437a <HAL_TIM_ConfigClockSource+0x61e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   14030:	68ee      	ldr	r6, [r5, #12]
   14032:	2e0f      	cmp	r6, #15
   14034:	f200 8209 	bhi.w	1444a <HAL_TIM_ConfigClockSource+0x6ee>
      TIM_TI2_ConfigInputStage(htim->Instance,
   14038:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
   1403a:	f64f 738f 	movw	r3, #65423	; 0xff8f
      TIM_TI2_ConfigInputStage(htim->Instance,
   1403e:	686f      	ldr	r7, [r5, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
   14040:	6a15      	ldr	r5, [r2, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
   14042:	f6cf 73cf 	movt	r3, #65487	; 0xffcf
  TIMx->CCER &= ~TIM_CCER_CC2E;
   14046:	f025 0510 	bic.w	r5, r5, #16
   1404a:	6215      	str	r5, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
   1404c:	6990      	ldr	r0, [r2, #24]
  tmpccer = TIMx->CCER;
   1404e:	6a11      	ldr	r1, [r2, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
   14050:	f420 4070 	bic.w	r0, r0, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   14054:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
   14058:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
   1405c:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
   14060:	6190      	str	r0, [r2, #24]
  TIMx->CCER = tmpccer;
   14062:	6211      	str	r1, [r2, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   14064:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   14066:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   14068:	400b      	ands	r3, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   1406a:	f043 0367 	orr.w	r3, r3, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
   1406e:	6093      	str	r3, [r2, #8]
   14070:	e795      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   14072:	2300      	movs	r3, #0
   14074:	6822      	ldr	r2, [r4, #0]
   14076:	f44f 6680 	mov.w	r6, #1024	; 0x400
   1407a:	f44f 6000 	mov.w	r0, #2048	; 0x800
   1407e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14082:	f44f 6140 	mov.w	r1, #3072	; 0xc00
   14086:	f2c4 0600 	movt	r6, #16384	; 0x4000
   1408a:	f2c4 0000 	movt	r0, #16384	; 0x4000
   1408e:	429a      	cmp	r2, r3
   14090:	bf18      	it	ne
   14092:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   14096:	f2c4 0100 	movt	r1, #16384	; 0x4000
   1409a:	bf14      	ite	ne
   1409c:	2301      	movne	r3, #1
   1409e:	2300      	moveq	r3, #0
   140a0:	42b2      	cmp	r2, r6
   140a2:	bf0c      	ite	eq
   140a4:	2300      	moveq	r3, #0
   140a6:	f003 0301 	andne.w	r3, r3, #1
   140aa:	4282      	cmp	r2, r0
   140ac:	bf0c      	ite	eq
   140ae:	2300      	moveq	r3, #0
   140b0:	f003 0301 	andne.w	r3, r3, #1
   140b4:	428a      	cmp	r2, r1
   140b6:	bf0c      	ite	eq
   140b8:	2300      	moveq	r3, #0
   140ba:	f003 0301 	andne.w	r3, r3, #1
   140be:	b133      	cbz	r3, 140ce <HAL_TIM_ConfigClockSource+0x372>
   140c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
   140c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
   140c8:	429a      	cmp	r2, r3
   140ca:	f040 8132 	bne.w	14332 <HAL_TIM_ConfigClockSource+0x5d6>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   140ce:	68ab      	ldr	r3, [r5, #8]
   140d0:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
   140d4:	f040 81cd 	bne.w	14472 <HAL_TIM_ConfigClockSource+0x716>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   140d8:	686b      	ldr	r3, [r5, #4]
   140da:	2b0a      	cmp	r3, #10
   140dc:	bf18      	it	ne
   140de:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   140e2:	d003      	beq.n	140ec <HAL_TIM_ConfigClockSource+0x390>
   140e4:	f033 0302 	bics.w	r3, r3, #2
   140e8:	f040 8159 	bne.w	1439e <HAL_TIM_ConfigClockSource+0x642>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   140ec:	68e9      	ldr	r1, [r5, #12]
   140ee:	290f      	cmp	r1, #15
   140f0:	f200 818d 	bhi.w	1440e <HAL_TIM_ConfigClockSource+0x6b2>
      TIM_ETR_SetConfig(htim->Instance,
   140f4:	6820      	ldr	r0, [r4, #0]
   140f6:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
   140f8:	6882      	ldr	r2, [r0, #8]
   140fa:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   140fc:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   14100:	432b      	orrs	r3, r5
   14102:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   14104:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
   14108:	6083      	str	r3, [r0, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
   1410a:	6822      	ldr	r2, [r4, #0]
   1410c:	6893      	ldr	r3, [r2, #8]
   1410e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   14112:	6093      	str	r3, [r2, #8]
      break;
   14114:	e743      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
  __HAL_LOCK(htim);
   14116:	2002      	movs	r0, #2
}
   14118:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   1411a:	2300      	movs	r3, #0
   1411c:	6822      	ldr	r2, [r4, #0]
   1411e:	f44f 6680 	mov.w	r6, #1024	; 0x400
   14122:	f44f 6000 	mov.w	r0, #2048	; 0x800
   14126:	f2c4 0301 	movt	r3, #16385	; 0x4001
   1412a:	f44f 6140 	mov.w	r1, #3072	; 0xc00
   1412e:	f2c4 0600 	movt	r6, #16384	; 0x4000
   14132:	f2c4 0000 	movt	r0, #16384	; 0x4000
   14136:	429a      	cmp	r2, r3
   14138:	bf18      	it	ne
   1413a:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   1413e:	f2c4 0100 	movt	r1, #16384	; 0x4000
   14142:	bf14      	ite	ne
   14144:	2301      	movne	r3, #1
   14146:	2300      	moveq	r3, #0
   14148:	42b2      	cmp	r2, r6
   1414a:	bf0c      	ite	eq
   1414c:	2300      	moveq	r3, #0
   1414e:	f003 0301 	andne.w	r3, r3, #1
   14152:	4282      	cmp	r2, r0
   14154:	bf0c      	ite	eq
   14156:	2300      	moveq	r3, #0
   14158:	f003 0301 	andne.w	r3, r3, #1
   1415c:	428a      	cmp	r2, r1
   1415e:	bf0c      	ite	eq
   14160:	2300      	moveq	r3, #0
   14162:	f003 0301 	andne.w	r3, r3, #1
   14166:	b133      	cbz	r3, 14176 <HAL_TIM_ConfigClockSource+0x41a>
   14168:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1416c:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14170:	429a      	cmp	r2, r3
   14172:	f040 80e7 	bne.w	14344 <HAL_TIM_ConfigClockSource+0x5e8>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   14176:	68ab      	ldr	r3, [r5, #8]
   14178:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
   1417c:	f040 8182 	bne.w	14484 <HAL_TIM_ConfigClockSource+0x728>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   14180:	686b      	ldr	r3, [r5, #4]
   14182:	2b0a      	cmp	r3, #10
   14184:	bf18      	it	ne
   14186:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   1418a:	d003      	beq.n	14194 <HAL_TIM_ConfigClockSource+0x438>
   1418c:	f033 0302 	bics.w	r3, r3, #2
   14190:	f040 80fc 	bne.w	1438c <HAL_TIM_ConfigClockSource+0x630>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   14194:	68e9      	ldr	r1, [r5, #12]
   14196:	290f      	cmp	r1, #15
   14198:	f200 814d 	bhi.w	14436 <HAL_TIM_ConfigClockSource+0x6da>
      TIM_ETR_SetConfig(htim->Instance,
   1419c:	6820      	ldr	r0, [r4, #0]
   1419e:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
   141a0:	6882      	ldr	r2, [r0, #8]
   141a2:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   141a4:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   141a8:	432b      	orrs	r3, r5
   141aa:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   141ac:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
   141b0:	6083      	str	r3, [r0, #8]
      tmpsmcr = htim->Instance->SMCR;
   141b2:	6822      	ldr	r2, [r4, #0]
   141b4:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   141b6:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
   141ba:	6093      	str	r3, [r2, #8]
      break;
   141bc:	e6ef      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   141be:	2300      	movs	r3, #0
   141c0:	6822      	ldr	r2, [r4, #0]
   141c2:	f44f 6680 	mov.w	r6, #1024	; 0x400
   141c6:	f44f 6100 	mov.w	r1, #2048	; 0x800
   141ca:	f2c4 0301 	movt	r3, #16385	; 0x4001
   141ce:	f44f 6040 	mov.w	r0, #3072	; 0xc00
   141d2:	f2c4 0600 	movt	r6, #16384	; 0x4000
   141d6:	f2c4 0100 	movt	r1, #16384	; 0x4000
   141da:	429a      	cmp	r2, r3
   141dc:	bf18      	it	ne
   141de:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   141e2:	f2c4 0000 	movt	r0, #16384	; 0x4000
   141e6:	bf14      	ite	ne
   141e8:	2301      	movne	r3, #1
   141ea:	2300      	moveq	r3, #0
   141ec:	42b2      	cmp	r2, r6
   141ee:	bf0c      	ite	eq
   141f0:	2300      	moveq	r3, #0
   141f2:	f003 0301 	andne.w	r3, r3, #1
   141f6:	428a      	cmp	r2, r1
   141f8:	bf0c      	ite	eq
   141fa:	2300      	moveq	r3, #0
   141fc:	f003 0301 	andne.w	r3, r3, #1
   14200:	f44f 6180 	mov.w	r1, #1024	; 0x400
   14204:	4282      	cmp	r2, r0
   14206:	bf0c      	ite	eq
   14208:	2300      	moveq	r3, #0
   1420a:	f003 0301 	andne.w	r3, r3, #1
   1420e:	f2c4 0101 	movt	r1, #16385	; 0x4001
   14212:	428a      	cmp	r2, r1
   14214:	bf0c      	ite	eq
   14216:	2300      	moveq	r3, #0
   14218:	f003 0301 	andne.w	r3, r3, #1
   1421c:	b133      	cbz	r3, 1422c <HAL_TIM_ConfigClockSource+0x4d0>
   1421e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   14222:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14226:	429a      	cmp	r2, r3
   14228:	f040 80cb 	bne.w	143c2 <HAL_TIM_ConfigClockSource+0x666>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1422c:	686b      	ldr	r3, [r5, #4]
   1422e:	2b0a      	cmp	r3, #10
   14230:	bf18      	it	ne
   14232:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   14236:	d003      	beq.n	14240 <HAL_TIM_ConfigClockSource+0x4e4>
   14238:	f033 0302 	bics.w	r3, r3, #2
   1423c:	f040 80b8 	bne.w	143b0 <HAL_TIM_ConfigClockSource+0x654>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   14240:	68ef      	ldr	r7, [r5, #12]
   14242:	2f0f      	cmp	r7, #15
   14244:	f200 80ed 	bhi.w	14422 <HAL_TIM_ConfigClockSource+0x6c6>
      TIM_TI1_ConfigInputStage(htim->Instance,
   14248:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
   1424a:	f64f 738f 	movw	r3, #65423	; 0xff8f
      TIM_TI1_ConfigInputStage(htim->Instance,
   1424e:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
   14250:	6a16      	ldr	r6, [r2, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
   14252:	f6cf 73cf 	movt	r3, #65487	; 0xffcf
  TIMx->CCER &= ~TIM_CCER_CC1E;
   14256:	6a15      	ldr	r5, [r2, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   14258:	f026 060a 	bic.w	r6, r6, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
   1425c:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
   14260:	4330      	orrs	r0, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
   14262:	6215      	str	r5, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
   14264:	6991      	ldr	r1, [r2, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
   14266:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
   1426a:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1;
   1426e:	6191      	str	r1, [r2, #24]
  TIMx->CCER = tmpccer;
   14270:	6210      	str	r0, [r2, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   14272:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   14274:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   14276:	400b      	ands	r3, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   14278:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
   1427c:	6093      	str	r3, [r2, #8]
   1427e:	e68e      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
  switch (sClockSourceConfig->ClockSource)
   14280:	2b10      	cmp	r3, #16
   14282:	d004      	beq.n	1428e <HAL_TIM_ConfigClockSource+0x532>
   14284:	2b20      	cmp	r3, #32
   14286:	d002      	beq.n	1428e <HAL_TIM_ConfigClockSource+0x532>
   14288:	2b00      	cmp	r3, #0
   1428a:	f47f ae88 	bne.w	13f9e <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   1428e:	2200      	movs	r2, #0
   14290:	6821      	ldr	r1, [r4, #0]
   14292:	f44f 6780 	mov.w	r7, #1024	; 0x400
   14296:	f44f 6000 	mov.w	r0, #2048	; 0x800
   1429a:	f2c4 0201 	movt	r2, #16385	; 0x4001
   1429e:	f44f 6640 	mov.w	r6, #3072	; 0xc00
   142a2:	f2c4 0700 	movt	r7, #16384	; 0x4000
   142a6:	f2c4 0000 	movt	r0, #16384	; 0x4000
   142aa:	4291      	cmp	r1, r2
   142ac:	bf18      	it	ne
   142ae:	f1b1 4f80 	cmpne.w	r1, #1073741824	; 0x40000000
   142b2:	f2c4 0600 	movt	r6, #16384	; 0x4000
   142b6:	bf14      	ite	ne
   142b8:	2201      	movne	r2, #1
   142ba:	2200      	moveq	r2, #0
   142bc:	42b9      	cmp	r1, r7
   142be:	bf0c      	ite	eq
   142c0:	2200      	moveq	r2, #0
   142c2:	f002 0201 	andne.w	r2, r2, #1
   142c6:	4281      	cmp	r1, r0
   142c8:	bf0c      	ite	eq
   142ca:	2200      	moveq	r2, #0
   142cc:	f002 0201 	andne.w	r2, r2, #1
   142d0:	f44f 6080 	mov.w	r0, #1024	; 0x400
   142d4:	42b1      	cmp	r1, r6
   142d6:	bf0c      	ite	eq
   142d8:	2200      	moveq	r2, #0
   142da:	f002 0201 	andne.w	r2, r2, #1
   142de:	f2c4 0001 	movt	r0, #16385	; 0x4001
   142e2:	4281      	cmp	r1, r0
   142e4:	bf0c      	ite	eq
   142e6:	2200      	moveq	r2, #0
   142e8:	f002 0201 	andne.w	r2, r2, #1
   142ec:	b12a      	cbz	r2, 142fa <HAL_TIM_ConfigClockSource+0x59e>
   142ee:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   142f2:	f2c4 0201 	movt	r2, #16385	; 0x4001
   142f6:	4291      	cmp	r1, r2
   142f8:	d16c      	bne.n	143d4 <HAL_TIM_ConfigClockSource+0x678>
  tmpsmcr &= ~TIM_SMCR_TS;
   142fa:	f64f 728f 	movw	r2, #65423	; 0xff8f
  tmpsmcr = TIMx->SMCR;
   142fe:	6888      	ldr	r0, [r1, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   14300:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
   14304:	f6cf 72cf 	movt	r2, #65487	; 0xffcf
   14308:	4002      	ands	r2, r0
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   1430a:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
   1430c:	608b      	str	r3, [r1, #8]
   1430e:	e646      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>
  switch (sClockSourceConfig->ClockSource)
   14310:	2230      	movs	r2, #48	; 0x30
   14312:	f2c0 0210 	movt	r2, #16
   14316:	4293      	cmp	r3, r2
   14318:	d0b9      	beq.n	1428e <HAL_TIM_ConfigClockSource+0x532>
   1431a:	2240      	movs	r2, #64	; 0x40
   1431c:	f2c0 0210 	movt	r2, #16
   14320:	4293      	cmp	r3, r2
   14322:	d0b4      	beq.n	1428e <HAL_TIM_ConfigClockSource+0x532>
   14324:	2220      	movs	r2, #32
   14326:	f2c0 0210 	movt	r2, #16
   1432a:	4293      	cmp	r3, r2
   1432c:	f47f ae37 	bne.w	13f9e <HAL_TIM_ConfigClockSource+0x242>
   14330:	e7ad      	b.n	1428e <HAL_TIM_ConfigClockSource+0x532>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   14332:	f643 2034 	movw	r0, #14900	; 0x3a34
   14336:	f241 21ab 	movw	r1, #4779	; 0x12ab
   1433a:	f2c0 0003 	movt	r0, #3
   1433e:	f006 feb7 	bl	1b0b0 <assert_failed>
   14342:	e6c4      	b.n	140ce <HAL_TIM_ConfigClockSource+0x372>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   14344:	f643 2034 	movw	r0, #14900	; 0x3a34
   14348:	f241 2193 	movw	r1, #4755	; 0x1293
   1434c:	f2c0 0003 	movt	r0, #3
   14350:	f006 feae 	bl	1b0b0 <assert_failed>
   14354:	e70f      	b.n	14176 <HAL_TIM_ConfigClockSource+0x41a>
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   14356:	f643 2034 	movw	r0, #14900	; 0x3a34
   1435a:	f44f 5194 	mov.w	r1, #4736	; 0x1280
   1435e:	f2c0 0003 	movt	r0, #3
   14362:	f006 fea5 	bl	1b0b0 <assert_failed>
   14366:	e518      	b.n	13d9a <HAL_TIM_ConfigClockSource+0x3e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   14368:	f643 2034 	movw	r0, #14900	; 0x3a34
   1436c:	f241 21e2 	movw	r1, #4834	; 0x12e2
   14370:	f2c0 0003 	movt	r0, #3
   14374:	f006 fe9c 	bl	1b0b0 <assert_failed>
   14378:	e56a      	b.n	13e50 <HAL_TIM_ConfigClockSource+0xf4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1437a:	f643 2034 	movw	r0, #14900	; 0x3a34
   1437e:	f241 21d2 	movw	r1, #4818	; 0x12d2
   14382:	f2c0 0003 	movt	r0, #3
   14386:	f006 fe93 	bl	1b0b0 <assert_failed>
   1438a:	e651      	b.n	14030 <HAL_TIM_ConfigClockSource+0x2d4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1438c:	f643 2034 	movw	r0, #14900	; 0x3a34
   14390:	f241 2197 	movw	r1, #4759	; 0x1297
   14394:	f2c0 0003 	movt	r0, #3
   14398:	f006 fe8a 	bl	1b0b0 <assert_failed>
   1439c:	e6fa      	b.n	14194 <HAL_TIM_ConfigClockSource+0x438>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1439e:	f643 2034 	movw	r0, #14900	; 0x3a34
   143a2:	f241 21af 	movw	r1, #4783	; 0x12af
   143a6:	f2c0 0003 	movt	r0, #3
   143aa:	f006 fe81 	bl	1b0b0 <assert_failed>
   143ae:	e69d      	b.n	140ec <HAL_TIM_ConfigClockSource+0x390>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   143b0:	f643 2034 	movw	r0, #14900	; 0x3a34
   143b4:	f241 21c2 	movw	r1, #4802	; 0x12c2
   143b8:	f2c0 0003 	movt	r0, #3
   143bc:	f006 fe78 	bl	1b0b0 <assert_failed>
   143c0:	e73e      	b.n	14240 <HAL_TIM_ConfigClockSource+0x4e4>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   143c2:	f643 2034 	movw	r0, #14900	; 0x3a34
   143c6:	f241 21bf 	movw	r1, #4799	; 0x12bf
   143ca:	f2c0 0003 	movt	r0, #3
   143ce:	f006 fe6f 	bl	1b0b0 <assert_failed>
   143d2:	e72b      	b.n	1422c <HAL_TIM_ConfigClockSource+0x4d0>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   143d4:	f643 2034 	movw	r0, #14900	; 0x3a34
   143d8:	f241 21f7 	movw	r1, #4855	; 0x12f7
   143dc:	f2c0 0003 	movt	r0, #3
   143e0:	f006 fe66 	bl	1b0b0 <assert_failed>
   143e4:	682b      	ldr	r3, [r5, #0]
   143e6:	6821      	ldr	r1, [r4, #0]
   143e8:	e787      	b.n	142fa <HAL_TIM_ConfigClockSource+0x59e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   143ea:	f643 2034 	movw	r0, #14900	; 0x3a34
   143ee:	f241 21cf 	movw	r1, #4815	; 0x12cf
   143f2:	f2c0 0003 	movt	r0, #3
   143f6:	f006 fe5b 	bl	1b0b0 <assert_failed>
   143fa:	e60f      	b.n	1401c <HAL_TIM_ConfigClockSource+0x2c0>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   143fc:	f643 2034 	movw	r0, #14900	; 0x3a34
   14400:	f241 21df 	movw	r1, #4831	; 0x12df
   14404:	f2c0 0003 	movt	r0, #3
   14408:	f006 fe52 	bl	1b0b0 <assert_failed>
   1440c:	e516      	b.n	13e3c <HAL_TIM_ConfigClockSource+0xe0>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   1440e:	f643 2034 	movw	r0, #14900	; 0x3a34
   14412:	f241 21b0 	movw	r1, #4784	; 0x12b0
   14416:	f2c0 0003 	movt	r0, #3
   1441a:	f006 fe49 	bl	1b0b0 <assert_failed>
   1441e:	68e9      	ldr	r1, [r5, #12]
   14420:	e668      	b.n	140f4 <HAL_TIM_ConfigClockSource+0x398>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   14422:	f643 2034 	movw	r0, #14900	; 0x3a34
   14426:	f241 21c3 	movw	r1, #4803	; 0x12c3
   1442a:	f2c0 0003 	movt	r0, #3
   1442e:	f006 fe3f 	bl	1b0b0 <assert_failed>
   14432:	68ef      	ldr	r7, [r5, #12]
   14434:	e708      	b.n	14248 <HAL_TIM_ConfigClockSource+0x4ec>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   14436:	f643 2034 	movw	r0, #14900	; 0x3a34
   1443a:	f241 2198 	movw	r1, #4760	; 0x1298
   1443e:	f2c0 0003 	movt	r0, #3
   14442:	f006 fe35 	bl	1b0b0 <assert_failed>
   14446:	68e9      	ldr	r1, [r5, #12]
   14448:	e6a8      	b.n	1419c <HAL_TIM_ConfigClockSource+0x440>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   1444a:	f643 2034 	movw	r0, #14900	; 0x3a34
   1444e:	f241 21d3 	movw	r1, #4819	; 0x12d3
   14452:	f2c0 0003 	movt	r0, #3
   14456:	f006 fe2b 	bl	1b0b0 <assert_failed>
   1445a:	68ee      	ldr	r6, [r5, #12]
   1445c:	e5ec      	b.n	14038 <HAL_TIM_ConfigClockSource+0x2dc>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   1445e:	f643 2034 	movw	r0, #14900	; 0x3a34
   14462:	f241 21e3 	movw	r1, #4835	; 0x12e3
   14466:	f2c0 0003 	movt	r0, #3
   1446a:	f006 fe21 	bl	1b0b0 <assert_failed>
   1446e:	68ef      	ldr	r7, [r5, #12]
   14470:	e4f2      	b.n	13e58 <HAL_TIM_ConfigClockSource+0xfc>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   14472:	f643 2034 	movw	r0, #14900	; 0x3a34
   14476:	f241 21ae 	movw	r1, #4782	; 0x12ae
   1447a:	f2c0 0003 	movt	r0, #3
   1447e:	f006 fe17 	bl	1b0b0 <assert_failed>
   14482:	e629      	b.n	140d8 <HAL_TIM_ConfigClockSource+0x37c>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   14484:	f643 2034 	movw	r0, #14900	; 0x3a34
   14488:	f241 2196 	movw	r1, #4758	; 0x1296
   1448c:	f2c0 0003 	movt	r0, #3
   14490:	f006 fe0e 	bl	1b0b0 <assert_failed>
   14494:	e674      	b.n	14180 <HAL_TIM_ConfigClockSource+0x424>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
   14496:	f643 2034 	movw	r0, #14900	; 0x3a34
   1449a:	f241 218c 	movw	r1, #4748	; 0x128c
   1449e:	f2c0 0003 	movt	r0, #3
   144a2:	f006 fe05 	bl	1b0b0 <assert_failed>
   144a6:	e57a      	b.n	13f9e <HAL_TIM_ConfigClockSource+0x242>

000144a8 <TIM_OC2_SetConfig>:
{
   144a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
   144ac:	6a02      	ldr	r2, [r0, #32]
{
   144ae:	460f      	mov	r7, r1
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   144b0:	f648 43ff 	movw	r3, #36095	; 0x8cff
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   144b4:	2100      	movs	r1, #0
  TIMx->CCER &= ~TIM_CCER_CC2E;
   144b6:	f022 0210 	bic.w	r2, r2, #16
{
   144ba:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   144bc:	f6cf 63ff 	movt	r3, #65279	; 0xfeff
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   144c0:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC2E;
   144c4:	6202      	str	r2, [r0, #32]
  tmpccer = TIMx->CCER;
   144c6:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   144c8:	428c      	cmp	r4, r1
  tmpcr2 =  TIMx->CR2;
   144ca:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
   144ce:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
   144d0:	f025 0520 	bic.w	r5, r5, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
   144d4:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   144d6:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= (OC_Config->OCMode << 8U);
   144da:	683e      	ldr	r6, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
   144dc:	ea45 1502 	orr.w	r5, r5, r2, lsl #4
  tmpccmrx |= (OC_Config->OCMode << 8U);
   144e0:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   144e4:	d02e      	beq.n	14544 <TIM_OC2_SetConfig+0x9c>
   144e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
   144ea:	f2c4 0301 	movt	r3, #16385	; 0x4001
   144ee:	429c      	cmp	r4, r3
   144f0:	d028      	beq.n	14544 <TIM_OC2_SetConfig+0x9c>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   144f2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   144f6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   144fa:	f2c4 0201 	movt	r2, #16385	; 0x4001
   144fe:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14502:	429c      	cmp	r4, r3
   14504:	bf18      	it	ne
   14506:	4294      	cmpne	r4, r2
   14508:	d005      	beq.n	14516 <TIM_OC2_SetConfig+0x6e>
   1450a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   1450e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14512:	429c      	cmp	r4, r3
   14514:	d10e      	bne.n	14534 <TIM_OC2_SetConfig+0x8c>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   14516:	69bb      	ldr	r3, [r7, #24]
   14518:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1451c:	d120      	bne.n	14560 <TIM_OC2_SetConfig+0xb8>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1451e:	697b      	ldr	r3, [r7, #20]
   14520:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   14524:	d128      	bne.n	14578 <TIM_OC2_SetConfig+0xd0>
    tmpcr2 &= ~TIM_CR2_OIS2N;
   14526:	f428 6840 	bic.w	r8, r8, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   1452a:	69ba      	ldr	r2, [r7, #24]
   1452c:	ea48 0882 	orr.w	r8, r8, r2, lsl #2
   14530:	ea48 0883 	orr.w	r8, r8, r3, lsl #2
  TIMx->CR2 = tmpcr2;
   14534:	f8c4 8004 	str.w	r8, [r4, #4]
  TIMx->CCMR1 = tmpccmrx;
   14538:	61a6      	str	r6, [r4, #24]
  TIMx->CCR2 = OC_Config->Pulse;
   1453a:	687b      	ldr	r3, [r7, #4]
   1453c:	63a3      	str	r3, [r4, #56]	; 0x38
  TIMx->CCER = tmpccer;
   1453e:	6225      	str	r5, [r4, #32]
}
   14540:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   14544:	68fb      	ldr	r3, [r7, #12]
   14546:	f033 0208 	bics.w	r2, r3, #8
   1454a:	d11f      	bne.n	1458c <TIM_OC2_SetConfig+0xe4>
    tmpccer &= ~TIM_CCER_CC2NP;
   1454c:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
   14550:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
   14554:	f025 0540 	bic.w	r5, r5, #64	; 0x40
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   14558:	69bb      	ldr	r3, [r7, #24]
   1455a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1455e:	d0de      	beq.n	1451e <TIM_OC2_SetConfig+0x76>
   14560:	f643 2034 	movw	r0, #14900	; 0x3a34
   14564:	f641 015f 	movw	r1, #6239	; 0x185f
   14568:	f2c0 0003 	movt	r0, #3
   1456c:	f006 fda0 	bl	1b0b0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   14570:	697b      	ldr	r3, [r7, #20]
   14572:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   14576:	d0d6      	beq.n	14526 <TIM_OC2_SetConfig+0x7e>
   14578:	f643 2034 	movw	r0, #14900	; 0x3a34
   1457c:	f44f 51c3 	mov.w	r1, #6240	; 0x1860
   14580:	f2c0 0003 	movt	r0, #3
   14584:	f006 fd94 	bl	1b0b0 <assert_failed>
   14588:	697b      	ldr	r3, [r7, #20]
   1458a:	e7cc      	b.n	14526 <TIM_OC2_SetConfig+0x7e>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   1458c:	f643 2034 	movw	r0, #14900	; 0x3a34
   14590:	f641 0151 	movw	r1, #6225	; 0x1851
    tmpccer &= ~TIM_CCER_CC2NP;
   14594:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   14598:	f2c0 0003 	movt	r0, #3
   1459c:	f006 fd88 	bl	1b0b0 <assert_failed>
   145a0:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
   145a2:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
   145a6:	f025 0540 	bic.w	r5, r5, #64	; 0x40
   145aa:	e7d5      	b.n	14558 <TIM_OC2_SetConfig+0xb0>

000145ac <HAL_TIM_PWM_ConfigChannel>:
  assert_param(IS_TIM_CHANNELS(Channel));
   145ac:	2a14      	cmp	r2, #20
{
   145ae:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   145b2:	4616      	mov	r6, r2
   145b4:	4604      	mov	r4, r0
   145b6:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
   145b8:	f240 80c1 	bls.w	1473e <HAL_TIM_PWM_ConfigChannel+0x192>
   145bc:	2a3c      	cmp	r2, #60	; 0x3c
   145be:	f040 80c6 	bne.w	1474e <HAL_TIM_PWM_ConfigChannel+0x1a2>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   145c2:	682a      	ldr	r2, [r5, #0]
   145c4:	2340      	movs	r3, #64	; 0x40
   145c6:	f022 0110 	bic.w	r1, r2, #16
   145ca:	f2c0 0301 	movt	r3, #1
   145ce:	4299      	cmp	r1, r3
   145d0:	d007      	beq.n	145e2 <HAL_TIM_PWM_ConfigChannel+0x36>
   145d2:	f64f 73ef 	movw	r3, #65519	; 0xffef
   145d6:	f6cf 73fe 	movt	r3, #65534	; 0xfffe
   145da:	4013      	ands	r3, r2
   145dc:	2b60      	cmp	r3, #96	; 0x60
   145de:	f040 829d 	bne.w	14b1c <HAL_TIM_PWM_ConfigChannel+0x570>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   145e2:	68ab      	ldr	r3, [r5, #8]
   145e4:	f033 0302 	bics.w	r3, r3, #2
   145e8:	f040 80ba 	bne.w	14760 <HAL_TIM_PWM_ConfigChannel+0x1b4>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   145ec:	692b      	ldr	r3, [r5, #16]
   145ee:	f033 0304 	bics.w	r3, r3, #4
   145f2:	f040 80c2 	bne.w	1477a <HAL_TIM_PWM_ConfigChannel+0x1ce>
  __HAL_LOCK(htim);
   145f6:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   145fa:	2b01      	cmp	r3, #1
   145fc:	f000 80ca 	beq.w	14794 <HAL_TIM_PWM_ConfigChannel+0x1e8>
   14600:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
   14602:	2302      	movs	r3, #2
  __HAL_LOCK(htim);
   14604:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
   14608:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  switch (Channel)
   1460c:	2e14      	cmp	r6, #20
   1460e:	f200 808d 	bhi.w	1472c <HAL_TIM_PWM_ConfigChannel+0x180>
   14612:	e8df f016 	tbh	[pc, r6, lsl #1]
   14616:	0015      	.short	0x0015
   14618:	008b008b 	.word	0x008b008b
   1461c:	00c2008b 	.word	0x00c2008b
   14620:	008b008b 	.word	0x008b008b
   14624:	0116008b 	.word	0x0116008b
   14628:	008b008b 	.word	0x008b008b
   1462c:	0157008b 	.word	0x0157008b
   14630:	008b008b 	.word	0x008b008b
   14634:	01d5008b 	.word	0x01d5008b
   14638:	008b008b 	.word	0x008b008b
   1463c:	022c008b 	.word	0x022c008b
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   14640:	2300      	movs	r3, #0
   14642:	6820      	ldr	r0, [r4, #0]
   14644:	f44f 6680 	mov.w	r6, #1024	; 0x400
   14648:	f44f 6200 	mov.w	r2, #2048	; 0x800
   1464c:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14650:	f44f 6140 	mov.w	r1, #3072	; 0xc00
   14654:	f2c4 0600 	movt	r6, #16384	; 0x4000
   14658:	f2c4 0200 	movt	r2, #16384	; 0x4000
   1465c:	4298      	cmp	r0, r3
   1465e:	bf18      	it	ne
   14660:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   14664:	f2c4 0100 	movt	r1, #16384	; 0x4000
   14668:	bf14      	ite	ne
   1466a:	2301      	movne	r3, #1
   1466c:	2300      	moveq	r3, #0
   1466e:	42b0      	cmp	r0, r6
   14670:	bf0c      	ite	eq
   14672:	2300      	moveq	r3, #0
   14674:	f003 0301 	andne.w	r3, r3, #1
   14678:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
   1467c:	4290      	cmp	r0, r2
   1467e:	bf0c      	ite	eq
   14680:	2300      	moveq	r3, #0
   14682:	f003 0301 	andne.w	r3, r3, #1
   14686:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1468a:	f2c4 0600 	movt	r6, #16384	; 0x4000
   1468e:	4288      	cmp	r0, r1
   14690:	bf0c      	ite	eq
   14692:	2300      	moveq	r3, #0
   14694:	f003 0301 	andne.w	r3, r3, #1
   14698:	f2c4 0201 	movt	r2, #16385	; 0x4001
   1469c:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
   146a0:	4290      	cmp	r0, r2
   146a2:	bf0c      	ite	eq
   146a4:	2300      	moveq	r3, #0
   146a6:	f003 0301 	andne.w	r3, r3, #1
   146aa:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   146ae:	f2c4 0100 	movt	r1, #16384	; 0x4000
   146b2:	42b0      	cmp	r0, r6
   146b4:	bf0c      	ite	eq
   146b6:	2300      	moveq	r3, #0
   146b8:	f003 0301 	andne.w	r3, r3, #1
   146bc:	f2c4 0200 	movt	r2, #16384	; 0x4000
   146c0:	4288      	cmp	r0, r1
   146c2:	bf0c      	ite	eq
   146c4:	2300      	moveq	r3, #0
   146c6:	f003 0301 	andne.w	r3, r3, #1
   146ca:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   146ce:	4290      	cmp	r0, r2
   146d0:	bf0c      	ite	eq
   146d2:	2300      	moveq	r3, #0
   146d4:	f003 0301 	andne.w	r3, r3, #1
   146d8:	f2c4 0101 	movt	r1, #16385	; 0x4001
   146dc:	f44f 4288 	mov.w	r2, #17408	; 0x4400
   146e0:	4288      	cmp	r0, r1
   146e2:	bf0c      	ite	eq
   146e4:	2300      	moveq	r3, #0
   146e6:	f003 0301 	andne.w	r3, r3, #1
   146ea:	f2c4 0201 	movt	r2, #16385	; 0x4001
   146ee:	4290      	cmp	r0, r2
   146f0:	bf0c      	ite	eq
   146f2:	2300      	moveq	r3, #0
   146f4:	f003 0301 	andne.w	r3, r3, #1
   146f8:	b133      	cbz	r3, 14708 <HAL_TIM_PWM_ConfigChannel+0x15c>
   146fa:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   146fe:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14702:	4298      	cmp	r0, r3
   14704:	f040 824f 	bne.w	14ba6 <HAL_TIM_PWM_ConfigChannel+0x5fa>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
   14708:	4629      	mov	r1, r5
   1470a:	f7fe fe41 	bl	13390 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   1470e:	6822      	ldr	r2, [r4, #0]
   14710:	6993      	ldr	r3, [r2, #24]
   14712:	f043 0308 	orr.w	r3, r3, #8
   14716:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   14718:	6822      	ldr	r2, [r4, #0]
   1471a:	6993      	ldr	r3, [r2, #24]
   1471c:	f023 0304 	bic.w	r3, r3, #4
   14720:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
   14722:	6822      	ldr	r2, [r4, #0]
   14724:	6929      	ldr	r1, [r5, #16]
   14726:	6993      	ldr	r3, [r2, #24]
   14728:	430b      	orrs	r3, r1
   1472a:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
   1472c:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   1472e:	2201      	movs	r2, #1
  return HAL_OK;
   14730:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   14732:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   14736:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   1473a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_TIM_CHANNELS(Channel));
   1473e:	f241 1311 	movw	r3, #4369	; 0x1111
   14742:	f2c0 0311 	movt	r3, #17
   14746:	40d3      	lsrs	r3, r2
   14748:	07db      	lsls	r3, r3, #31
   1474a:	f53f af3a 	bmi.w	145c2 <HAL_TIM_PWM_ConfigChannel+0x16>
   1474e:	f643 2034 	movw	r0, #14900	; 0x3a34
   14752:	f640 611c 	movw	r1, #3612	; 0xe1c
   14756:	f2c0 0003 	movt	r0, #3
   1475a:	f006 fca9 	bl	1b0b0 <assert_failed>
   1475e:	e730      	b.n	145c2 <HAL_TIM_PWM_ConfigChannel+0x16>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   14760:	f643 2034 	movw	r0, #14900	; 0x3a34
   14764:	f640 611e 	movw	r1, #3614	; 0xe1e
   14768:	f2c0 0003 	movt	r0, #3
   1476c:	f006 fca0 	bl	1b0b0 <assert_failed>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   14770:	692b      	ldr	r3, [r5, #16]
   14772:	f033 0304 	bics.w	r3, r3, #4
   14776:	f43f af3e 	beq.w	145f6 <HAL_TIM_PWM_ConfigChannel+0x4a>
   1477a:	f643 2034 	movw	r0, #14900	; 0x3a34
   1477e:	f640 611f 	movw	r1, #3615	; 0xe1f
   14782:	f2c0 0003 	movt	r0, #3
   14786:	f006 fc93 	bl	1b0b0 <assert_failed>
  __HAL_LOCK(htim);
   1478a:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1478e:	2b01      	cmp	r3, #1
   14790:	f47f af36 	bne.w	14600 <HAL_TIM_PWM_ConfigChannel+0x54>
   14794:	2002      	movs	r0, #2
}
   14796:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   1479a:	2300      	movs	r3, #0
   1479c:	6820      	ldr	r0, [r4, #0]
   1479e:	f44f 6680 	mov.w	r6, #1024	; 0x400
   147a2:	f44f 6100 	mov.w	r1, #2048	; 0x800
   147a6:	f2c4 0301 	movt	r3, #16385	; 0x4001
   147aa:	f44f 6240 	mov.w	r2, #3072	; 0xc00
   147ae:	f2c4 0600 	movt	r6, #16384	; 0x4000
   147b2:	f2c4 0100 	movt	r1, #16384	; 0x4000
   147b6:	4298      	cmp	r0, r3
   147b8:	bf18      	it	ne
   147ba:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   147be:	f2c4 0200 	movt	r2, #16384	; 0x4000
   147c2:	bf14      	ite	ne
   147c4:	2301      	movne	r3, #1
   147c6:	2300      	moveq	r3, #0
   147c8:	42b0      	cmp	r0, r6
   147ca:	bf0c      	ite	eq
   147cc:	2300      	moveq	r3, #0
   147ce:	f003 0301 	andne.w	r3, r3, #1
   147d2:	4288      	cmp	r0, r1
   147d4:	bf0c      	ite	eq
   147d6:	2300      	moveq	r3, #0
   147d8:	f003 0301 	andne.w	r3, r3, #1
   147dc:	f44f 6180 	mov.w	r1, #1024	; 0x400
   147e0:	4290      	cmp	r0, r2
   147e2:	bf0c      	ite	eq
   147e4:	2300      	moveq	r3, #0
   147e6:	f003 0301 	andne.w	r3, r3, #1
   147ea:	f2c4 0101 	movt	r1, #16385	; 0x4001
   147ee:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
   147f2:	4288      	cmp	r0, r1
   147f4:	bf0c      	ite	eq
   147f6:	2300      	moveq	r3, #0
   147f8:	f003 0301 	andne.w	r3, r3, #1
   147fc:	f2c4 0200 	movt	r2, #16384	; 0x4000
   14800:	4290      	cmp	r0, r2
   14802:	bf0c      	ite	eq
   14804:	2300      	moveq	r3, #0
   14806:	f003 0301 	andne.w	r3, r3, #1
   1480a:	b133      	cbz	r3, 1481a <HAL_TIM_PWM_ConfigChannel+0x26e>
   1480c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   14810:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14814:	4298      	cmp	r0, r3
   14816:	f040 81bc 	bne.w	14b92 <HAL_TIM_PWM_ConfigChannel+0x5e6>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
   1481a:	4629      	mov	r1, r5
   1481c:	f7ff fe44 	bl	144a8 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   14820:	6822      	ldr	r2, [r4, #0]
   14822:	6993      	ldr	r3, [r2, #24]
   14824:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   14828:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   1482a:	6822      	ldr	r2, [r4, #0]
   1482c:	6993      	ldr	r3, [r2, #24]
   1482e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   14832:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   14834:	6822      	ldr	r2, [r4, #0]
   14836:	6929      	ldr	r1, [r5, #16]
   14838:	6993      	ldr	r3, [r2, #24]
   1483a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   1483e:	6193      	str	r3, [r2, #24]
      break;
   14840:	e774      	b.n	1472c <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   14842:	2300      	movs	r3, #0
   14844:	6820      	ldr	r0, [r4, #0]
   14846:	f44f 6680 	mov.w	r6, #1024	; 0x400
   1484a:	f44f 6100 	mov.w	r1, #2048	; 0x800
   1484e:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14852:	f44f 6240 	mov.w	r2, #3072	; 0xc00
   14856:	f2c4 0600 	movt	r6, #16384	; 0x4000
   1485a:	f2c4 0100 	movt	r1, #16384	; 0x4000
   1485e:	4298      	cmp	r0, r3
   14860:	bf18      	it	ne
   14862:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   14866:	f2c4 0200 	movt	r2, #16384	; 0x4000
   1486a:	bf14      	ite	ne
   1486c:	2301      	movne	r3, #1
   1486e:	2300      	moveq	r3, #0
   14870:	42b0      	cmp	r0, r6
   14872:	bf0c      	ite	eq
   14874:	2300      	moveq	r3, #0
   14876:	f003 0301 	andne.w	r3, r3, #1
   1487a:	4288      	cmp	r0, r1
   1487c:	bf0c      	ite	eq
   1487e:	2300      	moveq	r3, #0
   14880:	f003 0301 	andne.w	r3, r3, #1
   14884:	4290      	cmp	r0, r2
   14886:	bf0c      	ite	eq
   14888:	2300      	moveq	r3, #0
   1488a:	f003 0301 	andne.w	r3, r3, #1
   1488e:	b133      	cbz	r3, 1489e <HAL_TIM_PWM_ConfigChannel+0x2f2>
   14890:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14894:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14898:	4298      	cmp	r0, r3
   1489a:	f040 8170 	bne.w	14b7e <HAL_TIM_PWM_ConfigChannel+0x5d2>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
   1489e:	4629      	mov	r1, r5
   148a0:	f7fe fe16 	bl	134d0 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   148a4:	6822      	ldr	r2, [r4, #0]
   148a6:	69d3      	ldr	r3, [r2, #28]
   148a8:	f043 0308 	orr.w	r3, r3, #8
   148ac:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   148ae:	6822      	ldr	r2, [r4, #0]
   148b0:	69d3      	ldr	r3, [r2, #28]
   148b2:	f023 0304 	bic.w	r3, r3, #4
   148b6:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
   148b8:	6822      	ldr	r2, [r4, #0]
   148ba:	6929      	ldr	r1, [r5, #16]
   148bc:	69d3      	ldr	r3, [r2, #28]
   148be:	430b      	orrs	r3, r1
   148c0:	61d3      	str	r3, [r2, #28]
      break;
   148c2:	e733      	b.n	1472c <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   148c4:	2300      	movs	r3, #0
   148c6:	6826      	ldr	r6, [r4, #0]
   148c8:	f44f 6080 	mov.w	r0, #1024	; 0x400
   148cc:	f44f 6100 	mov.w	r1, #2048	; 0x800
   148d0:	f2c4 0301 	movt	r3, #16385	; 0x4001
   148d4:	f44f 6240 	mov.w	r2, #3072	; 0xc00
   148d8:	f2c4 0000 	movt	r0, #16384	; 0x4000
   148dc:	f2c4 0100 	movt	r1, #16384	; 0x4000
   148e0:	429e      	cmp	r6, r3
   148e2:	bf18      	it	ne
   148e4:	f1b6 4f80 	cmpne.w	r6, #1073741824	; 0x40000000
   148e8:	f2c4 0200 	movt	r2, #16384	; 0x4000
   148ec:	bf14      	ite	ne
   148ee:	2301      	movne	r3, #1
   148f0:	2300      	moveq	r3, #0
   148f2:	4286      	cmp	r6, r0
   148f4:	bf0c      	ite	eq
   148f6:	2300      	moveq	r3, #0
   148f8:	f003 0301 	andne.w	r3, r3, #1
   148fc:	428e      	cmp	r6, r1
   148fe:	bf0c      	ite	eq
   14900:	2300      	moveq	r3, #0
   14902:	f003 0301 	andne.w	r3, r3, #1
   14906:	4296      	cmp	r6, r2
   14908:	bf0c      	ite	eq
   1490a:	2300      	moveq	r3, #0
   1490c:	f003 0301 	andne.w	r3, r3, #1
   14910:	b133      	cbz	r3, 14920 <HAL_TIM_PWM_ConfigChannel+0x374>
   14912:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14916:	f2c4 0301 	movt	r3, #16385	; 0x4001
   1491a:	429e      	cmp	r6, r3
   1491c:	f040 8125 	bne.w	14b6a <HAL_TIM_PWM_ConfigChannel+0x5be>
  TIMx->CCER &= ~TIM_CCER_CC4E;
   14920:	6a33      	ldr	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14922:	2100      	movs	r1, #0
  TIMx->CCER &= ~TIM_CCER_CC4E;
   14924:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14928:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC4E;
   1492c:	6233      	str	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1492e:	428e      	cmp	r6, r1
  tmpccer = TIMx->CCER;
   14930:	6a33      	ldr	r3, [r6, #32]
  tmpcr2 =  TIMx->CR2;
   14932:	f8d6 9004 	ldr.w	r9, [r6, #4]
  tmpccmrx = TIMx->CCMR2;
   14936:	69f7      	ldr	r7, [r6, #28]
  tmpccer &= ~TIM_CCER_CC4P;
   14938:	f423 5800 	bic.w	r8, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
   1493c:	68aa      	ldr	r2, [r5, #8]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
   1493e:	f427 47e6 	bic.w	r7, r7, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
   14942:	682b      	ldr	r3, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
   14944:	ea48 3802 	orr.w	r8, r8, r2, lsl #12
  tmpccmrx |= (OC_Config->OCMode << 8U);
   14948:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1494c:	d017      	beq.n	1497e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   1494e:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14952:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14956:	429e      	cmp	r6, r3
   14958:	d011      	beq.n	1497e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   1495a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1495e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
   14962:	f2c4 0201 	movt	r2, #16385	; 0x4001
   14966:	f2c4 0301 	movt	r3, #16385	; 0x4001
   1496a:	429e      	cmp	r6, r3
   1496c:	bf18      	it	ne
   1496e:	4296      	cmpne	r6, r2
   14970:	d005      	beq.n	1497e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   14972:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   14976:	f2c4 0301 	movt	r3, #16385	; 0x4001
   1497a:	429e      	cmp	r6, r3
   1497c:	d108      	bne.n	14990 <HAL_TIM_PWM_ConfigChannel+0x3e4>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1497e:	696b      	ldr	r3, [r5, #20]
   14980:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   14984:	f040 80e7 	bne.w	14b56 <HAL_TIM_PWM_ConfigChannel+0x5aa>
    tmpcr2 &= ~TIM_CR2_OIS4;
   14988:	f429 4980 	bic.w	r9, r9, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
   1498c:	ea49 1983 	orr.w	r9, r9, r3, lsl #6
  TIMx->CR2 = tmpcr2;
   14990:	f8c6 9004 	str.w	r9, [r6, #4]
  TIMx->CCMR2 = tmpccmrx;
   14994:	61f7      	str	r7, [r6, #28]
  TIMx->CCR4 = OC_Config->Pulse;
   14996:	686b      	ldr	r3, [r5, #4]
   14998:	6433      	str	r3, [r6, #64]	; 0x40
  TIMx->CCER = tmpccer;
   1499a:	f8c6 8020 	str.w	r8, [r6, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   1499e:	6822      	ldr	r2, [r4, #0]
   149a0:	69d3      	ldr	r3, [r2, #28]
   149a2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   149a6:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   149a8:	6822      	ldr	r2, [r4, #0]
   149aa:	69d3      	ldr	r3, [r2, #28]
   149ac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   149b0:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   149b2:	6822      	ldr	r2, [r4, #0]
   149b4:	6929      	ldr	r1, [r5, #16]
   149b6:	69d3      	ldr	r3, [r2, #28]
   149b8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   149bc:	61d3      	str	r3, [r2, #28]
      break;
   149be:	e6b5      	b.n	1472c <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   149c0:	2200      	movs	r2, #0
   149c2:	6823      	ldr	r3, [r4, #0]
   149c4:	f2c4 0201 	movt	r2, #16385	; 0x4001
   149c8:	4293      	cmp	r3, r2
   149ca:	d006      	beq.n	149da <HAL_TIM_PWM_ConfigChannel+0x42e>
   149cc:	f44f 6280 	mov.w	r2, #1024	; 0x400
   149d0:	f2c4 0201 	movt	r2, #16385	; 0x4001
   149d4:	4293      	cmp	r3, r2
   149d6:	f040 80b4 	bne.w	14b42 <HAL_TIM_PWM_ConfigChannel+0x596>
  TIMx->CCER &= ~TIM_CCER_CC5E;
   149da:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   149dc:	2700      	movs	r7, #0
  TIMx->CCER &= ~TIM_CCER_CC5E;
   149de:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   149e2:	f2c4 0701 	movt	r7, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC5E;
   149e6:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   149e8:	42bb      	cmp	r3, r7
  tmpccer = TIMx->CCER;
   149ea:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
   149ec:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
   149f0:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= ~TIM_CCER_CC5P;
   149f2:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
   149f6:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
   149f8:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
   149fc:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
   149fe:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  tmpccmrx |= OC_Config->OCMode;
   14a02:	ea41 0100 	orr.w	r1, r1, r0
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14a06:	d017      	beq.n	14a38 <HAL_TIM_PWM_ConfigChannel+0x48c>
   14a08:	f44f 6080 	mov.w	r0, #1024	; 0x400
   14a0c:	f2c4 0001 	movt	r0, #16385	; 0x4001
   14a10:	4283      	cmp	r3, r0
   14a12:	d011      	beq.n	14a38 <HAL_TIM_PWM_ConfigChannel+0x48c>
   14a14:	f44f 4680 	mov.w	r6, #16384	; 0x4000
   14a18:	f44f 4088 	mov.w	r0, #17408	; 0x4400
   14a1c:	f2c4 0601 	movt	r6, #16385	; 0x4001
   14a20:	f2c4 0001 	movt	r0, #16385	; 0x4001
   14a24:	4283      	cmp	r3, r0
   14a26:	bf18      	it	ne
   14a28:	42b3      	cmpne	r3, r6
   14a2a:	d005      	beq.n	14a38 <HAL_TIM_PWM_ConfigChannel+0x48c>
   14a2c:	f44f 4090 	mov.w	r0, #18432	; 0x4800
   14a30:	f2c4 0001 	movt	r0, #16385	; 0x4001
   14a34:	4283      	cmp	r3, r0
   14a36:	d104      	bne.n	14a42 <HAL_TIM_PWM_ConfigChannel+0x496>
    tmpcr2 &= ~TIM_CR2_OIS5;
   14a38:	f42c 3c80 	bic.w	ip, ip, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
   14a3c:	6968      	ldr	r0, [r5, #20]
   14a3e:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
  TIMx->CR2 = tmpcr2;
   14a42:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
   14a46:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
   14a48:	6869      	ldr	r1, [r5, #4]
   14a4a:	6599      	str	r1, [r3, #88]	; 0x58
  TIMx->CCER = tmpccer;
   14a4c:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   14a4e:	6822      	ldr	r2, [r4, #0]
   14a50:	6d53      	ldr	r3, [r2, #84]	; 0x54
   14a52:	f043 0308 	orr.w	r3, r3, #8
   14a56:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   14a58:	6822      	ldr	r2, [r4, #0]
   14a5a:	6d53      	ldr	r3, [r2, #84]	; 0x54
   14a5c:	f023 0304 	bic.w	r3, r3, #4
   14a60:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
   14a62:	6822      	ldr	r2, [r4, #0]
   14a64:	6929      	ldr	r1, [r5, #16]
   14a66:	6d53      	ldr	r3, [r2, #84]	; 0x54
   14a68:	430b      	orrs	r3, r1
   14a6a:	6553      	str	r3, [r2, #84]	; 0x54
      break;
   14a6c:	e65e      	b.n	1472c <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   14a6e:	2200      	movs	r2, #0
   14a70:	6823      	ldr	r3, [r4, #0]
   14a72:	f2c4 0201 	movt	r2, #16385	; 0x4001
   14a76:	4293      	cmp	r3, r2
   14a78:	d005      	beq.n	14a86 <HAL_TIM_PWM_ConfigChannel+0x4da>
   14a7a:	f44f 6280 	mov.w	r2, #1024	; 0x400
   14a7e:	f2c4 0201 	movt	r2, #16385	; 0x4001
   14a82:	4293      	cmp	r3, r2
   14a84:	d153      	bne.n	14b2e <HAL_TIM_PWM_ConfigChannel+0x582>
  TIMx->CCER &= ~TIM_CCER_CC6E;
   14a86:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14a88:	2700      	movs	r7, #0
  TIMx->CCER &= ~TIM_CCER_CC6E;
   14a8a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14a8e:	f2c4 0701 	movt	r7, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC6E;
   14a92:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14a94:	42bb      	cmp	r3, r7
  tmpccer = TIMx->CCER;
   14a96:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
   14a98:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
   14a9c:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   14a9e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
   14aa2:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
   14aa4:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
   14aa8:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
   14aaa:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  tmpccmrx |= (OC_Config->OCMode << 8U);
   14aae:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   14ab2:	d017      	beq.n	14ae4 <HAL_TIM_PWM_ConfigChannel+0x538>
   14ab4:	f44f 6080 	mov.w	r0, #1024	; 0x400
   14ab8:	f2c4 0001 	movt	r0, #16385	; 0x4001
   14abc:	4283      	cmp	r3, r0
   14abe:	d011      	beq.n	14ae4 <HAL_TIM_PWM_ConfigChannel+0x538>
   14ac0:	f44f 4680 	mov.w	r6, #16384	; 0x4000
   14ac4:	f44f 4088 	mov.w	r0, #17408	; 0x4400
   14ac8:	f2c4 0601 	movt	r6, #16385	; 0x4001
   14acc:	f2c4 0001 	movt	r0, #16385	; 0x4001
   14ad0:	4283      	cmp	r3, r0
   14ad2:	bf18      	it	ne
   14ad4:	42b3      	cmpne	r3, r6
   14ad6:	d005      	beq.n	14ae4 <HAL_TIM_PWM_ConfigChannel+0x538>
   14ad8:	f44f 4090 	mov.w	r0, #18432	; 0x4800
   14adc:	f2c4 0001 	movt	r0, #16385	; 0x4001
   14ae0:	4283      	cmp	r3, r0
   14ae2:	d104      	bne.n	14aee <HAL_TIM_PWM_ConfigChannel+0x542>
    tmpcr2 &= ~TIM_CR2_OIS6;
   14ae4:	f42c 3c00 	bic.w	ip, ip, #131072	; 0x20000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
   14ae8:	6968      	ldr	r0, [r5, #20]
   14aea:	ea4c 2c80 	orr.w	ip, ip, r0, lsl #10
  TIMx->CR2 = tmpcr2;
   14aee:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
   14af2:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
   14af4:	6869      	ldr	r1, [r5, #4]
   14af6:	65d9      	str	r1, [r3, #92]	; 0x5c
  TIMx->CCER = tmpccer;
   14af8:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   14afa:	6822      	ldr	r2, [r4, #0]
   14afc:	6d53      	ldr	r3, [r2, #84]	; 0x54
   14afe:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   14b02:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   14b04:	6822      	ldr	r2, [r4, #0]
   14b06:	6d53      	ldr	r3, [r2, #84]	; 0x54
   14b08:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   14b0c:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
   14b0e:	6822      	ldr	r2, [r4, #0]
   14b10:	6929      	ldr	r1, [r5, #16]
   14b12:	6d53      	ldr	r3, [r2, #84]	; 0x54
   14b14:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   14b18:	6553      	str	r3, [r2, #84]	; 0x54
      break;
   14b1a:	e607      	b.n	1472c <HAL_TIM_PWM_ConfigChannel+0x180>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   14b1c:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b20:	f640 611d 	movw	r1, #3613	; 0xe1d
   14b24:	f2c0 0003 	movt	r0, #3
   14b28:	f006 fac2 	bl	1b0b0 <assert_failed>
   14b2c:	e559      	b.n	145e2 <HAL_TIM_PWM_ConfigChannel+0x36>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   14b2e:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b32:	f44f 6168 	mov.w	r1, #3712	; 0xe80
   14b36:	f2c0 0003 	movt	r0, #3
   14b3a:	f006 fab9 	bl	1b0b0 <assert_failed>
   14b3e:	6823      	ldr	r3, [r4, #0]
   14b40:	e7a1      	b.n	14a86 <HAL_TIM_PWM_ConfigChannel+0x4da>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   14b42:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b46:	f640 616f 	movw	r1, #3695	; 0xe6f
   14b4a:	f2c0 0003 	movt	r0, #3
   14b4e:	f006 faaf 	bl	1b0b0 <assert_failed>
   14b52:	6823      	ldr	r3, [r4, #0]
   14b54:	e741      	b.n	149da <HAL_TIM_PWM_ConfigChannel+0x42e>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   14b56:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b5a:	f641 01e8 	movw	r1, #6376	; 0x18e8
   14b5e:	f2c0 0003 	movt	r0, #3
   14b62:	f006 faa5 	bl	1b0b0 <assert_failed>
   14b66:	696b      	ldr	r3, [r5, #20]
   14b68:	e70e      	b.n	14988 <HAL_TIM_PWM_ConfigChannel+0x3dc>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   14b6a:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b6e:	f640 615e 	movw	r1, #3678	; 0xe5e
   14b72:	f2c0 0003 	movt	r0, #3
   14b76:	f006 fa9b 	bl	1b0b0 <assert_failed>
   14b7a:	6826      	ldr	r6, [r4, #0]
   14b7c:	e6d0      	b.n	14920 <HAL_TIM_PWM_ConfigChannel+0x374>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   14b7e:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b82:	f640 614d 	movw	r1, #3661	; 0xe4d
   14b86:	f2c0 0003 	movt	r0, #3
   14b8a:	f006 fa91 	bl	1b0b0 <assert_failed>
   14b8e:	6820      	ldr	r0, [r4, #0]
   14b90:	e685      	b.n	1489e <HAL_TIM_PWM_ConfigChannel+0x2f2>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   14b92:	f643 2034 	movw	r0, #14900	; 0x3a34
   14b96:	f640 613c 	movw	r1, #3644	; 0xe3c
   14b9a:	f2c0 0003 	movt	r0, #3
   14b9e:	f006 fa87 	bl	1b0b0 <assert_failed>
   14ba2:	6820      	ldr	r0, [r4, #0]
   14ba4:	e639      	b.n	1481a <HAL_TIM_PWM_ConfigChannel+0x26e>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   14ba6:	f643 2034 	movw	r0, #14900	; 0x3a34
   14baa:	f640 612b 	movw	r1, #3627	; 0xe2b
   14bae:	f2c0 0003 	movt	r0, #3
   14bb2:	f006 fa7d 	bl	1b0b0 <assert_failed>
   14bb6:	6820      	ldr	r0, [r4, #0]
   14bb8:	e5a6      	b.n	14708 <HAL_TIM_PWM_ConfigChannel+0x15c>
   14bba:	bf00      	nop

00014bbc <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
   14bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   14bbe:	2300      	movs	r3, #0
   14bc0:	6802      	ldr	r2, [r0, #0]
   14bc2:	f44f 6680 	mov.w	r6, #1024	; 0x400
{
   14bc6:	460d      	mov	r5, r1
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   14bc8:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14bcc:	f44f 6100 	mov.w	r1, #2048	; 0x800
   14bd0:	f2c4 0600 	movt	r6, #16384	; 0x4000
{
   14bd4:	4604      	mov	r4, r0
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   14bd6:	429a      	cmp	r2, r3
   14bd8:	bf18      	it	ne
   14bda:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   14bde:	f2c4 0100 	movt	r1, #16384	; 0x4000
   14be2:	f44f 6040 	mov.w	r0, #3072	; 0xc00
   14be6:	bf14      	ite	ne
   14be8:	2301      	movne	r3, #1
   14bea:	2300      	moveq	r3, #0
   14bec:	f2c4 0000 	movt	r0, #16384	; 0x4000
   14bf0:	42b2      	cmp	r2, r6
   14bf2:	bf0c      	ite	eq
   14bf4:	2300      	moveq	r3, #0
   14bf6:	f003 0301 	andne.w	r3, r3, #1
   14bfa:	428a      	cmp	r2, r1
   14bfc:	bf0c      	ite	eq
   14bfe:	2300      	moveq	r3, #0
   14c00:	f003 0301 	andne.w	r3, r3, #1
   14c04:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   14c08:	4282      	cmp	r2, r0
   14c0a:	bf0c      	ite	eq
   14c0c:	2300      	moveq	r3, #0
   14c0e:	f003 0301 	andne.w	r3, r3, #1
   14c12:	f2c4 0100 	movt	r1, #16384	; 0x4000
   14c16:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
   14c1a:	428a      	cmp	r2, r1
   14c1c:	bf0c      	ite	eq
   14c1e:	2300      	moveq	r3, #0
   14c20:	f003 0301 	andne.w	r3, r3, #1
   14c24:	f44f 6180 	mov.w	r1, #1024	; 0x400
   14c28:	f2c4 0000 	movt	r0, #16384	; 0x4000
   14c2c:	f2c4 0101 	movt	r1, #16385	; 0x4001
   14c30:	4282      	cmp	r2, r0
   14c32:	bf0c      	ite	eq
   14c34:	2300      	moveq	r3, #0
   14c36:	f003 0301 	andne.w	r3, r3, #1
   14c3a:	428a      	cmp	r2, r1
   14c3c:	bf0c      	ite	eq
   14c3e:	2300      	moveq	r3, #0
   14c40:	f003 0301 	andne.w	r3, r3, #1
   14c44:	b133      	cbz	r3, 14c54 <HAL_TIMEx_MasterConfigSynchronization+0x98>
   14c46:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   14c4a:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14c4e:	429a      	cmp	r2, r3
   14c50:	f040 808e 	bne.w	14d70 <HAL_TIMEx_MasterConfigSynchronization+0x1b4>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   14c54:	682b      	ldr	r3, [r5, #0]
   14c56:	f023 0330 	bic.w	r3, r3, #48	; 0x30
   14c5a:	2b40      	cmp	r3, #64	; 0x40
   14c5c:	d002      	beq.n	14c64 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
   14c5e:	2b00      	cmp	r3, #0
   14c60:	f040 808f 	bne.w	14d82 <HAL_TIMEx_MasterConfigSynchronization+0x1c6>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   14c64:	68ab      	ldr	r3, [r5, #8]
   14c66:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   14c6a:	d173      	bne.n	14d54 <HAL_TIMEx_MasterConfigSynchronization+0x198>

  /* Check input state */
  __HAL_LOCK(htim);
   14c6c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   14c70:	2b01      	cmp	r3, #1
   14c72:	d07b      	beq.n	14d6c <HAL_TIMEx_MasterConfigSynchronization+0x1b0>

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   14c74:	2300      	movs	r3, #0
  tmpcr2 = htim->Instance->CR2;
   14c76:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(htim);
   14c78:	2001      	movs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
   14c7a:	2102      	movs	r1, #2
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   14c7c:	f2c4 0301 	movt	r3, #16385	; 0x4001
  __HAL_LOCK(htim);
   14c80:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   14c84:	429a      	cmp	r2, r3
  htim->State = HAL_TIM_STATE_BUSY;
   14c86:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
   14c8a:	6857      	ldr	r7, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
   14c8c:	6896      	ldr	r6, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   14c8e:	d049      	beq.n	14d24 <HAL_TIMEx_MasterConfigSynchronization+0x168>
   14c90:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14c94:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14c98:	429a      	cmp	r2, r3
   14c9a:	d043      	beq.n	14d24 <HAL_TIMEx_MasterConfigSynchronization+0x168>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   14c9c:	6829      	ldr	r1, [r5, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
   14c9e:	f027 0770 	bic.w	r7, r7, #112	; 0x70

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   14ca2:	2300      	movs	r3, #0
   14ca4:	f44f 6080 	mov.w	r0, #1024	; 0x400
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   14ca8:	430f      	orrs	r7, r1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   14caa:	f44f 6100 	mov.w	r1, #2048	; 0x800
   14cae:	f2c4 0301 	movt	r3, #16385	; 0x4001
   14cb2:	f2c4 0000 	movt	r0, #16384	; 0x4000
  htim->Instance->CR2 = tmpcr2;
   14cb6:	6057      	str	r7, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   14cb8:	f2c4 0100 	movt	r1, #16384	; 0x4000
   14cbc:	6822      	ldr	r2, [r4, #0]
   14cbe:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   14cc2:	bf18      	it	ne
   14cc4:	429a      	cmpne	r2, r3
   14cc6:	bf0c      	ite	eq
   14cc8:	2301      	moveq	r3, #1
   14cca:	2300      	movne	r3, #0
   14ccc:	4282      	cmp	r2, r0
   14cce:	bf08      	it	eq
   14cd0:	f043 0301 	orreq.w	r3, r3, #1
   14cd4:	f44f 6040 	mov.w	r0, #3072	; 0xc00
   14cd8:	428a      	cmp	r2, r1
   14cda:	bf08      	it	eq
   14cdc:	f043 0301 	orreq.w	r3, r3, #1
   14ce0:	f2c4 0000 	movt	r0, #16384	; 0x4000
   14ce4:	f44f 6180 	mov.w	r1, #1024	; 0x400
   14ce8:	4282      	cmp	r2, r0
   14cea:	bf08      	it	eq
   14cec:	f043 0301 	orreq.w	r3, r3, #1
   14cf0:	f2c4 0101 	movt	r1, #16385	; 0x4001
   14cf4:	428a      	cmp	r2, r1
   14cf6:	bf08      	it	eq
   14cf8:	f043 0301 	orreq.w	r3, r3, #1
   14cfc:	b92b      	cbnz	r3, 14d0a <HAL_TIMEx_MasterConfigSynchronization+0x14e>
   14cfe:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   14d02:	f2c4 0300 	movt	r3, #16384	; 0x4000
   14d06:	429a      	cmp	r2, r3
   14d08:	d104      	bne.n	14d14 <HAL_TIMEx_MasterConfigSynchronization+0x158>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
   14d0a:	68ab      	ldr	r3, [r5, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
   14d0c:	f026 0680 	bic.w	r6, r6, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
   14d10:	431e      	orrs	r6, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
   14d12:	6096      	str	r6, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
   14d14:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   14d16:	2201      	movs	r2, #1

  return HAL_OK;
   14d18:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   14d1a:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   14d1e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   14d22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   14d24:	6868      	ldr	r0, [r5, #4]
   14d26:	f420 1340 	bic.w	r3, r0, #3145728	; 0x300000
   14d2a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   14d2e:	bf18      	it	ne
   14d30:	2b00      	cmpne	r3, #0
   14d32:	bf14      	ite	ne
   14d34:	2101      	movne	r1, #1
   14d36:	2100      	moveq	r1, #0
   14d38:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   14d3c:	bf0c      	ite	eq
   14d3e:	2100      	moveq	r1, #0
   14d40:	f001 0101 	andne.w	r1, r1, #1
   14d44:	b111      	cbz	r1, 14d4c <HAL_TIMEx_MasterConfigSynchronization+0x190>
   14d46:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   14d4a:	d123      	bne.n	14d94 <HAL_TIMEx_MasterConfigSynchronization+0x1d8>
    tmpcr2 &= ~TIM_CR2_MMS2;
   14d4c:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
   14d50:	4307      	orrs	r7, r0
   14d52:	e7a3      	b.n	14c9c <HAL_TIMEx_MasterConfigSynchronization+0xe0>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   14d54:	f643 206c 	movw	r0, #14956	; 0x3a6c
   14d58:	f240 6175 	movw	r1, #1653	; 0x675
   14d5c:	f2c0 0003 	movt	r0, #3
   14d60:	f006 f9a6 	bl	1b0b0 <assert_failed>
  __HAL_LOCK(htim);
   14d64:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   14d68:	2b01      	cmp	r3, #1
   14d6a:	d183      	bne.n	14c74 <HAL_TIMEx_MasterConfigSynchronization+0xb8>
   14d6c:	2002      	movs	r0, #2
}
   14d6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   14d70:	f643 206c 	movw	r0, #14956	; 0x3a6c
   14d74:	f240 6173 	movw	r1, #1651	; 0x673
   14d78:	f2c0 0003 	movt	r0, #3
   14d7c:	f006 f998 	bl	1b0b0 <assert_failed>
   14d80:	e768      	b.n	14c54 <HAL_TIMEx_MasterConfigSynchronization+0x98>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   14d82:	f643 206c 	movw	r0, #14956	; 0x3a6c
   14d86:	f240 6174 	movw	r1, #1652	; 0x674
   14d8a:	f2c0 0003 	movt	r0, #3
   14d8e:	f006 f98f 	bl	1b0b0 <assert_failed>
   14d92:	e767      	b.n	14c64 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   14d94:	f643 206c 	movw	r0, #14956	; 0x3a6c
   14d98:	f240 6187 	movw	r1, #1671	; 0x687
   14d9c:	f2c0 0003 	movt	r0, #3
   14da0:	f006 f986 	bl	1b0b0 <assert_failed>
   14da4:	6868      	ldr	r0, [r5, #4]
   14da6:	6822      	ldr	r2, [r4, #0]
   14da8:	e7d0      	b.n	14d4c <HAL_TIMEx_MasterConfigSynchronization+0x190>
   14daa:	bf00      	nop

00014dac <FMC_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   14dac:	f244 1340 	movw	r3, #16704	; 0x4140
   14db0:	f2c5 2300 	movt	r3, #20992	; 0x5200
   14db4:	4298      	cmp	r0, r3
{
   14db6:	b570      	push	{r4, r5, r6, lr}
   14db8:	4605      	mov	r5, r0
   14dba:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   14dbc:	d007      	beq.n	14dce <FMC_SDRAM_Init+0x22>
   14dbe:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14dc2:	f240 311a 	movw	r1, #794	; 0x31a
   14dc6:	f2c0 0003 	movt	r0, #3
   14dca:	f006 f971 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
   14dce:	6823      	ldr	r3, [r4, #0]
   14dd0:	2b01      	cmp	r3, #1
   14dd2:	d907      	bls.n	14de4 <FMC_SDRAM_Init+0x38>
   14dd4:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14dd8:	f240 311b 	movw	r1, #795	; 0x31b
   14ddc:	f2c0 0003 	movt	r0, #3
   14de0:	f006 f966 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
   14de4:	6863      	ldr	r3, [r4, #4]
   14de6:	2b03      	cmp	r3, #3
   14de8:	f200 80c0 	bhi.w	14f6c <FMC_SDRAM_Init+0x1c0>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
   14dec:	68a3      	ldr	r3, [r4, #8]
   14dee:	f033 0204 	bics.w	r2, r3, #4
   14df2:	d002      	beq.n	14dfa <FMC_SDRAM_Init+0x4e>
   14df4:	2b08      	cmp	r3, #8
   14df6:	f040 80b0 	bne.w	14f5a <FMC_SDRAM_Init+0x1ae>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
   14dfa:	68e3      	ldr	r3, [r4, #12]
   14dfc:	f033 0210 	bics.w	r2, r3, #16
   14e00:	d002      	beq.n	14e08 <FMC_SDRAM_Init+0x5c>
   14e02:	2b20      	cmp	r3, #32
   14e04:	f040 8093 	bne.w	14f2e <FMC_SDRAM_Init+0x182>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
   14e08:	6923      	ldr	r3, [r4, #16]
   14e0a:	f033 0340 	bics.w	r3, r3, #64	; 0x40
   14e0e:	f040 809b 	bne.w	14f48 <FMC_SDRAM_Init+0x19c>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
   14e12:	6963      	ldr	r3, [r4, #20]
   14e14:	f423 7280 	bic.w	r2, r3, #256	; 0x100
   14e18:	2a80      	cmp	r2, #128	; 0x80
   14e1a:	d002      	beq.n	14e22 <FMC_SDRAM_Init+0x76>
   14e1c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   14e20:	d170      	bne.n	14f04 <FMC_SDRAM_Init+0x158>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
   14e22:	69a3      	ldr	r3, [r4, #24]
   14e24:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   14e28:	d178      	bne.n	14f1c <FMC_SDRAM_Init+0x170>
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
   14e2a:	69e3      	ldr	r3, [r4, #28]
   14e2c:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
   14e30:	d002      	beq.n	14e38 <FMC_SDRAM_Init+0x8c>
   14e32:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
   14e36:	d150      	bne.n	14eda <FMC_SDRAM_Init+0x12e>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
   14e38:	6a23      	ldr	r3, [r4, #32]
   14e3a:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   14e3e:	d158      	bne.n	14ef2 <FMC_SDRAM_Init+0x146>
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
   14e40:	6a62      	ldr	r2, [r4, #36]	; 0x24
   14e42:	f432 5300 	bics.w	r3, r2, #8192	; 0x2000
   14e46:	d002      	beq.n	14e4e <FMC_SDRAM_Init+0xa2>
   14e48:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
   14e4c:	d11f      	bne.n	14e8e <FMC_SDRAM_Init+0xe2>

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
   14e4e:	6821      	ldr	r1, [r4, #0]
   14e50:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
   14e54:	b349      	cbz	r1, 14eaa <FMC_SDRAM_Init+0xfe>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   14e56:	6829      	ldr	r1, [r5, #0]
   14e58:	4303      	orrs	r3, r0
               FMC_SDCRx_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   14e5a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   14e5e:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   14e62:	f6cf 70ff 	movt	r0, #65535	; 0xffff
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   14e66:	430b      	orrs	r3, r1
   14e68:	4313      	orrs	r3, r2
   14e6a:	602b      	str	r3, [r5, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   14e6c:	68e2      	ldr	r2, [r4, #12]
   14e6e:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   14e72:	430b      	orrs	r3, r1
   14e74:	6921      	ldr	r1, [r4, #16]
   14e76:	4313      	orrs	r3, r2
   14e78:	e9d4 6205 	ldrd	r6, r2, [r4, #20]
   14e7c:	430b      	orrs	r3, r1
   14e7e:	6869      	ldr	r1, [r5, #4]
   14e80:	4333      	orrs	r3, r6
   14e82:	4008      	ands	r0, r1
   14e84:	4313      	orrs	r3, r2
   14e86:	4303      	orrs	r3, r0
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
   14e88:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   14e8a:	606b      	str	r3, [r5, #4]
}
   14e8c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
   14e8e:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14e92:	f44f 7149 	mov.w	r1, #804	; 0x324
   14e96:	f2c0 0003 	movt	r0, #3
   14e9a:	f006 f909 	bl	1b0b0 <assert_failed>
  if (Init->SDBank == FMC_SDRAM_BANK1)
   14e9e:	6821      	ldr	r1, [r4, #0]
   14ea0:	6a62      	ldr	r2, [r4, #36]	; 0x24
   14ea2:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
   14ea6:	2900      	cmp	r1, #0
   14ea8:	d1d5      	bne.n	14e56 <FMC_SDRAM_Init+0xaa>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   14eaa:	4303      	orrs	r3, r0
   14eac:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
   14eb0:	4303      	orrs	r3, r0
   14eb2:	68e0      	ldr	r0, [r4, #12]
   14eb4:	430b      	orrs	r3, r1
   14eb6:	6921      	ldr	r1, [r4, #16]
   14eb8:	4303      	orrs	r3, r0
   14eba:	e9d4 0405 	ldrd	r0, r4, [r4, #20]
   14ebe:	430b      	orrs	r3, r1
   14ec0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   14ec4:	4303      	orrs	r3, r0
   14ec6:	f6cf 71ff 	movt	r1, #65535	; 0xffff
   14eca:	6828      	ldr	r0, [r5, #0]
   14ecc:	4323      	orrs	r3, r4
   14ece:	4001      	ands	r1, r0
}
   14ed0:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   14ed2:	430b      	orrs	r3, r1
   14ed4:	4313      	orrs	r3, r2
   14ed6:	602b      	str	r3, [r5, #0]
}
   14ed8:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
   14eda:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14ede:	f240 3122 	movw	r1, #802	; 0x322
   14ee2:	f2c0 0003 	movt	r0, #3
   14ee6:	f006 f8e3 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
   14eea:	6a23      	ldr	r3, [r4, #32]
   14eec:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   14ef0:	d0a6      	beq.n	14e40 <FMC_SDRAM_Init+0x94>
   14ef2:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14ef6:	f240 3123 	movw	r1, #803	; 0x323
   14efa:	f2c0 0003 	movt	r0, #3
   14efe:	f006 f8d7 	bl	1b0b0 <assert_failed>
   14f02:	e79d      	b.n	14e40 <FMC_SDRAM_Init+0x94>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
   14f04:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f08:	f44f 7148 	mov.w	r1, #800	; 0x320
   14f0c:	f2c0 0003 	movt	r0, #3
   14f10:	f006 f8ce 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
   14f14:	69a3      	ldr	r3, [r4, #24]
   14f16:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   14f1a:	d086      	beq.n	14e2a <FMC_SDRAM_Init+0x7e>
   14f1c:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f20:	f240 3121 	movw	r1, #801	; 0x321
   14f24:	f2c0 0003 	movt	r0, #3
   14f28:	f006 f8c2 	bl	1b0b0 <assert_failed>
   14f2c:	e77d      	b.n	14e2a <FMC_SDRAM_Init+0x7e>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
   14f2e:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f32:	f240 311e 	movw	r1, #798	; 0x31e
   14f36:	f2c0 0003 	movt	r0, #3
   14f3a:	f006 f8b9 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
   14f3e:	6923      	ldr	r3, [r4, #16]
   14f40:	f033 0340 	bics.w	r3, r3, #64	; 0x40
   14f44:	f43f af65 	beq.w	14e12 <FMC_SDRAM_Init+0x66>
   14f48:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f4c:	f240 311f 	movw	r1, #799	; 0x31f
   14f50:	f2c0 0003 	movt	r0, #3
   14f54:	f006 f8ac 	bl	1b0b0 <assert_failed>
   14f58:	e75b      	b.n	14e12 <FMC_SDRAM_Init+0x66>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
   14f5a:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f5e:	f240 311d 	movw	r1, #797	; 0x31d
   14f62:	f2c0 0003 	movt	r0, #3
   14f66:	f006 f8a3 	bl	1b0b0 <assert_failed>
   14f6a:	e746      	b.n	14dfa <FMC_SDRAM_Init+0x4e>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
   14f6c:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f70:	f44f 7147 	mov.w	r1, #796	; 0x31c
   14f74:	f2c0 0003 	movt	r0, #3
   14f78:	f006 f89a 	bl	1b0b0 <assert_failed>
   14f7c:	e736      	b.n	14dec <FMC_SDRAM_Init+0x40>
   14f7e:	bf00      	nop

00014f80 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
   14f80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   14f82:	f244 1340 	movw	r3, #16704	; 0x4140
{
   14f86:	4605      	mov	r5, r0
   14f88:	460c      	mov	r4, r1
   14f8a:	4616      	mov	r6, r2
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   14f8c:	f2c5 2300 	movt	r3, #20992	; 0x5200
   14f90:	4298      	cmp	r0, r3
   14f92:	d007      	beq.n	14fa4 <FMC_SDRAM_Timing_Init+0x24>
   14f94:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   14f98:	f44f 7156 	mov.w	r1, #856	; 0x358
   14f9c:	f2c0 0003 	movt	r0, #3
   14fa0:	f006 f886 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
   14fa4:	6823      	ldr	r3, [r4, #0]
   14fa6:	3b01      	subs	r3, #1
   14fa8:	2b0f      	cmp	r3, #15
   14faa:	f200 80a4 	bhi.w	150f6 <FMC_SDRAM_Timing_Init+0x176>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
   14fae:	6863      	ldr	r3, [r4, #4]
   14fb0:	3b01      	subs	r3, #1
   14fb2:	2b0f      	cmp	r3, #15
   14fb4:	f200 8096 	bhi.w	150e4 <FMC_SDRAM_Timing_Init+0x164>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
   14fb8:	68a3      	ldr	r3, [r4, #8]
   14fba:	3b01      	subs	r3, #1
   14fbc:	2b0f      	cmp	r3, #15
   14fbe:	f200 8088 	bhi.w	150d2 <FMC_SDRAM_Timing_Init+0x152>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
   14fc2:	68e3      	ldr	r3, [r4, #12]
   14fc4:	3b01      	subs	r3, #1
   14fc6:	2b0f      	cmp	r3, #15
   14fc8:	d87a      	bhi.n	150c0 <FMC_SDRAM_Timing_Init+0x140>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
   14fca:	6923      	ldr	r3, [r4, #16]
   14fcc:	3b01      	subs	r3, #1
   14fce:	2b0f      	cmp	r3, #15
   14fd0:	d86d      	bhi.n	150ae <FMC_SDRAM_Timing_Init+0x12e>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
   14fd2:	6963      	ldr	r3, [r4, #20]
   14fd4:	3b01      	subs	r3, #1
   14fd6:	2b0f      	cmp	r3, #15
   14fd8:	d860      	bhi.n	1509c <FMC_SDRAM_Timing_Init+0x11c>
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
   14fda:	69a3      	ldr	r3, [r4, #24]
   14fdc:	3b01      	subs	r3, #1
   14fde:	2b0f      	cmp	r3, #15
   14fe0:	d853      	bhi.n	1508a <FMC_SDRAM_Timing_Init+0x10a>
  assert_param(IS_FMC_SDRAM_BANK(Bank));
   14fe2:	2e01      	cmp	r6, #1
   14fe4:	d821      	bhi.n	1502a <FMC_SDRAM_Timing_Init+0xaa>
   14fe6:	68e3      	ldr	r3, [r4, #12]
   14fe8:	6961      	ldr	r1, [r4, #20]
   14fea:	3b01      	subs	r3, #1
   14fec:	3901      	subs	r1, #1
   14fee:	031b      	lsls	r3, r3, #12
   14ff0:	0509      	lsls	r1, r1, #20

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
   14ff2:	bb46      	cbnz	r6, 15046 <FMC_SDRAM_Timing_Init+0xc6>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   14ff4:	6822      	ldr	r2, [r4, #0]
   14ff6:	430b      	orrs	r3, r1
   14ff8:	6860      	ldr	r0, [r4, #4]
   14ffa:	3a01      	subs	r2, #1
   14ffc:	68a1      	ldr	r1, [r4, #8]
   14ffe:	1e47      	subs	r7, r0, #1
   15000:	6920      	ldr	r0, [r4, #16]
   15002:	4313      	orrs	r3, r2
   15004:	1e4e      	subs	r6, r1, #1
   15006:	3801      	subs	r0, #1
   15008:	69a1      	ldr	r1, [r4, #24]
   1500a:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
   1500e:	68aa      	ldr	r2, [r5, #8]
   15010:	3901      	subs	r1, #1
   15012:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
   15016:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   1501a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
}
   1501e:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   15020:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   15024:	4313      	orrs	r3, r2
   15026:	60ab      	str	r3, [r5, #8]
}
   15028:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_SDRAM_BANK(Bank));
   1502a:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   1502e:	f44f 7158 	mov.w	r1, #864	; 0x360
   15032:	f2c0 0003 	movt	r0, #3
   15036:	f006 f83b 	bl	1b0b0 <assert_failed>
   1503a:	68e3      	ldr	r3, [r4, #12]
   1503c:	6961      	ldr	r1, [r4, #20]
   1503e:	3b01      	subs	r3, #1
   15040:	3901      	subs	r1, #1
   15042:	031b      	lsls	r3, r3, #12
   15044:	0509      	lsls	r1, r1, #20
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   15046:	f640 72ff 	movw	r2, #4095	; 0xfff
   1504a:	68a8      	ldr	r0, [r5, #8]
   1504c:	430b      	orrs	r3, r1
   1504e:	f6cf 720f 	movt	r2, #65295	; 0xff0f
   15052:	4002      	ands	r2, r0
   15054:	4313      	orrs	r3, r2
   15056:	60ab      	str	r3, [r5, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
   15058:	6820      	ldr	r0, [r4, #0]
   1505a:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   1505e:	1e46      	subs	r6, r0, #1
   15060:	1e5a      	subs	r2, r3, #1
   15062:	1e4b      	subs	r3, r1, #1
   15064:	6921      	ldr	r1, [r4, #16]
   15066:	0212      	lsls	r2, r2, #8
   15068:	1e48      	subs	r0, r1, #1
   1506a:	69a1      	ldr	r1, [r4, #24]
   1506c:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
   15070:	68ea      	ldr	r2, [r5, #12]
   15072:	3901      	subs	r1, #1
   15074:	4333      	orrs	r3, r6
   15076:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   1507a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
}
   1507e:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
   15080:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   15084:	4313      	orrs	r3, r2
   15086:	60eb      	str	r3, [r5, #12]
}
   15088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
   1508a:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   1508e:	f240 315f 	movw	r1, #863	; 0x35f
   15092:	f2c0 0003 	movt	r0, #3
   15096:	f006 f80b 	bl	1b0b0 <assert_failed>
   1509a:	e7a2      	b.n	14fe2 <FMC_SDRAM_Timing_Init+0x62>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
   1509c:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   150a0:	f240 315e 	movw	r1, #862	; 0x35e
   150a4:	f2c0 0003 	movt	r0, #3
   150a8:	f006 f802 	bl	1b0b0 <assert_failed>
   150ac:	e795      	b.n	14fda <FMC_SDRAM_Timing_Init+0x5a>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
   150ae:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   150b2:	f240 315d 	movw	r1, #861	; 0x35d
   150b6:	f2c0 0003 	movt	r0, #3
   150ba:	f005 fff9 	bl	1b0b0 <assert_failed>
   150be:	e788      	b.n	14fd2 <FMC_SDRAM_Timing_Init+0x52>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
   150c0:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   150c4:	f44f 7157 	mov.w	r1, #860	; 0x35c
   150c8:	f2c0 0003 	movt	r0, #3
   150cc:	f005 fff0 	bl	1b0b0 <assert_failed>
   150d0:	e77b      	b.n	14fca <FMC_SDRAM_Timing_Init+0x4a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
   150d2:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   150d6:	f240 315b 	movw	r1, #859	; 0x35b
   150da:	f2c0 0003 	movt	r0, #3
   150de:	f005 ffe7 	bl	1b0b0 <assert_failed>
   150e2:	e76e      	b.n	14fc2 <FMC_SDRAM_Timing_Init+0x42>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
   150e4:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   150e8:	f240 315a 	movw	r1, #858	; 0x35a
   150ec:	f2c0 0003 	movt	r0, #3
   150f0:	f005 ffde 	bl	1b0b0 <assert_failed>
   150f4:	e760      	b.n	14fb8 <FMC_SDRAM_Timing_Init+0x38>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
   150f6:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   150fa:	f240 3159 	movw	r1, #857	; 0x359
   150fe:	f2c0 0003 	movt	r0, #3
   15102:	f005 ffd5 	bl	1b0b0 <assert_failed>
   15106:	e752      	b.n	14fae <FMC_SDRAM_Timing_Init+0x2e>

00015108 <FMC_SDRAM_SendCommand>:
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   15108:	f244 1340 	movw	r3, #16704	; 0x4140
   1510c:	f2c5 2300 	movt	r3, #20992	; 0x5200
   15110:	4298      	cmp	r0, r3
{
   15112:	b570      	push	{r4, r5, r6, lr}
   15114:	4605      	mov	r5, r0
   15116:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   15118:	d007      	beq.n	1512a <FMC_SDRAM_SendCommand+0x22>
   1511a:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   1511e:	f240 31d9 	movw	r1, #985	; 0x3d9
   15122:	f2c0 0003 	movt	r0, #3
   15126:	f005 ffc3 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
   1512a:	6823      	ldr	r3, [r4, #0]
   1512c:	2b06      	cmp	r3, #6
   1512e:	d83a      	bhi.n	151a6 <FMC_SDRAM_SendCommand+0x9e>
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
   15130:	6863      	ldr	r3, [r4, #4]
   15132:	f023 0210 	bic.w	r2, r3, #16
   15136:	2a08      	cmp	r2, #8
   15138:	d001      	beq.n	1513e <FMC_SDRAM_SendCommand+0x36>
   1513a:	2b10      	cmp	r3, #16
   1513c:	d11e      	bne.n	1517c <FMC_SDRAM_SendCommand+0x74>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
   1513e:	68a3      	ldr	r3, [r4, #8]
   15140:	3b01      	subs	r3, #1
   15142:	2b0e      	cmp	r3, #14
   15144:	d826      	bhi.n	15194 <FMC_SDRAM_SendCommand+0x8c>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));
   15146:	68e1      	ldr	r1, [r4, #12]
   15148:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
   1514c:	d308      	bcc.n	15160 <FMC_SDRAM_SendCommand+0x58>
   1514e:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   15152:	f240 31dd 	movw	r1, #989	; 0x3dd
   15156:	f2c0 0003 	movt	r0, #3
   1515a:	f005 ffa9 	bl	1b0b0 <assert_failed>
   1515e:	68e1      	ldr	r1, [r4, #12]

  /* Set command register */
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
   15160:	6823      	ldr	r3, [r4, #0]
                          (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos)   |
                          ((Command->ModeRegisterDefinition)   << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
   15162:	2000      	movs	r0, #0
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
   15164:	e9d4 6201 	ldrd	r6, r2, [r4, #4]
   15168:	692c      	ldr	r4, [r5, #16]
   1516a:	4333      	orrs	r3, r6
   1516c:	3a01      	subs	r2, #1
   1516e:	4323      	orrs	r3, r4
   15170:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
   15174:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
   15178:	612b      	str	r3, [r5, #16]
}
   1517a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
   1517c:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   15180:	f240 31db 	movw	r1, #987	; 0x3db
   15184:	f2c0 0003 	movt	r0, #3
   15188:	f005 ff92 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
   1518c:	68a3      	ldr	r3, [r4, #8]
   1518e:	3b01      	subs	r3, #1
   15190:	2b0e      	cmp	r3, #14
   15192:	d9d8      	bls.n	15146 <FMC_SDRAM_SendCommand+0x3e>
   15194:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   15198:	f44f 7177 	mov.w	r1, #988	; 0x3dc
   1519c:	f2c0 0003 	movt	r0, #3
   151a0:	f005 ff86 	bl	1b0b0 <assert_failed>
   151a4:	e7cf      	b.n	15146 <FMC_SDRAM_SendCommand+0x3e>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
   151a6:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   151aa:	f240 31da 	movw	r1, #986	; 0x3da
   151ae:	f2c0 0003 	movt	r0, #3
   151b2:	f005 ff7d 	bl	1b0b0 <assert_failed>
   151b6:	e7bb      	b.n	15130 <FMC_SDRAM_SendCommand+0x28>

000151b8 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
   151b8:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   151ba:	f244 1340 	movw	r3, #16704	; 0x4140
{
   151be:	4604      	mov	r4, r0
   151c0:	460d      	mov	r5, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   151c2:	f2c5 2300 	movt	r3, #20992	; 0x5200
   151c6:	4298      	cmp	r0, r3
   151c8:	d007      	beq.n	151da <FMC_SDRAM_ProgramRefreshRate+0x22>
   151ca:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   151ce:	f240 31f2 	movw	r1, #1010	; 0x3f2
   151d2:	f2c0 0003 	movt	r0, #3
   151d6:	f005 ff6b 	bl	1b0b0 <assert_failed>
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
   151da:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
   151de:	d307      	bcc.n	151f0 <FMC_SDRAM_ProgramRefreshRate+0x38>
   151e0:	f643 20a8 	movw	r0, #15016	; 0x3aa8
   151e4:	f240 31f3 	movw	r1, #1011	; 0x3f3
   151e8:	f2c0 0003 	movt	r0, #3
   151ec:	f005 ff60 	bl	1b0b0 <assert_failed>

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
   151f0:	f24c 0101 	movw	r1, #49153	; 0xc001
   151f4:	6963      	ldr	r3, [r4, #20]

  return HAL_OK;
}
   151f6:	2000      	movs	r0, #0
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
   151f8:	f6cf 71ff 	movt	r1, #65535	; 0xffff
   151fc:	4019      	ands	r1, r3
   151fe:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
   15202:	6161      	str	r1, [r4, #20]
}
   15204:	bd38      	pop	{r3, r4, r5, pc}
   15206:	bf00      	nop

00015208 <SDMMC_GetCmdResp1.part.2>:
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
   15208:	f24e 0308 	movw	r3, #57352	; 0xe008
  return (*(__IO uint32_t *) tmp);
   1520c:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
   1520e:	f6cf 53ff 	movt	r3, #65023	; 0xfdff
   15212:	4013      	ands	r3, r2
   15214:	b34b      	cbz	r3, 1526a <SDMMC_GetCmdResp1.part.2+0x62>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
   15216:	2a00      	cmp	r2, #0
   15218:	db29      	blt.n	1526e <SDMMC_GetCmdResp1.part.2+0x66>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
   1521a:	0051      	lsls	r1, r2, #1
   1521c:	d42d      	bmi.n	1527a <SDMMC_GetCmdResp1.part.2+0x72>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
   1521e:	0093      	lsls	r3, r2, #2
   15220:	d42d      	bmi.n	1527e <SDMMC_GetCmdResp1.part.2+0x76>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
   15222:	00d1      	lsls	r1, r2, #3
   15224:	d426      	bmi.n	15274 <SDMMC_GetCmdResp1.part.2+0x6c>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
   15226:	0113      	lsls	r3, r2, #4
   15228:	d42e      	bmi.n	15288 <SDMMC_GetCmdResp1.part.2+0x80>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
   1522a:	0151      	lsls	r1, r2, #5
   1522c:	d42f      	bmi.n	1528e <SDMMC_GetCmdResp1.part.2+0x86>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
   1522e:	01d3      	lsls	r3, r2, #7
   15230:	d427      	bmi.n	15282 <SDMMC_GetCmdResp1.part.2+0x7a>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
   15232:	0211      	lsls	r1, r2, #8
   15234:	d42e      	bmi.n	15294 <SDMMC_GetCmdResp1.part.2+0x8c>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
   15236:	0253      	lsls	r3, r2, #9
   15238:	d42f      	bmi.n	1529a <SDMMC_GetCmdResp1.part.2+0x92>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
   1523a:	0291      	lsls	r1, r2, #10
   1523c:	d430      	bmi.n	152a0 <SDMMC_GetCmdResp1.part.2+0x98>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
   1523e:	02d3      	lsls	r3, r2, #11
   15240:	d431      	bmi.n	152a6 <SDMMC_GetCmdResp1.part.2+0x9e>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
   15242:	0351      	lsls	r1, r2, #13
   15244:	d432      	bmi.n	152ac <SDMMC_GetCmdResp1.part.2+0xa4>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
   15246:	0393      	lsls	r3, r2, #14
   15248:	d433      	bmi.n	152b2 <SDMMC_GetCmdResp1.part.2+0xaa>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
   1524a:	03d1      	lsls	r1, r2, #15
   1524c:	d434      	bmi.n	152b8 <SDMMC_GetCmdResp1.part.2+0xb0>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
   1524e:	0413      	lsls	r3, r2, #16
   15250:	d435      	bmi.n	152be <SDMMC_GetCmdResp1.part.2+0xb6>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
   15252:	0451      	lsls	r1, r2, #17
   15254:	d436      	bmi.n	152c4 <SDMMC_GetCmdResp1.part.2+0xbc>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
   15256:	0493      	lsls	r3, r2, #18
   15258:	d437      	bmi.n	152ca <SDMMC_GetCmdResp1.part.2+0xc2>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
   1525a:	f012 0f08 	tst.w	r2, #8
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
   1525e:	bf14      	ite	ne
   15260:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
   15264:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   15268:	4770      	bx	lr
    return SDMMC_ERROR_NONE;
   1526a:	4618      	mov	r0, r3
   1526c:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
   1526e:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
   15272:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
   15274:	f44f 7080 	mov.w	r0, #256	; 0x100
   15278:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
   1527a:	2040      	movs	r0, #64	; 0x40
   1527c:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
   1527e:	2080      	movs	r0, #128	; 0x80
   15280:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
   15282:	f44f 6000 	mov.w	r0, #2048	; 0x800
   15286:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
   15288:	f44f 7000 	mov.w	r0, #512	; 0x200
   1528c:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
   1528e:	f44f 6080 	mov.w	r0, #1024	; 0x400
   15292:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
   15294:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   15298:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
   1529a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   1529e:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
   152a0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   152a4:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
   152a6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   152aa:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
   152ac:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   152b0:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
   152b2:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   152b6:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
   152b8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   152bc:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
   152be:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   152c2:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
   152c4:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   152c8:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
   152ca:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
}
   152ce:	4770      	bx	lr

000152d0 <SDMMC_Init>:
{
   152d0:	b084      	sub	sp, #16
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   152d2:	f44f 4ce0 	mov.w	ip, #28672	; 0x7000
{
   152d6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   152da:	f2c5 2c00 	movt	ip, #20992	; 0x5200
{
   152de:	4605      	mov	r5, r0
   152e0:	a809      	add	r0, sp, #36	; 0x24
   152e2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   152e4:	4565      	cmp	r5, ip
   152e6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   152e8:	460c      	mov	r4, r1
{
   152ea:	e880 000e 	stmia.w	r0, {r1, r2, r3}
   152ee:	e9dd 980a 	ldrd	r9, r8, [sp, #40]	; 0x28
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   152f2:	d005      	beq.n	15300 <SDMMC_Init+0x30>
   152f4:	f44f 5310 	mov.w	r3, #9216	; 0x2400
   152f8:	f6c4 0302 	movt	r3, #18434	; 0x4802
   152fc:	429d      	cmp	r5, r3
   152fe:	d12b      	bne.n	15358 <SDMMC_Init+0x88>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
   15300:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
   15304:	d132      	bne.n	1536c <SDMMC_Init+0x9c>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
   15306:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
   1530a:	d139      	bne.n	15380 <SDMMC_Init+0xb0>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
   1530c:	f438 4380 	bics.w	r3, r8, #16384	; 0x4000
   15310:	d002      	beq.n	15318 <SDMMC_Init+0x48>
   15312:	f5b8 4f00 	cmp.w	r8, #32768	; 0x8000
   15316:	d13b      	bne.n	15390 <SDMMC_Init+0xc0>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
   15318:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
   1531c:	d142      	bne.n	153a4 <SDMMC_Init+0xd4>
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
   1531e:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   15322:	d306      	bcc.n	15332 <SDMMC_Init+0x62>
   15324:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   15328:	21d7      	movs	r1, #215	; 0xd7
   1532a:	f2c0 0003 	movt	r0, #3
   1532e:	f005 febf 	bl	1b0b0 <assert_failed>
  tmpreg |= (Init.ClockEdge           |\
   15332:	ea44 0309 	orr.w	r3, r4, r9
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   15336:	f44f 5230 	mov.w	r2, #11264	; 0x2c00
   1533a:	6869      	ldr	r1, [r5, #4]
}
   1533c:	2000      	movs	r0, #0
             Init.ClockPowerSave      |\
   1533e:	ea43 0308 	orr.w	r3, r3, r8
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   15342:	f6cf 72c0 	movt	r2, #65472	; 0xffc0
             Init.BusWide             |\
   15346:	433b      	orrs	r3, r7
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   15348:	400a      	ands	r2, r1
             Init.HardwareFlowControl |\
   1534a:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   1534c:	4313      	orrs	r3, r2
   1534e:	606b      	str	r3, [r5, #4]
}
   15350:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15354:	b004      	add	sp, #16
   15356:	4770      	bx	lr
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   15358:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   1535c:	21d2      	movs	r1, #210	; 0xd2
   1535e:	f2c0 0003 	movt	r0, #3
   15362:	f005 fea5 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
   15366:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
   1536a:	d0cc      	beq.n	15306 <SDMMC_Init+0x36>
   1536c:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   15370:	21d3      	movs	r1, #211	; 0xd3
   15372:	f2c0 0003 	movt	r0, #3
   15376:	f005 fe9b 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
   1537a:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
   1537e:	d0c5      	beq.n	1530c <SDMMC_Init+0x3c>
   15380:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   15384:	21d4      	movs	r1, #212	; 0xd4
   15386:	f2c0 0003 	movt	r0, #3
   1538a:	f005 fe91 	bl	1b0b0 <assert_failed>
   1538e:	e7bd      	b.n	1530c <SDMMC_Init+0x3c>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
   15390:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   15394:	21d5      	movs	r1, #213	; 0xd5
   15396:	f2c0 0003 	movt	r0, #3
   1539a:	f005 fe89 	bl	1b0b0 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
   1539e:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
   153a2:	d0bc      	beq.n	1531e <SDMMC_Init+0x4e>
   153a4:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   153a8:	21d6      	movs	r1, #214	; 0xd6
   153aa:	f2c0 0003 	movt	r0, #3
   153ae:	f005 fe7f 	bl	1b0b0 <assert_failed>
   153b2:	e7b4      	b.n	1531e <SDMMC_Init+0x4e>

000153b4 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
   153b4:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
   153b8:	4770      	bx	lr
   153ba:	bf00      	nop

000153bc <SDMMC_WriteFIFO>:
{
   153bc:	4603      	mov	r3, r0
  SDMMCx->FIFO = *pWriteData;
   153be:	680a      	ldr	r2, [r1, #0]
}
   153c0:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
   153c2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
   153c6:	4770      	bx	lr

000153c8 <SDMMC_PowerState_ON>:
{
   153c8:	4602      	mov	r2, r0
}
   153ca:	2000      	movs	r0, #0
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
   153cc:	6813      	ldr	r3, [r2, #0]
   153ce:	f043 0303 	orr.w	r3, r3, #3
   153d2:	6013      	str	r3, [r2, #0]
}
   153d4:	4770      	bx	lr
   153d6:	bf00      	nop

000153d8 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
   153d8:	6800      	ldr	r0, [r0, #0]
}
   153da:	f000 0003 	and.w	r0, r0, #3
   153de:	4770      	bx	lr

000153e0 <SDMMC_GetResponse>:
{
   153e0:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_SDMMC_RESP(Response));
   153e2:	f031 030c 	bics.w	r3, r1, #12
{
   153e6:	460d      	mov	r5, r1
   153e8:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_RESP(Response));
   153ea:	d007      	beq.n	153fc <SDMMC_GetResponse+0x1c>
   153ec:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   153f0:	f44f 71cc 	mov.w	r1, #408	; 0x198
   153f4:	f2c0 0003 	movt	r0, #3
   153f8:	f005 fe5a 	bl	1b0b0 <assert_failed>
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
   153fc:	3414      	adds	r4, #20
  return (*(__IO uint32_t *) tmp);
   153fe:	5960      	ldr	r0, [r4, r5]
}
   15400:	bd38      	pop	{r3, r4, r5, pc}
   15402:	bf00      	nop

00015404 <SDMMC_ConfigData>:
{
   15404:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   15406:	684b      	ldr	r3, [r1, #4]
{
   15408:	460c      	mov	r4, r1
   1540a:	4605      	mov	r5, r0
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   1540c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   15410:	d23e      	bcs.n	15490 <SDMMC_ConfigData+0x8c>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
   15412:	68a2      	ldr	r2, [r4, #8]
   15414:	f032 0130 	bics.w	r1, r2, #48	; 0x30
   15418:	bf14      	ite	ne
   1541a:	2301      	movne	r3, #1
   1541c:	2300      	moveq	r3, #0
   1541e:	2940      	cmp	r1, #64	; 0x40
   15420:	bf0c      	ite	eq
   15422:	2300      	moveq	r3, #0
   15424:	f003 0301 	andne.w	r3, r3, #1
   15428:	2ae0      	cmp	r2, #224	; 0xe0
   1542a:	bf0c      	ite	eq
   1542c:	2300      	moveq	r3, #0
   1542e:	f003 0301 	andne.w	r3, r3, #1
   15432:	2980      	cmp	r1, #128	; 0x80
   15434:	bf0c      	ite	eq
   15436:	2300      	moveq	r3, #0
   15438:	f003 0301 	andne.w	r3, r3, #1
   1543c:	b11b      	cbz	r3, 15446 <SDMMC_ConfigData+0x42>
   1543e:	f022 0210 	bic.w	r2, r2, #16
   15442:	2ac0      	cmp	r2, #192	; 0xc0
   15444:	d13f      	bne.n	154c6 <SDMMC_ConfigData+0xc2>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
   15446:	68e3      	ldr	r3, [r4, #12]
   15448:	f033 0302 	bics.w	r3, r3, #2
   1544c:	d132      	bne.n	154b4 <SDMMC_ConfigData+0xb0>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
   1544e:	6923      	ldr	r3, [r4, #16]
   15450:	f033 0308 	bics.w	r3, r3, #8
   15454:	d125      	bne.n	154a2 <SDMMC_ConfigData+0x9e>
  assert_param(IS_SDMMC_DPSM(Data->DPSM));
   15456:	6963      	ldr	r3, [r4, #20]
   15458:	2b01      	cmp	r3, #1
   1545a:	d907      	bls.n	1546c <SDMMC_ConfigData+0x68>
   1545c:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   15460:	f240 11b1 	movw	r1, #433	; 0x1b1
   15464:	f2c0 0003 	movt	r0, #3
   15468:	f005 fe22 	bl	1b0b0 <assert_failed>
  SDMMCx->DTIMER = Data->DataTimeOut;
   1546c:	6823      	ldr	r3, [r4, #0]
}
   1546e:	2000      	movs	r0, #0
  SDMMCx->DTIMER = Data->DataTimeOut;
   15470:	626b      	str	r3, [r5, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
   15472:	6863      	ldr	r3, [r4, #4]
   15474:	62ab      	str	r3, [r5, #40]	; 0x28
                       Data->TransferDir   |\
   15476:	6926      	ldr	r6, [r4, #16]
                       Data->TransferMode  |\
   15478:	6961      	ldr	r1, [r4, #20]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
   1547a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   1547e:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   15480:	6aea      	ldr	r2, [r5, #44]	; 0x2c
                       Data->TransferDir   |\
   15482:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   15484:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
                       Data->TransferMode  |\
   15488:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   1548a:	4313      	orrs	r3, r2
   1548c:	62eb      	str	r3, [r5, #44]	; 0x2c
}
   1548e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   15490:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   15494:	f240 11ad 	movw	r1, #429	; 0x1ad
   15498:	f2c0 0003 	movt	r0, #3
   1549c:	f005 fe08 	bl	1b0b0 <assert_failed>
   154a0:	e7b7      	b.n	15412 <SDMMC_ConfigData+0xe>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
   154a2:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   154a6:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
   154aa:	f2c0 0003 	movt	r0, #3
   154ae:	f005 fdff 	bl	1b0b0 <assert_failed>
   154b2:	e7d0      	b.n	15456 <SDMMC_ConfigData+0x52>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
   154b4:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   154b8:	f240 11af 	movw	r1, #431	; 0x1af
   154bc:	f2c0 0003 	movt	r0, #3
   154c0:	f005 fdf6 	bl	1b0b0 <assert_failed>
   154c4:	e7c3      	b.n	1544e <SDMMC_ConfigData+0x4a>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
   154c6:	f643 20e0 	movw	r0, #15072	; 0x3ae0
   154ca:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   154ce:	f2c0 0003 	movt	r0, #3
   154d2:	f005 fded 	bl	1b0b0 <assert_failed>
   154d6:	e7b6      	b.n	15446 <SDMMC_ConfigData+0x42>

000154d8 <SDMMC_CmdBlockLength>:
{
   154d8:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   154da:	f246 25b4 	movw	r5, #25268	; 0x62b4
   154de:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   154e2:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   154e6:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   154e8:	f2c0 0506 	movt	r5, #6
   154ec:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   154f0:	68c1      	ldr	r1, [r0, #12]
   154f2:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   154f6:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   154f8:	f241 1510 	movw	r5, #4368	; 0x1110
   154fc:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   154fe:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15500:	fba3 3202 	umull	r3, r2, r3, r2
   15504:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15508:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1550a:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1550e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15510:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15512:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   15516:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1551a:	d314      	bcc.n	15546 <SDMMC_CmdBlockLength+0x6e>
    sta_reg = SDMMCx->STA;
   1551c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   1551e:	420a      	tst	r2, r1
   15520:	d0f9      	beq.n	15516 <SDMMC_CmdBlockLength+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15522:	0494      	lsls	r4, r2, #18
   15524:	d4f7      	bmi.n	15516 <SDMMC_CmdBlockLength+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15526:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15528:	075a      	lsls	r2, r3, #29
   1552a:	d410      	bmi.n	1554e <SDMMC_CmdBlockLength+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   1552c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1552e:	07db      	lsls	r3, r3, #31
   15530:	d411      	bmi.n	15556 <SDMMC_CmdBlockLength+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15532:	23c5      	movs	r3, #197	; 0xc5
   15534:	f2c0 0320 	movt	r3, #32
   15538:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   1553a:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   1553c:	b2db      	uxtb	r3, r3
   1553e:	2b10      	cmp	r3, #16
   15540:	d00d      	beq.n	1555e <SDMMC_CmdBlockLength+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15542:	2001      	movs	r0, #1
  return errorstate;
   15544:	e001      	b.n	1554a <SDMMC_CmdBlockLength+0x72>
      return SDMMC_ERROR_TIMEOUT;
   15546:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1554a:	bc30      	pop	{r4, r5}
   1554c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   1554e:	2304      	movs	r3, #4
   15550:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15552:	4618      	mov	r0, r3
   15554:	e7f9      	b.n	1554a <SDMMC_CmdBlockLength+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15556:	2301      	movs	r3, #1
   15558:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1555a:	4618      	mov	r0, r3
   1555c:	e7f5      	b.n	1554a <SDMMC_CmdBlockLength+0x72>
}
   1555e:	bc30      	pop	{r4, r5}
   15560:	f7ff be52 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

00015564 <SDMMC_CmdReadSingleBlock>:
{
   15564:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15566:	f246 25b4 	movw	r5, #25268	; 0x62b4
   1556a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1556e:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15572:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15574:	f2c0 0506 	movt	r5, #6
   15578:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1557c:	68c1      	ldr	r1, [r0, #12]
   1557e:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15582:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15584:	f241 1511 	movw	r5, #4369	; 0x1111
   15588:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1558a:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1558c:	fba3 3202 	umull	r3, r2, r3, r2
   15590:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15594:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15596:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1559a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1559c:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1559e:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   155a2:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   155a6:	d314      	bcc.n	155d2 <SDMMC_CmdReadSingleBlock+0x6e>
    sta_reg = SDMMCx->STA;
   155a8:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   155aa:	420a      	tst	r2, r1
   155ac:	d0f9      	beq.n	155a2 <SDMMC_CmdReadSingleBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   155ae:	0494      	lsls	r4, r2, #18
   155b0:	d4f7      	bmi.n	155a2 <SDMMC_CmdReadSingleBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   155b2:	6b43      	ldr	r3, [r0, #52]	; 0x34
   155b4:	075a      	lsls	r2, r3, #29
   155b6:	d410      	bmi.n	155da <SDMMC_CmdReadSingleBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   155b8:	6b43      	ldr	r3, [r0, #52]	; 0x34
   155ba:	07db      	lsls	r3, r3, #31
   155bc:	d411      	bmi.n	155e2 <SDMMC_CmdReadSingleBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   155be:	23c5      	movs	r3, #197	; 0xc5
   155c0:	f2c0 0320 	movt	r3, #32
   155c4:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   155c6:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   155c8:	b2db      	uxtb	r3, r3
   155ca:	2b11      	cmp	r3, #17
   155cc:	d00d      	beq.n	155ea <SDMMC_CmdReadSingleBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   155ce:	2001      	movs	r0, #1
  return errorstate;
   155d0:	e001      	b.n	155d6 <SDMMC_CmdReadSingleBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
   155d2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   155d6:	bc30      	pop	{r4, r5}
   155d8:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   155da:	2304      	movs	r3, #4
   155dc:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   155de:	4618      	mov	r0, r3
   155e0:	e7f9      	b.n	155d6 <SDMMC_CmdReadSingleBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   155e2:	2301      	movs	r3, #1
   155e4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   155e6:	4618      	mov	r0, r3
   155e8:	e7f5      	b.n	155d6 <SDMMC_CmdReadSingleBlock+0x72>
}
   155ea:	bc30      	pop	{r4, r5}
   155ec:	f7ff be0c 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

000155f0 <SDMMC_CmdReadMultiBlock>:
{
   155f0:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   155f2:	f246 25b4 	movw	r5, #25268	; 0x62b4
   155f6:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   155fa:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   155fe:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15600:	f2c0 0506 	movt	r5, #6
   15604:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15608:	68c1      	ldr	r1, [r0, #12]
   1560a:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1560e:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15610:	f241 1512 	movw	r5, #4370	; 0x1112
   15614:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15616:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15618:	fba3 3202 	umull	r3, r2, r3, r2
   1561c:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15620:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15622:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15626:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15628:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1562a:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   1562e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15632:	d314      	bcc.n	1565e <SDMMC_CmdReadMultiBlock+0x6e>
    sta_reg = SDMMCx->STA;
   15634:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15636:	420a      	tst	r2, r1
   15638:	d0f9      	beq.n	1562e <SDMMC_CmdReadMultiBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1563a:	0494      	lsls	r4, r2, #18
   1563c:	d4f7      	bmi.n	1562e <SDMMC_CmdReadMultiBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1563e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15640:	075a      	lsls	r2, r3, #29
   15642:	d410      	bmi.n	15666 <SDMMC_CmdReadMultiBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15644:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15646:	07db      	lsls	r3, r3, #31
   15648:	d411      	bmi.n	1566e <SDMMC_CmdReadMultiBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   1564a:	23c5      	movs	r3, #197	; 0xc5
   1564c:	f2c0 0320 	movt	r3, #32
   15650:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15652:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15654:	b2db      	uxtb	r3, r3
   15656:	2b12      	cmp	r3, #18
   15658:	d00d      	beq.n	15676 <SDMMC_CmdReadMultiBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1565a:	2001      	movs	r0, #1
  return errorstate;
   1565c:	e001      	b.n	15662 <SDMMC_CmdReadMultiBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
   1565e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15662:	bc30      	pop	{r4, r5}
   15664:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15666:	2304      	movs	r3, #4
   15668:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   1566a:	4618      	mov	r0, r3
   1566c:	e7f9      	b.n	15662 <SDMMC_CmdReadMultiBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1566e:	2301      	movs	r3, #1
   15670:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15672:	4618      	mov	r0, r3
   15674:	e7f5      	b.n	15662 <SDMMC_CmdReadMultiBlock+0x72>
}
   15676:	bc30      	pop	{r4, r5}
   15678:	f7ff bdc6 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

0001567c <SDMMC_CmdWriteSingleBlock>:
{
   1567c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1567e:	f246 25b4 	movw	r5, #25268	; 0x62b4
   15682:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15686:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   1568a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1568c:	f2c0 0506 	movt	r5, #6
   15690:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15694:	68c1      	ldr	r1, [r0, #12]
   15696:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1569a:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1569c:	f241 1518 	movw	r5, #4376	; 0x1118
   156a0:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   156a2:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   156a4:	fba3 3202 	umull	r3, r2, r3, r2
   156a8:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   156ac:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   156ae:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   156b2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   156b4:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   156b6:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   156ba:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   156be:	d314      	bcc.n	156ea <SDMMC_CmdWriteSingleBlock+0x6e>
    sta_reg = SDMMCx->STA;
   156c0:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   156c2:	420a      	tst	r2, r1
   156c4:	d0f9      	beq.n	156ba <SDMMC_CmdWriteSingleBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   156c6:	0494      	lsls	r4, r2, #18
   156c8:	d4f7      	bmi.n	156ba <SDMMC_CmdWriteSingleBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   156ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
   156cc:	075a      	lsls	r2, r3, #29
   156ce:	d410      	bmi.n	156f2 <SDMMC_CmdWriteSingleBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   156d0:	6b43      	ldr	r3, [r0, #52]	; 0x34
   156d2:	07db      	lsls	r3, r3, #31
   156d4:	d411      	bmi.n	156fa <SDMMC_CmdWriteSingleBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   156d6:	23c5      	movs	r3, #197	; 0xc5
   156d8:	f2c0 0320 	movt	r3, #32
   156dc:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   156de:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   156e0:	b2db      	uxtb	r3, r3
   156e2:	2b18      	cmp	r3, #24
   156e4:	d00d      	beq.n	15702 <SDMMC_CmdWriteSingleBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   156e6:	2001      	movs	r0, #1
  return errorstate;
   156e8:	e001      	b.n	156ee <SDMMC_CmdWriteSingleBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
   156ea:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   156ee:	bc30      	pop	{r4, r5}
   156f0:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   156f2:	2304      	movs	r3, #4
   156f4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   156f6:	4618      	mov	r0, r3
   156f8:	e7f9      	b.n	156ee <SDMMC_CmdWriteSingleBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   156fa:	2301      	movs	r3, #1
   156fc:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   156fe:	4618      	mov	r0, r3
   15700:	e7f5      	b.n	156ee <SDMMC_CmdWriteSingleBlock+0x72>
}
   15702:	bc30      	pop	{r4, r5}
   15704:	f7ff bd80 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

00015708 <SDMMC_CmdWriteMultiBlock>:
{
   15708:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1570a:	f246 25b4 	movw	r5, #25268	; 0x62b4
   1570e:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15712:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15716:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15718:	f2c0 0506 	movt	r5, #6
   1571c:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15720:	68c1      	ldr	r1, [r0, #12]
   15722:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15726:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15728:	f241 1519 	movw	r5, #4377	; 0x1119
   1572c:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1572e:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15730:	fba3 3202 	umull	r3, r2, r3, r2
   15734:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15738:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1573a:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1573e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15740:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15742:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   15746:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1574a:	d314      	bcc.n	15776 <SDMMC_CmdWriteMultiBlock+0x6e>
    sta_reg = SDMMCx->STA;
   1574c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   1574e:	420a      	tst	r2, r1
   15750:	d0f9      	beq.n	15746 <SDMMC_CmdWriteMultiBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15752:	0494      	lsls	r4, r2, #18
   15754:	d4f7      	bmi.n	15746 <SDMMC_CmdWriteMultiBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15756:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15758:	075a      	lsls	r2, r3, #29
   1575a:	d410      	bmi.n	1577e <SDMMC_CmdWriteMultiBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   1575c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1575e:	07db      	lsls	r3, r3, #31
   15760:	d411      	bmi.n	15786 <SDMMC_CmdWriteMultiBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15762:	23c5      	movs	r3, #197	; 0xc5
   15764:	f2c0 0320 	movt	r3, #32
   15768:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   1576a:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   1576c:	b2db      	uxtb	r3, r3
   1576e:	2b19      	cmp	r3, #25
   15770:	d00d      	beq.n	1578e <SDMMC_CmdWriteMultiBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15772:	2001      	movs	r0, #1
  return errorstate;
   15774:	e001      	b.n	1577a <SDMMC_CmdWriteMultiBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
   15776:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1577a:	bc30      	pop	{r4, r5}
   1577c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   1577e:	2304      	movs	r3, #4
   15780:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15782:	4618      	mov	r0, r3
   15784:	e7f9      	b.n	1577a <SDMMC_CmdWriteMultiBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15786:	2301      	movs	r3, #1
   15788:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1578a:	4618      	mov	r0, r3
   1578c:	e7f5      	b.n	1577a <SDMMC_CmdWriteMultiBlock+0x72>
}
   1578e:	bc30      	pop	{r4, r5}
   15790:	f7ff bd3a 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

00015794 <SDMMC_CmdStopTransfer>:
{
   15794:	b570      	push	{r4, r5, r6, lr}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15796:	f246 25b4 	movw	r5, #25268	; 0x62b4
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   1579a:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1579c:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  SDMMCx->ARG = Command->Argument;
   157a0:	2600      	movs	r6, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157a2:	f2c0 0506 	movt	r5, #6
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   157a6:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157aa:	f2c1 0262 	movt	r2, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157ae:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   157b2:	60c1      	str	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157b4:	682b      	ldr	r3, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157b6:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   157ba:	68c1      	ldr	r1, [r0, #12]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157bc:	f241 150c 	movw	r5, #4364	; 0x110c
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157c0:	fba2 2303 	umull	r2, r3, r2, r3
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   157c4:	f021 0140 	bic.w	r1, r1, #64	; 0x40
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157c8:	0a5a      	lsrs	r2, r3, #9
   157ca:	f44f 4361 	mov.w	r3, #57600	; 0xe100
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   157ce:	60c1      	str	r1, [r0, #12]
  SDMMCx->ARG = Command->Argument;
   157d0:	6086      	str	r6, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157d2:	f2c0 53f5 	movt	r3, #1525	; 0x5f5
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157d6:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   157d8:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157dc:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   157de:	2145      	movs	r1, #69	; 0x45
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157e0:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   157e2:	f2c0 0120 	movt	r1, #32
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   157e6:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
   157e8:	b1d3      	cbz	r3, 15820 <SDMMC_CmdStopTransfer+0x8c>
    sta_reg = SDMMCx->STA;
   157ea:	6b42      	ldr	r2, [r0, #52]	; 0x34
   157ec:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   157ee:	420a      	tst	r2, r1
   157f0:	d0fa      	beq.n	157e8 <SDMMC_CmdStopTransfer+0x54>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   157f2:	0492      	lsls	r2, r2, #18
   157f4:	d4f8      	bmi.n	157e8 <SDMMC_CmdStopTransfer+0x54>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   157f6:	6b43      	ldr	r3, [r0, #52]	; 0x34
   157f8:	075b      	lsls	r3, r3, #29
   157fa:	d419      	bmi.n	15830 <SDMMC_CmdStopTransfer+0x9c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   157fc:	6b44      	ldr	r4, [r0, #52]	; 0x34
   157fe:	f014 0401 	ands.w	r4, r4, #1
   15802:	d11c      	bne.n	1583e <SDMMC_CmdStopTransfer+0xaa>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15804:	23c5      	movs	r3, #197	; 0xc5
   15806:	f2c0 0320 	movt	r3, #32
   1580a:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   1580c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   1580e:	b2db      	uxtb	r3, r3
   15810:	2b0c      	cmp	r3, #12
   15812:	d01b      	beq.n	1584c <SDMMC_CmdStopTransfer+0xb8>
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   15814:	68c3      	ldr	r3, [r0, #12]
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15816:	2401      	movs	r4, #1
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   15818:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1581c:	60c3      	str	r3, [r0, #12]
   1581e:	e005      	b.n	1582c <SDMMC_CmdStopTransfer+0x98>
   15820:	68c3      	ldr	r3, [r0, #12]
      return SDMMC_ERROR_TIMEOUT;
   15822:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   15826:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1582a:	60c3      	str	r3, [r0, #12]
}
   1582c:	4620      	mov	r0, r4
   1582e:	bd70      	pop	{r4, r5, r6, pc}
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15830:	2404      	movs	r4, #4
   15832:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   15834:	68c3      	ldr	r3, [r0, #12]
   15836:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1583a:	60c3      	str	r3, [r0, #12]
   1583c:	e7f6      	b.n	1582c <SDMMC_CmdStopTransfer+0x98>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1583e:	2401      	movs	r4, #1
   15840:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   15842:	68c3      	ldr	r3, [r0, #12]
   15844:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   15848:	60c3      	str	r3, [r0, #12]
   1584a:	e7ef      	b.n	1582c <SDMMC_CmdStopTransfer+0x98>
   1584c:	4605      	mov	r5, r0
   1584e:	f7ff fcdb 	bl	15208 <SDMMC_GetCmdResp1.part.2>
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
   15852:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
   15856:	bf18      	it	ne
   15858:	4604      	movne	r4, r0
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   1585a:	68eb      	ldr	r3, [r5, #12]
   1585c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   15860:	60eb      	str	r3, [r5, #12]
   15862:	e7e3      	b.n	1582c <SDMMC_CmdStopTransfer+0x98>

00015864 <SDMMC_CmdSelDesel>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15864:	f246 21b4 	movw	r1, #25268	; 0x62b4
   15868:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   1586c:	f2c0 0106 	movt	r1, #6
   15870:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
   15874:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   15876:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15878:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1587c:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1587e:	f241 1507 	movw	r5, #4359	; 0x1107
   15882:	68c1      	ldr	r1, [r0, #12]
   15884:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15888:	fba3 3202 	umull	r3, r2, r3, r2
   1588c:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15890:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15892:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15894:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15896:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15898:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1589c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   158a0:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
   158a2:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   158a6:	d314      	bcc.n	158d2 <SDMMC_CmdSelDesel+0x6e>
    sta_reg = SDMMCx->STA;
   158a8:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   158aa:	420a      	tst	r2, r1
   158ac:	d0f9      	beq.n	158a2 <SDMMC_CmdSelDesel+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   158ae:	0494      	lsls	r4, r2, #18
   158b0:	d4f7      	bmi.n	158a2 <SDMMC_CmdSelDesel+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   158b2:	6b43      	ldr	r3, [r0, #52]	; 0x34
   158b4:	075a      	lsls	r2, r3, #29
   158b6:	d410      	bmi.n	158da <SDMMC_CmdSelDesel+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   158b8:	6b43      	ldr	r3, [r0, #52]	; 0x34
   158ba:	07db      	lsls	r3, r3, #31
   158bc:	d411      	bmi.n	158e2 <SDMMC_CmdSelDesel+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   158be:	23c5      	movs	r3, #197	; 0xc5
   158c0:	f2c0 0320 	movt	r3, #32
   158c4:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   158c6:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   158c8:	b2db      	uxtb	r3, r3
   158ca:	2b07      	cmp	r3, #7
   158cc:	d00d      	beq.n	158ea <SDMMC_CmdSelDesel+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   158ce:	2001      	movs	r0, #1
  return errorstate;
   158d0:	e001      	b.n	158d6 <SDMMC_CmdSelDesel+0x72>
      return SDMMC_ERROR_TIMEOUT;
   158d2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   158d6:	bc30      	pop	{r4, r5}
   158d8:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   158da:	2304      	movs	r3, #4
   158dc:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   158de:	4618      	mov	r0, r3
   158e0:	e7f9      	b.n	158d6 <SDMMC_CmdSelDesel+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   158e2:	2301      	movs	r3, #1
   158e4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   158e6:	4618      	mov	r0, r3
   158e8:	e7f5      	b.n	158d6 <SDMMC_CmdSelDesel+0x72>
}
   158ea:	bc30      	pop	{r4, r5}
   158ec:	f7ff bc8c 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

000158f0 <SDMMC_CmdGoIdleState>:
{
   158f0:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   158f2:	f246 24b4 	movw	r4, #25268	; 0x62b4
{
   158f6:	4602      	mov	r2, r0
  SDMMCx->ARG = Command->Argument;
   158f8:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   158fa:	f644 55d3 	movw	r5, #19923	; 0x4dd3
   158fe:	f2c0 0406 	movt	r4, #6
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15902:	f24e 01c0 	movw	r1, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15906:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15908:	f2c1 0562 	movt	r5, #4194	; 0x1062
   1590c:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1590e:	f6cf 71fe 	movt	r1, #65534	; 0xfffe
   15912:	68d4      	ldr	r4, [r2, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15914:	f241 3388 	movw	r3, #5000	; 0x1388
   15918:	fba5 5000 	umull	r5, r0, r5, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1591c:	4021      	ands	r1, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1591e:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15920:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15924:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15928:	60d1      	str	r1, [r2, #12]
   1592a:	e002      	b.n	15932 <SDMMC_CmdGoIdleState+0x42>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
   1592c:	6b51      	ldr	r1, [r2, #52]	; 0x34
   1592e:	0609      	lsls	r1, r1, #24
   15930:	d406      	bmi.n	15940 <SDMMC_CmdGoIdleState+0x50>
    if (count-- == 0U)
   15932:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15936:	d2f9      	bcs.n	1592c <SDMMC_CmdGoIdleState+0x3c>
      return SDMMC_ERROR_TIMEOUT;
   15938:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1593c:	bc30      	pop	{r4, r5}
   1593e:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15940:	23c5      	movs	r3, #197	; 0xc5
  return SDMMC_ERROR_NONE;
   15942:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15944:	f2c0 0320 	movt	r3, #32
   15948:	6393      	str	r3, [r2, #56]	; 0x38
}
   1594a:	bc30      	pop	{r4, r5}
   1594c:	4770      	bx	lr
   1594e:	bf00      	nop

00015950 <SDMMC_CmdOperCond>:
{
   15950:	b430      	push	{r4, r5}
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15952:	f246 24b4 	movw	r4, #25268	; 0x62b4
{
   15956:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
   15958:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1595c:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   15960:	f2c0 0406 	movt	r4, #6
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15964:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15968:	608a      	str	r2, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1596a:	f2c1 0362 	movt	r3, #4194	; 0x1062
   1596e:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15970:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
   15974:	68cd      	ldr	r5, [r1, #12]
   15976:	f241 1408 	movw	r4, #4360	; 0x1108
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1597a:	fba3 3202 	umull	r3, r2, r3, r2
   1597e:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15982:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15984:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15986:	4304      	orrs	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15988:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1598c:	60cc      	str	r4, [r1, #12]

  do
  {
    if (count-- == 0U)
   1598e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15992:	d313      	bcc.n	159bc <SDMMC_CmdOperCond+0x6c>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
   15994:	6b4a      	ldr	r2, [r1, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15996:	f012 0f45 	tst.w	r2, #69	; 0x45
   1599a:	d0f8      	beq.n	1598e <SDMMC_CmdOperCond+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   1599c:	0492      	lsls	r2, r2, #18
   1599e:	d4f6      	bmi.n	1598e <SDMMC_CmdOperCond+0x3e>

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   159a0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   159a2:	075b      	lsls	r3, r3, #29
   159a4:	d40e      	bmi.n	159c4 <SDMMC_CmdOperCond+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   159a6:	6b48      	ldr	r0, [r1, #52]	; 0x34
   159a8:	f010 0001 	ands.w	r0, r0, #1
   159ac:	d10d      	bne.n	159ca <SDMMC_CmdOperCond+0x7a>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
   159ae:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   159b0:	f013 0340 	ands.w	r3, r3, #64	; 0x40
   159b4:	d00c      	beq.n	159d0 <SDMMC_CmdOperCond+0x80>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
   159b6:	2340      	movs	r3, #64	; 0x40
   159b8:	638b      	str	r3, [r1, #56]	; 0x38
   159ba:	e001      	b.n	159c0 <SDMMC_CmdOperCond+0x70>
      return SDMMC_ERROR_TIMEOUT;
   159bc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   159c0:	bc30      	pop	{r4, r5}
   159c2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   159c4:	2004      	movs	r0, #4
   159c6:	6388      	str	r0, [r1, #56]	; 0x38
   159c8:	e7fa      	b.n	159c0 <SDMMC_CmdOperCond+0x70>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   159ca:	2001      	movs	r0, #1
   159cc:	6388      	str	r0, [r1, #56]	; 0x38
   159ce:	e7f7      	b.n	159c0 <SDMMC_CmdOperCond+0x70>
  }

  return SDMMC_ERROR_NONE;
   159d0:	4618      	mov	r0, r3
  return errorstate;
   159d2:	e7f5      	b.n	159c0 <SDMMC_CmdOperCond+0x70>

000159d4 <SDMMC_CmdAppCommand>:
{
   159d4:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   159d6:	f246 25b4 	movw	r5, #25268	; 0x62b4
   159da:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   159de:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   159e2:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   159e4:	f2c0 0506 	movt	r5, #6
   159e8:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   159ec:	68c1      	ldr	r1, [r0, #12]
   159ee:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   159f2:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   159f4:	f241 1537 	movw	r5, #4407	; 0x1137
   159f8:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   159fa:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   159fc:	fba3 3202 	umull	r3, r2, r3, r2
   15a00:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a04:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15a06:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15a0a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a0c:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15a0e:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   15a12:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15a16:	d314      	bcc.n	15a42 <SDMMC_CmdAppCommand+0x6e>
    sta_reg = SDMMCx->STA;
   15a18:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15a1a:	420a      	tst	r2, r1
   15a1c:	d0f9      	beq.n	15a12 <SDMMC_CmdAppCommand+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15a1e:	0494      	lsls	r4, r2, #18
   15a20:	d4f7      	bmi.n	15a12 <SDMMC_CmdAppCommand+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15a22:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15a24:	075a      	lsls	r2, r3, #29
   15a26:	d410      	bmi.n	15a4a <SDMMC_CmdAppCommand+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15a28:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15a2a:	07db      	lsls	r3, r3, #31
   15a2c:	d411      	bmi.n	15a52 <SDMMC_CmdAppCommand+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15a2e:	23c5      	movs	r3, #197	; 0xc5
   15a30:	f2c0 0320 	movt	r3, #32
   15a34:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15a36:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15a38:	b2db      	uxtb	r3, r3
   15a3a:	2b37      	cmp	r3, #55	; 0x37
   15a3c:	d00d      	beq.n	15a5a <SDMMC_CmdAppCommand+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15a3e:	2001      	movs	r0, #1
  return errorstate;
   15a40:	e001      	b.n	15a46 <SDMMC_CmdAppCommand+0x72>
      return SDMMC_ERROR_TIMEOUT;
   15a42:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15a46:	bc30      	pop	{r4, r5}
   15a48:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15a4a:	2304      	movs	r3, #4
   15a4c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15a4e:	4618      	mov	r0, r3
   15a50:	e7f9      	b.n	15a46 <SDMMC_CmdAppCommand+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15a52:	2301      	movs	r3, #1
   15a54:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15a56:	4618      	mov	r0, r3
   15a58:	e7f5      	b.n	15a46 <SDMMC_CmdAppCommand+0x72>
}
   15a5a:	bc30      	pop	{r4, r5}
   15a5c:	f7ff bbd4 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

00015a60 <SDMMC_CmdAppOperCommand>:
{
   15a60:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15a62:	f246 25b4 	movw	r5, #25268	; 0x62b4
   15a66:	f644 53d3 	movw	r3, #19923	; 0x4dd3
{
   15a6a:	4604      	mov	r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a6c:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15a70:	f2c0 0506 	movt	r5, #6
   15a74:	f2c1 0362 	movt	r3, #4194	; 0x1062
  SDMMCx->ARG = Command->Argument;
   15a78:	60a1      	str	r1, [r4, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a7a:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15a7e:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a80:	f241 1129 	movw	r1, #4393	; 0x1129
   15a84:	68e5      	ldr	r5, [r4, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15a86:	fba3 3202 	umull	r3, r2, r3, r2
   15a8a:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a8e:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15a90:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a92:	4301      	orrs	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15a94:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15a98:	60e1      	str	r1, [r4, #12]
    if (count-- == 0U)
   15a9a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15a9e:	d30f      	bcc.n	15ac0 <SDMMC_CmdAppOperCommand+0x60>
    sta_reg = SDMMCx->STA;
   15aa0:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15aa2:	f012 0f45 	tst.w	r2, #69	; 0x45
   15aa6:	d0f8      	beq.n	15a9a <SDMMC_CmdAppOperCommand+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   15aa8:	0492      	lsls	r2, r2, #18
   15aaa:	d4f6      	bmi.n	15a9a <SDMMC_CmdAppOperCommand+0x3a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15aac:	6b60      	ldr	r0, [r4, #52]	; 0x34
   15aae:	f010 0004 	ands.w	r0, r0, #4
   15ab2:	d109      	bne.n	15ac8 <SDMMC_CmdAppOperCommand+0x68>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15ab4:	23c5      	movs	r3, #197	; 0xc5
   15ab6:	f2c0 0320 	movt	r3, #32
   15aba:	63a3      	str	r3, [r4, #56]	; 0x38
}
   15abc:	bc30      	pop	{r4, r5}
   15abe:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
   15ac0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15ac4:	bc30      	pop	{r4, r5}
   15ac6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15ac8:	2004      	movs	r0, #4
   15aca:	63a0      	str	r0, [r4, #56]	; 0x38
   15acc:	e7fa      	b.n	15ac4 <SDMMC_CmdAppOperCommand+0x64>
   15ace:	bf00      	nop

00015ad0 <SDMMC_CmdBusWidth>:
{
   15ad0:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15ad2:	f246 25b4 	movw	r5, #25268	; 0x62b4
   15ad6:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ada:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15ade:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15ae0:	f2c0 0506 	movt	r5, #6
   15ae4:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ae8:	68c1      	ldr	r1, [r0, #12]
   15aea:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15aee:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15af0:	f241 1506 	movw	r5, #4358	; 0x1106
   15af4:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15af6:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15af8:	fba3 3202 	umull	r3, r2, r3, r2
   15afc:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b00:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15b02:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b06:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b08:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b0a:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   15b0e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15b12:	d314      	bcc.n	15b3e <SDMMC_CmdBusWidth+0x6e>
    sta_reg = SDMMCx->STA;
   15b14:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15b16:	420a      	tst	r2, r1
   15b18:	d0f9      	beq.n	15b0e <SDMMC_CmdBusWidth+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15b1a:	0494      	lsls	r4, r2, #18
   15b1c:	d4f7      	bmi.n	15b0e <SDMMC_CmdBusWidth+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15b1e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15b20:	075a      	lsls	r2, r3, #29
   15b22:	d410      	bmi.n	15b46 <SDMMC_CmdBusWidth+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15b24:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15b26:	07db      	lsls	r3, r3, #31
   15b28:	d411      	bmi.n	15b4e <SDMMC_CmdBusWidth+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15b2a:	23c5      	movs	r3, #197	; 0xc5
   15b2c:	f2c0 0320 	movt	r3, #32
   15b30:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15b32:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15b34:	b2db      	uxtb	r3, r3
   15b36:	2b06      	cmp	r3, #6
   15b38:	d00d      	beq.n	15b56 <SDMMC_CmdBusWidth+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15b3a:	2001      	movs	r0, #1
  return errorstate;
   15b3c:	e001      	b.n	15b42 <SDMMC_CmdBusWidth+0x72>
      return SDMMC_ERROR_TIMEOUT;
   15b3e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15b42:	bc30      	pop	{r4, r5}
   15b44:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15b46:	2304      	movs	r3, #4
   15b48:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15b4a:	4618      	mov	r0, r3
   15b4c:	e7f9      	b.n	15b42 <SDMMC_CmdBusWidth+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15b4e:	2301      	movs	r3, #1
   15b50:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15b52:	4618      	mov	r0, r3
   15b54:	e7f5      	b.n	15b42 <SDMMC_CmdBusWidth+0x72>
}
   15b56:	bc30      	pop	{r4, r5}
   15b58:	f7ff bb56 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

00015b5c <SDMMC_CmdSendSCR>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b5c:	f246 21b4 	movw	r1, #25268	; 0x62b4
  SDMMCx->ARG = Command->Argument;
   15b60:	2200      	movs	r2, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b62:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   15b66:	f2c0 0106 	movt	r1, #6
   15b6a:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
   15b6e:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   15b70:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b72:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b76:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b78:	f241 1533 	movw	r5, #4403	; 0x1133
   15b7c:	68c1      	ldr	r1, [r0, #12]
   15b7e:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b82:	fba3 3202 	umull	r3, r2, r3, r2
   15b86:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b8a:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15b8c:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b8e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b90:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15b92:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15b96:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15b9a:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
   15b9c:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15ba0:	d314      	bcc.n	15bcc <SDMMC_CmdSendSCR+0x70>
    sta_reg = SDMMCx->STA;
   15ba2:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15ba4:	420a      	tst	r2, r1
   15ba6:	d0f9      	beq.n	15b9c <SDMMC_CmdSendSCR+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15ba8:	0494      	lsls	r4, r2, #18
   15baa:	d4f7      	bmi.n	15b9c <SDMMC_CmdSendSCR+0x40>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15bac:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15bae:	075a      	lsls	r2, r3, #29
   15bb0:	d410      	bmi.n	15bd4 <SDMMC_CmdSendSCR+0x78>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15bb2:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15bb4:	07db      	lsls	r3, r3, #31
   15bb6:	d411      	bmi.n	15bdc <SDMMC_CmdSendSCR+0x80>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15bb8:	23c5      	movs	r3, #197	; 0xc5
   15bba:	f2c0 0320 	movt	r3, #32
   15bbe:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15bc0:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15bc2:	b2db      	uxtb	r3, r3
   15bc4:	2b33      	cmp	r3, #51	; 0x33
   15bc6:	d00d      	beq.n	15be4 <SDMMC_CmdSendSCR+0x88>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15bc8:	2001      	movs	r0, #1
  return errorstate;
   15bca:	e001      	b.n	15bd0 <SDMMC_CmdSendSCR+0x74>
      return SDMMC_ERROR_TIMEOUT;
   15bcc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15bd0:	bc30      	pop	{r4, r5}
   15bd2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15bd4:	2304      	movs	r3, #4
   15bd6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15bd8:	4618      	mov	r0, r3
   15bda:	e7f9      	b.n	15bd0 <SDMMC_CmdSendSCR+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15bdc:	2301      	movs	r3, #1
   15bde:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15be0:	4618      	mov	r0, r3
   15be2:	e7f5      	b.n	15bd0 <SDMMC_CmdSendSCR+0x74>
}
   15be4:	bc30      	pop	{r4, r5}
   15be6:	f7ff bb0f 	b.w	15208 <SDMMC_GetCmdResp1.part.2>
   15bea:	bf00      	nop

00015bec <SDMMC_CmdSendCID>:
{
   15bec:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15bee:	f246 24b4 	movw	r4, #25268	; 0x62b4
{
   15bf2:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
   15bf4:	2200      	movs	r2, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15bf6:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   15bfa:	f2c0 0406 	movt	r4, #6
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15bfe:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15c02:	608a      	str	r2, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c04:	f2c1 0362 	movt	r3, #4194	; 0x1062
   15c08:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c0a:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
   15c0e:	68cd      	ldr	r5, [r1, #12]
   15c10:	f241 3402 	movw	r4, #4866	; 0x1302
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c14:	fba3 3202 	umull	r3, r2, r3, r2
   15c18:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c1c:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c1e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c20:	4304      	orrs	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c22:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c26:	60cc      	str	r4, [r1, #12]
    if (count-- == 0U)
   15c28:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15c2c:	d311      	bcc.n	15c52 <SDMMC_CmdSendCID+0x66>
    sta_reg = SDMMCx->STA;
   15c2e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15c30:	f012 0f45 	tst.w	r2, #69	; 0x45
   15c34:	d0f8      	beq.n	15c28 <SDMMC_CmdSendCID+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   15c36:	0492      	lsls	r2, r2, #18
   15c38:	d4f6      	bmi.n	15c28 <SDMMC_CmdSendCID+0x3c>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15c3a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   15c3c:	075b      	lsls	r3, r3, #29
   15c3e:	d40c      	bmi.n	15c5a <SDMMC_CmdSendCID+0x6e>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15c40:	6b48      	ldr	r0, [r1, #52]	; 0x34
   15c42:	f010 0001 	ands.w	r0, r0, #1
   15c46:	d10b      	bne.n	15c60 <SDMMC_CmdSendCID+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15c48:	23c5      	movs	r3, #197	; 0xc5
   15c4a:	f2c0 0320 	movt	r3, #32
   15c4e:	638b      	str	r3, [r1, #56]	; 0x38
   15c50:	e001      	b.n	15c56 <SDMMC_CmdSendCID+0x6a>
      return SDMMC_ERROR_TIMEOUT;
   15c52:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15c56:	bc30      	pop	{r4, r5}
   15c58:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15c5a:	2004      	movs	r0, #4
   15c5c:	6388      	str	r0, [r1, #56]	; 0x38
   15c5e:	e7fa      	b.n	15c56 <SDMMC_CmdSendCID+0x6a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15c60:	2001      	movs	r0, #1
   15c62:	6388      	str	r0, [r1, #56]	; 0x38
   15c64:	e7f7      	b.n	15c56 <SDMMC_CmdSendCID+0x6a>
   15c66:	bf00      	nop

00015c68 <SDMMC_CmdSendCSD>:
{
   15c68:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c6a:	f246 25b4 	movw	r5, #25268	; 0x62b4
   15c6e:	f644 53d3 	movw	r3, #19923	; 0x4dd3
{
   15c72:	4604      	mov	r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c74:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c78:	f2c0 0506 	movt	r5, #6
   15c7c:	f2c1 0362 	movt	r3, #4194	; 0x1062
  SDMMCx->ARG = Command->Argument;
   15c80:	60a1      	str	r1, [r4, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c82:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c86:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c88:	f241 3109 	movw	r1, #4873	; 0x1309
   15c8c:	68e5      	ldr	r5, [r4, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c8e:	fba3 3202 	umull	r3, r2, r3, r2
   15c92:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c96:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c98:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15c9a:	4301      	orrs	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15c9c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ca0:	60e1      	str	r1, [r4, #12]
    if (count-- == 0U)
   15ca2:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15ca6:	d311      	bcc.n	15ccc <SDMMC_CmdSendCSD+0x64>
    sta_reg = SDMMCx->STA;
   15ca8:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15caa:	f012 0f45 	tst.w	r2, #69	; 0x45
   15cae:	d0f8      	beq.n	15ca2 <SDMMC_CmdSendCSD+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   15cb0:	0492      	lsls	r2, r2, #18
   15cb2:	d4f6      	bmi.n	15ca2 <SDMMC_CmdSendCSD+0x3a>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15cb4:	6b63      	ldr	r3, [r4, #52]	; 0x34
   15cb6:	075b      	lsls	r3, r3, #29
   15cb8:	d40c      	bmi.n	15cd4 <SDMMC_CmdSendCSD+0x6c>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15cba:	6b60      	ldr	r0, [r4, #52]	; 0x34
   15cbc:	f010 0001 	ands.w	r0, r0, #1
   15cc0:	d10b      	bne.n	15cda <SDMMC_CmdSendCSD+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15cc2:	23c5      	movs	r3, #197	; 0xc5
   15cc4:	f2c0 0320 	movt	r3, #32
   15cc8:	63a3      	str	r3, [r4, #56]	; 0x38
   15cca:	e001      	b.n	15cd0 <SDMMC_CmdSendCSD+0x68>
      return SDMMC_ERROR_TIMEOUT;
   15ccc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15cd0:	bc30      	pop	{r4, r5}
   15cd2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15cd4:	2004      	movs	r0, #4
   15cd6:	63a0      	str	r0, [r4, #56]	; 0x38
   15cd8:	e7fa      	b.n	15cd0 <SDMMC_CmdSendCSD+0x68>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15cda:	2001      	movs	r0, #1
   15cdc:	63a0      	str	r0, [r4, #56]	; 0x38
   15cde:	e7f7      	b.n	15cd0 <SDMMC_CmdSendCSD+0x68>

00015ce0 <SDMMC_CmdSetRelAdd>:
{
   15ce0:	b470      	push	{r4, r5, r6}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15ce2:	f246 25b4 	movw	r5, #25268	; 0x62b4
  SDMMCx->ARG = Command->Argument;
   15ce6:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15ce8:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15cec:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15cf0:	f2c0 0506 	movt	r5, #6
  SDMMCx->ARG = Command->Argument;
   15cf4:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15cf6:	f2c1 0262 	movt	r2, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15cfa:	68c6      	ldr	r6, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15cfc:	682b      	ldr	r3, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15cfe:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
   15d02:	f241 1503 	movw	r5, #4355	; 0x1103
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15d06:	fba2 3203 	umull	r3, r2, r2, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15d0a:	4034      	ands	r4, r6
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15d0c:	f241 3388 	movw	r3, #5000	; 0x1388
   15d10:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15d12:	4325      	orrs	r5, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   15d14:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15d18:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
   15d1a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15d1e:	d311      	bcc.n	15d44 <SDMMC_CmdSetRelAdd+0x64>
    sta_reg = SDMMCx->STA;
   15d20:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15d22:	f012 0f45 	tst.w	r2, #69	; 0x45
   15d26:	d0f8      	beq.n	15d1a <SDMMC_CmdSetRelAdd+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   15d28:	0496      	lsls	r6, r2, #18
   15d2a:	d4f6      	bmi.n	15d1a <SDMMC_CmdSetRelAdd+0x3a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15d2c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15d2e:	075d      	lsls	r5, r3, #29
   15d30:	d40c      	bmi.n	15d4c <SDMMC_CmdSetRelAdd+0x6c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15d32:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15d34:	07dc      	lsls	r4, r3, #31
   15d36:	d40d      	bmi.n	15d54 <SDMMC_CmdSetRelAdd+0x74>
  return (uint8_t)(SDMMCx->RESPCMD);
   15d38:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15d3a:	b2db      	uxtb	r3, r3
   15d3c:	2b03      	cmp	r3, #3
   15d3e:	d00d      	beq.n	15d5c <SDMMC_CmdSetRelAdd+0x7c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15d40:	2001      	movs	r0, #1
   15d42:	e001      	b.n	15d48 <SDMMC_CmdSetRelAdd+0x68>
      return SDMMC_ERROR_TIMEOUT;
   15d44:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15d48:	bc70      	pop	{r4, r5, r6}
   15d4a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15d4c:	2304      	movs	r3, #4
   15d4e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15d50:	4618      	mov	r0, r3
   15d52:	e7f9      	b.n	15d48 <SDMMC_CmdSetRelAdd+0x68>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15d54:	2301      	movs	r3, #1
   15d56:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15d58:	4618      	mov	r0, r3
   15d5a:	e7f5      	b.n	15d48 <SDMMC_CmdSetRelAdd+0x68>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15d5c:	23c5      	movs	r3, #197	; 0xc5
   15d5e:	f2c0 0320 	movt	r3, #32
   15d62:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
   15d64:	6943      	ldr	r3, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
   15d66:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
   15d6a:	d009      	beq.n	15d80 <SDMMC_CmdSetRelAdd+0xa0>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
   15d6c:	045a      	lsls	r2, r3, #17
   15d6e:	d40a      	bmi.n	15d86 <SDMMC_CmdSetRelAdd+0xa6>
    return SDMMC_ERROR_COM_CRC_FAILED;
   15d70:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   15d74:	bf0c      	ite	eq
   15d76:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   15d7a:	f44f 5080 	movne.w	r0, #4096	; 0x1000
   15d7e:	e7e3      	b.n	15d48 <SDMMC_CmdSetRelAdd+0x68>
    *pRCA = (uint16_t) (response_r1 >> 16);
   15d80:	0c1b      	lsrs	r3, r3, #16
   15d82:	800b      	strh	r3, [r1, #0]
   15d84:	e7e0      	b.n	15d48 <SDMMC_CmdSetRelAdd+0x68>
    return SDMMC_ERROR_ILLEGAL_CMD;
   15d86:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   15d8a:	e7dd      	b.n	15d48 <SDMMC_CmdSetRelAdd+0x68>

00015d8c <SDMMC_CmdSendStatus>:
{
   15d8c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15d8e:	f246 25b4 	movw	r5, #25268	; 0x62b4
   15d92:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15d96:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
   15d9a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15d9c:	f2c0 0506 	movt	r5, #6
   15da0:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15da4:	68c1      	ldr	r1, [r0, #12]
   15da6:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15daa:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15dac:	f241 150d 	movw	r5, #4365	; 0x110d
   15db0:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15db2:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15db4:	fba3 3202 	umull	r3, r2, r3, r2
   15db8:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15dbc:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15dbe:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15dc2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15dc4:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15dc6:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
   15dca:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15dce:	d314      	bcc.n	15dfa <SDMMC_CmdSendStatus+0x6e>
    sta_reg = SDMMCx->STA;
   15dd0:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15dd2:	420a      	tst	r2, r1
   15dd4:	d0f9      	beq.n	15dca <SDMMC_CmdSendStatus+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15dd6:	0494      	lsls	r4, r2, #18
   15dd8:	d4f7      	bmi.n	15dca <SDMMC_CmdSendStatus+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15dda:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15ddc:	075a      	lsls	r2, r3, #29
   15dde:	d410      	bmi.n	15e02 <SDMMC_CmdSendStatus+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15de0:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15de2:	07db      	lsls	r3, r3, #31
   15de4:	d411      	bmi.n	15e0a <SDMMC_CmdSendStatus+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15de6:	23c5      	movs	r3, #197	; 0xc5
   15de8:	f2c0 0320 	movt	r3, #32
   15dec:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15dee:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15df0:	b2db      	uxtb	r3, r3
   15df2:	2b0d      	cmp	r3, #13
   15df4:	d00d      	beq.n	15e12 <SDMMC_CmdSendStatus+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15df6:	2001      	movs	r0, #1
  return errorstate;
   15df8:	e001      	b.n	15dfe <SDMMC_CmdSendStatus+0x72>
      return SDMMC_ERROR_TIMEOUT;
   15dfa:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15dfe:	bc30      	pop	{r4, r5}
   15e00:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15e02:	2304      	movs	r3, #4
   15e04:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15e06:	4618      	mov	r0, r3
   15e08:	e7f9      	b.n	15dfe <SDMMC_CmdSendStatus+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15e0a:	2301      	movs	r3, #1
   15e0c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15e0e:	4618      	mov	r0, r3
   15e10:	e7f5      	b.n	15dfe <SDMMC_CmdSendStatus+0x72>
}
   15e12:	bc30      	pop	{r4, r5}
   15e14:	f7ff b9f8 	b.w	15208 <SDMMC_GetCmdResp1.part.2>

00015e18 <SDMMC_CmdStatusRegister>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15e18:	f246 21b4 	movw	r1, #25268	; 0x62b4
  SDMMCx->ARG = Command->Argument;
   15e1c:	2200      	movs	r2, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15e1e:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   15e22:	f2c0 0106 	movt	r1, #6
   15e26:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
   15e2a:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   15e2c:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15e2e:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15e32:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15e34:	f241 150d 	movw	r5, #4365	; 0x110d
   15e38:	68c1      	ldr	r1, [r0, #12]
   15e3a:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15e3e:	fba3 3202 	umull	r3, r2, r3, r2
   15e42:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15e46:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15e48:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15e4a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15e4c:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15e4e:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15e52:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15e56:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
   15e58:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15e5c:	d314      	bcc.n	15e88 <SDMMC_CmdStatusRegister+0x70>
    sta_reg = SDMMCx->STA;
   15e5e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15e60:	420a      	tst	r2, r1
   15e62:	d0f9      	beq.n	15e58 <SDMMC_CmdStatusRegister+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15e64:	0494      	lsls	r4, r2, #18
   15e66:	d4f7      	bmi.n	15e58 <SDMMC_CmdStatusRegister+0x40>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15e68:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15e6a:	075a      	lsls	r2, r3, #29
   15e6c:	d410      	bmi.n	15e90 <SDMMC_CmdStatusRegister+0x78>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15e6e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15e70:	07db      	lsls	r3, r3, #31
   15e72:	d411      	bmi.n	15e98 <SDMMC_CmdStatusRegister+0x80>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15e74:	23c5      	movs	r3, #197	; 0xc5
   15e76:	f2c0 0320 	movt	r3, #32
   15e7a:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15e7c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15e7e:	b2db      	uxtb	r3, r3
   15e80:	2b0d      	cmp	r3, #13
   15e82:	d00d      	beq.n	15ea0 <SDMMC_CmdStatusRegister+0x88>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15e84:	2001      	movs	r0, #1
  return errorstate;
   15e86:	e001      	b.n	15e8c <SDMMC_CmdStatusRegister+0x74>
      return SDMMC_ERROR_TIMEOUT;
   15e88:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15e8c:	bc30      	pop	{r4, r5}
   15e8e:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15e90:	2304      	movs	r3, #4
   15e92:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15e94:	4618      	mov	r0, r3
   15e96:	e7f9      	b.n	15e8c <SDMMC_CmdStatusRegister+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15e98:	2301      	movs	r3, #1
   15e9a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15e9c:	4618      	mov	r0, r3
   15e9e:	e7f5      	b.n	15e8c <SDMMC_CmdStatusRegister+0x74>
}
   15ea0:	bc30      	pop	{r4, r5}
   15ea2:	f7ff b9b1 	b.w	15208 <SDMMC_GetCmdResp1.part.2>
   15ea6:	bf00      	nop

00015ea8 <SDMMC_CmdVoltageSwitch>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15ea8:	f246 21b4 	movw	r1, #25268	; 0x62b4
  SDMMCx->ARG = Command->Argument;
   15eac:	2200      	movs	r2, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15eae:	f644 53d3 	movw	r3, #19923	; 0x4dd3
   15eb2:	f2c0 0106 	movt	r1, #6
   15eb6:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
   15eba:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   15ebc:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ebe:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15ec2:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ec4:	f241 150b 	movw	r5, #4363	; 0x110b
   15ec8:	68c1      	ldr	r1, [r0, #12]
   15eca:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15ece:	fba3 3202 	umull	r3, r2, r3, r2
   15ed2:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ed6:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15ed8:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15eda:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15edc:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15ede:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   15ee2:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   15ee6:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
   15ee8:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   15eec:	d314      	bcc.n	15f18 <SDMMC_CmdVoltageSwitch+0x70>
    sta_reg = SDMMCx->STA;
   15eee:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   15ef0:	420a      	tst	r2, r1
   15ef2:	d0f9      	beq.n	15ee8 <SDMMC_CmdVoltageSwitch+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   15ef4:	0494      	lsls	r4, r2, #18
   15ef6:	d4f7      	bmi.n	15ee8 <SDMMC_CmdVoltageSwitch+0x40>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   15ef8:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15efa:	075a      	lsls	r2, r3, #29
   15efc:	d410      	bmi.n	15f20 <SDMMC_CmdVoltageSwitch+0x78>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   15efe:	6b43      	ldr	r3, [r0, #52]	; 0x34
   15f00:	07db      	lsls	r3, r3, #31
   15f02:	d411      	bmi.n	15f28 <SDMMC_CmdVoltageSwitch+0x80>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   15f04:	23c5      	movs	r3, #197	; 0xc5
   15f06:	f2c0 0320 	movt	r3, #32
   15f0a:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   15f0c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   15f0e:	b2db      	uxtb	r3, r3
   15f10:	2b0b      	cmp	r3, #11
   15f12:	d00d      	beq.n	15f30 <SDMMC_CmdVoltageSwitch+0x88>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15f14:	2001      	movs	r0, #1
  return errorstate;
   15f16:	e001      	b.n	15f1c <SDMMC_CmdVoltageSwitch+0x74>
      return SDMMC_ERROR_TIMEOUT;
   15f18:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   15f1c:	bc30      	pop	{r4, r5}
   15f1e:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   15f20:	2304      	movs	r3, #4
   15f22:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   15f24:	4618      	mov	r0, r3
   15f26:	e7f9      	b.n	15f1c <SDMMC_CmdVoltageSwitch+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   15f28:	2301      	movs	r3, #1
   15f2a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   15f2c:	4618      	mov	r0, r3
   15f2e:	e7f5      	b.n	15f1c <SDMMC_CmdVoltageSwitch+0x74>
}
   15f30:	bc30      	pop	{r4, r5}
   15f32:	f7ff b969 	b.w	15208 <SDMMC_GetCmdResp1.part.2>
   15f36:	bf00      	nop

00015f38 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   15f38:	b084      	sub	sp, #16
   15f3a:	b430      	push	{r4, r5}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   15f3c:	9d08      	ldr	r5, [sp, #32]
{
   15f3e:	ac03      	add	r4, sp, #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   15f40:	2d01      	cmp	r5, #1
{
   15f42:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   15f46:	d13a      	bne.n	15fbe <USB_CoreInit+0x86>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   15f48:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   15f4a:	f64f 73bf 	movw	r3, #65471	; 0xffbf

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
   15f4e:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   15f50:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   15f54:	f6cf 73bd 	movt	r3, #65469	; 0xffbd
    if (cfg.use_external_vbus == 1U)
   15f58:	2901      	cmp	r1, #1
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   15f5a:	6382      	str	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   15f5c:	68c2      	ldr	r2, [r0, #12]
   15f5e:	ea03 0302 	and.w	r3, r3, r2
   15f62:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   15f64:	68c3      	ldr	r3, [r0, #12]
   15f66:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
   15f6a:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
   15f6c:	d050      	beq.n	16010 <USB_CoreInit+0xd8>
{
   15f6e:	f44f 6354 	mov.w	r3, #3392	; 0xd40
   15f72:	f2c0 0303 	movt	r3, #3
   15f76:	e001      	b.n	15f7c <USB_CoreInit+0x44>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
   15f78:	3b01      	subs	r3, #1
   15f7a:	d04e      	beq.n	1601a <USB_CoreInit+0xe2>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   15f7c:	6902      	ldr	r2, [r0, #16]
   15f7e:	2a00      	cmp	r2, #0
   15f80:	dafa      	bge.n	15f78 <USB_CoreInit+0x40>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   15f82:	6903      	ldr	r3, [r0, #16]
   15f84:	f44f 6254 	mov.w	r2, #3392	; 0xd40
   15f88:	f043 0301 	orr.w	r3, r3, #1
   15f8c:	f2c0 0203 	movt	r2, #3
   15f90:	6103      	str	r3, [r0, #16]
   15f92:	e001      	b.n	15f98 <USB_CoreInit+0x60>

  do
  {
    if (++count > 200000U)
   15f94:	3a01      	subs	r2, #1
   15f96:	d040      	beq.n	1601a <USB_CoreInit+0xe2>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   15f98:	6903      	ldr	r3, [r0, #16]
   15f9a:	f013 0301 	ands.w	r3, r3, #1
   15f9e:	d1f9      	bne.n	15f94 <USB_CoreInit+0x5c>
  if (cfg.dma_enable == 1U)
   15fa0:	9a06      	ldr	r2, [sp, #24]
   15fa2:	2a01      	cmp	r2, #1
   15fa4:	d107      	bne.n	15fb6 <USB_CoreInit+0x7e>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
   15fa6:	6882      	ldr	r2, [r0, #8]
   15fa8:	f042 0206 	orr.w	r2, r2, #6
   15fac:	6082      	str	r2, [r0, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   15fae:	6882      	ldr	r2, [r0, #8]
   15fb0:	f042 0220 	orr.w	r2, r2, #32
   15fb4:	6082      	str	r2, [r0, #8]
}
   15fb6:	4618      	mov	r0, r3
   15fb8:	bc30      	pop	{r4, r5}
   15fba:	b004      	add	sp, #16
   15fbc:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   15fbe:	68c2      	ldr	r2, [r0, #12]
   15fc0:	f44f 6354 	mov.w	r3, #3392	; 0xd40
   15fc4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   15fc8:	f2c0 0303 	movt	r3, #3
   15fcc:	60c2      	str	r2, [r0, #12]
   15fce:	e001      	b.n	15fd4 <USB_CoreInit+0x9c>
    if (++count > 200000U)
   15fd0:	3b01      	subs	r3, #1
   15fd2:	d024      	beq.n	1601e <USB_CoreInit+0xe6>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   15fd4:	6902      	ldr	r2, [r0, #16]
   15fd6:	2a00      	cmp	r2, #0
   15fd8:	dafa      	bge.n	15fd0 <USB_CoreInit+0x98>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   15fda:	6903      	ldr	r3, [r0, #16]
   15fdc:	f44f 6254 	mov.w	r2, #3392	; 0xd40
   15fe0:	f043 0301 	orr.w	r3, r3, #1
   15fe4:	f2c0 0203 	movt	r2, #3
   15fe8:	6103      	str	r3, [r0, #16]
   15fea:	e001      	b.n	15ff0 <USB_CoreInit+0xb8>
    if (++count > 200000U)
   15fec:	3a01      	subs	r2, #1
   15fee:	d016      	beq.n	1601e <USB_CoreInit+0xe6>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   15ff0:	6903      	ldr	r3, [r0, #16]
   15ff2:	f013 0301 	ands.w	r3, r3, #1
   15ff6:	d1f9      	bne.n	15fec <USB_CoreInit+0xb4>
    if (cfg.battery_charging_enable == 0U)
   15ff8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   15ffa:	b922      	cbnz	r2, 16006 <USB_CoreInit+0xce>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
   15ffc:	6b82      	ldr	r2, [r0, #56]	; 0x38
   15ffe:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   16002:	6382      	str	r2, [r0, #56]	; 0x38
   16004:	e7cc      	b.n	15fa0 <USB_CoreInit+0x68>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   16006:	6b82      	ldr	r2, [r0, #56]	; 0x38
   16008:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
   1600c:	6382      	str	r2, [r0, #56]	; 0x38
   1600e:	e7c7      	b.n	15fa0 <USB_CoreInit+0x68>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   16010:	68c3      	ldr	r3, [r0, #12]
   16012:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   16016:	60c3      	str	r3, [r0, #12]
   16018:	e7a9      	b.n	15f6e <USB_CoreInit+0x36>
      return HAL_TIMEOUT;
   1601a:	2303      	movs	r3, #3
   1601c:	e7c0      	b.n	15fa0 <USB_CoreInit+0x68>
   1601e:	2303      	movs	r3, #3
   16020:	e7ea      	b.n	15ff8 <USB_CoreInit+0xc0>
   16022:	bf00      	nop

00016024 <USB_EnableGlobalInt>:
{
   16024:	4602      	mov	r2, r0
}
   16026:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   16028:	6893      	ldr	r3, [r2, #8]
   1602a:	f043 0301 	orr.w	r3, r3, #1
   1602e:	6093      	str	r3, [r2, #8]
}
   16030:	4770      	bx	lr
   16032:	bf00      	nop

00016034 <USB_DisableGlobalInt>:
{
   16034:	4602      	mov	r2, r0
}
   16036:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   16038:	6893      	ldr	r3, [r2, #8]
   1603a:	f023 0301 	bic.w	r3, r3, #1
   1603e:	6093      	str	r3, [r2, #8]
}
   16040:	4770      	bx	lr
   16042:	bf00      	nop

00016044 <USB_SetCurrentMode>:
{
   16044:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   16046:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
   16048:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   1604a:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
   1604e:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
   16050:	d00b      	beq.n	1606a <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
   16052:	b941      	cbnz	r1, 16066 <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
   16054:	68c3      	ldr	r3, [r0, #12]
   16056:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   1605a:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
   1605c:	2032      	movs	r0, #50	; 0x32
   1605e:	f7f2 f9f5 	bl	844c <HAL_Delay>
  return HAL_OK;
   16062:	2000      	movs	r0, #0
}
   16064:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
   16066:	2001      	movs	r0, #1
}
   16068:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
   1606a:	68c3      	ldr	r3, [r0, #12]
   1606c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   16070:	60c3      	str	r3, [r0, #12]
   16072:	e7f3      	b.n	1605c <USB_SetCurrentMode+0x18>

00016074 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   16074:	b084      	sub	sp, #16
   16076:	b530      	push	{r4, r5, lr}
   16078:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
   1607a:	2500      	movs	r5, #0
{
   1607c:	b083      	sub	sp, #12
  USBx_PCGCCTL = 0U;
   1607e:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   16082:	6ba5      	ldr	r5, [r4, #56]	; 0x38
{
   16084:	a807      	add	r0, sp, #28
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   16086:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
   1608a:	63a5      	str	r5, [r4, #56]	; 0x38

  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
   1608c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
   1608e:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
   16092:	63a5      	str	r5, [r4, #56]	; 0x38


  if ((USBx->CID & (0x1U << 8)) != 0U)
   16094:	6be5      	ldr	r5, [r4, #60]	; 0x3c
{
   16096:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if ((USBx->CID & (0x1U << 8)) != 0U)
   1609a:	05eb      	lsls	r3, r5, #23
   1609c:	9908      	ldr	r1, [sp, #32]
   1609e:	d576      	bpl.n	1618e <USB_HostInit+0x11a>
  {
    if (cfg.speed == USB_OTG_SPEED_FULL)
   160a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   160a2:	2b03      	cmp	r3, #3
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   160a4:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    if (cfg.speed == USB_OTG_SPEED_FULL)
   160a8:	d074      	beq.n	16194 <USB_HostInit+0x120>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   160aa:	f023 0304 	bic.w	r3, r3, #4
   160ae:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   160b2:	f44f 6284 	mov.w	r2, #1056	; 0x420
   160b6:	f44f 6354 	mov.w	r3, #3392	; 0xd40
   160ba:	6122      	str	r2, [r4, #16]
   160bc:	f2c0 0303 	movt	r3, #3
   160c0:	e001      	b.n	160c6 <USB_HostInit+0x52>
    if (++count > 200000U)
   160c2:	3b01      	subs	r3, #1
   160c4:	d002      	beq.n	160cc <USB_HostInit+0x58>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   160c6:	6922      	ldr	r2, [r4, #16]
   160c8:	0695      	lsls	r5, r2, #26
   160ca:	d4fa      	bmi.n	160c2 <USB_HostInit+0x4e>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   160cc:	2210      	movs	r2, #16
   160ce:	f44f 6354 	mov.w	r3, #3392	; 0xd40
   160d2:	6122      	str	r2, [r4, #16]
   160d4:	f2c0 0303 	movt	r3, #3
   160d8:	e001      	b.n	160de <USB_HostInit+0x6a>
    if (++count > 200000U)
   160da:	3b01      	subs	r3, #1
   160dc:	d002      	beq.n	160e4 <USB_HostInit+0x70>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   160de:	6922      	ldr	r2, [r4, #16]
   160e0:	06d0      	lsls	r0, r2, #27
   160e2:	d4fa      	bmi.n	160da <USB_HostInit+0x66>
  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
  (void)USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
   160e4:	b159      	cbz	r1, 160fe <USB_HostInit+0x8a>
   160e6:	2200      	movs	r2, #0
   160e8:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   160ec:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    USBx_HC(i)->HCINTMSK = 0U;
   160f0:	4610      	mov	r0, r2
  for (i = 0U; i < cfg.Host_channels; i++)
   160f2:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   160f4:	609d      	str	r5, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
   160f6:	60d8      	str	r0, [r3, #12]
   160f8:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.Host_channels; i++)
   160fa:	428a      	cmp	r2, r1
   160fc:	d1f9      	bne.n	160f2 <USB_HostInit+0x7e>
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
   160fe:	2300      	movs	r3, #0
   16100:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
   16102:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
   16106:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   16108:	9b01      	ldr	r3, [sp, #4]
   1610a:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   1610e:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   16110:	9b01      	ldr	r3, [sp, #4]
   16112:	04da      	lsls	r2, r3, #19
   16114:	d404      	bmi.n	16120 <USB_HostInit+0xac>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   16116:	9b01      	ldr	r3, [sp, #4]
   16118:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   1611c:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(200U);
   16120:	20c8      	movs	r0, #200	; 0xc8
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   16122:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(200U);
   16124:	f7f2 f992 	bl	844c <HAL_Delay>
  USBx->GINTSTS = 0xFFFFFFFFU;
   16128:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTMSK = 0U;
   1612c:	2200      	movs	r2, #0
   1612e:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xFFFFFFFFU;
   16130:	6163      	str	r3, [r4, #20]
  if ((USBx->CID & (0x1U << 8)) != 0U)
   16132:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   16134:	05db      	lsls	r3, r3, #23
   16136:	d51e      	bpl.n	16176 <USB_HostInit+0x102>
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   16138:	f44f 7200 	mov.w	r2, #512	; 0x200
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   1613c:	f44f 7340 	mov.w	r3, #768	; 0x300
    USBx->GRXFSIZ  = 0x200U;
   16140:	4611      	mov	r1, r2
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   16142:	f2c0 03e0 	movt	r3, #224	; 0xe0
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   16146:	f2c0 1200 	movt	r2, #256	; 0x100
    USBx->GRXFSIZ  = 0x200U;
   1614a:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   1614c:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   1614e:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  if (cfg.dma_enable == 0U)
   16152:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   16154:	b91b      	cbnz	r3, 1615e <USB_HostInit+0xea>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
   16156:	69a3      	ldr	r3, [r4, #24]
   16158:	f043 0310 	orr.w	r3, r3, #16
   1615c:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   1615e:	2308      	movs	r3, #8
   16160:	69a2      	ldr	r2, [r4, #24]
}
   16162:	2000      	movs	r0, #0
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   16164:	f2ca 3320 	movt	r3, #41760	; 0xa320
   16168:	4313      	orrs	r3, r2
   1616a:	61a3      	str	r3, [r4, #24]
}
   1616c:	b003      	add	sp, #12
   1616e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   16172:	b004      	add	sp, #16
   16174:	4770      	bx	lr
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   16176:	2280      	movs	r2, #128	; 0x80
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   16178:	23e0      	movs	r3, #224	; 0xe0
    USBx->GRXFSIZ  = 0x80U;
   1617a:	4611      	mov	r1, r2
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   1617c:	f2c0 0340 	movt	r3, #64	; 0x40
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   16180:	f2c0 0260 	movt	r2, #96	; 0x60
    USBx->GRXFSIZ  = 0x80U;
   16184:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   16186:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   16188:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
   1618c:	e7e1      	b.n	16152 <USB_HostInit+0xde>
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   1618e:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
   16192:	e78a      	b.n	160aa <USB_HostInit+0x36>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   16194:	f043 0304 	orr.w	r3, r3, #4
   16198:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
   1619c:	e789      	b.n	160b2 <USB_HostInit+0x3e>
   1619e:	bf00      	nop

000161a0 <USB_ResetPort>:
{
   161a0:	b530      	push	{r4, r5, lr}
   161a2:	4604      	mov	r4, r0
   161a4:	b083      	sub	sp, #12
  __IO uint32_t hprt0 = 0U;
   161a6:	2500      	movs	r5, #0
  HAL_Delay(100U);                                 /* See Note #1 */
   161a8:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
   161aa:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
   161ac:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
   161b0:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   161b2:	9b01      	ldr	r3, [sp, #4]
   161b4:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   161b8:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
   161ba:	9b01      	ldr	r3, [sp, #4]
   161bc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   161c0:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
   161c4:	f7f2 f942 	bl	844c <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   161c8:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
   161ca:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   161cc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   161d0:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
   161d4:	f7f2 f93a 	bl	844c <HAL_Delay>
}
   161d8:	4628      	mov	r0, r5
   161da:	b003      	add	sp, #12
   161dc:	bd30      	pop	{r4, r5, pc}
   161de:	bf00      	nop

000161e0 <USB_DriveVbus>:
{
   161e0:	b082      	sub	sp, #8
  __IO uint32_t hprt0 = 0U;
   161e2:	2300      	movs	r3, #0
   161e4:	9301      	str	r3, [sp, #4]
  hprt0 = USBx_HPRT0;
   161e6:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
   161ea:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   161ec:	9b01      	ldr	r3, [sp, #4]
   161ee:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   161f2:	9301      	str	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   161f4:	9b01      	ldr	r3, [sp, #4]
   161f6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   161fa:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   161fc:	d101      	bne.n	16202 <USB_DriveVbus+0x22>
   161fe:	2901      	cmp	r1, #1
   16200:	d00a      	beq.n	16218 <USB_DriveVbus+0x38>
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   16202:	04db      	lsls	r3, r3, #19
   16204:	d505      	bpl.n	16212 <USB_DriveVbus+0x32>
   16206:	b921      	cbnz	r1, 16212 <USB_DriveVbus+0x32>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
   16208:	9b01      	ldr	r3, [sp, #4]
   1620a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   1620e:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  return HAL_OK;
}
   16212:	2000      	movs	r0, #0
   16214:	b002      	add	sp, #8
   16216:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   16218:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   1621c:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
   16220:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   16222:	9b01      	ldr	r3, [sp, #4]
}
   16224:	b002      	add	sp, #8
   16226:	4770      	bx	lr

00016228 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
   16228:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
   1622a:	2300      	movs	r3, #0
   1622c:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
   1622e:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
   16232:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
   16234:	9801      	ldr	r0, [sp, #4]
}
   16236:	f3c0 4041 	ubfx	r0, r0, #17, #2
   1623a:	b002      	add	sp, #8
   1623c:	4770      	bx	lr
   1623e:	bf00      	nop

00016240 <USB_GetCurrentFrame>:
*/
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   16240:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   16244:	6880      	ldr	r0, [r0, #8]
}
   16246:	b280      	uxth	r0, r0
   16248:	4770      	bx	lr
   1624a:	bf00      	nop

0001624c <USB_HC_Init>:
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
   1624c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   16250:	4606      	mov	r6, r0
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t HCcharEpDir, HCcharLowSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   16252:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   16256:	2001      	movs	r0, #1
{
   16258:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   1625c:	eb06 1541 	add.w	r5, r6, r1, lsl #5
   16260:	f001 010f 	and.w	r1, r1, #15
   16264:	f506 6980 	add.w	r9, r6, #1024	; 0x400
{
   16268:	f89d e01c 	ldrb.w	lr, [sp, #28]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   1626c:	f505 68a0 	add.w	r8, r5, #1280	; 0x500
   16270:	fa00 f101 	lsl.w	r1, r0, r1
   16274:	f8c8 7008 	str.w	r7, [r8, #8]
   16278:	b250      	sxtb	r0, r2
{
   1627a:	f8bd c024 	ldrh.w	ip, [sp, #36]	; 0x24

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
   1627e:	2c03      	cmp	r4, #3
   16280:	d85b      	bhi.n	1633a <USB_HC_Init+0xee>
   16282:	e8df f004 	tbb	[pc, r4]
   16286:	3d4a      	.short	0x3d4a
   16288:	024a      	.short	0x024a
        }
      }
      break;

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   1628a:	f240 679d 	movw	r7, #1693	; 0x69d
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
   1628e:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   16290:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   16294:	db63      	blt.n	1635e <USB_HC_Init+0x112>
      ret = HAL_ERROR;
      break;
  }

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   16296:	f8d9 7018 	ldr.w	r7, [r9, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   1629a:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   1629c:	4339      	orrs	r1, r7
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
  }
  else
  {
    HCcharEpDir = 0U;
   1629e:	4607      	mov	r7, r0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   162a0:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   162a4:	69b1      	ldr	r1, [r6, #24]
   162a6:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   162aa:	61b1      	str	r1, [r6, #24]
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   162ac:	0599      	lsls	r1, r3, #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   162ae:	f3cc 030a 	ubfx	r3, ip, #0, #11
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   162b2:	02d2      	lsls	r2, r2, #11
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   162b4:	f1be 0f02 	cmp.w	lr, #2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   162b8:	f001 51fe 	and.w	r1, r1, #532676608	; 0x1fc00000
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   162bc:	ea4f 4684 	mov.w	r6, r4, lsl #18
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   162c0:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   162c4:	bf18      	it	ne
   162c6:	f04f 0c00 	movne.w	ip, #0
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   162ca:	ea43 0301 	orr.w	r3, r3, r1
   162ce:	f406 2140 	and.w	r1, r6, #786432	; 0xc0000
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   162d2:	bf08      	it	eq
   162d4:	f44f 3c00 	moveq.w	ip, #131072	; 0x20000

  if (ep_type == EP_TYPE_INTR)
   162d8:	2c03      	cmp	r4, #3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   162da:	ea43 0302 	orr.w	r3, r3, r2
   162de:	ea43 0301 	orr.w	r3, r3, r1
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   162e2:	ea43 0307 	orr.w	r3, r3, r7
   162e6:	ea43 030c 	orr.w	r3, r3, ip
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   162ea:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  if (ep_type == EP_TYPE_INTR)
   162ee:	d105      	bne.n	162fc <USB_HC_Init+0xb0>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   162f0:	f8d5 3500 	ldr.w	r3, [r5, #1280]	; 0x500
   162f4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   162f8:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  }

  return ret;
}
   162fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   16300:	f240 2725 	movw	r7, #549	; 0x225
      if ((epnum & 0x80U) == 0x80U)
   16304:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   16306:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   1630a:	dac4      	bge.n	16296 <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
   1630c:	f8d8 000c 	ldr.w	r0, [r8, #12]
   16310:	f440 70c0 	orr.w	r0, r0, #384	; 0x180
   16314:	f8c8 000c 	str.w	r0, [r8, #12]
   16318:	e027      	b.n	1636a <USB_HC_Init+0x11e>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   1631a:	f240 479d 	movw	r7, #1181	; 0x49d
      if ((epnum & 0x80U) == 0x80U)
   1631e:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   16320:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   16324:	db1b      	blt.n	1635e <USB_HC_Init+0x112>
        if ((USBx->CID & (0x1U << 8)) != 0U)
   16326:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
   16328:	05c0      	lsls	r0, r0, #23
   1632a:	d5b4      	bpl.n	16296 <USB_HC_Init+0x4a>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   1632c:	f8d8 000c 	ldr.w	r0, [r8, #12]
   16330:	f040 0060 	orr.w	r0, r0, #96	; 0x60
   16334:	f8c8 000c 	str.w	r0, [r8, #12]
   16338:	e7ad      	b.n	16296 <USB_HC_Init+0x4a>
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   1633a:	f8d9 7018 	ldr.w	r7, [r9, #24]
      ret = HAL_ERROR;
   1633e:	2800      	cmp	r0, #0
   16340:	f04f 0001 	mov.w	r0, #1
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   16344:	ea41 0107 	orr.w	r1, r1, r7
      ret = HAL_ERROR;
   16348:	bfac      	ite	ge
   1634a:	2700      	movge	r7, #0
   1634c:	f44f 4700 	movlt.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   16350:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   16354:	69b1      	ldr	r1, [r6, #24]
   16356:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   1635a:	61b1      	str	r1, [r6, #24]
   1635c:	e7a6      	b.n	162ac <USB_HC_Init+0x60>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   1635e:	f8d8 000c 	ldr.w	r0, [r8, #12]
   16362:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   16366:	f8c8 000c 	str.w	r0, [r8, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   1636a:	f8d9 7018 	ldr.w	r7, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   1636e:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   16370:	4339      	orrs	r1, r7
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
   16372:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   16376:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   1637a:	69b1      	ldr	r1, [r6, #24]
   1637c:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   16380:	61b1      	str	r1, [r6, #24]
   16382:	e793      	b.n	162ac <USB_HC_Init+0x60>

00016384 <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
   16384:	b4f0      	push	{r4, r5, r6, r7}
   16386:	784c      	ldrb	r4, [r1, #1]
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
   16388:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   1638a:	eb00 1444 	add.w	r4, r0, r4, lsl #5
   1638e:	05db      	lsls	r3, r3, #23
   16390:	f504 67a0 	add.w	r7, r4, #1280	; 0x500
   16394:	d50a      	bpl.n	163ac <USB_HC_StartXfer+0x28>
   16396:	790b      	ldrb	r3, [r1, #4]
   16398:	b943      	cbnz	r3, 163ac <USB_HC_StartXfer+0x28>
  {
    if ((dma == 0U) && (hc->do_ping == 1U))
   1639a:	2a00      	cmp	r2, #0
   1639c:	d062      	beq.n	16464 <USB_HC_StartXfer+0xe0>
    {
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
    else if (dma == 1U)
   1639e:	2a01      	cmp	r2, #1
   163a0:	d104      	bne.n	163ac <USB_HC_StartXfer+0x28>
    {
      USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   163a2:	68fd      	ldr	r5, [r7, #12]
   163a4:	f025 0560 	bic.w	r5, r5, #96	; 0x60
   163a8:	60fd      	str	r5, [r7, #12]
      hc->do_ping = 0U;
   163aa:	714b      	strb	r3, [r1, #5]
      /* ... */
    }
  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
   163ac:	690d      	ldr	r5, [r1, #16]
   163ae:	2d00      	cmp	r5, #0
   163b0:	d14c      	bne.n	1644c <USB_HC_StartXfer+0xc8>
   163b2:	f44f 2600 	mov.w	r6, #524288	; 0x80000
   163b6:	f04f 0c01 	mov.w	ip, #1
  }
  else
  {
    num_packets = 1U;
  }
  if (hc->ep_is_in != 0U)
   163ba:	78cb      	ldrb	r3, [r1, #3]
   163bc:	b11b      	cbz	r3, 163c6 <USB_HC_StartXfer+0x42>
  {
    hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   163be:	890d      	ldrh	r5, [r1, #8]
   163c0:	fb0c f505 	mul.w	r5, ip, r5
   163c4:	610d      	str	r5, [r1, #16]
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   163c6:	7a8b      	ldrb	r3, [r1, #10]
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   163c8:	f3c5 0512 	ubfx	r5, r5, #0, #19
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   163cc:	075b      	lsls	r3, r3, #29
   163ce:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   163d2:	4333      	orrs	r3, r6
   163d4:	432b      	orrs	r3, r5
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   163d6:	613b      	str	r3, [r7, #16]

  if (dma != 0U)
   163d8:	b10a      	cbz	r2, 163de <USB_HC_StartXfer+0x5a>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   163da:	68cb      	ldr	r3, [r1, #12]
   163dc:	617b      	str	r3, [r7, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
   163de:	f500 6680 	add.w	r6, r0, #1024	; 0x400
   163e2:	68b5      	ldr	r5, [r6, #8]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   163e4:	f8d4 7500 	ldr.w	r7, [r4, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   163e8:	f646 0324 	movw	r3, #26660	; 0x6824
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   163ec:	43ed      	mvns	r5, r5
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   163ee:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   163f2:	f2c0 230e 	movt	r3, #526	; 0x20e
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   163f6:	076d      	lsls	r5, r5, #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   163f8:	f8c4 7500 	str.w	r7, [r4, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   163fc:	f005 5500 	and.w	r5, r5, #536870912	; 0x20000000
   16400:	f8d4 7500 	ldr.w	r7, [r4, #1280]	; 0x500
   16404:	433d      	orrs	r5, r7
   16406:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   1640a:	f8d4 5500 	ldr.w	r5, [r4, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
   1640e:	78cf      	ldrb	r7, [r1, #3]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   16410:	601d      	str	r5, [r3, #0]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   16412:	681d      	ldr	r5, [r3, #0]
   16414:	f025 4580 	bic.w	r5, r5, #1073741824	; 0x40000000
   16418:	601d      	str	r5, [r3, #0]
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
   1641a:	681d      	ldr	r5, [r3, #0]
  if (hc->ep_is_in != 0U)
   1641c:	2f00      	cmp	r7, #0
   1641e:	d033      	beq.n	16488 <USB_HC_StartXfer+0x104>
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
   16420:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
   16424:	601d      	str	r5, [r3, #0]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
   16426:	681d      	ldr	r5, [r3, #0]
   16428:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
   1642c:	601d      	str	r5, [r3, #0]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
   1642e:	681b      	ldr	r3, [r3, #0]
   16430:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500

  if (dma == 0U) /* Slave mode */
   16434:	bb2a      	cbnz	r2, 16482 <USB_HC_StartXfer+0xfe>
  {
    if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
   16436:	78cb      	ldrb	r3, [r1, #3]
   16438:	bb1b      	cbnz	r3, 16482 <USB_HC_StartXfer+0xfe>
   1643a:	690b      	ldr	r3, [r1, #16]
   1643c:	b30b      	cbz	r3, 16482 <USB_HC_StartXfer+0xfe>
    {
      switch (hc->ep_type)
   1643e:	79ca      	ldrb	r2, [r1, #7]
   16440:	2a03      	cmp	r2, #3
   16442:	d833      	bhi.n	164ac <USB_HC_StartXfer+0x128>
   16444:	e8df f002 	tbb	[pc, r2]
   16448:	2b462b46 	.word	0x2b462b46
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
   1644c:	890e      	ldrh	r6, [r1, #8]
   1644e:	1e6b      	subs	r3, r5, #1
   16450:	4433      	add	r3, r6
   16452:	fbb3 f3f6 	udiv	r3, r3, r6
    if (num_packets > max_hc_pkt_count)
   16456:	fa1f fc83 	uxth.w	ip, r3
   1645a:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
   1645e:	d817      	bhi.n	16490 <USB_HC_StartXfer+0x10c>
   16460:	04de      	lsls	r6, r3, #19
   16462:	e7aa      	b.n	163ba <USB_HC_StartXfer+0x36>
    if ((dma == 0U) && (hc->do_ping == 1U))
   16464:	794b      	ldrb	r3, [r1, #5]
   16466:	2b01      	cmp	r3, #1
   16468:	d1a0      	bne.n	163ac <USB_HC_StartXfer+0x28>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   1646a:	2300      	movs	r3, #0
   1646c:	f2c8 0308 	movt	r3, #32776	; 0x8008
   16470:	613b      	str	r3, [r7, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
   16472:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   16476:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
   1647a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
   1647e:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
}
   16482:	2000      	movs	r0, #0
   16484:	bcf0      	pop	{r4, r5, r6, r7}
   16486:	4770      	bx	lr
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
   16488:	f425 4500 	bic.w	r5, r5, #32768	; 0x8000
   1648c:	601d      	str	r5, [r3, #0]
   1648e:	e7ca      	b.n	16426 <USB_HC_StartXfer+0xa2>
      hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   16490:	0235      	lsls	r5, r6, #8
   16492:	f44f 7c80 	mov.w	ip, #256	; 0x100
   16496:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
   1649a:	610d      	str	r5, [r1, #16]
   1649c:	e78d      	b.n	163ba <USB_HC_StartXfer+0x36>
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   1649e:	6934      	ldr	r4, [r6, #16]
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   164a0:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   164a2:	b2a4      	uxth	r4, r4
   164a4:	f3c2 028f 	ubfx	r2, r2, #2, #16
   164a8:	4294      	cmp	r4, r2
   164aa:	d320      	bcc.n	164ee <USB_HC_StartXfer+0x16a>
    count32b = ((uint32_t)len + 3U) / 4U;
   164ac:	b29b      	uxth	r3, r3
      (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
   164ae:	68ca      	ldr	r2, [r1, #12]
   164b0:	7849      	ldrb	r1, [r1, #1]
    count32b = ((uint32_t)len + 3U) / 4U;
   164b2:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
   164b4:	089b      	lsrs	r3, r3, #2
   164b6:	d0e4      	beq.n	16482 <USB_HC_StartXfer+0xfe>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   164b8:	eb00 3001 	add.w	r0, r0, r1, lsl #12
   164bc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   164c0:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
   164c4:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
   164c8:	4293      	cmp	r3, r2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   164ca:	6001      	str	r1, [r0, #0]
    for (i = 0U; i < count32b; i++)
   164cc:	d1fa      	bne.n	164c4 <USB_HC_StartXfer+0x140>
}
   164ce:	2000      	movs	r0, #0
   164d0:	bcf0      	pop	{r4, r5, r6, r7}
   164d2:	4770      	bx	lr
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   164d4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   164d6:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   164d8:	b2a4      	uxth	r4, r4
   164da:	f3c2 028f 	ubfx	r2, r2, #2, #16
   164de:	4294      	cmp	r4, r2
   164e0:	d2e4      	bcs.n	164ac <USB_HC_StartXfer+0x128>
            USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   164e2:	6983      	ldr	r3, [r0, #24]
   164e4:	f043 0320 	orr.w	r3, r3, #32
   164e8:	6183      	str	r3, [r0, #24]
   164ea:	690b      	ldr	r3, [r1, #16]
   164ec:	e7de      	b.n	164ac <USB_HC_StartXfer+0x128>
            USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
   164ee:	6983      	ldr	r3, [r0, #24]
   164f0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   164f4:	6183      	str	r3, [r0, #24]
   164f6:	690b      	ldr	r3, [r1, #16]
   164f8:	e7d8      	b.n	164ac <USB_HC_StartXfer+0x128>
   164fa:	bf00      	nop

000164fc <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
   164fc:	eb00 1141 	add.w	r1, r0, r1, lsl #5
   16500:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   16504:	f501 62a0 	add.w	r2, r1, #1280	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   16508:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   1650c:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   16510:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   16514:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   16518:	d11f      	bne.n	1655a <USB_HC_Halt+0x5e>
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
   1651a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   1651c:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   16520:	d13c      	bne.n	1659c <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   16522:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   16526:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   1652a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   1652e:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   16532:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   16536:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
   1653a:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   1653e:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   16542:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
   16546:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
   1654a:	e001      	b.n	16550 <USB_HC_Halt+0x54>
        if (++count > 1000U)
   1654c:	3b01      	subs	r3, #1
   1654e:	d02b      	beq.n	165a8 <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   16550:	6811      	ldr	r1, [r2, #0]
   16552:	2900      	cmp	r1, #0
   16554:	dbfa      	blt.n	1654c <USB_HC_Halt+0x50>
}
   16556:	2000      	movs	r0, #0
   16558:	4770      	bx	lr
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
   1655a:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
   1655e:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   16562:	d11b      	bne.n	1659c <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   16564:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   16568:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   1656c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   16570:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   16574:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   16578:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
   1657c:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   16580:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   16584:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
   16588:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
   1658c:	e001      	b.n	16592 <USB_HC_Halt+0x96>
        if (++count > 1000U)
   1658e:	3b01      	subs	r3, #1
   16590:	d00a      	beq.n	165a8 <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   16592:	6811      	ldr	r1, [r2, #0]
   16594:	2900      	cmp	r1, #0
   16596:	dbfa      	blt.n	1658e <USB_HC_Halt+0x92>
}
   16598:	2000      	movs	r0, #0
   1659a:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   1659c:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   165a0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   165a4:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
   165a8:	2000      	movs	r0, #0
   165aa:	4770      	bx	lr

000165ac <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
   165ac:	b410      	push	{r4}
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   165ae:	6882      	ldr	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   165b0:	f44f 6184 	mov.w	r1, #1056	; 0x420
   165b4:	f44f 6354 	mov.w	r3, #3392	; 0xd40
{
   165b8:	4604      	mov	r4, r0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   165ba:	f022 0201 	bic.w	r2, r2, #1
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   165be:	f2c0 0303 	movt	r3, #3
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   165c2:	6082      	str	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   165c4:	6101      	str	r1, [r0, #16]
   165c6:	e001      	b.n	165cc <USB_StopHost+0x20>
    if (++count > 200000U)
   165c8:	3b01      	subs	r3, #1
   165ca:	d002      	beq.n	165d2 <USB_StopHost+0x26>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   165cc:	6922      	ldr	r2, [r4, #16]
   165ce:	0691      	lsls	r1, r2, #26
   165d0:	d4fa      	bmi.n	165c8 <USB_StopHost+0x1c>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   165d2:	2210      	movs	r2, #16
   165d4:	f44f 6354 	mov.w	r3, #3392	; 0xd40
   165d8:	6122      	str	r2, [r4, #16]
   165da:	f2c0 0303 	movt	r3, #3
   165de:	e001      	b.n	165e4 <USB_StopHost+0x38>
    if (++count > 200000U)
   165e0:	3b01      	subs	r3, #1
   165e2:	d002      	beq.n	165ea <USB_StopHost+0x3e>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   165e4:	6922      	ldr	r2, [r4, #16]
   165e6:	06d2      	lsls	r2, r2, #27
   165e8:	d4fa      	bmi.n	165e0 <USB_StopHost+0x34>
  (void)USB_FlushRxFifo(USBx);

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
   165ea:	f8d4 2500 	ldr.w	r2, [r4, #1280]	; 0x500
   165ee:	f504 61a0 	add.w	r1, r4, #1280	; 0x500
   165f2:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
  uint32_t count = 0U;
   165f6:	2300      	movs	r3, #0
   165f8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
   165fc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16600:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    value = USBx_HC(i)->HCCHAR;
   16604:	f8d4 2520 	ldr.w	r2, [r4, #1312]	; 0x520
   16608:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1660c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16610:	f8c4 2520 	str.w	r2, [r4, #1312]	; 0x520
    value = USBx_HC(i)->HCCHAR;
   16614:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
   16618:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1661c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16620:	f8c4 2540 	str.w	r2, [r4, #1344]	; 0x540
    value = USBx_HC(i)->HCCHAR;
   16624:	f8d4 2560 	ldr.w	r2, [r4, #1376]	; 0x560
   16628:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1662c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16630:	f8c4 2560 	str.w	r2, [r4, #1376]	; 0x560
    value = USBx_HC(i)->HCCHAR;
   16634:	f8d4 2580 	ldr.w	r2, [r4, #1408]	; 0x580
   16638:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1663c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16640:	f8c4 2580 	str.w	r2, [r4, #1408]	; 0x580
    value = USBx_HC(i)->HCCHAR;
   16644:	f8d4 25a0 	ldr.w	r2, [r4, #1440]	; 0x5a0
   16648:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1664c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16650:	f8c4 25a0 	str.w	r2, [r4, #1440]	; 0x5a0
    value = USBx_HC(i)->HCCHAR;
   16654:	f8d4 25c0 	ldr.w	r2, [r4, #1472]	; 0x5c0
   16658:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1665c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16660:	f8c4 25c0 	str.w	r2, [r4, #1472]	; 0x5c0
    value = USBx_HC(i)->HCCHAR;
   16664:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
   16668:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1666c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16670:	f8c4 25e0 	str.w	r2, [r4, #1504]	; 0x5e0
    value = USBx_HC(i)->HCCHAR;
   16674:	f8d4 2600 	ldr.w	r2, [r4, #1536]	; 0x600
   16678:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1667c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16680:	f8c4 2600 	str.w	r2, [r4, #1536]	; 0x600
    value = USBx_HC(i)->HCCHAR;
   16684:	f8d4 2620 	ldr.w	r2, [r4, #1568]	; 0x620
   16688:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1668c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   16690:	f8c4 2620 	str.w	r2, [r4, #1568]	; 0x620
    value = USBx_HC(i)->HCCHAR;
   16694:	f8d4 2640 	ldr.w	r2, [r4, #1600]	; 0x640
   16698:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   1669c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   166a0:	f8c4 2640 	str.w	r2, [r4, #1600]	; 0x640
    value = USBx_HC(i)->HCCHAR;
   166a4:	f8d4 2660 	ldr.w	r2, [r4, #1632]	; 0x660
   166a8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   166ac:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   166b0:	f8c4 2660 	str.w	r2, [r4, #1632]	; 0x660
    value = USBx_HC(i)->HCCHAR;
   166b4:	f8d4 2680 	ldr.w	r2, [r4, #1664]	; 0x680
   166b8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   166bc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   166c0:	f8c4 2680 	str.w	r2, [r4, #1664]	; 0x680
    value = USBx_HC(i)->HCCHAR;
   166c4:	f8d4 26a0 	ldr.w	r2, [r4, #1696]	; 0x6a0
   166c8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   166cc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   166d0:	f8c4 26a0 	str.w	r2, [r4, #1696]	; 0x6a0
    value = USBx_HC(i)->HCCHAR;
   166d4:	f8d4 26c0 	ldr.w	r2, [r4, #1728]	; 0x6c0
   166d8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   166dc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   166e0:	f8c4 26c0 	str.w	r2, [r4, #1728]	; 0x6c0
    value = USBx_HC(i)->HCCHAR;
   166e4:	f8d4 26e0 	ldr.w	r2, [r4, #1760]	; 0x6e0
   166e8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   166ec:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   166f0:	f8c4 26e0 	str.w	r2, [r4, #1760]	; 0x6e0
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
   166f4:	680a      	ldr	r2, [r1, #0]
   166f6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
   166fa:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
   166fe:	600a      	str	r2, [r1, #0]
   16700:	e002      	b.n	16708 <USB_StopHost+0x15c>
      if (++count > 1000U)
      {
        break;
      }
    }
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   16702:	680a      	ldr	r2, [r1, #0]
   16704:	2a00      	cmp	r2, #0
   16706:	da03      	bge.n	16710 <USB_StopHost+0x164>
      if (++count > 1000U)
   16708:	3301      	adds	r3, #1
   1670a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   1670e:	d9f8      	bls.n	16702 <USB_StopHost+0x156>
   16710:	3120      	adds	r1, #32
  for (i = 0U; i <= 15U; i++)
   16712:	4281      	cmp	r1, r0
   16714:	d1ee      	bne.n	166f4 <USB_StopHost+0x148>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
   16716:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTSTS = 0xFFFFFFFFU;

  (void)USB_EnableGlobalInt(USBx);

  return HAL_OK;
}
   1671a:	2000      	movs	r0, #0
  USBx_HOST->HAINT = 0xFFFFFFFFU;
   1671c:	f8c4 3414 	str.w	r3, [r4, #1044]	; 0x414
  USBx->GINTSTS = 0xFFFFFFFFU;
   16720:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   16722:	68a3      	ldr	r3, [r4, #8]
   16724:	f043 0301 	orr.w	r3, r3, #1
   16728:	60a3      	str	r3, [r4, #8]
}
   1672a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1672e:	4770      	bx	lr

00016730 <USBH_Init>:
USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
                              void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                              uint8_t id), uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
   16730:	b3a0      	cbz	r0, 1679c <USBH_Init+0x6c>
{
   16732:	b570      	push	{r4, r5, r6, lr}
   16734:	4604      	mov	r4, r0

  /* Set DRiver ID */
  phost->id = id;

  /* Unlink class*/
  phost->pActiveClass = NULL;
   16736:	2500      	movs	r5, #0
  phost->id = id;
   16738:	f880 253c 	strb.w	r2, [r0, #1340]	; 0x53c
   1673c:	460e      	mov	r6, r1
   1673e:	223c      	movs	r2, #60	; 0x3c
   16740:	4629      	mov	r1, r5
   16742:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
  phost->pActiveClass = NULL;
   16746:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
  phost->ClassNumber = 0U;
   1674a:	f8c4 54f0 	str.w	r5, [r4, #1264]	; 0x4f0
   1674e:	f019 fd30 	bl	301b2 <memset>
   16752:	4629      	mov	r1, r5
   16754:	f44f 7200 	mov.w	r2, #512	; 0x200
   16758:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   1675c:	f019 fd29 	bl	301b2 <memset>
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
  phost->EnumState = ENUM_IDLE;
  phost->RequestState = CMD_SEND;
   16760:	2301      	movs	r3, #1
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   16762:	2140      	movs	r1, #64	; 0x40
  phost->Control.errorcount = 0U;

  phost->device.address = USBH_ADDRESS_DEFAULT;
   16764:	f44f 7280 	mov.w	r2, #256	; 0x100
  phost->gState = HOST_IDLE;
   16768:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
   1676a:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
   1676c:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
   16770:	7665      	strb	r5, [r4, #25]
  phost->device.is_connected = 0U;
   16772:	f884 5320 	strb.w	r5, [r4, #800]	; 0x320
  phost->device.PortEnabled = 0U;
   16776:	f884 5323 	strb.w	r5, [r4, #803]	; 0x323
  phost->device.is_disconnected = 0U;
   1677a:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
  phost->RequestState = CMD_SEND;
   1677e:	70a3      	strb	r3, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
   16780:	f884 5322 	strb.w	r5, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
   16784:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   16786:	71a1      	strb	r1, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
   16788:	f8c4 231c 	str.w	r2, [r4, #796]	; 0x31c
  if (pUsrFunc != NULL)
   1678c:	b10e      	cbz	r6, 16792 <USBH_Init+0x62>
    phost->pUser = pUsrFunc;
   1678e:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
  USBH_LL_Init(phost);
   16792:	4620      	mov	r0, r4
   16794:	f010 fb5a 	bl	26e4c <USBH_LL_Init>
  return USBH_OK;
   16798:	2000      	movs	r0, #0
}
   1679a:	bd70      	pop	{r4, r5, r6, pc}
    return USBH_FAIL;
   1679c:	2002      	movs	r0, #2
}
   1679e:	4770      	bx	lr

000167a0 <USBH_DeInit>:
{
   167a0:	b538      	push	{r3, r4, r5, lr}
   167a2:	4604      	mov	r4, r0
   167a4:	223c      	movs	r2, #60	; 0x3c
   167a6:	2100      	movs	r1, #0
   167a8:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
   167ac:	f019 fd01 	bl	301b2 <memset>
   167b0:	f44f 7200 	mov.w	r2, #512	; 0x200
   167b4:	2100      	movs	r1, #0
   167b6:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   167ba:	f019 fcfa 	bl	301b2 <memset>
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   167be:	2540      	movs	r5, #64	; 0x40
  phost->gState = HOST_IDLE;
   167c0:	2300      	movs	r3, #0
  phost->RequestState = CMD_SEND;
   167c2:	2201      	movs	r2, #1
  phost->device.address = USBH_ADDRESS_DEFAULT;
   167c4:	f44f 7080 	mov.w	r0, #256	; 0x100
  if (phost->pData != NULL)
   167c8:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
  phost->gState = HOST_IDLE;
   167cc:	7023      	strb	r3, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   167ce:	71a5      	strb	r5, [r4, #6]
  phost->Timer = 0U;
   167d0:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
  phost->device.address = USBH_ADDRESS_DEFAULT;
   167d4:	f8c4 031c 	str.w	r0, [r4, #796]	; 0x31c
  phost->device.is_connected = 0U;
   167d8:	f884 3320 	strb.w	r3, [r4, #800]	; 0x320
  phost->EnumState = ENUM_IDLE;
   167dc:	7063      	strb	r3, [r4, #1]
  phost->device.is_disconnected = 0U;
   167de:	f884 3321 	strb.w	r3, [r4, #801]	; 0x321
  phost->Control.errorcount = 0U;
   167e2:	7663      	strb	r3, [r4, #25]
  phost->device.PortEnabled = 0U;
   167e4:	f884 3323 	strb.w	r3, [r4, #803]	; 0x323
  phost->RequestState = CMD_SEND;
   167e8:	70a2      	strb	r2, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
   167ea:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
   167ee:	7622      	strb	r2, [r4, #24]
  if (phost->pData != NULL)
   167f0:	b111      	cbz	r1, 167f8 <USBH_DeInit+0x58>
    USBH_LL_Stop(phost);
   167f2:	4620      	mov	r0, r4
   167f4:	f010 fb6a 	bl	26ecc <USBH_LL_Stop>
}
   167f8:	2000      	movs	r0, #0
   167fa:	bd38      	pop	{r3, r4, r5, pc}

000167fc <USBH_RegisterClass>:
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
   167fc:	b149      	cbz	r1, 16812 <USBH_RegisterClass+0x16>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
   167fe:	f8d0 34f0 	ldr.w	r3, [r0, #1264]	; 0x4f0
   16802:	b933      	cbnz	r3, 16812 <USBH_RegisterClass+0x16>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
   16804:	2201      	movs	r2, #1
   16806:	f8c0 14e8 	str.w	r1, [r0, #1256]	; 0x4e8
   1680a:	f8c0 24f0 	str.w	r2, [r0, #1264]	; 0x4f0
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
   1680e:	4618      	mov	r0, r3
   16810:	4770      	bx	lr
    status = USBH_FAIL;
   16812:	2302      	movs	r3, #2
}
   16814:	4618      	mov	r0, r3
   16816:	4770      	bx	lr

00016818 <USBH_SelectInterface>:
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
   16818:	f890 333c 	ldrb.w	r3, [r0, #828]	; 0x33c
   1681c:	428b      	cmp	r3, r1
   1681e:	d903      	bls.n	16828 <USBH_SelectInterface+0x10>
  {
    phost->device.current_interface = interface;
   16820:	f880 1324 	strb.w	r1, [r0, #804]	; 0x324
  USBH_StatusTypeDef status = USBH_OK;
   16824:	2000      	movs	r0, #0
   16826:	4770      	bx	lr
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
   16828:	2002      	movs	r0, #2
  }

  return status;
}
   1682a:	4770      	bx	lr

0001682c <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
   1682c:	b430      	push	{r4, r5}
   1682e:	f1a1 04ff 	sub.w	r4, r1, #255	; 0xff
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   16832:	f890 5347 	ldrb.w	r5, [r0, #839]	; 0x347
   16836:	fab4 f484 	clz	r4, r4
   1683a:	428d      	cmp	r5, r1
   1683c:	ea4f 1454 	mov.w	r4, r4, lsr #5
   16840:	d03c      	beq.n	168bc <USBH_FindInterface+0x90>
   16842:	2c00      	cmp	r4, #0
   16844:	d13a      	bne.n	168bc <USBH_FindInterface+0x90>
   16846:	f890 5371 	ldrb.w	r5, [r0, #881]	; 0x371
   1684a:	428d      	cmp	r5, r1
   1684c:	d044      	beq.n	168d8 <USBH_FindInterface+0xac>
   1684e:	2c00      	cmp	r4, #0
   16850:	d142      	bne.n	168d8 <USBH_FindInterface+0xac>
   16852:	f890 539b 	ldrb.w	r5, [r0, #923]	; 0x39b
   16856:	428d      	cmp	r5, r1
   16858:	d04c      	beq.n	168f4 <USBH_FindInterface+0xc8>
   1685a:	2c00      	cmp	r4, #0
   1685c:	d14a      	bne.n	168f4 <USBH_FindInterface+0xc8>
   1685e:	f890 53c5 	ldrb.w	r5, [r0, #965]	; 0x3c5
   16862:	428d      	cmp	r5, r1
   16864:	d054      	beq.n	16910 <USBH_FindInterface+0xe4>
   16866:	2c00      	cmp	r4, #0
   16868:	d152      	bne.n	16910 <USBH_FindInterface+0xe4>
   1686a:	f890 53ef 	ldrb.w	r5, [r0, #1007]	; 0x3ef
   1686e:	428d      	cmp	r5, r1
   16870:	d05c      	beq.n	1692c <USBH_FindInterface+0x100>
   16872:	2c00      	cmp	r4, #0
   16874:	d15a      	bne.n	1692c <USBH_FindInterface+0x100>
   16876:	f890 5419 	ldrb.w	r5, [r0, #1049]	; 0x419
   1687a:	428d      	cmp	r5, r1
   1687c:	d064      	beq.n	16948 <USBH_FindInterface+0x11c>
   1687e:	2c00      	cmp	r4, #0
   16880:	d162      	bne.n	16948 <USBH_FindInterface+0x11c>
   16882:	f890 5443 	ldrb.w	r5, [r0, #1091]	; 0x443
   16886:	428d      	cmp	r5, r1
   16888:	d06c      	beq.n	16964 <USBH_FindInterface+0x138>
   1688a:	2c00      	cmp	r4, #0
   1688c:	d16a      	bne.n	16964 <USBH_FindInterface+0x138>
   1688e:	f890 546d 	ldrb.w	r5, [r0, #1133]	; 0x46d
   16892:	428d      	cmp	r5, r1
   16894:	d074      	beq.n	16980 <USBH_FindInterface+0x154>
   16896:	2c00      	cmp	r4, #0
   16898:	d172      	bne.n	16980 <USBH_FindInterface+0x154>
   1689a:	f890 5497 	ldrb.w	r5, [r0, #1175]	; 0x497
   1689e:	428d      	cmp	r5, r1
   168a0:	d07c      	beq.n	1699c <USBH_FindInterface+0x170>
   168a2:	2c00      	cmp	r4, #0
   168a4:	d17a      	bne.n	1699c <USBH_FindInterface+0x170>
   168a6:	f890 54c1 	ldrb.w	r5, [r0, #1217]	; 0x4c1
   168aa:	428d      	cmp	r5, r1
   168ac:	f000 8086 	beq.w	169bc <USBH_FindInterface+0x190>
   168b0:	2c00      	cmp	r4, #0
   168b2:	f040 8083 	bne.w	169bc <USBH_FindInterface+0x190>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
   168b6:	20ff      	movs	r0, #255	; 0xff
}
   168b8:	bc30      	pop	{r4, r5}
   168ba:	4770      	bx	lr
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   168bc:	f890 5348 	ldrb.w	r5, [r0, #840]	; 0x348
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   168c0:	4295      	cmp	r5, r2
   168c2:	d001      	beq.n	168c8 <USBH_FindInterface+0x9c>
   168c4:	2aff      	cmp	r2, #255	; 0xff
   168c6:	d1be      	bne.n	16846 <USBH_FindInterface+0x1a>
   168c8:	f890 5349 	ldrb.w	r5, [r0, #841]	; 0x349
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   168cc:	429d      	cmp	r5, r3
   168ce:	d001      	beq.n	168d4 <USBH_FindInterface+0xa8>
   168d0:	2bff      	cmp	r3, #255	; 0xff
   168d2:	d1b8      	bne.n	16846 <USBH_FindInterface+0x1a>
  uint8_t if_ix = 0U;
   168d4:	2000      	movs	r0, #0
   168d6:	e7ef      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   168d8:	f890 5372 	ldrb.w	r5, [r0, #882]	; 0x372
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   168dc:	4295      	cmp	r5, r2
   168de:	d001      	beq.n	168e4 <USBH_FindInterface+0xb8>
   168e0:	2aff      	cmp	r2, #255	; 0xff
   168e2:	d1b6      	bne.n	16852 <USBH_FindInterface+0x26>
   168e4:	f890 5373 	ldrb.w	r5, [r0, #883]	; 0x373
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   168e8:	429d      	cmp	r5, r3
   168ea:	d001      	beq.n	168f0 <USBH_FindInterface+0xc4>
   168ec:	2bff      	cmp	r3, #255	; 0xff
   168ee:	d1b0      	bne.n	16852 <USBH_FindInterface+0x26>
    if_ix++;
   168f0:	2001      	movs	r0, #1
   168f2:	e7e1      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   168f4:	f890 539c 	ldrb.w	r5, [r0, #924]	; 0x39c
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   168f8:	4295      	cmp	r5, r2
   168fa:	d001      	beq.n	16900 <USBH_FindInterface+0xd4>
   168fc:	2aff      	cmp	r2, #255	; 0xff
   168fe:	d1ae      	bne.n	1685e <USBH_FindInterface+0x32>
   16900:	f890 539d 	ldrb.w	r5, [r0, #925]	; 0x39d
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   16904:	429d      	cmp	r5, r3
   16906:	d001      	beq.n	1690c <USBH_FindInterface+0xe0>
   16908:	2bff      	cmp	r3, #255	; 0xff
   1690a:	d1a8      	bne.n	1685e <USBH_FindInterface+0x32>
    if_ix++;
   1690c:	2002      	movs	r0, #2
   1690e:	e7d3      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   16910:	f890 53c6 	ldrb.w	r5, [r0, #966]	; 0x3c6
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   16914:	4295      	cmp	r5, r2
   16916:	d001      	beq.n	1691c <USBH_FindInterface+0xf0>
   16918:	2aff      	cmp	r2, #255	; 0xff
   1691a:	d1a6      	bne.n	1686a <USBH_FindInterface+0x3e>
   1691c:	f890 53c7 	ldrb.w	r5, [r0, #967]	; 0x3c7
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   16920:	429d      	cmp	r5, r3
   16922:	d001      	beq.n	16928 <USBH_FindInterface+0xfc>
   16924:	2bff      	cmp	r3, #255	; 0xff
   16926:	d1a0      	bne.n	1686a <USBH_FindInterface+0x3e>
    if_ix++;
   16928:	2003      	movs	r0, #3
   1692a:	e7c5      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   1692c:	f890 53f0 	ldrb.w	r5, [r0, #1008]	; 0x3f0
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   16930:	4295      	cmp	r5, r2
   16932:	d001      	beq.n	16938 <USBH_FindInterface+0x10c>
   16934:	2aff      	cmp	r2, #255	; 0xff
   16936:	d19e      	bne.n	16876 <USBH_FindInterface+0x4a>
   16938:	f890 53f1 	ldrb.w	r5, [r0, #1009]	; 0x3f1
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1693c:	429d      	cmp	r5, r3
   1693e:	d001      	beq.n	16944 <USBH_FindInterface+0x118>
   16940:	2bff      	cmp	r3, #255	; 0xff
   16942:	d198      	bne.n	16876 <USBH_FindInterface+0x4a>
    if_ix++;
   16944:	2004      	movs	r0, #4
   16946:	e7b7      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   16948:	f890 541a 	ldrb.w	r5, [r0, #1050]	; 0x41a
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1694c:	4295      	cmp	r5, r2
   1694e:	d001      	beq.n	16954 <USBH_FindInterface+0x128>
   16950:	2aff      	cmp	r2, #255	; 0xff
   16952:	d196      	bne.n	16882 <USBH_FindInterface+0x56>
   16954:	f890 541b 	ldrb.w	r5, [r0, #1051]	; 0x41b
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   16958:	429d      	cmp	r5, r3
   1695a:	d001      	beq.n	16960 <USBH_FindInterface+0x134>
   1695c:	2bff      	cmp	r3, #255	; 0xff
   1695e:	d190      	bne.n	16882 <USBH_FindInterface+0x56>
    if_ix++;
   16960:	2005      	movs	r0, #5
   16962:	e7a9      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   16964:	f890 5444 	ldrb.w	r5, [r0, #1092]	; 0x444
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   16968:	4295      	cmp	r5, r2
   1696a:	d001      	beq.n	16970 <USBH_FindInterface+0x144>
   1696c:	2aff      	cmp	r2, #255	; 0xff
   1696e:	d18e      	bne.n	1688e <USBH_FindInterface+0x62>
   16970:	f890 5445 	ldrb.w	r5, [r0, #1093]	; 0x445
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   16974:	429d      	cmp	r5, r3
   16976:	d001      	beq.n	1697c <USBH_FindInterface+0x150>
   16978:	2bff      	cmp	r3, #255	; 0xff
   1697a:	d188      	bne.n	1688e <USBH_FindInterface+0x62>
    if_ix++;
   1697c:	2006      	movs	r0, #6
   1697e:	e79b      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   16980:	f890 546e 	ldrb.w	r5, [r0, #1134]	; 0x46e
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   16984:	4295      	cmp	r5, r2
   16986:	d001      	beq.n	1698c <USBH_FindInterface+0x160>
   16988:	2aff      	cmp	r2, #255	; 0xff
   1698a:	d186      	bne.n	1689a <USBH_FindInterface+0x6e>
   1698c:	f890 546f 	ldrb.w	r5, [r0, #1135]	; 0x46f
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   16990:	429d      	cmp	r5, r3
   16992:	d001      	beq.n	16998 <USBH_FindInterface+0x16c>
   16994:	2bff      	cmp	r3, #255	; 0xff
   16996:	d180      	bne.n	1689a <USBH_FindInterface+0x6e>
    if_ix++;
   16998:	2007      	movs	r0, #7
   1699a:	e78d      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   1699c:	f890 5498 	ldrb.w	r5, [r0, #1176]	; 0x498
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   169a0:	4295      	cmp	r5, r2
   169a2:	d002      	beq.n	169aa <USBH_FindInterface+0x17e>
   169a4:	2aff      	cmp	r2, #255	; 0xff
   169a6:	f47f af7e 	bne.w	168a6 <USBH_FindInterface+0x7a>
   169aa:	f890 5499 	ldrb.w	r5, [r0, #1177]	; 0x499
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   169ae:	429d      	cmp	r5, r3
   169b0:	d002      	beq.n	169b8 <USBH_FindInterface+0x18c>
   169b2:	2bff      	cmp	r3, #255	; 0xff
   169b4:	f47f af77 	bne.w	168a6 <USBH_FindInterface+0x7a>
    if_ix++;
   169b8:	2008      	movs	r0, #8
   169ba:	e77d      	b.n	168b8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   169bc:	f890 14c2 	ldrb.w	r1, [r0, #1218]	; 0x4c2
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   169c0:	4291      	cmp	r1, r2
   169c2:	d002      	beq.n	169ca <USBH_FindInterface+0x19e>
   169c4:	2aff      	cmp	r2, #255	; 0xff
   169c6:	f47f af76 	bne.w	168b6 <USBH_FindInterface+0x8a>
   169ca:	f890 24c3 	ldrb.w	r2, [r0, #1219]	; 0x4c3
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   169ce:	429a      	cmp	r2, r3
   169d0:	d002      	beq.n	169d8 <USBH_FindInterface+0x1ac>
   169d2:	2bff      	cmp	r3, #255	; 0xff
   169d4:	f47f af6f 	bne.w	168b6 <USBH_FindInterface+0x8a>
    if_ix++;
   169d8:	2009      	movs	r0, #9
   169da:	e76d      	b.n	168b8 <USBH_FindInterface+0x8c>

000169dc <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
{
   169dc:	b510      	push	{r4, lr}
   169de:	4604      	mov	r4, r0
  /* Start the low level driver  */
  USBH_LL_Start(phost);
   169e0:	f010 fa64 	bl	26eac <USBH_LL_Start>

  /* Activate VBUS on the port */
  USBH_LL_DriverVBUS(phost, OTRUE);
   169e4:	2101      	movs	r1, #1
   169e6:	4620      	mov	r0, r4
   169e8:	f010 faf2 	bl	26fd0 <USBH_LL_DriverVBUS>

  return USBH_OK;
}
   169ec:	2000      	movs	r0, #0
   169ee:	bd10      	pop	{r4, pc}

000169f0 <USBH_Stop>:
  *         Stop the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Stop(USBH_HandleTypeDef *phost)
{
   169f0:	b510      	push	{r4, lr}
   169f2:	4604      	mov	r4, r0
  /* DeActivate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 0);
   169f4:	2100      	movs	r1, #0
   169f6:	f010 faeb 	bl	26fd0 <USBH_LL_DriverVBUS>

  /* Stop and cleanup the low level driver  */
  USBH_LL_Stop(phost);
   169fa:	4620      	mov	r0, r4
   169fc:	f010 fa66 	bl	26ecc <USBH_LL_Stop>

  /* Free Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
   16a00:	7921      	ldrb	r1, [r4, #4]
   16a02:	4620      	mov	r0, r4
   16a04:	f001 fa28 	bl	17e58 <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
   16a08:	7961      	ldrb	r1, [r4, #5]
   16a0a:	4620      	mov	r0, r4
   16a0c:	f001 fa24 	bl	17e58 <USBH_FreePipe>

  return USBH_OK;
}
   16a10:	2000      	movs	r0, #0
   16a12:	bd10      	pop	{r4, pc}

00016a14 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
{
   16a14:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
   16a16:	2302      	movs	r3, #2
{
   16a18:	b087      	sub	sp, #28
   16a1a:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
   16a1c:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
   16a20:	f890 3321 	ldrb.w	r3, [r0, #801]	; 0x321
   16a24:	2b01      	cmp	r3, #1
   16a26:	d101      	bne.n	16a2c <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
   16a28:	2303      	movs	r3, #3
   16a2a:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
   16a2c:	7823      	ldrb	r3, [r4, #0]
   16a2e:	2b0b      	cmp	r3, #11
   16a30:	d84f      	bhi.n	16ad2 <USBH_Process+0xbe>
   16a32:	e8df f013 	tbh	[pc, r3, lsl #1]
   16a36:	0059      	.short	0x0059
   16a38:	0082006b 	.word	0x0082006b
   16a3c:	004e00b8 	.word	0x004e00b8
   16a40:	00f700ee 	.word	0x00f700ee
   16a44:	011f010c 	.word	0x011f010c
   16a48:	000c0117 	.word	0x000c0117
   16a4c:	0051      	.short	0x0051
#endif
      break;

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
   16a4e:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
   16a52:	2b00      	cmp	r3, #0
   16a54:	d03d      	beq.n	16ad2 <USBH_Process+0xbe>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
   16a56:	2300      	movs	r3, #0

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
        {
          for (int j = 0; j < 10; j++)
          {
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
   16a58:	f8d4 14e8 	ldr.w	r1, [r4, #1256]	; 0x4e8
   16a5c:	f894 2347 	ldrb.w	r2, [r4, #839]	; 0x347
        phost->pActiveClass = NULL;
   16a60:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
   16a64:	790b      	ldrb	r3, [r1, #4]
   16a66:	429a      	cmp	r2, r3
   16a68:	d024      	beq.n	16ab4 <USBH_Process+0xa0>
   16a6a:	f894 2371 	ldrb.w	r2, [r4, #881]	; 0x371
   16a6e:	429a      	cmp	r2, r3
   16a70:	d020      	beq.n	16ab4 <USBH_Process+0xa0>
   16a72:	f894 239b 	ldrb.w	r2, [r4, #923]	; 0x39b
   16a76:	429a      	cmp	r2, r3
   16a78:	d01c      	beq.n	16ab4 <USBH_Process+0xa0>
   16a7a:	f894 23c5 	ldrb.w	r2, [r4, #965]	; 0x3c5
   16a7e:	429a      	cmp	r2, r3
   16a80:	d018      	beq.n	16ab4 <USBH_Process+0xa0>
   16a82:	f894 23ef 	ldrb.w	r2, [r4, #1007]	; 0x3ef
   16a86:	429a      	cmp	r2, r3
   16a88:	d014      	beq.n	16ab4 <USBH_Process+0xa0>
   16a8a:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
   16a8e:	429a      	cmp	r2, r3
   16a90:	d010      	beq.n	16ab4 <USBH_Process+0xa0>
   16a92:	f894 2443 	ldrb.w	r2, [r4, #1091]	; 0x443
   16a96:	429a      	cmp	r2, r3
   16a98:	d00c      	beq.n	16ab4 <USBH_Process+0xa0>
   16a9a:	f894 246d 	ldrb.w	r2, [r4, #1133]	; 0x46d
   16a9e:	429a      	cmp	r2, r3
   16aa0:	d008      	beq.n	16ab4 <USBH_Process+0xa0>
   16aa2:	f894 2497 	ldrb.w	r2, [r4, #1175]	; 0x497
   16aa6:	429a      	cmp	r2, r3
   16aa8:	d004      	beq.n	16ab4 <USBH_Process+0xa0>
   16aaa:	f894 24c1 	ldrb.w	r2, [r4, #1217]	; 0x4c1
   16aae:	429a      	cmp	r2, r3
   16ab0:	f040 80c8 	bne.w	16c44 <USBH_Process+0x230>
			  {
				phost->pActiveClass = phost->pClass[idx];
   16ab4:	f8c4 14ec 	str.w	r1, [r4, #1260]	; 0x4ec
          }
        }

        if (phost->pActiveClass != NULL)
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
   16ab8:	4620      	mov	r0, r4
   16aba:	688b      	ldr	r3, [r1, #8]
   16abc:	4798      	blx	r3
   16abe:	2800      	cmp	r0, #0
   16ac0:	f040 80c0 	bne.w	16c44 <USBH_Process+0x230>
          {
            phost->gState = HOST_CLASS_REQUEST;
   16ac4:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
   16ac6:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   16aca:	4620      	mov	r0, r4
   16acc:	2103      	movs	r1, #3
            phost->gState = HOST_CLASS_REQUEST;
   16ace:	7022      	strb	r2, [r4, #0]
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
   16ad0:	4798      	blx	r3
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
   16ad2:	2000      	movs	r0, #0
   16ad4:	b007      	add	sp, #28
   16ad6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pActiveClass != NULL)
   16ad8:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
   16adc:	2b00      	cmp	r3, #0
   16ade:	d0f8      	beq.n	16ad2 <USBH_Process+0xbe>
        phost->pActiveClass->BgndProcess(phost);
   16ae0:	695b      	ldr	r3, [r3, #20]
   16ae2:	4620      	mov	r0, r4
   16ae4:	4798      	blx	r3
   16ae6:	e7f4      	b.n	16ad2 <USBH_Process+0xbe>
      if (phost->device.is_connected)
   16ae8:	f894 3320 	ldrb.w	r3, [r4, #800]	; 0x320
   16aec:	2b00      	cmp	r3, #0
   16aee:	d0f0      	beq.n	16ad2 <USBH_Process+0xbe>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
   16af0:	2301      	movs	r3, #1
        USBH_Delay(200U);
   16af2:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
   16af4:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
   16af6:	f010 fa8f 	bl	27018 <USBH_Delay>
        USBH_LL_ResetPort(phost);
   16afa:	4620      	mov	r0, r4
   16afc:	f010 fa06 	bl	26f0c <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
   16b00:	2300      	movs	r3, #0
   16b02:	f884 331c 	strb.w	r3, [r4, #796]	; 0x31c
        phost->Timeout = 0U;
   16b06:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
   16b0a:	e7e2      	b.n	16ad2 <USBH_Process+0xbe>
      if (phost->device.PortEnabled == 1U)
   16b0c:	f894 3323 	ldrb.w	r3, [r4, #803]	; 0x323
   16b10:	2b01      	cmp	r3, #1
   16b12:	f000 8145 	beq.w	16da0 <USBH_Process+0x38c>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
   16b16:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
   16b1a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   16b1e:	f240 80b7 	bls.w	16c90 <USBH_Process+0x27c>
          phost->device.RstCnt++;
   16b22:	f894 331f 	ldrb.w	r3, [r4, #799]	; 0x31f
   16b26:	3301      	adds	r3, #1
   16b28:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
   16b2a:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
   16b2c:	f884 331f 	strb.w	r3, [r4, #799]	; 0x31f
          if (phost->device.RstCnt > 3U)
   16b30:	f200 8088 	bhi.w	16c44 <USBH_Process+0x230>
            phost->gState = HOST_IDLE;
   16b34:	2300      	movs	r3, #0
   16b36:	7023      	strb	r3, [r4, #0]
   16b38:	e7cb      	b.n	16ad2 <USBH_Process+0xbe>
      if (phost->pUser != NULL)
   16b3a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   16b3e:	b113      	cbz	r3, 16b46 <USBH_Process+0x132>
        phost->pUser(phost, HOST_USER_CONNECTION);
   16b40:	2104      	movs	r1, #4
   16b42:	4620      	mov	r0, r4
   16b44:	4798      	blx	r3
      USBH_Delay(100U);
   16b46:	2064      	movs	r0, #100	; 0x64
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   16b48:	2500      	movs	r5, #0
      USBH_Delay(100U);
   16b4a:	f010 fa65 	bl	27018 <USBH_Delay>
      phost->device.speed = USBH_LL_GetSpeed(phost);
   16b4e:	4620      	mov	r0, r4
   16b50:	f010 f9cc 	bl	26eec <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
   16b54:	2305      	movs	r3, #5
      phost->device.speed = USBH_LL_GetSpeed(phost);
   16b56:	f884 031d 	strb.w	r0, [r4, #797]	; 0x31d
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   16b5a:	4629      	mov	r1, r5
      phost->gState = HOST_ENUMERATION;
   16b5c:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   16b5e:	4620      	mov	r0, r4
   16b60:	f001 f930 	bl	17dc4 <USBH_AllocPipe>
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   16b64:	2180      	movs	r1, #128	; 0x80
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   16b66:	7160      	strb	r0, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   16b68:	4620      	mov	r0, r4
   16b6a:	f001 f92b 	bl	17dc4 <USBH_AllocPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   16b6e:	79a7      	ldrb	r7, [r4, #6]
   16b70:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
   16b74:	4601      	mov	r1, r0
   16b76:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   16b7a:	2280      	movs	r2, #128	; 0x80
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   16b7c:	7120      	strb	r0, [r4, #4]
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   16b7e:	4620      	mov	r0, r4
   16b80:	9702      	str	r7, [sp, #8]
   16b82:	e9cd 6500 	strd	r6, r5, [sp]
   16b86:	f001 f907 	bl	17d98 <USBH_OpenPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
   16b8a:	79a7      	ldrb	r7, [r4, #6]
   16b8c:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
   16b90:	462a      	mov	r2, r5
   16b92:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   16b96:	4620      	mov	r0, r4
   16b98:	7961      	ldrb	r1, [r4, #5]
   16b9a:	9501      	str	r5, [sp, #4]
   16b9c:	9702      	str	r7, [sp, #8]
   16b9e:	9600      	str	r6, [sp, #0]
   16ba0:	f001 f8fa 	bl	17d98 <USBH_OpenPipe>
      break;
   16ba4:	e795      	b.n	16ad2 <USBH_Process+0xbe>
      phost->device.is_disconnected = 0U;
   16ba6:	2500      	movs	r5, #0
   16ba8:	223c      	movs	r2, #60	; 0x3c
   16baa:	f204 40f4 	addw	r0, r4, #1268	; 0x4f4
   16bae:	4629      	mov	r1, r5
   16bb0:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
   16bb4:	f019 fafd 	bl	301b2 <memset>
   16bb8:	4629      	mov	r1, r5
   16bba:	f44f 7200 	mov.w	r2, #512	; 0x200
   16bbe:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   16bc2:	f019 faf6 	bl	301b2 <memset>
  phost->RequestState = CMD_SEND;
   16bc6:	2301      	movs	r3, #1
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   16bc8:	2040      	movs	r0, #64	; 0x40
  phost->device.address = USBH_ADDRESS_DEFAULT;
   16bca:	f44f 7180 	mov.w	r1, #256	; 0x100
      if (phost->pActiveClass != NULL)
   16bce:	f8d4 24ec 	ldr.w	r2, [r4, #1260]	; 0x4ec
  phost->gState = HOST_IDLE;
   16bd2:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
   16bd4:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
   16bd6:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
   16bda:	7665      	strb	r5, [r4, #25]
  phost->RequestState = CMD_SEND;
   16bdc:	70a3      	strb	r3, [r4, #2]
  phost->Control.state = CTRL_SETUP;
   16bde:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   16be0:	71a0      	strb	r0, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
   16be2:	f8c4 131c 	str.w	r1, [r4, #796]	; 0x31c
      if (phost->pActiveClass != NULL)
   16be6:	b122      	cbz	r2, 16bf2 <USBH_Process+0x1de>
        phost->pActiveClass->DeInit(phost);
   16be8:	68d3      	ldr	r3, [r2, #12]
   16bea:	4620      	mov	r0, r4
   16bec:	4798      	blx	r3
        phost->pActiveClass = NULL;
   16bee:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
      if (phost->pUser != NULL)
   16bf2:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   16bf6:	b113      	cbz	r3, 16bfe <USBH_Process+0x1ea>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
   16bf8:	2105      	movs	r1, #5
   16bfa:	4620      	mov	r0, r4
   16bfc:	4798      	blx	r3
      if (phost->device.is_ReEnumerated == 1U)
   16bfe:	f894 5322 	ldrb.w	r5, [r4, #802]	; 0x322
   16c02:	b2ed      	uxtb	r5, r5
   16c04:	2d01      	cmp	r5, #1
   16c06:	f000 80c0 	beq.w	16d8a <USBH_Process+0x376>
        USBH_LL_Start(phost);
   16c0a:	4620      	mov	r0, r4
   16c0c:	f010 f94e 	bl	26eac <USBH_LL_Start>
  return USBH_OK;
   16c10:	e75f      	b.n	16ad2 <USBH_Process+0xbe>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
   16c12:	7863      	ldrb	r3, [r4, #1]
   16c14:	2b07      	cmp	r3, #7
   16c16:	d84d      	bhi.n	16cb4 <USBH_Process+0x2a0>
   16c18:	e8df f003 	tbb	[pc, r3]
   16c1c:	a58b9b41 	.word	0xa58b9b41
   16c20:	5f656d75 	.word	0x5f656d75
      if (phost->pActiveClass != NULL)
   16c24:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
   16c28:	b163      	cbz	r3, 16c44 <USBH_Process+0x230>
        status = phost->pActiveClass->Requests(phost);
   16c2a:	691b      	ldr	r3, [r3, #16]
   16c2c:	4620      	mov	r0, r4
   16c2e:	4798      	blx	r3
   16c30:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
   16c34:	f89d 3017 	ldrb.w	r3, [sp, #23]
   16c38:	b33b      	cbz	r3, 16c8a <USBH_Process+0x276>
        else if (status == USBH_FAIL)
   16c3a:	f89d 3017 	ldrb.w	r3, [sp, #23]
   16c3e:	2b02      	cmp	r3, #2
   16c40:	f47f af47 	bne.w	16ad2 <USBH_Process+0xbe>
        phost->gState = HOST_ABORT_STATE;
   16c44:	230d      	movs	r3, #13
}
   16c46:	2000      	movs	r0, #0
        phost->gState = HOST_ABORT_STATE;
   16c48:	7023      	strb	r3, [r4, #0]
}
   16c4a:	b007      	add	sp, #28
   16c4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pUser != NULL)
   16c4e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   16c52:	2b00      	cmp	r3, #0
   16c54:	f43f af3d 	beq.w	16ad2 <USBH_Process+0xbe>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
   16c58:	2101      	movs	r1, #1
   16c5a:	4620      	mov	r0, r4
   16c5c:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
   16c5e:	2308      	movs	r3, #8
   16c60:	7023      	strb	r3, [r4, #0]
   16c62:	e736      	b.n	16ad2 <USBH_Process+0xbe>
      if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
   16c64:	f894 333f 	ldrb.w	r3, [r4, #831]	; 0x33f
   16c68:	069b      	lsls	r3, r3, #26
   16c6a:	f100 8086 	bmi.w	16d7a <USBH_Process+0x366>
        phost->gState = HOST_CHECK_CLASS;
   16c6e:	230a      	movs	r3, #10
   16c70:	7023      	strb	r3, [r4, #0]
   16c72:	e72e      	b.n	16ad2 <USBH_Process+0xbe>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
   16c74:	f894 133d 	ldrb.w	r1, [r4, #829]	; 0x33d
   16c78:	4620      	mov	r0, r4
   16c7a:	f000 fd8f 	bl	1779c <USBH_SetCfg>
   16c7e:	2800      	cmp	r0, #0
   16c80:	f47f af27 	bne.w	16ad2 <USBH_Process+0xbe>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
   16c84:	2309      	movs	r3, #9
   16c86:	7023      	strb	r3, [r4, #0]
   16c88:	e723      	b.n	16ad2 <USBH_Process+0xbe>
          phost->gState = HOST_CLASS;
   16c8a:	230b      	movs	r3, #11
   16c8c:	7023      	strb	r3, [r4, #0]
   16c8e:	e720      	b.n	16ad2 <USBH_Process+0xbe>
          phost->Timeout += 10U;
   16c90:	330a      	adds	r3, #10
          USBH_Delay(10U);
   16c92:	200a      	movs	r0, #10
          phost->Timeout += 10U;
   16c94:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
          USBH_Delay(10U);
   16c98:	f010 f9be 	bl	27018 <USBH_Delay>
   16c9c:	e719      	b.n	16ad2 <USBH_Process+0xbe>
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
   16c9e:	2108      	movs	r1, #8
   16ca0:	4620      	mov	r0, r4
   16ca2:	f000 f91f 	bl	16ee4 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
   16ca6:	4605      	mov	r5, r0
   16ca8:	2800      	cmp	r0, #0
   16caa:	f000 80c1 	beq.w	16e30 <USBH_Process+0x41c>
        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
      }
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   16cae:	2803      	cmp	r0, #3
   16cb0:	f000 80aa 	beq.w	16e08 <USBH_Process+0x3f4>
  USBH_StatusTypeDef Status = USBH_BUSY;
   16cb4:	2301      	movs	r3, #1
      status = USBH_HandleEnum(phost);
   16cb6:	f88d 3017 	strb.w	r3, [sp, #23]
      if (status == USBH_OK)
   16cba:	f89d 3017 	ldrb.w	r3, [sp, #23]
   16cbe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   16cc2:	2b00      	cmp	r3, #0
   16cc4:	f47f af05 	bne.w	16ad2 <USBH_Process+0xbe>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
   16cc8:	f894 3337 	ldrb.w	r3, [r4, #823]	; 0x337
        phost->device.current_interface = 0U;
   16ccc:	f884 2324 	strb.w	r2, [r4, #804]	; 0x324
        if (phost->device.DevDesc.bNumConfigurations == 1U)
   16cd0:	2b01      	cmp	r3, #1
   16cd2:	d0c4      	beq.n	16c5e <USBH_Process+0x24a>
          phost->gState = HOST_INPUT;
   16cd4:	2307      	movs	r3, #7
   16cd6:	7023      	strb	r3, [r4, #0]
   16cd8:	e6fb      	b.n	16ad2 <USBH_Process+0xbe>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
   16cda:	f894 1336 	ldrb.w	r1, [r4, #822]	; 0x336
   16cde:	2900      	cmp	r1, #0
   16ce0:	d174      	bne.n	16dcc <USBH_Process+0x3b8>
        }
      }
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
   16ce2:	460b      	mov	r3, r1
   16ce4:	e7e7      	b.n	16cb6 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iProduct != 0U)
   16ce6:	f894 1335 	ldrb.w	r1, [r4, #821]	; 0x335
   16cea:	2900      	cmp	r1, #0
   16cec:	d17f      	bne.n	16dee <USBH_Process+0x3da>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   16cee:	2207      	movs	r2, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
   16cf0:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   16cf2:	7062      	strb	r2, [r4, #1]
   16cf4:	e7df      	b.n	16cb6 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iManufacturer != 0U)
   16cf6:	f894 1334 	ldrb.w	r1, [r4, #820]	; 0x334
   16cfa:	2900      	cmp	r1, #0
   16cfc:	d15a      	bne.n	16db4 <USBH_Process+0x3a0>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   16cfe:	2206      	movs	r2, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
   16d00:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   16d02:	7062      	strb	r2, [r4, #1]
   16d04:	e7d7      	b.n	16cb6 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
   16d06:	f8b4 133a 	ldrh.w	r1, [r4, #826]	; 0x33a
   16d0a:	4620      	mov	r0, r4
   16d0c:	f000 f9fa 	bl	17104 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
   16d10:	2800      	cmp	r0, #0
   16d12:	d04b      	beq.n	16dac <USBH_Process+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   16d14:	2803      	cmp	r0, #3
   16d16:	d1cd      	bne.n	16cb4 <USBH_Process+0x2a0>
        phost->device.EnumCnt++;
   16d18:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
   16d1c:	3301      	adds	r3, #1
   16d1e:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
   16d20:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
   16d22:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
   16d26:	f240 80a6 	bls.w	16e76 <USBH_Process+0x462>
          phost->gState = HOST_ABORT_STATE;
   16d2a:	220d      	movs	r2, #13
  USBH_StatusTypeDef Status = USBH_BUSY;
   16d2c:	2301      	movs	r3, #1
          phost->gState = HOST_ABORT_STATE;
   16d2e:	7022      	strb	r2, [r4, #0]
   16d30:	e7c1      	b.n	16cb6 <USBH_Process+0x2a2>
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
   16d32:	2101      	movs	r1, #1
   16d34:	4620      	mov	r0, r4
   16d36:	f000 fc4b 	bl	175d0 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
   16d3a:	4606      	mov	r6, r0
   16d3c:	2800      	cmp	r0, #0
   16d3e:	f000 80a7 	beq.w	16e90 <USBH_Process+0x47c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   16d42:	2803      	cmp	r0, #3
   16d44:	d1b6      	bne.n	16cb4 <USBH_Process+0x2a0>
        phost->gState = HOST_ABORT_STATE;
   16d46:	210d      	movs	r1, #13
        phost->EnumState = ENUM_IDLE;
   16d48:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   16d4a:	2301      	movs	r3, #1
        phost->gState = HOST_ABORT_STATE;
   16d4c:	7021      	strb	r1, [r4, #0]
        phost->EnumState = ENUM_IDLE;
   16d4e:	7062      	strb	r2, [r4, #1]
   16d50:	e7b1      	b.n	16cb6 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
   16d52:	2112      	movs	r1, #18
   16d54:	4620      	mov	r0, r4
   16d56:	f000 f8c5 	bl	16ee4 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
   16d5a:	2800      	cmp	r0, #0
   16d5c:	d1da      	bne.n	16d14 <USBH_Process+0x300>
        phost->EnumState = ENUM_SET_ADDR;
   16d5e:	2202      	movs	r2, #2
  USBH_StatusTypeDef Status = USBH_BUSY;
   16d60:	2301      	movs	r3, #1
        phost->EnumState = ENUM_SET_ADDR;
   16d62:	7062      	strb	r2, [r4, #1]
   16d64:	e7a7      	b.n	16cb6 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
   16d66:	2109      	movs	r1, #9
   16d68:	4620      	mov	r0, r4
   16d6a:	f000 f9cb 	bl	17104 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
   16d6e:	2800      	cmp	r0, #0
   16d70:	d1d0      	bne.n	16d14 <USBH_Process+0x300>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   16d72:	2204      	movs	r2, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
   16d74:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   16d76:	7062      	strb	r2, [r4, #1]
   16d78:	e79d      	b.n	16cb6 <USBH_Process+0x2a2>
        if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
   16d7a:	2101      	movs	r1, #1
   16d7c:	4620      	mov	r0, r4
   16d7e:	f000 fdf3 	bl	17968 <USBH_SetFeature>
   16d82:	2800      	cmp	r0, #0
   16d84:	f47f aea5 	bne.w	16ad2 <USBH_Process+0xbe>
   16d88:	e771      	b.n	16c6e <USBH_Process+0x25a>
        phost->device.is_ReEnumerated = 0U;
   16d8a:	2300      	movs	r3, #0
  USBH_LL_Start(phost);
   16d8c:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
   16d8e:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  USBH_LL_Start(phost);
   16d92:	f010 f88b 	bl	26eac <USBH_LL_Start>
  USBH_LL_DriverVBUS(phost, OTRUE);
   16d96:	4629      	mov	r1, r5
   16d98:	4620      	mov	r0, r4
   16d9a:	f010 f919 	bl	26fd0 <USBH_LL_DriverVBUS>
   16d9e:	e698      	b.n	16ad2 <USBH_Process+0xbe>
        phost->device.RstCnt = 0U;
   16da0:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
   16da2:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
   16da4:	f884 231f 	strb.w	r2, [r4, #799]	; 0x31f
        phost->gState = HOST_DEV_ATTACHED;
   16da8:	7023      	strb	r3, [r4, #0]
   16daa:	e692      	b.n	16ad2 <USBH_Process+0xbe>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   16dac:	2205      	movs	r2, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
   16dae:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   16db0:	7062      	strb	r2, [r4, #1]
   16db2:	e780      	b.n	16cb6 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
   16db4:	23ff      	movs	r3, #255	; 0xff
   16db6:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   16dba:	4620      	mov	r0, r4
   16dbc:	f000 fafa 	bl	173b4 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
   16dc0:	2800      	cmp	r0, #0
   16dc2:	d09c      	beq.n	16cfe <USBH_Process+0x2ea>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   16dc4:	2803      	cmp	r0, #3
   16dc6:	f47f af75 	bne.w	16cb4 <USBH_Process+0x2a0>
   16dca:	e798      	b.n	16cfe <USBH_Process+0x2ea>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
   16dcc:	23ff      	movs	r3, #255	; 0xff
   16dce:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   16dd2:	4620      	mov	r0, r4
   16dd4:	f000 faee 	bl	173b4 <USBH_Get_StringDesc>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   16dd8:	f1a0 0303 	sub.w	r3, r0, #3
   16ddc:	fab3 f383 	clz	r3, r3
   16de0:	095b      	lsrs	r3, r3, #5
   16de2:	2800      	cmp	r0, #0
   16de4:	bf08      	it	eq
   16de6:	2301      	moveq	r3, #1
  USBH_StatusTypeDef Status = USBH_BUSY;
   16de8:	f083 0301 	eor.w	r3, r3, #1
   16dec:	e763      	b.n	16cb6 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
   16dee:	23ff      	movs	r3, #255	; 0xff
   16df0:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   16df4:	4620      	mov	r0, r4
   16df6:	f000 fadd 	bl	173b4 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
   16dfa:	2800      	cmp	r0, #0
   16dfc:	f43f af77 	beq.w	16cee <USBH_Process+0x2da>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   16e00:	2803      	cmp	r0, #3
   16e02:	f47f af57 	bne.w	16cb4 <USBH_Process+0x2a0>
   16e06:	e772      	b.n	16cee <USBH_Process+0x2da>
        phost->device.EnumCnt++;
   16e08:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
   16e0c:	3301      	adds	r3, #1
   16e0e:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
   16e10:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
   16e12:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
   16e16:	d888      	bhi.n	16d2a <USBH_Process+0x316>
          USBH_FreePipe(phost, phost->Control.pipe_out);
   16e18:	7961      	ldrb	r1, [r4, #5]
   16e1a:	4620      	mov	r0, r4
   16e1c:	f001 f81c 	bl	17e58 <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
   16e20:	7921      	ldrb	r1, [r4, #4]
   16e22:	4620      	mov	r0, r4
   16e24:	f001 f818 	bl	17e58 <USBH_FreePipe>
          phost->gState = HOST_IDLE;
   16e28:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   16e2a:	2301      	movs	r3, #1
          phost->gState = HOST_IDLE;
   16e2c:	7022      	strb	r2, [r4, #0]
   16e2e:	e742      	b.n	16cb6 <USBH_Process+0x2a2>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   16e30:	f894 732d 	ldrb.w	r7, [r4, #813]	; 0x32d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   16e34:	2601      	movs	r6, #1
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   16e36:	f894 c31d 	ldrb.w	ip, [r4, #797]	; 0x31d
   16e3a:	2280      	movs	r2, #128	; 0x80
   16e3c:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   16e40:	4620      	mov	r0, r4
   16e42:	7921      	ldrb	r1, [r4, #4]
   16e44:	9501      	str	r5, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   16e46:	71a7      	strb	r7, [r4, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   16e48:	9702      	str	r7, [sp, #8]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   16e4a:	7066      	strb	r6, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   16e4c:	f8cd c000 	str.w	ip, [sp]
   16e50:	f000 ffa2 	bl	17d98 <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
   16e54:	f894 c006 	ldrb.w	ip, [r4, #6]
   16e58:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   16e5c:	462a      	mov	r2, r5
   16e5e:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   16e62:	4620      	mov	r0, r4
   16e64:	7961      	ldrb	r1, [r4, #5]
   16e66:	9501      	str	r5, [sp, #4]
   16e68:	f8cd c008 	str.w	ip, [sp, #8]
   16e6c:	9700      	str	r7, [sp, #0]
   16e6e:	f000 ff93 	bl	17d98 <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
   16e72:	4633      	mov	r3, r6
   16e74:	e71f      	b.n	16cb6 <USBH_Process+0x2a2>
          USBH_FreePipe(phost, phost->Control.pipe_out);
   16e76:	7961      	ldrb	r1, [r4, #5]
   16e78:	4620      	mov	r0, r4
   16e7a:	f000 ffed 	bl	17e58 <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
   16e7e:	7921      	ldrb	r1, [r4, #4]
   16e80:	4620      	mov	r0, r4
   16e82:	f000 ffe9 	bl	17e58 <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
   16e86:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   16e88:	2301      	movs	r3, #1
          phost->EnumState = ENUM_IDLE;
   16e8a:	7062      	strb	r2, [r4, #1]
          phost->gState = HOST_IDLE;
   16e8c:	7022      	strb	r2, [r4, #0]
   16e8e:	e712      	b.n	16cb6 <USBH_Process+0x2a2>
        USBH_Delay(2U);
   16e90:	2002      	movs	r0, #2
        phost->device.address = USBH_DEVICE_ADDRESS;
   16e92:	2501      	movs	r5, #1
        USBH_Delay(2U);
   16e94:	f010 f8c0 	bl	27018 <USBH_Delay>
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   16e98:	79a7      	ldrb	r7, [r4, #6]
        phost->EnumState = ENUM_GET_CFG_DESC;
   16e9a:	2003      	movs	r0, #3
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   16e9c:	7921      	ldrb	r1, [r4, #4]
   16e9e:	9601      	str	r6, [sp, #4]
   16ea0:	462b      	mov	r3, r5
        phost->EnumState = ENUM_GET_CFG_DESC;
   16ea2:	7060      	strb	r0, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   16ea4:	2280      	movs	r2, #128	; 0x80
        phost->device.address = USBH_DEVICE_ADDRESS;
   16ea6:	f884 531c 	strb.w	r5, [r4, #796]	; 0x31c
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   16eaa:	4620      	mov	r0, r4
   16eac:	9702      	str	r7, [sp, #8]
   16eae:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   16eb2:	9700      	str	r7, [sp, #0]
   16eb4:	f000 ff70 	bl	17d98 <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
   16eb8:	f894 c006 	ldrb.w	ip, [r4, #6]
   16ebc:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   16ec0:	4632      	mov	r2, r6
   16ec2:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   16ec6:	4620      	mov	r0, r4
   16ec8:	7961      	ldrb	r1, [r4, #5]
   16eca:	9601      	str	r6, [sp, #4]
   16ecc:	f8cd c008 	str.w	ip, [sp, #8]
   16ed0:	9700      	str	r7, [sp, #0]
   16ed2:	f000 ff61 	bl	17d98 <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
   16ed6:	462b      	mov	r3, r5
   16ed8:	e6ed      	b.n	16cb6 <USBH_Process+0x2a2>
   16eda:	bf00      	nop

00016edc <USBH_LL_SetTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
  phost->Timer = time;
   16edc:	f8c0 1534 	str.w	r1, [r0, #1332]	; 0x534
}
   16ee0:	4770      	bx	lr
   16ee2:	bf00      	nop

00016ee4 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
{
   16ee4:	b570      	push	{r4, r5, r6, lr}
   16ee6:	4604      	mov	r4, r0
                                      uint8_t  req_type,
                                      uint16_t value_idx,
                                      uint8_t *buff,
                                      uint16_t length)
{
  if (phost->RequestState == CMD_SEND)
   16ee8:	7880      	ldrb	r0, [r0, #2]
{
   16eea:	b082      	sub	sp, #8
  if (phost->RequestState == CMD_SEND)
   16eec:	2801      	cmp	r0, #1
   16eee:	d011      	beq.n	16f14 <USBH_Get_DevDesc+0x30>
                               uint16_t length)
{
  USBH_StatusTypeDef status;
  status = USBH_BUSY;

  switch (phost->RequestState)
   16ef0:	2802      	cmp	r0, #2
   16ef2:	d002      	beq.n	16efa <USBH_Get_DevDesc+0x16>
  status = USBH_BUSY;
   16ef4:	2001      	movs	r0, #1
}
   16ef6:	b002      	add	sp, #8
   16ef8:	bd70      	pop	{r4, r5, r6, pc}
{
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
   16efa:	7e23      	ldrb	r3, [r4, #24]
   16efc:	460d      	mov	r5, r1
   16efe:	3b01      	subs	r3, #1
   16f00:	2b0a      	cmp	r3, #10
   16f02:	d8f7      	bhi.n	16ef4 <USBH_Get_DevDesc+0x10>
   16f04:	e8df f003 	tbb	[pc, r3]
   16f08:	584b3c32 	.word	0x584b3c32
   16f0c:	8f827263 	.word	0x8f827263
   16f10:	afa0      	.short	0xafa0
   16f12:	17          	.byte	0x17
   16f13:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   16f14:	f44f 63d0 	mov.w	r3, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
   16f18:	2600      	movs	r6, #0
                                   USB_DESC_DEVICE, phost->device.Data,
   16f1a:	f504 758e 	add.w	r5, r4, #284	; 0x11c
      phost->RequestState = CMD_WAIT;
   16f1e:	2202      	movs	r2, #2
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   16f20:	f2c0 1300 	movt	r3, #256	; 0x100
    phost->Control.setup.b.wLength.w = length;
   16f24:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
   16f26:	81a1      	strh	r1, [r4, #12]
      phost->Control.state = CTRL_SETUP;
   16f28:	7620      	strb	r0, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   16f2a:	6123      	str	r3, [r4, #16]
    phost->Control.setup.b.wValue.w = value_idx;
   16f2c:	82a6      	strh	r6, [r4, #20]
      phost->Control.buff = buff;
   16f2e:	60a5      	str	r5, [r4, #8]
      phost->RequestState = CMD_WAIT;
   16f30:	70a2      	strb	r2, [r4, #2]
}
   16f32:	b002      	add	sp, #8
   16f34:	bd70      	pop	{r4, r5, r6, pc}
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   16f36:	7e63      	ldrb	r3, [r4, #25]
   16f38:	3301      	adds	r3, #1
   16f3a:	b2db      	uxtb	r3, r3
   16f3c:	2b02      	cmp	r3, #2
   16f3e:	7663      	strb	r3, [r4, #25]
   16f40:	f240 80d7 	bls.w	170f2 <USBH_Get_DevDesc+0x20e>
        phost->RequestState = CMD_SEND;
      }
      else
      {
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
        phost->Control.errorcount = 0U;
   16f44:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   16f46:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   16f4a:	2106      	movs	r1, #6
   16f4c:	4620      	mov	r0, r4
   16f4e:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");

        /* Free control pipes */
        USBH_FreePipe(phost, phost->Control.pipe_out);
   16f50:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   16f52:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   16f54:	4620      	mov	r0, r4
   16f56:	f000 ff7f 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   16f5a:	7921      	ldrb	r1, [r4, #4]
   16f5c:	4620      	mov	r0, r4
   16f5e:	f000 ff7b 	bl	17e58 <USBH_FreePipe>

        phost->gState = HOST_IDLE;
   16f62:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   16f64:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   16f66:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   16f68:	70a3      	strb	r3, [r4, #2]
   16f6a:	e7c4      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   16f6c:	7962      	ldrb	r2, [r4, #5]
   16f6e:	f104 0110 	add.w	r1, r4, #16
   16f72:	4620      	mov	r0, r4
   16f74:	f000 fec4 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   16f78:	2302      	movs	r3, #2
   16f7a:	2001      	movs	r0, #1
   16f7c:	7623      	strb	r3, [r4, #24]
   16f7e:	e7ba      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16f80:	7961      	ldrb	r1, [r4, #5]
   16f82:	4620      	mov	r0, r4
   16f84:	f010 f820 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16f88:	2801      	cmp	r0, #1
   16f8a:	f000 80a7 	beq.w	170dc <USBH_Get_DevDesc+0x1f8>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   16f8e:	2804      	cmp	r0, #4
   16f90:	d001      	beq.n	16f96 <USBH_Get_DevDesc+0xb2>
   16f92:	2802      	cmp	r0, #2
   16f94:	d1ae      	bne.n	16ef4 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
   16f96:	230b      	movs	r3, #11
   16f98:	2001      	movs	r0, #1
   16f9a:	7623      	strb	r3, [r4, #24]
   16f9c:	e7ab      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   16f9e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16fa2:	4620      	mov	r0, r4
   16fa4:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   16fa6:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16fa8:	68a1      	ldr	r1, [r4, #8]
   16faa:	89a2      	ldrh	r2, [r4, #12]
   16fac:	f000 fed0 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   16fb0:	2304      	movs	r3, #4
   16fb2:	2001      	movs	r0, #1
   16fb4:	7623      	strb	r3, [r4, #24]
   16fb6:	e79e      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   16fb8:	7921      	ldrb	r1, [r4, #4]
   16fba:	4620      	mov	r0, r4
   16fbc:	f010 f804 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16fc0:	2801      	cmp	r0, #1
   16fc2:	d058      	beq.n	17076 <USBH_Get_DevDesc+0x192>
      if (URB_Status == USBH_URB_STALL)
   16fc4:	2805      	cmp	r0, #5
   16fc6:	d039      	beq.n	1703c <USBH_Get_DevDesc+0x158>
        if (URB_Status == USBH_URB_ERROR)
   16fc8:	2804      	cmp	r0, #4
   16fca:	d193      	bne.n	16ef4 <USBH_Get_DevDesc+0x10>
   16fcc:	e7e3      	b.n	16f96 <USBH_Get_DevDesc+0xb2>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   16fce:	2501      	movs	r5, #1
   16fd0:	7963      	ldrb	r3, [r4, #5]
   16fd2:	89a2      	ldrh	r2, [r4, #12]
   16fd4:	4620      	mov	r0, r4
   16fd6:	68a1      	ldr	r1, [r4, #8]
   16fd8:	9500      	str	r5, [sp, #0]
   16fda:	f000 fea1 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   16fde:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   16fe2:	2306      	movs	r3, #6
   16fe4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16fe6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   16fe8:	7623      	strb	r3, [r4, #24]
   16fea:	e784      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16fec:	7961      	ldrb	r1, [r4, #5]
   16fee:	4620      	mov	r0, r4
   16ff0:	f00f ffea 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16ff4:	2801      	cmp	r0, #1
   16ff6:	d06d      	beq.n	170d4 <USBH_Get_DevDesc+0x1f0>
      else if (URB_Status == USBH_URB_STALL)
   16ff8:	2805      	cmp	r0, #5
   16ffa:	d01f      	beq.n	1703c <USBH_Get_DevDesc+0x158>
      else if (URB_Status == USBH_URB_NOTREADY)
   16ffc:	2802      	cmp	r0, #2
   16ffe:	d074      	beq.n	170ea <USBH_Get_DevDesc+0x206>
        if (URB_Status == USBH_URB_ERROR)
   17000:	2804      	cmp	r0, #4
   17002:	f47f af77 	bne.w	16ef4 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
   17006:	230b      	movs	r3, #11
   17008:	7623      	strb	r3, [r4, #24]
   1700a:	e7ab      	b.n	16f64 <USBH_Get_DevDesc+0x80>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   1700c:	2200      	movs	r2, #0
   1700e:	7923      	ldrb	r3, [r4, #4]
   17010:	4620      	mov	r0, r4
   17012:	4611      	mov	r1, r2
   17014:	f000 fe9c 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17018:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   1701c:	2308      	movs	r3, #8
   1701e:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   17020:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17022:	7623      	strb	r3, [r4, #24]
   17024:	e767      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17026:	7921      	ldrb	r1, [r4, #4]
   17028:	4620      	mov	r0, r4
   1702a:	f00f ffcd 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1702e:	2801      	cmp	r0, #1
   17030:	d025      	beq.n	1707e <USBH_Get_DevDesc+0x19a>
      else if (URB_Status == USBH_URB_ERROR)
   17032:	2804      	cmp	r0, #4
   17034:	d0af      	beq.n	16f96 <USBH_Get_DevDesc+0xb2>
        if (URB_Status == USBH_URB_STALL)
   17036:	2805      	cmp	r0, #5
   17038:	f47f af5c 	bne.w	16ef4 <USBH_Get_DevDesc+0x10>
        phost->RequestState = CMD_SEND;
   1703c:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   1703e:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   17040:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   17042:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   17044:	7623      	strb	r3, [r4, #24]
   17046:	e756      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   17048:	2200      	movs	r2, #0
   1704a:	2501      	movs	r5, #1
   1704c:	7963      	ldrb	r3, [r4, #5]
   1704e:	4620      	mov	r0, r4
   17050:	4611      	mov	r1, r2
   17052:	9500      	str	r5, [sp, #0]
   17054:	f000 fe64 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17058:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   1705c:	230a      	movs	r3, #10
   1705e:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17060:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17062:	7623      	strb	r3, [r4, #24]
   17064:	e747      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17066:	7961      	ldrb	r1, [r4, #5]
   17068:	4620      	mov	r0, r4
   1706a:	f00f ffad 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1706e:	2801      	cmp	r0, #1
   17070:	d005      	beq.n	1707e <USBH_Get_DevDesc+0x19a>
      else if (URB_Status == USBH_URB_NOTREADY)
   17072:	2802      	cmp	r0, #2
   17074:	d1a8      	bne.n	16fc8 <USBH_Get_DevDesc+0xe4>
            phost->Control.state = CTRL_STATUS_OUT;
   17076:	2309      	movs	r3, #9
   17078:	2001      	movs	r0, #1
   1707a:	7623      	strb	r3, [r4, #24]
   1707c:	e73b      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
        phost->RequestState = CMD_SEND;
   1707e:	2201      	movs	r2, #1
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
   17080:	f894 311c 	ldrb.w	r3, [r4, #284]	; 0x11c
        phost->Control.state = CTRL_IDLE;
   17084:	2000      	movs	r0, #0
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
   17086:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
   1708a:	70a2      	strb	r2, [r4, #2]
  if (length > 8U)
   1708c:	2d08      	cmp	r5, #8
  dev_desc->bcdUSB             = LE16(buf +  2);
   1708e:	f8b4 211e 	ldrh.w	r2, [r4, #286]	; 0x11e
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
   17092:	f884 3326 	strb.w	r3, [r4, #806]	; 0x326
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
   17096:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
        phost->Control.state = CTRL_IDLE;
   1709a:	7620      	strb	r0, [r4, #24]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
   1709c:	f884 1327 	strb.w	r1, [r4, #807]	; 0x327
  dev_desc->bcdUSB             = LE16(buf +  2);
   170a0:	f8a4 2328 	strh.w	r2, [r4, #808]	; 0x328
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
   170a4:	f8c4 332a 	str.w	r3, [r4, #810]	; 0x32a
  if (length > 8U)
   170a8:	f67f af25 	bls.w	16ef6 <USBH_Get_DevDesc+0x12>
    dev_desc->idVendor           = LE16(buf +  8);
   170ac:	f8b4 5124 	ldrh.w	r5, [r4, #292]	; 0x124
    dev_desc->idProduct          = LE16(buf + 10);
   170b0:	f8b4 1126 	ldrh.w	r1, [r4, #294]	; 0x126
    dev_desc->bcdDevice          = LE16(buf + 12);
   170b4:	f8b4 2128 	ldrh.w	r2, [r4, #296]	; 0x128
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
   170b8:	f8d4 312a 	ldr.w	r3, [r4, #298]	; 0x12a
    dev_desc->idVendor           = LE16(buf +  8);
   170bc:	f8a4 532e 	strh.w	r5, [r4, #814]	; 0x32e
    dev_desc->idProduct          = LE16(buf + 10);
   170c0:	f8a4 1330 	strh.w	r1, [r4, #816]	; 0x330
    dev_desc->bcdDevice          = LE16(buf + 12);
   170c4:	f8a4 2332 	strh.w	r2, [r4, #818]	; 0x332
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
   170c8:	f8c4 3334 	str.w	r3, [r4, #820]	; 0x334
}
   170cc:	b002      	add	sp, #8
   170ce:	bd70      	pop	{r4, r5, r6, pc}
          if (direction == USB_D2H)
   170d0:	2a00      	cmp	r2, #0
   170d2:	dbd0      	blt.n	17076 <USBH_Get_DevDesc+0x192>
            phost->Control.state = CTRL_STATUS_IN;
   170d4:	2307      	movs	r3, #7
   170d6:	2001      	movs	r0, #1
   170d8:	7623      	strb	r3, [r4, #24]
   170da:	e70c      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   170dc:	8ae3      	ldrh	r3, [r4, #22]
   170de:	f994 2010 	ldrsb.w	r2, [r4, #16]
   170e2:	2b00      	cmp	r3, #0
   170e4:	d0f4      	beq.n	170d0 <USBH_Get_DevDesc+0x1ec>
          if (direction == USB_D2H)
   170e6:	2a00      	cmp	r2, #0
   170e8:	db08      	blt.n	170fc <USBH_Get_DevDesc+0x218>
            phost->Control.state = CTRL_DATA_OUT;
   170ea:	2305      	movs	r3, #5
   170ec:	2001      	movs	r0, #1
   170ee:	7623      	strb	r3, [r4, #24]
   170f0:	e701      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
        phost->Control.state = CTRL_SETUP;
   170f2:	2301      	movs	r3, #1
   170f4:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   170f6:	4618      	mov	r0, r3
   170f8:	70a3      	strb	r3, [r4, #2]
   170fa:	e6fc      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
            phost->Control.state = CTRL_DATA_IN;
   170fc:	2303      	movs	r3, #3
   170fe:	7623      	strb	r3, [r4, #24]
   17100:	e6f9      	b.n	16ef6 <USBH_Get_DevDesc+0x12>
   17102:	bf00      	nop

00017104 <USBH_Get_CfgDesc>:
{
   17104:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (phost->RequestState == CMD_SEND)
   17108:	7883      	ldrb	r3, [r0, #2]
{
   1710a:	b083      	sub	sp, #12
   1710c:	4605      	mov	r5, r0
  uint8_t *pData = phost->device.CfgDesc_Raw;;
   1710e:	f100 041c 	add.w	r4, r0, #28
  if (phost->RequestState == CMD_SEND)
   17112:	2b01      	cmp	r3, #1
   17114:	d012      	beq.n	1713c <USBH_Get_CfgDesc+0x38>
  switch (phost->RequestState)
   17116:	2b02      	cmp	r3, #2
   17118:	d003      	beq.n	17122 <USBH_Get_CfgDesc+0x1e>
  status = USBH_BUSY;
   1711a:	2001      	movs	r0, #1
}
   1711c:	b003      	add	sp, #12
   1711e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  switch (phost->Control.state)
   17122:	7e03      	ldrb	r3, [r0, #24]
   17124:	460e      	mov	r6, r1
   17126:	3b01      	subs	r3, #1
   17128:	2b0a      	cmp	r3, #10
   1712a:	d8f6      	bhi.n	1711a <USBH_Get_CfgDesc+0x16>
   1712c:	e8df f003 	tbb	[pc, r3]
   17130:	54483a31 	.word	0x54483a31
   17134:	897d6c5e 	.word	0x897d6c5e
   17138:	a799      	.short	0xa799
   1713a:	17          	.byte	0x17
   1713b:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   1713c:	f44f 62d0 	mov.w	r2, #1664	; 0x680
    phost->Control.setup.b.wLength.w = length;
   17140:	82c1      	strh	r1, [r0, #22]
      phost->Control.buff = buff;
   17142:	6084      	str	r4, [r0, #8]
    phost->Control.setup.b.wValue.w = value_idx;
   17144:	2700      	movs	r7, #0
      phost->Control.length = length;
   17146:	8181      	strh	r1, [r0, #12]
      phost->RequestState = CMD_WAIT;
   17148:	2602      	movs	r6, #2
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   1714a:	f2c0 2200 	movt	r2, #512	; 0x200
      status = USBH_BUSY;
   1714e:	4618      	mov	r0, r3
      phost->Control.state = CTRL_SETUP;
   17150:	762b      	strb	r3, [r5, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   17152:	612a      	str	r2, [r5, #16]
    phost->Control.setup.b.wValue.w = value_idx;
   17154:	82af      	strh	r7, [r5, #20]
      phost->RequestState = CMD_WAIT;
   17156:	70ae      	strb	r6, [r5, #2]
}
   17158:	b003      	add	sp, #12
   1715a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   1715e:	7e43      	ldrb	r3, [r0, #25]
   17160:	3301      	adds	r3, #1
   17162:	b2db      	uxtb	r3, r3
   17164:	2b02      	cmp	r3, #2
   17166:	7643      	strb	r3, [r0, #25]
   17168:	f240 811b 	bls.w	173a2 <USBH_Get_CfgDesc+0x29e>
        phost->Control.errorcount = 0U;
   1716c:	2400      	movs	r4, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   1716e:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
   17172:	2106      	movs	r1, #6
   17174:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17176:	7969      	ldrb	r1, [r5, #5]
        phost->Control.errorcount = 0U;
   17178:	766c      	strb	r4, [r5, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   1717a:	4628      	mov	r0, r5
   1717c:	f000 fe6c 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   17180:	7929      	ldrb	r1, [r5, #4]
   17182:	4628      	mov	r0, r5
   17184:	f000 fe68 	bl	17e58 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   17188:	702c      	strb	r4, [r5, #0]
        phost->RequestState = CMD_SEND;
   1718a:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   1718c:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   1718e:	70ab      	strb	r3, [r5, #2]
   17190:	e7c4      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   17192:	7942      	ldrb	r2, [r0, #5]
   17194:	f100 0110 	add.w	r1, r0, #16
   17198:	f000 fdb2 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   1719c:	2302      	movs	r3, #2
   1719e:	2001      	movs	r0, #1
   171a0:	762b      	strb	r3, [r5, #24]
   171a2:	e7bb      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   171a4:	7941      	ldrb	r1, [r0, #5]
   171a6:	f00f ff0f 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   171aa:	2801      	cmp	r0, #1
   171ac:	f000 80ee 	beq.w	1738c <USBH_Get_CfgDesc+0x288>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   171b0:	2804      	cmp	r0, #4
   171b2:	d001      	beq.n	171b8 <USBH_Get_CfgDesc+0xb4>
   171b4:	2802      	cmp	r0, #2
   171b6:	d1b0      	bne.n	1711a <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
   171b8:	230b      	movs	r3, #11
   171ba:	2001      	movs	r0, #1
   171bc:	762b      	strb	r3, [r5, #24]
   171be:	e7ad      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      phost->Control.timer = (uint16_t)phost->Timer;
   171c0:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   171c4:	7903      	ldrb	r3, [r0, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   171c6:	81c2      	strh	r2, [r0, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   171c8:	6881      	ldr	r1, [r0, #8]
   171ca:	8982      	ldrh	r2, [r0, #12]
   171cc:	f000 fdc0 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   171d0:	2304      	movs	r3, #4
   171d2:	2001      	movs	r0, #1
   171d4:	762b      	strb	r3, [r5, #24]
   171d6:	e7a1      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   171d8:	7901      	ldrb	r1, [r0, #4]
   171da:	f00f fef5 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   171de:	2801      	cmp	r0, #1
   171e0:	d054      	beq.n	1728c <USBH_Get_CfgDesc+0x188>
      if (URB_Status == USBH_URB_STALL)
   171e2:	2805      	cmp	r0, #5
   171e4:	d037      	beq.n	17256 <USBH_Get_CfgDesc+0x152>
        if (URB_Status == USBH_URB_ERROR)
   171e6:	2804      	cmp	r0, #4
   171e8:	d197      	bne.n	1711a <USBH_Get_CfgDesc+0x16>
   171ea:	e7e5      	b.n	171b8 <USBH_Get_CfgDesc+0xb4>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   171ec:	2401      	movs	r4, #1
   171ee:	7943      	ldrb	r3, [r0, #5]
   171f0:	8982      	ldrh	r2, [r0, #12]
   171f2:	6881      	ldr	r1, [r0, #8]
   171f4:	9400      	str	r4, [sp, #0]
   171f6:	f000 fd93 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   171fa:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   171fe:	2306      	movs	r3, #6
   17200:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
   17202:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17204:	762b      	strb	r3, [r5, #24]
   17206:	e789      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17208:	7941      	ldrb	r1, [r0, #5]
   1720a:	f00f fedd 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1720e:	2801      	cmp	r0, #1
   17210:	f000 80b8 	beq.w	17384 <USBH_Get_CfgDesc+0x280>
      else if (URB_Status == USBH_URB_STALL)
   17214:	2805      	cmp	r0, #5
   17216:	d01e      	beq.n	17256 <USBH_Get_CfgDesc+0x152>
      else if (URB_Status == USBH_URB_NOTREADY)
   17218:	2802      	cmp	r0, #2
   1721a:	f000 80be 	beq.w	1739a <USBH_Get_CfgDesc+0x296>
        if (URB_Status == USBH_URB_ERROR)
   1721e:	2804      	cmp	r0, #4
   17220:	f47f af7b 	bne.w	1711a <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
   17224:	230b      	movs	r3, #11
   17226:	762b      	strb	r3, [r5, #24]
   17228:	e7af      	b.n	1718a <USBH_Get_CfgDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   1722a:	2200      	movs	r2, #0
   1722c:	7903      	ldrb	r3, [r0, #4]
   1722e:	4611      	mov	r1, r2
   17230:	f000 fd8e 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17234:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17238:	2308      	movs	r3, #8
   1723a:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   1723c:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   1723e:	762b      	strb	r3, [r5, #24]
   17240:	e76c      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17242:	7901      	ldrb	r1, [r0, #4]
   17244:	f00f fec0 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17248:	2801      	cmp	r0, #1
   1724a:	d023      	beq.n	17294 <USBH_Get_CfgDesc+0x190>
      else if (URB_Status == USBH_URB_ERROR)
   1724c:	2804      	cmp	r0, #4
   1724e:	d0b3      	beq.n	171b8 <USBH_Get_CfgDesc+0xb4>
        if (URB_Status == USBH_URB_STALL)
   17250:	2805      	cmp	r0, #5
   17252:	f47f af62 	bne.w	1711a <USBH_Get_CfgDesc+0x16>
        phost->RequestState = CMD_SEND;
   17256:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   17258:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   1725a:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   1725c:	70aa      	strb	r2, [r5, #2]
        phost->Control.state = CTRL_IDLE;
   1725e:	762b      	strb	r3, [r5, #24]
   17260:	e75c      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   17262:	2200      	movs	r2, #0
   17264:	2401      	movs	r4, #1
   17266:	7943      	ldrb	r3, [r0, #5]
   17268:	4611      	mov	r1, r2
   1726a:	9400      	str	r4, [sp, #0]
   1726c:	f000 fd58 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17270:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17274:	230a      	movs	r3, #10
   17276:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
   17278:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   1727a:	762b      	strb	r3, [r5, #24]
   1727c:	e74e      	b.n	1711c <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1727e:	7941      	ldrb	r1, [r0, #5]
   17280:	f00f fea2 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17284:	2801      	cmp	r0, #1
   17286:	d005      	beq.n	17294 <USBH_Get_CfgDesc+0x190>
      else if (URB_Status == USBH_URB_NOTREADY)
   17288:	2802      	cmp	r0, #2
   1728a:	d1ac      	bne.n	171e6 <USBH_Get_CfgDesc+0xe2>
            phost->Control.state = CTRL_STATUS_OUT;
   1728c:	2309      	movs	r3, #9
   1728e:	2001      	movs	r0, #1
   17290:	762b      	strb	r3, [r5, #24]
   17292:	e743      	b.n	1711c <USBH_Get_CfgDesc+0x18>
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
   17294:	7f2a      	ldrb	r2, [r5, #28]
        phost->RequestState = CMD_SEND;
   17296:	2101      	movs	r1, #1
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
   17298:	7f6b      	ldrb	r3, [r5, #29]
        phost->Control.state = CTRL_IDLE;
   1729a:	2700      	movs	r7, #0
  cfg_desc->wTotalLength        = LE16(buf + 2);
   1729c:	8be8      	ldrh	r0, [r5, #30]
  if (length > USB_CONFIGURATION_DESC_SIZE)
   1729e:	2e09      	cmp	r6, #9
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
   172a0:	f885 2338 	strb.w	r2, [r5, #824]	; 0x338
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
   172a4:	f885 3339 	strb.w	r3, [r5, #825]	; 0x339
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
   172a8:	6a2a      	ldr	r2, [r5, #32]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
   172aa:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
        phost->RequestState = CMD_SEND;
   172ae:	70a9      	strb	r1, [r5, #2]
        phost->Control.state = CTRL_IDLE;
   172b0:	762f      	strb	r7, [r5, #24]
  cfg_desc->wTotalLength        = LE16(buf + 2);
   172b2:	f8a5 033a 	strh.w	r0, [r5, #826]	; 0x33a
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
   172b6:	f8c5 233c 	str.w	r2, [r5, #828]	; 0x33c
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
   172ba:	f885 3340 	strb.w	r3, [r5, #832]	; 0x340
  if (length > USB_CONFIGURATION_DESC_SIZE)
   172be:	d913      	bls.n	172e8 <USBH_Get_CfgDesc+0x1e4>
   172c0:	46ac      	mov	ip, r5
    ptr = USB_LEN_CFG_DESC;
   172c2:	2209      	movs	r2, #9
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   172c4:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
   172c8:	b2fe      	uxtb	r6, r7
   172ca:	2e09      	cmp	r6, #9
   172cc:	bf8c      	ite	hi
   172ce:	2600      	movhi	r6, #0
   172d0:	2601      	movls	r6, #1
   172d2:	e007      	b.n	172e4 <USBH_Get_CfgDesc+0x1e0>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
   172d4:	b146      	cbz	r6, 172e8 <USBH_Get_CfgDesc+0x1e4>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   172d6:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
   172d8:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   172da:	4413      	add	r3, r2
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
   172dc:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   172de:	b29a      	uxth	r2, r3
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
   172e0:	2904      	cmp	r1, #4
   172e2:	d005      	beq.n	172f0 <USBH_Get_CfgDesc+0x1ec>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
   172e4:	4290      	cmp	r0, r2
   172e6:	d8f5      	bhi.n	172d4 <USBH_Get_CfgDesc+0x1d0>
        status = USBH_NOT_SUPPORTED;
   172e8:	2000      	movs	r0, #0
}
   172ea:	b003      	add	sp, #12
   172ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
   172f0:	7823      	ldrb	r3, [r4, #0]
        ep_ix = 0U;
   172f2:	2100      	movs	r1, #0
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   172f4:	fb0e f907 	mul.w	r9, lr, r7
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
   172f8:	f88c 3342 	strb.w	r3, [ip, #834]	; 0x342
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
   172fc:	7863      	ldrb	r3, [r4, #1]
   172fe:	f88c 3343 	strb.w	r3, [ip, #835]	; 0x343
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
   17302:	78a3      	ldrb	r3, [r4, #2]
   17304:	f88c 3344 	strb.w	r3, [ip, #836]	; 0x344
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
   17308:	78e3      	ldrb	r3, [r4, #3]
   1730a:	f88c 3345 	strb.w	r3, [ip, #837]	; 0x345
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
   1730e:	f894 8004 	ldrb.w	r8, [r4, #4]
   17312:	f88c 8346 	strb.w	r8, [ip, #838]	; 0x346
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
   17316:	7963      	ldrb	r3, [r4, #5]
   17318:	f88c 3347 	strb.w	r3, [ip, #839]	; 0x347
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
   1731c:	79a3      	ldrb	r3, [r4, #6]
   1731e:	f88c 3348 	strb.w	r3, [ip, #840]	; 0x348
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
   17322:	79e3      	ldrb	r3, [r4, #7]
   17324:	f88c 3349 	strb.w	r3, [ip, #841]	; 0x349
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
   17328:	7a23      	ldrb	r3, [r4, #8]
   1732a:	f88c 334a 	strb.w	r3, [ip, #842]	; 0x34a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
   1732e:	4290      	cmp	r0, r2
   17330:	d922      	bls.n	17378 <USBH_Get_CfgDesc+0x274>
   17332:	4541      	cmp	r1, r8
   17334:	d220      	bcs.n	17378 <USBH_Get_CfgDesc+0x274>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   17336:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
   17338:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   1733a:	4413      	add	r3, r2
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
   1733c:	7866      	ldrb	r6, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   1733e:	b29a      	uxth	r2, r3
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
   17340:	2e05      	cmp	r6, #5
   17342:	d1f4      	bne.n	1732e <USBH_Get_CfgDesc+0x22a>
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   17344:	3101      	adds	r1, #1
   17346:	7826      	ldrb	r6, [r4, #0]
   17348:	eb09 03c1 	add.w	r3, r9, r1, lsl #3
            ep_ix++;
   1734c:	b2c9      	uxtb	r1, r1
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   1734e:	442b      	add	r3, r5
   17350:	f883 6344 	strb.w	r6, [r3, #836]	; 0x344
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
   17354:	7866      	ldrb	r6, [r4, #1]
   17356:	f883 6345 	strb.w	r6, [r3, #837]	; 0x345
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
   1735a:	78a6      	ldrb	r6, [r4, #2]
   1735c:	f883 6346 	strb.w	r6, [r3, #838]	; 0x346
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
   17360:	78e6      	ldrb	r6, [r4, #3]
   17362:	f883 6347 	strb.w	r6, [r3, #839]	; 0x347
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
   17366:	88a6      	ldrh	r6, [r4, #4]
   17368:	f8a3 6348 	strh.w	r6, [r3, #840]	; 0x348
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
   1736c:	79a6      	ldrb	r6, [r4, #6]
   1736e:	f883 634a 	strb.w	r6, [r3, #842]	; 0x34a
   17372:	f89c 8346 	ldrb.w	r8, [ip, #838]	; 0x346
   17376:	e7da      	b.n	1732e <USBH_Get_CfgDesc+0x22a>
   17378:	3701      	adds	r7, #1
   1737a:	f10c 0c2a 	add.w	ip, ip, #42	; 0x2a
   1737e:	e7a3      	b.n	172c8 <USBH_Get_CfgDesc+0x1c4>
          if (direction == USB_D2H)
   17380:	2b00      	cmp	r3, #0
   17382:	db83      	blt.n	1728c <USBH_Get_CfgDesc+0x188>
            phost->Control.state = CTRL_STATUS_IN;
   17384:	2307      	movs	r3, #7
   17386:	2001      	movs	r0, #1
   17388:	762b      	strb	r3, [r5, #24]
   1738a:	e6c7      	b.n	1711c <USBH_Get_CfgDesc+0x18>
        if (phost->Control.setup.b.wLength.w != 0U)
   1738c:	8aea      	ldrh	r2, [r5, #22]
   1738e:	f995 3010 	ldrsb.w	r3, [r5, #16]
   17392:	2a00      	cmp	r2, #0
   17394:	d0f4      	beq.n	17380 <USBH_Get_CfgDesc+0x27c>
          if (direction == USB_D2H)
   17396:	2b00      	cmp	r3, #0
   17398:	db08      	blt.n	173ac <USBH_Get_CfgDesc+0x2a8>
            phost->Control.state = CTRL_DATA_OUT;
   1739a:	2305      	movs	r3, #5
   1739c:	2001      	movs	r0, #1
   1739e:	762b      	strb	r3, [r5, #24]
   173a0:	e6bc      	b.n	1711c <USBH_Get_CfgDesc+0x18>
        phost->Control.state = CTRL_SETUP;
   173a2:	2301      	movs	r3, #1
   173a4:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
   173a6:	4618      	mov	r0, r3
   173a8:	70ab      	strb	r3, [r5, #2]
   173aa:	e6b7      	b.n	1711c <USBH_Get_CfgDesc+0x18>
            phost->Control.state = CTRL_DATA_IN;
   173ac:	2303      	movs	r3, #3
   173ae:	762b      	strb	r3, [r5, #24]
   173b0:	e6b4      	b.n	1711c <USBH_Get_CfgDesc+0x18>
   173b2:	bf00      	nop

000173b4 <USBH_Get_StringDesc>:
{
   173b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (phost->RequestState == CMD_SEND)
   173b6:	7885      	ldrb	r5, [r0, #2]
{
   173b8:	b085      	sub	sp, #20
   173ba:	4604      	mov	r4, r0
                                   phost->device.Data, length)) == USBH_OK)
   173bc:	f500 768e 	add.w	r6, r0, #284	; 0x11c
  if (phost->RequestState == CMD_SEND)
   173c0:	2d01      	cmp	r5, #1
   173c2:	d010      	beq.n	173e6 <USBH_Get_StringDesc+0x32>
  switch (phost->RequestState)
   173c4:	2d02      	cmp	r5, #2
   173c6:	d002      	beq.n	173ce <USBH_Get_StringDesc+0x1a>
  status = USBH_BUSY;
   173c8:	2001      	movs	r0, #1
}
   173ca:	b005      	add	sp, #20
   173cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (phost->Control.state)
   173ce:	7e01      	ldrb	r1, [r0, #24]
   173d0:	3901      	subs	r1, #1
   173d2:	290a      	cmp	r1, #10
   173d4:	d8f8      	bhi.n	173c8 <USBH_Get_StringDesc+0x14>
   173d6:	e8df f001 	tbb	[pc, r1]
   173da:	3e34      	.short	0x3e34
   173dc:	74655a4d 	.word	0x74655a4d
   173e0:	b5a69184 	.word	0xb5a69184
   173e4:	19          	.byte	0x19
   173e5:	00          	.byte	0x00
  if ((status = USBH_GetDescriptor(phost,
   173e6:	f441 7140 	orr.w	r1, r1, #768	; 0x300
    phost->Control.setup.b.wLength.w = length;
   173ea:	82c3      	strh	r3, [r0, #22]
      phost->Control.buff = buff;
   173ec:	6086      	str	r6, [r0, #8]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   173ee:	f44f 6cd0 	mov.w	ip, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
   173f2:	8241      	strh	r1, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
   173f4:	f240 4709 	movw	r7, #1033	; 0x409
      phost->Control.length = length;
   173f8:	8183      	strh	r3, [r0, #12]
      phost->RequestState = CMD_WAIT;
   173fa:	2202      	movs	r2, #2
      status = USBH_BUSY;
   173fc:	4628      	mov	r0, r5
      phost->Control.state = CTRL_SETUP;
   173fe:	7625      	strb	r5, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   17400:	f8a4 c010 	strh.w	ip, [r4, #16]
      phost->Control.setup.b.wIndex.w = 0x0409U;
   17404:	82a7      	strh	r7, [r4, #20]
      phost->RequestState = CMD_WAIT;
   17406:	70a2      	strb	r2, [r4, #2]
}
   17408:	b005      	add	sp, #20
   1740a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   1740c:	7e63      	ldrb	r3, [r4, #25]
   1740e:	3301      	adds	r3, #1
   17410:	b2db      	uxtb	r3, r3
   17412:	2b02      	cmp	r3, #2
   17414:	7663      	strb	r3, [r4, #25]
   17416:	f240 80d3 	bls.w	175c0 <USBH_Get_StringDesc+0x20c>
        phost->Control.errorcount = 0U;
   1741a:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   1741c:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   17420:	2106      	movs	r1, #6
   17422:	4620      	mov	r0, r4
   17424:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17426:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   17428:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   1742a:	4620      	mov	r0, r4
   1742c:	f000 fd14 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   17430:	7921      	ldrb	r1, [r4, #4]
   17432:	4620      	mov	r0, r4
   17434:	f000 fd10 	bl	17e58 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   17438:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   1743a:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   1743c:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   1743e:	70a3      	strb	r3, [r4, #2]
   17440:	e7c3      	b.n	173ca <USBH_Get_StringDesc+0x16>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   17442:	7962      	ldrb	r2, [r4, #5]
   17444:	f104 0110 	add.w	r1, r4, #16
   17448:	4620      	mov	r0, r4
   1744a:	f000 fc59 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   1744e:	2302      	movs	r3, #2
   17450:	2001      	movs	r0, #1
   17452:	7623      	strb	r3, [r4, #24]
   17454:	e7b9      	b.n	173ca <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17456:	7961      	ldrb	r1, [r4, #5]
   17458:	4620      	mov	r0, r4
   1745a:	f00f fdb5 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1745e:	2801      	cmp	r0, #1
   17460:	f000 80a3 	beq.w	175aa <USBH_Get_StringDesc+0x1f6>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   17464:	2804      	cmp	r0, #4
   17466:	d001      	beq.n	1746c <USBH_Get_StringDesc+0xb8>
   17468:	2802      	cmp	r0, #2
   1746a:	d1ad      	bne.n	173c8 <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
   1746c:	230b      	movs	r3, #11
   1746e:	2001      	movs	r0, #1
   17470:	7623      	strb	r3, [r4, #24]
   17472:	e7aa      	b.n	173ca <USBH_Get_StringDesc+0x16>
      phost->Control.timer = (uint16_t)phost->Timer;
   17474:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17478:	4620      	mov	r0, r4
   1747a:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   1747c:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   1747e:	68a1      	ldr	r1, [r4, #8]
   17480:	89a2      	ldrh	r2, [r4, #12]
   17482:	f000 fc65 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   17486:	2304      	movs	r3, #4
   17488:	2001      	movs	r0, #1
   1748a:	7623      	strb	r3, [r4, #24]
   1748c:	e79d      	b.n	173ca <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1748e:	7921      	ldrb	r1, [r4, #4]
   17490:	4620      	mov	r0, r4
   17492:	f00f fd99 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17496:	2801      	cmp	r0, #1
   17498:	d060      	beq.n	1755c <USBH_Get_StringDesc+0x1a8>
      if (URB_Status == USBH_URB_STALL)
   1749a:	2805      	cmp	r0, #5
   1749c:	d03d      	beq.n	1751a <USBH_Get_StringDesc+0x166>
        if (URB_Status == USBH_URB_ERROR)
   1749e:	2804      	cmp	r0, #4
   174a0:	d192      	bne.n	173c8 <USBH_Get_StringDesc+0x14>
   174a2:	e7e3      	b.n	1746c <USBH_Get_StringDesc+0xb8>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   174a4:	2501      	movs	r5, #1
   174a6:	7963      	ldrb	r3, [r4, #5]
   174a8:	89a2      	ldrh	r2, [r4, #12]
   174aa:	4620      	mov	r0, r4
   174ac:	68a1      	ldr	r1, [r4, #8]
   174ae:	9500      	str	r5, [sp, #0]
   174b0:	f000 fc36 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   174b4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   174b8:	2306      	movs	r3, #6
   174ba:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   174bc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   174be:	7623      	strb	r3, [r4, #24]
   174c0:	e783      	b.n	173ca <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   174c2:	7961      	ldrb	r1, [r4, #5]
   174c4:	4620      	mov	r0, r4
   174c6:	f00f fd7f 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   174ca:	2801      	cmp	r0, #1
   174cc:	d069      	beq.n	175a2 <USBH_Get_StringDesc+0x1ee>
      else if (URB_Status == USBH_URB_STALL)
   174ce:	2805      	cmp	r0, #5
   174d0:	d023      	beq.n	1751a <USBH_Get_StringDesc+0x166>
      else if (URB_Status == USBH_URB_NOTREADY)
   174d2:	2802      	cmp	r0, #2
   174d4:	d070      	beq.n	175b8 <USBH_Get_StringDesc+0x204>
        if (URB_Status == USBH_URB_ERROR)
   174d6:	2804      	cmp	r0, #4
   174d8:	f47f af76 	bne.w	173c8 <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
   174dc:	230b      	movs	r3, #11
   174de:	7623      	strb	r3, [r4, #24]
   174e0:	e7ab      	b.n	1743a <USBH_Get_StringDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   174e2:	2200      	movs	r2, #0
   174e4:	7923      	ldrb	r3, [r4, #4]
   174e6:	4620      	mov	r0, r4
   174e8:	4611      	mov	r1, r2
   174ea:	f000 fc31 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   174ee:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   174f2:	2308      	movs	r3, #8
   174f4:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   174f6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   174f8:	7623      	strb	r3, [r4, #24]
   174fa:	e766      	b.n	173ca <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   174fc:	7921      	ldrb	r1, [r4, #4]
   174fe:	4620      	mov	r0, r4
   17500:	e9cd 2302 	strd	r2, r3, [sp, #8]
   17504:	f00f fd60 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17508:	2801      	cmp	r0, #1
   1750a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1750e:	d029      	beq.n	17564 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_ERROR)
   17510:	2804      	cmp	r0, #4
   17512:	d0ab      	beq.n	1746c <USBH_Get_StringDesc+0xb8>
        if (URB_Status == USBH_URB_STALL)
   17514:	2805      	cmp	r0, #5
   17516:	f47f af57 	bne.w	173c8 <USBH_Get_StringDesc+0x14>
        phost->RequestState = CMD_SEND;
   1751a:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   1751c:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   1751e:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   17520:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   17522:	7623      	strb	r3, [r4, #24]
   17524:	e751      	b.n	173ca <USBH_Get_StringDesc+0x16>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   17526:	2200      	movs	r2, #0
   17528:	2501      	movs	r5, #1
   1752a:	7963      	ldrb	r3, [r4, #5]
   1752c:	4620      	mov	r0, r4
   1752e:	4611      	mov	r1, r2
   17530:	9500      	str	r5, [sp, #0]
   17532:	f000 fbf5 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17536:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   1753a:	230a      	movs	r3, #10
   1753c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   1753e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17540:	7623      	strb	r3, [r4, #24]
   17542:	e742      	b.n	173ca <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17544:	7961      	ldrb	r1, [r4, #5]
   17546:	4620      	mov	r0, r4
   17548:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1754c:	f00f fd3c 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17550:	2801      	cmp	r0, #1
   17552:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   17556:	d005      	beq.n	17564 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_NOTREADY)
   17558:	2802      	cmp	r0, #2
   1755a:	d1a0      	bne.n	1749e <USBH_Get_StringDesc+0xea>
            phost->Control.state = CTRL_STATUS_OUT;
   1755c:	2309      	movs	r3, #9
   1755e:	2001      	movs	r0, #1
   17560:	7623      	strb	r3, [r4, #24]
   17562:	e732      	b.n	173ca <USBH_Get_StringDesc+0x16>
  if (psrc[1] == USB_DESC_TYPE_STRING)
   17564:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
   17568:	2501      	movs	r5, #1
        phost->Control.state = CTRL_IDLE;
   1756a:	2000      	movs	r0, #0
  if (psrc[1] == USB_DESC_TYPE_STRING)
   1756c:	2903      	cmp	r1, #3
        phost->RequestState = CMD_SEND;
   1756e:	70a5      	strb	r5, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   17570:	7620      	strb	r0, [r4, #24]
  if (psrc[1] == USB_DESC_TYPE_STRING)
   17572:	f47f af2a 	bne.w	173ca <USBH_Get_StringDesc+0x16>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
   17576:	f894 111c 	ldrb.w	r1, [r4, #284]	; 0x11c
   1757a:	3902      	subs	r1, #2
   1757c:	428b      	cmp	r3, r1
   1757e:	bf28      	it	cs
   17580:	460b      	movcs	r3, r1
   17582:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
   17584:	b13b      	cbz	r3, 17596 <USBH_Get_StringDesc+0x1e2>
      *pdest =  psrc[idx];
   17586:	1833      	adds	r3, r6, r0
    for (idx = 0U; idx < strlength; idx += 2U)
   17588:	3002      	adds	r0, #2
   1758a:	b280      	uxth	r0, r0
      *pdest =  psrc[idx];
   1758c:	789b      	ldrb	r3, [r3, #2]
    for (idx = 0U; idx < strlength; idx += 2U)
   1758e:	4281      	cmp	r1, r0
      *pdest =  psrc[idx];
   17590:	f802 3b01 	strb.w	r3, [r2], #1
    for (idx = 0U; idx < strlength; idx += 2U)
   17594:	d8f7      	bhi.n	17586 <USBH_Get_StringDesc+0x1d2>
    *pdest = 0U; /* mark end of string */
   17596:	2000      	movs	r0, #0
   17598:	7010      	strb	r0, [r2, #0]
}
   1759a:	b005      	add	sp, #20
   1759c:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (direction == USB_D2H)
   1759e:	2a00      	cmp	r2, #0
   175a0:	dbdc      	blt.n	1755c <USBH_Get_StringDesc+0x1a8>
            phost->Control.state = CTRL_STATUS_IN;
   175a2:	2307      	movs	r3, #7
   175a4:	2001      	movs	r0, #1
   175a6:	7623      	strb	r3, [r4, #24]
   175a8:	e70f      	b.n	173ca <USBH_Get_StringDesc+0x16>
        if (phost->Control.setup.b.wLength.w != 0U)
   175aa:	8ae3      	ldrh	r3, [r4, #22]
   175ac:	f994 2010 	ldrsb.w	r2, [r4, #16]
   175b0:	2b00      	cmp	r3, #0
   175b2:	d0f4      	beq.n	1759e <USBH_Get_StringDesc+0x1ea>
          if (direction == USB_D2H)
   175b4:	2a00      	cmp	r2, #0
   175b6:	db08      	blt.n	175ca <USBH_Get_StringDesc+0x216>
            phost->Control.state = CTRL_DATA_OUT;
   175b8:	2305      	movs	r3, #5
   175ba:	2001      	movs	r0, #1
   175bc:	7623      	strb	r3, [r4, #24]
   175be:	e704      	b.n	173ca <USBH_Get_StringDesc+0x16>
        phost->Control.state = CTRL_SETUP;
   175c0:	2301      	movs	r3, #1
   175c2:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   175c4:	4618      	mov	r0, r3
   175c6:	70a3      	strb	r3, [r4, #2]
   175c8:	e6ff      	b.n	173ca <USBH_Get_StringDesc+0x16>
            phost->Control.state = CTRL_DATA_IN;
   175ca:	2303      	movs	r3, #3
   175cc:	7623      	strb	r3, [r4, #24]
   175ce:	e6fc      	b.n	173ca <USBH_Get_StringDesc+0x16>

000175d0 <USBH_SetAddress>:
{
   175d0:	b530      	push	{r4, r5, lr}
   175d2:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   175d4:	7880      	ldrb	r0, [r0, #2]
{
   175d6:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   175d8:	2801      	cmp	r0, #1
   175da:	d011      	beq.n	17600 <USBH_SetAddress+0x30>
  switch (phost->RequestState)
   175dc:	2802      	cmp	r0, #2
   175de:	d002      	beq.n	175e6 <USBH_SetAddress+0x16>
  status = USBH_BUSY;
   175e0:	2001      	movs	r0, #1
}
   175e2:	b003      	add	sp, #12
   175e4:	bd30      	pop	{r4, r5, pc}
   175e6:	461c      	mov	r4, r3
  switch (phost->Control.state)
   175e8:	7e1b      	ldrb	r3, [r3, #24]
   175ea:	3b01      	subs	r3, #1
   175ec:	2b0a      	cmp	r3, #10
   175ee:	d8f7      	bhi.n	175e0 <USBH_SetAddress+0x10>
   175f0:	e8df f003 	tbb	[pc, r3]
   175f4:	5447382e 	.word	0x5447382e
   175f8:	8b7e6e5f 	.word	0x8b7e6e5f
   175fc:	ac9d      	.short	0xac9d
   175fe:	13          	.byte	0x13
   175ff:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   17600:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
   17602:	f44f 65a0 	mov.w	r5, #1280	; 0x500
      phost->RequestState = CMD_WAIT;
   17606:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
   17608:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   1760a:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
   1760c:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   1760e:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   17610:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   17612:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   17614:	709c      	strb	r4, [r3, #2]
}
   17616:	b003      	add	sp, #12
   17618:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   1761a:	7e63      	ldrb	r3, [r4, #25]
   1761c:	3301      	adds	r3, #1
   1761e:	b2db      	uxtb	r3, r3
   17620:	2b02      	cmp	r3, #2
   17622:	7663      	strb	r3, [r4, #25]
   17624:	f240 80b1 	bls.w	1778a <USBH_SetAddress+0x1ba>
        phost->Control.errorcount = 0U;
   17628:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   1762a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   1762e:	2106      	movs	r1, #6
   17630:	4620      	mov	r0, r4
   17632:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17634:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   17636:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17638:	4620      	mov	r0, r4
   1763a:	f000 fc0d 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   1763e:	7921      	ldrb	r1, [r4, #4]
   17640:	4620      	mov	r0, r4
   17642:	f000 fc09 	bl	17e58 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   17646:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   17648:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   1764a:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   1764c:	70a3      	strb	r3, [r4, #2]
   1764e:	e7c8      	b.n	175e2 <USBH_SetAddress+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   17650:	7962      	ldrb	r2, [r4, #5]
   17652:	f104 0110 	add.w	r1, r4, #16
   17656:	4620      	mov	r0, r4
   17658:	f000 fb52 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   1765c:	2302      	movs	r3, #2
   1765e:	2001      	movs	r0, #1
   17660:	7623      	strb	r3, [r4, #24]
   17662:	e7be      	b.n	175e2 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17664:	7961      	ldrb	r1, [r4, #5]
   17666:	4620      	mov	r0, r4
   17668:	f00f fcae 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1766c:	2801      	cmp	r0, #1
   1766e:	f000 8081 	beq.w	17774 <USBH_SetAddress+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   17672:	2804      	cmp	r0, #4
   17674:	d001      	beq.n	1767a <USBH_SetAddress+0xaa>
   17676:	2802      	cmp	r0, #2
   17678:	d1b2      	bne.n	175e0 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
   1767a:	230b      	movs	r3, #11
   1767c:	2001      	movs	r0, #1
   1767e:	7623      	strb	r3, [r4, #24]
   17680:	e7af      	b.n	175e2 <USBH_SetAddress+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   17682:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17686:	4620      	mov	r0, r4
   17688:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   1768a:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   1768c:	68a1      	ldr	r1, [r4, #8]
   1768e:	89a2      	ldrh	r2, [r4, #12]
   17690:	f000 fb5e 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   17694:	2304      	movs	r3, #4
   17696:	2001      	movs	r0, #1
   17698:	7623      	strb	r3, [r4, #24]
   1769a:	e7a2      	b.n	175e2 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1769c:	7921      	ldrb	r1, [r4, #4]
   1769e:	4620      	mov	r0, r4
   176a0:	f00f fc92 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   176a4:	2801      	cmp	r0, #1
   176a6:	d059      	beq.n	1775c <USBH_SetAddress+0x18c>
      if (URB_Status == USBH_URB_STALL)
   176a8:	2805      	cmp	r0, #5
   176aa:	d039      	beq.n	17720 <USBH_SetAddress+0x150>
        if (URB_Status == USBH_URB_ERROR)
   176ac:	2804      	cmp	r0, #4
   176ae:	d197      	bne.n	175e0 <USBH_SetAddress+0x10>
   176b0:	e7e3      	b.n	1767a <USBH_SetAddress+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   176b2:	2501      	movs	r5, #1
   176b4:	7963      	ldrb	r3, [r4, #5]
   176b6:	89a2      	ldrh	r2, [r4, #12]
   176b8:	4620      	mov	r0, r4
   176ba:	68a1      	ldr	r1, [r4, #8]
   176bc:	9500      	str	r5, [sp, #0]
   176be:	f000 fb2f 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   176c2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   176c6:	2306      	movs	r3, #6
   176c8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   176ca:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   176cc:	7623      	strb	r3, [r4, #24]
   176ce:	e788      	b.n	175e2 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   176d0:	7961      	ldrb	r1, [r4, #5]
   176d2:	4620      	mov	r0, r4
   176d4:	f00f fc78 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   176d8:	2801      	cmp	r0, #1
   176da:	d047      	beq.n	1776c <USBH_SetAddress+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   176dc:	2805      	cmp	r0, #5
   176de:	d01f      	beq.n	17720 <USBH_SetAddress+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   176e0:	2802      	cmp	r0, #2
   176e2:	d04e      	beq.n	17782 <USBH_SetAddress+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   176e4:	2804      	cmp	r0, #4
   176e6:	f47f af7b 	bne.w	175e0 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
   176ea:	230b      	movs	r3, #11
   176ec:	7623      	strb	r3, [r4, #24]
   176ee:	e7ab      	b.n	17648 <USBH_SetAddress+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   176f0:	2200      	movs	r2, #0
   176f2:	7923      	ldrb	r3, [r4, #4]
   176f4:	4620      	mov	r0, r4
   176f6:	4611      	mov	r1, r2
   176f8:	f000 fb2a 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   176fc:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17700:	2308      	movs	r3, #8
   17702:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   17704:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17706:	7623      	strb	r3, [r4, #24]
   17708:	e76b      	b.n	175e2 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1770a:	7921      	ldrb	r1, [r4, #4]
   1770c:	4620      	mov	r0, r4
   1770e:	f00f fc5b 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17712:	2801      	cmp	r0, #1
   17714:	d026      	beq.n	17764 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   17716:	2804      	cmp	r0, #4
   17718:	d0af      	beq.n	1767a <USBH_SetAddress+0xaa>
        if (URB_Status == USBH_URB_STALL)
   1771a:	2805      	cmp	r0, #5
   1771c:	f47f af60 	bne.w	175e0 <USBH_SetAddress+0x10>
        status = USBH_NOT_SUPPORTED;
   17720:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   17722:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   17724:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   17726:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   17728:	7623      	strb	r3, [r4, #24]
}
   1772a:	b003      	add	sp, #12
   1772c:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1772e:	2200      	movs	r2, #0
   17730:	2501      	movs	r5, #1
   17732:	7963      	ldrb	r3, [r4, #5]
   17734:	4620      	mov	r0, r4
   17736:	4611      	mov	r1, r2
   17738:	9500      	str	r5, [sp, #0]
   1773a:	f000 faf1 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1773e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17742:	230a      	movs	r3, #10
   17744:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17746:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17748:	7623      	strb	r3, [r4, #24]
   1774a:	e74a      	b.n	175e2 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1774c:	7961      	ldrb	r1, [r4, #5]
   1774e:	4620      	mov	r0, r4
   17750:	f00f fc3a 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17754:	2801      	cmp	r0, #1
   17756:	d005      	beq.n	17764 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   17758:	2802      	cmp	r0, #2
   1775a:	d1a7      	bne.n	176ac <USBH_SetAddress+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   1775c:	2309      	movs	r3, #9
   1775e:	2001      	movs	r0, #1
   17760:	7623      	strb	r3, [r4, #24]
   17762:	e73e      	b.n	175e2 <USBH_SetAddress+0x12>
        status = USBH_OK;
   17764:	2000      	movs	r0, #0
   17766:	e7dc      	b.n	17722 <USBH_SetAddress+0x152>
          if (direction == USB_D2H)
   17768:	2a00      	cmp	r2, #0
   1776a:	dbf7      	blt.n	1775c <USBH_SetAddress+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   1776c:	2307      	movs	r3, #7
   1776e:	2001      	movs	r0, #1
   17770:	7623      	strb	r3, [r4, #24]
   17772:	e736      	b.n	175e2 <USBH_SetAddress+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   17774:	8ae3      	ldrh	r3, [r4, #22]
   17776:	f994 2010 	ldrsb.w	r2, [r4, #16]
   1777a:	2b00      	cmp	r3, #0
   1777c:	d0f4      	beq.n	17768 <USBH_SetAddress+0x198>
          if (direction == USB_D2H)
   1777e:	2a00      	cmp	r2, #0
   17780:	db08      	blt.n	17794 <USBH_SetAddress+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   17782:	2305      	movs	r3, #5
   17784:	2001      	movs	r0, #1
   17786:	7623      	strb	r3, [r4, #24]
   17788:	e72b      	b.n	175e2 <USBH_SetAddress+0x12>
        phost->Control.state = CTRL_SETUP;
   1778a:	2301      	movs	r3, #1
   1778c:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   1778e:	4618      	mov	r0, r3
   17790:	70a3      	strb	r3, [r4, #2]
   17792:	e726      	b.n	175e2 <USBH_SetAddress+0x12>
            phost->Control.state = CTRL_DATA_IN;
   17794:	2303      	movs	r3, #3
   17796:	7623      	strb	r3, [r4, #24]
   17798:	e723      	b.n	175e2 <USBH_SetAddress+0x12>
   1779a:	bf00      	nop

0001779c <USBH_SetCfg>:
{
   1779c:	b530      	push	{r4, r5, lr}
   1779e:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   177a0:	7880      	ldrb	r0, [r0, #2]
{
   177a2:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   177a4:	2801      	cmp	r0, #1
   177a6:	d011      	beq.n	177cc <USBH_SetCfg+0x30>
  switch (phost->RequestState)
   177a8:	2802      	cmp	r0, #2
   177aa:	d002      	beq.n	177b2 <USBH_SetCfg+0x16>
  status = USBH_BUSY;
   177ac:	2001      	movs	r0, #1
}
   177ae:	b003      	add	sp, #12
   177b0:	bd30      	pop	{r4, r5, pc}
   177b2:	461c      	mov	r4, r3
  switch (phost->Control.state)
   177b4:	7e1b      	ldrb	r3, [r3, #24]
   177b6:	3b01      	subs	r3, #1
   177b8:	2b0a      	cmp	r3, #10
   177ba:	d8f7      	bhi.n	177ac <USBH_SetCfg+0x10>
   177bc:	e8df f003 	tbb	[pc, r3]
   177c0:	5447382e 	.word	0x5447382e
   177c4:	8b7e6e5f 	.word	0x8b7e6e5f
   177c8:	ac9d      	.short	0xac9d
   177ca:	13          	.byte	0x13
   177cb:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   177cc:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   177ce:	f44f 6510 	mov.w	r5, #2304	; 0x900
      phost->RequestState = CMD_WAIT;
   177d2:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = cfg_idx;
   177d4:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   177d6:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   177d8:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   177da:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   177dc:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   177de:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   177e0:	709c      	strb	r4, [r3, #2]
}
   177e2:	b003      	add	sp, #12
   177e4:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   177e6:	7e63      	ldrb	r3, [r4, #25]
   177e8:	3301      	adds	r3, #1
   177ea:	b2db      	uxtb	r3, r3
   177ec:	2b02      	cmp	r3, #2
   177ee:	7663      	strb	r3, [r4, #25]
   177f0:	f240 80b1 	bls.w	17956 <USBH_SetCfg+0x1ba>
        phost->Control.errorcount = 0U;
   177f4:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   177f6:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   177fa:	2106      	movs	r1, #6
   177fc:	4620      	mov	r0, r4
   177fe:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17800:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   17802:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17804:	4620      	mov	r0, r4
   17806:	f000 fb27 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   1780a:	7921      	ldrb	r1, [r4, #4]
   1780c:	4620      	mov	r0, r4
   1780e:	f000 fb23 	bl	17e58 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   17812:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   17814:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   17816:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   17818:	70a3      	strb	r3, [r4, #2]
   1781a:	e7c8      	b.n	177ae <USBH_SetCfg+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   1781c:	7962      	ldrb	r2, [r4, #5]
   1781e:	f104 0110 	add.w	r1, r4, #16
   17822:	4620      	mov	r0, r4
   17824:	f000 fa6c 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   17828:	2302      	movs	r3, #2
   1782a:	2001      	movs	r0, #1
   1782c:	7623      	strb	r3, [r4, #24]
   1782e:	e7be      	b.n	177ae <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17830:	7961      	ldrb	r1, [r4, #5]
   17832:	4620      	mov	r0, r4
   17834:	f00f fbc8 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17838:	2801      	cmp	r0, #1
   1783a:	f000 8081 	beq.w	17940 <USBH_SetCfg+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   1783e:	2804      	cmp	r0, #4
   17840:	d001      	beq.n	17846 <USBH_SetCfg+0xaa>
   17842:	2802      	cmp	r0, #2
   17844:	d1b2      	bne.n	177ac <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
   17846:	230b      	movs	r3, #11
   17848:	2001      	movs	r0, #1
   1784a:	7623      	strb	r3, [r4, #24]
   1784c:	e7af      	b.n	177ae <USBH_SetCfg+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   1784e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17852:	4620      	mov	r0, r4
   17854:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   17856:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17858:	68a1      	ldr	r1, [r4, #8]
   1785a:	89a2      	ldrh	r2, [r4, #12]
   1785c:	f000 fa78 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   17860:	2304      	movs	r3, #4
   17862:	2001      	movs	r0, #1
   17864:	7623      	strb	r3, [r4, #24]
   17866:	e7a2      	b.n	177ae <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17868:	7921      	ldrb	r1, [r4, #4]
   1786a:	4620      	mov	r0, r4
   1786c:	f00f fbac 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17870:	2801      	cmp	r0, #1
   17872:	d059      	beq.n	17928 <USBH_SetCfg+0x18c>
      if (URB_Status == USBH_URB_STALL)
   17874:	2805      	cmp	r0, #5
   17876:	d039      	beq.n	178ec <USBH_SetCfg+0x150>
        if (URB_Status == USBH_URB_ERROR)
   17878:	2804      	cmp	r0, #4
   1787a:	d197      	bne.n	177ac <USBH_SetCfg+0x10>
   1787c:	e7e3      	b.n	17846 <USBH_SetCfg+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1787e:	2501      	movs	r5, #1
   17880:	7963      	ldrb	r3, [r4, #5]
   17882:	89a2      	ldrh	r2, [r4, #12]
   17884:	4620      	mov	r0, r4
   17886:	68a1      	ldr	r1, [r4, #8]
   17888:	9500      	str	r5, [sp, #0]
   1788a:	f000 fa49 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1788e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17892:	2306      	movs	r3, #6
   17894:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17896:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17898:	7623      	strb	r3, [r4, #24]
   1789a:	e788      	b.n	177ae <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1789c:	7961      	ldrb	r1, [r4, #5]
   1789e:	4620      	mov	r0, r4
   178a0:	f00f fb92 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   178a4:	2801      	cmp	r0, #1
   178a6:	d047      	beq.n	17938 <USBH_SetCfg+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   178a8:	2805      	cmp	r0, #5
   178aa:	d01f      	beq.n	178ec <USBH_SetCfg+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   178ac:	2802      	cmp	r0, #2
   178ae:	d04e      	beq.n	1794e <USBH_SetCfg+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   178b0:	2804      	cmp	r0, #4
   178b2:	f47f af7b 	bne.w	177ac <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
   178b6:	230b      	movs	r3, #11
   178b8:	7623      	strb	r3, [r4, #24]
   178ba:	e7ab      	b.n	17814 <USBH_SetCfg+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   178bc:	2200      	movs	r2, #0
   178be:	7923      	ldrb	r3, [r4, #4]
   178c0:	4620      	mov	r0, r4
   178c2:	4611      	mov	r1, r2
   178c4:	f000 fa44 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   178c8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   178cc:	2308      	movs	r3, #8
   178ce:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   178d0:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   178d2:	7623      	strb	r3, [r4, #24]
   178d4:	e76b      	b.n	177ae <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   178d6:	7921      	ldrb	r1, [r4, #4]
   178d8:	4620      	mov	r0, r4
   178da:	f00f fb75 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   178de:	2801      	cmp	r0, #1
   178e0:	d026      	beq.n	17930 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   178e2:	2804      	cmp	r0, #4
   178e4:	d0af      	beq.n	17846 <USBH_SetCfg+0xaa>
        if (URB_Status == USBH_URB_STALL)
   178e6:	2805      	cmp	r0, #5
   178e8:	f47f af60 	bne.w	177ac <USBH_SetCfg+0x10>
        status = USBH_NOT_SUPPORTED;
   178ec:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   178ee:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   178f0:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   178f2:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   178f4:	7623      	strb	r3, [r4, #24]
}
   178f6:	b003      	add	sp, #12
   178f8:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   178fa:	2200      	movs	r2, #0
   178fc:	2501      	movs	r5, #1
   178fe:	7963      	ldrb	r3, [r4, #5]
   17900:	4620      	mov	r0, r4
   17902:	4611      	mov	r1, r2
   17904:	9500      	str	r5, [sp, #0]
   17906:	f000 fa0b 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1790a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   1790e:	230a      	movs	r3, #10
   17910:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17912:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17914:	7623      	strb	r3, [r4, #24]
   17916:	e74a      	b.n	177ae <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17918:	7961      	ldrb	r1, [r4, #5]
   1791a:	4620      	mov	r0, r4
   1791c:	f00f fb54 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17920:	2801      	cmp	r0, #1
   17922:	d005      	beq.n	17930 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   17924:	2802      	cmp	r0, #2
   17926:	d1a7      	bne.n	17878 <USBH_SetCfg+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   17928:	2309      	movs	r3, #9
   1792a:	2001      	movs	r0, #1
   1792c:	7623      	strb	r3, [r4, #24]
   1792e:	e73e      	b.n	177ae <USBH_SetCfg+0x12>
        status = USBH_OK;
   17930:	2000      	movs	r0, #0
   17932:	e7dc      	b.n	178ee <USBH_SetCfg+0x152>
          if (direction == USB_D2H)
   17934:	2a00      	cmp	r2, #0
   17936:	dbf7      	blt.n	17928 <USBH_SetCfg+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   17938:	2307      	movs	r3, #7
   1793a:	2001      	movs	r0, #1
   1793c:	7623      	strb	r3, [r4, #24]
   1793e:	e736      	b.n	177ae <USBH_SetCfg+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   17940:	8ae3      	ldrh	r3, [r4, #22]
   17942:	f994 2010 	ldrsb.w	r2, [r4, #16]
   17946:	2b00      	cmp	r3, #0
   17948:	d0f4      	beq.n	17934 <USBH_SetCfg+0x198>
          if (direction == USB_D2H)
   1794a:	2a00      	cmp	r2, #0
   1794c:	db08      	blt.n	17960 <USBH_SetCfg+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   1794e:	2305      	movs	r3, #5
   17950:	2001      	movs	r0, #1
   17952:	7623      	strb	r3, [r4, #24]
   17954:	e72b      	b.n	177ae <USBH_SetCfg+0x12>
        phost->Control.state = CTRL_SETUP;
   17956:	2301      	movs	r3, #1
   17958:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   1795a:	4618      	mov	r0, r3
   1795c:	70a3      	strb	r3, [r4, #2]
   1795e:	e726      	b.n	177ae <USBH_SetCfg+0x12>
            phost->Control.state = CTRL_DATA_IN;
   17960:	2303      	movs	r3, #3
   17962:	7623      	strb	r3, [r4, #24]
   17964:	e723      	b.n	177ae <USBH_SetCfg+0x12>
   17966:	bf00      	nop

00017968 <USBH_SetFeature>:
{
   17968:	b530      	push	{r4, r5, lr}
   1796a:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   1796c:	7880      	ldrb	r0, [r0, #2]
{
   1796e:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   17970:	2801      	cmp	r0, #1
   17972:	d011      	beq.n	17998 <USBH_SetFeature+0x30>
  switch (phost->RequestState)
   17974:	2802      	cmp	r0, #2
   17976:	d002      	beq.n	1797e <USBH_SetFeature+0x16>
  status = USBH_BUSY;
   17978:	2001      	movs	r0, #1
}
   1797a:	b003      	add	sp, #12
   1797c:	bd30      	pop	{r4, r5, pc}
   1797e:	461c      	mov	r4, r3
  switch (phost->Control.state)
   17980:	7e1b      	ldrb	r3, [r3, #24]
   17982:	3b01      	subs	r3, #1
   17984:	2b0a      	cmp	r3, #10
   17986:	d8f7      	bhi.n	17978 <USBH_SetFeature+0x10>
   17988:	e8df f003 	tbb	[pc, r3]
   1798c:	5447382e 	.word	0x5447382e
   17990:	8b7e6e5f 	.word	0x8b7e6e5f
   17994:	ac9d      	.short	0xac9d
   17996:	13          	.byte	0x13
   17997:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   17998:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   1799a:	f44f 7540 	mov.w	r5, #768	; 0x300
      phost->RequestState = CMD_WAIT;
   1799e:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = wValue;
   179a0:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   179a2:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   179a4:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   179a6:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   179a8:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   179aa:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   179ac:	709c      	strb	r4, [r3, #2]
}
   179ae:	b003      	add	sp, #12
   179b0:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   179b2:	7e63      	ldrb	r3, [r4, #25]
   179b4:	3301      	adds	r3, #1
   179b6:	b2db      	uxtb	r3, r3
   179b8:	2b02      	cmp	r3, #2
   179ba:	7663      	strb	r3, [r4, #25]
   179bc:	f240 80b1 	bls.w	17b22 <USBH_SetFeature+0x1ba>
        phost->Control.errorcount = 0U;
   179c0:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   179c2:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   179c6:	2106      	movs	r1, #6
   179c8:	4620      	mov	r0, r4
   179ca:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   179cc:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   179ce:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   179d0:	4620      	mov	r0, r4
   179d2:	f000 fa41 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   179d6:	7921      	ldrb	r1, [r4, #4]
   179d8:	4620      	mov	r0, r4
   179da:	f000 fa3d 	bl	17e58 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   179de:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   179e0:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   179e2:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   179e4:	70a3      	strb	r3, [r4, #2]
   179e6:	e7c8      	b.n	1797a <USBH_SetFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   179e8:	7962      	ldrb	r2, [r4, #5]
   179ea:	f104 0110 	add.w	r1, r4, #16
   179ee:	4620      	mov	r0, r4
   179f0:	f000 f986 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   179f4:	2302      	movs	r3, #2
   179f6:	2001      	movs	r0, #1
   179f8:	7623      	strb	r3, [r4, #24]
   179fa:	e7be      	b.n	1797a <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   179fc:	7961      	ldrb	r1, [r4, #5]
   179fe:	4620      	mov	r0, r4
   17a00:	f00f fae2 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17a04:	2801      	cmp	r0, #1
   17a06:	f000 8081 	beq.w	17b0c <USBH_SetFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   17a0a:	2804      	cmp	r0, #4
   17a0c:	d001      	beq.n	17a12 <USBH_SetFeature+0xaa>
   17a0e:	2802      	cmp	r0, #2
   17a10:	d1b2      	bne.n	17978 <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   17a12:	230b      	movs	r3, #11
   17a14:	2001      	movs	r0, #1
   17a16:	7623      	strb	r3, [r4, #24]
   17a18:	e7af      	b.n	1797a <USBH_SetFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   17a1a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17a1e:	4620      	mov	r0, r4
   17a20:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   17a22:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17a24:	68a1      	ldr	r1, [r4, #8]
   17a26:	89a2      	ldrh	r2, [r4, #12]
   17a28:	f000 f992 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   17a2c:	2304      	movs	r3, #4
   17a2e:	2001      	movs	r0, #1
   17a30:	7623      	strb	r3, [r4, #24]
   17a32:	e7a2      	b.n	1797a <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17a34:	7921      	ldrb	r1, [r4, #4]
   17a36:	4620      	mov	r0, r4
   17a38:	f00f fac6 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17a3c:	2801      	cmp	r0, #1
   17a3e:	d059      	beq.n	17af4 <USBH_SetFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
   17a40:	2805      	cmp	r0, #5
   17a42:	d039      	beq.n	17ab8 <USBH_SetFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
   17a44:	2804      	cmp	r0, #4
   17a46:	d197      	bne.n	17978 <USBH_SetFeature+0x10>
   17a48:	e7e3      	b.n	17a12 <USBH_SetFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   17a4a:	2501      	movs	r5, #1
   17a4c:	7963      	ldrb	r3, [r4, #5]
   17a4e:	89a2      	ldrh	r2, [r4, #12]
   17a50:	4620      	mov	r0, r4
   17a52:	68a1      	ldr	r1, [r4, #8]
   17a54:	9500      	str	r5, [sp, #0]
   17a56:	f000 f963 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17a5a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17a5e:	2306      	movs	r3, #6
   17a60:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17a62:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17a64:	7623      	strb	r3, [r4, #24]
   17a66:	e788      	b.n	1797a <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17a68:	7961      	ldrb	r1, [r4, #5]
   17a6a:	4620      	mov	r0, r4
   17a6c:	f00f faac 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17a70:	2801      	cmp	r0, #1
   17a72:	d047      	beq.n	17b04 <USBH_SetFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   17a74:	2805      	cmp	r0, #5
   17a76:	d01f      	beq.n	17ab8 <USBH_SetFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   17a78:	2802      	cmp	r0, #2
   17a7a:	d04e      	beq.n	17b1a <USBH_SetFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   17a7c:	2804      	cmp	r0, #4
   17a7e:	f47f af7b 	bne.w	17978 <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   17a82:	230b      	movs	r3, #11
   17a84:	7623      	strb	r3, [r4, #24]
   17a86:	e7ab      	b.n	179e0 <USBH_SetFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   17a88:	2200      	movs	r2, #0
   17a8a:	7923      	ldrb	r3, [r4, #4]
   17a8c:	4620      	mov	r0, r4
   17a8e:	4611      	mov	r1, r2
   17a90:	f000 f95e 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17a94:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17a98:	2308      	movs	r3, #8
   17a9a:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   17a9c:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17a9e:	7623      	strb	r3, [r4, #24]
   17aa0:	e76b      	b.n	1797a <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17aa2:	7921      	ldrb	r1, [r4, #4]
   17aa4:	4620      	mov	r0, r4
   17aa6:	f00f fa8f 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17aaa:	2801      	cmp	r0, #1
   17aac:	d026      	beq.n	17afc <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   17aae:	2804      	cmp	r0, #4
   17ab0:	d0af      	beq.n	17a12 <USBH_SetFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
   17ab2:	2805      	cmp	r0, #5
   17ab4:	f47f af60 	bne.w	17978 <USBH_SetFeature+0x10>
        status = USBH_NOT_SUPPORTED;
   17ab8:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   17aba:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   17abc:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   17abe:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   17ac0:	7623      	strb	r3, [r4, #24]
}
   17ac2:	b003      	add	sp, #12
   17ac4:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   17ac6:	2200      	movs	r2, #0
   17ac8:	2501      	movs	r5, #1
   17aca:	7963      	ldrb	r3, [r4, #5]
   17acc:	4620      	mov	r0, r4
   17ace:	4611      	mov	r1, r2
   17ad0:	9500      	str	r5, [sp, #0]
   17ad2:	f000 f925 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17ad6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17ada:	230a      	movs	r3, #10
   17adc:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17ade:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17ae0:	7623      	strb	r3, [r4, #24]
   17ae2:	e74a      	b.n	1797a <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17ae4:	7961      	ldrb	r1, [r4, #5]
   17ae6:	4620      	mov	r0, r4
   17ae8:	f00f fa6e 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17aec:	2801      	cmp	r0, #1
   17aee:	d005      	beq.n	17afc <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   17af0:	2802      	cmp	r0, #2
   17af2:	d1a7      	bne.n	17a44 <USBH_SetFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   17af4:	2309      	movs	r3, #9
   17af6:	2001      	movs	r0, #1
   17af8:	7623      	strb	r3, [r4, #24]
   17afa:	e73e      	b.n	1797a <USBH_SetFeature+0x12>
        status = USBH_OK;
   17afc:	2000      	movs	r0, #0
   17afe:	e7dc      	b.n	17aba <USBH_SetFeature+0x152>
          if (direction == USB_D2H)
   17b00:	2a00      	cmp	r2, #0
   17b02:	dbf7      	blt.n	17af4 <USBH_SetFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   17b04:	2307      	movs	r3, #7
   17b06:	2001      	movs	r0, #1
   17b08:	7623      	strb	r3, [r4, #24]
   17b0a:	e736      	b.n	1797a <USBH_SetFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   17b0c:	8ae3      	ldrh	r3, [r4, #22]
   17b0e:	f994 2010 	ldrsb.w	r2, [r4, #16]
   17b12:	2b00      	cmp	r3, #0
   17b14:	d0f4      	beq.n	17b00 <USBH_SetFeature+0x198>
          if (direction == USB_D2H)
   17b16:	2a00      	cmp	r2, #0
   17b18:	db08      	blt.n	17b2c <USBH_SetFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   17b1a:	2305      	movs	r3, #5
   17b1c:	2001      	movs	r0, #1
   17b1e:	7623      	strb	r3, [r4, #24]
   17b20:	e72b      	b.n	1797a <USBH_SetFeature+0x12>
        phost->Control.state = CTRL_SETUP;
   17b22:	2301      	movs	r3, #1
   17b24:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   17b26:	4618      	mov	r0, r3
   17b28:	70a3      	strb	r3, [r4, #2]
   17b2a:	e726      	b.n	1797a <USBH_SetFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
   17b2c:	2303      	movs	r3, #3
   17b2e:	7623      	strb	r3, [r4, #24]
   17b30:	e723      	b.n	1797a <USBH_SetFeature+0x12>
   17b32:	bf00      	nop

00017b34 <USBH_ClrFeature>:
{
   17b34:	b530      	push	{r4, r5, lr}
   17b36:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   17b38:	7880      	ldrb	r0, [r0, #2]
{
   17b3a:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   17b3c:	2801      	cmp	r0, #1
   17b3e:	d011      	beq.n	17b64 <USBH_ClrFeature+0x30>
  switch (phost->RequestState)
   17b40:	2802      	cmp	r0, #2
   17b42:	d002      	beq.n	17b4a <USBH_ClrFeature+0x16>
  status = USBH_BUSY;
   17b44:	2001      	movs	r0, #1
}
   17b46:	b003      	add	sp, #12
   17b48:	bd30      	pop	{r4, r5, pc}
   17b4a:	461c      	mov	r4, r3
  switch (phost->Control.state)
   17b4c:	7e1b      	ldrb	r3, [r3, #24]
   17b4e:	3b01      	subs	r3, #1
   17b50:	2b0a      	cmp	r3, #10
   17b52:	d8f7      	bhi.n	17b44 <USBH_ClrFeature+0x10>
   17b54:	e8df f003 	tbb	[pc, r3]
   17b58:	5447382e 	.word	0x5447382e
   17b5c:	8b7e6e5f 	.word	0x8b7e6e5f
   17b60:	ac9d      	.short	0xac9d
   17b62:	13          	.byte	0x13
   17b63:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = 0U;
   17b64:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
   17b66:	f44f 7581 	mov.w	r5, #258	; 0x102
      phost->RequestState = CMD_WAIT;
   17b6a:	2402      	movs	r4, #2
    phost->Control.setup.b.wIndex.w = ep_num;
   17b6c:	8299      	strh	r1, [r3, #20]
      phost->Control.state = CTRL_SETUP;
   17b6e:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
   17b70:	611d      	str	r5, [r3, #16]
    phost->Control.setup.b.wLength.w = 0U;
   17b72:	82da      	strh	r2, [r3, #22]
      phost->Control.buff = buff;
   17b74:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   17b76:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   17b78:	709c      	strb	r4, [r3, #2]
}
   17b7a:	b003      	add	sp, #12
   17b7c:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   17b7e:	7e63      	ldrb	r3, [r4, #25]
   17b80:	3301      	adds	r3, #1
   17b82:	b2db      	uxtb	r3, r3
   17b84:	2b02      	cmp	r3, #2
   17b86:	7663      	strb	r3, [r4, #25]
   17b88:	f240 80b1 	bls.w	17cee <USBH_ClrFeature+0x1ba>
        phost->Control.errorcount = 0U;
   17b8c:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   17b8e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   17b92:	2106      	movs	r1, #6
   17b94:	4620      	mov	r0, r4
   17b96:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17b98:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   17b9a:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   17b9c:	4620      	mov	r0, r4
   17b9e:	f000 f95b 	bl	17e58 <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   17ba2:	7921      	ldrb	r1, [r4, #4]
   17ba4:	4620      	mov	r0, r4
   17ba6:	f000 f957 	bl	17e58 <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   17baa:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   17bac:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   17bae:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   17bb0:	70a3      	strb	r3, [r4, #2]
   17bb2:	e7c8      	b.n	17b46 <USBH_ClrFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   17bb4:	7962      	ldrb	r2, [r4, #5]
   17bb6:	f104 0110 	add.w	r1, r4, #16
   17bba:	4620      	mov	r0, r4
   17bbc:	f000 f8a0 	bl	17d00 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   17bc0:	2302      	movs	r3, #2
   17bc2:	2001      	movs	r0, #1
   17bc4:	7623      	strb	r3, [r4, #24]
   17bc6:	e7be      	b.n	17b46 <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17bc8:	7961      	ldrb	r1, [r4, #5]
   17bca:	4620      	mov	r0, r4
   17bcc:	f00f f9fc 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17bd0:	2801      	cmp	r0, #1
   17bd2:	f000 8081 	beq.w	17cd8 <USBH_ClrFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   17bd6:	2804      	cmp	r0, #4
   17bd8:	d001      	beq.n	17bde <USBH_ClrFeature+0xaa>
   17bda:	2802      	cmp	r0, #2
   17bdc:	d1b2      	bne.n	17b44 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   17bde:	230b      	movs	r3, #11
   17be0:	2001      	movs	r0, #1
   17be2:	7623      	strb	r3, [r4, #24]
   17be4:	e7af      	b.n	17b46 <USBH_ClrFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   17be6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17bea:	4620      	mov	r0, r4
   17bec:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   17bee:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   17bf0:	68a1      	ldr	r1, [r4, #8]
   17bf2:	89a2      	ldrh	r2, [r4, #12]
   17bf4:	f000 f8ac 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   17bf8:	2304      	movs	r3, #4
   17bfa:	2001      	movs	r0, #1
   17bfc:	7623      	strb	r3, [r4, #24]
   17bfe:	e7a2      	b.n	17b46 <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17c00:	7921      	ldrb	r1, [r4, #4]
   17c02:	4620      	mov	r0, r4
   17c04:	f00f f9e0 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17c08:	2801      	cmp	r0, #1
   17c0a:	d059      	beq.n	17cc0 <USBH_ClrFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
   17c0c:	2805      	cmp	r0, #5
   17c0e:	d039      	beq.n	17c84 <USBH_ClrFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
   17c10:	2804      	cmp	r0, #4
   17c12:	d197      	bne.n	17b44 <USBH_ClrFeature+0x10>
   17c14:	e7e3      	b.n	17bde <USBH_ClrFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   17c16:	2501      	movs	r5, #1
   17c18:	7963      	ldrb	r3, [r4, #5]
   17c1a:	89a2      	ldrh	r2, [r4, #12]
   17c1c:	4620      	mov	r0, r4
   17c1e:	68a1      	ldr	r1, [r4, #8]
   17c20:	9500      	str	r5, [sp, #0]
   17c22:	f000 f87d 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17c26:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17c2a:	2306      	movs	r3, #6
   17c2c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17c2e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   17c30:	7623      	strb	r3, [r4, #24]
   17c32:	e788      	b.n	17b46 <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17c34:	7961      	ldrb	r1, [r4, #5]
   17c36:	4620      	mov	r0, r4
   17c38:	f00f f9c6 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17c3c:	2801      	cmp	r0, #1
   17c3e:	d047      	beq.n	17cd0 <USBH_ClrFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   17c40:	2805      	cmp	r0, #5
   17c42:	d01f      	beq.n	17c84 <USBH_ClrFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   17c44:	2802      	cmp	r0, #2
   17c46:	d04e      	beq.n	17ce6 <USBH_ClrFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   17c48:	2804      	cmp	r0, #4
   17c4a:	f47f af7b 	bne.w	17b44 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   17c4e:	230b      	movs	r3, #11
   17c50:	7623      	strb	r3, [r4, #24]
   17c52:	e7ab      	b.n	17bac <USBH_ClrFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   17c54:	2200      	movs	r2, #0
   17c56:	7923      	ldrb	r3, [r4, #4]
   17c58:	4620      	mov	r0, r4
   17c5a:	4611      	mov	r1, r2
   17c5c:	f000 f878 	bl	17d50 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17c60:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17c64:	2308      	movs	r3, #8
   17c66:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   17c68:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   17c6a:	7623      	strb	r3, [r4, #24]
   17c6c:	e76b      	b.n	17b46 <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   17c6e:	7921      	ldrb	r1, [r4, #4]
   17c70:	4620      	mov	r0, r4
   17c72:	f00f f9a9 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17c76:	2801      	cmp	r0, #1
   17c78:	d026      	beq.n	17cc8 <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   17c7a:	2804      	cmp	r0, #4
   17c7c:	d0af      	beq.n	17bde <USBH_ClrFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
   17c7e:	2805      	cmp	r0, #5
   17c80:	f47f af60 	bne.w	17b44 <USBH_ClrFeature+0x10>
        status = USBH_NOT_SUPPORTED;
   17c84:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   17c86:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   17c88:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   17c8a:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   17c8c:	7623      	strb	r3, [r4, #24]
}
   17c8e:	b003      	add	sp, #12
   17c90:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   17c92:	2200      	movs	r2, #0
   17c94:	2501      	movs	r5, #1
   17c96:	7963      	ldrb	r3, [r4, #5]
   17c98:	4620      	mov	r0, r4
   17c9a:	4611      	mov	r1, r2
   17c9c:	9500      	str	r5, [sp, #0]
   17c9e:	f000 f83f 	bl	17d20 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   17ca2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17ca6:	230a      	movs	r3, #10
   17ca8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   17caa:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   17cac:	7623      	strb	r3, [r4, #24]
   17cae:	e74a      	b.n	17b46 <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   17cb0:	7961      	ldrb	r1, [r4, #5]
   17cb2:	4620      	mov	r0, r4
   17cb4:	f00f f988 	bl	26fc8 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   17cb8:	2801      	cmp	r0, #1
   17cba:	d005      	beq.n	17cc8 <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   17cbc:	2802      	cmp	r0, #2
   17cbe:	d1a7      	bne.n	17c10 <USBH_ClrFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   17cc0:	2309      	movs	r3, #9
   17cc2:	2001      	movs	r0, #1
   17cc4:	7623      	strb	r3, [r4, #24]
   17cc6:	e73e      	b.n	17b46 <USBH_ClrFeature+0x12>
        status = USBH_OK;
   17cc8:	2000      	movs	r0, #0
   17cca:	e7dc      	b.n	17c86 <USBH_ClrFeature+0x152>
          if (direction == USB_D2H)
   17ccc:	2a00      	cmp	r2, #0
   17cce:	dbf7      	blt.n	17cc0 <USBH_ClrFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   17cd0:	2307      	movs	r3, #7
   17cd2:	2001      	movs	r0, #1
   17cd4:	7623      	strb	r3, [r4, #24]
   17cd6:	e736      	b.n	17b46 <USBH_ClrFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   17cd8:	8ae3      	ldrh	r3, [r4, #22]
   17cda:	f994 2010 	ldrsb.w	r2, [r4, #16]
   17cde:	2b00      	cmp	r3, #0
   17ce0:	d0f4      	beq.n	17ccc <USBH_ClrFeature+0x198>
          if (direction == USB_D2H)
   17ce2:	2a00      	cmp	r2, #0
   17ce4:	db08      	blt.n	17cf8 <USBH_ClrFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   17ce6:	2305      	movs	r3, #5
   17ce8:	2001      	movs	r0, #1
   17cea:	7623      	strb	r3, [r4, #24]
   17cec:	e72b      	b.n	17b46 <USBH_ClrFeature+0x12>
        phost->Control.state = CTRL_SETUP;
   17cee:	2301      	movs	r3, #1
   17cf0:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   17cf2:	4618      	mov	r0, r3
   17cf4:	70a3      	strb	r3, [r4, #2]
   17cf6:	e726      	b.n	17b46 <USBH_ClrFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
   17cf8:	2303      	movs	r3, #3
   17cfa:	7623      	strb	r3, [r4, #24]
   17cfc:	e723      	b.n	17b46 <USBH_ClrFeature+0x12>
   17cfe:	bf00      	nop

00017d00 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
   17d00:	b530      	push	{r4, r5, lr}

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d02:	2400      	movs	r4, #0
{
   17d04:	b085      	sub	sp, #20
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d06:	2508      	movs	r5, #8
   17d08:	9101      	str	r1, [sp, #4]
   17d0a:	4623      	mov	r3, r4
   17d0c:	4611      	mov	r1, r2
   17d0e:	9403      	str	r4, [sp, #12]
   17d10:	9400      	str	r4, [sp, #0]
   17d12:	4622      	mov	r2, r4
   17d14:	9502      	str	r5, [sp, #8]
   17d16:	f00f f939 	bl	26f8c <USBH_LL_SubmitURB>
                    USBH_PID_SETUP,       /* Type setup       */
                    buff,                 /* data buffer      */
                    USBH_SETUP_PKT_SIZE,  /* data length      */
                    0U);
  return USBH_OK;
}
   17d1a:	4620      	mov	r0, r4
   17d1c:	b005      	add	sp, #20
   17d1e:	bd30      	pop	{r4, r5, pc}

00017d20 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
   17d20:	b570      	push	{r4, r5, r6, lr}
  if (phost->device.speed != USBH_SPEED_HIGH)
   17d22:	f890 631d 	ldrb.w	r6, [r0, #797]	; 0x31d
{
   17d26:	b084      	sub	sp, #16
   17d28:	461d      	mov	r5, r3
  {
    do_ping = 0U;
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d2a:	2300      	movs	r3, #0
  if (phost->device.speed != USBH_SPEED_HIGH)
   17d2c:	2e00      	cmp	r6, #0
{
   17d2e:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d32:	f04f 0601 	mov.w	r6, #1
   17d36:	9202      	str	r2, [sp, #8]
    do_ping = 0U;
   17d38:	bf18      	it	ne
   17d3a:	461c      	movne	r4, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d3c:	461a      	mov	r2, r3
   17d3e:	e9cd 6100 	strd	r6, r1, [sp]
   17d42:	9403      	str	r4, [sp, #12]
   17d44:	4629      	mov	r1, r5
   17d46:	f00f f921 	bl	26f8c <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
   17d4a:	2000      	movs	r0, #0
   17d4c:	b004      	add	sp, #16
   17d4e:	bd70      	pop	{r4, r5, r6, pc}

00017d50 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
   17d50:	b570      	push	{r4, r5, r6, lr}
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d52:	2400      	movs	r4, #0
{
   17d54:	b084      	sub	sp, #16
   17d56:	461e      	mov	r6, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d58:	2501      	movs	r5, #1
   17d5a:	4623      	mov	r3, r4
   17d5c:	9403      	str	r4, [sp, #12]
   17d5e:	9500      	str	r5, [sp, #0]
   17d60:	e9cd 1201 	strd	r1, r2, [sp, #4]
   17d64:	4631      	mov	r1, r6
   17d66:	462a      	mov	r2, r5
   17d68:	f00f f910 	bl	26f8c <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;

}
   17d6c:	4620      	mov	r0, r4
   17d6e:	b004      	add	sp, #16
   17d70:	bd70      	pop	{r4, r5, r6, pc}
   17d72:	bf00      	nop

00017d74 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
   17d74:	b570      	push	{r4, r5, r6, lr}
   17d76:	461e      	mov	r6, r3
   17d78:	b084      	sub	sp, #16
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   17d7a:	2400      	movs	r4, #0
   17d7c:	2501      	movs	r5, #1
   17d7e:	2302      	movs	r3, #2
   17d80:	9403      	str	r4, [sp, #12]
   17d82:	9500      	str	r5, [sp, #0]
   17d84:	e9cd 1201 	strd	r1, r2, [sp, #4]
   17d88:	4631      	mov	r1, r6
   17d8a:	462a      	mov	r2, r5
   17d8c:	f00f f8fe 	bl	26f8c <USBH_LL_SubmitURB>
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
}
   17d90:	4620      	mov	r0, r4
   17d92:	b004      	add	sp, #16
   17d94:	bd70      	pop	{r4, r5, r6, pc}
   17d96:	bf00      	nop

00017d98 <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
   17d98:	b530      	push	{r4, r5, lr}
   17d9a:	b085      	sub	sp, #20
   17d9c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   17da0:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
   17da4:	9400      	str	r4, [sp, #0]
{
   17da6:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
   17daa:	e9cd 5401 	strd	r5, r4, [sp, #4]
   17dae:	f00f f8c1 	bl	26f34 <USBH_LL_OpenPipe>

  return USBH_OK;
}
   17db2:	2000      	movs	r0, #0
   17db4:	b005      	add	sp, #20
   17db6:	bd30      	pop	{r4, r5, pc}

00017db8 <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
   17db8:	b508      	push	{r3, lr}
  USBH_LL_ClosePipe(phost, pipe_num);
   17dba:	f00f f8d7 	bl	26f6c <USBH_LL_ClosePipe>

  return USBH_OK;
}
   17dbe:	2000      	movs	r0, #0
   17dc0:	bd08      	pop	{r3, pc}
   17dc2:	bf00      	nop

00017dc4 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
   17dc4:	4603      	mov	r3, r0
{
  uint8_t idx = 0U;

  for (idx = 0U ; idx < 11U ; idx++)
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
   17dc6:	f8d0 04f4 	ldr.w	r0, [r0, #1268]	; 0x4f4
   17dca:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
   17dce:	d02a      	beq.n	17e26 <USBH_AllocPipe+0x62>
   17dd0:	f8d3 24f8 	ldr.w	r2, [r3, #1272]	; 0x4f8
   17dd4:	0410      	lsls	r0, r2, #16
   17dd6:	d52d      	bpl.n	17e34 <USBH_AllocPipe+0x70>
   17dd8:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
   17ddc:	0412      	lsls	r2, r2, #16
   17dde:	d52b      	bpl.n	17e38 <USBH_AllocPipe+0x74>
   17de0:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
   17de4:	0410      	lsls	r0, r2, #16
   17de6:	d529      	bpl.n	17e3c <USBH_AllocPipe+0x78>
   17de8:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   17dec:	0412      	lsls	r2, r2, #16
   17dee:	d527      	bpl.n	17e40 <USBH_AllocPipe+0x7c>
   17df0:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
   17df4:	0410      	lsls	r0, r2, #16
   17df6:	d525      	bpl.n	17e44 <USBH_AllocPipe+0x80>
   17df8:	f8d3 250c 	ldr.w	r2, [r3, #1292]	; 0x50c
   17dfc:	0412      	lsls	r2, r2, #16
   17dfe:	d525      	bpl.n	17e4c <USBH_AllocPipe+0x88>
   17e00:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   17e04:	0410      	lsls	r0, r2, #16
   17e06:	d523      	bpl.n	17e50 <USBH_AllocPipe+0x8c>
   17e08:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
   17e0c:	0412      	lsls	r2, r2, #16
   17e0e:	d51b      	bpl.n	17e48 <USBH_AllocPipe+0x84>
   17e10:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   17e14:	0410      	lsls	r0, r2, #16
   17e16:	d505      	bpl.n	17e24 <USBH_AllocPipe+0x60>
   17e18:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
   17e1c:	0412      	lsls	r2, r2, #16
   17e1e:	d519      	bpl.n	17e54 <USBH_AllocPipe+0x90>
   17e20:	20ff      	movs	r0, #255	; 0xff
}
   17e22:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
   17e24:	2009      	movs	r0, #9
    phost->Pipes[pipe & 0xFU] = 0x8000U | ep_addr;
   17e26:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   17e2a:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
   17e2e:	f8c3 14f4 	str.w	r1, [r3, #1268]	; 0x4f4
   17e32:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
   17e34:	2001      	movs	r0, #1
   17e36:	e7f6      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e38:	2002      	movs	r0, #2
   17e3a:	e7f4      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e3c:	2003      	movs	r0, #3
   17e3e:	e7f2      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e40:	2004      	movs	r0, #4
   17e42:	e7f0      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e44:	2005      	movs	r0, #5
   17e46:	e7ee      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e48:	2008      	movs	r0, #8
   17e4a:	e7ec      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e4c:	2006      	movs	r0, #6
   17e4e:	e7ea      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e50:	2007      	movs	r0, #7
   17e52:	e7e8      	b.n	17e26 <USBH_AllocPipe+0x62>
   17e54:	200a      	movs	r0, #10
   17e56:	e7e6      	b.n	17e26 <USBH_AllocPipe+0x62>

00017e58 <USBH_FreePipe>:
  if (idx < 11U)
   17e58:	290a      	cmp	r1, #10
   17e5a:	d807      	bhi.n	17e6c <USBH_FreePipe+0x14>
   17e5c:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    phost->Pipes[idx] &= 0x7FFFU;
   17e60:	f8d0 34f4 	ldr.w	r3, [r0, #1268]	; 0x4f4
   17e64:	f3c3 030e 	ubfx	r3, r3, #0, #15
   17e68:	f8c0 34f4 	str.w	r3, [r0, #1268]	; 0x4f4
}
   17e6c:	2000      	movs	r0, #0
   17e6e:	4770      	bx	lr

00017e70 <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
   17e70:	f646 0328 	movw	r3, #26664	; 0x6828
   17e74:	f2c0 230e 	movt	r3, #526	; 0x20e
   17e78:	7a5a      	ldrb	r2, [r3, #9]
   17e7a:	b10a      	cbz	r2, 17e80 <FATFS_LinkDriver+0x10>
  uint8_t ret = 1;
   17e7c:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
}
   17e7e:	4770      	bx	lr
{
   17e80:	b5f0      	push	{r4, r5, r6, r7, lr}
   17e82:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    disk.is_initialized[disk.nbr] = 0;
   17e86:	f893 e009 	ldrb.w	lr, [r3, #9]
    disk.drv[disk.nbr] = drv;
   17e8a:	7a5e      	ldrb	r6, [r3, #9]
    path[1] = ':';
   17e8c:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
    disk.lun[disk.nbr] = lun;
   17e90:	7a5d      	ldrb	r5, [r3, #9]
    path[2] = '/';
   17e92:	272f      	movs	r7, #47	; 0x2f
    DiskNum = disk.nbr++;
   17e94:	7a5a      	ldrb	r2, [r3, #9]
    disk.drv[disk.nbr] = drv;
   17e96:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    disk.lun[disk.nbr] = lun;
   17e9a:	441d      	add	r5, r3
    disk.is_initialized[disk.nbr] = 0;
   17e9c:	f803 400e 	strb.w	r4, [r3, lr]
    DiskNum = disk.nbr++;
   17ea0:	b2d2      	uxtb	r2, r2
    disk.drv[disk.nbr] = drv;
   17ea2:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
   17ea4:	722c      	strb	r4, [r5, #8]
    DiskNum = disk.nbr++;
   17ea6:	1c50      	adds	r0, r2, #1
    path[0] = DiskNum + '0';
   17ea8:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
   17eaa:	b2c0      	uxtb	r0, r0
   17eac:	7258      	strb	r0, [r3, #9]
    path[3] = 0;
   17eae:	4620      	mov	r0, r4
    path[0] = DiskNum + '0';
   17eb0:	700a      	strb	r2, [r1, #0]
    path[3] = 0;
   17eb2:	70cc      	strb	r4, [r1, #3]
    path[1] = ':';
   17eb4:	f881 c001 	strb.w	ip, [r1, #1]
    path[2] = '/';
   17eb8:	708f      	strb	r7, [r1, #2]
}
   17eba:	bdf0      	pop	{r4, r5, r6, r7, pc}

00017ebc <MIDI_Application>:
 * @brief  Main routine for MIDI application, looped in main.c
 * @param  None
 * @retval none
 */
void MIDI_Application(void)
{
   17ebc:	b510      	push	{r4, lr}
	if(Appli_state == APPLICATION_READY)
   17ebe:	f646 14bc 	movw	r4, #27068	; 0x69bc
   17ec2:	f2c0 240e 	movt	r4, #526	; 0x20e
   17ec6:	7823      	ldrb	r3, [r4, #0]
   17ec8:	2b02      	cmp	r3, #2
   17eca:	d019      	beq.n	17f00 <MIDI_Application+0x44>
	if(Appli_state == APPLICATION_RUNNING)
	{
			//....pffff......grrrrr......
	}

	if(Appli_state == APPLICATION_DISCONNECT)
   17ecc:	2b04      	cmp	r3, #4
   17ece:	d000      	beq.n	17ed2 <MIDI_Application+0x16>
		HAL_Delay(10);
		MX_USB_HOST_Init();

	}

}
   17ed0:	bd10      	pop	{r4, pc}
		Appli_state = APPLICATION_IDLE;
   17ed2:	2300      	movs	r3, #0
		setLED_USB(0);
   17ed4:	4618      	mov	r0, r3
		Appli_state = APPLICATION_IDLE;
   17ed6:	7023      	strb	r3, [r4, #0]
		setLED_USB(0);
   17ed8:	f003 f8fc 	bl	1b0d4 <setLED_USB>
		USBH_MIDI_Stop(&hUsbHostFS);
   17edc:	f247 5040 	movw	r0, #30016	; 0x7540
   17ee0:	f2c0 0006 	movt	r0, #6
   17ee4:	f00e ff44 	bl	26d70 <USBH_MIDI_Stop>
		HAL_Delay(10);
   17ee8:	200a      	movs	r0, #10
   17eea:	f7f0 faaf 	bl	844c <HAL_Delay>
		MX_USB_HOST_DeInit();
   17eee:	f00e fdbb 	bl	26a68 <MX_USB_HOST_DeInit>
		HAL_Delay(10);
   17ef2:	200a      	movs	r0, #10
   17ef4:	f7f0 faaa 	bl	844c <HAL_Delay>
}
   17ef8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		MX_USB_HOST_Init();
   17efc:	f00e bd88 	b.w	26a10 <MX_USB_HOST_Init>
		USBH_MIDI_Receive(&hUsbHostFS, MIDI_RX_Buffer[MIDI_write_buffer], RX_BUFF_SIZE); // just once at the beginning, start the first reception
   17f00:	f246 010c 	movw	r1, #24588	; 0x600c
   17f04:	f246 43a0 	movw	r3, #25760	; 0x64a0
   17f08:	f247 5040 	movw	r0, #30016	; 0x7540
   17f0c:	2240      	movs	r2, #64	; 0x40
   17f0e:	f2c0 0106 	movt	r1, #6
   17f12:	f2c0 0306 	movt	r3, #6
   17f16:	f2c0 0006 	movt	r0, #6
   17f1a:	7809      	ldrb	r1, [r1, #0]
   17f1c:	eb03 1181 	add.w	r1, r3, r1, lsl #6
   17f20:	f00e ff3c 	bl	26d9c <USBH_MIDI_Receive>
		Appli_state = APPLICATION_RUNNING;
   17f24:	2303      	movs	r3, #3
		setLED_USB(1);
   17f26:	2001      	movs	r0, #1
		Appli_state = APPLICATION_RUNNING;
   17f28:	7023      	strb	r3, [r4, #0]
		setLED_USB(1);
   17f2a:	f003 f8d3 	bl	1b0d4 <setLED_USB>
   17f2e:	7823      	ldrb	r3, [r4, #0]
   17f30:	e7cc      	b.n	17ecc <MIDI_Application+0x10>
   17f32:	bf00      	nop

00017f34 <ProcessReceivedMidiDatas>:

}
volatile testInt = 0;
/*-----------------------------------------------------------------------------*/
void ProcessReceivedMidiDatas(void)
{
   17f34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   17f38:	f646 14be 	movw	r4, #27070	; 0x69be
   17f3c:	f646 17c0 	movw	r7, #27072	; 0x69c0
	uint8_t miniBufferPosition = 0;
	uint8_t processed = 0;
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   17f40:	f646 18bd 	movw	r8, #27069	; 0x69bd
			(processed < 32)) // maximum notes to process in a frame * 4
	{

		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   17f44:	f24f 4944 	movw	r9, #62532	; 0xf444
   17f48:	f646 266c 	movw	r6, #27244	; 0x6a6c
   17f4c:	f2c0 240e 	movt	r4, #526	; 0x20e
   17f50:	f2c0 270e 	movt	r7, #526	; 0x20e
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   17f54:	f2c0 280e 	movt	r8, #526	; 0x20e
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   17f58:	f2c0 290f 	movt	r9, #527	; 0x20f
   17f5c:	f2c0 260e 	movt	r6, #526	; 0x20e
	uint8_t processed = 0;
   17f60:	2500      	movs	r5, #0
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   17f62:	e008      	b.n	17f76 <ProcessReceivedMidiDatas+0x42>
		myUSB_FIFO_readPointer++;
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
		{
			parse_MIDI_Message();
		}
		if (myUSB_FIFO_readPointer >= USB_FIFO_SIZE)
   17f64:	8823      	ldrh	r3, [r4, #0]
   17f66:	2bff      	cmp	r3, #255	; 0xff
   17f68:	d903      	bls.n	17f72 <ProcessReceivedMidiDatas+0x3e>
		{
			myUSB_FIFO_overflowBit = 0;
   17f6a:	2300      	movs	r3, #0
   17f6c:	f888 3000 	strb.w	r3, [r8]
			myUSB_FIFO_readPointer = 0;
   17f70:	8023      	strh	r3, [r4, #0]
		}
		processed++;
   17f72:	3501      	adds	r5, #1
   17f74:	b2ed      	uxtb	r5, r5
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   17f76:	883b      	ldrh	r3, [r7, #0]
   17f78:	8822      	ldrh	r2, [r4, #0]
   17f7a:	429a      	cmp	r2, r3
   17f7c:	d303      	bcc.n	17f86 <ProcessReceivedMidiDatas+0x52>
   17f7e:	f898 3000 	ldrb.w	r3, [r8]
   17f82:	2b00      	cmp	r3, #0
   17f84:	d069      	beq.n	1805a <ProcessReceivedMidiDatas+0x126>
   17f86:	2d20      	cmp	r5, #32
   17f88:	d06b      	beq.n	18062 <ProcessReceivedMidiDatas+0x12e>
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
   17f8a:	8822      	ldrh	r2, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   17f8c:	8823      	ldrh	r3, [r4, #0]
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
   17f8e:	f002 0203 	and.w	r2, r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   17f92:	b29b      	uxth	r3, r3
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
   17f94:	2a03      	cmp	r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   17f96:	f819 1003 	ldrb.w	r1, [r9, r3]
		myUSB_FIFO_readPointer++;
   17f9a:	8823      	ldrh	r3, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   17f9c:	54b1      	strb	r1, [r6, r2]
		myUSB_FIFO_readPointer++;
   17f9e:	f103 0301 	add.w	r3, r3, #1
   17fa2:	b29b      	uxth	r3, r3
   17fa4:	8023      	strh	r3, [r4, #0]
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
   17fa6:	d1dd      	bne.n	17f64 <ProcessReceivedMidiDatas+0x30>
	switch(USB_message[1])
   17fa8:	7873      	ldrb	r3, [r6, #1]
   17faa:	2b90      	cmp	r3, #144	; 0x90
   17fac:	d020      	beq.n	17ff0 <ProcessReceivedMidiDatas+0xbc>
   17fae:	d90a      	bls.n	17fc6 <ProcessReceivedMidiDatas+0x92>
   17fb0:	2bb0      	cmp	r3, #176	; 0xb0
   17fb2:	d030      	beq.n	18016 <ProcessReceivedMidiDatas+0xe2>
   17fb4:	2be0      	cmp	r3, #224	; 0xe0
   17fb6:	d1d5      	bne.n	17f64 <ProcessReceivedMidiDatas+0x30>
			pitchBend((USB_message[2]) + (USB_message[3] << 7));
   17fb8:	78f0      	ldrb	r0, [r6, #3]
   17fba:	78b3      	ldrb	r3, [r6, #2]
   17fbc:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
   17fc0:	f00c fae8 	bl	24594 <pitchBend>
   17fc4:	e7ce      	b.n	17f64 <ProcessReceivedMidiDatas+0x30>
	switch(USB_message[1])
   17fc6:	2b80      	cmp	r3, #128	; 0x80
   17fc8:	d1cc      	bne.n	17f64 <ProcessReceivedMidiDatas+0x30>
			key = USB_message[2];
   17fca:	f646 2270 	movw	r2, #27248	; 0x6a70
			velocity = USB_message[3];
   17fce:	f646 2368 	movw	r3, #27240	; 0x6a68
			key = USB_message[2];
   17fd2:	78b1      	ldrb	r1, [r6, #2]
			velocity = USB_message[3];
   17fd4:	f896 c003 	ldrb.w	ip, [r6, #3]
			key = USB_message[2];
   17fd8:	f2c0 220e 	movt	r2, #526	; 0x20e
			velocity = USB_message[3];
   17fdc:	f2c0 230e 	movt	r3, #526	; 0x20e
			noteOff(key, velocity);
   17fe0:	4608      	mov	r0, r1
			key = USB_message[2];
   17fe2:	7011      	strb	r1, [r2, #0]
			noteOff(key, velocity);
   17fe4:	4661      	mov	r1, ip
			velocity = USB_message[3];
   17fe6:	f883 c000 	strb.w	ip, [r3]
			noteOff(key, velocity);
   17fea:	f00c f88b 	bl	24104 <noteOff>
   17fee:	e7b9      	b.n	17f64 <ProcessReceivedMidiDatas+0x30>
			key = USB_message[2];
   17ff0:	f646 2270 	movw	r2, #27248	; 0x6a70
			velocity = USB_message[3];
   17ff4:	f646 2368 	movw	r3, #27240	; 0x6a68
			key = USB_message[2];
   17ff8:	78b1      	ldrb	r1, [r6, #2]
			velocity = USB_message[3];
   17ffa:	f896 c003 	ldrb.w	ip, [r6, #3]
			key = USB_message[2];
   17ffe:	f2c0 220e 	movt	r2, #526	; 0x20e
			velocity = USB_message[3];
   18002:	f2c0 230e 	movt	r3, #526	; 0x20e
			noteOn(key, velocity);
   18006:	4608      	mov	r0, r1
			key = USB_message[2];
   18008:	7011      	strb	r1, [r2, #0]
			noteOn(key, velocity);
   1800a:	4661      	mov	r1, ip
			velocity = USB_message[3];
   1800c:	f883 c000 	strb.w	ip, [r3]
			noteOn(key, velocity);
   18010:	f00c f940 	bl	24294 <noteOn>
   18014:	e7a6      	b.n	17f64 <ProcessReceivedMidiDatas+0x30>
			ctrl = USB_message[2];
   18016:	78b3      	ldrb	r3, [r6, #2]
   18018:	f646 10e5 	movw	r0, #27109	; 0x69e5
			CCs[ctrl] = data;
   1801c:	f646 11e8 	movw	r1, #27112	; 0x69e8
			data = USB_message[3];
   18020:	f646 2269 	movw	r2, #27241	; 0x6a69
   18024:	f896 c003 	ldrb.w	ip, [r6, #3]
			ctrl = USB_message[2];
   18028:	f2c0 200e 	movt	r0, #526	; 0x20e
			CCs[ctrl] = data;
   1802c:	f2c0 210e 	movt	r1, #526	; 0x20e
			data = USB_message[3];
   18030:	f2c0 220e 	movt	r2, #526	; 0x20e
			switch(ctrl)
   18034:	2b40      	cmp	r3, #64	; 0x40
			ctrl = USB_message[2];
   18036:	7003      	strb	r3, [r0, #0]
			CCs[ctrl] = data;
   18038:	f801 c003 	strb.w	ip, [r1, r3]
			data = USB_message[3];
   1803c:	f882 c000 	strb.w	ip, [r2]
			switch(ctrl)
   18040:	d190      	bne.n	17f64 <ProcessReceivedMidiDatas+0x30>
   18042:	f646 13e4 	movw	r3, #27108	; 0x69e4
   18046:	f2c0 230e 	movt	r3, #526	; 0x20e
   1804a:	781b      	ldrb	r3, [r3, #0]
					if (data)
   1804c:	f1bc 0f00 	cmp.w	ip, #0
   18050:	d00f      	beq.n	18072 <ProcessReceivedMidiDatas+0x13e>
						if (sustainInverted) 	sustainOff();
   18052:	b183      	cbz	r3, 18076 <ProcessReceivedMidiDatas+0x142>
   18054:	f00c faac 	bl	245b0 <sustainOff>
   18058:	e784      	b.n	17f64 <ProcessReceivedMidiDatas+0x30>
	}
	if (processed >= 32)
   1805a:	2d20      	cmp	r5, #32
   1805c:	d001      	beq.n	18062 <ProcessReceivedMidiDatas+0x12e>
	{
		testInt = 1;
	}
}
   1805e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		testInt = 1;
   18062:	f646 0338 	movw	r3, #26680	; 0x6838
   18066:	2201      	movs	r2, #1
   18068:	f2c0 230e 	movt	r3, #526	; 0x20e
   1806c:	601a      	str	r2, [r3, #0]
}
   1806e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (sustainInverted) 	sustainOn();
   18072:	2b00      	cmp	r3, #0
   18074:	d0ee      	beq.n	18054 <ProcessReceivedMidiDatas+0x120>
						else					sustainOn();
   18076:	f00c fa9d 	bl	245b4 <sustainOn>
   1807a:	e773      	b.n	17f64 <ProcessReceivedMidiDatas+0x30>

0001807c <MX_ADC1_Init>:
  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /** Common config 
  */
  hadc1.Instance = ADC1;
   1807c:	f646 2374 	movw	r3, #27252	; 0x6a74
   18080:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
   18084:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.NbrOfConversion = 6;
   18088:	2106      	movs	r1, #6
  hadc1.Instance = ADC1;
   1808a:	f2c0 230e 	movt	r3, #526	; 0x20e
   1808e:	f2c4 0202 	movt	r2, #16386	; 0x4002
{
   18092:	b570      	push	{r4, r5, r6, lr}
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = ENABLE;
  hadc1.Init.Oversampling.Ratio = 64;
   18094:	2440      	movs	r4, #64	; 0x40
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
   18096:	6058      	str	r0, [r3, #4]
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
   18098:	20c0      	movs	r0, #192	; 0xc0
{
   1809a:	b08a      	sub	sp, #40	; 0x28
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
   1809c:	2608      	movs	r6, #8
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
   1809e:	2503      	movs	r5, #3
  hadc1.Instance = ADC1;
   180a0:	601a      	str	r2, [r3, #0]
  ADC_MultiModeTypeDef multimode = {0};
   180a2:	2200      	movs	r2, #0
  hadc1.Init.NbrOfConversion = 6;
   180a4:	6199      	str	r1, [r3, #24]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
   180a6:	2101      	movs	r1, #1
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
   180a8:	611e      	str	r6, [r3, #16]
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
   180aa:	62dd      	str	r5, [r3, #44]	; 0x2c
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
   180ac:	609a      	str	r2, [r3, #8]
  hadc1.Init.LowPowerAutoWait = DISABLE;
   180ae:	751a      	strb	r2, [r3, #20]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
   180b0:	771a      	strb	r2, [r3, #28]
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
   180b2:	645a      	str	r2, [r3, #68]	; 0x44
  ADC_MultiModeTypeDef multimode = {0};
   180b4:	9200      	str	r2, [sp, #0]
  ADC_ChannelConfTypeDef sConfig = {0};
   180b6:	9203      	str	r2, [sp, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
   180b8:	60d9      	str	r1, [r3, #12]
  hadc1.Init.ContinuousConvMode = ENABLE;
   180ba:	7559      	strb	r1, [r3, #21]
  hadc1.Init.OversamplingMode = ENABLE;
   180bc:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
   180c0:	6499      	str	r1, [r3, #72]	; 0x48
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
   180c2:	e9c3 400f 	strd	r4, r0, [r3, #60]	; 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
   180c6:	4618      	mov	r0, r3
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
   180c8:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
   180cc:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
  ADC_MultiModeTypeDef multimode = {0};
   180d0:	e9cd 2201 	strd	r2, r2, [sp, #4]
  ADC_ChannelConfTypeDef sConfig = {0};
   180d4:	e9cd 2204 	strd	r2, r2, [sp, #16]
   180d8:	e9cd 2206 	strd	r2, r2, [sp, #24]
   180dc:	e9cd 2208 	strd	r2, r2, [sp, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
   180e0:	f7f1 f954 	bl	938c <HAL_ADC_Init>
   180e4:	2800      	cmp	r0, #0
   180e6:	f040 8086 	bne.w	181f6 <MX_ADC1_Init+0x17a>
    Error_Handler();
  }
  /** Configure the ADC multi-mode 
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   180ea:	f646 2074 	movw	r0, #27252	; 0x6a74
  multimode.Mode = ADC_MODE_INDEPENDENT;
   180ee:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   180f0:	4669      	mov	r1, sp
   180f2:	f2c0 200e 	movt	r0, #526	; 0x20e
  multimode.Mode = ADC_MODE_INDEPENDENT;
   180f6:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   180f8:	f7f1 fcb4 	bl	9a64 <HAL_ADCEx_MultiModeConfigChannel>
   180fc:	2800      	cmp	r0, #0
   180fe:	d177      	bne.n	181f0 <MX_ADC1_Init+0x174>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_7;
   18100:	2380      	movs	r3, #128	; 0x80
  sConfig.Rank = ADC_REGULAR_RANK_1;
   18102:	2206      	movs	r2, #6
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
   18104:	2105      	movs	r1, #5
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18106:	f646 2074 	movw	r0, #27252	; 0x6a74
  sConfig.Channel = ADC_CHANNEL_7;
   1810a:	f6c1 5350 	movt	r3, #7504	; 0x1d50
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
   1810e:	f240 74ff 	movw	r4, #2047	; 0x7ff
  sConfig.Rank = ADC_REGULAR_RANK_1;
   18112:	9204      	str	r2, [sp, #16]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
   18114:	2204      	movs	r2, #4
  sConfig.Channel = ADC_CHANNEL_7;
   18116:	9303      	str	r3, [sp, #12]
  sConfig.Offset = 0;
   18118:	2300      	movs	r3, #0
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
   1811a:	9105      	str	r1, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1811c:	f2c0 200e 	movt	r0, #526	; 0x20e
   18120:	a903      	add	r1, sp, #12
  sConfig.Offset = 0;
   18122:	9308      	str	r3, [sp, #32]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
   18124:	e9cd 4206 	strd	r4, r2, [sp, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18128:	f7f0 fb2a 	bl	8780 <HAL_ADC_ConfigChannel>
   1812c:	2800      	cmp	r0, #0
   1812e:	d15c      	bne.n	181ea <MX_ADC1_Init+0x16e>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_19;
   18130:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_2;
   18132:	220c      	movs	r2, #12
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18134:	f646 2074 	movw	r0, #27252	; 0x6a74
  sConfig.Channel = ADC_CHANNEL_19;
   18138:	f6c4 73b8 	movt	r3, #20408	; 0x4fb8
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1813c:	eb0d 0102 	add.w	r1, sp, r2
   18140:	f2c0 200e 	movt	r0, #526	; 0x20e
  sConfig.Channel = ADC_CHANNEL_19;
   18144:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18148:	f7f0 fb1a 	bl	8780 <HAL_ADC_ConfigChannel>
   1814c:	2800      	cmp	r0, #0
   1814e:	d149      	bne.n	181e4 <MX_ADC1_Init+0x168>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_14;
   18150:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  sConfig.Rank = ADC_REGULAR_RANK_3;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18154:	f646 2074 	movw	r0, #27252	; 0x6a74
  sConfig.Rank = ADC_REGULAR_RANK_3;
   18158:	2212      	movs	r2, #18
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1815a:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_14;
   1815c:	f6c3 23c0 	movt	r3, #15040	; 0x3ac0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18160:	f2c0 200e 	movt	r0, #526	; 0x20e
  sConfig.Channel = ADC_CHANNEL_14;
   18164:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18168:	f7f0 fb0a 	bl	8780 <HAL_ADC_ConfigChannel>
   1816c:	bbb8      	cbnz	r0, 181de <MX_ADC1_Init+0x162>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_16;
   1816e:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_4;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18170:	f646 2074 	movw	r0, #27252	; 0x6a74
  sConfig.Rank = ADC_REGULAR_RANK_4;
   18174:	2218      	movs	r2, #24
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18176:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_16;
   18178:	f2c4 3321 	movt	r3, #17185	; 0x4321
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1817c:	f2c0 200e 	movt	r0, #526	; 0x20e
  sConfig.Channel = ADC_CHANNEL_16;
   18180:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18184:	f7f0 fafc 	bl	8780 <HAL_ADC_ConfigChannel>
   18188:	bb30      	cbnz	r0, 181d8 <MX_ADC1_Init+0x15c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_15;
   1818a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  sConfig.Rank = ADC_REGULAR_RANK_5;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1818e:	f646 2074 	movw	r0, #27252	; 0x6a74
  sConfig.Rank = ADC_REGULAR_RANK_5;
   18192:	f44f 7280 	mov.w	r2, #256	; 0x100
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   18196:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_15;
   18198:	f6c3 63f0 	movt	r3, #16112	; 0x3ef0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1819c:	f2c0 200e 	movt	r0, #526	; 0x20e
  sConfig.Channel = ADC_CHANNEL_15;
   181a0:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   181a4:	f7f0 faec 	bl	8780 <HAL_ADC_ConfigChannel>
   181a8:	b998      	cbnz	r0, 181d2 <MX_ADC1_Init+0x156>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_8;
   181aa:	f44f 7380 	mov.w	r3, #256	; 0x100
  sConfig.Rank = ADC_REGULAR_RANK_6;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   181ae:	f646 2074 	movw	r0, #27252	; 0x6a74
  sConfig.Rank = ADC_REGULAR_RANK_6;
   181b2:	f44f 7283 	mov.w	r2, #262	; 0x106
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   181b6:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_8;
   181b8:	f2c2 1380 	movt	r3, #8576	; 0x2180
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   181bc:	f2c0 200e 	movt	r0, #526	; 0x20e
  sConfig.Channel = ADC_CHANNEL_8;
   181c0:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   181c4:	f7f0 fadc 	bl	8780 <HAL_ADC_ConfigChannel>
   181c8:	b108      	cbz	r0, 181ce <MX_ADC1_Init+0x152>
  {
    Error_Handler();
   181ca:	f002 ff6f 	bl	1b0ac <Error_Handler>
  }

}
   181ce:	b00a      	add	sp, #40	; 0x28
   181d0:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
   181d2:	f002 ff6b 	bl	1b0ac <Error_Handler>
   181d6:	e7e8      	b.n	181aa <MX_ADC1_Init+0x12e>
    Error_Handler();
   181d8:	f002 ff68 	bl	1b0ac <Error_Handler>
   181dc:	e7d5      	b.n	1818a <MX_ADC1_Init+0x10e>
    Error_Handler();
   181de:	f002 ff65 	bl	1b0ac <Error_Handler>
   181e2:	e7c4      	b.n	1816e <MX_ADC1_Init+0xf2>
    Error_Handler();
   181e4:	f002 ff62 	bl	1b0ac <Error_Handler>
   181e8:	e7b2      	b.n	18150 <MX_ADC1_Init+0xd4>
    Error_Handler();
   181ea:	f002 ff5f 	bl	1b0ac <Error_Handler>
   181ee:	e79f      	b.n	18130 <MX_ADC1_Init+0xb4>
    Error_Handler();
   181f0:	f002 ff5c 	bl	1b0ac <Error_Handler>
   181f4:	e784      	b.n	18100 <MX_ADC1_Init+0x84>
    Error_Handler();
   181f6:	f002 ff59 	bl	1b0ac <Error_Handler>
   181fa:	e776      	b.n	180ea <MX_ADC1_Init+0x6e>

000181fc <HAL_ADC_MspInit>:
void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
  if(adcHandle->Instance==ADC1)
   181fc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
   18200:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(adcHandle->Instance==ADC1)
   18204:	f2c4 0302 	movt	r3, #16386	; 0x4002
   18208:	6802      	ldr	r2, [r0, #0]
{
   1820a:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1820c:	2400      	movs	r4, #0
  if(adcHandle->Instance==ADC1)
   1820e:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18210:	940d      	str	r4, [sp, #52]	; 0x34
   18212:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
   18216:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
   1821a:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1821e:	e9cd 4406 	strd	r4, r4, [sp, #24]
  if(adcHandle->Instance==ADC1)
   18222:	d002      	beq.n	1822a <HAL_ADC_MspInit+0x2e>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
   18224:	b00f      	add	sp, #60	; 0x3c
   18226:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_ADC12_CLK_ENABLE();
   1822a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
   1822e:	2122      	movs	r1, #34	; 0x22
   18230:	4606      	mov	r6, r0
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18232:	f44f 6000 	mov.w	r0, #2048	; 0x800
    __HAL_RCC_ADC12_CLK_ENABLE();
   18236:	f6c5 0302 	movt	r3, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1823a:	2703      	movs	r7, #3
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1823c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    hdma_adc1.Instance = DMA2_Stream0;
   18240:	f646 25d8 	movw	r5, #27352	; 0x6ad8
    __HAL_RCC_ADC12_CLK_ENABLE();
   18244:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    hdma_adc1.Instance = DMA2_Stream0;
   18248:	f2c0 250e 	movt	r5, #526	; 0x20e
    __HAL_RCC_ADC12_CLK_ENABLE();
   1824c:	f042 0220 	orr.w	r2, r2, #32
   18250:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   18254:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   18258:	f002 0220 	and.w	r2, r2, #32
   1825c:	9201      	str	r2, [sp, #4]
   1825e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
   18260:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   18264:	f042 0204 	orr.w	r2, r2, #4
   18268:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1826c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   18270:	f002 0204 	and.w	r2, r2, #4
   18274:	9202      	str	r2, [sp, #8]
   18276:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
   18278:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1827c:	f042 0201 	orr.w	r2, r2, #1
   18280:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   18284:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
   18288:	9109      	str	r1, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1828a:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
   1828c:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   18290:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
   18292:	9303      	str	r3, [sp, #12]
   18294:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18296:	f7f4 f97f 	bl	c598 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   1829a:	4620      	mov	r0, r4
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
   1829c:	23ad      	movs	r3, #173	; 0xad
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   1829e:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   182a0:	970a      	str	r7, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   182a2:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
   182a6:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   182a8:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   182aa:	f7f4 f975 	bl	c598 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream0;
   182ae:	f44f 6382 	mov.w	r3, #1040	; 0x410
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
   182b2:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
   182b6:	f04f 0e09 	mov.w	lr, #9
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   182ba:	f44f 6c00 	mov.w	ip, #2048	; 0x800
    hdma_adc1.Instance = DMA2_Stream0;
   182be:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   182c2:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
   182c6:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
   182ca:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_adc1.Instance = DMA2_Stream0;
   182ce:	602b      	str	r3, [r5, #0]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   182d0:	2304      	movs	r3, #4
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
   182d2:	6128      	str	r0, [r5, #16]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
   182d4:	4628      	mov	r0, r5
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
   182d6:	60ac      	str	r4, [r5, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
   182d8:	60ec      	str	r4, [r5, #12]
    hdma_adc1.Init.PeriphBurst = DMA_PBURST_SINGLE;
   182da:	632c      	str	r4, [r5, #48]	; 0x30
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
   182dc:	f8c5 e004 	str.w	lr, [r5, #4]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   182e0:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_adc1.Init.MemBurst = DMA_MBURST_SINGLE;
   182e2:	e9c5 440a 	strd	r4, r4, [r5, #40]	; 0x28
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   182e6:	e9c5 c705 	strd	ip, r7, [r5, #20]
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
   182ea:	e9c5 1207 	strd	r1, r2, [r5, #28]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
   182ee:	f7f1 fee9 	bl	a0c4 <HAL_DMA_Init>
   182f2:	bb18      	cbnz	r0, 1833c <HAL_ADC_MspInit+0x140>
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   182f4:	f04f 0900 	mov.w	r9, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   182f8:	f646 20d8 	movw	r0, #27352	; 0x6ad8
    pSyncConfig.EventEnable = ENABLE;
   182fc:	2301      	movs	r3, #1
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   182fe:	f04f 0806 	mov.w	r8, #6
   18302:	f2c0 0902 	movt	r9, #2
    pSyncConfig.SyncEnable = DISABLE;
   18306:	2200      	movs	r2, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   18308:	a904      	add	r1, sp, #16
   1830a:	f2c0 200e 	movt	r0, #526	; 0x20e
    pSyncConfig.SyncEnable = DISABLE;
   1830e:	f88d 2018 	strb.w	r2, [sp, #24]
    pSyncConfig.EventEnable = ENABLE;
   18312:	f88d 3019 	strb.w	r3, [sp, #25]
    pSyncConfig.RequestNumber = 1;
   18316:	9307      	str	r3, [sp, #28]
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   18318:	e9cd 8904 	strd	r8, r9, [sp, #16]
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   1831c:	f7f3 fc1c 	bl	bb58 <HAL_DMAEx_ConfigMuxSync>
   18320:	b978      	cbnz	r0, 18342 <HAL_ADC_MspInit+0x146>
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   18322:	2200      	movs	r2, #0
   18324:	2105      	movs	r1, #5
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
   18326:	64f5      	str	r5, [r6, #76]	; 0x4c
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   18328:	2012      	movs	r0, #18
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
   1832a:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   1832c:	f7f1 fca6 	bl	9c7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
   18330:	2012      	movs	r0, #18
   18332:	f7f1 fcf3 	bl	9d1c <HAL_NVIC_EnableIRQ>
}
   18336:	b00f      	add	sp, #60	; 0x3c
   18338:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      Error_Handler();
   1833c:	f002 feb6 	bl	1b0ac <Error_Handler>
   18340:	e7d8      	b.n	182f4 <HAL_ADC_MspInit+0xf8>
      Error_Handler();
   18342:	f002 feb3 	bl	1b0ac <Error_Handler>
   18346:	e7ec      	b.n	18322 <HAL_ADC_MspInit+0x126>

00018348 <audioFrame>:
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void audioFrame(uint16_t buffer_offset)
{
   18348:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1834c:	ed2d 8b04 	vpush	{d8-d9}
   18350:	b089      	sub	sp, #36	; 0x24
   18352:	9000      	str	r0, [sp, #0]
	//int32_t current_sample;
	uint32_t clipCatcher = 0;

	//tempCount5 = DWT->CYCCNT;

	buttonCheck();
   18354:	f00d f9aa 	bl	256ac <buttonCheck>

	adcCheck();
   18358:	f00d fd94 	bl	25e84 <adcCheck>

	// if the USB write pointer has advanced (indicating unread data is in the buffer),
	// or the overflow bit is set, meaning that the write pointer wrapped around and the read pointer hasn't caught up to it yet
	// then process that new data this frame
	if ((myUSB_FIFO_overflowBit) || (myUSB_FIFO_writePointer > myUSB_FIFO_readPointer))
   1835c:	f646 13bd 	movw	r3, #27069	; 0x69bd
   18360:	f2c0 230e 	movt	r3, #526	; 0x20e
   18364:	781b      	ldrb	r3, [r3, #0]
   18366:	2b00      	cmp	r3, #0
   18368:	f040 81bc 	bne.w	186e4 <audioFrame+0x39c>
   1836c:	f646 12c0 	movw	r2, #27072	; 0x69c0
   18370:	f646 13be 	movw	r3, #27070	; 0x69be
   18374:	f2c0 220e 	movt	r2, #526	; 0x20e
   18378:	f2c0 230e 	movt	r3, #526	; 0x20e
   1837c:	8812      	ldrh	r2, [r2, #0]
   1837e:	881b      	ldrh	r3, [r3, #0]
   18380:	4293      	cmp	r3, r2
   18382:	f0c0 81af 	bcc.w	186e4 <audioFrame+0x39c>
	{
		ProcessReceivedMidiDatas();
	}


	if (!loadingPreset)
   18386:	f646 13bb 	movw	r3, #27067	; 0x69bb
   1838a:	f2c0 230e 	movt	r3, #526	; 0x20e
   1838e:	9303      	str	r3, [sp, #12]
   18390:	781b      	ldrb	r3, [r3, #0]
   18392:	2b00      	cmp	r3, #0
   18394:	d163      	bne.n	1845e <audioFrame+0x116>
   18396:	f24a 6468 	movw	r4, #42600	; 0xa668
   1839a:	f24a 6708 	movw	r7, #42504	; 0xa608
   1839e:	f646 15b9 	movw	r5, #27065	; 0x69b9
   183a2:	f646 1aba 	movw	sl, #27066	; 0x69ba
   183a6:	f2c0 240f 	movt	r4, #527	; 0x20f
   183aa:	f64c 2678 	movw	r6, #51832	; 0xca78
   183ae:	f2c0 270f 	movt	r7, #527	; 0x20f
   183b2:	f2c0 250e 	movt	r5, #526	; 0x20e
   183b6:	46a0      	mov	r8, r4
   183b8:	f104 0918 	add.w	r9, r4, #24
   183bc:	f2c0 2a0e 	movt	sl, #526	; 0x20e
   183c0:	f2c0 260f 	movt	r6, #527	; 0x20f
	{

		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
		{
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
   183c4:	4638      	mov	r0, r7
   183c6:	3704      	adds	r7, #4
   183c8:	f013 f800 	bl	2b3cc <tExpSmooth_tick>
			for (int i = 0; i < KNOB_PAGE_SIZE; i++)
			{
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   183cc:	f895 b000 	ldrb.w	fp, [r5]
   183d0:	f89a 3000 	ldrb.w	r3, [sl]
   183d4:	eb0b 028b 	add.w	r2, fp, fp, lsl #2
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
   183d8:	eca8 0a01 	vstmia	r8!, {s0}
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   183dc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   183e0:	ed94 7a00 	vldr	s14, [r4]
   183e4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   183e8:	edd4 7a01 	vldr	s15, [r4, #4]
   183ec:	f103 0c01 	add.w	ip, r3, #1
   183f0:	1c98      	adds	r0, r3, #2
   183f2:	eb02 0e03 	add.w	lr, r2, r3
   183f6:	1cd9      	adds	r1, r3, #3
   183f8:	4494      	add	ip, r2
   183fa:	3304      	adds	r3, #4
   183fc:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   18400:	4410      	add	r0, r2
   18402:	eb06 0c8c 	add.w	ip, r6, ip, lsl #2
   18406:	4411      	add	r1, r2
   18408:	ed8e 7a00 	vstr	s14, [lr]
   1840c:	eb06 0080 	add.w	r0, r6, r0, lsl #2
   18410:	4413      	add	r3, r2
   18412:	f8d4 e008 	ldr.w	lr, [r4, #8]
   18416:	edcc 7a00 	vstr	s15, [ip]
   1841a:	eb06 0181 	add.w	r1, r6, r1, lsl #2
   1841e:	f8c0 e000 	str.w	lr, [r0]
   18422:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   18426:	f8d4 c00c 	ldr.w	ip, [r4, #12]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   1842a:	45c1      	cmp	r9, r8
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   1842c:	6920      	ldr	r0, [r4, #16]
   1842e:	f8c1 c000 	str.w	ip, [r1]
   18432:	6018      	str	r0, [r3, #0]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   18434:	d1c6      	bne.n	183c4 <audioFrame+0x7c>
			}
		}


		if (cvAddParam[currentPreset] >= 0)
   18436:	f64e 43a0 	movw	r3, #60576	; 0xeca0
   1843a:	f2c0 230f 	movt	r3, #527	; 0x20f
   1843e:	f913 300b 	ldrsb.w	r3, [r3, fp]
   18442:	2b00      	cmp	r3, #0
   18444:	db04      	blt.n	18450 <audioFrame+0x108>
		{
			presetKnobValues[currentPreset][cvAddParam[currentPreset]] = smoothedADC[5];
   18446:	441a      	add	r2, r3
   18448:	6963      	ldr	r3, [r4, #20]
   1844a:	eb06 0282 	add.w	r2, r6, r2, lsl #2
   1844e:	6013      	str	r3, [r2, #0]
		}

		frameFunctions[currentPreset]();
   18450:	f24a 6320 	movw	r3, #42528	; 0xa620
   18454:	f2c0 230f 	movt	r3, #527	; 0x20f
   18458:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
   1845c:	4798      	blx	r3
	//if the codec isn't ready, keep the buffer as all zeros
	//otherwise, start computing audio!

	bufferCleared = TRUE;

	if (codecReady)
   1845e:	f646 0360 	movw	r3, #26720	; 0x6860
	bufferCleared = TRUE;
   18462:	f246 010d 	movw	r1, #24589	; 0x600d
   18466:	2201      	movs	r2, #1
	if (codecReady)
   18468:	f2c0 230e 	movt	r3, #526	; 0x20e
	bufferCleared = TRUE;
   1846c:	f2c0 0106 	movt	r1, #6
	if (codecReady)
   18470:	781b      	ldrb	r3, [r3, #0]
	bufferCleared = TRUE;
   18472:	9105      	str	r1, [sp, #20]
   18474:	700a      	strb	r2, [r1, #0]
	if (codecReady)
   18476:	2b00      	cmp	r3, #0
   18478:	f000 8137 	beq.w	186ea <audioFrame+0x3a2>
	//uint32_t tempCount5 = DWT->CYCCNT;

	//cycleCountVals[1][2] = 0;


	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   1847c:	f64f 71ef 	movw	r1, #65519	; 0xffef
   18480:	9c00      	ldr	r4, [sp, #0]
	{
		clips |= 2;
	}


	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18482:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   18486:	f246 5a20 	movw	sl, #25888	; 0x6520
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   1848a:	460a      	mov	r2, r1
   1848c:	1c65      	adds	r5, r4, #1
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   1848e:	f2c4 33ff 	movt	r3, #17407	; 0x43ff
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   18492:	f64f 70f6 	movw	r0, #65526	; 0xfff6
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18496:	f24a 6480 	movw	r4, #42624	; 0xa680
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   1849a:	f6cb 717f 	movt	r1, #49023	; 0xbf7f
   1849e:	f2c0 0a06 	movt	sl, #6
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   184a2:	f6c2 70ff 	movt	r0, #12287	; 0x2fff
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   184a6:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
	uint32_t clipCatcher = 0;
   184aa:	2600      	movs	r6, #0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   184ac:	ee08 3a90 	vmov	s17, r3
   184b0:	f2c0 240f 	movt	r4, #527	; 0x20f
   184b4:	9b03      	ldr	r3, [sp, #12]
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   184b6:	ee09 1a90 	vmov	s19, r1
	uint32_t clipCatcher = 0;
   184ba:	9601      	str	r6, [sp, #4]
   184bc:	f50a 6b00 	add.w	fp, sl, #2048	; 0x800
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   184c0:	ee08 0a10 	vmov	s16, r0
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   184c4:	ee09 2a10 	vmov	s18, r2
   184c8:	00ad      	lsls	r5, r5, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   184ca:	9404      	str	r4, [sp, #16]
   184cc:	7819      	ldrb	r1, [r3, #0]
   184ce:	e00b      	b.n	184e8 <audioFrame+0x1a0>
	if (loadingPreset)
   184d0:	2300      	movs	r3, #0
   184d2:	461a      	mov	r2, r3
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
   184d4:	3602      	adds	r6, #2
			audioOutBuffer[buffer_offset + i] = (int32_t)(theSamples[1] * TWO_TO_23);
   184d6:	f84b 2024 	str.w	r2, [fp, r4, lsl #2]
			audioOutBuffer[buffer_offset + i + 1] = (int32_t)(theSamples[0] * TWO_TO_23);
   184da:	f84b 3005 	str.w	r3, [fp, r5]
   184de:	3508      	adds	r5, #8
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
   184e0:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   184e4:	f000 8154 	beq.w	18790 <audioFrame+0x448>
   184e8:	9b00      	ldr	r3, [sp, #0]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   184ea:	f85a 2005 	ldr.w	r2, [sl, r5]
   184ee:	18f4      	adds	r4, r6, r3
   184f0:	0212      	lsls	r2, r2, #8
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   184f2:	f85a 3024 	ldr.w	r3, [sl, r4, lsl #2]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   184f6:	ee00 2a90 	vmov	s1, r2
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   184fa:	021b      	lsls	r3, r3, #8
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   184fc:	eef8 0ae0 	vcvt.f32.s32	s1, s1
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   18500:	ee07 3a90 	vmov	s15, r3
   18504:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   18508:	ee60 0a88 	vmul.f32	s1, s1, s16
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   1850c:	ee67 7a88 	vmul.f32	s15, s15, s16
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   18510:	edcd 0a07 	vstr	s1, [sp, #28]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   18514:	edcd 7a06 	vstr	s15, [sp, #24]
	if (loadingPreset)
   18518:	2900      	cmp	r1, #0
   1851a:	d1d9      	bne.n	184d0 <audioFrame+0x188>
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   1851c:	eef4 0ae9 	vcmpe.f32	s1, s19
   18520:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   18524:	eef4 0ac9 	vcmpe.f32	s1, s18
   18528:	bf94      	ite	ls
   1852a:	f04f 0801 	movls.w	r8, #1
   1852e:	f04f 0800 	movhi.w	r8, #0
   18532:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   18536:	eef4 7ac9 	vcmpe.f32	s15, s18
	uint32_t clips = 0;
   1853a:	bfa8      	it	ge
   1853c:	f048 0801 	orrge.w	r8, r8, #1
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   18540:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   18544:	da04      	bge.n	18550 <audioFrame+0x208>
   18546:	eef4 7a69 	vcmp.f32	s15, s19
   1854a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1854e:	d801      	bhi.n	18554 <audioFrame+0x20c>
		clips |= 2;
   18550:	f048 0802 	orr.w	r8, r8, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18554:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   18558:	f24a 6790 	movw	r7, #42640	; 0xa690
   1855c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   18560:	f64e 19d8 	movw	r9, #59864	; 0xe9d8
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18564:	f014 fc3c 	bl	2cde0 <LEAF_clip>
   18568:	9804      	ldr	r0, [sp, #16]
   1856a:	f00f f86d 	bl	27648 <tEnvelopeFollower_tick>
   1856e:	ee20 0a28 	vmul.f32	s0, s0, s17
   18572:	f2c0 270f 	movt	r7, #527	; 0x20f
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   18576:	f64e 2218 	movw	r2, #59928	; 0xea18
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   1857a:	a906      	add	r1, sp, #24
   1857c:	eddd 0a06 	vldr	s1, [sp, #24]
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18580:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   18584:	f2c0 220f 	movt	r2, #527	; 0x20f
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18588:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   1858c:	9102      	str	r1, [sp, #8]
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   1858e:	6810      	ldr	r0, [r2, #0]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18590:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18594:	ee17 3a90 	vmov	r3, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   18598:	f2c0 290f 	movt	r9, #527	; 0x20f
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   1859c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   185a0:	edd3 7a00 	vldr	s15, [r3]
   185a4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   185a8:	ee17 3a90 	vmov	r3, s15
   185ac:	b29b      	uxth	r3, r3
   185ae:	6383      	str	r3, [r0, #56]	; 0x38
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   185b0:	f014 fc16 	bl	2cde0 <LEAF_clip>
   185b4:	f24a 6088 	movw	r0, #42632	; 0xa688
   185b8:	f2c0 200f 	movt	r0, #527	; 0x20f
   185bc:	f00f f844 	bl	27648 <tEnvelopeFollower_tick>
   185c0:	ee20 0a28 	vmul.f32	s0, s0, s17


	tickFunctions[currentPreset](samples);
   185c4:	9902      	ldr	r1, [sp, #8]
   185c6:	f646 1eb9 	movw	lr, #27065	; 0x69b9
   185ca:	f24a 5c20 	movw	ip, #42272	; 0xa520
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   185ce:	f8d9 3000 	ldr.w	r3, [r9]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   185d2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	tickFunctions[currentPreset](samples);
   185d6:	4608      	mov	r0, r1
   185d8:	f2c0 2e0e 	movt	lr, #526	; 0x20e
   185dc:	f2c0 2c0f 	movt	ip, #527	; 0x20f
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   185e0:	ee17 1a90 	vmov	r1, s15
	tickFunctions[currentPreset](samples);
   185e4:	f89e e000 	ldrb.w	lr, [lr]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   185e8:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   185ec:	edd1 7a00 	vldr	s15, [r1]
   185f0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   185f4:	ee17 2a90 	vmov	r2, s15
   185f8:	b291      	uxth	r1, r2
   185fa:	6399      	str	r1, [r3, #56]	; 0x38
	tickFunctions[currentPreset](samples);
   185fc:	f85c 302e 	ldr.w	r3, [ip, lr, lsl #2]
   18600:	4798      	blx	r3

	//now the samples array is output
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   18602:	eddd 0a07 	vldr	s1, [sp, #28]
   18606:	eef4 0ac9 	vcmpe.f32	s1, s18
   1860a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1860e:	da04      	bge.n	1861a <audioFrame+0x2d2>
   18610:	eef4 0a69 	vcmp.f32	s1, s19
   18614:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   18618:	d801      	bhi.n	1861e <audioFrame+0x2d6>
	{
		clips |= 4;
   1861a:	f048 0804 	orr.w	r8, r8, #4
	}

	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   1861e:	eddd 7a06 	vldr	s15, [sp, #24]
   18622:	eef4 7ae9 	vcmpe.f32	s15, s19
   18626:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1862a:	d904      	bls.n	18636 <audioFrame+0x2ee>
   1862c:	eef4 7a49 	vcmp.f32	s15, s18
   18630:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   18634:	db01      	blt.n	1863a <audioFrame+0x2f2>
	{
		clips |= 8;
   18636:	f048 0808 	orr.w	r8, r8, #8
   1863a:	9b01      	ldr	r3, [sp, #4]
	}
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   1863c:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   18640:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   18644:	ea43 0308 	orr.w	r3, r3, r8
   18648:	9301      	str	r3, [sp, #4]
   1864a:	f014 fbc9 	bl	2cde0 <LEAF_clip>
   1864e:	f24a 6084 	movw	r0, #42628	; 0xa684
   18652:	f2c0 200f 	movt	r0, #527	; 0x20f
   18656:	f00e fff7 	bl	27648 <tEnvelopeFollower_tick>
   1865a:	ee60 7a28 	vmul.f32	s15, s0, s17
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
   1865e:	f8d9 3000 	ldr.w	r3, [r9]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   18662:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   18666:	eddd 0a06 	vldr	s1, [sp, #24]
   1866a:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   1866e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   18672:	ee17 1a90 	vmov	r1, s15
   18676:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   1867a:	edd1 7a00 	vldr	s15, [r1]
   1867e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
   18682:	ee17 2a90 	vmov	r2, s15
   18686:	b291      	uxth	r1, r2
   18688:	63d9      	str	r1, [r3, #60]	; 0x3c
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   1868a:	f014 fba9 	bl	2cde0 <LEAF_clip>
   1868e:	f24a 608c 	movw	r0, #42636	; 0xa68c
   18692:	f2c0 200f 	movt	r0, #527	; 0x20f
   18696:	f00e ffd7 	bl	27648 <tEnvelopeFollower_tick>
   1869a:	ee20 0a28 	vmul.f32	s0, s0, s17
   1869e:	9b03      	ldr	r3, [sp, #12]
   186a0:	ed9d 7a07 	vldr	s14, [sp, #28]
   186a4:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   186a8:	7819      	ldrb	r1, [r3, #0]
   186aa:	eddd 7a06 	vldr	s15, [sp, #24]
   186ae:	eef0 6a47 	vmov.f32	s13, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
   186b2:	f8d9 0000 	ldr.w	r0, [r9]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   186b6:	ee10 3a10 	vmov	r3, s0
   186ba:	eeb0 7a67 	vmov.f32	s14, s15
   186be:	eefe 6ae4 	vcvt.s32.f32	s13, s13, #23
   186c2:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   186c6:	eebe 7ae4 	vcvt.s32.f32	s14, s14, #23
   186ca:	edd7 7a00 	vldr	s15, [r7]
   186ce:	ee16 2a90 	vmov	r2, s13
   186d2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   186d6:	ee17 3a10 	vmov	r3, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
   186da:	ee17 7a90 	vmov	r7, s15
   186de:	b2bf      	uxth	r7, r7
   186e0:	6347      	str	r7, [r0, #52]	; 0x34
   186e2:	e6f7      	b.n	184d4 <audioFrame+0x18c>
		ProcessReceivedMidiDatas();
   186e4:	f7ff fc26 	bl	17f34 <ProcessReceivedMidiDatas>
   186e8:	e64d      	b.n	18386 <audioFrame+0x3e>
	uint32_t clipCatcher = 0;
   186ea:	9301      	str	r3, [sp, #4]
		numBuffersCleared++;
   186ec:	f646 0364 	movw	r3, #26724	; 0x6864
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   186f0:	f246 0110 	movw	r1, #24592	; 0x6010
		numBuffersCleared++;
   186f4:	f2c0 230e 	movt	r3, #526	; 0x20e
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   186f8:	f2c0 0106 	movt	r1, #6
		numBuffersCleared++;
   186fc:	681a      	ldr	r2, [r3, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   186fe:	6809      	ldr	r1, [r1, #0]
		numBuffersCleared++;
   18700:	3201      	adds	r2, #1
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   18702:	428a      	cmp	r2, r1
		numBuffersCleared++;
   18704:	601a      	str	r2, [r3, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   18706:	da50      	bge.n	187aa <audioFrame+0x462>
   18708:	f646 053c 	movw	r5, #26684	; 0x683c
   1870c:	f646 065c 	movw	r6, #26716	; 0x685c
			clipHappened[i] = 0;
   18710:	f646 084c 	movw	r8, #26700	; 0x684c
	uint32_t clipCatcher = 0;
   18714:	2400      	movs	r4, #0
   18716:	f2c0 250e 	movt	r5, #526	; 0x20e
   1871a:	f2c0 260e 	movt	r6, #526	; 0x20e
			clipHappened[i] = 0;
   1871e:	f2c0 280e 	movt	r8, #526	; 0x20e
			clipCounter[i] = 80;
   18722:	2750      	movs	r7, #80	; 0x50
   18724:	f8dd 9004 	ldr.w	r9, [sp, #4]
		if ((clipCatcher >> i) & 1)
   18728:	fa29 f304 	lsr.w	r3, r9, r4
   1872c:	07db      	lsls	r3, r3, #31
   1872e:	d51c      	bpl.n	1876a <audioFrame+0x422>
			switch (i)
   18730:	2c02      	cmp	r4, #2
   18732:	f000 8082 	beq.w	1883a <audioFrame+0x4f2>
   18736:	2c03      	cmp	r4, #3
   18738:	d07b      	beq.n	18832 <audioFrame+0x4ea>
   1873a:	2c01      	cmp	r4, #1
   1873c:	d075      	beq.n	1882a <audioFrame+0x4e2>
					setLED_leftin_clip(1);
   1873e:	2001      	movs	r0, #1
   18740:	f002 fd46 	bl	1b1d0 <setLED_leftin_clip>
			clipped[i] = 1;
   18744:	2101      	movs	r1, #1
			clipHappened[i] = 0;
   18746:	2200      	movs	r2, #0
   18748:	00a3      	lsls	r3, r4, #2
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   1874a:	2050      	movs	r0, #80	; 0x50
			clipCounter[i] = 80;
   1874c:	f845 7024 	str.w	r7, [r5, r4, lsl #2]
			clipped[i] = 1;
   18750:	5531      	strb	r1, [r6, r4]
			clipHappened[i] = 0;
   18752:	f848 2024 	str.w	r2, [r8, r4, lsl #2]
			clipCounter[i]--;
   18756:	3801      	subs	r0, #1
   18758:	50e8      	str	r0, [r5, r3]
	for (int i = 0; i < 4; i++)
   1875a:	3401      	adds	r4, #1
   1875c:	2c04      	cmp	r4, #4
   1875e:	d1e3      	bne.n	18728 <audioFrame+0x3e0>
}
   18760:	b009      	add	sp, #36	; 0x24
   18762:	ecbd 8b04 	vpop	{d8-d9}
   18766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   1876a:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   1876e:	00a3      	lsls	r3, r4, #2
   18770:	5d32      	ldrb	r2, [r6, r4]
   18772:	2800      	cmp	r0, #0
   18774:	d16e      	bne.n	18854 <audioFrame+0x50c>
		else if ((clipCounter[i] == 0) && (clipped[i] == 1))
   18776:	2a01      	cmp	r2, #1
   18778:	d1ef      	bne.n	1875a <audioFrame+0x412>
			switch (i)
   1877a:	2c02      	cmp	r4, #2
   1877c:	d061      	beq.n	18842 <audioFrame+0x4fa>
   1877e:	2c03      	cmp	r4, #3
   18780:	d065      	beq.n	1884e <audioFrame+0x506>
   18782:	2c01      	cmp	r4, #1
   18784:	d060      	beq.n	18848 <audioFrame+0x500>
					setLED_leftin_clip(0);
   18786:	f002 fd23 	bl	1b1d0 <setLED_leftin_clip>
			clipped[i] = 0;
   1878a:	2300      	movs	r3, #0
   1878c:	5533      	strb	r3, [r6, r4]
   1878e:	e7e4      	b.n	1875a <audioFrame+0x412>
			bufferCleared = 0;
   18790:	9b05      	ldr	r3, [sp, #20]
		if (!loadingPreset)
   18792:	2900      	cmp	r1, #0
   18794:	d047      	beq.n	18826 <audioFrame+0x4de>
	if (bufferCleared)
   18796:	781b      	ldrb	r3, [r3, #0]
   18798:	2b00      	cmp	r3, #0
   1879a:	d1a7      	bne.n	186ec <audioFrame+0x3a4>
	else numBuffersCleared = 0;
   1879c:	f646 0364 	movw	r3, #26724	; 0x6864
   187a0:	2200      	movs	r2, #0
   187a2:	f2c0 230e 	movt	r3, #526	; 0x20e
   187a6:	601a      	str	r2, [r3, #0]
   187a8:	e7ae      	b.n	18708 <audioFrame+0x3c0>
			if (loadingPreset)
   187aa:	9a03      	ldr	r2, [sp, #12]
			numBuffersCleared = numBuffersToClearOnLoad;
   187ac:	6019      	str	r1, [r3, #0]
			if (loadingPreset)
   187ae:	7812      	ldrb	r2, [r2, #0]
   187b0:	2a00      	cmp	r2, #0
   187b2:	d0a9      	beq.n	18708 <audioFrame+0x3c0>
				if (previousPreset != PresetNil)
   187b4:	f246 23d0 	movw	r3, #25296	; 0x62d0
   187b8:	f2c0 0306 	movt	r3, #6
   187bc:	781a      	ldrb	r2, [r3, #0]
   187be:	2a12      	cmp	r2, #18
   187c0:	d006      	beq.n	187d0 <audioFrame+0x488>
					freeFunctions[previousPreset]();
   187c2:	f24a 536c 	movw	r3, #42348	; 0xa56c
   187c6:	f2c0 230f 	movt	r3, #527	; 0x20f
   187ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   187ce:	4798      	blx	r3
				setLED_A(0);
   187d0:	2000      	movs	r0, #0
				knobPage = 0;
   187d2:	4604      	mov	r4, r0
				setLED_A(0);
   187d4:	f002 fcae 	bl	1b134 <setLED_A>
				setLED_B(0);
   187d8:	4620      	mov	r0, r4
   187da:	f002 fcbb 	bl	1b154 <setLED_B>
				setLED_C(0);
   187de:	4620      	mov	r0, r4
   187e0:	f002 fcc8 	bl	1b174 <setLED_C>
				setLED_Edit(0);
   187e4:	4620      	mov	r0, r4
   187e6:	f002 fc65 	bl	1b0b4 <setLED_Edit>
				setLED_1(0);
   187ea:	4620      	mov	r0, r4
   187ec:	f002 fc82 	bl	1b0f4 <setLED_1>
				knobPage = 0;
   187f0:	f646 13ba 	movw	r3, #27066	; 0x69ba
   187f4:	f2c0 230e 	movt	r3, #526	; 0x20e
   187f8:	701c      	strb	r4, [r3, #0]
				resetKnobValues();
   187fa:	f00d fc65 	bl	260c8 <resetKnobValues>
				allocFunctions[currentPreset]();
   187fe:	f646 11b9 	movw	r1, #27065	; 0x69b9
				leaf.clearOnAllocation = 0;
   18802:	f64f 0208 	movw	r2, #63496	; 0xf808
				allocFunctions[currentPreset]();
   18806:	f24a 53bc 	movw	r3, #42428	; 0xa5bc
   1880a:	f2c0 210e 	movt	r1, #526	; 0x20e
				leaf.clearOnAllocation = 0;
   1880e:	f2c0 220f 	movt	r2, #527	; 0x20f
				allocFunctions[currentPreset]();
   18812:	f2c0 230f 	movt	r3, #527	; 0x20f
   18816:	7809      	ldrb	r1, [r1, #0]
				leaf.clearOnAllocation = 0;
   18818:	6154      	str	r4, [r2, #20]
				allocFunctions[currentPreset]();
   1881a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   1881e:	4798      	blx	r3
				loadingPreset = 0;
   18820:	9b03      	ldr	r3, [sp, #12]
   18822:	701c      	strb	r4, [r3, #0]
   18824:	e770      	b.n	18708 <audioFrame+0x3c0>
			bufferCleared = 0;
   18826:	7019      	strb	r1, [r3, #0]
   18828:	e7b8      	b.n	1879c <audioFrame+0x454>
					setLED_rightin_clip(1);
   1882a:	4620      	mov	r0, r4
   1882c:	f002 fce0 	bl	1b1f0 <setLED_rightin_clip>
					break;
   18830:	e788      	b.n	18744 <audioFrame+0x3fc>
					setLED_rightout_clip(1);
   18832:	2001      	movs	r0, #1
   18834:	f002 fcbe 	bl	1b1b4 <setLED_rightout_clip>
					break;
   18838:	e784      	b.n	18744 <audioFrame+0x3fc>
					setLED_leftout_clip(1);
   1883a:	2001      	movs	r0, #1
   1883c:	f002 fcac 	bl	1b198 <setLED_leftout_clip>
					break;
   18840:	e780      	b.n	18744 <audioFrame+0x3fc>
					setLED_leftout_clip(0);
   18842:	f002 fca9 	bl	1b198 <setLED_leftout_clip>
					break;
   18846:	e7a0      	b.n	1878a <audioFrame+0x442>
					setLED_rightin_clip(0);
   18848:	f002 fcd2 	bl	1b1f0 <setLED_rightin_clip>
					break;
   1884c:	e79d      	b.n	1878a <audioFrame+0x442>
					setLED_rightout_clip(0);
   1884e:	f002 fcb1 	bl	1b1b4 <setLED_rightout_clip>
					break;
   18852:	e79a      	b.n	1878a <audioFrame+0x442>
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   18854:	2a01      	cmp	r2, #1
   18856:	d180      	bne.n	1875a <audioFrame+0x412>
   18858:	e77d      	b.n	18756 <audioFrame+0x40e>
   1885a:	bf00      	nop

0001885c <initFunctionPointers>:
}

*/

void initFunctionPointers(void)
{
   1885c:	b4f0      	push	{r4, r5, r6, r7}
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   1885e:	f24a 50bc 	movw	r0, #42428	; 0xa5bc
   18862:	f24c 740d 	movw	r4, #50957	; 0xc70d
	frameFunctions[Vocoder] = SFXVocoderFrame;
	tickFunctions[Vocoder] = SFXVocoderTick;
	freeFunctions[Vocoder] = SFXVocoderFree;

	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   18866:	f64c 6129 	movw	r1, #52777	; 0xce29
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
	tickFunctions[VocoderCh] = SFXVocoderChTick;
	freeFunctions[VocoderCh] = SFXVocoderChFree;

	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   1886a:	f64d 63f9 	movw	r3, #57081	; 0xdef9
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   1886e:	f2c0 200f 	movt	r0, #527	; 0x20f
   18872:	f2c0 0401 	movt	r4, #1
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
	freeFunctions[Pitchshift] = SFXPitchShiftFree;

	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   18876:	f24e 2751 	movw	r7, #57937	; 0xe251
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
	freeFunctions[AutotuneMono] = SFXNeartuneFree;

	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   1887a:	f24e 4251 	movw	r2, #58449	; 0xe451
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   1887e:	6004      	str	r4, [r0, #0]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
	freeFunctions[AutotunePoly] = SFXAutotuneFree;

	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   18880:	f24e 6679 	movw	r6, #59001	; 0xe679
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;

	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   18884:	f64e 258d 	movw	r5, #60045	; 0xea8d
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;

	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   18888:	f24f 6441 	movw	r4, #63041	; 0xf641
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   1888c:	f2c0 0101 	movt	r1, #1
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   18890:	f2c0 0301 	movt	r3, #1
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   18894:	f2c0 0701 	movt	r7, #1
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   18898:	f2c0 0201 	movt	r2, #1
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   1889c:	f2c0 0601 	movt	r6, #1
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   188a0:	f2c0 0501 	movt	r5, #1
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   188a4:	f2c0 0401 	movt	r4, #1
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   188a8:	6041      	str	r1, [r0, #4]
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   188aa:	6083      	str	r3, [r0, #8]
	frameFunctions[Vocoder] = SFXVocoderFrame;
   188ac:	f24a 6120 	movw	r1, #42528	; 0xa620
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   188b0:	60c7      	str	r7, [r0, #12]
	frameFunctions[Vocoder] = SFXVocoderFrame;
   188b2:	f64c 03c9 	movw	r3, #51401	; 0xc8c9
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   188b6:	6102      	str	r2, [r0, #16]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   188b8:	f24d 3745 	movw	r7, #54085	; 0xd345
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   188bc:	6146      	str	r6, [r0, #20]
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   188be:	f64d 72c9 	movw	r2, #57289	; 0xdfc9
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   188c2:	6185      	str	r5, [r0, #24]
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   188c4:	f24e 3641 	movw	r6, #58177	; 0xe341
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   188c8:	61c4      	str	r4, [r0, #28]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   188ca:	f24e 457d 	movw	r5, #58493	; 0xe47d
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   188ce:	f24e 7431 	movw	r4, #59185	; 0xe731
	frameFunctions[Vocoder] = SFXVocoderFrame;
   188d2:	f2c0 210f 	movt	r1, #527	; 0x20f
   188d6:	f2c0 0301 	movt	r3, #1
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   188da:	f2c0 0701 	movt	r7, #1
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   188de:	f2c0 0201 	movt	r2, #1
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   188e2:	f2c0 0601 	movt	r6, #1
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   188e6:	f2c0 0501 	movt	r5, #1
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   188ea:	f2c0 0401 	movt	r4, #1
	frameFunctions[Vocoder] = SFXVocoderFrame;
   188ee:	600b      	str	r3, [r1, #0]
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   188f0:	f64e 4345 	movw	r3, #60485	; 0xec45
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   188f4:	604f      	str	r7, [r1, #4]
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   188f6:	f24f 7795 	movw	r7, #63381	; 0xf795
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   188fa:	608a      	str	r2, [r1, #8]
	tickFunctions[Vocoder] = SFXVocoderTick;
   188fc:	f24a 5220 	movw	r2, #42272	; 0xa520
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   18900:	60ce      	str	r6, [r1, #12]
	tickFunctions[Vocoder] = SFXVocoderTick;
   18902:	f64c 368d 	movw	r6, #52109	; 0xcb8d
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   18906:	610d      	str	r5, [r1, #16]
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   18908:	f64d 25d9 	movw	r5, #56025	; 0xdad9
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   1890c:	614c      	str	r4, [r1, #20]
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   1890e:	f64d 74cd 	movw	r4, #57293	; 0xdfcd
	tickFunctions[Vocoder] = SFXVocoderTick;
   18912:	f2c0 220f 	movt	r2, #527	; 0x20f
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   18916:	f2c0 0301 	movt	r3, #1
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   1891a:	f2c0 0701 	movt	r7, #1
	tickFunctions[Vocoder] = SFXVocoderTick;
   1891e:	f2c0 0601 	movt	r6, #1
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   18922:	f2c0 0501 	movt	r5, #1
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   18926:	f2c0 0401 	movt	r4, #1
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   1892a:	618b      	str	r3, [r1, #24]
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   1892c:	f643 6385 	movw	r3, #16005	; 0x3e85
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   18930:	61cf      	str	r7, [r1, #28]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   18932:	f24e 578d 	movw	r7, #58765	; 0xe58d
	tickFunctions[Vocoder] = SFXVocoderTick;
   18936:	6016      	str	r6, [r2, #0]
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   18938:	f24e 7635 	movw	r6, #59189	; 0xe735
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   1893c:	6055      	str	r5, [r2, #4]
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   1893e:	f64e 7575 	movw	r5, #61301	; 0xef75
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   18942:	6094      	str	r4, [r2, #8]
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   18944:	f24f 74c1 	movw	r4, #63425	; 0xf7c1
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   18948:	f2c0 0302 	movt	r3, #2
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   1894c:	f2c0 0701 	movt	r7, #1
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   18950:	f2c0 0601 	movt	r6, #1
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   18954:	f2c0 0501 	movt	r5, #1
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   18958:	f2c0 0401 	movt	r4, #1
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   1895c:	60d3      	str	r3, [r2, #12]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   1895e:	6117      	str	r7, [r2, #16]
	freeFunctions[Vocoder] = SFXVocoderFree;
   18960:	f24a 536c 	movw	r3, #42348	; 0xa56c
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   18964:	6156      	str	r6, [r2, #20]
	freeFunctions[Vocoder] = SFXVocoderFree;
   18966:	f64c 57a1 	movw	r7, #52641	; 0xcda1
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   1896a:	6195      	str	r5, [r2, #24]
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   1896c:	f64d 6629 	movw	r6, #56873	; 0xde29
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   18970:	61d4      	str	r4, [r2, #28]
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   18972:	f24e 15f5 	movw	r5, #57845	; 0xe1f5
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   18976:	f24e 4425 	movw	r4, #58405	; 0xe425
	freeFunctions[Vocoder] = SFXVocoderFree;
   1897a:	f2c0 230f 	movt	r3, #527	; 0x20f
   1897e:	f2c0 0701 	movt	r7, #1
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   18982:	f2c0 0601 	movt	r6, #1
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   18986:	f2c0 0501 	movt	r5, #1
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   1898a:	f2c0 0401 	movt	r4, #1
	freeFunctions[Vocoder] = SFXVocoderFree;
   1898e:	601f      	str	r7, [r3, #0]
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   18990:	f24e 676d 	movw	r7, #58989	; 0xe66d
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   18994:	605e      	str	r6, [r3, #4]
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   18996:	f64e 2655 	movw	r6, #59989	; 0xea55
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   1899a:	609d      	str	r5, [r3, #8]
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   1899c:	f24f 6509 	movw	r5, #62985	; 0xf609
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   189a0:	60dc      	str	r4, [r3, #12]
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   189a2:	f64f 6461 	movw	r4, #65121	; 0xfe61
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   189a6:	f2c0 0701 	movt	r7, #1
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   189aa:	f2c0 0601 	movt	r6, #1
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   189ae:	f2c0 0501 	movt	r5, #1
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   189b2:	f2c0 0401 	movt	r4, #1
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   189b6:	611f      	str	r7, [r3, #16]

	allocFunctions[Distortion] = SFXDistortionAlloc;
   189b8:	f64f 67a9 	movw	r7, #65193	; 0xfea9
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   189bc:	615e      	str	r6, [r3, #20]
	frameFunctions[Distortion] = SFXDistortionFrame;
   189be:	f64f 769d 	movw	r6, #65437	; 0xff9d
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   189c2:	619d      	str	r5, [r3, #24]
	tickFunctions[Distortion] = SFXDistortionTick;
   189c4:	f240 057d 	movw	r5, #125	; 0x7d
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   189c8:	61dc      	str	r4, [r3, #28]
	freeFunctions[Distortion] = SFXDistortionFree;
   189ca:	f240 1489 	movw	r4, #393	; 0x189
	allocFunctions[Distortion] = SFXDistortionAlloc;
   189ce:	f2c0 0701 	movt	r7, #1
	frameFunctions[Distortion] = SFXDistortionFrame;
   189d2:	f2c0 0601 	movt	r6, #1
	tickFunctions[Distortion] = SFXDistortionTick;
   189d6:	f2c0 0502 	movt	r5, #2
	freeFunctions[Distortion] = SFXDistortionFree;
   189da:	f2c0 0402 	movt	r4, #2
	allocFunctions[Distortion] = SFXDistortionAlloc;
   189de:	6207      	str	r7, [r0, #32]

	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   189e0:	f240 17c1 	movw	r7, #449	; 0x1c1
	frameFunctions[Distortion] = SFXDistortionFrame;
   189e4:	620e      	str	r6, [r1, #32]
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   189e6:	f240 262d 	movw	r6, #557	; 0x22d
	tickFunctions[Distortion] = SFXDistortionTick;
   189ea:	6215      	str	r5, [r2, #32]
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   189ec:	f240 2559 	movw	r5, #601	; 0x259
	freeFunctions[Distortion] = SFXDistortionFree;
   189f0:	621c      	str	r4, [r3, #32]
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   189f2:	f240 3499 	movw	r4, #921	; 0x399
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   189f6:	f2c0 0702 	movt	r7, #2
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   189fa:	f2c0 0602 	movt	r6, #2
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   189fe:	f2c0 0502 	movt	r5, #2
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   18a02:	f2c0 0402 	movt	r4, #2
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   18a06:	6247      	str	r7, [r0, #36]	; 0x24

	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   18a08:	f240 37d1 	movw	r7, #977	; 0x3d1
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   18a0c:	624e      	str	r6, [r1, #36]	; 0x24
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   18a0e:	f240 4609 	movw	r6, #1033	; 0x409
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   18a12:	6255      	str	r5, [r2, #36]	; 0x24
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   18a14:	f240 4535 	movw	r5, #1077	; 0x435
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   18a18:	625c      	str	r4, [r3, #36]	; 0x24
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   18a1a:	f240 54e5 	movw	r4, #1509	; 0x5e5
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   18a1e:	f2c0 0702 	movt	r7, #2
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   18a22:	f2c0 0602 	movt	r6, #2
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   18a26:	f2c0 0502 	movt	r5, #2
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   18a2a:	f2c0 0402 	movt	r4, #2
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   18a2e:	6287      	str	r7, [r0, #40]	; 0x28

	allocFunctions[Delay] = SFXDelayAlloc;
   18a30:	f240 6705 	movw	r7, #1541	; 0x605
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   18a34:	628e      	str	r6, [r1, #40]	; 0x28
	frameFunctions[Delay] = SFXDelayFrame;
   18a36:	f240 7621 	movw	r6, #1825	; 0x721
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   18a3a:	6295      	str	r5, [r2, #40]	; 0x28
	tickFunctions[Delay] = SFXDelayTick;
   18a3c:	f240 758d 	movw	r5, #1933	; 0x78d
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   18a40:	629c      	str	r4, [r3, #40]	; 0x28
	freeFunctions[Delay] = SFXDelayFree;
   18a42:	f640 2489 	movw	r4, #2697	; 0xa89
	allocFunctions[Delay] = SFXDelayAlloc;
   18a46:	f2c0 0702 	movt	r7, #2
	frameFunctions[Delay] = SFXDelayFrame;
   18a4a:	f2c0 0602 	movt	r6, #2
	tickFunctions[Delay] = SFXDelayTick;
   18a4e:	f2c0 0502 	movt	r5, #2
	freeFunctions[Delay] = SFXDelayFree;
   18a52:	f2c0 0402 	movt	r4, #2
	allocFunctions[Delay] = SFXDelayAlloc;
   18a56:	62c7      	str	r7, [r0, #44]	; 0x2c

	allocFunctions[Reverb] = SFXReverbAlloc;
   18a58:	f640 27f1 	movw	r7, #2801	; 0xaf1
	frameFunctions[Delay] = SFXDelayFrame;
   18a5c:	62ce      	str	r6, [r1, #44]	; 0x2c
	frameFunctions[Reverb] = SFXReverbFrame;
   18a5e:	f640 364d 	movw	r6, #2893	; 0xb4d
	tickFunctions[Delay] = SFXDelayTick;
   18a62:	62d5      	str	r5, [r2, #44]	; 0x2c
	tickFunctions[Reverb] = SFXReverbTick;
   18a64:	f640 35f9 	movw	r5, #3065	; 0xbf9
	freeFunctions[Delay] = SFXDelayFree;
   18a68:	62dc      	str	r4, [r3, #44]	; 0x2c
	freeFunctions[Reverb] = SFXReverbFree;
   18a6a:	f640 5429 	movw	r4, #3369	; 0xd29
	allocFunctions[Reverb] = SFXReverbAlloc;
   18a6e:	f2c0 0702 	movt	r7, #2
	frameFunctions[Reverb] = SFXReverbFrame;
   18a72:	f2c0 0602 	movt	r6, #2
	tickFunctions[Reverb] = SFXReverbTick;
   18a76:	f2c0 0502 	movt	r5, #2
	freeFunctions[Reverb] = SFXReverbFree;
   18a7a:	f2c0 0402 	movt	r4, #2
	allocFunctions[Reverb] = SFXReverbAlloc;
   18a7e:	6307      	str	r7, [r0, #48]	; 0x30

	allocFunctions[Reverb2] = SFXReverb2Alloc;
   18a80:	f640 5749 	movw	r7, #3401	; 0xd49
	frameFunctions[Reverb] = SFXReverbFrame;
   18a84:	630e      	str	r6, [r1, #48]	; 0x30
	frameFunctions[Reverb2] = SFXReverb2Frame;
   18a86:	f640 6631 	movw	r6, #3633	; 0xe31
	tickFunctions[Reverb] = SFXReverbTick;
   18a8a:	6315      	str	r5, [r2, #48]	; 0x30
	tickFunctions[Reverb2] = SFXReverb2Tick;
   18a8c:	f640 6535 	movw	r5, #3637	; 0xe35
	freeFunctions[Reverb] = SFXReverbFree;
   18a90:	631c      	str	r4, [r3, #48]	; 0x30
	freeFunctions[Reverb2] = SFXReverb2Free;
   18a92:	f241 0425 	movw	r4, #4133	; 0x1025
	allocFunctions[Reverb2] = SFXReverb2Alloc;
   18a96:	f2c0 0702 	movt	r7, #2
	frameFunctions[Reverb2] = SFXReverb2Frame;
   18a9a:	f2c0 0602 	movt	r6, #2
	tickFunctions[Reverb2] = SFXReverb2Tick;
   18a9e:	f2c0 0502 	movt	r5, #2
	freeFunctions[Reverb2] = SFXReverb2Free;
   18aa2:	f2c0 0402 	movt	r4, #2
	allocFunctions[Reverb2] = SFXReverb2Alloc;
   18aa6:	6347      	str	r7, [r0, #52]	; 0x34

	allocFunctions[LivingString] = SFXLivingStringAlloc;
   18aa8:	f241 0781 	movw	r7, #4225	; 0x1081
	frameFunctions[Reverb2] = SFXReverb2Frame;
   18aac:	634e      	str	r6, [r1, #52]	; 0x34
	frameFunctions[LivingString] = SFXLivingStringFrame;
   18aae:	f241 1699 	movw	r6, #4505	; 0x1199
	tickFunctions[Reverb2] = SFXReverb2Tick;
   18ab2:	6355      	str	r5, [r2, #52]	; 0x34
	tickFunctions[LivingString] = SFXLivingStringTick;
   18ab4:	f241 655d 	movw	r5, #5725	; 0x165d
	freeFunctions[Reverb2] = SFXReverb2Free;
   18ab8:	635c      	str	r4, [r3, #52]	; 0x34
	freeFunctions[LivingString] = SFXLivingStringFree;
   18aba:	f241 64b9 	movw	r4, #5817	; 0x16b9
	allocFunctions[LivingString] = SFXLivingStringAlloc;
   18abe:	f2c0 0702 	movt	r7, #2
	frameFunctions[LivingString] = SFXLivingStringFrame;
   18ac2:	f2c0 0602 	movt	r6, #2
	tickFunctions[LivingString] = SFXLivingStringTick;
   18ac6:	f2c0 0502 	movt	r5, #2
	freeFunctions[LivingString] = SFXLivingStringFree;
   18aca:	f2c0 0402 	movt	r4, #2
	allocFunctions[LivingString] = SFXLivingStringAlloc;
   18ace:	6387      	str	r7, [r0, #56]	; 0x38

	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   18ad0:	f241 67e1 	movw	r7, #5857	; 0x16e1
	frameFunctions[LivingString] = SFXLivingStringFrame;
   18ad4:	638e      	str	r6, [r1, #56]	; 0x38
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   18ad6:	f641 0695 	movw	r6, #6293	; 0x1895
	tickFunctions[LivingString] = SFXLivingStringTick;
   18ada:	6395      	str	r5, [r2, #56]	; 0x38
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   18adc:	f641 4561 	movw	r5, #7265	; 0x1c61
	freeFunctions[LivingString] = SFXLivingStringFree;
   18ae0:	639c      	str	r4, [r3, #56]	; 0x38
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   18ae2:	f641 5439 	movw	r4, #7481	; 0x1d39
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   18ae6:	f2c0 0702 	movt	r7, #2
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   18aea:	f2c0 0602 	movt	r6, #2
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   18aee:	f2c0 0502 	movt	r5, #2
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   18af2:	f2c0 0402 	movt	r4, #2
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   18af6:	63c7      	str	r7, [r0, #60]	; 0x3c

	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   18af8:	f641 579d 	movw	r7, #7581	; 0x1d9d
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   18afc:	63ce      	str	r6, [r1, #60]	; 0x3c
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   18afe:	f242 1639 	movw	r6, #8505	; 0x2139
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   18b02:	63d5      	str	r5, [r2, #60]	; 0x3c
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   18b04:	f642 156d 	movw	r5, #10605	; 0x296d
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   18b08:	63dc      	str	r4, [r3, #60]	; 0x3c
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   18b0a:	f642 24bd 	movw	r4, #10941	; 0x2abd
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   18b0e:	f2c0 0702 	movt	r7, #2
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   18b12:	f2c0 0602 	movt	r6, #2
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   18b16:	f2c0 0502 	movt	r5, #2
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   18b1a:	f2c0 0402 	movt	r4, #2
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   18b1e:	6407      	str	r7, [r0, #64]	; 0x40

	allocFunctions[Rhodes] = SFXRhodesAlloc;
   18b20:	f642 3745 	movw	r7, #11077	; 0x2b45
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   18b24:	640e      	str	r6, [r1, #64]	; 0x40
	frameFunctions[Rhodes] = SFXRhodesFrame;
   18b26:	f642 46ed 	movw	r6, #11501	; 0x2ced
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   18b2a:	6415      	str	r5, [r2, #64]	; 0x40
	tickFunctions[Rhodes] = SFXRhodesTick;
   18b2c:	f243 75cd 	movw	r5, #14285	; 0x37cd
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   18b30:	641c      	str	r4, [r3, #64]	; 0x40
	freeFunctions[Rhodes] = SFXRhodesFree;
   18b32:	f643 346d 	movw	r4, #15213	; 0x3b6d
	allocFunctions[Rhodes] = SFXRhodesAlloc;
   18b36:	f2c0 0702 	movt	r7, #2
	frameFunctions[Rhodes] = SFXRhodesFrame;
   18b3a:	f2c0 0602 	movt	r6, #2
	tickFunctions[Rhodes] = SFXRhodesTick;
   18b3e:	f2c0 0502 	movt	r5, #2
	freeFunctions[Rhodes] = SFXRhodesFree;
   18b42:	f2c0 0402 	movt	r4, #2
	allocFunctions[Rhodes] = SFXRhodesAlloc;
   18b46:	6447      	str	r7, [r0, #68]	; 0x44
	frameFunctions[Rhodes] = SFXRhodesFrame;
   18b48:	644e      	str	r6, [r1, #68]	; 0x44
	tickFunctions[Rhodes] = SFXRhodesTick;
   18b4a:	6455      	str	r5, [r2, #68]	; 0x44
	freeFunctions[Rhodes] = SFXRhodesFree;
   18b4c:	645c      	str	r4, [r3, #68]	; 0x44
}
   18b4e:	bcf0      	pop	{r4, r5, r6, r7}
   18b50:	4770      	bx	lr
   18b52:	bf00      	nop

00018b54 <audioInit>:
{
   18b54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   18b58:	f44f 4400 	mov.w	r4, #32768	; 0x8000
{
   18b5c:	4688      	mov	r8, r1
   18b5e:	4617      	mov	r7, r2
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   18b60:	f64a 7371 	movw	r3, #44913	; 0xaf71
   18b64:	f2c4 743b 	movt	r4, #18235	; 0x473b
   18b68:	f64e 3258 	movw	r2, #60248	; 0xeb58
   18b6c:	f647 21a0 	movw	r1, #31392	; 0x7aa0
   18b70:	f2c0 0301 	movt	r3, #1
   18b74:	ee00 4a10 	vmov	s0, r4
   18b78:	f2c0 0207 	movt	r2, #7
   18b7c:	f2c0 0106 	movt	r1, #6
{
   18b80:	4606      	mov	r6, r0
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   18b82:	2080      	movs	r0, #128	; 0x80
   18b84:	f24a 6408 	movw	r4, #42504	; 0xa608
{
   18b88:	ed2d 8b02 	vpush	{d8}
   18b8c:	b086      	sub	sp, #24
   18b8e:	f2c0 240f 	movt	r4, #527	; 0x20f
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   18b92:	f017 fa95 	bl	300c0 <LEAF_init>
	tMempool_init (&smallPool, small_memory, SMALL_MEM_SIZE);
   18b96:	f643 12c8 	movw	r2, #14792	; 0x39c8
   18b9a:	f646 3158 	movw	r1, #27480	; 0x6b58
   18b9e:	f64a 6090 	movw	r0, #44688	; 0xae90
   18ba2:	f2c0 0201 	movt	r2, #1
   18ba6:	f104 0518 	add.w	r5, r4, #24
   18baa:	f2c0 210e 	movt	r1, #526	; 0x20e
   18bae:	f2c0 200f 	movt	r0, #527	; 0x20f
   18bb2:	f014 fc45 	bl	2d440 <tMempool_init>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
   18bb6:	f246 6100 	movw	r1, #26112	; 0x6600
   18bba:	f24a 50b8 	movw	r0, #42424	; 0xa5b8
   18bbe:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   18bc2:	f2c0 010e 	movt	r1, #14
   18bc6:	f2c0 200f 	movt	r0, #527	; 0x20f
   18bca:	f014 fc39 	bl	2d440 <tMempool_init>
	initFunctionPointers();
   18bce:	f7ff fe45 	bl	1885c <initFunctionPointers>
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   18bd2:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   18bd6:	2200      	movs	r2, #0
   18bd8:	f6c3 634c 	movt	r3, #15948	; 0x3e4c
   18bdc:	ee08 2a90 	vmov	s17, r2
   18be0:	ee08 3a10 	vmov	s16, r3
   18be4:	4620      	mov	r0, r4
   18be6:	3404      	adds	r4, #4
   18be8:	eef0 0a48 	vmov.f32	s1, s16
   18bec:	eeb0 0a68 	vmov.f32	s0, s17
   18bf0:	f012 fb7c 	bl	2b2ec <tExpSmooth_init>
	for (int i = 0; i < 6; i++)
   18bf4:	42ac      	cmp	r4, r5
   18bf6:	d1f5      	bne.n	18be4 <audioInit+0x90>
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
   18bf8:	f64d 723b 	movw	r2, #57147	; 0xdf3b
   18bfc:	f24b 7317 	movw	r3, #46871	; 0xb717
   18c00:	f24a 6080 	movw	r0, #42624	; 0xa680
	loadingPreset = 1;
   18c04:	2401      	movs	r4, #1
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
   18c06:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
   18c0a:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   18c0e:	f2c0 200f 	movt	r0, #527	; 0x20f
   18c12:	ee00 2a90 	vmov	s1, r2
   18c16:	ee00 3a10 	vmov	s0, r3
   18c1a:	f00e fcdd 	bl	275d8 <tEnvelopeFollower_init>
   18c1e:	f64d 723b 	movw	r2, #57147	; 0xdf3b
   18c22:	f24b 7317 	movw	r3, #46871	; 0xb717
   18c26:	f24a 6084 	movw	r0, #42628	; 0xa684
   18c2a:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
   18c2e:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   18c32:	f2c0 200f 	movt	r0, #527	; 0x20f
   18c36:	ee00 2a90 	vmov	s1, r2
   18c3a:	ee00 3a10 	vmov	s0, r3
   18c3e:	f00e fccb 	bl	275d8 <tEnvelopeFollower_init>
   18c42:	f64d 723b 	movw	r2, #57147	; 0xdf3b
   18c46:	f24b 7317 	movw	r3, #46871	; 0xb717
   18c4a:	f24a 6088 	movw	r0, #42632	; 0xa688
   18c4e:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
   18c52:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   18c56:	f2c0 200f 	movt	r0, #527	; 0x20f
   18c5a:	ee00 2a90 	vmov	s1, r2
   18c5e:	ee00 3a10 	vmov	s0, r3
   18c62:	f00e fcb9 	bl	275d8 <tEnvelopeFollower_init>
   18c66:	f64d 723b 	movw	r2, #57147	; 0xdf3b
   18c6a:	f24b 7317 	movw	r3, #46871	; 0xb717
   18c6e:	f24a 608c 	movw	r0, #42636	; 0xa68c
   18c72:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
   18c76:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   18c7a:	f2c0 200f 	movt	r0, #527	; 0x20f
   18c7e:	ee00 2a90 	vmov	s1, r2
   18c82:	ee00 3a10 	vmov	s0, r3
   18c86:	f00e fca7 	bl	275d8 <tEnvelopeFollower_init>
	LEAF_generate_atodbPositiveClipped(atodbTable, -120.0f, 380.0f, ATODB_TABLE_SIZE);
   18c8a:	2200      	movs	r2, #0
   18c8c:	f24a 6090 	movw	r0, #42640	; 0xa690
   18c90:	f44f 7100 	mov.w	r1, #512	; 0x200
   18c94:	4613      	mov	r3, r2
   18c96:	f2c4 32be 	movt	r2, #17342	; 0x43be
   18c9a:	f2c0 200f 	movt	r0, #527	; 0x20f
   18c9e:	f2cc 23f0 	movt	r3, #49904	; 0xc2f0
   18ca2:	ee00 2a90 	vmov	s1, r2
   18ca6:	ee00 3a10 	vmov	s0, r3
   18caa:	f014 f935 	bl	2cf18 <LEAF_generate_atodbPositiveClipped>
	initGlobalSFXObjects();
   18cae:	f003 fa4f 	bl	1c150 <initGlobalSFXObjects>
	loadingPreset = 1;
   18cb2:	f646 12bb 	movw	r2, #27067	; 0x69bb
	previousPreset = PresetNil;
   18cb6:	f246 23d0 	movw	r3, #25296	; 0x62d0
   18cba:	2112      	movs	r1, #18
	loadingPreset = 1;
   18cbc:	f2c0 220e 	movt	r2, #526	; 0x20e
	HAL_Delay(10);
   18cc0:	200a      	movs	r0, #10
	previousPreset = PresetNil;
   18cc2:	f2c0 0306 	movt	r3, #6
	loadingPreset = 1;
   18cc6:	7014      	strb	r4, [r2, #0]
	previousPreset = PresetNil;
   18cc8:	7019      	strb	r1, [r3, #0]
	HAL_Delay(10);
   18cca:	f7ef fbbf 	bl	844c <HAL_Delay>
   18cce:	f646 5020 	movw	r0, #27936	; 0x6d20
   18cd2:	f44f 6200 	mov.w	r2, #2048	; 0x800
   18cd6:	2100      	movs	r1, #0
   18cd8:	f2c0 0006 	movt	r0, #6
   18cdc:	f017 fa69 	bl	301b2 <memset>
	HAL_Delay(1);
   18ce0:	4620      	mov	r0, r4
   18ce2:	f7ef fbb3 	bl	844c <HAL_Delay>
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   18ce6:	f646 5120 	movw	r1, #27936	; 0x6d20
   18cea:	4640      	mov	r0, r8
   18cec:	f44f 7200 	mov.w	r2, #512	; 0x200
   18cf0:	f2c0 0106 	movt	r1, #6
   18cf4:	f7f9 f9b4 	bl	12060 <HAL_SAI_Transmit_DMA>
   18cf8:	f24a 5368 	movw	r3, #42344	; 0xa568
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   18cfc:	f246 5120 	movw	r1, #25888	; 0x6520
   18d00:	f44f 7200 	mov.w	r2, #512	; 0x200
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   18d04:	f2c0 230f 	movt	r3, #527	; 0x20f
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   18d08:	f2c0 0106 	movt	r1, #6
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   18d0c:	7018      	strb	r0, [r3, #0]
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   18d0e:	4638      	mov	r0, r7
   18d10:	f7f9 fa3a 	bl	12188 <HAL_SAI_Receive_DMA>
   18d14:	f24a 6304 	movw	r3, #42500	; 0xa604
   18d18:	f2c0 230f 	movt	r3, #527	; 0x20f
   18d1c:	7018      	strb	r0, [r3, #0]
	AudioCodec_init(hi2c);
   18d1e:	4630      	mov	r0, r6
   18d20:	f000 f8b4 	bl	18e8c <AudioCodec_init>
	HAL_Delay(1);
   18d24:	4620      	mov	r0, r4
   18d26:	f7ef fb91 	bl	844c <HAL_Delay>
	HAL_I2C_MspDeInit(hi2c);
   18d2a:	4630      	mov	r0, r6
   18d2c:	f001 ffac 	bl	1ac88 <HAL_I2C_MspDeInit>
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18d30:	f44f 6080 	mov.w	r0, #1024	; 0x400
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   18d34:	2300      	movs	r3, #0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   18d36:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18d3a:	f6c5 0002 	movt	r0, #22530	; 0x5802
   18d3e:	a901      	add	r1, sp, #4
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   18d40:	9302      	str	r3, [sp, #8]
   18d42:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   18d44:	9201      	str	r2, [sp, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   18d46:	e9cd 4303 	strd	r4, r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18d4a:	f7f3 fc25 	bl	c598 <HAL_GPIO_Init>
}
   18d4e:	b006      	add	sp, #24
   18d50:	ecbd 8b02 	vpop	{d8}
   18d54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00018d58 <HAL_SAI_ErrorCallback>:



void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
	setLED_Edit(1);
   18d58:	2001      	movs	r0, #1
   18d5a:	f002 b9ab 	b.w	1b0b4 <setLED_Edit>
   18d5e:	bf00      	nop

00018d60 <HAL_SAI_TxCpltCallback>:
   18d60:	4770      	bx	lr
   18d62:	bf00      	nop

00018d64 <HAL_SAI_TxHalfCpltCallback>:
}

void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{

}
   18d64:	4770      	bx	lr
   18d66:	bf00      	nop

00018d68 <HAL_SAI_RxCpltCallback>:


void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(HALF_BUFFER_SIZE);
   18d68:	f44f 7080 	mov.w	r0, #256	; 0x100
   18d6c:	f7ff baec 	b.w	18348 <audioFrame>

00018d70 <HAL_SAI_RxHalfCpltCallback>:
}

void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(0);
   18d70:	2000      	movs	r0, #0
   18d72:	f7ff bae9 	b.w	18348 <audioFrame>
   18d76:	bf00      	nop

00018d78 <MX_BDMA_Init>:
  */
void MX_BDMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_BDMA_CLK_ENABLE();
   18d78:	f44f 4388 	mov.w	r3, #17408	; 0x4400

  /* DMA interrupt init */
  /* BDMA_Channel0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   18d7c:	2200      	movs	r2, #0
   18d7e:	2081      	movs	r0, #129	; 0x81
  __HAL_RCC_BDMA_CLK_ENABLE();
   18d80:	f6c5 0302 	movt	r3, #22530	; 0x5802
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   18d84:	4611      	mov	r1, r2
{
   18d86:	b510      	push	{r4, lr}
  __HAL_RCC_BDMA_CLK_ENABLE();
   18d88:	f8d3 40e0 	ldr.w	r4, [r3, #224]	; 0xe0
{
   18d8c:	b082      	sub	sp, #8
  __HAL_RCC_BDMA_CLK_ENABLE();
   18d8e:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
   18d92:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
   18d96:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   18d9a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
   18d9e:	9301      	str	r3, [sp, #4]
   18da0:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   18da2:	f7f0 ff6b 	bl	9c7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel0_IRQn);
   18da6:	2081      	movs	r0, #129	; 0x81
   18da8:	f7f0 ffb8 	bl	9d1c <HAL_NVIC_EnableIRQ>
  /* BDMA_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel1_IRQn, 0, 0);
   18dac:	2200      	movs	r2, #0
   18dae:	2082      	movs	r0, #130	; 0x82
   18db0:	4611      	mov	r1, r2
   18db2:	f7f0 ff63 	bl	9c7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
   18db6:	2082      	movs	r0, #130	; 0x82

}
   18db8:	b002      	add	sp, #8
   18dba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
   18dbe:	f7f0 bfad 	b.w	9d1c <HAL_NVIC_EnableIRQ>
   18dc2:	bf00      	nop

00018dc4 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
   18dc4:	b500      	push	{lr}
   18dc6:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_ReadBlocks(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
   18dc8:	9300      	str	r3, [sp, #0]
   18dca:	4613      	mov	r3, r2
   18dcc:	460a      	mov	r2, r1
   18dce:	4601      	mov	r1, r0
   18dd0:	f64b 4030 	movw	r0, #48176	; 0xbc30
   18dd4:	f2c0 200f 	movt	r0, #527	; 0x20f
   18dd8:	f7f9 fb6a 	bl	124b0 <HAL_SD_ReadBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
   18ddc:	3000      	adds	r0, #0
   18dde:	bf18      	it	ne
   18de0:	2001      	movne	r0, #1
   18de2:	b003      	add	sp, #12
   18de4:	f85d fb04 	ldr.w	pc, [sp], #4

00018de8 <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
   18de8:	b500      	push	{lr}
   18dea:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_WriteBlocks(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
   18dec:	9300      	str	r3, [sp, #0]
   18dee:	4613      	mov	r3, r2
   18df0:	460a      	mov	r2, r1
   18df2:	4601      	mov	r1, r0
   18df4:	f64b 4030 	movw	r0, #48176	; 0xbc30
   18df8:	f2c0 200f 	movt	r0, #527	; 0x20f
   18dfc:	f7f9 fc74 	bl	126e8 <HAL_SD_WriteBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
   18e00:	3000      	adds	r0, #0
   18e02:	bf18      	it	ne
   18e04:	2001      	movne	r0, #1
   18e06:	b003      	add	sp, #12
   18e08:	f85d fb04 	ldr.w	pc, [sp], #4

00018e0c <BSP_SD_GetCardState>:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
   18e0c:	f64b 4030 	movw	r0, #48176	; 0xbc30
{
   18e10:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
   18e12:	f2c0 200f 	movt	r0, #527	; 0x20f
   18e16:	f7fa fa41 	bl	1329c <HAL_SD_GetCardState>
}
   18e1a:	3804      	subs	r0, #4
   18e1c:	bf18      	it	ne
   18e1e:	2001      	movne	r0, #1
   18e20:	bd08      	pop	{r3, pc}
   18e22:	bf00      	nop

00018e24 <BSP_SD_GetCardInfo>:
  * @retval None 
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
   18e24:	4601      	mov	r1, r0
   18e26:	f64b 4030 	movw	r0, #48176	; 0xbc30
   18e2a:	f2c0 200f 	movt	r0, #527	; 0x20f
   18e2e:	f7fa b891 	b.w	12f54 <HAL_SD_GetCardInfo>
   18e32:	bf00      	nop

00018e34 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
   18e34:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
   18e36:	2301      	movs	r3, #1
{
   18e38:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
   18e3a:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0) 
   18e3e:	f000 fcc3 	bl	197c8 <BSP_PlatformIsDetected>
   18e42:	b908      	cbnz	r0, 18e48 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
   18e44:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
   18e48:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
   18e4c:	b003      	add	sp, #12
   18e4e:	f85d fb04 	ldr.w	pc, [sp], #4
   18e52:	bf00      	nop

00018e54 <BSP_SD_Init>:
{
   18e54:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
   18e56:	f7ff ffed 	bl	18e34 <BSP_SD_IsDetected>
   18e5a:	2801      	cmp	r0, #1
   18e5c:	d001      	beq.n	18e62 <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
   18e5e:	2002      	movs	r0, #2
}
   18e60:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
   18e62:	f64b 4030 	movw	r0, #48176	; 0xbc30
   18e66:	f2c0 200f 	movt	r0, #527	; 0x20f
   18e6a:	f7fa f93d 	bl	130e8 <HAL_SD_Init>
  if (sd_state == MSD_OK)
   18e6e:	2800      	cmp	r0, #0
   18e70:	d1f6      	bne.n	18e60 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
   18e72:	f64b 4030 	movw	r0, #48176	; 0xbc30
   18e76:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   18e7a:	f2c0 200f 	movt	r0, #527	; 0x20f
   18e7e:	f7fa f87d 	bl	12f7c <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
   18e82:	3000      	adds	r0, #0
   18e84:	bf18      	it	ne
   18e86:	2001      	movne	r0, #1
}
   18e88:	bd08      	pop	{r3, pc}
   18e8a:	bf00      	nop

00018e8c <AudioCodec_init>:

volatile int blankCount = 0;
uint16_t addressCounter = 0;


void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
   18e8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18e90:	4680      	mov	r8, r0

	HAL_Delay(2);
	//enable control port and put part in power-down mode while loading registers
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x03;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18e92:	f246 0514 	movw	r5, #24596	; 0x6014
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   18e96:	f44f 6000 	mov.w	r0, #2048	; 0x800
void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
   18e9a:	b082      	sub	sp, #8
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18e9c:	f2c0 0506 	movt	r5, #6
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   18ea0:	2201      	movs	r2, #1
   18ea2:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   18ea6:	f6c5 0002 	movt	r0, #22530	; 0x5802
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18eaa:	f246 0618 	movw	r6, #24600	; 0x6018
	myI2cData[0] = 0x07;
   18eae:	f646 0468 	movw	r4, #26728	; 0x6868
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   18eb2:	f7f3 ff1b 	bl	ccec <HAL_GPIO_WritePin>
	HAL_Delay(2);
   18eb6:	2002      	movs	r0, #2
	myI2cData[0] = 0x07;
   18eb8:	f2c0 240e 	movt	r4, #526	; 0x20e
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18ebc:	f2c0 0606 	movt	r6, #6
	HAL_Delay(2);
   18ec0:	f7ef fac4 	bl	844c <HAL_Delay>
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18ec4:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x07;
   18ec6:	f240 3c07 	movw	ip, #775	; 0x307
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18eca:	f64a 6794 	movw	r7, #44692	; 0xae94
   18ece:	8833      	ldrh	r3, [r6, #0]
   18ed0:	4622      	mov	r2, r4
   18ed2:	9100      	str	r1, [sp, #0]
   18ed4:	4640      	mov	r0, r8
   18ed6:	2120      	movs	r1, #32
   18ed8:	f2c0 270f 	movt	r7, #527	; 0x20f
	myI2cData[0] = 0x07;
   18edc:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18ee0:	f7f4 fa50 	bl	d384 <HAL_I2C_Master_Transmit>
	//HAL_Delay(2);

	myI2cData[0] = 0x01;
	myI2cData[1] = 0x41;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18ee4:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x01;
   18ee6:	f244 1c01 	movw	ip, #16641	; 0x4101
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18eea:	8833      	ldrh	r3, [r6, #0]
   18eec:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18eee:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18ef0:	4640      	mov	r0, r8
   18ef2:	9100      	str	r1, [sp, #0]
   18ef4:	2120      	movs	r1, #32
	myI2cData[0] = 0x01;
   18ef6:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18efa:	f7f4 fa43 	bl	d384 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x02;
	myI2cData[1] = 0x00;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18efe:	682a      	ldr	r2, [r5, #0]
	myI2cData[0] = 0x02;
   18f00:	f04f 0c02 	mov.w	ip, #2
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f04:	8833      	ldrh	r3, [r6, #0]
   18f06:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f08:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f0a:	4640      	mov	r0, r8
   18f0c:	9200      	str	r2, [sp, #0]
   18f0e:	4622      	mov	r2, r4
	myI2cData[0] = 0x02;
   18f10:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f14:	f7f4 fa36 	bl	d384 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x03;
	myI2cData[1] = 0x79;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f18:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x03;
   18f1a:	f647 1c03 	movw	ip, #30979	; 0x7903
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f1e:	8833      	ldrh	r3, [r6, #0]
   18f20:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f22:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f24:	4640      	mov	r0, r8
   18f26:	9100      	str	r1, [sp, #0]
   18f28:	2120      	movs	r1, #32
	myI2cData[0] = 0x03;
   18f2a:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f2e:	f7f4 fa29 	bl	d384 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x04;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f32:	682a      	ldr	r2, [r5, #0]
	myI2cData[0] = 0x04;
   18f34:	f44f 7c82 	mov.w	ip, #260	; 0x104
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f38:	8833      	ldrh	r3, [r6, #0]
   18f3a:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f3c:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f3e:	4640      	mov	r0, r8
   18f40:	9200      	str	r2, [sp, #0]
   18f42:	4622      	mov	r2, r4
	myI2cData[0] = 0x04;
   18f44:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f48:	f7f4 fa1c 	bl	d384 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x05;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f4c:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x05;
   18f4e:	f240 1c05 	movw	ip, #261	; 0x105
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f52:	8833      	ldrh	r3, [r6, #0]
   18f54:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f56:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f58:	4640      	mov	r0, r8
   18f5a:	9100      	str	r1, [sp, #0]
   18f5c:	2120      	movs	r1, #32
	myI2cData[0] = 0x05;
   18f5e:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f62:	f7f4 fa0f 	bl	d384 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x06;
	myI2cData[1] = 0x10;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f66:	682a      	ldr	r2, [r5, #0]
	myI2cData[0] = 0x06;
   18f68:	f241 0c06 	movw	ip, #4102	; 0x1006
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f6c:	8833      	ldrh	r3, [r6, #0]
   18f6e:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f70:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f72:	4640      	mov	r0, r8
   18f74:	9200      	str	r2, [sp, #0]
   18f76:	4622      	mov	r2, r4
	myI2cData[0] = 0x06;
   18f78:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f7c:	f7f4 fa02 	bl	d384 <HAL_I2C_Master_Transmit>
	//HAL_Delay(1); // might not be necessary

	//turn off power down bit to start things cookin'
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x02;
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f80:	6829      	ldr	r1, [r5, #0]
   18f82:	4622      	mov	r2, r4
   18f84:	8833      	ldrh	r3, [r6, #0]
	myI2cData[0] = 0x07;
   18f86:	f240 2607 	movw	r6, #519	; 0x207
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f8a:	7038      	strb	r0, [r7, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f8c:	4640      	mov	r0, r8
   18f8e:	9100      	str	r1, [sp, #0]
   18f90:	2120      	movs	r1, #32
	myI2cData[0] = 0x07;
   18f92:	8026      	strh	r6, [r4, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   18f94:	f7f4 f9f6 	bl	d384 <HAL_I2C_Master_Transmit>


	//HAL_Delay(1); // might not be necessary
	codecReady = 1;
   18f98:	f646 0360 	movw	r3, #26720	; 0x6860
   18f9c:	2201      	movs	r2, #1
   18f9e:	f2c0 230e 	movt	r3, #526	; 0x20e
   18fa2:	701a      	strb	r2, [r3, #0]

}
   18fa4:	b002      	add	sp, #8
   18fa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18faa:	bf00      	nop

00018fac <MX_DMA_Init>:
  */
void MX_DMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
   18fac:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
   18fb0:	2200      	movs	r2, #0
   18fb2:	2103      	movs	r1, #3
   18fb4:	200c      	movs	r0, #12
  __HAL_RCC_DMA2_CLK_ENABLE();
   18fb6:	f6c5 0302 	movt	r3, #22530	; 0x5802
{
   18fba:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
   18fbc:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
{
   18fc0:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
   18fc2:	f044 0402 	orr.w	r4, r4, #2
   18fc6:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
   18fca:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
   18fce:	f004 0402 	and.w	r4, r4, #2
   18fd2:	9400      	str	r4, [sp, #0]
   18fd4:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
   18fd6:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
   18fda:	f044 0401 	orr.w	r4, r4, #1
   18fde:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
   18fe2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
   18fe6:	f003 0301 	and.w	r3, r3, #1
   18fea:	9301      	str	r3, [sp, #4]
   18fec:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
   18fee:	f7f0 fe45 	bl	9c7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
   18ff2:	200c      	movs	r0, #12
   18ff4:	f7f0 fe92 	bl	9d1c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 3, 0);
   18ff8:	2200      	movs	r2, #0
   18ffa:	2103      	movs	r1, #3
   18ffc:	200d      	movs	r0, #13
   18ffe:	f7f0 fe3d 	bl	9c7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
   19002:	200d      	movs	r0, #13
   19004:	f7f0 fe8a 	bl	9d1c <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 4, 0);
   19008:	2200      	movs	r2, #0
   1900a:	2104      	movs	r1, #4
   1900c:	2038      	movs	r0, #56	; 0x38
   1900e:	f7f0 fe35 	bl	9c7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
   19012:	2038      	movs	r0, #56	; 0x38
   19014:	f7f0 fe82 	bl	9d1c <HAL_NVIC_EnableIRQ>
  /* DMAMUX1_OVR_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMAMUX1_OVR_IRQn, 0, 0);
   19018:	2200      	movs	r2, #0
   1901a:	2066      	movs	r0, #102	; 0x66
   1901c:	4611      	mov	r1, r2
   1901e:	f7f0 fe2d 	bl	9c7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
   19022:	2066      	movs	r0, #102	; 0x66

}
   19024:	b002      	add	sp, #8
   19026:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
   1902a:	f7f0 be77 	b.w	9d1c <HAL_NVIC_EnableIRQ>
   1902e:	bf00      	nop

00019030 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
   19030:	b510      	push	{r4, lr}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19032:	2400      	movs	r4, #0
{
   19034:	b090      	sub	sp, #64	; 0x40
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19036:	4622      	mov	r2, r4
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint16_t ValidPage = PAGE0;
  uint32_t Address = EEPROM_START_ADDRESS, PageEndAddress = EEPROM_START_ADDRESS+PAGE_SIZE;

  uint32_t data32[8] = {Data};
   19038:	4623      	mov	r3, r4
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1903a:	f6c0 041c 	movt	r4, #2076	; 0x81c
  uint32_t data32[8] = {Data};
   1903e:	9100      	str	r1, [sp, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19040:	f6c0 021e 	movt	r2, #2078	; 0x81e
  uint32_t VirtAddress1[8] = {VirtAddress};
   19044:	9008      	str	r0, [sp, #32]
  uint32_t data32[8] = {Data};
   19046:	9307      	str	r3, [sp, #28]
  uint32_t VirtAddress1[8] = {VirtAddress};
   19048:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t data32[8] = {Data};
   1904a:	e9cd 3301 	strd	r3, r3, [sp, #4]
   1904e:	e9cd 3303 	strd	r3, r3, [sp, #12]
   19052:	e9cd 3305 	strd	r3, r3, [sp, #20]
  uint32_t VirtAddress1[8] = {VirtAddress};
   19056:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   1905a:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   1905e:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19062:	8824      	ldrh	r4, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19064:	8813      	ldrh	r3, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19066:	b2a4      	uxth	r4, r4
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19068:	b29b      	uxth	r3, r3
      if (PageStatus1 == VALID_PAGE)
   1906a:	bb03      	cbnz	r3, 190ae <EE_VerifyPageFullWriteVariable+0x7e>
        if (PageStatus0 == RECEIVE_DATA)
   1906c:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
   19070:	1ae4      	subs	r4, r4, r3
   19072:	bf18      	it	ne
   19074:	2401      	movne	r4, #1

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   19076:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1907a:	1c63      	adds	r3, r4, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   1907c:	f204 440e 	addw	r4, r4, #1038	; 0x40e
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   19080:	f6c0 021b 	movt	r2, #2075	; 0x81b
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   19084:	0464      	lsls	r4, r4, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   19086:	eb02 4243 	add.w	r2, r2, r3, lsl #17

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
   1908a:	4294      	cmp	r4, r2
   1908c:	d303      	bcc.n	19096 <EE_VerifyPageFullWriteVariable+0x66>
   1908e:	e016      	b.n	190be <EE_VerifyPageFullWriteVariable+0x8e>
     return FlashStatus;
    }
    else
    {
      /* Next address location */
      Address = Address + 64;
   19090:	3440      	adds	r4, #64	; 0x40
  while (Address < PageEndAddress)
   19092:	42a2      	cmp	r2, r4
   19094:	d913      	bls.n	190be <EE_VerifyPageFullWriteVariable+0x8e>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
   19096:	6823      	ldr	r3, [r4, #0]
   19098:	3301      	adds	r3, #1
   1909a:	d1f9      	bne.n	19090 <EE_VerifyPageFullWriteVariable+0x60>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
   1909c:	466a      	mov	r2, sp
   1909e:	4621      	mov	r1, r4
   190a0:	2001      	movs	r0, #1
   190a2:	f7f2 ffa7 	bl	bff4 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
   190a6:	b180      	cbz	r0, 190ca <EE_VerifyPageFullWriteVariable+0x9a>
     return FlashStatus;
   190a8:	b280      	uxth	r0, r0
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
}
   190aa:	b010      	add	sp, #64	; 0x40
   190ac:	bd10      	pop	{r4, pc}
      else if (PageStatus0 == VALID_PAGE)
   190ae:	b94c      	cbnz	r4, 190c4 <EE_VerifyPageFullWriteVariable+0x94>
        if (PageStatus1 == RECEIVE_DATA)
   190b0:	f64e 64ee 	movw	r4, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
   190b4:	1b1c      	subs	r4, r3, r4
   190b6:	fab4 f484 	clz	r4, r4
   190ba:	0964      	lsrs	r4, r4, #5
   190bc:	e7db      	b.n	19076 <EE_VerifyPageFullWriteVariable+0x46>
  return PAGE_FULL;
   190be:	2080      	movs	r0, #128	; 0x80
}
   190c0:	b010      	add	sp, #64	; 0x40
   190c2:	bd10      	pop	{r4, pc}
    return  NO_VALID_PAGE;
   190c4:	20ab      	movs	r0, #171	; 0xab
}
   190c6:	b010      	add	sp, #64	; 0x40
   190c8:	bd10      	pop	{r4, pc}
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
   190ca:	f104 0120 	add.w	r1, r4, #32
   190ce:	aa08      	add	r2, sp, #32
   190d0:	2001      	movs	r0, #1
   190d2:	f7f2 ff8f 	bl	bff4 <HAL_FLASH_Program>
   190d6:	e7e7      	b.n	190a8 <EE_VerifyPageFullWriteVariable+0x78>

000190d8 <EE_Init>:
{
   190d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   190dc:	2400      	movs	r4, #0
{
   190de:	b09f      	sub	sp, #124	; 0x7c
  uint32_t valid[8] = {0x0000};
   190e0:	f04f 0920 	mov.w	r9, #32
  pEraseInit.Sector = PAGE0_ID;
   190e4:	f04f 0b06 	mov.w	fp, #6
  uint32_t SectorError = 0;
   190e8:	46a0      	mov	r8, r4
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   190ea:	f6c0 041c 	movt	r4, #2076	; 0x81c
  uint32_t valid[8] = {0x0000};
   190ee:	464a      	mov	r2, r9
   190f0:	a80e      	add	r0, sp, #56	; 0x38
   190f2:	4641      	mov	r1, r8
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   190f4:	4645      	mov	r5, r8
  uint32_t SectorError = 0;
   190f6:	f8cd 8008 	str.w	r8, [sp, #8]
  uint32_t valid[8] = {0x0000};
   190fa:	f017 f85a 	bl	301b2 <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   190fe:	8826      	ldrh	r6, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19100:	f6c0 051e 	movt	r5, #2078	; 0x81e
  switch (PageStatus0)
   19104:	f64e 62ee 	movw	r2, #61166	; 0xeeee
  pEraseInit.Banks = FLASH_BANK_2 ;
   19108:	2302      	movs	r3, #2
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1910a:	b2b6      	uxth	r6, r6
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1910c:	8828      	ldrh	r0, [r5, #0]
  pEraseInit.NbSectors = 1;
   1910e:	f04f 0a01 	mov.w	sl, #1
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   19112:	f8cd 8010 	str.w	r8, [sp, #16]
  switch (PageStatus0)
   19116:	4296      	cmp	r6, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19118:	b287      	uxth	r7, r0
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   1911a:	f8cd 9020 	str.w	r9, [sp, #32]
  pEraseInit.NbSectors = 1;
   1911e:	f8cd a01c 	str.w	sl, [sp, #28]
  pEraseInit.Sector = PAGE0_ID;
   19122:	e9cd 3b05 	strd	r3, fp, [sp, #20]
  switch (PageStatus0)
   19126:	f000 80dd 	beq.w	192e4 <EE_Init+0x20c>
   1912a:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1912e:	428e      	cmp	r6, r1
   19130:	f000 80ac 	beq.w	1928c <EE_Init+0x1b4>
   19134:	b376      	cbz	r6, 19194 <EE_Init+0xbc>
   19136:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   19138:	ab16      	add	r3, sp, #88	; 0x58
   1913a:	464a      	mov	r2, r9
   1913c:	4641      	mov	r1, r8
   1913e:	4618      	mov	r0, r3
   19140:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   19142:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   19146:	f017 f834 	bl	301b2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   1914a:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
   1914c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   19150:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   19154:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19158:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   1915c:	e001      	b.n	19162 <EE_Init+0x8a>
  while (Address <= PAGE0_END_ADDRESS)
   1915e:	42ac      	cmp	r4, r5
   19160:	d00a      	beq.n	19178 <EE_Init+0xa0>
    AddressValue = (*(__IO uint16_t*)Address);
   19162:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   19164:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   19166:	429a      	cmp	r2, r3
   19168:	d0f9      	beq.n	1915e <EE_Init+0x86>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   1916a:	a903      	add	r1, sp, #12
   1916c:	a809      	add	r0, sp, #36	; 0x24
   1916e:	f7f3 f8fb 	bl	c368 <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
   19172:	2800      	cmp	r0, #0
   19174:	f040 8085 	bne.w	19282 <EE_Init+0x1aa>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
   19178:	2100      	movs	r1, #0
   1917a:	9a00      	ldr	r2, [sp, #0]
   1917c:	2001      	movs	r0, #1
   1917e:	f6c0 011c 	movt	r1, #2076	; 0x81c
   19182:	f7f2 ff37 	bl	bff4 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   19186:	2800      	cmp	r0, #0
   19188:	d17b      	bne.n	19282 <EE_Init+0x1aa>
  return HAL_OK;
   1918a:	2700      	movs	r7, #0
}
   1918c:	4638      	mov	r0, r7
   1918e:	b01f      	add	sp, #124	; 0x7c
   19190:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
   19194:	2f00      	cmp	r7, #0
   19196:	f000 8135 	beq.w	19404 <EE_Init+0x32c>
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
   1919a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1919e:	429f      	cmp	r7, r3
   191a0:	d0f3      	beq.n	1918a <EE_Init+0xb2>
      if (PageStatus0 == VALID_PAGE)
   191a2:	f04f 0920 	mov.w	r9, #32
   191a6:	f246 051c 	movw	r5, #24604	; 0x601c
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   191aa:	2406      	movs	r4, #6
      if (PageStatus0 == VALID_PAGE)
   191ac:	f64f 7ac0 	movw	sl, #65472	; 0xffc0
      else if (PageStatus1 == VALID_PAGE)
   191b0:	46cb      	mov	fp, r9
      if (PageStatus0 == VALID_PAGE)
   191b2:	f64f 78e0 	movw	r8, #65504	; 0xffe0
   191b6:	f2c0 0506 	movt	r5, #6
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   191ba:	f6c0 041e 	movt	r4, #2078	; 0x81e
      if (PageStatus0 == VALID_PAGE)
   191be:	f6c0 0a1d 	movt	sl, #2077	; 0x81d
   191c2:	f6c0 081d 	movt	r8, #2077	; 0x81d
   191c6:	f6c0 091c 	movt	r9, #2076	; 0x81c
      else if (PageStatus1 == VALID_PAGE)
   191ca:	f6c0 0b1e 	movt	fp, #2078	; 0x81e
  int16_t x = -1;
   191ce:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   191d2:	8823      	ldrh	r3, [r4, #0]
   191d4:	f835 0016 	ldrh.w	r0, [r5, r6, lsl #1]
   191d8:	4298      	cmp	r0, r3
            x = VarIdx;
   191da:	bf08      	it	eq
   191dc:	b232      	sxtheq	r2, r6
          if (VarIdx != x)
   191de:	4296      	cmp	r6, r2
   191e0:	d027      	beq.n	19232 <EE_Init+0x15a>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   191e2:	2300      	movs	r3, #0
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   191e4:	4619      	mov	r1, r3
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   191e6:	f6c0 031c 	movt	r3, #2076	; 0x81c
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   191ea:	f6c0 011e 	movt	r1, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   191ee:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   191f0:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   191f2:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   191f4:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   191f6:	2b00      	cmp	r3, #0
   191f8:	f000 8133 	beq.w	19462 <EE_Init+0x38a>
      else if (PageStatus1 == VALID_PAGE)
   191fc:	2900      	cmp	r1, #0
   191fe:	f040 816b 	bne.w	194d8 <EE_Init+0x400>
   19202:	f64f 71e0 	movw	r1, #65504	; 0xffe0
   19206:	f64f 77c0 	movw	r7, #65472	; 0xffc0
   1920a:	46dc      	mov	ip, fp
   1920c:	f6c0 011f 	movt	r1, #2079	; 0x81f
   19210:	f6c0 071f 	movt	r7, #2079	; 0x81f
   19214:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   19216:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   19218:	4288      	cmp	r0, r1
   1921a:	d106      	bne.n	1922a <EE_Init+0x152>
   1921c:	e13a      	b.n	19494 <EE_Init+0x3bc>
    AddressValue = (*(__IO uint16_t*)Address);
   1921e:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
   19222:	42b8      	cmp	r0, r7
   19224:	f000 8134 	beq.w	19490 <EE_Init+0x3b8>
   19228:	460b      	mov	r3, r1
      Address = Address - 32;
   1922a:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   1922e:	458c      	cmp	ip, r1
   19230:	d3f5      	bcc.n	1921e <EE_Init+0x146>
   19232:	3601      	adds	r6, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   19234:	2e03      	cmp	r6, #3
   19236:	d1cc      	bne.n	191d2 <EE_Init+0xfa>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
   19238:	2100      	movs	r1, #0
   1923a:	aa0e      	add	r2, sp, #56	; 0x38
   1923c:	2001      	movs	r0, #1
   1923e:	f6c0 011e 	movt	r1, #2078	; 0x81e
   19242:	f7f2 fed7 	bl	bff4 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   19246:	b9e0      	cbnz	r0, 19282 <EE_Init+0x1aa>
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19248:	2300      	movs	r3, #0
        pEraseInit.Sector = PAGE0_ID;
   1924a:	2006      	movs	r0, #6
        pEraseInit.Banks = FLASH_BANK_2 ;
   1924c:	2502      	movs	r5, #2
        pEraseInit.NbSectors = 1;
   1924e:	2401      	movs	r4, #1
  while (Address <= PAGE0_END_ADDRESS)
   19250:	4619      	mov	r1, r3
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19252:	2220      	movs	r2, #32
        pEraseInit.Sector = PAGE0_ID;
   19254:	9006      	str	r0, [sp, #24]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19256:	f6c0 031c 	movt	r3, #2076	; 0x81c
  while (Address <= PAGE0_END_ADDRESS)
   1925a:	f6c0 011e 	movt	r1, #2078	; 0x81e
    if (AddressValue != ERASED)
   1925e:	f64f 70ff 	movw	r0, #65535	; 0xffff
        pEraseInit.Banks = FLASH_BANK_2 ;
   19262:	9505      	str	r5, [sp, #20]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19264:	e9cd 4207 	strd	r4, r2, [sp, #28]
   19268:	e001      	b.n	1926e <EE_Init+0x196>
  while (Address <= PAGE0_END_ADDRESS)
   1926a:	428b      	cmp	r3, r1
   1926c:	d08d      	beq.n	1918a <EE_Init+0xb2>
    AddressValue = (*(__IO uint16_t*)Address);
   1926e:	881a      	ldrh	r2, [r3, #0]
    Address = Address + 4;
   19270:	3304      	adds	r3, #4
    if (AddressValue != ERASED)
   19272:	4290      	cmp	r0, r2
   19274:	d0f9      	beq.n	1926a <EE_Init+0x192>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   19276:	a902      	add	r1, sp, #8
   19278:	a804      	add	r0, sp, #16
   1927a:	f7f3 f875 	bl	c368 <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   1927e:	2800      	cmp	r0, #0
   19280:	d083      	beq.n	1918a <EE_Init+0xb2>
        return FlashStatus;
   19282:	b287      	uxth	r7, r0
}
   19284:	4638      	mov	r0, r7
   19286:	b01f      	add	sp, #124	; 0x7c
   19288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
   1928c:	b1ff      	cbz	r7, 192ce <EE_Init+0x1f6>
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
   1928e:	4297      	cmp	r7, r2
   19290:	f000 80a2 	beq.w	193d8 <EE_Init+0x300>
   19294:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   19296:	ab16      	add	r3, sp, #88	; 0x58
   19298:	464a      	mov	r2, r9
   1929a:	4641      	mov	r1, r8
   1929c:	4618      	mov	r0, r3
   1929e:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   192a0:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   192a4:	f016 ff85 	bl	301b2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   192a8:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   192aa:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   192ae:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   192b2:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   192b6:	e002      	b.n	192be <EE_Init+0x1e6>
  while (Address <= PAGE0_END_ADDRESS)
   192b8:	42ac      	cmp	r4, r5
   192ba:	f43f af5d 	beq.w	19178 <EE_Init+0xa0>
    AddressValue = (*(__IO uint16_t*)Address);
   192be:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   192c0:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   192c2:	429e      	cmp	r6, r3
   192c4:	d0f8      	beq.n	192b8 <EE_Init+0x1e0>
   192c6:	e750      	b.n	1916a <EE_Init+0x92>
  while (Address <= PAGE0_END_ADDRESS)
   192c8:	42ac      	cmp	r4, r5
   192ca:	f43f af5e 	beq.w	1918a <EE_Init+0xb2>
    AddressValue = (*(__IO uint16_t*)Address);
   192ce:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   192d0:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   192d2:	429e      	cmp	r6, r3
   192d4:	d0f8      	beq.n	192c8 <EE_Init+0x1f0>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   192d6:	a902      	add	r1, sp, #8
   192d8:	a804      	add	r0, sp, #16
   192da:	f7f3 f845 	bl	c368 <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   192de:	2800      	cmp	r0, #0
   192e0:	d1cf      	bne.n	19282 <EE_Init+0x1aa>
   192e2:	e752      	b.n	1918a <EE_Init+0xb2>
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
   192e4:	2f00      	cmp	r7, #0
   192e6:	d156      	bne.n	19396 <EE_Init+0x2be>
      if (PageStatus0 == VALID_PAGE)
   192e8:	f04f 0a20 	mov.w	sl, #32
   192ec:	f246 051c 	movw	r5, #24604	; 0x601c
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   192f0:	2606      	movs	r6, #6
      if (PageStatus0 == VALID_PAGE)
   192f2:	f64f 7bc0 	movw	fp, #65472	; 0xffc0
      else if (PageStatus1 == VALID_PAGE)
   192f6:	4652      	mov	r2, sl
      if (PageStatus0 == VALID_PAGE)
   192f8:	f64f 79e0 	movw	r9, #65504	; 0xffe0
   192fc:	463c      	mov	r4, r7
   192fe:	f2c0 0506 	movt	r5, #6
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   19302:	f6c0 061c 	movt	r6, #2076	; 0x81c
      if (PageStatus0 == VALID_PAGE)
   19306:	f6c0 0b1d 	movt	fp, #2077	; 0x81d
   1930a:	f6c0 0a1c 	movt	sl, #2076	; 0x81c
   1930e:	f6c0 091d 	movt	r9, #2077	; 0x81d
      else if (PageStatus1 == VALID_PAGE)
   19312:	f6c0 021e 	movt	r2, #2078	; 0x81e
  int16_t x = -1;
   19316:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1931a:	8833      	ldrh	r3, [r6, #0]
   1931c:	f835 0014 	ldrh.w	r0, [r5, r4, lsl #1]
   19320:	4298      	cmp	r0, r3
            x = VarIdx;
   19322:	bf08      	it	eq
   19324:	fa0f f884 	sxtheq.w	r8, r4
          if (VarIdx != x)
   19328:	4544      	cmp	r4, r8
   1932a:	d026      	beq.n	1937a <EE_Init+0x2a2>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1932c:	2300      	movs	r3, #0
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1932e:	4619      	mov	r1, r3
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19330:	f6c0 031c 	movt	r3, #2076	; 0x81c
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19334:	f6c0 011e 	movt	r1, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19338:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1933a:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1933c:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1933e:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   19340:	2b00      	cmp	r3, #0
   19342:	f000 8089 	beq.w	19458 <EE_Init+0x380>
      else if (PageStatus1 == VALID_PAGE)
   19346:	2900      	cmp	r1, #0
   19348:	f040 80c0 	bne.w	194cc <EE_Init+0x3f4>
   1934c:	f64f 71e0 	movw	r1, #65504	; 0xffe0
   19350:	f64f 77c0 	movw	r7, #65472	; 0xffc0
   19354:	4694      	mov	ip, r2
   19356:	f6c0 011f 	movt	r1, #2079	; 0x81f
   1935a:	f6c0 071f 	movt	r7, #2079	; 0x81f
   1935e:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   19360:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   19362:	4288      	cmp	r0, r1
   19364:	d105      	bne.n	19372 <EE_Init+0x29a>
   19366:	e083      	b.n	19470 <EE_Init+0x398>
    AddressValue = (*(__IO uint16_t*)Address);
   19368:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
   1936c:	42b8      	cmp	r0, r7
   1936e:	d07d      	beq.n	1946c <EE_Init+0x394>
   19370:	460b      	mov	r3, r1
      Address = Address - 32;
   19372:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   19376:	4561      	cmp	r1, ip
   19378:	d8f6      	bhi.n	19368 <EE_Init+0x290>
   1937a:	3401      	adds	r4, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   1937c:	2c03      	cmp	r4, #3
   1937e:	d1cc      	bne.n	1931a <EE_Init+0x242>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   19380:	2100      	movs	r1, #0
   19382:	aa0e      	add	r2, sp, #56	; 0x38
   19384:	2001      	movs	r0, #1
   19386:	f6c0 011c 	movt	r1, #2076	; 0x81c
   1938a:	f7f2 fe33 	bl	bff4 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   1938e:	2800      	cmp	r0, #0
   19390:	f43f aefb 	beq.w	1918a <EE_Init+0xb2>
   19394:	e775      	b.n	19282 <EE_Init+0x1aa>
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
   19396:	f64f 76ff 	movw	r6, #65535	; 0xffff
   1939a:	42b7      	cmp	r7, r6
   1939c:	f000 808a 	beq.w	194b4 <EE_Init+0x3dc>
   193a0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   193a2:	ab16      	add	r3, sp, #88	; 0x58
   193a4:	464a      	mov	r2, r9
   193a6:	4641      	mov	r1, r8
   193a8:	4618      	mov	r0, r3
   193aa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   193ac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   193b0:	f016 feff 	bl	301b2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   193b4:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   193b6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   193ba:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   193be:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   193c2:	e002      	b.n	193ca <EE_Init+0x2f2>
  while (Address <= PAGE0_END_ADDRESS)
   193c4:	42ac      	cmp	r4, r5
   193c6:	f43f aed7 	beq.w	19178 <EE_Init+0xa0>
    AddressValue = (*(__IO uint16_t*)Address);
   193ca:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   193cc:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   193ce:	429e      	cmp	r6, r3
   193d0:	d0f8      	beq.n	193c4 <EE_Init+0x2ec>
   193d2:	e6ca      	b.n	1916a <EE_Init+0x92>
  while (Address <= PAGE0_END_ADDRESS)
   193d4:	42ac      	cmp	r4, r5
   193d6:	d00a      	beq.n	193ee <EE_Init+0x316>
    AddressValue = (*(__IO uint16_t*)Address);
   193d8:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   193da:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   193dc:	429e      	cmp	r6, r3
   193de:	d0f9      	beq.n	193d4 <EE_Init+0x2fc>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   193e0:	a902      	add	r1, sp, #8
   193e2:	a804      	add	r0, sp, #16
   193e4:	f7f2 ffc0 	bl	c368 <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   193e8:	2800      	cmp	r0, #0
   193ea:	f47f af4a 	bne.w	19282 <EE_Init+0x1aa>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
   193ee:	2100      	movs	r1, #0
   193f0:	aa0e      	add	r2, sp, #56	; 0x38
   193f2:	2001      	movs	r0, #1
   193f4:	f6c0 011e 	movt	r1, #2078	; 0x81e
   193f8:	f7f2 fdfc 	bl	bff4 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   193fc:	2800      	cmp	r0, #0
   193fe:	f43f aec4 	beq.w	1918a <EE_Init+0xb2>
   19402:	e73e      	b.n	19282 <EE_Init+0x1aa>
   19404:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   19406:	ab16      	add	r3, sp, #88	; 0x58
   19408:	464a      	mov	r2, r9
   1940a:	4639      	mov	r1, r7
   1940c:	4618      	mov	r0, r3
   1940e:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   19410:	9703      	str	r7, [sp, #12]
  uint32_t valid[8] = {0x0000};
   19412:	f016 fece 	bl	301b2 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   19416:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
   19418:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   1941c:	9709      	str	r7, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   1941e:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19422:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   19426:	e001      	b.n	1942c <EE_Init+0x354>
  while (Address <= PAGE0_END_ADDRESS)
   19428:	42ac      	cmp	r4, r5
   1942a:	d00a      	beq.n	19442 <EE_Init+0x36a>
    AddressValue = (*(__IO uint16_t*)Address);
   1942c:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   1942e:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   19430:	429a      	cmp	r2, r3
   19432:	d0f9      	beq.n	19428 <EE_Init+0x350>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   19434:	a903      	add	r1, sp, #12
   19436:	a809      	add	r0, sp, #36	; 0x24
   19438:	f7f2 ff96 	bl	c368 <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
   1943c:	2800      	cmp	r0, #0
   1943e:	f47f af20 	bne.w	19282 <EE_Init+0x1aa>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
   19442:	2100      	movs	r1, #0
   19444:	9a00      	ldr	r2, [sp, #0]
   19446:	2001      	movs	r0, #1
   19448:	f6c0 011c 	movt	r1, #2076	; 0x81c
   1944c:	f7f2 fdd2 	bl	bff4 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   19450:	2800      	cmp	r0, #0
   19452:	f43f ae9b 	beq.w	1918c <EE_Init+0xb4>
   19456:	e714      	b.n	19282 <EE_Init+0x1aa>
      if (PageStatus0 == VALID_PAGE)
   19458:	465f      	mov	r7, fp
   1945a:	46d4      	mov	ip, sl
   1945c:	4649      	mov	r1, r9
   1945e:	464b      	mov	r3, r9
   19460:	e77e      	b.n	19360 <EE_Init+0x288>
   19462:	4657      	mov	r7, sl
   19464:	4641      	mov	r1, r8
   19466:	4643      	mov	r3, r8
   19468:	46cc      	mov	ip, r9
   1946a:	e6d4      	b.n	19216 <EE_Init+0x13e>
   1946c:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   19470:	8839      	ldrh	r1, [r7, #0]
   19472:	f646 036a 	movw	r3, #26730	; 0x686a
   19476:	b289      	uxth	r1, r1
   19478:	f2c0 230e 	movt	r3, #526	; 0x20e
   1947c:	8019      	strh	r1, [r3, #0]
   1947e:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   19480:	f7ff fdd6 	bl	19030 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
   19484:	9a00      	ldr	r2, [sp, #0]
   19486:	4607      	mov	r7, r0
   19488:	2800      	cmp	r0, #0
   1948a:	f43f af76 	beq.w	1937a <EE_Init+0x2a2>
   1948e:	e67d      	b.n	1918c <EE_Init+0xb4>
   19490:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   19494:	8839      	ldrh	r1, [r7, #0]
   19496:	f646 036a 	movw	r3, #26730	; 0x686a
   1949a:	b289      	uxth	r1, r1
   1949c:	f2c0 230e 	movt	r3, #526	; 0x20e
   194a0:	8019      	strh	r1, [r3, #0]
   194a2:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   194a4:	f7ff fdc4 	bl	19030 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
   194a8:	9a00      	ldr	r2, [sp, #0]
   194aa:	4607      	mov	r7, r0
   194ac:	2800      	cmp	r0, #0
   194ae:	f43f aec0 	beq.w	19232 <EE_Init+0x15a>
   194b2:	e66b      	b.n	1918c <EE_Init+0xb4>
        pEraseInit.Sector = PAGE1_ID;
   194b4:	2307      	movs	r3, #7
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   194b6:	aa0e      	add	r2, sp, #56	; 0x38
   194b8:	4621      	mov	r1, r4
   194ba:	4650      	mov	r0, sl
        pEraseInit.Sector = PAGE1_ID;
   194bc:	e9cd a305 	strd	sl, r3, [sp, #20]
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   194c0:	f7f2 fd98 	bl	bff4 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   194c4:	2800      	cmp	r0, #0
   194c6:	f43f ae60 	beq.w	1918a <EE_Init+0xb2>
   194ca:	e6da      	b.n	19282 <EE_Init+0x1aa>
   194cc:	f646 036a 	movw	r3, #26730	; 0x686a
   194d0:	f2c0 230e 	movt	r3, #526	; 0x20e
   194d4:	8819      	ldrh	r1, [r3, #0]
   194d6:	e7d2      	b.n	1947e <EE_Init+0x3a6>
   194d8:	f646 036a 	movw	r3, #26730	; 0x686a
   194dc:	f2c0 230e 	movt	r3, #526	; 0x20e
   194e0:	8819      	ldrh	r1, [r3, #0]
   194e2:	e7de      	b.n	194a2 <EE_Init+0x3ca>

000194e4 <EE_ReadVariable>:
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   194e4:	2300      	movs	r3, #0
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   194e6:	461a      	mov	r2, r3
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   194e8:	f6c0 031c 	movt	r3, #2076	; 0x81c
{
   194ec:	b430      	push	{r4, r5}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   194ee:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   194f0:	f6c0 021e 	movt	r2, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   194f4:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   194f6:	8812      	ldrh	r2, [r2, #0]
      if (PageStatus0 == VALID_PAGE)
   194f8:	b173      	cbz	r3, 19518 <EE_ReadVariable+0x34>
   194fa:	b292      	uxth	r2, r2
      else if (PageStatus1 == VALID_PAGE)
   194fc:	bb7a      	cbnz	r2, 1955e <EE_ReadVariable+0x7a>
   194fe:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   19502:	f64f 72c0 	movw	r2, #65472	; 0xffc0
   19506:	2520      	movs	r5, #32
   19508:	f6c0 031f 	movt	r3, #2079	; 0x81f
   1950c:	f6c0 021f 	movt	r2, #2079	; 0x81f
   19510:	f6c0 051e 	movt	r5, #2078	; 0x81e
   19514:	461c      	mov	r4, r3
   19516:	e00b      	b.n	19530 <EE_ReadVariable+0x4c>
      if (PageStatus0 == VALID_PAGE)
   19518:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   1951c:	f64f 72c0 	movw	r2, #65472	; 0xffc0
   19520:	2520      	movs	r5, #32
   19522:	f6c0 031d 	movt	r3, #2077	; 0x81d
   19526:	f6c0 021d 	movt	r2, #2077	; 0x81d
   1952a:	f6c0 051c 	movt	r5, #2076	; 0x81c
   1952e:	461c      	mov	r4, r3
    AddressValue = (*(__IO uint16_t*)Address);
   19530:	8824      	ldrh	r4, [r4, #0]
    if (AddressValue == VirtAddress)
   19532:	42a0      	cmp	r0, r4
   19534:	d105      	bne.n	19542 <EE_ReadVariable+0x5e>
   19536:	e00d      	b.n	19554 <EE_ReadVariable+0x70>
    AddressValue = (*(__IO uint16_t*)Address);
   19538:	f833 4c20 	ldrh.w	r4, [r3, #-32]
    if (AddressValue == VirtAddress)
   1953c:	42a0      	cmp	r0, r4
   1953e:	d007      	beq.n	19550 <EE_ReadVariable+0x6c>
   19540:	4613      	mov	r3, r2
      Address = Address - 32;
   19542:	f1a3 0220 	sub.w	r2, r3, #32
  while (Address > (PageStartAddress + 32))
   19546:	42aa      	cmp	r2, r5
   19548:	d8f6      	bhi.n	19538 <EE_ReadVariable+0x54>
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
   1954a:	2001      	movs	r0, #1
}
   1954c:	bc30      	pop	{r4, r5}
   1954e:	4770      	bx	lr
   19550:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   19554:	8813      	ldrh	r3, [r2, #0]
      ReadStatus = 0;
   19556:	2000      	movs	r0, #0
      *Data = (*(__IO uint16_t*)(Address - 32));
   19558:	800b      	strh	r3, [r1, #0]
}
   1955a:	bc30      	pop	{r4, r5}
   1955c:	4770      	bx	lr
    return  NO_VALID_PAGE;
   1955e:	20ab      	movs	r0, #171	; 0xab
}
   19560:	bc30      	pop	{r4, r5}
   19562:	4770      	bx	lr

00019564 <EE_WriteVariable>:
{
   19564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19568:	2500      	movs	r5, #0
{
   1956a:	b09b      	sub	sp, #108	; 0x6c
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1956c:	462a      	mov	r2, r5
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1956e:	f6c0 051c 	movt	r5, #2076	; 0x81c
  uint32_t VirtAddress1[8] = {VirtAddress};
   19572:	9012      	str	r0, [sp, #72]	; 0x48
  uint32_t data32[8] = {Data};
   19574:	4613      	mov	r3, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19576:	f6c0 021e 	movt	r2, #2078	; 0x81e
  uint32_t data32[8] = {Data};
   1957a:	910a      	str	r1, [sp, #40]	; 0x28
   1957c:	9311      	str	r3, [sp, #68]	; 0x44
  uint32_t VirtAddress1[8] = {VirtAddress};
   1957e:	9319      	str	r3, [sp, #100]	; 0x64
  uint32_t data32[8] = {Data};
   19580:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   19584:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
   19588:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
  uint32_t VirtAddress1[8] = {VirtAddress};
   1958c:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
   19590:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
   19594:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19598:	882f      	ldrh	r7, [r5, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1959a:	8813      	ldrh	r3, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1959c:	b2bf      	uxth	r7, r7
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1959e:	b29b      	uxth	r3, r3
      if (PageStatus1 == VALID_PAGE)
   195a0:	bb43      	cbnz	r3, 195f4 <EE_WriteVariable+0x90>
        if (PageStatus0 == RECEIVE_DATA)
   195a2:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
   195a6:	1aff      	subs	r7, r7, r3
   195a8:	bf18      	it	ne
   195aa:	2701      	movne	r7, #1
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   195ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
   195b0:	1c7b      	adds	r3, r7, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   195b2:	f207 470e 	addw	r7, r7, #1038	; 0x40e
   195b6:	4688      	mov	r8, r1
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   195b8:	f6c0 021b 	movt	r2, #2075	; 0x81b
   195bc:	4604      	mov	r4, r0
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   195be:	047f      	lsls	r7, r7, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   195c0:	eb02 4243 	add.w	r2, r2, r3, lsl #17
  while (Address < PageEndAddress)
   195c4:	4297      	cmp	r7, r2
   195c6:	d303      	bcc.n	195d0 <EE_WriteVariable+0x6c>
   195c8:	e021      	b.n	1960e <EE_WriteVariable+0xaa>
      Address = Address + 64;
   195ca:	3740      	adds	r7, #64	; 0x40
  while (Address < PageEndAddress)
   195cc:	42ba      	cmp	r2, r7
   195ce:	d91e      	bls.n	1960e <EE_WriteVariable+0xaa>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
   195d0:	683b      	ldr	r3, [r7, #0]
   195d2:	3301      	adds	r3, #1
   195d4:	d1f9      	bne.n	195ca <EE_WriteVariable+0x66>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
   195d6:	ae0a      	add	r6, sp, #40	; 0x28
   195d8:	4639      	mov	r1, r7
   195da:	2001      	movs	r0, #1
   195dc:	4632      	mov	r2, r6
   195de:	f7f2 fd09 	bl	bff4 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
   195e2:	2800      	cmp	r0, #0
   195e4:	d043      	beq.n	1966e <EE_WriteVariable+0x10a>
     return FlashStatus;
   195e6:	b285      	uxth	r5, r0
  if (Status == PAGE_FULL)
   195e8:	2d80      	cmp	r5, #128	; 0x80
   195ea:	d011      	beq.n	19610 <EE_WriteVariable+0xac>
}
   195ec:	4628      	mov	r0, r5
   195ee:	b01b      	add	sp, #108	; 0x6c
   195f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (PageStatus0 == VALID_PAGE)
   195f4:	b937      	cbnz	r7, 19604 <EE_WriteVariable+0xa0>
        if (PageStatus1 == RECEIVE_DATA)
   195f6:	f64e 67ee 	movw	r7, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
   195fa:	1bdf      	subs	r7, r3, r7
   195fc:	fab7 f787 	clz	r7, r7
   19600:	097f      	lsrs	r7, r7, #5
   19602:	e7d3      	b.n	195ac <EE_WriteVariable+0x48>
    /* Old page ID where variable will be taken from */
    OldPageId = PAGE0_ID;
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
   19604:	25ab      	movs	r5, #171	; 0xab
}
   19606:	4628      	mov	r0, r5
   19608:	b01b      	add	sp, #108	; 0x6c
   1960a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1960e:	ae0a      	add	r6, sp, #40	; 0x28
  uint32_t SectorError = 0;
   19610:	2500      	movs	r5, #0
  uint32_t valid[8] = {0x0000};
   19612:	2220      	movs	r2, #32
   19614:	4630      	mov	r0, r6
   19616:	4629      	mov	r1, r5
  uint32_t SectorError = 0;
   19618:	9504      	str	r5, [sp, #16]
  uint32_t valid[8] = {0x0000};
   1961a:	f016 fdca 	bl	301b2 <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1961e:	4629      	mov	r1, r5
  uint32_t receive[8] = {0xEEEE};
   19620:	f64e 63ee 	movw	r3, #61166	; 0xeeee
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19624:	462f      	mov	r7, r5
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19626:	f6c0 011c 	movt	r1, #2076	; 0x81c
  uint32_t receive[8] = {0xEEEE};
   1962a:	9519      	str	r5, [sp, #100]	; 0x64
   1962c:	9312      	str	r3, [sp, #72]	; 0x48
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1962e:	f6c0 071e 	movt	r7, #2078	; 0x81e
  uint32_t receive[8] = {0xEEEE};
   19632:	e9cd 5513 	strd	r5, r5, [sp, #76]	; 0x4c
   19636:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
   1963a:	e9cd 5517 	strd	r5, r5, [sp, #92]	; 0x5c
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1963e:	880b      	ldrh	r3, [r1, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19640:	883a      	ldrh	r2, [r7, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19642:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   19644:	b292      	uxth	r2, r2
      if (PageStatus0 == VALID_PAGE)
   19646:	b17b      	cbz	r3, 19668 <EE_WriteVariable+0x104>
      else if (PageStatus1 == VALID_PAGE)
   19648:	2a00      	cmp	r2, #0
   1964a:	d1db      	bne.n	19604 <EE_WriteVariable+0xa0>
    NewPageAddress = PAGE0_BASE_ADDRESS;
   1964c:	460f      	mov	r7, r1
      else if (PageStatus1 == VALID_PAGE)
   1964e:	f04f 0907 	mov.w	r9, #7
  }

  /* Set the new Page status to RECEIVE_DATA status */

  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)receive));
   19652:	aa12      	add	r2, sp, #72	; 0x48
   19654:	4639      	mov	r1, r7
   19656:	2001      	movs	r0, #1
   19658:	f7f2 fccc 	bl	bff4 <HAL_FLASH_Program>

  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
   1965c:	b170      	cbz	r0, 1967c <EE_WriteVariable+0x118>
  /* Set new Page status to VALID_PAGE status */
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
  {
    return FlashStatus;
   1965e:	b285      	uxth	r5, r0
}
   19660:	4628      	mov	r0, r5
   19662:	b01b      	add	sp, #108	; 0x6c
   19664:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus0 == VALID_PAGE)
   19668:	f04f 0906 	mov.w	r9, #6
   1966c:	e7f1      	b.n	19652 <EE_WriteVariable+0xee>
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
   1966e:	f107 0120 	add.w	r1, r7, #32
   19672:	aa12      	add	r2, sp, #72	; 0x48
   19674:	2001      	movs	r0, #1
   19676:	f7f2 fcbd 	bl	bff4 <HAL_FLASH_Program>
   1967a:	e7b4      	b.n	195e6 <EE_WriteVariable+0x82>
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
   1967c:	4641      	mov	r1, r8
   1967e:	4620      	mov	r0, r4
   19680:	f7ff fcd6 	bl	19030 <EE_VerifyPageFullWriteVariable>
  if (EepromStatus != HAL_OK)
   19684:	4605      	mov	r5, r0
   19686:	2800      	cmp	r0, #0
   19688:	d1b0      	bne.n	195ec <EE_WriteVariable+0x88>
      if (PageStatus0 == VALID_PAGE)
   1968a:	2320      	movs	r3, #32
   1968c:	f64f 72c0 	movw	r2, #65472	; 0xffc0
   19690:	f246 081c 	movw	r8, #24604	; 0x601c
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   19694:	f04f 0b00 	mov.w	fp, #0
      else if (PageStatus1 == VALID_PAGE)
   19698:	4619      	mov	r1, r3
      if (PageStatus0 == VALID_PAGE)
   1969a:	f6c0 021d 	movt	r2, #2077	; 0x81d
   1969e:	f6c0 031c 	movt	r3, #2076	; 0x81c
   196a2:	f64f 7ae0 	movw	sl, #65504	; 0xffe0
      else if (PageStatus1 == VALID_PAGE)
   196a6:	f6c0 011e 	movt	r1, #2078	; 0x81e
   196aa:	f2c0 0806 	movt	r8, #6
      if (PageStatus0 == VALID_PAGE)
   196ae:	9301      	str	r3, [sp, #4]
      else if (PageStatus1 == VALID_PAGE)
   196b0:	4613      	mov	r3, r2
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   196b2:	f6c0 0b1c 	movt	fp, #2076	; 0x81c
      else if (PageStatus1 == VALID_PAGE)
   196b6:	4632      	mov	r2, r6
      if (PageStatus0 == VALID_PAGE)
   196b8:	f6c0 0a1d 	movt	sl, #2077	; 0x81d
      else if (PageStatus1 == VALID_PAGE)
   196bc:	4606      	mov	r6, r0
   196be:	461d      	mov	r5, r3
   196c0:	9103      	str	r1, [sp, #12]
    if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
   196c2:	f838 0b02 	ldrh.w	r0, [r8], #2
   196c6:	4284      	cmp	r4, r0
   196c8:	d023      	beq.n	19712 <EE_WriteVariable+0x1ae>
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   196ca:	2100      	movs	r1, #0
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   196cc:	f8bb 3000 	ldrh.w	r3, [fp]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   196d0:	f6c0 011e 	movt	r1, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   196d4:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   196d6:	8809      	ldrh	r1, [r1, #0]
   196d8:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   196da:	2b00      	cmp	r3, #0
   196dc:	d043      	beq.n	19766 <EE_WriteVariable+0x202>
      else if (PageStatus1 == VALID_PAGE)
   196de:	2900      	cmp	r1, #0
   196e0:	d159      	bne.n	19796 <EE_WriteVariable+0x232>
   196e2:	f64f 71e0 	movw	r1, #65504	; 0xffe0
   196e6:	f64f 7cc0 	movw	ip, #65472	; 0xffc0
   196ea:	f8dd e00c 	ldr.w	lr, [sp, #12]
   196ee:	f6c0 011f 	movt	r1, #2079	; 0x81f
   196f2:	f6c0 0c1f 	movt	ip, #2079	; 0x81f
   196f6:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   196f8:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   196fa:	4288      	cmp	r0, r1
   196fc:	d105      	bne.n	1970a <EE_WriteVariable+0x1a6>
   196fe:	e03a      	b.n	19776 <EE_WriteVariable+0x212>
    AddressValue = (*(__IO uint16_t*)Address);
   19700:	f833 cc20 	ldrh.w	ip, [r3, #-32]
    if (AddressValue == VirtAddress)
   19704:	4560      	cmp	r0, ip
   19706:	d034      	beq.n	19772 <EE_WriteVariable+0x20e>
   19708:	460b      	mov	r3, r1
      Address = Address - 32;
   1970a:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   1970e:	458e      	cmp	lr, r1
   19710:	d3f6      	bcc.n	19700 <EE_WriteVariable+0x19c>
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   19712:	f246 0322 	movw	r3, #24610	; 0x6022
   19716:	f2c0 0306 	movt	r3, #6
   1971a:	4598      	cmp	r8, r3
   1971c:	d1d1      	bne.n	196c2 <EE_WriteVariable+0x15e>
   1971e:	4635      	mov	r5, r6
   19720:	4616      	mov	r6, r2
  HAL_FLASH_Unlock();
   19722:	f7f2 fced 	bl	c100 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   19726:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   1972a:	f44f 008e 	mov.w	r0, #4653056	; 0x470000
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   1972e:	2100      	movs	r1, #0
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   19730:	f2c5 2300 	movt	r3, #20992	; 0x5200
  pEraseInit.Banks = FLASH_BANK_2 ;
   19734:	2202      	movs	r2, #2
  pEraseInit.NbSectors = 1;
   19736:	2401      	movs	r4, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   19738:	6158      	str	r0, [r3, #20]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   1973a:	2320      	movs	r3, #32
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   1973c:	9105      	str	r1, [sp, #20]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   1973e:	a805      	add	r0, sp, #20
   19740:	a904      	add	r1, sp, #16
  pEraseInit.Sector = OldPageId;
   19742:	f8cd 901c 	str.w	r9, [sp, #28]
  pEraseInit.Banks = FLASH_BANK_2 ;
   19746:	9206      	str	r2, [sp, #24]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   19748:	e9cd 4308 	strd	r4, r3, [sp, #32]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   1974c:	f7f2 fe0c 	bl	c368 <HAL_FLASHEx_Erase>
  if (FlashStatus != HAL_OK)
   19750:	2800      	cmp	r0, #0
   19752:	d184      	bne.n	1965e <EE_WriteVariable+0xfa>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
   19754:	4632      	mov	r2, r6
   19756:	4639      	mov	r1, r7
   19758:	4620      	mov	r0, r4
   1975a:	f7f2 fc4b 	bl	bff4 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   1975e:	2800      	cmp	r0, #0
   19760:	f47f af7d 	bne.w	1965e <EE_WriteVariable+0xfa>
   19764:	e742      	b.n	195ec <EE_WriteVariable+0x88>
      if (PageStatus0 == VALID_PAGE)
   19766:	46ac      	mov	ip, r5
   19768:	4651      	mov	r1, sl
   1976a:	4653      	mov	r3, sl
   1976c:	f8dd e004 	ldr.w	lr, [sp, #4]
   19770:	e7c2      	b.n	196f8 <EE_WriteVariable+0x194>
   19772:	f1a3 0c40 	sub.w	ip, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   19776:	f8bc 1000 	ldrh.w	r1, [ip]
   1977a:	f646 036a 	movw	r3, #26730	; 0x686a
   1977e:	b289      	uxth	r1, r1
   19780:	f2c0 230e 	movt	r3, #526	; 0x20e
   19784:	8019      	strh	r1, [r3, #0]
   19786:	9202      	str	r2, [sp, #8]
        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   19788:	f7ff fc52 	bl	19030 <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != HAL_OK)
   1978c:	9a02      	ldr	r2, [sp, #8]
   1978e:	2800      	cmp	r0, #0
   19790:	d0bf      	beq.n	19712 <EE_WriteVariable+0x1ae>
   19792:	4605      	mov	r5, r0
  return Status;
   19794:	e72a      	b.n	195ec <EE_WriteVariable+0x88>
   19796:	f646 036a 	movw	r3, #26730	; 0x686a
   1979a:	f2c0 230e 	movt	r3, #526	; 0x20e
   1979e:	8819      	ldrh	r1, [r3, #0]
   197a0:	e7f1      	b.n	19786 <EE_WriteVariable+0x222>
   197a2:	bf00      	nop

000197a4 <MX_FATFS_Init>:
/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
   197a4:	f64a 619c 	movw	r1, #44700	; 0xae9c
   197a8:	f244 706c 	movw	r0, #18284	; 0x476c
{
   197ac:	b508      	push	{r3, lr}
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
   197ae:	f2c0 210f 	movt	r1, #527	; 0x20f
   197b2:	f2c0 0003 	movt	r0, #3
   197b6:	f7fe fb5b 	bl	17e70 <FATFS_LinkDriver>
   197ba:	f64a 6398 	movw	r3, #44696	; 0xae98
   197be:	f2c0 230f 	movt	r3, #527	; 0x20f
   197c2:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
   197c4:	bd08      	pop	{r3, pc}
   197c6:	bf00      	nop

000197c8 <BSP_PlatformIsDetected>:
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
   197c8:	f44f 6000 	mov.w	r0, #2048	; 0x800
   197cc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
uint8_t	BSP_PlatformIsDetected(void) {
   197d0:	b508      	push	{r3, lr}
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
   197d2:	f6c5 0002 	movt	r0, #22530	; 0x5802
   197d6:	f7f3 fa75 	bl	ccc4 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */ 
    return status;
}  
   197da:	fab0 f080 	clz	r0, r0
   197de:	0940      	lsrs	r0, r0, #5
   197e0:	bd08      	pop	{r3, pc}
   197e2:	bf00      	nop

000197e4 <MX_FMC_Init>:
{
  FMC_SDRAM_TimingTypeDef SdramTiming = {0};

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   197e4:	f24b 3300 	movw	r3, #45824	; 0xb300
   197e8:	f244 1240 	movw	r2, #16704	; 0x4140
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
   197ec:	2001      	movs	r0, #1
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
   197ee:	2108      	movs	r1, #8
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   197f0:	f2c0 230f 	movt	r3, #527	; 0x20f
   197f4:	f2c5 2200 	movt	r2, #20992	; 0x5200
{
   197f8:	b570      	push	{r4, r5, r6, lr}
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   197fa:	2640      	movs	r6, #64	; 0x40
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
   197fc:	2410      	movs	r4, #16
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
   197fe:	f44f 7580 	mov.w	r5, #256	; 0x100
{
   19802:	b088      	sub	sp, #32
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
   19804:	6098      	str	r0, [r3, #8]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
   19806:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
   1980a:	60d9      	str	r1, [r3, #12]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
   1980c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   19810:	615e      	str	r6, [r3, #20]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
  SdramTiming.ExitSelfRefreshDelay = 6;
  SdramTiming.SelfRefreshTime = 4;
   19812:	2604      	movs	r6, #4
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   19814:	601a      	str	r2, [r3, #0]
  SdramTiming.LoadToActiveDelay = 2;
   19816:	2202      	movs	r2, #2
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
   19818:	611c      	str	r4, [r3, #16]
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
   1981a:	2400      	movs	r4, #0
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
   1981c:	619d      	str	r5, [r3, #24]
  SdramTiming.ExitSelfRefreshDelay = 6;
   1981e:	2506      	movs	r5, #6
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
   19820:	6218      	str	r0, [r3, #32]
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 2;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   19822:	4618      	mov	r0, r3
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
   19824:	6259      	str	r1, [r3, #36]	; 0x24
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   19826:	eb0d 0106 	add.w	r1, sp, r6
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
   1982a:	605c      	str	r4, [r3, #4]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
   1982c:	61dc      	str	r4, [r3, #28]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
   1982e:	629c      	str	r4, [r3, #40]	; 0x28
  SdramTiming.LoadToActiveDelay = 2;
   19830:	9201      	str	r2, [sp, #4]
  SdramTiming.RCDDelay = 2;
   19832:	9207      	str	r2, [sp, #28]
  SdramTiming.ExitSelfRefreshDelay = 6;
   19834:	9502      	str	r5, [sp, #8]
  SdramTiming.RPDelay = 2;
   19836:	e9cd 2205 	strd	r2, r2, [sp, #20]
  SdramTiming.SelfRefreshTime = 4;
   1983a:	e9cd 6503 	strd	r6, r5, [sp, #12]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   1983e:	f7f9 fd41 	bl	132c4 <HAL_SDRAM_Init>
   19842:	b108      	cbz	r0, 19848 <MX_FMC_Init+0x64>
  {
    Error_Handler( );
   19844:	f001 fc32 	bl	1b0ac <Error_Handler>
  }

  HAL_SetFMCMemorySwappingConfig(FMC_SWAPBMAP_SDRAM_SRAM);
   19848:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
   1984c:	f7ee fe1a 	bl	8484 <HAL_SetFMCMemorySwappingConfig>

}
   19850:	b008      	add	sp, #32
   19852:	bd70      	pop	{r4, r5, r6, pc}

00019854 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (FMC_Initialized) {
   19854:	f646 026c 	movw	r2, #26732	; 0x686c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   19858:	2300      	movs	r3, #0
  if (FMC_Initialized) {
   1985a:	f2c0 220e 	movt	r2, #526	; 0x20e
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
   1985e:	b5f0      	push	{r4, r5, r6, r7, lr}
   19860:	b087      	sub	sp, #28
  if (FMC_Initialized) {
   19862:	6814      	ldr	r4, [r2, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   19864:	9302      	str	r3, [sp, #8]
   19866:	9301      	str	r3, [sp, #4]
   19868:	9305      	str	r3, [sp, #20]
   1986a:	e9cd 3303 	strd	r3, r3, [sp, #12]
  if (FMC_Initialized) {
   1986e:	b10c      	cbz	r4, 19874 <HAL_SDRAM_MspInit+0x20>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
   19870:	b007      	add	sp, #28
   19872:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_RCC_FMC_CLK_ENABLE();
   19874:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  FMC_Initialized = 1;
   19878:	2501      	movs	r5, #1
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
   1987a:	f64f 013f 	movw	r1, #63551	; 0xf83f
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1987e:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
  __HAL_RCC_FMC_CLK_ENABLE();
   19882:	f6c5 0302 	movt	r3, #22530	; 0x5802
  FMC_Initialized = 1;
   19886:	6015      	str	r5, [r2, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19888:	2702      	movs	r7, #2
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1988a:	2603      	movs	r6, #3
  __HAL_RCC_FMC_CLK_ENABLE();
   1988c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   19890:	250c      	movs	r5, #12
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   19892:	f6c5 0002 	movt	r0, #22530	; 0x5802
  __HAL_RCC_FMC_CLK_ENABLE();
   19896:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   1989a:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
   1989e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
   198a2:	9101      	str	r1, [sp, #4]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   198a4:	a901      	add	r1, sp, #4
  __HAL_RCC_FMC_CLK_ENABLE();
   198a6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   198aa:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   198ac:	9604      	str	r6, [sp, #16]
  __HAL_RCC_FMC_CLK_ENABLE();
   198ae:	9300      	str	r3, [sp, #0]
   198b0:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   198b2:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   198b4:	f7f2 fe70 	bl	c598 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   198b8:	f44f 6000 	mov.w	r0, #2048	; 0x800
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
   198bc:	230d      	movs	r3, #13
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   198be:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   198c0:	9702      	str	r7, [sp, #8]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   198c2:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
   198c6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   198c8:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   198ca:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   198ce:	f7f2 fe63 	bl	c598 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   198d2:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
   198d6:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   198da:	a901      	add	r1, sp, #4
   198dc:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   198e0:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
   198e2:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   198e4:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   198e6:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   198ea:	f7f2 fe55 	bl	c598 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   198ee:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
   198f2:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   198f6:	a901      	add	r1, sp, #4
   198f8:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   198fc:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
   198fe:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   19900:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   19902:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19906:	f7f2 fe47 	bl	c598 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1990a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
   1990e:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   19912:	a901      	add	r1, sp, #4
   19914:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19918:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1991a:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
   1991c:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   1991e:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   19922:	f7f2 fe39 	bl	c598 <HAL_GPIO_Init>
}
   19926:	b007      	add	sp, #28
   19928:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1992a:	bf00      	nop

0001992c <GFXdrawPixel.part.0>:
void GFXstartWrite(GFX* myGFX){
    // Overwrite in subclasses if desired!
}

// the most basic function, set a single pixel
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
   1992c:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
    return;

  // check rotation, move pixel around if necessary
  switch (GFXgetRotation(myGFX)) {
   1992e:	7a04      	ldrb	r4, [r0, #8]
   19930:	2c02      	cmp	r4, #2
   19932:	d057      	beq.n	199e4 <GFXdrawPixel.part.0+0xb8>
   19934:	2c03      	cmp	r4, #3
   19936:	d04f      	beq.n	199d8 <GFXdrawPixel.part.0+0xac>
   19938:	2c01      	cmp	r4, #1
   1993a:	d01a      	beq.n	19972 <GFXdrawPixel.part.0+0x46>
    y = myGFX->HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
   1993c:	2b01      	cmp	r3, #1
   1993e:	d020      	beq.n	19982 <GFXdrawPixel.part.0+0x56>
   19940:	d334      	bcc.n	199ac <GFXdrawPixel.part.0+0x80>
   19942:	2b02      	cmp	r3, #2
   19944:	d113      	bne.n	1996e <GFXdrawPixel.part.0+0x42>
    {
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
   19946:	2a00      	cmp	r2, #0
   19948:	4613      	mov	r3, r2
   1994a:	8804      	ldrh	r4, [r0, #0]
   1994c:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   19950:	bfb8      	it	lt
   19952:	1dd3      	addlt	r3, r2, #7
   19954:	f002 0207 	and.w	r2, r2, #7
   19958:	f2c0 200f 	movt	r0, #527	; 0x20f
   1995c:	10db      	asrs	r3, r3, #3
   1995e:	fb13 1104 	smlabb	r1, r3, r4, r1
   19962:	2301      	movs	r3, #1
   19964:	fa03 f202 	lsl.w	r2, r3, r2
   19968:	5c43      	ldrb	r3, [r0, r1]
   1996a:	405a      	eors	r2, r3
   1996c:	5442      	strb	r2, [r0, r1]
    }

}
   1996e:	bc30      	pop	{r4, r5}
   19970:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
   19972:	43d4      	mvns	r4, r2
   19974:	8805      	ldrh	r5, [r0, #0]
    _swap_int16_t(x, y);
   19976:	460a      	mov	r2, r1
    switch (color)
   19978:	2b01      	cmp	r3, #1
    x = myGFX->WIDTH - x - 1;
   1997a:	eb04 0105 	add.w	r1, r4, r5
   1997e:	b209      	sxth	r1, r1
    switch (color)
   19980:	d1de      	bne.n	19940 <GFXdrawPixel.part.0+0x14>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
   19982:	2a00      	cmp	r2, #0
   19984:	4613      	mov	r3, r2
   19986:	8805      	ldrh	r5, [r0, #0]
   19988:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   1998c:	bfb8      	it	lt
   1998e:	1dd3      	addlt	r3, r2, #7
   19990:	f002 0407 	and.w	r4, r2, #7
   19994:	f2c0 200f 	movt	r0, #527	; 0x20f
   19998:	2201      	movs	r2, #1
   1999a:	10db      	asrs	r3, r3, #3
   1999c:	40a2      	lsls	r2, r4
   1999e:	fb13 1105 	smlabb	r1, r3, r5, r1
   199a2:	5c43      	ldrb	r3, [r0, r1]
   199a4:	431a      	orrs	r2, r3
   199a6:	5442      	strb	r2, [r0, r1]
}
   199a8:	bc30      	pop	{r4, r5}
   199aa:	4770      	bx	lr
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
   199ac:	2a00      	cmp	r2, #0
   199ae:	4613      	mov	r3, r2
   199b0:	8804      	ldrh	r4, [r0, #0]
   199b2:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   199b6:	bfb8      	it	lt
   199b8:	1dd3      	addlt	r3, r2, #7
   199ba:	f002 0207 	and.w	r2, r2, #7
   199be:	f2c0 200f 	movt	r0, #527	; 0x20f
   199c2:	10db      	asrs	r3, r3, #3
   199c4:	fb13 1104 	smlabb	r1, r3, r4, r1
   199c8:	2301      	movs	r3, #1
   199ca:	4093      	lsls	r3, r2
   199cc:	5c42      	ldrb	r2, [r0, r1]
   199ce:	ea22 0203 	bic.w	r2, r2, r3
   199d2:	5442      	strb	r2, [r0, r1]
}
   199d4:	bc30      	pop	{r4, r5}
   199d6:	4770      	bx	lr
    y = myGFX->HEIGHT - y - 1;
   199d8:	43cc      	mvns	r4, r1
   199da:	8845      	ldrh	r5, [r0, #2]
	_swap_int16_t(x, y);
   199dc:	4611      	mov	r1, r2
    y = myGFX->HEIGHT - y - 1;
   199de:	1962      	adds	r2, r4, r5
   199e0:	b212      	sxth	r2, r2
   199e2:	e7ab      	b.n	1993c <GFXdrawPixel.part.0+0x10>
    x = myGFX->WIDTH - x - 1;
   199e4:	43c9      	mvns	r1, r1
    y = myGFX->HEIGHT - y - 1;
   199e6:	43d2      	mvns	r2, r2
    x = myGFX->WIDTH - x - 1;
   199e8:	8805      	ldrh	r5, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
   199ea:	8844      	ldrh	r4, [r0, #2]
    x = myGFX->WIDTH - x - 1;
   199ec:	4429      	add	r1, r5
    y = myGFX->HEIGHT - y - 1;
   199ee:	4422      	add	r2, r4
    x = myGFX->WIDTH - x - 1;
   199f0:	b209      	sxth	r1, r1
    y = myGFX->HEIGHT - y - 1;
   199f2:	b212      	sxth	r2, r2
   199f4:	e7a2      	b.n	1993c <GFXdrawPixel.part.0+0x10>
   199f6:	bf00      	nop

000199f8 <GFXinit>:
	myGfx->WIDTH = w;
   199f8:	2300      	movs	r3, #0
	myGfx->_width    = w;
   199fa:	8081      	strh	r1, [r0, #4]
	myGfx->_height   = h;
   199fc:	80c2      	strh	r2, [r0, #6]
	myGfx->WIDTH = w;
   199fe:	f361 030f 	bfi	r3, r1, #0, #16
	myGfx->rotation  = 0;
   19a02:	2101      	movs	r1, #1
	myGfx->WIDTH = w;
   19a04:	f362 431f 	bfi	r3, r2, #16, #16
	myGfx->fontHeight = 8;
   19a08:	2208      	movs	r2, #8
	myGfx->rotation  = 0;
   19a0a:	6141      	str	r1, [r0, #20]
	myGfx->WIDTH = w;
   19a0c:	6003      	str	r3, [r0, #0]
	myGfx->rotation  = 0;
   19a0e:	2300      	movs	r3, #0
	myGfx->fontHeight = 8;
   19a10:	61c2      	str	r2, [r0, #28]
	myGfx->rotation  = 0;
   19a12:	6083      	str	r3, [r0, #8]
	myGfx->gfxFont   = NULL;
   19a14:	6183      	str	r3, [r0, #24]
{
   19a16:	b430      	push	{r4, r5}
	myGfx->rotation  = 0;
   19a18:	f44f 3580 	mov.w	r5, #65536	; 0x10000
   19a1c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   19a20:	e9c0 5403 	strd	r5, r4, [r0, #12]
}
   19a24:	bc30      	pop	{r4, r5}
   19a26:	4770      	bx	lr

00019a28 <GFXwriteLine>:
        uint16_t color) {
   19a28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19a2c:	b083      	sub	sp, #12
   19a2e:	461e      	mov	r6, r3
   19a30:	4617      	mov	r7, r2
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   19a32:	4694      	mov	ip, r2
        uint16_t color) {
   19a34:	f9bd 5030 	ldrsh.w	r5, [sp, #48]	; 0x30
   19a38:	4682      	mov	sl, r0
   19a3a:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   19a3e:	1aab      	subs	r3, r5, r2
   19a40:	1a72      	subs	r2, r6, r1
        uint16_t color) {
   19a42:	9001      	str	r0, [sp, #4]
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   19a44:	2b00      	cmp	r3, #0
   19a46:	bfb8      	it	lt
   19a48:	425b      	neglt	r3, r3
   19a4a:	2a00      	cmp	r2, #0
   19a4c:	bfb8      	it	lt
   19a4e:	4252      	neglt	r2, r2
    if (steep) {
   19a50:	4293      	cmp	r3, r2
   19a52:	dc7d      	bgt.n	19b50 <GFXwriteLine+0x128>
   19a54:	46ae      	mov	lr, r5
   19a56:	462c      	mov	r4, r5
   19a58:	46bb      	mov	fp, r7
   19a5a:	4635      	mov	r5, r6
   19a5c:	460f      	mov	r7, r1
   19a5e:	4676      	mov	r6, lr
   19a60:	4661      	mov	r1, ip
   19a62:	4698      	mov	r8, r3
    if (x0 > x1) {
   19a64:	42af      	cmp	r7, r5
   19a66:	dd5f      	ble.n	19b28 <GFXwriteLine+0x100>
    dx = x1 - x0;
   19a68:	eba7 0905 	sub.w	r9, r7, r5
   19a6c:	ebab 0004 	sub.w	r0, fp, r4
    if (y0 < y1) {
   19a70:	f64f 7bff 	movw	fp, #65535	; 0xffff
    dx = x1 - x0;
   19a74:	fa1f f989 	uxth.w	r9, r9
   19a78:	ea80 78e0 	eor.w	r8, r0, r0, asr #31
    int16_t err = dx / 2;
   19a7c:	fa0f f489 	sxth.w	r4, r9
   19a80:	eba8 78e0 	sub.w	r8, r8, r0, asr #31
   19a84:	2c00      	cmp	r4, #0
   19a86:	bfb8      	it	lt
   19a88:	3401      	addlt	r4, #1
    if (y0 < y1) {
   19a8a:	42b1      	cmp	r1, r6
   19a8c:	bfc8      	it	gt
   19a8e:	f04f 0b01 	movgt.w	fp, #1
    int16_t err = dx / 2;
   19a92:	1064      	asrs	r4, r4, #1
   19a94:	4293      	cmp	r3, r2
   19a96:	fa1f f888 	uxth.w	r8, r8
   19a9a:	dc3c      	bgt.n	19b16 <GFXwriteLine+0xee>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   19a9c:	2d00      	cmp	r5, #0
   19a9e:	db0f      	blt.n	19ac0 <GFXwriteLine+0x98>
   19aa0:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   19aa4:	42ab      	cmp	r3, r5
   19aa6:	dd0b      	ble.n	19ac0 <GFXwriteLine+0x98>
   19aa8:	0432      	lsls	r2, r6, #16
   19aaa:	d409      	bmi.n	19ac0 <GFXwriteLine+0x98>
   19aac:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   19ab0:	4632      	mov	r2, r6
   19ab2:	4629      	mov	r1, r5
   19ab4:	9b01      	ldr	r3, [sp, #4]
   19ab6:	42b0      	cmp	r0, r6
   19ab8:	4650      	mov	r0, sl
   19aba:	dd01      	ble.n	19ac0 <GFXwriteLine+0x98>
   19abc:	f7ff ff36 	bl	1992c <GFXdrawPixel.part.0>
        err -= dy;
   19ac0:	eba4 0408 	sub.w	r4, r4, r8
   19ac4:	3501      	adds	r5, #1
   19ac6:	b2a3      	uxth	r3, r4
   19ac8:	b22d      	sxth	r5, r5
   19aca:	b21c      	sxth	r4, r3
        if (err < 0) {
   19acc:	2c00      	cmp	r4, #0
   19ace:	da04      	bge.n	19ada <GFXwriteLine+0xb2>
            y0 += ystep;
   19ad0:	445e      	add	r6, fp
            err += dx;
   19ad2:	eb09 0403 	add.w	r4, r9, r3
            y0 += ystep;
   19ad6:	b236      	sxth	r6, r6
            err += dx;
   19ad8:	b224      	sxth	r4, r4
    for (; x0<=x1; x0++) {
   19ada:	42af      	cmp	r7, r5
   19adc:	dade      	bge.n	19a9c <GFXwriteLine+0x74>
}
   19ade:	b003      	add	sp, #12
   19ae0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   19ae4:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   19ae8:	462a      	mov	r2, r5
   19aea:	4631      	mov	r1, r6
   19aec:	9b01      	ldr	r3, [sp, #4]
   19aee:	4285      	cmp	r5, r0
   19af0:	4650      	mov	r0, sl
   19af2:	da01      	bge.n	19af8 <GFXwriteLine+0xd0>
   19af4:	f7ff ff1a 	bl	1992c <GFXdrawPixel.part.0>
        err -= dy;
   19af8:	eba4 0408 	sub.w	r4, r4, r8
   19afc:	3501      	adds	r5, #1
   19afe:	b2a3      	uxth	r3, r4
   19b00:	b22d      	sxth	r5, r5
   19b02:	b21c      	sxth	r4, r3
        if (err < 0) {
   19b04:	2c00      	cmp	r4, #0
   19b06:	da04      	bge.n	19b12 <GFXwriteLine+0xea>
            y0 += ystep;
   19b08:	445e      	add	r6, fp
            err += dx;
   19b0a:	eb03 0409 	add.w	r4, r3, r9
            y0 += ystep;
   19b0e:	b236      	sxth	r6, r6
            err += dx;
   19b10:	b224      	sxth	r4, r4
    for (; x0<=x1; x0++) {
   19b12:	42af      	cmp	r7, r5
   19b14:	dbe3      	blt.n	19ade <GFXwriteLine+0xb6>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   19b16:	2e00      	cmp	r6, #0
   19b18:	dbee      	blt.n	19af8 <GFXwriteLine+0xd0>
   19b1a:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   19b1e:	429e      	cmp	r6, r3
   19b20:	daea      	bge.n	19af8 <GFXwriteLine+0xd0>
   19b22:	042b      	lsls	r3, r5, #16
   19b24:	d4e8      	bmi.n	19af8 <GFXwriteLine+0xd0>
   19b26:	e7dd      	b.n	19ae4 <GFXwriteLine+0xbc>
    dx = x1 - x0;
   19b28:	eba5 0907 	sub.w	r9, r5, r7
    if (y0 < y1) {
   19b2c:	4628      	mov	r0, r5
   19b2e:	463d      	mov	r5, r7
    dx = x1 - x0;
   19b30:	fa1f f989 	uxth.w	r9, r9
    int16_t err = dx / 2;
   19b34:	fa0f f489 	sxth.w	r4, r9
   19b38:	2c00      	cmp	r4, #0
   19b3a:	bfb8      	it	lt
   19b3c:	3401      	addlt	r4, #1
    if (y0 < y1) {
   19b3e:	42b1      	cmp	r1, r6
   19b40:	460e      	mov	r6, r1
    int16_t err = dx / 2;
   19b42:	ea4f 0464 	mov.w	r4, r4, asr #1
    if (y0 < y1) {
   19b46:	da07      	bge.n	19b58 <GFXwriteLine+0x130>
   19b48:	f04f 0b01 	mov.w	fp, #1
   19b4c:	4607      	mov	r7, r0
   19b4e:	e7a1      	b.n	19a94 <GFXwriteLine+0x6c>
   19b50:	4634      	mov	r4, r6
   19b52:	468b      	mov	fp, r1
   19b54:	4690      	mov	r8, r2
   19b56:	e785      	b.n	19a64 <GFXwriteLine+0x3c>
   19b58:	f64f 7bff 	movw	fp, #65535	; 0xffff
   19b5c:	4607      	mov	r7, r0
   19b5e:	e799      	b.n	19a94 <GFXwriteLine+0x6c>

00019b60 <GFXdrawPixel>:
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   19b60:	2900      	cmp	r1, #0
   19b62:	db2a      	blt.n	19bba <GFXdrawPixel+0x5a>
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
   19b64:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   19b66:	8884      	ldrh	r4, [r0, #4]
   19b68:	42a1      	cmp	r1, r4
   19b6a:	da24      	bge.n	19bb6 <GFXdrawPixel+0x56>
   19b6c:	2a00      	cmp	r2, #0
   19b6e:	db22      	blt.n	19bb6 <GFXdrawPixel+0x56>
   19b70:	88c4      	ldrh	r4, [r0, #6]
   19b72:	42a2      	cmp	r2, r4
   19b74:	da1f      	bge.n	19bb6 <GFXdrawPixel+0x56>
  switch (GFXgetRotation(myGFX)) {
   19b76:	7a04      	ldrb	r4, [r0, #8]
   19b78:	2c02      	cmp	r4, #2
   19b7a:	d055      	beq.n	19c28 <GFXdrawPixel+0xc8>
   19b7c:	2c03      	cmp	r4, #3
   19b7e:	d04d      	beq.n	19c1c <GFXdrawPixel+0xbc>
   19b80:	2c01      	cmp	r4, #1
   19b82:	d01b      	beq.n	19bbc <GFXdrawPixel+0x5c>
    switch (color)
   19b84:	2b01      	cmp	r3, #1
   19b86:	d035      	beq.n	19bf4 <GFXdrawPixel+0x94>
   19b88:	d31e      	bcc.n	19bc8 <GFXdrawPixel+0x68>
   19b8a:	2b02      	cmp	r3, #2
   19b8c:	d113      	bne.n	19bb6 <GFXdrawPixel+0x56>
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
   19b8e:	2a00      	cmp	r2, #0
   19b90:	4613      	mov	r3, r2
   19b92:	8804      	ldrh	r4, [r0, #0]
   19b94:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   19b98:	bfb8      	it	lt
   19b9a:	1dd3      	addlt	r3, r2, #7
   19b9c:	f002 0207 	and.w	r2, r2, #7
   19ba0:	f2c0 200f 	movt	r0, #527	; 0x20f
   19ba4:	10db      	asrs	r3, r3, #3
   19ba6:	fb13 1104 	smlabb	r1, r3, r4, r1
   19baa:	2301      	movs	r3, #1
   19bac:	fa03 f202 	lsl.w	r2, r3, r2
   19bb0:	5c43      	ldrb	r3, [r0, r1]
   19bb2:	405a      	eors	r2, r3
   19bb4:	5442      	strb	r2, [r0, r1]
}
   19bb6:	bc30      	pop	{r4, r5}
   19bb8:	4770      	bx	lr
   19bba:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
   19bbc:	43d4      	mvns	r4, r2
   19bbe:	8805      	ldrh	r5, [r0, #0]
   19bc0:	460a      	mov	r2, r1
   19bc2:	1961      	adds	r1, r4, r5
   19bc4:	b209      	sxth	r1, r1
   19bc6:	e7dd      	b.n	19b84 <GFXdrawPixel+0x24>
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
   19bc8:	2a00      	cmp	r2, #0
   19bca:	4613      	mov	r3, r2
   19bcc:	8804      	ldrh	r4, [r0, #0]
   19bce:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   19bd2:	bfb8      	it	lt
   19bd4:	1dd3      	addlt	r3, r2, #7
   19bd6:	f002 0207 	and.w	r2, r2, #7
   19bda:	f2c0 200f 	movt	r0, #527	; 0x20f
   19bde:	10db      	asrs	r3, r3, #3
   19be0:	fb13 1104 	smlabb	r1, r3, r4, r1
   19be4:	2301      	movs	r3, #1
   19be6:	fa03 f202 	lsl.w	r2, r3, r2
   19bea:	5c43      	ldrb	r3, [r0, r1]
   19bec:	ea23 0302 	bic.w	r3, r3, r2
   19bf0:	5443      	strb	r3, [r0, r1]
   19bf2:	e7e0      	b.n	19bb6 <GFXdrawPixel+0x56>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
   19bf4:	2a00      	cmp	r2, #0
   19bf6:	4613      	mov	r3, r2
   19bf8:	8804      	ldrh	r4, [r0, #0]
   19bfa:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   19bfe:	bfb8      	it	lt
   19c00:	1dd3      	addlt	r3, r2, #7
   19c02:	f002 0207 	and.w	r2, r2, #7
   19c06:	f2c0 200f 	movt	r0, #527	; 0x20f
   19c0a:	10db      	asrs	r3, r3, #3
   19c0c:	fb13 1104 	smlabb	r1, r3, r4, r1
   19c10:	2301      	movs	r3, #1
   19c12:	4093      	lsls	r3, r2
   19c14:	5c42      	ldrb	r2, [r0, r1]
   19c16:	4313      	orrs	r3, r2
   19c18:	5443      	strb	r3, [r0, r1]
   19c1a:	e7cc      	b.n	19bb6 <GFXdrawPixel+0x56>
    y = myGFX->HEIGHT - y - 1;
   19c1c:	8844      	ldrh	r4, [r0, #2]
   19c1e:	3c01      	subs	r4, #1
   19c20:	1a64      	subs	r4, r4, r1
   19c22:	4611      	mov	r1, r2
   19c24:	b222      	sxth	r2, r4
   19c26:	e7ad      	b.n	19b84 <GFXdrawPixel+0x24>
    x = myGFX->WIDTH - x - 1;
   19c28:	8804      	ldrh	r4, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
   19c2a:	43d2      	mvns	r2, r2
   19c2c:	8845      	ldrh	r5, [r0, #2]
    x = myGFX->WIDTH - x - 1;
   19c2e:	3c01      	subs	r4, #1
    y = myGFX->HEIGHT - y - 1;
   19c30:	442a      	add	r2, r5
    x = myGFX->WIDTH - x - 1;
   19c32:	1a61      	subs	r1, r4, r1
    y = myGFX->HEIGHT - y - 1;
   19c34:	b212      	sxth	r2, r2
    x = myGFX->WIDTH - x - 1;
   19c36:	b209      	sxth	r1, r1
   19c38:	e7a4      	b.n	19b84 <GFXdrawPixel+0x24>
   19c3a:	bf00      	nop

00019c3c <GFXfillRect>:
   19c3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19c40:	440b      	add	r3, r1
   19c42:	b089      	sub	sp, #36	; 0x24
   19c44:	428b      	cmp	r3, r1
   19c46:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
   19c4a:	f9bd 4048 	ldrsh.w	r4, [sp, #72]	; 0x48
   19c4e:	9301      	str	r3, [sp, #4]
   19c50:	9502      	str	r5, [sp, #8]
   19c52:	f340 80b5 	ble.w	19dc0 <GFXfillRect+0x184>
   19c56:	1e67      	subs	r7, r4, #1
   19c58:	f24e 7acc 	movw	sl, #59340	; 0xe7cc
   19c5c:	4417      	add	r7, r2
   19c5e:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   19c62:	b23f      	sxth	r7, r7
   19c64:	42ba      	cmp	r2, r7
   19c66:	bfcb      	itete	gt
   19c68:	4614      	movgt	r4, r2
   19c6a:	463c      	movle	r4, r7
   19c6c:	463b      	movgt	r3, r7
   19c6e:	4613      	movle	r3, r2
   19c70:	9404      	str	r4, [sp, #16]
   19c72:	9303      	str	r3, [sp, #12]
   19c74:	1ae3      	subs	r3, r4, r3
   19c76:	b29b      	uxth	r3, r3
   19c78:	b21c      	sxth	r4, r3
   19c7a:	9307      	str	r3, [sp, #28]
   19c7c:	1abb      	subs	r3, r7, r2
   19c7e:	2c00      	cmp	r4, #0
   19c80:	bfb8      	it	lt
   19c82:	3401      	addlt	r4, #1
   19c84:	2b00      	cmp	r3, #0
   19c86:	ea4f 0464 	mov.w	r4, r4, asr #1
   19c8a:	bfb8      	it	lt
   19c8c:	425b      	neglt	r3, r3
   19c8e:	9406      	str	r4, [sp, #24]
   19c90:	9305      	str	r3, [sp, #20]
   19c92:	42ba      	cmp	r2, r7
   19c94:	f040 8097 	bne.w	19dc6 <GFXfillRect+0x18a>
   19c98:	2500      	movs	r5, #0
   19c9a:	460b      	mov	r3, r1
   19c9c:	468e      	mov	lr, r1
   19c9e:	f8dd c014 	ldr.w	ip, [sp, #20]
   19ca2:	46a9      	mov	r9, r5
   19ca4:	4616      	mov	r6, r2
   19ca6:	fa1f fc8c 	uxth.w	ip, ip
   19caa:	9100      	str	r1, [sp, #0]
   19cac:	e045      	b.n	19d3a <GFXfillRect+0xfe>
   19cae:	2e00      	cmp	r6, #0
   19cb0:	db34      	blt.n	19d1c <GFXfillRect+0xe0>
   19cb2:	f8b0 8004 	ldrh.w	r8, [r0, #4]
   19cb6:	4546      	cmp	r6, r8
   19cb8:	da30      	bge.n	19d1c <GFXfillRect+0xe0>
   19cba:	0be1      	lsrs	r1, r4, #15
   19cbc:	d12e      	bne.n	19d1c <GFXfillRect+0xe0>
   19cbe:	f8b0 8006 	ldrh.w	r8, [r0, #6]
   19cc2:	4543      	cmp	r3, r8
   19cc4:	da2a      	bge.n	19d1c <GFXfillRect+0xe0>
   19cc6:	f890 8008 	ldrb.w	r8, [r0, #8]
   19cca:	f1b8 0f02 	cmp.w	r8, #2
   19cce:	f000 80db 	beq.w	19e88 <GFXfillRect+0x24c>
   19cd2:	f1b8 0f03 	cmp.w	r8, #3
   19cd6:	f000 80cf 	beq.w	19e78 <GFXfillRect+0x23c>
   19cda:	f1b8 0f01 	cmp.w	r8, #1
   19cde:	f000 80c1 	beq.w	19e64 <GFXfillRect+0x228>
   19ce2:	46b0      	mov	r8, r6
   19ce4:	9902      	ldr	r1, [sp, #8]
   19ce6:	2901      	cmp	r1, #1
   19ce8:	f000 80a6 	beq.w	19e38 <GFXfillRect+0x1fc>
   19cec:	d377      	bcc.n	19dde <GFXfillRect+0x1a2>
   19cee:	2902      	cmp	r1, #2
   19cf0:	d114      	bne.n	19d1c <GFXfillRect+0xe0>
   19cf2:	2b00      	cmp	r3, #0
   19cf4:	469b      	mov	fp, r3
   19cf6:	8801      	ldrh	r1, [r0, #0]
   19cf8:	bfb8      	it	lt
   19cfa:	f103 0b07 	addlt.w	fp, r3, #7
   19cfe:	f003 0307 	and.w	r3, r3, #7
   19d02:	ea4f 0beb 	mov.w	fp, fp, asr #3
   19d06:	fb1b 8801 	smlabb	r8, fp, r1, r8
   19d0a:	2101      	movs	r1, #1
   19d0c:	f81a b008 	ldrb.w	fp, [sl, r8]
   19d10:	fa01 f303 	lsl.w	r3, r1, r3
   19d14:	ea83 030b 	eor.w	r3, r3, fp
   19d18:	f80a 3008 	strb.w	r3, [sl, r8]
   19d1c:	eba5 050c 	sub.w	r5, r5, ip
   19d20:	b2ab      	uxth	r3, r5
   19d22:	b21d      	sxth	r5, r3
   19d24:	2d00      	cmp	r5, #0
   19d26:	da04      	bge.n	19d32 <GFXfillRect+0xf6>
   19d28:	3e01      	subs	r6, #1
   19d2a:	eb03 0509 	add.w	r5, r3, r9
   19d2e:	b236      	sxth	r6, r6
   19d30:	b22d      	sxth	r5, r5
   19d32:	1c63      	adds	r3, r4, #1
   19d34:	b21b      	sxth	r3, r3
   19d36:	4573      	cmp	r3, lr
   19d38:	dc3b      	bgt.n	19db2 <GFXfillRect+0x176>
   19d3a:	42ba      	cmp	r2, r7
   19d3c:	b29c      	uxth	r4, r3
   19d3e:	d1b6      	bne.n	19cae <GFXfillRect+0x72>
   19d40:	2b00      	cmp	r3, #0
   19d42:	dbeb      	blt.n	19d1c <GFXfillRect+0xe0>
   19d44:	f8b0 8004 	ldrh.w	r8, [r0, #4]
   19d48:	4543      	cmp	r3, r8
   19d4a:	dae7      	bge.n	19d1c <GFXfillRect+0xe0>
   19d4c:	0431      	lsls	r1, r6, #16
   19d4e:	d4e5      	bmi.n	19d1c <GFXfillRect+0xe0>
   19d50:	f8b0 8006 	ldrh.w	r8, [r0, #6]
   19d54:	4546      	cmp	r6, r8
   19d56:	dae1      	bge.n	19d1c <GFXfillRect+0xe0>
   19d58:	f890 8008 	ldrb.w	r8, [r0, #8]
   19d5c:	f1b8 0f02 	cmp.w	r8, #2
   19d60:	f000 80c8 	beq.w	19ef4 <GFXfillRect+0x2b8>
   19d64:	f1b8 0f03 	cmp.w	r8, #3
   19d68:	f000 80ba 	beq.w	19ee0 <GFXfillRect+0x2a4>
   19d6c:	f1b8 0f01 	cmp.w	r8, #1
   19d70:	f000 80ae 	beq.w	19ed0 <GFXfillRect+0x294>
   19d74:	46b0      	mov	r8, r6
   19d76:	9902      	ldr	r1, [sp, #8]
   19d78:	2901      	cmp	r1, #1
   19d7a:	f000 8092 	beq.w	19ea2 <GFXfillRect+0x266>
   19d7e:	d344      	bcc.n	19e0a <GFXfillRect+0x1ce>
   19d80:	2902      	cmp	r1, #2
   19d82:	d1cb      	bne.n	19d1c <GFXfillRect+0xe0>
   19d84:	f1b8 0f00 	cmp.w	r8, #0
   19d88:	46c3      	mov	fp, r8
   19d8a:	8801      	ldrh	r1, [r0, #0]
   19d8c:	bfb8      	it	lt
   19d8e:	f108 0b07 	addlt.w	fp, r8, #7
   19d92:	f008 0807 	and.w	r8, r8, #7
   19d96:	ea4f 0beb 	mov.w	fp, fp, asr #3
   19d9a:	fb1b 3b01 	smlabb	fp, fp, r1, r3
   19d9e:	2301      	movs	r3, #1
   19da0:	fa03 f808 	lsl.w	r8, r3, r8
   19da4:	f81a 300b 	ldrb.w	r3, [sl, fp]
   19da8:	ea88 0303 	eor.w	r3, r8, r3
   19dac:	f80a 300b 	strb.w	r3, [sl, fp]
   19db0:	e7b4      	b.n	19d1c <GFXfillRect+0xe0>
   19db2:	9900      	ldr	r1, [sp, #0]
   19db4:	3101      	adds	r1, #1
   19db6:	9b01      	ldr	r3, [sp, #4]
   19db8:	b209      	sxth	r1, r1
   19dba:	4299      	cmp	r1, r3
   19dbc:	f6ff af69 	blt.w	19c92 <GFXfillRect+0x56>
   19dc0:	b009      	add	sp, #36	; 0x24
   19dc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19dc6:	9b03      	ldr	r3, [sp, #12]
   19dc8:	9d04      	ldr	r5, [sp, #16]
   19dca:	42ab      	cmp	r3, r5
   19dcc:	dcf2      	bgt.n	19db4 <GFXfillRect+0x178>
   19dce:	46ae      	mov	lr, r5
   19dd0:	460e      	mov	r6, r1
   19dd2:	9d06      	ldr	r5, [sp, #24]
   19dd4:	f04f 0c00 	mov.w	ip, #0
   19dd8:	f8dd 901c 	ldr.w	r9, [sp, #28]
   19ddc:	e763      	b.n	19ca6 <GFXfillRect+0x6a>
   19dde:	2b00      	cmp	r3, #0
   19de0:	469b      	mov	fp, r3
   19de2:	8801      	ldrh	r1, [r0, #0]
   19de4:	bfb8      	it	lt
   19de6:	f103 0b07 	addlt.w	fp, r3, #7
   19dea:	f003 0307 	and.w	r3, r3, #7
   19dee:	ea4f 0beb 	mov.w	fp, fp, asr #3
   19df2:	fb1b 8801 	smlabb	r8, fp, r1, r8
   19df6:	2101      	movs	r1, #1
   19df8:	f81a b008 	ldrb.w	fp, [sl, r8]
   19dfc:	fa01 f303 	lsl.w	r3, r1, r3
   19e00:	ea2b 0303 	bic.w	r3, fp, r3
   19e04:	f80a 3008 	strb.w	r3, [sl, r8]
   19e08:	e788      	b.n	19d1c <GFXfillRect+0xe0>
   19e0a:	f1b8 0f00 	cmp.w	r8, #0
   19e0e:	46c3      	mov	fp, r8
   19e10:	8801      	ldrh	r1, [r0, #0]
   19e12:	bfb8      	it	lt
   19e14:	f108 0b07 	addlt.w	fp, r8, #7
   19e18:	f008 0807 	and.w	r8, r8, #7
   19e1c:	ea4f 0beb 	mov.w	fp, fp, asr #3
   19e20:	fb1b 3b01 	smlabb	fp, fp, r1, r3
   19e24:	2301      	movs	r3, #1
   19e26:	fa03 f808 	lsl.w	r8, r3, r8
   19e2a:	f81a 300b 	ldrb.w	r3, [sl, fp]
   19e2e:	ea23 0308 	bic.w	r3, r3, r8
   19e32:	f80a 300b 	strb.w	r3, [sl, fp]
   19e36:	e771      	b.n	19d1c <GFXfillRect+0xe0>
   19e38:	2b00      	cmp	r3, #0
   19e3a:	469b      	mov	fp, r3
   19e3c:	8801      	ldrh	r1, [r0, #0]
   19e3e:	bfb8      	it	lt
   19e40:	f103 0b07 	addlt.w	fp, r3, #7
   19e44:	f003 0307 	and.w	r3, r3, #7
   19e48:	ea4f 0beb 	mov.w	fp, fp, asr #3
   19e4c:	fb1b 8801 	smlabb	r8, fp, r1, r8
   19e50:	2101      	movs	r1, #1
   19e52:	f81a b008 	ldrb.w	fp, [sl, r8]
   19e56:	fa01 f303 	lsl.w	r3, r1, r3
   19e5a:	ea43 030b 	orr.w	r3, r3, fp
   19e5e:	f80a 3008 	strb.w	r3, [sl, r8]
   19e62:	e75b      	b.n	19d1c <GFXfillRect+0xe0>
   19e64:	f8b0 8000 	ldrh.w	r8, [r0]
   19e68:	4633      	mov	r3, r6
   19e6a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   19e6e:	eba8 0804 	sub.w	r8, r8, r4
   19e72:	fa0f f888 	sxth.w	r8, r8
   19e76:	e735      	b.n	19ce4 <GFXfillRect+0xa8>
   19e78:	f8b0 b002 	ldrh.w	fp, [r0, #2]
   19e7c:	4698      	mov	r8, r3
   19e7e:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   19e82:	1b9b      	subs	r3, r3, r6
   19e84:	b21b      	sxth	r3, r3
   19e86:	e72d      	b.n	19ce4 <GFXfillRect+0xa8>
   19e88:	f8b0 8000 	ldrh.w	r8, [r0]
   19e8c:	8843      	ldrh	r3, [r0, #2]
   19e8e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   19e92:	3b01      	subs	r3, #1
   19e94:	eba8 0806 	sub.w	r8, r8, r6
   19e98:	1b1b      	subs	r3, r3, r4
   19e9a:	fa0f f888 	sxth.w	r8, r8
   19e9e:	b21b      	sxth	r3, r3
   19ea0:	e720      	b.n	19ce4 <GFXfillRect+0xa8>
   19ea2:	f1b8 0f00 	cmp.w	r8, #0
   19ea6:	46c3      	mov	fp, r8
   19ea8:	8801      	ldrh	r1, [r0, #0]
   19eaa:	bfb8      	it	lt
   19eac:	f108 0b07 	addlt.w	fp, r8, #7
   19eb0:	f008 0807 	and.w	r8, r8, #7
   19eb4:	ea4f 0beb 	mov.w	fp, fp, asr #3
   19eb8:	fb1b 3b01 	smlabb	fp, fp, r1, r3
   19ebc:	2301      	movs	r3, #1
   19ebe:	fa03 f808 	lsl.w	r8, r3, r8
   19ec2:	f81a 300b 	ldrb.w	r3, [sl, fp]
   19ec6:	ea48 0303 	orr.w	r3, r8, r3
   19eca:	f80a 300b 	strb.w	r3, [sl, fp]
   19ece:	e725      	b.n	19d1c <GFXfillRect+0xe0>
   19ed0:	f8b0 b000 	ldrh.w	fp, [r0]
   19ed4:	4698      	mov	r8, r3
   19ed6:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   19eda:	1b9b      	subs	r3, r3, r6
   19edc:	b21b      	sxth	r3, r3
   19ede:	e74a      	b.n	19d76 <GFXfillRect+0x13a>
   19ee0:	f8b0 8002 	ldrh.w	r8, [r0, #2]
   19ee4:	4633      	mov	r3, r6
   19ee6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   19eea:	eba8 0804 	sub.w	r8, r8, r4
   19eee:	fa0f f888 	sxth.w	r8, r8
   19ef2:	e740      	b.n	19d76 <GFXfillRect+0x13a>
   19ef4:	8803      	ldrh	r3, [r0, #0]
   19ef6:	f8b0 8002 	ldrh.w	r8, [r0, #2]
   19efa:	3b01      	subs	r3, #1
   19efc:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   19f00:	1b1b      	subs	r3, r3, r4
   19f02:	eba8 0806 	sub.w	r8, r8, r6
   19f06:	b21b      	sxth	r3, r3
   19f08:	fa0f f888 	sxth.w	r8, r8
   19f0c:	e733      	b.n	19d76 <GFXfillRect+0x13a>
   19f0e:	bf00      	nop

00019f10 <GFXdrawChar>:

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void GFXdrawChar(GFX* myGFX, int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
   19f10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19f14:	b09b      	sub	sp, #108	; 0x6c
   19f16:	4682      	mov	sl, r0

    if(!myGFX->gfxFont) { // 'Classic' built-in font
   19f18:	6980      	ldr	r0, [r0, #24]
  uint16_t color, uint16_t bg, uint8_t size) {
   19f1a:	9204      	str	r2, [sp, #16]
   19f1c:	f8bd 2090 	ldrh.w	r2, [sp, #144]	; 0x90
   19f20:	920b      	str	r2, [sp, #44]	; 0x2c
   19f22:	f8bd 2094 	ldrh.w	r2, [sp, #148]	; 0x94
   19f26:	9202      	str	r2, [sp, #8]
   19f28:	f89d 2098 	ldrb.w	r2, [sp, #152]	; 0x98
   19f2c:	920d      	str	r2, [sp, #52]	; 0x34
    if(!myGFX->gfxFont) { // 'Classic' built-in font
   19f2e:	2800      	cmp	r0, #0
   19f30:	f000 811e 	beq.w	1a170 <GFXdrawChar+0x260>

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
   19f34:	7a04      	ldrb	r4, [r0, #8]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   19f36:	6842      	ldr	r2, [r0, #4]
        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
   19f38:	1b1b      	subs	r3, r3, r4
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
   19f3a:	6800      	ldr	r0, [r0, #0]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   19f3c:	b2db      	uxtb	r3, r3
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
   19f3e:	9010      	str	r0, [sp, #64]	; 0x40
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   19f40:	eb02 03c3 	add.w	r3, r2, r3, lsl #3

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   19f44:	881a      	ldrh	r2, [r3, #0]
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
   19f46:	f993 0006 	ldrsb.w	r0, [r3, #6]
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   19f4a:	920c      	str	r2, [sp, #48]	; 0x30
        uint8_t  w  = pgm_read_byte(&glyph->width),
   19f4c:	789a      	ldrb	r2, [r3, #2]
                 yo = pgm_read_byte(&glyph->yOffset);
   19f4e:	9019      	str	r0, [sp, #100]	; 0x64
        uint8_t  w  = pgm_read_byte(&glyph->width),
   19f50:	9209      	str	r2, [sp, #36]	; 0x24
                 h  = pgm_read_byte(&glyph->height);
   19f52:	78da      	ldrb	r2, [r3, #3]
   19f54:	9214      	str	r2, [sp, #80]	; 0x50
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
   19f56:	f993 2005 	ldrsb.w	r2, [r3, #5]
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
   19f5a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   19f5c:	2b01      	cmp	r3, #1
   19f5e:	f240 80a7 	bls.w	1a0b0 <GFXdrawChar+0x1a0>
            xo16 = xo;
            yo16 = yo;
   19f62:	b200      	sxth	r0, r0
            xo16 = xo;
   19f64:	b213      	sxth	r3, r2
            yo16 = yo;
   19f66:	9015      	str	r0, [sp, #84]	; 0x54
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        //startWrite();
        for(yy=0; yy<h; yy++) {
   19f68:	9814      	ldr	r0, [sp, #80]	; 0x50
   19f6a:	2800      	cmp	r0, #0
   19f6c:	f000 80a6 	beq.w	1a0bc <GFXdrawChar+0x1ac>
   19f70:	9809      	ldr	r0, [sp, #36]	; 0x24
   19f72:	2800      	cmp	r0, #0
   19f74:	f000 80a2 	beq.w	1a0bc <GFXdrawChar+0x1ac>
                }
                if(bits & 0x80) {
                    if(size == 1) {
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
                    } else {
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19f78:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   19f7c:	b289      	uxth	r1, r1
        uint8_t  xx, yy, bits = 0, bit = 0;
   19f7e:	2000      	movs	r0, #0
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   19f80:	188a      	adds	r2, r1, r2
   19f82:	fb03 1104 	mla	r1, r3, r4, r1
   19f86:	1e63      	subs	r3, r4, #1
        uint8_t  xx, yy, bits = 0, bit = 0;
   19f88:	9007      	str	r0, [sp, #28]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   19f8a:	9218      	str	r2, [sp, #96]	; 0x60
   19f8c:	9317      	str	r3, [sp, #92]	; 0x5c
   19f8e:	b28b      	uxth	r3, r1
   19f90:	f8bd 2010 	ldrh.w	r2, [sp, #16]
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19f94:	940a      	str	r4, [sp, #40]	; 0x28
   19f96:	9213      	str	r2, [sp, #76]	; 0x4c
        uint8_t  xx, yy, bits = 0, bit = 0;
   19f98:	9002      	str	r0, [sp, #8]
        for(yy=0; yy<h; yy++) {
   19f9a:	900f      	str	r0, [sp, #60]	; 0x3c
   19f9c:	9316      	str	r3, [sp, #88]	; 0x58
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19f9e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    int16_t err = dx / 2;
   19fa0:	2700      	movs	r7, #0
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19fa2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   19fa4:	9913      	ldr	r1, [sp, #76]	; 0x4c
   19fa6:	4413      	add	r3, r2
   19fa8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   19faa:	fb03 1302 	mla	r3, r3, r2, r1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   19fae:	9a17      	ldr	r2, [sp, #92]	; 0x5c
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19fb0:	b29b      	uxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   19fb2:	189a      	adds	r2, r3, r2
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19fb4:	b21b      	sxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   19fb6:	b211      	sxth	r1, r2
   19fb8:	461a      	mov	r2, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   19fba:	9311      	str	r3, [sp, #68]	; 0x44
   19fbc:	428b      	cmp	r3, r1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   19fbe:	9104      	str	r1, [sp, #16]
   19fc0:	bfa8      	it	ge
   19fc2:	460a      	movge	r2, r1
   19fc4:	428b      	cmp	r3, r1
   19fc6:	bfb8      	it	lt
   19fc8:	460b      	movlt	r3, r1
   19fca:	9208      	str	r2, [sp, #32]
   19fcc:	9911      	ldr	r1, [sp, #68]	; 0x44
   19fce:	4699      	mov	r9, r3
    dx = x1 - x0;
   19fd0:	1a9b      	subs	r3, r3, r2
   19fd2:	9a04      	ldr	r2, [sp, #16]
   19fd4:	b29b      	uxth	r3, r3
   19fd6:	eba2 0801 	sub.w	r8, r2, r1
   19fda:	9306      	str	r3, [sp, #24]
    int16_t err = dx / 2;
   19fdc:	b21b      	sxth	r3, r3
   19fde:	2b00      	cmp	r3, #0
   19fe0:	bfb8      	it	lt
   19fe2:	3301      	addlt	r3, #1
   19fe4:	f1b8 0f00 	cmp.w	r8, #0
   19fe8:	ea4f 0363 	mov.w	r3, r3, asr #1
   19fec:	bfb8      	it	lt
   19fee:	f1c8 0800 	rsblt	r8, r8, #0
   19ff2:	930e      	str	r3, [sp, #56]	; 0x38
   19ff4:	fa1f f888 	uxth.w	r8, r8
   19ff8:	9b16      	ldr	r3, [sp, #88]	; 0x58
   19ffa:	9303      	str	r3, [sp, #12]
   19ffc:	e00e      	b.n	1a01c <GFXdrawChar+0x10c>
                          size, size, color);
                    }
                }
                bits <<= 1;
   19ffe:	9b02      	ldr	r3, [sp, #8]
   1a000:	3701      	adds	r7, #1
   1a002:	9a03      	ldr	r2, [sp, #12]
   1a004:	990a      	ldr	r1, [sp, #40]	; 0x28
   1a006:	005b      	lsls	r3, r3, #1
   1a008:	b2bf      	uxth	r7, r7
   1a00a:	440a      	add	r2, r1
   1a00c:	b2db      	uxtb	r3, r3
   1a00e:	b292      	uxth	r2, r2
   1a010:	9302      	str	r3, [sp, #8]
            for(xx=0; xx<w; xx++) {
   1a012:	b2fb      	uxtb	r3, r7
   1a014:	9203      	str	r2, [sp, #12]
   1a016:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1a018:	429a      	cmp	r2, r3
   1a01a:	d97b      	bls.n	1a114 <GFXdrawChar+0x204>
                if(!(bit++ & 7)) {
   1a01c:	9b07      	ldr	r3, [sp, #28]
   1a01e:	443b      	add	r3, r7
   1a020:	0759      	lsls	r1, r3, #29
   1a022:	d106      	bne.n	1a032 <GFXdrawChar+0x122>
                    bits = pgm_read_byte(&bitmap[bo++]);
   1a024:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1a026:	9910      	ldr	r1, [sp, #64]	; 0x40
   1a028:	1c53      	adds	r3, r2, #1
   1a02a:	5c8a      	ldrb	r2, [r1, r2]
   1a02c:	b29b      	uxth	r3, r3
   1a02e:	9202      	str	r2, [sp, #8]
   1a030:	930c      	str	r3, [sp, #48]	; 0x30
                if(bits & 0x80) {
   1a032:	9b02      	ldr	r3, [sp, #8]
   1a034:	061a      	lsls	r2, r3, #24
   1a036:	d5e2      	bpl.n	19ffe <GFXdrawChar+0xee>
                    if(size == 1) {
   1a038:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a03a:	2b01      	cmp	r3, #1
   1a03c:	d07a      	beq.n	1a134 <GFXdrawChar+0x224>
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1a03e:	f9bd 600c 	ldrsh.w	r6, [sp, #12]
    for (int16_t i=x; i<x+w; i++) {
   1a042:	4433      	add	r3, r6
   1a044:	42b3      	cmp	r3, r6
   1a046:	9305      	str	r3, [sp, #20]
   1a048:	ddd9      	ble.n	19ffe <GFXdrawChar+0xee>
   1a04a:	9712      	str	r7, [sp, #72]	; 0x48
   1a04c:	9f11      	ldr	r7, [sp, #68]	; 0x44
    if (steep) {
   1a04e:	9b04      	ldr	r3, [sp, #16]
   1a050:	429f      	cmp	r7, r3
   1a052:	d036      	beq.n	1a0c2 <GFXdrawChar+0x1b2>
    for (; x0<=x1; x0++) {
   1a054:	9b08      	ldr	r3, [sp, #32]
   1a056:	454b      	cmp	r3, r9
   1a058:	dc23      	bgt.n	1a0a2 <GFXdrawChar+0x192>
   1a05a:	461c      	mov	r4, r3
   1a05c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   1a05e:	46b3      	mov	fp, r6
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   1a060:	f1bb 0f00 	cmp.w	fp, #0
   1a064:	db0f      	blt.n	1a086 <GFXdrawChar+0x176>
   1a066:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   1a06a:	459b      	cmp	fp, r3
   1a06c:	da0b      	bge.n	1a086 <GFXdrawChar+0x176>
   1a06e:	0423      	lsls	r3, r4, #16
   1a070:	d409      	bmi.n	1a086 <GFXdrawChar+0x176>
   1a072:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   1a076:	4622      	mov	r2, r4
   1a078:	4659      	mov	r1, fp
   1a07a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a07c:	4284      	cmp	r4, r0
   1a07e:	4650      	mov	r0, sl
   1a080:	da01      	bge.n	1a086 <GFXdrawChar+0x176>
   1a082:	f7ff fc53 	bl	1992c <GFXdrawPixel.part.0>
   1a086:	3401      	adds	r4, #1
        if (err < 0) {
   1a088:	2d00      	cmp	r5, #0
        err -= dy;
   1a08a:	b2ab      	uxth	r3, r5
   1a08c:	b224      	sxth	r4, r4
        if (err < 0) {
   1a08e:	da06      	bge.n	1a09e <GFXdrawChar+0x18e>
            err += dx;
   1a090:	9a06      	ldr	r2, [sp, #24]
            y0 += ystep;
   1a092:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
            err += dx;
   1a096:	18d5      	adds	r5, r2, r3
            y0 += ystep;
   1a098:	fa0f fb8b 	sxth.w	fp, fp
            err += dx;
   1a09c:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
   1a09e:	45a1      	cmp	r9, r4
   1a0a0:	dade      	bge.n	1a060 <GFXdrawChar+0x150>
   1a0a2:	3601      	adds	r6, #1
    for (int16_t i=x; i<x+w; i++) {
   1a0a4:	9b05      	ldr	r3, [sp, #20]
   1a0a6:	b236      	sxth	r6, r6
   1a0a8:	429e      	cmp	r6, r3
   1a0aa:	dbd0      	blt.n	1a04e <GFXdrawChar+0x13e>
   1a0ac:	9f12      	ldr	r7, [sp, #72]	; 0x48
   1a0ae:	e7a6      	b.n	19ffe <GFXdrawChar+0xee>
        int16_t  xo16 = 0, yo16 = 0;
   1a0b0:	2300      	movs	r3, #0
        for(yy=0; yy<h; yy++) {
   1a0b2:	9814      	ldr	r0, [sp, #80]	; 0x50
        int16_t  xo16 = 0, yo16 = 0;
   1a0b4:	9315      	str	r3, [sp, #84]	; 0x54
        for(yy=0; yy<h; yy++) {
   1a0b6:	2800      	cmp	r0, #0
   1a0b8:	f47f af5a 	bne.w	19f70 <GFXdrawChar+0x60>
            }
        }
        //endWrite();

    } // End classic vs custom font
}
   1a0bc:	b01b      	add	sp, #108	; 0x6c
   1a0be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (steep) {
   1a0c2:	4634      	mov	r4, r6
   1a0c4:	46bb      	mov	fp, r7
    int16_t err = dx / 2;
   1a0c6:	2500      	movs	r5, #0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   1a0c8:	2c00      	cmp	r4, #0
   1a0ca:	db10      	blt.n	1a0ee <GFXdrawChar+0x1de>
   1a0cc:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   1a0d0:	42a3      	cmp	r3, r4
   1a0d2:	dd0c      	ble.n	1a0ee <GFXdrawChar+0x1de>
   1a0d4:	f1bb 0f00 	cmp.w	fp, #0
   1a0d8:	db09      	blt.n	1a0ee <GFXdrawChar+0x1de>
   1a0da:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   1a0de:	465a      	mov	r2, fp
   1a0e0:	4621      	mov	r1, r4
   1a0e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a0e4:	4558      	cmp	r0, fp
   1a0e6:	4650      	mov	r0, sl
   1a0e8:	dd01      	ble.n	1a0ee <GFXdrawChar+0x1de>
   1a0ea:	f7ff fc1f 	bl	1992c <GFXdrawPixel.part.0>
        err -= dy;
   1a0ee:	eba5 0508 	sub.w	r5, r5, r8
   1a0f2:	3401      	adds	r4, #1
   1a0f4:	b22d      	sxth	r5, r5
   1a0f6:	b224      	sxth	r4, r4
        if (err < 0) {
   1a0f8:	2d00      	cmp	r5, #0
   1a0fa:	da03      	bge.n	1a104 <GFXdrawChar+0x1f4>
            y0 += ystep;
   1a0fc:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   1a100:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
   1a104:	42a6      	cmp	r6, r4
   1a106:	dadf      	bge.n	1a0c8 <GFXdrawChar+0x1b8>
   1a108:	3601      	adds	r6, #1
    for (int16_t i=x; i<x+w; i++) {
   1a10a:	9b05      	ldr	r3, [sp, #20]
   1a10c:	b236      	sxth	r6, r6
   1a10e:	429e      	cmp	r6, r3
   1a110:	db9d      	blt.n	1a04e <GFXdrawChar+0x13e>
   1a112:	e7cb      	b.n	1a0ac <GFXdrawChar+0x19c>
   1a114:	4611      	mov	r1, r2
   1a116:	9b07      	ldr	r3, [sp, #28]
        for(yy=0; yy<h; yy++) {
   1a118:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1a11a:	440b      	add	r3, r1
   1a11c:	3201      	adds	r2, #1
   1a11e:	b2db      	uxtb	r3, r3
   1a120:	b2d2      	uxtb	r2, r2
   1a122:	9307      	str	r3, [sp, #28]
   1a124:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1a126:	920f      	str	r2, [sp, #60]	; 0x3c
   1a128:	4293      	cmp	r3, r2
   1a12a:	f63f af38 	bhi.w	19f9e <GFXdrawChar+0x8e>
}
   1a12e:	b01b      	add	sp, #108	; 0x6c
   1a130:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a134:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1a136:	18f9      	adds	r1, r7, r3
   1a138:	b209      	sxth	r1, r1
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   1a13a:	2900      	cmp	r1, #0
   1a13c:	f6ff af5f 	blt.w	19ffe <GFXdrawChar+0xee>
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   1a140:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a142:	9a19      	ldr	r2, [sp, #100]	; 0x64
   1a144:	980f      	ldr	r0, [sp, #60]	; 0x3c
   1a146:	189a      	adds	r2, r3, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   1a148:	f8ba 3004 	ldrh.w	r3, [sl, #4]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   1a14c:	4402      	add	r2, r0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   1a14e:	4299      	cmp	r1, r3
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   1a150:	b212      	sxth	r2, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   1a152:	f6bf af54 	bge.w	19ffe <GFXdrawChar+0xee>
   1a156:	2a00      	cmp	r2, #0
   1a158:	f6ff af51 	blt.w	19ffe <GFXdrawChar+0xee>
   1a15c:	f8ba 3006 	ldrh.w	r3, [sl, #6]
   1a160:	429a      	cmp	r2, r3
   1a162:	f6bf af4c 	bge.w	19ffe <GFXdrawChar+0xee>
   1a166:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a168:	4650      	mov	r0, sl
   1a16a:	f7ff fbdf 	bl	1992c <GFXdrawPixel.part.0>
   1a16e:	e746      	b.n	19ffe <GFXdrawChar+0xee>
        if((x >= myGFX->_width)            || // Clip right
   1a170:	f8ba 2004 	ldrh.w	r2, [sl, #4]
   1a174:	4291      	cmp	r1, r2
   1a176:	daa1      	bge.n	1a0bc <GFXdrawChar+0x1ac>
           (y >= myGFX->_height)           || // Clip bottom
   1a178:	f8ba 2006 	ldrh.w	r2, [sl, #6]
        if((x >= myGFX->_width)            || // Clip right
   1a17c:	9c04      	ldr	r4, [sp, #16]
   1a17e:	4294      	cmp	r4, r2
   1a180:	da9c      	bge.n	1a0bc <GFXdrawChar+0x1ac>
           ((x + 6 * size - 1) < 0) || // Clip left
   1a182:	2206      	movs	r2, #6
   1a184:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   1a186:	fb12 1205 	smlabb	r2, r2, r5, r1
           (y >= myGFX->_height)           || // Clip bottom
   1a18a:	2a00      	cmp	r2, #0
   1a18c:	dd96      	ble.n	1a0bc <GFXdrawChar+0x1ac>
           ((y + 8 * size - 1) < 0))   // Clip top
   1a18e:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
           ((x + 6 * size - 1) < 0) || // Clip left
   1a192:	2a00      	cmp	r2, #0
   1a194:	dd92      	ble.n	1a0bc <GFXdrawChar+0x1ac>
        if(!myGFX->_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
   1a196:	f8ba 2016 	ldrh.w	r2, [sl, #22]
   1a19a:	b91a      	cbnz	r2, 1a1a4 <GFXdrawChar+0x294>
   1a19c:	2baf      	cmp	r3, #175	; 0xaf
   1a19e:	d901      	bls.n	1a1a4 <GFXdrawChar+0x294>
   1a1a0:	3301      	adds	r3, #1
   1a1a2:	b2db      	uxtb	r3, r3
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
   1a1a4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1a1a8:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   1a1ac:	b289      	uxth	r1, r1
   1a1ae:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1a1b2:	9403      	str	r4, [sp, #12]
   1a1b4:	1d4a      	adds	r2, r1, #5
   1a1b6:	910f      	str	r1, [sp, #60]	; 0x3c
   1a1b8:	009b      	lsls	r3, r3, #2
   1a1ba:	9106      	str	r1, [sp, #24]
   1a1bc:	b292      	uxth	r2, r2
   1a1be:	9107      	str	r1, [sp, #28]
   1a1c0:	9308      	str	r3, [sp, #32]
   1a1c2:	1e63      	subs	r3, r4, #1
   1a1c4:	920c      	str	r2, [sp, #48]	; 0x30
   1a1c6:	9309      	str	r3, [sp, #36]	; 0x24
   1a1c8:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1a1cc:	9a08      	ldr	r2, [sp, #32]
   1a1ce:	461d      	mov	r5, r3
   1a1d0:	9313      	str	r3, [sp, #76]	; 0x4c
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1a1d2:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
    for (int16_t i=x; i<x+w; i++) {
   1a1d6:	2700      	movs	r7, #0
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
   1a1d8:	f810 9002 	ldrb.w	r9, [r0, r2]
    for (int16_t i=x; i<x+w; i++) {
   1a1dc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    GFXdrawPixel(myGFX, x, y, color);
   1a1de:	46b8      	mov	r8, r7
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1a1e0:	9305      	str	r3, [sp, #20]
    for (int16_t i=x; i<x+w; i++) {
   1a1e2:	189e      	adds	r6, r3, r2
    GFXdrawPixel(myGFX, x, y, color);
   1a1e4:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
   1a1e8:	930e      	str	r3, [sp, #56]	; 0x38
                if(line & 1) {
   1a1ea:	f019 0f01 	tst.w	r9, #1
   1a1ee:	d037      	beq.n	1a260 <GFXdrawChar+0x350>
                    if(size == 1)
   1a1f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a1f2:	2b01      	cmp	r3, #1
   1a1f4:	d057      	beq.n	1a2a6 <GFXdrawChar+0x396>
    for (int16_t i=x; i<x+w; i++) {
   1a1f6:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, color);
   1a1f8:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
   1a1fc:	42b4      	cmp	r4, r6
   1a1fe:	da11      	bge.n	1a224 <GFXdrawChar+0x314>
   1a200:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a202:	950a      	str	r5, [sp, #40]	; 0x28
   1a204:	18ef      	adds	r7, r5, r3
   1a206:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   1a208:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1a20a:	4623      	mov	r3, r4
   1a20c:	4621      	mov	r1, r4
   1a20e:	3401      	adds	r4, #1
   1a210:	9501      	str	r5, [sp, #4]
   1a212:	9700      	str	r7, [sp, #0]
   1a214:	465a      	mov	r2, fp
   1a216:	b224      	sxth	r4, r4
   1a218:	4650      	mov	r0, sl
   1a21a:	f7ff fc05 	bl	19a28 <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
   1a21e:	42b4      	cmp	r4, r6
   1a220:	dbf3      	blt.n	1a20a <GFXdrawChar+0x2fa>
   1a222:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   1a224:	9b03      	ldr	r3, [sp, #12]
   1a226:	f108 0801 	add.w	r8, r8, #1
            for(int8_t j=0; j<8; j++, line >>= 1) {
   1a22a:	ea4f 0959 	mov.w	r9, r9, lsr #1
   1a22e:	441d      	add	r5, r3
   1a230:	f1b8 0f08 	cmp.w	r8, #8
   1a234:	b2ad      	uxth	r5, r5
   1a236:	d1d8      	bne.n	1a1ea <GFXdrawChar+0x2da>
   1a238:	4619      	mov	r1, r3
   1a23a:	9b07      	ldr	r3, [sp, #28]
   1a23c:	9a06      	ldr	r2, [sp, #24]
   1a23e:	440b      	add	r3, r1
   1a240:	9908      	ldr	r1, [sp, #32]
   1a242:	3201      	adds	r2, #1
   1a244:	b29b      	uxth	r3, r3
   1a246:	310c      	adds	r1, #12
   1a248:	b292      	uxth	r2, r2
   1a24a:	9307      	str	r3, [sp, #28]
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
   1a24c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1a24e:	9108      	str	r1, [sp, #32]
   1a250:	4293      	cmp	r3, r2
   1a252:	9206      	str	r2, [sp, #24]
   1a254:	d03b      	beq.n	1a2ce <GFXdrawChar+0x3be>
   1a256:	f8da 0018 	ldr.w	r0, [sl, #24]
   1a25a:	460a      	mov	r2, r1
   1a25c:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   1a25e:	e7b8      	b.n	1a1d2 <GFXdrawChar+0x2c2>
                } else if(bg != color) {
   1a260:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a262:	9a02      	ldr	r2, [sp, #8]
   1a264:	4293      	cmp	r3, r2
   1a266:	d0dd      	beq.n	1a224 <GFXdrawChar+0x314>
                    if(size == 1)
   1a268:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a26a:	2b01      	cmp	r3, #1
   1a26c:	d025      	beq.n	1a2ba <GFXdrawChar+0x3aa>
    for (int16_t i=x; i<x+w; i++) {
   1a26e:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1a270:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
   1a274:	42b4      	cmp	r4, r6
   1a276:	dad5      	bge.n	1a224 <GFXdrawChar+0x314>
   1a278:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a27a:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   1a27e:	46a9      	mov	r9, r5
   1a280:	18ef      	adds	r7, r5, r3
   1a282:	9d02      	ldr	r5, [sp, #8]
   1a284:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1a286:	4623      	mov	r3, r4
   1a288:	4621      	mov	r1, r4
   1a28a:	3401      	adds	r4, #1
   1a28c:	9501      	str	r5, [sp, #4]
   1a28e:	9700      	str	r7, [sp, #0]
   1a290:	465a      	mov	r2, fp
   1a292:	b224      	sxth	r4, r4
   1a294:	4650      	mov	r0, sl
   1a296:	f7ff fbc7 	bl	19a28 <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
   1a29a:	42b4      	cmp	r4, r6
   1a29c:	dbf3      	blt.n	1a286 <GFXdrawChar+0x376>
   1a29e:	464d      	mov	r5, r9
   1a2a0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
   1a2a4:	e7be      	b.n	1a224 <GFXdrawChar+0x314>
    GFXdrawPixel(myGFX, x, y, color);
   1a2a6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a2a8:	4650      	mov	r0, sl
   1a2aa:	990e      	ldr	r1, [sp, #56]	; 0x38
   1a2ac:	eb03 0208 	add.w	r2, r3, r8
   1a2b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a2b2:	b212      	sxth	r2, r2
   1a2b4:	f7ff fc54 	bl	19b60 <GFXdrawPixel>
   1a2b8:	e7b4      	b.n	1a224 <GFXdrawChar+0x314>
   1a2ba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a2bc:	4650      	mov	r0, sl
   1a2be:	990e      	ldr	r1, [sp, #56]	; 0x38
   1a2c0:	eb03 0208 	add.w	r2, r3, r8
   1a2c4:	9b02      	ldr	r3, [sp, #8]
   1a2c6:	b212      	sxth	r2, r2
   1a2c8:	f7ff fc4a 	bl	19b60 <GFXdrawPixel>
   1a2cc:	e7aa      	b.n	1a224 <GFXdrawChar+0x314>
        if(bg != color) { // If opaque, draw vertical line for last column
   1a2ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a2d0:	9a02      	ldr	r2, [sp, #8]
   1a2d2:	4293      	cmp	r3, r2
   1a2d4:	f43f aef2 	beq.w	1a0bc <GFXdrawChar+0x1ac>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
   1a2d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a2da:	2b01      	cmp	r3, #1
   1a2dc:	d01e      	beq.n	1a31c <GFXdrawChar+0x40c>
            else          GFXwriteFillRect(myGFX,x+5*size, y, size, 8*size, bg);
   1a2de:	9b03      	ldr	r3, [sp, #12]
   1a2e0:	eb03 0583 	add.w	r5, r3, r3, lsl #2
   1a2e4:	00dc      	lsls	r4, r3, #3
   1a2e6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a2e8:	442b      	add	r3, r5
   1a2ea:	b21d      	sxth	r5, r3
    for (int16_t i=x; i<x+w; i++) {
   1a2ec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a2ee:	442b      	add	r3, r5
   1a2f0:	42ab      	cmp	r3, r5
   1a2f2:	461e      	mov	r6, r3
   1a2f4:	f77f aee2 	ble.w	1a0bc <GFXdrawChar+0x1ac>
   1a2f8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a2fa:	3b01      	subs	r3, #1
   1a2fc:	441c      	add	r4, r3
   1a2fe:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1a300:	9b02      	ldr	r3, [sp, #8]
   1a302:	4629      	mov	r1, r5
   1a304:	9400      	str	r4, [sp, #0]
   1a306:	4650      	mov	r0, sl
   1a308:	9301      	str	r3, [sp, #4]
   1a30a:	462b      	mov	r3, r5
   1a30c:	3501      	adds	r5, #1
   1a30e:	9a04      	ldr	r2, [sp, #16]
   1a310:	f7ff fb8a 	bl	19a28 <GFXwriteLine>
   1a314:	b22d      	sxth	r5, r5
    for (int16_t i=x; i<x+w; i++) {
   1a316:	42ae      	cmp	r6, r5
   1a318:	dcf2      	bgt.n	1a300 <GFXdrawChar+0x3f0>
   1a31a:	e6cf      	b.n	1a0bc <GFXdrawChar+0x1ac>
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1a31c:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   1a31e:	4650      	mov	r0, sl
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
   1a320:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1a324:	3407      	adds	r4, #7
   1a326:	9225      	str	r2, [sp, #148]	; 0x94
   1a328:	4619      	mov	r1, r3
   1a32a:	9a04      	ldr	r2, [sp, #16]
   1a32c:	b224      	sxth	r4, r4
   1a32e:	9424      	str	r4, [sp, #144]	; 0x90
}
   1a330:	b01b      	add	sp, #108	; 0x6c
   1a332:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1a336:	f7ff bb77 	b.w	19a28 <GFXwriteLine>
   1a33a:	bf00      	nop

0001a33c <GFXwrite>:
        }
  }
}


void GFXwrite(GFX* myGFX, uint8_t c) {
   1a33c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(!myGFX->gfxFont) { // 'Classic' built-in font
   1a33e:	6983      	ldr	r3, [r0, #24]
void GFXwrite(GFX* myGFX, uint8_t c) {
   1a340:	b085      	sub	sp, #20
   1a342:	4604      	mov	r4, r0
	if(!myGFX->gfxFont) { // 'Classic' built-in font
   1a344:	b32b      	cbz	r3, 1a392 <GFXwrite+0x56>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
		}

	} else { // Custom font

		if(c == '\n') {
   1a346:	290a      	cmp	r1, #10
   1a348:	d018      	beq.n	1a37c <GFXwrite+0x40>
			myGFX->cursor_x  = 0;
			myGFX->cursor_y += (int16_t)myGFX->textsize *
						(uint8_t)pgm_read_byte(&myGFX->gfxFont->yAdvance);
		} else if(c != '\r') {
   1a34a:	290d      	cmp	r1, #13
   1a34c:	d01f      	beq.n	1a38e <GFXwrite+0x52>
			uint8_t first = pgm_read_byte(&myGFX->gfxFont->first);
   1a34e:	7a1a      	ldrb	r2, [r3, #8]
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&myGFX->gfxFont->last))) {
   1a350:	4291      	cmp	r1, r2
   1a352:	d31c      	bcc.n	1a38e <GFXwrite+0x52>
   1a354:	7a58      	ldrb	r0, [r3, #9]
   1a356:	4288      	cmp	r0, r1
   1a358:	d319      	bcc.n	1a38e <GFXwrite+0x52>
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
				  &myGFX->gfxFont->glyph))[c - first]);
   1a35a:	685d      	ldr	r5, [r3, #4]
   1a35c:	1a8a      	subs	r2, r1, r2
   1a35e:	89e0      	ldrh	r0, [r4, #14]
   1a360:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
				uint8_t   w     = pgm_read_byte(&glyph->width),
						  h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   1a364:	78eb      	ldrb	r3, [r5, #3]
				uint8_t   w     = pgm_read_byte(&glyph->width),
   1a366:	78ae      	ldrb	r6, [r5, #2]
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   1a368:	b10b      	cbz	r3, 1a36e <GFXwrite+0x32>
   1a36a:	2e00      	cmp	r6, #0
   1a36c:	d158      	bne.n	1a420 <GFXwrite+0xe4>
					//     cursor_y += (int16_t)textsize *
					//       (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
					// }
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
				}
				myGFX->cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)myGFX->textsize;
   1a36e:	792b      	ldrb	r3, [r5, #4]
   1a370:	89a2      	ldrh	r2, [r4, #12]
   1a372:	fb13 f300 	smulbb	r3, r3, r0
   1a376:	4413      	add	r3, r2
   1a378:	81a3      	strh	r3, [r4, #12]
			}
		}

	}
}
   1a37a:	e008      	b.n	1a38e <GFXwrite+0x52>
			myGFX->cursor_x  = 0;
   1a37c:	2000      	movs	r0, #0
			myGFX->cursor_y += (int16_t)myGFX->textsize *
   1a37e:	8962      	ldrh	r2, [r4, #10]
   1a380:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
			myGFX->cursor_x  = 0;
   1a384:	81a0      	strh	r0, [r4, #12]
			myGFX->cursor_y += (int16_t)myGFX->textsize *
   1a386:	7a9b      	ldrb	r3, [r3, #10]
   1a388:	fb01 2303 	mla	r3, r1, r3, r2
   1a38c:	8163      	strh	r3, [r4, #10]
}
   1a38e:	b005      	add	sp, #20
   1a390:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(c == '\n') {                        // Newline?
   1a392:	290a      	cmp	r1, #10
   1a394:	d03c      	beq.n	1a410 <GFXwrite+0xd4>
		} else if(c != '\r') {                 // Ignore carriage returns
   1a396:	290d      	cmp	r1, #13
   1a398:	d0f9      	beq.n	1a38e <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a39a:	8a85      	ldrh	r5, [r0, #20]
   1a39c:	8962      	ldrh	r2, [r4, #10]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
   1a39e:	89c0      	ldrh	r0, [r0, #14]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a3a0:	b135      	cbz	r5, 1a3b0 <GFXwrite+0x74>
   1a3a2:	89a7      	ldrh	r7, [r4, #12]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
   1a3a4:	0085      	lsls	r5, r0, #2
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a3a6:	88a6      	ldrh	r6, [r4, #4]
   1a3a8:	fa07 f585 	sxtah	r5, r7, r5
   1a3ac:	42b5      	cmp	r5, r6
   1a3ae:	da6c      	bge.n	1a48a <GFXwrite+0x14e>
    if (myGFX->autoscroll) {
   1a3b0:	8c23      	ldrh	r3, [r4, #32]
   1a3b2:	b1b3      	cbz	r3, 1a3e2 <GFXwrite+0xa6>
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   1a3b4:	8ba3      	ldrh	r3, [r4, #28]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1a3b6:	8be5      	ldrh	r5, [r4, #30]
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   1a3b8:	fb13 f300 	smulbb	r3, r3, r0
        if (cursor >= myGFX->_height) {
   1a3bc:	88e7      	ldrh	r7, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1a3be:	fb15 f500 	smulbb	r5, r5, r0
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   1a3c2:	3b01      	subs	r3, #1
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1a3c4:	b2ad      	uxth	r5, r5
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   1a3c6:	b29b      	uxth	r3, r3
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1a3c8:	195e      	adds	r6, r3, r5
   1a3ca:	4416      	add	r6, r2
        if (cursor >= myGFX->_height) {
   1a3cc:	b2b6      	uxth	r6, r6
   1a3ce:	42be      	cmp	r6, r7
   1a3d0:	d307      	bcc.n	1a3e2 <GFXwrite+0xa6>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1a3d2:	43ed      	mvns	r5, r5
            myGFX->cursor_x  = 0;
   1a3d4:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1a3d6:	443d      	add	r5, r7
            myGFX->cursor_x  = 0;
   1a3d8:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1a3da:	1aeb      	subs	r3, r5, r3
   1a3dc:	b29a      	uxth	r2, r3
   1a3de:	8162      	strh	r2, [r4, #10]
   1a3e0:	e001      	b.n	1a3e6 <GFXwrite+0xaa>
   1a3e2:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
			GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
   1a3e6:	8a67      	ldrh	r7, [r4, #18]
   1a3e8:	b2c0      	uxtb	r0, r0
   1a3ea:	8a25      	ldrh	r5, [r4, #16]
   1a3ec:	460b      	mov	r3, r1
   1a3ee:	9002      	str	r0, [sp, #8]
   1a3f0:	b212      	sxth	r2, r2
   1a3f2:	4631      	mov	r1, r6
   1a3f4:	4620      	mov	r0, r4
   1a3f6:	e9cd 5700 	strd	r5, r7, [sp]
   1a3fa:	f7ff fd89 	bl	19f10 <GFXdrawChar>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
   1a3fe:	89e3      	ldrh	r3, [r4, #14]
   1a400:	89a2      	ldrh	r2, [r4, #12]
   1a402:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1a406:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   1a40a:	81a3      	strh	r3, [r4, #12]
}
   1a40c:	b005      	add	sp, #20
   1a40e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
   1a410:	8b82      	ldrh	r2, [r0, #28]
   1a412:	8961      	ldrh	r1, [r4, #10]
   1a414:	89c0      	ldrh	r0, [r0, #14]
			myGFX->cursor_x  = 0;                     // Reset x to zero,
   1a416:	81a3      	strh	r3, [r4, #12]
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
   1a418:	fb12 1300 	smlabb	r3, r2, r0, r1
   1a41c:	8163      	strh	r3, [r4, #10]
   1a41e:	e7b6      	b.n	1a38e <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a420:	8aa3      	ldrh	r3, [r4, #20]
   1a422:	8962      	ldrh	r2, [r4, #10]
   1a424:	b18b      	cbz	r3, 1a44a <GFXwrite+0x10e>
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   1a426:	f995 3005 	ldrsb.w	r3, [r5, #5]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a42a:	89a7      	ldrh	r7, [r4, #12]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   1a42c:	4433      	add	r3, r6
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a42e:	88a6      	ldrh	r6, [r4, #4]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   1a430:	fb13 f300 	smulbb	r3, r3, r0
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1a434:	fa07 f383 	sxtah	r3, r7, r3
   1a438:	42b3      	cmp	r3, r6
   1a43a:	db06      	blt.n	1a44a <GFXwrite+0x10e>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1a43c:	8ba3      	ldrh	r3, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
   1a43e:	2600      	movs	r6, #0
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1a440:	fb13 2200 	smlabb	r2, r3, r0, r2
    	myGFX->cursor_x  = 0;            // Reset x to zero
   1a444:	81a6      	strh	r6, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1a446:	b292      	uxth	r2, r2
   1a448:	8162      	strh	r2, [r4, #10]
    if (myGFX->autoscroll) {
   1a44a:	8c23      	ldrh	r3, [r4, #32]
   1a44c:	b323      	cbz	r3, 1a498 <GFXwrite+0x15c>
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1a44e:	8be3      	ldrh	r3, [r4, #30]
        if (cursor >= myGFX->_height) {
   1a450:	88e6      	ldrh	r6, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1a452:	fb13 f300 	smulbb	r3, r3, r0
   1a456:	b29b      	uxth	r3, r3
   1a458:	18d7      	adds	r7, r2, r3
        if (cursor >= myGFX->_height) {
   1a45a:	b2bf      	uxth	r7, r7
   1a45c:	42b7      	cmp	r7, r6
   1a45e:	d31b      	bcc.n	1a498 <GFXwrite+0x15c>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1a460:	1e72      	subs	r2, r6, #1
            myGFX->cursor_x  = 0;
   1a462:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1a464:	1ad3      	subs	r3, r2, r3
   1a466:	46b4      	mov	ip, r6
            myGFX->cursor_x  = 0;
   1a468:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1a46a:	b29a      	uxth	r2, r3
   1a46c:	8162      	strh	r2, [r4, #10]
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
   1a46e:	8a67      	ldrh	r7, [r4, #18]
   1a470:	b2c0      	uxtb	r0, r0
   1a472:	8a26      	ldrh	r6, [r4, #16]
   1a474:	460b      	mov	r3, r1
   1a476:	9002      	str	r0, [sp, #8]
   1a478:	b212      	sxth	r2, r2
   1a47a:	4620      	mov	r0, r4
   1a47c:	4661      	mov	r1, ip
   1a47e:	e9cd 6700 	strd	r6, r7, [sp]
   1a482:	f7ff fd45 	bl	19f10 <GFXdrawChar>
   1a486:	89e0      	ldrh	r0, [r4, #14]
   1a488:	e771      	b.n	1a36e <GFXwrite+0x32>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1a48a:	8ba5      	ldrh	r5, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
   1a48c:	81a3      	strh	r3, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1a48e:	fb15 2200 	smlabb	r2, r5, r0, r2
   1a492:	b292      	uxth	r2, r2
   1a494:	8162      	strh	r2, [r4, #10]
   1a496:	e78b      	b.n	1a3b0 <GFXwrite+0x74>
   1a498:	f9b4 c00c 	ldrsh.w	ip, [r4, #12]
   1a49c:	e7e7      	b.n	1a46e <GFXwrite+0x132>
   1a49e:	bf00      	nop

0001a4a0 <GFXsetCursor>:

void GFXsetCursor(GFX* myGFX, int16_t x, int16_t y) {
	myGFX->cursor_x = x;
   1a4a0:	8181      	strh	r1, [r0, #12]
	myGFX->cursor_y = y;
   1a4a2:	8142      	strh	r2, [r0, #10]
}
   1a4a4:	4770      	bx	lr
   1a4a6:	bf00      	nop

0001a4a8 <GFXgetCursorX>:

int16_t GFXgetCursorX(GFX* myGFX)
{
    return myGFX->cursor_x;
}
   1a4a8:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
   1a4ac:	4770      	bx	lr
   1a4ae:	bf00      	nop

0001a4b0 <GFXsetTextSize>:
{
    return myGFX->cursor_y;
}

void GFXsetTextSize(GFX* myGFX, uint8_t s) {
	myGFX->textsize = (s > 0) ? s : 1;
   1a4b0:	2900      	cmp	r1, #0
   1a4b2:	bf08      	it	eq
   1a4b4:	2101      	moveq	r1, #1
   1a4b6:	81c1      	strh	r1, [r0, #14]
}
   1a4b8:	4770      	bx	lr
   1a4ba:	bf00      	nop

0001a4bc <GFXsetTextColor>:

void GFXsetTextColor(GFX* myGFX, uint16_t c, uint16_t b) {
	myGFX->textcolor   = c;
   1a4bc:	8201      	strh	r1, [r0, #16]
	myGFX->textbgcolor = b;
   1a4be:	8242      	strh	r2, [r0, #18]
}
   1a4c0:	4770      	bx	lr
   1a4c2:	bf00      	nop

0001a4c4 <GFXsetFont>:
// to this function to use correct CP437 character values in your code.
void GFXcp437(GFX* myGFX, uint8_t x) {
	myGFX->_cp437 = x;
}

void GFXsetFont(GFX* myGFX, const GFXfont *f) {
   1a4c4:	6983      	ldr	r3, [r0, #24]

	if(f)
   1a4c6:	b139      	cbz	r1, 1a4d8 <GFXsetFont+0x14>
    {            // Font struct pointer passed in?
        if(!myGFX->gfxFont) { // And no current font struct?
   1a4c8:	b10b      	cbz	r3, 1a4ce <GFXsetFont+0xa>
		}

		myGFX->fontHeight = 8;
		myGFX->fontDesc = 0;
	}
    myGFX->gfxFont = (GFXfont *)f;
   1a4ca:	6181      	str	r1, [r0, #24]
}
   1a4cc:	4770      	bx	lr
        	myGFX->cursor_y += 6;
   1a4ce:	8943      	ldrh	r3, [r0, #10]
    myGFX->gfxFont = (GFXfont *)f;
   1a4d0:	6181      	str	r1, [r0, #24]
        	myGFX->cursor_y += 6;
   1a4d2:	3306      	adds	r3, #6
   1a4d4:	8143      	strh	r3, [r0, #10]
}
   1a4d6:	4770      	bx	lr
	else if(myGFX->gfxFont)
   1a4d8:	b113      	cbz	r3, 1a4e0 <GFXsetFont+0x1c>
		myGFX->fontDesc = 0;
   1a4da:	83c1      	strh	r1, [r0, #30]
		uint8_t first  = (uint8_t) pgm_read_byte(&f->first);
   1a4dc:	7a0b      	ldrb	r3, [r1, #8]
   1a4de:	deff      	udf	#255	; 0xff
		myGFX->fontHeight = 8;
   1a4e0:	2308      	movs	r3, #8
   1a4e2:	61c3      	str	r3, [r0, #28]
   1a4e4:	e7f1      	b.n	1a4ca <GFXsetFont+0x6>
   1a4e6:	bf00      	nop

0001a4e8 <OLEDparseInt>:
	'A', '#',
	'B', ' '
};

int OLEDparseInt(char* buffer, uint32_t myNumber, uint8_t numDigits)
{
   1a4e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int i = 0; i < numDigits; i++)
   1a4ea:	4617      	mov	r7, r2
   1a4ec:	b1ca      	cbz	r2, 1a522 <OLEDparseInt+0x3a>
   1a4ee:	460d      	mov	r5, r1
   1a4f0:	4606      	mov	r6, r0
   1a4f2:	1e54      	subs	r4, r2, #1
	{
		int whichPlace = (uint32_t)(powf(10.0f,(numDigits - 1) - i));
   1a4f4:	ee07 4a90 	vmov	s15, r4
   1a4f8:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1a4fc:	3c01      	subs	r4, #1
   1a4fe:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   1a502:	f016 f92d 	bl	30760 <powf>
   1a506:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   1a50a:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
   1a50e:	fbb5 f2f3 	udiv	r2, r5, r3
		buffer[i] = thisDigit + 48;
   1a512:	f102 0130 	add.w	r1, r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
   1a516:	fb02 5513 	mls	r5, r2, r3, r5
	for (int i = 0; i < numDigits; i++)
   1a51a:	1c63      	adds	r3, r4, #1
		buffer[i] = thisDigit + 48;
   1a51c:	f806 1b01 	strb.w	r1, [r6], #1
	for (int i = 0; i < numDigits; i++)
   1a520:	d1e8      	bne.n	1a4f4 <OLEDparseInt+0xc>
	}

	return numDigits;
}
   1a522:	4638      	mov	r0, r7
   1a524:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a526:	bf00      	nop

0001a528 <OLEDparsePitch>:

int OLEDparsePitch(char* buffer, float midi, uint8_t showCents)
{
	int pclass, octave, note, neg = 0; float offset;

	note = (int)midi;
   1a528:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	offset = midi - note;

	if ((midi + 0.5f) > (note+1))
   1a52c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	note = (int)midi;
   1a530:	ee17 3a10 	vmov	r3, s14
	offset = midi - note;
   1a534:	eef8 6ac7 	vcvt.f32.s32	s13, s14
	if ((midi + 0.5f) > (note+1))
   1a538:	ee70 7a27 	vadd.f32	s15, s0, s15
{
   1a53c:	b470      	push	{r4, r5, r6}
	if ((midi + 0.5f) > (note+1))
   1a53e:	1c5c      	adds	r4, r3, #1
	offset = midi - note;
   1a540:	ee30 0a66 	vsub.f32	s0, s0, s13
	if ((midi + 0.5f) > (note+1))
   1a544:	ee07 4a10 	vmov	s14, r4
   1a548:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1a54c:	eef4 7ac7 	vcmpe.f32	s15, s14
   1a550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1a554:	dd4a      	ble.n	1a5ec <OLEDparsePitch+0xc4>
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
   1a556:	f244 72ae 	movw	r2, #18350	; 0x47ae
		note += 1;
   1a55a:	4623      	mov	r3, r4
		neg = 1;
   1a55c:	2601      	movs	r6, #1
		offset = (1.0f - offset) + 0.01f;
   1a55e:	f6c3 7281 	movt	r2, #16257	; 0x3f81
   1a562:	ee07 2a90 	vmov	s15, r2
   1a566:	ee37 0ac0 	vsub.f32	s0, s15, s0
	}

	pclass = (note % 12);
   1a56a:	f64a 25ab 	movw	r5, #43691	; 0xaaab
   1a56e:	17da      	asrs	r2, r3, #31
	octave = (int)(note / 12) - 1;

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
   1a570:	f246 0424 	movw	r4, #24612	; 0x6024
	pclass = (note % 12);
   1a574:	f6c2 25aa 	movt	r5, #10922	; 0x2aaa
	buffer[idx++] = pitches[pclass*2];
   1a578:	f2c0 0406 	movt	r4, #6
	pclass = (note % 12);
   1a57c:	fb85 c503 	smull	ip, r5, r5, r3
   1a580:	ebc2 0265 	rsb	r2, r2, r5, asr #1
   1a584:	eb02 0542 	add.w	r5, r2, r2, lsl #1
		buffer[i] = thisDigit + 48;
   1a588:	322f      	adds	r2, #47	; 0x2f
	pclass = (note % 12);
   1a58a:	eba3 0385 	sub.w	r3, r3, r5, lsl #2
	buffer[idx++] = pitches[pclass*2];
   1a58e:	f814 5013 	ldrb.w	r5, [r4, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
   1a592:	eb04 0343 	add.w	r3, r4, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
   1a596:	7005      	strb	r5, [r0, #0]
	buffer[idx++] = pitches[pclass*2+1];
   1a598:	785b      	ldrb	r3, [r3, #1]
		buffer[i] = thisDigit + 48;
   1a59a:	7082      	strb	r2, [r0, #2]
	buffer[idx++] = pitches[pclass*2+1];
   1a59c:	7043      	strb	r3, [r0, #1]

	OLEDparseInt(&buffer[idx++], octave, 1);

	if (showCents)
   1a59e:	b339      	cbz	r1, 1a5f0 <OLEDparsePitch+0xc8>
		if (neg == 1)
			buffer[idx++] = '-';
		else
			buffer[idx++] = '+';

		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   1a5a0:	2300      	movs	r3, #0
		if (neg == 1)
   1a5a2:	2e01      	cmp	r6, #1
		int thisDigit = (myNumber / whichPlace);
   1a5a4:	f64c 42cd 	movw	r2, #52429	; 0xcccd
		buffer[idx++] = ' ';
   1a5a8:	f04f 0120 	mov.w	r1, #32
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   1a5ac:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
			buffer[idx++] = '+';
   1a5b0:	bf0c      	ite	eq
   1a5b2:	242d      	moveq	r4, #45	; 0x2d
   1a5b4:	242b      	movne	r4, #43	; 0x2b
		int thisDigit = (myNumber / whichPlace);
   1a5b6:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   1a5ba:	ee07 3a90 	vmov	s15, r3
		buffer[idx++] = ' ';
   1a5be:	70c1      	strb	r1, [r0, #3]
   1a5c0:	7104      	strb	r4, [r0, #4]
		idx += 2;
   1a5c2:	2107      	movs	r1, #7
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   1a5c4:	ee20 0a27 	vmul.f32	s0, s0, s15
   1a5c8:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   1a5cc:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
   1a5d0:	fba2 4203 	umull	r4, r2, r2, r3
   1a5d4:	08d2      	lsrs	r2, r2, #3
		myNumber -= thisDigit * whichPlace;
   1a5d6:	eb02 0482 	add.w	r4, r2, r2, lsl #2
		buffer[i] = thisDigit + 48;
   1a5da:	3230      	adds	r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
   1a5dc:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
		buffer[i] = thisDigit + 48;
   1a5e0:	7142      	strb	r2, [r0, #5]
   1a5e2:	3330      	adds	r3, #48	; 0x30
   1a5e4:	7183      	strb	r3, [r0, #6]
	}

	return idx;
}
   1a5e6:	4608      	mov	r0, r1
   1a5e8:	bc70      	pop	{r4, r5, r6}
   1a5ea:	4770      	bx	lr
	int pclass, octave, note, neg = 0; float offset;
   1a5ec:	2600      	movs	r6, #0
   1a5ee:	e7bc      	b.n	1a56a <OLEDparsePitch+0x42>
	OLEDparseInt(&buffer[idx++], octave, 1);
   1a5f0:	2103      	movs	r1, #3
}
   1a5f2:	bc70      	pop	{r4, r5, r6}
   1a5f4:	4608      	mov	r0, r1
   1a5f6:	4770      	bx	lr

0001a5f8 <OLEDparsePitchClass>:
int OLEDparsePitchClass(char* buffer, float midi)
{
	int pclass, note;
	float offset;

	note = (int)midi;
   1a5f8:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
	}

	pclass = (note % 12);
   1a5fc:	f64a 21ab 	movw	r1, #43691	; 0xaaab
	if ((midi + 0.5f) > (note+1))
   1a600:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
   1a604:	f246 0224 	movw	r2, #24612	; 0x6024
	pclass = (note % 12);
   1a608:	f6c2 21aa 	movt	r1, #10922	; 0x2aaa
	note = (int)midi;
   1a60c:	ee17 3a10 	vmov	r3, s14
	buffer[idx++] = pitches[pclass*2];
   1a610:	f2c0 0206 	movt	r2, #6
	if ((midi + 0.5f) > (note+1))
   1a614:	ee30 0a27 	vadd.f32	s0, s0, s15
{
   1a618:	b430      	push	{r4, r5}
	if ((midi + 0.5f) > (note+1))
   1a61a:	1c5c      	adds	r4, r3, #1
{
   1a61c:	4605      	mov	r5, r0
	buffer[idx++] = pitches[pclass*2+1];

	return idx;
}
   1a61e:	2002      	movs	r0, #2
	if ((midi + 0.5f) > (note+1))
   1a620:	ee07 4a90 	vmov	s15, r4
   1a624:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		note += 1;
   1a628:	eeb4 0a67 	vcmp.f32	s0, s15
   1a62c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1a630:	bfc8      	it	gt
   1a632:	4623      	movgt	r3, r4
	pclass = (note % 12);
   1a634:	fb81 1403 	smull	r1, r4, r1, r3
   1a638:	17d9      	asrs	r1, r3, #31
   1a63a:	ebc1 0164 	rsb	r1, r1, r4, asr #1
   1a63e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   1a642:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
	buffer[idx++] = pitches[pclass*2];
   1a646:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
   1a64a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
   1a64e:	7029      	strb	r1, [r5, #0]
	buffer[idx++] = pitches[pclass*2+1];
   1a650:	785b      	ldrb	r3, [r3, #1]
   1a652:	706b      	strb	r3, [r5, #1]
}
   1a654:	bc30      	pop	{r4, r5}
   1a656:	4770      	bx	lr

0001a658 <OLEDparseFixedFloat>:

int OLEDparseFixedFloat(char* buffer, float input, uint8_t numDigits, uint8_t numDecimal)
{
	float power = powf(10.0f, numDecimal);
   1a658:	ee07 2a90 	vmov	s15, r2
{
   1a65c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a660:	ed2d 8b02 	vpush	{d8}
   1a664:	b085      	sub	sp, #20
   1a666:	eeb0 8a40 	vmov.f32	s16, s0
	float power = powf(10.0f, numDecimal);
   1a66a:	eef8 0a67 	vcvt.f32.u32	s1, s15
{
   1a66e:	4680      	mov	r8, r0
	float power = powf(10.0f, numDecimal);
   1a670:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
{
   1a674:	9201      	str	r2, [sp, #4]
   1a676:	9102      	str	r1, [sp, #8]
	float power = powf(10.0f, numDecimal);
   1a678:	f016 f872 	bl	30760 <powf>
	float f = ((float)(int)(input * power + 0.5f)) / power;
   1a67c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1a680:	eee0 7a08 	vfma.f32	s15, s0, s16
   1a684:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1a688:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1a68c:	ee87 7a80 	vdiv.f32	s14, s15, s0

	int nonzeroHasHappened = 0, decimalHasHappened = 0;

	int myNumber = (int)(f * power);
   1a690:	ee27 0a00 	vmul.f32	s0, s14, s0
   1a694:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   1a698:	ee17 5a90 	vmov	r5, s15

	int idx = 0, i = 0;

	if (myNumber < 0)
   1a69c:	2d00      	cmp	r5, #0
   1a69e:	f2c0 8082 	blt.w	1a7a6 <OLEDparseFixedFloat+0x14e>
	int idx = 0, i = 0;
   1a6a2:	2600      	movs	r6, #0
		myNumber *= -1;
		buffer[idx++] = '-';
		i++;
	}

	while (i < numDigits)
   1a6a4:	9b02      	ldr	r3, [sp, #8]
   1a6a6:	429e      	cmp	r6, r3
   1a6a8:	da3e      	bge.n	1a728 <OLEDparseFixedFloat+0xd0>
   1a6aa:	2400      	movs	r4, #0
   1a6ac:	1b9f      	subs	r7, r3, r6
   1a6ae:	9603      	str	r6, [sp, #12]
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
		{
			if (nonzeroHasHappened == 0)
			{
				idx++; //get past the negative if there is one - this is hacky should figure out how to do it right
				buffer[idx-1] = '0';
   1a6b0:	46a9      	mov	r9, r5
			decimalHasHappened = 1;
		}
		else
		{

			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   1a6b2:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
	while (i < numDigits)
   1a6b6:	9400      	str	r4, [sp, #0]
				buffer[idx-1] = '0';
   1a6b8:	46a3      	mov	fp, r4
   1a6ba:	e00d      	b.n	1a6d8 <OLEDparseFixedFloat+0x80>
			int thisDigit = (myNumber / whichPlace);

			if (nonzeroHasHappened == 0)
			{
				if (thisDigit > 0)
   1a6bc:	2b00      	cmp	r3, #0
   1a6be:	dd63      	ble.n	1a788 <OLEDparseFixedFloat+0x130>
				{
					buffer[idx++] = thisDigit + 48;
   1a6c0:	f103 0e30 	add.w	lr, r3, #48	; 0x30
   1a6c4:	462e      	mov	r6, r5
					nonzeroHasHappened = 1;
   1a6c6:	f04f 0b01 	mov.w	fp, #1
					buffer[idx++] = thisDigit + 48;
   1a6ca:	f88c e000 	strb.w	lr, [ip]
   1a6ce:	3401      	adds	r4, #1
   1a6d0:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
   1a6d4:	42bc      	cmp	r4, r7
   1a6d6:	d027      	beq.n	1a728 <OLEDparseFixedFloat+0xd0>
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
   1a6d8:	9b00      	ldr	r3, [sp, #0]
   1a6da:	1c75      	adds	r5, r6, #1
   1a6dc:	b91b      	cbnz	r3, 1a6e6 <OLEDparseFixedFloat+0x8e>
   1a6de:	1b3b      	subs	r3, r7, r4
   1a6e0:	9a01      	ldr	r2, [sp, #4]
   1a6e2:	429a      	cmp	r2, r3
   1a6e4:	d026      	beq.n	1a734 <OLEDparseFixedFloat+0xdc>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   1a6e6:	ebaa 0304 	sub.w	r3, sl, r4
   1a6ea:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1a6ee:	ee07 3a90 	vmov	s15, r3
   1a6f2:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   1a6f6:	f016 f833 	bl	30760 <powf>
   1a6fa:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   1a6fe:	eb08 0c06 	add.w	ip, r8, r6
   1a702:	ee17 2a90 	vmov	r2, s15
			int thisDigit = (myNumber / whichPlace);
   1a706:	fb99 f3f2 	sdiv	r3, r9, r2
			if (nonzeroHasHappened == 0)
   1a70a:	f1bb 0f00 	cmp.w	fp, #0
   1a70e:	d0d5      	beq.n	1a6bc <OLEDparseFixedFloat+0x64>
					buffer[idx++] = ' ';
				}
			}
			else
			{
				buffer[idx++] = thisDigit + 48;
   1a710:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1a714:	462e      	mov	r6, r5
   1a716:	f04f 0b01 	mov.w	fp, #1
   1a71a:	f88c 1000 	strb.w	r1, [ip]
   1a71e:	3401      	adds	r4, #1
   1a720:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
   1a724:	42bc      	cmp	r4, r7
   1a726:	d1d7      	bne.n	1a6d8 <OLEDparseFixedFloat+0x80>
			i++;
		}
	}

	return idx;
}
   1a728:	4630      	mov	r0, r6
   1a72a:	b005      	add	sp, #20
   1a72c:	ecbd 8b02 	vpop	{d8}
   1a730:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (nonzeroHasHappened == 0)
   1a734:	f1bb 0f00 	cmp.w	fp, #0
   1a738:	d02c      	beq.n	1a794 <OLEDparseFixedFloat+0x13c>
   1a73a:	4632      	mov	r2, r6
	while (i < numDigits)
   1a73c:	9b03      	ldr	r3, [sp, #12]
			buffer[idx++] = '.';
   1a73e:	f04f 012e 	mov.w	r1, #46	; 0x2e
	while (i < numDigits)
   1a742:	4423      	add	r3, r4
			buffer[idx++] = '.';
   1a744:	f808 1002 	strb.w	r1, [r8, r2]
	while (i < numDigits)
   1a748:	9a02      	ldr	r2, [sp, #8]
   1a74a:	4293      	cmp	r3, r2
   1a74c:	da31      	bge.n	1a7b2 <OLEDparseFixedFloat+0x15a>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   1a74e:	ebaa 0304 	sub.w	r3, sl, r4
			decimalHasHappened = 1;
   1a752:	2201      	movs	r2, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   1a754:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
				buffer[idx++] = thisDigit + 48;
   1a758:	f04f 0b01 	mov.w	fp, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   1a75c:	ee07 3a90 	vmov	s15, r3
			decimalHasHappened = 1;
   1a760:	9200      	str	r2, [sp, #0]
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   1a762:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   1a766:	f015 fffb 	bl	30760 <powf>
   1a76a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   1a76e:	eb08 0c05 	add.w	ip, r8, r5
   1a772:	3501      	adds	r5, #1
   1a774:	ee17 2a90 	vmov	r2, s15
				buffer[idx++] = thisDigit + 48;
   1a778:	462e      	mov	r6, r5
			int thisDigit = (myNumber / whichPlace);
   1a77a:	fb99 f3f2 	sdiv	r3, r9, r2
				buffer[idx++] = thisDigit + 48;
   1a77e:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1a782:	f88c 1000 	strb.w	r1, [ip]
   1a786:	e7ca      	b.n	1a71e <OLEDparseFixedFloat+0xc6>
					buffer[idx++] = ' ';
   1a788:	f04f 0120 	mov.w	r1, #32
   1a78c:	462e      	mov	r6, r5
   1a78e:	f88c 1000 	strb.w	r1, [ip]
   1a792:	e79c      	b.n	1a6ce <OLEDparseFixedFloat+0x76>
				buffer[idx-1] = '0';
   1a794:	eb08 0305 	add.w	r3, r8, r5
   1a798:	f04f 0130 	mov.w	r1, #48	; 0x30
   1a79c:	462a      	mov	r2, r5
   1a79e:	1cb5      	adds	r5, r6, #2
   1a7a0:	f803 1c01 	strb.w	r1, [r3, #-1]
   1a7a4:	e7ca      	b.n	1a73c <OLEDparseFixedFloat+0xe4>
		buffer[idx++] = '-';
   1a7a6:	232d      	movs	r3, #45	; 0x2d
		myNumber *= -1;
   1a7a8:	426d      	negs	r5, r5
		buffer[idx++] = '-';
   1a7aa:	2601      	movs	r6, #1
   1a7ac:	f888 3000 	strb.w	r3, [r8]
   1a7b0:	e778      	b.n	1a6a4 <OLEDparseFixedFloat+0x4c>
			buffer[idx++] = '.';
   1a7b2:	462e      	mov	r6, r5
}
   1a7b4:	4630      	mov	r0, r6
   1a7b6:	b005      	add	sp, #20
   1a7b8:	ecbd 8b02 	vpop	{d8}
   1a7bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001a7c0 <MX_GPIO_Init>:
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
   1a7c0:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   1a7c4:	f244 01d0 	movw	r1, #16592	; 0x40d0
{
   1a7c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_RCC_GPIOE_CLK_ENABLE();
   1a7cc:	f6c5 0302 	movt	r3, #22530	; 0x5802
{
   1a7d0:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a7d2:	2400      	movs	r4, #0
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   1a7d4:	f44f 6900 	mov.w	r9, #2048	; 0x800

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   1a7d8:	f44f 5ba0 	mov.w	fp, #5120	; 0x1400
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
                          |GPIO_PIN_10, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   1a7dc:	f44f 6880 	mov.w	r8, #1024	; 0x400
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a7e0:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   1a7e2:	f6c5 0902 	movt	r9, #22530	; 0x5802
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a7e6:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   1a7e8:	46a2      	mov	sl, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a7ea:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   1a7ec:	f6c5 0b02 	movt	fp, #22530	; 0x5802
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a7f0:	940c      	str	r4, [sp, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   1a7f2:	f6c5 0a02 	movt	sl, #22530	; 0x5802
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a7f6:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   1a7f8:	4648      	mov	r0, r9
  __HAL_RCC_GPIOE_CLK_ENABLE();
   1a7fa:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   1a7fe:	4622      	mov	r2, r4

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   1a800:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   1a804:	f6c5 0802 	movt	r8, #22530	; 0x5802
  __HAL_RCC_GPIOE_CLK_ENABLE();
   1a808:	f045 0510 	orr.w	r5, r5, #16
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pins : PF7 PF8 PF9 PF10 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1a80c:	2703      	movs	r7, #3
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   1a80e:	f6c5 0602 	movt	r6, #22530	; 0x5802
  __HAL_RCC_GPIOE_CLK_ENABLE();
   1a812:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a816:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a81a:	f005 0510 	and.w	r5, r5, #16
   1a81e:	9501      	str	r5, [sp, #4]
   1a820:	9d01      	ldr	r5, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
   1a822:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a826:	f045 0504 	orr.w	r5, r5, #4
   1a82a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a82e:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a832:	f005 0504 	and.w	r5, r5, #4
   1a836:	9502      	str	r5, [sp, #8]
   1a838:	9d02      	ldr	r5, [sp, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
   1a83a:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a83e:	f045 0520 	orr.w	r5, r5, #32
   1a842:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a846:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a84a:	f005 0520 	and.w	r5, r5, #32
   1a84e:	9503      	str	r5, [sp, #12]
   1a850:	9d03      	ldr	r5, [sp, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
   1a852:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a856:	f045 0580 	orr.w	r5, r5, #128	; 0x80
   1a85a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a85e:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a862:	f005 0580 	and.w	r5, r5, #128	; 0x80
   1a866:	9504      	str	r5, [sp, #16]
   1a868:	9d04      	ldr	r5, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
   1a86a:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a86e:	f045 0501 	orr.w	r5, r5, #1
   1a872:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a876:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a87a:	f005 0501 	and.w	r5, r5, #1
   1a87e:	9505      	str	r5, [sp, #20]
   1a880:	9d05      	ldr	r5, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
   1a882:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a886:	f045 0502 	orr.w	r5, r5, #2
   1a88a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a88e:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a892:	f005 0502 	and.w	r5, r5, #2
   1a896:	9506      	str	r5, [sp, #24]
   1a898:	9d06      	ldr	r5, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
   1a89a:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a89e:	f045 0540 	orr.w	r5, r5, #64	; 0x40
   1a8a2:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
   1a8a6:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a8aa:	f005 0540 	and.w	r5, r5, #64	; 0x40
   1a8ae:	9507      	str	r5, [sp, #28]
   1a8b0:	9d07      	ldr	r5, [sp, #28]
  __HAL_RCC_GPIOD_CLK_ENABLE();
   1a8b2:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1a8b6:	f045 0508 	orr.w	r5, r5, #8
   1a8ba:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   1a8be:	2501      	movs	r5, #1
  __HAL_RCC_GPIOD_CLK_ENABLE();
   1a8c0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   1a8c4:	f003 0308 	and.w	r3, r3, #8
   1a8c8:	9308      	str	r3, [sp, #32]
   1a8ca:	9b08      	ldr	r3, [sp, #32]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   1a8cc:	f7f2 fa0e 	bl	ccec <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   1a8d0:	4658      	mov	r0, fp
   1a8d2:	4622      	mov	r2, r4
   1a8d4:	2140      	movs	r1, #64	; 0x40
   1a8d6:	f7f2 fa09 	bl	ccec <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   1a8da:	4650      	mov	r0, sl
   1a8dc:	4622      	mov	r2, r4
   1a8de:	f44f 61ea 	mov.w	r1, #1872	; 0x750
   1a8e2:	f7f2 fa03 	bl	ccec <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   1a8e6:	4640      	mov	r0, r8
   1a8e8:	4622      	mov	r2, r4
   1a8ea:	2111      	movs	r1, #17
   1a8ec:	f7f2 f9fe 	bl	ccec <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   1a8f0:	4622      	mov	r2, r4
   1a8f2:	4630      	mov	r0, r6
   1a8f4:	f44f 6198 	mov.w	r1, #1216	; 0x4c0
   1a8f8:	f7f2 f9f8 	bl	ccec <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13;
   1a8fc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a900:	4648      	mov	r0, r9
   1a902:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_13;
   1a904:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a906:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a90a:	f7f1 fe45 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
   1a90e:	f244 03d0 	movw	r3, #16592	; 0x40d0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a912:	4648      	mov	r0, r9
   1a914:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
   1a916:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   1a918:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   1a91a:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a91e:	f7f1 fe3b 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   1a922:	4623      	mov	r3, r4
  GPIO_InitStruct.Pin = GPIO_PIN_15;
   1a924:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a928:	4648      	mov	r0, r9
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   1a92a:	f2c1 1311 	movt	r3, #4369	; 0x1111
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a92e:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_15;
   1a930:	9209      	str	r2, [sp, #36]	; 0x24

  /*Configure GPIO pins : PD11 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a932:	f44f 6940 	mov.w	r9, #3072	; 0xc00
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   1a936:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a938:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a93a:	f7f1 fe2d 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_6;
   1a93e:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1a940:	4658      	mov	r0, fp
   1a942:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   1a944:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pin = GPIO_PIN_6;
   1a946:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a948:	f6c5 0902 	movt	r9, #22530	; 0x5802
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a94c:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1a950:	f7f1 fe22 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
   1a954:	f44f 63f0 	mov.w	r3, #1920	; 0x780
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1a958:	4658      	mov	r0, fp
   1a95a:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
   1a95c:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a95e:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1a960:	970a      	str	r7, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   1a962:	f7f1 fe19 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
   1a966:	f248 0302 	movw	r3, #32770	; 0x8002
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   1a96a:	4650      	mov	r0, sl
   1a96c:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
   1a96e:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a970:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   1a974:	f7f1 fe10 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   1a978:	f44f 63ea 	mov.w	r3, #1872	; 0x750
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   1a97c:	4650      	mov	r0, sl
   1a97e:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   1a980:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   1a982:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a984:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   1a988:	f7f1 fe06 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
   1a98c:	2311      	movs	r3, #17
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1a98e:	4640      	mov	r0, r8
   1a990:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
   1a992:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   1a994:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a996:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1a99a:	f7f1 fdfd 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
   1a99e:	f24f 0302 	movw	r3, #61442	; 0xf002
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1a9a2:	4640      	mov	r0, r8
   1a9a4:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
   1a9a6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   1a9a8:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1a9ac:	f7f1 fdf4 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
   1a9b0:	f44f 7301 	mov.w	r3, #516	; 0x204
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1a9b4:	4640      	mov	r0, r8
   1a9b6:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
   1a9b8:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a9ba:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1a9be:	f7f1 fdeb 	bl	c598 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
   1a9c2:	f44f 6308 	mov.w	r3, #2176	; 0x880
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a9c6:	4648      	mov	r0, r9
   1a9c8:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
   1a9ca:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   1a9cc:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a9d0:	f7f1 fde2 	bl	c598 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG3 PG9 PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
   1a9d4:	f246 2308 	movw	r3, #25096	; 0x6208
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1a9d8:	4630      	mov	r0, r6
   1a9da:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
   1a9dc:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a9de:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1a9e2:	f7f1 fdd9 	bl	c598 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG7 PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
   1a9e6:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1a9ea:	4630      	mov	r0, r6
   1a9ec:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
   1a9ee:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   1a9f0:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a9f2:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1a9f6:	f7f1 fdcf 	bl	c598 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD3 PD4 PD5 PD6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   1a9fa:	2378      	movs	r3, #120	; 0x78
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a9fc:	4648      	mov	r0, r9
   1a9fe:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   1aa00:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   1aa02:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1aa06:	f7f1 fdc7 	bl	c598 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG11 PG12 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   1aa0a:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1aa0e:	4630      	mov	r0, r6
   1aa10:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   1aa12:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   1aa14:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   1aa18:	f7f1 fdbe 	bl	c598 <HAL_GPIO_Init>

}
   1aa1c:	b00f      	add	sp, #60	; 0x3c
   1aa1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1aa22:	bf00      	nop

0001aa24 <MX_I2C2_Init>:
DMA_HandleTypeDef hdma_i2c4_rx;
DMA_HandleTypeDef hdma_i2c4_tx;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
   1aa24:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
   1aa26:	f24b 33f8 	movw	r3, #46072	; 0xb3f8
   1aa2a:	f44f 44b0 	mov.w	r4, #22528	; 0x5800
  hi2c2.Init.Timing = 0x505097F4;
   1aa2e:	f249 71f4 	movw	r1, #38900	; 0x97f4
  hi2c2.Init.OwnAddress1 = 0;
   1aa32:	2200      	movs	r2, #0
  hi2c2.Instance = I2C2;
   1aa34:	f2c0 230f 	movt	r3, #527	; 0x20f
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   1aa38:	2501      	movs	r5, #1
  hi2c2.Instance = I2C2;
   1aa3a:	f2c4 0400 	movt	r4, #16384	; 0x4000
  hi2c2.Init.Timing = 0x505097F4;
   1aa3e:	f2c5 0150 	movt	r1, #20560	; 0x5050
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
   1aa42:	4618      	mov	r0, r3
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   1aa44:	621a      	str	r2, [r3, #32]
  hi2c2.Init.Timing = 0x505097F4;
   1aa46:	e9c3 4100 	strd	r4, r1, [r3]
  hi2c2.Init.OwnAddress1 = 0;
   1aa4a:	e9c3 2502 	strd	r2, r5, [r3, #8]
  hi2c2.Init.OwnAddress2 = 0;
   1aa4e:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   1aa52:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
   1aa56:	f7f2 fb87 	bl	d168 <HAL_I2C_Init>
   1aa5a:	b9b8      	cbnz	r0, 1aa8c <MX_I2C2_Init+0x68>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
   1aa5c:	f24b 30f8 	movw	r0, #46072	; 0xb3f8
   1aa60:	2100      	movs	r1, #0
   1aa62:	f2c0 200f 	movt	r0, #527	; 0x20f
   1aa66:	f7f4 f847 	bl	eaf8 <HAL_I2CEx_ConfigAnalogFilter>
   1aa6a:	b960      	cbnz	r0, 1aa86 <MX_I2C2_Init+0x62>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
   1aa6c:	f24b 30f8 	movw	r0, #46072	; 0xb3f8
   1aa70:	2100      	movs	r1, #0
   1aa72:	f2c0 200f 	movt	r0, #527	; 0x20f
   1aa76:	f7f4 f89f 	bl	ebb8 <HAL_I2CEx_ConfigDigitalFilter>
   1aa7a:	b900      	cbnz	r0, 1aa7e <MX_I2C2_Init+0x5a>
  {
    Error_Handler();
  }

}
   1aa7c:	bd38      	pop	{r3, r4, r5, pc}
   1aa7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
   1aa82:	f000 bb13 	b.w	1b0ac <Error_Handler>
    Error_Handler();
   1aa86:	f000 fb11 	bl	1b0ac <Error_Handler>
   1aa8a:	e7ef      	b.n	1aa6c <MX_I2C2_Init+0x48>
    Error_Handler();
   1aa8c:	f000 fb0e 	bl	1b0ac <Error_Handler>
   1aa90:	e7e4      	b.n	1aa5c <MX_I2C2_Init+0x38>
   1aa92:	bf00      	nop

0001aa94 <MX_I2C4_Init>:
/* I2C4 init function */
void MX_I2C4_Init(void)
{
   1aa94:	b538      	push	{r3, r4, r5, lr}

  hi2c4.Instance = I2C4;
   1aa96:	f24b 33ac 	movw	r3, #45996	; 0xb3ac
   1aa9a:	f44f 54e0 	mov.w	r4, #7168	; 0x1c00
  hi2c4.Init.Timing = 0x307075B1;
   1aa9e:	f247 51b1 	movw	r1, #30129	; 0x75b1
  hi2c4.Init.OwnAddress1 = 0;
   1aaa2:	2200      	movs	r2, #0
  hi2c4.Instance = I2C4;
   1aaa4:	f2c0 230f 	movt	r3, #527	; 0x20f
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   1aaa8:	2501      	movs	r5, #1
  hi2c4.Instance = I2C4;
   1aaaa:	f6c5 0400 	movt	r4, #22528	; 0x5800
  hi2c4.Init.Timing = 0x307075B1;
   1aaae:	f2c3 0170 	movt	r1, #12400	; 0x3070
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   1aab2:	4618      	mov	r0, r3
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   1aab4:	621a      	str	r2, [r3, #32]
  hi2c4.Init.Timing = 0x307075B1;
   1aab6:	e9c3 4100 	strd	r4, r1, [r3]
  hi2c4.Init.OwnAddress1 = 0;
   1aaba:	e9c3 2502 	strd	r2, r5, [r3, #8]
  hi2c4.Init.OwnAddress2 = 0;
   1aabe:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   1aac2:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   1aac6:	f7f2 fb4f 	bl	d168 <HAL_I2C_Init>
   1aaca:	b9b8      	cbnz	r0, 1aafc <MX_I2C4_Init+0x68>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
   1aacc:	f24b 30ac 	movw	r0, #45996	; 0xb3ac
   1aad0:	2100      	movs	r1, #0
   1aad2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1aad6:	f7f4 f80f 	bl	eaf8 <HAL_I2CEx_ConfigAnalogFilter>
   1aada:	b960      	cbnz	r0, 1aaf6 <MX_I2C4_Init+0x62>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
   1aadc:	f24b 30ac 	movw	r0, #45996	; 0xb3ac
   1aae0:	2100      	movs	r1, #0
   1aae2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1aae6:	f7f4 f867 	bl	ebb8 <HAL_I2CEx_ConfigDigitalFilter>
   1aaea:	b900      	cbnz	r0, 1aaee <MX_I2C4_Init+0x5a>
  {
    Error_Handler();
  }

}
   1aaec:	bd38      	pop	{r3, r4, r5, pc}
   1aaee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
   1aaf2:	f000 badb 	b.w	1b0ac <Error_Handler>
    Error_Handler();
   1aaf6:	f000 fad9 	bl	1b0ac <Error_Handler>
   1aafa:	e7ef      	b.n	1aadc <MX_I2C4_Init+0x48>
    Error_Handler();
   1aafc:	f000 fad6 	bl	1b0ac <Error_Handler>
   1ab00:	e7e4      	b.n	1aacc <MX_I2C4_Init+0x38>
   1ab02:	bf00      	nop

0001ab04 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance==I2C2)
   1ab04:	f44f 43b0 	mov.w	r3, #22528	; 0x5800
{
   1ab08:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(i2cHandle->Instance==I2C2)
   1ab0a:	f2c4 0300 	movt	r3, #16384	; 0x4000
   1ab0e:	6802      	ldr	r2, [r0, #0]
{
   1ab10:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1ab12:	2400      	movs	r4, #0
  if(i2cHandle->Instance==I2C2)
   1ab14:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1ab16:	9409      	str	r4, [sp, #36]	; 0x24
   1ab18:	e9cd 4405 	strd	r4, r4, [sp, #20]
   1ab1c:	e9cd 4407 	strd	r4, r4, [sp, #28]
  if(i2cHandle->Instance==I2C2)
   1ab20:	d07f      	beq.n	1ac22 <HAL_I2C_MspInit+0x11e>
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
   1ab22:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
   1ab26:	f6c5 0300 	movt	r3, #22528	; 0x5800
   1ab2a:	429a      	cmp	r2, r3
   1ab2c:	d001      	beq.n	1ab32 <HAL_I2C_MspInit+0x2e>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
  }
}
   1ab2e:	b00b      	add	sp, #44	; 0x2c
   1ab30:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab32:	f44f 4788 	mov.w	r7, #17408	; 0x4400
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
   1ab36:	f44f 5640 	mov.w	r6, #12288	; 0x3000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1ab3a:	2212      	movs	r2, #18
   1ab3c:	4605      	mov	r5, r0
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab3e:	f6c5 0702 	movt	r7, #22530	; 0x5802
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1ab42:	f44f 6040 	mov.w	r0, #3072	; 0xc00
   1ab46:	a905      	add	r1, sp, #20
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab48:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1ab4c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab50:	f043 0308 	orr.w	r3, r3, #8
   1ab54:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   1ab58:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
   1ab5c:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   1ab5e:	2601      	movs	r6, #1
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab60:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1ab64:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
   1ab66:	2204      	movs	r2, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   1ab68:	9608      	str	r6, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab6a:	9303      	str	r3, [sp, #12]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   1ab6c:	f24b 4644 	movw	r6, #46148	; 0xb444
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1ab70:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
   1ab72:	9209      	str	r2, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1ab74:	f7f1 fd10 	bl	c598 <HAL_GPIO_Init>
    __HAL_RCC_I2C4_CLK_ENABLE();
   1ab78:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   1ab7c:	f245 4208 	movw	r2, #21512	; 0x5408
   1ab80:	f2c0 260f 	movt	r6, #527	; 0x20f
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
   1ab84:	f04f 0c0d 	mov.w	ip, #13
    __HAL_RCC_I2C4_CLK_ENABLE();
   1ab88:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   1ab8c:	f6c5 0202 	movt	r2, #22530	; 0x5802
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
   1ab90:	f44f 6180 	mov.w	r1, #1024	; 0x400
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
   1ab94:	4630      	mov	r0, r6
    __HAL_RCC_I2C4_CLK_ENABLE();
   1ab96:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
   1ab9a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   1ab9e:	60b4      	str	r4, [r6, #8]
    __HAL_RCC_I2C4_CLK_ENABLE();
   1aba0:	f003 0380 	and.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   1aba4:	60f4      	str	r4, [r6, #12]
    hdma_i2c4_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
   1aba6:	6174      	str	r4, [r6, #20]
    __HAL_RCC_I2C4_CLK_ENABLE();
   1aba8:	9304      	str	r3, [sp, #16]
   1abaa:	9b04      	ldr	r3, [sp, #16]
    hdma_i2c4_rx.Init.Priority = DMA_PRIORITY_LOW;
   1abac:	6234      	str	r4, [r6, #32]
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
   1abae:	6131      	str	r1, [r6, #16]
    hdma_i2c4_rx.Init.Mode = DMA_NORMAL;
   1abb0:	e9c6 4406 	strd	r4, r4, [r6, #24]
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
   1abb4:	e9c6 2c00 	strd	r2, ip, [r6]
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
   1abb8:	f7ef fa84 	bl	a0c4 <HAL_DMA_Init>
   1abbc:	2800      	cmp	r0, #0
   1abbe:	d15f      	bne.n	1ac80 <HAL_I2C_MspInit+0x17c>
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   1abc0:	f24b 3434 	movw	r4, #45876	; 0xb334
   1abc4:	f245 431c 	movw	r3, #21532	; 0x541c
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
   1abc8:	200e      	movs	r0, #14
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1abca:	2140      	movs	r1, #64	; 0x40
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   1abcc:	f2c0 240f 	movt	r4, #527	; 0x20f
   1abd0:	f6c5 0302 	movt	r3, #22530	; 0x5802
    hdma_i2c4_tx.Init.MemInc = DMA_MINC_ENABLE;
   1abd4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
   1abd8:	63ee      	str	r6, [r5, #60]	; 0x3c
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   1abda:	6023      	str	r3, [r4, #0]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   1abdc:	2300      	movs	r3, #0
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
   1abde:	6060      	str	r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
   1abe0:	4620      	mov	r0, r4
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
   1abe2:	63b5      	str	r5, [r6, #56]	; 0x38
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1abe4:	60a1      	str	r1, [r4, #8]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   1abe6:	e9c4 3203 	strd	r3, r2, [r4, #12]
    hdma_i2c4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   1abea:	e9c4 3305 	strd	r3, r3, [r4, #20]
    hdma_i2c4_tx.Init.Priority = DMA_PRIORITY_LOW;
   1abee:	e9c4 3307 	strd	r3, r3, [r4, #28]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
   1abf2:	f7ef fa67 	bl	a0c4 <HAL_DMA_Init>
   1abf6:	2800      	cmp	r0, #0
   1abf8:	d13f      	bne.n	1ac7a <HAL_I2C_MspInit+0x176>
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
   1abfa:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
   1abfc:	2200      	movs	r2, #0
   1abfe:	2107      	movs	r1, #7
   1ac00:	205f      	movs	r0, #95	; 0x5f
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
   1ac02:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
   1ac04:	f7ef f83a 	bl	9c7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_EV_IRQn);
   1ac08:	205f      	movs	r0, #95	; 0x5f
   1ac0a:	f7ef f887 	bl	9d1c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C4_ER_IRQn, 7, 0);
   1ac0e:	2200      	movs	r2, #0
   1ac10:	2107      	movs	r1, #7
   1ac12:	2060      	movs	r0, #96	; 0x60
   1ac14:	f7ef f832 	bl	9c7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
   1ac18:	2060      	movs	r0, #96	; 0x60
   1ac1a:	f7ef f87f 	bl	9d1c <HAL_NVIC_EnableIRQ>
}
   1ac1e:	b00b      	add	sp, #44	; 0x2c
   1ac20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1ac22:	f44f 4488 	mov.w	r4, #17408	; 0x4400
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1ac26:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
   1ac2a:	2204      	movs	r2, #4
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   1ac2c:	f44f 6640 	mov.w	r6, #3072	; 0xc00
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1ac30:	f6c5 0402 	movt	r4, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1ac34:	2512      	movs	r5, #18
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1ac36:	a905      	add	r1, sp, #20
   1ac38:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1ac3c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
   1ac40:	f043 0302 	orr.w	r3, r3, #2
   1ac44:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
   1ac48:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   1ac4c:	9605      	str	r6, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1ac4e:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1ac52:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
   1ac54:	9209      	str	r2, [sp, #36]	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1ac56:	9301      	str	r3, [sp, #4]
   1ac58:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1ac5a:	f7f1 fc9d 	bl	c598 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
   1ac5e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   1ac62:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   1ac66:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
   1ac6a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   1ac6e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1ac72:	9302      	str	r3, [sp, #8]
   1ac74:	9b02      	ldr	r3, [sp, #8]
}
   1ac76:	b00b      	add	sp, #44	; 0x2c
   1ac78:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
   1ac7a:	f000 fa17 	bl	1b0ac <Error_Handler>
   1ac7e:	e7bc      	b.n	1abfa <HAL_I2C_MspInit+0xf6>
      Error_Handler();
   1ac80:	f000 fa14 	bl	1b0ac <Error_Handler>
   1ac84:	e79c      	b.n	1abc0 <HAL_I2C_MspInit+0xbc>
   1ac86:	bf00      	nop

0001ac88 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C2)
   1ac88:	f44f 43b0 	mov.w	r3, #22528	; 0x5800
   1ac8c:	6802      	ldr	r2, [r0, #0]
   1ac8e:	f2c4 0300 	movt	r3, #16384	; 0x4000
   1ac92:	429a      	cmp	r2, r3
   1ac94:	d028      	beq.n	1ace8 <HAL_I2C_MspDeInit+0x60>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
   1ac96:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
   1ac9a:	f6c5 0300 	movt	r3, #22528	; 0x5800
   1ac9e:	429a      	cmp	r2, r3
   1aca0:	d000      	beq.n	1aca4 <HAL_I2C_MspDeInit+0x1c>
   1aca2:	4770      	bx	lr
  {
  /* USER CODE BEGIN I2C4_MspDeInit 0 */

  /* USER CODE END I2C4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C4_CLK_DISABLE();
   1aca4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  
    /**I2C4 GPIO Configuration    
    PD12     ------> I2C4_SCL
    PD13     ------> I2C4_SDA 
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   1aca8:	f44f 5140 	mov.w	r1, #12288	; 0x3000
    __HAL_RCC_I2C4_CLK_DISABLE();
   1acac:	f6c5 0302 	movt	r3, #22530	; 0x5802
{
   1acb0:	b510      	push	{r4, lr}
    __HAL_RCC_I2C4_CLK_DISABLE();
   1acb2:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
   1acb6:	4604      	mov	r4, r0
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   1acb8:	f44f 6040 	mov.w	r0, #3072	; 0xc00
    __HAL_RCC_I2C4_CLK_DISABLE();
   1acbc:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   1acc0:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_I2C4_CLK_DISABLE();
   1acc4:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   1acc8:	f7f1 feb0 	bl	ca2c <HAL_GPIO_DeInit>

    /* I2C4 DMA DeInit */
    HAL_DMA_DeInit(i2cHandle->hdmarx);
   1accc:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1acce:	f7ef fee7 	bl	aaa0 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(i2cHandle->hdmatx);
   1acd2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   1acd4:	f7ef fee4 	bl	aaa0 <HAL_DMA_DeInit>

    /* I2C4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C4_EV_IRQn);
   1acd8:	205f      	movs	r0, #95	; 0x5f
   1acda:	f7ef f835 	bl	9d48 <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
   1acde:	2060      	movs	r0, #96	; 0x60
  /* USER CODE BEGIN I2C4_MspDeInit 1 */

  /* USER CODE END I2C4_MspDeInit 1 */
  }
} 
   1ace0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
   1ace4:	f7ef b830 	b.w	9d48 <HAL_NVIC_DisableIRQ>
    __HAL_RCC_I2C2_CLK_DISABLE();
   1ace8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   1acec:	f44f 6080 	mov.w	r0, #1024	; 0x400
   1acf0:	f44f 6140 	mov.w	r1, #3072	; 0xc00
    __HAL_RCC_I2C2_CLK_DISABLE();
   1acf4:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   1acf8:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_I2C2_CLK_DISABLE();
   1acfc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   1ad00:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
   1ad04:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   1ad08:	f7f1 be90 	b.w	ca2c <HAL_GPIO_DeInit>

0001ad0c <SCB_EnableDCache>:
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
   1ad0c:	f44f 406d 	mov.w	r0, #60672	; 0xed00
   1ad10:	2300      	movs	r3, #0
   1ad12:	f2ce 0000 	movt	r0, #57344	; 0xe000
{
   1ad16:	b4f0      	push	{r4, r5, r6, r7}
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
   1ad18:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
   1ad1c:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
   1ad20:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1ad24:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
   1ad28:	f3c5 06c9 	ubfx	r6, r5, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
   1ad2c:	f3c5 354e 	ubfx	r5, r5, #13, #15
   1ad30:	07b7      	lsls	r7, r6, #30
   1ad32:	016d      	lsls	r5, r5, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1ad34:	ea05 040c 	and.w	r4, r5, ip
   1ad38:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
   1ad3a:	4632      	mov	r2, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1ad3c:	ea44 0301 	orr.w	r3, r4, r1
      } while (ways-- != 0U);
   1ad40:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1ad42:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
   1ad46:	f8c0 3260 	str.w	r3, [r0, #608]	; 0x260
      } while (ways-- != 0U);
   1ad4a:	1c53      	adds	r3, r2, #1
   1ad4c:	d1f6      	bne.n	1ad3c <SCB_EnableDCache+0x30>
   1ad4e:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
   1ad50:	f115 0f20 	cmn.w	r5, #32
   1ad54:	d1ee      	bne.n	1ad34 <SCB_EnableDCache+0x28>
   1ad56:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
   1ad5a:	6943      	ldr	r3, [r0, #20]
   1ad5c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1ad60:	6143      	str	r3, [r0, #20]
   1ad62:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1ad66:	f3bf 8f6f 	isb	sy
}
   1ad6a:	bcf0      	pop	{r4, r5, r6, r7}
   1ad6c:	4770      	bx	lr
   1ad6e:	bf00      	nop

0001ad70 <SystemClock_Config>:
{
   1ad70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ad74:	b0cc      	sub	sp, #304	; 0x130
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
   1ad76:	224c      	movs	r2, #76	; 0x4c
   1ad78:	2100      	movs	r1, #0
   1ad7a:	a80a      	add	r0, sp, #40	; 0x28
   1ad7c:	f015 fa19 	bl	301b2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
   1ad80:	2220      	movs	r2, #32
   1ad82:	2100      	movs	r1, #0
   1ad84:	a802      	add	r0, sp, #8
   1ad86:	f015 fa14 	bl	301b2 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
   1ad8a:	22bc      	movs	r2, #188	; 0xbc
   1ad8c:	2100      	movs	r1, #0
   1ad8e:	a81d      	add	r0, sp, #116	; 0x74
   1ad90:	f015 fa0f 	bl	301b2 <memset>
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
   1ad94:	2002      	movs	r0, #2
   1ad96:	f7f3 ff6d 	bl	ec74 <HAL_PWREx_ConfigSupply>
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   1ad9a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
   1ad9e:	2100      	movs	r1, #0
   1ada0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1ada4:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1ada8:	9101      	str	r1, [sp, #4]
   1adaa:	f6c5 0200 	movt	r2, #22528	; 0x5800
   1adae:	6999      	ldr	r1, [r3, #24]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   1adb0:	4618      	mov	r0, r3
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   1adb2:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
   1adb6:	6199      	str	r1, [r3, #24]
   1adb8:	699b      	ldr	r3, [r3, #24]
   1adba:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
   1adbe:	9301      	str	r3, [sp, #4]
   1adc0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1adc2:	f043 0301 	orr.w	r3, r3, #1
   1adc6:	62d3      	str	r3, [r2, #44]	; 0x2c
   1adc8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1adca:	f003 0301 	and.w	r3, r3, #1
   1adce:	9301      	str	r3, [sp, #4]
   1add0:	9b01      	ldr	r3, [sp, #4]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   1add2:	6983      	ldr	r3, [r0, #24]
   1add4:	049b      	lsls	r3, r3, #18
   1add6:	d5fc      	bpl.n	1add2 <SystemClock_Config+0x62>
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   1add8:	f44f 4288 	mov.w	r2, #17408	; 0x4400
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   1addc:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   1adde:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
   1ade2:	f04f 0c21 	mov.w	ip, #33	; 0x21
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   1ade6:	f6c5 0202 	movt	r2, #22530	; 0x5802
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
   1adea:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLM = 10;
   1adec:	210a      	movs	r1, #10
  RCC_OscInitStruct.PLL.PLLN = 384;
   1adee:	f44f 76c0 	mov.w	r6, #384	; 0x180
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   1adf2:	6a93      	ldr	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLQ = 3;
   1adf4:	2703      	movs	r7, #3
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
   1adf6:	f04f 0804 	mov.w	r8, #4
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   1adfa:	f023 0303 	bic.w	r3, r3, #3
   1adfe:	4323      	orrs	r3, r4
   1ae00:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   1ae02:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   1ae04:	900b      	str	r0, [sp, #44]	; 0x2c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   1ae06:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
   1ae08:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
   1ae0c:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = 2;
   1ae0e:	9417      	str	r4, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
   1ae10:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 3;
   1ae12:	9718      	str	r7, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
   1ae14:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   1ae16:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLN = 384;
   1ae1a:	e9cd 1615 	strd	r1, r6, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   1ae1e:	e9cd 831a 	strd	r8, r3, [sp, #104]	; 0x68
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   1ae22:	f7f3 ff6d 	bl	ed00 <HAL_RCC_OscConfig>
   1ae26:	b100      	cbz	r0, 1ae2a <SystemClock_Config+0xba>
   1ae28:	e7fe      	b.n	1ae28 <SystemClock_Config+0xb8>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   1ae2a:	223f      	movs	r2, #63	; 0x3f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   1ae2c:	9703      	str	r7, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   1ae2e:	2708      	movs	r7, #8
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
   1ae30:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   1ae32:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
   1ae34:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
   1ae38:	9004      	str	r0, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
   1ae3a:	4641      	mov	r1, r8
   1ae3c:	eb0d 0007 	add.w	r0, sp, r7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   1ae40:	9705      	str	r7, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
   1ae42:	e9cd 3306 	strd	r3, r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
   1ae46:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
   1ae4a:	f7f4 fc13 	bl	f674 <HAL_RCC_ClockConfig>
   1ae4e:	4603      	mov	r3, r0
   1ae50:	b100      	cbz	r0, 1ae54 <SystemClock_Config+0xe4>
   1ae52:	e7fe      	b.n	1ae52 <SystemClock_Config+0xe2>
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
   1ae54:	f44f 718c 	mov.w	r1, #280	; 0x118
  PeriphClkInitStruct.PLL2.PLL2M = 25;
   1ae58:	2219      	movs	r2, #25
  PeriphClkInitStruct.PLL2.PLL2N = 344;
   1ae5a:	f44f 7eac 	mov.w	lr, #344	; 0x158
  PeriphClkInitStruct.PLL3.PLL3N = 384;
   1ae5e:	9627      	str	r6, [sp, #156]	; 0x9c
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
   1ae60:	f2c0 110f 	movt	r1, #271	; 0x10f
  PeriphClkInitStruct.PLL2.PLL2P = 7;
   1ae64:	f04f 0c07 	mov.w	ip, #7
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
   1ae68:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   1ae6c:	a81d      	add	r0, sp, #116	; 0x74
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
   1ae6e:	9421      	str	r4, [sp, #132]	; 0x84
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
   1ae70:	932e      	str	r3, [sp, #184]	; 0xb8
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
   1ae72:	9330      	str	r3, [sp, #192]	; 0xc0
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
   1ae74:	9532      	str	r5, [sp, #200]	; 0xc8
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
   1ae76:	9342      	str	r3, [sp, #264]	; 0x108
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
   1ae78:	9345      	str	r3, [sp, #276]	; 0x114
  PeriphClkInitStruct.PLL3.PLL3M = 25;
   1ae7a:	9226      	str	r2, [sp, #152]	; 0x98
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
   1ae7c:	963e      	str	r6, [sp, #248]	; 0xf8
  PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_0;
   1ae7e:	e9cd 5322 	strd	r5, r3, [sp, #136]	; 0x88
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
   1ae82:	e9cd 3324 	strd	r3, r3, [sp, #144]	; 0x90
  PeriphClkInitStruct.PLL3.PLL3Q = 8;
   1ae86:	e9cd 4728 	strd	r4, r7, [sp, #160]	; 0xa0
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
   1ae8a:	e9cd 432a 	strd	r4, r3, [sp, #168]	; 0xa8
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
   1ae8e:	e9cd 332c 	strd	r3, r3, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
   1ae92:	e9cd 333c 	strd	r3, r3, [sp, #240]	; 0xf0
  PeriphClkInitStruct.PLL2.PLL2M = 25;
   1ae96:	e9cd 121d 	strd	r1, r2, [sp, #116]	; 0x74
  PeriphClkInitStruct.PLL2.PLL2P = 7;
   1ae9a:	e9cd ec1f 	strd	lr, ip, [sp, #124]	; 0x7c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   1ae9e:	f7f5 f943 	bl	10128 <HAL_RCCEx_PeriphCLKConfig>
   1aea2:	b100      	cbz	r0, 1aea6 <SystemClock_Config+0x136>
   1aea4:	e7fe      	b.n	1aea4 <SystemClock_Config+0x134>
  HAL_PWREx_EnableUSBVoltageDetector();
   1aea6:	f7f3 ff17 	bl	ecd8 <HAL_PWREx_EnableUSBVoltageDetector>
}
   1aeaa:	b04c      	add	sp, #304	; 0x130
   1aeac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001aeb0 <HAL_ADC_ConvCpltCallback>:
}
   1aeb0:	4770      	bx	lr
   1aeb2:	bf00      	nop

0001aeb4 <HAL_ADC_ConvHalfCpltCallback>:
   1aeb4:	4770      	bx	lr
   1aeb6:	bf00      	nop

0001aeb8 <SDRAM_Initialization_sequence>:
{
   1aeb8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1aebc:	f24b 3400 	movw	r4, #45824	; 0xb300
{
   1aec0:	b087      	sub	sp, #28
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
   1aec2:	2501      	movs	r5, #1
    __IO uint32_t tmpmrd = 0;
   1aec4:	2600      	movs	r6, #0
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1aec6:	f2c0 240f 	movt	r4, #527	; 0x20f
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1aeca:	2710      	movs	r7, #16
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1aecc:	a902      	add	r1, sp, #8
   1aece:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1aed2:	4620      	mov	r0, r4
    Command.AutoRefreshNumber = 8;
   1aed4:	f04f 0808 	mov.w	r8, #8
    __IO uint32_t tmpmrd = 0;
   1aed8:	9601      	str	r6, [sp, #4]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   1aeda:	f04f 0903 	mov.w	r9, #3
    Command.ModeRegisterDefinition = 0;
   1aede:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
   1aee0:	9502      	str	r5, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1aee2:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1aee6:	f7f8 fa17 	bl	13318 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
   1aeea:	4628      	mov	r0, r5
   1aeec:	f7ed faae 	bl	844c <HAL_Delay>
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
   1aef0:	2302      	movs	r3, #2
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1aef2:	eb0d 0108 	add.w	r1, sp, r8
   1aef6:	4620      	mov	r0, r4
   1aef8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
   1aefc:	9302      	str	r3, [sp, #8]
    Command.ModeRegisterDefinition = 0;
   1aefe:	9605      	str	r6, [sp, #20]
    Command.AutoRefreshNumber = 1;
   1af00:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af04:	f7f8 fa08 	bl	13318 <HAL_SDRAM_SendCommand>
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
   1af08:	f240 2222 	movw	r2, #546	; 0x222
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
   1af0c:	2304      	movs	r3, #4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af0e:	eb0d 0108 	add.w	r1, sp, r8
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
   1af12:	9201      	str	r2, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af14:	4620      	mov	r0, r4
    Command.ModeRegisterDefinition = tmpmrd;
   1af16:	f8dd c004 	ldr.w	ip, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
   1af1e:	9302      	str	r3, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1af20:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = tmpmrd;
   1af22:	e9cd 5c04 	strd	r5, ip, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af26:	f7f8 f9f7 	bl	13318 <HAL_SDRAM_SendCommand>
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af2a:	eb0d 0108 	add.w	r1, sp, r8
   1af2e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1af32:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1af34:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = 0;
   1af36:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   1af38:	f8cd 9008 	str.w	r9, [sp, #8]
    Command.AutoRefreshNumber = 8;
   1af3c:	f8cd 8010 	str.w	r8, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af40:	f7f8 f9ea 	bl	13318 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
   1af44:	4628      	mov	r0, r5
   1af46:	f7ed fa81 	bl	844c <HAL_Delay>
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af4a:	eb0d 0108 	add.w	r1, sp, r8
   1af4e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1af52:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1af54:	e9cd 9702 	strd	r9, r7, [sp, #8]
    Command.ModeRegisterDefinition = 0;
   1af58:	e9cd 8604 	strd	r8, r6, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1af5c:	f7f8 f9dc 	bl	13318 <HAL_SDRAM_SendCommand>
    HAL_SDRAM_ProgramRefreshRate(&hsdram1, SDRAM_REFRESH_COUNT);
   1af60:	f240 5169 	movw	r1, #1385	; 0x569
   1af64:	4620      	mov	r0, r4
   1af66:	f7f8 f9f9 	bl	1335c <HAL_SDRAM_ProgramRefreshRate>
}
   1af6a:	b007      	add	sp, #28
   1af6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0001af70 <randomNumber>:
float randomNumber(void) {
   1af70:	b500      	push	{lr}
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
   1af72:	f64b 10fc 	movw	r0, #47612	; 0xb9fc
float randomNumber(void) {
   1af76:	b083      	sub	sp, #12
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
   1af78:	f2c0 200f 	movt	r0, #527	; 0x20f
   1af7c:	a901      	add	r1, sp, #4
   1af7e:	f7f6 fb5f 	bl	11640 <HAL_RNG_GenerateRandomNumber>
	float num = (float)rand * INV_TWO_TO_32;
   1af82:	230d      	movs	r3, #13
   1af84:	eddd 7a01 	vldr	s15, [sp, #4]
   1af88:	f6c2 7380 	movt	r3, #12160	; 0x2f80
   1af8c:	eeb8 0a67 	vcvt.f32.u32	s0, s15
   1af90:	ee07 3a90 	vmov	s15, r3
}
   1af94:	ee20 0a27 	vmul.f32	s0, s0, s15
   1af98:	b003      	add	sp, #12
   1af9a:	f85d fb04 	ldr.w	pc, [sp], #4
   1af9e:	bf00      	nop

0001afa0 <MPU_Conf>:
{
   1afa0:	b510      	push	{r4, lr}
   1afa2:	b084      	sub	sp, #16
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   1afa4:	2400      	movs	r4, #0
	HAL_MPU_Disable();
   1afa6:	f7ee ff05 	bl	9db4 <HAL_MPU_Disable>
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   1afaa:	2311      	movs	r3, #17
  MPU_InitStruct.BaseAddress = 0x30000000;
   1afac:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   1afb0:	f240 1201 	movw	r2, #257	; 0x101
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   1afb4:	f2c0 3301 	movt	r3, #769	; 0x301
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   1afb8:	4668      	mov	r0, sp
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   1afba:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   1afbe:	9403      	str	r4, [sp, #12]
  MPU_InitStruct.BaseAddress = 0x30000000;
   1afc0:	e9cd 1301 	strd	r1, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   1afc4:	f7ee ff1c 	bl	9e00 <HAL_MPU_ConfigRegion>
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   1afc8:	230f      	movs	r3, #15
  MPU_InitStruct.BaseAddress = 0x38000000;
   1afca:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   1afce:	f240 2201 	movw	r2, #513	; 0x201
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   1afd2:	f2c0 3301 	movt	r3, #769	; 0x301
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   1afd6:	4668      	mov	r0, sp
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   1afd8:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   1afdc:	9403      	str	r4, [sp, #12]
   1afde:	e9cd 1301 	strd	r1, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   1afe2:	f7ee ff0d 	bl	9e00 <HAL_MPU_ConfigRegion>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
   1afe6:	2004      	movs	r0, #4
   1afe8:	f7ee fef6 	bl	9dd8 <HAL_MPU_Enable>
}
   1afec:	b004      	add	sp, #16
   1afee:	bd10      	pop	{r4, pc}

0001aff0 <LEAF_error>:
{
   1aff0:	b508      	push	{r3, lr}
	setLED_C(1);
   1aff2:	2001      	movs	r0, #1
   1aff4:	f000 f8be 	bl	1b174 <setLED_C>
   1aff8:	e7fe      	b.n	1aff8 <LEAF_error+0x8>
   1affa:	bf00      	nop

0001affc <CycleCounterTrackMinAndMax>:



//this keeps min and max, but doesn't do the array for averaging - a bit less expensive
void CycleCounterTrackMinAndMax( uint8_t whichCount)
{
   1affc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if ((cycleCountVals[whichCount][2] == 0) && (cycleCountVals[whichCount][1] > 0)) //the [2] spot in the array will be set to 1 if an interrupt happened during the cycle count -- need to set that in any higher-priority interrupts to make that true
   1b000:	f64b 04f8 	movw	r4, #47352	; 0xb8f8
   1b004:	0046      	lsls	r6, r0, #1
   1b006:	f2c0 240f 	movt	r4, #527	; 0x20f
   1b00a:	1833      	adds	r3, r6, r0
   1b00c:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
{
   1b010:	ed2d 8b02 	vpush	{d8}
	if ((cycleCountVals[whichCount][2] == 0) && (cycleCountVals[whichCount][1] > 0)) //the [2] spot in the array will be set to 1 if an interrupt happened during the cycle count -- need to set that in any higher-priority interrupts to make that true
   1b014:	e9d2 8904 	ldrd	r8, r9, [r2, #16]
   1b018:	ea58 0109 	orrs.w	r1, r8, r9
   1b01c:	d141      	bne.n	1b0a2 <CycleCounterTrackMinAndMax+0xa6>
   1b01e:	e9d2 8902 	ldrd	r8, r9, [r2, #8]
   1b022:	f1b8 0f01 	cmp.w	r8, #1
   1b026:	f179 0100 	sbcs.w	r1, r9, #0
   1b02a:	db3a      	blt.n	1b0a2 <CycleCounterTrackMinAndMax+0xa6>
	{
		if ((cycleCountVals[whichCount][1] < cycleCountAverages[whichCount][1]) || (cycleCountAverages[whichCount][1] == 0))
   1b02c:	f64b 07c8 	movw	r7, #47304	; 0xb8c8
   1b030:	4605      	mov	r5, r0
   1b032:	f2c0 270f 	movt	r7, #527	; 0x20f
   1b036:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   1b03a:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
   1b03e:	ed93 8a01 	vldr	s16, [r3, #4]
   1b042:	f018 f925 	bl	33290 <__aeabi_l2f>
   1b046:	ee07 0a90 	vmov	s15, r0
   1b04a:	eef4 7ac8 	vcmpe.f32	s15, s16
   1b04e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b052:	d404      	bmi.n	1b05e <CycleCounterTrackMinAndMax+0x62>
   1b054:	eeb5 8a40 	vcmp.f32	s16, #0.0
   1b058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b05c:	d10a      	bne.n	1b074 <CycleCounterTrackMinAndMax+0x78>
		{
			cycleCountAverages[whichCount][1] = cycleCountVals[whichCount][1];
   1b05e:	1973      	adds	r3, r6, r5
   1b060:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   1b064:	eb07 0883 	add.w	r8, r7, r3, lsl #2
   1b068:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
   1b06c:	f018 f910 	bl	33290 <__aeabi_l2f>
   1b070:	f8c8 0004 	str.w	r0, [r8, #4]
		}
		//update max value ([2])
		if (cycleCountVals[whichCount][1] > cycleCountAverages[whichCount][2])
   1b074:	1970      	adds	r0, r6, r5
   1b076:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
   1b07a:	eb07 0780 	add.w	r7, r7, r0, lsl #2
   1b07e:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
   1b082:	f018 f905 	bl	33290 <__aeabi_l2f>
   1b086:	edd7 7a02 	vldr	s15, [r7, #8]
   1b08a:	ee07 0a10 	vmov	s14, r0
   1b08e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1b092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b096:	dd04      	ble.n	1b0a2 <CycleCounterTrackMinAndMax+0xa6>
		{
			cycleCountAverages[whichCount][2] = cycleCountVals[whichCount][1];
   1b098:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
   1b09c:	f018 f8f8 	bl	33290 <__aeabi_l2f>
   1b0a0:	60b8      	str	r0, [r7, #8]
		}
	}
}
   1b0a2:	ecbd 8b02 	vpop	{d8}
   1b0a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1b0aa:	bf00      	nop

0001b0ac <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
   1b0ac:	e7fe      	b.n	1b0ac <Error_Handler>
   1b0ae:	bf00      	nop

0001b0b0 <assert_failed>:
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
   1b0b0:	4770      	bx	lr
   1b0b2:	bf00      	nop

0001b0b4 <setLED_Edit>:
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
}

void setLED_Edit(uint8_t onOff)
{
	if (onOff)
   1b0b4:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
   1b0b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
	if (onOff)
   1b0ba:	b922      	cbnz	r2, 1b0c6 <setLED_Edit+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);
   1b0bc:	2180      	movs	r1, #128	; 0x80
   1b0be:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b0c2:	f7f1 be13 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
   1b0c6:	2201      	movs	r2, #1
   1b0c8:	2180      	movs	r1, #128	; 0x80
   1b0ca:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b0ce:	f7f1 be0d 	b.w	ccec <HAL_GPIO_WritePin>
   1b0d2:	bf00      	nop

0001b0d4 <setLED_USB>:
}


void setLED_USB(uint8_t onOff)
{
	if (onOff)
   1b0d4:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
   1b0d6:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	if (onOff)
   1b0da:	b922      	cbnz	r2, 1b0e6 <setLED_USB+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
   1b0dc:	2140      	movs	r1, #64	; 0x40
   1b0de:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b0e2:	f7f1 be03 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
   1b0e6:	2201      	movs	r2, #1
   1b0e8:	2140      	movs	r1, #64	; 0x40
   1b0ea:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b0ee:	f7f1 bdfd 	b.w	ccec <HAL_GPIO_WritePin>
   1b0f2:	bf00      	nop

0001b0f4 <setLED_1>:
}


void setLED_1(uint8_t onOff)
{
	if (onOff)
   1b0f4:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
   1b0f6:	2000      	movs	r0, #0
	if (onOff)
   1b0f8:	b92a      	cbnz	r2, 1b106 <setLED_1+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
   1b0fa:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1b0fe:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b102:	f7f1 bdf3 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
   1b106:	2201      	movs	r2, #1
   1b108:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1b10c:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b110:	f7f1 bdec 	b.w	ccec <HAL_GPIO_WritePin>

0001b114 <setLED_2>:
	}
}

void setLED_2(uint8_t onOff)
{
	if (onOff)
   1b114:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
   1b116:	2000      	movs	r0, #0
	if (onOff)
   1b118:	b92a      	cbnz	r2, 1b126 <setLED_2+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
   1b11a:	f44f 7180 	mov.w	r1, #256	; 0x100
   1b11e:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b122:	f7f1 bde3 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
   1b126:	2201      	movs	r2, #1
   1b128:	f44f 7180 	mov.w	r1, #256	; 0x100
   1b12c:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b130:	f7f1 bddc 	b.w	ccec <HAL_GPIO_WritePin>

0001b134 <setLED_A>:
}


void setLED_A(uint8_t onOff)
{
	if (onOff)
   1b134:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
   1b136:	f44f 6000 	mov.w	r0, #2048	; 0x800
	if (onOff)
   1b13a:	b922      	cbnz	r2, 1b146 <setLED_A+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET);
   1b13c:	2140      	movs	r1, #64	; 0x40
   1b13e:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b142:	f7f1 bdd3 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
   1b146:	2201      	movs	r2, #1
   1b148:	2140      	movs	r1, #64	; 0x40
   1b14a:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b14e:	f7f1 bdcd 	b.w	ccec <HAL_GPIO_WritePin>
   1b152:	bf00      	nop

0001b154 <setLED_B>:
	}
}

void setLED_B(uint8_t onOff)
{
	if (onOff)
   1b154:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
   1b156:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	if (onOff)
   1b15a:	b922      	cbnz	r2, 1b166 <setLED_B+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
   1b15c:	2180      	movs	r1, #128	; 0x80
   1b15e:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b162:	f7f1 bdc3 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
   1b166:	2201      	movs	r2, #1
   1b168:	2180      	movs	r1, #128	; 0x80
   1b16a:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b16e:	f7f1 bdbd 	b.w	ccec <HAL_GPIO_WritePin>
   1b172:	bf00      	nop

0001b174 <setLED_C>:
	}
}

void setLED_C(uint8_t onOff)
{
	if (onOff)
   1b174:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
   1b176:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	if (onOff)
   1b17a:	b92a      	cbnz	r2, 1b188 <setLED_C+0x14>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET);
   1b17c:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1b180:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b184:	f7f1 bdb2 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
   1b188:	2201      	movs	r2, #1
   1b18a:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1b18e:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b192:	f7f1 bdab 	b.w	ccec <HAL_GPIO_WritePin>
   1b196:	bf00      	nop

0001b198 <setLED_leftout_clip>:
	}
}

void setLED_leftout_clip(uint8_t onOff)
{
	if (onOff)
   1b198:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
   1b19a:	2000      	movs	r0, #0
	if (onOff)
   1b19c:	b922      	cbnz	r2, 1b1a8 <setLED_leftout_clip+0x10>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
   1b19e:	2110      	movs	r1, #16
   1b1a0:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1a4:	f7f1 bda2 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
   1b1a8:	2201      	movs	r2, #1
   1b1aa:	2110      	movs	r1, #16
   1b1ac:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1b0:	f7f1 bd9c 	b.w	ccec <HAL_GPIO_WritePin>

0001b1b4 <setLED_rightout_clip>:
	}
}

void setLED_rightout_clip(uint8_t onOff)
{
	if (onOff)
   1b1b4:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
   1b1b6:	2000      	movs	r0, #0
	if (onOff)
   1b1b8:	b922      	cbnz	r2, 1b1c4 <setLED_rightout_clip+0x10>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
   1b1ba:	2140      	movs	r1, #64	; 0x40
   1b1bc:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1c0:	f7f1 bd94 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
   1b1c4:	2201      	movs	r2, #1
   1b1c6:	2140      	movs	r1, #64	; 0x40
   1b1c8:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1cc:	f7f1 bd8e 	b.w	ccec <HAL_GPIO_WritePin>

0001b1d0 <setLED_leftin_clip>:
	}
}

void setLED_leftin_clip(uint8_t onOff)
{
	if (onOff)
   1b1d0:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
   1b1d2:	f44f 6000 	mov.w	r0, #2048	; 0x800
	if (onOff)
   1b1d6:	b922      	cbnz	r2, 1b1e2 <setLED_leftin_clip+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);
   1b1d8:	2110      	movs	r1, #16
   1b1da:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1de:	f7f1 bd85 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
   1b1e2:	2201      	movs	r2, #1
   1b1e4:	2110      	movs	r1, #16
   1b1e6:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1ea:	f7f1 bd7f 	b.w	ccec <HAL_GPIO_WritePin>
   1b1ee:	bf00      	nop

0001b1f0 <setLED_rightin_clip>:
	}
}

void setLED_rightin_clip(uint8_t onOff)
{
	if (onOff)
   1b1f0:	4602      	mov	r2, r0
   1b1f2:	b930      	cbnz	r0, 1b202 <setLED_rightin_clip+0x12>
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
   1b1f4:	f44f 6080 	mov.w	r0, #1024	; 0x400
   1b1f8:	2101      	movs	r1, #1
   1b1fa:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b1fe:	f7f1 bd75 	b.w	ccec <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
   1b202:	2201      	movs	r2, #1
   1b204:	f44f 6080 	mov.w	r0, #1024	; 0x400
   1b208:	4611      	mov	r1, r2
   1b20a:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1b20e:	f7f1 bd6d 	b.w	ccec <HAL_GPIO_WritePin>
   1b212:	bf00      	nop

0001b214 <OLED_writePreset>:
//	OLED_draw();
}

void OLED_writePreset()
{
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1b214:	f244 01d0 	movw	r1, #16592	; 0x40d0
   1b218:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
{
   1b21c:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1b21e:	f2c0 0103 	movt	r1, #3
{
   1b222:	b089      	sub	sp, #36	; 0x24
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1b224:	f2c0 200f 	movt	r0, #527	; 0x20f
	OLEDclear();
	char tempString[24];
	itoa((currentPreset+1), tempString, 10);
   1b228:	f646 17b9 	movw	r7, #27065	; 0x69b9
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1b22c:	f7ff f94a 	bl	1a4c4 <GFXsetFont>
}


void OLEDclear()
{
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1b230:	2600      	movs	r6, #0
   1b232:	2320      	movs	r3, #32
   1b234:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	itoa((currentPreset+1), tempString, 10);
   1b238:	f2c0 270e 	movt	r7, #526	; 0x20e
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1b23c:	4632      	mov	r2, r6
   1b23e:	4631      	mov	r1, r6
   1b240:	9300      	str	r3, [sp, #0]
   1b242:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b246:	2380      	movs	r3, #128	; 0x80
   1b248:	9601      	str	r6, [sp, #4]
	itoa((currentPreset+1), tempString, 10);
   1b24a:	ac02      	add	r4, sp, #8
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1b24c:	f7fe fcf6 	bl	19c3c <GFXfillRect>
	itoa((currentPreset+1), tempString, 10);
   1b250:	7838      	ldrb	r0, [r7, #0]
   1b252:	220a      	movs	r2, #10
   1b254:	4621      	mov	r1, r4
   1b256:	3001      	adds	r0, #1
   1b258:	f014 ff9e 	bl	30198 <itoa>
	strcat(tempString, ":");
   1b25c:	4620      	mov	r0, r4
   1b25e:	f014 ffb9 	bl	301d4 <strlen>
   1b262:	f244 7268 	movw	r2, #18280	; 0x4768
	strcat(tempString, modeNames[currentPreset]);
   1b266:	f64e 23a8 	movw	r3, #60072	; 0xeaa8
	strcat(tempString, ":");
   1b26a:	4605      	mov	r5, r0
   1b26c:	f2c0 0203 	movt	r2, #3
	strcat(tempString, modeNames[currentPreset]);
   1b270:	7839      	ldrb	r1, [r7, #0]
   1b272:	f2c0 230f 	movt	r3, #527	; 0x20f
	strcat(tempString, ":");
   1b276:	3001      	adds	r0, #1
   1b278:	8812      	ldrh	r2, [r2, #0]
	strcat(tempString, modeNames[currentPreset]);
   1b27a:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
   1b27e:	4420      	add	r0, r4
	strcat(tempString, ":");
   1b280:	5362      	strh	r2, [r4, r5]
	strcat(tempString, modeNames[currentPreset]);
   1b282:	f014 ff9e 	bl	301c2 <stpcpy>
	int myLength = strlen(tempString);
   1b286:	1b05      	subs	r5, r0, r4

void OLEDwriteString(char* myCharArray, uint8_t arrayLength, uint8_t startCursor, OLEDLine line)
{
	uint8_t cursorX = startCursor;
	uint8_t cursorY = 12 + (16 * (line%2));
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b288:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b28c:	4631      	mov	r1, r6

	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b28e:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b290:	220c      	movs	r2, #12
   1b292:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b296:	f7ff f903 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b29a:	f04f 0c10 	mov.w	ip, #16
   1b29e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b2a2:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b2a6:	9601      	str	r6, [sp, #4]
   1b2a8:	4632      	mov	r2, r6
   1b2aa:	009b      	lsls	r3, r3, #2
   1b2ac:	4631      	mov	r1, r6
   1b2ae:	f8cd c000 	str.w	ip, [sp]
   1b2b2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b2b6:	f7fe fcc1 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b2ba:	b15d      	cbz	r5, 1b2d4 <OLED_writePreset+0xc0>
	{
		GFXwrite(&theGFX, myCharArray[i]);
   1b2bc:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b2c0:	4425      	add	r5, r4
   1b2c2:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b2c6:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b2ca:	4630      	mov	r0, r6
   1b2cc:	f7ff f836 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b2d0:	42a5      	cmp	r5, r4
   1b2d2:	d1f8      	bne.n	1b2c6 <OLED_writePreset+0xb2>
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b2d4:	f643 311c 	movw	r1, #15132	; 0x3b1c
   1b2d8:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b2dc:	f2c0 0103 	movt	r1, #3
   1b2e0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b2e4:	f7ff f8ee 	bl	1a4c4 <GFXsetFont>
	OLEDwriteString(modeNamesDetails[currentPreset], strlen(modeNamesDetails[currentPreset]), 0, SecondLine);
   1b2e8:	f64e 4358 	movw	r3, #60504	; 0xec58
   1b2ec:	783a      	ldrb	r2, [r7, #0]
   1b2ee:	f2c0 230f 	movt	r3, #527	; 0x20f
   1b2f2:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
   1b2f6:	4620      	mov	r0, r4
   1b2f8:	f014 ff6c 	bl	301d4 <strlen>
   1b2fc:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b2fe:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b302:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b304:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b306:	2100      	movs	r1, #0
   1b308:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b30c:	f7ff f8c8 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b310:	2220      	movs	r2, #32
   1b312:	2100      	movs	r1, #0
   1b314:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b318:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b31c:	9200      	str	r2, [sp, #0]
   1b31e:	9101      	str	r1, [sp, #4]
   1b320:	009b      	lsls	r3, r3, #2
   1b322:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b326:	2210      	movs	r2, #16
   1b328:	f7fe fc88 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b32c:	b165      	cbz	r5, 1b348 <OLED_writePreset+0x134>
   1b32e:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
   1b330:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b334:	4425      	add	r5, r4
   1b336:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b33a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   1b33e:	4630      	mov	r0, r6
   1b340:	f7fe fffc 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b344:	42ac      	cmp	r4, r5
   1b346:	d1f8      	bne.n	1b33a <OLED_writePreset+0x126>
}
   1b348:	b009      	add	sp, #36	; 0x24
   1b34a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b34c <OLED_init>:
{
   1b34c:	b5f0      	push	{r4, r5, r6, r7, lr}
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   1b34e:	2278      	movs	r2, #120	; 0x78
{
   1b350:	b083      	sub	sp, #12
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   1b352:	2102      	movs	r1, #2
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   1b354:	f246 178d 	movw	r7, #24973	; 0x618d
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   1b358:	f009 f92e 	bl	245b8 <ssd1306_begin>
   1b35c:	f24e 70cc 	movw	r0, #59340	; 0xe7cc
   1b360:	f44f 7200 	mov.w	r2, #512	; 0x200
   1b364:	2100      	movs	r1, #0
   1b366:	f2c0 200f 	movt	r0, #527	; 0x20f
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   1b36a:	f246 2625 	movw	r6, #25125	; 0x6225
   1b36e:	f014 ff20 	bl	301b2 <memset>
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   1b372:	f246 25bd 	movw	r5, #25277	; 0x62bd
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   1b376:	f24f 33e0 	movw	r3, #62432	; 0xf3e0
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   1b37a:	f246 20c9 	movw	r0, #25289	; 0x62c9
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   1b37e:	f246 3135 	movw	r1, #25397	; 0x6335
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   1b382:	f246 3241 	movw	r2, #25409	; 0x6341
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   1b386:	f2c0 230f 	movt	r3, #527	; 0x20f
   1b38a:	f2c0 0702 	movt	r7, #2
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   1b38e:	f2c0 0602 	movt	r6, #2
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   1b392:	f2c0 0502 	movt	r5, #2
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   1b396:	f2c0 0002 	movt	r0, #2
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   1b39a:	f2c0 0102 	movt	r1, #2
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   1b39e:	f2c0 0202 	movt	r2, #2
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   1b3a2:	601f      	str	r7, [r3, #0]
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   1b3a4:	605e      	str	r6, [r3, #4]
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   1b3a6:	f246 4765 	movw	r7, #25701	; 0x6465
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   1b3aa:	609d      	str	r5, [r3, #8]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   1b3ac:	f246 5609 	movw	r6, #25865	; 0x6509
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   1b3b0:	60d8      	str	r0, [r3, #12]
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   1b3b2:	f246 55a9 	movw	r5, #26025	; 0x65a9
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   1b3b6:	6119      	str	r1, [r3, #16]
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   1b3b8:	f246 50ed 	movw	r0, #26093	; 0x65ed
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   1b3bc:	615a      	str	r2, [r3, #20]
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   1b3be:	f246 6131 	movw	r1, #26161	; 0x6631
	buttonActionFunctions[Delay] = UIDelayButtons;
   1b3c2:	f246 6275 	movw	r2, #26229	; 0x6675
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   1b3c6:	f2c0 0702 	movt	r7, #2
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   1b3ca:	f2c0 0602 	movt	r6, #2
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   1b3ce:	f2c0 0502 	movt	r5, #2
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   1b3d2:	f2c0 0002 	movt	r0, #2
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   1b3d6:	f2c0 0102 	movt	r1, #2
	buttonActionFunctions[Delay] = UIDelayButtons;
   1b3da:	f2c0 0202 	movt	r2, #2
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   1b3de:	619f      	str	r7, [r3, #24]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   1b3e0:	61de      	str	r6, [r3, #28]
	  GFXinit(&theGFX, 128, 32);
   1b3e2:	f64b 14d8 	movw	r4, #47576	; 0xb9d8
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   1b3e6:	621d      	str	r5, [r3, #32]
	buttonActionFunctions[Reverb] = UIReverbButtons;
   1b3e8:	f246 67e1 	movw	r7, #26337	; 0x66e1
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   1b3ec:	6258      	str	r0, [r3, #36]	; 0x24
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
   1b3ee:	f246 764d 	movw	r6, #26445	; 0x674d
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   1b3f2:	6299      	str	r1, [r3, #40]	; 0x28
	buttonActionFunctions[LivingString] = UILivingStringButtons;
   1b3f4:	f246 7591 	movw	r5, #26513	; 0x6791
	buttonActionFunctions[Delay] = UIDelayButtons;
   1b3f8:	62da      	str	r2, [r3, #44]	; 0x2c
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
   1b3fa:	f646 0029 	movw	r0, #26665	; 0x6829
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
   1b3fe:	f646 01c1 	movw	r1, #26817	; 0x68c1
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   1b402:	f646 1219 	movw	r2, #26905	; 0x6919
	  GFXinit(&theGFX, 128, 32);
   1b406:	f2c0 240f 	movt	r4, #527	; 0x20f
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
   1b40a:	f2c0 0002 	movt	r0, #2
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
   1b40e:	f2c0 0102 	movt	r1, #2
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   1b412:	f2c0 0202 	movt	r2, #2
	buttonActionFunctions[Reverb] = UIReverbButtons;
   1b416:	f2c0 0702 	movt	r7, #2
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
   1b41a:	f2c0 0602 	movt	r6, #2
	buttonActionFunctions[LivingString] = UILivingStringButtons;
   1b41e:	f2c0 0502 	movt	r5, #2
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   1b422:	645a      	str	r2, [r3, #68]	; 0x44
	buttonActionFunctions[Reverb] = UIReverbButtons;
   1b424:	631f      	str	r7, [r3, #48]	; 0x30
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
   1b426:	e9c3 010f 	strd	r0, r1, [r3, #60]	; 0x3c
	buttonActionFunctions[LivingString] = UILivingStringButtons;
   1b42a:	e9c3 650d 	strd	r6, r5, [r3, #52]	; 0x34
	  initModeNames();
   1b42e:	f009 fc3b 	bl	24ca8 <initModeNames>
	  GFXinit(&theGFX, 128, 32);
   1b432:	4620      	mov	r0, r4
   1b434:	2220      	movs	r2, #32
   1b436:	2180      	movs	r1, #128	; 0x80
   1b438:	f7fe fade 	bl	199f8 <GFXinit>
	  GFXsetFont(&theGFX, &EuphemiaCAS8pt7b); //this one is elegant but definitely not monospaced can fit 9 Ms
   1b43c:	f244 01d0 	movw	r1, #16592	; 0x40d0
   1b440:	4620      	mov	r0, r4
   1b442:	f2c0 0103 	movt	r1, #3
   1b446:	f7ff f83d 	bl	1a4c4 <GFXsetFont>
	  GFXsetTextColor(&theGFX, 1, 0);
   1b44a:	4620      	mov	r0, r4
   1b44c:	2200      	movs	r2, #0
   1b44e:	2101      	movs	r1, #1
   1b450:	f7ff f834 	bl	1a4bc <GFXsetTextColor>
	  GFXsetTextSize(&theGFX, 1);
   1b454:	4620      	mov	r0, r4
   1b456:	2101      	movs	r1, #1
   1b458:	f7ff f82a 	bl	1a4b0 <GFXsetTextSize>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1b45c:	2200      	movs	r2, #0
   1b45e:	2320      	movs	r3, #32
   1b460:	4620      	mov	r0, r4
   1b462:	4611      	mov	r1, r2
   1b464:	9201      	str	r2, [sp, #4]
   1b466:	9300      	str	r3, [sp, #0]
   1b468:	2380      	movs	r3, #128	; 0x80
   1b46a:	f7fe fbe7 	bl	19c3c <GFXfillRect>
	  OLED_writePreset();
   1b46e:	f7ff fed1 	bl	1b214 <OLED_writePreset>
}
   1b472:	b003      	add	sp, #12
   1b474:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	ssd1306_display_full_buffer();
   1b478:	f009 ba02 	b.w	24880 <ssd1306_display_full_buffer>

0001b47c <OLED_writeEditScreen>:
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b47c:	f643 311c 	movw	r1, #15132	; 0x3b1c
   1b480:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
{
   1b484:	b570      	push	{r4, r5, r6, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b486:	f2c0 0103 	movt	r1, #3
{
   1b48a:	b082      	sub	sp, #8
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b48c:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1b490:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b492:	f7ff f817 	bl	1a4c4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1b496:	2320      	movs	r3, #32
   1b498:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b49c:	4632      	mov	r2, r6
   1b49e:	4631      	mov	r1, r6
   1b4a0:	9601      	str	r6, [sp, #4]
   1b4a2:	9300      	str	r3, [sp, #0]
   1b4a4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b4a8:	2380      	movs	r3, #128	; 0x80
   1b4aa:	f244 7443 	movw	r4, #18243	; 0x4743
   1b4ae:	f7fe fbc5 	bl	19c3c <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b4b2:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
		GFXwrite(&theGFX, myCharArray[i]);
   1b4b6:	f64b 15d8 	movw	r5, #47576	; 0xb9d8
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b4ba:	4631      	mov	r1, r6
   1b4bc:	220c      	movs	r2, #12
   1b4be:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b4c2:	f2c0 0403 	movt	r4, #3
   1b4c6:	f7fe ffeb 	bl	1a4a0 <GFXsetCursor>
		GFXwrite(&theGFX, myCharArray[i]);
   1b4ca:	f2c0 250f 	movt	r5, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b4ce:	2310      	movs	r3, #16
   1b4d0:	9601      	str	r6, [sp, #4]
   1b4d2:	4632      	mov	r2, r6
   1b4d4:	4631      	mov	r1, r6
   1b4d6:	f104 060f 	add.w	r6, r4, #15
   1b4da:	9300      	str	r3, [sp, #0]
   1b4dc:	4628      	mov	r0, r5
   1b4de:	23b4      	movs	r3, #180	; 0xb4
   1b4e0:	f7fe fbac 	bl	19c3c <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   1b4e4:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   1b4e8:	4628      	mov	r0, r5
   1b4ea:	f7fe ff27 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b4ee:	42a6      	cmp	r6, r4
   1b4f0:	d1f8      	bne.n	1b4e4 <OLED_writeEditScreen+0x68>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b4f2:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
		GFXwrite(&theGFX, myCharArray[i]);
   1b4f6:	f64b 15d8 	movw	r5, #47576	; 0xb9d8
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b4fa:	221c      	movs	r2, #28
   1b4fc:	2100      	movs	r1, #0
   1b4fe:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b502:	f244 7453 	movw	r4, #18259	; 0x4753
   1b506:	f7fe ffcb 	bl	1a4a0 <GFXsetCursor>
		GFXwrite(&theGFX, myCharArray[i]);
   1b50a:	f2c0 250f 	movt	r5, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b50e:	2320      	movs	r3, #32
   1b510:	2100      	movs	r1, #0
   1b512:	f2c0 0403 	movt	r4, #3
   1b516:	2210      	movs	r2, #16
   1b518:	4628      	mov	r0, r5
   1b51a:	18a6      	adds	r6, r4, r2
   1b51c:	e9cd 3100 	strd	r3, r1, [sp]
   1b520:	23c0      	movs	r3, #192	; 0xc0
   1b522:	f7fe fb8b 	bl	19c3c <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   1b526:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   1b52a:	4628      	mov	r0, r5
   1b52c:	f7fe ff06 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b530:	42b4      	cmp	r4, r6
   1b532:	d1f8      	bne.n	1b526 <OLED_writeEditScreen+0xaa>
}
   1b534:	b002      	add	sp, #8
   1b536:	bd70      	pop	{r4, r5, r6, pc}

0001b538 <OLED_writeTuning>:
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b538:	f643 311c 	movw	r1, #15132	; 0x3b1c
   1b53c:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
{
   1b540:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b544:	f2c0 0103 	movt	r1, #3
{
   1b548:	b083      	sub	sp, #12
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b54a:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1b54e:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1b550:	f7fe ffb8 	bl	1a4c4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1b554:	f04f 0810 	mov.w	r8, #16
   1b558:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b55c:	2380      	movs	r3, #128	; 0x80
   1b55e:	4631      	mov	r1, r6
   1b560:	4642      	mov	r2, r8
   1b562:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b566:	9601      	str	r6, [sp, #4]
   1b568:	f8cd 8000 	str.w	r8, [sp]
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b56c:	f04f 0920 	mov.w	r9, #32
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1b570:	f7fe fb64 	bl	19c3c <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b574:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b578:	4631      	mov	r1, r6
   1b57a:	221c      	movs	r2, #28
   1b57c:	f2c0 200f 	movt	r0, #527	; 0x20f
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
   1b580:	f646 17b4 	movw	r7, #27060	; 0x69b4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b584:	f7fe ff8c 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b588:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b58c:	2318      	movs	r3, #24
   1b58e:	4642      	mov	r2, r8
   1b590:	4631      	mov	r1, r6
   1b592:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b596:	9601      	str	r6, [sp, #4]
	}
}

void OLEDwriteInt(uint32_t myNumber, uint8_t numDigits, uint8_t startCursor, OLEDLine line)
{
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b598:	f64b 14b8 	movw	r4, #47544	; 0xb9b8
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b59c:	f8cd 9000 	str.w	r9, [sp]
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
   1b5a0:	f2c0 270e 	movt	r7, #526	; 0x20e
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b5a4:	f7fe fb4a 	bl	19c3c <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   1b5a8:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b5ac:	2154      	movs	r1, #84	; 0x54
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b5ae:	f2c0 240f 	movt	r4, #527	; 0x20f
		GFXwrite(&theGFX, myCharArray[i]);
   1b5b2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b5b6:	f7fe fec1 	bl	1a33c <GFXwrite>
   1b5ba:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b5be:	4631      	mov	r1, r6
   1b5c0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b5c4:	f7fe feba 	bl	1a33c <GFXwrite>
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b5c8:	6839      	ldr	r1, [r7, #0]
   1b5ca:	2202      	movs	r2, #2
   1b5cc:	4620      	mov	r0, r4
   1b5ce:	f7fe ff8b 	bl	1a4e8 <OLEDparseInt>
   1b5d2:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b5d4:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b5d8:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b5da:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b5dc:	210c      	movs	r1, #12
   1b5de:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b5e2:	f7fe ff5d 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b5e6:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b5ea:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b5ee:	4642      	mov	r2, r8
   1b5f0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b5f4:	210c      	movs	r1, #12
   1b5f6:	009b      	lsls	r3, r3, #2
   1b5f8:	e9cd 9600 	strd	r9, r6, [sp]
   1b5fc:	f7fe fb1e 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b600:	b15d      	cbz	r5, 1b61a <OLED_writeTuning+0xe2>
		GFXwrite(&theGFX, myCharArray[i]);
   1b602:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b606:	4425      	add	r5, r4
   1b608:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b60c:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b610:	4630      	mov	r0, r6
   1b612:	f7fe fe93 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b616:	42ac      	cmp	r4, r5
   1b618:	d1f8      	bne.n	1b60c <OLED_writeTuning+0xd4>
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   1b61a:	683b      	ldr	r3, [r7, #0]
   1b61c:	f244 75d4 	movw	r5, #18388	; 0x47d4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b620:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
		GFXwrite(&theGFX, myCharArray[i]);
   1b624:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   1b628:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1b62c:	f2c0 0503 	movt	r5, #3
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b630:	221c      	movs	r2, #28
   1b632:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b636:	2124      	movs	r1, #36	; 0x24
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   1b638:	eb05 0583 	add.w	r5, r5, r3, lsl #2
		GFXwrite(&theGFX, myCharArray[i]);
   1b63c:	f2c0 260f 	movt	r6, #527	; 0x20f
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b640:	f7fe ff2e 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b644:	2200      	movs	r2, #0
   1b646:	2320      	movs	r3, #32
   1b648:	4630      	mov	r0, r6
   1b64a:	2124      	movs	r1, #36	; 0x24
   1b64c:	1e6c      	subs	r4, r5, #1
   1b64e:	350b      	adds	r5, #11
   1b650:	e9cd 3200 	strd	r3, r2, [sp]
   1b654:	2390      	movs	r3, #144	; 0x90
   1b656:	2210      	movs	r2, #16
   1b658:	f7fe faf0 	bl	19c3c <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   1b65c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   1b660:	4630      	mov	r0, r6
   1b662:	f7fe fe6b 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b666:	42a5      	cmp	r5, r4
   1b668:	d1f8      	bne.n	1b65c <OLED_writeTuning+0x124>
}
   1b66a:	b003      	add	sp, #12
   1b66c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0001b670 <OLED_draw>:
	ssd1306_display_full_buffer();
   1b670:	f009 b906 	b.w	24880 <ssd1306_display_full_buffer>

0001b674 <OLEDclearLine>:
{
   1b674:	4602      	mov	r2, r0
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1b676:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b67a:	2100      	movs	r1, #0
   1b67c:	2380      	movs	r3, #128	; 0x80
   1b67e:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   1b682:	b510      	push	{r4, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1b684:	0854      	lsrs	r4, r2, #1
   1b686:	f002 0201 	and.w	r2, r2, #1
{
   1b68a:	b082      	sub	sp, #8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1b68c:	3401      	adds	r4, #1
   1b68e:	0112      	lsls	r2, r2, #4
   1b690:	9101      	str	r1, [sp, #4]
   1b692:	0124      	lsls	r4, r4, #4
   1b694:	9400      	str	r4, [sp, #0]
   1b696:	f7fe fad1 	bl	19c3c <GFXfillRect>
}
   1b69a:	b002      	add	sp, #8
   1b69c:	bd10      	pop	{r4, pc}
   1b69e:	bf00      	nop

0001b6a0 <OLEDwriteString>:
{
   1b6a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b6a4:	4690      	mov	r8, r2
	uint8_t cursorY = 12 + (16 * (line%2));
   1b6a6:	f003 0201 	and.w	r2, r3, #1
{
   1b6aa:	461f      	mov	r7, r3
   1b6ac:	4604      	mov	r4, r0
	uint8_t cursorY = 12 + (16 * (line%2));
   1b6ae:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b6b0:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
{
   1b6b4:	460d      	mov	r5, r1
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b6b6:	1c7e      	adds	r6, r7, #1
{
   1b6b8:	b082      	sub	sp, #8
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b6ba:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b6be:	4641      	mov	r1, r8
   1b6c0:	320c      	adds	r2, #12
   1b6c2:	f7fe feed 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b6c6:	f04f 0c00 	mov.w	ip, #0
   1b6ca:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b6ce:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b6d2:	0136      	lsls	r6, r6, #4
   1b6d4:	4641      	mov	r1, r8
   1b6d6:	013a      	lsls	r2, r7, #4
   1b6d8:	f8cd c004 	str.w	ip, [sp, #4]
   1b6dc:	9600      	str	r6, [sp, #0]
   1b6de:	009b      	lsls	r3, r3, #2
   1b6e0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b6e4:	f7fe faaa 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b6e8:	b15d      	cbz	r5, 1b702 <OLEDwriteString+0x62>
		GFXwrite(&theGFX, myCharArray[i]);
   1b6ea:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b6ee:	4425      	add	r5, r4
   1b6f0:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b6f4:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b6f8:	4630      	mov	r0, r6
   1b6fa:	f7fe fe1f 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b6fe:	42a5      	cmp	r5, r4
   1b700:	d1f8      	bne.n	1b6f4 <OLEDwriteString+0x54>
}
   1b702:	b002      	add	sp, #8
   1b704:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001b708 <OLEDwriteInt>:
{
   1b708:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b70a:	f64b 14b8 	movw	r4, #47544	; 0xb9b8
{
   1b70e:	461f      	mov	r7, r3
   1b710:	b083      	sub	sp, #12
   1b712:	4616      	mov	r6, r2
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b714:	f2c0 240f 	movt	r4, #527	; 0x20f
   1b718:	460a      	mov	r2, r1
   1b71a:	4601      	mov	r1, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b71c:	b236      	sxth	r6, r6
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b71e:	4620      	mov	r0, r4
   1b720:	f7fe fee2 	bl	1a4e8 <OLEDparseInt>
	uint8_t cursorY = 12 + (16 * (line%2));
   1b724:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   1b728:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b72a:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	uint8_t cursorY = 12 + (16 * (line%2));
   1b72e:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b730:	4631      	mov	r1, r6
   1b732:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b736:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b738:	320c      	adds	r2, #12
   1b73a:	f7fe feb1 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b73e:	1c7a      	adds	r2, r7, #1
   1b740:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b744:	f04f 0c00 	mov.w	ip, #0
   1b748:	0112      	lsls	r2, r2, #4
   1b74a:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b74e:	4631      	mov	r1, r6
   1b750:	009b      	lsls	r3, r3, #2
   1b752:	9200      	str	r2, [sp, #0]
   1b754:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b758:	013a      	lsls	r2, r7, #4
   1b75a:	f8cd c004 	str.w	ip, [sp, #4]
   1b75e:	f7fe fa6d 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b762:	b15d      	cbz	r5, 1b77c <OLEDwriteInt+0x74>
		GFXwrite(&theGFX, myCharArray[i]);
   1b764:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b768:	4425      	add	r5, r4
   1b76a:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b76e:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b772:	4630      	mov	r0, r6
   1b774:	f7fe fde2 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b778:	42a5      	cmp	r5, r4
   1b77a:	d1f8      	bne.n	1b76e <OLEDwriteInt+0x66>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   1b77c:	b003      	add	sp, #12
   1b77e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b780 <OLEDwritePitch>:

	OLEDwriteLine(oled_buffer, len, line);
}

void OLEDwritePitch(float midi, uint8_t startCursor, OLEDLine line, uint8_t showCents)
{
   1b780:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   1b782:	f64b 14b8 	movw	r4, #47544	; 0xb9b8
{
   1b786:	460f      	mov	r7, r1
   1b788:	b083      	sub	sp, #12
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   1b78a:	4611      	mov	r1, r2
   1b78c:	f2c0 240f 	movt	r4, #527	; 0x20f
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b790:	b206      	sxth	r6, r0
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   1b792:	4620      	mov	r0, r4
   1b794:	f7fe fec8 	bl	1a528 <OLEDparsePitch>
	uint8_t cursorY = 12 + (16 * (line%2));
   1b798:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   1b79c:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b79e:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	uint8_t cursorY = 12 + (16 * (line%2));
   1b7a2:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b7a4:	4631      	mov	r1, r6
   1b7a6:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b7aa:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b7ac:	320c      	adds	r2, #12
   1b7ae:	f7fe fe77 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b7b2:	1c7a      	adds	r2, r7, #1
   1b7b4:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b7b8:	f04f 0c00 	mov.w	ip, #0
   1b7bc:	0112      	lsls	r2, r2, #4
   1b7be:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b7c2:	4631      	mov	r1, r6
   1b7c4:	009b      	lsls	r3, r3, #2
   1b7c6:	9200      	str	r2, [sp, #0]
   1b7c8:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b7cc:	013a      	lsls	r2, r7, #4
   1b7ce:	f8cd c004 	str.w	ip, [sp, #4]
   1b7d2:	f7fe fa33 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b7d6:	b15d      	cbz	r5, 1b7f0 <OLEDwritePitch+0x70>
		GFXwrite(&theGFX, myCharArray[i]);
   1b7d8:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b7dc:	4425      	add	r5, r4
   1b7de:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b7e2:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b7e6:	4630      	mov	r0, r6
   1b7e8:	f7fe fda8 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b7ec:	42a5      	cmp	r5, r4
   1b7ee:	d1f8      	bne.n	1b7e2 <OLEDwritePitch+0x62>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   1b7f0:	b003      	add	sp, #12
   1b7f2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b7f4 <OLEDwritePitchClass>:

void OLEDwritePitchClass(float midi, uint8_t startCursor, OLEDLine line)
{
   1b7f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitchClass(oled_buffer, midi);
   1b7f6:	f64b 14b8 	movw	r4, #47544	; 0xb9b8
{
   1b7fa:	460f      	mov	r7, r1
   1b7fc:	b083      	sub	sp, #12
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b7fe:	b206      	sxth	r6, r0
	int len = OLEDparsePitchClass(oled_buffer, midi);
   1b800:	f2c0 240f 	movt	r4, #527	; 0x20f
   1b804:	4620      	mov	r0, r4
   1b806:	f7fe fef7 	bl	1a5f8 <OLEDparsePitchClass>
	uint8_t cursorY = 12 + (16 * (line%2));
   1b80a:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparsePitchClass(oled_buffer, midi);
   1b80e:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b810:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	uint8_t cursorY = 12 + (16 * (line%2));
   1b814:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b816:	4631      	mov	r1, r6
   1b818:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b81c:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b81e:	320c      	adds	r2, #12
   1b820:	f7fe fe3e 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b824:	1c7a      	adds	r2, r7, #1
   1b826:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b82a:	f04f 0c00 	mov.w	ip, #0
   1b82e:	0112      	lsls	r2, r2, #4
   1b830:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b834:	4631      	mov	r1, r6
   1b836:	009b      	lsls	r3, r3, #2
   1b838:	9200      	str	r2, [sp, #0]
   1b83a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b83e:	013a      	lsls	r2, r7, #4
   1b840:	f8cd c004 	str.w	ip, [sp, #4]
   1b844:	f7fe f9fa 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b848:	b15d      	cbz	r5, 1b862 <OLEDwritePitchClass+0x6e>
		GFXwrite(&theGFX, myCharArray[i]);
   1b84a:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b84e:	4425      	add	r5, r4
   1b850:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b854:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b858:	4630      	mov	r0, r6
   1b85a:	f7fe fd6f 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b85e:	42a5      	cmp	r5, r4
   1b860:	d1f8      	bne.n	1b854 <OLEDwritePitchClass+0x60>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   1b862:	b003      	add	sp, #12
   1b864:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1b866:	bf00      	nop

0001b868 <OLEDwriteFloat>:
	OLEDwriteLine(oled_buffer, len, line);
}


void OLEDwriteFloat(float input, uint8_t startCursor, OLEDLine line)
{
   1b868:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b86a:	ed2d 8b02 	vpush	{d8}
   1b86e:	b083      	sub	sp, #12
   1b870:	4606      	mov	r6, r0
   1b872:	460f      	mov	r7, r1
   1b874:	eeb0 8a40 	vmov.f32	s16, s0
	int numDigits = 5;
	int numDecimal = 1;

	if (fastabsf(input)<1.0f)
   1b878:	f011 f9c6 	bl	2cc08 <fastabsf>
   1b87c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1b880:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b884:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b888:	d446      	bmi.n	1b918 <OLEDwriteFloat+0xb0>
	{
		numDigits = 3;
		numDecimal = 2;
	}

	else if (fastabsf(input)<10.0f)
   1b88a:	eeb0 0a48 	vmov.f32	s0, s16
   1b88e:	f011 f9bb 	bl	2cc08 <fastabsf>
   1b892:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
   1b896:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b89a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b89e:	d53e      	bpl.n	1b91e <OLEDwriteFloat+0xb6>
   1b8a0:	2202      	movs	r2, #2
   1b8a2:	2104      	movs	r1, #4
	{
		numDigits = 8;
		numDecimal = 0;
	}

	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   1b8a4:	f64b 14b8 	movw	r4, #47544	; 0xb9b8
   1b8a8:	eeb0 0a48 	vmov.f32	s0, s16
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b8ac:	b236      	sxth	r6, r6
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   1b8ae:	f2c0 240f 	movt	r4, #527	; 0x20f
   1b8b2:	4620      	mov	r0, r4
   1b8b4:	f7fe fed0 	bl	1a658 <OLEDparseFixedFloat>
	uint8_t cursorY = 12 + (16 * (line%2));
   1b8b8:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   1b8bc:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b8be:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	uint8_t cursorY = 12 + (16 * (line%2));
   1b8c2:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b8c4:	4631      	mov	r1, r6
   1b8c6:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b8ca:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1b8cc:	320c      	adds	r2, #12
   1b8ce:	f7fe fde7 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1b8d2:	1c7a      	adds	r2, r7, #1
   1b8d4:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1b8d8:	f04f 0c00 	mov.w	ip, #0
   1b8dc:	0112      	lsls	r2, r2, #4
   1b8de:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1b8e2:	4631      	mov	r1, r6
   1b8e4:	009b      	lsls	r3, r3, #2
   1b8e6:	9200      	str	r2, [sp, #0]
   1b8e8:	f2c0 200f 	movt	r0, #527	; 0x20f
   1b8ec:	013a      	lsls	r2, r7, #4
   1b8ee:	f8cd c004 	str.w	ip, [sp, #4]
   1b8f2:	f7fe f9a3 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1b8f6:	b15d      	cbz	r5, 1b910 <OLEDwriteFloat+0xa8>
		GFXwrite(&theGFX, myCharArray[i]);
   1b8f8:	f64b 16d8 	movw	r6, #47576	; 0xb9d8
   1b8fc:	4425      	add	r5, r4
   1b8fe:	f2c0 260f 	movt	r6, #527	; 0x20f
   1b902:	f814 1b01 	ldrb.w	r1, [r4], #1
   1b906:	4630      	mov	r0, r6
   1b908:	f7fe fd18 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1b90c:	42ac      	cmp	r4, r5
   1b90e:	d1f8      	bne.n	1b902 <OLEDwriteFloat+0x9a>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   1b910:	b003      	add	sp, #12
   1b912:	ecbd 8b02 	vpop	{d8}
   1b916:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1b918:	2202      	movs	r2, #2
   1b91a:	2103      	movs	r1, #3
   1b91c:	e7c2      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100.0f)
   1b91e:	eeb0 0a48 	vmov.f32	s0, s16
   1b922:	f011 f971 	bl	2cc08 <fastabsf>
   1b926:	2300      	movs	r3, #0
   1b928:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
   1b92c:	ee07 3a90 	vmov	s15, r3
   1b930:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b938:	d502      	bpl.n	1b940 <OLEDwriteFloat+0xd8>
   1b93a:	2202      	movs	r2, #2
   1b93c:	2105      	movs	r1, #5
   1b93e:	e7b1      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000.0f)
   1b940:	eeb0 0a48 	vmov.f32	s0, s16
   1b944:	f011 f960 	bl	2cc08 <fastabsf>
   1b948:	2300      	movs	r3, #0
   1b94a:	f2c4 437a 	movt	r3, #17530	; 0x447a
   1b94e:	ee07 3a90 	vmov	s15, r3
   1b952:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b956:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b95a:	d502      	bpl.n	1b962 <OLEDwriteFloat+0xfa>
   1b95c:	2201      	movs	r2, #1
   1b95e:	2105      	movs	r1, #5
   1b960:	e7a0      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000.0f)
   1b962:	eeb0 0a48 	vmov.f32	s0, s16
   1b966:	f011 f94f 	bl	2cc08 <fastabsf>
   1b96a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   1b96e:	f2c4 631c 	movt	r3, #17948	; 0x461c
   1b972:	ee07 3a90 	vmov	s15, r3
   1b976:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b97a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b97e:	d502      	bpl.n	1b986 <OLEDwriteFloat+0x11e>
   1b980:	2200      	movs	r2, #0
   1b982:	2105      	movs	r1, #5
   1b984:	e78e      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100000.0f)
   1b986:	eeb0 0a48 	vmov.f32	s0, s16
   1b98a:	f011 f93d 	bl	2cc08 <fastabsf>
   1b98e:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
   1b992:	f2c4 73c3 	movt	r3, #18371	; 0x47c3
   1b996:	ee07 3a90 	vmov	s15, r3
   1b99a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b99e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b9a2:	d502      	bpl.n	1b9aa <OLEDwriteFloat+0x142>
   1b9a4:	2200      	movs	r2, #0
   1b9a6:	2106      	movs	r1, #6
   1b9a8:	e77c      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000000.0f)
   1b9aa:	eeb0 0a48 	vmov.f32	s0, s16
   1b9ae:	f011 f92b 	bl	2cc08 <fastabsf>
   1b9b2:	f44f 5310 	mov.w	r3, #9216	; 0x2400
   1b9b6:	f6c4 1374 	movt	r3, #18804	; 0x4974
   1b9ba:	ee07 3a90 	vmov	s15, r3
   1b9be:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b9c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b9c6:	d502      	bpl.n	1b9ce <OLEDwriteFloat+0x166>
   1b9c8:	2200      	movs	r2, #0
   1b9ca:	2107      	movs	r1, #7
   1b9cc:	e76a      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000000.0f)
   1b9ce:	eeb0 0a48 	vmov.f32	s0, s16
   1b9d2:	f011 f919 	bl	2cc08 <fastabsf>
   1b9d6:	f249 6380 	movw	r3, #38528	; 0x9680
   1b9da:	f6c4 3318 	movt	r3, #19224	; 0x4b18
   1b9de:	ee07 3a90 	vmov	s15, r3
   1b9e2:	eeb4 0ae7 	vcmpe.f32	s0, s15
   1b9e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b9ea:	d5b7      	bpl.n	1b95c <OLEDwriteFloat+0xf4>
   1b9ec:	2200      	movs	r2, #0
   1b9ee:	2108      	movs	r1, #8
   1b9f0:	e758      	b.n	1b8a4 <OLEDwriteFloat+0x3c>
   1b9f2:	bf00      	nop

0001b9f4 <OLED_writeKnobParameter.part.0>:
void OLED_writeKnobParameter(uint8_t whichKnob)
   1b9f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1b9f8:	f646 1bb9 	movw	fp, #27065	; 0x69b9
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   1b9fc:	f646 16ba 	movw	r6, #27066	; 0x69ba
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba00:	f24a 6168 	movw	r1, #42600	; 0xa668
void OLED_writeKnobParameter(uint8_t whichKnob)
   1ba04:	4680      	mov	r8, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba06:	f2c0 2b0e 	movt	fp, #526	; 0x20e
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   1ba0a:	f2c0 260e 	movt	r6, #526	; 0x20e
   1ba0e:	2705      	movs	r7, #5
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba10:	0080      	lsls	r0, r0, #2
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba12:	f89b 3000 	ldrb.w	r3, [fp]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba16:	f2c0 210f 	movt	r1, #527	; 0x20f
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   1ba1a:	7835      	ldrb	r5, [r6, #0]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba1c:	f64e 32a4 	movw	r2, #60324	; 0xeba4
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba20:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1ba24:	f64e 44cc 	movw	r4, #60620	; 0xeccc
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   1ba28:	fb17 8705 	smlabb	r7, r7, r5, r8
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba2c:	4401      	add	r1, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba2e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba32:	f2c0 220f 	movt	r2, #527	; 0x20f
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba36:	f2c0 240f 	movt	r4, #527	; 0x20f
   1ba3a:	443b      	add	r3, r7
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba3c:	4402      	add	r2, r0
void OLED_writeKnobParameter(uint8_t whichKnob)
   1ba3e:	ed2d 8b02 	vpush	{d8}
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba42:	6809      	ldr	r1, [r1, #0]
void OLED_writeKnobParameter(uint8_t whichKnob)
   1ba44:	b083      	sub	sp, #12
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba46:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   1ba4a:	6011      	str	r1, [r2, #0]
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   1ba4c:	f014 fbc2 	bl	301d4 <strlen>
		if (len > 0)
   1ba50:	2800      	cmp	r0, #0
   1ba52:	f000 808b 	beq.w	1bb6c <OLED_writeKnobParameter.part.0+0x178>
   1ba56:	4605      	mov	r5, r0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1ba58:	f643 311c 	movw	r1, #15132	; 0x3b1c
   1ba5c:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1ba60:	f04f 0900 	mov.w	r9, #0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1ba64:	f2c0 0103 	movt	r1, #3
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1ba68:	f04f 0a10 	mov.w	sl, #16
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1ba6c:	f2c0 200f 	movt	r0, #527	; 0x20f
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1ba70:	b2ed      	uxtb	r5, r5
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1ba72:	f7fe fd27 	bl	1a4c4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1ba76:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1ba7a:	4649      	mov	r1, r9
   1ba7c:	4652      	mov	r2, sl
   1ba7e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ba82:	2380      	movs	r3, #128	; 0x80
   1ba84:	f8cd 9004 	str.w	r9, [sp, #4]
   1ba88:	f8cd a000 	str.w	sl, [sp]
   1ba8c:	f7fe f8d6 	bl	19c3c <GFXfillRect>
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   1ba90:	f89b 3000 	ldrb.w	r3, [fp]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1ba94:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1ba98:	4649      	mov	r1, r9
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   1ba9a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1ba9e:	221c      	movs	r2, #28
   1baa0:	f2c0 200f 	movt	r0, #527	; 0x20f
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   1baa4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1baa8:	441f      	add	r7, r3
   1baaa:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1baae:	f7fe fcf7 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1bab2:	2720      	movs	r7, #32
   1bab4:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1bab8:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1babc:	f8cd 9004 	str.w	r9, [sp, #4]
   1bac0:	4652      	mov	r2, sl
   1bac2:	4649      	mov	r1, r9
   1bac4:	009b      	lsls	r3, r3, #2
   1bac6:	9700      	str	r7, [sp, #0]
   1bac8:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bacc:	f7fe f8b6 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1bad0:	b165      	cbz	r5, 1baec <OLED_writeKnobParameter.part.0+0xf8>
   1bad2:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
   1bad4:	f64b 17d8 	movw	r7, #47576	; 0xb9d8
   1bad8:	4425      	add	r5, r4
   1bada:	f2c0 270f 	movt	r7, #527	; 0x20f
   1bade:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   1bae2:	4638      	mov	r0, r7
   1bae4:	f7fe fc2a 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1bae8:	42ac      	cmp	r4, r5
   1baea:	d1f8      	bne.n	1bade <OLED_writeKnobParameter.part.0+0xea>
	return GFXgetCursorX(&theGFX);
   1baec:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1baf0:	2420      	movs	r4, #32
	return GFXgetCursorX(&theGFX);
   1baf2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1baf6:	f7fe fcd7 	bl	1a4a8 <GFXgetCursorX>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1bafa:	221c      	movs	r2, #28
   1bafc:	b2c5      	uxtb	r5, r0
   1bafe:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bb02:	4629      	mov	r1, r5
   1bb04:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bb08:	f7fe fcca 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1bb0c:	2300      	movs	r3, #0
   1bb0e:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bb12:	4629      	mov	r1, r5
   1bb14:	9301      	str	r3, [sp, #4]
   1bb16:	2210      	movs	r2, #16
   1bb18:	230c      	movs	r3, #12
   1bb1a:	9400      	str	r4, [sp, #0]
   1bb1c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bb20:	f7fe f88c 	bl	19c3c <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   1bb24:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bb28:	4621      	mov	r1, r4
   1bb2a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bb2e:	f7fe fc05 	bl	1a33c <GFXwrite>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   1bb32:	7831      	ldrb	r1, [r6, #0]
   1bb34:	2205      	movs	r2, #5
   1bb36:	f64e 332c 	movw	r3, #60204	; 0xeb2c
	return GFXgetCursorX(&theGFX);
   1bb3a:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   1bb3e:	fb12 8801 	smlabb	r8, r2, r1, r8
   1bb42:	f2c0 230f 	movt	r3, #527	; 0x20f
	return GFXgetCursorX(&theGFX);
   1bb46:	f2c0 200f 	movt	r0, #527	; 0x20f
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   1bb4a:	eb03 0388 	add.w	r3, r3, r8, lsl #2
   1bb4e:	ed93 8a00 	vldr	s16, [r3]
	return GFXgetCursorX(&theGFX);
   1bb52:	f7fe fca9 	bl	1a4a8 <GFXgetCursorX>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   1bb56:	2101      	movs	r1, #1
   1bb58:	b2c0      	uxtb	r0, r0
   1bb5a:	eeb0 0a48 	vmov.f32	s0, s16
}
   1bb5e:	b003      	add	sp, #12
   1bb60:	ecbd 8b02 	vpop	{d8}
   1bb64:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   1bb68:	f7ff be7e 	b.w	1b868 <OLEDwriteFloat>
}
   1bb6c:	b003      	add	sp, #12
   1bb6e:	ecbd 8b02 	vpop	{d8}
   1bb72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1bb76:	bf00      	nop

0001bb78 <OLED_process>:
{
   1bb78:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (writeKnobFlag >= 0)
   1bb7c:	f246 24d3 	movw	r4, #25299	; 0x62d3
{
   1bb80:	b083      	sub	sp, #12
	if (writeKnobFlag >= 0)
   1bb82:	f2c0 0406 	movt	r4, #6
   1bb86:	f994 0000 	ldrsb.w	r0, [r4]
   1bb8a:	2800      	cmp	r0, #0
   1bb8c:	db03      	blt.n	1bb96 <OLED_process+0x1e>
	if (whichKnob < KNOB_PAGE_SIZE)
   1bb8e:	2804      	cmp	r0, #4
   1bb90:	dd6f      	ble.n	1bc72 <OLED_process+0xfa>
		writeKnobFlag = -1;
   1bb92:	23ff      	movs	r3, #255	; 0xff
   1bb94:	7023      	strb	r3, [r4, #0]
	if (writeButtonFlag >= 0 && writeActionFlag >= 0) //These should always be set together
   1bb96:	f246 24d2 	movw	r4, #25298	; 0x62d2
   1bb9a:	f2c0 0406 	movt	r4, #6
   1bb9e:	f994 0000 	ldrsb.w	r0, [r4]
   1bba2:	2800      	cmp	r0, #0
   1bba4:	db62      	blt.n	1bc6c <OLED_process+0xf4>
   1bba6:	f246 27d1 	movw	r7, #25297	; 0x62d1
   1bbaa:	f2c0 0706 	movt	r7, #6
   1bbae:	f997 1000 	ldrsb.w	r1, [r7]
   1bbb2:	2900      	cmp	r1, #0
   1bbb4:	db5a      	blt.n	1bc6c <OLED_process+0xf4>
	char* str = buttonActionFunctions[currentPreset](whichButton, whichAction);
   1bbb6:	f646 12b9 	movw	r2, #27065	; 0x69b9
   1bbba:	f24f 33e0 	movw	r3, #62432	; 0xf3e0
   1bbbe:	b2c9      	uxtb	r1, r1
   1bbc0:	f2c0 220e 	movt	r2, #526	; 0x20e
   1bbc4:	f2c0 230f 	movt	r3, #527	; 0x20f
   1bbc8:	b2c0      	uxtb	r0, r0
   1bbca:	7812      	ldrb	r2, [r2, #0]
   1bbcc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1bbd0:	4798      	blx	r3
   1bbd2:	4605      	mov	r5, r0
	int len = strlen(str);
   1bbd4:	f014 fafe 	bl	301d4 <strlen>
	if (len > 0)
   1bbd8:	4606      	mov	r6, r0
   1bbda:	2800      	cmp	r0, #0
   1bbdc:	d043      	beq.n	1bc66 <OLED_process+0xee>
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1bbde:	f643 311c 	movw	r1, #15132	; 0x3b1c
   1bbe2:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1bbe6:	f04f 0800 	mov.w	r8, #0
   1bbea:	f04f 0910 	mov.w	r9, #16
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1bbee:	f2c0 0103 	movt	r1, #3
   1bbf2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bbf6:	f7fe fc65 	bl	1a4c4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1bbfa:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bbfe:	2380      	movs	r3, #128	; 0x80
   1bc00:	4641      	mov	r1, r8
   1bc02:	464a      	mov	r2, r9
   1bc04:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bc08:	f8cd 8004 	str.w	r8, [sp, #4]
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1bc0c:	b2f6      	uxtb	r6, r6
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1bc0e:	f8cd 9000 	str.w	r9, [sp]
   1bc12:	f7fe f813 	bl	19c3c <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1bc16:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bc1a:	4641      	mov	r1, r8
   1bc1c:	221c      	movs	r2, #28
   1bc1e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bc22:	f7fe fc3d 	bl	1a4a0 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1bc26:	f04f 0c20 	mov.w	ip, #32
   1bc2a:	eb06 0346 	add.w	r3, r6, r6, lsl #1
   1bc2e:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bc32:	f8cd 8004 	str.w	r8, [sp, #4]
   1bc36:	464a      	mov	r2, r9
   1bc38:	4641      	mov	r1, r8
   1bc3a:	009b      	lsls	r3, r3, #2
   1bc3c:	f8cd c000 	str.w	ip, [sp]
   1bc40:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bc44:	f7fd fffa 	bl	19c3c <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1bc48:	b16e      	cbz	r6, 1bc66 <OLED_process+0xee>
   1bc4a:	442e      	add	r6, r5
		GFXwrite(&theGFX, myCharArray[i]);
   1bc4c:	f64b 18d8 	movw	r8, #47576	; 0xb9d8
   1bc50:	3d01      	subs	r5, #1
   1bc52:	3e01      	subs	r6, #1
   1bc54:	f2c0 280f 	movt	r8, #527	; 0x20f
   1bc58:	f815 1f01 	ldrb.w	r1, [r5, #1]!
   1bc5c:	4640      	mov	r0, r8
   1bc5e:	f7fe fb6d 	bl	1a33c <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1bc62:	42b5      	cmp	r5, r6
   1bc64:	d1f8      	bne.n	1bc58 <OLED_process+0xe0>
		writeButtonFlag = -1;
   1bc66:	23ff      	movs	r3, #255	; 0xff
   1bc68:	7023      	strb	r3, [r4, #0]
		writeActionFlag = -1;
   1bc6a:	703b      	strb	r3, [r7, #0]
}
   1bc6c:	b003      	add	sp, #12
   1bc6e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1bc72:	b2c0      	uxtb	r0, r0
   1bc74:	f7ff febe 	bl	1b9f4 <OLED_writeKnobParameter.part.0>
   1bc78:	e78b      	b.n	1bb92 <OLED_process+0x1a>
   1bc7a:	bf00      	nop

0001bc7c <OLEDgetCursor>:
	}
}

int16_t OLEDgetCursor()
{
	return GFXgetCursorX(&theGFX);
   1bc7c:	f64b 10d8 	movw	r0, #47576	; 0xb9d8
   1bc80:	f2c0 200f 	movt	r0, #527	; 0x20f
   1bc84:	f7fe bc10 	b.w	1a4a8 <GFXgetCursorX>

0001bc88 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
   1bc88:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
   1bc8a:	f64b 13fc 	movw	r3, #47612	; 0xb9fc
   1bc8e:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
   1bc92:	2100      	movs	r1, #0
  hrng.Instance = RNG;
   1bc94:	f2c0 230f 	movt	r3, #527	; 0x20f
   1bc98:	f6c4 0202 	movt	r2, #18434	; 0x4802
  if (HAL_RNG_Init(&hrng) != HAL_OK)
   1bc9c:	4618      	mov	r0, r3
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
   1bc9e:	e9c3 2100 	strd	r2, r1, [r3]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
   1bca2:	f7f5 fc6f 	bl	11584 <HAL_RNG_Init>
   1bca6:	b900      	cbnz	r0, 1bcaa <MX_RNG_Init+0x22>
  {
    Error_Handler();
  }

}
   1bca8:	bd08      	pop	{r3, pc}
   1bcaa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
   1bcae:	f7ff b9fd 	b.w	1b0ac <Error_Handler>
   1bcb2:	bf00      	nop

0001bcb4 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
   1bcb4:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   1bcb8:	6802      	ldr	r2, [r0, #0]
   1bcba:	f6c4 0302 	movt	r3, #18434	; 0x4802
   1bcbe:	429a      	cmp	r2, r3
   1bcc0:	d000      	beq.n	1bcc4 <HAL_RNG_MspInit+0x10>
   1bcc2:	4770      	bx	lr
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
   1bcc4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
   1bcc8:	b082      	sub	sp, #8
    __HAL_RCC_RNG_CLK_ENABLE();
   1bcca:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1bcce:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
   1bcd2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   1bcd6:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
   1bcda:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
   1bcde:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1bce2:	9301      	str	r3, [sp, #4]
   1bce4:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
   1bce6:	b002      	add	sp, #8
   1bce8:	4770      	bx	lr
   1bcea:	bf00      	nop

0001bcec <MX_SAI1_Init>:
DMA_HandleTypeDef hdma_sai1_a;
DMA_HandleTypeDef hdma_sai1_b;

/* SAI1 init function */
void MX_SAI1_Init(void)
{
   1bcec:	b570      	push	{r4, r5, r6, lr}

  hsai_BlockA1.Instance = SAI1_Block_A;
   1bcee:	f645 0204 	movw	r2, #22532	; 0x5804
   1bcf2:	f64b 3498 	movw	r4, #48024	; 0xbb98
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
   1bcf6:	2500      	movs	r5, #0
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   1bcf8:	2101      	movs	r1, #1
  hsai_BlockA1.Instance = SAI1_Block_A;
   1bcfa:	f2c0 240f 	movt	r4, #527	; 0x20f
   1bcfe:	f2c4 0201 	movt	r2, #16385	; 0x4001
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockA1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd02:	2302      	movs	r3, #2
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
   1bd04:	f64b 3680 	movw	r6, #48000	; 0xbb80
  hsai_BlockA1.Instance = SAI1_Block_A;
   1bd08:	6022      	str	r2, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd0a:	4620      	mov	r0, r4
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   1bd0c:	61e1      	str	r1, [r4, #28]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd0e:	461a      	mov	r2, r3
   1bd10:	4629      	mov	r1, r5
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
   1bd12:	6226      	str	r6, [r4, #32]
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
   1bd14:	60e5      	str	r5, [r4, #12]
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
   1bd16:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
   1bd18:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
   1bd1c:	e9c4 5505 	strd	r5, r5, [r4, #20]
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
   1bd20:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd24:	f7f5 fcbc 	bl	116a0 <HAL_SAI_InitProtocol>
   1bd28:	b9f8      	cbnz	r0, 1bd6a <MX_SAI1_Init+0x7e>
  {
    Error_Handler();
  }

  hsai_BlockB1.Instance = SAI1_Block_B;
   1bd2a:	f64b 2410 	movw	r4, #47632	; 0xba10
   1bd2e:	f645 0224 	movw	r2, #22564	; 0x5824
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
   1bd32:	2500      	movs	r5, #0
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
   1bd34:	2103      	movs	r1, #3
  hsai_BlockB1.Instance = SAI1_Block_B;
   1bd36:	f2c0 240f 	movt	r4, #527	; 0x20f
   1bd3a:	f2c4 0201 	movt	r2, #16385	; 0x4001
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockB1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd3e:	2302      	movs	r3, #2
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
   1bd40:	2601      	movs	r6, #1
  hsai_BlockB1.Instance = SAI1_Block_B;
   1bd42:	6022      	str	r2, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd44:	4620      	mov	r0, r4
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
   1bd46:	6061      	str	r1, [r4, #4]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd48:	461a      	mov	r2, r3
   1bd4a:	4629      	mov	r1, r5
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
   1bd4c:	60a6      	str	r6, [r4, #8]
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   1bd4e:	61e6      	str	r6, [r4, #28]
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
   1bd50:	6165      	str	r5, [r4, #20]
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
   1bd52:	60e5      	str	r5, [r4, #12]
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
   1bd54:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
   1bd56:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   1bd5a:	f7f5 fca1 	bl	116a0 <HAL_SAI_InitProtocol>
   1bd5e:	b900      	cbnz	r0, 1bd62 <MX_SAI1_Init+0x76>
  {
    Error_Handler();
  }

}
   1bd60:	bd70      	pop	{r4, r5, r6, pc}
   1bd62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
   1bd66:	f7ff b9a1 	b.w	1b0ac <Error_Handler>
    Error_Handler();
   1bd6a:	f7ff f99f 	bl	1b0ac <Error_Handler>
   1bd6e:	e7dc      	b.n	1bd2a <MX_SAI1_Init+0x3e>

0001bd70 <HAL_SAI_MspInit>:
void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(hsai->Instance==SAI1_Block_A)
   1bd70:	f645 0204 	movw	r2, #22532	; 0x5804
{
   1bd74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(hsai->Instance==SAI1_Block_A)
   1bd78:	f2c4 0201 	movt	r2, #16385	; 0x4001
   1bd7c:	6803      	ldr	r3, [r0, #0]
{
   1bd7e:	b088      	sub	sp, #32
   1bd80:	4605      	mov	r5, r0
    if(hsai->Instance==SAI1_Block_A)
   1bd82:	4293      	cmp	r3, r2
   1bd84:	d051      	beq.n	1be2a <HAL_SAI_MspInit+0xba>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
    }
    if(hsai->Instance==SAI1_Block_B)
   1bd86:	f645 0224 	movw	r2, #22564	; 0x5824
   1bd8a:	f2c4 0201 	movt	r2, #16385	; 0x4001
   1bd8e:	4293      	cmp	r3, r2
   1bd90:	d002      	beq.n	1bd98 <HAL_SAI_MspInit+0x28>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
    }
}
   1bd92:	b008      	add	sp, #32
   1bd94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (SAI1_client == 0)
   1bd98:	f646 0474 	movw	r4, #26740	; 0x6874
   1bd9c:	f2c0 240e 	movt	r4, #526	; 0x20e
   1bda0:	6822      	ldr	r2, [r4, #0]
   1bda2:	2a00      	cmp	r2, #0
   1bda4:	f000 8098 	beq.w	1bed8 <HAL_SAI_MspInit+0x168>
    SAI1_client ++;
   1bda8:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_3;
   1bdaa:	2108      	movs	r1, #8
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1bdac:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1bdb0:	2600      	movs	r6, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1bdb2:	2302      	movs	r3, #2
    SAI1_client ++;
   1bdb4:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1bdb6:	2206      	movs	r2, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1bdb8:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Pin = GPIO_PIN_3;
   1bdbc:	9103      	str	r1, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1bdbe:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1bdc0:	9304      	str	r3, [sp, #16]
    hdma_sai1_b.Instance = DMA1_Stream2;
   1bdc2:	f64b 3420 	movw	r4, #47904	; 0xbb20
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1bdc6:	9207      	str	r2, [sp, #28]
    hdma_sai1_b.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
   1bdc8:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_b.Instance = DMA1_Stream2;
   1bdcc:	f2c0 240f 	movt	r4, #527	; 0x20f
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1bdd0:	e9cd 6305 	strd	r6, r3, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1bdd4:	f7f0 fbe0 	bl	c598 <HAL_GPIO_Init>
    hdma_sai1_b.Instance = DMA1_Stream2;
   1bdd8:	2340      	movs	r3, #64	; 0x40
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   1bdda:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    hdma_sai1_b.Init.MemInc = DMA_MINC_ENABLE;
   1bdde:	f44f 6c80 	mov.w	ip, #1024	; 0x400
    hdma_sai1_b.Instance = DMA1_Stream2;
   1bde2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
   1bde6:	f04f 0e58 	mov.w	lr, #88	; 0x58
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
   1bdea:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_b.Init.Priority = DMA_PRIORITY_VERY_HIGH;
   1bdee:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_b.Instance = DMA1_Stream2;
   1bdf2:	6023      	str	r3, [r4, #0]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1bdf4:	2304      	movs	r3, #4
    hdma_sai1_b.Init.Direction = DMA_PERIPH_TO_MEMORY;
   1bdf6:	60a6      	str	r6, [r4, #8]
    hdma_sai1_b.Init.PeriphInc = DMA_PINC_DISABLE;
   1bdf8:	60e6      	str	r6, [r4, #12]
    hdma_sai1_b.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   1bdfa:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_b.Init.MemBurst = DMA_MBURST_SINGLE;
   1bdfc:	62e6      	str	r6, [r4, #44]	; 0x2c
    hdma_sai1_b.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1bdfe:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
   1be00:	f8c4 e004 	str.w	lr, [r4, #4]
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   1be04:	e9c4 c004 	strd	ip, r0, [r4, #16]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
   1be08:	4620      	mov	r0, r4
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
   1be0a:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1be0e:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
   1be12:	f7ee f957 	bl	a0c4 <HAL_DMA_Init>
   1be16:	2800      	cmp	r0, #0
   1be18:	d177      	bne.n	1bf0a <HAL_SAI_MspInit+0x19a>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
   1be1a:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
   1be1e:	63a5      	str	r5, [r4, #56]	; 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
   1be20:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
}
   1be24:	b008      	add	sp, #32
   1be26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (SAI1_client == 0)
   1be2a:	f646 0474 	movw	r4, #26740	; 0x6874
   1be2e:	f2c0 240e 	movt	r4, #526	; 0x20e
   1be32:	6822      	ldr	r2, [r4, #0]
   1be34:	2a00      	cmp	r2, #0
   1be36:	d06e      	beq.n	1bf16 <HAL_SAI_MspInit+0x1a6>
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1be38:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1be3c:	2600      	movs	r6, #0
    SAI1_client ++;
   1be3e:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
   1be40:	f04f 0c24 	mov.w	ip, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1be44:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1be46:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1be48:	f04f 0806 	mov.w	r8, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1be4c:	f6c5 0002 	movt	r0, #22530	; 0x5802
   1be50:	a903      	add	r1, sp, #12
    SAI1_client ++;
   1be52:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
   1be54:	f8cd c00c 	str.w	ip, [sp, #12]
    hdma_sai1_a.Instance = DMA1_Stream1;
   1be58:	f64b 24a8 	movw	r4, #47784	; 0xbaa8
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1be5c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1be5e:	f8cd 801c 	str.w	r8, [sp, #28]
    hdma_sai1_a.Instance = DMA1_Stream1;
   1be62:	f2c0 240f 	movt	r4, #527	; 0x20f
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1be66:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1be6a:	f7f0 fb95 	bl	c598 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1be6e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
   1be72:	2350      	movs	r3, #80	; 0x50
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1be74:	a903      	add	r1, sp, #12
   1be76:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1be7a:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1be7c:	f8cd 801c 	str.w	r8, [sp, #28]
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
   1be80:	f04f 0857 	mov.w	r8, #87	; 0x57
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
   1be84:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   1be86:	e9cd 6705 	strd	r6, r7, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1be8a:	f7f0 fb85 	bl	c598 <HAL_GPIO_Init>
    hdma_sai1_a.Instance = DMA1_Stream1;
   1be8e:	2328      	movs	r3, #40	; 0x28
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1be90:	2040      	movs	r0, #64	; 0x40
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
   1be92:	f44f 6e80 	mov.w	lr, #1024	; 0x400
    hdma_sai1_a.Instance = DMA1_Stream1;
   1be96:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   1be9a:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
   1be9e:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
   1bea2:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_VERY_HIGH;
   1bea6:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_a.Instance = DMA1_Stream1;
   1beaa:	6023      	str	r3, [r4, #0]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1beac:	2304      	movs	r3, #4
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
   1beae:	60e6      	str	r6, [r4, #12]
    hdma_sai1_a.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   1beb0:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1beb2:	e9c4 8001 	strd	r8, r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
   1beb6:	4620      	mov	r0, r4
    hdma_sai1_a.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1beb8:	e9c4 660b 	strd	r6, r6, [r4, #44]	; 0x2c
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   1bebc:	e9c4 ec04 	strd	lr, ip, [r4, #16]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
   1bec0:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1bec4:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
   1bec8:	f7ee f8fc 	bl	a0c4 <HAL_DMA_Init>
   1becc:	bb00      	cbnz	r0, 1bf10 <HAL_SAI_MspInit+0x1a0>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
   1bece:	63a5      	str	r5, [r4, #56]	; 0x38
   1bed0:	682b      	ldr	r3, [r5, #0]
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
   1bed2:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
   1bed6:	e756      	b.n	1bd86 <HAL_SAI_MspInit+0x16>
       __HAL_RCC_SAI1_CLK_ENABLE();
   1bed8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1bedc:	2102      	movs	r1, #2
   1bede:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
   1bee0:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1bee4:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
   1bee8:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
   1beec:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
   1bef0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   1bef4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1bef8:	9302      	str	r3, [sp, #8]
   1befa:	9b02      	ldr	r3, [sp, #8]
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1befc:	f7ed febe 	bl	9c7c <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ(SAI1_IRQn);
   1bf00:	2057      	movs	r0, #87	; 0x57
   1bf02:	f7ed ff0b 	bl	9d1c <HAL_NVIC_EnableIRQ>
   1bf06:	6822      	ldr	r2, [r4, #0]
   1bf08:	e74e      	b.n	1bda8 <HAL_SAI_MspInit+0x38>
      Error_Handler();
   1bf0a:	f7ff f8cf 	bl	1b0ac <Error_Handler>
   1bf0e:	e784      	b.n	1be1a <HAL_SAI_MspInit+0xaa>
      Error_Handler();
   1bf10:	f7ff f8cc 	bl	1b0ac <Error_Handler>
   1bf14:	e7db      	b.n	1bece <HAL_SAI_MspInit+0x15e>
       __HAL_RCC_SAI1_CLK_ENABLE();
   1bf16:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1bf1a:	2102      	movs	r1, #2
   1bf1c:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
   1bf1e:	f6c5 0302 	movt	r3, #22530	; 0x5802
   1bf22:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
   1bf26:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
   1bf2a:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
   1bf2e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   1bf32:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1bf36:	9301      	str	r3, [sp, #4]
   1bf38:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1bf3a:	f7ed fe9f 	bl	9c7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SAI1_IRQn);
   1bf3e:	2057      	movs	r0, #87	; 0x57
   1bf40:	f7ed feec 	bl	9d1c <HAL_NVIC_EnableIRQ>
   1bf44:	6822      	ldr	r2, [r4, #0]
   1bf46:	e777      	b.n	1be38 <HAL_SAI_MspInit+0xc8>

0001bf48 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
   1bf48:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;  
   1bf4a:	f246 043c 	movw	r4, #24636	; 0x603c
   1bf4e:	2501      	movs	r5, #1
   1bf50:	f2c0 0406 	movt	r4, #6
   1bf54:	7025      	strb	r5, [r4, #0]

#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
   1bf56:	f7fc ff7d 	bl	18e54 <BSP_SD_Init>
   1bf5a:	b108      	cbz	r0, 1bf60 <SD_initialize+0x18>

#else
  Stat = SD_CheckStatus(lun);
#endif

  return Stat;
   1bf5c:	7820      	ldrb	r0, [r4, #0]
}
   1bf5e:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
   1bf60:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
   1bf62:	f7fc ff53 	bl	18e0c <BSP_SD_GetCardState>
   1bf66:	b918      	cbnz	r0, 1bf70 <SD_initialize+0x28>
    Stat &= ~STA_NOINIT;
   1bf68:	7823      	ldrb	r3, [r4, #0]
   1bf6a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   1bf6e:	7023      	strb	r3, [r4, #0]
  return Stat;
   1bf70:	7823      	ldrb	r3, [r4, #0]
   1bf72:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
   1bf74:	7023      	strb	r3, [r4, #0]
  return Stat;
   1bf76:	7820      	ldrb	r0, [r4, #0]
}
   1bf78:	bd38      	pop	{r3, r4, r5, pc}
   1bf7a:	bf00      	nop

0001bf7c <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
   1bf7c:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
   1bf7e:	f246 043c 	movw	r4, #24636	; 0x603c
   1bf82:	2301      	movs	r3, #1
   1bf84:	f2c0 0406 	movt	r4, #6
   1bf88:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
   1bf8a:	f7fc ff3f 	bl	18e0c <BSP_SD_GetCardState>
   1bf8e:	b918      	cbnz	r0, 1bf98 <SD_status+0x1c>
    Stat &= ~STA_NOINIT;
   1bf90:	7823      	ldrb	r3, [r4, #0]
   1bf92:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   1bf96:	7023      	strb	r3, [r4, #0]
  return Stat;
   1bf98:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
   1bf9a:	bd10      	pop	{r4, pc}

0001bf9c <SD_read>:
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
              
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
   1bf9c:	b508      	push	{r3, lr}
   1bf9e:	4608      	mov	r0, r1
   1bfa0:	4611      	mov	r1, r2
   1bfa2:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
   1bfa4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1bfa8:	f7fc ff0c 	bl	18dc4 <BSP_SD_ReadBlocks>
   1bfac:	b920      	cbnz	r0, 1bfb8 <SD_read+0x1c>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
   1bfae:	f7fc ff2d 	bl	18e0c <BSP_SD_GetCardState>
   1bfb2:	2800      	cmp	r0, #0
   1bfb4:	d1fb      	bne.n	1bfae <SD_read+0x12>
    }
    res = RES_OK;
  }

  return res;
}
   1bfb6:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
   1bfb8:	2001      	movs	r0, #1
}
   1bfba:	bd08      	pop	{r3, pc}

0001bfbc <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
   1bfbc:	f246 033c 	movw	r3, #24636	; 0x603c
   1bfc0:	f2c0 0306 	movt	r3, #6
   1bfc4:	781b      	ldrb	r3, [r3, #0]
   1bfc6:	07db      	lsls	r3, r3, #31
   1bfc8:	d408      	bmi.n	1bfdc <SD_ioctl+0x20>
{
   1bfca:	b510      	push	{r4, lr}
   1bfcc:	4614      	mov	r4, r2
   1bfce:	b08a      	sub	sp, #40	; 0x28

  switch (cmd)
   1bfd0:	2903      	cmp	r1, #3
   1bfd2:	d821      	bhi.n	1c018 <SD_ioctl+0x5c>
   1bfd4:	e8df f001 	tbb	[pc, r1]
   1bfd8:	170f0704 	.word	0x170f0704
  if (Stat & STA_NOINIT) return RES_NOTRDY;
   1bfdc:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
   1bfde:	4770      	bx	lr
    res = RES_OK;
   1bfe0:	2000      	movs	r0, #0
}
   1bfe2:	b00a      	add	sp, #40	; 0x28
   1bfe4:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1bfe6:	a801      	add	r0, sp, #4
   1bfe8:	f7fc ff1c 	bl	18e24 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
   1bfec:	9b07      	ldr	r3, [sp, #28]
    res = RES_OK;
   1bfee:	2000      	movs	r0, #0
    *(DWORD*)buff = CardInfo.LogBlockNbr;
   1bff0:	6023      	str	r3, [r4, #0]
}
   1bff2:	b00a      	add	sp, #40	; 0x28
   1bff4:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1bff6:	a801      	add	r0, sp, #4
   1bff8:	f7fc ff14 	bl	18e24 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
   1bffc:	9b08      	ldr	r3, [sp, #32]
    res = RES_OK;
   1bffe:	2000      	movs	r0, #0
    *(WORD*)buff = CardInfo.LogBlockSize;
   1c000:	8023      	strh	r3, [r4, #0]
}
   1c002:	b00a      	add	sp, #40	; 0x28
   1c004:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1c006:	a801      	add	r0, sp, #4
   1c008:	f7fc ff0c 	bl	18e24 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
   1c00c:	9b08      	ldr	r3, [sp, #32]
   1c00e:	2000      	movs	r0, #0
   1c010:	0a5b      	lsrs	r3, r3, #9
   1c012:	6023      	str	r3, [r4, #0]
}
   1c014:	b00a      	add	sp, #40	; 0x28
   1c016:	bd10      	pop	{r4, pc}
    res = RES_PARERR;
   1c018:	2004      	movs	r0, #4
}
   1c01a:	b00a      	add	sp, #40	; 0x28
   1c01c:	bd10      	pop	{r4, pc}
   1c01e:	bf00      	nop

0001c020 <SD_write>:
{
   1c020:	b508      	push	{r3, lr}
   1c022:	4608      	mov	r0, r1
   1c024:	4611      	mov	r1, r2
   1c026:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
   1c028:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1c02c:	f7fc fedc 	bl	18de8 <BSP_SD_WriteBlocks>
   1c030:	b920      	cbnz	r0, 1c03c <SD_write+0x1c>
    while(BSP_SD_GetCardState()!= MSD_OK)
   1c032:	f7fc feeb 	bl	18e0c <BSP_SD_GetCardState>
   1c036:	2800      	cmp	r0, #0
   1c038:	d1fb      	bne.n	1c032 <SD_write+0x12>
}
   1c03a:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
   1c03c:	2001      	movs	r0, #1
}
   1c03e:	bd08      	pop	{r3, pc}

0001c040 <MX_SDMMC1_SD_Init>:
/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{

  hsd1.Instance = SDMMC1;
   1c040:	f64b 4330 	movw	r3, #48176	; 0xbc30
   1c044:	f44f 41e0 	mov.w	r1, #28672	; 0x7000
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd1.Init.ClockDiv = 0;
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
   1c048:	2001      	movs	r0, #1
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
   1c04a:	2200      	movs	r2, #0
  hsd1.Instance = SDMMC1;
   1c04c:	f2c0 230f 	movt	r3, #527	; 0x20f
   1c050:	f2c5 2100 	movt	r1, #20992	; 0x5200
{
   1c054:	b410      	push	{r4}
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
   1c056:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
   1c05a:	6019      	str	r1, [r3, #0]
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
   1c05c:	6198      	str	r0, [r3, #24]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
   1c05e:	60dc      	str	r4, [r3, #12]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
   1c060:	e9c3 2201 	strd	r2, r2, [r3, #4]
  hsd1.Init.ClockDiv = 0;
   1c064:	e9c3 2204 	strd	r2, r2, [r3, #16]

}
   1c068:	f85d 4b04 	ldr.w	r4, [sp], #4
   1c06c:	4770      	bx	lr
   1c06e:	bf00      	nop

0001c070 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(sdHandle->Instance==SDMMC1)
   1c070:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
{
   1c074:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(sdHandle->Instance==SDMMC1)
   1c078:	f2c5 2300 	movt	r3, #20992	; 0x5200
   1c07c:	6802      	ldr	r2, [r0, #0]
{
   1c07e:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1c080:	2400      	movs	r4, #0
  if(sdHandle->Instance==SDMMC1)
   1c082:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1c084:	9407      	str	r4, [sp, #28]
   1c086:	e9cd 4403 	strd	r4, r4, [sp, #12]
   1c08a:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(sdHandle->Instance==SDMMC1)
   1c08e:	d002      	beq.n	1c096 <HAL_SD_MspInit+0x26>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
   1c090:	b008      	add	sp, #32
   1c092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1c096:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1c09a:	250c      	movs	r5, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
   1c09c:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c0a0:	f44f 6000 	mov.w	r0, #2048	; 0x800
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1c0a4:	f6c5 0302 	movt	r3, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1c0a8:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1c0aa:	2603      	movs	r6, #3
    GPIO_InitStruct.Pull = GPIO_PULLUP;
   1c0ac:	f04f 0801 	mov.w	r8, #1
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1c0b0:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c0b4:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1c0b8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   1c0bc:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
   1c0c0:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   1c0c4:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
   1c0c8:	9200      	str	r2, [sp, #0]
   1c0ca:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
   1c0cc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1c0d0:	f042 0204 	orr.w	r2, r2, #4
   1c0d4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1c0d8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1c0dc:	f002 0204 	and.w	r2, r2, #4
   1c0e0:	9201      	str	r2, [sp, #4]
   1c0e2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1c0e4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1c0e8:	f042 0208 	orr.w	r2, r2, #8
   1c0ec:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1c0f0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
   1c0f4:	9103      	str	r1, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c0f6:	eb0d 0105 	add.w	r1, sp, r5
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1c0fa:	f003 0308 	and.w	r3, r3, #8
   1c0fe:	9302      	str	r3, [sp, #8]
   1c100:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
   1c102:	e9cd 7804 	strd	r7, r8, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1c106:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c10a:	f7f0 fa45 	bl	c598 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c10e:	f44f 6000 	mov.w	r0, #2048	; 0x800
    GPIO_InitStruct.Pin = GPIO_PIN_12;
   1c112:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c116:	eb0d 0105 	add.w	r1, sp, r5
   1c11a:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1c11e:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_12;
   1c120:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1c122:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1c124:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1c128:	f7f0 fa36 	bl	c598 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1c12c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
    GPIO_InitStruct.Pin = GPIO_PIN_2;
   1c130:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1c132:	eb0d 0105 	add.w	r1, sp, r5
   1c136:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1c13a:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1c13c:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
   1c13e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1c140:	e9cd 8605 	strd	r8, r6, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1c144:	f7f0 fa28 	bl	c598 <HAL_GPIO_Init>
}
   1c148:	b008      	add	sp, #32
   1c14a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1c14e:	bf00      	nop

0001c150 <initGlobalSFXObjects>:
void calculateNoteArray()
{
	for (int i = 0; i < 128; i++)
	{
		float tempNote = i;
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c150:	f646 13b8 	movw	r3, #27064	; 0x69b8
	for (int i = 0; i < 128; i++)
   1c154:	2000      	movs	r0, #0
{
   1c156:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c15a:	f2c0 230e 	movt	r3, #526	; 0x20e
   1c15e:	f24c 74b0 	movw	r4, #51120	; 0xc7b0
   1c162:	f646 1584 	movw	r5, #27012	; 0x6984
   1c166:	f64a 26ab 	movw	r6, #43691	; 0xaaab
{
   1c16a:	b083      	sub	sp, #12
   1c16c:	f2c0 240f 	movt	r4, #527	; 0x20f
   1c170:	f2c0 250e 	movt	r5, #526	; 0x20e
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c174:	f6c2 26aa 	movt	r6, #10922	; 0x2aaa
   1c178:	781f      	ldrb	r7, [r3, #0]
		float tempNote = i;
   1c17a:	ee07 0a90 	vmov	s15, r0
	for (int i = 0; i < 128; i++)
   1c17e:	3001      	adds	r0, #1
		float tempNote = i;
   1c180:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	for (int i = 0; i < 128; i++)
   1c184:	2880      	cmp	r0, #128	; 0x80
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c186:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1c18a:	ee17 3a90 	vmov	r3, s15
   1c18e:	eba3 0307 	sub.w	r3, r3, r7
   1c192:	fb86 2103 	smull	r2, r1, r6, r3
   1c196:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1c19a:	ebc2 0261 	rsb	r2, r2, r1, asr #1
   1c19e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1c1a2:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1c1a6:	ee07 3a90 	vmov	s15, r3
   1c1aa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1c1ae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1c1b2:	ee17 3a90 	vmov	r3, s15
   1c1b6:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   1c1ba:	edd3 7a00 	vldr	s15, [r3]
   1c1be:	ee37 7a87 	vadd.f32	s14, s15, s14
		notes[i] = tunedNote;
   1c1c2:	eca4 7a01 	vstmia	r4!, {s14}
	for (int i = 0; i < 128; i++)
   1c1c6:	d1d8      	bne.n	1c17a <initGlobalSFXObjects+0x2a>
   1c1c8:	f64d 44b8 	movw	r4, #56504	; 0xdcb8
		tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1c1cc:	f24d 770a 	movw	r7, #55050	; 0xd70a
   1c1d0:	f64a 6690 	movw	r6, #44688	; 0xae90
	tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
   1c1d4:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c1d8:	f2c0 240f 	movt	r4, #527	; 0x20f
   1c1dc:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
		tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1c1e0:	2500      	movs	r5, #0
   1c1e2:	f6c3 47a3 	movt	r7, #15523	; 0x3ca3
   1c1e6:	f104 0820 	add.w	r8, r4, #32
   1c1ea:	f2c0 260f 	movt	r6, #527	; 0x20f
	tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
   1c1ee:	2108      	movs	r1, #8
   1c1f0:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c1f4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c1f8:	f011 f99c 	bl	2d534 <tSimplePoly_initToPool>
		tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1c1fc:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1c200:	2200      	movs	r2, #0
   1c202:	4620      	mov	r0, r4
   1c204:	3404      	adds	r4, #4
   1c206:	f6c3 43a3 	movt	r3, #15523	; 0x3ca3
   1c20a:	ee00 2a10 	vmov	s0, r2
   1c20e:	4631      	mov	r1, r6
   1c210:	ee00 3a90 	vmov	s1, r3
   1c214:	f00f f894 	bl	2b340 <tExpSmooth_initToPool>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1c218:	45a0      	cmp	r8, r4
   1c21a:	d1ef      	bne.n	1c1fc <initGlobalSFXObjects+0xac>
	tExpSmooth_init(&comp, 1.0f, 0.01f);
   1c21c:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1c220:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1c224:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
	defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1c228:	f649 189a 	movw	r8, #39322	; 0x999a
	tExpSmooth_init(&comp, 1.0f, 0.01f);
   1c22c:	f6c3 4323 	movt	r3, #15395	; 0x3c23
   1c230:	f2c0 200f 	movt	r0, #527	; 0x20f
	defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1c234:	f24f 5ac3 	movw	sl, #62915	; 0xf5c3
	defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1c238:	f243 3933 	movw	r9, #13107	; 0x3333
	tExpSmooth_init(&comp, 1.0f, 0.01f);
   1c23c:	ee00 3a90 	vmov	s1, r3
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1c240:	f246 6666 	movw	r6, #26214	; 0x6666
	tExpSmooth_init(&comp, 1.0f, 0.01f);
   1c244:	f00f f852 	bl	2b2ec <tExpSmooth_init>
	LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
   1c248:	2300      	movs	r3, #0
   1c24a:	f24b 7217 	movw	r2, #46871	; 0xb717
   1c24e:	f24d 30e4 	movw	r0, #54244	; 0xd3e4
   1c252:	4619      	mov	r1, r3
   1c254:	f2c4 437a 	movt	r3, #17530	; 0x447a
   1c258:	f6cb 2251 	movt	r2, #47697	; 0xba51
   1c25c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c260:	ee01 1a10 	vmov	s2, r1
   1c264:	ee00 3a10 	vmov	s0, r3
   1c268:	ee01 2a90 	vmov	s3, r2
   1c26c:	2180      	movs	r1, #128	; 0x80
   1c26e:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
	defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1c272:	f6c3 7a28 	movt	sl, #16168	; 0x3f28
	LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
   1c276:	f010 fe27 	bl	2cec8 <LEAF_generate_exp>
	LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
   1c27a:	f24b 7217 	movw	r2, #46871	; 0xb717
   1c27e:	f241 236f 	movw	r3, #4719	; 0x126f
   1c282:	2100      	movs	r1, #0
   1c284:	f6cb 2251 	movt	r2, #47697	; 0xba51
   1c288:	f64d 40d8 	movw	r0, #56536	; 0xdcd8
   1c28c:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   1c290:	ee00 1a90 	vmov	s1, r1
   1c294:	ee01 2a90 	vmov	s3, r2
   1c298:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c29c:	ee00 3a10 	vmov	s0, r3
   1c2a0:	f44f 7100 	mov.w	r1, #512	; 0x200
   1c2a4:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
	defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1c2a8:	f6c3 7973 	movt	r9, #16243	; 0x3f73
	LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
   1c2ac:	f010 fe0c 	bl	2cec8 <LEAF_generate_exp>
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1c2b0:	f64c 40cd 	movw	r0, #52429	; 0xcccd
   1c2b4:	f64b 43d0 	movw	r3, #48336	; 0xbcd0
	defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
   1c2b8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1c2bc:	4684      	mov	ip, r0
	defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
   1c2be:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
	defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
   1c2c2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1c2c6:	f2c0 230f 	movt	r3, #527	; 0x20f
	defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1c2ca:	f6c3 6c4c 	movt	ip, #15948	; 0x3e4c
	defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1c2ce:	4602      	mov	r2, r0
	defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1c2d0:	4641      	mov	r1, r8
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1c2d2:	f6c3 60cc 	movt	r0, #16076	; 0x3ecc
	defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1c2d6:	f6c3 7859 	movt	r8, #16217	; 0x3f59
	defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
   1c2da:	eeb6 6a08 	vmov.f32	s12, #104	; 0x3f400000  0.750
	defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1c2de:	f6c3 52cc 	movt	r2, #15820	; 0x3dcc
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1c2e2:	6018      	str	r0, [r3, #0]
	defaultPresetKnobValues[VocoderCh][0] = 0.4f; // volume
   1c2e4:	6658      	str	r0, [r3, #100]	; 0x64
	defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1c2e6:	f6c3 6199 	movt	r1, #16025	; 0x3e99
	defaultPresetKnobValues[Vocoder][5] = 0.02f; // breathiness
   1c2ea:	615f      	str	r7, [r3, #20]
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1c2ec:	f6c3 7666 	movt	r6, #16230	; 0x3f66
	defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1c2f0:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
	defaultPresetKnobValues[LivingString][8] = 0.8f;
   1c2f4:	f64c 4ecd 	movw	lr, #52429	; 0xcccd
	defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1c2f8:	f8c3 8008 	str.w	r8, [r3, #8]
	defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1c2fc:	f24c 2b8f 	movw	fp, #49807	; 0xc28f
	defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1c300:	f8c3 c010 	str.w	ip, [r3, #16]
	defaultPresetKnobValues[LivingString][8] = 0.8f;
   1c304:	f6c3 7e4c 	movt	lr, #16204	; 0x3f4c
	defaultPresetKnobValues[VocoderCh][4] = 0.2f; //noise thresh
   1c308:	f8c3 c074 	str.w	ip, [r3, #116]	; 0x74
	defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1c30c:	f6c3 5b75 	movt	fp, #15733	; 0x3d75
	defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
   1c310:	ed83 7a37 	vstr	s14, [r3, #220]	; 0xdc
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1c314:	f64c 47cd 	movw	r7, #52429	; 0xcccd
	defaultPresetKnobValues[Pitchshift][6] = 0.25f;
   1c318:	ed83 7a38 	vstr	s14, [r3, #224]	; 0xe0
   1c31c:	f64c 2478 	movw	r4, #51832	; 0xca78
	defaultPresetKnobValues[Vocoder][3] = 0.0f; // sawToPulse
   1c320:	60dd      	str	r5, [r3, #12]
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1c322:	f6c3 574c 	movt	r7, #15692	; 0x3d4c
	defaultPresetKnobValues[Vocoder][9] = 0.0f;
   1c326:	625d      	str	r5, [r3, #36]	; 0x24
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1c328:	f643 3acd 	movw	sl, #15309	; 0x3bcd
	defaultPresetKnobValues[VocoderCh][5] = 0.0f;// saw->pulse fade
   1c32c:	679d      	str	r5, [r3, #120]	; 0x78
   1c32e:	f2c0 240f 	movt	r4, #527	; 0x20f
	defaultPresetKnobValues[VocoderCh][8] = 0.0f; // breathiness
   1c332:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1c336:	f6c3 5ace 	movt	sl, #15822	; 0x3dce
	defaultPresetKnobValues[VocoderCh][13] = 0.0f; // stereo
   1c33a:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
	defaultPresetKnobValues[VocoderCh][14] = 0.0f; // barkpull
   1c33e:	f8c3 509c 	str.w	r5, [r3, #156]	; 0x9c
	defaultPresetKnobValues[Pitchshift][2] = 0.0f; // f amount
   1c342:	f8c3 50d0 	str.w	r5, [r3, #208]	; 0xd0
	defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
   1c346:	edc3 7a01 	vstr	s15, [r3, #4]
	defaultPresetKnobValues[Vocoder][6] = 0.5f; // tilt
   1c34a:	edc3 7a06 	vstr	s15, [r3, #24]
	defaultPresetKnobValues[Vocoder][7] = 0.5f; // pulse width
   1c34e:	edc3 7a07 	vstr	s15, [r3, #28]
	defaultPresetKnobValues[Vocoder][8] = 0.5f; // pulse shape
   1c352:	edc3 7a08 	vstr	s15, [r3, #32]
	defaultPresetKnobValues[VocoderCh][1] = 0.5f; // warp factor
   1c356:	edc3 7a1a 	vstr	s15, [r3, #104]	; 0x68
	defaultPresetKnobValues[VocoderCh][3] = 0.5f; //band width
   1c35a:	edc3 7a1c 	vstr	s15, [r3, #112]	; 0x70
	defaultPresetKnobValues[VocoderCh][6] = 0.5f; // pulse length
   1c35e:	edc3 7a1f 	vstr	s15, [r3, #124]	; 0x7c
	defaultPresetKnobValues[VocoderCh][7] = 0.5f; // pulse width
   1c362:	edc3 7a20 	vstr	s15, [r3, #128]	; 0x80
	defaultPresetKnobValues[VocoderCh][10] = 0.5f;// squish
   1c366:	edc3 7a23 	vstr	s15, [r3, #140]	; 0x8c
	defaultPresetKnobValues[VocoderCh][11] = 0.5f; // offset
   1c36a:	edc3 7a24 	vstr	s15, [r3, #144]	; 0x90
	defaultPresetKnobValues[VocoderCh][12] = 0.5f; // tilt
   1c36e:	edc3 7a25 	vstr	s15, [r3, #148]	; 0x94
	defaultPresetKnobValues[Pitchshift][0] = 0.5f; // pitch
   1c372:	edc3 7a32 	vstr	s15, [r3, #200]	; 0xc8
	defaultPresetKnobValues[Pitchshift][1] = 0.5f; // fine pitch
   1c376:	edc3 7a33 	vstr	s15, [r3, #204]	; 0xcc
	defaultPresetKnobValues[Pitchshift][3] = 0.5f; // formant
   1c37a:	edc3 7a35 	vstr	s15, [r3, #212]	; 0xd4
	defaultPresetKnobValues[Pitchshift][4] = 0.5f; //range
   1c37e:	edc3 7a36 	vstr	s15, [r3, #216]	; 0xd8
	defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
   1c382:	edc3 6a1b 	vstr	s13, [r3, #108]	; 0x6c
	defaultPresetKnobValues[Pitchshift][7] = 0.25f;
   1c386:	ed83 7a39 	vstr	s14, [r3, #228]	; 0xe4
	defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1c38a:	f8c3 92bc 	str.w	r9, [r3, #700]	; 0x2bc
	defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
   1c38e:	f203 5914 	addw	r9, r3, #1300	; 0x514
	defaultPresetKnobValues[SamplerButtonPress][4] = 0.4f;//crossfade
   1c392:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
	defaultPresetKnobValues[SamplerKeyboard][5] = 0.4f;//crossfade
   1c396:	f8c3 026c 	str.w	r0, [r3, #620]	; 0x26c
	defaultPresetKnobValues[Pitchshift][8] = 0.25f;
   1c39a:	ed83 7a3a 	vstr	s14, [r3, #232]	; 0xe8
	defaultPresetKnobValues[Pitchshift][9] = 0.25f;
   1c39e:	ed83 7a3b 	vstr	s14, [r3, #236]	; 0xec
	defaultPresetKnobValues[AutotuneMono][4] = 0.25f; // hysteresis
   1c3a2:	ed83 7a4f 	vstr	s14, [r3, #316]	; 0x13c
	defaultPresetKnobValues[SamplerAutoGrab][3] = 0.25f; // crossfade
   1c3a6:	ed83 7ab2 	vstr	s14, [r3, #712]	; 0x2c8
	defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1c3aa:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
	defaultPresetKnobValues[AutotuneMono][0] = 0.0f; // pickiness
   1c3ae:	f8c3 512c 	str.w	r5, [r3, #300]	; 0x12c
	defaultPresetKnobValues[AutotuneMono][1] = 1.0f; // amount
   1c3b2:	edc3 6a4c 	vstr	s13, [r3, #304]	; 0x130
	defaultPresetKnobValues[AutotuneMono][2] = 0.5f; // speed
   1c3b6:	edc3 7a4d 	vstr	s15, [r3, #308]	; 0x134
	defaultPresetKnobValues[AutotuneMono][3] = 1.0f; // leap allow
   1c3ba:	edc3 6a4e 	vstr	s13, [r3, #312]	; 0x138
	defaultPresetKnobValues[AutotunePoly][0] = 1.0f; // fidelity thresh
   1c3be:	edc3 6a64 	vstr	s13, [r3, #400]	; 0x190
	defaultPresetKnobValues[AutotunePoly][1] = 0.5f;
   1c3c2:	edc3 7a65 	vstr	s15, [r3, #404]	; 0x194
	defaultPresetKnobValues[AutotunePoly][3] = 0.0f;
   1c3c6:	f8c3 519c 	str.w	r5, [r3, #412]	; 0x19c
	defaultPresetKnobValues[AutotunePoly][4] = 0.0f;
   1c3ca:	f8c3 51a0 	str.w	r5, [r3, #416]	; 0x1a0
	defaultPresetKnobValues[SamplerButtonPress][0] = 0.0f; // start
   1c3ce:	f8c3 51f4 	str.w	r5, [r3, #500]	; 0x1f4
	defaultPresetKnobValues[SamplerButtonPress][1] = 1.0f; // end
   1c3d2:	edc3 6a7e 	vstr	s13, [r3, #504]	; 0x1f8
	defaultPresetKnobValues[SamplerButtonPress][3] = 0.5f; // speed mult
   1c3d6:	edc3 7a80 	vstr	s15, [r3, #512]	; 0x200
	defaultPresetKnobValues[SamplerKeyboard][0] = 0.0f; // start
   1c3da:	f8c3 5258 	str.w	r5, [r3, #600]	; 0x258
	defaultPresetKnobValues[SamplerKeyboard][1] = 1.0f; // end
   1c3de:	edc3 6a97 	vstr	s13, [r3, #604]	; 0x25c
	defaultPresetKnobValues[SamplerKeyboard][3] = 0.5f; // speed mult
   1c3e2:	edc3 7a99 	vstr	s15, [r3, #612]	; 0x264
	defaultPresetKnobValues[SamplerKeyboard][4] = 0.0f; //looping on
   1c3e6:	f8c3 5268 	str.w	r5, [r3, #616]	; 0x268
	defaultPresetKnobValues[SamplerKeyboard][6] = 0.0f;//velocity sensitivity
   1c3ea:	f8c3 5270 	str.w	r5, [r3, #624]	; 0x270
	defaultPresetKnobValues[SamplerAutoGrab][1] = 0.5f; // window
   1c3ee:	edc3 7ab0 	vstr	s15, [r3, #704]	; 0x2c0
	defaultPresetKnobValues[SamplerAutoGrab][4] = 0.0f;
   1c3f2:	f8c3 52cc 	str.w	r5, [r3, #716]	; 0x2cc
	defaultPresetKnobValues[SamplerAutoGrab][5] = 0.0f; // len rand
   1c3f6:	f8c3 52d0 	str.w	r5, [r3, #720]	; 0x2d0
	defaultPresetKnobValues[SamplerAutoGrab][6] = 0.0f; // speed rand
   1c3fa:	f8c3 52d4 	str.w	r5, [r3, #724]	; 0x2d4
	defaultPresetKnobValues[SamplerAutoGrab][7] = 0.0f;
   1c3fe:	f8c3 52d8 	str.w	r5, [r3, #728]	; 0x2d8
	defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
   1c402:	ed83 6a7f 	vstr	s12, [r3, #508]	; 0x1fc
	defaultPresetKnobValues[SamplerKeyboard][2] = 0.75f; // speed
   1c406:	ed83 6a98 	vstr	s12, [r3, #608]	; 0x260
	defaultPresetKnobValues[SamplerAutoGrab][2] = 0.75f; // speed
   1c40a:	ed83 6ab1 	vstr	s12, [r3, #708]	; 0x2c4
	defaultPresetKnobValues[SamplerAutoGrab][8] = 0.0f;
   1c40e:	f8c3 52dc 	str.w	r5, [r3, #732]	; 0x2dc
	defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
   1c412:	f8c9 c000 	str.w	ip, [r9]
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1c416:	f649 199a 	movw	r9, #39322	; 0x999a
	defaultPresetKnobValues[Wavefolder][0] = 0.4f; // gain
   1c41a:	f8c3 0384 	str.w	r0, [r3, #900]	; 0x384
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1c41e:	f6c3 7919 	movt	r9, #16153	; 0x3f19
	defaultPresetKnobValues[BitCrusher][0] = 0.1f; // quality
   1c422:	f8c3 23e8 	str.w	r2, [r3, #1000]	; 0x3e8
	defaultPresetKnobValues[Distortion][0] = .25f; // pre gain
   1c426:	ed83 7ac8 	vstr	s14, [r3, #800]	; 0x320
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1c42a:	f8cd 9004 	str.w	r9, [sp, #4]
	defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
   1c42e:	f203 494c 	addw	r9, r3, #1100	; 0x44c
	defaultPresetKnobValues[Distortion][4] = 0.25f; //post gain
   1c432:	ed83 7acc 	vstr	s14, [r3, #816]	; 0x330
	defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
   1c436:	ed89 7a00 	vstr	s14, [r9]
	defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
   1c43a:	f503 698a 	add.w	r9, r3, #1104	; 0x450
	defaultPresetKnobValues[SamplerAutoGrab][9] = 0.0f;
   1c43e:	f8c3 52e0 	str.w	r5, [r3, #736]	; 0x2e0
	defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
   1c442:	ed89 7a00 	vstr	s14, [r9]
	defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
   1c446:	f503 698b 	add.w	r9, r3, #1112	; 0x458
	defaultPresetKnobValues[Distortion][1] = 0.5f; // tilt (low and high shelves, opposing gains)
   1c44a:	edc3 7ac9 	vstr	s15, [r3, #804]	; 0x324
	defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
   1c44e:	edc9 6a00 	vstr	s13, [r9]
	defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
   1c452:	f203 495c 	addw	r9, r3, #1116	; 0x45c
	defaultPresetKnobValues[Distortion][2] = 0.5f; // mid gain
   1c456:	edc3 7aca 	vstr	s15, [r3, #808]	; 0x328
	defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
   1c45a:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
   1c45e:	f503 698c 	add.w	r9, r3, #1120	; 0x460
	defaultPresetKnobValues[Distortion][3] = 0.5f; // mid freq
   1c462:	edc3 7acb 	vstr	s15, [r3, #812]	; 0x32c
	defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
   1c466:	edc9 6a00 	vstr	s13, [r9]
	defaultPresetKnobValues[Reverb][0] = 0.5f; // size
   1c46a:	f503 6996 	add.w	r9, r3, #1200	; 0x4b0
	defaultPresetKnobValues[Wavefolder][1] = 0.5f; // offset1
   1c46e:	edc3 7ae2 	vstr	s15, [r3, #904]	; 0x388
	defaultPresetKnobValues[Reverb][0] = 0.5f; // size
   1c472:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
   1c476:	f203 49b4 	addw	r9, r3, #1204	; 0x4b4
	defaultPresetKnobValues[Wavefolder][2] = 0.5f; // offset2
   1c47a:	edc3 7ae3 	vstr	s15, [r3, #908]	; 0x38c
	defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
   1c47e:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
   1c482:	f503 6997 	add.w	r9, r3, #1208	; 0x4b8
	defaultPresetKnobValues[Wavefolder][3] = 0.75f; // post gain
   1c486:	ed83 6ae4 	vstr	s12, [r3, #912]	; 0x390
	defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
   1c48a:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
   1c48e:	f203 49bc 	addw	r9, r3, #1212	; 0x4bc
	defaultPresetKnobValues[Wavefolder][4] = 0.0f;
   1c492:	f8c3 5394 	str.w	r5, [r3, #916]	; 0x394
	defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
   1c496:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
   1c49a:	f503 6998 	add.w	r9, r3, #1216	; 0x4c0
	defaultPresetKnobValues[BitCrusher][1] = 0.5f; // samp ratio
   1c49e:	edc3 7afb 	vstr	s15, [r3, #1004]	; 0x3ec
	defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
   1c4a2:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
   1c4a6:	f503 69a3 	add.w	r9, r3, #1304	; 0x518
	defaultPresetKnobValues[BitCrusher][2] = 0.0f; // rounding
   1c4aa:	f8c3 53f0 	str.w	r5, [r3, #1008]	; 0x3f0
	defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
   1c4ae:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
   1c4b2:	f203 591c 	addw	r9, r3, #1308	; 0x51c
	defaultPresetKnobValues[BitCrusher][3] = 0.0f; // operation
   1c4b6:	f8c3 53f4 	str.w	r5, [r3, #1012]	; 0x3f4
	defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
   1c4ba:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
   1c4be:	f503 69a4 	add.w	r9, r3, #1312	; 0x520
	defaultPresetKnobValues[BitCrusher][4] = 0.5f; // post gain
   1c4c2:	edc3 7afe 	vstr	s15, [r3, #1016]	; 0x3f8
	defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
   1c4c6:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
   1c4ca:	f203 4954 	addw	r9, r3, #1108	; 0x454
	defaultPresetKnobValues[BitCrusher][5] = 0.0f; // pre gain
   1c4ce:	f8c3 53fc 	str.w	r5, [r3, #1020]	; 0x3fc
	defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
   1c4d2:	f8c9 5000 	str.w	r5, [r9]
	defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
   1c4d6:	f203 5924 	addw	r9, r3, #1316	; 0x524
   1c4da:	edc9 7a00 	vstr	s15, [r9]
	defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
   1c4de:	f203 59ec 	addw	r9, r3, #1516	; 0x5ec
   1c4e2:	f8c9 0000 	str.w	r0, [r9]
	defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
   1c4e6:	f203 597c 	addw	r9, r3, #1404	; 0x57c
   1c4ea:	f8c9 2000 	str.w	r2, [r9]
	defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
   1c4ee:	f203 59e4 	addw	r9, r3, #1508	; 0x5e4
   1c4f2:	f8c9 8000 	str.w	r8, [r9]
	defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
   1c4f6:	f503 68c0 	add.w	r8, r3, #1536	; 0x600
	defaultPresetKnobValues[Rhodes][22] = 0.00f;
   1c4fa:	f203 69fc 	addw	r9, r3, #1788	; 0x6fc
	defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
   1c4fe:	f8c8 0000 	str.w	r0, [r8]
	defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
   1c502:	f503 68c9 	add.w	r8, r3, #1608	; 0x648
	defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1c506:	f243 3033 	movw	r0, #13107	; 0x3333
	defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
   1c50a:	f8c8 c000 	str.w	ip, [r8]
	defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
   1c50e:	f503 6cb1 	add.w	ip, r3, #1416	; 0x588
	defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1c512:	f6c3 7033 	movt	r0, #16179	; 0x3f33
   1c516:	f503 68dd 	add.w	r8, r3, #1768	; 0x6e8
	defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
   1c51a:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
   1c51e:	f203 5c8c 	addw	ip, r3, #1420	; 0x58c
   1c522:	ed8c 7a00 	vstr	s14, [ip]
	defaultPresetKnobValues[LivingString][9] = 0.5f;
   1c526:	f203 5c9c 	addw	ip, r3, #1436	; 0x59c
   1c52a:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
   1c52e:	f203 5cdc 	addw	ip, r3, #1500	; 0x5dc
   1c532:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
   1c536:	f503 6cbc 	add.w	ip, r3, #1504	; 0x5e0
   1c53a:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
   1c53e:	f503 6cbd 	add.w	ip, r3, #1512	; 0x5e8
   1c542:	edcc 6a00 	vstr	s13, [ip]
	defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
   1c546:	f503 6cbe 	add.w	ip, r3, #1520	; 0x5f0
   1c54a:	ed8c 7a00 	vstr	s14, [ip]
	defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
   1c54e:	f503 6cc8 	add.w	ip, r3, #1600	; 0x640
   1c552:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
   1c556:	f203 6c44 	addw	ip, r3, #1604	; 0x644
   1c55a:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1c55e:	f503 6caf 	add.w	ip, r3, #1400	; 0x578
   1c562:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
   1c566:	f503 6cb0 	add.w	ip, r3, #1408	; 0x580
   1c56a:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
   1c56e:	f503 6cb4 	add.w	ip, r3, #1440	; 0x5a0
   1c572:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
   1c576:	f203 5ca4 	addw	ip, r3, #1444	; 0x5a4
   1c57a:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
   1c57e:	f503 6cb5 	add.w	ip, r3, #1448	; 0x5a8
   1c582:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
   1c586:	f203 5cac 	addw	ip, r3, #1452	; 0x5ac
   1c58a:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
   1c58e:	f503 6cb6 	add.w	ip, r3, #1456	; 0x5b0
   1c592:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
   1c596:	f203 5cfc 	addw	ip, r3, #1532	; 0x5fc
   1c59a:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1c59e:	f203 5184 	addw	r1, r3, #1412	; 0x584
	defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
   1c5a2:	f503 6cd1 	add.w	ip, r3, #1672	; 0x688
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1c5a6:	600e      	str	r6, [r1, #0]
	defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
   1c5a8:	f503 61b2 	add.w	r1, r3, #1424	; 0x590
   1c5ac:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
   1c5ae:	f203 5194 	addw	r1, r3, #1428	; 0x594
   1c5b2:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[LivingString][8] = 0.8f;
   1c5b4:	f503 61b3 	add.w	r1, r3, #1432	; 0x598
   1c5b8:	f8c1 e000 	str.w	lr, [r1]
	defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
   1c5bc:	f203 51f4 	addw	r1, r3, #1524	; 0x5f4
   1c5c0:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
   1c5c2:	f503 61bf 	add.w	r1, r3, #1528	; 0x5f8
   1c5c6:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
   1c5c8:	f203 614c 	addw	r1, r3, #1612	; 0x64c
   1c5cc:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
   1c5ce:	f503 61ca 	add.w	r1, r3, #1616	; 0x650
   1c5d2:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
   1c5d4:	f203 6154 	addw	r1, r3, #1620	; 0x654
   1c5d8:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1c5da:	f503 61cb 	add.w	r1, r3, #1624	; 0x658
   1c5de:	f8c1 b000 	str.w	fp, [r1]
	defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
   1c5e2:	f203 615c 	addw	r1, r3, #1628	; 0x65c
	defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
   1c5e6:	f8cc 2000 	str.w	r2, [ip]
	defaultPresetKnobValues[Rhodes][7] = 0.9f;
   1c5ea:	f503 6cd8 	add.w	ip, r3, #1728	; 0x6c0
	defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
   1c5ee:	600e      	str	r6, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
   1c5f0:	f503 61cc 	add.w	r1, r3, #1632	; 0x660
	defaultPresetKnobValues[Rhodes][7] = 0.9f;
   1c5f4:	f8cc 6000 	str.w	r6, [ip]
	defaultPresetKnobValues[Rhodes][18] = 0.5f;
   1c5f8:	f203 6cec 	addw	ip, r3, #1772	; 0x6ec
	defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
   1c5fc:	600a      	str	r2, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
   1c5fe:	f203 6164 	addw	r1, r3, #1636	; 0x664
	defaultPresetKnobValues[Rhodes][18] = 0.5f;
   1c602:	edcc 7a00 	vstr	s15, [ip]
	defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
   1c606:	f203 6cb4 	addw	ip, r3, #1716	; 0x6b4
	defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
   1c60a:	600a      	str	r2, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
   1c60c:	f203 616c 	addw	r1, r3, #1644	; 0x66c
	defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
   1c610:	f8cc 5000 	str.w	r5, [ip]
	defaultPresetKnobValues[Rhodes][11] = 0.05f;
   1c614:	f503 6cda 	add.w	ip, r3, #1744	; 0x6d0
	defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
   1c618:	f8c1 b000 	str.w	fp, [r1]
	defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
   1c61c:	f503 61ce 	add.w	r1, r3, #1648	; 0x670
	defaultPresetKnobValues[Rhodes][11] = 0.05f;
   1c620:	f8cc 7000 	str.w	r7, [ip]
	defaultPresetKnobValues[Rhodes][21] = 0.0f;
   1c624:	f503 6cdf 	add.w	ip, r3, #1784	; 0x6f8
	defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
   1c628:	600e      	str	r6, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
   1c62a:	f203 6174 	addw	r1, r3, #1652	; 0x674
   1c62e:	600a      	str	r2, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
   1c630:	f503 61cf 	add.w	r1, r3, #1656	; 0x678
   1c634:	600a      	str	r2, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
   1c636:	f503 61d0 	add.w	r1, r3, #1664	; 0x680
   1c63a:	f8c1 b000 	str.w	fp, [r1]
	defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
   1c63e:	f203 6184 	addw	r1, r3, #1668	; 0x684
   1c642:	600e      	str	r6, [r1, #0]
	defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
   1c644:	f203 618c 	addw	r1, r3, #1676	; 0x68c
   1c648:	600a      	str	r2, [r1, #0]
	defaultPresetKnobValues[Rhodes][12] = 0.9f;
   1c64a:	f203 61d4 	addw	r1, r3, #1748	; 0x6d4
	defaultPresetKnobValues[Rhodes][15] = 0.8f;
   1c64e:	f503 62dc 	add.w	r2, r3, #1760	; 0x6e0
	defaultPresetKnobValues[Rhodes][12] = 0.9f;
   1c652:	600e      	str	r6, [r1, #0]
	defaultPresetKnobValues[Rhodes][0] = 0.25f;
   1c654:	f203 66a4 	addw	r6, r3, #1700	; 0x6a4
	defaultPresetKnobValues[Rhodes][15] = 0.8f;
   1c658:	f8c2 e000 	str.w	lr, [r2]
	defaultPresetKnobValues[Rhodes][1] = 0.25f;
   1c65c:	f503 61d5 	add.w	r1, r3, #1704	; 0x6a8
	defaultPresetKnobValues[Rhodes][2] = 0.25f;
   1c660:	f203 62ac 	addw	r2, r3, #1708	; 0x6ac
	defaultPresetKnobValues[Rhodes][0] = 0.25f;
   1c664:	ed86 7a00 	vstr	s14, [r6]
	defaultPresetKnobValues[Rhodes][1] = 0.25f;
   1c668:	ed81 7a00 	vstr	s14, [r1]
	defaultPresetKnobValues[Rhodes][3] = 0.5f;
   1c66c:	f503 66d6 	add.w	r6, r3, #1712	; 0x6b0
	defaultPresetKnobValues[Rhodes][2] = 0.25f;
   1c670:	ed82 7a00 	vstr	s14, [r2]
	defaultPresetKnobValues[Rhodes][9] = 0.5f;
   1c674:	f503 61d9 	add.w	r1, r3, #1736	; 0x6c8
	defaultPresetKnobValues[Rhodes][14] = 0.5f;
   1c678:	f203 62dc 	addw	r2, r3, #1756	; 0x6dc
	defaultPresetKnobValues[Rhodes][3] = 0.5f;
   1c67c:	edc6 7a00 	vstr	s15, [r6]
	defaultPresetKnobValues[Rhodes][9] = 0.5f;
   1c680:	edc1 7a00 	vstr	s15, [r1]
	defaultPresetKnobValues[Rhodes][19] = 0.5f;
   1c684:	f503 66de 	add.w	r6, r3, #1776	; 0x6f0
	defaultPresetKnobValues[Rhodes][14] = 0.5f;
   1c688:	edc2 7a00 	vstr	s15, [r2]
	defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
   1c68c:	f503 61cd 	add.w	r1, r3, #1640	; 0x668
	defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
   1c690:	f203 627c 	addw	r2, r3, #1660	; 0x67c
	defaultPresetKnobValues[Rhodes][19] = 0.5f;
   1c694:	edc6 7a00 	vstr	s15, [r6]
	defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
   1c698:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1c69a:	f503 66d7 	add.w	r6, r3, #1720	; 0x6b8
	defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
   1c69e:	6015      	str	r5, [r2, #0]
	defaultPresetKnobValues[Rhodes][6] = 0.05f;
   1c6a0:	f203 61bc 	addw	r1, r3, #1724	; 0x6bc
	defaultPresetKnobValues[Rhodes][10] = 0.05f;
   1c6a4:	f203 62cc 	addw	r2, r3, #1740	; 0x6cc
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1c6a8:	6037      	str	r7, [r6, #0]
	defaultPresetKnobValues[Rhodes][6] = 0.05f;
   1c6aa:	600f      	str	r7, [r1, #0]
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1c6ac:	f203 66c4 	addw	r6, r3, #1732	; 0x6c4
	defaultPresetKnobValues[Rhodes][10] = 0.05f;
   1c6b0:	6017      	str	r7, [r2, #0]
	defaultPresetKnobValues[Rhodes][13] = 0.1007f;
   1c6b2:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1c6b6:	f203 62e4 	addw	r2, r3, #1764	; 0x6e4
   1c6ba:	ed9d 7a01 	vldr	s14, [sp, #4]
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1c6be:	f8c6 a000 	str.w	sl, [r6]
	defaultPresetKnobValues[Rhodes][20] = 0.5f;
   1c6c2:	f203 6ef4 	addw	lr, r3, #1780	; 0x6f4
	defaultPresetKnobValues[Rhodes][13] = 0.1007f;
   1c6c6:	f8c1 a000 	str.w	sl, [r1]
   1c6ca:	461e      	mov	r6, r3
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1c6cc:	ed82 7a00 	vstr	s14, [r2]
	defaultPresetKnobValues[Rhodes][23] = 0.00f;
   1c6d0:	f503 61e0 	add.w	r1, r3, #1792	; 0x700
	defaultPresetKnobValues[Rhodes][24] = 0.00f;
   1c6d4:	f203 7204 	addw	r2, r3, #1796	; 0x704
   1c6d8:	f504 67e1 	add.w	r7, r4, #1800	; 0x708
	defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1c6dc:	f8c8 0000 	str.w	r0, [r8]
	defaultPresetKnobValues[Rhodes][20] = 0.5f;
   1c6e0:	edce 7a00 	vstr	s15, [lr]
	defaultPresetKnobValues[Rhodes][21] = 0.0f;
   1c6e4:	f8cc 5000 	str.w	r5, [ip]
	defaultPresetKnobValues[Rhodes][22] = 0.00f;
   1c6e8:	f8c9 5000 	str.w	r5, [r9]
	defaultPresetKnobValues[Rhodes][23] = 0.00f;
   1c6ec:	600d      	str	r5, [r1, #0]
	defaultPresetKnobValues[Rhodes][24] = 0.00f;
   1c6ee:	6015      	str	r5, [r2, #0]
   1c6f0:	4620      	mov	r0, r4
   1c6f2:	3464      	adds	r4, #100	; 0x64
   1c6f4:	4631      	mov	r1, r6
   1c6f6:	2264      	movs	r2, #100	; 0x64
   1c6f8:	f013 fd50 	bl	3019c <memcpy>
	for (int p = 0; p < PresetNil; p++)
   1c6fc:	42a7      	cmp	r7, r4
   1c6fe:	f106 0664 	add.w	r6, r6, #100	; 0x64
   1c702:	d1f5      	bne.n	1c6f0 <initGlobalSFXObjects+0x5a0>
}
   1c704:	b003      	add	sp, #12
   1c706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c70a:	bf00      	nop

0001c70c <SFXVocoderAlloc>:
{
   1c70c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	leaf.clearOnAllocation = 1;
   1c710:	f64f 0308 	movw	r3, #63496	; 0xf808
	tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1c714:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c718:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
	leaf.clearOnAllocation = 1;
   1c71c:	2401      	movs	r4, #1
   1c71e:	f2c0 230f 	movt	r3, #527	; 0x20f
	tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1c722:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c726:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1c72a:	f2c0 200f 	movt	r0, #527	; 0x20f
	tSimplePoly_setNumVoices(&poly, numVoices);
   1c72e:	f246 2954 	movw	r9, #25172	; 0x6254
   1c732:	f24d 687c 	movw	r8, #54908	; 0xd67c
   1c736:	f24c 57b0 	movw	r7, #50608	; 0xc5b0
		tSawtooth_initToPool(&osc[i], &smallPool);
   1c73a:	f64a 6690 	movw	r6, #44688	; 0xae90
	tSimplePoly_setNumVoices(&poly, numVoices);
   1c73e:	f2c0 0906 	movt	r9, #6
   1c742:	f2c0 280f 	movt	r8, #527	; 0x20f
   1c746:	f2c0 270f 	movt	r7, #527	; 0x20f
		tSawtooth_initToPool(&osc[i], &smallPool);
   1c74a:	f2c0 260f 	movt	r6, #527	; 0x20f
{
   1c74e:	ed2d 8b02 	vpush	{d8}
	leaf.clearOnAllocation = 1;
   1c752:	615c      	str	r4, [r3, #20]
	tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1c754:	f00c fd88 	bl	29268 <tTalkboxFloat_initToPool>
	tTalkboxFloat_setWarpOn(&vocoder, 1);
   1c758:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
   1c75c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
	tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
   1c760:	2400      	movs	r4, #0
	tTalkboxFloat_setWarpOn(&vocoder, 1);
   1c762:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c766:	f00d f83f 	bl	297e8 <tTalkboxFloat_setWarpOn>
	tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1c76a:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c76e:	f24d 10cc 	movw	r0, #53708	; 0xd1cc
   1c772:	2100      	movs	r1, #0
   1c774:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c778:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c77c:	f011 fb24 	bl	2ddc8 <tNoise_initToPool>
	tZeroCrossing_initToPool(&zerox, 16, &smallPool);
   1c780:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c784:	f64d 202c 	movw	r0, #55852	; 0xda2c
   1c788:	2110      	movs	r1, #16
   1c78a:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c78e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c792:	f00a ff83 	bl	2769c <tZeroCrossing_initToPool>
	tSimplePoly_setNumVoices(&poly, numVoices);
   1c796:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1c79a:	f899 1000 	ldrb.w	r1, [r9]
   1c79e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c7a2:	f011 f999 	bl	2dad8 <tSimplePoly_setNumVoices>
	tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.005f, &smallPool);
   1c7a6:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1c7aa:	2200      	movs	r2, #0
   1c7ac:	f64a 6190 	movw	r1, #44688	; 0xae90
   1c7b0:	f6c3 33a3 	movt	r3, #15267	; 0x3ba3
   1c7b4:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
   1c7b8:	ee00 2a10 	vmov	s0, r2
   1c7bc:	f2c0 210f 	movt	r1, #527	; 0x20f
   1c7c0:	ee00 3a90 	vmov	s1, r3
   1c7c4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c7c8:	f00e fdba 	bl	2b340 <tExpSmooth_initToPool>
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1c7cc:	2300      	movs	r3, #0
   1c7ce:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c7d2:	f64d 009c 	movw	r0, #55452	; 0xd89c
   1c7d6:	f2c4 23a0 	movt	r3, #17056	; 0x42a0
   1c7da:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1c7de:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c7e2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c7e6:	ee00 3a10 	vmov	s0, r3
   1c7ea:	2106      	movs	r1, #6
   1c7ec:	f00f f946 	bl	2ba7c <tVZFilter_initToPool>
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1c7f0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   1c7f4:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c7f8:	f24d 70c4 	movw	r0, #55236	; 0xd7c4
   1c7fc:	f2c4 633b 	movt	r3, #17979	; 0x463b
   1c800:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1c804:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c808:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c80c:	ee00 3a10 	vmov	s0, r3
   1c810:	2107      	movs	r1, #7
   1c812:	f00f f933 	bl	2ba7c <tVZFilter_initToPool>
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1c816:	f64a 6290 	movw	r2, #44688	; 0xae90
   1c81a:	f24c 5080 	movw	r0, #50560	; 0xc580
   1c81e:	2100      	movs	r1, #0
   1c820:	f2c0 220f 	movt	r2, #527	; 0x20f
   1c824:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c828:	f011 face 	bl	2ddc8 <tNoise_initToPool>
	tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
   1c82c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
   1c830:	f64a 6190 	movw	r1, #44688	; 0xae90
   1c834:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
   1c838:	f2c4 538c 	movt	r3, #17804	; 0x458c
   1c83c:	f2c0 210f 	movt	r1, #527	; 0x20f
   1c840:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c844:	ee00 3a10 	vmov	s0, r3
   1c848:	f00f f8d2 	bl	2b9f0 <tHighpass_initToPool>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1c84c:	f64c 42cd 	movw	r2, #52429	; 0xcccd
   1c850:	f649 139a 	movw	r3, #39322	; 0x999a
   1c854:	f6c3 62cc 	movt	r2, #16076	; 0x3ecc
   1c858:	f6c3 6399 	movt	r3, #16025	; 0x3e99
   1c85c:	ee08 2a90 	vmov	s17, r2
   1c860:	ee08 3a10 	vmov	s16, r3
   1c864:	193d      	adds	r5, r7, r4
		tSawtooth_initToPool(&osc[i], &smallPool);
   1c866:	eb08 0004 	add.w	r0, r8, r4
   1c86a:	4631      	mov	r1, r6
   1c86c:	3404      	adds	r4, #4
   1c86e:	f011 f9f3 	bl	2dc58 <tSawtooth_initToPool>
		tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
   1c872:	4628      	mov	r0, r5
   1c874:	4631      	mov	r1, r6
   1c876:	f00c ffc3 	bl	29800 <tRosenbergGlottalPulse_initToPool>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1c87a:	eef0 0a68 	vmov.f32	s1, s17
   1c87e:	eeb0 0a48 	vmov.f32	s0, s16
   1c882:	4628      	mov	r0, r5
   1c884:	f00d f8de 	bl	29a44 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1c888:	2c20      	cmp	r4, #32
   1c88a:	d1eb      	bne.n	1c864 <SFXVocoderAlloc+0x158>
	setLED_A(numVoices == 1);
   1c88c:	f899 0000 	ldrb.w	r0, [r9]
   1c890:	f1a0 0001 	sub.w	r0, r0, #1
   1c894:	fab0 f080 	clz	r0, r0
   1c898:	0940      	lsrs	r0, r0, #5
   1c89a:	f7fe fc4b 	bl	1b134 <setLED_A>
	setLED_B(internalExternal);
   1c89e:	f646 1304 	movw	r3, #26884	; 0x6904
   1c8a2:	f2c0 230e 	movt	r3, #526	; 0x20e
   1c8a6:	7818      	ldrb	r0, [r3, #0]
   1c8a8:	f7fe fc54 	bl	1b154 <setLED_B>
	vocFreezeLPC = 0;
   1c8ac:	f646 137c 	movw	r3, #27004	; 0x697c
   1c8b0:	2200      	movs	r2, #0
   1c8b2:	f2c0 230e 	movt	r3, #526	; 0x20e
	setLED_C(vocFreezeLPC);
   1c8b6:	4610      	mov	r0, r2
	vocFreezeLPC = 0;
   1c8b8:	601a      	str	r2, [r3, #0]
}
   1c8ba:	ecbd 8b02 	vpop	{d8}
   1c8be:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	setLED_C(vocFreezeLPC);
   1c8c2:	f7fe bc57 	b.w	1b174 <setLED_C>
   1c8c6:	bf00      	nop

0001c8c8 <SFXVocoderFrame>:
{
   1c8c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1c8cc:	f64e 247c 	movw	r4, #60028	; 0xea7c
   1c8d0:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   1c8d4:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1c8d8:	7d23      	ldrb	r3, [r4, #20]
   1c8da:	2b01      	cmp	r3, #1
   1c8dc:	d119      	bne.n	1c912 <SFXVocoderFrame+0x4a>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1c8de:	f246 2554 	movw	r5, #25172	; 0x6254
		tSimplePoly_setNumVoices(&poly, numVoices);
   1c8e2:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1c8e6:	f2c0 0506 	movt	r5, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   1c8ea:	f2c0 200f 	movt	r0, #527	; 0x20f
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1c8ee:	782a      	ldrb	r2, [r5, #0]
   1c8f0:	2a01      	cmp	r2, #1
   1c8f2:	bf98      	it	ls
   1c8f4:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   1c8f6:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1c8f8:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   1c8fa:	f011 f8ed 	bl	2dad8 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   1c8fe:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c900:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   1c902:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c906:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   1c908:	fab0 f080 	clz	r0, r0
   1c90c:	0940      	lsrs	r0, r0, #5
   1c90e:	f7fe fc11 	bl	1b134 <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1c912:	7e23      	ldrb	r3, [r4, #24]
   1c914:	2b01      	cmp	r3, #1
   1c916:	f000 8129 	beq.w	1cb6c <SFXVocoderFrame+0x2a4>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1c91a:	7f23      	ldrb	r3, [r4, #28]
   1c91c:	2b01      	cmp	r3, #1
   1c91e:	f000 810c 	beq.w	1cb3a <SFXVocoderFrame+0x272>
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1c922:	f64c 40cd 	movw	r0, #52429	; 0xcccd
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1c926:	f64c 2378 	movw	r3, #51832	; 0xca78
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1c92a:	eef3 5a0e 	vmov.f32	s11, #62	; 0x41f00000  30.0
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1c92e:	f64e 352c 	movw	r5, #60204	; 0xeb2c
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1c932:	4602      	mov	r2, r0
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1c934:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1c938:	4601      	mov	r1, r0
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1c93a:	f6c3 60cc 	movt	r0, #16076	; 0x3ecc
   1c93e:	f6cb 624c 	movt	r2, #48716	; 0xbe4c
   1c942:	ed93 6a01 	vldr	s12, [r3, #4]
   1c946:	ee07 0a10 	vmov	s14, r0
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1c94a:	eefa 6a0e 	vmov.f32	s13, #174	; 0xc1700000 -15.0
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1c94e:	ee07 2a90 	vmov	s15, r2
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1c952:	ed93 5a06 	vldr	s10, [r3, #24]
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1c956:	f6c3 718c 	movt	r1, #16268	; 0x3f8c
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1c95a:	f2c0 250f 	movt	r5, #527	; 0x20f
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1c95e:	eee6 7a07 	vfma.f32	s15, s12, s14
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1c962:	ed93 6a02 	vldr	s12, [r3, #8]
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1c966:	eee5 6a25 	vfma.f32	s13, s10, s11
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1c96a:	ee07 1a10 	vmov	s14, r1
	displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
   1c96e:	68da      	ldr	r2, [r3, #12]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1c970:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1c974:	ee26 7a07 	vmul.f32	s14, s12, s14
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1c978:	681e      	ldr	r6, [r3, #0]
	displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
   1c97a:	691c      	ldr	r4, [r3, #16]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1c97c:	f2c0 200f 	movt	r0, #527	; 0x20f
	displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
   1c980:	6959      	ldr	r1, [r3, #20]
   1c982:	f24d 17a4 	movw	r7, #53668	; 0xd1a4
	displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
   1c986:	60ea      	str	r2, [r5, #12]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1c988:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
   1c98c:	69da      	ldr	r2, [r3, #28]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c98e:	f64a 28ab 	movw	r8, #43691	; 0xaaab
	displayValues[8] = presetKnobValues[Vocoder][8]; //open length
   1c992:	6a1b      	ldr	r3, [r3, #32]
   1c994:	f2c0 270f 	movt	r7, #527	; 0x20f
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1c998:	edc5 7a01 	vstr	s15, [r5, #4]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c99c:	f6c2 28aa 	movt	r8, #10922	; 0x2aaa
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1c9a0:	602e      	str	r6, [r5, #0]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1c9a2:	f64d 06bc 	movw	r6, #55484	; 0xd8bc
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1c9a6:	ed85 7a02 	vstr	s14, [r5, #8]
	displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
   1c9aa:	612c      	str	r4, [r5, #16]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1c9ac:	2400      	movs	r4, #0
	displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
   1c9ae:	6169      	str	r1, [r5, #20]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1c9b0:	f2c0 260f 	movt	r6, #527	; 0x20f
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1c9b4:	edc5 6a06 	vstr	s13, [r5, #24]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1c9b8:	46a1      	mov	r9, r4
	displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
   1c9ba:	61ea      	str	r2, [r5, #28]
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c9bc:	ee08 4a10 	vmov	s16, r4
	displayValues[8] = presetKnobValues[Vocoder][8]; //open length
   1c9c0:	622b      	str	r3, [r5, #32]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1c9c2:	f00c ff0d 	bl	297e0 <tTalkboxFloat_setWarpFactor>
	tTalkboxFloat_setQuality(&vocoder, displayValues[2]);
   1c9c6:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
   1c9ca:	ed95 0a02 	vldr	s0, [r5, #8]
   1c9ce:	f2c0 200f 	movt	r0, #527	; 0x20f
   1c9d2:	f00c fee3 	bl	2979c <tTalkboxFloat_setQuality>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1c9d6:	e060      	b.n	1ca9a <SFXVocoderFrame+0x1d2>
   1c9d8:	eb04 0b03 	add.w	fp, r4, r3
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c9dc:	f011 f8ac 	bl	2db38 <tSimplePoly_getVelocity>
   1c9e0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c9e4:	2800      	cmp	r0, #0
   1c9e6:	4658      	mov	r0, fp
   1c9e8:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1c9ec:	f00e fce4 	bl	2b3b8 <tExpSmooth_setDest>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c9f0:	4651      	mov	r1, sl
   1c9f2:	4630      	mov	r0, r6
   1c9f4:	f011 f894 	bl	2db20 <tSimplePoly_getPitch>
   1c9f8:	f646 1240 	movw	r2, #26944	; 0x6940
   1c9fc:	ee07 0a90 	vmov	s15, r0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ca00:	f646 13b8 	movw	r3, #27064	; 0x69b8
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1ca04:	f2c0 220e 	movt	r2, #526	; 0x20e
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1ca08:	f646 1184 	movw	r1, #27012	; 0x6984
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1ca0c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ca10:	f2c0 230e 	movt	r3, #526	; 0x20e
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1ca14:	ed92 0a00 	vldr	s0, [r2]
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1ca18:	f2c0 210e 	movt	r1, #526	; 0x20e
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ca1c:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1ca1e:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ca22:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1ca26:	ee17 3a90 	vmov	r3, s15
   1ca2a:	1a9b      	subs	r3, r3, r2
   1ca2c:	fb88 2003 	smull	r2, r0, r8, r3
   1ca30:	17da      	asrs	r2, r3, #31
   1ca32:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1ca36:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1ca3a:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1ca3e:	ee07 3a90 	vmov	s15, r3
   1ca42:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1ca46:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1ca4a:	ee17 3a90 	vmov	r3, s15
   1ca4e:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   1ca52:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1ca56:	ee37 0a00 	vadd.f32	s0, s14, s0
   1ca5a:	f010 faa9 	bl	2cfb0 <LEAF_midiToFrequency>
		tSawtooth_setFreq(&osc[i], freq[i]);
   1ca5e:	f24d 607c 	movw	r0, #54908	; 0xd67c
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1ca62:	ed87 0a00 	vstr	s0, [r7]
		tSawtooth_setFreq(&osc[i], freq[i]);
   1ca66:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ca6a:	4420      	add	r0, r4
   1ca6c:	f011 f91e 	bl	2dcac <tSawtooth_setFreq>
   1ca70:	f24c 50b0 	movw	r0, #50608	; 0xc5b0
		tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
   1ca74:	ecb7 0a01 	vldmia	r7!, {s0}
   1ca78:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ca7c:	eb04 0a00 	add.w	sl, r4, r0
   1ca80:	3404      	adds	r4, #4
   1ca82:	4650      	mov	r0, sl
   1ca84:	f00c ffb4 	bl	299f0 <tRosenbergGlottalPulse_setFreq>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[8] * displayValues[7], displayValues[7]);
   1ca88:	edd5 0a07 	vldr	s1, [r5, #28]
   1ca8c:	ed95 0a08 	vldr	s0, [r5, #32]
   1ca90:	4650      	mov	r0, sl
   1ca92:	ee20 0a80 	vmul.f32	s0, s1, s0
   1ca96:	f00c ffd5 	bl	29a44 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ca9a:	4630      	mov	r0, r6
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1ca9c:	fa5f fa89 	uxtb.w	sl, r9
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1caa0:	f011 f822 	bl	2dae8 <tSimplePoly_getNumVoices>
   1caa4:	f64d 43b8 	movw	r3, #56504	; 0xdcb8
   1caa8:	4548      	cmp	r0, r9
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1caaa:	4651      	mov	r1, sl
   1caac:	f2c0 230f 	movt	r3, #527	; 0x20f
   1cab0:	4630      	mov	r0, r6
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cab2:	f109 0901 	add.w	r9, r9, #1
   1cab6:	dc8f      	bgt.n	1c9d8 <SFXVocoderFrame+0x110>
	if (tSimplePoly_getNumActiveVoices(&poly) != 0)
   1cab8:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1cabc:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cac0:	f011 f816 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
   1cac4:	bb10      	cbnz	r0, 1cb0c <SFXVocoderFrame+0x244>
		tExpSmooth_setDest(&comp, 0.0f);
   1cac6:	2300      	movs	r3, #0
   1cac8:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1cacc:	ee00 3a10 	vmov	s0, r3
   1cad0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cad4:	f00e fc70 	bl	2b3b8 <tExpSmooth_setDest>
	tVZFilter_setGain(&shelf1, fasterdbtoa(-1.0f * displayValues[6]));
   1cad8:	ed95 0a06 	vldr	s0, [r5, #24]
   1cadc:	eeb1 0a40 	vneg.f32	s0, s0
   1cae0:	f010 fb5a 	bl	2d198 <fasterdbtoa>
   1cae4:	f64d 009c 	movw	r0, #55452	; 0xd89c
   1cae8:	f2c0 200f 	movt	r0, #527	; 0x20f
   1caec:	f00f fe40 	bl	2c770 <tVZFilter_setGain>
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1caf0:	ed95 0a06 	vldr	s0, [r5, #24]
   1caf4:	f010 fb46 	bl	2d184 <fastdbtoa>
   1caf8:	f24d 70c4 	movw	r0, #55236	; 0xd7c4
}
   1cafc:	ecbd 8b02 	vpop	{d8}
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1cb00:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   1cb04:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1cb08:	f00f be32 	b.w	2c770 <tVZFilter_setGain>
		tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
   1cb0c:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1cb10:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cb14:	f010 ffec 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
   1cb18:	ee07 0a90 	vmov	s15, r0
   1cb1c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1cb20:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1cb24:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1cb28:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cb2c:	ee87 0a27 	vdiv.f32	s0, s14, s15
   1cb30:	eeb1 0ac0 	vsqrt.f32	s0, s0
   1cb34:	f00e fc40 	bl	2b3b8 <tExpSmooth_setDest>
   1cb38:	e7ce      	b.n	1cad8 <SFXVocoderFrame+0x210>
		vocFreezeLPC = !vocFreezeLPC;
   1cb3a:	f646 157c 	movw	r5, #27004	; 0x697c
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1cb3e:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
		vocFreezeLPC = !vocFreezeLPC;
   1cb42:	f2c0 250e 	movt	r5, #526	; 0x20e
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1cb46:	f2c0 200f 	movt	r0, #527	; 0x20f
		vocFreezeLPC = !vocFreezeLPC;
   1cb4a:	682b      	ldr	r3, [r5, #0]
   1cb4c:	fab3 f383 	clz	r3, r3
   1cb50:	095b      	lsrs	r3, r3, #5
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1cb52:	ee07 3a90 	vmov	s15, r3
		vocFreezeLPC = !vocFreezeLPC;
   1cb56:	602b      	str	r3, [r5, #0]
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1cb58:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   1cb5c:	f00c fe4a 	bl	297f4 <tTalkboxFloat_setFreeze>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1cb60:	2300      	movs	r3, #0
		setLED_C(vocFreezeLPC);
   1cb62:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1cb64:	7723      	strb	r3, [r4, #28]
		setLED_C(vocFreezeLPC);
   1cb66:	f7fe fb05 	bl	1b174 <setLED_C>
   1cb6a:	e6da      	b.n	1c922 <SFXVocoderFrame+0x5a>
		internalExternal = !internalExternal;
   1cb6c:	f646 1204 	movw	r2, #26884	; 0x6904
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1cb70:	2300      	movs	r3, #0
		internalExternal = !internalExternal;
   1cb72:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1cb76:	7623      	strb	r3, [r4, #24]
		internalExternal = !internalExternal;
   1cb78:	7813      	ldrb	r3, [r2, #0]
   1cb7a:	fab3 f383 	clz	r3, r3
   1cb7e:	095b      	lsrs	r3, r3, #5
		setLED_B(internalExternal);
   1cb80:	4618      	mov	r0, r3
		internalExternal = !internalExternal;
   1cb82:	7013      	strb	r3, [r2, #0]
		setLED_B(internalExternal);
   1cb84:	f7fe fae6 	bl	1b154 <setLED_B>
   1cb88:	e6c7      	b.n	1c91a <SFXVocoderFrame+0x52>
   1cb8a:	bf00      	nop

0001cb8c <SFXVocoderTick>:
	if (internalExternal == 1)
   1cb8c:	f646 1304 	movw	r3, #26884	; 0x6904
   1cb90:	f2c0 230e 	movt	r3, #526	; 0x20e
{
   1cb94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1cb98:	ed2d 8b08 	vpush	{d8-d11}
	if (internalExternal == 1)
   1cb9c:	781b      	ldrb	r3, [r3, #0]
{
   1cb9e:	4682      	mov	sl, r0
   1cba0:	ed90 8a01 	vldr	s16, [r0, #4]
	if (internalExternal == 1)
   1cba4:	2b01      	cmp	r3, #1
   1cba6:	f000 80f4 	beq.w	1cd92 <SFXVocoderTick+0x206>
		zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1cbaa:	f64d 202c 	movw	r0, #55852	; 0xda2c
   1cbae:	eeb0 0a48 	vmov.f32	s0, s16
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1cbb2:	f64e 362c 	movw	r6, #60204	; 0xeb2c
		zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1cbb6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cbba:	f00a fda5 	bl	27708 <tZeroCrossing_tick>
		if (!vocChFreeze)
   1cbbe:	f646 1378 	movw	r3, #27000	; 0x6978
   1cbc2:	f2c0 230e 	movt	r3, #526	; 0x20e
   1cbc6:	681b      	ldr	r3, [r3, #0]
   1cbc8:	2b00      	cmp	r3, #0
   1cbca:	f000 80c1 	beq.w	1cd50 <SFXVocoderTick+0x1c4>
   1cbce:	f2c0 260f 	movt	r6, #527	; 0x20f
		noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1cbd2:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cbd6:	2500      	movs	r5, #0
   1cbd8:	f64d 09bc 	movw	r9, #55484	; 0xd8bc
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1cbdc:	f24d 687c 	movw	r8, #54908	; 0xd67c
		noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1cbe0:	f2c0 200f 	movt	r0, #527	; 0x20f
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cbe4:	462f      	mov	r7, r5
		noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1cbe6:	f00e fbf1 	bl	2b3cc <tExpSmooth_tick>
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1cbea:	f24d 10cc 	movw	r0, #53708	; 0xd1cc
		noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1cbee:	eeb0 ba40 	vmov.f32	s22, s0
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cbf2:	f2c0 290f 	movt	r9, #527	; 0x20f
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1cbf6:	f2c0 200f 	movt	r0, #527	; 0x20f
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1cbfa:	f2c0 280f 	movt	r8, #527	; 0x20f
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1cbfe:	f011 f8f9 	bl	2ddf4 <tNoise_tick>
   1cc02:	f649 139a 	movw	r3, #39322	; 0x999a
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1cc06:	f243 3233 	movw	r2, #13107	; 0x3333
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1cc0a:	ee20 0a0b 	vmul.f32	s0, s0, s22
   1cc0e:	f6c3 7319 	movt	r3, #16153	; 0x3f19
	float sample = 0.0f;
   1cc12:	ee09 5a10 	vmov	s18, r5
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1cc16:	f6c3 72f3 	movt	r2, #16371	; 0x3ff3
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1cc1a:	ee07 3a90 	vmov	s15, r3
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1cc1e:	ee0a 2a90 	vmov	s21, r2
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1cc22:	ee20 aa27 	vmul.f32	s20, s0, s15
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cc26:	e02c      	b.n	1cc82 <SFXVocoderTick+0xf6>
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1cc28:	f011 f874 	bl	2dd14 <tSawtooth_tick>
   1cc2c:	f64d 40b8 	movw	r0, #56504	; 0xdcb8
   1cc30:	eef0 8a40 	vmov.f32	s17, s0
   1cc34:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cc38:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   1cc3c:	182c      	adds	r4, r5, r0
   1cc3e:	4620      	mov	r0, r4
   1cc40:	f00e fbc4 	bl	2b3cc <tExpSmooth_tick>
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1cc44:	f24c 50b0 	movw	r0, #50608	; 0xc5b0
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1cc48:	edd6 7a03 	vldr	s15, [r6, #12]
   1cc4c:	ee68 8a80 	vmul.f32	s17, s17, s0
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1cc50:	f2c0 200f 	movt	r0, #527	; 0x20f
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1cc54:	ee38 8a67 	vsub.f32	s16, s16, s15
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1cc58:	4428      	add	r0, r5
   1cc5a:	3504      	adds	r5, #4
   1cc5c:	f00c fe54 	bl	29908 <tRosenbergGlottalPulse_tickHQ>
   1cc60:	4620      	mov	r0, r4
   1cc62:	eef0 9a40 	vmov.f32	s19, s0
   1cc66:	f00e fbb1 	bl	2b3cc <tExpSmooth_tick>
   1cc6a:	edd6 7a03 	vldr	s15, [r6, #12]
   1cc6e:	ee67 7aaa 	vmul.f32	s15, s15, s21
   1cc72:	ee67 7aa9 	vmul.f32	s15, s15, s19
   1cc76:	ee27 0a80 	vmul.f32	s0, s15, s0
   1cc7a:	eea8 0a88 	vfma.f32	s0, s17, s16
   1cc7e:	ee39 9a00 	vadd.f32	s18, s18, s0
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cc82:	4648      	mov	r0, r9
   1cc84:	f010 ff30 	bl	2dae8 <tSimplePoly_getNumVoices>
   1cc88:	42b8      	cmp	r0, r7
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1cc8a:	eb08 0005 	add.w	r0, r8, r5
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1cc8e:	f107 0701 	add.w	r7, r7, #1
   1cc92:	dcc9      	bgt.n	1cc28 <SFXVocoderTick+0x9c>
		sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1cc94:	f649 139a 	movw	r3, #39322	; 0x999a
   1cc98:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1cc9c:	edd6 6a05 	vldr	s13, [r6, #20]
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1cca0:	f24c 5080 	movw	r0, #50560	; 0xc580
		sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1cca4:	f6c3 6399 	movt	r3, #16025	; 0x3e99
   1cca8:	ee37 8acb 	vsub.f32	s16, s15, s22
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ccac:	f2c0 200f 	movt	r0, #527	; 0x20f
		sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1ccb0:	ee07 3a10 	vmov	s14, r3
   1ccb4:	eee6 7ac7 	vfms.f32	s15, s13, s14
   1ccb8:	ee27 8a88 	vmul.f32	s16, s15, s16
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ccbc:	f011 f89a 	bl	2ddf4 <tNoise_tick>
   1ccc0:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
   1ccc4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ccc8:	f00e fec8 	bl	2ba5c <tHighpass_tick>
   1cccc:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
   1ccd0:	edd6 7a05 	vldr	s15, [r6, #20]
		sample *= tExpSmooth_tick(&comp);
   1ccd4:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ccd8:	ee67 7a87 	vmul.f32	s15, s15, s14
		sample *= tExpSmooth_tick(&comp);
   1ccdc:	f2c0 200f 	movt	r0, #527	; 0x20f
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1cce0:	ee27 0a80 	vmul.f32	s0, s15, s0
   1cce4:	eea9 0a08 	vfma.f32	s0, s18, s16
   1cce8:	ee3a aa00 	vadd.f32	s20, s20, s0
		sample *= tExpSmooth_tick(&comp);
   1ccec:	f00e fb6e 	bl	2b3cc <tExpSmooth_tick>
   1ccf0:	ed9a 8a01 	vldr	s16, [sl, #4]
   1ccf4:	ee2a 0a00 	vmul.f32	s0, s20, s0
	sample = tanhf(sample);
   1ccf8:	f013 fe98 	bl	30a2c <tanhf>
	sample = tTalkboxFloat_tick(&vocoder, sample, input[1]);
   1ccfc:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
   1cd00:	eef0 0a48 	vmov.f32	s1, s16
   1cd04:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cd08:	f00c fc6e 	bl	295e8 <tTalkboxFloat_tick>
	sample = tVZFilter_tick(&shelf1, sample); //put it through the low shelf
   1cd0c:	f64d 009c 	movw	r0, #55452	; 0xd89c
   1cd10:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cd14:	f00f f8c6 	bl	2bea4 <tVZFilter_tick>
	sample = tVZFilter_tick(&shelf2, sample); // now put that result through the high shelf
   1cd18:	f24d 70c4 	movw	r0, #55236	; 0xd7c4
   1cd1c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cd20:	f00f f8c0 	bl	2bea4 <tVZFilter_tick>
	sample *= displayValues[0] * 0.6f;
   1cd24:	f649 139a 	movw	r3, #39322	; 0x999a
   1cd28:	ed96 7a00 	vldr	s14, [r6]
   1cd2c:	f6c3 7319 	movt	r3, #16153	; 0x3f19
   1cd30:	ee07 3a90 	vmov	s15, r3
   1cd34:	ee67 7a27 	vmul.f32	s15, s14, s15
	sample = tanhf(sample);
   1cd38:	ee27 0a80 	vmul.f32	s0, s15, s0
   1cd3c:	f013 fe76 	bl	30a2c <tanhf>
	input[0] = sample;
   1cd40:	ed8a 0a00 	vstr	s0, [sl]
	input[1] = sample;
   1cd44:	ed8a 0a01 	vstr	s0, [sl, #4]
}
   1cd48:	ecbd 8b08 	vpop	{d8-d11}
   1cd4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1cd50:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   1cd54:	f2c0 260f 	movt	r6, #527	; 0x20f
   1cd58:	2200      	movs	r2, #0
   1cd5a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   1cd5e:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
   1cd62:	edd6 6a04 	vldr	s13, [r6, #16]
   1cd66:	ee07 2a10 	vmov	s14, r2
   1cd6a:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
   1cd6e:	ee07 3a90 	vmov	s15, r3
   1cd72:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cd76:	ee76 7ae7 	vsub.f32	s15, s13, s15
   1cd7a:	eef4 7ac0 	vcmpe.f32	s15, s0
   1cd7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cd82:	bf54      	ite	pl
   1cd84:	eeb0 0a47 	vmovpl.f32	s0, s14
   1cd88:	eeb0 0a46 	vmovmi.f32	s0, s12
   1cd8c:	f00e fb14 	bl	2b3b8 <tExpSmooth_setDest>
   1cd90:	e71f      	b.n	1cbd2 <SFXVocoderTick+0x46>
   1cd92:	f64e 362c 	movw	r6, #60204	; 0xeb2c
		sample = input[0];
   1cd96:	ed90 0a00 	vldr	s0, [r0]
   1cd9a:	f2c0 260f 	movt	r6, #527	; 0x20f
   1cd9e:	e7ab      	b.n	1ccf8 <SFXVocoderTick+0x16c>

0001cda0 <SFXVocoderFree>:
	tTalkboxFloat_free(&vocoder);
   1cda0:	f24e 40dc 	movw	r0, #58588	; 0xe4dc
{
   1cda4:	b570      	push	{r4, r5, r6, lr}
	tTalkboxFloat_free(&vocoder);
   1cda6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cdaa:	f24d 667c 	movw	r6, #54908	; 0xd67c
   1cdae:	f00c f9ad 	bl	2910c <tTalkboxFloat_free>
	tNoise_free(&vocoderNoise);
   1cdb2:	f24d 10cc 	movw	r0, #53708	; 0xd1cc
   1cdb6:	f24c 55b0 	movw	r5, #50608	; 0xc5b0
	tVZFilter_free(&shelf2);
   1cdba:	2400      	movs	r4, #0
	tNoise_free(&vocoderNoise);
   1cdbc:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cdc0:	f2c0 260f 	movt	r6, #527	; 0x20f
   1cdc4:	f011 f812 	bl	2ddec <tNoise_free>
	tZeroCrossing_free(&zerox);
   1cdc8:	f64d 202c 	movw	r0, #55852	; 0xda2c
   1cdcc:	f2c0 250f 	movt	r5, #527	; 0x20f
   1cdd0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cdd4:	f00a fc88 	bl	276e8 <tZeroCrossing_free>
	tExpSmooth_free(&noiseRamp);
   1cdd8:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
   1cddc:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cde0:	f00e fad4 	bl	2b38c <tExpSmooth_free>
	tNoise_free(&breathNoise);
   1cde4:	f24c 5080 	movw	r0, #50560	; 0xc580
   1cde8:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cdec:	f010 fffe 	bl	2ddec <tNoise_free>
	tHighpass_free(&noiseHP);
   1cdf0:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
   1cdf4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1cdf8:	f00e fe1c 	bl	2ba34 <tHighpass_free>
	tVZFilter_free(&shelf1);
   1cdfc:	f64d 009c 	movw	r0, #55452	; 0xd89c
   1ce00:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ce04:	f00f f840 	bl	2be88 <tVZFilter_free>
	tVZFilter_free(&shelf2);
   1ce08:	f24d 70c4 	movw	r0, #55236	; 0xd7c4
   1ce0c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ce10:	f00f f83a 	bl	2be88 <tVZFilter_free>
		tSawtooth_free(&osc[i]);
   1ce14:	1930      	adds	r0, r6, r4
   1ce16:	f010 ff45 	bl	2dca4 <tSawtooth_free>
		tRosenbergGlottalPulse_free(&glottal[i]);
   1ce1a:	1928      	adds	r0, r5, r4
   1ce1c:	3404      	adds	r4, #4
   1ce1e:	f00c fcff 	bl	29820 <tRosenbergGlottalPulse_free>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1ce22:	2c20      	cmp	r4, #32
   1ce24:	d1f6      	bne.n	1ce14 <SFXVocoderFree+0x74>
}
   1ce26:	bd70      	pop	{r4, r5, r6, pc}

0001ce28 <SFXVocoderChAlloc>:
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce28:	f246 2155 	movw	r1, #25173	; 0x6255
   1ce2c:	f247 02a4 	movw	r2, #28836	; 0x70a4
   1ce30:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ce34:	f243 3333 	movw	r3, #13107	; 0x3333
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce38:	f2c0 0106 	movt	r1, #6
   1ce3c:	f6c3 727d 	movt	r2, #16253	; 0x3f7d
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ce40:	f2c4 1387 	movt	r3, #16775	; 0x4187
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ce44:	f64c 40cd 	movw	r0, #52429	; 0xcccd
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce48:	ee06 2a90 	vmov	s13, r2
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ce4c:	eeb0 2a00 	vmov.f32	s4, #0	; 0x40000000  2.0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ce50:	ee07 3a10 	vmov	s14, r3
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1ce54:	f64a 23ab 	movw	r3, #43691	; 0xaaab
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1ce58:	2200      	movs	r2, #0
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1ce5a:	eeff 3a00 	vmov.f32	s7, #240	; 0xbf800000 -1.0
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1ce5e:	f6c3 53aa 	movt	r3, #15786	; 0x3daa
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ce62:	eef2 1a00 	vmov.f32	s3, #32	; 0x41000000  8.0
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1ce66:	f2c4 22c6 	movt	r2, #17094	; 0x42c6
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce6a:	f246 2c48 	movw	ip, #25160	; 0x6248
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1ce6e:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce72:	f2c0 0c06 	movt	ip, #6
{
   1ce76:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ce7a:	ed2d 8b04 	vpush	{d8-d9}
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce7e:	7809      	ldrb	r1, [r1, #0]
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1ce80:	f64c 2478 	movw	r4, #51832	; 0xca78
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ce84:	f64c 45cd 	movw	r5, #52429	; 0xcccd
{
   1ce88:	b083      	sub	sp, #12
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce8a:	ee07 1a90 	vmov	s15, r1
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1ce8e:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ce92:	f6c3 55cc 	movt	r5, #15820	; 0x3dcc
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ce96:	4601      	mov	r1, r0
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ce98:	eef8 7a67 	vcvt.f32.u32	s15, s15
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ce9c:	ed94 6a1b 	vldr	s12, [r4, #108]	; 0x6c
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1cea0:	ee04 5a10 	vmov	s8, r5
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1cea4:	f6c3 704c 	movt	r0, #16204	; 0x3f4c
   1cea8:	f6cb 61cc 	movt	r1, #48844	; 0xbecc
   1ceac:	ed94 5a1a 	vldr	s10, [r4, #104]	; 0x68
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1ceb0:	ee77 7ae6 	vsub.f32	s15, s15, s13
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1ceb4:	ee04 0a90 	vmov	s9, r0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ceb8:	ee66 6a07 	vmul.f32	s13, s12, s14
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1cebc:	ee06 1a10 	vmov	s12, r1
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1cec0:	ee07 2a10 	vmov	s14, r2
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1cec4:	2200      	movs	r2, #0
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1cec6:	eec5 2aa7 	vdiv.f32	s5, s11, s15
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1ceca:	edd4 7a1c 	vldr	s15, [r4, #112]	; 0x70
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1cece:	ed94 1a25 	vldr	s2, [r4, #148]	; 0x94
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1ced2:	f24d 15d0 	movw	r5, #53712	; 0xd1d0
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1ced6:	6fe7      	ldr	r7, [r4, #124]	; 0x7c
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1ced8:	f2c4 2270 	movt	r2, #17008	; 0x4270
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1cedc:	f2c0 250f 	movt	r5, #527	; 0x20f
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1cee0:	ed94 3a24 	vldr	s6, [r4, #144]	; 0x90
	displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1cee4:	edd4 5a23 	vldr	s11, [r4, #140]	; 0x8c
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cee8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1ceec:	eefc 6ae6 	vcvt.u32.f32	s13, s13
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1cef0:	9501      	str	r5, [sp, #4]
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1cef2:	eea7 4a82 	vfma.f32	s8, s15, s4
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1cef6:	ee07 3a90 	vmov	s15, r3
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1cefa:	eea5 6a24 	vfma.f32	s12, s10, s9
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1cefe:	ee05 2a10 	vmov	s10, r2
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1cf02:	edcd 6a00 	vstr	s13, [sp]
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1cf06:	eef0 4a63 	vmov.f32	s9, s7
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1cf0a:	f89d 3000 	ldrb.w	r3, [sp]
   1cf0e:	f24d 75c8 	movw	r5, #55240	; 0xd7c8
	displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1cf12:	ee75 5aa5 	vadd.f32	s11, s11, s11
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1cf16:	f8d4 e078 	ldr.w	lr, [r4, #120]	; 0x78
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1cf1a:	ee06 3a90 	vmov	s13, r3
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1cf1e:	f64e 332c 	movw	r3, #60204	; 0xeb2c
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1cf22:	eee1 4a02 	vfma.f32	s9, s2, s4
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1cf26:	f8d4 9064 	ldr.w	r9, [r4, #100]	; 0x64
   1cf2a:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1cf2e:	eef8 6ae6 	vcvt.f32.s32	s13, s13
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1cf32:	ee23 5a05 	vmul.f32	s10, s6, s10
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1cf36:	f8d4 8074 	ldr.w	r8, [r4, #116]	; 0x74
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1cf3a:	619f      	str	r7, [r3, #24]
   1cf3c:	f2c0 250f 	movt	r5, #527	; 0x20f
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1cf40:	ee22 7a87 	vmul.f32	s14, s5, s14
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1cf44:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1cf48:	ee76 6aa1 	vadd.f32	s13, s13, s3
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1cf4c:	f64d 0ab0 	movw	sl, #55472	; 0xd8b0
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1cf50:	61df      	str	r7, [r3, #28]
	thisBandwidth = bandWidthInOctaves * myQ;
   1cf52:	f24c 56a8 	movw	r6, #50600	; 0xc5a8
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1cf56:	ee67 7a27 	vmul.f32	s15, s14, s15
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1cf5a:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cf5e:	f2c4 51bb 	movt	r1, #17851	; 0x45bb
   1cf62:	f64a 6290 	movw	r2, #44688	; 0xae90
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1cf66:	621f      	str	r7, [r3, #32]
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cf68:	f64d 108c 	movw	r0, #55692	; 0xd98c
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1cf6c:	f8d4 7088 	ldr.w	r7, [r4, #136]	; 0x88
	thisBandwidth = bandWidthInOctaves * myQ;
   1cf70:	ee64 3a27 	vmul.f32	s7, s8, s15
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1cf74:	f8c3 9000 	str.w	r9, [r3]
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1cf78:	f2c0 2a0f 	movt	sl, #527	; 0x20f
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1cf7c:	f8c3 8010 	str.w	r8, [r3, #16]
	thisBandwidth = bandWidthInOctaves * myQ;
   1cf80:	f2c0 260f 	movt	r6, #527	; 0x20f
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1cf84:	edc3 6a02 	vstr	s13, [r3, #8]
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cf88:	ee00 1a10 	vmov	s0, r1
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1cf8c:	ed83 6a01 	vstr	s12, [r3, #4]
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cf90:	f2c0 220f 	movt	r2, #527	; 0x20f
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1cf94:	f8c3 e014 	str.w	lr, [r3, #20]
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cf98:	f2c0 200f 	movt	r0, #527	; 0x20f
	displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1cf9c:	edc3 5a0a 	vstr	s11, [r3, #40]	; 0x28
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cfa0:	2107      	movs	r1, #7
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1cfa2:	ed83 5a0b 	vstr	s10, [r3, #44]	; 0x2c
   1cfa6:	f24e 5bd4 	movw	fp, #58836	; 0xe5d4
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1cfaa:	edc3 4a0c 	vstr	s9, [r3, #48]	; 0x30
   1cfae:	f24d 6918 	movw	r9, #54808	; 0xd618
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1cfb2:	625f      	str	r7, [r3, #36]	; 0x24
   1cfb4:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   1cfb8:	9500      	str	r5, [sp, #0]
   1cfba:	f2c0 290f 	movt	r9, #527	; 0x20f
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1cfbe:	f8d4 7098 	ldr.w	r7, [r4, #152]	; 0x98
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1cfc2:	f04f 0801 	mov.w	r8, #1
	displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
   1cfc6:	f8d4 409c 	ldr.w	r4, [r4, #156]	; 0x9c
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1cfca:	9d01      	ldr	r5, [sp, #4]
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1cfcc:	635f      	str	r7, [r3, #52]	; 0x34
   1cfce:	f64d 17c8 	movw	r7, #55752	; 0xd9c8
	displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
   1cfd2:	639c      	str	r4, [r3, #56]	; 0x38
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1cfd4:	2400      	movs	r4, #0
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1cfd6:	ed83 4a03 	vstr	s8, [r3, #12]
   1cfda:	f2c0 270f 	movt	r7, #527	; 0x20f
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1cfde:	edc5 7a00 	vstr	s15, [r5]
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1cfe2:	ee09 4a10 	vmov	s18, r4
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1cfe6:	edcc 2a00 	vstr	s5, [ip]
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1cfea:	4625      	mov	r5, r4
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1cfec:	ed8a 7a00 	vstr	s14, [sl]
	thisBandwidth = bandWidthInOctaves * myQ;
   1cff0:	edc6 3a00 	vstr	s7, [r6]
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1cff4:	f00e fd42 	bl	2ba7c <tVZFilter_initToPool>
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1cff8:	f64d 108c 	movw	r0, #55692	; 0xd98c
   1cffc:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1d000:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d004:	f00f fbb4 	bl	2c770 <tVZFilter_setGain>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1d008:	f241 236f 	movw	r3, #4719	; 0x126f
   1d00c:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   1d010:	ee08 3a90 	vmov	s17, r3
   1d014:	e004      	b.n	1d020 <SFXVocoderChAlloc+0x1f8>
   1d016:	3501      	adds	r5, #1
   1d018:	f108 0801 	add.w	r8, r8, #1
   1d01c:	3704      	adds	r7, #4
   1d01e:	3408      	adds	r4, #8
		float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1d020:	ee07 5a90 	vmov	s15, r5
   1d024:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
   1d028:	ed9a 7a00 	vldr	s14, [sl]
   1d02c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1d030:	eea7 0a87 	vfma.f32	s0, s15, s14
   1d034:	f010 f84e 	bl	2d0d4 <faster_mtof>
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d038:	f64a 6290 	movw	r2, #44688	; 0xae90
		bandGains[i] = 1.0f;
   1d03c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1d040:	eeb0 8a40 	vmov.f32	s16, s0
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d044:	eb0b 0004 	add.w	r0, fp, r4
   1d048:	2103      	movs	r1, #3
   1d04a:	f2c0 220f 	movt	r2, #527	; 0x20f
		bandGains[i] = 1.0f;
   1d04e:	f849 3b04 	str.w	r3, [r9], #4
		if (i == 0)
   1d052:	2d00      	cmp	r5, #0
   1d054:	f000 8136 	beq.w	1d2c4 <SFXVocoderChAlloc+0x49c>
   1d058:	edd6 7a00 	vldr	s15, [r6]
		else if (i == (MAX_NUM_VOCODER_BANDS-1))
   1d05c:	2d17      	cmp	r5, #23
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d05e:	eef0 0a67 	vmov.f32	s1, s15
		else if (i == (MAX_NUM_VOCODER_BANDS-1))
   1d062:	f000 80e6 	beq.w	1d232 <SFXVocoderChAlloc+0x40a>
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d066:	f00e fd09 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&analysisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d06a:	f24e 53d8 	movw	r3, #58840	; 0xe5d8
   1d06e:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d072:	edd6 0a00 	vldr	s1, [r6]
   1d076:	f2c0 230f 	movt	r3, #527	; 0x20f
   1d07a:	eeb0 0a48 	vmov.f32	s0, s16
   1d07e:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d082:	2103      	movs	r1, #3
   1d084:	1918      	adds	r0, r3, r4
   1d086:	f00e fcf9 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d08a:	9b00      	ldr	r3, [sp, #0]
   1d08c:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d090:	edd6 0a00 	vldr	s1, [r6]
   1d094:	1918      	adds	r0, r3, r4
   1d096:	eeb0 0a48 	vmov.f32	s0, s16
   1d09a:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d09e:	2103      	movs	r1, #3
   1d0a0:	f00e fcec 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1d0a4:	f24d 73cc 	movw	r3, #55244	; 0xd7cc
   1d0a8:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d0ac:	eeb0 0a48 	vmov.f32	s0, s16
   1d0b0:	f2c0 230f 	movt	r3, #527	; 0x20f
   1d0b4:	edd6 0a00 	vldr	s1, [r6]
   1d0b8:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d0bc:	2103      	movs	r1, #3
   1d0be:	1918      	adds	r0, r3, r4
   1d0c0:	f00e fcdc 	bl	2ba7c <tVZFilter_initToPool>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1d0c4:	f64a 6190 	movw	r1, #44688	; 0xae90
   1d0c8:	eef0 0a68 	vmov.f32	s1, s17
   1d0cc:	4638      	mov	r0, r7
   1d0ce:	eeb0 0a49 	vmov.f32	s0, s18
   1d0d2:	f2c0 210f 	movt	r1, #527	; 0x20f
   1d0d6:	f00e f933 	bl	2b340 <tExpSmooth_initToPool>
	for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
   1d0da:	f1b8 0f18 	cmp.w	r8, #24
   1d0de:	d19a      	bne.n	1d016 <SFXVocoderChAlloc+0x1ee>
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1d0e0:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d0e4:	f24c 5080 	movw	r0, #50560	; 0xc580
   1d0e8:	2100      	movs	r1, #0
	tSimplePoly_setNumVoices(&poly, numVoices);
   1d0ea:	f246 2954 	movw	r9, #25172	; 0x6254
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1d0ee:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d0f2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d0f6:	f010 fe67 	bl	2ddc8 <tNoise_initToPool>
	tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1d0fa:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d0fe:	f24d 10cc 	movw	r0, #53708	; 0xd1cc
   1d102:	2100      	movs	r1, #0
   1d104:	f2c0 220f 	movt	r2, #527	; 0x20f
	tSimplePoly_setNumVoices(&poly, numVoices);
   1d108:	f2c0 0906 	movt	r9, #6
	tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1d10c:	f2c0 200f 	movt	r0, #527	; 0x20f
		tSawtooth_initToPool(&osc[i], &smallPool);
   1d110:	f64a 6690 	movw	r6, #44688	; 0xae90
	tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1d114:	f010 fe58 	bl	2ddc8 <tNoise_initToPool>
	tZeroCrossing_initToPool(&zerox, 256, &smallPool);
   1d118:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d11c:	f64d 202c 	movw	r0, #55852	; 0xda2c
   1d120:	f44f 7180 	mov.w	r1, #256	; 0x100
   1d124:	f2c0 220f 	movt	r2, #527	; 0x20f
		tSawtooth_initToPool(&osc[i], &smallPool);
   1d128:	f2c0 260f 	movt	r6, #527	; 0x20f
	tZeroCrossing_initToPool(&zerox, 256, &smallPool);
   1d12c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d130:	f24d 687c 	movw	r8, #54908	; 0xd67c
   1d134:	f00a fab2 	bl	2769c <tZeroCrossing_initToPool>
	tSimplePoly_setNumVoices(&poly, numVoices);
   1d138:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1d13c:	f899 1000 	ldrb.w	r1, [r9]
   1d140:	f24c 57b0 	movw	r7, #50608	; 0xc5b0
   1d144:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d148:	f2c0 280f 	movt	r8, #527	; 0x20f
   1d14c:	f010 fcc4 	bl	2dad8 <tSimplePoly_setNumVoices>
	tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.05f, &smallPool);
   1d150:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   1d154:	2200      	movs	r2, #0
   1d156:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
   1d15a:	f6c3 534c 	movt	r3, #15692	; 0x3d4c
   1d15e:	4631      	mov	r1, r6
   1d160:	ee00 2a10 	vmov	s0, r2
   1d164:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d168:	ee00 3a90 	vmov	s1, r3
   1d16c:	f2c0 270f 	movt	r7, #527	; 0x20f
   1d170:	f00e f8e6 	bl	2b340 <tExpSmooth_initToPool>
	tHighpass_initToPool(&noiseHP, 5000.0f, &smallPool);
   1d174:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   1d178:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
   1d17c:	4631      	mov	r1, r6
   1d17e:	f2c4 539c 	movt	r3, #17820	; 0x459c
	tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1d182:	2400      	movs	r4, #0
	tHighpass_initToPool(&noiseHP, 5000.0f, &smallPool);
   1d184:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d188:	ee00 3a10 	vmov	s0, r3
   1d18c:	f00e fc30 	bl	2b9f0 <tHighpass_initToPool>
	tHighpass_initToPool(&chVocFinalHP1, 20.0f, &smallPool);
   1d190:	f24c 50a4 	movw	r0, #50596	; 0xc5a4
   1d194:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1d198:	4631      	mov	r1, r6
   1d19a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d19e:	f00e fc27 	bl	2b9f0 <tHighpass_initToPool>
	tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1d1a2:	f24e 50c8 	movw	r0, #58824	; 0xe5c8
   1d1a6:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1d1aa:	4631      	mov	r1, r6
   1d1ac:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d1b0:	f00e fc1e 	bl	2b9f0 <tHighpass_initToPool>
		tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1d1b4:	f649 129a 	movw	r2, #39322	; 0x999a
		tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1d1b8:	f64c 43cd 	movw	r3, #52429	; 0xcccd
		tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1d1bc:	f6c3 6299 	movt	r2, #16025	; 0x3e99
		tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1d1c0:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
		tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1d1c4:	ee08 2a90 	vmov	s17, r2
		tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1d1c8:	ee08 3a10 	vmov	s16, r3
   1d1cc:	193d      	adds	r5, r7, r4
		tSawtooth_initToPool(&osc[i], &smallPool);
   1d1ce:	eb08 0004 	add.w	r0, r8, r4
   1d1d2:	4631      	mov	r1, r6
   1d1d4:	3404      	adds	r4, #4
   1d1d6:	f010 fd3f 	bl	2dc58 <tSawtooth_initToPool>
		tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
   1d1da:	4631      	mov	r1, r6
   1d1dc:	4628      	mov	r0, r5
   1d1de:	f00c fb0f 	bl	29800 <tRosenbergGlottalPulse_initToPool>
		tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1d1e2:	eeb0 0a68 	vmov.f32	s0, s17
   1d1e6:	4628      	mov	r0, r5
   1d1e8:	f00c fc10 	bl	29a0c <tRosenbergGlottalPulse_setOpenLength>
		tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1d1ec:	eeb0 0a48 	vmov.f32	s0, s16
   1d1f0:	4628      	mov	r0, r5
   1d1f2:	f00c fc19 	bl	29a28 <tRosenbergGlottalPulse_setPulseLength>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1d1f6:	2c20      	cmp	r4, #32
   1d1f8:	d1e8      	bne.n	1d1cc <SFXVocoderChAlloc+0x3a4>
	setLED_A(numVoices == 1);
   1d1fa:	f899 0000 	ldrb.w	r0, [r9]
   1d1fe:	f1a0 0001 	sub.w	r0, r0, #1
   1d202:	fab0 f080 	clz	r0, r0
   1d206:	0940      	lsrs	r0, r0, #5
   1d208:	f7fd ff94 	bl	1b134 <setLED_A>
	setLED_B(internalExternal);
   1d20c:	f646 1304 	movw	r3, #26884	; 0x6904
   1d210:	f2c0 230e 	movt	r3, #526	; 0x20e
   1d214:	7818      	ldrb	r0, [r3, #0]
   1d216:	f7fd ff9d 	bl	1b154 <setLED_B>
	setLED_C(vocChFreeze);
   1d21a:	f646 1378 	movw	r3, #27000	; 0x6978
   1d21e:	f2c0 230e 	movt	r3, #526	; 0x20e
   1d222:	7818      	ldrb	r0, [r3, #0]
}
   1d224:	b003      	add	sp, #12
   1d226:	ecbd 8b04 	vpop	{d8-d9}
   1d22a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	setLED_C(vocChFreeze);
   1d22e:	f7fd bfa1 	b.w	1b174 <setLED_C>
			tVZFilter_initToPool(&analysisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
   1d232:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d236:	f24e 608c 	movw	r0, #59020	; 0xe68c
   1d23a:	2100      	movs	r1, #0
   1d23c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d240:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d244:	f00e fc1a 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&analysisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
   1d248:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d24c:	f24e 6090 	movw	r0, #59024	; 0xe690
   1d250:	edd6 0a00 	vldr	s1, [r6]
   1d254:	eeb0 0a48 	vmov.f32	s0, s16
   1d258:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d25c:	2100      	movs	r1, #0
   1d25e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d262:	f00e fc0b 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
   1d266:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d26a:	f64d 0080 	movw	r0, #55424	; 0xd880
   1d26e:	edd6 0a00 	vldr	s1, [r6]
   1d272:	eeb0 0a48 	vmov.f32	s0, s16
   1d276:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d27a:	2100      	movs	r1, #0
   1d27c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d280:	f00e fbfc 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
   1d284:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d288:	f64d 0084 	movw	r0, #55428	; 0xd884
   1d28c:	eeb0 0a48 	vmov.f32	s0, s16
   1d290:	edd6 0a00 	vldr	s1, [r6]
   1d294:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d298:	2100      	movs	r1, #0
   1d29a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d29e:	f00e fbed 	bl	2ba7c <tVZFilter_initToPool>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1d2a2:	f241 236f 	movw	r3, #4719	; 0x126f
   1d2a6:	2200      	movs	r2, #0
   1d2a8:	f64a 6190 	movw	r1, #44688	; 0xae90
   1d2ac:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   1d2b0:	4638      	mov	r0, r7
   1d2b2:	f2c0 210f 	movt	r1, #527	; 0x20f
   1d2b6:	ee00 2a10 	vmov	s0, r2
   1d2ba:	ee00 3a90 	vmov	s1, r3
   1d2be:	f00e f83f 	bl	2b340 <tExpSmooth_initToPool>
   1d2c2:	e70d      	b.n	1d0e0 <SFXVocoderChAlloc+0x2b8>
			tVZFilter_initToPool(&analysisBands[i][0], Lowpass, bandFreq, thisBandwidth, &smallPool);
   1d2c4:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d2c8:	edd6 0a00 	vldr	s1, [r6]
   1d2cc:	4658      	mov	r0, fp
   1d2ce:	2101      	movs	r1, #1
   1d2d0:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d2d4:	f00e fbd2 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&analysisBands[i][1], Lowpass, bandFreq, thisBandwidth, &smallPool);
   1d2d8:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d2dc:	f24e 50d8 	movw	r0, #58840	; 0xe5d8
   1d2e0:	edd6 0a00 	vldr	s1, [r6]
   1d2e4:	eeb0 0a48 	vmov.f32	s0, s16
   1d2e8:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d2ec:	2101      	movs	r1, #1
   1d2ee:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d2f2:	f00e fbc3 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][0], Lowpass, bandFreq,thisBandwidth, &smallPool);
   1d2f6:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d2fa:	edd6 0a00 	vldr	s1, [r6]
   1d2fe:	eeb0 0a48 	vmov.f32	s0, s16
   1d302:	9800      	ldr	r0, [sp, #0]
   1d304:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d308:	2101      	movs	r1, #1
   1d30a:	f00e fbb7 	bl	2ba7c <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][1], Lowpass, bandFreq,thisBandwidth, &smallPool);
   1d30e:	f64a 6290 	movw	r2, #44688	; 0xae90
   1d312:	f24d 70cc 	movw	r0, #55244	; 0xd7cc
   1d316:	eeb0 0a48 	vmov.f32	s0, s16
   1d31a:	edd6 0a00 	vldr	s1, [r6]
   1d31e:	f2c0 220f 	movt	r2, #527	; 0x20f
   1d322:	2101      	movs	r1, #1
   1d324:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d328:	f00e fba8 	bl	2ba7c <tVZFilter_initToPool>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1d32c:	f64a 6190 	movw	r1, #44688	; 0xae90
   1d330:	eef0 0a68 	vmov.f32	s1, s17
   1d334:	4638      	mov	r0, r7
   1d336:	eeb0 0a49 	vmov.f32	s0, s18
   1d33a:	f2c0 210f 	movt	r1, #527	; 0x20f
   1d33e:	f00d ffff 	bl	2b340 <tExpSmooth_initToPool>
   1d342:	e668      	b.n	1d016 <SFXVocoderChAlloc+0x1ee>

0001d344 <SFXVocoderChFrame>:
{
   1d344:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1d348:	f64e 247c 	movw	r4, #60028	; 0xea7c
   1d34c:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   1d350:	ed2d 8b08 	vpush	{d8-d11}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1d354:	7d23      	ldrb	r3, [r4, #20]
{
   1d356:	b089      	sub	sp, #36	; 0x24
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1d358:	2b01      	cmp	r3, #1
   1d35a:	d119      	bne.n	1d390 <SFXVocoderChFrame+0x4c>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1d35c:	f246 2554 	movw	r5, #25172	; 0x6254
		tSimplePoly_setNumVoices(&poly, numVoices);
   1d360:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1d364:	f2c0 0506 	movt	r5, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   1d368:	f2c0 200f 	movt	r0, #527	; 0x20f
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1d36c:	782a      	ldrb	r2, [r5, #0]
   1d36e:	2a01      	cmp	r2, #1
   1d370:	bf98      	it	ls
   1d372:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   1d374:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1d376:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   1d378:	f010 fbae 	bl	2dad8 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   1d37c:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d37e:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   1d380:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d384:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   1d386:	fab0 f080 	clz	r0, r0
   1d38a:	0940      	lsrs	r0, r0, #5
   1d38c:	f7fd fed2 	bl	1b134 <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1d390:	7e23      	ldrb	r3, [r4, #24]
   1d392:	2b01      	cmp	r3, #1
   1d394:	f000 82b8 	beq.w	1d908 <SFXVocoderChFrame+0x5c4>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1d398:	7f23      	ldrb	r3, [r4, #28]
   1d39a:	2b01      	cmp	r3, #1
   1d39c:	f000 82c6 	beq.w	1d92c <SFXVocoderChFrame+0x5e8>
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1d3a0:	f64c 2378 	movw	r3, #51832	; 0xca78
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d3a4:	f243 3033 	movw	r0, #13107	; 0x3333
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1d3a8:	f64c 44cd 	movw	r4, #52429	; 0xcccd
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d3ac:	eeb0 3a00 	vmov.f32	s6, #0	; 0x40000000  2.0
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1d3b0:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d3b4:	f2c4 1087 	movt	r0, #16775	; 0x4187
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1d3b8:	4621      	mov	r1, r4
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d3ba:	4622      	mov	r2, r4
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d3bc:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
   1d3c0:	ee07 0a90 	vmov	s15, r0
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1d3c4:	f6c3 744c 	movt	r4, #16204	; 0x3f4c
   1d3c8:	f6cb 61cc 	movt	r1, #48844	; 0xbecc
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d3cc:	ee67 7a27 	vmul.f32	s15, s14, s15
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d3d0:	f6c3 52cc 	movt	r2, #15820	; 0x3dcc
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1d3d4:	2000      	movs	r0, #0
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1d3d6:	ed93 6a1a 	vldr	s12, [r3, #104]	; 0x68
   1d3da:	ee05 4a90 	vmov	s11, r4
   1d3de:	ee06 1a90 	vmov	s13, r1
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d3e2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d3e6:	ee07 2a10 	vmov	s14, r2
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1d3ea:	f2c4 2070 	movt	r0, #17008	; 0x4270
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1d3ee:	f64e 342c 	movw	r4, #60204	; 0xeb2c
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1d3f2:	eeb1 5a00 	vmov.f32	s10, #16	; 0x40800000  4.0
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d3f6:	edd3 2a1c 	vldr	s5, [r3, #112]	; 0x70
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d3fa:	edcd 7a00 	vstr	s15, [sp]
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1d3fe:	eef8 4a00 	vmov.f32	s9, #128	; 0xc0000000 -2.0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d402:	f89d 2000 	ldrb.w	r2, [sp]
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1d406:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1d40a:	ed93 1a25 	vldr	s2, [r3, #148]	; 0x94
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1d40e:	eee6 6a25 	vfma.f32	s13, s12, s11
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d412:	ee07 2a90 	vmov	s15, r2
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1d416:	ee06 0a10 	vmov	s12, r0
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1d41a:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d41c:	eea2 7a83 	vfma.f32	s14, s5, s6
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1d420:	eee1 4a05 	vfma.f32	s9, s2, s10
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1d424:	edd3 2a19 	vldr	s5, [r3, #100]	; 0x64
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1d428:	61a0      	str	r0, [r4, #24]
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d42a:	eef2 1a00 	vmov.f32	s3, #32	; 0x41000000  8.0
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1d42e:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d432:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1d436:	eeb6 2a00 	vmov.f32	s4, #96	; 0x3f000000  0.5
   1d43a:	edd3 3a23 	vldr	s7, [r3, #140]	; 0x8c
	chVocOutputGain = 9.0f * displayValues[0];
   1d43e:	eeb2 5a02 	vmov.f32	s10, #34	; 0x41100000  9.0
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1d442:	ed93 4a24 	vldr	s8, [r3, #144]	; 0x90
	oneMinusStereo = 1.0f - displayValues[13];
   1d446:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1d44a:	ed93 3a26 	vldr	s6, [r3, #152]	; 0x98
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1d44e:	6f5e      	ldr	r6, [r3, #116]	; 0x74
	chVocOutputGain = 9.0f * displayValues[0];
   1d450:	f246 11f0 	movw	r1, #25072	; 0x61f0
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1d454:	61e0      	str	r0, [r4, #28]
	oneMinusStereo = 1.0f - displayValues[13];
   1d456:	f246 2258 	movw	r2, #25176	; 0x6258
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1d45a:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d45e:	ee77 7aa1 	vadd.f32	s15, s15, s3
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1d462:	ee73 3a82 	vadd.f32	s7, s7, s4
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1d466:	f8d3 c078 	ldr.w	ip, [r3, #120]	; 0x78
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1d46a:	ee24 6a06 	vmul.f32	s12, s8, s12
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d46e:	2500      	movs	r5, #0
	chVocOutputGain = 9.0f * displayValues[0];
   1d470:	ee22 5a85 	vmul.f32	s10, s5, s10
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1d474:	6126      	str	r6, [r4, #16]
	oneMinusStereo = 1.0f - displayValues[13];
   1d476:	ee75 5ac3 	vsub.f32	s11, s11, s6
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1d47a:	6220      	str	r0, [r4, #32]
	chVocOutputGain = 9.0f * displayValues[0];
   1d47c:	f2c0 0106 	movt	r1, #6
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1d480:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
	oneMinusStereo = 1.0f - displayValues[13];
   1d484:	f2c0 0206 	movt	r2, #6
	displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
   1d488:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   1d48c:	f24d 17a4 	movw	r7, #53668	; 0xd1a4
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d490:	f64d 06bc 	movw	r6, #55484	; 0xd8bc
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1d494:	f64a 28ab 	movw	r8, #43691	; 0xaaab
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1d498:	edc4 7a02 	vstr	s15, [r4, #8]
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1d49c:	edc4 6a01 	vstr	s13, [r4, #4]
   1d4a0:	f2c0 270f 	movt	r7, #527	; 0x20f
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1d4a4:	ed84 7a03 	vstr	s14, [r4, #12]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d4a8:	f2c0 260f 	movt	r6, #527	; 0x20f
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1d4ac:	f8c4 c014 	str.w	ip, [r4, #20]
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1d4b0:	ee08 5a10 	vmov	s16, r5
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1d4b4:	edc4 3a0a 	vstr	s7, [r4, #40]	; 0x28
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1d4b8:	f6c2 28aa 	movt	r8, #10922	; 0x2aaa
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1d4bc:	ed84 6a0b 	vstr	s12, [r4, #44]	; 0x2c
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d4c0:	46a9      	mov	r9, r5
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1d4c2:	6260      	str	r0, [r4, #36]	; 0x24
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1d4c4:	edc4 4a0c 	vstr	s9, [r4, #48]	; 0x30
	displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
   1d4c8:	63a3      	str	r3, [r4, #56]	; 0x38
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1d4ca:	edc4 2a00 	vstr	s5, [r4]
	chVocOutputGain = 9.0f * displayValues[0];
   1d4ce:	ed81 5a00 	vstr	s10, [r1]
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1d4d2:	ed84 3a0d 	vstr	s6, [r4, #52]	; 0x34
	oneMinusStereo = 1.0f - displayValues[13];
   1d4d6:	edc2 5a00 	vstr	s11, [r2]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d4da:	e060      	b.n	1d59e <SFXVocoderChFrame+0x25a>
   1d4dc:	eb05 0b03 	add.w	fp, r5, r3
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1d4e0:	f010 fb2a 	bl	2db38 <tSimplePoly_getVelocity>
   1d4e4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1d4e8:	2800      	cmp	r0, #0
   1d4ea:	4658      	mov	r0, fp
   1d4ec:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1d4f0:	f00d ff62 	bl	2b3b8 <tExpSmooth_setDest>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1d4f4:	4651      	mov	r1, sl
   1d4f6:	4630      	mov	r0, r6
   1d4f8:	f010 fb12 	bl	2db20 <tSimplePoly_getPitch>
   1d4fc:	f646 1240 	movw	r2, #26944	; 0x6940
   1d500:	ee07 0a90 	vmov	s15, r0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1d504:	f646 13b8 	movw	r3, #27064	; 0x69b8
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1d508:	f2c0 220e 	movt	r2, #526	; 0x20e
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1d50c:	f646 1184 	movw	r1, #27012	; 0x6984
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1d510:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1d514:	f2c0 230e 	movt	r3, #526	; 0x20e
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1d518:	ed92 0a00 	vldr	s0, [r2]
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1d51c:	f2c0 210e 	movt	r1, #526	; 0x20e
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1d520:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1d522:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1d526:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1d52a:	ee17 3a90 	vmov	r3, s15
   1d52e:	1a9b      	subs	r3, r3, r2
   1d530:	fb88 2003 	smull	r2, r0, r8, r3
   1d534:	17da      	asrs	r2, r3, #31
   1d536:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1d53a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1d53e:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1d542:	ee07 3a90 	vmov	s15, r3
   1d546:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1d54a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d54e:	ee17 3a90 	vmov	r3, s15
   1d552:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   1d556:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1d55a:	ee37 0a00 	vadd.f32	s0, s14, s0
   1d55e:	f00f fd27 	bl	2cfb0 <LEAF_midiToFrequency>
		tSawtooth_setFreq(&osc[i], freq[i]);
   1d562:	f24d 607c 	movw	r0, #54908	; 0xd67c
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1d566:	ed87 0a00 	vstr	s0, [r7]
		tSawtooth_setFreq(&osc[i], freq[i]);
   1d56a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d56e:	4428      	add	r0, r5
   1d570:	f010 fb9c 	bl	2dcac <tSawtooth_setFreq>
   1d574:	f24c 50b0 	movw	r0, #50608	; 0xc5b0
		tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
   1d578:	ecb7 0a01 	vldmia	r7!, {s0}
   1d57c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d580:	eb05 0a00 	add.w	sl, r5, r0
   1d584:	3504      	adds	r5, #4
   1d586:	4650      	mov	r0, sl
   1d588:	f00c fa32 	bl	299f0 <tRosenbergGlottalPulse_setFreq>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[6] * displayValues[7], displayValues[6]);
   1d58c:	edd4 0a06 	vldr	s1, [r4, #24]
   1d590:	ed94 0a07 	vldr	s0, [r4, #28]
   1d594:	4650      	mov	r0, sl
   1d596:	ee20 0a80 	vmul.f32	s0, s1, s0
   1d59a:	f00c fa53 	bl	29a44 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d59e:	4630      	mov	r0, r6
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1d5a0:	fa5f fa89 	uxtb.w	sl, r9
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d5a4:	f010 faa0 	bl	2dae8 <tSimplePoly_getNumVoices>
   1d5a8:	f64d 43b8 	movw	r3, #56504	; 0xdcb8
   1d5ac:	4548      	cmp	r0, r9
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1d5ae:	4651      	mov	r1, sl
   1d5b0:	f2c0 230f 	movt	r3, #527	; 0x20f
   1d5b4:	4630      	mov	r0, r6
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1d5b6:	f109 0901 	add.w	r9, r9, #1
   1d5ba:	dc8f      	bgt.n	1d4dc <SFXVocoderChFrame+0x198>
	numberOfVocoderBands = displayValues[2];
   1d5bc:	ed94 7a02 	vldr	s14, [r4, #8]
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1d5c0:	f246 266c 	movw	r6, #25196	; 0x626c
	numberOfVocoderBands = displayValues[2];
   1d5c4:	f246 2555 	movw	r5, #25173	; 0x6255
	float warpFactor = 1.0f + displayValues[1];
   1d5c8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	numberOfVocoderBands = displayValues[2];
   1d5cc:	eebc 7ac7 	vcvt.u32.f32	s14, s14
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1d5d0:	f2c0 0606 	movt	r6, #6
	numberOfVocoderBands = displayValues[2];
   1d5d4:	f2c0 0506 	movt	r5, #6
	float warpFactor = 1.0f + displayValues[1];
   1d5d8:	edd4 8a01 	vldr	s17, [r4, #4]
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1d5dc:	7833      	ldrb	r3, [r6, #0]
   1d5de:	f246 2868 	movw	r8, #25192	; 0x6268
	numberOfVocoderBands = displayValues[2];
   1d5e2:	ed8d 7a00 	vstr	s14, [sp]
	float warpFactor = 1.0f + displayValues[1];
   1d5e6:	ee78 8aa7 	vadd.f32	s17, s17, s15
	numberOfVocoderBands = displayValues[2];
   1d5ea:	f89d 1000 	ldrb.w	r1, [sp]
	float myQ = displayValues[3];
   1d5ee:	ed94 8a03 	vldr	s16, [r4, #12]
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1d5f2:	428b      	cmp	r3, r1
	numberOfVocoderBands = displayValues[2];
   1d5f4:	7029      	strb	r1, [r5, #0]
	float bandSquish = displayValues[10];
   1d5f6:	ed94 9a0a 	vldr	s18, [r4, #40]	; 0x28
	float bandOffset = displayValues[11];
   1d5fa:	ed94 aa0b 	vldr	s20, [r4, #44]	; 0x2c
	float myTilt = displayValues[12];
   1d5fe:	edd4 aa0c 	vldr	s21, [r4, #48]	; 0x30
	float barkPull = displayValues[14];
   1d602:	edd4 9a0e 	vldr	s19, [r4, #56]	; 0x38
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1d606:	f000 8161 	beq.w	1d8cc <SFXVocoderChFrame+0x588>
   1d60a:	f246 2974 	movw	r9, #25204	; 0x6274
   1d60e:	f246 2a64 	movw	sl, #25188	; 0x6264
   1d612:	f246 2360 	movw	r3, #25184	; 0x6260
   1d616:	f646 124c 	movw	r2, #26956	; 0x694c
   1d61a:	f646 1048 	movw	r0, #26952	; 0x6948
   1d61e:	f2c0 0806 	movt	r8, #6
   1d622:	f2c0 0906 	movt	r9, #6
   1d626:	f2c0 0a06 	movt	sl, #6
   1d62a:	f2c0 0306 	movt	r3, #6
   1d62e:	f2c0 220e 	movt	r2, #526	; 0x20e
   1d632:	f2c0 200e 	movt	r0, #526	; 0x20e
   1d636:	9300      	str	r3, [sp, #0]
   1d638:	9201      	str	r2, [sp, #4]
   1d63a:	9002      	str	r0, [sp, #8]
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d63c:	f247 00a4 	movw	r0, #28836	; 0x70a4
   1d640:	ee07 1a90 	vmov	s15, r1
   1d644:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d648:	2200      	movs	r2, #0
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d64a:	f6c3 707d 	movt	r0, #16253	; 0x3f7d
   1d64e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d652:	f2c4 22bc 	movt	r2, #17084	; 0x42bc
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d656:	f64a 21ab 	movw	r1, #43691	; 0xaaab
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d65a:	ee06 0a90 	vmov	s13, r0
		invMyQ = 1.0f / myQ;
   1d65e:	ee85 5a88 	vdiv.f32	s10, s11, s16
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d662:	ee07 2a90 	vmov	s15, r2
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d666:	f6c3 51aa 	movt	r1, #15786	; 0x3daa
		invMyQ = 1.0f / myQ;
   1d66a:	f246 2344 	movw	r3, #25156	; 0x6244
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d66e:	f64d 00b0 	movw	r0, #55472	; 0xd8b0
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d672:	ee07 1a10 	vmov	s14, r1
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d676:	f246 2248 	movw	r2, #25160	; 0x6248
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d67a:	f24d 11d0 	movw	r1, #53712	; 0xd1d0
		thisBandwidth = bandWidthInOctaves * myQ;
   1d67e:	f24c 57a8 	movw	r7, #50600	; 0xc5a8
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d682:	ee76 6a66 	vsub.f32	s13, s12, s13
		alteringBands = 1;
   1d686:	f646 0b7c 	movw	fp, #26748	; 0x687c
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d68a:	ee69 7a27 	vmul.f32	s15, s18, s15
		invMyQ = 1.0f / myQ;
   1d68e:	f2c0 0306 	movt	r3, #6
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d692:	f2c0 200f 	movt	r0, #527	; 0x20f
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d696:	f2c0 0206 	movt	r2, #6
   1d69a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d69e:	f2c0 210f 	movt	r1, #527	; 0x20f
		thisBandwidth = bandWidthInOctaves * myQ;
   1d6a2:	f2c0 270f 	movt	r7, #527	; 0x20f
		alteringBands = 1;
   1d6a6:	f04f 0c01 	mov.w	ip, #1
   1d6aa:	f2c0 2b0e 	movt	fp, #526	; 0x20e
   1d6ae:	f8cb c000 	str.w	ip, [fp]
		invMyQ = 1.0f / myQ;
   1d6b2:	ed83 5a00 	vstr	s10, [r3]
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d6b6:	ee67 7a86 	vmul.f32	s15, s15, s12
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1d6ba:	ed82 6a00 	vstr	s12, [r2]
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d6be:	ee27 7a87 	vmul.f32	s14, s15, s14
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1d6c2:	edc0 7a00 	vstr	s15, [r0]
		thisBandwidth = bandWidthInOctaves * myQ;
   1d6c6:	ee67 6a08 	vmul.f32	s13, s14, s16
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1d6ca:	ed81 7a00 	vstr	s14, [r1]
		thisBandwidth = bandWidthInOctaves * myQ;
   1d6ce:	edc7 6a00 	vstr	s13, [r7]
		if (analysisOrSynthesis == 0)
   1d6d2:	f646 0080 	movw	r0, #26752	; 0x6880
		float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1d6d6:	eeb0 0a4a 	vmov.f32	s0, s20
	float oneMinusBarkPull = 1.0f - barkPull;
   1d6da:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
		if (analysisOrSynthesis == 0)
   1d6de:	f2c0 200e 	movt	r0, #526	; 0x20e
   1d6e2:	e9cd 3206 	strd	r3, r2, [sp, #24]
		float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1d6e6:	f646 03d4 	movw	r3, #26836	; 0x68d4
	float oneMinusBarkPull = 1.0f - barkPull;
   1d6ea:	ee7b ba69 	vsub.f32	s23, s22, s19
		float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1d6ee:	f2c0 230e 	movt	r3, #526	; 0x20e
   1d6f2:	6819      	ldr	r1, [r3, #0]
   1d6f4:	ee07 1a10 	vmov	s14, r1
   1d6f8:	9105      	str	r1, [sp, #20]
   1d6fa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1d6fe:	e9cd 3003 	strd	r3, r0, [sp, #12]
   1d702:	eea7 0a27 	vfma.f32	s0, s14, s15
   1d706:	f00f fce5 	bl	2d0d4 <faster_mtof>
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d70a:	9903      	ldr	r1, [sp, #12]
   1d70c:	f246 1030 	movw	r0, #24880	; 0x6130
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d710:	9a07      	ldr	r2, [sp, #28]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d712:	f8d1 c000 	ldr.w	ip, [r1]
		float tiltOffset = (1.0f - ((myTilt * 0.5f) + 0.5f)) + 0.5f;
   1d716:	ee7a 4a8b 	vadd.f32	s9, s21, s22
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d71a:	f2c0 0006 	movt	r0, #6
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d71e:	edd2 6a00 	vldr	s13, [r2]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d722:	ea4f 018c 	mov.w	r1, ip, lsl #2
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d726:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
   1d72a:	ee07 ca10 	vmov	s14, ip
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d72e:	9b06      	ldr	r3, [sp, #24]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d730:	4408      	add	r0, r1
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d732:	ee66 6aa7 	vmul.f32	s13, s13, s15
		float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
   1d736:	eef8 5ac7 	vcvt.f32.s32	s11, s14
		if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
   1d73a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d73e:	edd0 7a00 	vldr	s15, [r0]
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d742:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
   1d746:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d74a:	ed93 6a00 	vldr	s12, [r3]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d74e:	ee69 7aa7 	vmul.f32	s15, s19, s15
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d752:	f246 1390 	movw	r3, #24976	; 0x6190
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d756:	eea5 7aa6 	vfma.f32	s14, s11, s13
		if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
   1d75a:	f2c4 529c 	movt	r2, #17820	; 0x459c
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d75e:	f2c0 0306 	movt	r3, #6
   1d762:	2000      	movs	r0, #0
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d764:	eeeb 7a80 	vfma.f32	s15, s23, s0
		if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
   1d768:	ee06 2a90 	vmov	s13, r2
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d76c:	440b      	add	r3, r1
   1d76e:	ee68 0a29 	vmul.f32	s1, s16, s19
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d772:	f24d 6218 	movw	r2, #54808	; 0xd618
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d776:	edd7 5a00 	vldr	s11, [r7]
   1d77a:	f2c4 607a 	movt	r0, #18042	; 0x467a
		if (analysisOrSynthesis == 0)
   1d77e:	9f04      	ldr	r7, [sp, #16]
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1d780:	eea4 7ac5 	vfms.f32	s14, s9, s10
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d784:	f2c0 220f 	movt	r2, #527	; 0x20f
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1d788:	eeb0 0a67 	vmov.f32	s0, s15
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d78c:	edd3 7a00 	vldr	s15, [r3]
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d790:	440a      	add	r2, r1
		if (analysisOrSynthesis == 0)
   1d792:	683b      	ldr	r3, [r7, #0]
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d794:	ee60 0aa7 	vmul.f32	s1, s1, s15
   1d798:	ee07 0a90 	vmov	s15, r0
		float tempWarpFactor = warpFactor;
   1d79c:	eeb4 0ae6 	vcmpe.f32	s0, s13
   1d7a0:	ea4f 00cc 	mov.w	r0, ip, lsl #3
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d7a4:	ee27 7a06 	vmul.f32	s14, s14, s12
   1d7a8:	fe80 0a67 	vminnm.f32	s0, s0, s15
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1d7ac:	eee5 0aab 	vfma.f32	s1, s11, s23
		float tempWarpFactor = warpFactor;
   1d7b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1d7b4:	ed82 7a00 	vstr	s14, [r2]
		float tempWarpFactor = warpFactor;
   1d7b8:	bf98      	it	ls
   1d7ba:	eeb0 ba68 	vmovls.f32	s22, s17
		if (analysisOrSynthesis == 0)
   1d7be:	2b00      	cmp	r3, #0
   1d7c0:	f040 80cc 	bne.w	1d95c <SFXVocoderChFrame+0x618>
			tVZFilter_setFreqAndBandwidth(&analysisBands[currentBandToAlter][0], bandFreq, bandBandwidth);
   1d7c4:	f24e 57d4 	movw	r7, #58836	; 0xe5d4
   1d7c8:	f2c0 270f 	movt	r7, #527	; 0x20f
   1d7cc:	4438      	add	r0, r7
   1d7ce:	f00e fdcd 	bl	2c36c <tVZFilter_setFreqAndBandwidth>
			analysisBands[currentBandToAlter][1]->B = analysisBands[currentBandToAlter][0]->B;
   1d7d2:	9903      	ldr	r1, [sp, #12]
   1d7d4:	680b      	ldr	r3, [r1, #0]
   1d7d6:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d7da:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   1d7de:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1d7e0:	6851      	ldr	r1, [r2, #4]
   1d7e2:	6348      	str	r0, [r1, #52]	; 0x34
			analysisBands[currentBandToAlter][1]->fc = analysisBands[currentBandToAlter][0]->fc;
   1d7e4:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d7e8:	6851      	ldr	r1, [r2, #4]
   1d7ea:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1d7ec:	6288      	str	r0, [r1, #40]	; 0x28
			analysisBands[currentBandToAlter][1]->R2 = analysisBands[currentBandToAlter][0]->R2;
   1d7ee:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d7f2:	6851      	ldr	r1, [r2, #4]
   1d7f4:	6940      	ldr	r0, [r0, #20]
   1d7f6:	6148      	str	r0, [r1, #20]
			analysisBands[currentBandToAlter][1]->cL = analysisBands[currentBandToAlter][0]->cL;
   1d7f8:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d7fc:	6851      	ldr	r1, [r2, #4]
   1d7fe:	69c0      	ldr	r0, [r0, #28]
   1d800:	61c8      	str	r0, [r1, #28]
			analysisBands[currentBandToAlter][1]->cB = analysisBands[currentBandToAlter][0]->cB;
   1d802:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d806:	6851      	ldr	r1, [r2, #4]
   1d808:	6a00      	ldr	r0, [r0, #32]
   1d80a:	6208      	str	r0, [r1, #32]
			analysisBands[currentBandToAlter][1]->cH = analysisBands[currentBandToAlter][0]->cH;
   1d80c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d810:	6851      	ldr	r1, [r2, #4]
   1d812:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1d814:	6248      	str	r0, [r1, #36]	; 0x24
			analysisBands[currentBandToAlter][1]->h = analysisBands[currentBandToAlter][0]->h;
   1d816:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d81a:	6851      	ldr	r1, [r2, #4]
   1d81c:	6980      	ldr	r0, [r0, #24]
   1d81e:	6188      	str	r0, [r1, #24]
			analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
   1d820:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   1d824:	6852      	ldr	r2, [r2, #4]
   1d826:	6909      	ldr	r1, [r1, #16]
			analysisOrSynthesis++;
   1d828:	9804      	ldr	r0, [sp, #16]
			analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
   1d82a:	6111      	str	r1, [r2, #16]
			analysisOrSynthesis++;
   1d82c:	6802      	ldr	r2, [r0, #0]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1d82e:	7829      	ldrb	r1, [r5, #0]
			analysisOrSynthesis++;
   1d830:	3201      	adds	r2, #1
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1d832:	428b      	cmp	r3, r1
			analysisOrSynthesis++;
   1d834:	6002      	str	r2, [r0, #0]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1d836:	db02      	blt.n	1d83e <SFXVocoderChFrame+0x4fa>
   1d838:	2a00      	cmp	r2, #0
   1d83a:	f000 80d2 	beq.w	1d9e2 <SFXVocoderChFrame+0x69e>
	prevBandOffset = bandOffset;
   1d83e:	9b00      	ldr	r3, [sp, #0]
	prevNumberOfVocoderBands = numberOfVocoderBands;
   1d840:	7031      	strb	r1, [r6, #0]
	prevBandOffset = bandOffset;
   1d842:	ed83 aa00 	vstr	s20, [r3]
	prevMyTilt = myTilt;
   1d846:	9b01      	ldr	r3, [sp, #4]
	prevMyQ = myQ;
   1d848:	ed88 8a00 	vstr	s16, [r8]
	prevMyTilt = myTilt;
   1d84c:	edc3 aa00 	vstr	s21, [r3]
	prevBarkPull = barkPull;
   1d850:	9b02      	ldr	r3, [sp, #8]
	prevWarpFactor = warpFactor;
   1d852:	edc9 8a00 	vstr	s17, [r9]
	prevBandSquish = bandSquish;
   1d856:	ed8a 9a00 	vstr	s18, [sl]
	prevBarkPull = barkPull;
   1d85a:	edc3 9a00 	vstr	s19, [r3]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1d85e:	b1f1      	cbz	r1, 1d89e <SFXVocoderChFrame+0x55a>
		tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1d860:	f649 32a6 	movw	r2, #39846	; 0x9ba6
   1d864:	f24b 7317 	movw	r3, #46871	; 0xb717
   1d868:	f64d 16c8 	movw	r6, #55752	; 0xd9c8
	for (int i = 0; i < numberOfVocoderBands; i++)
   1d86c:	2700      	movs	r7, #0
		tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1d86e:	f6c3 22c4 	movt	r2, #15044	; 0x3ac4
   1d872:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   1d876:	f2c0 260f 	movt	r6, #527	; 0x20f
   1d87a:	ee08 2a90 	vmov	s17, r2
   1d87e:	ee08 3a10 	vmov	s16, r3
   1d882:	eeb0 0a48 	vmov.f32	s0, s16
   1d886:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   1d88a:	4630      	mov	r0, r6
	for (int i = 0; i < numberOfVocoderBands; i++)
   1d88c:	3701      	adds	r7, #1
   1d88e:	3604      	adds	r6, #4
		tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1d890:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1d894:	f00d fd7e 	bl	2b394 <tExpSmooth_setFactor>
	for (int i = 0; i < numberOfVocoderBands; i++)
   1d898:	782b      	ldrb	r3, [r5, #0]
   1d89a:	42bb      	cmp	r3, r7
   1d89c:	dcf1      	bgt.n	1d882 <SFXVocoderChFrame+0x53e>
	if (tSimplePoly_getNumActiveVoices(&poly) != 0)
   1d89e:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1d8a2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d8a6:	f010 f923 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
   1d8aa:	2800      	cmp	r0, #0
   1d8ac:	f040 809f 	bne.w	1d9ee <SFXVocoderChFrame+0x6aa>
		tExpSmooth_setDest(&comp, 0.0f);
   1d8b0:	2300      	movs	r3, #0
   1d8b2:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1d8b6:	ee00 3a10 	vmov	s0, r3
   1d8ba:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   1d8be:	b009      	add	sp, #36	; 0x24
   1d8c0:	ecbd 8b08 	vpop	{d8-d11}
   1d8c4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		tExpSmooth_setDest(&comp, 0.0f);
   1d8c8:	f00d bd76 	b.w	2b3b8 <tExpSmooth_setDest>
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1d8cc:	f2c0 0806 	movt	r8, #6
   1d8d0:	f246 2974 	movw	r9, #25204	; 0x6274
   1d8d4:	edd8 7a00 	vldr	s15, [r8]
   1d8d8:	eef4 7a48 	vcmp.f32	s15, s16
   1d8dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d8e0:	d133      	bne.n	1d94a <SFXVocoderChFrame+0x606>
   1d8e2:	f2c0 0906 	movt	r9, #6
   1d8e6:	f246 2a64 	movw	sl, #25188	; 0x6264
   1d8ea:	edd9 7a00 	vldr	s15, [r9]
   1d8ee:	eef4 7a68 	vcmp.f32	s15, s17
   1d8f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d8f6:	f000 8095 	beq.w	1da24 <SFXVocoderChFrame+0x6e0>
   1d8fa:	f246 2360 	movw	r3, #25184	; 0x6260
   1d8fe:	f646 124c 	movw	r2, #26956	; 0x694c
   1d902:	f646 1048 	movw	r0, #26952	; 0x6948
   1d906:	e68e      	b.n	1d626 <SFXVocoderChFrame+0x2e2>
		internalExternal = !internalExternal;
   1d908:	f646 1204 	movw	r2, #26884	; 0x6904
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1d90c:	2300      	movs	r3, #0
		internalExternal = !internalExternal;
   1d90e:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1d912:	7623      	strb	r3, [r4, #24]
		internalExternal = !internalExternal;
   1d914:	7813      	ldrb	r3, [r2, #0]
   1d916:	fab3 f383 	clz	r3, r3
   1d91a:	095b      	lsrs	r3, r3, #5
		setLED_B(internalExternal);
   1d91c:	4618      	mov	r0, r3
		internalExternal = !internalExternal;
   1d91e:	7013      	strb	r3, [r2, #0]
		setLED_B(internalExternal);
   1d920:	f7fd fc18 	bl	1b154 <setLED_B>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1d924:	7f23      	ldrb	r3, [r4, #28]
   1d926:	2b01      	cmp	r3, #1
   1d928:	f47f ad3a 	bne.w	1d3a0 <SFXVocoderChFrame+0x5c>
		vocChFreeze = !vocChFreeze;
   1d92c:	f646 1278 	movw	r2, #27000	; 0x6978
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1d930:	2300      	movs	r3, #0
		vocChFreeze = !vocChFreeze;
   1d932:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1d936:	7723      	strb	r3, [r4, #28]
		vocChFreeze = !vocChFreeze;
   1d938:	6813      	ldr	r3, [r2, #0]
   1d93a:	fab3 f383 	clz	r3, r3
   1d93e:	095b      	lsrs	r3, r3, #5
		setLED_C(vocChFreeze);
   1d940:	4618      	mov	r0, r3
		vocChFreeze = !vocChFreeze;
   1d942:	6013      	str	r3, [r2, #0]
		setLED_C(vocChFreeze);
   1d944:	f7fd fc16 	bl	1b174 <setLED_C>
   1d948:	e52a      	b.n	1d3a0 <SFXVocoderChFrame+0x5c>
   1d94a:	f246 2a64 	movw	sl, #25188	; 0x6264
   1d94e:	f246 2360 	movw	r3, #25184	; 0x6260
   1d952:	f646 124c 	movw	r2, #26956	; 0x694c
   1d956:	f646 1048 	movw	r0, #26952	; 0x6948
   1d95a:	e662      	b.n	1d622 <SFXVocoderChFrame+0x2de>
			tVZFilter_setFreqAndBandwidth(&synthesisBands[currentBandToAlter][0], bandFreq * tempWarpFactor, bandBandwidth);
   1d95c:	f24d 77c8 	movw	r7, #55240	; 0xd7c8
   1d960:	ee2b 0a00 	vmul.f32	s0, s22, s0
   1d964:	f2c0 270f 	movt	r7, #527	; 0x20f
   1d968:	4438      	add	r0, r7
   1d96a:	f00e fcff 	bl	2c36c <tVZFilter_setFreqAndBandwidth>
			synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1d96e:	9b03      	ldr	r3, [sp, #12]
			analysisOrSynthesis = 0;
   1d970:	f04f 0e00 	mov.w	lr, #0
			synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1d974:	681b      	ldr	r3, [r3, #0]
   1d976:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d97a:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
			currentBandToAlter++;
   1d97e:	f103 0c01 	add.w	ip, r3, #1
			synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1d982:	6851      	ldr	r1, [r2, #4]
   1d984:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1d986:	6348      	str	r0, [r1, #52]	; 0x34
			synthesisBands[currentBandToAlter][1]->fc = synthesisBands[currentBandToAlter][0]->fc;
   1d988:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d98c:	6851      	ldr	r1, [r2, #4]
   1d98e:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1d990:	6288      	str	r0, [r1, #40]	; 0x28
			synthesisBands[currentBandToAlter][1]->R2 = synthesisBands[currentBandToAlter][0]->R2;
   1d992:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d996:	6851      	ldr	r1, [r2, #4]
   1d998:	6940      	ldr	r0, [r0, #20]
   1d99a:	6148      	str	r0, [r1, #20]
			synthesisBands[currentBandToAlter][1]->cL = synthesisBands[currentBandToAlter][0]->cL;
   1d99c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d9a0:	6851      	ldr	r1, [r2, #4]
   1d9a2:	69c0      	ldr	r0, [r0, #28]
   1d9a4:	61c8      	str	r0, [r1, #28]
			synthesisBands[currentBandToAlter][1]->cB = synthesisBands[currentBandToAlter][0]->cB;
   1d9a6:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d9aa:	6851      	ldr	r1, [r2, #4]
   1d9ac:	6a00      	ldr	r0, [r0, #32]
   1d9ae:	6208      	str	r0, [r1, #32]
			synthesisBands[currentBandToAlter][1]->cH = synthesisBands[currentBandToAlter][0]->cH;
   1d9b0:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d9b4:	6851      	ldr	r1, [r2, #4]
   1d9b6:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1d9b8:	6248      	str	r0, [r1, #36]	; 0x24
			synthesisBands[currentBandToAlter][1]->h = synthesisBands[currentBandToAlter][0]->h;
   1d9ba:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1d9be:	6851      	ldr	r1, [r2, #4]
   1d9c0:	6980      	ldr	r0, [r0, #24]
   1d9c2:	6188      	str	r0, [r1, #24]
			synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
   1d9c4:	f857 3033 	ldr.w	r3, [r7, r3, lsl #3]
   1d9c8:	6852      	ldr	r2, [r2, #4]
   1d9ca:	691b      	ldr	r3, [r3, #16]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1d9cc:	7829      	ldrb	r1, [r5, #0]
			synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
   1d9ce:	6113      	str	r3, [r2, #16]
			currentBandToAlter++;
   1d9d0:	9b03      	ldr	r3, [sp, #12]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1d9d2:	458c      	cmp	ip, r1
			currentBandToAlter++;
   1d9d4:	f8c3 c000 	str.w	ip, [r3]
			analysisOrSynthesis = 0;
   1d9d8:	9b04      	ldr	r3, [sp, #16]
   1d9da:	f8c3 e000 	str.w	lr, [r3]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1d9de:	f6ff af2e 	blt.w	1d83e <SFXVocoderChFrame+0x4fa>
			alteringBands = 0;
   1d9e2:	2300      	movs	r3, #0
			currentBandToAlter = 0;
   1d9e4:	9a03      	ldr	r2, [sp, #12]
			alteringBands = 0;
   1d9e6:	f8cb 3000 	str.w	r3, [fp]
			currentBandToAlter = 0;
   1d9ea:	6013      	str	r3, [r2, #0]
   1d9ec:	e727      	b.n	1d83e <SFXVocoderChFrame+0x4fa>
		tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
   1d9ee:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1d9f2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1d9f6:	f010 f87b 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
   1d9fa:	ee07 0a90 	vmov	s15, r0
   1d9fe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1da02:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1da06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1da0a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1da0e:	ee87 0a27 	vdiv.f32	s0, s14, s15
   1da12:	eeb1 0ac0 	vsqrt.f32	s0, s0
}
   1da16:	b009      	add	sp, #36	; 0x24
   1da18:	ecbd 8b08 	vpop	{d8-d11}
   1da1c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		tExpSmooth_setDest(&comp, 0.0f);
   1da20:	f00d bcca 	b.w	2b3b8 <tExpSmooth_setDest>
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1da24:	f2c0 0a06 	movt	sl, #6
   1da28:	f246 2360 	movw	r3, #25184	; 0x6260
   1da2c:	edda 7a00 	vldr	s15, [sl]
   1da30:	eef4 7a49 	vcmp.f32	s15, s18
   1da34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1da38:	d114      	bne.n	1da64 <SFXVocoderChFrame+0x720>
   1da3a:	f2c0 0306 	movt	r3, #6
   1da3e:	edd3 7a00 	vldr	s15, [r3]
   1da42:	9300      	str	r3, [sp, #0]
   1da44:	f646 134c 	movw	r3, #26956	; 0x694c
   1da48:	eef4 7a4a 	vcmp.f32	s15, s20
   1da4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1da50:	d00d      	beq.n	1da6e <SFXVocoderChFrame+0x72a>
   1da52:	f646 1248 	movw	r2, #26952	; 0x6948
   1da56:	f2c0 230e 	movt	r3, #526	; 0x20e
   1da5a:	f2c0 220e 	movt	r2, #526	; 0x20e
   1da5e:	9301      	str	r3, [sp, #4]
   1da60:	9202      	str	r2, [sp, #8]
   1da62:	e5eb      	b.n	1d63c <SFXVocoderChFrame+0x2f8>
   1da64:	f646 124c 	movw	r2, #26956	; 0x694c
   1da68:	f646 1048 	movw	r0, #26952	; 0x6948
   1da6c:	e5dd      	b.n	1d62a <SFXVocoderChFrame+0x2e6>
   1da6e:	f2c0 230e 	movt	r3, #526	; 0x20e
   1da72:	edd3 7a00 	vldr	s15, [r3]
   1da76:	9301      	str	r3, [sp, #4]
   1da78:	f646 1348 	movw	r3, #26952	; 0x6948
   1da7c:	eef4 7a6a 	vcmp.f32	s15, s21
   1da80:	f2c0 230e 	movt	r3, #526	; 0x20e
   1da84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1da88:	9302      	str	r3, [sp, #8]
   1da8a:	f47f add7 	bne.w	1d63c <SFXVocoderChFrame+0x2f8>
   1da8e:	edd3 7a00 	vldr	s15, [r3]
   1da92:	eef4 7a69 	vcmp.f32	s15, s19
   1da96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1da9a:	f47f adcf 	bne.w	1d63c <SFXVocoderChFrame+0x2f8>
	if (alteringBands)
   1da9e:	f646 0b7c 	movw	fp, #26748	; 0x687c
   1daa2:	f2c0 2b0e 	movt	fp, #526	; 0x20e
   1daa6:	f8db 3000 	ldr.w	r3, [fp]
   1daaa:	2b00      	cmp	r3, #0
   1daac:	f43f aec7 	beq.w	1d83e <SFXVocoderChFrame+0x4fa>
   1dab0:	f64d 01b0 	movw	r1, #55472	; 0xd8b0
   1dab4:	f246 2248 	movw	r2, #25160	; 0x6248
   1dab8:	f24c 57a8 	movw	r7, #50600	; 0xc5a8
   1dabc:	f246 2344 	movw	r3, #25156	; 0x6244
   1dac0:	f2c0 210f 	movt	r1, #527	; 0x20f
   1dac4:	f2c0 0206 	movt	r2, #6
   1dac8:	f2c0 270f 	movt	r7, #527	; 0x20f
   1dacc:	f2c0 0306 	movt	r3, #6
   1dad0:	edd1 7a00 	vldr	s15, [r1]
   1dad4:	e5fd      	b.n	1d6d2 <SFXVocoderChFrame+0x38e>
   1dad6:	bf00      	nop

0001dad8 <SFXVocoderChTick>:
{
   1dad8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dadc:	4606      	mov	r6, r0
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1dade:	f64d 108c 	movw	r0, #55692	; 0xd98c
{
   1dae2:	ed2d 8b06 	vpush	{d8-d10}
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1dae6:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   1daea:	b087      	sub	sp, #28
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1daec:	ed96 0a01 	vldr	s0, [r6, #4]
   1daf0:	f00e f9d8 	bl	2bea4 <tVZFilter_tick>
	if (internalExternal == 1)
   1daf4:	f646 1304 	movw	r3, #26884	; 0x6904
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1daf8:	ed86 0a01 	vstr	s0, [r6, #4]
	if (internalExternal == 1)
   1dafc:	f2c0 230e 	movt	r3, #526	; 0x20e
   1db00:	781b      	ldrb	r3, [r3, #0]
   1db02:	2b01      	cmp	r3, #1
   1db04:	f040 80d8 	bne.w	1dcb8 <SFXVocoderChTick+0x1e0>
   1db08:	f64e 372c 	movw	r7, #60204	; 0xeb2c
		sample = input[0];
   1db0c:	ed96 0a00 	vldr	s0, [r6]
   1db10:	f2c0 270f 	movt	r7, #527	; 0x20f
	sample = LEAF_tanh(sample);
   1db14:	f00f f9b4 	bl	2ce80 <LEAF_tanh>
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1db18:	eeb3 7a0e 	vmov.f32	s14, #62	; 0x41f00000  30.0
	sample = LEAF_tanh(sample);
   1db1c:	eeb0 9a40 	vmov.f32	s18, s0
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1db20:	ed97 0a00 	vldr	s0, [r7]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1db24:	f246 2855 	movw	r8, #25173	; 0x6255
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1db28:	edd6 7a01 	vldr	s15, [r6, #4]
   1db2c:	ee20 0a07 	vmul.f32	s0, s0, s14
	float output[2] = {0.0f, 0.0f};
   1db30:	2300      	movs	r3, #0
	for (int i = 0; i < numberOfVocoderBands; i++)
   1db32:	f2c0 0806 	movt	r8, #6
	float output[2] = {0.0f, 0.0f};
   1db36:	9304      	str	r3, [sp, #16]
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1db38:	ee20 0a27 	vmul.f32	s0, s0, s15
	for (int i = 0; i < numberOfVocoderBands; i++)
   1db3c:	f898 2000 	ldrb.w	r2, [r8]
	float output[2] = {0.0f, 0.0f};
   1db40:	9305      	str	r3, [sp, #20]
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1db42:	ed86 0a01 	vstr	s0, [r6, #4]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1db46:	2a00      	cmp	r2, #0
   1db48:	f000 8168 	beq.w	1de1c <SFXVocoderChTick+0x344>
   1db4c:	ee08 3a10 	vmov	s16, r3
   1db50:	f24e 52d4 	movw	r2, #58836	; 0xe5d4
   1db54:	469a      	mov	sl, r3
   1db56:	f64d 13c8 	movw	r3, #55752	; 0xd9c8
   1db5a:	f24d 79c8 	movw	r9, #55240	; 0xd7c8
   1db5e:	f24d 6518 	movw	r5, #54808	; 0xd618
   1db62:	f2c0 220f 	movt	r2, #527	; 0x20f
   1db66:	f646 1778 	movw	r7, #27000	; 0x6978
   1db6a:	f2c0 230f 	movt	r3, #527	; 0x20f
   1db6e:	f2c0 290f 	movt	r9, #527	; 0x20f
   1db72:	9203      	str	r2, [sp, #12]
   1db74:	f2c0 250f 	movt	r5, #527	; 0x20f
		tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1db78:	eef0 9a48 	vmov.f32	s19, s16
   1db7c:	ee18 ba10 	vmov	fp, s16
   1db80:	f2c0 270e 	movt	r7, #526	; 0x20e
   1db84:	e9cd 3601 	strd	r3, r6, [sp, #4]
   1db88:	e033      	b.n	1dbf2 <SFXVocoderChTick+0x11a>
		tempSamp = tExpSmooth_tick(&envFollowers[i]);
   1db8a:	4630      	mov	r0, r6
	for (int i = 0; i < numberOfVocoderBands; i++)
   1db8c:	f10b 0b01 	add.w	fp, fp, #1
		tempSamp = tExpSmooth_tick(&envFollowers[i]);
   1db90:	f00d fc1c 	bl	2b3cc <tExpSmooth_tick>
		tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1db94:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
   1db98:	eef0 0a40 	vmov.f32	s1, s0
   1db9c:	eeb0 0a69 	vmov.f32	s0, s19
   1dba0:	f00f f91e 	bl	2cde0 <LEAF_clip>
		tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
   1dba4:	eb09 0004 	add.w	r0, r9, r4
		tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1dba8:	eef0 8a40 	vmov.f32	s17, s0
		tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
   1dbac:	eeb0 0a49 	vmov.f32	s0, s18
   1dbb0:	f00e f9b6 	bl	2bf20 <tVZFilter_tickEfficient>
		tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][1], tempSynth);
   1dbb4:	f24d 73cc 	movw	r3, #55244	; 0xd7cc
   1dbb8:	f2c0 230f 	movt	r3, #527	; 0x20f
   1dbbc:	1918      	adds	r0, r3, r4
   1dbbe:	f00e f9af 	bl	2bf20 <tVZFilter_tickEfficient>
		output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1dbc2:	ee28 0a80 	vmul.f32	s0, s17, s0
   1dbc6:	ecf5 7a01 	vldmia	r5!, {s15}
   1dbca:	ab06      	add	r3, sp, #24
	for (int i = 0; i < numberOfVocoderBands; i++)
   1dbcc:	f898 1000 	ldrb.w	r1, [r8]
		output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1dbd0:	eea0 8a27 	vfma.f32	s16, s0, s15
   1dbd4:	eb03 008a 	add.w	r0, r3, sl, lsl #2
	for (int i = 0; i < numberOfVocoderBands; i++)
   1dbd8:	4559      	cmp	r1, fp
   1dbda:	f00b 0a01 	and.w	sl, fp, #1
   1dbde:	eb03 048a 	add.w	r4, r3, sl, lsl #2
		output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1dbe2:	ed00 8a02 	vstr	s16, [r0, #-8]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1dbe6:	dd1d      	ble.n	1dc24 <SFXVocoderChTick+0x14c>
   1dbe8:	9b02      	ldr	r3, [sp, #8]
   1dbea:	ed14 8a02 	vldr	s16, [r4, #-8]
   1dbee:	ed93 0a01 	vldr	s0, [r3, #4]
   1dbf2:	9b01      	ldr	r3, [sp, #4]
   1dbf4:	ea4f 04cb 	mov.w	r4, fp, lsl #3
		if (!vocChFreeze)
   1dbf8:	6838      	ldr	r0, [r7, #0]
   1dbfa:	eb03 068b 	add.w	r6, r3, fp, lsl #2
   1dbfe:	2800      	cmp	r0, #0
   1dc00:	d1c3      	bne.n	1db8a <SFXVocoderChTick+0xb2>
			tempSamp = tVZFilter_tickEfficient(&analysisBands[i][0], tempSamp);
   1dc02:	9b03      	ldr	r3, [sp, #12]
   1dc04:	1918      	adds	r0, r3, r4
   1dc06:	f00e f98b 	bl	2bf20 <tVZFilter_tickEfficient>
			tempSamp = tVZFilter_tickEfficient(&analysisBands[i][1], tempSamp);
   1dc0a:	f24e 53d8 	movw	r3, #58840	; 0xe5d8
   1dc0e:	f2c0 230f 	movt	r3, #527	; 0x20f
   1dc12:	1918      	adds	r0, r3, r4
   1dc14:	f00e f984 	bl	2bf20 <tVZFilter_tickEfficient>
			tExpSmooth_setDest(&envFollowers[i], fabsf(tempSamp));
   1dc18:	4630      	mov	r0, r6
   1dc1a:	eeb0 0ac0 	vabs.f32	s0, s0
   1dc1e:	f00d fbcb 	bl	2b3b8 <tExpSmooth_setDest>
   1dc22:	e7b2      	b.n	1db8a <SFXVocoderChTick+0xb2>
   1dc24:	9e02      	ldr	r6, [sp, #8]
   1dc26:	eddd 8a04 	vldr	s17, [sp, #16]
   1dc2a:	ed9d 8a05 	vldr	s16, [sp, #20]
	float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1dc2e:	f246 2558 	movw	r5, #25176	; 0x6258
   1dc32:	eeb0 0a68 	vmov.f32	s0, s17
   1dc36:	f246 14f0 	movw	r4, #25072	; 0x61f0
   1dc3a:	f24c 50a4 	movw	r0, #50596	; 0xc5a4
   1dc3e:	f2c0 0506 	movt	r5, #6
   1dc42:	f2c0 0406 	movt	r4, #6
   1dc46:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dc4a:	ed95 7a00 	vldr	s14, [r5]
   1dc4e:	edd4 7a00 	vldr	s15, [r4]
   1dc52:	eea7 0a08 	vfma.f32	s0, s14, s16
   1dc56:	ee20 0a27 	vmul.f32	s0, s0, s15
   1dc5a:	f00d feff 	bl	2ba5c <tHighpass_tick>
	float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
   1dc5e:	edd5 7a00 	vldr	s15, [r5]
	float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1dc62:	eeb0 9a40 	vmov.f32	s18, s0
	float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
   1dc66:	f24e 50c8 	movw	r0, #58824	; 0xe5c8
   1dc6a:	eea7 8aa8 	vfma.f32	s16, s15, s17
   1dc6e:	ed94 0a00 	vldr	s0, [r4]
   1dc72:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dc76:	ee28 0a00 	vmul.f32	s0, s16, s0
   1dc7a:	f00d feef 	bl	2ba5c <tHighpass_tick>
   1dc7e:	eef0 8a40 	vmov.f32	s17, s0
	input[0] = 0.98f * tanhf(finalSample1);
   1dc82:	eeb0 0a49 	vmov.f32	s0, s18
   1dc86:	f012 fed1 	bl	30a2c <tanhf>
   1dc8a:	f24e 1348 	movw	r3, #57672	; 0xe148
   1dc8e:	f6c3 737a 	movt	r3, #16250	; 0x3f7a
   1dc92:	ee08 3a10 	vmov	s16, r3
   1dc96:	ee60 7a08 	vmul.f32	s15, s0, s16
	input[1] = 0.98f * tanhf(finalSample2);
   1dc9a:	eeb0 0a68 	vmov.f32	s0, s17
	input[0] = 0.98f * tanhf(finalSample1);
   1dc9e:	edc6 7a00 	vstr	s15, [r6]
	input[1] = 0.98f * tanhf(finalSample2);
   1dca2:	f012 fec3 	bl	30a2c <tanhf>
   1dca6:	ee20 0a08 	vmul.f32	s0, s0, s16
   1dcaa:	ed86 0a01 	vstr	s0, [r6, #4]
}
   1dcae:	b007      	add	sp, #28
   1dcb0:	ecbd 8b06 	vpop	{d8-d10}
   1dcb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!vocChFreeze)
   1dcb8:	f646 1778 	movw	r7, #27000	; 0x6978
		float zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1dcbc:	f64d 202c 	movw	r0, #55852	; 0xda2c
		if (!vocChFreeze)
   1dcc0:	f2c0 270e 	movt	r7, #526	; 0x20e
		float zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1dcc4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dcc8:	f009 fd1e 	bl	27708 <tZeroCrossing_tick>
		if (!vocChFreeze)
   1dccc:	683b      	ldr	r3, [r7, #0]
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1dcce:	f64e 372c 	movw	r7, #60204	; 0xeb2c
		if (!vocChFreeze)
   1dcd2:	2b00      	cmp	r3, #0
   1dcd4:	f000 8081 	beq.w	1ddda <SFXVocoderChTick+0x302>
   1dcd8:	f2c0 270f 	movt	r7, #527	; 0x20f
		float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1dcdc:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1dce0:	f64d 09bc 	movw	r9, #55484	; 0xd8bc
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1dce4:	f64d 48b8 	movw	r8, #56504	; 0xdcb8
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1dce8:	2400      	movs	r4, #0
		float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1dcea:	f2c0 200f 	movt	r0, #527	; 0x20f
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1dcee:	f2c0 290f 	movt	r9, #527	; 0x20f
		float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1dcf2:	f00d fb6b 	bl	2b3cc <tExpSmooth_tick>
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1dcf6:	f24d 10cc 	movw	r0, #53708	; 0xd1cc
		float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1dcfa:	eeb0 aa40 	vmov.f32	s20, s0
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1dcfe:	f2c0 280f 	movt	r8, #527	; 0x20f
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1dd02:	f2c0 200f 	movt	r0, #527	; 0x20f
	float sample = 0.0f;
   1dd06:	ee09 4a10 	vmov	s18, r4
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1dd0a:	f010 f873 	bl	2ddf4 <tNoise_tick>
			if (tempRamp > 0.0001f)
   1dd0e:	f24b 7317 	movw	r3, #46871	; 0xb717
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1dd12:	ee60 9a0a 	vmul.f32	s19, s0, s20
			if (tempRamp > 0.0001f)
   1dd16:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   1dd1a:	ee08 3a90 	vmov	s17, r3
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1dd1e:	e005      	b.n	1dd2c <SFXVocoderChTick+0x254>
					sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1dd20:	1958      	adds	r0, r3, r5
   1dd22:	f00f fff7 	bl	2dd14 <tSawtooth_tick>
   1dd26:	eea0 9a08 	vfma.f32	s18, s0, s16
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1dd2a:	3401      	adds	r4, #1
   1dd2c:	4648      	mov	r0, r9
   1dd2e:	00a5      	lsls	r5, r4, #2
   1dd30:	f00f feda 	bl	2dae8 <tSimplePoly_getNumVoices>
   1dd34:	42a0      	cmp	r0, r4
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1dd36:	eb08 0005 	add.w	r0, r8, r5
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1dd3a:	dd1f      	ble.n	1dd7c <SFXVocoderChTick+0x2a4>
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1dd3c:	f00d fb46 	bl	2b3cc <tExpSmooth_tick>
			if (tempRamp > 0.0001f)
   1dd40:	eeb4 0ae8 	vcmpe.f32	s0, s17
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1dd44:	eeb0 8a40 	vmov.f32	s16, s0
				if (displayValues[5] < 0.5f)
   1dd48:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
			if (tempRamp > 0.0001f)
   1dd4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dd50:	ddeb      	ble.n	1dd2a <SFXVocoderChTick+0x252>
				if (displayValues[5] < 0.5f)
   1dd52:	ed97 7a05 	vldr	s14, [r7, #20]
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1dd56:	f24c 50b0 	movw	r0, #50608	; 0xc5b0
					sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1dd5a:	f24d 637c 	movw	r3, #54908	; 0xd67c
				if (displayValues[5] < 0.5f)
   1dd5e:	eeb4 7ae7 	vcmpe.f32	s14, s15
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1dd62:	f2c0 200f 	movt	r0, #527	; 0x20f
					sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1dd66:	f2c0 230f 	movt	r3, #527	; 0x20f
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1dd6a:	4428      	add	r0, r5
				if (displayValues[5] < 0.5f)
   1dd6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dd70:	d4d6      	bmi.n	1dd20 <SFXVocoderChTick+0x248>
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1dd72:	f00b fd59 	bl	29828 <tRosenbergGlottalPulse_tick>
   1dd76:	eea0 9a08 	vfma.f32	s18, s0, s16
   1dd7a:	e7d6      	b.n	1dd2a <SFXVocoderChTick+0x252>
		sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1dd7c:	f649 139a 	movw	r3, #39322	; 0x999a
   1dd80:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1dd84:	edd7 6a08 	vldr	s13, [r7, #32]
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1dd88:	f24c 5080 	movw	r0, #50560	; 0xc580
		sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1dd8c:	f6c3 6399 	movt	r3, #16025	; 0x3e99
   1dd90:	ee37 8aca 	vsub.f32	s16, s15, s20
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1dd94:	f2c0 200f 	movt	r0, #527	; 0x20f
		sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1dd98:	ee07 3a10 	vmov	s14, r3
   1dd9c:	eee6 7ac7 	vfms.f32	s15, s13, s14
   1dda0:	ee27 8a88 	vmul.f32	s16, s15, s16
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1dda4:	f010 f826 	bl	2ddf4 <tNoise_tick>
   1dda8:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
   1ddac:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ddb0:	f00d fe54 	bl	2ba5c <tHighpass_tick>
   1ddb4:	edd7 7a08 	vldr	s15, [r7, #32]
		sample *= tExpSmooth_tick(&comp);
   1ddb8:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1ddbc:	ee77 7aa7 	vadd.f32	s15, s15, s15
		sample *= tExpSmooth_tick(&comp);
   1ddc0:	f2c0 200f 	movt	r0, #527	; 0x20f
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1ddc4:	ee67 7a80 	vmul.f32	s15, s15, s0
   1ddc8:	eee9 7a08 	vfma.f32	s15, s18, s16
   1ddcc:	ee79 9aa7 	vadd.f32	s19, s19, s15
		sample *= tExpSmooth_tick(&comp);
   1ddd0:	f00d fafc 	bl	2b3cc <tExpSmooth_tick>
   1ddd4:	ee29 0a80 	vmul.f32	s0, s19, s0
   1ddd8:	e69c      	b.n	1db14 <SFXVocoderChTick+0x3c>
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1ddda:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   1ddde:	f2c0 270f 	movt	r7, #527	; 0x20f
   1dde2:	2200      	movs	r2, #0
   1dde4:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   1dde8:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
   1ddec:	edd7 6a04 	vldr	s13, [r7, #16]
   1ddf0:	ee07 2a10 	vmov	s14, r2
   1ddf4:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
   1ddf8:	ee07 3a90 	vmov	s15, r3
   1ddfc:	f2c0 200f 	movt	r0, #527	; 0x20f
   1de00:	ee76 7ae7 	vsub.f32	s15, s13, s15
   1de04:	eef4 7ac0 	vcmpe.f32	s15, s0
   1de08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1de0c:	bf54      	ite	pl
   1de0e:	eeb0 0a47 	vmovpl.f32	s0, s14
   1de12:	eeb0 0a46 	vmovmi.f32	s0, s12
   1de16:	f00d facf 	bl	2b3b8 <tExpSmooth_setDest>
   1de1a:	e75f      	b.n	1dcdc <SFXVocoderChTick+0x204>
	for (int i = 0; i < numberOfVocoderBands; i++)
   1de1c:	ee08 3a10 	vmov	s16, r3
   1de20:	ee08 3a90 	vmov	s17, r3
   1de24:	e703      	b.n	1dc2e <SFXVocoderChTick+0x156>
   1de26:	bf00      	nop

0001de28 <SFXVocoderChFree>:
{
   1de28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1de2a:	f24e 54d4 	movw	r4, #58836	; 0xe5d4
   1de2e:	f64d 16c8 	movw	r6, #55752	; 0xd9c8
   1de32:	f24d 75cc 	movw	r5, #55244	; 0xd7cc
   1de36:	f2c0 240f 	movt	r4, #527	; 0x20f
   1de3a:	f2c0 260f 	movt	r6, #527	; 0x20f
   1de3e:	f2c0 250f 	movt	r5, #527	; 0x20f
   1de42:	f104 07c0 	add.w	r7, r4, #192	; 0xc0
		tVZFilter_free(&analysisBands[i][0]);
   1de46:	4620      	mov	r0, r4
   1de48:	f00e f81e 	bl	2be88 <tVZFilter_free>
		tVZFilter_free(&analysisBands[i][1]);
   1de4c:	1d20      	adds	r0, r4, #4
   1de4e:	f00e f81b 	bl	2be88 <tVZFilter_free>
		tVZFilter_free(&synthesisBands[i][0]);
   1de52:	1f28      	subs	r0, r5, #4
   1de54:	f00e f818 	bl	2be88 <tVZFilter_free>
   1de58:	3408      	adds	r4, #8
		tVZFilter_free(&synthesisBands[i][1]);
   1de5a:	4628      	mov	r0, r5
   1de5c:	3508      	adds	r5, #8
   1de5e:	f00e f813 	bl	2be88 <tVZFilter_free>
		tExpSmooth_free(&envFollowers[i]);
   1de62:	4630      	mov	r0, r6
   1de64:	f00d fa92 	bl	2b38c <tExpSmooth_free>
	for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
   1de68:	42a7      	cmp	r7, r4
   1de6a:	f106 0604 	add.w	r6, r6, #4
   1de6e:	d1ea      	bne.n	1de46 <SFXVocoderChFree+0x1e>
	tNoise_free(&breathNoise);
   1de70:	f24c 5080 	movw	r0, #50560	; 0xc580
   1de74:	f24d 667c 	movw	r6, #54908	; 0xd67c
   1de78:	f24c 55b0 	movw	r5, #50608	; 0xc5b0
	tHighpass_free(&chVocFinalHP2);
   1de7c:	2400      	movs	r4, #0
	tNoise_free(&breathNoise);
   1de7e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1de82:	f2c0 260f 	movt	r6, #527	; 0x20f
   1de86:	f00f ffb1 	bl	2ddec <tNoise_free>
	tNoise_free(&vocoderNoise);
   1de8a:	f24d 10cc 	movw	r0, #53708	; 0xd1cc
   1de8e:	f2c0 250f 	movt	r5, #527	; 0x20f
   1de92:	f2c0 200f 	movt	r0, #527	; 0x20f
   1de96:	f00f ffa9 	bl	2ddec <tNoise_free>
	tZeroCrossing_free(&zerox);
   1de9a:	f64d 202c 	movw	r0, #55852	; 0xda2c
   1de9e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dea2:	f009 fc21 	bl	276e8 <tZeroCrossing_free>
	tExpSmooth_free(&noiseRamp);
   1dea6:	f24e 50c4 	movw	r0, #58820	; 0xe5c4
   1deaa:	f2c0 200f 	movt	r0, #527	; 0x20f
   1deae:	f00d fa6d 	bl	2b38c <tExpSmooth_free>
	tHighpass_free(&noiseHP);
   1deb2:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
   1deb6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1deba:	f00d fdbb 	bl	2ba34 <tHighpass_free>
	tVZFilter_free(&vocodec_highshelf);
   1debe:	f64d 108c 	movw	r0, #55692	; 0xd98c
   1dec2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dec6:	f00d ffdf 	bl	2be88 <tVZFilter_free>
	tHighpass_free(&chVocFinalHP1);
   1deca:	f24c 50a4 	movw	r0, #50596	; 0xc5a4
   1dece:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ded2:	f00d fdaf 	bl	2ba34 <tHighpass_free>
	tHighpass_free(&chVocFinalHP2);
   1ded6:	f24e 50c8 	movw	r0, #58824	; 0xe5c8
   1deda:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dede:	f00d fda9 	bl	2ba34 <tHighpass_free>
		tSawtooth_free(&osc[i]);
   1dee2:	1930      	adds	r0, r6, r4
   1dee4:	f00f fede 	bl	2dca4 <tSawtooth_free>
		tRosenbergGlottalPulse_free(&glottal[i]);
   1dee8:	1928      	adds	r0, r5, r4
   1deea:	3404      	adds	r4, #4
   1deec:	f00b fc98 	bl	29820 <tRosenbergGlottalPulse_free>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1def0:	2c20      	cmp	r4, #32
   1def2:	d1f6      	bne.n	1dee2 <SFXVocoderChFree+0xba>
}
   1def4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1def6:	bf00      	nop

0001def8 <SFXPitchShiftAlloc>:
	tFormantShifter_initToPool(&fs, 7, &smallPool);
   1def8:	f64a 6290 	movw	r2, #44688	; 0xae90
   1defc:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
   1df00:	2107      	movs	r1, #7
   1df02:	f2c0 220f 	movt	r2, #527	; 0x20f
   1df06:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   1df0a:	b510      	push	{r4, lr}
   1df0c:	ed2d 8b02 	vpush	{d8}
	tFormantShifter_initToPool(&fs, 7, &smallPool);
   1df10:	f00c fb7c 	bl	2a60c <tFormantShifter_initToPool>
	tRetune_init(&retune, NUM_RETUNE, 1024, 512);
   1df14:	f24c 30f0 	movw	r0, #50160	; 0xc3f0
   1df18:	f44f 7300 	mov.w	r3, #512	; 0x200
   1df1c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1df20:	f2c0 200f 	movt	r0, #527	; 0x20f
   1df24:	2101      	movs	r1, #1
   1df26:	f00b fff5 	bl	29f14 <tRetune_init>
	tRetune_init(&retune2, NUM_RETUNE, 1024, 512);
   1df2a:	f64d 30e8 	movw	r0, #56296	; 0xdbe8
   1df2e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1df32:	f44f 7300 	mov.w	r3, #512	; 0x200
   1df36:	f2c0 200f 	movt	r0, #527	; 0x20f
   1df3a:	2101      	movs	r1, #1
   1df3c:	f00b ffea 	bl	29f14 <tRetune_init>
	tRamp_init(&pitchshiftRamp, 100.0f, 1);
   1df40:	f64d 2430 	movw	r4, #55856	; 0xda30
   1df44:	2300      	movs	r3, #0
   1df46:	2101      	movs	r1, #1
   1df48:	f2c0 240f 	movt	r4, #527	; 0x20f
   1df4c:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
   1df50:	4620      	mov	r0, r4
   1df52:	ee00 3a10 	vmov	s0, r3
   1df56:	f00d f911 	bl	2b17c <tRamp_init>
	tRamp_setVal(&pitchshiftRamp, 1.0f);
   1df5a:	4620      	mov	r0, r4
   1df5c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1df60:	f00d f98a 	bl	2b278 <tRamp_setVal>
	tSimplePoly_setNumVoices(&poly, 1);
   1df64:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1df68:	2101      	movs	r1, #1
   1df6a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1df6e:	f00f fdb3 	bl	2dad8 <tSimplePoly_setNumVoices>
	tExpSmooth_init(&smoother1, 0.0f, 0.01f);
   1df72:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1df76:	2200      	movs	r2, #0
   1df78:	f24c 50ac 	movw	r0, #50604	; 0xc5ac
   1df7c:	f6c3 4323 	movt	r3, #15395	; 0x3c23
   1df80:	ee00 2a10 	vmov	s0, r2
   1df84:	f2c0 200f 	movt	r0, #527	; 0x20f
   1df88:	ee00 3a90 	vmov	s1, r3
   1df8c:	ee08 2a90 	vmov	s17, r2
   1df90:	ee08 3a10 	vmov	s16, r3
   1df94:	f00d f9aa 	bl	2b2ec <tExpSmooth_init>
	tExpSmooth_init(&smoother2, 0.0f, 0.01f);
   1df98:	f24d 30e0 	movw	r0, #54240	; 0xd3e0
   1df9c:	eeb0 0a68 	vmov.f32	s0, s17
   1dfa0:	eef0 0a48 	vmov.f32	s1, s16
   1dfa4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1dfa8:	f00d f9a0 	bl	2b2ec <tExpSmooth_init>
	tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1dfac:	eef0 0a48 	vmov.f32	s1, s16
   1dfb0:	eeb0 0a68 	vmov.f32	s0, s17
   1dfb4:	f64d 301c 	movw	r0, #56092	; 0xdb1c
}
   1dfb8:	ecbd 8b02 	vpop	{d8}
	tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1dfbc:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   1dfc0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1dfc4:	f00d b992 	b.w	2b2ec <tExpSmooth_init>

0001dfc8 <SFXPitchShiftFrame>:
}
   1dfc8:	4770      	bx	lr
   1dfca:	bf00      	nop

0001dfcc <SFXPitchShiftTick>:
{
   1dfcc:	b570      	push	{r4, r5, r6, lr}
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1dfce:	f64c 2578 	movw	r5, #51832	; 0xca78
   1dfd2:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
	float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1dfd6:	f64c 43cd 	movw	r3, #52429	; 0xcccd
	displayValues[0] = myPitchFactorCombined;
   1dfda:	f64e 342c 	movw	r4, #60204	; 0xeb2c
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1dfde:	f2c0 250f 	movt	r5, #527	; 0x20f
{
   1dfe2:	4606      	mov	r6, r0
	float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1dfe4:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
	float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1dfe8:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1dfec:	edd5 6a33 	vldr	s13, [r5, #204]	; 0xcc
	displayValues[0] = myPitchFactorCombined;
   1dff0:	f2c0 240f 	movt	r4, #527	; 0x20f
	float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
   1dff4:	ed95 6a32 	vldr	s12, [r5, #200]	; 0xc8
	float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1dff8:	ee07 3a90 	vmov	s15, r3
	float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1dffc:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e000:	2100      	movs	r1, #0
{
   1e002:	ed2d 8b04 	vpush	{d8-d9}
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1e006:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
{
   1e00a:	b082      	sub	sp, #8
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1e00c:	eef0 5a48 	vmov.f32	s11, s16
	float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
   1e010:	eea6 8a07 	vfma.f32	s16, s12, s14
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1e014:	eee6 5a87 	vfma.f32	s11, s13, s14
	float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1e018:	eea5 8aa7 	vfma.f32	s16, s11, s15
	displayValues[0] = myPitchFactorCombined;
   1e01c:	ed84 8a00 	vstr	s16, [r4]
	displayValues[1] = myPitchFactorCombined;
   1e020:	ed84 8a01 	vstr	s16, [r4, #4]
	float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1e024:	f00f fd82 	bl	2db2c <tSimplePoly_getPitchAndCheckActive>
   1e028:	ee07 0a90 	vmov	s15, r0
   1e02c:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
	if (keyPitch >= 0)
   1e030:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   1e034:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1e038:	f280 80d1 	bge.w	1e1de <SFXPitchShiftTick+0x212>
		keyPitch = 1.0f;
   1e03c:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
	float myPitchFactor = fastexp2f(myPitchFactorCombined);
   1e040:	eeb0 0a48 	vmov.f32	s0, s16
   1e044:	f00e fde8 	bl	2cc18 <fastexp2f>
	myPitchFactor *= keyPitch;
   1e048:	ee68 8a80 	vmul.f32	s17, s17, s0
	tRetune_setPitchFactor(&retune, myPitchFactor, 0);
   1e04c:	f24c 30f0 	movw	r0, #50160	; 0xc3f0
   1e050:	2100      	movs	r1, #0
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1e052:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
	tRetune_setPitchFactor(&retune, myPitchFactor, 0);
   1e056:	eeb0 0a68 	vmov.f32	s0, s17
   1e05a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e05e:	f00c f87d 	bl	2a15c <tRetune_setPitchFactor>
	tRetune_setPitchFactor(&retune2, myPitchFactor, 0);
   1e062:	f64d 30e8 	movw	r0, #56296	; 0xdbe8
   1e066:	2100      	movs	r1, #0
   1e068:	eeb0 0a68 	vmov.f32	s0, s17
   1e06c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e070:	f00c f874 	bl	2a15c <tRetune_setPitchFactor>
	displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
   1e074:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   1e078:	eeb0 1a08 	vmov.f32	s2, #8	; 0x40400000  3.0
   1e07c:	2200      	movs	r2, #0
   1e07e:	f6cb 634c 	movt	r3, #48716	; 0xbe4c
   1e082:	edd5 7a34 	vldr	s15, [r5, #208]	; 0xd0
   1e086:	ee00 2a10 	vmov	s0, r2
   1e08a:	ee00 3a90 	vmov	s1, r3
   1e08e:	eee7 0a81 	vfma.f32	s1, s15, s2
   1e092:	f00e fea5 	bl	2cde0 <LEAF_clip>
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1e096:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
	displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
   1e09a:	ed84 0a02 	vstr	s0, [r4, #8]
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1e09e:	eeb0 0a49 	vmov.f32	s0, s18
   1e0a2:	ed95 7a35 	vldr	s14, [r5, #212]	; 0xd4
   1e0a6:	eea7 0a27 	vfma.f32	s0, s14, s15
   1e0aa:	f00e fdb5 	bl	2cc18 <fastexp2f>
	tExpSmooth_setDest(&smoother3, displayValues[2]);
   1e0ae:	f64d 301c 	movw	r0, #56092	; 0xdb1c
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1e0b2:	ed84 0a03 	vstr	s0, [r4, #12]
	tExpSmooth_setDest(&smoother3, displayValues[2]);
   1e0b6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e0ba:	ed94 0a02 	vldr	s0, [r4, #8]
   1e0be:	f00d f97b 	bl	2b3b8 <tExpSmooth_setDest>
	tFormantShifter_setIntensity(&fs, tExpSmooth_tick(&smoother3)+.1f);
   1e0c2:	f64d 301c 	movw	r0, #56092	; 0xdb1c
   1e0c6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e0ca:	f00d f97f 	bl	2b3cc <tExpSmooth_tick>
   1e0ce:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   1e0d2:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
   1e0d6:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
   1e0da:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e0de:	ee07 3a90 	vmov	s15, r3
   1e0e2:	ee30 0a27 	vadd.f32	s0, s0, s15
   1e0e6:	f00c fd55 	bl	2ab94 <tFormantShifter_setIntensity>
	tFormantShifter_setShiftFactor(&fs, displayValues[3]);
   1e0ea:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
   1e0ee:	ed94 0a03 	vldr	s0, [r4, #12]
   1e0f2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e0f6:	f00c fd49 	bl	2ab8c <tFormantShifter_setShiftFactor>
	if (displayValues[2] > 0.01f)
   1e0fa:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1e0fe:	ed94 7a02 	vldr	s14, [r4, #8]
		tRamp_setDest(&pitchshiftRamp, -1.0f);
   1e102:	f64d 2030 	movw	r0, #55856	; 0xda30
	if (displayValues[2] > 0.01f)
   1e106:	f6c3 4323 	movt	r3, #15395	; 0x3c23
		tRamp_setDest(&pitchshiftRamp, 1.0f);
   1e10a:	f2c0 200f 	movt	r0, #527	; 0x20f
	if (displayValues[2] > 0.01f)
   1e10e:	ee07 3a90 	vmov	s15, r3
   1e112:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1e116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		tRamp_setDest(&pitchshiftRamp, -1.0f);
   1e11a:	bfcc      	ite	gt
   1e11c:	eeb0 0a49 	vmovgt.f32	s0, s18
		tRamp_setDest(&pitchshiftRamp, 1.0f);
   1e120:	eeb7 0a00 	vmovle.f32	s0, #112	; 0x3f800000  1.0
   1e124:	f00d f89a 	bl	2b25c <tRamp_setDest>
	float crossfadeVal = tRamp_tick(&pitchshiftRamp);
   1e128:	f64d 2030 	movw	r0, #55856	; 0xda30
   1e12c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e130:	f00d f8b0 	bl	2b294 <tRamp_tick>
	LEAF_crossfade(crossfadeVal, myGains);
   1e134:	4668      	mov	r0, sp
   1e136:	f00e fdc3 	bl	2ccc0 <LEAF_crossfade>
	tExpSmooth_setDest(&smoother1, myGains[0]);
   1e13a:	f24c 50ac 	movw	r0, #50604	; 0xc5ac
   1e13e:	ed9d 0a00 	vldr	s0, [sp]
   1e142:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e146:	f00d f937 	bl	2b3b8 <tExpSmooth_setDest>
	tExpSmooth_setDest(&smoother2, myGains[1]);
   1e14a:	f24d 30e0 	movw	r0, #54240	; 0xd3e0
   1e14e:	ed9d 0a01 	vldr	s0, [sp, #4]
   1e152:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e156:	f00d f92f 	bl	2b3b8 <tExpSmooth_setDest>
	float formantsample = tanhf(tFormantShifter_remove(&fs, input[1]));
   1e15a:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
   1e15e:	ed96 0a01 	vldr	s0, [r6, #4]
   1e162:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e166:	f00c fb57 	bl	2a818 <tFormantShifter_remove>
   1e16a:	f012 fc5f 	bl	30a2c <tanhf>
	float* samples = tRetune_tick(&retune2, formantsample);
   1e16e:	f64d 30e8 	movw	r0, #56296	; 0xdbe8
   1e172:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e176:	f00b ff1b 	bl	29fb0 <tRetune_tick>
	formantsample = samples[0];
   1e17a:	edd0 8a00 	vldr	s17, [r0]
	samples = tRetune_tick(&retune, sample);
   1e17e:	f24c 30f0 	movw	r0, #50160	; 0xc3f0
   1e182:	ed96 0a01 	vldr	s0, [r6, #4]
   1e186:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e18a:	f00b ff11 	bl	29fb0 <tRetune_tick>
	sample = samples[0];
   1e18e:	ed90 8a00 	vldr	s16, [r0]
	formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1e192:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
   1e196:	eeb0 0a68 	vmov.f32	s0, s17
   1e19a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e19e:	f00c fbbf 	bl	2a920 <tFormantShifter_add>
   1e1a2:	f012 fc43 	bl	30a2c <tanhf>
   1e1a6:	f24d 30e0 	movw	r0, #54240	; 0xd3e0
   1e1aa:	eeb0 9a40 	vmov.f32	s18, s0
   1e1ae:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e1b2:	f00d f90b 	bl	2b3cc <tExpSmooth_tick>
	sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
   1e1b6:	f24c 50ac 	movw	r0, #50604	; 0xc5ac
	formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1e1ba:	eef0 8a40 	vmov.f32	s17, s0
	sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
   1e1be:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e1c2:	f00d f903 	bl	2b3cc <tExpSmooth_tick>
   1e1c6:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e1ca:	eea9 0a28 	vfma.f32	s0, s18, s17
	input[0] = sample;
   1e1ce:	ed86 0a00 	vstr	s0, [r6]
	input[1] = sample;
   1e1d2:	ed86 0a01 	vstr	s0, [r6, #4]
}
   1e1d6:	b002      	add	sp, #8
   1e1d8:	ecbd 8b04 	vpop	{d8-d9}
   1e1dc:	bd70      	pop	{r4, r5, r6, pc}
		keyPitch = LEAF_midiToFrequency(keyPitch) * 0.003822629969419f ;
   1e1de:	f00e fee7 	bl	2cfb0 <LEAF_midiToFrequency>
   1e1e2:	f248 5317 	movw	r3, #34071	; 0x8517
   1e1e6:	f6c3 337a 	movt	r3, #15226	; 0x3b7a
   1e1ea:	ee08 3a90 	vmov	s17, r3
   1e1ee:	ee60 8a28 	vmul.f32	s17, s0, s17
   1e1f2:	e725      	b.n	1e040 <SFXPitchShiftTick+0x74>

0001e1f4 <SFXPitchShiftFree>:
	tFormantShifter_free(&fs);
   1e1f4:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
{
   1e1f8:	b508      	push	{r3, lr}
	tFormantShifter_free(&fs);
   1e1fa:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e1fe:	f00c facf 	bl	2a7a0 <tFormantShifter_free>
	tRetune_free(&retune);
   1e202:	f24c 30f0 	movw	r0, #50160	; 0xc3f0
   1e206:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e20a:	f00b fe8f 	bl	29f2c <tRetune_free>
	tRetune_free(&retune2);
   1e20e:	f64d 30e8 	movw	r0, #56296	; 0xdbe8
   1e212:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e216:	f00b fe89 	bl	29f2c <tRetune_free>
	tRamp_free(&pitchshiftRamp);
   1e21a:	f64d 2030 	movw	r0, #55856	; 0xda30
   1e21e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e222:	f00d f817 	bl	2b254 <tRamp_free>
	tExpSmooth_free(&smoother1);
   1e226:	f24c 50ac 	movw	r0, #50604	; 0xc5ac
   1e22a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e22e:	f00d f8ad 	bl	2b38c <tExpSmooth_free>
	tExpSmooth_free(&smoother2);
   1e232:	f24d 30e0 	movw	r0, #54240	; 0xd3e0
   1e236:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e23a:	f00d f8a7 	bl	2b38c <tExpSmooth_free>
	tExpSmooth_free(&smoother3);
   1e23e:	f64d 301c 	movw	r0, #56092	; 0xdb1c
}
   1e242:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tExpSmooth_free(&smoother3);
   1e246:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e24a:	f00d b89f 	b.w	2b38c <tExpSmooth_free>
   1e24e:	bf00      	nop

0001e250 <SFXNeartuneAlloc>:
{
   1e250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	leaf.clearOnAllocation = 1;
   1e252:	f64f 0408 	movw	r4, #63496	; 0xf808
   1e256:	2501      	movs	r5, #1
	tRetune_init(&autotuneMono, 1, 512, 256);
   1e258:	f64d 00b4 	movw	r0, #55476	; 0xd8b4
   1e25c:	f44f 7380 	mov.w	r3, #256	; 0x100
	leaf.clearOnAllocation = 1;
   1e260:	f2c0 240f 	movt	r4, #527	; 0x20f
	tRetune_init(&autotuneMono, 1, 512, 256);
   1e264:	4629      	mov	r1, r5
   1e266:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e26a:	f44f 7200 	mov.w	r2, #512	; 0x200
	leaf.clearOnAllocation = 1;
   1e26e:	6165      	str	r5, [r4, #20]
	tRetune_init(&autotuneMono, 1, 512, 256);
   1e270:	f00b fe50 	bl	29f14 <tRetune_init>
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e274:	f646 13b8 	movw	r3, #27064	; 0x69b8
   1e278:	f24c 70b0 	movw	r0, #51120	; 0xc7b0
   1e27c:	f646 1584 	movw	r5, #27012	; 0x6984
   1e280:	f64a 26ab 	movw	r6, #43691	; 0xaaab
   1e284:	f2c0 230e 	movt	r3, #526	; 0x20e
   1e288:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e28c:	f2c0 250e 	movt	r5, #526	; 0x20e
   1e290:	f6c2 26aa 	movt	r6, #10922	; 0x2aaa
   1e294:	781f      	ldrb	r7, [r3, #0]
	for (int i = 0; i < 128; i++)
   1e296:	2100      	movs	r1, #0
		float tempNote = i;
   1e298:	ee07 1a90 	vmov	s15, r1
	for (int i = 0; i < 128; i++)
   1e29c:	3101      	adds	r1, #1
		float tempNote = i;
   1e29e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	for (int i = 0; i < 128; i++)
   1e2a2:	2980      	cmp	r1, #128	; 0x80
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e2a4:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1e2a8:	ee17 3a90 	vmov	r3, s15
   1e2ac:	eba3 0307 	sub.w	r3, r3, r7
   1e2b0:	fb86 2403 	smull	r2, r4, r6, r3
   1e2b4:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1e2b8:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   1e2bc:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1e2c0:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1e2c4:	ee07 3a90 	vmov	s15, r3
   1e2c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1e2cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1e2d0:	ee17 3a90 	vmov	r3, s15
   1e2d4:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   1e2d8:	edd3 7a00 	vldr	s15, [r3]
   1e2dc:	ee77 7a87 	vadd.f32	s15, s15, s14
		notes[i] = tunedNote;
   1e2e0:	ece0 7a01 	vstmia	r0!, {s15}
	for (int i = 0; i < 128; i++)
   1e2e4:	d1d8      	bne.n	1e298 <SFXNeartuneAlloc+0x48>
	tExpSmooth_init(&neartune_smoother, 1.0f, .007f);
   1e2e6:	f246 0342 	movw	r3, #24642	; 0x6042
   1e2ea:	f64d 1084 	movw	r0, #55684	; 0xd984
   1e2ee:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e2f2:	f6c3 33e5 	movt	r3, #15333	; 0x3be5
   1e2f6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e2fa:	ee00 3a90 	vmov	s1, r3
   1e2fe:	f00c fff5 	bl	2b2ec <tExpSmooth_init>
	tRamp_init(&nearWetRamp, 20.0f, 1);
   1e302:	f24e 60fc 	movw	r0, #59132	; 0xe6fc
   1e306:	2101      	movs	r1, #1
   1e308:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1e30c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e310:	f00c ff34 	bl	2b17c <tRamp_init>
	setLED_A(autotuneChromatic);
   1e314:	f646 0384 	movw	r3, #26756	; 0x6884
   1e318:	f2c0 230e 	movt	r3, #526	; 0x20e
   1e31c:	7818      	ldrb	r0, [r3, #0]
   1e31e:	f7fc ff09 	bl	1b134 <setLED_A>
	setLED_C(autotuneLock);
   1e322:	f646 0388 	movw	r3, #26760	; 0x6888
   1e326:	f2c0 230e 	movt	r3, #526	; 0x20e
   1e32a:	7818      	ldrb	r0, [r3, #0]
   1e32c:	f7fc ff22 	bl	1b174 <setLED_C>
	lastSnap = 1.0f;
   1e330:	f246 2350 	movw	r3, #25168	; 0x6250
   1e334:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
   1e338:	f2c0 0306 	movt	r3, #6
   1e33c:	601a      	str	r2, [r3, #0]
}
   1e33e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001e340 <SFXNeartuneFrame>:
	if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
   1e340:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
{
   1e344:	b538      	push	{r3, r4, r5, lr}
	if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
   1e346:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e34a:	f00f fbd1 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
   1e34e:	bb60      	cbnz	r0, 1e3aa <SFXNeartuneFrame+0x6a>
   1e350:	f646 0384 	movw	r3, #26756	; 0x6884
   1e354:	f2c0 230e 	movt	r3, #526	; 0x20e
   1e358:	781b      	ldrb	r3, [r3, #0]
   1e35a:	2b01      	cmp	r3, #1
   1e35c:	d025      	beq.n	1e3aa <SFXNeartuneFrame+0x6a>
   1e35e:	f646 0388 	movw	r3, #26760	; 0x6888
   1e362:	f2c0 230e 	movt	r3, #526	; 0x20e
   1e366:	681b      	ldr	r3, [r3, #0]
   1e368:	2b01      	cmp	r3, #1
   1e36a:	d01e      	beq.n	1e3aa <SFXNeartuneFrame+0x6a>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e36c:	f64e 247c 	movw	r4, #60028	; 0xea7c
		tRamp_setDest(&nearWetRamp, -1.0f);
   1e370:	f24e 60fc 	movw	r0, #59132	; 0xe6fc
   1e374:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e378:	f2c0 240f 	movt	r4, #527	; 0x20f
		tRamp_setDest(&nearWetRamp, -1.0f);
   1e37c:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e380:	f00c ff6c 	bl	2b25c <tRamp_setDest>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e384:	7d23      	ldrb	r3, [r4, #20]
   1e386:	b1fb      	cbz	r3, 1e3c8 <SFXNeartuneFrame+0x88>
		autotuneChromatic = !autotuneChromatic;
   1e388:	f646 0284 	movw	r2, #26756	; 0x6884
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e38c:	2300      	movs	r3, #0
		autotuneChromatic = !autotuneChromatic;
   1e38e:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e392:	7523      	strb	r3, [r4, #20]
		autotuneChromatic = !autotuneChromatic;
   1e394:	7813      	ldrb	r3, [r2, #0]
   1e396:	fab3 f383 	clz	r3, r3
   1e39a:	095b      	lsrs	r3, r3, #5
		setLED_A(autotuneChromatic);
   1e39c:	4618      	mov	r0, r3
		autotuneChromatic = !autotuneChromatic;
   1e39e:	7013      	strb	r3, [r2, #0]
		setLED_A(autotuneChromatic);
   1e3a0:	f7fc fec8 	bl	1b134 <setLED_A>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e3a4:	7f23      	ldrb	r3, [r4, #28]
   1e3a6:	b993      	cbnz	r3, 1e3ce <SFXNeartuneFrame+0x8e>
}
   1e3a8:	bd38      	pop	{r3, r4, r5, pc}
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e3aa:	f64e 247c 	movw	r4, #60028	; 0xea7c
		tRamp_setDest(&nearWetRamp, 1.0f);
   1e3ae:	f24e 60fc 	movw	r0, #59132	; 0xe6fc
   1e3b2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e3b6:	f2c0 240f 	movt	r4, #527	; 0x20f
		tRamp_setDest(&nearWetRamp, 1.0f);
   1e3ba:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e3be:	f00c ff4d 	bl	2b25c <tRamp_setDest>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e3c2:	7d23      	ldrb	r3, [r4, #20]
   1e3c4:	2b00      	cmp	r3, #0
   1e3c6:	d1df      	bne.n	1e388 <SFXNeartuneFrame+0x48>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e3c8:	7f23      	ldrb	r3, [r4, #28]
   1e3ca:	2b00      	cmp	r3, #0
   1e3cc:	d0ec      	beq.n	1e3a8 <SFXNeartuneFrame+0x68>
		autotuneLock = !autotuneLock;
   1e3ce:	f646 0588 	movw	r5, #26760	; 0x6888
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e3d2:	2300      	movs	r3, #0
		autotuneLock = !autotuneLock;
   1e3d4:	f2c0 250e 	movt	r5, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e3d8:	7723      	strb	r3, [r4, #28]
		autotuneLock = !autotuneLock;
   1e3da:	682b      	ldr	r3, [r5, #0]
   1e3dc:	fab3 f383 	clz	r3, r3
   1e3e0:	095b      	lsrs	r3, r3, #5
		setLED_C(autotuneLock);
   1e3e2:	4618      	mov	r0, r3
		autotuneLock = !autotuneLock;
   1e3e4:	602b      	str	r3, [r5, #0]
		setLED_C(autotuneLock);
   1e3e6:	f7fc fec5 	bl	1b174 <setLED_C>
		if (autotuneLock)
   1e3ea:	6829      	ldr	r1, [r5, #0]
   1e3ec:	b181      	cbz	r1, 1e410 <SFXNeartuneFrame+0xd0>
   1e3ee:	f646 0598 	movw	r5, #26776	; 0x6898
   1e3f2:	f646 1410 	movw	r4, #26896	; 0x6910
   1e3f6:	f2c0 250e 	movt	r5, #526	; 0x20e
   1e3fa:	f2c0 240e 	movt	r4, #526	; 0x20e
   1e3fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1e400:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1e402:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1e404:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1e406:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1e40a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
   1e40e:	bd38      	pop	{r3, r4, r5, pc}
   1e410:	f646 1010 	movw	r0, #26896	; 0x6910
   1e414:	2230      	movs	r2, #48	; 0x30
   1e416:	f2c0 200e 	movt	r0, #526	; 0x20e
   1e41a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1e41e:	f011 bec8 	b.w	301b2 <memset>
   1e422:	bf00      	nop

0001e424 <SFXNeartuneFree>:
	tRetune_free(&autotuneMono);
   1e424:	f64d 00b4 	movw	r0, #55476	; 0xd8b4
{
   1e428:	b508      	push	{r3, lr}
	tRetune_free(&autotuneMono);
   1e42a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e42e:	f00b fd7d 	bl	29f2c <tRetune_free>
	tExpSmooth_free(&neartune_smoother);
   1e432:	f64d 1084 	movw	r0, #55684	; 0xd984
   1e436:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e43a:	f00c ffa7 	bl	2b38c <tExpSmooth_free>
	tRamp_free(&nearWetRamp);
   1e43e:	f24e 60fc 	movw	r0, #59132	; 0xe6fc
}
   1e442:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tRamp_free(&nearWetRamp);
   1e446:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e44a:	f00c bf03 	b.w	2b254 <tRamp_free>
   1e44e:	bf00      	nop

0001e450 <SFXAutotuneAlloc>:
	tAutotune_init(&autotunePoly, NUM_AUTOTUNE, 1024, 512);
   1e450:	f24d 10a0 	movw	r0, #53664	; 0xd1a0
   1e454:	2104      	movs	r1, #4
   1e456:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e45a:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   1e45e:	b508      	push	{r3, lr}
	tAutotune_init(&autotunePoly, NUM_AUTOTUNE, 1024, 512);
   1e460:	f44f 7300 	mov.w	r3, #512	; 0x200
   1e464:	f00b ff78 	bl	2a358 <tAutotune_init>
	tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
   1e468:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1e46c:	2104      	movs	r1, #4
   1e46e:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   1e472:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
   1e476:	f00f bb2f 	b.w	2dad8 <tSimplePoly_setNumVoices>
   1e47a:	bf00      	nop

0001e47c <SFXAutotuneFrame>:
{
   1e47c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1e480:	2300      	movs	r3, #0
   1e482:	f24d 17a4 	movw	r7, #53668	; 0xd1a4
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e486:	f64d 05bc 	movw	r5, #55484	; 0xd8bc
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e48a:	f64a 28ab 	movw	r8, #43691	; 0xaaab
   1e48e:	f2c0 270f 	movt	r7, #527	; 0x20f
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e492:	461c      	mov	r4, r3
   1e494:	f2c0 250f 	movt	r5, #527	; 0x20f
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e498:	f6c2 28aa 	movt	r8, #10922	; 0x2aaa
{
   1e49c:	ed2d 8b02 	vpush	{d8}
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1e4a0:	ee08 3a10 	vmov	s16, r3
{
   1e4a4:	b082      	sub	sp, #8
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e4a6:	e049      	b.n	1e53c <SFXAutotuneFrame+0xc0>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e4a8:	f00f fb3a 	bl	2db20 <tSimplePoly_getPitch>
   1e4ac:	f646 1240 	movw	r2, #26944	; 0x6940
   1e4b0:	ee07 0a90 	vmov	s15, r0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e4b4:	f646 13b8 	movw	r3, #27064	; 0x69b8
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e4b8:	f2c0 220e 	movt	r2, #526	; 0x20e
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1e4bc:	f646 1184 	movw	r1, #27012	; 0x6984
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e4c0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e4c4:	f2c0 230e 	movt	r3, #526	; 0x20e
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e4c8:	ed92 0a00 	vldr	s0, [r2]
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1e4cc:	f2c0 210e 	movt	r1, #526	; 0x20e
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e4d0:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e4d2:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1e4d6:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1e4da:	ee17 3a90 	vmov	r3, s15
   1e4de:	1a9b      	subs	r3, r3, r2
   1e4e0:	fb88 2003 	smull	r2, r0, r8, r3
   1e4e4:	17da      	asrs	r2, r3, #31
   1e4e6:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1e4ea:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1e4ee:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1e4f2:	ee07 3a90 	vmov	s15, r3
   1e4f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1e4fa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1e4fe:	ee17 3a90 	vmov	r3, s15
   1e502:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   1e506:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1e50a:	ee37 0a00 	vadd.f32	s0, s14, s0
   1e50e:	f00e fd4f 	bl	2cfb0 <LEAF_midiToFrequency>
   1e512:	f64d 43b8 	movw	r3, #56504	; 0xdcb8
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1e516:	4631      	mov	r1, r6
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1e518:	eca7 0a01 	vstmia	r7!, {s0}
   1e51c:	f2c0 230f 	movt	r3, #527	; 0x20f
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1e520:	4628      	mov	r0, r5
   1e522:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   1e526:	3401      	adds	r4, #1
   1e528:	f00f fb06 	bl	2db38 <tSimplePoly_getVelocity>
   1e52c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e530:	2800      	cmp	r0, #0
   1e532:	4630      	mov	r0, r6
   1e534:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1e538:	f00c ff3e 	bl	2b3b8 <tExpSmooth_setDest>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e53c:	4628      	mov	r0, r5
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e53e:	b2e6      	uxtb	r6, r4
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e540:	f00f fad2 	bl	2dae8 <tSimplePoly_getNumVoices>
   1e544:	42a0      	cmp	r0, r4
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e546:	4631      	mov	r1, r6
   1e548:	4628      	mov	r0, r5
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e54a:	dcad      	bgt.n	1e4a8 <SFXAutotuneFrame+0x2c>
	int tempNumVoices = tSimplePoly_getNumActiveVoices(&poly);
   1e54c:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1e550:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e554:	f00f facc 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
	if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1e558:	9001      	str	r0, [sp, #4]
   1e55a:	b920      	cbnz	r0, 1e566 <SFXAutotuneFrame+0xea>
}
   1e55c:	b002      	add	sp, #8
   1e55e:	ecbd 8b02 	vpop	{d8}
   1e562:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1e566:	ee07 0a90 	vmov	s15, r0
   1e56a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e56e:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1e572:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1e576:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e57a:	ee80 0a27 	vdiv.f32	s0, s0, s15
}
   1e57e:	b002      	add	sp, #8
   1e580:	ecbd 8b02 	vpop	{d8}
   1e584:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1e588:	f00c bf16 	b.w	2b3b8 <tExpSmooth_setDest>

0001e58c <SFXAutotuneTick>:
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1e58c:	f64c 2178 	movw	r1, #51832	; 0xca78
   1e590:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
   1e594:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1e598:	f64e 322c 	movw	r2, #60204	; 0xeb2c
   1e59c:	f2c0 210f 	movt	r1, #527	; 0x20f
   1e5a0:	f6c3 63f0 	movt	r3, #16112	; 0x3ef0
   1e5a4:	f2c0 220f 	movt	r2, #527	; 0x20f
   1e5a8:	ee07 3a10 	vmov	s14, r3
{
   1e5ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e5b0:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1e5b4:	edd1 6a64 	vldr	s13, [r1, #400]	; 0x190
{
   1e5b8:	4680      	mov	r8, r0
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1e5ba:	f24d 10a0 	movw	r0, #53664	; 0xd1a0
   1e5be:	f24d 15a4 	movw	r5, #53668	; 0xd1a4
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1e5c2:	eee6 7a87 	vfma.f32	s15, s13, s14
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e5c6:	f64d 07bc 	movw	r7, #55484	; 0xd8bc
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1e5ca:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e5ce:	f2c0 250f 	movt	r5, #527	; 0x20f
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e5d2:	f2c0 270f 	movt	r7, #527	; 0x20f
   1e5d6:	2400      	movs	r4, #0
		tAutotune_setFreq(&autotunePoly, freq[i], i);
   1e5d8:	4606      	mov	r6, r0
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1e5da:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1e5de:	edc2 7a00 	vstr	s15, [r2]
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1e5e2:	f00c f80f 	bl	2a604 <tAutotune_setFidelityThreshold>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e5e6:	e003      	b.n	1e5f0 <SFXAutotuneTick+0x64>
		tAutotune_setFreq(&autotunePoly, freq[i], i);
   1e5e8:	ecb5 0a01 	vldmia	r5!, {s0}
   1e5ec:	f00c f802 	bl	2a5f4 <tAutotune_setFreq>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e5f0:	4638      	mov	r0, r7
   1e5f2:	f00f fa79 	bl	2dae8 <tSimplePoly_getNumVoices>
   1e5f6:	42a0      	cmp	r0, r4
		tAutotune_setFreq(&autotunePoly, freq[i], i);
   1e5f8:	4621      	mov	r1, r4
   1e5fa:	4630      	mov	r0, r6
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e5fc:	f104 0401 	add.w	r4, r4, #1
   1e600:	dcf2      	bgt.n	1e5e8 <SFXAutotuneTick+0x5c>
	float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1e602:	f24d 10a0 	movw	r0, #53664	; 0xd1a0
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e606:	f64d 07bc 	movw	r7, #55484	; 0xd8bc
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1e60a:	f64d 46b8 	movw	r6, #56504	; 0xdcb8
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e60e:	2400      	movs	r4, #0
	float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1e610:	ed98 0a01 	vldr	s0, [r8, #4]
   1e614:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e618:	f00b feec 	bl	2a3f4 <tAutotune_tick>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e61c:	f2c0 270f 	movt	r7, #527	; 0x20f
	float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1e620:	4605      	mov	r5, r0
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1e622:	f2c0 260f 	movt	r6, #527	; 0x20f
	float sample = 0.0f;
   1e626:	ee08 4a10 	vmov	s16, r4
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e62a:	e005      	b.n	1e638 <SFXAutotuneTick+0xac>
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1e62c:	ecf5 8a01 	vldmia	r5!, {s17}
   1e630:	f00c fecc 	bl	2b3cc <tExpSmooth_tick>
   1e634:	eea8 8a80 	vfma.f32	s16, s17, s0
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e638:	4638      	mov	r0, r7
   1e63a:	f00f fa55 	bl	2dae8 <tSimplePoly_getNumVoices>
   1e63e:	42a0      	cmp	r0, r4
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1e640:	eb06 0084 	add.w	r0, r6, r4, lsl #2
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1e644:	f104 0401 	add.w	r4, r4, #1
   1e648:	dcf0      	bgt.n	1e62c <SFXAutotuneTick+0xa0>
	sample *= tExpSmooth_tick(&comp);
   1e64a:	f24d 50fc 	movw	r0, #54780	; 0xd5fc
   1e64e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e652:	f00c febb 	bl	2b3cc <tExpSmooth_tick>
   1e656:	ee28 0a00 	vmul.f32	s0, s16, s0
	input[0] = sample;
   1e65a:	ed88 0a00 	vstr	s0, [r8]
	input[1] = sample;
   1e65e:	ed88 0a01 	vstr	s0, [r8, #4]
}
   1e662:	ecbd 8b02 	vpop	{d8}
   1e666:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e66a:	bf00      	nop

0001e66c <SFXAutotuneFree>:
	tAutotune_free(&autotunePoly);
   1e66c:	f24d 10a0 	movw	r0, #53664	; 0xd1a0
   1e670:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e674:	f00b be7c 	b.w	2a370 <tAutotune_free>

0001e678 <SFXSamplerBPAlloc>:
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1e678:	f64f 0108 	movw	r1, #63496	; 0xf808
   1e67c:	2300      	movs	r3, #0
   1e67e:	f24a 52b8 	movw	r2, #42424	; 0xa5b8
   1e682:	f2c4 332c 	movt	r3, #17196	; 0x432c
   1e686:	f2c0 210f 	movt	r1, #527	; 0x20f
   1e68a:	f2c0 220f 	movt	r2, #527	; 0x20f
   1e68e:	ee07 3a90 	vmov	s15, r3
{
   1e692:	b570      	push	{r4, r5, r6, lr}
   1e694:	ed2d 8b02 	vpush	{d8}
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1e698:	ed91 7a00 	vldr	s14, [r1]
   1e69c:	f24d 3458 	movw	r4, #54104	; 0xd358
	tSampler_init(&sampler, &buff);
   1e6a0:	f24d 56f4 	movw	r6, #54772	; 0xd5f4
	tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1e6a4:	f64a 6590 	movw	r5, #44688	; 0xae90
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1e6a8:	ee67 7a27 	vmul.f32	s15, s14, s15
   1e6ac:	f2c0 240f 	movt	r4, #527	; 0x20f
	tSampler_init(&sampler, &buff);
   1e6b0:	f2c0 260f 	movt	r6, #527	; 0x20f
	tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1e6b4:	f2c0 250f 	movt	r5, #527	; 0x20f
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1e6b8:	4620      	mov	r0, r4
   1e6ba:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1e6be:	ee17 1a90 	vmov	r1, s15
   1e6c2:	f010 fe5b 	bl	2f37c <tBuffer_initToPool>
	tBuffer_setRecordMode(&buff, RecordOneShot);
   1e6c6:	4620      	mov	r0, r4
   1e6c8:	2100      	movs	r1, #0
   1e6ca:	f010 febb 	bl	2f444 <tBuffer_setRecordMode>
	tSampler_init(&sampler, &buff);
   1e6ce:	4621      	mov	r1, r4
   1e6d0:	4630      	mov	r0, r6
   1e6d2:	f010 fec7 	bl	2f464 <tSampler_init>
	tSampler_setMode(&sampler, bpMode + 1);
   1e6d6:	f646 038c 	movw	r3, #26764	; 0x688c
   1e6da:	4630      	mov	r0, r6
   1e6dc:	f2c0 230e 	movt	r3, #526	; 0x20e
   1e6e0:	6819      	ldr	r1, [r3, #0]
   1e6e2:	3101      	adds	r1, #1
   1e6e4:	b2c9      	uxtb	r1, r1
   1e6e6:	f010 ff59 	bl	2f59c <tSampler_setMode>
	tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1e6ea:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1e6ee:	2200      	movs	r2, #0
   1e6f0:	f64d 3020 	movw	r0, #56096	; 0xdb20
   1e6f4:	f6c3 4323 	movt	r3, #15395	; 0x3c23
   1e6f8:	4629      	mov	r1, r5
   1e6fa:	ee08 2a90 	vmov	s17, r2
   1e6fe:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e702:	ee08 3a10 	vmov	s16, r3
   1e706:	ee00 2a10 	vmov	s0, r2
   1e70a:	ee00 3a90 	vmov	s1, r3
   1e70e:	f00c fe17 	bl	2b340 <tExpSmooth_initToPool>
	tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
   1e712:	eef0 0a48 	vmov.f32	s1, s16
   1e716:	eeb0 0a68 	vmov.f32	s0, s17
   1e71a:	f24d 30c4 	movw	r0, #54212	; 0xd3c4
   1e71e:	4629      	mov	r1, r5
   1e720:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   1e724:	ecbd 8b02 	vpop	{d8}
   1e728:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
   1e72c:	f00c be08 	b.w	2b340 <tExpSmooth_initToPool>

0001e730 <SFXSamplerBPFrame>:
   1e730:	4770      	bx	lr
   1e732:	bf00      	nop

0001e734 <SFXSamplerBPTick>:
{
   1e734:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e738:	f64e 267c 	movw	r6, #60028	; 0xea7c
{
   1e73c:	4681      	mov	r9, r0
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1e73e:	f24d 3058 	movw	r0, #54104	; 0xd358
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e742:	f2c0 260f 	movt	r6, #527	; 0x20f
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1e746:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   1e74a:	ed2d 8b02 	vpush	{d8}
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1e74e:	f010 fe71 	bl	2f434 <tBuffer_getRecordPosition>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e752:	7f33      	ldrb	r3, [r6, #28]
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1e754:	ee08 0a10 	vmov	s16, r0
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e758:	2b00      	cmp	r3, #0
   1e75a:	f040 80de 	bne.w	1e91a <SFXSamplerBPTick+0x1e6>
   1e75e:	f646 1764 	movw	r7, #26980	; 0x6964
   1e762:	f64c 2478 	movw	r4, #51832	; 0xca78
   1e766:	f64e 352c 	movw	r5, #60204	; 0xeb2c
	if (buttonActionsSFX[ButtonB][ActionPress])
   1e76a:	7e33      	ldrb	r3, [r6, #24]
   1e76c:	f2c0 270e 	movt	r7, #526	; 0x20e
   1e770:	f2c0 240f 	movt	r4, #527	; 0x20f
   1e774:	f2c0 250f 	movt	r5, #527	; 0x20f
   1e778:	2b00      	cmp	r3, #0
   1e77a:	f040 80ef 	bne.w	1e95c <SFXSamplerBPTick+0x228>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e77e:	7d33      	ldrb	r3, [r6, #20]
   1e780:	2b00      	cmp	r3, #0
   1e782:	f040 8107 	bne.w	1e994 <SFXSamplerBPTick+0x260>
	if (buttonActionsSFX[ButtonA][ActionRelease])
   1e786:	7d73      	ldrb	r3, [r6, #21]
   1e788:	2b00      	cmp	r3, #0
   1e78a:	f040 8118 	bne.w	1e9be <SFXSamplerBPTick+0x28a>
	sampleLength = recordPosition * leaf.invSampleRate;
   1e78e:	f64f 0308 	movw	r3, #63496	; 0xf808
   1e792:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e796:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
	displayValues[0] = knobs[0] * sampleLength;
   1e79a:	ed94 7a7d 	vldr	s14, [r4, #500]	; 0x1f4
	sampleLength = recordPosition * leaf.invSampleRate;
   1e79e:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e7a2:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
   1e7a6:	2200      	movs	r2, #0
	sampleLength = recordPosition * leaf.invSampleRate;
   1e7a8:	edd3 7a01 	vldr	s15, [r3, #4]
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e7ac:	ee38 1ac7 	vsub.f32	s2, s17, s14
   1e7b0:	ee00 2a10 	vmov	s0, r2
	sampleLength = recordPosition * leaf.invSampleRate;
   1e7b4:	ee68 7a27 	vmul.f32	s15, s16, s15
	displayValues[0] = knobs[0] * sampleLength;
   1e7b8:	ee27 7a87 	vmul.f32	s14, s15, s14
	sampleLength = recordPosition * leaf.invSampleRate;
   1e7bc:	edc7 7a00 	vstr	s15, [r7]
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e7c0:	ee21 1a27 	vmul.f32	s2, s2, s15
   1e7c4:	ee67 0aa0 	vmul.f32	s1, s15, s1
	displayValues[0] = knobs[0] * sampleLength;
   1e7c8:	ed85 7a00 	vstr	s14, [r5]
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e7cc:	f00e fb08 	bl	2cde0 <LEAF_clip>
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1e7d0:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1e7d4:	edd4 6a7f 	vldr	s13, [r4, #508]	; 0x1fc
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1e7d8:	ed94 7a80 	vldr	s14, [r4, #512]	; 0x200
   1e7dc:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1e7e0:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e7e4:	ed85 0a01 	vstr	s0, [r5, #4]
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1e7e8:	ee76 6ae7 	vsub.f32	s13, s13, s15
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1e7ec:	ee77 7a67 	vsub.f32	s15, s14, s15
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1e7f0:	ee66 6aa5 	vmul.f32	s13, s13, s11
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1e7f4:	ee67 7a86 	vmul.f32	s15, s15, s12
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1e7f8:	edc5 6a02 	vstr	s13, [r5, #8]
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1e7fc:	fef8 7a67 	vrinta.f32	s15, s15
	if (rate < 0.0f)
   1e800:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1e804:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1e808:	f100 8115 	bmi.w	1ea36 <SFXSamplerBPTick+0x302>
		rate += 1.0f;
   1e80c:	ee77 7aa8 	vadd.f32	s15, s15, s17
	displayValues[4] = knobs[4] * 4000.0f;
   1e810:	2300      	movs	r3, #0
   1e812:	ed94 6a81 	vldr	s12, [r4, #516]	; 0x204
	samplerRate = displayValues[3] * displayValues[2];
   1e816:	f246 26ac 	movw	r6, #25260	; 0x62ac
   1e81a:	ee66 6aa7 	vmul.f32	s13, s13, s15
	displayValues[4] = knobs[4] * 4000.0f;
   1e81e:	f2c4 537a 	movt	r3, #17786	; 0x457a
	tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1e822:	ed94 0a7d 	vldr	s0, [r4, #500]	; 0x1f4
   1e826:	f64d 3020 	movw	r0, #56096	; 0xdb20
	samplerRate = displayValues[3] * displayValues[2];
   1e82a:	f2c0 0606 	movt	r6, #6
	displayValues[4] = knobs[4] * 4000.0f;
   1e82e:	ee07 3a10 	vmov	s14, r3
	tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1e832:	ee28 0a00 	vmul.f32	s0, s16, s0
   1e836:	f2c0 200f 	movt	r0, #527	; 0x20f
	samplerRate = displayValues[3] * displayValues[2];
   1e83a:	edc6 6a00 	vstr	s13, [r6]
	displayValues[4] = knobs[4] * 4000.0f;
   1e83e:	ee26 7a07 	vmul.f32	s14, s12, s14
	displayValues[3] = rate;
   1e842:	edc5 7a03 	vstr	s15, [r5, #12]
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1e846:	f646 186c 	movw	r8, #26988	; 0x696c
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e84a:	f646 1768 	movw	r7, #26984	; 0x6968
	displayValues[4] = knobs[4] * 4000.0f;
   1e84e:	ed85 7a04 	vstr	s14, [r5, #16]
	tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1e852:	f00c fdb1 	bl	2b3b8 <tExpSmooth_setDest>
	tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
   1e856:	ed94 0a7e 	vldr	s0, [r4, #504]	; 0x1f8
   1e85a:	f24d 30c4 	movw	r0, #54212	; 0xd3c4
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1e85e:	f2c0 280e 	movt	r8, #526	; 0x20e
	crossfadeLength = displayValues[4];
   1e862:	f646 04cc 	movw	r4, #26828	; 0x68cc
	tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
   1e866:	ee28 0a00 	vmul.f32	s0, s16, s0
   1e86a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e86e:	f00c fda3 	bl	2b3b8 <tExpSmooth_setDest>
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1e872:	f64d 3020 	movw	r0, #56096	; 0xdb20
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e876:	f2c0 270e 	movt	r7, #526	; 0x20e
	crossfadeLength = displayValues[4];
   1e87a:	f2c0 240e 	movt	r4, #526	; 0x20e
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1e87e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e882:	f00c fda3 	bl	2b3cc <tExpSmooth_tick>
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e886:	f24d 30c4 	movw	r0, #54212	; 0xd3c4
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1e88a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e88e:	f2c0 200f 	movt	r0, #527	; 0x20f
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1e892:	ed88 0a00 	vstr	s0, [r8]
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e896:	f00c fd99 	bl	2b3cc <tExpSmooth_tick>
	crossfadeLength = displayValues[4];
   1e89a:	edd5 7a04 	vldr	s15, [r5, #16]
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e89e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
	tSampler_setStart(&sampler, samplePlayStart);
   1e8a2:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e8a6:	f8d8 1000 	ldr.w	r1, [r8]
	crossfadeLength = displayValues[4];
   1e8aa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	tSampler_setStart(&sampler, samplePlayStart);
   1e8ae:	f2c0 200f 	movt	r0, #527	; 0x20f
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1e8b2:	ed87 0a00 	vstr	s0, [r7]
	crossfadeLength = displayValues[4];
   1e8b6:	edc4 7a00 	vstr	s15, [r4]
	tSampler_setStart(&sampler, samplePlayStart);
   1e8ba:	f010 fedf 	bl	2f67c <tSampler_setStart>
	tSampler_setLength(&sampler, samplePlayLength);
   1e8be:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e8c2:	6839      	ldr	r1, [r7, #0]
   1e8c4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e8c8:	f011 fb18 	bl	2fefc <tSampler_setLength>
	tSampler_setRate(&sampler, samplerRate);
   1e8cc:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e8d0:	ed96 0a00 	vldr	s0, [r6]
   1e8d4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e8d8:	f011 fbdc 	bl	30094 <tSampler_setRate>
	tSampler_setCrossfadeLength(&sampler, crossfadeLength);
   1e8dc:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e8e0:	6821      	ldr	r1, [r4, #0]
   1e8e2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e8e6:	f010 fe5d 	bl	2f5a4 <tSampler_setCrossfadeLength>
	tBuffer_tick(&buff, input[1]);
   1e8ea:	f24d 3058 	movw	r0, #54104	; 0xd358
   1e8ee:	ed99 0a01 	vldr	s0, [r9, #4]
   1e8f2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e8f6:	f010 fd65 	bl	2f3c4 <tBuffer_tick>
	sample = tanhf(tSampler_tick(&sampler));
   1e8fa:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e8fe:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e902:	f011 f815 	bl	2f930 <tSampler_tick>
   1e906:	f012 f891 	bl	30a2c <tanhf>
	input[0] = sample;
   1e90a:	ed89 0a00 	vstr	s0, [r9]
	input[1] = sample;
   1e90e:	ed89 0a01 	vstr	s0, [r9, #4]
}
   1e912:	ecbd 8b02 	vpop	{d8}
   1e916:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (samplePlaying)
   1e91a:	f246 23a8 	movw	r3, #25256	; 0x62a8
   1e91e:	f2c0 0306 	movt	r3, #6
   1e922:	781a      	ldrb	r2, [r3, #0]
   1e924:	2a00      	cmp	r2, #0
   1e926:	d15c      	bne.n	1e9e2 <SFXSamplerBPTick+0x2ae>
			tSampler_play(&sampler);
   1e928:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e92c:	f646 1764 	movw	r7, #26980	; 0x6964
   1e930:	f64c 2478 	movw	r4, #51832	; 0xca78
			samplePlaying = 1;
   1e934:	2201      	movs	r2, #1
   1e936:	f64e 352c 	movw	r5, #60204	; 0xeb2c
			tSampler_play(&sampler);
   1e93a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e93e:	f2c0 270e 	movt	r7, #526	; 0x20e
   1e942:	f2c0 240f 	movt	r4, #527	; 0x20f
   1e946:	f2c0 250f 	movt	r5, #527	; 0x20f
			samplePlaying = 1;
   1e94a:	701a      	strb	r2, [r3, #0]
			tSampler_play(&sampler);
   1e94c:	f010 fe3e 	bl	2f5cc <tSampler_play>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e950:	2300      	movs	r3, #0
   1e952:	7733      	strb	r3, [r6, #28]
	if (buttonActionsSFX[ButtonB][ActionPress])
   1e954:	7e33      	ldrb	r3, [r6, #24]
   1e956:	2b00      	cmp	r3, #0
   1e958:	f43f af11 	beq.w	1e77e <SFXSamplerBPTick+0x4a>
		bpMode = !bpMode;
   1e95c:	f646 088c 	movw	r8, #26764	; 0x688c
		tSampler_setMode(&sampler, bpMode + 1);
   1e960:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
		bpMode = !bpMode;
   1e964:	f2c0 280e 	movt	r8, #526	; 0x20e
		tSampler_setMode(&sampler, bpMode + 1);
   1e968:	f2c0 200f 	movt	r0, #527	; 0x20f
		bpMode = !bpMode;
   1e96c:	f8d8 3000 	ldr.w	r3, [r8]
   1e970:	fab3 f383 	clz	r3, r3
   1e974:	095b      	lsrs	r3, r3, #5
		tSampler_setMode(&sampler, bpMode + 1);
   1e976:	1c59      	adds	r1, r3, #1
		bpMode = !bpMode;
   1e978:	f8c8 3000 	str.w	r3, [r8]
		tSampler_setMode(&sampler, bpMode + 1);
   1e97c:	f010 fe0e 	bl	2f59c <tSampler_setMode>
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1e980:	2300      	movs	r3, #0
		setLED_B(bpMode);
   1e982:	f898 0000 	ldrb.w	r0, [r8]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1e986:	7633      	strb	r3, [r6, #24]
		setLED_B(bpMode);
   1e988:	f7fc fbe4 	bl	1b154 <setLED_B>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e98c:	7d33      	ldrb	r3, [r6, #20]
   1e98e:	2b00      	cmp	r3, #0
   1e990:	f43f aef9 	beq.w	1e786 <SFXSamplerBPTick+0x52>
		tSampler_stop(&sampler);
   1e994:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1e998:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e99c:	f010 fe64 	bl	2f668 <tSampler_stop>
		tBuffer_record(&buff);
   1e9a0:	f24d 3058 	movw	r0, #54104	; 0xd358
   1e9a4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e9a8:	f010 fd3a 	bl	2f420 <tBuffer_record>
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e9ac:	2300      	movs	r3, #0
		setLED_A(1);
   1e9ae:	2001      	movs	r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e9b0:	7533      	strb	r3, [r6, #20]
		setLED_A(1);
   1e9b2:	f7fc fbbf 	bl	1b134 <setLED_A>
	if (buttonActionsSFX[ButtonA][ActionRelease])
   1e9b6:	7d73      	ldrb	r3, [r6, #21]
   1e9b8:	2b00      	cmp	r3, #0
   1e9ba:	f43f aee8 	beq.w	1e78e <SFXSamplerBPTick+0x5a>
		tBuffer_stop(&buff);
   1e9be:	f24d 3058 	movw	r0, #54104	; 0xd358
   1e9c2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1e9c6:	f010 fd31 	bl	2f42c <tBuffer_stop>
		if (samplePlaying) tSampler_play(&sampler);
   1e9ca:	f246 23a8 	movw	r3, #25256	; 0x62a8
   1e9ce:	f2c0 0306 	movt	r3, #6
   1e9d2:	781b      	ldrb	r3, [r3, #0]
   1e9d4:	bbb3      	cbnz	r3, 1ea44 <SFXSamplerBPTick+0x310>
		buttonActionsSFX[ButtonA][ActionRelease] = 0;
   1e9d6:	2300      	movs	r3, #0
		setLED_A(0);
   1e9d8:	4618      	mov	r0, r3
		buttonActionsSFX[ButtonA][ActionRelease] = 0;
   1e9da:	7573      	strb	r3, [r6, #21]
		setLED_A(0);
   1e9dc:	f7fc fbaa 	bl	1b134 <setLED_A>
   1e9e0:	e6d5      	b.n	1e78e <SFXSamplerBPTick+0x5a>
			tSampler_stop(&sampler);
   1e9e2:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
			displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e9e6:	f64c 2478 	movw	r4, #51832	; 0xca78
			samplePlaying = 0;
   1e9ea:	2200      	movs	r2, #0
			displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e9ec:	f646 1764 	movw	r7, #26980	; 0x6964
			tSampler_stop(&sampler);
   1e9f0:	f2c0 200f 	movt	r0, #527	; 0x20f
			displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e9f4:	f2c0 240f 	movt	r4, #527	; 0x20f
			samplePlaying = 0;
   1e9f8:	701a      	strb	r2, [r3, #0]
			tSampler_stop(&sampler);
   1e9fa:	f010 fe35 	bl	2f668 <tSampler_stop>
			displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1e9fe:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1ea02:	ed94 1a7d 	vldr	s2, [r4, #500]	; 0x1f4
   1ea06:	f2c0 270e 	movt	r7, #526	; 0x20e
   1ea0a:	f64e 352c 	movw	r5, #60204	; 0xeb2c
   1ea0e:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
   1ea12:	2300      	movs	r3, #0
   1ea14:	ee77 7ac1 	vsub.f32	s15, s15, s2
   1ea18:	ed97 1a00 	vldr	s2, [r7]
   1ea1c:	f2c0 250f 	movt	r5, #527	; 0x20f
   1ea20:	ee00 3a10 	vmov	s0, r3
   1ea24:	ee61 0a20 	vmul.f32	s1, s2, s1
   1ea28:	ee27 1a81 	vmul.f32	s2, s15, s2
   1ea2c:	f00e f9d8 	bl	2cde0 <LEAF_clip>
   1ea30:	ed85 0a01 	vstr	s0, [r5, #4]
   1ea34:	e78c      	b.n	1e950 <SFXSamplerBPTick+0x21c>
		(rate = 1.0f / fabsf(rate-1.0f));
   1ea36:	ee77 7ae8 	vsub.f32	s15, s15, s17
   1ea3a:	eeb0 7ae7 	vabs.f32	s14, s15
   1ea3e:	eec8 7a87 	vdiv.f32	s15, s17, s14
   1ea42:	e6e5      	b.n	1e810 <SFXSamplerBPTick+0xdc>
		if (samplePlaying) tSampler_play(&sampler);
   1ea44:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1ea48:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ea4c:	f010 fdbe 	bl	2f5cc <tSampler_play>
   1ea50:	e7c1      	b.n	1e9d6 <SFXSamplerBPTick+0x2a2>
   1ea52:	bf00      	nop

0001ea54 <SFXSamplerBPFree>:
	tBuffer_free(&buff);
   1ea54:	f24d 3058 	movw	r0, #54104	; 0xd358
{
   1ea58:	b508      	push	{r3, lr}
	tBuffer_free(&buff);
   1ea5a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ea5e:	f010 fca5 	bl	2f3ac <tBuffer_free>
	tSampler_free(&sampler);
   1ea62:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
   1ea66:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ea6a:	f010 fd8b 	bl	2f584 <tSampler_free>
	tExpSmooth_free(&startSmooth);
   1ea6e:	f64d 3020 	movw	r0, #56096	; 0xdb20
   1ea72:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ea76:	f00c fc89 	bl	2b38c <tExpSmooth_free>
	tExpSmooth_free(&lengthSmooth);
   1ea7a:	f24d 30c4 	movw	r0, #54212	; 0xd3c4
}
   1ea7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tExpSmooth_free(&lengthSmooth);
   1ea82:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ea86:	f00c bc81 	b.w	2b38c <tExpSmooth_free>
   1ea8a:	bf00      	nop

0001ea8c <SFXSamplerKAlloc>:
	leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1ea8c:	2000      	movs	r0, #0
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1ea8e:	f24d 720a 	movw	r2, #55050	; 0xd70a
		tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
   1ea92:	f24a 5cb8 	movw	ip, #42424	; 0xa5b8
	currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1ea96:	f246 2124 	movw	r1, #25124	; 0x6224
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1ea9a:	f6c3 5223 	movt	r2, #15651	; 0x3d23
   1ea9e:	f64d 33ec 	movw	r3, #56300	; 0xdbec
	currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1eaa2:	f2c0 0106 	movt	r1, #6
   1eaa6:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   1eaaa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		crossfadeLengths[i] = 1000;
   1eaae:	4605      	mov	r5, r0
	leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1eab0:	f64f 0b08 	movw	fp, #63496	; 0xf808
		tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1eab4:	f64a 6890 	movw	r8, #44688	; 0xae90
	currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1eab8:	4604      	mov	r4, r0
		crossfadeLengths[i] = 1000;
   1eaba:	f2c4 457a 	movt	r5, #17530	; 0x447a
	leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1eabe:	f2c0 2b0f 	movt	fp, #527	; 0x20f
		tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1eac2:	f2c0 280f 	movt	r8, #527	; 0x20f
   1eac6:	f24d 66e4 	movw	r6, #55012	; 0xd6e4
   1eaca:	f64d 3a24 	movw	sl, #56100	; 0xdb24
   1eace:	f24c 69d0 	movw	r9, #50896	; 0xc6d0
		samplePlayStarts[i] = 0;
   1ead2:	4607      	mov	r7, r0
   1ead4:	f2c0 260f 	movt	r6, #527	; 0x20f
   1ead8:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   1eadc:	f2c0 290f 	movt	r9, #527	; 0x20f
{
   1eae0:	ed2d 8b02 	vpush	{d8}
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1eae4:	ee08 2a10 	vmov	s16, r2
{
   1eae8:	b08d      	sub	sp, #52	; 0x34
   1eaea:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
	leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1eaee:	f8cb 0014 	str.w	r0, [fp, #20]
		crossfadeLengths[i] = 1000;
   1eaf2:	950b      	str	r5, [sp, #44]	; 0x2c
   1eaf4:	f24e 7004 	movw	r0, #59140	; 0xe704
   1eaf8:	4615      	mov	r5, r2
   1eafa:	f24e 5200 	movw	r2, #58624	; 0xe500
   1eafe:	f2c0 200f 	movt	r0, #527	; 0x20f
   1eb02:	9604      	str	r6, [sp, #16]
   1eb04:	f2c0 250f 	movt	r5, #527	; 0x20f
   1eb08:	9003      	str	r0, [sp, #12]
   1eb0a:	9501      	str	r5, [sp, #4]
   1eb0c:	4615      	mov	r5, r2
   1eb0e:	f24d 2294 	movw	r2, #53908	; 0xd294
   1eb12:	f2c0 250f 	movt	r5, #527	; 0x20f
   1eb16:	9507      	str	r5, [sp, #28]
   1eb18:	4615      	mov	r5, r2
   1eb1a:	f24c 32f4 	movw	r2, #50164	; 0xc3f4
   1eb1e:	f2c0 250f 	movt	r5, #527	; 0x20f
   1eb22:	9509      	str	r5, [sp, #36]	; 0x24
   1eb24:	4615      	mov	r5, r2
   1eb26:	f64c 12b4 	movw	r2, #51636	; 0xc9b4
   1eb2a:	f2c0 250f 	movt	r5, #527	; 0x20f
   1eb2e:	9506      	str	r5, [sp, #24]
   1eb30:	4615      	mov	r5, r2
		tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
   1eb32:	4662      	mov	r2, ip
   1eb34:	f2c0 250f 	movt	r5, #527	; 0x20f
   1eb38:	f2c0 220f 	movt	r2, #527	; 0x20f
   1eb3c:	9508      	str	r5, [sp, #32]
   1eb3e:	920a      	str	r2, [sp, #40]	; 0x28
	currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1eb40:	2218      	movs	r2, #24
   1eb42:	600a      	str	r2, [r1, #0]
   1eb44:	f64d 22d3 	movw	r2, #56019	; 0xdad3
   1eb48:	f2c0 220f 	movt	r2, #527	; 0x20f
   1eb4c:	9202      	str	r2, [sp, #8]
   1eb4e:	4642      	mov	r2, r8
   1eb50:	4698      	mov	r8, r3
   1eb52:	465b      	mov	r3, fp
   1eb54:	4693      	mov	fp, r2
		tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
   1eb56:	eef0 7a0c 	vmov.f32	s15, #12	; 0x40600000  3.5
   1eb5a:	ed93 7a00 	vldr	s14, [r3]
   1eb5e:	9305      	str	r3, [sp, #20]
   1eb60:	9b07      	ldr	r3, [sp, #28]
   1eb62:	ee67 7a27 	vmul.f32	s15, s14, s15
   1eb66:	191d      	adds	r5, r3, r4
   1eb68:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1eb6c:	4628      	mov	r0, r5
   1eb6e:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
   1eb72:	ee17 1a90 	vmov	r1, s15
   1eb76:	191e      	adds	r6, r3, r4
   1eb78:	f010 fc00 	bl	2f37c <tBuffer_initToPool>
		tBuffer_setRecordMode(&keyBuff[i], RecordOneShot);
   1eb7c:	4628      	mov	r0, r5
   1eb7e:	2100      	movs	r1, #0
   1eb80:	f010 fc60 	bl	2f444 <tBuffer_setRecordMode>
		tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1eb84:	465a      	mov	r2, fp
   1eb86:	4629      	mov	r1, r5
   1eb88:	4630      	mov	r0, r6
   1eb8a:	f010 fcb5 	bl	2f4f8 <tSampler_initToPool>
		tSampler_setMode(&keySampler[i], PlayLoop);
   1eb8e:	4630      	mov	r0, r6
   1eb90:	2101      	movs	r1, #1
   1eb92:	f010 fd03 	bl	2f59c <tSampler_setMode>
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1eb96:	9b06      	ldr	r3, [sp, #24]
   1eb98:	2200      	movs	r2, #0
		crossfadeLengths[i] = 1000;
   1eb9a:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1eb9e:	1918      	adds	r0, r3, r4
		samplePlayStarts[i] = 0;
   1eba0:	9b04      	ldr	r3, [sp, #16]
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1eba2:	ee00 2a10 	vmov	s0, r2
   1eba6:	4659      	mov	r1, fp
		samplePlayStarts[i] = 0;
   1eba8:	f843 7b04 	str.w	r7, [r3], #4
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1ebac:	eef0 0a48 	vmov.f32	s1, s16
		samplePlayStarts[i] = 0;
   1ebb0:	9304      	str	r3, [sp, #16]
		samplePlayLengths[i] = 0;
   1ebb2:	9b01      	ldr	r3, [sp, #4]
		crossfadeLengths[i] = 1000;
   1ebb4:	ecea 7a01 	vstmia	sl!, {s15}
		samplePlayLengths[i] = 0;
   1ebb8:	f843 7b04 	str.w	r7, [r3], #4
   1ebbc:	9301      	str	r3, [sp, #4]
		detectedAttackPos[i] = 0;
   1ebbe:	9b03      	ldr	r3, [sp, #12]
   1ebc0:	461a      	mov	r2, r3
   1ebc2:	2300      	movs	r3, #0
   1ebc4:	f842 3f04 	str.w	r3, [r2, #4]!
		samplerKeyHeld[i] = 0;
   1ebc8:	9b02      	ldr	r3, [sp, #8]
		detectedAttackPos[i] = 0;
   1ebca:	9203      	str	r2, [sp, #12]
		samplerKeyHeld[i] = 0;
   1ebcc:	f04f 0200 	mov.w	r2, #0
   1ebd0:	f803 2f01 	strb.w	r2, [r3, #1]!
   1ebd4:	9302      	str	r3, [sp, #8]
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1ebd6:	f00c fbb3 	bl	2b340 <tExpSmooth_initToPool>
		loopOns[i] = 1;
   1ebda:	9b08      	ldr	r3, [sp, #32]
   1ebdc:	2101      	movs	r1, #1
		sampleRates[i] = 1.0f;
   1ebde:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
		loopOns[i] = 1;
   1ebe2:	5119      	str	r1, [r3, r4]
   1ebe4:	3404      	adds	r4, #4
		sampleRates[i] = 1.0f;
   1ebe6:	f849 2b04 	str.w	r2, [r9], #4
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1ebea:	2cc4      	cmp	r4, #196	; 0xc4
		sampleRatesMult[i] = 1.0f;
   1ebec:	f848 2b04 	str.w	r2, [r8], #4
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1ebf0:	9b05      	ldr	r3, [sp, #20]
   1ebf2:	d1b0      	bne.n	1eb56 <SFXSamplerKAlloc+0xca>
	tSimplePoly_setNumVoices(&poly, NUM_SAMPLER_VOICES);
   1ebf4:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   1ebf8:	2106      	movs	r1, #6
   1ebfa:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ebfe:	f00e ff6b 	bl	2dad8 <tSimplePoly_setNumVoices>
	setLED_B(controlAllKeys);
   1ec02:	f646 01c8 	movw	r1, #26824	; 0x68c8
		waitingForDeactivation[i] = -1;
   1ec06:	f64d 13b0 	movw	r3, #55728	; 0xd9b0
   1ec0a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	setLED_B(controlAllKeys);
   1ec0e:	f2c0 210e 	movt	r1, #526	; 0x20e
		waitingForDeactivation[i] = -1;
   1ec12:	f2c0 230f 	movt	r3, #527	; 0x20f
	setLED_B(controlAllKeys);
   1ec16:	7808      	ldrb	r0, [r1, #0]
		waitingForDeactivation[i] = -1;
   1ec18:	e9c3 2200 	strd	r2, r2, [r3]
   1ec1c:	e9c3 2202 	strd	r2, r2, [r3, #8]
   1ec20:	e9c3 2204 	strd	r2, r2, [r3, #16]
	setLED_B(controlAllKeys);
   1ec24:	f7fc fa96 	bl	1b154 <setLED_B>
	samp_thresh = 0.0002f;
   1ec28:	f24b 7317 	movw	r3, #46871	; 0xb717
   1ec2c:	f646 125c 	movw	r2, #26972	; 0x695c
   1ec30:	f6c3 1351 	movt	r3, #14673	; 0x3951
   1ec34:	f2c0 220e 	movt	r2, #526	; 0x20e
   1ec38:	6013      	str	r3, [r2, #0]
}
   1ec3a:	b00d      	add	sp, #52	; 0x34
   1ec3c:	ecbd 8b02 	vpop	{d8}
   1ec40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001ec44 <SFXSamplerKFrame>:
	int currentSamplerKey = currentSamplerKeyGlobal;
   1ec44:	f246 2224 	movw	r2, #25124	; 0x6224
	if (samplerKeyHeld[currentSamplerKey])
   1ec48:	f64d 23d4 	movw	r3, #56020	; 0xdad4
	int currentSamplerKey = currentSamplerKeyGlobal;
   1ec4c:	f2c0 0206 	movt	r2, #6
	if (samplerKeyHeld[currentSamplerKey])
   1ec50:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   1ec54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ec58:	ed2d 8b04 	vpush	{d8-d9}
	int currentSamplerKey = currentSamplerKeyGlobal;
   1ec5c:	6815      	ldr	r5, [r2, #0]
{
   1ec5e:	b083      	sub	sp, #12
	if (samplerKeyHeld[currentSamplerKey])
   1ec60:	5d5b      	ldrb	r3, [r3, r5]
   1ec62:	2b00      	cmp	r3, #0
   1ec64:	f040 8135 	bne.w	1eed2 <SFXSamplerKFrame+0x28e>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1ec68:	f64e 247c 	movw	r4, #60028	; 0xea7c
   1ec6c:	f2c0 240f 	movt	r4, #527	; 0x20f
   1ec70:	7d23      	ldrb	r3, [r4, #20]
   1ec72:	b17b      	cbz	r3, 1ec94 <SFXSamplerKFrame+0x50>
		tBuffer_setRecordPosition(&keyBuff[currentSamplerKey],0);
   1ec74:	f24e 5000 	movw	r0, #58624	; 0xe500
   1ec78:	2100      	movs	r1, #0
   1ec7a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1ec7e:	eb00 0685 	add.w	r6, r0, r5, lsl #2
   1ec82:	4630      	mov	r0, r6
   1ec84:	f010 fbda 	bl	2f43c <tBuffer_setRecordPosition>
		tBuffer_setRecordedLength(&keyBuff[currentSamplerKey],0);
   1ec88:	4630      	mov	r0, r6
   1ec8a:	2100      	movs	r1, #0
   1ec8c:	f010 fbe2 	bl	2f454 <tBuffer_setRecordedLength>
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ec90:	2300      	movs	r3, #0
   1ec92:	7523      	strb	r3, [r4, #20]
	if (buttonActionsSFX[ButtonB][ActionPress])
   1ec94:	7e23      	ldrb	r3, [r4, #24]
   1ec96:	b16b      	cbz	r3, 1ecb4 <SFXSamplerKFrame+0x70>
		controlAllKeys = !controlAllKeys;
   1ec98:	f646 02c8 	movw	r2, #26824	; 0x68c8
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1ec9c:	2300      	movs	r3, #0
		controlAllKeys = !controlAllKeys;
   1ec9e:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1eca2:	7623      	strb	r3, [r4, #24]
		controlAllKeys = !controlAllKeys;
   1eca4:	6813      	ldr	r3, [r2, #0]
   1eca6:	fab3 f383 	clz	r3, r3
   1ecaa:	095b      	lsrs	r3, r3, #5
		setLED_B(controlAllKeys);
   1ecac:	4618      	mov	r0, r3
		controlAllKeys = !controlAllKeys;
   1ecae:	6013      	str	r3, [r2, #0]
		setLED_B(controlAllKeys);
   1ecb0:	f7fc fa50 	bl	1b154 <setLED_B>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1ecb4:	7f23      	ldrb	r3, [r4, #28]
   1ecb6:	2b00      	cmp	r3, #0
   1ecb8:	f000 80ed 	beq.w	1ee96 <SFXSamplerKFrame+0x252>
		if (!controlAllKeys)
   1ecbc:	f646 03c8 	movw	r3, #26824	; 0x68c8
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1ecc0:	2200      	movs	r2, #0
		if (!controlAllKeys)
   1ecc2:	f2c0 230e 	movt	r3, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1ecc6:	7722      	strb	r2, [r4, #28]
		if (!controlAllKeys)
   1ecc8:	f8d3 9000 	ldr.w	r9, [r3]
   1eccc:	f1b9 0f00 	cmp.w	r9, #0
   1ecd0:	d064      	beq.n	1ed9c <SFXSamplerKFrame+0x158>
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1ecd2:	f241 236f 	movw	r3, #4719	; 0x126f
						float previousPower = 0.0f;
   1ecd6:	2200      	movs	r2, #0
   1ecd8:	f24e 79cc 	movw	r9, #59340	; 0xe7cc
   1ecdc:	2106      	movs	r1, #6
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1ecde:	f6c3 2303 	movt	r3, #14851	; 0x3a03
						float previousPower = 0.0f;
   1ece2:	ee09 2a10 	vmov	s18, r2
   1ece6:	f2c0 290f 	movt	r9, #527	; 0x20f
   1ecea:	9101      	str	r1, [sp, #4]
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1ecec:	ee08 3a90 	vmov	s17, r3
   1ecf0:	f24e 5700 	movw	r7, #58624	; 0xe500
   1ecf4:	f24e 7608 	movw	r6, #59144	; 0xe708
   1ecf8:	f24d 68e4 	movw	r8, #55012	; 0xd6e4
   1ecfc:	f2c0 270f 	movt	r7, #527	; 0x20f
   1ed00:	f2c0 260f 	movt	r6, #527	; 0x20f
   1ed04:	f2c0 280f 	movt	r8, #527	; 0x20f
   1ed08:	e01c      	b.n	1ed44 <SFXSamplerKFrame+0x100>
   1ed0a:	eeb4 8ac0 	vcmpe.f32	s16, s0
   1ed0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ed12:	d53d      	bpl.n	1ed90 <SFXSamplerKFrame+0x14c>
								int thePos = (i + detectedAttackPos[key] - 480) % buffLength;
   1ed14:	6833      	ldr	r3, [r6, #0]
   1ed16:	441d      	add	r5, r3
   1ed18:	f5a5 75f0 	sub.w	r5, r5, #480	; 0x1e0
   1ed1c:	fb95 f3f4 	sdiv	r3, r5, r4
   1ed20:	fb04 5513 	mls	r5, r4, r3, r5
   1ed24:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
								samplePlayStarts[key] = thePos;
   1ed28:	ee07 5a90 	vmov	s15, r5
								detectedAttackPos[key] = thePos;
   1ed2c:	6035      	str	r5, [r6, #0]
								samplePlayStarts[key] = thePos;
   1ed2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ed32:	edc8 7a00 	vstr	s15, [r8]
   1ed36:	3604      	adds	r6, #4
   1ed38:	3704      	adds	r7, #4
   1ed3a:	f108 0804 	add.w	r8, r8, #4
				for (int key = 0; key < NUM_SAMPLER_KEYS; key++)
   1ed3e:	45b1      	cmp	r9, r6
   1ed40:	f000 80bd 	beq.w	1eebe <SFXSamplerKFrame+0x27a>
					int buffLength = tBuffer_getRecordedLength(&keyBuff[key]);
   1ed44:	4638      	mov	r0, r7
   1ed46:	f010 fb81 	bl	2f44c <tBuffer_getRecordedLength>
					if (buffLength > 0)
   1ed4a:	1e04      	subs	r4, r0, #0
   1ed4c:	ddf3      	ble.n	1ed36 <SFXSamplerKFrame+0xf2>
						if (detectedAttackPos[key] > 0)
   1ed4e:	6833      	ldr	r3, [r6, #0]
   1ed50:	2b00      	cmp	r3, #0
   1ed52:	f300 80a5 	bgt.w	1eea0 <SFXSamplerKFrame+0x25c>
						float previousPower = 0.0f;
   1ed56:	eeb0 0a49 	vmov.f32	s0, s18
   1ed5a:	f646 1a5c 	movw	sl, #26972	; 0x695c
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1ed5e:	ee30 8a28 	vadd.f32	s16, s0, s17
{
   1ed62:	f04f 0b01 	mov.w	fp, #1
   1ed66:	f2c0 2a0e 	movt	sl, #526	; 0x20e
   1ed6a:	f10b 35ff 	add.w	r5, fp, #4294967295	; 0xffffffff
							float testSample = tBuffer_get(&keyBuff[key], (i + detectedAttackPos[key]) % buffLength);
   1ed6e:	4638      	mov	r0, r7
   1ed70:	442b      	add	r3, r5
   1ed72:	fb93 f1f4 	sdiv	r1, r3, r4
   1ed76:	fb04 3111 	mls	r1, r4, r1, r3
   1ed7a:	f010 fb41 	bl	2f400 <tBuffer_get>
							currentPower = testSample*testSample;
   1ed7e:	ee20 0a00 	vmul.f32	s0, s0, s0
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1ed82:	edda 7a00 	vldr	s15, [sl]
   1ed86:	eef4 7ac0 	vcmpe.f32	s15, s0
   1ed8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ed8e:	d4bc      	bmi.n	1ed0a <SFXSamplerKFrame+0xc6>
							if (i >= buffLength)
   1ed90:	455c      	cmp	r4, fp
   1ed92:	ddd0      	ble.n	1ed36 <SFXSamplerKFrame+0xf2>
   1ed94:	f10b 0b01 	add.w	fp, fp, #1
   1ed98:	6833      	ldr	r3, [r6, #0]
   1ed9a:	e7e6      	b.n	1ed6a <SFXSamplerKFrame+0x126>
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1ed9c:	f24e 5700 	movw	r7, #58624	; 0xe500
   1eda0:	ea4f 0885 	mov.w	r8, r5, lsl #2
			if (detectedAttackPos[currentSamplerKey] > 0)
   1eda4:	f24e 7608 	movw	r6, #59144	; 0xe708
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1eda8:	f2c0 270f 	movt	r7, #527	; 0x20f
			if (detectedAttackPos[currentSamplerKey] > 0)
   1edac:	f2c0 260f 	movt	r6, #527	; 0x20f
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1edb0:	4447      	add	r7, r8
   1edb2:	4638      	mov	r0, r7
   1edb4:	f010 fb4a 	bl	2f44c <tBuffer_getRecordedLength>
			if (detectedAttackPos[currentSamplerKey] > 0)
   1edb8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1edbc:	4604      	mov	r4, r0
			if (detectedAttackPos[currentSamplerKey] > 0)
   1edbe:	2b00      	cmp	r3, #0
   1edc0:	f300 80c7 	bgt.w	1ef52 <SFXSamplerKFrame+0x30e>
			float previousPower = 0.0f;
   1edc4:	2200      	movs	r2, #0
   1edc6:	ee00 2a10 	vmov	s0, r2
				if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1edca:	f241 216f 	movw	r1, #4719	; 0x126f
   1edce:	f646 1a5c 	movw	sl, #26972	; 0x695c
   1edd2:	f6c3 2103 	movt	r1, #14851	; 0x3a03
   1edd6:	f2c0 2a0e 	movt	sl, #526	; 0x20e
   1edda:	ee08 1a10 	vmov	s16, r1
   1edde:	ee30 8a08 	vadd.f32	s16, s0, s16
				float testSample = tBuffer_get(&keyBuff[currentSamplerKey], (i + detectedAttackPos[currentSamplerKey]) % buffLength);
   1ede2:	444b      	add	r3, r9
   1ede4:	4638      	mov	r0, r7
   1ede6:	f109 0b01 	add.w	fp, r9, #1
   1edea:	fb93 f1f4 	sdiv	r1, r3, r4
   1edee:	fb04 3111 	mls	r1, r4, r1, r3
   1edf2:	f010 fb05 	bl	2f400 <tBuffer_get>
				currentPower = testSample*testSample;
   1edf6:	ee20 0a00 	vmul.f32	s0, s0, s0
				if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1edfa:	edda 7a00 	vldr	s15, [sl]
   1edfe:	eef4 7ac0 	vcmpe.f32	s15, s0
   1ee02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ee06:	f140 809e 	bpl.w	1ef46 <SFXSamplerKFrame+0x302>
   1ee0a:	eeb4 8ac0 	vcmpe.f32	s16, s0
   1ee0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ee12:	f140 8098 	bpl.w	1ef46 <SFXSamplerKFrame+0x302>
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1ee16:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
					samplePlayStarts[currentSamplerKey] = thePos;
   1ee1a:	f24d 61e4 	movw	r1, #55012	; 0xd6e4
					OLEDclearLine(SecondLine);
   1ee1e:	2001      	movs	r0, #1
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1ee20:	444b      	add	r3, r9
					samplePlayStarts[currentSamplerKey] = thePos;
   1ee22:	f2c0 210f 	movt	r1, #527	; 0x20f
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1ee26:	f5a3 72f0 	sub.w	r2, r3, #480	; 0x1e0
					samplePlayStarts[currentSamplerKey] = thePos;
   1ee2a:	4488      	add	r8, r1
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1ee2c:	fb92 f3f4 	sdiv	r3, r2, r4
   1ee30:	fb04 2313 	mls	r3, r4, r3, r2
   1ee34:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
					samplePlayStarts[currentSamplerKey] = thePos;
   1ee38:	ee07 3a90 	vmov	s15, r3
					detectedAttackPos[currentSamplerKey] = thePos;
   1ee3c:	f846 3025 	str.w	r3, [r6, r5, lsl #2]
					samplePlayStarts[currentSamplerKey] = thePos;
   1ee40:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ee44:	edc8 7a00 	vstr	s15, [r8]
					OLEDclearLine(SecondLine);
   1ee48:	f7fc fc14 	bl	1b674 <OLEDclearLine>
					OLEDwriteString("ATKDETECT ", 10, 0, SecondLine);
   1ee4c:	f244 70b8 	movw	r0, #18360	; 0x47b8
   1ee50:	2200      	movs	r2, #0
   1ee52:	210a      	movs	r1, #10
   1ee54:	2301      	movs	r3, #1
   1ee56:	f2c0 0003 	movt	r0, #3
   1ee5a:	f7fc fc21 	bl	1b6a0 <OLEDwriteString>
					OLEDwriteFloat((samplePlayStarts[currentSamplerKey] / (float)buffLength) * (buffLength * leaf.invSampleRate), OLEDgetCursor(), SecondLine);
   1ee5e:	ee07 4a90 	vmov	s15, r4
   1ee62:	ed98 7a00 	vldr	s14, [r8]
   1ee66:	f64f 0308 	movw	r3, #63496	; 0xf808
   1ee6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ee6e:	f2c0 230f 	movt	r3, #527	; 0x20f
   1ee72:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1ee76:	ed93 7a01 	vldr	s14, [r3, #4]
   1ee7a:	ee67 7a87 	vmul.f32	s15, s15, s14
   1ee7e:	ee28 8a27 	vmul.f32	s16, s16, s15
   1ee82:	f7fc fefb 	bl	1bc7c <OLEDgetCursor>
   1ee86:	2101      	movs	r1, #1
   1ee88:	b2c0      	uxtb	r0, r0
   1ee8a:	eeb0 0a48 	vmov.f32	s0, s16
   1ee8e:	f7fc fceb 	bl	1b868 <OLEDwriteFloat>
				if (i >= buffLength)
   1ee92:	455c      	cmp	r4, fp
   1ee94:	dd43      	ble.n	1ef1e <SFXSamplerKFrame+0x2da>
}
   1ee96:	b003      	add	sp, #12
   1ee98:	ecbd 8b04 	vpop	{d8-d9}
   1ee9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
							previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1eea0:	f241 22bf 	movw	r2, #4799	; 0x12bf
							detectedAttackPos[key] += 4800;
   1eea4:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
							previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1eea8:	4638      	mov	r0, r7
   1eeaa:	441a      	add	r2, r3
							detectedAttackPos[key] += 4800;
   1eeac:	6031      	str	r1, [r6, #0]
							previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1eeae:	fb92 f1f4 	sdiv	r1, r2, r4
   1eeb2:	fb04 2111 	mls	r1, r4, r1, r2
   1eeb6:	f010 faa3 	bl	2f400 <tBuffer_get>
   1eeba:	6833      	ldr	r3, [r6, #0]
   1eebc:	e74d      	b.n	1ed5a <SFXSamplerKFrame+0x116>
			for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1eebe:	9b01      	ldr	r3, [sp, #4]
   1eec0:	3b01      	subs	r3, #1
   1eec2:	9301      	str	r3, [sp, #4]
   1eec4:	f47f af14 	bne.w	1ecf0 <SFXSamplerKFrame+0xac>
}
   1eec8:	b003      	add	sp, #12
   1eeca:	ecbd 8b04 	vpop	{d8-d9}
   1eece:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
   1eed2:	f24e 5000 	movw	r0, #58624	; 0xe500
   1eed6:	f2c0 200f 	movt	r0, #527	; 0x20f
   1eeda:	eb00 0085 	add.w	r0, r0, r5, lsl #2
   1eede:	f010 fabd 	bl	2f45c <tBuffer_isActive>
   1eee2:	f246 2370 	movw	r3, #25200	; 0x6270
   1eee6:	f2c0 0306 	movt	r3, #6
   1eeea:	b1a0      	cbz	r0, 1ef16 <SFXSamplerKFrame+0x2d2>
			buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1eeec:	f64e 30bc 	movw	r0, #60348	; 0xebbc
			writeButtonFlag = ExtraMessage;
   1eef0:	f246 21d2 	movw	r1, #25298	; 0x62d2
			writeActionFlag = ActionHoldContinuous;
   1eef4:	f246 22d1 	movw	r2, #25297	; 0x62d1
			buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1eef8:	2601      	movs	r6, #1
   1eefa:	f2c0 200f 	movt	r0, #527	; 0x20f
			writeButtonFlag = ExtraMessage;
   1eefe:	f2c0 0106 	movt	r1, #6
			writeActionFlag = ActionHoldContinuous;
   1ef02:	f2c0 0206 	movt	r2, #6
			writeButtonFlag = ExtraMessage;
   1ef06:	240a      	movs	r4, #10
			buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1ef08:	f880 602b 	strb.w	r6, [r0, #43]	; 0x2b
			writeActionFlag = ActionHoldContinuous;
   1ef0c:	2003      	movs	r0, #3
			writeButtonFlag = ExtraMessage;
   1ef0e:	700c      	strb	r4, [r1, #0]
			writeActionFlag = ActionHoldContinuous;
   1ef10:	7010      	strb	r0, [r2, #0]
		prevSamplerKey = currentSamplerKey;
   1ef12:	601d      	str	r5, [r3, #0]
   1ef14:	e6a8      	b.n	1ec68 <SFXSamplerKFrame+0x24>
		if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
   1ef16:	681a      	ldr	r2, [r3, #0]
   1ef18:	42aa      	cmp	r2, r5
   1ef1a:	d1e7      	bne.n	1eeec <SFXSamplerKFrame+0x2a8>
   1ef1c:	e7f9      	b.n	1ef12 <SFXSamplerKFrame+0x2ce>
					detectedAttackPos[currentSamplerKey] = 0;
   1ef1e:	2400      	movs	r4, #0
					OLEDclearLine(SecondLine);
   1ef20:	2001      	movs	r0, #1
					detectedAttackPos[currentSamplerKey] = 0;
   1ef22:	f846 4025 	str.w	r4, [r6, r5, lsl #2]
					OLEDclearLine(SecondLine);
   1ef26:	f7fc fba5 	bl	1b674 <OLEDclearLine>
					OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
   1ef2a:	f244 70a8 	movw	r0, #18344	; 0x47a8
   1ef2e:	4622      	mov	r2, r4
   1ef30:	2301      	movs	r3, #1
   1ef32:	210a      	movs	r1, #10
   1ef34:	f2c0 0003 	movt	r0, #3
}
   1ef38:	b003      	add	sp, #12
   1ef3a:	ecbd 8b04 	vpop	{d8-d9}
   1ef3e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
   1ef42:	f7fc bbad 	b.w	1b6a0 <OLEDwriteString>
				if (i >= buffLength)
   1ef46:	455c      	cmp	r4, fp
   1ef48:	dde9      	ble.n	1ef1e <SFXSamplerKFrame+0x2da>
{
   1ef4a:	46d9      	mov	r9, fp
   1ef4c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   1ef50:	e747      	b.n	1ede2 <SFXSamplerKFrame+0x19e>
				previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1ef52:	f241 22bf 	movw	r2, #4799	; 0x12bf
				detectedAttackPos[currentSamplerKey] += 4800;
   1ef56:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
				previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1ef5a:	4638      	mov	r0, r7
   1ef5c:	441a      	add	r2, r3
				detectedAttackPos[currentSamplerKey] += 4800;
   1ef5e:	f846 1025 	str.w	r1, [r6, r5, lsl #2]
				previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1ef62:	fb92 f1f4 	sdiv	r1, r2, r4
   1ef66:	fb04 2111 	mls	r1, r4, r1, r2
   1ef6a:	f010 fa49 	bl	2f400 <tBuffer_get>
   1ef6e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   1ef72:	e72a      	b.n	1edca <SFXSamplerKFrame+0x186>

0001ef74 <SFXSamplerKTick>:
	if (!controlAllKeys)
   1ef74:	f646 03c8 	movw	r3, #26824	; 0x68c8
   1ef78:	f2c0 230e 	movt	r3, #526	; 0x20e
{
   1ef7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ef80:	ed2d 8b04 	vpush	{d8-d9}
	if (!controlAllKeys)
   1ef84:	681b      	ldr	r3, [r3, #0]
{
   1ef86:	b089      	sub	sp, #36	; 0x24
   1ef88:	4683      	mov	fp, r0
	if (!controlAllKeys)
   1ef8a:	2b00      	cmp	r3, #0
   1ef8c:	f000 8194 	beq.w	1f2b8 <SFXSamplerKTick+0x344>
			displayValues[5] = knobs[5] * 4000.0f;
   1ef90:	2300      	movs	r3, #0
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1ef92:	2200      	movs	r2, #0
   1ef94:	f64c 2478 	movw	r4, #51832	; 0xca78
   1ef98:	f64e 352c 	movw	r5, #60204	; 0xeb2c
   1ef9c:	f24e 49e8 	movw	r9, #58600	; 0xe4e8
			displayValues[5] = knobs[5] * 4000.0f;
   1efa0:	f2c4 537a 	movt	r3, #17786	; 0x457a
			if (tSimplePoly_isOn(&poly, i) > 0)
   1efa4:	f64d 07bc 	movw	r7, #55484	; 0xd8bc
   1efa8:	f2c0 240f 	movt	r4, #527	; 0x20f
			displayValues[5] = knobs[5] * 4000.0f;
   1efac:	ee08 3a10 	vmov	s16, r3
   1efb0:	f2c0 250f 	movt	r5, #527	; 0x20f
   1efb4:	f2c0 290f 	movt	r9, #527	; 0x20f
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1efb8:	ee08 2a90 	vmov	s17, r2
			if (tSimplePoly_isOn(&poly, i) > 0)
   1efbc:	f2c0 270f 	movt	r7, #527	; 0x20f
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1efc0:	4692      	mov	sl, r2
   1efc2:	9002      	str	r0, [sp, #8]
   1efc4:	e005      	b.n	1efd2 <SFXSamplerKTick+0x5e>
   1efc6:	f10a 0a01 	add.w	sl, sl, #1
   1efca:	f1ba 0f06 	cmp.w	sl, #6
   1efce:	f000 810a 	beq.w	1f1e6 <SFXSamplerKTick+0x272>
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1efd2:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
			displayValues[0] = knobs[0];
   1efd6:	ed94 1a96 	vldr	s2, [r4, #600]	; 0x258
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1efda:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
   1efde:	eeb0 0a68 	vmov.f32	s0, s17
			displayValues[0] = knobs[0];
   1efe2:	ed85 1a00 	vstr	s2, [r5]
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1efe6:	ee39 1a41 	vsub.f32	s2, s18, s2
   1efea:	f00d fef9 	bl	2cde0 <LEAF_clip>
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1efee:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1eff2:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1eff6:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
   1effa:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1effe:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
   1f002:	ee75 5ae7 	vsub.f32	s11, s11, s15
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1f006:	ed85 0a01 	vstr	s0, [r5, #4]
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f00a:	ee76 7ae7 	vsub.f32	s15, s13, s15
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f00e:	ee25 6a86 	vmul.f32	s12, s11, s12
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f012:	ee67 7a87 	vmul.f32	s15, s15, s14
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f016:	ed85 6a02 	vstr	s12, [r5, #8]
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f01a:	fef8 7a67 	vrinta.f32	s15, s15
			if (rate < 0.0f)
   1f01e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1f022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f026:	f100 8138 	bmi.w	1f29a <SFXSamplerKTick+0x326>
				rate += 1.0f;
   1f02a:	ee77 7a89 	vadd.f32	s15, s15, s18
			displayValues[5] = knobs[5] * 4000.0f;
   1f02e:	edd4 6a9b 	vldr	s13, [r4, #620]	; 0x26c
			if (tSimplePoly_isOn(&poly, i) > 0)
   1f032:	fa5f f68a 	uxtb.w	r6, sl
			displayValues[4] = roundf(knobs[4]);
   1f036:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
			if (tSimplePoly_isOn(&poly, i) > 0)
   1f03a:	4638      	mov	r0, r7
			displayValues[5] = knobs[5] * 4000.0f;
   1f03c:	ee66 6a88 	vmul.f32	s13, s13, s16
			displayValues[6] = knobs[6];
   1f040:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
			if (tSimplePoly_isOn(&poly, i) > 0)
   1f044:	4631      	mov	r1, r6
			displayValues[3] = rate;
   1f046:	edc5 7a03 	vstr	s15, [r5, #12]
			displayValues[6] = knobs[6];
   1f04a:	61ab      	str	r3, [r5, #24]
			displayValues[4] = roundf(knobs[4]);
   1f04c:	fef8 7a47 	vrinta.f32	s15, s14
			displayValues[5] = knobs[5] * 4000.0f;
   1f050:	edc5 6a05 	vstr	s13, [r5, #20]
			displayValues[4] = roundf(knobs[4]);
   1f054:	edc5 7a04 	vstr	s15, [r5, #16]
			if (tSimplePoly_isOn(&poly, i) > 0)
   1f058:	f00e fd74 	bl	2db44 <tSimplePoly_isOn>
   1f05c:	2800      	cmp	r0, #0
   1f05e:	ddb2      	ble.n	1efc6 <SFXSamplerKTick+0x52>
				int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
   1f060:	4631      	mov	r1, r6
   1f062:	4638      	mov	r0, r7
   1f064:	f00e fd5c 	bl	2db20 <tSimplePoly_getPitch>
   1f068:	f1a0 0b24 	sub.w	fp, r0, #36	; 0x24
				if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
   1f06c:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
   1f070:	d8a9      	bhi.n	1efc6 <SFXSamplerKTick+0x52>
					tBuffer_tick(&keyBuff[key], input[1]);
   1f072:	f24e 5300 	movw	r3, #58624	; 0xe500
   1f076:	ea4f 088b 	mov.w	r8, fp, lsl #2
   1f07a:	9a02      	ldr	r2, [sp, #8]
   1f07c:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f080:	ed92 0a01 	vldr	s0, [r2, #4]
   1f084:	eb03 0608 	add.w	r6, r3, r8
   1f088:	4630      	mov	r0, r6
   1f08a:	f010 f99b 	bl	2f3c4 <tBuffer_tick>
					int recordedLength = tBuffer_getRecordedLength(&keyBuff[key]);
   1f08e:	4630      	mov	r0, r6
   1f090:	f010 f9dc 	bl	2f44c <tBuffer_getRecordedLength>
					sampleLength = recordedLength * leaf.invSampleRate;
   1f094:	f64f 0208 	movw	r2, #63496	; 0xf808
   1f098:	ee07 0a90 	vmov	s15, r0
					if (knobs[0] != prevKnobs[0])
   1f09c:	edd4 6a96 	vldr	s13, [r4, #600]	; 0x258
   1f0a0:	ed99 6a00 	vldr	s12, [r9]
					sampleLength = recordedLength * leaf.invSampleRate;
   1f0a4:	f2c0 220f 	movt	r2, #527	; 0x20f
   1f0a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1f0ac:	f646 1364 	movw	r3, #26980	; 0x6964
					if (knobs[0] != prevKnobs[0])
   1f0b0:	eef4 6a46 	vcmp.f32	s13, s12
					sampleLength = recordedLength * leaf.invSampleRate;
   1f0b4:	ed92 7a01 	vldr	s14, [r2, #4]
   1f0b8:	f2c0 230e 	movt	r3, #526	; 0x20e
   1f0bc:	ee27 7a27 	vmul.f32	s14, s14, s15
					if (knobs[0] != prevKnobs[0])
   1f0c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					sampleLength = recordedLength * leaf.invSampleRate;
   1f0c4:	ed83 7a00 	vstr	s14, [r3]
						samplePlayStarts[key]= (knobs[0] * recordedLength);
   1f0c8:	f24d 63e4 	movw	r3, #55012	; 0xd6e4
					if (knobs[0] != prevKnobs[0])
   1f0cc:	f040 80ec 	bne.w	1f2a8 <SFXSamplerKTick+0x334>
   1f0d0:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f0d4:	4443      	add	r3, r8
   1f0d6:	edd3 6a00 	vldr	s13, [r3]
					if (knobs[1] != prevKnobs[1])
   1f0da:	ed94 7a97 	vldr	s14, [r4, #604]	; 0x25c
						samplePlayLengths[key] = (knobs[1] * recordedLength);
   1f0de:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
					if (knobs[1] != prevKnobs[1])
   1f0e2:	ed99 6a01 	vldr	s12, [r9, #4]
   1f0e6:	eeb4 7a46 	vcmp.f32	s14, s12
   1f0ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f0ee:	f040 825f 	bne.w	1f5b0 <SFXSamplerKTick+0x63c>
   1f0f2:	f2c0 220f 	movt	r2, #527	; 0x20f
					if (knobs[2] != prevKnobs[2])
   1f0f6:	ed94 7a98 	vldr	s14, [r4, #608]	; 0x260
						sampleRates[key] = displayValues[2];
   1f0fa:	f24c 63d0 	movw	r3, #50896	; 0xc6d0
					if (knobs[2] != prevKnobs[2])
   1f0fe:	edd9 7a02 	vldr	s15, [r9, #8]
   1f102:	eeb4 7a67 	vcmp.f32	s14, s15
   1f106:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f10a:	f040 824a 	bne.w	1f5a2 <SFXSamplerKTick+0x62e>
   1f10e:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f112:	9305      	str	r3, [sp, #20]
					if (knobs[3] != prevKnobs[3])
   1f114:	ed94 7a99 	vldr	s14, [r4, #612]	; 0x264
						sampleRatesMult[key] = displayValues[3];
   1f118:	f64d 33ec 	movw	r3, #56300	; 0xdbec
					if (knobs[3] != prevKnobs[3])
   1f11c:	edd9 7a03 	vldr	s15, [r9, #12]
   1f120:	eeb4 7a67 	vcmp.f32	s14, s15
   1f124:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f128:	f040 8234 	bne.w	1f594 <SFXSamplerKTick+0x620>
   1f12c:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f130:	9304      	str	r3, [sp, #16]
					if (knobs[4] != prevKnobs[4])
   1f132:	edd4 7a9a 	vldr	s15, [r4, #616]	; 0x268
						loopOns[key] = roundf(knobs[4]);
   1f136:	f64c 13b4 	movw	r3, #51636	; 0xc9b4
					if (knobs[4] != prevKnobs[4])
   1f13a:	ed99 7a04 	vldr	s14, [r9, #16]
   1f13e:	eef4 7a47 	vcmp.f32	s15, s14
   1f142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f146:	f040 8219 	bne.w	1f57c <SFXSamplerKTick+0x608>
   1f14a:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f14e:	9303      	str	r3, [sp, #12]
					if (knobs[5] != prevKnobs[5])
   1f150:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
						crossfadeLengths[key] = displayValues[5];
   1f154:	f64d 3324 	movw	r3, #56100	; 0xdb24
					if (knobs[5] != prevKnobs[5])
   1f158:	edd9 7a05 	vldr	s15, [r9, #20]
   1f15c:	eeb4 7a67 	vcmp.f32	s14, s15
   1f160:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f164:	f040 8203 	bne.w	1f56e <SFXSamplerKTick+0x5fa>
   1f168:	f2c0 230f 	movt	r3, #527	; 0x20f
					tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
   1f16c:	f24d 2694 	movw	r6, #53908	; 0xd294
   1f170:	eefd 7ae6 	vcvt.s32.f32	s15, s13
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1f174:	f10a 0a01 	add.w	sl, sl, #1
					tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
   1f178:	f2c0 260f 	movt	r6, #527	; 0x20f
   1f17c:	ee17 1a90 	vmov	r1, s15
   1f180:	4446      	add	r6, r8
   1f182:	4630      	mov	r0, r6
   1f184:	e9cd 3206 	strd	r3, r2, [sp, #24]
   1f188:	f010 fa78 	bl	2f67c <tSampler_setStart>
					tSampler_setLength(&keySampler[key], samplePlayLengths[key]);
   1f18c:	9a07      	ldr	r2, [sp, #28]
   1f18e:	4630      	mov	r0, r6
   1f190:	4442      	add	r2, r8
   1f192:	edd2 7a00 	vldr	s15, [r2]
   1f196:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f19a:	ee17 1a90 	vmov	r1, s15
   1f19e:	f010 fead 	bl	2fefc <tSampler_setLength>
					tSampler_setCrossfadeLength(&keySampler[key], crossfadeLengths[key]);
   1f1a2:	9b06      	ldr	r3, [sp, #24]
   1f1a4:	4630      	mov	r0, r6
   1f1a6:	4443      	add	r3, r8
   1f1a8:	edd3 7a00 	vldr	s15, [r3]
   1f1ac:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1f1b0:	ee17 1a90 	vmov	r1, s15
   1f1b4:	f010 f9f6 	bl	2f5a4 <tSampler_setCrossfadeLength>
					tSampler_setRate(&keySampler[key], sampleRates[key] * sampleRatesMult[key]);
   1f1b8:	9b05      	ldr	r3, [sp, #20]
   1f1ba:	9a04      	ldr	r2, [sp, #16]
   1f1bc:	4630      	mov	r0, r6
   1f1be:	4443      	add	r3, r8
   1f1c0:	4442      	add	r2, r8
   1f1c2:	ed93 0a00 	vldr	s0, [r3]
   1f1c6:	edd2 7a00 	vldr	s15, [r2]
   1f1ca:	ee20 0a27 	vmul.f32	s0, s0, s15
   1f1ce:	f010 ff61 	bl	30094 <tSampler_setRate>
					tSampler_setMode(&keySampler[key], loopOns[key]);
   1f1d2:	9b03      	ldr	r3, [sp, #12]
   1f1d4:	4630      	mov	r0, r6
   1f1d6:	f813 102b 	ldrb.w	r1, [r3, fp, lsl #2]
   1f1da:	f010 f9df 	bl	2f59c <tSampler_setMode>
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1f1de:	f1ba 0f06 	cmp.w	sl, #6
   1f1e2:	f47f aef6 	bne.w	1efd2 <SFXSamplerKTick+0x5e>
   1f1e6:	f8dd b008 	ldr.w	fp, [sp, #8]
   1f1ea:	f64c 4cd0 	movw	ip, #52432	; 0xccd0
		if ( tempGain > 0.0001f)
   1f1ee:	f24b 7317 	movw	r3, #46871	; 0xb717
	float sample = 0.0f;
   1f1f2:	2200      	movs	r2, #0
   1f1f4:	f24e 47e8 	movw	r7, #58600	; 0xe4e8
		if ( tempGain > 0.0001f)
   1f1f8:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   1f1fc:	f2c0 2c0f 	movt	ip, #527	; 0x20f
   1f200:	f2c0 270f 	movt	r7, #527	; 0x20f
	float sample = 0.0f;
   1f204:	ee09 2a10 	vmov	s18, r2
		if ( tempGain > 0.0001f)
   1f208:	ee08 3a90 	vmov	s17, r3
   1f20c:	f24c 35f4 	movw	r5, #50164	; 0xc3f4
			sample += tSampler_tick(&keySampler[i]) * tempGain;
   1f210:	f24d 2694 	movw	r6, #53908	; 0xd294
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1f214:	2400      	movs	r4, #0
   1f216:	f2c0 250f 	movt	r5, #527	; 0x20f
			sample += tSampler_tick(&keySampler[i]) * tempGain;
   1f21a:	f2c0 260f 	movt	r6, #527	; 0x20f
   1f21e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1f222:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   1f224:	e89c 0003 	ldmia.w	ip, {r0, r1}
   1f228:	e887 0003 	stmia.w	r7, {r0, r1}
   1f22c:	e002      	b.n	1f234 <SFXSamplerKTick+0x2c0>
   1f22e:	3404      	adds	r4, #4
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1f230:	2cc4      	cmp	r4, #196	; 0xc4
   1f232:	d011      	beq.n	1f258 <SFXSamplerKTick+0x2e4>
		float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
   1f234:	1928      	adds	r0, r5, r4
   1f236:	f00c f8c9 	bl	2b3cc <tExpSmooth_tick>
		if ( tempGain > 0.0001f)
   1f23a:	eeb4 0ae8 	vcmpe.f32	s0, s17
		float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
   1f23e:	eeb0 8a40 	vmov.f32	s16, s0
		if ( tempGain > 0.0001f)
   1f242:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f246:	ddf2      	ble.n	1f22e <SFXSamplerKTick+0x2ba>
			sample += tSampler_tick(&keySampler[i]) * tempGain;
   1f248:	1930      	adds	r0, r6, r4
   1f24a:	3404      	adds	r4, #4
   1f24c:	f010 fb70 	bl	2f930 <tSampler_tick>
   1f250:	eea0 9a08 	vfma.f32	s18, s0, s16
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1f254:	2cc4      	cmp	r4, #196	; 0xc4
   1f256:	d1ed      	bne.n	1f234 <SFXSamplerKTick+0x2c0>
	sample = tanhf(sample) * 0.98;
   1f258:	f648 735c 	movw	r3, #36700	; 0x8f5c
   1f25c:	eeb0 0a49 	vmov.f32	s0, s18
   1f260:	9300      	str	r3, [sp, #0]
   1f262:	f011 fbe3 	bl	30a2c <tanhf>
   1f266:	9b00      	ldr	r3, [sp, #0]
   1f268:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
   1f26c:	f2cf 53c2 	movt	r3, #62914	; 0xf5c2
   1f270:	9300      	str	r3, [sp, #0]
   1f272:	f645 4328 	movw	r3, #23592	; 0x5c28
   1f276:	f6c3 73ef 	movt	r3, #16367	; 0x3fef
   1f27a:	9301      	str	r3, [sp, #4]
   1f27c:	ed9d 7b00 	vldr	d7, [sp]
   1f280:	ee20 0b07 	vmul.f64	d0, d0, d7
   1f284:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
	input[0] = sample;
   1f288:	ed8b 0a00 	vstr	s0, [fp]
	input[1] = sample;
   1f28c:	ed8b 0a01 	vstr	s0, [fp, #4]
}
   1f290:	b009      	add	sp, #36	; 0x24
   1f292:	ecbd 8b04 	vpop	{d8-d9}
   1f296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				(rate = 1.0f / fabsf(rate-1.0f));
   1f29a:	ee77 7ac9 	vsub.f32	s15, s15, s18
   1f29e:	eeb0 7ae7 	vabs.f32	s14, s15
   1f2a2:	eec9 7a07 	vdiv.f32	s15, s18, s14
   1f2a6:	e6c2      	b.n	1f02e <SFXSamplerKTick+0xba>
						samplePlayStarts[key]= (knobs[0] * recordedLength);
   1f2a8:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f2ac:	ee67 6aa6 	vmul.f32	s13, s15, s13
   1f2b0:	4443      	add	r3, r8
   1f2b2:	edc3 6a00 	vstr	s13, [r3]
   1f2b6:	e710      	b.n	1f0da <SFXSamplerKTick+0x166>
	int currentSamplerKey = currentSamplerKeyGlobal;
   1f2b8:	f246 2324 	movw	r3, #25124	; 0x6224
		int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1f2bc:	f24e 5000 	movw	r0, #58624	; 0xe500
		displayValues[0] = knobs[0] * sampleLength;
   1f2c0:	f64c 2478 	movw	r4, #51832	; 0xca78
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f2c4:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
	int currentSamplerKey = currentSamplerKeyGlobal;
   1f2c8:	f2c0 0306 	movt	r3, #6
		int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1f2cc:	f2c0 200f 	movt	r0, #527	; 0x20f
		displayValues[0] = knobs[0] * sampleLength;
   1f2d0:	f2c0 240f 	movt	r4, #527	; 0x20f
   1f2d4:	f64e 352c 	movw	r5, #60204	; 0xeb2c
	int currentSamplerKey = currentSamplerKeyGlobal;
   1f2d8:	681b      	ldr	r3, [r3, #0]
		displayValues[0] = knobs[0] * sampleLength;
   1f2da:	f2c0 250f 	movt	r5, #527	; 0x20f
   1f2de:	009f      	lsls	r7, r3, #2
	int currentSamplerKey = currentSamplerKeyGlobal;
   1f2e0:	9302      	str	r3, [sp, #8]
		int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1f2e2:	4438      	add	r0, r7
   1f2e4:	f010 f8b2 	bl	2f44c <tBuffer_getRecordedLength>
		sampleLength = recordedLength * leaf.invSampleRate;
   1f2e8:	f64f 0208 	movw	r2, #63496	; 0xf808
   1f2ec:	ee07 0a90 	vmov	s15, r0
		displayValues[0] = knobs[0] * sampleLength;
   1f2f0:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
		sampleLength = recordedLength * leaf.invSampleRate;
   1f2f4:	f2c0 220f 	movt	r2, #527	; 0x20f
   1f2f8:	f646 1364 	movw	r3, #26980	; 0x6964
   1f2fc:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f300:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
		sampleLength = recordedLength * leaf.invSampleRate;
   1f304:	edd2 7a01 	vldr	s15, [r2, #4]
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f308:	ee38 1ac7 	vsub.f32	s2, s17, s14
   1f30c:	2200      	movs	r2, #0
		sampleLength = recordedLength * leaf.invSampleRate;
   1f30e:	f2c0 230e 	movt	r3, #526	; 0x20e
   1f312:	ee68 7a27 	vmul.f32	s15, s16, s15
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f316:	ee00 2a10 	vmov	s0, r2
		displayValues[0] = knobs[0] * sampleLength;
   1f31a:	ee27 7a87 	vmul.f32	s14, s15, s14
		sampleLength = recordedLength * leaf.invSampleRate;
   1f31e:	edc3 7a00 	vstr	s15, [r3]
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f322:	ee21 1a27 	vmul.f32	s2, s2, s15
   1f326:	ee67 0aa0 	vmul.f32	s1, s15, s1
		displayValues[0] = knobs[0] * sampleLength;
   1f32a:	ed85 7a00 	vstr	s14, [r5]
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f32e:	f00d fd57 	bl	2cde0 <LEAF_clip>
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f332:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1f336:	ed94 6a98 	vldr	s12, [r4, #608]	; 0x260
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f33a:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
   1f33e:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f342:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1f346:	ed85 0a01 	vstr	s0, [r5, #4]
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f34a:	ee76 3a67 	vsub.f32	s7, s12, s15
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f34e:	ee76 7ae7 	vsub.f32	s15, s13, s15
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f352:	ee63 3aa5 	vmul.f32	s7, s7, s11
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f356:	ee67 7a87 	vmul.f32	s15, s15, s14
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1f35a:	edc5 3a02 	vstr	s7, [r5, #8]
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1f35e:	fef8 7a67 	vrinta.f32	s15, s15
		if (rate < 0.0f)
   1f362:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1f366:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f36a:	f100 8146 	bmi.w	1f5fa <SFXSamplerKTick+0x686>
			rate += 1.0f;
   1f36e:	ee77 2aa8 	vadd.f32	s5, s15, s17
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f372:	f24e 49e8 	movw	r9, #58600	; 0xe4e8
   1f376:	ed94 5a96 	vldr	s10, [r4, #600]	; 0x258
   1f37a:	f24b 7317 	movw	r3, #46871	; 0xb717
		displayValues[5] = knobs[5] * 4000.0f;
   1f37e:	2200      	movs	r2, #0
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f380:	f2c0 290f 	movt	r9, #527	; 0x20f
		displayValues[5] = knobs[5] * 4000.0f;
   1f384:	edd4 7a9b 	vldr	s15, [r4, #620]	; 0x26c
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f388:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
		displayValues[5] = knobs[5] * 4000.0f;
   1f38c:	f2c4 527a 	movt	r2, #17786	; 0x457a
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f390:	edd9 5a00 	vldr	s11, [r9]
   1f394:	ee04 3a90 	vmov	s9, r3
		displayValues[5] = knobs[5] * 4000.0f;
   1f398:	ee04 2a10 	vmov	s8, r2
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f39c:	ee75 5a65 	vsub.f32	s11, s10, s11
		displayValues[6] = knobs[6];
   1f3a0:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
		displayValues[5] = knobs[5] * 4000.0f;
   1f3a4:	ee27 4a84 	vmul.f32	s8, s15, s8
		displayValues[4] = roundf(knobs[4]);
   1f3a8:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
		displayValues[6] = knobs[6];
   1f3ac:	61ab      	str	r3, [r5, #24]
			samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
   1f3ae:	f24d 63e4 	movw	r3, #55012	; 0xd6e4
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f3b2:	eef0 5ae5 	vabs.f32	s11, s11
		displayValues[4] = roundf(knobs[4]);
   1f3b6:	feb8 3a47 	vrinta.f32	s6, s14
		displayValues[3] = rate;
   1f3ba:	edc5 2a03 	vstr	s5, [r5, #12]
		displayValues[4] = roundf(knobs[4]);
   1f3be:	ed85 3a04 	vstr	s6, [r5, #16]
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f3c2:	eef4 5ae4 	vcmpe.f32	s11, s9
		displayValues[5] = knobs[5] * 4000.0f;
   1f3c6:	ed85 4a05 	vstr	s8, [r5, #20]
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1f3ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f3ce:	f300 80f8 	bgt.w	1f5c2 <SFXSamplerKTick+0x64e>
   1f3d2:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f3d6:	443b      	add	r3, r7
   1f3d8:	ed93 5a00 	vldr	s10, [r3]
		if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
   1f3dc:	ed94 2a97 	vldr	s4, [r4, #604]	; 0x25c
   1f3e0:	f24b 7317 	movw	r3, #46871	; 0xb717
   1f3e4:	edd9 5a01 	vldr	s11, [r9, #4]
			samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
   1f3e8:	f24c 5ae8 	movw	sl, #50664	; 0xc5e8
		if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
   1f3ec:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   1f3f0:	ee72 5a65 	vsub.f32	s11, s4, s11
   1f3f4:	ee04 3a90 	vmov	s9, r3
   1f3f8:	eef0 5ae5 	vabs.f32	s11, s11
   1f3fc:	eef4 5ae4 	vcmpe.f32	s11, s9
   1f400:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f404:	f300 80f0 	bgt.w	1f5e8 <SFXSamplerKTick+0x674>
   1f408:	f2c0 2a0f 	movt	sl, #527	; 0x20f
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1f40c:	edd9 5a02 	vldr	s11, [r9, #8]
   1f410:	f24b 7317 	movw	r3, #46871	; 0xb717
			sampleRatesMult[currentSamplerKey] = displayValues[3];
   1f414:	f64d 38ec 	movw	r8, #56300	; 0xdbec
			loopOns[currentSamplerKey] = roundf(knobs[4]);
   1f418:	f64c 12b4 	movw	r2, #51636	; 0xc9b4
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1f41c:	ee36 6a65 	vsub.f32	s12, s12, s11
   1f420:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
			sampleRatesMult[currentSamplerKey] = displayValues[3];
   1f424:	f2c0 280f 	movt	r8, #527	; 0x20f
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1f428:	ee05 3a90 	vmov	s11, r3
			sampleRates[currentSamplerKey] = displayValues[2];
   1f42c:	f24c 63d0 	movw	r3, #50896	; 0xc6d0
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1f430:	eeb0 6ac6 	vabs.f32	s12, s12
			sampleRates[currentSamplerKey] = displayValues[2];
   1f434:	f2c0 230f 	movt	r3, #527	; 0x20f
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1f438:	eeb4 6ae5 	vcmpe.f32	s12, s11
			sampleRates[currentSamplerKey] = displayValues[2];
   1f43c:	9303      	str	r3, [sp, #12]
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1f43e:	ed99 6a03 	vldr	s12, [r9, #12]
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1f442:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1f446:	ee76 6ac6 	vsub.f32	s13, s13, s12
			sampleRates[currentSamplerKey] = displayValues[2];
   1f44a:	bfc8      	it	gt
   1f44c:	19db      	addgt	r3, r3, r7
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1f44e:	eef0 6ae6 	vabs.f32	s13, s13
			sampleRates[currentSamplerKey] = displayValues[2];
   1f452:	bfc8      	it	gt
   1f454:	edc3 3a00 	vstrgt	s7, [r3]
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1f458:	f24b 7317 	movw	r3, #46871	; 0xb717
   1f45c:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   1f460:	ee06 3a10 	vmov	s12, r3
   1f464:	eef4 6ac6 	vcmpe.f32	s13, s12
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1f468:	edd9 6a04 	vldr	s13, [r9, #16]
   1f46c:	ee37 7a66 	vsub.f32	s14, s14, s13
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1f470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1f474:	eeb0 7ac7 	vabs.f32	s14, s14
			sampleRatesMult[currentSamplerKey] = displayValues[3];
   1f478:	bfc4      	itt	gt
   1f47a:	eb08 0307 	addgt.w	r3, r8, r7
   1f47e:	edc3 2a00 	vstrgt	s5, [r3]
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1f482:	f24b 7317 	movw	r3, #46871	; 0xb717
   1f486:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   1f48a:	ee06 3a90 	vmov	s13, r3
   1f48e:	eeb4 7ae6 	vcmpe.f32	s14, s13
   1f492:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f496:	f300 809c 	bgt.w	1f5d2 <SFXSamplerKTick+0x65e>
   1f49a:	f2c0 220f 	movt	r2, #527	; 0x20f
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1f49e:	ed99 7a05 	vldr	s14, [r9, #20]
   1f4a2:	f24b 7317 	movw	r3, #46871	; 0xb717
		tSampler_forceStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1f4a6:	f24d 2694 	movw	r6, #53908	; 0xd294
			crossfadeLengths[currentSamplerKey] = displayValues[5];
   1f4aa:	f64d 3924 	movw	r9, #56100	; 0xdb24
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1f4ae:	ee77 7ac7 	vsub.f32	s15, s15, s14
   1f4b2:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
		tSampler_forceStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1f4b6:	f2c0 260f 	movt	r6, #527	; 0x20f
			crossfadeLengths[currentSamplerKey] = displayValues[5];
   1f4ba:	f2c0 290f 	movt	r9, #527	; 0x20f
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1f4be:	ee07 3a10 	vmov	s14, r3
		tSampler_forceLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
   1f4c2:	44ba      	add	sl, r7
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1f4c4:	eef0 7ae7 	vabs.f32	s15, s15
		tSampler_forceStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1f4c8:	443e      	add	r6, r7
   1f4ca:	9204      	str	r2, [sp, #16]
   1f4cc:	f64d 24d3 	movw	r4, #56019	; 0xdad3
   1f4d0:	4630      	mov	r0, r6
   1f4d2:	f24e 5500 	movw	r5, #58624	; 0xe500
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1f4d6:	eef4 7ac7 	vcmpe.f32	s15, s14
   1f4da:	f2c0 240f 	movt	r4, #527	; 0x20f
		tSampler_forceStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1f4de:	eefd 7ac5 	vcvt.s32.f32	s15, s10
   1f4e2:	f2c0 250f 	movt	r5, #527	; 0x20f
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1f4e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		tSampler_forceStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1f4ea:	ee17 1a90 	vmov	r1, s15
			crossfadeLengths[currentSamplerKey] = displayValues[5];
   1f4ee:	bfc4      	itt	gt
   1f4f0:	eb09 0307 	addgt.w	r3, r9, r7
   1f4f4:	ed83 4a00 	vstrgt	s8, [r3]
		tSampler_forceStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1f4f8:	f010 f956 	bl	2f7a8 <tSampler_forceStart>
		tSampler_forceLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
   1f4fc:	edda 7a00 	vldr	s15, [sl]
   1f500:	4630      	mov	r0, r6
   1f502:	f104 0a31 	add.w	sl, r4, #49	; 0x31
   1f506:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f50a:	ee17 1a90 	vmov	r1, s15
   1f50e:	f010 fd8f 	bl	30030 <tSampler_forceLength>
		tSampler_setCrossfadeLength(&keySampler[currentSamplerKey], crossfadeLengths[currentSamplerKey]);
   1f512:	eb09 0307 	add.w	r3, r9, r7
   1f516:	4630      	mov	r0, r6
   1f518:	edd3 7a00 	vldr	s15, [r3]
   1f51c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1f520:	ee17 1a90 	vmov	r1, s15
   1f524:	f010 f83e 	bl	2f5a4 <tSampler_setCrossfadeLength>
		tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
   1f528:	9b03      	ldr	r3, [sp, #12]
   1f52a:	4630      	mov	r0, r6
   1f52c:	443b      	add	r3, r7
   1f52e:	4447      	add	r7, r8
   1f530:	ed93 0a00 	vldr	s0, [r3]
   1f534:	edd7 7a00 	vldr	s15, [r7]
   1f538:	ee20 0a27 	vmul.f32	s0, s0, s15
   1f53c:	f010 fdaa 	bl	30094 <tSampler_setRate>
		tSampler_setMode(&keySampler[currentSamplerKey], loopOns[currentSamplerKey]);
   1f540:	9b02      	ldr	r3, [sp, #8]
   1f542:	9a04      	ldr	r2, [sp, #16]
   1f544:	4630      	mov	r0, r6
   1f546:	f812 1023 	ldrb.w	r1, [r2, r3, lsl #2]
   1f54a:	f010 f827 	bl	2f59c <tSampler_setMode>
   1f54e:	e004      	b.n	1f55a <SFXSamplerKTick+0x5e6>
		for (int i = 0; i < NUM_SAMPLER_KEYS; ++i)
   1f550:	45a2      	cmp	sl, r4
   1f552:	f105 0504 	add.w	r5, r5, #4
   1f556:	f43f ae48 	beq.w	1f1ea <SFXSamplerKTick+0x276>
			if (samplerKeyHeld[i] > 0)
   1f55a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   1f55e:	2b00      	cmp	r3, #0
   1f560:	d0f6      	beq.n	1f550 <SFXSamplerKTick+0x5dc>
				tBuffer_tick(&keyBuff[i], input[1]);
   1f562:	ed9b 0a01 	vldr	s0, [fp, #4]
   1f566:	4628      	mov	r0, r5
   1f568:	f00f ff2c 	bl	2f3c4 <tBuffer_tick>
   1f56c:	e7f0      	b.n	1f550 <SFXSamplerKTick+0x5dc>
						crossfadeLengths[key] = displayValues[5];
   1f56e:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f572:	6968      	ldr	r0, [r5, #20]
   1f574:	eb03 0108 	add.w	r1, r3, r8
   1f578:	6008      	str	r0, [r1, #0]
   1f57a:	e5f7      	b.n	1f16c <SFXSamplerKTick+0x1f8>
						loopOns[key] = roundf(knobs[4]);
   1f57c:	fef8 7a67 	vrinta.f32	s15, s15
   1f580:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f584:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f588:	ee17 1a90 	vmov	r1, s15
   1f58c:	9303      	str	r3, [sp, #12]
   1f58e:	f843 102b 	str.w	r1, [r3, fp, lsl #2]
   1f592:	e5dd      	b.n	1f150 <SFXSamplerKTick+0x1dc>
						sampleRatesMult[key] = displayValues[3];
   1f594:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f598:	68e9      	ldr	r1, [r5, #12]
   1f59a:	9304      	str	r3, [sp, #16]
   1f59c:	4443      	add	r3, r8
   1f59e:	6019      	str	r1, [r3, #0]
   1f5a0:	e5c7      	b.n	1f132 <SFXSamplerKTick+0x1be>
						sampleRates[key] = displayValues[2];
   1f5a2:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f5a6:	68a9      	ldr	r1, [r5, #8]
   1f5a8:	9305      	str	r3, [sp, #20]
   1f5aa:	4443      	add	r3, r8
   1f5ac:	6019      	str	r1, [r3, #0]
   1f5ae:	e5b1      	b.n	1f114 <SFXSamplerKTick+0x1a0>
						samplePlayLengths[key] = (knobs[1] * recordedLength);
   1f5b0:	f2c0 220f 	movt	r2, #527	; 0x20f
   1f5b4:	ee67 7a87 	vmul.f32	s15, s15, s14
   1f5b8:	eb02 0308 	add.w	r3, r2, r8
   1f5bc:	edc3 7a00 	vstr	s15, [r3]
   1f5c0:	e599      	b.n	1f0f6 <SFXSamplerKTick+0x182>
			samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
   1f5c2:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f5c6:	ee28 5a05 	vmul.f32	s10, s16, s10
   1f5ca:	443b      	add	r3, r7
   1f5cc:	ed83 5a00 	vstr	s10, [r3]
   1f5d0:	e704      	b.n	1f3dc <SFXSamplerKTick+0x468>
			loopOns[currentSamplerKey] = roundf(knobs[4]);
   1f5d2:	eebd 3ac3 	vcvt.s32.f32	s6, s6
   1f5d6:	9b02      	ldr	r3, [sp, #8]
   1f5d8:	f2c0 220f 	movt	r2, #527	; 0x20f
   1f5dc:	4619      	mov	r1, r3
   1f5de:	ee13 3a10 	vmov	r3, s6
   1f5e2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
   1f5e6:	e75a      	b.n	1f49e <SFXSamplerKTick+0x52a>
			samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
   1f5e8:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   1f5ec:	ee28 8a02 	vmul.f32	s16, s16, s4
   1f5f0:	eb0a 0307 	add.w	r3, sl, r7
   1f5f4:	ed83 8a00 	vstr	s16, [r3]
   1f5f8:	e708      	b.n	1f40c <SFXSamplerKTick+0x498>
			(rate = 1.0f / fabsf(rate-1.0f));
   1f5fa:	ee77 7ae8 	vsub.f32	s15, s15, s17
   1f5fe:	eef0 7ae7 	vabs.f32	s15, s15
   1f602:	eec8 2aa7 	vdiv.f32	s5, s17, s15
   1f606:	e6b4      	b.n	1f372 <SFXSamplerKTick+0x3fe>

0001f608 <SFXSamplerKFree>:
{
   1f608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f60a:	f24e 5700 	movw	r7, #58624	; 0xe500
   1f60e:	f24d 2694 	movw	r6, #53908	; 0xd294
   1f612:	f24c 35f4 	movw	r5, #50164	; 0xc3f4
   1f616:	2400      	movs	r4, #0
   1f618:	f2c0 270f 	movt	r7, #527	; 0x20f
   1f61c:	f2c0 260f 	movt	r6, #527	; 0x20f
   1f620:	f2c0 250f 	movt	r5, #527	; 0x20f
		tBuffer_free(&keyBuff[i]);
   1f624:	1938      	adds	r0, r7, r4
   1f626:	f00f fec1 	bl	2f3ac <tBuffer_free>
		tSampler_free(&keySampler[i]);
   1f62a:	1930      	adds	r0, r6, r4
   1f62c:	f00f ffaa 	bl	2f584 <tSampler_free>
		tExpSmooth_free(&kSamplerGains[i]);
   1f630:	1928      	adds	r0, r5, r4
   1f632:	3404      	adds	r4, #4
   1f634:	f00b feaa 	bl	2b38c <tExpSmooth_free>
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1f638:	2cc4      	cmp	r4, #196	; 0xc4
   1f63a:	d1f3      	bne.n	1f624 <SFXSamplerKFree+0x1c>
}
   1f63c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1f63e:	bf00      	nop

0001f640 <SFXSamplerAutoAlloc>:
{
   1f640:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1f644:	f24a 57b8 	movw	r7, #42424	; 0xa5b8
   1f648:	f44f 496e 	mov.w	r9, #60928	; 0xee00
   1f64c:	f64d 05a0 	movw	r5, #55456	; 0xd8a0
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1f650:	f64a 6490 	movw	r4, #44688	; 0xae90
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1f654:	f2c0 270f 	movt	r7, #527	; 0x20f
   1f658:	f2c0 0902 	movt	r9, #2
   1f65c:	f2c0 250f 	movt	r5, #527	; 0x20f
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1f660:	f64d 3610 	movw	r6, #56080	; 0xdb10
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1f664:	463a      	mov	r2, r7
   1f666:	4649      	mov	r1, r9
	tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1f668:	f105 0804 	add.w	r8, r5, #4
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1f66c:	4628      	mov	r0, r5
   1f66e:	f00f fe85 	bl	2f37c <tBuffer_initToPool>
	tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
   1f672:	4628      	mov	r0, r5
   1f674:	2100      	movs	r1, #0
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1f676:	f2c0 240f 	movt	r4, #527	; 0x20f
	tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
   1f67a:	f00f fee3 	bl	2f444 <tBuffer_setRecordMode>
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1f67e:	f2c0 260f 	movt	r6, #527	; 0x20f
	tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1f682:	463a      	mov	r2, r7
   1f684:	4649      	mov	r1, r9
   1f686:	4640      	mov	r0, r8
   1f688:	f00f fe78 	bl	2f37c <tBuffer_initToPool>
	tBuffer_setRecordMode(&asBuff[1], RecordOneShot);
   1f68c:	4640      	mov	r0, r8
   1f68e:	2100      	movs	r1, #0
   1f690:	f00f fed8 	bl	2f444 <tBuffer_setRecordMode>
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1f694:	4622      	mov	r2, r4
   1f696:	4629      	mov	r1, r5
   1f698:	4630      	mov	r0, r6
	tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
   1f69a:	1d35      	adds	r5, r6, #4
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1f69c:	f00f ff2c 	bl	2f4f8 <tSampler_initToPool>
	tSampler_setMode(&asSampler[0], PlayLoop);
   1f6a0:	4630      	mov	r0, r6
   1f6a2:	2101      	movs	r1, #1
   1f6a4:	f00f ff7a 	bl	2f59c <tSampler_setMode>
	tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
   1f6a8:	4622      	mov	r2, r4
   1f6aa:	4641      	mov	r1, r8
   1f6ac:	4628      	mov	r0, r5
   1f6ae:	f00f ff23 	bl	2f4f8 <tSampler_initToPool>
	tSampler_setMode(&asSampler[1], PlayLoop);
   1f6b2:	4628      	mov	r0, r5
   1f6b4:	2101      	movs	r1, #1
   1f6b6:	f00f ff71 	bl	2f59c <tSampler_setMode>
	tEnvelopeFollower_initToPool(&envfollow, 0.00001f, 0.9999f, &smallPool);
   1f6ba:	f64f 1272 	movw	r2, #63858	; 0xf972
   1f6be:	f24c 53ac 	movw	r3, #50604	; 0xc5ac
   1f6c2:	f24e 7000 	movw	r0, #59136	; 0xe700
   1f6c6:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
   1f6ca:	4621      	mov	r1, r4
   1f6cc:	f2c3 7327 	movt	r3, #14119	; 0x3727
   1f6d0:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f6d4:	ee00 2a90 	vmov	s1, r2
   1f6d8:	ee00 3a10 	vmov	s0, r3
   1f6dc:	f007 ff98 	bl	27610 <tEnvelopeFollower_initToPool>
	tExpSmooth_initToPool(&cfxSmooth, 0.0f, 0.01f, &smallPool);
   1f6e0:	f24d 730a 	movw	r3, #55050	; 0xd70a
   1f6e4:	2200      	movs	r2, #0
   1f6e6:	f24d 50f8 	movw	r0, #54776	; 0xd5f8
   1f6ea:	f6c3 4323 	movt	r3, #15395	; 0x3c23
   1f6ee:	4621      	mov	r1, r4
   1f6f0:	ee00 2a10 	vmov	s0, r2
   1f6f4:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f6f8:	ee00 3a90 	vmov	s1, r3
   1f6fc:	f00b fe20 	bl	2b340 <tExpSmooth_initToPool>
	setLED_A(samplerMode == PlayBackAndForth);
   1f700:	f246 23a9 	movw	r3, #25257	; 0x62a9
   1f704:	f2c0 0306 	movt	r3, #6
   1f708:	7818      	ldrb	r0, [r3, #0]
   1f70a:	f1a0 0002 	sub.w	r0, r0, #2
   1f70e:	fab0 f080 	clz	r0, r0
   1f712:	0940      	lsrs	r0, r0, #5
   1f714:	f7fb fd0e 	bl	1b134 <setLED_A>
	setLED_B(triggerChannel);
   1f718:	f646 1375 	movw	r3, #26997	; 0x6975
   1f71c:	f2c0 230e 	movt	r3, #526	; 0x20e
   1f720:	7818      	ldrb	r0, [r3, #0]
   1f722:	f7fb fd17 	bl	1b154 <setLED_B>
	currentSampler = 1;
   1f726:	f646 02dc 	movw	r2, #26844	; 0x68dc
	sample_countdown = 0;
   1f72a:	f646 1370 	movw	r3, #26992	; 0x6970
	currentSampler = 1;
   1f72e:	2001      	movs	r0, #1
   1f730:	f2c0 220e 	movt	r2, #526	; 0x20e
	sample_countdown = 0;
   1f734:	2100      	movs	r1, #0
   1f736:	f2c0 230e 	movt	r3, #526	; 0x20e
	currentSampler = 1;
   1f73a:	7010      	strb	r0, [r2, #0]
	sample_countdown = 0;
   1f73c:	6019      	str	r1, [r3, #0]
	randLengthVal = randomNumber() * 10000.0f;
   1f73e:	f7fb fc17 	bl	1af70 <randomNumber>
   1f742:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   1f746:	f646 1254 	movw	r2, #26964	; 0x6954
   1f74a:	f2c4 631c 	movt	r3, #17948	; 0x461c
   1f74e:	f2c0 220e 	movt	r2, #526	; 0x20e
   1f752:	ee07 3a90 	vmov	s15, r3
   1f756:	ee20 0a27 	vmul.f32	s0, s0, s15
   1f75a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   1f75e:	ed82 0a00 	vstr	s0, [r2]
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1f762:	f7fb fc05 	bl	1af70 <randomNumber>
   1f766:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	setLED_C(pitchQuantization);
   1f76a:	f646 1244 	movw	r2, #26948	; 0x6944
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1f76e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   1f772:	f646 1358 	movw	r3, #26968	; 0x6958
	setLED_C(pitchQuantization);
   1f776:	f2c0 220e 	movt	r2, #526	; 0x20e
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1f77a:	ee30 0a67 	vsub.f32	s0, s0, s15
   1f77e:	f2c0 230e 	movt	r3, #526	; 0x20e
	setLED_C(pitchQuantization);
   1f782:	7810      	ldrb	r0, [r2, #0]
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1f784:	ee20 0a07 	vmul.f32	s0, s0, s14
   1f788:	ed83 0a00 	vstr	s0, [r3]
}
   1f78c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	setLED_C(pitchQuantization);
   1f790:	f7fb bcf0 	b.w	1b174 <setLED_C>

0001f794 <SFXSamplerAutoFrame>:
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1f794:	f64e 237c 	movw	r3, #60028	; 0xea7c
   1f798:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f79c:	7f1a      	ldrb	r2, [r3, #28]
   1f79e:	2a01      	cmp	r2, #1
   1f7a0:	d000      	beq.n	1f7a4 <SFXSamplerAutoFrame+0x10>
}
   1f7a2:	4770      	bx	lr
		pitchQuantization = !pitchQuantization;
   1f7a4:	f646 1244 	movw	r2, #26948	; 0x6944
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1f7a8:	2100      	movs	r1, #0
		pitchQuantization = !pitchQuantization;
   1f7aa:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1f7ae:	7719      	strb	r1, [r3, #28]
		pitchQuantization = !pitchQuantization;
   1f7b0:	6813      	ldr	r3, [r2, #0]
   1f7b2:	fab3 f383 	clz	r3, r3
   1f7b6:	095b      	lsrs	r3, r3, #5
		setLED_C(pitchQuantization);
   1f7b8:	4618      	mov	r0, r3
		pitchQuantization = !pitchQuantization;
   1f7ba:	6013      	str	r3, [r2, #0]
		setLED_C(pitchQuantization);
   1f7bc:	f7fb bcda 	b.w	1b174 <setLED_C>

0001f7c0 <SFXSamplerAutoTick>:
{
   1f7c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (triggerChannel > 0)
   1f7c4:	f646 1975 	movw	r9, #26997	; 0x6975
{
   1f7c8:	4605      	mov	r5, r0
		currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
   1f7ca:	f646 04d8 	movw	r4, #26840	; 0x68d8
   1f7ce:	f24e 7000 	movw	r0, #59136	; 0xe700
	if (triggerChannel > 0)
   1f7d2:	f2c0 290e 	movt	r9, #526	; 0x20e
   1f7d6:	f899 3000 	ldrb.w	r3, [r9]
{
   1f7da:	ed2d 8b06 	vpush	{d8-d10}
   1f7de:	b087      	sub	sp, #28
	if (triggerChannel > 0)
   1f7e0:	2b00      	cmp	r3, #0
   1f7e2:	f000 8095 	beq.w	1f910 <SFXSamplerAutoTick+0x150>
		currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
   1f7e6:	f2c0 240e 	movt	r4, #526	; 0x20e
   1f7ea:	ed95 0a00 	vldr	s0, [r5]
   1f7ee:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f7f2:	f007 ff29 	bl	27648 <tEnvelopeFollower_tick>
   1f7f6:	ed84 0a00 	vstr	s0, [r4]
	samp_thresh = 1.0f - knobs[0];
   1f7fa:	f64c 2178 	movw	r1, #51832	; 0xca78
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f7fe:	f246 203c 	movw	r0, #25148	; 0x623c
   1f802:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   1f806:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
	samp_thresh = 1.0f - knobs[0];
   1f80a:	f2c0 210f 	movt	r1, #527	; 0x20f
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f80e:	f2c0 0006 	movt	r0, #6
   1f812:	f6c4 023b 	movt	r2, #18491	; 0x483b
   1f816:	f2c0 230f 	movt	r3, #527	; 0x20f
   1f81a:	edd0 7a00 	vldr	s15, [r0]
   1f81e:	2600      	movs	r6, #0
   1f820:	ed91 7ab0 	vldr	s14, [r1, #704]	; 0x2c0
   1f824:	ee00 2a90 	vmov	s1, r2
   1f828:	f2c4 467a 	movt	r6, #17530	; 0x447a
   1f82c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   1f830:	ee27 7a27 	vmul.f32	s14, s14, s15
   1f834:	edd1 6ab2 	vldr	s13, [r1, #712]	; 0x2c8
   1f838:	ee07 6a90 	vmov	s15, r6
   1f83c:	f2c4 509c 	movt	r0, #17820	; 0x459c
	samp_thresh = 1.0f - knobs[0];
   1f840:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	if (pitchQuantization)
   1f844:	f646 1644 	movw	r6, #26948	; 0x6944
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f848:	eebd 7ac7 	vcvt.s32.f32	s14, s14
	samp_thresh = 1.0f - knobs[0];
   1f84c:	ed91 6aaf 	vldr	s12, [r1, #700]	; 0x2bc
   1f850:	ee66 7aa7 	vmul.f32	s15, s13, s15
   1f854:	ed91 9ab4 	vldr	s18, [r1, #720]	; 0x2d0
   1f858:	ee06 0a90 	vmov	s13, r0
	if (pitchQuantization)
   1f85c:	f2c0 260e 	movt	r6, #526	; 0x20e
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f860:	ee17 2a10 	vmov	r2, s14
	samp_thresh = 1.0f - knobs[0];
   1f864:	f646 175c 	movw	r7, #26972	; 0x695c
   1f868:	ee35 6ac6 	vsub.f32	s12, s11, s12
   1f86c:	ed91 7ab1 	vldr	s14, [r1, #708]	; 0x2c4
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f870:	eb03 0282 	add.w	r2, r3, r2, lsl #2
	displayValues[0] = samp_thresh;
   1f874:	f64e 332c 	movw	r3, #60204	; 0xeb2c
   1f878:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	samp_thresh = 1.0f - knobs[0];
   1f87c:	f2c0 270e 	movt	r7, #526	; 0x20e
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f880:	edd2 8a00 	vldr	s17, [r2]
   1f884:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
   1f888:	ee29 9a26 	vmul.f32	s18, s18, s13
	displayValues[0] = samp_thresh;
   1f88c:	f2c0 230f 	movt	r3, #527	; 0x20f
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f890:	ee68 0aa0 	vmul.f32	s1, s17, s1
	if (pitchQuantization)
   1f894:	6832      	ldr	r2, [r6, #0]
   1f896:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
	displayValues[0] = samp_thresh;
   1f89a:	ed83 6a00 	vstr	s12, [r3]
	samp_thresh = 1.0f - knobs[0];
   1f89e:	ed87 6a00 	vstr	s12, [r7]
   1f8a2:	ee37 7a64 	vsub.f32	s14, s14, s9
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1f8a6:	eefd 8ae0 	vcvt.s32.f32	s17, s1
	displayValues[1] = window_size;
   1f8aa:	eef8 6ae8 	vcvt.f32.s32	s13, s17
   1f8ae:	edc3 6a01 	vstr	s13, [r3, #4]
	if (pitchQuantization)
   1f8b2:	b3c2      	cbz	r2, 1f926 <SFXSamplerAutoTick+0x166>
		rate = roundf((knobs[2] - 0.5f) * 14.0f);
   1f8b4:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1f8b8:	2200      	movs	r2, #0
   1f8ba:	ee06 2a90 	vmov	s13, r2
		rate = roundf((knobs[2] - 0.5f) * 14.0f);
   1f8be:	ee27 7a06 	vmul.f32	s14, s14, s12
   1f8c2:	feb8 7a47 	vrinta.f32	s14, s14
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1f8c6:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
   1f8ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f8ce:	f100 81f3 	bmi.w	1fcb8 <SFXSamplerAutoTick+0x4f8>
		else rate += 1.0f;
   1f8d2:	ee77 9a25 	vadd.f32	s19, s14, s11
	crossfadeLength = knobs[3] * 1000.0f;
   1f8d6:	f646 08cc 	movw	r8, #26828	; 0x68cc
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f8da:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
	displayValues[3] = crossfadeLength;
   1f8de:	ed83 5a03 	vstr	s10, [r3, #12]
	crossfadeLength = knobs[3] * 1000.0f;
   1f8e2:	f2c0 280e 	movt	r8, #526	; 0x20e
	displayValues[2] = rate;
   1f8e6:	edc3 9a02 	vstr	s19, [r3, #8]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f8ea:	eeb4 9ac7 	vcmpe.f32	s18, s14
	crossfadeLength = knobs[3] * 1000.0f;
   1f8ee:	edc8 7a00 	vstr	s15, [r8]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f8f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f8f6:	f100 81f9 	bmi.w	1fcec <SFXSamplerAutoTick+0x52c>
	displayValues[5] = randLengthAmount;
   1f8fa:	ed83 9a05 	vstr	s18, [r3, #20]
		randRateAmount = roundf(knobs[6] * 8.0f);
   1f8fe:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
   1f902:	ed91 8ab5 	vldr	s16, [r1, #724]	; 0x2d4
   1f906:	ee28 8a07 	vmul.f32	s16, s16, s14
   1f90a:	feb8 8a48 	vrinta.f32	s16, s16
   1f90e:	e03c      	b.n	1f98a <SFXSamplerAutoTick+0x1ca>
		currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
   1f910:	f2c0 240e 	movt	r4, #526	; 0x20e
   1f914:	ed95 0a01 	vldr	s0, [r5, #4]
   1f918:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f91c:	f007 fe94 	bl	27648 <tEnvelopeFollower_tick>
   1f920:	ed84 0a00 	vstr	s0, [r4]
   1f924:	e769      	b.n	1f7fa <SFXSamplerAutoTick+0x3a>
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f926:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
	crossfadeLength = knobs[3] * 1000.0f;
   1f92a:	f646 08cc 	movw	r8, #26828	; 0x68cc
		rate = (knobs[2] - 0.5f) * 4.0f;
   1f92e:	eef1 9a00 	vmov.f32	s19, #16	; 0x40800000  4.0
	displayValues[3] = crossfadeLength;
   1f932:	ed83 5a03 	vstr	s10, [r3, #12]
	crossfadeLength = knobs[3] * 1000.0f;
   1f936:	f2c0 280e 	movt	r8, #526	; 0x20e
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f93a:	eeb4 9ae6 	vcmpe.f32	s18, s13
		rate = (knobs[2] - 0.5f) * 4.0f;
   1f93e:	ee67 9a29 	vmul.f32	s19, s14, s19
	crossfadeLength = knobs[3] * 1000.0f;
   1f942:	edc8 7a00 	vstr	s15, [r8]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f946:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	displayValues[2] = rate;
   1f94a:	edc3 9a02 	vstr	s19, [r3, #8]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1f94e:	f100 8116 	bmi.w	1fb7e <SFXSamplerAutoTick+0x3be>
	displayValues[5] = randLengthAmount;
   1f952:	ed83 9a05 	vstr	s18, [r3, #20]
		randRateAmount = knobs[6] * 2.0f;
   1f956:	ed91 8ab5 	vldr	s16, [r1, #724]	; 0x2d4
		if (randRateAmount < 0.01) randRateAmount = 0.0f;
   1f95a:	f241 4a7b 	movw	sl, #5243	; 0x147b
   1f95e:	f647 2be1 	movw	fp, #31457	; 0x7ae1
   1f962:	2200      	movs	r2, #0
		randRateAmount = knobs[6] * 2.0f;
   1f964:	ee38 8a08 	vadd.f32	s16, s16, s16
		if (randRateAmount < 0.01) randRateAmount = 0.0f;
   1f968:	f2c4 7aae 	movt	sl, #18350	; 0x47ae
   1f96c:	f6c3 7b84 	movt	fp, #16260	; 0x3f84
   1f970:	ee07 2a10 	vmov	s14, r2
   1f974:	eeb7 5ac8 	vcvt.f64.f32	d5, s16
   1f978:	ec4b ab16 	vmov	d6, sl, fp
   1f97c:	eeb4 5b46 	vcmp.f64	d5, d6
   1f980:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f984:	bf48      	it	mi
   1f986:	eeb0 8a47 	vmovmi.f32	s16, s14
	tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
   1f98a:	f64d 3010 	movw	r0, #56080	; 0xdb10
   1f98e:	ee17 1a90 	vmov	r1, s15
	displayValues[6] = randRateAmount;
   1f992:	ed83 8a06 	vstr	s16, [r3, #24]
	if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1f996:	f646 1a50 	movw	sl, #26960	; 0x6950
	tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
   1f99a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f99e:	f00f fe01 	bl	2f5a4 <tSampler_setCrossfadeLength>
	tSampler_setCrossfadeLength(&asSampler[1], crossfadeLength);
   1f9a2:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1f9a6:	f8d8 1000 	ldr.w	r1, [r8]
   1f9aa:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f9ae:	f00f fdf9 	bl	2f5a4 <tSampler_setCrossfadeLength>
	if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1f9b2:	ed94 7a00 	vldr	s14, [r4]
   1f9b6:	edd7 7a00 	vldr	s15, [r7]
   1f9ba:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1f9be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1f9c2:	f300 80e1 	bgt.w	1fb88 <SFXSamplerAutoTick+0x3c8>
   1f9c6:	f646 1170 	movw	r1, #26992	; 0x6970
   1f9ca:	f646 1b54 	movw	fp, #26964	; 0x6954
   1f9ce:	f646 1858 	movw	r8, #26968	; 0x6958
   1f9d2:	f246 2740 	movw	r7, #25152	; 0x6240
   1f9d6:	f64d 3210 	movw	r2, #56080	; 0xdb10
   1f9da:	f2c0 2a0e 	movt	sl, #526	; 0x20e
   1f9de:	f2c0 210e 	movt	r1, #526	; 0x20e
   1f9e2:	f2c0 2b0e 	movt	fp, #526	; 0x20e
   1f9e6:	f2c0 280e 	movt	r8, #526	; 0x20e
   1f9ea:	f2c0 0706 	movt	r7, #6
   1f9ee:	f2c0 220f 	movt	r2, #527	; 0x20f
	tBuffer_tick(&asBuff[0], input[1]);
   1f9f2:	f64d 00a0 	movw	r0, #55456	; 0xd8a0
   1f9f6:	ed95 0a01 	vldr	s0, [r5, #4]
   1f9fa:	f2c0 200f 	movt	r0, #527	; 0x20f
   1f9fe:	e9cd 1200 	strd	r1, r2, [sp]
   1fa02:	f00f fcdf 	bl	2f3c4 <tBuffer_tick>
	tBuffer_tick(&asBuff[1], input[1]);
   1fa06:	f64d 00a4 	movw	r0, #55460	; 0xd8a4
   1fa0a:	ed95 0a01 	vldr	s0, [r5, #4]
   1fa0e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fa12:	f00f fcd7 	bl	2f3c4 <tBuffer_tick>
	if (sample_countdown > 0)
   1fa16:	9900      	ldr	r1, [sp, #0]
   1fa18:	9a01      	ldr	r2, [sp, #4]
   1fa1a:	680b      	ldr	r3, [r1, #0]
   1fa1c:	2b00      	cmp	r3, #0
   1fa1e:	f000 80e2 	beq.w	1fbe6 <SFXSamplerAutoTick+0x426>
		sample_countdown--;
   1fa22:	3b01      	subs	r3, #1
   1fa24:	600b      	str	r3, [r1, #0]
	if (pitchQuantization)
   1fa26:	6833      	ldr	r3, [r6, #0]
		tSampler_setRate(&asSampler[0], rate * randRateVal);
   1fa28:	f64d 3010 	movw	r0, #56080	; 0xdb10
   1fa2c:	ed98 0a00 	vldr	s0, [r8]
	if (pitchQuantization)
   1fa30:	2b00      	cmp	r3, #0
   1fa32:	f000 80c7 	beq.w	1fbc4 <SFXSamplerAutoTick+0x404>
		tSampler_setRate(&asSampler[0], rate * randRateVal);
   1fa36:	ee29 0a80 	vmul.f32	s0, s19, s0
   1fa3a:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fa3e:	f010 fb29 	bl	30094 <tSampler_setRate>
		tSampler_setRate(&asSampler[1], rate * randRateVal);
   1fa42:	ed98 0a00 	vldr	s0, [r8]
   1fa46:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1fa4a:	ee29 0a80 	vmul.f32	s0, s19, s0
   1fa4e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fa52:	f010 fb1f 	bl	30094 <tSampler_setRate>
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fa56:	f8db 3000 	ldr.w	r3, [fp]
   1fa5a:	ee18 1a90 	vmov	r1, s17
   1fa5e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   1fa62:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1fa66:	4419      	add	r1, r3
	if (buttonActionsSFX[ButtonA][ActionPress])
   1fa68:	f64e 267c 	movw	r6, #60028	; 0xea7c
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fa6c:	f6c4 023b 	movt	r2, #18491	; 0x483b
   1fa70:	ee00 1a90 	vmov	s1, r1
	if (buttonActionsSFX[ButtonA][ActionPress])
   1fa74:	f2c0 260f 	movt	r6, #527	; 0x20f
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fa78:	ee01 2a10 	vmov	s2, r2
   1fa7c:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   1fa80:	f00d f9ae 	bl	2cde0 <LEAF_clip>
   1fa84:	eefd 7ac0 	vcvt.s32.f32	s15, s0
	tSampler_setEnd(&asSampler[0], finalWindowSize);
   1fa88:	f64d 3010 	movw	r0, #56080	; 0xdb10
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fa8c:	ee17 1a90 	vmov	r1, s15
	tSampler_setEnd(&asSampler[0], finalWindowSize);
   1fa90:	f2c0 200f 	movt	r0, #527	; 0x20f
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fa94:	edc7 7a00 	vstr	s15, [r7]
	tSampler_setEnd(&asSampler[0], finalWindowSize);
   1fa98:	f00f feb4 	bl	2f804 <tSampler_setEnd>
	tSampler_setEnd(&asSampler[1], finalWindowSize);
   1fa9c:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1faa0:	6839      	ldr	r1, [r7, #0]
   1faa2:	f2c0 200f 	movt	r0, #527	; 0x20f
   1faa6:	f00f fead 	bl	2f804 <tSampler_setEnd>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1faaa:	7d33      	ldrb	r3, [r6, #20]
   1faac:	b16b      	cbz	r3, 1faca <SFXSamplerAutoTick+0x30a>
		if (samplerMode == PlayLoop)
   1faae:	f246 27a9 	movw	r7, #25257	; 0x62a9
   1fab2:	f2c0 0706 	movt	r7, #6
   1fab6:	f897 8000 	ldrb.w	r8, [r7]
   1faba:	f1b8 0f01 	cmp.w	r8, #1
   1fabe:	f000 8119 	beq.w	1fcf4 <SFXSamplerAutoTick+0x534>
		else if (samplerMode == PlayBackAndForth)
   1fac2:	f1b8 0f02 	cmp.w	r8, #2
   1fac6:	f000 812b 	beq.w	1fd20 <SFXSamplerAutoTick+0x560>
	if (buttonActionsSFX[ButtonB][ActionPress])
   1faca:	7e33      	ldrb	r3, [r6, #24]
   1facc:	2b00      	cmp	r3, #0
   1face:	f040 80c1 	bne.w	1fc54 <SFXSamplerAutoTick+0x494>
	float fade = tExpSmooth_tick(&cfxSmooth);
   1fad2:	f24d 56f8 	movw	r6, #54776	; 0xd5f8
   1fad6:	f2c0 260f 	movt	r6, #527	; 0x20f
   1fada:	4630      	mov	r0, r6
   1fadc:	f00b fc76 	bl	2b3cc <tExpSmooth_tick>
	if (fabsf(cfxSmooth->curr - cfxSmooth->dest) < 0.00001f)
   1fae0:	6832      	ldr	r2, [r6, #0]
   1fae2:	f24c 53ac 	movw	r3, #50604	; 0xc5ac
   1fae6:	edd2 7a03 	vldr	s15, [r2, #12]
   1faea:	edd2 6a04 	vldr	s13, [r2, #16]
   1faee:	f2c3 7327 	movt	r3, #14119	; 0x3727
   1faf2:	ee77 7ae6 	vsub.f32	s15, s15, s13
   1faf6:	ee07 3a10 	vmov	s14, r3
   1fafa:	eef0 7ae7 	vabs.f32	s15, s15
   1fafe:	eef4 7ac7 	vcmpe.f32	s15, s14
   1fb02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1fb06:	d505      	bpl.n	1fb14 <SFXSamplerAutoTick+0x354>
		fadeDone = 1;
   1fb08:	f646 03ec 	movw	r3, #26860	; 0x68ec
   1fb0c:	2201      	movs	r2, #1
   1fb0e:	f2c0 230e 	movt	r3, #526	; 0x20e
   1fb12:	601a      	str	r2, [r3, #0]
	LEAF_crossfade((fade * 2.0f) - 1.0f, volumes);
   1fb14:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   1fb18:	a804      	add	r0, sp, #16
   1fb1a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1fb1e:	eee0 7a07 	vfma.f32	s15, s0, s14
   1fb22:	eeb0 0a67 	vmov.f32	s0, s15
   1fb26:	f00d f8cb 	bl	2ccc0 <LEAF_crossfade>
	sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1fb2a:	f64d 3010 	movw	r0, #56080	; 0xdb10
   1fb2e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fb32:	f00f fefd 	bl	2f930 <tSampler_tick>
   1fb36:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1fb3a:	eef0 8a40 	vmov.f32	s17, s0
   1fb3e:	ed9d 8a05 	vldr	s16, [sp, #20]
   1fb42:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fb46:	f00f fef3 	bl	2f930 <tSampler_tick>
   1fb4a:	eddd 7a04 	vldr	s15, [sp, #16]
	input[0] = sample * 0.99f;
   1fb4e:	f247 03a4 	movw	r3, #28836	; 0x70a4
	previousPower = currentPower;
   1fb52:	6822      	ldr	r2, [r4, #0]
	sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1fb54:	ee20 0a27 	vmul.f32	s0, s0, s15
	input[0] = sample * 0.99f;
   1fb58:	f6c3 737d 	movt	r3, #16253	; 0x3f7d
	previousPower = currentPower;
   1fb5c:	f8ca 2000 	str.w	r2, [sl]
	sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1fb60:	eea8 0a88 	vfma.f32	s0, s17, s16
	input[0] = sample * 0.99f;
   1fb64:	ee07 3a90 	vmov	s15, r3
   1fb68:	ee20 0a27 	vmul.f32	s0, s0, s15
   1fb6c:	ed85 0a00 	vstr	s0, [r5]
	input[1] = sample * 0.99f;
   1fb70:	ed85 0a01 	vstr	s0, [r5, #4]
}
   1fb74:	b007      	add	sp, #28
   1fb76:	ecbd 8b06 	vpop	{d8-d10}
   1fb7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	displayValues[5] = randLengthAmount;
   1fb7e:	2200      	movs	r2, #0
   1fb80:	ee09 2a10 	vmov	s18, r2
   1fb84:	615a      	str	r2, [r3, #20]
   1fb86:	e6e6      	b.n	1f956 <SFXSamplerAutoTick+0x196>
	if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1fb88:	f241 236f 	movw	r3, #4719	; 0x126f
   1fb8c:	f2c0 2a0e 	movt	sl, #526	; 0x20e
   1fb90:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   1fb94:	ed9a 7a00 	vldr	s14, [sl]
   1fb98:	edd4 6a00 	vldr	s13, [r4]
   1fb9c:	ee07 3a90 	vmov	s15, r3
   1fba0:	ee77 7a27 	vadd.f32	s15, s14, s15
   1fba4:	eef4 7ae6 	vcmpe.f32	s15, s13
   1fba8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1fbac:	d45f      	bmi.n	1fc6e <SFXSamplerAutoTick+0x4ae>
   1fbae:	f646 1170 	movw	r1, #26992	; 0x6970
   1fbb2:	f646 1b54 	movw	fp, #26964	; 0x6954
   1fbb6:	f646 1858 	movw	r8, #26968	; 0x6958
   1fbba:	f246 2740 	movw	r7, #25152	; 0x6240
   1fbbe:	f64d 3210 	movw	r2, #56080	; 0xdb10
   1fbc2:	e70c      	b.n	1f9de <SFXSamplerAutoTick+0x21e>
		tSampler_setRate(&asSampler[0], rate + randRateVal);
   1fbc4:	ee39 0a80 	vadd.f32	s0, s19, s0
   1fbc8:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fbcc:	f010 fa62 	bl	30094 <tSampler_setRate>
		tSampler_setRate(&asSampler[1], rate + randRateVal);
   1fbd0:	ed98 0a00 	vldr	s0, [r8]
   1fbd4:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1fbd8:	ee39 0a80 	vadd.f32	s0, s19, s0
   1fbdc:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fbe0:	f010 fa58 	bl	30094 <tSampler_setRate>
   1fbe4:	e737      	b.n	1fa56 <SFXSamplerAutoTick+0x296>
	else if (samp_triggered == 1)
   1fbe6:	f646 1160 	movw	r1, #26976	; 0x6960
   1fbea:	f2c0 210e 	movt	r1, #526	; 0x20e
   1fbee:	6808      	ldr	r0, [r1, #0]
   1fbf0:	2801      	cmp	r0, #1
   1fbf2:	f47f af18 	bne.w	1fa26 <SFXSamplerAutoTick+0x266>
		setLED_1(0);
   1fbf6:	4618      	mov	r0, r3
   1fbf8:	9301      	str	r3, [sp, #4]
   1fbfa:	e9cd 1202 	strd	r1, r2, [sp, #8]
		currentSampler = !currentSampler;
   1fbfe:	f646 02dc 	movw	r2, #26844	; 0x68dc
   1fc02:	9200      	str	r2, [sp, #0]
		setLED_1(0);
   1fc04:	f7fb fa76 	bl	1b0f4 <setLED_1>
		currentSampler = !currentSampler;
   1fc08:	9b00      	ldr	r3, [sp, #0]
		tSampler_play(&asSampler[currentSampler]);
   1fc0a:	9a03      	ldr	r2, [sp, #12]
		currentSampler = !currentSampler;
   1fc0c:	f2c0 230e 	movt	r3, #526	; 0x20e
   1fc10:	f893 c000 	ldrb.w	ip, [r3]
   1fc14:	9300      	str	r3, [sp, #0]
   1fc16:	fabc fc8c 	clz	ip, ip
   1fc1a:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
		tSampler_play(&asSampler[currentSampler]);
   1fc1e:	eb02 008c 	add.w	r0, r2, ip, lsl #2
		currentSampler = !currentSampler;
   1fc22:	f883 c000 	strb.w	ip, [r3]
		tSampler_play(&asSampler[currentSampler]);
   1fc26:	f00f fcd1 	bl	2f5cc <tSampler_play>
		tExpSmooth_setDest(&cfxSmooth,(float)currentSampler);
   1fc2a:	9b00      	ldr	r3, [sp, #0]
   1fc2c:	f24d 50f8 	movw	r0, #54776	; 0xd5f8
   1fc30:	781b      	ldrb	r3, [r3, #0]
   1fc32:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fc36:	ee00 3a10 	vmov	s0, r3
   1fc3a:	eeb8 0a40 	vcvt.f32.u32	s0, s0
   1fc3e:	f00b fbbb 	bl	2b3b8 <tExpSmooth_setDest>
		fadeDone = 0;
   1fc42:	f646 02ec 	movw	r2, #26860	; 0x68ec
		samp_triggered = 0;
   1fc46:	e9dd 3101 	ldrd	r3, r1, [sp, #4]
		fadeDone = 0;
   1fc4a:	f2c0 220e 	movt	r2, #526	; 0x20e
		samp_triggered = 0;
   1fc4e:	600b      	str	r3, [r1, #0]
		fadeDone = 0;
   1fc50:	6013      	str	r3, [r2, #0]
   1fc52:	e6e8      	b.n	1fa26 <SFXSamplerAutoTick+0x266>
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1fc54:	f899 3000 	ldrb.w	r3, [r9]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1fc58:	2200      	movs	r2, #0
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1fc5a:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1fc5e:	7632      	strb	r2, [r6, #24]
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1fc60:	095b      	lsrs	r3, r3, #5
		setLED_B(triggerChannel);
   1fc62:	4618      	mov	r0, r3
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1fc64:	f889 3000 	strb.w	r3, [r9]
		setLED_B(triggerChannel);
   1fc68:	f7fb fa74 	bl	1b154 <setLED_B>
   1fc6c:	e731      	b.n	1fad2 <SFXSamplerAutoTick+0x312>
	if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1fc6e:	f646 1360 	movw	r3, #26976	; 0x6960
   1fc72:	f646 1170 	movw	r1, #26992	; 0x6970
   1fc76:	f2c0 230e 	movt	r3, #526	; 0x20e
   1fc7a:	681a      	ldr	r2, [r3, #0]
   1fc7c:	2a00      	cmp	r2, #0
   1fc7e:	d198      	bne.n	1fbb2 <SFXSamplerAutoTick+0x3f2>
   1fc80:	f2c0 210e 	movt	r1, #526	; 0x20e
   1fc84:	680a      	ldr	r2, [r1, #0]
   1fc86:	b932      	cbnz	r2, 1fc96 <SFXSamplerAutoTick+0x4d6>
   1fc88:	f646 02ec 	movw	r2, #26860	; 0x68ec
   1fc8c:	f2c0 220e 	movt	r2, #526	; 0x20e
   1fc90:	6812      	ldr	r2, [r2, #0]
   1fc92:	2a01      	cmp	r2, #1
   1fc94:	d05a      	beq.n	1fd4c <SFXSamplerAutoTick+0x58c>
   1fc96:	f646 1b54 	movw	fp, #26964	; 0x6954
   1fc9a:	f646 1858 	movw	r8, #26968	; 0x6958
   1fc9e:	f246 2740 	movw	r7, #25152	; 0x6240
   1fca2:	f64d 3210 	movw	r2, #56080	; 0xdb10
   1fca6:	f2c0 2b0e 	movt	fp, #526	; 0x20e
   1fcaa:	f2c0 280e 	movt	r8, #526	; 0x20e
   1fcae:	f2c0 0706 	movt	r7, #6
   1fcb2:	f2c0 220f 	movt	r2, #527	; 0x20f
   1fcb6:	e69c      	b.n	1f9f2 <SFXSamplerAutoTick+0x232>
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1fcb8:	ee37 7a65 	vsub.f32	s14, s14, s11
	crossfadeLength = knobs[3] * 1000.0f;
   1fcbc:	f646 08cc 	movw	r8, #26828	; 0x68cc
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1fcc0:	eeb3 6a04 	vmov.f32	s12, #52	; 0x41a00000  20.0
	displayValues[3] = crossfadeLength;
   1fcc4:	ed83 5a03 	vstr	s10, [r3, #12]
	crossfadeLength = knobs[3] * 1000.0f;
   1fcc8:	f2c0 280e 	movt	r8, #526	; 0x20e
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1fccc:	eeb0 7ac7 	vabs.f32	s14, s14
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1fcd0:	eeb4 9a46 	vcmp.f32	s18, s12
	crossfadeLength = knobs[3] * 1000.0f;
   1fcd4:	edc8 7a00 	vstr	s15, [r8]
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1fcd8:	eec5 9a87 	vdiv.f32	s19, s11, s14
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1fcdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1fce0:	bf48      	it	mi
   1fce2:	eeb0 9a66 	vmovmi.f32	s18, s13
	displayValues[2] = rate;
   1fce6:	edc3 9a02 	vstr	s19, [r3, #8]
   1fcea:	e606      	b.n	1f8fa <SFXSamplerAutoTick+0x13a>
	displayValues[5] = randLengthAmount;
   1fcec:	615a      	str	r2, [r3, #20]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1fcee:	ee09 2a10 	vmov	s18, r2
   1fcf2:	e604      	b.n	1f8fe <SFXSamplerAutoTick+0x13e>
			tSampler_setMode(&asSampler[0], PlayBackAndForth);
   1fcf4:	f64d 3010 	movw	r0, #56080	; 0xdb10
   1fcf8:	2102      	movs	r1, #2
   1fcfa:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fcfe:	f00f fc4d 	bl	2f59c <tSampler_setMode>
			tSampler_setMode(&asSampler[1], PlayBackAndForth);
   1fd02:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1fd06:	2102      	movs	r1, #2
   1fd08:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fd0c:	f00f fc46 	bl	2f59c <tSampler_setMode>
			samplerMode = PlayBackAndForth;
   1fd10:	2302      	movs	r3, #2
			setLED_A(1);
   1fd12:	4640      	mov	r0, r8
			samplerMode = PlayBackAndForth;
   1fd14:	703b      	strb	r3, [r7, #0]
			setLED_A(1);
   1fd16:	f7fb fa0d 	bl	1b134 <setLED_A>
			buttonActionsSFX[ButtonA][ActionPress] = 0;
   1fd1a:	2300      	movs	r3, #0
   1fd1c:	7533      	strb	r3, [r6, #20]
   1fd1e:	e6d4      	b.n	1faca <SFXSamplerAutoTick+0x30a>
			tSampler_setMode(&asSampler[0], PlayLoop);
   1fd20:	f64d 3010 	movw	r0, #56080	; 0xdb10
   1fd24:	2101      	movs	r1, #1
   1fd26:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fd2a:	f00f fc37 	bl	2f59c <tSampler_setMode>
			tSampler_setMode(&asSampler[1], PlayLoop);
   1fd2e:	f64d 3014 	movw	r0, #56084	; 0xdb14
   1fd32:	2101      	movs	r1, #1
   1fd34:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fd38:	f00f fc30 	bl	2f59c <tSampler_setMode>
			samplerMode = PlayLoop;
   1fd3c:	2301      	movs	r3, #1
			setLED_A(0);
   1fd3e:	2000      	movs	r0, #0
			samplerMode = PlayLoop;
   1fd40:	703b      	strb	r3, [r7, #0]
			setLED_A(0);
   1fd42:	f7fb f9f7 	bl	1b134 <setLED_A>
			buttonActionsSFX[ButtonA][ActionPress] = 0;
   1fd46:	2300      	movs	r3, #0
   1fd48:	7533      	strb	r3, [r6, #20]
   1fd4a:	e6be      	b.n	1faca <SFXSamplerAutoTick+0x30a>
		randLengthVal = (randomNumber() - 0.5f) * randLengthAmount * 2.0f;
   1fd4c:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
   1fd50:	f646 1b54 	movw	fp, #26964	; 0x6954
   1fd54:	ee39 9a09 	vadd.f32	s18, s18, s18
   1fd58:	f2c0 2b0e 	movt	fp, #526	; 0x20e
   1fd5c:	e9cd 1300 	strd	r1, r3, [sp]
   1fd60:	f7fb f906 	bl	1af70 <randomNumber>
   1fd64:	ee70 7a4a 	vsub.f32	s15, s0, s20
		if (pitchQuantization) randRateVal = roundf(randomNumber() * randRateAmount) + 1.0f;
   1fd68:	6832      	ldr	r2, [r6, #0]
		randLengthVal = (randomNumber() - 0.5f) * randLengthAmount * 2.0f;
   1fd6a:	ee67 7a89 	vmul.f32	s15, s15, s18
		if (pitchQuantization) randRateVal = roundf(randomNumber() * randRateAmount) + 1.0f;
   1fd6e:	e9dd 1300 	ldrd	r1, r3, [sp]
		randLengthVal = (randomNumber() - 0.5f) * randLengthAmount * 2.0f;
   1fd72:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1fd76:	edcb 7a00 	vstr	s15, [fp]
		if (pitchQuantization) randRateVal = roundf(randomNumber() * randRateAmount) + 1.0f;
   1fd7a:	2a00      	cmp	r2, #0
   1fd7c:	d05c      	beq.n	1fe38 <SFXSamplerAutoTick+0x678>
   1fd7e:	f7fb f8f7 	bl	1af70 <randomNumber>
   1fd82:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1fd86:	ee60 7a08 	vmul.f32	s15, s0, s16
   1fd8a:	f646 1858 	movw	r8, #26968	; 0x6958
   1fd8e:	e9dd 1300 	ldrd	r1, r3, [sp]
   1fd92:	fef8 7a67 	vrinta.f32	s15, s15
   1fd96:	ee77 7a87 	vadd.f32	s15, s15, s14
   1fd9a:	f2c0 280e 	movt	r8, #526	; 0x20e
   1fd9e:	edc8 7a00 	vstr	s15, [r8]
		tSampler_stop(&asSampler[!currentSampler]);
   1fda2:	f646 02dc 	movw	r2, #26844	; 0x68dc
		samp_triggered = 1;
   1fda6:	2001      	movs	r0, #1
   1fda8:	9102      	str	r1, [sp, #8]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdaa:	f246 2740 	movw	r7, #25152	; 0x6240
		tSampler_stop(&asSampler[!currentSampler]);
   1fdae:	9200      	str	r2, [sp, #0]
   1fdb0:	f64d 3210 	movw	r2, #56080	; 0xdb10
		samp_triggered = 1;
   1fdb4:	6018      	str	r0, [r3, #0]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdb6:	f2c0 0706 	movt	r7, #6
		tSampler_stop(&asSampler[!currentSampler]);
   1fdba:	9201      	str	r2, [sp, #4]
		setLED_1(1);
   1fdbc:	f7fb f99a 	bl	1b0f4 <setLED_1>
		tSampler_stop(&asSampler[!currentSampler]);
   1fdc0:	9a00      	ldr	r2, [sp, #0]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdc2:	ee18 1a90 	vmov	r1, s17
   1fdc6:	f8db 3000 	ldr.w	r3, [fp]
   1fdca:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		tSampler_stop(&asSampler[!currentSampler]);
   1fdce:	f2c0 220e 	movt	r2, #526	; 0x20e
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdd2:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1fdd6:	4419      	add	r1, r3
   1fdd8:	f6c4 003b 	movt	r0, #18491	; 0x483b
		tSampler_stop(&asSampler[!currentSampler]);
   1fddc:	9200      	str	r2, [sp, #0]
   1fdde:	9a01      	ldr	r2, [sp, #4]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fde0:	ee00 1a90 	vmov	s1, r1
   1fde4:	ee01 0a10 	vmov	s2, r0
		tSampler_stop(&asSampler[!currentSampler]);
   1fde8:	f2c0 220f 	movt	r2, #527	; 0x20f
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdec:	eef8 0ae0 	vcvt.f32.s32	s1, s1
		tSampler_stop(&asSampler[!currentSampler]);
   1fdf0:	9201      	str	r2, [sp, #4]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdf2:	f00c fff5 	bl	2cde0 <LEAF_clip>
		tSampler_stop(&asSampler[!currentSampler]);
   1fdf6:	9b00      	ldr	r3, [sp, #0]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fdf8:	eefd 7ac0 	vcvt.s32.f32	s15, s0
		tSampler_stop(&asSampler[!currentSampler]);
   1fdfc:	9a01      	ldr	r2, [sp, #4]
   1fdfe:	7818      	ldrb	r0, [r3, #0]
		sample_countdown = finalWindowSize;
   1fe00:	9902      	ldr	r1, [sp, #8]
		tSampler_stop(&asSampler[!currentSampler]);
   1fe02:	fab0 f080 	clz	r0, r0
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1fe06:	edc7 7a00 	vstr	s15, [r7]
		sample_countdown = finalWindowSize;
   1fe0a:	edc1 7a00 	vstr	s15, [r1]
		tSampler_stop(&asSampler[!currentSampler]);
   1fe0e:	0940      	lsrs	r0, r0, #5
   1fe10:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   1fe14:	f00f fc28 	bl	2f668 <tSampler_stop>
		tBuffer_record(&asBuff[!currentSampler]);
   1fe18:	9b00      	ldr	r3, [sp, #0]
   1fe1a:	f64d 00a0 	movw	r0, #55456	; 0xd8a0
   1fe1e:	781b      	ldrb	r3, [r3, #0]
   1fe20:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fe24:	fab3 f383 	clz	r3, r3
   1fe28:	095b      	lsrs	r3, r3, #5
   1fe2a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   1fe2e:	f00f faf7 	bl	2f420 <tBuffer_record>
   1fe32:	e9dd 2101 	ldrd	r2, r1, [sp, #4]
   1fe36:	e5dc      	b.n	1f9f2 <SFXSamplerAutoTick+0x232>
   1fe38:	e9cd 1300 	strd	r1, r3, [sp]
		else randRateVal = (randomNumber() - 0.5f) * randRateAmount * 2.0f;
   1fe3c:	ee38 8a08 	vadd.f32	s16, s16, s16
   1fe40:	f7fb f896 	bl	1af70 <randomNumber>
   1fe44:	ee30 0a4a 	vsub.f32	s0, s0, s20
   1fe48:	f646 1858 	movw	r8, #26968	; 0x6958
   1fe4c:	f2c0 280e 	movt	r8, #526	; 0x20e
   1fe50:	ee20 8a08 	vmul.f32	s16, s0, s16
   1fe54:	e9dd 1300 	ldrd	r1, r3, [sp]
   1fe58:	ed88 8a00 	vstr	s16, [r8]
   1fe5c:	e7a1      	b.n	1fda2 <SFXSamplerAutoTick+0x5e2>
   1fe5e:	bf00      	nop

0001fe60 <SFXSamplerAutoFree>:
{
   1fe60:	b538      	push	{r3, r4, r5, lr}
	tBuffer_free(&asBuff[0]);
   1fe62:	f64d 05a0 	movw	r5, #55456	; 0xd8a0
	tSampler_free(&asSampler[0]);
   1fe66:	f64d 3410 	movw	r4, #56080	; 0xdb10
	tBuffer_free(&asBuff[0]);
   1fe6a:	f2c0 250f 	movt	r5, #527	; 0x20f
	tSampler_free(&asSampler[0]);
   1fe6e:	f2c0 240f 	movt	r4, #527	; 0x20f
	tBuffer_free(&asBuff[0]);
   1fe72:	4628      	mov	r0, r5
   1fe74:	f00f fa9a 	bl	2f3ac <tBuffer_free>
	tBuffer_free(&asBuff[1]);
   1fe78:	1d28      	adds	r0, r5, #4
   1fe7a:	f00f fa97 	bl	2f3ac <tBuffer_free>
	tSampler_free(&asSampler[0]);
   1fe7e:	4620      	mov	r0, r4
   1fe80:	f00f fb80 	bl	2f584 <tSampler_free>
	tSampler_free(&asSampler[1]);
   1fe84:	1d20      	adds	r0, r4, #4
   1fe86:	f00f fb7d 	bl	2f584 <tSampler_free>
	tEnvelopeFollower_free(&envfollow);
   1fe8a:	f24e 7000 	movw	r0, #59136	; 0xe700
   1fe8e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fe92:	f007 fbd5 	bl	27640 <tEnvelopeFollower_free>
	tExpSmooth_free(&cfxSmooth);
   1fe96:	f24d 50f8 	movw	r0, #54776	; 0xd5f8
}
   1fe9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	tExpSmooth_free(&cfxSmooth);
   1fe9e:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fea2:	f00b ba73 	b.w	2b38c <tExpSmooth_free>
   1fea6:	bf00      	nop

0001fea8 <SFXDistortionAlloc>:
{
   1fea8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1feac:	f64a 6690 	movw	r6, #44688	; 0xae90
   1feb0:	f246 2538 	movw	r5, #25144	; 0x6238
	leaf.clearOnAllocation = 1;
   1feb4:	f64f 0408 	movw	r4, #63496	; 0xf808
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1feb8:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
   1febc:	f2c0 260f 	movt	r6, #527	; 0x20f
   1fec0:	f2c0 0506 	movt	r5, #6
	leaf.clearOnAllocation = 1;
   1fec4:	f2c0 240f 	movt	r4, #527	; 0x20f
   1fec8:	2701      	movs	r7, #1
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1feca:	4633      	mov	r3, r6
   1fecc:	6829      	ldr	r1, [r5, #0]
   1fece:	f2c0 200f 	movt	r0, #527	; 0x20f
   1fed2:	2200      	movs	r2, #0
	leaf.clearOnAllocation = 1;
   1fed4:	6167      	str	r7, [r4, #20]
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1fed6:	f64d 099c 	movw	r9, #55452	; 0xd89c
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1feda:	f008 fbdb 	bl	28694 <tOversampler_initToPool>
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1fede:	2300      	movs	r3, #0
   1fee0:	f2c0 290f 	movt	r9, #527	; 0x20f
   1fee4:	4632      	mov	r2, r6
   1fee6:	f2c4 23a0 	movt	r3, #17056	; 0x42a0
   1feea:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1feee:	4648      	mov	r0, r9
   1fef0:	2106      	movs	r1, #6
   1fef2:	ee00 3a10 	vmov	s0, r3
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1fef6:	f24d 78c4 	movw	r8, #55236	; 0xd7c4
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1fefa:	f00b fdbf 	bl	2ba7c <tVZFilter_initToPool>
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1fefe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   1ff02:	f2c0 280f 	movt	r8, #527	; 0x20f
   1ff06:	4632      	mov	r2, r6
   1ff08:	f2c4 633b 	movt	r3, #17979	; 0x463b
   1ff0c:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1ff10:	4640      	mov	r0, r8
   1ff12:	2107      	movs	r1, #7
   1ff14:	ee00 3a10 	vmov	s0, r3
	tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
   1ff18:	f24d 67dc 	movw	r7, #55004	; 0xd6dc
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1ff1c:	f00b fdae 	bl	2ba7c <tVZFilter_initToPool>
	tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
   1ff20:	f243 3133 	movw	r1, #13107	; 0x3333
   1ff24:	2300      	movs	r3, #0
   1ff26:	f2c0 270f 	movt	r7, #527	; 0x20f
   1ff2a:	f6c3 71f3 	movt	r1, #16371	; 0x3ff3
   1ff2e:	4632      	mov	r2, r6
   1ff30:	f2c4 437a 	movt	r3, #17530	; 0x447a
   1ff34:	4638      	mov	r0, r7
   1ff36:	ee00 1a90 	vmov	s1, r1
   1ff3a:	2105      	movs	r1, #5
   1ff3c:	ee00 3a10 	vmov	s0, r3
   1ff40:	f00b fd9c 	bl	2ba7c <tVZFilter_initToPool>
	tVZFilter_setSampleRate(&shelf1, leaf.sampleRate * distOS_ratio);
   1ff44:	edd5 7a00 	vldr	s15, [r5]
   1ff48:	ed94 0a00 	vldr	s0, [r4]
   1ff4c:	4648      	mov	r0, r9
   1ff4e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ff52:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ff56:	f00b ff9b 	bl	2be90 <tVZFilter_setSampleRate>
	tVZFilter_setSampleRate(&shelf2, leaf.sampleRate * distOS_ratio);
   1ff5a:	edd5 7a00 	vldr	s15, [r5]
   1ff5e:	ed94 0a00 	vldr	s0, [r4]
   1ff62:	4640      	mov	r0, r8
   1ff64:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ff68:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ff6c:	f00b ff90 	bl	2be90 <tVZFilter_setSampleRate>
	tVZFilter_setSampleRate(&bell1, leaf.sampleRate * distOS_ratio);
   1ff70:	ed95 0a00 	vldr	s0, [r5]
   1ff74:	edd4 7a00 	vldr	s15, [r4]
   1ff78:	4638      	mov	r0, r7
   1ff7a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   1ff7e:	ee20 0a27 	vmul.f32	s0, s0, s15
   1ff82:	f00b ff85 	bl	2be90 <tVZFilter_setSampleRate>
	setLED_A(distortionMode);
   1ff86:	f646 03e4 	movw	r3, #26852	; 0x68e4
   1ff8a:	f2c0 230e 	movt	r3, #526	; 0x20e
   1ff8e:	7818      	ldrb	r0, [r3, #0]
   1ff90:	f7fb f8d0 	bl	1b134 <setLED_A>
	leaf.clearOnAllocation = 0;
   1ff94:	2300      	movs	r3, #0
   1ff96:	6163      	str	r3, [r4, #20]
}
   1ff98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001ff9c <SFXDistortionFrame>:
	if (buttonActionsSFX[ButtonA][ActionPress])
   1ff9c:	f64e 237c 	movw	r3, #60028	; 0xea7c
   1ffa0:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   1ffa4:	b510      	push	{r4, lr}
	if (buttonActionsSFX[ButtonA][ActionPress])
   1ffa6:	7d1a      	ldrb	r2, [r3, #20]
   1ffa8:	b16a      	cbz	r2, 1ffc6 <SFXDistortionFrame+0x2a>
		distortionMode = !distortionMode;
   1ffaa:	f646 02e4 	movw	r2, #26852	; 0x68e4
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ffae:	2100      	movs	r1, #0
		distortionMode = !distortionMode;
   1ffb0:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ffb4:	7519      	strb	r1, [r3, #20]
		distortionMode = !distortionMode;
   1ffb6:	7813      	ldrb	r3, [r2, #0]
   1ffb8:	fab3 f383 	clz	r3, r3
   1ffbc:	095b      	lsrs	r3, r3, #5
		setLED_A(distortionMode);
   1ffbe:	4618      	mov	r0, r3
		distortionMode = !distortionMode;
   1ffc0:	7013      	strb	r3, [r2, #0]
		setLED_A(distortionMode);
   1ffc2:	f7fb f8b7 	bl	1b134 <setLED_A>
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1ffc6:	2000      	movs	r0, #0
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1ffc8:	f64c 2378 	movw	r3, #51832	; 0xca78
   1ffcc:	eef3 5a0e 	vmov.f32	s11, #62	; 0x41f00000  30.0
   1ffd0:	f64e 342c 	movw	r4, #60204	; 0xeb2c
   1ffd4:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1ffd8:	4601      	mov	r1, r0
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1ffda:	f2c4 2008 	movt	r0, #16904	; 0x4208
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1ffde:	eefa 6a0e 	vmov.f32	s13, #174	; 0xc1700000 -15.0
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1ffe2:	eebb 7a01 	vmov.f32	s14, #177	; 0xc1880000 -17.0
   1ffe6:	ed93 6aca 	vldr	s12, [r3, #808]	; 0x328
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1ffea:	ed93 5ac9 	vldr	s10, [r3, #804]	; 0x324
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1ffee:	ee07 0a90 	vmov	s15, r0
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1fff2:	460a      	mov	r2, r1
   1fff4:	f2c4 219a 	movt	r1, #17050	; 0x429a
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1fff8:	eea6 7a27 	vfma.f32	s14, s12, s15
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1fffc:	ed93 6acb 	vldr	s12, [r3, #812]	; 0x32c
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   20000:	eee5 6a25 	vfma.f32	s13, s10, s11
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   20004:	f2c4 2228 	movt	r2, #16936	; 0x4228
   20008:	ee07 1a90 	vmov	s15, r1
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   2000c:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   20010:	ee00 2a10 	vmov	s0, r2
   20014:	eea6 0a27 	vfma.f32	s0, s12, s15
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   20018:	ed84 7a02 	vstr	s14, [r4, #8]
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   2001c:	edc4 6a01 	vstr	s13, [r4, #4]
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   20020:	f00d f858 	bl	2d0d4 <faster_mtof>
	tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
   20024:	edd4 7a01 	vldr	s15, [r4, #4]
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   20028:	ed84 0a03 	vstr	s0, [r4, #12]
	tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
   2002c:	eeb1 0a67 	vneg.f32	s0, s15
   20030:	f00d f8a8 	bl	2d184 <fastdbtoa>
   20034:	f64d 009c 	movw	r0, #55452	; 0xd89c
   20038:	f2c0 200f 	movt	r0, #527	; 0x20f
   2003c:	f00c fb98 	bl	2c770 <tVZFilter_setGain>
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[1]));
   20040:	ed94 0a01 	vldr	s0, [r4, #4]
   20044:	f00d f89e 	bl	2d184 <fastdbtoa>
   20048:	f24d 70c4 	movw	r0, #55236	; 0xd7c4
   2004c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20050:	f00c fb8e 	bl	2c770 <tVZFilter_setGain>
	tVZFilter_setFreq(&bell1, displayValues[3]);
   20054:	f24d 60dc 	movw	r0, #55004	; 0xd6dc
   20058:	ed94 0a03 	vldr	s0, [r4, #12]
   2005c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20060:	f00b ff90 	bl	2bf84 <tVZFilter_setFreq>
	tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
   20064:	ed94 0a02 	vldr	s0, [r4, #8]
   20068:	f00d f88c 	bl	2d184 <fastdbtoa>
   2006c:	f24d 60dc 	movw	r0, #55004	; 0xd6dc
}
   20070:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
   20074:	f2c0 200f 	movt	r0, #527	; 0x20f
   20078:	f00c bb7a 	b.w	2c770 <tVZFilter_setGain>

0002007c <SFXDistortionTick>:
{
   2007c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   20080:	f64c 2678 	movw	r6, #51832	; 0xca78
   20084:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
   20088:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2008c:	f64e 332c 	movw	r3, #60204	; 0xeb2c
   20090:	f2c0 260f 	movt	r6, #527	; 0x20f
	for (int i = 0; i < distOS_ratio; i++)
   20094:	f246 2738 	movw	r7, #25144	; 0x6238
{
   20098:	4683      	mov	fp, r0
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   2009a:	f24d 6108 	movw	r1, #54792	; 0xd608
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   2009e:	edd6 6ac8 	vldr	s13, [r6, #800]	; 0x320
   200a2:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
   200a6:	f8d6 2330 	ldr.w	r2, [r6, #816]	; 0x330
	for (int i = 0; i < distOS_ratio; i++)
   200aa:	f2c0 0706 	movt	r7, #6
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   200ae:	eee6 7a87 	vfma.f32	s15, s13, s14
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   200b2:	f2c0 210f 	movt	r1, #527	; 0x20f
{
   200b6:	ed2d 8b02 	vpush	{d8}
	float sample = input[1];
   200ba:	ed90 0a01 	vldr	s0, [r0, #4]
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   200be:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
	displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
   200c2:	611a      	str	r2, [r3, #16]
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   200c4:	f2c0 200f 	movt	r0, #527	; 0x20f
   200c8:	ee27 0a80 	vmul.f32	s0, s15, s0
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   200cc:	edc3 7a00 	vstr	s15, [r3]
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   200d0:	f008 fbda 	bl	28888 <tOversampler_upsample>
	for (int i = 0; i < distOS_ratio; i++)
   200d4:	683b      	ldr	r3, [r7, #0]
   200d6:	2b00      	cmp	r3, #0
   200d8:	dd3d      	ble.n	20156 <SFXDistortionTick+0xda>
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   200da:	f243 3333 	movw	r3, #13107	; 0x3333
   200de:	f24d 6408 	movw	r4, #54792	; 0xd608
   200e2:	f646 0ae4 	movw	sl, #26852	; 0x68e4
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   200e6:	f64d 099c 	movw	r9, #55452	; 0xd89c
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   200ea:	f6c3 7373 	movt	r3, #16243	; 0x3f73
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   200ee:	f24d 78c4 	movw	r8, #55236	; 0xd7c4
   200f2:	f2c0 240f 	movt	r4, #527	; 0x20f
   200f6:	f2c0 2a0e 	movt	sl, #526	; 0x20e
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   200fa:	ee08 3a10 	vmov	s16, r3
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   200fe:	f2c0 290f 	movt	r9, #527	; 0x20f
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   20102:	f2c0 280f 	movt	r8, #527	; 0x20f
	for (int i = 0; i < distOS_ratio; i++)
   20106:	2500      	movs	r5, #0
		if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
   20108:	f89a 3000 	ldrb.w	r3, [sl]
   2010c:	ecb4 0a01 	vldmia	r4!, {s0}
   20110:	bb9b      	cbnz	r3, 2017a <SFXDistortionTick+0xfe>
		else oversamplerArray[i] = tanhf(oversamplerArray[i]);
   20112:	f010 fc8b 	bl	30a2c <tanhf>
   20116:	ed04 0a01 	vstr	s0, [r4, #-4]
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   2011a:	4648      	mov	r0, r9
	for (int i = 0; i < distOS_ratio; i++)
   2011c:	3501      	adds	r5, #1
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   2011e:	f00b fec1 	bl	2bea4 <tVZFilter_tick>
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   20122:	4640      	mov	r0, r8
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   20124:	ed04 0a01 	vstr	s0, [r4, #-4]
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   20128:	f00b febc 	bl	2bea4 <tVZFilter_tick>
		oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
   2012c:	f24d 60dc 	movw	r0, #55004	; 0xd6dc
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   20130:	ed04 0a01 	vstr	s0, [r4, #-4]
		oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
   20134:	f2c0 200f 	movt	r0, #527	; 0x20f
   20138:	f00b feb4 	bl	2bea4 <tVZFilter_tick>
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   2013c:	edd6 7acc 	vldr	s15, [r6, #816]	; 0x330
   20140:	ee20 0a27 	vmul.f32	s0, s0, s15
   20144:	f010 fc72 	bl	30a2c <tanhf>
	for (int i = 0; i < distOS_ratio; i++)
   20148:	683b      	ldr	r3, [r7, #0]
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   2014a:	ee20 0a08 	vmul.f32	s0, s0, s16
	for (int i = 0; i < distOS_ratio; i++)
   2014e:	42ab      	cmp	r3, r5
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   20150:	ed04 0a01 	vstr	s0, [r4, #-4]
	for (int i = 0; i < distOS_ratio; i++)
   20154:	dcd8      	bgt.n	20108 <SFXDistortionTick+0x8c>
	sample = tOversampler_downsample(&oversampler, oversamplerArray);
   20156:	f24d 6108 	movw	r1, #54792	; 0xd608
   2015a:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
   2015e:	f2c0 210f 	movt	r1, #527	; 0x20f
   20162:	f2c0 200f 	movt	r0, #527	; 0x20f
   20166:	f008 fbd9 	bl	2891c <tOversampler_downsample>
	input[0] = sample;
   2016a:	ed8b 0a00 	vstr	s0, [fp]
	input[1] = sample;
   2016e:	ed8b 0a01 	vstr	s0, [fp, #4]
}
   20172:	ecbd 8b02 	vpop	{d8}
   20176:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
   2017a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   2017e:	f00c fdcd 	bl	2cd1c <LEAF_shaper>
   20182:	ed04 0a01 	vstr	s0, [r4, #-4]
   20186:	e7c8      	b.n	2011a <SFXDistortionTick+0x9e>

00020188 <SFXDistortionFree>:
	tOversampler_free(&oversampler);
   20188:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
{
   2018c:	b508      	push	{r3, lr}
	tOversampler_free(&oversampler);
   2018e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20192:	f008 fad5 	bl	28740 <tOversampler_free>
	tVZFilter_free(&shelf1);
   20196:	f64d 009c 	movw	r0, #55452	; 0xd89c
   2019a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2019e:	f00b fe73 	bl	2be88 <tVZFilter_free>
	tVZFilter_free(&shelf2);
   201a2:	f24d 70c4 	movw	r0, #55236	; 0xd7c4
   201a6:	f2c0 200f 	movt	r0, #527	; 0x20f
   201aa:	f00b fe6d 	bl	2be88 <tVZFilter_free>
	tVZFilter_free(&bell1);
   201ae:	f24d 60dc 	movw	r0, #55004	; 0xd6dc
}
   201b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tVZFilter_free(&bell1);
   201b6:	f2c0 200f 	movt	r0, #527	; 0x20f
   201ba:	f00b be65 	b.w	2be88 <tVZFilter_free>
   201be:	bf00      	nop

000201c0 <SFXWaveFolderAlloc>:
{
   201c0:	b538      	push	{r3, r4, r5, lr}
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   201c2:	f64a 6490 	movw	r4, #44688	; 0xae90
	leaf.clearOnAllocation = 1;
   201c6:	f64f 0508 	movw	r5, #63496	; 0xf808
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   201ca:	f24c 40b8 	movw	r0, #50360	; 0xc4b8
	leaf.clearOnAllocation = 1;
   201ce:	2301      	movs	r3, #1
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   201d0:	f2c0 240f 	movt	r4, #527	; 0x20f
	leaf.clearOnAllocation = 1;
   201d4:	f2c0 250f 	movt	r5, #527	; 0x20f
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   201d8:	f2c0 200f 	movt	r0, #527	; 0x20f
   201dc:	4621      	mov	r1, r4
	leaf.clearOnAllocation = 1;
   201de:	616b      	str	r3, [r5, #20]
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   201e0:	f008 fbd2 	bl	28988 <tLockhartWavefolder_initToPool>
	tLockhartWavefolder_initToPool(&wavefolder2, &smallPool);
   201e4:	f24d 70c0 	movw	r0, #55232	; 0xd7c0
   201e8:	4621      	mov	r1, r4
   201ea:	f2c0 200f 	movt	r0, #527	; 0x20f
   201ee:	f008 fbcb 	bl	28988 <tLockhartWavefolder_initToPool>
	tHighpass_initToPool(&wfHP, 10.0f, &smallPool);
   201f2:	f24d 6004 	movw	r0, #54788	; 0xd604
   201f6:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   201fa:	4621      	mov	r1, r4
   201fc:	f2c0 200f 	movt	r0, #527	; 0x20f
   20200:	f00b fbf6 	bl	2b9f0 <tHighpass_initToPool>
	tOversampler_initToPool(&oversampler, 2, 0, &smallPool);
   20204:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
   20208:	4623      	mov	r3, r4
   2020a:	2200      	movs	r2, #0
   2020c:	2102      	movs	r1, #2
   2020e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20212:	f008 fa3f 	bl	28694 <tOversampler_initToPool>
	setLED_A(foldMode);
   20216:	f646 03f4 	movw	r3, #26868	; 0x68f4
   2021a:	f2c0 230e 	movt	r3, #526	; 0x20e
   2021e:	7818      	ldrb	r0, [r3, #0]
   20220:	f7fa ff88 	bl	1b134 <setLED_A>
	leaf.clearOnAllocation = 0;
   20224:	2300      	movs	r3, #0
   20226:	616b      	str	r3, [r5, #20]
}
   20228:	bd38      	pop	{r3, r4, r5, pc}
   2022a:	bf00      	nop

0002022c <SFXWaveFolderFrame>:
	if (buttonActionsSFX[ButtonA][ActionPress])
   2022c:	f64e 237c 	movw	r3, #60028	; 0xea7c
   20230:	f2c0 230f 	movt	r3, #527	; 0x20f
   20234:	7d1a      	ldrb	r2, [r3, #20]
   20236:	b902      	cbnz	r2, 2023a <SFXWaveFolderFrame+0xe>
}
   20238:	4770      	bx	lr
		foldMode = !foldMode;
   2023a:	f646 02f4 	movw	r2, #26868	; 0x68f4
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   2023e:	2100      	movs	r1, #0
		foldMode = !foldMode;
   20240:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20244:	7519      	strb	r1, [r3, #20]
		foldMode = !foldMode;
   20246:	6813      	ldr	r3, [r2, #0]
   20248:	fab3 f383 	clz	r3, r3
   2024c:	095b      	lsrs	r3, r3, #5
		setLED_A(foldMode);
   2024e:	4618      	mov	r0, r3
		foldMode = !foldMode;
   20250:	6013      	str	r3, [r2, #0]
		setLED_A(foldMode);
   20252:	f7fa bf6f 	b.w	1b134 <setLED_A>
   20256:	bf00      	nop

00020258 <SFXWaveFolderTick>:
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   20258:	f64c 2378 	movw	r3, #51832	; 0xca78
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   2025c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   20260:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
	if (foldMode == 0)
   20264:	f646 02f4 	movw	r2, #26868	; 0x68f4
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   20268:	f2c0 230f 	movt	r3, #527	; 0x20f
	if (foldMode == 0)
   2026c:	f2c0 220e 	movt	r2, #526	; 0x20e
{
   20270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20274:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   20278:	ed93 0ae1 	vldr	s0, [r3, #900]	; 0x384
   2027c:	f64e 342c 	movw	r4, #60204	; 0xeb2c
	displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   20280:	ed93 7ae3 	vldr	s14, [r3, #908]	; 0x38c
{
   20284:	4606      	mov	r6, r0
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   20286:	edd3 7ae2 	vldr	s15, [r3, #904]	; 0x388
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   2028a:	ee20 0a06 	vmul.f32	s0, s0, s12
	displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   2028e:	ee37 7a66 	vsub.f32	s14, s14, s13
	float sample = input[1];
   20292:	ed90 8a01 	vldr	s16, [r0, #4]
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   20296:	ee77 7ae6 	vsub.f32	s15, s15, s13
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   2029a:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[3] = presetKnobValues[Wavefolder][3];
   2029e:	f8d3 1390 	ldr.w	r1, [r3, #912]	; 0x390
	sample = sample * gain;
   202a2:	ee20 8a08 	vmul.f32	s16, s0, s16
	if (foldMode == 0)
   202a6:	6813      	ldr	r3, [r2, #0]
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   202a8:	ed84 0a00 	vstr	s0, [r4]
	displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   202ac:	ed84 7a02 	vstr	s14, [r4, #8]
	displayValues[3] = presetKnobValues[Wavefolder][3];
   202b0:	60e1      	str	r1, [r4, #12]
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   202b2:	edc4 7a01 	vstr	s15, [r4, #4]
	if (foldMode == 0)
   202b6:	2b00      	cmp	r3, #0
   202b8:	d143      	bne.n	20342 <SFXWaveFolderTick+0xea>
   202ba:	f24d 6508 	movw	r5, #54792	; 0xd608
		tOversampler_upsample(&oversampler, sample, oversamplerArray);
   202be:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   202c2:	f24c 47b8 	movw	r7, #50360	; 0xc4b8
		tOversampler_upsample(&oversampler, sample, oversamplerArray);
   202c6:	eeb0 0a48 	vmov.f32	s0, s16
   202ca:	f2c0 250f 	movt	r5, #527	; 0x20f
   202ce:	f2c0 200f 	movt	r0, #527	; 0x20f
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   202d2:	f2c0 270f 	movt	r7, #527	; 0x20f
		tOversampler_upsample(&oversampler, sample, oversamplerArray);
   202d6:	4629      	mov	r1, r5
   202d8:	f105 0808 	add.w	r8, r5, #8
   202dc:	f008 fad4 	bl	28888 <tOversampler_upsample>
			oversamplerArray[i] = sample + displayValues[1];
   202e0:	edd4 7a01 	vldr	s15, [r4, #4]
			oversamplerArray[i] *= displayValues[0];
   202e4:	ed94 0a00 	vldr	s0, [r4]
			oversamplerArray[i] = sample + displayValues[1];
   202e8:	ee78 7a27 	vadd.f32	s15, s16, s15
			oversamplerArray[i] = tanhf(oversamplerArray[i]);
   202ec:	ee27 0a80 	vmul.f32	s0, s15, s0
   202f0:	f010 fb9c 	bl	30a2c <tanhf>
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   202f4:	4638      	mov	r0, r7
			oversamplerArray[i] = tanhf(oversamplerArray[i]);
   202f6:	ed85 0a00 	vstr	s0, [r5]
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   202fa:	f008 fbf3 	bl	28ae4 <tLockhartWavefolder_tick>
			oversamplerArray[i] = tanhf(oversamplerArray[i]);
   202fe:	f010 fb95 	bl	30a2c <tanhf>
   20302:	eca5 0a01 	vstmia	r5!, {s0}
		for (int i = 0; i < 2; i++)
   20306:	4545      	cmp	r5, r8
   20308:	d1ea      	bne.n	202e0 <SFXWaveFolderTick+0x88>
		sample = tHighpass_tick(&wfHP, tOversampler_downsample(&oversampler, oversamplerArray)) * displayValues[3];
   2030a:	f24d 6108 	movw	r1, #54792	; 0xd608
   2030e:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
   20312:	f2c0 210f 	movt	r1, #527	; 0x20f
   20316:	f2c0 200f 	movt	r0, #527	; 0x20f
   2031a:	f008 faff 	bl	2891c <tOversampler_downsample>
		sample = tHighpass_tick(&wfHP, sample) * displayValues[3];
   2031e:	f24d 6004 	movw	r0, #54788	; 0xd604
   20322:	f2c0 200f 	movt	r0, #527	; 0x20f
   20326:	f00b fb99 	bl	2ba5c <tHighpass_tick>
   2032a:	edd4 7a03 	vldr	s15, [r4, #12]
   2032e:	ee20 0a27 	vmul.f32	s0, s0, s15
		input[0] = sample;
   20332:	ed86 0a00 	vstr	s0, [r6]
		input[1] = sample;
   20336:	ed86 0a01 	vstr	s0, [r6, #4]
}
   2033a:	ecbd 8b02 	vpop	{d8}
   2033e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		sample = sample + displayValues[1];
   20342:	ee77 7a88 	vadd.f32	s15, s15, s16
		sample = LEAF_tanh(sample);
   20346:	ee20 0a27 	vmul.f32	s0, s0, s15
   2034a:	f00c fd99 	bl	2ce80 <LEAF_tanh>
		sample = tLockhartWavefolder_tick(&wavefolder1, sample);
   2034e:	f24c 40b8 	movw	r0, #50360	; 0xc4b8
   20352:	f2c0 200f 	movt	r0, #527	; 0x20f
   20356:	f008 fbc5 	bl	28ae4 <tLockhartWavefolder_tick>
		sample = sample + displayValues[2];
   2035a:	edd4 7a02 	vldr	s15, [r4, #8]
		sample *= displayValues[0];
   2035e:	ed94 7a00 	vldr	s14, [r4]
		sample = sample + displayValues[2];
   20362:	ee30 0a27 	vadd.f32	s0, s0, s15
		sample = LEAF_tanh(sample);
   20366:	ee20 0a07 	vmul.f32	s0, s0, s14
   2036a:	f00c fd89 	bl	2ce80 <LEAF_tanh>
		sample = tLockhartWavefolder_tick(&wavefolder2, sample);
   2036e:	f24d 70c0 	movw	r0, #55232	; 0xd7c0
   20372:	f2c0 200f 	movt	r0, #527	; 0x20f
   20376:	f008 fbb5 	bl	28ae4 <tLockhartWavefolder_tick>
		sample = tOversampler_tick(&oversampler, sample, oversampleBuf, &LEAF_tanh);
   2037a:	f64c 6281 	movw	r2, #52865	; 0xce81
   2037e:	f24e 6194 	movw	r1, #59028	; 0xe694
   20382:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
   20386:	f2c0 0202 	movt	r2, #2
   2038a:	f2c0 210f 	movt	r1, #527	; 0x20f
   2038e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20392:	f008 f9e5 	bl	28760 <tOversampler_tick>
   20396:	e7c2      	b.n	2031e <SFXWaveFolderTick+0xc6>

00020398 <SFXWaveFolderFree>:
	tLockhartWavefolder_free(&wavefolder1);
   20398:	f24c 40b8 	movw	r0, #50360	; 0xc4b8
{
   2039c:	b508      	push	{r3, lr}
	tLockhartWavefolder_free(&wavefolder1);
   2039e:	f2c0 200f 	movt	r0, #527	; 0x20f
   203a2:	f008 fb9b 	bl	28adc <tLockhartWavefolder_free>
	tLockhartWavefolder_free(&wavefolder2);
   203a6:	f24d 70c0 	movw	r0, #55232	; 0xd7c0
   203aa:	f2c0 200f 	movt	r0, #527	; 0x20f
   203ae:	f008 fb95 	bl	28adc <tLockhartWavefolder_free>
	tHighpass_free(&wfHP);
   203b2:	f24d 6004 	movw	r0, #54788	; 0xd604
   203b6:	f2c0 200f 	movt	r0, #527	; 0x20f
   203ba:	f00b fb3b 	bl	2ba34 <tHighpass_free>
	tOversampler_free(&oversampler);
   203be:	f24e 40e4 	movw	r0, #58596	; 0xe4e4
}
   203c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tOversampler_free(&oversampler);
   203c6:	f2c0 200f 	movt	r0, #527	; 0x20f
   203ca:	f008 b9b9 	b.w	28740 <tOversampler_free>
   203ce:	bf00      	nop

000203d0 <SFXBitcrusherAlloc>:
{
   203d0:	b510      	push	{r4, lr}
	tCrusher_initToPool(&crush, &smallPool);
   203d2:	f64a 6490 	movw	r4, #44688	; 0xae90
   203d6:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
   203da:	f2c0 240f 	movt	r4, #527	; 0x20f
   203de:	f2c0 200f 	movt	r0, #527	; 0x20f
   203e2:	4621      	mov	r1, r4
   203e4:	f008 fc96 	bl	28d14 <tCrusher_initToPool>
	tCrusher_initToPool(&crush2, &smallPool);
   203e8:	f24c 7094 	movw	r0, #51092	; 0xc794
   203ec:	4621      	mov	r1, r4
   203ee:	f2c0 200f 	movt	r0, #527	; 0x20f
   203f2:	f008 fc8f 	bl	28d14 <tCrusher_initToPool>
	setLED_A(crusherStereo);
   203f6:	f646 03d0 	movw	r3, #26832	; 0x68d0
   203fa:	f2c0 230e 	movt	r3, #526	; 0x20e
}
   203fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	setLED_A(crusherStereo);
   20402:	7818      	ldrb	r0, [r3, #0]
   20404:	f7fa be96 	b.w	1b134 <setLED_A>

00020408 <SFXBitcrusherFrame>:
	if (buttonActionsSFX[ButtonA][ActionPress])
   20408:	f64e 237c 	movw	r3, #60028	; 0xea7c
   2040c:	f2c0 230f 	movt	r3, #527	; 0x20f
   20410:	7d1a      	ldrb	r2, [r3, #20]
   20412:	b902      	cbnz	r2, 20416 <SFXBitcrusherFrame+0xe>
}
   20414:	4770      	bx	lr
		crusherStereo = !crusherStereo;
   20416:	f646 02d0 	movw	r2, #26832	; 0x68d0
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   2041a:	2100      	movs	r1, #0
		crusherStereo = !crusherStereo;
   2041c:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20420:	7519      	strb	r1, [r3, #20]
		crusherStereo = !crusherStereo;
   20422:	6813      	ldr	r3, [r2, #0]
   20424:	fab3 f383 	clz	r3, r3
   20428:	095b      	lsrs	r3, r3, #5
		setLED_A(crusherStereo);
   2042a:	4618      	mov	r0, r3
		crusherStereo = !crusherStereo;
   2042c:	6013      	str	r3, [r2, #0]
		setLED_A(crusherStereo);
   2042e:	f7fa be81 	b.w	1b134 <setLED_A>
   20432:	bf00      	nop

00020434 <SFXBitcrusherTick>:
{
   20434:	b570      	push	{r4, r5, r6, lr}
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   20436:	f247 02a4 	movw	r2, #28836	; 0x70a4
   2043a:	f64c 2578 	movw	r5, #51832	; 0xca78
   2043e:	f24d 730a 	movw	r3, #55050	; 0xd70a
   20442:	f64e 342c 	movw	r4, #60204	; 0xeb2c
   20446:	f2c0 250f 	movt	r5, #527	; 0x20f
   2044a:	f6c3 727d 	movt	r2, #16253	; 0x3f7d
   2044e:	f6c3 4323 	movt	r3, #15395	; 0x3c23
{
   20452:	4606      	mov	r6, r0
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   20454:	edd5 6afa 	vldr	s13, [r5, #1000]	; 0x3e8
   20458:	ee07 2a10 	vmov	s14, r2
   2045c:	ee07 3a90 	vmov	s15, r3
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   20460:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   20464:	f2c0 240f 	movt	r4, #527	; 0x20f
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   20468:	eeb0 0a66 	vmov.f32	s0, s13
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   2046c:	eee6 7a87 	vfma.f32	s15, s13, s14
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   20470:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   20474:	ed2d 8b02 	vpush	{d8}
	tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   20478:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   2047c:	edc4 7a00 	vstr	s15, [r4]
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   20480:	f008 fcd6 	bl	28e30 <tCrusher_setQuality>
	tCrusher_setQuality (&crush2, presetKnobValues[BitCrusher][0]);
   20484:	f24c 7094 	movw	r0, #51092	; 0xc794
   20488:	ed95 0afa 	vldr	s0, [r5, #1000]	; 0x3e8
   2048c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20490:	f008 fcce 	bl	28e30 <tCrusher_setQuality>
	displayValues[1] = presetKnobValues[BitCrusher][1];
   20494:	edd5 7afb 	vldr	s15, [r5, #1004]	; 0x3ec
	tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   20498:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
   2049c:	ee27 0a88 	vmul.f32	s0, s15, s16
	displayValues[1] = presetKnobValues[BitCrusher][1];
   204a0:	edc4 7a01 	vstr	s15, [r4, #4]
	tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   204a4:	f2c0 200f 	movt	r0, #527	; 0x20f
   204a8:	f008 fcf4 	bl	28e94 <tCrusher_setSamplingRatio>
	tCrusher_setSamplingRatio (&crush2, presetKnobValues[BitCrusher][1] * 0.5f);
   204ac:	ed95 0afb 	vldr	s0, [r5, #1004]	; 0x3ec
   204b0:	f24c 7094 	movw	r0, #51092	; 0xc794
   204b4:	ee20 0a08 	vmul.f32	s0, s0, s16
   204b8:	f2c0 200f 	movt	r0, #527	; 0x20f
   204bc:	f008 fcea 	bl	28e94 <tCrusher_setSamplingRatio>
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   204c0:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   204c4:	edd5 7afc 	vldr	s15, [r5, #1008]	; 0x3f0
	tCrusher_setRound (&crush, displayValues[2]);
   204c8:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   204cc:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
	tCrusher_setRound (&crush, displayValues[2]);
   204d0:	f2c0 200f 	movt	r0, #527	; 0x20f
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   204d4:	ee08 3a10 	vmov	s16, r3
   204d8:	ee67 7a88 	vmul.f32	s15, s15, s16
	tCrusher_setRound (&crush, displayValues[2]);
   204dc:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   204e0:	edc4 7a02 	vstr	s15, [r4, #8]
	tCrusher_setRound (&crush, displayValues[2]);
   204e4:	f008 fcd0 	bl	28e88 <tCrusher_setRound>
	tCrusher_setRound (&crush2, displayValues[2]);
   204e8:	f24c 7094 	movw	r0, #51092	; 0xc794
   204ec:	ed94 0a02 	vldr	s0, [r4, #8]
   204f0:	f2c0 200f 	movt	r0, #527	; 0x20f
   204f4:	f008 fcc8 	bl	28e88 <tCrusher_setRound>
	displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   204f8:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   204fc:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
	tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   20500:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
	displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   20504:	ee60 7a27 	vmul.f32	s15, s0, s15
	tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   20508:	f2c0 200f 	movt	r0, #527	; 0x20f
	displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   2050c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   20510:	eef8 7a67 	vcvt.f32.u32	s15, s15
   20514:	edc4 7a03 	vstr	s15, [r4, #12]
	tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   20518:	f008 fc80 	bl	28e1c <tCrusher_setOperation>
	tCrusher_setOperation (&crush2, presetKnobValues[BitCrusher][3]);
   2051c:	f24c 7094 	movw	r0, #51092	; 0xc794
   20520:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
   20524:	f2c0 200f 	movt	r0, #527	; 0x20f
   20528:	f008 fc78 	bl	28e1c <tCrusher_setOperation>
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   2052c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   20530:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
   20534:	ed95 6aff 	vldr	s12, [r5, #1020]	; 0x3fc
	if (displayValues[0] < 0.1f)
   20538:	edd4 6a00 	vldr	s13, [r4]
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   2053c:	eef0 5a67 	vmov.f32	s11, s15
	displayValues[4] = presetKnobValues[BitCrusher][4];
   20540:	f8d5 33f8 	ldr.w	r3, [r5, #1016]	; 0x3f8
	if (displayValues[0] < 0.1f)
   20544:	eef4 6ac8 	vcmpe.f32	s13, s16
	displayValues[4] = presetKnobValues[BitCrusher][4];
   20548:	6123      	str	r3, [r4, #16]
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   2054a:	eee6 5a07 	vfma.f32	s11, s12, s14
	if (displayValues[0] < 0.1f)
   2054e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   20552:	eeb0 7a65 	vmov.f32	s14, s11
   20556:	edc4 5a05 	vstr	s11, [r4, #20]
	if (displayValues[0] < 0.1f)
   2055a:	d424      	bmi.n	205a6 <SFXBitcrusherTick+0x172>
		volumeComp = (1.0f / (displayValues[3] + 1.0f));
   2055c:	edd4 6a03 	vldr	s13, [r4, #12]
   20560:	ee76 6aa7 	vadd.f32	s13, s13, s15
   20564:	eec7 8aa6 	vdiv.f32	s17, s15, s13
	sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   20568:	ed96 0a01 	vldr	s0, [r6, #4]
   2056c:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
   20570:	f2c0 200f 	movt	r0, #527	; 0x20f
   20574:	ee27 0a00 	vmul.f32	s0, s14, s0
   20578:	f008 fc0e 	bl	28d98 <tCrusher_tick>
   2057c:	f010 fa56 	bl	30a2c <tanhf>
	if (crusherStereo)
   20580:	f646 03d0 	movw	r3, #26832	; 0x68d0
	sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   20584:	ee20 0a28 	vmul.f32	s0, s0, s17
   20588:	ed94 8a04 	vldr	s16, [r4, #16]
	if (crusherStereo)
   2058c:	f2c0 230e 	movt	r3, #526	; 0x20e
   20590:	681b      	ldr	r3, [r3, #0]
	sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   20592:	ee20 8a08 	vmul.f32	s16, s0, s16
	if (crusherStereo)
   20596:	b94b      	cbnz	r3, 205ac <SFXBitcrusherTick+0x178>
		input[1] = sample;
   20598:	ed86 8a01 	vstr	s16, [r6, #4]
	input[0] = sample;
   2059c:	ed86 8a00 	vstr	s16, [r6]
}
   205a0:	ecbd 8b02 	vpop	{d8}
   205a4:	bd70      	pop	{r4, r5, r6, pc}
		volumeComp = 1.0f;
   205a6:	eef0 8a67 	vmov.f32	s17, s15
   205aa:	e7dd      	b.n	20568 <SFXBitcrusherTick+0x134>
		input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
   205ac:	edd4 7a05 	vldr	s15, [r4, #20]
   205b0:	f24c 7094 	movw	r0, #51092	; 0xc794
   205b4:	ed96 0a00 	vldr	s0, [r6]
   205b8:	f2c0 200f 	movt	r0, #527	; 0x20f
   205bc:	ee20 0a27 	vmul.f32	s0, s0, s15
   205c0:	f008 fbea 	bl	28d98 <tCrusher_tick>
   205c4:	f010 fa32 	bl	30a2c <tanhf>
   205c8:	edd4 7a04 	vldr	s15, [r4, #16]
	input[0] = sample;
   205cc:	ed86 8a00 	vstr	s16, [r6]
		input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
   205d0:	ee68 8aa7 	vmul.f32	s17, s17, s15
   205d4:	ee68 8a80 	vmul.f32	s17, s17, s0
   205d8:	edc6 8a01 	vstr	s17, [r6, #4]
}
   205dc:	ecbd 8b02 	vpop	{d8}
   205e0:	bd70      	pop	{r4, r5, r6, pc}
   205e2:	bf00      	nop

000205e4 <SFXBitcrusherFree>:
	tCrusher_free(&crush);
   205e4:	f24d 10c8 	movw	r0, #53704	; 0xd1c8
{
   205e8:	b508      	push	{r3, lr}
	tCrusher_free(&crush);
   205ea:	f2c0 200f 	movt	r0, #527	; 0x20f
   205ee:	f008 fbc7 	bl	28d80 <tCrusher_free>
	tCrusher_free(&crush2);
   205f2:	f24c 7094 	movw	r0, #51092	; 0xc794
}
   205f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tCrusher_free(&crush2);
   205fa:	f2c0 200f 	movt	r0, #527	; 0x20f
   205fe:	f008 bbbf 	b.w	28d80 <tCrusher_free>
   20602:	bf00      	nop

00020604 <SFXDelayAlloc>:
	tTapeDelay_init(&delay, 2000, 30000);
   20604:	2300      	movs	r3, #0
   20606:	f64d 3018 	movw	r0, #56088	; 0xdb18
   2060a:	f247 5130 	movw	r1, #30000	; 0x7530
   2060e:	f2c4 43fa 	movt	r3, #17658	; 0x44fa
   20612:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   20616:	b570      	push	{r4, r5, r6, lr}
	leaf.clearOnAllocation = 1;
   20618:	f64f 0408 	movw	r4, #63496	; 0xf808
   2061c:	2601      	movs	r6, #1
	tTapeDelay_init(&delay, 2000, 30000);
   2061e:	ee00 3a10 	vmov	s0, r3
	delayShaper = 0;
   20622:	2500      	movs	r5, #0
	leaf.clearOnAllocation = 1;
   20624:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   20628:	ed2d 8b02 	vpush	{d8}
	leaf.clearOnAllocation = 1;
   2062c:	6166      	str	r6, [r4, #20]
	tTapeDelay_init(&delay, 2000, 30000);
   2062e:	ee08 3a10 	vmov	s16, r3
   20632:	f007 feef 	bl	28414 <tTapeDelay_init>
	tTapeDelay_init(&delay2, 2000, 30000);
   20636:	f24d 30c0 	movw	r0, #54208	; 0xd3c0
   2063a:	eeb0 0a48 	vmov.f32	s0, s16
   2063e:	f247 5130 	movw	r1, #30000	; 0x7530
   20642:	f2c0 200f 	movt	r0, #527	; 0x20f
   20646:	f007 fee5 	bl	28414 <tTapeDelay_init>
	tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   2064a:	f243 3333 	movw	r3, #13107	; 0x3333
   2064e:	462a      	mov	r2, r5
   20650:	f64d 2034 	movw	r0, #55860	; 0xda34
   20654:	f6c3 7333 	movt	r3, #16179	; 0x3f33
   20658:	4631      	mov	r1, r6
   2065a:	f2c4 627a 	movt	r2, #18042	; 0x467a
   2065e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20662:	ee00 3a90 	vmov	s1, r3
   20666:	ee08 3a10 	vmov	s16, r3
   2066a:	ee00 2a10 	vmov	s0, r2
   2066e:	ee08 2a90 	vmov	s17, r2
   20672:	f00a ffe1 	bl	2b638 <tSVF_init>
	tSVF_init(&delayHP, SVFTypeHighpass, 20.f, .7f);
   20676:	f24d 6078 	movw	r0, #54904	; 0xd678
   2067a:	eef0 0a48 	vmov.f32	s1, s16
   2067e:	4629      	mov	r1, r5
   20680:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   20684:	f2c0 200f 	movt	r0, #527	; 0x20f
   20688:	f00a ffd6 	bl	2b638 <tSVF_init>
	tSVF_init(&delayLP2, SVFTypeLowpass, 16000.f, .7f);
   2068c:	f64d 10ac 	movw	r0, #55724	; 0xd9ac
   20690:	eef0 0a48 	vmov.f32	s1, s16
   20694:	4631      	mov	r1, r6
   20696:	eeb0 0a68 	vmov.f32	s0, s17
   2069a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2069e:	f00a ffcb 	bl	2b638 <tSVF_init>
	tSVF_init(&delayHP2, SVFTypeHighpass, 20.f, .7f);
   206a2:	f64d 00c0 	movw	r0, #55488	; 0xd8c0
   206a6:	eef0 0a48 	vmov.f32	s1, s16
   206aa:	4629      	mov	r1, r5
   206ac:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   206b0:	f2c0 200f 	movt	r0, #527	; 0x20f
   206b4:	f00a ffc0 	bl	2b638 <tSVF_init>
	tHighpass_init(&delayShaperHp, 20.0f);
   206b8:	f64d 00a8 	movw	r0, #55464	; 0xd8a8
   206bc:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   206c0:	f2c0 200f 	movt	r0, #527	; 0x20f
   206c4:	f00b f972 	bl	2b9ac <tHighpass_init>
	tFeedbackLeveler_init(&feedbackControl, .99f, 0.01, 0.125f, 0);
   206c8:	f24d 720a 	movw	r2, #55050	; 0xd70a
   206cc:	f247 03a4 	movw	r3, #28836	; 0x70a4
   206d0:	f24d 60e0 	movw	r0, #55008	; 0xd6e0
   206d4:	f6c3 4223 	movt	r2, #15395	; 0x3c23
   206d8:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
   206dc:	f6c3 737d 	movt	r3, #16253	; 0x3f7d
   206e0:	f2c0 200f 	movt	r0, #527	; 0x20f
   206e4:	ee00 2a90 	vmov	s1, r2
   206e8:	4629      	mov	r1, r5
   206ea:	ee00 3a10 	vmov	s0, r3
   206ee:	f008 fbe7 	bl	28ec0 <tFeedbackLeveler_init>
	capFeedback = 1;
   206f2:	f646 0190 	movw	r1, #26768	; 0x6890
	delayShaper = 0;
   206f6:	f646 02e0 	movw	r2, #26848	; 0x68e0
	freeze = 0;
   206fa:	f646 03f8 	movw	r3, #26872	; 0x68f8
	capFeedback = 1;
   206fe:	f2c0 210e 	movt	r1, #526	; 0x20e
	setLED_A(delayShaper);
   20702:	4628      	mov	r0, r5
	delayShaper = 0;
   20704:	f2c0 220e 	movt	r2, #526	; 0x20e
	freeze = 0;
   20708:	f2c0 230e 	movt	r3, #526	; 0x20e
	capFeedback = 1;
   2070c:	700e      	strb	r6, [r1, #0]
	delayShaper = 0;
   2070e:	6015      	str	r5, [r2, #0]
	freeze = 0;
   20710:	601d      	str	r5, [r3, #0]
	setLED_A(delayShaper);
   20712:	f7fa fd0f 	bl	1b134 <setLED_A>
	leaf.clearOnAllocation = 0;
   20716:	6165      	str	r5, [r4, #20]
}
   20718:	ecbd 8b02 	vpop	{d8}
   2071c:	bd70      	pop	{r4, r5, r6, pc}
   2071e:	bf00      	nop

00020720 <SFXDelayFrame>:
{
   20720:	b510      	push	{r4, lr}
	if (buttonActionsSFX[ButtonA][ActionPress])
   20722:	f64e 247c 	movw	r4, #60028	; 0xea7c
   20726:	f2c0 240f 	movt	r4, #527	; 0x20f
   2072a:	7d23      	ldrb	r3, [r4, #20]
   2072c:	b9fb      	cbnz	r3, 2076e <SFXDelayFrame+0x4e>
	if (buttonActionsSFX[ButtonB][ActionPress])
   2072e:	7e23      	ldrb	r3, [r4, #24]
   20730:	b153      	cbz	r3, 20748 <SFXDelayFrame+0x28>
		capFeedback = !capFeedback;
   20732:	f646 0290 	movw	r2, #26768	; 0x6890
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   20736:	2300      	movs	r3, #0
		capFeedback = !capFeedback;
   20738:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   2073c:	7623      	strb	r3, [r4, #24]
		capFeedback = !capFeedback;
   2073e:	7813      	ldrb	r3, [r2, #0]
   20740:	fab3 f383 	clz	r3, r3
   20744:	095b      	lsrs	r3, r3, #5
   20746:	7013      	strb	r3, [r2, #0]
	if (buttonActionsSFX[ButtonC][ActionPress])
   20748:	7f23      	ldrb	r3, [r4, #28]
   2074a:	b903      	cbnz	r3, 2074e <SFXDelayFrame+0x2e>
}
   2074c:	bd10      	pop	{r4, pc}
		freeze = !freeze;
   2074e:	f646 02f8 	movw	r2, #26872	; 0x68f8
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   20752:	2300      	movs	r3, #0
		freeze = !freeze;
   20754:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   20758:	7723      	strb	r3, [r4, #28]
		freeze = !freeze;
   2075a:	6813      	ldr	r3, [r2, #0]
   2075c:	fab3 f383 	clz	r3, r3
   20760:	095b      	lsrs	r3, r3, #5
   20762:	6013      	str	r3, [r2, #0]
		setLED_C(freeze);
   20764:	4618      	mov	r0, r3
}
   20766:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		setLED_C(freeze);
   2076a:	f7fa bd03 	b.w	1b174 <setLED_C>
		delayShaper = !delayShaper;
   2076e:	f646 02e0 	movw	r2, #26848	; 0x68e0
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20772:	2300      	movs	r3, #0
		delayShaper = !delayShaper;
   20774:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20778:	7523      	strb	r3, [r4, #20]
		delayShaper = !delayShaper;
   2077a:	6813      	ldr	r3, [r2, #0]
   2077c:	fab3 f383 	clz	r3, r3
   20780:	095b      	lsrs	r3, r3, #5
		setLED_A(delayShaper);
   20782:	4618      	mov	r0, r3
		delayShaper = !delayShaper;
   20784:	6013      	str	r3, [r2, #0]
		setLED_A(delayShaper);
   20786:	f7fa fcd5 	bl	1b134 <setLED_A>
   2078a:	e7d0      	b.n	2072e <SFXDelayFrame+0xe>

0002078c <SFXDelayTick>:
{
   2078c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   2078e:	f64c 65c4 	movw	r5, #52932	; 0xcec4
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   20792:	f04f 4286 	mov.w	r2, #1124073472	; 0x43000000
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   20796:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
   2079a:	f64e 342c 	movw	r4, #60204	; 0xeb2c
   2079e:	f2c0 250f 	movt	r5, #527	; 0x20f
{
   207a2:	4607      	mov	r7, r0
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   207a4:	f2c4 63ea 	movt	r3, #18154	; 0x46ea
   207a8:	f2c0 240f 	movt	r4, #527	; 0x20f
   207ac:	4629      	mov	r1, r5
   207ae:	ee07 3a90 	vmov	s15, r3
{
   207b2:	ed2d 8b02 	vpush	{d8}
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   207b6:	eef2 8a04 	vmov.f32	s17, #36	; 0x41200000  10.0
   207ba:	ee08 2a10 	vmov	s16, r2
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   207be:	ecf1 6a01 	vldmia	r1!, {s13}
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   207c2:	ed95 7a02 	vldr	s14, [r5, #8]
   207c6:	eeb0 0a68 	vmov.f32	s0, s17
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   207ca:	ee66 6aa7 	vmul.f32	s13, s13, s15
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   207ce:	eea7 0a08 	vfma.f32	s0, s14, s16
	displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
   207d2:	ed91 7a00 	vldr	s14, [r1]
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   207d6:	edc4 6a00 	vstr	s13, [r4]
	displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
   207da:	ee67 7a27 	vmul.f32	s15, s14, s15
   207de:	edc4 7a01 	vstr	s15, [r4, #4]
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   207e2:	f00c fc77 	bl	2d0d4 <faster_mtof>
   207e6:	ed84 0a02 	vstr	s0, [r4, #8]
	displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
   207ea:	eeb0 0a68 	vmov.f32	s0, s17
   207ee:	edd5 7a03 	vldr	s15, [r5, #12]
   207f2:	eea7 0a88 	vfma.f32	s0, s15, s16
   207f6:	f00c fc6d 	bl	2d0d4 <faster_mtof>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   207fa:	f646 0390 	movw	r3, #26768	; 0x6890
	displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
   207fe:	ed84 0a03 	vstr	s0, [r4, #12]
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   20802:	f2c0 230e 	movt	r3, #526	; 0x20e
   20806:	781b      	ldrb	r3, [r3, #0]
   20808:	2b00      	cmp	r3, #0
   2080a:	f040 8125 	bne.w	20a58 <SFXDelayTick+0x2cc>
   2080e:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   20812:	ed95 7a04 	vldr	s14, [r5, #16]
   20816:	f6c3 738c 	movt	r3, #16268	; 0x3f8c
   2081a:	ee07 3a90 	vmov	s15, r3
   2081e:	ee67 7a27 	vmul.f32	s15, s14, s15
	displayValues[5] = presetKnobValues[Delay][5];
   20822:	f64c 63d8 	movw	r3, #52952	; 0xced8
	tSVF_setFreq(&delayHP, displayValues[2]);
   20826:	f24d 6078 	movw	r0, #54904	; 0xd678
   2082a:	ed94 0a02 	vldr	s0, [r4, #8]
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   2082e:	f64d 06b8 	movw	r6, #55480	; 0xd8b8
	displayValues[5] = presetKnobValues[Delay][5];
   20832:	f2c0 230f 	movt	r3, #527	; 0x20f
	tSVF_setFreq(&delayHP, displayValues[2]);
   20836:	f2c0 200f 	movt	r0, #527	; 0x20f
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   2083a:	edc4 7a04 	vstr	s15, [r4, #16]
	displayValues[5] = presetKnobValues[Delay][5];
   2083e:	681b      	ldr	r3, [r3, #0]
   20840:	6163      	str	r3, [r4, #20]
	tSVF_setFreq(&delayHP, displayValues[2]);
   20842:	f00a ffb3 	bl	2b7ac <tSVF_setFreq>
	tSVF_setFreq(&delayHP2, displayValues[2]);
   20846:	f64d 00c0 	movw	r0, #55488	; 0xd8c0
   2084a:	ed94 0a02 	vldr	s0, [r4, #8]
   2084e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20852:	f00a ffab 	bl	2b7ac <tSVF_setFreq>
	tSVF_setFreq(&delayLP, displayValues[3]);
   20856:	f64d 2034 	movw	r0, #55860	; 0xda34
   2085a:	ed94 0a03 	vldr	s0, [r4, #12]
   2085e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20862:	f00a ffa3 	bl	2b7ac <tSVF_setFreq>
	tSVF_setFreq(&delayLP2, displayValues[3]);
   20866:	f64d 10ac 	movw	r0, #55724	; 0xd9ac
   2086a:	ed94 0a03 	vldr	s0, [r4, #12]
   2086e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20872:	f00a ff9b 	bl	2b7ac <tSVF_setFreq>
	if (delayShaper == 0)
   20876:	f646 03e0 	movw	r3, #26848	; 0x68e0
   2087a:	f2c0 230e 	movt	r3, #526	; 0x20e
   2087e:	681b      	ldr	r3, [r3, #0]
   20880:	2b00      	cmp	r3, #0
   20882:	f040 8095 	bne.w	209b0 <SFXDelayTick+0x224>
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   20886:	f2c0 260f 	movt	r6, #527	; 0x20f
   2088a:	ed94 7a04 	vldr	s14, [r4, #16]
   2088e:	ed97 0a01 	vldr	s0, [r7, #4]
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   20892:	f24e 55cc 	movw	r5, #58828	; 0xe5cc
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   20896:	edd6 7a00 	vldr	s15, [r6]
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   2089a:	f2c0 250f 	movt	r5, #527	; 0x20f
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   2089e:	eea7 0a27 	vfma.f32	s0, s14, s15
   208a2:	f010 f8c3 	bl	30a2c <tanhf>
   208a6:	f24d 60e0 	movw	r0, #55008	; 0xd6e0
   208aa:	f2c0 200f 	movt	r0, #527	; 0x20f
   208ae:	f008 fb6b 	bl	28f88 <tFeedbackLeveler_tick>
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   208b2:	edd5 7a00 	vldr	s15, [r5]
   208b6:	ed94 7a04 	vldr	s14, [r4, #16]
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   208ba:	eef0 8a40 	vmov.f32	s17, s0
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   208be:	ed97 0a01 	vldr	s0, [r7, #4]
   208c2:	eea7 0a27 	vfma.f32	s0, s14, s15
   208c6:	f010 f8b1 	bl	30a2c <tanhf>
   208ca:	f24d 60e0 	movw	r0, #55008	; 0xd6e0
   208ce:	f2c0 200f 	movt	r0, #527	; 0x20f
   208d2:	f008 fb59 	bl	28f88 <tFeedbackLeveler_tick>
   208d6:	eeb0 8a40 	vmov.f32	s16, s0
	tTapeDelay_setDelay(&delay, displayValues[0]);
   208da:	f64d 3018 	movw	r0, #56088	; 0xdb18
   208de:	ed94 0a00 	vldr	s0, [r4]
   208e2:	f2c0 200f 	movt	r0, #527	; 0x20f
   208e6:	f007 fe7b 	bl	285e0 <tTapeDelay_setDelay>
	tTapeDelay_setDelay(&delay2, displayValues[1]);
   208ea:	f24d 30c0 	movw	r0, #54208	; 0xd3c0
   208ee:	ed94 0a01 	vldr	s0, [r4, #4]
   208f2:	f2c0 200f 	movt	r0, #527	; 0x20f
   208f6:	f007 fe73 	bl	285e0 <tTapeDelay_setDelay>
	if (!freeze)
   208fa:	f646 03f8 	movw	r3, #26872	; 0x68f8
		delayFB1 = tTapeDelay_tick(&delay, input1);
   208fe:	f64d 3018 	movw	r0, #56088	; 0xdb18
	if (!freeze)
   20902:	f2c0 230e 	movt	r3, #526	; 0x20e
   20906:	681b      	ldr	r3, [r3, #0]
   20908:	2b00      	cmp	r3, #0
   2090a:	f000 8092 	beq.w	20a32 <SFXDelayTick+0x2a6>
		delayFB1 = tTapeDelay_tick(&delay, delayFB1);
   2090e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20912:	ed96 0a00 	vldr	s0, [r6]
   20916:	f007 fded 	bl	284f4 <tTapeDelay_tick>
		delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
   2091a:	f24d 30c0 	movw	r0, #54208	; 0xd3c0
		delayFB1 = tTapeDelay_tick(&delay, delayFB1);
   2091e:	ed86 0a00 	vstr	s0, [r6]
		delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
   20922:	f2c0 200f 	movt	r0, #527	; 0x20f
   20926:	ed95 0a00 	vldr	s0, [r5]
   2092a:	f007 fde3 	bl	284f4 <tTapeDelay_tick>
   2092e:	ed85 0a00 	vstr	s0, [r5]
	delayFB1 = tSVF_tick(&delayLP, delayFB1);
   20932:	f64d 2034 	movw	r0, #55860	; 0xda34
   20936:	ed96 0a00 	vldr	s0, [r6]
   2093a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2093e:	f00a feff 	bl	2b740 <tSVF_tick>
	delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   20942:	f64d 10ac 	movw	r0, #55724	; 0xd9ac
	delayFB1 = tSVF_tick(&delayLP, delayFB1);
   20946:	ed86 0a00 	vstr	s0, [r6]
	delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   2094a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2094e:	ed95 0a00 	vldr	s0, [r5]
   20952:	f00a fef5 	bl	2b740 <tSVF_tick>
	delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   20956:	f24d 6078 	movw	r0, #54904	; 0xd678
	delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   2095a:	ed85 0a00 	vstr	s0, [r5]
	delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   2095e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20962:	ed96 0a00 	vldr	s0, [r6]
   20966:	f00a feeb 	bl	2b740 <tSVF_tick>
   2096a:	f010 f85f 	bl	30a2c <tanhf>
	delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   2096e:	f64d 00c0 	movw	r0, #55488	; 0xd8c0
	delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   20972:	ed86 0a00 	vstr	s0, [r6]
	delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   20976:	f2c0 200f 	movt	r0, #527	; 0x20f
   2097a:	ed95 0a00 	vldr	s0, [r5]
   2097e:	f00a fedf 	bl	2b740 <tSVF_tick>
   20982:	f010 f853 	bl	30a2c <tanhf>
	input[0] = delayFB1 * displayValues[5];
   20986:	edd4 7a05 	vldr	s15, [r4, #20]
   2098a:	ed96 7a00 	vldr	s14, [r6]
	delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   2098e:	ed85 0a00 	vstr	s0, [r5]
	input[0] = delayFB1 * displayValues[5];
   20992:	ee67 7a87 	vmul.f32	s15, s15, s14
   20996:	edc7 7a00 	vstr	s15, [r7]
	input[1] = delayFB2 * displayValues[5];
   2099a:	edd4 7a05 	vldr	s15, [r4, #20]
   2099e:	ed95 7a00 	vldr	s14, [r5]
   209a2:	ee67 7a87 	vmul.f32	s15, s15, s14
   209a6:	edc7 7a01 	vstr	s15, [r7, #4]
}
   209aa:	ecbd 8b02 	vpop	{d8}
   209ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   209b0:	f2c0 260f 	movt	r6, #527	; 0x20f
   209b4:	edd4 7a04 	vldr	s15, [r4, #16]
   209b8:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
   209bc:	ed97 0a01 	vldr	s0, [r7, #4]
   209c0:	ed96 7a00 	vldr	s14, [r6]
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   209c4:	f24e 55cc 	movw	r5, #58828	; 0xe5cc
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   209c8:	ee67 7a87 	vmul.f32	s15, s15, s14
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   209cc:	f2c0 250f 	movt	r5, #527	; 0x20f
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   209d0:	eef0 0a48 	vmov.f32	s1, s16
   209d4:	eea7 0a88 	vfma.f32	s0, s15, s16
   209d8:	f00c f9a0 	bl	2cd1c <LEAF_shaper>
   209dc:	f64d 00a8 	movw	r0, #55464	; 0xd8a8
   209e0:	f2c0 200f 	movt	r0, #527	; 0x20f
   209e4:	f00b f83a 	bl	2ba5c <tHighpass_tick>
   209e8:	f24d 60e0 	movw	r0, #55008	; 0xd6e0
   209ec:	f2c0 200f 	movt	r0, #527	; 0x20f
   209f0:	f008 faca 	bl	28f88 <tFeedbackLeveler_tick>
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   209f4:	ed95 7a00 	vldr	s14, [r5]
   209f8:	edd4 7a04 	vldr	s15, [r4, #16]
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   209fc:	eef0 8a40 	vmov.f32	s17, s0
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   20a00:	ed97 0a01 	vldr	s0, [r7, #4]
   20a04:	eef0 0a48 	vmov.f32	s1, s16
   20a08:	ee67 7a87 	vmul.f32	s15, s15, s14
   20a0c:	eea7 0a88 	vfma.f32	s0, s15, s16
   20a10:	f00c f984 	bl	2cd1c <LEAF_shaper>
   20a14:	f64d 00a8 	movw	r0, #55464	; 0xd8a8
   20a18:	f2c0 200f 	movt	r0, #527	; 0x20f
   20a1c:	f00b f81e 	bl	2ba5c <tHighpass_tick>
   20a20:	f24d 60e0 	movw	r0, #55008	; 0xd6e0
   20a24:	f2c0 200f 	movt	r0, #527	; 0x20f
   20a28:	f008 faae 	bl	28f88 <tFeedbackLeveler_tick>
   20a2c:	eeb0 8a40 	vmov.f32	s16, s0
   20a30:	e753      	b.n	208da <SFXDelayTick+0x14e>
		delayFB1 = tTapeDelay_tick(&delay, input1);
   20a32:	f2c0 200f 	movt	r0, #527	; 0x20f
   20a36:	eeb0 0a68 	vmov.f32	s0, s17
   20a3a:	f007 fd5b 	bl	284f4 <tTapeDelay_tick>
		delayFB2 = tTapeDelay_tick(&delay2, input2);
   20a3e:	f24d 30c0 	movw	r0, #54208	; 0xd3c0
		delayFB1 = tTapeDelay_tick(&delay, input1);
   20a42:	ed86 0a00 	vstr	s0, [r6]
		delayFB2 = tTapeDelay_tick(&delay2, input2);
   20a46:	eeb0 0a48 	vmov.f32	s0, s16
   20a4a:	f2c0 200f 	movt	r0, #527	; 0x20f
   20a4e:	f007 fd51 	bl	284f4 <tTapeDelay_tick>
   20a52:	ed85 0a00 	vstr	s0, [r5]
   20a56:	e76c      	b.n	20932 <SFXDelayTick+0x1a6>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   20a58:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   20a5c:	f246 6266 	movw	r2, #26214	; 0x6666
   20a60:	edd5 0a04 	vldr	s1, [r5, #16]
   20a64:	2100      	movs	r1, #0
   20a66:	f6c3 738c 	movt	r3, #16268	; 0x3f8c
   20a6a:	f6c3 7266 	movt	r2, #16230	; 0x3f66
   20a6e:	ee00 1a10 	vmov	s0, r1
   20a72:	ee07 3a90 	vmov	s15, r3
   20a76:	ee01 2a10 	vmov	s2, r2
   20a7a:	ee60 0aa7 	vmul.f32	s1, s1, s15
   20a7e:	f00c f9af 	bl	2cde0 <LEAF_clip>
   20a82:	eef0 7a40 	vmov.f32	s15, s0
   20a86:	e6cc      	b.n	20822 <SFXDelayTick+0x96>

00020a88 <SFXDelayFree>:
	tTapeDelay_free(&delay);
   20a88:	f64d 3018 	movw	r0, #56088	; 0xdb18
{
   20a8c:	b508      	push	{r3, lr}
	tTapeDelay_free(&delay);
   20a8e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20a92:	f007 fd23 	bl	284dc <tTapeDelay_free>
	tTapeDelay_free(&delay2);
   20a96:	f24d 30c0 	movw	r0, #54208	; 0xd3c0
   20a9a:	f2c0 200f 	movt	r0, #527	; 0x20f
   20a9e:	f007 fd1d 	bl	284dc <tTapeDelay_free>
	tSVF_free(&delayLP);
   20aa2:	f64d 2034 	movw	r0, #55860	; 0xda34
   20aa6:	f2c0 200f 	movt	r0, #527	; 0x20f
   20aaa:	f00a fe45 	bl	2b738 <tSVF_free>
	tSVF_free(&delayHP);
   20aae:	f24d 6078 	movw	r0, #54904	; 0xd678
   20ab2:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ab6:	f00a fe3f 	bl	2b738 <tSVF_free>
	tSVF_free(&delayLP2);
   20aba:	f64d 10ac 	movw	r0, #55724	; 0xd9ac
   20abe:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ac2:	f00a fe39 	bl	2b738 <tSVF_free>
	tSVF_free(&delayHP2);
   20ac6:	f64d 00c0 	movw	r0, #55488	; 0xd8c0
   20aca:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ace:	f00a fe33 	bl	2b738 <tSVF_free>
	tHighpass_free(&delayShaperHp);
   20ad2:	f64d 00a8 	movw	r0, #55464	; 0xd8a8
   20ad6:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ada:	f00a ffab 	bl	2ba34 <tHighpass_free>
	tFeedbackLeveler_free(&feedbackControl);
   20ade:	f24d 60e0 	movw	r0, #55008	; 0xd6e0
}
   20ae2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tFeedbackLeveler_free(&feedbackControl);
   20ae6:	f2c0 200f 	movt	r0, #527	; 0x20f
   20aea:	f008 ba3d 	b.w	28f68 <tFeedbackLeveler_free>
   20aee:	bf00      	nop

00020af0 <SFXReverbAlloc>:
{
   20af0:	b570      	push	{r4, r5, r6, lr}
	tDattorroReverb_init(&reverb);
   20af2:	f64c 15b0 	movw	r5, #51632	; 0xc9b0
	leaf.clearOnAllocation = 1;
   20af6:	f64f 0408 	movw	r4, #63496	; 0xf808
   20afa:	2601      	movs	r6, #1
	tDattorroReverb_init(&reverb);
   20afc:	f2c0 250f 	movt	r5, #527	; 0x20f
	leaf.clearOnAllocation = 1;
   20b00:	f2c0 240f 	movt	r4, #527	; 0x20f
	tDattorroReverb_init(&reverb);
   20b04:	4628      	mov	r0, r5
	leaf.clearOnAllocation = 1;
   20b06:	6166      	str	r6, [r4, #20]
	tDattorroReverb_init(&reverb);
   20b08:	f00e f8ec 	bl	2ece4 <tDattorroReverb_init>
	tExpSmooth_init(&sizeSmoother, 0.5f, 0.001f);
   20b0c:	f241 236f 	movw	r3, #4719	; 0x126f
   20b10:	f24e 40d8 	movw	r0, #58584	; 0xe4d8
   20b14:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
   20b18:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   20b1c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20b20:	ee00 3a90 	vmov	s1, r3
   20b24:	f00a fbe2 	bl	2b2ec <tExpSmooth_init>
	tDattorroReverb_setMix(&reverb, 1.0f);
   20b28:	4628      	mov	r0, r5
   20b2a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   20b2e:	f00e faff 	bl	2f130 <tDattorroReverb_setMix>
	freeze = 0;
   20b32:	f646 02f8 	movw	r2, #26872	; 0x68f8
	capFeedback = 1;
   20b36:	f646 0390 	movw	r3, #26768	; 0x6890
	freeze = 0;
   20b3a:	2100      	movs	r1, #0
   20b3c:	f2c0 220e 	movt	r2, #526	; 0x20e
	capFeedback = 1;
   20b40:	f2c0 230e 	movt	r3, #526	; 0x20e
	leaf.clearOnAllocation = 0;
   20b44:	6161      	str	r1, [r4, #20]
	freeze = 0;
   20b46:	6011      	str	r1, [r2, #0]
	capFeedback = 1;
   20b48:	701e      	strb	r6, [r3, #0]
}
   20b4a:	bd70      	pop	{r4, r5, r6, pc}

00020b4c <SFXReverbFrame>:
	if (buttonActionsSFX[ButtonB][ActionPress])
   20b4c:	f64e 237c 	movw	r3, #60028	; 0xea7c
   20b50:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   20b54:	b570      	push	{r4, r5, r6, lr}
   20b56:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonB][ActionPress])
   20b5a:	7e1a      	ldrb	r2, [r3, #24]
   20b5c:	b152      	cbz	r2, 20b74 <SFXReverbFrame+0x28>
		capFeedback = !capFeedback;
   20b5e:	f646 0290 	movw	r2, #26768	; 0x6890
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   20b62:	2100      	movs	r1, #0
		capFeedback = !capFeedback;
   20b64:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   20b68:	7619      	strb	r1, [r3, #24]
		capFeedback = !capFeedback;
   20b6a:	7813      	ldrb	r3, [r2, #0]
   20b6c:	fab3 f383 	clz	r3, r3
   20b70:	095b      	lsrs	r3, r3, #5
   20b72:	7013      	strb	r3, [r2, #0]
	displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
   20b74:	f64c 762c 	movw	r6, #53036	; 0xcf2c
   20b78:	2300      	movs	r3, #0
   20b7a:	f64e 342c 	movw	r4, #60204	; 0xeb2c
   20b7e:	f2c0 260f 	movt	r6, #527	; 0x20f
   20b82:	f2c4 3301 	movt	r3, #17153	; 0x4301
   20b86:	f2c0 240f 	movt	r4, #527	; 0x20f
   20b8a:	4635      	mov	r5, r6
   20b8c:	ee08 3a10 	vmov	s16, r3
   20b90:	ecb5 0a01 	vldmia	r5!, {s0}
   20b94:	ee20 0a08 	vmul.f32	s0, s0, s16
   20b98:	f00c fa9c 	bl	2d0d4 <faster_mtof>
	tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
   20b9c:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
	displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
   20ba0:	ed84 0a01 	vstr	s0, [r4, #4]
	tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
   20ba4:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ba8:	f00e fbc6 	bl	2f338 <tDattorroReverb_setFeedbackFilter>
	displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
   20bac:	2300      	movs	r3, #0
   20bae:	ed95 0a00 	vldr	s0, [r5]
   20bb2:	f2c4 23f6 	movt	r3, #17142	; 0x42f6
   20bb6:	ee07 3a90 	vmov	s15, r3
   20bba:	ee20 0a27 	vmul.f32	s0, s0, s15
   20bbe:	f00c fa89 	bl	2d0d4 <faster_mtof>
	tDattorroReverb_setHP(&reverb, displayValues[2]);
   20bc2:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
	displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
   20bc6:	ed84 0a02 	vstr	s0, [r4, #8]
	tDattorroReverb_setHP(&reverb, displayValues[2]);
   20bca:	f2c0 200f 	movt	r0, #527	; 0x20f
   20bce:	f00e fb05 	bl	2f1dc <tDattorroReverb_setHP>
	displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
   20bd2:	ed96 0a02 	vldr	s0, [r6, #8]
   20bd6:	ee20 0a08 	vmul.f32	s0, s0, s16
   20bda:	f00c fa7b 	bl	2d0d4 <faster_mtof>
	tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   20bde:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
	displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
   20be2:	ed84 0a03 	vstr	s0, [r4, #12]
	tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   20be6:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   20bea:	ecbd 8b02 	vpop	{d8}
   20bee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   20bf2:	f00e bb89 	b.w	2f308 <tDattorroReverb_setInputFilter>
   20bf6:	bf00      	nop

00020bf8 <SFXReverbTick>:
	if (buttonActionsSFX[ButtonC][ActionPress])
   20bf8:	f64e 237c 	movw	r3, #60028	; 0xea7c
   20bfc:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   20c00:	b570      	push	{r4, r5, r6, lr}
   20c02:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonC][ActionPress])
   20c06:	7f1a      	ldrb	r2, [r3, #28]
{
   20c08:	b082      	sub	sp, #8
   20c0a:	4604      	mov	r4, r0
	if (buttonActionsSFX[ButtonC][ActionPress])
   20c0c:	2a00      	cmp	r2, #0
   20c0e:	d169      	bne.n	20ce4 <SFXReverbTick+0xec>
	input[1] *= 4.0f;
   20c10:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
   20c14:	ed94 7a01 	vldr	s14, [r4, #4]
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   20c18:	f246 6266 	movw	r2, #26214	; 0x6666
   20c1c:	f64c 43cd 	movw	r3, #52429	; 0xcccd
	displayValues[0] = presetKnobValues[Reverb][0];
   20c20:	f64c 7628 	movw	r6, #53032	; 0xcf28
   20c24:	f64e 352c 	movw	r5, #60204	; 0xeb2c
	input[1] *= 4.0f;
   20c28:	ee27 7a27 	vmul.f32	s14, s14, s15
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   20c2c:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
   20c30:	f6c3 7266 	movt	r2, #16230	; 0x3f66
	displayValues[0] = presetKnobValues[Reverb][0];
   20c34:	f2c0 260f 	movt	r6, #527	; 0x20f
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   20c38:	ee00 3a10 	vmov	s0, r3
   20c3c:	f24e 40d8 	movw	r0, #58584	; 0xe4d8
   20c40:	ee07 2a90 	vmov	s15, r2
	input[1] *= 4.0f;
   20c44:	ed84 7a01 	vstr	s14, [r4, #4]
	displayValues[0] = presetKnobValues[Reverb][0];
   20c48:	ed96 7a00 	vldr	s14, [r6]
   20c4c:	f2c0 250f 	movt	r5, #527	; 0x20f
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   20c50:	f2c0 200f 	movt	r0, #527	; 0x20f
   20c54:	eea7 0a27 	vfma.f32	s0, s14, s15
	displayValues[0] = presetKnobValues[Reverb][0];
   20c58:	ed85 7a00 	vstr	s14, [r5]
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   20c5c:	f00a fbac 	bl	2b3b8 <tExpSmooth_setDest>
	float tempSize = tExpSmooth_tick(&sizeSmoother);
   20c60:	f24e 40d8 	movw	r0, #58584	; 0xe4d8
   20c64:	f2c0 200f 	movt	r0, #527	; 0x20f
   20c68:	f00a fbb0 	bl	2b3cc <tExpSmooth_tick>
	tDattorroReverb_setSize(&reverb, tempSize);
   20c6c:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
   20c70:	f2c0 200f 	movt	r0, #527	; 0x20f
   20c74:	f00e fad2 	bl	2f21c <tDattorroReverb_setSize>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   20c78:	f646 0390 	movw	r3, #26768	; 0x6890
   20c7c:	f2c0 230e 	movt	r3, #526	; 0x20e
   20c80:	781b      	ldrb	r3, [r3, #0]
   20c82:	2b00      	cmp	r3, #0
   20c84:	d144      	bne.n	20d10 <SFXReverbTick+0x118>
   20c86:	edd6 7a04 	vldr	s15, [r6, #16]
	tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
   20c8a:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
   20c8e:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   20c92:	edc5 7a04 	vstr	s15, [r5, #16]
	tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
   20c96:	f2c0 200f 	movt	r0, #527	; 0x20f
   20c9a:	f00e fb6b 	bl	2f374 <tDattorroReverb_setFeedbackGain>
	tDattorroReverb_tickStereo(&reverb, input[1], stereo);
   20c9e:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
   20ca2:	4669      	mov	r1, sp
   20ca4:	ed94 0a01 	vldr	s0, [r4, #4]
   20ca8:	f2c0 200f 	movt	r0, #527	; 0x20f
   20cac:	f00e f878 	bl	2eda0 <tDattorroReverb_tickStereo>
	sample = tanhf(stereo[0]) * 0.99f;
   20cb0:	ed9d 0a00 	vldr	s0, [sp]
   20cb4:	f00f feba 	bl	30a2c <tanhf>
   20cb8:	f247 03a4 	movw	r3, #28836	; 0x70a4
   20cbc:	f6c3 737d 	movt	r3, #16253	; 0x3f7d
   20cc0:	ee08 3a10 	vmov	s16, r3
   20cc4:	ee60 7a08 	vmul.f32	s15, s0, s16
	input[1] = tanhf(stereo[1]) * 0.99f;
   20cc8:	ed9d 0a01 	vldr	s0, [sp, #4]
	input[0] = sample;
   20ccc:	edc4 7a00 	vstr	s15, [r4]
	input[1] = tanhf(stereo[1]) * 0.99f;
   20cd0:	f00f feac 	bl	30a2c <tanhf>
   20cd4:	ee20 0a08 	vmul.f32	s0, s0, s16
   20cd8:	ed84 0a01 	vstr	s0, [r4, #4]
}
   20cdc:	b002      	add	sp, #8
   20cde:	ecbd 8b02 	vpop	{d8}
   20ce2:	bd70      	pop	{r4, r5, r6, pc}
		freeze = !freeze;
   20ce4:	f646 05f8 	movw	r5, #26872	; 0x68f8
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   20ce8:	2200      	movs	r2, #0
		tDattorroReverb_setFreeze(&reverb, freeze);
   20cea:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
		freeze = !freeze;
   20cee:	f2c0 250e 	movt	r5, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   20cf2:	771a      	strb	r2, [r3, #28]
		tDattorroReverb_setFreeze(&reverb, freeze);
   20cf4:	f2c0 200f 	movt	r0, #527	; 0x20f
		freeze = !freeze;
   20cf8:	682b      	ldr	r3, [r5, #0]
   20cfa:	fab3 f383 	clz	r3, r3
   20cfe:	095b      	lsrs	r3, r3, #5
		tDattorroReverb_setFreeze(&reverb, freeze);
   20d00:	4619      	mov	r1, r3
		freeze = !freeze;
   20d02:	602b      	str	r3, [r5, #0]
		tDattorroReverb_setFreeze(&reverb, freeze);
   20d04:	f00e fa22 	bl	2f14c <tDattorroReverb_setFreeze>
		setLED_C(freeze);
   20d08:	7828      	ldrb	r0, [r5, #0]
   20d0a:	f7fa fa33 	bl	1b174 <setLED_C>
   20d0e:	e77f      	b.n	20c10 <SFXReverbTick+0x18>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   20d10:	2300      	movs	r3, #0
   20d12:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
   20d16:	edd6 0a04 	vldr	s1, [r6, #16]
   20d1a:	ee00 3a10 	vmov	s0, r3
   20d1e:	f00c f85f 	bl	2cde0 <LEAF_clip>
   20d22:	eef0 7a40 	vmov.f32	s15, s0
   20d26:	e7b0      	b.n	20c8a <SFXReverbTick+0x92>

00020d28 <SFXReverbFree>:
	tDattorroReverb_free(&reverb);
   20d28:	f64c 10b0 	movw	r0, #51632	; 0xc9b0
{
   20d2c:	b508      	push	{r3, lr}
	tDattorroReverb_free(&reverb);
   20d2e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20d32:	f00d ffdd 	bl	2ecf0 <tDattorroReverb_free>
	tExpSmooth_free(&sizeSmoother);
   20d36:	f24e 40d8 	movw	r0, #58584	; 0xe4d8
}
   20d3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tExpSmooth_free(&sizeSmoother);
   20d3e:	f2c0 200f 	movt	r0, #527	; 0x20f
   20d42:	f00a bb23 	b.w	2b38c <tExpSmooth_free>
   20d46:	bf00      	nop

00020d48 <SFXReverb2Alloc>:
{
   20d48:	b570      	push	{r4, r5, r6, lr}
	tNReverb_init(&reverb2, 1.0f);
   20d4a:	f24e 55d0 	movw	r5, #58832	; 0xe5d0
	leaf.clearOnAllocation = 1;
   20d4e:	f64f 0408 	movw	r4, #63496	; 0xf808
   20d52:	2601      	movs	r6, #1
	tNReverb_init(&reverb2, 1.0f);
   20d54:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   20d58:	f2c0 250f 	movt	r5, #527	; 0x20f
	leaf.clearOnAllocation = 1;
   20d5c:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   20d60:	ed2d 8b04 	vpush	{d8-d9}
	tNReverb_init(&reverb2, 1.0f);
   20d64:	4628      	mov	r0, r5
	leaf.clearOnAllocation = 1;
   20d66:	6166      	str	r6, [r4, #20]
	tNReverb_init(&reverb2, 1.0f);
   20d68:	f00d fcb8 	bl	2e6dc <tNReverb_init>
	tNReverb_setMix(&reverb2, 1.0f);
   20d6c:	4628      	mov	r0, r5
   20d6e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   20d72:	f00d fd1d 	bl	2e7b0 <tNReverb_setMix>
	tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
   20d76:	f44f 4320 	mov.w	r3, #40960	; 0xa000
   20d7a:	f24c 60b0 	movw	r0, #50864	; 0xc6b0
   20d7e:	4631      	mov	r1, r6
   20d80:	f2c4 638c 	movt	r3, #18060	; 0x468c
   20d84:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   20d88:	f2c0 200f 	movt	r0, #527	; 0x20f
   20d8c:	ee00 3a10 	vmov	s0, r3
   20d90:	ee09 3a10 	vmov	s18, r3
   20d94:	f00a fc50 	bl	2b638 <tSVF_init>
	tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
   20d98:	2300      	movs	r3, #0
   20d9a:	f24e 40e0 	movw	r0, #58592	; 0xe4e0
   20d9e:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   20da2:	f2c4 2320 	movt	r3, #16928	; 0x4220
   20da6:	2100      	movs	r1, #0
   20da8:	f2c0 200f 	movt	r0, #527	; 0x20f
   20dac:	ee00 3a10 	vmov	s0, r3
   20db0:	ee08 3a90 	vmov	s17, r3
   20db4:	f00a fc40 	bl	2b638 <tSVF_init>
	tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
   20db8:	2300      	movs	r3, #0
   20dba:	f64d 10a8 	movw	r0, #55720	; 0xd9a8
   20dbe:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   20dc2:	f2c4 43fa 	movt	r3, #17658	; 0x44fa
   20dc6:	2102      	movs	r1, #2
   20dc8:	f2c0 200f 	movt	r0, #527	; 0x20f
   20dcc:	ee00 3a10 	vmov	s0, r3
   20dd0:	ee08 3a10 	vmov	s16, r3
   20dd4:	f00a fc30 	bl	2b638 <tSVF_init>
	tSVF_init(&lowpass2, SVFTypeLowpass, 18000.0f, 0.75f);
   20dd8:	f24d 6000 	movw	r0, #54784	; 0xd600
   20ddc:	eeb0 0a49 	vmov.f32	s0, s18
   20de0:	4631      	mov	r1, r6
   20de2:	f2c0 200f 	movt	r0, #527	; 0x20f
   20de6:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   20dea:	f00a fc25 	bl	2b638 <tSVF_init>
	tSVF_init(&highpass2, SVFTypeHighpass, 40.0f, 0.75f);
   20dee:	f64d 00ac 	movw	r0, #55468	; 0xd8ac
   20df2:	eeb0 0a68 	vmov.f32	s0, s17
   20df6:	2100      	movs	r1, #0
   20df8:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   20dfc:	f2c0 200f 	movt	r0, #527	; 0x20f
   20e00:	f00a fc1a 	bl	2b638 <tSVF_init>
	tSVF_init(&bandpass2, SVFTypeBandpass, 2000.0f, 1.0f);
   20e04:	f64d 1088 	movw	r0, #55688	; 0xd988
   20e08:	eeb0 0a48 	vmov.f32	s0, s16
   20e0c:	2102      	movs	r1, #2
   20e0e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   20e12:	f2c0 200f 	movt	r0, #527	; 0x20f
   20e16:	f00a fc0f 	bl	2b638 <tSVF_init>
	freeze = 0;
   20e1a:	f646 03f8 	movw	r3, #26872	; 0x68f8
   20e1e:	2200      	movs	r2, #0
   20e20:	f2c0 230e 	movt	r3, #526	; 0x20e
	leaf.clearOnAllocation = 0;
   20e24:	6162      	str	r2, [r4, #20]
	freeze = 0;
   20e26:	601a      	str	r2, [r3, #0]
}
   20e28:	ecbd 8b04 	vpop	{d8-d9}
   20e2c:	bd70      	pop	{r4, r5, r6, pc}
   20e2e:	bf00      	nop

00020e30 <SFXReverb2Frame>:
   20e30:	4770      	bx	lr
   20e32:	bf00      	nop

00020e34 <SFXReverb2Tick>:
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   20e34:	f64c 738c 	movw	r3, #53132	; 0xcf8c
   20e38:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
   20e3c:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   20e40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!freeze)
   20e44:	f646 06f8 	movw	r6, #26872	; 0x68f8
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   20e48:	f64e 342c 	movw	r4, #60204	; 0xeb2c
{
   20e4c:	4607      	mov	r7, r0
	if (!freeze)
   20e4e:	f2c0 260e 	movt	r6, #526	; 0x20e
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   20e52:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   20e56:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   20e5a:	ed93 0a00 	vldr	s0, [r3]
{
   20e5e:	b083      	sub	sp, #12
	if (!freeze)
   20e60:	6833      	ldr	r3, [r6, #0]
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   20e62:	ee20 0a27 	vmul.f32	s0, s0, s15
   20e66:	ed84 0a00 	vstr	s0, [r4]
	if (!freeze)
   20e6a:	2b00      	cmp	r3, #0
   20e6c:	f040 80c1 	bne.w	20ff2 <SFXReverb2Tick+0x1be>
		tNReverb_setT60(&reverb2, displayValues[0]);
   20e70:	f24e 50d0 	movw	r0, #58832	; 0xe5d0
   20e74:	f2c0 200f 	movt	r0, #527	; 0x20f
   20e78:	f00d fc52 	bl	2e720 <tNReverb_setT60>
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   20e7c:	f64c 7890 	movw	r8, #53136	; 0xcf90
   20e80:	2300      	movs	r3, #0
	if (buttonActionsSFX[ButtonC][ActionPress])
   20e82:	f64e 257c 	movw	r5, #60028	; 0xea7c
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   20e86:	f2c0 280f 	movt	r8, #527	; 0x20f
   20e8a:	f2c4 3307 	movt	r3, #17159	; 0x4307
	if (buttonActionsSFX[ButtonC][ActionPress])
   20e8e:	f2c0 250f 	movt	r5, #527	; 0x20f
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   20e92:	46c1      	mov	r9, r8
   20e94:	ee07 3a90 	vmov	s15, r3
   20e98:	ecb9 0a01 	vldmia	r9!, {s0}
   20e9c:	ee20 0a27 	vmul.f32	s0, s0, s15
   20ea0:	f00c f918 	bl	2d0d4 <faster_mtof>
	tSVF_setFreq(&lowpass, displayValues[1]);
   20ea4:	f24c 60b0 	movw	r0, #50864	; 0xc6b0
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   20ea8:	ed84 0a01 	vstr	s0, [r4, #4]
	tSVF_setFreq(&lowpass, displayValues[1]);
   20eac:	f2c0 200f 	movt	r0, #527	; 0x20f
   20eb0:	f00a fc7c 	bl	2b7ac <tSVF_setFreq>
	tSVF_setFreq(&lowpass2, displayValues[1]);
   20eb4:	f24d 6000 	movw	r0, #54784	; 0xd600
   20eb8:	ed94 0a01 	vldr	s0, [r4, #4]
   20ebc:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ec0:	f00a fc74 	bl	2b7ac <tSVF_setFreq>
	displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   20ec4:	f04f 4386 	mov.w	r3, #1124073472	; 0x43000000
   20ec8:	ed99 0a00 	vldr	s0, [r9]
   20ecc:	ee08 3a10 	vmov	s16, r3
   20ed0:	ee20 0a08 	vmul.f32	s0, s0, s16
   20ed4:	f00c f8fe 	bl	2d0d4 <faster_mtof>
	tSVF_setFreq(&highpass, displayValues[2]);
   20ed8:	f24e 40e0 	movw	r0, #58592	; 0xe4e0
	displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   20edc:	ed84 0a02 	vstr	s0, [r4, #8]
	tSVF_setFreq(&highpass, displayValues[2]);
   20ee0:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ee4:	f00a fc62 	bl	2b7ac <tSVF_setFreq>
	tSVF_setFreq(&highpass2, displayValues[2]);
   20ee8:	f64d 00ac 	movw	r0, #55468	; 0xd8ac
   20eec:	ed94 0a02 	vldr	s0, [r4, #8]
   20ef0:	f2c0 200f 	movt	r0, #527	; 0x20f
   20ef4:	f00a fc5a 	bl	2b7ac <tSVF_setFreq>
	displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
   20ef8:	ed98 0a02 	vldr	s0, [r8, #8]
   20efc:	ee20 0a08 	vmul.f32	s0, s0, s16
   20f00:	f00c f8e8 	bl	2d0d4 <faster_mtof>
	tSVF_setFreq(&bandpass, displayValues[3]);
   20f04:	f64d 10a8 	movw	r0, #55720	; 0xd9a8
	displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
   20f08:	ed84 0a03 	vstr	s0, [r4, #12]
	tSVF_setFreq(&bandpass, displayValues[3]);
   20f0c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20f10:	f00a fc4c 	bl	2b7ac <tSVF_setFreq>
	tSVF_setFreq(&bandpass2, displayValues[3]);
   20f14:	f64d 1088 	movw	r0, #55688	; 0xd988
   20f18:	ed94 0a03 	vldr	s0, [r4, #12]
   20f1c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20f20:	f00a fc44 	bl	2b7ac <tSVF_setFreq>
	displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
   20f24:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   20f28:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
   20f2c:	edd8 6a03 	vldr	s13, [r8, #12]
	if (buttonActionsSFX[ButtonC][ActionPress])
   20f30:	7f2b      	ldrb	r3, [r5, #28]
	displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
   20f32:	eee6 7a87 	vfma.f32	s15, s13, s14
   20f36:	edc4 7a04 	vstr	s15, [r4, #16]
	if (buttonActionsSFX[ButtonC][ActionPress])
   20f3a:	2b00      	cmp	r3, #0
   20f3c:	d167      	bne.n	2100e <SFXReverb2Tick+0x1da>
	if (buttonActionsSFX[ButtonA][ActionPress])
   20f3e:	7d2b      	ldrb	r3, [r5, #20]
   20f40:	b14b      	cbz	r3, 20f56 <SFXReverb2Tick+0x122>
		freeze = !freeze;
   20f42:	6833      	ldr	r3, [r6, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20f44:	2200      	movs	r2, #0
		freeze = !freeze;
   20f46:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20f4a:	752a      	strb	r2, [r5, #20]
		freeze = !freeze;
   20f4c:	095b      	lsrs	r3, r3, #5
		setLED_C(freeze);
   20f4e:	4618      	mov	r0, r3
		freeze = !freeze;
   20f50:	6033      	str	r3, [r6, #0]
		setLED_C(freeze);
   20f52:	f7fa f90f 	bl	1b174 <setLED_C>
	tNReverb_tickStereo(&reverb2, input[1], stereoOuts);
   20f56:	f24e 50d0 	movw	r0, #58832	; 0xe5d0
   20f5a:	4669      	mov	r1, sp
   20f5c:	ed97 0a01 	vldr	s0, [r7, #4]
   20f60:	f2c0 200f 	movt	r0, #527	; 0x20f
   20f64:	f00d fc28 	bl	2e7b8 <tNReverb_tickStereo>
	float leftOut = tSVF_tick(&lowpass, stereoOuts[0]);
   20f68:	f24c 60b0 	movw	r0, #50864	; 0xc6b0
   20f6c:	ed9d 0a00 	vldr	s0, [sp]
   20f70:	f2c0 200f 	movt	r0, #527	; 0x20f
   20f74:	f00a fbe4 	bl	2b740 <tSVF_tick>
	leftOut = tSVF_tick(&highpass, leftOut);
   20f78:	f24e 40e0 	movw	r0, #58592	; 0xe4e0
   20f7c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20f80:	f00a fbde 	bl	2b740 <tSVF_tick>
	leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   20f84:	f64d 10a8 	movw	r0, #55720	; 0xd9a8
	leftOut = tSVF_tick(&highpass, leftOut);
   20f88:	eef0 8a40 	vmov.f32	s17, s0
	leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   20f8c:	f2c0 200f 	movt	r0, #527	; 0x20f
   20f90:	f00a fbd6 	bl	2b740 <tSVF_tick>
   20f94:	edd4 7a04 	vldr	s15, [r4, #16]
	float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
   20f98:	f24d 6000 	movw	r0, #54784	; 0xd600
	leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   20f9c:	eee0 8a27 	vfma.f32	s17, s0, s15
	float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
   20fa0:	ed9d 0a01 	vldr	s0, [sp, #4]
   20fa4:	f2c0 200f 	movt	r0, #527	; 0x20f
   20fa8:	f00a fbca 	bl	2b740 <tSVF_tick>
	rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
   20fac:	f64d 00ac 	movw	r0, #55468	; 0xd8ac
   20fb0:	f2c0 200f 	movt	r0, #527	; 0x20f
   20fb4:	f00a fbc4 	bl	2b740 <tSVF_tick>
	rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
   20fb8:	f64d 10a8 	movw	r0, #55720	; 0xd9a8
	rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
   20fbc:	eeb0 8a40 	vmov.f32	s16, s0
	rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
   20fc0:	f2c0 200f 	movt	r0, #527	; 0x20f
   20fc4:	f00a fbbc 	bl	2b740 <tSVF_tick>
   20fc8:	edd4 7a04 	vldr	s15, [r4, #16]
   20fcc:	eea0 8a27 	vfma.f32	s16, s0, s15
	sample = tanhf(leftOut);
   20fd0:	eeb0 0a68 	vmov.f32	s0, s17
   20fd4:	f00f fd2a 	bl	30a2c <tanhf>
	input[0] = sample;
   20fd8:	ed87 0a00 	vstr	s0, [r7]
	input[1] = tanhf(rightOutTemp);
   20fdc:	eeb0 0a48 	vmov.f32	s0, s16
   20fe0:	f00f fd24 	bl	30a2c <tanhf>
   20fe4:	ed87 0a01 	vstr	s0, [r7, #4]
}
   20fe8:	b003      	add	sp, #12
   20fea:	ecbd 8b02 	vpop	{d8}
   20fee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		tNReverb_setT60(&reverb2, 1000.0f);
   20ff2:	2300      	movs	r3, #0
   20ff4:	f24e 50d0 	movw	r0, #58832	; 0xe5d0
   20ff8:	f2c4 437a 	movt	r3, #17530	; 0x447a
   20ffc:	f2c0 200f 	movt	r0, #527	; 0x20f
   21000:	ee00 3a10 	vmov	s0, r3
   21004:	f00d fb8c 	bl	2e720 <tNReverb_setT60>
		input[1] = 0.0f;
   21008:	2300      	movs	r3, #0
   2100a:	607b      	str	r3, [r7, #4]
   2100c:	e736      	b.n	20e7c <SFXReverb2Tick+0x48>
		freeze = !freeze;
   2100e:	6833      	ldr	r3, [r6, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   21010:	2200      	movs	r2, #0
		freeze = !freeze;
   21012:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   21016:	772a      	strb	r2, [r5, #28]
		freeze = !freeze;
   21018:	095b      	lsrs	r3, r3, #5
		setLED_C(freeze);
   2101a:	4618      	mov	r0, r3
		freeze = !freeze;
   2101c:	6033      	str	r3, [r6, #0]
		setLED_C(freeze);
   2101e:	f7fa f8a9 	bl	1b174 <setLED_C>
   21022:	e78c      	b.n	20f3e <SFXReverb2Tick+0x10a>

00021024 <SFXReverb2Free>:
	tNReverb_free(&reverb2);
   21024:	f24e 50d0 	movw	r0, #58832	; 0xe5d0
{
   21028:	b508      	push	{r3, lr}
	tNReverb_free(&reverb2);
   2102a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2102e:	f00d fb5b 	bl	2e6e8 <tNReverb_free>
	tSVF_free(&lowpass);
   21032:	f24c 60b0 	movw	r0, #50864	; 0xc6b0
   21036:	f2c0 200f 	movt	r0, #527	; 0x20f
   2103a:	f00a fb7d 	bl	2b738 <tSVF_free>
	tSVF_free(&highpass);
   2103e:	f24e 40e0 	movw	r0, #58592	; 0xe4e0
   21042:	f2c0 200f 	movt	r0, #527	; 0x20f
   21046:	f00a fb77 	bl	2b738 <tSVF_free>
	tSVF_free(&bandpass);
   2104a:	f64d 10a8 	movw	r0, #55720	; 0xd9a8
   2104e:	f2c0 200f 	movt	r0, #527	; 0x20f
   21052:	f00a fb71 	bl	2b738 <tSVF_free>
	tSVF_free(&lowpass2);
   21056:	f24d 6000 	movw	r0, #54784	; 0xd600
   2105a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2105e:	f00a fb6b 	bl	2b738 <tSVF_free>
	tSVF_free(&highpass2);
   21062:	f64d 00ac 	movw	r0, #55468	; 0xd8ac
   21066:	f2c0 200f 	movt	r0, #527	; 0x20f
   2106a:	f00a fb65 	bl	2b738 <tSVF_free>
	tSVF_free(&bandpass2);
   2106e:	f64d 1088 	movw	r0, #55688	; 0xd988
}
   21072:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tSVF_free(&bandpass2);
   21076:	f2c0 200f 	movt	r0, #527	; 0x20f
   2107a:	f00a bb5d 	b.w	2b738 <tSVF_free>
   2107e:	bf00      	nop

00021080 <SFXLivingStringAlloc>:
{
   21080:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	levMode = 0;
   21084:	f646 1608 	movw	r6, #26888	; 0x6908
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   21088:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
	levMode = 0;
   2108c:	2400      	movs	r4, #0
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   2108e:	f649 179a 	movw	r7, #39322	; 0x999a
	levMode = 0;
   21092:	f2c0 260e 	movt	r6, #526	; 0x20e
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   21096:	2106      	movs	r1, #6
   21098:	f2c0 200f 	movt	r0, #527	; 0x20f
   2109c:	f24c 55d0 	movw	r5, #50640	; 0xc5d0
	levMode = 0;
   210a0:	6034      	str	r4, [r6, #0]
   210a2:	f24c 38d8 	movw	r8, #50136	; 0xc3d8
   210a6:	f2c0 250f 	movt	r5, #527	; 0x20f
   210aa:	f2c0 280f 	movt	r8, #527	; 0x20f
{
   210ae:	ed2d 8b06 	vpush	{d8-d10}
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   210b2:	f00c fd11 	bl	2dad8 <tSimplePoly_setNumVoices>
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   210b6:	4638      	mov	r0, r7
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   210b8:	f24d 710a 	movw	r1, #55050	; 0xd70a
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   210bc:	f6c3 6799 	movt	r7, #16025	; 0x3e99
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   210c0:	f44f 4320 	mov.w	r3, #40960	; 0xa000
   210c4:	f64c 42cd 	movw	r2, #52429	; 0xcccd
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   210c8:	f6cb 6019 	movt	r0, #48665	; 0xbe19
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   210cc:	f6c3 4123 	movt	r1, #15395	; 0x3c23
   210d0:	f2c4 630c 	movt	r3, #17932	; 0x460c
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   210d4:	ee0a 7a90 	vmov	s21, r7
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   210d8:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
   210dc:	f24d 37c8 	movw	r7, #54216	; 0xd3c8
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   210e0:	ee0a 0a10 	vmov	s20, r0
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   210e4:	ee09 1a90 	vmov	s19, r1
   210e8:	ee09 3a10 	vmov	s18, r3
   210ec:	ee08 2a90 	vmov	s17, r2
   210f0:	f2c0 270f 	movt	r7, #527	; 0x20f
   210f4:	ee08 4a10 	vmov	s16, r4
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   210f8:	f7f9 ff3a 	bl	1af70 <randomNumber>
   210fc:	eef0 7a4a 	vmov.f32	s15, s20
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   21100:	f649 129a 	movw	r2, #39322	; 0x999a
   21104:	2300      	movs	r3, #0
   21106:	eb08 0004 	add.w	r0, r8, r4
   2110a:	6831      	ldr	r1, [r6, #0]
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   2110c:	eee0 7a2a 	vfma.f32	s15, s0, s21
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   21110:	f6c3 6299 	movt	r2, #16025	; 0x3e99
   21114:	f2c4 33dc 	movt	r3, #17372	; 0x43dc
   21118:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
   2111c:	ee03 2a10 	vmov	s6, r2
   21120:	eef0 3a69 	vmov.f32	s7, s19
   21124:	ee00 3a10 	vmov	s0, r3
   21128:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
   2112c:	ee01 2a10 	vmov	s2, r2
   21130:	eeb0 2a49 	vmov.f32	s4, s18
   21134:	eef0 1a48 	vmov.f32	s3, s16
   21138:	eef0 0a68 	vmov.f32	s1, s17
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   2113c:	ece5 7a01 	vstmia	r5!, {s15}
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   21140:	f00c ffe2 	bl	2e108 <tComplexLivingString_init>
		tExpSmooth_initToPool(&stringGains[i], 0.0f, 0.002f, &smallPool);
   21144:	f241 236f 	movw	r3, #4719	; 0x126f
   21148:	f64a 6190 	movw	r1, #44688	; 0xae90
   2114c:	1938      	adds	r0, r7, r4
   2114e:	f6c3 3303 	movt	r3, #15107	; 0x3b03
   21152:	3404      	adds	r4, #4
   21154:	f2c0 210f 	movt	r1, #527	; 0x20f
   21158:	eeb0 0a48 	vmov.f32	s0, s16
   2115c:	ee00 3a90 	vmov	s1, r3
   21160:	f00a f8ee 	bl	2b340 <tExpSmooth_initToPool>
	for (int i = 0; i < NUM_STRINGS; i++)
   21164:	2c18      	cmp	r4, #24
   21166:	d1c7      	bne.n	210f8 <SFXLivingStringAlloc+0x78>
	ignoreFreqKnobs = 0;
   21168:	f646 03fc 	movw	r3, #26876	; 0x68fc
   2116c:	2200      	movs	r2, #0
   2116e:	f2c0 230e 	movt	r3, #526	; 0x20e
	setLED_A(ignoreFreqKnobs);
   21172:	4610      	mov	r0, r2
	ignoreFreqKnobs = 0;
   21174:	601a      	str	r2, [r3, #0]
	setLED_A(ignoreFreqKnobs);
   21176:	f7f9 ffdd 	bl	1b134 <setLED_A>
	setLED_B(independentStrings);
   2117a:	f646 1300 	movw	r3, #26880	; 0x6900
   2117e:	f2c0 230e 	movt	r3, #526	; 0x20e
   21182:	7818      	ldrb	r0, [r3, #0]
   21184:	f7f9 ffe6 	bl	1b154 <setLED_B>
	setLED_C(levMode);
   21188:	7830      	ldrb	r0, [r6, #0]
}
   2118a:	ecbd 8b06 	vpop	{d8-d10}
   2118e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	setLED_C(levMode);
   21192:	f7f9 bfef 	b.w	1b174 <setLED_C>
   21196:	bf00      	nop

00021198 <SFXLivingStringFrame>:
{
   21198:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   2119c:	f64e 257c 	movw	r5, #60028	; 0xea7c
   211a0:	f2c0 250f 	movt	r5, #527	; 0x20f
{
   211a4:	ed2d 8b04 	vpush	{d8-d9}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   211a8:	7d2a      	ldrb	r2, [r5, #20]
{
   211aa:	b087      	sub	sp, #28
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   211ac:	2a01      	cmp	r2, #1
   211ae:	f000 8243 	beq.w	21638 <SFXLivingStringFrame+0x4a0>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   211b2:	7f2a      	ldrb	r2, [r5, #28]
   211b4:	2a01      	cmp	r2, #1
   211b6:	f000 818a 	beq.w	214ce <SFXLivingStringFrame+0x336>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   211ba:	7e2a      	ldrb	r2, [r5, #24]
   211bc:	f24c 37d8 	movw	r7, #50136	; 0xc3d8
		independentStrings = !independentStrings;
   211c0:	f646 1600 	movw	r6, #26880	; 0x6900
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   211c4:	2a01      	cmp	r2, #1
   211c6:	f2c0 270f 	movt	r7, #527	; 0x20f
   211ca:	f000 81a5 	beq.w	21518 <SFXLivingStringFrame+0x380>
   211ce:	f2c0 260e 	movt	r6, #526	; 0x20e
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   211d2:	f64c 75f0 	movw	r5, #53232	; 0xcff0
   211d6:	2300      	movs	r3, #0
   211d8:	f64e 342c 	movw	r4, #60204	; 0xeb2c
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   211dc:	f641 6ab8 	movw	sl, #7864	; 0x1eb8
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   211e0:	f2c0 250f 	movt	r5, #527	; 0x20f
   211e4:	f2c4 23b4 	movt	r3, #17076	; 0x42b4
   211e8:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   211ec:	f647 29e1 	movw	r9, #31457	; 0x7ae1
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   211f0:	462a      	mov	r2, r5
   211f2:	ee08 3a90 	vmov	s17, r3
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   211f6:	f64b 0b51 	movw	fp, #47185	; 0xb851
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   211fa:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   211fe:	ecb2 0a01 	vldmia	r2!, {s0}
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   21202:	f6ce 3a85 	movt	sl, #60293	; 0xeb85
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   21206:	f6c3 7994 	movt	r9, #16276	; 0x3f94
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   2120a:	f6c3 7bde 	movt	fp, #16350	; 0x3fde
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   2120e:	ee20 0a28 	vmul.f32	s0, s0, s17
   21212:	9200      	str	r2, [sp, #0]
   21214:	f00b fecc 	bl	2cfb0 <LEAF_midiToFrequency>
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   21218:	2300      	movs	r3, #0
   2121a:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
   2121e:	edd5 6a03 	vldr	s13, [r5, #12]
   21222:	f2c4 3302 	movt	r3, #17154	; 0x4302
	displayValues[1] = presetKnobValues[LivingString][1]; //detune
   21226:	9a00      	ldr	r2, [sp, #0]
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   21228:	ed84 0a00 	vstr	s0, [r4]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   2122c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   21230:	ee07 3a90 	vmov	s15, r3
	displayValues[1] = presetKnobValues[LivingString][1]; //detune
   21234:	6812      	ldr	r2, [r2, #0]
	displayValues[2] = presetKnobValues[LivingString][2]; //decay
   21236:	68ab      	ldr	r3, [r5, #8]
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   21238:	eea6 7aa7 	vfma.f32	s14, s13, s15
	displayValues[1] = presetKnobValues[LivingString][1]; //detune
   2123c:	6062      	str	r2, [r4, #4]
	displayValues[2] = presetKnobValues[LivingString][2]; //decay
   2123e:	60a3      	str	r3, [r4, #8]
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   21240:	eeb0 0a47 	vmov.f32	s0, s14
   21244:	f00b ff1a 	bl	2d07c <mtof>
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   21248:	ed95 3a04 	vldr	s6, [r5, #16]
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   2124c:	ed95 4a05 	vldr	s8, [r5, #20]
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   21250:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
   21254:	eeb7 3ac3 	vcvt.f64.f32	d3, s6
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   21258:	ed84 0a03 	vstr	s0, [r4, #12]
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   2125c:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   21260:	ed95 2a06 	vldr	s4, [r5, #24]
   21264:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
   21268:	eeb9 0a00 	vmov.f32	s0, #144	; 0xc0800000 -4.0
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   2126c:	ec4b ab16 	vmov	d6, sl, fp
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   21270:	ec49 8b17 	vmov	d7, r8, r9
   21274:	eea4 7b06 	vfma.f64	d7, d4, d6
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   21278:	eea3 5b06 	vfma.f64	d5, d3, d6
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   2127c:	eea2 0a22 	vfma.f32	s0, s4, s5
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   21280:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   21284:	ed84 7a05 	vstr	s14, [r4, #20]
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   21288:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
   2128c:	ed84 5a04 	vstr	s10, [r4, #16]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   21290:	f00f fbcc 	bl	30a2c <tanhf>
   21294:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	displayValues[7] = presetKnobValues[LivingString][7];// let ring
   21298:	69eb      	ldr	r3, [r5, #28]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   2129a:	ee30 0a08 	vadd.f32	s0, s0, s16
	if (!independentStrings)
   2129e:	6836      	ldr	r6, [r6, #0]
	displayValues[7] = presetKnobValues[LivingString][7];// let ring
   212a0:	61e3      	str	r3, [r4, #28]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   212a2:	ee20 0a27 	vmul.f32	s0, s0, s15
   212a6:	ed84 0a06 	vstr	s0, [r4, #24]
	if (!independentStrings)
   212aa:	2e00      	cmp	r6, #0
   212ac:	f040 8141 	bne.w	21532 <SFXLivingStringFrame+0x39a>
		if (!ignoreFreqKnobs)
   212b0:	f646 03fc 	movw	r3, #26876	; 0x68fc
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   212b4:	f24c 228f 	movw	r2, #49807	; 0xc28f
		if (!ignoreFreqKnobs)
   212b8:	f2c0 230e 	movt	r3, #526	; 0x20e
   212bc:	f8d3 9000 	ldr.w	r9, [r3]
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   212c0:	f64b 0352 	movw	r3, #47186	; 0xb852
		if (!ignoreFreqKnobs)
   212c4:	f1b9 0f00 	cmp.w	r9, #0
   212c8:	f000 80ac 	beq.w	21424 <SFXLivingStringFrame+0x28c>
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   212cc:	f6c3 737e 	movt	r3, #16254	; 0x3f7e
   212d0:	f24c 51d0 	movw	r1, #50640	; 0xc5d0
   212d4:	f24d 38c8 	movw	r8, #54216	; 0xd3c8
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   212d8:	f64a 2cab 	movw	ip, #43691	; 0xaaab
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   212dc:	ee08 3a90 	vmov	s17, r3
   212e0:	460b      	mov	r3, r1
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   212e2:	f64d 01bc 	movw	r1, #55484	; 0xd8bc
   212e6:	f24d 1aa4 	movw	sl, #53668	; 0xd1a4
   212ea:	f2c0 230f 	movt	r3, #527	; 0x20f
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   212ee:	f6c3 4275 	movt	r2, #15477	; 0x3c75
   212f2:	f646 1b40 	movw	fp, #26944	; 0x6940
   212f6:	f646 1084 	movw	r0, #27012	; 0x6984
   212fa:	9300      	str	r3, [sp, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   212fc:	460b      	mov	r3, r1
   212fe:	f646 15b8 	movw	r5, #27064	; 0x69b8
   21302:	f2c0 280f 	movt	r8, #527	; 0x20f
   21306:	f2c0 230f 	movt	r3, #527	; 0x20f
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2130a:	4661      	mov	r1, ip
   2130c:	f2c0 200e 	movt	r0, #526	; 0x20e
   21310:	f2c0 250e 	movt	r5, #526	; 0x20e
   21314:	f6c2 21aa 	movt	r1, #10922	; 0x2aaa
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   21318:	ee09 2a10 	vmov	s18, r2
   2131c:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   21320:	f2c0 2b0e 	movt	fp, #526	; 0x20e
		if (!ignoreFreqKnobs)
   21324:	46b1      	mov	r9, r6
   21326:	9002      	str	r0, [sp, #8]
   21328:	9503      	str	r5, [sp, #12]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2132a:	9101      	str	r1, [sp, #4]
		if (!ignoreFreqKnobs)
   2132c:	e9cd 8704 	strd	r8, r7, [sp, #16]
   21330:	461f      	mov	r7, r3
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21332:	fa5f f889 	uxtb.w	r8, r9
   21336:	9b05      	ldr	r3, [sp, #20]
   21338:	4638      	mov	r0, r7
   2133a:	4641      	mov	r1, r8
   2133c:	199d      	adds	r5, r3, r6
   2133e:	f00c fbef 	bl	2db20 <tSimplePoly_getPitch>
   21342:	ee07 0a90 	vmov	s15, r0
   21346:	ed9b 0a00 	vldr	s0, [fp]
   2134a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2134e:	9b03      	ldr	r3, [sp, #12]
   21350:	7818      	ldrb	r0, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21352:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21356:	9b01      	ldr	r3, [sp, #4]
   21358:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   2135c:	ee17 1a90 	vmov	r1, s15
   21360:	1a09      	subs	r1, r1, r0
   21362:	fb83 3c01 	smull	r3, ip, r3, r1
   21366:	17c8      	asrs	r0, r1, #31
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   21368:	9b02      	ldr	r3, [sp, #8]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2136a:	ebc0 006c 	rsb	r0, r0, ip, asr #1
   2136e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   21372:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   21376:	ee07 0a90 	vmov	s15, r0
   2137a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   2137e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   21382:	ee17 1a90 	vmov	r1, s15
   21386:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2138a:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   2138e:	ee37 0a00 	vadd.f32	s0, s14, s0
   21392:	f00b fe0d 	bl	2cfb0 <LEAF_midiToFrequency>
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   21396:	9b00      	ldr	r3, [sp, #0]
   21398:	eef0 6a48 	vmov.f32	s13, s16
   2139c:	edd4 7a01 	vldr	s15, [r4, #4]
   213a0:	ecb3 7a01 	vldmia	r3!, {s14}
   213a4:	4628      	mov	r0, r5
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   213a6:	ecaa 0a01 	vstmia	sl!, {s0}
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   213aa:	eee7 6a27 	vfma.f32	s13, s14, s15
   213ae:	9300      	str	r3, [sp, #0]
   213b0:	ee26 0a80 	vmul.f32	s0, s13, s0
   213b4:	f00c fefa 	bl	2e1ac <tComplexLivingString_setFreq>
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   213b8:	eeb0 0a68 	vmov.f32	s0, s17
   213bc:	edd4 7a02 	vldr	s15, [r4, #8]
   213c0:	4628      	mov	r0, r5
   213c2:	eea7 0a89 	vfma.f32	s0, s15, s18
   213c6:	f00c ff5b 	bl	2e280 <tComplexLivingString_setDecay>
				tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   213ca:	4628      	mov	r0, r5
   213cc:	ed94 0a03 	vldr	s0, [r4, #12]
   213d0:	f00c ff36 	bl	2e240 <tComplexLivingString_setDampFreq>
				tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   213d4:	4628      	mov	r0, r5
   213d6:	ed94 0a04 	vldr	s0, [r4, #16]
   213da:	f00c ff03 	bl	2e1e4 <tComplexLivingString_setPickPos>
				tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   213de:	4628      	mov	r0, r5
   213e0:	ed94 0a05 	vldr	s0, [r4, #20]
   213e4:	f00c ff0e 	bl	2e204 <tComplexLivingString_setPrepPos>
				tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   213e8:	ed94 0a06 	vldr	s0, [r4, #24]
   213ec:	4628      	mov	r0, r5
   213ee:	f00c ff19 	bl	2e224 <tComplexLivingString_setPrepIndex>
				if (tSimplePoly_isOn(&poly, i))
   213f2:	4641      	mov	r1, r8
   213f4:	4638      	mov	r0, r7
   213f6:	f00c fba5 	bl	2db44 <tSimplePoly_isOn>
   213fa:	9b04      	ldr	r3, [sp, #16]
					tExpSmooth_setDest(&stringGains[i], 1.0f);
   213fc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   21400:	1999      	adds	r1, r3, r6
				if (tSimplePoly_isOn(&poly, i))
   21402:	b908      	cbnz	r0, 21408 <SFXLivingStringFrame+0x270>
					tExpSmooth_setDest(&stringGains[i], displayValues[7]);
   21404:	ed94 0a07 	vldr	s0, [r4, #28]
			for (int i = 0; i < NUM_STRINGS; i++)
   21408:	f109 0901 	add.w	r9, r9, #1
					tExpSmooth_setDest(&stringGains[i], displayValues[7]);
   2140c:	4608      	mov	r0, r1
   2140e:	f009 ffd3 	bl	2b3b8 <tExpSmooth_setDest>
   21412:	3604      	adds	r6, #4
			for (int i = 0; i < NUM_STRINGS; i++)
   21414:	f1b9 0f06 	cmp.w	r9, #6
   21418:	d18b      	bne.n	21332 <SFXLivingStringFrame+0x19a>
}
   2141a:	b007      	add	sp, #28
   2141c:	ecbd 8b04 	vpop	{d8-d9}
   21420:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   21424:	f24c 5ad0 	movw	sl, #50640	; 0xc5d0
   21428:	f24d 38c8 	movw	r8, #54216	; 0xd3c8
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   2142c:	f6c3 4275 	movt	r2, #15477	; 0x3c75
   21430:	f6c3 737e 	movt	r3, #16254	; 0x3f7e
   21434:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   21438:	f2c0 280f 	movt	r8, #527	; 0x20f
   2143c:	ee09 2a10 	vmov	s18, r2
   21440:	ee08 3a90 	vmov	s17, r3
		if (!ignoreFreqKnobs)
   21444:	464e      	mov	r6, r9
				float freqVal = displayValues[0] * (i+1);
   21446:	f109 0901 	add.w	r9, r9, #1
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   2144a:	eeb0 0a48 	vmov.f32	s0, s16
   2144e:	ecba 6a01 	vldmia	sl!, {s12}
   21452:	19bd      	adds	r5, r7, r6
   21454:	edd4 6a01 	vldr	s13, [r4, #4]
				float freqVal = displayValues[0] * (i+1);
   21458:	ee07 9a90 	vmov	s15, r9
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   2145c:	4628      	mov	r0, r5
				float freqVal = displayValues[0] * (i+1);
   2145e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   21462:	edd4 7a00 	vldr	s15, [r4]
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   21466:	eea6 0a26 	vfma.f32	s0, s12, s13
				float freqVal = displayValues[0] * (i+1);
   2146a:	ee67 7a27 	vmul.f32	s15, s14, s15
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   2146e:	ee27 0a80 	vmul.f32	s0, s15, s0
   21472:	f00c fe9b 	bl	2e1ac <tComplexLivingString_setFreq>
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   21476:	eeb0 0a68 	vmov.f32	s0, s17
   2147a:	edd4 7a02 	vldr	s15, [r4, #8]
   2147e:	4628      	mov	r0, r5
   21480:	eea7 0a89 	vfma.f32	s0, s15, s18
   21484:	f00c fefc 	bl	2e280 <tComplexLivingString_setDecay>
				tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   21488:	4628      	mov	r0, r5
   2148a:	ed94 0a03 	vldr	s0, [r4, #12]
   2148e:	f00c fed7 	bl	2e240 <tComplexLivingString_setDampFreq>
				tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   21492:	4628      	mov	r0, r5
   21494:	ed94 0a04 	vldr	s0, [r4, #16]
   21498:	f00c fea4 	bl	2e1e4 <tComplexLivingString_setPickPos>
				tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   2149c:	4628      	mov	r0, r5
   2149e:	ed94 0a05 	vldr	s0, [r4, #20]
   214a2:	f00c feaf 	bl	2e204 <tComplexLivingString_setPrepPos>
				tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   214a6:	4628      	mov	r0, r5
   214a8:	ed94 0a06 	vldr	s0, [r4, #24]
   214ac:	f00c feba 	bl	2e224 <tComplexLivingString_setPrepIndex>
				tExpSmooth_setDest(&stringGains[i], 1.0f);
   214b0:	eb08 0006 	add.w	r0, r8, r6
   214b4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   214b8:	3604      	adds	r6, #4
   214ba:	f009 ff7d 	bl	2b3b8 <tExpSmooth_setDest>
			for (int i = 0; i < NUM_STRINGS; i++)
   214be:	f1b9 0f06 	cmp.w	r9, #6
   214c2:	d1c0      	bne.n	21446 <SFXLivingStringFrame+0x2ae>
}
   214c4:	b007      	add	sp, #28
   214c6:	ecbd 8b04 	vpop	{d8-d9}
   214ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		levMode = !levMode;
   214ce:	f646 1608 	movw	r6, #26888	; 0x6908
   214d2:	f24c 37d8 	movw	r7, #50136	; 0xc3d8
   214d6:	f2c0 260e 	movt	r6, #526	; 0x20e
   214da:	f2c0 270f 	movt	r7, #527	; 0x20f
   214de:	6831      	ldr	r1, [r6, #0]
   214e0:	463c      	mov	r4, r7
   214e2:	fab1 f181 	clz	r1, r1
   214e6:	0949      	lsrs	r1, r1, #5
   214e8:	6031      	str	r1, [r6, #0]
   214ea:	e000      	b.n	214ee <SFXLivingStringFrame+0x356>
   214ec:	6831      	ldr	r1, [r6, #0]
			tComplexLivingString_setLevMode(&theString[i], levMode);
   214ee:	4620      	mov	r0, r4
   214f0:	3404      	adds	r4, #4
   214f2:	f00c fedd 	bl	2e2b0 <tComplexLivingString_setLevMode>
		for (int i = 0; i < NUM_STRINGS; i++)
   214f6:	f24c 33f0 	movw	r3, #50160	; 0xc3f0
   214fa:	f2c0 230f 	movt	r3, #527	; 0x20f
   214fe:	429c      	cmp	r4, r3
   21500:	d1f4      	bne.n	214ec <SFXLivingStringFrame+0x354>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   21502:	2200      	movs	r2, #0
		setLED_C(levMode);
   21504:	7830      	ldrb	r0, [r6, #0]
		independentStrings = !independentStrings;
   21506:	f646 1600 	movw	r6, #26880	; 0x6900
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   2150a:	772a      	strb	r2, [r5, #28]
		setLED_C(levMode);
   2150c:	f7f9 fe32 	bl	1b174 <setLED_C>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   21510:	7e2a      	ldrb	r2, [r5, #24]
   21512:	2a01      	cmp	r2, #1
   21514:	f47f ae5b 	bne.w	211ce <SFXLivingStringFrame+0x36>
		independentStrings = !independentStrings;
   21518:	f2c0 260e 	movt	r6, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   2151c:	2200      	movs	r2, #0
		independentStrings = !independentStrings;
   2151e:	6833      	ldr	r3, [r6, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   21520:	762a      	strb	r2, [r5, #24]
		independentStrings = !independentStrings;
   21522:	fab3 f383 	clz	r3, r3
   21526:	095b      	lsrs	r3, r3, #5
		setLED_B(independentStrings);
   21528:	4618      	mov	r0, r3
		independentStrings = !independentStrings;
   2152a:	6033      	str	r3, [r6, #0]
		setLED_B(independentStrings);
   2152c:	f7f9 fe12 	bl	1b154 <setLED_B>
   21530:	e64f      	b.n	211d2 <SFXLivingStringFrame+0x3a>
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   21532:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
   21536:	f24c 5bd0 	movw	fp, #50640	; 0xc5d0
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   2153a:	f04f 0a00 	mov.w	sl, #0
   2153e:	f24d 38c8 	movw	r8, #54216	; 0xd3c8
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   21542:	ee20 0a28 	vmul.f32	s0, s0, s17
   21546:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   2154a:	f00b fd31 	bl	2cfb0 <LEAF_midiToFrequency>
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   2154e:	edd5 7a0b 	vldr	s15, [r5, #44]	; 0x2c
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   21552:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
		for (int i = 0; i < NUM_STRINGS; i++)
   21556:	4656      	mov	r6, sl
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   21558:	ee27 0aa8 	vmul.f32	s0, s15, s17
   2155c:	f2c0 280f 	movt	r8, #527	; 0x20f
   21560:	f00b fd26 	bl	2cfb0 <LEAF_midiToFrequency>
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   21564:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   21568:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
   2156c:	f104 0924 	add.w	r9, r4, #36	; 0x24
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   21570:	ee27 0aa8 	vmul.f32	s0, s15, s17
   21574:	f00b fd1c 	bl	2cfb0 <LEAF_midiToFrequency>
		displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   21578:	edd5 7a0d 	vldr	s15, [r5, #52]	; 0x34
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   2157c:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
		displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   21580:	ee27 0aa8 	vmul.f32	s0, s15, s17
   21584:	f00b fd14 	bl	2cfb0 <LEAF_midiToFrequency>
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   21588:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
		displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   2158c:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   21590:	ee27 0aa8 	vmul.f32	s0, s15, s17
   21594:	f00b fd0c 	bl	2cfb0 <LEAF_midiToFrequency>
			tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   21598:	f24c 228f 	movw	r2, #49807	; 0xc28f
   2159c:	f64b 0352 	movw	r3, #47186	; 0xb852
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   215a0:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
			tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   215a4:	f6c3 4275 	movt	r2, #15477	; 0x3c75
   215a8:	f6c3 737e 	movt	r3, #16254	; 0x3f7e
   215ac:	ee09 2a10 	vmov	s18, r2
   215b0:	ee08 3a90 	vmov	s17, r3
			float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
   215b4:	2e00      	cmp	r6, #0
   215b6:	d04e      	beq.n	21656 <SFXLivingStringFrame+0x4be>
   215b8:	edd9 7a00 	vldr	s15, [r9]
			tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   215bc:	eeb0 0a48 	vmov.f32	s0, s16
   215c0:	ecfb 6a01 	vldmia	fp!, {s13}
   215c4:	ed94 7a01 	vldr	s14, [r4, #4]
   215c8:	eb07 050a 	add.w	r5, r7, sl
		for (int i = 0; i < NUM_STRINGS; i++)
   215cc:	3601      	adds	r6, #1
   215ce:	f109 0904 	add.w	r9, r9, #4
			tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   215d2:	eea6 0a87 	vfma.f32	s0, s13, s14
   215d6:	4628      	mov	r0, r5
   215d8:	ee20 0a27 	vmul.f32	s0, s0, s15
   215dc:	f00c fde6 	bl	2e1ac <tComplexLivingString_setFreq>
			tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   215e0:	eeb0 0a68 	vmov.f32	s0, s17
   215e4:	edd4 7a02 	vldr	s15, [r4, #8]
   215e8:	4628      	mov	r0, r5
   215ea:	eea7 0a89 	vfma.f32	s0, s15, s18
   215ee:	f00c fe47 	bl	2e280 <tComplexLivingString_setDecay>
			tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   215f2:	4628      	mov	r0, r5
   215f4:	ed94 0a03 	vldr	s0, [r4, #12]
   215f8:	f00c fe22 	bl	2e240 <tComplexLivingString_setDampFreq>
			tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   215fc:	4628      	mov	r0, r5
   215fe:	ed94 0a04 	vldr	s0, [r4, #16]
   21602:	f00c fdef 	bl	2e1e4 <tComplexLivingString_setPickPos>
			tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   21606:	4628      	mov	r0, r5
   21608:	ed94 0a05 	vldr	s0, [r4, #20]
   2160c:	f00c fdfa 	bl	2e204 <tComplexLivingString_setPrepPos>
			tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   21610:	4628      	mov	r0, r5
   21612:	ed94 0a06 	vldr	s0, [r4, #24]
   21616:	f00c fe05 	bl	2e224 <tComplexLivingString_setPrepIndex>
			tExpSmooth_setDest(&stringGains[i], 1.0f);
   2161a:	eb08 000a 	add.w	r0, r8, sl
   2161e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   21622:	f10a 0a04 	add.w	sl, sl, #4
   21626:	f009 fec7 	bl	2b3b8 <tExpSmooth_setDest>
		for (int i = 0; i < NUM_STRINGS; i++)
   2162a:	2e06      	cmp	r6, #6
   2162c:	d1c2      	bne.n	215b4 <SFXLivingStringFrame+0x41c>
}
   2162e:	b007      	add	sp, #28
   21630:	ecbd 8b04 	vpop	{d8-d9}
   21634:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ignoreFreqKnobs = !ignoreFreqKnobs;
   21638:	f646 01fc 	movw	r1, #26876	; 0x68fc
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   2163c:	2200      	movs	r2, #0
		ignoreFreqKnobs = !ignoreFreqKnobs;
   2163e:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   21642:	752a      	strb	r2, [r5, #20]
		ignoreFreqKnobs = !ignoreFreqKnobs;
   21644:	680a      	ldr	r2, [r1, #0]
   21646:	fab2 f282 	clz	r2, r2
   2164a:	0952      	lsrs	r2, r2, #5
		setLED_A(ignoreFreqKnobs);
   2164c:	4610      	mov	r0, r2
		ignoreFreqKnobs = !ignoreFreqKnobs;
   2164e:	600a      	str	r2, [r1, #0]
		setLED_A(ignoreFreqKnobs);
   21650:	f7f9 fd70 	bl	1b134 <setLED_A>
   21654:	e5ad      	b.n	211b2 <SFXLivingStringFrame+0x1a>
			float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
   21656:	edd4 7a00 	vldr	s15, [r4]
   2165a:	e7af      	b.n	215bc <SFXLivingStringFrame+0x424>

0002165c <SFXLivingStringTick>:
{
   2165c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	float sample = 0.0f;
   2165e:	2300      	movs	r3, #0
   21660:	f24c 37d8 	movw	r7, #50136	; 0xc3d8
   21664:	f24d 36c8 	movw	r6, #54216	; 0xd3c8
{
   21668:	4605      	mov	r5, r0
   2166a:	f2c0 270f 	movt	r7, #527	; 0x20f
   2166e:	461c      	mov	r4, r3
   21670:	f2c0 260f 	movt	r6, #527	; 0x20f
   21674:	ed2d 8b02 	vpush	{d8}
	float sample = 0.0f;
   21678:	ee08 3a10 	vmov	s16, r3
		float tick = tComplexLivingString_tick(&theString[i], input[1]);
   2167c:	1938      	adds	r0, r7, r4
   2167e:	ed95 0a01 	vldr	s0, [r5, #4]
   21682:	f00c fe2b 	bl	2e2dc <tComplexLivingString_tick>
		sample += tick * tExpSmooth_tick(&stringGains[i]);
   21686:	1930      	adds	r0, r6, r4
   21688:	3404      	adds	r4, #4
		float tick = tComplexLivingString_tick(&theString[i], input[1]);
   2168a:	eef0 8a40 	vmov.f32	s17, s0
		sample += tick * tExpSmooth_tick(&stringGains[i]);
   2168e:	f009 fe9d 	bl	2b3cc <tExpSmooth_tick>
	for (int i = 0; i < NUM_STRINGS; i++)
   21692:	2c18      	cmp	r4, #24
		sample += tick * tExpSmooth_tick(&stringGains[i]);
   21694:	eea0 8a28 	vfma.f32	s16, s0, s17
	for (int i = 0; i < NUM_STRINGS; i++)
   21698:	d1f0      	bne.n	2167c <SFXLivingStringTick+0x20>
	sample *= 0.1625f;
   2169a:	f246 6366 	movw	r3, #26214	; 0x6666
   2169e:	f6c3 6326 	movt	r3, #15910	; 0x3e26
   216a2:	ee07 3a90 	vmov	s15, r3
   216a6:	ee28 8a27 	vmul.f32	s16, s16, s15
	input[0] = sample;
   216aa:	ed85 8a00 	vstr	s16, [r5]
	input[1] = sample;
   216ae:	ed85 8a01 	vstr	s16, [r5, #4]
}
   216b2:	ecbd 8b02 	vpop	{d8}
   216b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000216b8 <SFXLivingStringFree>:
{
   216b8:	b570      	push	{r4, r5, r6, lr}
   216ba:	f24c 36d8 	movw	r6, #50136	; 0xc3d8
   216be:	f24d 35c8 	movw	r5, #54216	; 0xd3c8
   216c2:	2400      	movs	r4, #0
   216c4:	f2c0 260f 	movt	r6, #527	; 0x20f
   216c8:	f2c0 250f 	movt	r5, #527	; 0x20f
		tComplexLivingString_free(&theString[i]);
   216cc:	1930      	adds	r0, r6, r4
   216ce:	f00c fd21 	bl	2e114 <tComplexLivingString_free>
		tExpSmooth_free(&stringGains[i]);
   216d2:	1928      	adds	r0, r5, r4
   216d4:	3404      	adds	r4, #4
   216d6:	f009 fe59 	bl	2b38c <tExpSmooth_free>
	for (int i = 0; i < NUM_STRINGS; i++)
   216da:	2c18      	cmp	r4, #24
   216dc:	d1f6      	bne.n	216cc <SFXLivingStringFree+0x14>
}
   216de:	bd70      	pop	{r4, r5, r6, pc}

000216e0 <SFXLivingStringSynthAlloc>:
{
   216e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	levMode = 1;
   216e4:	f646 1308 	movw	r3, #26888	; 0x6908
	leaf.clearOnAllocation = 0;
   216e8:	f64f 0b08 	movw	fp, #63496	; 0xf808
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   216ec:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
	levMode = 1;
   216f0:	2201      	movs	r2, #1
   216f2:	f2c0 230e 	movt	r3, #526	; 0x20e
	leaf.clearOnAllocation = 0;
   216f6:	2400      	movs	r4, #0
   216f8:	f2c0 2b0f 	movt	fp, #527	; 0x20f
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   216fc:	f2c0 200f 	movt	r0, #527	; 0x20f
   21700:	2106      	movs	r1, #6
   21702:	f646 160c 	movw	r6, #26892	; 0x690c
	leaf.clearOnAllocation = 0;
   21706:	f8cb 4014 	str.w	r4, [fp, #20]
   2170a:	f24c 3ad8 	movw	sl, #50136	; 0xc3d8
   2170e:	f64d 1990 	movw	r9, #55696	; 0xd990
   21712:	f64d 2858 	movw	r8, #55896	; 0xda58
   21716:	f24d 77a8 	movw	r7, #55208	; 0xd7a8
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   2171a:	f64a 6590 	movw	r5, #44688	; 0xae90
   2171e:	f2c0 260e 	movt	r6, #526	; 0x20e
   21722:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   21726:	f2c0 290f 	movt	r9, #527	; 0x20f
   2172a:	f2c0 280f 	movt	r8, #527	; 0x20f
   2172e:	f2c0 270f 	movt	r7, #527	; 0x20f
   21732:	f2c0 250f 	movt	r5, #527	; 0x20f
{
   21736:	ed2d 8b06 	vpush	{d8-d10}
	levMode = 1;
   2173a:	601a      	str	r2, [r3, #0]
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   2173c:	f00c f9cc 	bl	2dad8 <tSimplePoly_setNumVoices>
		tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   21740:	f24d 700a 	movw	r0, #55050	; 0xd70a
   21744:	f44f 4120 	mov.w	r1, #40960	; 0xa000
   21748:	f649 129a 	movw	r2, #39322	; 0x999a
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   2174c:	4623      	mov	r3, r4
		tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   2174e:	f6c3 4023 	movt	r0, #15395	; 0x3c23
   21752:	f2c4 610c 	movt	r1, #17932	; 0x460c
   21756:	f6c3 6299 	movt	r2, #16025	; 0x3e99
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   2175a:	f2c4 437a 	movt	r3, #17530	; 0x447a
		tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   2175e:	ee0a 0a10 	vmov	s20, r0
   21762:	ee09 1a90 	vmov	s19, r1
   21766:	ee09 2a10 	vmov	s18, r2
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   2176a:	ee08 3a10 	vmov	s16, r3
		tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   2176e:	ee08 4a90 	vmov	s17, r4
   21772:	2300      	movs	r3, #0
   21774:	f64c 42cd 	movw	r2, #52429	; 0xcccd
   21778:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
   2177c:	6831      	ldr	r1, [r6, #0]
   2177e:	f6c3 624c 	movt	r2, #15948	; 0x3e4c
   21782:	4618      	mov	r0, r3
   21784:	f2c4 33dc 	movt	r3, #17372	; 0x43dc
   21788:	eef0 3a4a 	vmov.f32	s7, s20
   2178c:	ee01 0a90 	vmov	s3, r0
   21790:	ee00 2a90 	vmov	s1, r2
   21794:	ee00 3a10 	vmov	s0, r3
   21798:	eeb0 3a68 	vmov.f32	s6, s17
   2179c:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
   217a0:	eb0a 0004 	add.w	r0, sl, r4
   217a4:	eeb0 2a69 	vmov.f32	s4, s19
   217a8:	eeb0 1a49 	vmov.f32	s2, s18
   217ac:	f00c fcac 	bl	2e108 <tComplexLivingString_init>
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   217b0:	eb09 0004 	add.w	r0, r9, r4
   217b4:	4629      	mov	r1, r5
   217b6:	eef0 0a48 	vmov.f32	s1, s16
   217ba:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   217be:	f009 fe15 	bl	2b3ec <tSlide_initToPool>
		tSlide_initToPool(&stringInEnvs[i], 12.0f, 1000.0f, &smallPool);
   217c2:	eb08 0004 	add.w	r0, r8, r4
   217c6:	4629      	mov	r1, r5
   217c8:	eef0 0a48 	vmov.f32	s1, s16
   217cc:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
   217d0:	f009 fe0c 	bl	2b3ec <tSlide_initToPool>
		tADSR4_initToPool(&pluckEnvs[i], 4.0f, 70.0f, 0.0f, 5.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   217d4:	2200      	movs	r2, #0
   217d6:	f64d 41d8 	movw	r1, #56536	; 0xdcd8
   217da:	1938      	adds	r0, r7, r4
   217dc:	f2c4 228c 	movt	r2, #17036	; 0x428c
   217e0:	3404      	adds	r4, #4
   217e2:	462b      	mov	r3, r5
   217e4:	f2c0 210f 	movt	r1, #527	; 0x20f
   217e8:	ee00 2a90 	vmov	s1, r2
   217ec:	eef1 1a04 	vmov.f32	s3, #20	; 0x40a00000  5.0
   217f0:	eeb0 1a68 	vmov.f32	s2, s17
   217f4:	f44f 7200 	mov.w	r2, #512	; 0x200
   217f8:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   217fc:	f009 f9ea 	bl	2abd4 <tADSR4_initToPool>
	for (int i = 0; i < NUM_STRINGS; i++)
   21800:	2c18      	cmp	r4, #24
   21802:	d1b6      	bne.n	21772 <SFXLivingStringSynthAlloc+0x92>
	tVZFilter_initToPool(&pluckFilt, BandpassPeak, 2000.0f, 4.0f, &smallPool);
   21804:	2300      	movs	r3, #0
   21806:	f64a 6290 	movw	r2, #44688	; 0xae90
   2180a:	f24e 7004 	movw	r0, #59140	; 0xe704
   2180e:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
   21812:	f2c4 43fa 	movt	r3, #17658	; 0x44fa
   21816:	f2c0 220f 	movt	r2, #527	; 0x20f
   2181a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2181e:	2103      	movs	r1, #3
   21820:	ee00 3a10 	vmov	s0, r3
   21824:	f00a f92a 	bl	2ba7c <tVZFilter_initToPool>
	tNoise_initToPool(&stringPluckNoise, WhiteNoise, &smallPool);
   21828:	f64a 6290 	movw	r2, #44688	; 0xae90
   2182c:	f24c 60ac 	movw	r0, #50860	; 0xc6ac
   21830:	2100      	movs	r1, #0
   21832:	f2c0 220f 	movt	r2, #527	; 0x20f
   21836:	f2c0 200f 	movt	r0, #527	; 0x20f
   2183a:	f00c fac5 	bl	2ddc8 <tNoise_initToPool>
	setLED_A(numVoices == 1);
   2183e:	f246 2354 	movw	r3, #25172	; 0x6254
   21842:	f2c0 0306 	movt	r3, #6
   21846:	7818      	ldrb	r0, [r3, #0]
   21848:	f1a0 0001 	sub.w	r0, r0, #1
   2184c:	fab0 f080 	clz	r0, r0
   21850:	0940      	lsrs	r0, r0, #5
   21852:	f7f9 fc6f 	bl	1b134 <setLED_A>
	setLED_B(voicePluck);
   21856:	f646 1380 	movw	r3, #27008	; 0x6980
   2185a:	f2c0 230e 	movt	r3, #526	; 0x20e
   2185e:	7818      	ldrb	r0, [r3, #0]
   21860:	f7f9 fc78 	bl	1b154 <setLED_B>
	setLED_C(levModeStr);
   21864:	7830      	ldrb	r0, [r6, #0]
   21866:	f7f9 fc85 	bl	1b174 <setLED_C>
	samplesPerMs = leaf.sampleRate / 1000.0f;
   2186a:	f241 236f 	movw	r3, #4719	; 0x126f
   2186e:	ed9b 7a00 	vldr	s14, [fp]
   21872:	f246 22b0 	movw	r2, #25264	; 0x62b0
   21876:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   2187a:	f2c0 0206 	movt	r2, #6
   2187e:	ee07 3a90 	vmov	s15, r3
   21882:	ee67 7a27 	vmul.f32	s15, s14, s15
   21886:	edc2 7a00 	vstr	s15, [r2]
}
   2188a:	ecbd 8b06 	vpop	{d8-d10}
   2188e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   21892:	bf00      	nop

00021894 <SFXLivingStringSynthFrame>:
{
   21894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   21898:	f64e 2a7c 	movw	sl, #60028	; 0xea7c
   2189c:	f2c0 2a0f 	movt	sl, #527	; 0x20f
{
   218a0:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   218a4:	f89a 4014 	ldrb.w	r4, [sl, #20]
{
   218a8:	b085      	sub	sp, #20
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   218aa:	2c01      	cmp	r4, #1
   218ac:	d11a      	bne.n	218e4 <SFXLivingStringSynthFrame+0x50>
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   218ae:	f246 2554 	movw	r5, #25172	; 0x6254
		tSimplePoly_setNumVoices(&poly, numVoices);
   218b2:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   218b6:	f2c0 0506 	movt	r5, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   218ba:	f2c0 200f 	movt	r0, #527	; 0x20f
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   218be:	7829      	ldrb	r1, [r5, #0]
   218c0:	2901      	cmp	r1, #1
   218c2:	bf98      	it	ls
   218c4:	2406      	movls	r4, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   218c6:	4621      	mov	r1, r4
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   218c8:	702c      	strb	r4, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   218ca:	f00c f905 	bl	2dad8 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   218ce:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   218d0:	2100      	movs	r1, #0
		setLED_A(numVoices == 1);
   218d2:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   218d6:	f88a 1014 	strb.w	r1, [sl, #20]
		setLED_A(numVoices == 1);
   218da:	fab0 f080 	clz	r0, r0
   218de:	0940      	lsrs	r0, r0, #5
   218e0:	f7f9 fc28 	bl	1b134 <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   218e4:	f89a 1018 	ldrb.w	r1, [sl, #24]
   218e8:	2901      	cmp	r1, #1
   218ea:	f000 81a9 	beq.w	21c40 <SFXLivingStringSynthFrame+0x3ac>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   218ee:	f89a 101c 	ldrb.w	r1, [sl, #28]
   218f2:	2901      	cmp	r1, #1
   218f4:	f000 8184 	beq.w	21c00 <SFXLivingStringSynthFrame+0x36c>
   218f8:	f24c 33d8 	movw	r3, #50136	; 0xc3d8
   218fc:	f2c0 230f 	movt	r3, #527	; 0x20f
   21900:	9301      	str	r3, [sp, #4]
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   21902:	f24d 0b54 	movw	fp, #53332	; 0xd054
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   21906:	2100      	movs	r1, #0
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   21908:	eeb2 6a04 	vmov.f32	s12, #36	; 0x41200000  10.0
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   2190c:	2300      	movs	r3, #0
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   2190e:	f2c0 2b0f 	movt	fp, #527	; 0x20f
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   21912:	f2c4 21ee 	movt	r1, #17134	; 0x42ee
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   21916:	9302      	str	r3, [sp, #8]
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   21918:	f64e 342c 	movw	r4, #60204	; 0xeb2c
   2191c:	4658      	mov	r0, fp
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   2191e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   21922:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   21926:	ee07 1a90 	vmov	s15, r1
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   2192a:	ecb0 7a01 	vldmia	r0!, {s14}
   2192e:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   21932:	eddb 6a03 	vldr	s13, [fp, #12]
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   21936:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   2193a:	ee27 7a06 	vmul.f32	s14, s14, s12
	displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
   2193e:	6800      	ldr	r0, [r0, #0]
	displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
   21940:	f8db 1008 	ldr.w	r1, [fp, #8]
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   21944:	eea6 0aa7 	vfma.f32	s0, s13, s15
	displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
   21948:	6060      	str	r0, [r4, #4]
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   2194a:	f645 4629 	movw	r6, #23593	; 0x5c29
   2194e:	9303      	str	r3, [sp, #12]
   21950:	f642 07f5 	movw	r7, #10485	; 0x28f5
	displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
   21954:	60a1      	str	r1, [r4, #8]
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   21956:	f647 29e1 	movw	r9, #31457	; 0x7ae1
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   2195a:	ed84 7a00 	vstr	s14, [r4]
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   2195e:	f00b fbb9 	bl	2d0d4 <faster_mtof>
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   21962:	ed9b 3a04 	vldr	s6, [fp, #16]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   21966:	eef2 7a01 	vmov.f32	s15, #33	; 0x41080000  8.5
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   2196a:	ed9b 4a05 	vldr	s8, [fp, #20]
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   2196e:	f2cc 268f 	movt	r6, #49807	; 0xc28f
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   21972:	ed84 0a03 	vstr	s0, [r4, #12]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   21976:	eeb9 0a01 	vmov.f32	s0, #145	; 0xc0880000 -4.250
   2197a:	ed9b 7a06 	vldr	s14, [fp, #24]
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   2197e:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   21982:	f6c3 77dc 	movt	r7, #16348	; 0x3fdc
   21986:	eeb7 3ac3 	vcvt.f64.f32	d3, s6
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   2198a:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
   2198e:	f6c3 79a4 	movt	r9, #16292	; 0x3fa4
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   21992:	eea7 0a27 	vfma.f32	s0, s14, s15
   21996:	f64d 1a90 	movw	sl, #55696	; 0xd990
   2199a:	f246 25b0 	movw	r5, #25264	; 0x62b0
   2199e:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   219a2:	f2c0 0506 	movt	r5, #6
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   219a6:	ed9d 6b02 	vldr	d6, [sp, #8]
   219aa:	ec47 6b15 	vmov	d5, r6, r7
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   219ae:	ec49 8b17 	vmov	d7, r8, r9
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   219b2:	eea3 6b05 	vfma.f64	d6, d3, d5
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   219b6:	2700      	movs	r7, #0
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   219b8:	eea4 7b05 	vfma.f64	d7, d4, d5
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   219bc:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
   219c0:	ed84 6a04 	vstr	s12, [r4, #16]
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   219c4:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   219c8:	ed84 7a05 	vstr	s14, [r4, #20]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   219cc:	f00b fa58 	bl	2ce80 <LEAF_tanh>
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   219d0:	f246 223c 	movw	r2, #25148	; 0x623c
   219d4:	eddb 7a09 	vldr	s15, [fp, #36]	; 0x24
   219d8:	f04f 438c 	mov.w	r3, #1174405120	; 0x46000000
   219dc:	f24d 31e4 	movw	r1, #54244	; 0xd3e4
   219e0:	f2c0 0206 	movt	r2, #6
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   219e4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   219e8:	ee06 3a90 	vmov	s13, r3
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   219ec:	f24e 1348 	movw	r3, #57672	; 0xe148
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   219f0:	edd2 5a00 	vldr	s11, [r2]
   219f4:	f2c0 210f 	movt	r1, #527	; 0x20f
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   219f8:	f6c3 737a 	movt	r3, #16250	; 0x3f7a
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   219fc:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   21a00:	ee67 7aa5 	vmul.f32	s15, s15, s11
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   21a04:	f24d 720a 	movw	r2, #55050	; 0xd70a
   21a08:	ee08 3a10 	vmov	s16, r3
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   21a0c:	ee30 0a07 	vadd.f32	s0, s0, s14
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   21a10:	f6c3 42a3 	movt	r2, #15523	; 0x3ca3
	displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
   21a14:	f8db 601c 	ldr.w	r6, [fp, #28]
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   21a18:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
   21a1c:	f8db 0020 	ldr.w	r0, [fp, #32]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   21a20:	ee20 0a06 	vmul.f32	s0, s0, s12
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   21a24:	ee08 2a90 	vmov	s17, r2
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   21a28:	f8dd 8004 	ldr.w	r8, [sp, #4]
   21a2c:	ee17 3a90 	vmov	r3, s15
	displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
   21a30:	61e6      	str	r6, [r4, #28]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   21a32:	ed84 0a06 	vstr	s0, [r4, #24]
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   21a36:	eb01 0183 	add.w	r1, r1, r3, lsl #2
	displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
   21a3a:	6220      	str	r0, [r4, #32]
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   21a3c:	edd1 7a00 	vldr	s15, [r1]
   21a40:	ee67 7aa6 	vmul.f32	s15, s15, s13
   21a44:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   21a48:	eeb0 0a48 	vmov.f32	s0, s16
   21a4c:	edd4 7a02 	vldr	s15, [r4, #8]
   21a50:	eb08 0607 	add.w	r6, r8, r7
   21a54:	eea7 0aa8 	vfma.f32	s0, s15, s17
   21a58:	4630      	mov	r0, r6
   21a5a:	f00c fc11 	bl	2e280 <tComplexLivingString_setDecay>
		tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   21a5e:	4630      	mov	r0, r6
   21a60:	ed94 0a03 	vldr	s0, [r4, #12]
   21a64:	f00c fbec 	bl	2e240 <tComplexLivingString_setDampFreq>
		tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   21a68:	4630      	mov	r0, r6
   21a6a:	ed94 0a04 	vldr	s0, [r4, #16]
   21a6e:	f00c fbb9 	bl	2e1e4 <tComplexLivingString_setPickPos>
		tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   21a72:	4630      	mov	r0, r6
   21a74:	ed94 0a05 	vldr	s0, [r4, #20]
   21a78:	f00c fbc4 	bl	2e204 <tComplexLivingString_setPrepPos>
		tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   21a7c:	4630      	mov	r0, r6
   21a7e:	ed94 0a06 	vldr	s0, [r4, #24]
   21a82:	f00c fbcf 	bl	2e224 <tComplexLivingString_setPrepIndex>
		tSlide_setDownSlide(&stringOutEnvs[i], displayValues[9] * samplesPerMs);
   21a86:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   21a8a:	edd5 7a00 	vldr	s15, [r5]
   21a8e:	eb0a 0007 	add.w	r0, sl, r7
   21a92:	3704      	adds	r7, #4
   21a94:	ee20 0a27 	vmul.f32	s0, s0, s15
   21a98:	f009 fcd2 	bl	2b440 <tSlide_setDownSlide>
	for (int i = 0; i < NUM_STRINGS; i++)
   21a9c:	2f18      	cmp	r7, #24
   21a9e:	d1d3      	bne.n	21a48 <SFXLivingStringSynthFrame+0x1b4>
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   21aa0:	2300      	movs	r3, #0
   21aa2:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21aa6:	f64a 22ab 	movw	r2, #43691	; 0xaaab
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   21aaa:	ed94 7a01 	vldr	s14, [r4, #4]
   21aae:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21ab2:	2500      	movs	r5, #0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21ab4:	f6c2 22aa 	movt	r2, #10922	; 0x2aaa
   21ab8:	f24d 1ba4 	movw	fp, #53668	; 0xd1a4
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   21abc:	ee07 3a90 	vmov	s15, r3
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21ac0:	f64d 07bc 	movw	r7, #55484	; 0xd8bc
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21ac4:	9202      	str	r2, [sp, #8]
   21ac6:	f2c0 2b0f 	movt	fp, #527	; 0x20f
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   21aca:	eea7 0a27 	vfma.f32	s0, s14, s15
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21ace:	462e      	mov	r6, r5
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   21ad0:	f00b fb00 	bl	2d0d4 <faster_mtof>
   21ad4:	f24e 7004 	movw	r0, #59140	; 0xe704
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21ad8:	f2c0 270f 	movt	r7, #527	; 0x20f
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   21adc:	ee08 5a90 	vmov	s17, r5
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   21ae0:	f2c0 200f 	movt	r0, #527	; 0x20f
   21ae4:	f00a fa4e 	bl	2bf84 <tVZFilter_setFreq>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21ae8:	e01e      	b.n	21b28 <SFXLivingStringSynthFrame+0x294>
			tComplexLivingString_setTargetLev(&theString[i],voiceOn * displayValues[8]);
   21aea:	ed94 0a08 	vldr	s0, [r4, #32]
   21aee:	ee28 0a00 	vmul.f32	s0, s16, s0
   21af2:	f00c fbc9 	bl	2e288 <tComplexLivingString_setTargetLev>
		if (voiceOn)
   21af6:	eeb5 8a40 	vcmp.f32	s16, #0.0
   21afa:	f64d 2358 	movw	r3, #55896	; 0xda58
   21afe:	eb0a 0205 	add.w	r2, sl, r5
			tSlide_setDest(&stringOutEnvs[i], 1.0f);
   21b02:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   21b06:	f2c0 230f 	movt	r3, #527	; 0x20f
		if (voiceOn)
   21b0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			tSlide_setDest(&stringOutEnvs[i], 1.0f);
   21b0e:	4610      	mov	r0, r2
   21b10:	eb05 0803 	add.w	r8, r5, r3
		if (voiceOn)
   21b14:	d065      	beq.n	21be2 <SFXLivingStringSynthFrame+0x34e>
			tSlide_setDest(&stringOutEnvs[i], 1.0f);
   21b16:	f009 fc9b 	bl	2b450 <tSlide_setDest>
			tSlide_setDest(&stringInEnvs[i], 1.0f);
   21b1a:	4640      	mov	r0, r8
   21b1c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   21b20:	f009 fc96 	bl	2b450 <tSlide_setDest>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21b24:	3601      	adds	r6, #1
   21b26:	3504      	adds	r5, #4
   21b28:	9b01      	ldr	r3, [sp, #4]
   21b2a:	4638      	mov	r0, r7
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b2c:	fa5f f986 	uxtb.w	r9, r6
   21b30:	eb03 0805 	add.w	r8, r3, r5
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21b34:	f00b ffd8 	bl	2dae8 <tSimplePoly_getNumVoices>
   21b38:	42b0      	cmp	r0, r6
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b3a:	4649      	mov	r1, r9
   21b3c:	4638      	mov	r0, r7
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   21b3e:	dd5a      	ble.n	21bf6 <SFXLivingStringSynthFrame+0x362>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b40:	f00b ffee 	bl	2db20 <tSimplePoly_getPitch>
   21b44:	f646 1240 	movw	r2, #26944	; 0x6940
   21b48:	ee07 0a90 	vmov	s15, r0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21b4c:	f646 13b8 	movw	r3, #27064	; 0x69b8
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b50:	f2c0 220e 	movt	r2, #526	; 0x20e
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   21b54:	f646 1184 	movw	r1, #27012	; 0x6984
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b58:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21b5c:	f2c0 230e 	movt	r3, #526	; 0x20e
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b60:	ed92 0a00 	vldr	s0, [r2]
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   21b64:	f2c0 210e 	movt	r1, #526	; 0x20e
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21b68:	781a      	ldrb	r2, [r3, #0]
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   21b6a:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   21b6e:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   21b72:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   21b76:	ee17 3a90 	vmov	r3, s15
   21b7a:	1a9b      	subs	r3, r3, r2
   21b7c:	9a02      	ldr	r2, [sp, #8]
   21b7e:	fb82 2003 	smull	r2, r0, r2, r3
   21b82:	17da      	asrs	r2, r3, #31
   21b84:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   21b88:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   21b8c:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   21b90:	ee07 3a90 	vmov	s15, r3
   21b94:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   21b98:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   21b9c:	ee17 3a90 	vmov	r3, s15
   21ba0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   21ba4:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   21ba8:	ee37 0a00 	vadd.f32	s0, s14, s0
   21bac:	f00b fa00 	bl	2cfb0 <LEAF_midiToFrequency>
		tComplexLivingString_setFreq(&theString[i], freq[i]);
   21bb0:	4640      	mov	r0, r8
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   21bb2:	ecab 0a01 	vstmia	fp!, {s0}
		tComplexLivingString_setFreq(&theString[i], freq[i]);
   21bb6:	f00c faf9 	bl	2e1ac <tComplexLivingString_setFreq>
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   21bba:	4649      	mov	r1, r9
   21bbc:	4638      	mov	r0, r7
   21bbe:	f00b ffbb 	bl	2db38 <tSimplePoly_getVelocity>
		if (levModeStr)
   21bc2:	f646 130c 	movw	r3, #26892	; 0x690c
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   21bc6:	2800      	cmp	r0, #0
			tComplexLivingString_setTargetLev(&theString[i],1.0f);
   21bc8:	eeb0 0a48 	vmov.f32	s0, s16
		if (levModeStr)
   21bcc:	f2c0 230e 	movt	r3, #526	; 0x20e
			tComplexLivingString_setTargetLev(&theString[i],1.0f);
   21bd0:	4640      	mov	r0, r8
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   21bd2:	fe38 8a28 	vselgt.f32	s16, s16, s17
		if (levModeStr)
   21bd6:	681b      	ldr	r3, [r3, #0]
   21bd8:	2b00      	cmp	r3, #0
   21bda:	d186      	bne.n	21aea <SFXLivingStringSynthFrame+0x256>
			tComplexLivingString_setTargetLev(&theString[i],1.0f);
   21bdc:	f00c fb54 	bl	2e288 <tComplexLivingString_setTargetLev>
   21be0:	e789      	b.n	21af6 <SFXLivingStringSynthFrame+0x262>
			tSlide_setDest(&stringOutEnvs[i], displayValues[7]);
   21be2:	ed94 0a07 	vldr	s0, [r4, #28]
   21be6:	f009 fc33 	bl	2b450 <tSlide_setDest>
			tSlide_setDest(&stringInEnvs[i], 0.0f);
   21bea:	eeb0 0a68 	vmov.f32	s0, s17
   21bee:	4640      	mov	r0, r8
   21bf0:	f009 fc2e 	bl	2b450 <tSlide_setDest>
   21bf4:	e796      	b.n	21b24 <SFXLivingStringSynthFrame+0x290>
}
   21bf6:	b005      	add	sp, #20
   21bf8:	ecbd 8b02 	vpop	{d8}
   21bfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		levModeStr = !levModeStr;
   21c00:	f646 140c 	movw	r4, #26892	; 0x690c
   21c04:	f24c 33d8 	movw	r3, #50136	; 0xc3d8
   21c08:	f2c0 240e 	movt	r4, #526	; 0x20e
   21c0c:	f2c0 230f 	movt	r3, #527	; 0x20f
   21c10:	6821      	ldr	r1, [r4, #0]
   21c12:	461d      	mov	r5, r3
   21c14:	9301      	str	r3, [sp, #4]
   21c16:	f103 0b18 	add.w	fp, r3, #24
   21c1a:	fab1 f181 	clz	r1, r1
   21c1e:	0949      	lsrs	r1, r1, #5
   21c20:	6021      	str	r1, [r4, #0]
   21c22:	e000      	b.n	21c26 <SFXLivingStringSynthFrame+0x392>
   21c24:	6821      	ldr	r1, [r4, #0]
			tComplexLivingString_setLevMode(&theString[i], levModeStr);
   21c26:	4628      	mov	r0, r5
   21c28:	3504      	adds	r5, #4
   21c2a:	f00c fb41 	bl	2e2b0 <tComplexLivingString_setLevMode>
		for (int i = 0; i < NUM_STRINGS; i++)
   21c2e:	45ab      	cmp	fp, r5
   21c30:	d1f8      	bne.n	21c24 <SFXLivingStringSynthFrame+0x390>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   21c32:	2100      	movs	r1, #0
		setLED_C(levModeStr);
   21c34:	7820      	ldrb	r0, [r4, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   21c36:	f88a 101c 	strb.w	r1, [sl, #28]
		setLED_C(levModeStr);
   21c3a:	f7f9 fa9b 	bl	1b174 <setLED_C>
   21c3e:	e660      	b.n	21902 <SFXLivingStringSynthFrame+0x6e>
		voicePluck = !voicePluck;
   21c40:	f646 1480 	movw	r4, #27008	; 0x6980
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   21c44:	2100      	movs	r1, #0
		voicePluck = !voicePluck;
   21c46:	f2c0 240e 	movt	r4, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   21c4a:	f88a 1018 	strb.w	r1, [sl, #24]
		voicePluck = !voicePluck;
   21c4e:	6821      	ldr	r1, [r4, #0]
   21c50:	fab1 f181 	clz	r1, r1
   21c54:	0949      	lsrs	r1, r1, #5
		setLED_B(voicePluck);
   21c56:	4608      	mov	r0, r1
		voicePluck = !voicePluck;
   21c58:	6021      	str	r1, [r4, #0]
		setLED_B(voicePluck);
   21c5a:	f7f9 fa7b 	bl	1b154 <setLED_B>
   21c5e:	e646      	b.n	218ee <SFXLivingStringSynthFrame+0x5a>

00021c60 <SFXLivingStringSynthTick>:
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   21c60:	f64e 332c 	movw	r3, #60204	; 0xeb2c
{
   21c64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21c68:	4606      	mov	r6, r0
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   21c6a:	f24c 60ac 	movw	r0, #50860	; 0xc6ac
   21c6e:	f2c0 230f 	movt	r3, #527	; 0x20f
   21c72:	f646 1a80 	movw	sl, #27008	; 0x6980
   21c76:	f2c0 200f 	movt	r0, #527	; 0x20f
   21c7a:	f24d 79a8 	movw	r9, #55208	; 0xd7a8
   21c7e:	f64d 1890 	movw	r8, #55696	; 0xd990
   21c82:	f24c 37d8 	movw	r7, #50136	; 0xc3d8
   21c86:	f2c0 2a0e 	movt	sl, #526	; 0x20e
   21c8a:	f2c0 290f 	movt	r9, #527	; 0x20f
   21c8e:	f2c0 280f 	movt	r8, #527	; 0x20f
   21c92:	f2c0 270f 	movt	r7, #527	; 0x20f
{
   21c96:	ed2d 8b06 	vpush	{d8-d10}
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   21c9a:	ed93 8a00 	vldr	s16, [r3]
   21c9e:	f00c f8a9 	bl	2ddf4 <tNoise_tick>
	pluck = tVZFilter_tick(&pluckFilt, pluck);
   21ca2:	f24e 7004 	movw	r0, #59140	; 0xe704
   21ca6:	ee28 0a00 	vmul.f32	s0, s16, s0
   21caa:	f2c0 200f 	movt	r0, #527	; 0x20f
   21cae:	f00a f8f9 	bl	2bea4 <tVZFilter_tick>
	float sample = 0.0f;
   21cb2:	2300      	movs	r3, #0
	pluck = tVZFilter_tick(&pluckFilt, pluck);
   21cb4:	eeb0 aa40 	vmov.f32	s20, s0
   21cb8:	461c      	mov	r4, r3
	float sample = 0.0f;
   21cba:	ee09 3a10 	vmov	s18, r3
		inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
   21cbe:	edda 7a00 	vldr	s15, [sl]
   21cc2:	eb09 0004 	add.w	r0, r9, r4
   21cc6:	edd6 9a01 	vldr	s19, [r6, #4]
   21cca:	eb08 0504 	add.w	r5, r8, r4
   21cce:	eef8 8ae7 	vcvt.f32.s32	s17, s15
   21cd2:	f009 f83b 	bl	2ad4c <tADSR4_tick>
   21cd6:	ee20 8a0a 	vmul.f32	s16, s0, s20
		sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   21cda:	4628      	mov	r0, r5
   21cdc:	f009 fbbc 	bl	2b458 <tSlide_tickNoInput>
   21ce0:	1938      	adds	r0, r7, r4
   21ce2:	3404      	adds	r4, #4
		inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
   21ce4:	eea9 8aa8 	vfma.f32	s16, s19, s17
		sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   21ce8:	ee20 0a08 	vmul.f32	s0, s0, s16
   21cec:	f00c faf6 	bl	2e2dc <tComplexLivingString_tick>
   21cf0:	4628      	mov	r0, r5
   21cf2:	eeb0 8a40 	vmov.f32	s16, s0
   21cf6:	f009 fbaf 	bl	2b458 <tSlide_tickNoInput>
	for (int i = 0; i < NUM_STRINGS; i++)
   21cfa:	2c18      	cmp	r4, #24
		sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   21cfc:	eea8 9a00 	vfma.f32	s18, s16, s0
	for (int i = 0; i < NUM_STRINGS; i++)
   21d00:	d1dd      	bne.n	21cbe <SFXLivingStringSynthTick+0x5e>
	sample *= 0.1625f;
   21d02:	f246 6366 	movw	r3, #26214	; 0x6666
   21d06:	f6c3 6326 	movt	r3, #15910	; 0x3e26
   21d0a:	ee00 3a10 	vmov	s0, r3
	sample = LEAF_tanh(sample) * 0.98f;
   21d0e:	ee29 0a00 	vmul.f32	s0, s18, s0
   21d12:	f00b f8b5 	bl	2ce80 <LEAF_tanh>
   21d16:	f24e 1348 	movw	r3, #57672	; 0xe148
   21d1a:	f6c3 737a 	movt	r3, #16250	; 0x3f7a
   21d1e:	ee07 3a90 	vmov	s15, r3
   21d22:	ee20 0a27 	vmul.f32	s0, s0, s15
	input[0] = sample;
   21d26:	ed86 0a00 	vstr	s0, [r6]
	input[1] = sample;
   21d2a:	ed86 0a01 	vstr	s0, [r6, #4]
}
   21d2e:	ecbd 8b06 	vpop	{d8-d10}
   21d32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   21d36:	bf00      	nop

00021d38 <SFXLivingStringSynthFree>:
{
   21d38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21d3c:	f24c 38d8 	movw	r8, #50136	; 0xc3d8
   21d40:	f64d 2758 	movw	r7, #55896	; 0xda58
   21d44:	f64d 1690 	movw	r6, #55696	; 0xd990
   21d48:	f24d 75a8 	movw	r5, #55208	; 0xd7a8
   21d4c:	f2c0 280f 	movt	r8, #527	; 0x20f
   21d50:	f2c0 270f 	movt	r7, #527	; 0x20f
   21d54:	f2c0 260f 	movt	r6, #527	; 0x20f
   21d58:	f2c0 250f 	movt	r5, #527	; 0x20f
   21d5c:	2400      	movs	r4, #0
		tComplexLivingString_free(&theString[i]);
   21d5e:	eb08 0004 	add.w	r0, r8, r4
   21d62:	f00c f9d7 	bl	2e114 <tComplexLivingString_free>
		tSlide_free(&stringInEnvs[i]);
   21d66:	1938      	adds	r0, r7, r4
   21d68:	f009 fb66 	bl	2b438 <tSlide_free>
		tSlide_free(&stringOutEnvs[i]);
   21d6c:	1930      	adds	r0, r6, r4
   21d6e:	f009 fb63 	bl	2b438 <tSlide_free>
		tADSR4_free(&pluckEnvs[i]);
   21d72:	1928      	adds	r0, r5, r4
   21d74:	3404      	adds	r4, #4
   21d76:	f008 ff87 	bl	2ac88 <tADSR4_free>
	for (int i = 0; i < NUM_STRINGS; i++)
   21d7a:	2c18      	cmp	r4, #24
   21d7c:	d1ef      	bne.n	21d5e <SFXLivingStringSynthFree+0x26>
	tVZFilter_free(&pluckFilt);
   21d7e:	f24e 7004 	movw	r0, #59140	; 0xe704
   21d82:	f2c0 200f 	movt	r0, #527	; 0x20f
   21d86:	f00a f87f 	bl	2be88 <tVZFilter_free>
	tNoise_free(&stringPluckNoise);
   21d8a:	f24c 60ac 	movw	r0, #50860	; 0xc6ac
}
   21d8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	tNoise_free(&stringPluckNoise);
   21d92:	f2c0 200f 	movt	r0, #527	; 0x20f
   21d96:	f00c b829 	b.w	2ddec <tNoise_free>
   21d9a:	bf00      	nop

00021d9c <SFXClassicSynthAlloc>:
	tSimplePoly_setNumVoices(&poly, numVoices);
   21d9c:	f246 2254 	movw	r2, #25172	; 0x6254
   21da0:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
	leaf.clearOnAllocation = 1;
   21da4:	2301      	movs	r3, #1
	tSimplePoly_setNumVoices(&poly, numVoices);
   21da6:	f2c0 0206 	movt	r2, #6
   21daa:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   21dae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	leaf.clearOnAllocation = 1;
   21db2:	f64f 0a08 	movw	sl, #63496	; 0xf808
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   21db6:	f04f 478b 	mov.w	r7, #1166016512	; 0x45800000
	displayValues[0] = knobs[0]; //synth volume
   21dba:	f64e 352c 	movw	r5, #60204	; 0xeb2c
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   21dbe:	f04f 0800 	mov.w	r8, #0
	leaf.clearOnAllocation = 1;
   21dc2:	f2c0 2a0f 	movt	sl, #527	; 0x20f
	displayValues[0] = knobs[0]; //synth volume
   21dc6:	f2c0 250f 	movt	r5, #527	; 0x20f
	leaf.clearOnAllocation = 1;
   21dca:	f8ca 3014 	str.w	r3, [sl, #20]
{
   21dce:	ed2d 8b08 	vpush	{d8-d11}
   21dd2:	b089      	sub	sp, #36	; 0x24
	tSimplePoly_setNumVoices(&poly, numVoices);
   21dd4:	7811      	ldrb	r1, [r2, #0]
   21dd6:	9207      	str	r2, [sp, #28]
   21dd8:	f00b fe7e 	bl	2dad8 <tSimplePoly_setNumVoices>
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21ddc:	f246 213c 	movw	r1, #25148	; 0x623c
	displayValues[0] = knobs[0]; //synth volume
   21de0:	f24d 03b8 	movw	r3, #53432	; 0xd0b8
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21de4:	f64c 40cd 	movw	r0, #52429	; 0xcccd
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21de8:	f24d 32e4 	movw	r2, #54244	; 0xd3e4
	displayValues[0] = knobs[0]; //synth volume
   21dec:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21df0:	f2c0 0106 	movt	r1, #6
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21df4:	f6c3 60cc 	movt	r0, #16076	; 0x3ecc
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21df8:	f2c0 220f 	movt	r2, #527	; 0x20f
   21dfc:	edd1 7a00 	vldr	s15, [r1]
	displayValues[0] = knobs[0]; //synth volume
   21e00:	469c      	mov	ip, r3
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e02:	ed93 6a0a 	vldr	s12, [r3, #40]	; 0x28
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21e06:	ee09 0a90 	vmov	s19, r0
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e0a:	ed93 5a05 	vldr	s10, [r3, #20]
   21e0e:	f04f 418c 	mov.w	r1, #1174405120	; 0x46000000
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e12:	edd3 5a06 	vldr	s11, [r3, #24]
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e16:	ee27 6a86 	vmul.f32	s12, s15, s12
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21e1a:	ed93 7a08 	vldr	s14, [r3, #32]
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e1e:	ee27 5a85 	vmul.f32	s10, s15, s10
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e22:	edd3 6a0b 	vldr	s13, [r3, #44]	; 0x2c
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e26:	ee67 5aa5 	vmul.f32	s11, s15, s11
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21e2a:	ee27 7a87 	vmul.f32	s14, s15, s14
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21e2e:	edd3 4a04 	vldr	s9, [r3, #16]
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e32:	ee67 6aa6 	vmul.f32	s13, s15, s13
	displayValues[0] = knobs[0]; //synth volume
   21e36:	f85c 9b04 	ldr.w	r9, [ip], #4
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e3a:	eebd 6ac6 	vcvt.s32.f32	s12, s12
	displayValues[2] = knobs[2]; //keyfollow filter cutoff
   21e3e:	f8d3 b008 	ldr.w	fp, [r3, #8]
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e42:	eebd 5ac5 	vcvt.s32.f32	s10, s10
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   21e46:	ed9c 4a00 	vldr	s8, [ip]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e4a:	eefd 5ae5 	vcvt.s32.f32	s11, s11
	displayValues[7] = knobs[7]; //sus
   21e4e:	f8d3 c01c 	ldr.w	ip, [r3, #28]
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21e52:	eebd 7ac7 	vcvt.s32.f32	s14, s14
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e56:	ee16 0a10 	vmov	r0, s12
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e5a:	eefd 6ae6 	vcvt.s32.f32	s13, s13
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e5e:	ee15 ea10 	vmov	lr, s10
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21e62:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e66:	ee15 6a90 	vmov	r6, s11
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21e6a:	eef0 3a69 	vmov.f32	s7, s19
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21e6e:	ee17 4a10 	vmov	r4, s14
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e72:	ee07 1a10 	vmov	s14, r1
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e76:	ee16 1a90 	vmov	r1, s13
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e7a:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
	displayValues[12] = knobs[12]; //sus
   21e7e:	ed93 3a0c 	vldr	s6, [r3, #48]	; 0x30
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e82:	eb02 0686 	add.w	r6, r2, r6, lsl #2
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21e86:	eee4 3a86 	vfma.f32	s7, s9, s12
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21e8a:	eb02 0484 	add.w	r4, r2, r4, lsl #2
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   21e8e:	ee06 7a10 	vmov	s12, r7
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e92:	eb02 0080 	add.w	r0, r2, r0, lsl #2
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21e96:	edde 6a00 	vldr	s13, [lr]
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e9a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21e9e:	edd6 4a00 	vldr	s9, [r6]
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21ea2:	ed94 5a00 	vldr	s10, [r4]
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   21ea6:	ee24 4a06 	vmul.f32	s8, s8, s12
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21eaa:	edd0 5a00 	vldr	s11, [r0]
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21eae:	ee66 6a87 	vmul.f32	s13, s13, s14
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21eb2:	ed91 6a00 	vldr	s12, [r1]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21eb6:	ee64 4a87 	vmul.f32	s9, s9, s14
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21eba:	ee65 5a87 	vmul.f32	s11, s11, s14
	displayValues[9] = knobs[9]; //leak
   21ebe:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21ec0:	ee26 6a07 	vmul.f32	s12, s12, s14
	displayValues[3] = knobs[3]; //detune
   21ec4:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21ec8:	ee25 5a07 	vmul.f32	s10, s10, s14
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   21ecc:	edc5 6a05 	vstr	s13, [r5, #20]
	displayValues[7] = knobs[7]; //sus
   21ed0:	f8c5 c01c 	str.w	ip, [r5, #28]
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21ed4:	f244 40d0 	movw	r0, #17616	; 0x44d0
	displayValues[9] = knobs[9]; //leak
   21ed8:	626f      	str	r7, [r5, #36]	; 0x24
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   21eda:	f44f 4170 	mov.w	r1, #61440	; 0xf000
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21ede:	ed85 6a0b 	vstr	s12, [r5, #44]	; 0x2c
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21ee2:	f6cb 4058 	movt	r0, #48216	; 0xbc58
	displayValues[0] = knobs[0]; //synth volume
   21ee6:	f8c5 9000 	str.w	r9, [r5]
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   21eea:	f2c4 517f 	movt	r1, #17791	; 0x457f
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   21eee:	ed85 4a01 	vstr	s8, [r5, #4]
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21ef2:	ee0a 0a90 	vmov	s21, r0
	displayValues[2] = knobs[2]; //keyfollow filter cutoff
   21ef6:	f8c5 b008 	str.w	fp, [r5, #8]
   21efa:	f64b 40b0 	movw	r0, #48304	; 0xbcb0
	displayValues[3] = knobs[3]; //detune
   21efe:	f8c5 e00c 	str.w	lr, [r5, #12]
   21f02:	f24d 667c 	movw	r6, #54908	; 0xd67c
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   21f06:	edc5 3a04 	vstr	s7, [r5, #16]
   21f0a:	f2c0 200f 	movt	r0, #527	; 0x20f
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   21f0e:	edc5 4a06 	vstr	s9, [r5, #24]
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   21f12:	ee06 1a90 	vmov	s13, r1
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f16:	ed85 5a08 	vstr	s10, [r5, #32]
   21f1a:	f2c0 260f 	movt	r6, #527	; 0x20f
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   21f1e:	edc5 5a0a 	vstr	s11, [r5, #40]	; 0x28
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21f22:	f244 44d0 	movw	r4, #17616	; 0x44d0
	displayValues[12] = knobs[12]; //sus
   21f26:	ed85 3a0c 	vstr	s6, [r5, #48]	; 0x30
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   21f2a:	f649 119a 	movw	r1, #39322	; 0x999a
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f2e:	edd3 5a0d 	vldr	s11, [r3, #52]	; 0x34
   21f32:	f24c 5cb0 	movw	ip, #50608	; 0xc5b0
   21f36:	9004      	str	r0, [sp, #16]
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21f38:	f6c3 44d8 	movt	r4, #15576	; 0x3cd8
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f3c:	ee67 7aa5 	vmul.f32	s15, s15, s11
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   21f40:	f6c3 6199 	movt	r1, #16025	; 0x3e99
   21f44:	9600      	str	r6, [sp, #0]
   21f46:	4666      	mov	r6, ip
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21f48:	ee0b 4a10 	vmov	s22, r4
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   21f4c:	ee0a 1a10 	vmov	s20, r1
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f50:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   21f54:	f2c0 260f 	movt	r6, #527	; 0x20f
   21f58:	f24d 1480 	movw	r4, #53632	; 0xd180
   21f5c:	f24e 619c 	movw	r1, #59036	; 0xe69c
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   21f60:	ed93 6a0f 	vldr	s12, [r3, #60]	; 0x3c
   21f64:	f64d 2738 	movw	r7, #55864	; 0xda38
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f68:	ee17 0a90 	vmov	r0, s15
   21f6c:	f2c0 240f 	movt	r4, #527	; 0x20f
   21f70:	f2c0 210f 	movt	r1, #527	; 0x20f
   21f74:	9601      	str	r6, [sp, #4]
   21f76:	eb02 0280 	add.w	r2, r2, r0, lsl #2
			tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   21f7a:	f64a 6690 	movw	r6, #44688	; 0xae90
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   21f7e:	ee66 6a26 	vmul.f32	s13, s12, s13
   21f82:	9405      	str	r4, [sp, #20]
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f84:	edd2 7a00 	vldr	s15, [r2]
		tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   21f88:	f64d 42d8 	movw	r2, #56536	; 0xdcd8
   21f8c:	f2c0 270f 	movt	r7, #527	; 0x20f
   21f90:	9103      	str	r1, [sp, #12]
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21f92:	ee27 7a87 	vmul.f32	s14, s15, s14
	displayValues[14] = knobs[14]; //leak
   21f96:	6b99      	ldr	r1, [r3, #56]	; 0x38
		tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   21f98:	f2c0 220f 	movt	r2, #527	; 0x20f
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   21f9c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   21f9e:	4644      	mov	r4, r8
			tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   21fa0:	f2c0 260f 	movt	r6, #527	; 0x20f
   21fa4:	9702      	str	r7, [sp, #8]
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   21fa6:	edc5 6a0f 	vstr	s13, [r5, #60]	; 0x3c
	displayValues[14] = knobs[14]; //leak
   21faa:	63a9      	str	r1, [r5, #56]	; 0x38
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   21fac:	642b      	str	r3, [r5, #64]	; 0x40
		tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   21fae:	9206      	str	r2, [sp, #24]
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   21fb0:	ed85 7a0d 	vstr	s14, [r5, #52]	; 0x34
   21fb4:	9b03      	ldr	r3, [sp, #12]
   21fb6:	f104 090c 	add.w	r9, r4, #12
   21fba:	191f      	adds	r7, r3, r4
			tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   21fbc:	9b00      	ldr	r3, [sp, #0]
   21fbe:	4631      	mov	r1, r6
   21fc0:	1918      	adds	r0, r3, r4
   21fc2:	f00b fe49 	bl	2dc58 <tSawtooth_initToPool>
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21fc6:	f8da 2010 	ldr.w	r2, [sl, #16]
   21fca:	4790      	blx	r2
   21fcc:	eef0 7a6a 	vmov.f32	s15, s21
   21fd0:	9b01      	ldr	r3, [sp, #4]
			tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   21fd2:	4631      	mov	r1, r6
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21fd4:	eee0 7a0b 	vfma.f32	s15, s0, s22
   21fd8:	eb03 0b04 	add.w	fp, r3, r4
   21fdc:	3404      	adds	r4, #4
			tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   21fde:	4658      	mov	r0, fp
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   21fe0:	ece7 7a01 	vstmia	r7!, {s15}
			tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   21fe4:	f007 fc0c 	bl	29800 <tRosenbergGlottalPulse_initToPool>
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   21fe8:	eeb0 0a4a 	vmov.f32	s0, s20
   21fec:	4658      	mov	r0, fp
   21fee:	f007 fd0d 	bl	29a0c <tRosenbergGlottalPulse_setOpenLength>
			tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.4f);
   21ff2:	eeb0 0a69 	vmov.f32	s0, s19
   21ff6:	4658      	mov	r0, fp
   21ff8:	f007 fd16 	bl	29a28 <tRosenbergGlottalPulse_setPulseLength>
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   21ffc:	454c      	cmp	r4, r9
   21ffe:	d1dd      	bne.n	21fbc <SFXClassicSynthAlloc+0x220>
   22000:	9b02      	ldr	r3, [sp, #8]
		tEfficientSVF_initToPool(&synthLP[i], SVFTypeLowpass, 6000.0f, displayValues[4], &smallPool);
   22002:	f241 7270 	movw	r2, #6000	; 0x1770
   22006:	9805      	ldr	r0, [sp, #20]
   22008:	2101      	movs	r1, #1
   2200a:	eb03 0908 	add.w	r9, r3, r8
   2200e:	ed95 0a04 	vldr	s0, [r5, #16]
   22012:	4440      	add	r0, r8
   22014:	4633      	mov	r3, r6
   22016:	f009 fbfb 	bl	2b810 <tEfficientSVF_initToPool>
		tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   2201a:	f8dd b018 	ldr.w	fp, [sp, #24]
   2201e:	edd5 1a08 	vldr	s3, [r5, #32]
   22022:	4648      	mov	r0, r9
   22024:	4659      	mov	r1, fp
   22026:	ed95 1a07 	vldr	s2, [r5, #28]
   2202a:	edd5 0a06 	vldr	s1, [r5, #24]
   2202e:	4633      	mov	r3, r6
   22030:	f44f 7200 	mov.w	r2, #512	; 0x200
   22034:	ed95 0a05 	vldr	s0, [r5, #20]
		tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   22038:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   2203c:	9f04      	ldr	r7, [sp, #16]
		tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   2203e:	f008 fdc9 	bl	2abd4 <tADSR4_initToPool>
		tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   22042:	f24b 7217 	movw	r2, #46871	; 0xb717
   22046:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
   2204a:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
   2204e:	f6c3 0251 	movt	r2, #14417	; 0x3851
   22052:	4447      	add	r7, r8
   22054:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
   22058:	ee78 7a67 	vsub.f32	s15, s16, s15
   2205c:	ee09 2a10 	vmov	s18, r2
   22060:	4648      	mov	r0, r9
   22062:	ee00 3a10 	vmov	s0, r3
   22066:	ee08 3a90 	vmov	s17, r3
   2206a:	f108 0804 	add.w	r8, r8, #4
   2206e:	eea7 0a89 	vfma.f32	s0, s15, s18
   22072:	f008 fe4d 	bl	2ad10 <tADSR4_setLeakFactor>
		tADSR4_initToPool(&polyFiltEnvs[i], displayValues[10], displayValues[11], displayValues[12], displayValues[13], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22076:	4638      	mov	r0, r7
   22078:	4633      	mov	r3, r6
   2207a:	f44f 7200 	mov.w	r2, #512	; 0x200
   2207e:	4659      	mov	r1, fp
   22080:	edd5 1a0d 	vldr	s3, [r5, #52]	; 0x34
   22084:	ed95 1a0c 	vldr	s2, [r5, #48]	; 0x30
   22088:	edd5 0a0b 	vldr	s1, [r5, #44]	; 0x2c
   2208c:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
   22090:	f008 fda0 	bl	2abd4 <tADSR4_initToPool>
		tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   22094:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
   22098:	eeb0 0a68 	vmov.f32	s0, s17
   2209c:	4638      	mov	r0, r7
   2209e:	ee38 8a67 	vsub.f32	s16, s16, s15
   220a2:	eea8 0a09 	vfma.f32	s0, s16, s18
   220a6:	f008 fe33 	bl	2ad10 <tADSR4_setLeakFactor>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   220aa:	f1b8 0f20 	cmp.w	r8, #32
   220ae:	d181      	bne.n	21fb4 <SFXClassicSynthAlloc+0x218>
	tCycle_initToPool(&pwmLFO1, &smallPool);
   220b0:	f64a 6190 	movw	r1, #44688	; 0xae90
   220b4:	f64d 2028 	movw	r0, #55848	; 0xda28
   220b8:	f2c0 210f 	movt	r1, #527	; 0x20f
   220bc:	f2c0 200f 	movt	r0, #527	; 0x20f
   220c0:	f00b fd4a 	bl	2db58 <tCycle_initToPool>
	tCycle_initToPool(&pwmLFO2, &smallPool);
   220c4:	f64a 6190 	movw	r1, #44688	; 0xae90
   220c8:	f64d 300c 	movw	r0, #56076	; 0xdb0c
   220cc:	f2c0 210f 	movt	r1, #527	; 0x20f
   220d0:	f2c0 200f 	movt	r0, #527	; 0x20f
   220d4:	f00b fd40 	bl	2db58 <tCycle_initToPool>
	tCycle_setFreq(&pwmLFO1, 63.0f);
   220d8:	2300      	movs	r3, #0
   220da:	f64d 2028 	movw	r0, #55848	; 0xda28
   220de:	f2c4 237c 	movt	r3, #17020	; 0x427c
   220e2:	f2c0 200f 	movt	r0, #527	; 0x20f
   220e6:	ee00 3a10 	vmov	s0, r3
   220ea:	f00b fd47 	bl	2db7c <tCycle_setFreq>
	tCycle_setFreq(&pwmLFO2, 72.11f);
   220ee:	f643 0352 	movw	r3, #14418	; 0x3852
   220f2:	f64d 300c 	movw	r0, #56076	; 0xdb0c
   220f6:	f2c4 2390 	movt	r3, #17040	; 0x4290
   220fa:	f2c0 200f 	movt	r0, #527	; 0x20f
   220fe:	ee00 3a10 	vmov	s0, r3
   22102:	f00b fd3b 	bl	2db7c <tCycle_setFreq>
	setLED_A(numVoices == 1);
   22106:	9b07      	ldr	r3, [sp, #28]
   22108:	7818      	ldrb	r0, [r3, #0]
   2210a:	f1a0 0001 	sub.w	r0, r0, #1
   2210e:	fab0 f080 	clz	r0, r0
   22112:	0940      	lsrs	r0, r0, #5
   22114:	f7f9 f80e 	bl	1b134 <setLED_A>
	cycleCountVals[0][2] = 2;
   22118:	f64b 03f8 	movw	r3, #47352	; 0xb8f8
   2211c:	2002      	movs	r0, #2
   2211e:	2100      	movs	r1, #0
	leaf.clearOnAllocation = 0;
   22120:	2200      	movs	r2, #0
	cycleCountVals[0][2] = 2;
   22122:	f2c0 230f 	movt	r3, #527	; 0x20f
	leaf.clearOnAllocation = 0;
   22126:	f8ca 2014 	str.w	r2, [sl, #20]
	cycleCountVals[0][2] = 2;
   2212a:	e9c3 0104 	strd	r0, r1, [r3, #16]
}
   2212e:	b009      	add	sp, #36	; 0x24
   22130:	ecbd 8b08 	vpop	{d8-d11}
   22134:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00022138 <SFXClassicSynthFrame>:
{
   22138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   2213c:	f64e 247c 	movw	r4, #60028	; 0xea7c
   22140:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   22144:	ed2d 8b08 	vpush	{d8-d11}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   22148:	7d23      	ldrb	r3, [r4, #20]
{
   2214a:	b08d      	sub	sp, #52	; 0x34
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   2214c:	2b01      	cmp	r3, #1
   2214e:	f000 8151 	beq.w	223f4 <SFXClassicSynthFrame+0x2bc>
   22152:	f246 2354 	movw	r3, #25172	; 0x6254
   22156:	f2c0 0306 	movt	r3, #6
   2215a:	9304      	str	r3, [sp, #16]
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   2215c:	7e23      	ldrb	r3, [r4, #24]
   2215e:	2b01      	cmp	r3, #1
   22160:	f000 8167 	beq.w	22432 <SFXClassicSynthFrame+0x2fa>
	if (writeKnobFlag != -1)
   22164:	f246 23d3 	movw	r3, #25299	; 0x62d3
   22168:	f2c0 0306 	movt	r3, #6
   2216c:	f993 2000 	ldrsb.w	r2, [r3]
   22170:	1c53      	adds	r3, r2, #1
   22172:	d027      	beq.n	221c4 <SFXClassicSynthFrame+0x8c>
		switch(writeKnobFlag + (knobPage * KNOB_PAGE_SIZE))
   22174:	f646 11ba 	movw	r1, #27066	; 0x69ba
   22178:	2305      	movs	r3, #5
   2217a:	f2c0 210e 	movt	r1, #526	; 0x20e
   2217e:	7809      	ldrb	r1, [r1, #0]
   22180:	fb13 2301 	smlabb	r3, r3, r1, r2
   22184:	2b10      	cmp	r3, #16
   22186:	d81d      	bhi.n	221c4 <SFXClassicSynthFrame+0x8c>
   22188:	e8df f013 	tbh	[pc, r3, lsl #1]
   2218c:	03dd0011 	.word	0x03dd0011
   22190:	03c503d1 	.word	0x03c503d1
   22194:	035d0399 	.word	0x035d0399
   22198:	02ff0321 	.word	0x02ff0321
   2219c:	028d02c3 	.word	0x028d02c3
   221a0:	02150251 	.word	0x02150251
   221a4:	01b701f3 	.word	0x01b701f3
   221a8:	016c0181 	.word	0x016c0181
   221ac:	0160      	.short	0x0160
				displayValues[0] = knobs[0]; //synth volume
   221ae:	f24d 03b8 	movw	r3, #53432	; 0xd0b8
   221b2:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   221b6:	f2c0 230f 	movt	r3, #527	; 0x20f
   221ba:	f2c0 290f 	movt	r9, #527	; 0x20f
   221be:	681b      	ldr	r3, [r3, #0]
   221c0:	f8c9 3000 	str.w	r3, [r9]
	float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
   221c4:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
   221c8:	f64d 2028 	movw	r0, #55848	; 0xda28
   221cc:	eeb5 8a00 	vmov.f32	s16, #80	; 0x3e800000  0.250
   221d0:	f2c0 200f 	movt	r0, #527	; 0x20f
   221d4:	f00b fce0 	bl	2db98 <tCycle_tick>
   221d8:	eef0 9a68 	vmov.f32	s19, s17
	float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   221dc:	f64d 300c 	movw	r0, #56076	; 0xdb0c
   221e0:	f2c0 200f 	movt	r0, #527	; 0x20f
	float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
   221e4:	eee0 9a08 	vfma.f32	s19, s0, s16
	float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   221e8:	f00b fcd6 	bl	2db98 <tCycle_tick>
   221ec:	eee0 8a08 	vfma.f32	s17, s0, s16
	for (int i = 0; i < numVoices; i++)
   221f0:	9b04      	ldr	r3, [sp, #16]
   221f2:	781b      	ldrb	r3, [r3, #0]
	float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   221f4:	ee68 8aa9 	vmul.f32	s17, s17, s19
	for (int i = 0; i < numVoices; i++)
   221f8:	2b00      	cmp	r3, #0
   221fa:	f000 80e9 	beq.w	223d0 <SFXClassicSynthFrame+0x298>
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   221fe:	f44f 4170 	mov.w	r1, #61440	; 0xf000
   22202:	f646 1340 	movw	r3, #26944	; 0x6940
   22206:	f646 1284 	movw	r2, #27012	; 0x6984
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   2220a:	f64d 0abc 	movw	sl, #55484	; 0xd8bc
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   2220e:	f2c4 517f 	movt	r1, #17791	; 0x457f
	for (int i = 0; i < numVoices; i++)
   22212:	f04f 0b00 	mov.w	fp, #0
   22216:	f2c0 220e 	movt	r2, #526	; 0x20e
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   2221a:	f2c0 2a0f 	movt	sl, #527	; 0x20f
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   2221e:	ee0a 1a90 	vmov	s21, r1
   22222:	4619      	mov	r1, r3
   22224:	f24e 639c 	movw	r3, #59036	; 0xe69c
   22228:	9209      	str	r2, [sp, #36]	; 0x24
   2222a:	f24d 17a4 	movw	r7, #53668	; 0xd1a4
   2222e:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22232:	461a      	mov	r2, r3
   22234:	f24d 637c 	movw	r3, #54908	; 0xd67c
   22238:	f646 15b8 	movw	r5, #27064	; 0x69b8
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   2223c:	f04f 4485 	mov.w	r4, #1115684864	; 0x42800000
   22240:	f2c0 220f 	movt	r2, #527	; 0x20f
	for (int i = 0; i < numVoices; i++)
   22244:	465e      	mov	r6, fp
   22246:	f2c0 210e 	movt	r1, #526	; 0x20e
   2224a:	f2c0 250e 	movt	r5, #526	; 0x20e
   2224e:	9206      	str	r2, [sp, #24]
   22250:	461a      	mov	r2, r3
   22252:	f24c 53b0 	movw	r3, #50608	; 0xc5b0
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   22256:	ee0b ba10 	vmov	s22, fp
   2225a:	f2c0 220f 	movt	r2, #527	; 0x20f
   2225e:	f2c0 270f 	movt	r7, #527	; 0x20f
   22262:	f2c0 290f 	movt	r9, #527	; 0x20f
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   22266:	ee0b 4a90 	vmov	s23, r4
   2226a:	9201      	str	r2, [sp, #4]
   2226c:	461a      	mov	r2, r3
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2226e:	f64a 23ab 	movw	r3, #43691	; 0xaaab
   22272:	9107      	str	r1, [sp, #28]
   22274:	f2c0 220f 	movt	r2, #527	; 0x20f
   22278:	9508      	str	r5, [sp, #32]
   2227a:	9202      	str	r2, [sp, #8]
   2227c:	461a      	mov	r2, r3
				if (polyEnvs[i]->whichStage == env_idle)
   2227e:	f64d 2338 	movw	r3, #55864	; 0xda38
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   22282:	f6c2 22aa 	movt	r2, #10922	; 0x2aaa
				if (polyEnvs[i]->whichStage == env_idle)
   22286:	f2c0 230f 	movt	r3, #527	; 0x20f
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2228a:	9205      	str	r2, [sp, #20]
				if (polyEnvs[i]->whichStage == env_idle)
   2228c:	930b      	str	r3, [sp, #44]	; 0x2c
   2228e:	f24d 53e2 	movw	r3, #54754	; 0xd5e2
   22292:	f2c0 230f 	movt	r3, #527	; 0x20f
   22296:	9303      	str	r3, [sp, #12]
   22298:	4653      	mov	r3, sl
   2229a:	46da      	mov	sl, fp
   2229c:	469b      	mov	fp, r3
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   2229e:	b2f3      	uxtb	r3, r6
   222a0:	9a06      	ldr	r2, [sp, #24]
   222a2:	4658      	mov	r0, fp
			float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   222a4:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   222a8:	461c      	mov	r4, r3
   222aa:	4619      	mov	r1, r3
   222ac:	930a      	str	r3, [sp, #40]	; 0x28
   222ae:	eb02 050a 	add.w	r5, r2, sl
   222b2:	f00b fc35 	bl	2db20 <tSimplePoly_getPitch>
   222b6:	ee07 0a90 	vmov	s15, r0
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   222ba:	4621      	mov	r1, r4
   222bc:	4658      	mov	r0, fp
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   222be:	eeb8 aae7 	vcvt.f32.s32	s20, s15
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   222c2:	f00b fc2d 	bl	2db20 <tSimplePoly_getPitch>
   222c6:	ee07 0a90 	vmov	s15, r0
   222ca:	9b07      	ldr	r3, [sp, #28]
   222cc:	f10a 080c 	add.w	r8, sl, #12
   222d0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   222d4:	ed93 0a00 	vldr	s0, [r3]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   222d8:	9b08      	ldr	r3, [sp, #32]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   222da:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   222de:	7818      	ldrb	r0, [r3, #0]
   222e0:	9b05      	ldr	r3, [sp, #20]
   222e2:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   222e6:	ee17 1a90 	vmov	r1, s15
   222ea:	1a09      	subs	r1, r1, r0
   222ec:	fb83 3401 	smull	r3, r4, r3, r1
   222f0:	17c8      	asrs	r0, r1, #31
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   222f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   222f4:	ebc0 0064 	rsb	r0, r0, r4, asr #1
   222f8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   222fc:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   22300:	ee07 0a90 	vmov	s15, r0
   22304:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   22308:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2230c:	ee17 1a90 	vmov	r1, s15
   22310:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   22314:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   22318:	ee37 0a00 	vadd.f32	s0, s14, s0
   2231c:	f00a fe48 	bl	2cfb0 <LEAF_midiToFrequency>
   22320:	464b      	mov	r3, r9
   22322:	46b1      	mov	r9, r6
   22324:	eca7 0a01 	vstmia	r7!, {s0}
   22328:	461e      	mov	r6, r3
			float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   2232a:	eeb0 8a49 	vmov.f32	s16, s18
   2232e:	ecb5 7a01 	vldmia	r5!, {s14}
   22332:	edd6 7a03 	vldr	s15, [r6, #12]
   22336:	9b02      	ldr	r3, [sp, #8]
   22338:	eea7 8a27 	vfma.f32	s16, s14, s15
   2233c:	eb03 040a 	add.w	r4, r3, sl
			tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   22340:	9b01      	ldr	r3, [sp, #4]
   22342:	eb03 000a 	add.w	r0, r3, sl
   22346:	f10a 0a04 	add.w	sl, sl, #4
			float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   2234a:	ee28 8a00 	vmul.f32	s16, s16, s0
			tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   2234e:	eeb0 0a48 	vmov.f32	s0, s16
   22352:	f00b fcab 	bl	2dcac <tSawtooth_setFreq>
			tRosenbergGlottalPulse_setFreq(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   22356:	eeb0 0a48 	vmov.f32	s0, s16
   2235a:	4620      	mov	r0, r4
   2235c:	f007 fb48 	bl	299f0 <tRosenbergGlottalPulse_setFreq>
			tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO1);
   22360:	eeb0 0a69 	vmov.f32	s0, s19
   22364:	4620      	mov	r0, r4
   22366:	f007 fb5f 	bl	29a28 <tRosenbergGlottalPulse_setPulseLength>
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO2);
   2236a:	eeb0 0a68 	vmov.f32	s0, s17
   2236e:	4620      	mov	r0, r4
   22370:	f007 fb4c 	bl	29a0c <tRosenbergGlottalPulse_setOpenLength>
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   22374:	45c2      	cmp	sl, r8
   22376:	d002      	beq.n	2237e <SFXClassicSynthFrame+0x246>
   22378:	ed17 0a01 	vldr	s0, [r7, #-4]
   2237c:	e7d5      	b.n	2232a <SFXClassicSynthFrame+0x1f2>
   2237e:	4633      	mov	r3, r6
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   22380:	eeb0 1a6a 	vmov.f32	s2, s21
   22384:	eeb0 0a4b 	vmov.f32	s0, s22
   22388:	464e      	mov	r6, r9
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   2238a:	edd3 7a02 	vldr	s15, [r3, #8]
   2238e:	4699      	mov	r9, r3
   22390:	edd3 0a01 	vldr	s1, [r3, #4]
   22394:	ee67 7aab 	vmul.f32	s15, s15, s23
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   22398:	eeea 0a27 	vfma.f32	s1, s20, s15
   2239c:	f00a fd20 	bl	2cde0 <LEAF_clip>
		if (numVoices > 1)
   223a0:	9b04      	ldr	r3, [sp, #16]
		filtFreqs[i] = (uint16_t) tempFreq2;
   223a2:	eebc 0ac0 	vcvt.u32.f32	s0, s0
		if (numVoices > 1)
   223a6:	7819      	ldrb	r1, [r3, #0]
		filtFreqs[i] = (uint16_t) tempFreq2;
   223a8:	9b03      	ldr	r3, [sp, #12]
   223aa:	ee10 2a10 	vmov	r2, s0
		if (numVoices > 1)
   223ae:	2901      	cmp	r1, #1
		filtFreqs[i] = (uint16_t) tempFreq2;
   223b0:	f823 2f02 	strh.w	r2, [r3, #2]!
   223b4:	9303      	str	r3, [sp, #12]
		if (numVoices > 1)
   223b6:	d907      	bls.n	223c8 <SFXClassicSynthFrame+0x290>
			if (poly->voices[i][0] == -2)
   223b8:	f8db 0000 	ldr.w	r0, [fp]
   223bc:	6900      	ldr	r0, [r0, #16]
   223be:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
   223c2:	6800      	ldr	r0, [r0, #0]
   223c4:	3002      	adds	r0, #2
   223c6:	d008      	beq.n	223da <SFXClassicSynthFrame+0x2a2>
	for (int i = 0; i < numVoices; i++)
   223c8:	3601      	adds	r6, #1
   223ca:	42b1      	cmp	r1, r6
   223cc:	f73f af67 	bgt.w	2229e <SFXClassicSynthFrame+0x166>
}
   223d0:	b00d      	add	sp, #52	; 0x34
   223d2:	ecbd 8b08 	vpop	{d8-d11}
   223d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (polyEnvs[i]->whichStage == env_idle)
   223da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   223dc:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   223e0:	6a80      	ldr	r0, [r0, #40]	; 0x28
   223e2:	2800      	cmp	r0, #0
   223e4:	d1f0      	bne.n	223c8 <SFXClassicSynthFrame+0x290>
					tSimplePoly_deactivateVoice(&poly, i);
   223e6:	990a      	ldr	r1, [sp, #40]	; 0x28
   223e8:	4658      	mov	r0, fp
   223ea:	f00b fabf 	bl	2d96c <tSimplePoly_deactivateVoice>
   223ee:	9b04      	ldr	r3, [sp, #16]
   223f0:	7819      	ldrb	r1, [r3, #0]
   223f2:	e7e9      	b.n	223c8 <SFXClassicSynthFrame+0x290>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   223f4:	f246 2554 	movw	r5, #25172	; 0x6254
		tSimplePoly_setNumVoices(&poly, numVoices);
   223f8:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   223fc:	f2c0 0506 	movt	r5, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   22400:	f2c0 200f 	movt	r0, #527	; 0x20f
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   22404:	782a      	ldrb	r2, [r5, #0]
   22406:	9504      	str	r5, [sp, #16]
   22408:	2a01      	cmp	r2, #1
   2240a:	bf98      	it	ls
   2240c:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   2240e:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   22410:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   22412:	f00b fb61 	bl	2dad8 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   22416:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   22418:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   2241a:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   2241e:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   22420:	fab0 f080 	clz	r0, r0
   22424:	0940      	lsrs	r0, r0, #5
   22426:	f7f8 fe85 	bl	1b134 <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   2242a:	7e23      	ldrb	r3, [r4, #24]
   2242c:	2b01      	cmp	r3, #1
   2242e:	f47f ae99 	bne.w	22164 <SFXClassicSynthFrame+0x2c>
		cycleCountVals[0][1] = 0;
   22432:	f64b 03f8 	movw	r3, #47352	; 0xb8f8
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   22436:	2000      	movs	r0, #0
		cycleCountVals[0][1] = 0;
   22438:	2600      	movs	r6, #0
   2243a:	2700      	movs	r7, #0
   2243c:	f2c0 230f 	movt	r3, #527	; 0x20f
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   22440:	7620      	strb	r0, [r4, #24]
		cycleCountVals[0][1] = 0;
   22442:	e9c3 6702 	strd	r6, r7, [r3, #8]
		setLED_Edit(0);
   22446:	f7f8 fe35 	bl	1b0b4 <setLED_Edit>
   2244a:	e68b      	b.n	22164 <SFXClassicSynthFrame+0x2c>
				displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   2244c:	f24d 03f8 	movw	r3, #53496	; 0xd0f8
   22450:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22454:	f2c0 230f 	movt	r3, #527	; 0x20f
   22458:	f2c0 290f 	movt	r9, #527	; 0x20f
   2245c:	681b      	ldr	r3, [r3, #0]
   2245e:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
				break;
   22462:	e6af      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   22464:	f44f 4370 	mov.w	r3, #61440	; 0xf000
   22468:	f24d 01f4 	movw	r1, #53492	; 0xd0f4
   2246c:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22470:	f2c0 210f 	movt	r1, #527	; 0x20f
   22474:	f2c4 537f 	movt	r3, #17791	; 0x457f
   22478:	f2c0 290f 	movt	r9, #527	; 0x20f
   2247c:	ed91 7a00 	vldr	s14, [r1]
   22480:	ee07 3a90 	vmov	s15, r3
   22484:	ee67 7a27 	vmul.f32	s15, s14, s15
   22488:	edc9 7a0f 	vstr	s15, [r9, #60]	; 0x3c
				break;
   2248c:	e69a      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[14] = knobs[14]; //leak
   2248e:	f24d 01f0 	movw	r1, #53488	; 0xd0f0
   22492:	f64e 392c 	movw	r9, #60204	; 0xeb2c
				for (int i = 0; i < numVoices; i++)
   22496:	9e04      	ldr	r6, [sp, #16]
				displayValues[14] = knobs[14]; //leak
   22498:	f2c0 210f 	movt	r1, #527	; 0x20f
   2249c:	f2c0 290f 	movt	r9, #527	; 0x20f
				for (int i = 0; i < numVoices; i++)
   224a0:	7833      	ldrb	r3, [r6, #0]
				displayValues[14] = knobs[14]; //leak
   224a2:	edd1 7a00 	vldr	s15, [r1]
   224a6:	edc9 7a0e 	vstr	s15, [r9, #56]	; 0x38
				for (int i = 0; i < numVoices; i++)
   224aa:	2b00      	cmp	r3, #0
   224ac:	f43f ae8a 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
					tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   224b0:	f24b 7117 	movw	r1, #46871	; 0xb717
   224b4:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
   224b8:	f64b 44b0 	movw	r4, #48304	; 0xbcb0
   224bc:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   224c0:	f6c3 0151 	movt	r1, #14417	; 0x3851
   224c4:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
   224c8:	f2c0 240f 	movt	r4, #527	; 0x20f
				for (int i = 0; i < numVoices; i++)
   224cc:	2500      	movs	r5, #0
					tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   224ce:	ee08 1a90 	vmov	s17, r1
   224d2:	ee08 3a10 	vmov	s16, r3
   224d6:	e001      	b.n	224dc <SFXClassicSynthFrame+0x3a4>
   224d8:	edd9 7a0e 	vldr	s15, [r9, #56]	; 0x38
   224dc:	ee79 7a67 	vsub.f32	s15, s18, s15
   224e0:	4620      	mov	r0, r4
   224e2:	eeb0 0a48 	vmov.f32	s0, s16
				for (int i = 0; i < numVoices; i++)
   224e6:	3501      	adds	r5, #1
   224e8:	3404      	adds	r4, #4
					tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   224ea:	eea7 0aa8 	vfma.f32	s0, s15, s17
   224ee:	f008 fc0f 	bl	2ad10 <tADSR4_setLeakFactor>
				for (int i = 0; i < numVoices; i++)
   224f2:	7833      	ldrb	r3, [r6, #0]
   224f4:	42ab      	cmp	r3, r5
   224f6:	dcef      	bgt.n	224d8 <SFXClassicSynthFrame+0x3a0>
   224f8:	e664      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   224fa:	f246 213c 	movw	r1, #25148	; 0x623c
   224fe:	f24d 00ec 	movw	r0, #53484	; 0xd0ec
   22502:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
   22506:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   2250a:	f2c0 0106 	movt	r1, #6
   2250e:	f2c0 200f 	movt	r0, #527	; 0x20f
   22512:	ee07 2a10 	vmov	s14, r2
   22516:	f2c0 230f 	movt	r3, #527	; 0x20f
   2251a:	edd1 6a00 	vldr	s13, [r1]
   2251e:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22522:	edd0 7a00 	vldr	s15, [r0]
				for (int i = 0; i < numVoices; i++)
   22526:	9e04      	ldr	r6, [sp, #16]
				displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   22528:	f2c0 290f 	movt	r9, #527	; 0x20f
   2252c:	ee67 7aa6 	vmul.f32	s15, s15, s13
				for (int i = 0; i < numVoices; i++)
   22530:	7831      	ldrb	r1, [r6, #0]
				displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   22532:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   22536:	ee17 2a90 	vmov	r2, s15
   2253a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   2253e:	ed93 0a00 	vldr	s0, [r3]
   22542:	ee20 0a07 	vmul.f32	s0, s0, s14
   22546:	ed89 0a0d 	vstr	s0, [r9, #52]	; 0x34
				for (int i = 0; i < numVoices; i++)
   2254a:	2900      	cmp	r1, #0
   2254c:	f43f ae3a 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   22550:	f64b 44b0 	movw	r4, #48304	; 0xbcb0
   22554:	2500      	movs	r5, #0
   22556:	f2c0 240f 	movt	r4, #527	; 0x20f
   2255a:	e001      	b.n	22560 <SFXClassicSynthFrame+0x428>
   2255c:	ed99 0a0d 	vldr	s0, [r9, #52]	; 0x34
					tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
   22560:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   22562:	3501      	adds	r5, #1
					tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
   22564:	f008 fbc6 	bl	2acf4 <tADSR4_setRelease>
				for (int i = 0; i < numVoices; i++)
   22568:	7833      	ldrb	r3, [r6, #0]
   2256a:	3404      	adds	r4, #4
   2256c:	42ab      	cmp	r3, r5
   2256e:	dcf5      	bgt.n	2255c <SFXClassicSynthFrame+0x424>
   22570:	e628      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[12] = knobs[12]; //sus
   22572:	f24d 01e8 	movw	r1, #53480	; 0xd0e8
   22576:	f64e 392c 	movw	r9, #60204	; 0xeb2c
				for (int i = 0; i < numVoices; i++)
   2257a:	9e04      	ldr	r6, [sp, #16]
				displayValues[12] = knobs[12]; //sus
   2257c:	f2c0 210f 	movt	r1, #527	; 0x20f
   22580:	f2c0 290f 	movt	r9, #527	; 0x20f
				for (int i = 0; i < numVoices; i++)
   22584:	7833      	ldrb	r3, [r6, #0]
				displayValues[12] = knobs[12]; //sus
   22586:	ed91 0a00 	vldr	s0, [r1]
   2258a:	ed89 0a0c 	vstr	s0, [r9, #48]	; 0x30
				for (int i = 0; i < numVoices; i++)
   2258e:	2b00      	cmp	r3, #0
   22590:	f43f ae18 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   22594:	f64b 44b0 	movw	r4, #48304	; 0xbcb0
   22598:	2500      	movs	r5, #0
   2259a:	f2c0 240f 	movt	r4, #527	; 0x20f
   2259e:	e001      	b.n	225a4 <SFXClassicSynthFrame+0x46c>
   225a0:	ed99 0a0c 	vldr	s0, [r9, #48]	; 0x30
					tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
   225a4:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   225a6:	3501      	adds	r5, #1
					tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
   225a8:	f008 fb8e 	bl	2acc8 <tADSR4_setSustain>
				for (int i = 0; i < numVoices; i++)
   225ac:	7833      	ldrb	r3, [r6, #0]
   225ae:	3404      	adds	r4, #4
   225b0:	42ab      	cmp	r3, r5
   225b2:	dcf5      	bgt.n	225a0 <SFXClassicSynthFrame+0x468>
   225b4:	e606      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   225b6:	f246 213c 	movw	r1, #25148	; 0x623c
   225ba:	f24d 00e4 	movw	r0, #53476	; 0xd0e4
   225be:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
   225c2:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   225c6:	f2c0 0106 	movt	r1, #6
   225ca:	f2c0 200f 	movt	r0, #527	; 0x20f
   225ce:	ee07 2a10 	vmov	s14, r2
   225d2:	f2c0 230f 	movt	r3, #527	; 0x20f
   225d6:	edd1 6a00 	vldr	s13, [r1]
   225da:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   225de:	edd0 7a00 	vldr	s15, [r0]
				for (int i = 0; i < numVoices; i++)
   225e2:	9e04      	ldr	r6, [sp, #16]
				displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   225e4:	f2c0 290f 	movt	r9, #527	; 0x20f
   225e8:	ee67 7aa6 	vmul.f32	s15, s15, s13
				for (int i = 0; i < numVoices; i++)
   225ec:	7831      	ldrb	r1, [r6, #0]
				displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   225ee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   225f2:	ee17 2a90 	vmov	r2, s15
   225f6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   225fa:	ed93 0a00 	vldr	s0, [r3]
   225fe:	ee20 0a07 	vmul.f32	s0, s0, s14
   22602:	ed89 0a0b 	vstr	s0, [r9, #44]	; 0x2c
				for (int i = 0; i < numVoices; i++)
   22606:	2900      	cmp	r1, #0
   22608:	f43f addc 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   2260c:	f64b 44b0 	movw	r4, #48304	; 0xbcb0
   22610:	2500      	movs	r5, #0
   22612:	f2c0 240f 	movt	r4, #527	; 0x20f
   22616:	e001      	b.n	2261c <SFXClassicSynthFrame+0x4e4>
   22618:	ed99 0a0b 	vldr	s0, [r9, #44]	; 0x2c
					tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
   2261c:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   2261e:	3501      	adds	r5, #1
					tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
   22620:	f008 fb44 	bl	2acac <tADSR4_setDecay>
				for (int i = 0; i < numVoices; i++)
   22624:	7833      	ldrb	r3, [r6, #0]
   22626:	3404      	adds	r4, #4
   22628:	42ab      	cmp	r3, r5
   2262a:	dcf5      	bgt.n	22618 <SFXClassicSynthFrame+0x4e0>
   2262c:	e5ca      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   2262e:	f246 213c 	movw	r1, #25148	; 0x623c
   22632:	f24d 00e0 	movw	r0, #53472	; 0xd0e0
   22636:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
   2263a:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   2263e:	f2c0 0106 	movt	r1, #6
   22642:	f2c0 200f 	movt	r0, #527	; 0x20f
   22646:	ee07 2a10 	vmov	s14, r2
   2264a:	f2c0 230f 	movt	r3, #527	; 0x20f
   2264e:	edd1 6a00 	vldr	s13, [r1]
   22652:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22656:	edd0 7a00 	vldr	s15, [r0]
				for (int i = 0; i < numVoices; i++)
   2265a:	9e04      	ldr	r6, [sp, #16]
				displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   2265c:	f2c0 290f 	movt	r9, #527	; 0x20f
   22660:	ee67 7aa6 	vmul.f32	s15, s15, s13
				for (int i = 0; i < numVoices; i++)
   22664:	7831      	ldrb	r1, [r6, #0]
				displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   22666:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2266a:	ee17 2a90 	vmov	r2, s15
   2266e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   22672:	ed93 0a00 	vldr	s0, [r3]
   22676:	ee20 0a07 	vmul.f32	s0, s0, s14
   2267a:	ed89 0a0a 	vstr	s0, [r9, #40]	; 0x28
				for (int i = 0; i < numVoices; i++)
   2267e:	2900      	cmp	r1, #0
   22680:	f43f ada0 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   22684:	f64b 44b0 	movw	r4, #48304	; 0xbcb0
   22688:	2500      	movs	r5, #0
   2268a:	f2c0 240f 	movt	r4, #527	; 0x20f
   2268e:	e001      	b.n	22694 <SFXClassicSynthFrame+0x55c>
   22690:	ed99 0a0a 	vldr	s0, [r9, #40]	; 0x28
					tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
   22694:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   22696:	3501      	adds	r5, #1
					tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
   22698:	f008 fafa 	bl	2ac90 <tADSR4_setAttack>
				for (int i = 0; i < numVoices; i++)
   2269c:	7833      	ldrb	r3, [r6, #0]
   2269e:	3404      	adds	r4, #4
   226a0:	42ab      	cmp	r3, r5
   226a2:	dcf5      	bgt.n	22690 <SFXClassicSynthFrame+0x558>
   226a4:	e58e      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[9] = knobs[9]; //leak
   226a6:	f24d 01dc 	movw	r1, #53468	; 0xd0dc
   226aa:	f64e 392c 	movw	r9, #60204	; 0xeb2c
				for (int i = 0; i < numVoices; i++)
   226ae:	9e04      	ldr	r6, [sp, #16]
				displayValues[9] = knobs[9]; //leak
   226b0:	f2c0 210f 	movt	r1, #527	; 0x20f
   226b4:	f2c0 290f 	movt	r9, #527	; 0x20f
				for (int i = 0; i < numVoices; i++)
   226b8:	7833      	ldrb	r3, [r6, #0]
				displayValues[9] = knobs[9]; //leak
   226ba:	edd1 7a00 	vldr	s15, [r1]
   226be:	edc9 7a09 	vstr	s15, [r9, #36]	; 0x24
				for (int i = 0; i < numVoices; i++)
   226c2:	2b00      	cmp	r3, #0
   226c4:	f43f ad7e 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
					tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   226c8:	f24b 7117 	movw	r1, #46871	; 0xb717
   226cc:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
   226d0:	f64d 2438 	movw	r4, #55864	; 0xda38
   226d4:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   226d8:	f6c3 0151 	movt	r1, #14417	; 0x3851
   226dc:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
   226e0:	f2c0 240f 	movt	r4, #527	; 0x20f
				for (int i = 0; i < numVoices; i++)
   226e4:	2500      	movs	r5, #0
					tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   226e6:	ee08 1a90 	vmov	s17, r1
   226ea:	ee08 3a10 	vmov	s16, r3
   226ee:	e001      	b.n	226f4 <SFXClassicSynthFrame+0x5bc>
   226f0:	edd9 7a09 	vldr	s15, [r9, #36]	; 0x24
   226f4:	ee79 7a67 	vsub.f32	s15, s18, s15
   226f8:	4620      	mov	r0, r4
   226fa:	eeb0 0a48 	vmov.f32	s0, s16
				for (int i = 0; i < numVoices; i++)
   226fe:	3501      	adds	r5, #1
   22700:	3404      	adds	r4, #4
					tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   22702:	eea7 0aa8 	vfma.f32	s0, s15, s17
   22706:	f008 fb03 	bl	2ad10 <tADSR4_setLeakFactor>
				for (int i = 0; i < numVoices; i++)
   2270a:	7833      	ldrb	r3, [r6, #0]
   2270c:	42ab      	cmp	r3, r5
   2270e:	dcef      	bgt.n	226f0 <SFXClassicSynthFrame+0x5b8>
   22710:	e558      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   22712:	f246 213c 	movw	r1, #25148	; 0x623c
   22716:	f24d 00d8 	movw	r0, #53464	; 0xd0d8
   2271a:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
   2271e:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   22722:	f2c0 0106 	movt	r1, #6
   22726:	f2c0 200f 	movt	r0, #527	; 0x20f
   2272a:	ee07 2a10 	vmov	s14, r2
   2272e:	f2c0 230f 	movt	r3, #527	; 0x20f
   22732:	edd1 6a00 	vldr	s13, [r1]
   22736:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   2273a:	edd0 7a00 	vldr	s15, [r0]
				for (int i = 0; i < numVoices; i++)
   2273e:	9e04      	ldr	r6, [sp, #16]
				displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   22740:	f2c0 290f 	movt	r9, #527	; 0x20f
   22744:	ee67 7aa6 	vmul.f32	s15, s15, s13
				for (int i = 0; i < numVoices; i++)
   22748:	7831      	ldrb	r1, [r6, #0]
				displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   2274a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2274e:	ee17 2a90 	vmov	r2, s15
   22752:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   22756:	ed93 0a00 	vldr	s0, [r3]
   2275a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2275e:	ed89 0a08 	vstr	s0, [r9, #32]
				for (int i = 0; i < numVoices; i++)
   22762:	2900      	cmp	r1, #0
   22764:	f43f ad2e 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   22768:	f64d 2438 	movw	r4, #55864	; 0xda38
   2276c:	2500      	movs	r5, #0
   2276e:	f2c0 240f 	movt	r4, #527	; 0x20f
   22772:	e001      	b.n	22778 <SFXClassicSynthFrame+0x640>
   22774:	ed99 0a08 	vldr	s0, [r9, #32]
					tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
   22778:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   2277a:	3501      	adds	r5, #1
					tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
   2277c:	f008 faba 	bl	2acf4 <tADSR4_setRelease>
				for (int i = 0; i < numVoices; i++)
   22780:	7833      	ldrb	r3, [r6, #0]
   22782:	3404      	adds	r4, #4
   22784:	42ab      	cmp	r3, r5
   22786:	dcf5      	bgt.n	22774 <SFXClassicSynthFrame+0x63c>
   22788:	e51c      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[7] = knobs[7]; //sus
   2278a:	f24d 01d4 	movw	r1, #53460	; 0xd0d4
   2278e:	f64e 392c 	movw	r9, #60204	; 0xeb2c
				for (int i = 0; i < numVoices; i++)
   22792:	9e04      	ldr	r6, [sp, #16]
				displayValues[7] = knobs[7]; //sus
   22794:	f2c0 210f 	movt	r1, #527	; 0x20f
   22798:	f2c0 290f 	movt	r9, #527	; 0x20f
				for (int i = 0; i < numVoices; i++)
   2279c:	7833      	ldrb	r3, [r6, #0]
				displayValues[7] = knobs[7]; //sus
   2279e:	ed91 0a00 	vldr	s0, [r1]
   227a2:	ed89 0a07 	vstr	s0, [r9, #28]
				for (int i = 0; i < numVoices; i++)
   227a6:	2b00      	cmp	r3, #0
   227a8:	f43f ad0c 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   227ac:	f64d 2438 	movw	r4, #55864	; 0xda38
   227b0:	2500      	movs	r5, #0
   227b2:	f2c0 240f 	movt	r4, #527	; 0x20f
   227b6:	e001      	b.n	227bc <SFXClassicSynthFrame+0x684>
   227b8:	ed99 0a07 	vldr	s0, [r9, #28]
					tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
   227bc:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   227be:	3501      	adds	r5, #1
					tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
   227c0:	f008 fa82 	bl	2acc8 <tADSR4_setSustain>
				for (int i = 0; i < numVoices; i++)
   227c4:	7833      	ldrb	r3, [r6, #0]
   227c6:	3404      	adds	r4, #4
   227c8:	42ab      	cmp	r3, r5
   227ca:	dcf5      	bgt.n	227b8 <SFXClassicSynthFrame+0x680>
   227cc:	e4fa      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   227ce:	f246 213c 	movw	r1, #25148	; 0x623c
   227d2:	f24d 00d0 	movw	r0, #53456	; 0xd0d0
   227d6:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
   227da:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   227de:	f2c0 0106 	movt	r1, #6
   227e2:	f2c0 200f 	movt	r0, #527	; 0x20f
   227e6:	ee07 2a10 	vmov	s14, r2
   227ea:	f2c0 230f 	movt	r3, #527	; 0x20f
   227ee:	edd1 6a00 	vldr	s13, [r1]
   227f2:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   227f6:	edd0 7a00 	vldr	s15, [r0]
				for (int i = 0; i < numVoices; i++)
   227fa:	9e04      	ldr	r6, [sp, #16]
				displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   227fc:	f2c0 290f 	movt	r9, #527	; 0x20f
   22800:	ee67 7aa6 	vmul.f32	s15, s15, s13
				for (int i = 0; i < numVoices; i++)
   22804:	7831      	ldrb	r1, [r6, #0]
				displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   22806:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2280a:	ee17 2a90 	vmov	r2, s15
   2280e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   22812:	ed93 0a00 	vldr	s0, [r3]
   22816:	ee20 0a07 	vmul.f32	s0, s0, s14
   2281a:	ed89 0a06 	vstr	s0, [r9, #24]
				for (int i = 0; i < numVoices; i++)
   2281e:	2900      	cmp	r1, #0
   22820:	f43f acd0 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   22824:	f64d 2438 	movw	r4, #55864	; 0xda38
   22828:	2500      	movs	r5, #0
   2282a:	f2c0 240f 	movt	r4, #527	; 0x20f
   2282e:	e001      	b.n	22834 <SFXClassicSynthFrame+0x6fc>
   22830:	ed99 0a06 	vldr	s0, [r9, #24]
					tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
   22834:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   22836:	3501      	adds	r5, #1
					tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
   22838:	f008 fa38 	bl	2acac <tADSR4_setDecay>
				for (int i = 0; i < numVoices; i++)
   2283c:	7833      	ldrb	r3, [r6, #0]
   2283e:	3404      	adds	r4, #4
   22840:	42ab      	cmp	r3, r5
   22842:	dcf5      	bgt.n	22830 <SFXClassicSynthFrame+0x6f8>
   22844:	e4be      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   22846:	f246 213c 	movw	r1, #25148	; 0x623c
   2284a:	f24d 00cc 	movw	r0, #53452	; 0xd0cc
   2284e:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
   22852:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   22856:	f2c0 0106 	movt	r1, #6
   2285a:	f2c0 200f 	movt	r0, #527	; 0x20f
   2285e:	ee07 2a10 	vmov	s14, r2
   22862:	f2c0 230f 	movt	r3, #527	; 0x20f
   22866:	edd1 6a00 	vldr	s13, [r1]
   2286a:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   2286e:	edd0 7a00 	vldr	s15, [r0]
				for (int i = 0; i < numVoices; i++)
   22872:	9e04      	ldr	r6, [sp, #16]
				displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   22874:	f2c0 290f 	movt	r9, #527	; 0x20f
   22878:	ee67 7aa6 	vmul.f32	s15, s15, s13
				for (int i = 0; i < numVoices; i++)
   2287c:	7831      	ldrb	r1, [r6, #0]
				displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   2287e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   22882:	ee17 2a90 	vmov	r2, s15
   22886:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   2288a:	ed93 0a00 	vldr	s0, [r3]
   2288e:	ee20 0a07 	vmul.f32	s0, s0, s14
   22892:	ed89 0a05 	vstr	s0, [r9, #20]
				for (int i = 0; i < numVoices; i++)
   22896:	2900      	cmp	r1, #0
   22898:	f43f ac94 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   2289c:	f64d 2438 	movw	r4, #55864	; 0xda38
   228a0:	2500      	movs	r5, #0
   228a2:	f2c0 240f 	movt	r4, #527	; 0x20f
   228a6:	e001      	b.n	228ac <SFXClassicSynthFrame+0x774>
   228a8:	ed99 0a05 	vldr	s0, [r9, #20]
					tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
   228ac:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   228ae:	3501      	adds	r5, #1
					tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
   228b0:	f008 f9ee 	bl	2ac90 <tADSR4_setAttack>
				for (int i = 0; i < numVoices; i++)
   228b4:	7833      	ldrb	r3, [r6, #0]
   228b6:	3404      	adds	r4, #4
   228b8:	42ab      	cmp	r3, r5
   228ba:	dcf5      	bgt.n	228a8 <SFXClassicSynthFrame+0x770>
   228bc:	e482      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   228be:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   228c2:	f24d 01c8 	movw	r1, #53448	; 0xd0c8
   228c6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   228ca:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   228ce:	f2c0 210f 	movt	r1, #527	; 0x20f
   228d2:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
				for (int i = 0; i < numVoices; i++)
   228d6:	9e04      	ldr	r6, [sp, #16]
				displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   228d8:	f2c0 290f 	movt	r9, #527	; 0x20f
   228dc:	ed91 7a00 	vldr	s14, [r1]
   228e0:	ee00 3a10 	vmov	s0, r3
				for (int i = 0; i < numVoices; i++)
   228e4:	7831      	ldrb	r1, [r6, #0]
				displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   228e6:	eea7 0a27 	vfma.f32	s0, s14, s15
   228ea:	ed89 0a04 	vstr	s0, [r9, #16]
				for (int i = 0; i < numVoices; i++)
   228ee:	2900      	cmp	r1, #0
   228f0:	f43f ac68 	beq.w	221c4 <SFXClassicSynthFrame+0x8c>
   228f4:	f24d 1480 	movw	r4, #53632	; 0xd180
   228f8:	2500      	movs	r5, #0
   228fa:	f2c0 240f 	movt	r4, #527	; 0x20f
   228fe:	e001      	b.n	22904 <SFXClassicSynthFrame+0x7cc>
   22900:	ed99 0a04 	vldr	s0, [r9, #16]
					tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
   22904:	4620      	mov	r0, r4
				for (int i = 0; i < numVoices; i++)
   22906:	3501      	adds	r5, #1
					tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
   22908:	f009 f834 	bl	2b974 <tEfficientSVF_setQ>
				for (int i = 0; i < numVoices; i++)
   2290c:	7833      	ldrb	r3, [r6, #0]
   2290e:	3404      	adds	r4, #4
   22910:	42ab      	cmp	r3, r5
   22912:	dcf5      	bgt.n	22900 <SFXClassicSynthFrame+0x7c8>
   22914:	e456      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[3] = knobs[3]; //detune
   22916:	f24d 03c4 	movw	r3, #53444	; 0xd0c4
   2291a:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   2291e:	f2c0 230f 	movt	r3, #527	; 0x20f
   22922:	f2c0 290f 	movt	r9, #527	; 0x20f
   22926:	681b      	ldr	r3, [r3, #0]
   22928:	f8c9 300c 	str.w	r3, [r9, #12]
				break;
   2292c:	e44a      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[2] = knobs[2]; //keyfollow filter cutoff
   2292e:	f24d 03c0 	movw	r3, #53440	; 0xd0c0
   22932:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22936:	f2c0 230f 	movt	r3, #527	; 0x20f
   2293a:	f2c0 290f 	movt	r9, #527	; 0x20f
   2293e:	681b      	ldr	r3, [r3, #0]
   22940:	f8c9 3008 	str.w	r3, [r9, #8]
				break;
   22944:	e43e      	b.n	221c4 <SFXClassicSynthFrame+0x8c>
				displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   22946:	f24d 01bc 	movw	r1, #53436	; 0xd0bc
   2294a:	f04f 438b 	mov.w	r3, #1166016512	; 0x45800000
   2294e:	f64e 392c 	movw	r9, #60204	; 0xeb2c
   22952:	f2c0 210f 	movt	r1, #527	; 0x20f
   22956:	ee07 3a10 	vmov	s14, r3
   2295a:	f2c0 290f 	movt	r9, #527	; 0x20f
   2295e:	edd1 7a00 	vldr	s15, [r1]
   22962:	ee67 7a87 	vmul.f32	s15, s15, s14
   22966:	edc9 7a01 	vstr	s15, [r9, #4]
				break;
   2296a:	e42b      	b.n	221c4 <SFXClassicSynthFrame+0x8c>

0002296c <SFXClassicSynthTick>:
	float sample = 0.0f;
   2296c:	2200      	movs	r2, #0
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   2296e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
{
   22972:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   22976:	4615      	mov	r5, r2
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   22978:	f2c4 537f 	movt	r3, #17791	; 0x457f
   2297c:	f64e 342c 	movw	r4, #60204	; 0xeb2c
   22980:	f24d 5ae2 	movw	sl, #54754	; 0xd5e2
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   22984:	46a9      	mov	r9, r5
   22986:	f04f 080c 	mov.w	r8, #12
   2298a:	f2c0 240f 	movt	r4, #527	; 0x20f
   2298e:	f2c0 2a0f 	movt	sl, #527	; 0x20f
{
   22992:	ed2d 8b08 	vpush	{d8-d11}
	float sample = 0.0f;
   22996:	ee0a 2a90 	vmov	s21, r2
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   2299a:	f64d 02bc 	movw	r2, #55484	; 0xd8bc
{
   2299e:	b083      	sub	sp, #12
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   229a0:	ee0b 3a10 	vmov	s22, r3
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   229a4:	f2c0 220f 	movt	r2, #527	; 0x20f
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   229a8:	ee0b 5a90 	vmov	s23, r5
{
   229ac:	9001      	str	r0, [sp, #4]
   229ae:	4610      	mov	r0, r2
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   229b0:	9200      	str	r2, [sp, #0]
   229b2:	f00b f899 	bl	2dae8 <tSimplePoly_getNumVoices>
   229b6:	4548      	cmp	r0, r9
   229b8:	dd68      	ble.n	22a8c <SFXClassicSynthTick+0x120>
		float env = tADSR4_tick(&polyEnvs[i]);
   229ba:	f64d 2038 	movw	r0, #55864	; 0xda38
   229be:	f24d 677c 	movw	r7, #54908	; 0xd67c
   229c2:	f24c 56b0 	movw	r6, #50608	; 0xc5b0
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   229c6:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
		float env = tADSR4_tick(&polyEnvs[i]);
   229ca:	f2c0 200f 	movt	r0, #527	; 0x20f
   229ce:	f2c0 270f 	movt	r7, #527	; 0x20f
   229d2:	f2c0 260f 	movt	r6, #527	; 0x20f
   229d6:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
   229da:	4428      	add	r0, r5
   229dc:	f008 f9b6 	bl	2ad4c <tADSR4_tick>
		float tempSample = 0.0f;
   229e0:	2200      	movs	r2, #0
		float env = tADSR4_tick(&polyEnvs[i]);
   229e2:	eef0 9a40 	vmov.f32	s19, s0
		float tempSample = 0.0f;
   229e6:	ee08 2a90 	vmov	s17, r2
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   229ea:	eb07 000b 	add.w	r0, r7, fp
   229ee:	f00b f991 	bl	2dd14 <tSawtooth_tick>
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   229f2:	eb06 000b 	add.w	r0, r6, fp
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   229f6:	eeb0 9a40 	vmov.f32	s18, s0
   229fa:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   229fe:	f006 ff13 	bl	29828 <tRosenbergGlottalPulse_tick>
   22a02:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   22a06:	ee3a 8a48 	vsub.f32	s16, s20, s16
   22a0a:	f10b 0b04 	add.w	fp, fp, #4
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   22a0e:	ee20 0a27 	vmul.f32	s0, s0, s15
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   22a12:	45c3      	cmp	fp, r8
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   22a14:	eea9 0a08 	vfma.f32	s0, s18, s16
   22a18:	eee9 8a80 	vfma.f32	s17, s19, s0
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   22a1c:	d1e5      	bne.n	229ea <SFXClassicSynthTick+0x7e>
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   22a1e:	f83a 3f02 	ldrh.w	r3, [sl, #2]!
   22a22:	f64b 40b0 	movw	r0, #48304	; 0xbcb0
   22a26:	ed94 9a0f 	vldr	s18, [r4, #60]	; 0x3c
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   22a2a:	f109 0901 	add.w	r9, r9, #1
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   22a2e:	ee08 3a10 	vmov	s16, r3
   22a32:	f24d 1380 	movw	r3, #53632	; 0xd180
   22a36:	f2c0 200f 	movt	r0, #527	; 0x20f
   22a3a:	f108 080c 	add.w	r8, r8, #12
   22a3e:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
   22a42:	f2c0 230f 	movt	r3, #527	; 0x20f
   22a46:	4428      	add	r0, r5
   22a48:	18ee      	adds	r6, r5, r3
   22a4a:	f008 f97f 	bl	2ad4c <tADSR4_tick>
   22a4e:	eef0 0a48 	vmov.f32	s1, s16
   22a52:	3504      	adds	r5, #4
   22a54:	eeb0 1a4b 	vmov.f32	s2, s22
   22a58:	eee9 0a00 	vfma.f32	s1, s18, s0
   22a5c:	eeb0 0a6b 	vmov.f32	s0, s23
   22a60:	f00a f9be 	bl	2cde0 <LEAF_clip>
   22a64:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   22a68:	4630      	mov	r0, r6
   22a6a:	ee10 3a10 	vmov	r3, s0
   22a6e:	b299      	uxth	r1, r3
   22a70:	f008 ff5c 	bl	2b92c <tEfficientSVF_setFreq>
		sample += tEfficientSVF_tick(&synthLP[i], tempSample);
   22a74:	4630      	mov	r0, r6
   22a76:	eeb0 0a68 	vmov.f32	s0, s17
   22a7a:	f008 ff07 	bl	2b88c <tEfficientSVF_tick>
   22a7e:	9800      	ldr	r0, [sp, #0]
   22a80:	ee7a aa80 	vadd.f32	s21, s21, s0
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   22a84:	f00b f830 	bl	2dae8 <tSimplePoly_getNumVoices>
   22a88:	4548      	cmp	r0, r9
   22a8a:	dc96      	bgt.n	229ba <SFXClassicSynthTick+0x4e>
	sample *= INV_NUM_OSC_PER_VOICE * displayValues[0];
   22a8c:	f24f 53c3 	movw	r3, #62915	; 0xf5c3
   22a90:	edd4 7a00 	vldr	s15, [r4]
   22a94:	f6c3 63a8 	movt	r3, #16040	; 0x3ea8
   22a98:	ee00 3a10 	vmov	s0, r3
   22a9c:	ee27 0a80 	vmul.f32	s0, s15, s0
	sample = tanhf(sample);
   22aa0:	ee20 0a2a 	vmul.f32	s0, s0, s21
   22aa4:	f00d ffc2 	bl	30a2c <tanhf>
	input[0] = sample;
   22aa8:	9b01      	ldr	r3, [sp, #4]
   22aaa:	ed83 0a00 	vstr	s0, [r3]
	input[1] = sample;
   22aae:	ed83 0a01 	vstr	s0, [r3, #4]
}
   22ab2:	b003      	add	sp, #12
   22ab4:	ecbd 8b08 	vpop	{d8-d11}
   22ab8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00022abc <SFXClassicSynthFree>:
{
   22abc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22ac0:	f24d 687c 	movw	r8, #54908	; 0xd67c
   22ac4:	f24c 57b0 	movw	r7, #50608	; 0xc5b0
   22ac8:	f24d 1b80 	movw	fp, #53632	; 0xd180
   22acc:	f64d 2a38 	movw	sl, #55864	; 0xda38
   22ad0:	f64b 49b0 	movw	r9, #48304	; 0xbcb0
   22ad4:	f2c0 280f 	movt	r8, #527	; 0x20f
   22ad8:	f2c0 270f 	movt	r7, #527	; 0x20f
   22adc:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   22ae0:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   22ae4:	f2c0 290f 	movt	r9, #527	; 0x20f
   22ae8:	2500      	movs	r5, #0
   22aea:	260c      	movs	r6, #12
   22aec:	eb05 0445 	add.w	r4, r5, r5, lsl #1
			tSawtooth_free(&osc[(i * NUM_OSC_PER_VOICE) + j]);
   22af0:	eb08 0004 	add.w	r0, r8, r4
   22af4:	f00b f8d6 	bl	2dca4 <tSawtooth_free>
			tRosenbergGlottalPulse_free(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
   22af8:	1938      	adds	r0, r7, r4
   22afa:	3404      	adds	r4, #4
   22afc:	f006 fe90 	bl	29820 <tRosenbergGlottalPulse_free>
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   22b00:	42b4      	cmp	r4, r6
   22b02:	d1f5      	bne.n	22af0 <SFXClassicSynthFree+0x34>
		tEfficientSVF_free(&synthLP[i]);
   22b04:	eb0b 0005 	add.w	r0, fp, r5
   22b08:	f104 060c 	add.w	r6, r4, #12
   22b0c:	f008 feba 	bl	2b884 <tEfficientSVF_free>
		tADSR4_free(&polyEnvs[i]);
   22b10:	eb0a 0005 	add.w	r0, sl, r5
   22b14:	f008 f8b8 	bl	2ac88 <tADSR4_free>
		tADSR4_free(&polyFiltEnvs[i]);
   22b18:	eb09 0005 	add.w	r0, r9, r5
   22b1c:	3504      	adds	r5, #4
   22b1e:	f008 f8b3 	bl	2ac88 <tADSR4_free>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   22b22:	2d20      	cmp	r5, #32
   22b24:	d1e2      	bne.n	22aec <SFXClassicSynthFree+0x30>
	tCycle_free(&pwmLFO1);
   22b26:	f64d 2028 	movw	r0, #55848	; 0xda28
   22b2a:	f2c0 200f 	movt	r0, #527	; 0x20f
   22b2e:	f00b f821 	bl	2db74 <tCycle_free>
	tCycle_free(&pwmLFO2);
   22b32:	f64d 300c 	movw	r0, #56076	; 0xdb0c
}
   22b36:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tCycle_free(&pwmLFO2);
   22b3a:	f2c0 200f 	movt	r0, #527	; 0x20f
   22b3e:	f00b b819 	b.w	2db74 <tCycle_free>
   22b42:	bf00      	nop

00022b44 <SFXRhodesAlloc>:
	leaf.clearOnAllocation = 1;
   22b44:	f64f 0108 	movw	r1, #63496	; 0xf808
	soundNames[0] = "DARK  ";
   22b48:	f244 7280 	movw	r2, #18304	; 0x4780
	soundNames[1] = "LIGHT ";
   22b4c:	f244 7388 	movw	r3, #18312	; 0x4788
	soundNames[4] = "CUSTOM";
   22b50:	f244 70a0 	movw	r0, #18336	; 0x47a0
	leaf.clearOnAllocation = 1;
   22b54:	f2c0 210f 	movt	r1, #527	; 0x20f
	soundNames[0] = "DARK  ";
   22b58:	f2c0 0203 	movt	r2, #3
	soundNames[1] = "LIGHT ";
   22b5c:	f2c0 0303 	movt	r3, #3
	soundNames[4] = "CUSTOM";
   22b60:	f2c0 0003 	movt	r0, #3
{
   22b64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	soundNames[0] = "DARK  ";
   22b68:	f64d 0b88 	movw	fp, #55432	; 0xd888
	leaf.clearOnAllocation = 1;
   22b6c:	460e      	mov	r6, r1
	soundNames[3] = "PAD   ";
   22b6e:	f244 7498 	movw	r4, #18328	; 0x4798
	soundNames[2] = "BASS  ";
   22b72:	f244 7590 	movw	r5, #18320	; 0x4790
	soundNames[0] = "DARK  ";
   22b76:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   22b7a:	f24d 1ad4 	movw	sl, #53716	; 0xd1d4
	soundNames[3] = "PAD   ";
   22b7e:	f2c0 0403 	movt	r4, #3
   22b82:	f64d 09c4 	movw	r9, #55492	; 0xd8c4
	soundNames[0] = "DARK  ";
   22b86:	f8cb 2000 	str.w	r2, [fp]
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22b8a:	2200      	movs	r2, #0
	soundNames[1] = "LIGHT ";
   22b8c:	f8cb 3004 	str.w	r3, [fp, #4]
			tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   22b90:	f64f 63b0 	movw	r3, #65200	; 0xfeb0
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22b94:	f2c4 427a 	movt	r2, #17530	; 0x447a
	soundNames[2] = "BASS  ";
   22b98:	f2c0 0503 	movt	r5, #3
			tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   22b9c:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
   22ba0:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   22ba4:	f2c0 290f 	movt	r9, #527	; 0x20f
	soundNames[2] = "BASS  ";
   22ba8:	f8cb 5008 	str.w	r5, [fp, #8]
{
   22bac:	ed2d 8b04 	vpush	{d8-d9}
   22bb0:	b083      	sub	sp, #12
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22bb2:	ee08 2a90 	vmov	s17, r2
			tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   22bb6:	ee08 3a10 	vmov	s16, r3
	leaf.clearOnAllocation = 1;
   22bba:	9101      	str	r1, [sp, #4]
   22bbc:	2101      	movs	r1, #1
   22bbe:	6171      	str	r1, [r6, #20]
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22bc0:	2100      	movs	r1, #0
   22bc2:	f2c4 21c8 	movt	r1, #17096	; 0x42c8
	soundNames[4] = "CUSTOM";
   22bc6:	e9cb 4003 	strd	r4, r0, [fp, #12]
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22bca:	ee09 1a10 	vmov	s18, r1
	soundNames[4] = "CUSTOM";
   22bce:	2400      	movs	r4, #0
			tCycle_initToPool(&FM_sines[i][j], &smallPool);
   22bd0:	f64a 6690 	movw	r6, #44688	; 0xae90
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22bd4:	f64d 47d8 	movw	r7, #56536	; 0xdcd8
   22bd8:	f104 0818 	add.w	r8, r4, #24
			tCycle_initToPool(&FM_sines[i][j], &smallPool);
   22bdc:	f2c0 260f 	movt	r6, #527	; 0x20f
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22be0:	f2c0 270f 	movt	r7, #527	; 0x20f
   22be4:	eb09 0504 	add.w	r5, r9, r4
			tCycle_initToPool(&FM_sines[i][j], &smallPool);
   22be8:	eb0a 0004 	add.w	r0, sl, r4
   22bec:	4631      	mov	r1, r6
   22bee:	3404      	adds	r4, #4
   22bf0:	f00a ffb2 	bl	2db58 <tCycle_initToPool>
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   22bf4:	4628      	mov	r0, r5
   22bf6:	4633      	mov	r3, r6
   22bf8:	f44f 7200 	mov.w	r2, #512	; 0x200
   22bfc:	4639      	mov	r1, r7
   22bfe:	eef0 1a49 	vmov.f32	s3, s18
   22c02:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
   22c06:	eef0 0a68 	vmov.f32	s1, s17
   22c0a:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   22c0e:	f007 ffe1 	bl	2abd4 <tADSR4_initToPool>
			tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   22c12:	eeb0 0a48 	vmov.f32	s0, s16
   22c16:	4628      	mov	r0, r5
   22c18:	f008 f87a 	bl	2ad10 <tADSR4_setLeakFactor>
		for (int j = 0; j < 6; j++)
   22c1c:	4544      	cmp	r4, r8
   22c1e:	d1e1      	bne.n	22be4 <SFXRhodesAlloc+0xa0>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   22c20:	2cc0      	cmp	r4, #192	; 0xc0
   22c22:	d1d5      	bne.n	22bd0 <SFXRhodesAlloc+0x8c>
   22c24:	f24c 7498 	movw	r4, #51096	; 0xc798
		tExpSmooth_initToPool(&susSmoothers[i], 1.0f, 0.01f, &smallPool);
   22c28:	f24d 730a 	movw	r3, #55050	; 0xd70a
   22c2c:	f64a 6590 	movw	r5, #44688	; 0xae90
   22c30:	f2c0 240f 	movt	r4, #527	; 0x20f
   22c34:	f6c3 4323 	movt	r3, #15395	; 0x3c23
   22c38:	f2c0 250f 	movt	r5, #527	; 0x20f
   22c3c:	f104 0618 	add.w	r6, r4, #24
   22c40:	ee08 3a10 	vmov	s16, r3
   22c44:	4620      	mov	r0, r4
   22c46:	3404      	adds	r4, #4
   22c48:	4629      	mov	r1, r5
   22c4a:	eef0 0a48 	vmov.f32	s1, s16
   22c4e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   22c52:	f008 fb75 	bl	2b340 <tExpSmooth_initToPool>
	for (int i = 0; i < 6; i++)
   22c56:	42a6      	cmp	r6, r4
   22c58:	d1f4      	bne.n	22c44 <SFXRhodesAlloc+0x100>
	tCycle_initToPool(&tremolo, &smallPool);
   22c5a:	f64a 6190 	movw	r1, #44688	; 0xae90
   22c5e:	f64d 3008 	movw	r0, #56072	; 0xdb08
   22c62:	f2c0 210f 	movt	r1, #527	; 0x20f
   22c66:	f2c0 200f 	movt	r0, #527	; 0x20f
   22c6a:	f00a ff75 	bl	2db58 <tCycle_initToPool>
	tCycle_setFreq(&tremolo, 3.0f);
   22c6e:	f64d 3008 	movw	r0, #56072	; 0xdb08
   22c72:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
   22c76:	f2c0 200f 	movt	r0, #527	; 0x20f
   22c7a:	f00a ff7f 	bl	2db7c <tCycle_setFreq>
	tSimplePoly_setNumVoices(&poly, NUM_VOC_VOICES);
   22c7e:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   22c82:	2108      	movs	r1, #8
   22c84:	f2c0 200f 	movt	r0, #527	; 0x20f
   22c88:	f00a ff26 	bl	2dad8 <tSimplePoly_setNumVoices>
	setLED_A(numVoices == 1);
   22c8c:	f246 2354 	movw	r3, #25172	; 0x6254
   22c90:	f2c0 0306 	movt	r3, #6
   22c94:	7818      	ldrb	r0, [r3, #0]
   22c96:	f1a0 0001 	sub.w	r0, r0, #1
   22c9a:	fab0 f080 	clz	r0, r0
   22c9e:	0940      	lsrs	r0, r0, #5
   22ca0:	f7f8 fa48 	bl	1b134 <setLED_A>
	setLED_C(tremoloStereo == 1);
   22ca4:	f646 1374 	movw	r3, #26996	; 0x6974
   22ca8:	f2c0 230e 	movt	r3, #526	; 0x20e
   22cac:	7818      	ldrb	r0, [r3, #0]
   22cae:	f1a0 0001 	sub.w	r0, r0, #1
   22cb2:	fab0 f080 	clz	r0, r0
   22cb6:	0940      	lsrs	r0, r0, #5
   22cb8:	f7f8 fa5c 	bl	1b174 <setLED_C>
	OLEDclearLine(SecondLine);
   22cbc:	2001      	movs	r0, #1
   22cbe:	f7f8 fcd9 	bl	1b674 <OLEDclearLine>
	OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   22cc2:	f646 0078 	movw	r0, #26744	; 0x6878
   22cc6:	2301      	movs	r3, #1
   22cc8:	2200      	movs	r2, #0
   22cca:	f2c0 200e 	movt	r0, #526	; 0x20e
   22cce:	2106      	movs	r1, #6
   22cd0:	6800      	ldr	r0, [r0, #0]
   22cd2:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
   22cd6:	f7f8 fce3 	bl	1b6a0 <OLEDwriteString>
	leaf.clearOnAllocation = 0;
   22cda:	2300      	movs	r3, #0
   22cdc:	9a01      	ldr	r2, [sp, #4]
   22cde:	6153      	str	r3, [r2, #20]
}
   22ce0:	b003      	add	sp, #12
   22ce2:	ecbd 8b04 	vpop	{d8-d9}
   22ce6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22cea:	bf00      	nop

00022cec <SFXRhodesFrame>:
{
   22cec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   22cf0:	f64e 247c 	movw	r4, #60028	; 0xea7c
   22cf4:	f2c0 240f 	movt	r4, #527	; 0x20f
{
   22cf8:	ed2d 8b04 	vpush	{d8-d9}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   22cfc:	7d23      	ldrb	r3, [r4, #20]
{
   22cfe:	b085      	sub	sp, #20
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   22d00:	2b01      	cmp	r3, #1
   22d02:	f000 84d7 	beq.w	236b4 <SFXRhodesFrame+0x9c8>
   22d06:	f246 2354 	movw	r3, #25172	; 0x6254
   22d0a:	f2c0 0306 	movt	r3, #6
   22d0e:	9303      	str	r3, [sp, #12]
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   22d10:	7e23      	ldrb	r3, [r4, #24]
   22d12:	2b01      	cmp	r3, #1
   22d14:	d114      	bne.n	22d40 <SFXRhodesFrame+0x54>
		Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   22d16:	f646 0178 	movw	r1, #26744	; 0x6878
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   22d1a:	2300      	movs	r3, #0
		Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   22d1c:	f246 6267 	movw	r2, #26215	; 0x6667
   22d20:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   22d24:	7623      	strb	r3, [r4, #24]
		Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   22d26:	f2c6 6266 	movt	r2, #26214	; 0x6666
   22d2a:	680b      	ldr	r3, [r1, #0]
   22d2c:	3301      	adds	r3, #1
   22d2e:	fb82 2003 	smull	r2, r0, r2, r3
   22d32:	17da      	asrs	r2, r3, #31
   22d34:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   22d38:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   22d3c:	1a9b      	subs	r3, r3, r2
   22d3e:	600b      	str	r3, [r1, #0]
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   22d40:	7f23      	ldrb	r3, [r4, #28]
   22d42:	2b01      	cmp	r3, #1
   22d44:	f000 84d3 	beq.w	236ee <SFXRhodesFrame+0xa02>
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d48:	f246 233c 	movw	r3, #25148	; 0x623c
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22d4c:	f24d 151c 	movw	r5, #53532	; 0xd11c
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d50:	f24d 32e4 	movw	r2, #54244	; 0xd3e4
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   22d54:	f246 6466 	movw	r4, #26214	; 0x6666
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22d58:	f2c0 250f 	movt	r5, #527	; 0x20f
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d5c:	f2c0 0306 	movt	r3, #6
   22d60:	f2c0 220f 	movt	r2, #527	; 0x20f
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   22d64:	f6c3 74a6 	movt	r4, #16294	; 0x3fa6
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d68:	edd3 6a00 	vldr	s13, [r3]
   22d6c:	f04f 438c 	mov.w	r3, #1174405120	; 0x46000000
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22d70:	edd5 5a08 	vldr	s11, [r5, #32]
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22d74:	462f      	mov	r7, r5
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d76:	ed95 7a05 	vldr	s14, [r5, #20]
   22d7a:	ee06 3a10 	vmov	s12, r3
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22d7e:	edd5 7a06 	vldr	s15, [r5, #24]
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22d82:	2300      	movs	r3, #0
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d84:	ee26 7a87 	vmul.f32	s14, s13, s14
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22d88:	ecb7 3a01 	vldmia	r7!, {s6}
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22d8c:	ee66 7aa7 	vmul.f32	s15, s13, s15
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22d90:	f2c4 437a 	movt	r3, #17530	; 0x447a
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22d94:	ee66 6aa5 	vmul.f32	s13, s13, s11
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   22d98:	ee05 4a90 	vmov	s11, r4
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22d9c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22da0:	f64e 342c 	movw	r4, #60204	; 0xeb2c
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22da4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22da8:	ee01 3a10 	vmov	s2, r3
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22dac:	eefd 6ae6 	vcvt.s32.f32	s13, s13
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   22db0:	ed95 4a03 	vldr	s8, [r5, #12]
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22db4:	ee17 0a10 	vmov	r0, s14
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22db8:	eef1 1a00 	vmov.f32	s3, #16	; 0x40800000  4.0
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22dbc:	ee17 1a90 	vmov	r1, s15
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   22dc0:	eeb2 2a04 	vmov.f32	s4, #36	; 0x41200000  10.0
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22dc4:	ee16 6a90 	vmov	r6, s13
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22dc8:	eb02 0080 	add.w	r0, r2, r0, lsl #2
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22dcc:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   22dd0:	edd5 3a02 	vldr	s7, [r5, #8]
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22dd4:	eb02 0286 	add.w	r2, r2, r6, lsl #2
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22dd8:	edd0 2a00 	vldr	s5, [r0]
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22ddc:	edd1 4a00 	vldr	s9, [r1]
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22de0:	f2c0 240f 	movt	r4, #527	; 0x20f
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22de4:	ed92 5a00 	vldr	s10, [r2]
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22de8:	f246 06b8 	movw	r6, #24760	; 0x60b8
   22dec:	edd5 6a0a 	vldr	s13, [r5, #40]	; 0x28
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   22df0:	ee64 5a25 	vmul.f32	s11, s8, s11
	FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   22df4:	ed95 7a0b 	vldr	s14, [r5, #44]	; 0x2c
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22df8:	ee62 2a86 	vmul.f32	s5, s5, s12
	FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   22dfc:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22e00:	ee66 6a81 	vmul.f32	s13, s13, s2
	displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
   22e04:	683b      	ldr	r3, [r7, #0]
	FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   22e06:	ee27 7a01 	vmul.f32	s14, s14, s2
	FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   22e0a:	ee67 7a81 	vmul.f32	s15, s15, s2
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22e0e:	f2c0 0606 	movt	r6, #6
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22e12:	ee64 4a86 	vmul.f32	s9, s9, s12
	displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
   22e16:	6929      	ldr	r1, [r5, #16]
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22e18:	ee23 3a21 	vmul.f32	s6, s6, s3
	displayValues[7] = presetKnobValues[Rhodes][7];
   22e1c:	69ea      	ldr	r2, [r5, #28]
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   22e1e:	ee63 3a82 	vmul.f32	s7, s7, s4
	displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
   22e22:	6063      	str	r3, [r4, #4]
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22e24:	ee25 6a06 	vmul.f32	s12, s10, s12
	displayValues[9] = presetKnobValues[Rhodes][9];
   22e28:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   22e2a:	edc4 5a03 	vstr	s11, [r4, #12]
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22e2e:	eefa 0a04 	vmov.f32	s1, #164	; 0xc1200000 -10.0
	displayValues[9] = presetKnobValues[Rhodes][9];
   22e32:	6263      	str	r3, [r4, #36]	; 0x24
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22e34:	f64d 2870 	movw	r8, #55920	; 0xda70
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   22e38:	edc4 2a05 	vstr	s5, [r4, #20]
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   22e3c:	ed84 3a00 	vstr	s6, [r4]
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22e40:	f2c0 280f 	movt	r8, #527	; 0x20f
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   22e44:	edc4 3a02 	vstr	s7, [r4, #8]
	displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
   22e48:	6121      	str	r1, [r4, #16]
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22e4a:	2100      	movs	r1, #0
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   22e4c:	edc4 4a06 	vstr	s9, [r4, #24]
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   22e50:	ed84 6a08 	vstr	s12, [r4, #32]
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22e54:	ee00 1a10 	vmov	s0, r1
	displayValues[7] = presetKnobValues[Rhodes][7];
   22e58:	61e2      	str	r2, [r4, #28]
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   22e5a:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
   22e5e:	edc6 6a18 	vstr	s13, [r6, #96]	; 0x60
	FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   22e62:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
   22e66:	ed86 7a19 	vstr	s14, [r6, #100]	; 0x64
	FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   22e6a:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
   22e6e:	edc6 7a1a 	vstr	s15, [r6, #104]	; 0x68
	FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   22e72:	ed95 7a0d 	vldr	s14, [r5, #52]	; 0x34
	FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   22e76:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
	FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   22e7a:	ee27 7a01 	vmul.f32	s14, s14, s2
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22e7e:	edd5 6a15 	vldr	s13, [r5, #84]	; 0x54
	FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   22e82:	ee67 7a81 	vmul.f32	s15, s15, s2
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22e86:	eee6 0a81 	vfma.f32	s1, s13, s2
	FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   22e8a:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
   22e8e:	ed86 7a1b 	vstr	s14, [r6, #108]	; 0x6c
	FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   22e92:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
   22e96:	edc6 7a1c 	vstr	s15, [r6, #112]	; 0x70
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22e9a:	f009 ffa1 	bl	2cde0 <LEAF_clip>
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22e9e:	edd8 6a0f 	vldr	s13, [r8, #60]	; 0x3c
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22ea2:	f246 235c 	movw	r3, #25180	; 0x625c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22ea6:	ed95 4a0f 	vldr	s8, [r5, #60]	; 0x3c
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22eaa:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   22eae:	f2c0 0306 	movt	r3, #6
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22eb2:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22eb6:	eef4 6a44 	vcmp.f32	s13, s8
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   22eba:	ed86 0a1d 	vstr	s0, [r6, #116]	; 0x74
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22ebe:	ed93 7a00 	vldr	s14, [r3]
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22ec2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22ec6:	ee75 7ac7 	vsub.f32	s15, s11, s14
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22eca:	d01d      	beq.n	22f08 <SFXRhodesFrame+0x21c>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   22ecc:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   22ed0:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   22ed4:	ee74 6a66 	vsub.f32	s13, s8, s13
   22ed8:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22edc:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   22ee0:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22ee4:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   22ee8:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
   22eec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22ef0:	f100 842d 	bmi.w	2374e <SFXRhodesFrame+0xa62>
			else rate += 1.0f;
   22ef4:	ee36 6a25 	vadd.f32	s12, s12, s11
			FM_freqRatios[4][k-15] = rate;
   22ef8:	f246 0240 	movw	r2, #24640	; 0x6040
			displayValues[k] = rate;
   22efc:	ed84 6a0f 	vstr	s12, [r4, #60]	; 0x3c
			FM_freqRatios[4][k-15] = rate;
   22f00:	f2c0 0206 	movt	r2, #6
   22f04:	ed82 6a18 	vstr	s12, [r2, #96]	; 0x60
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22f08:	f24d 125c 	movw	r2, #53596	; 0xd15c
   22f0c:	edd8 6a10 	vldr	s13, [r8, #64]	; 0x40
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   22f10:	ed88 4a0f 	vstr	s8, [r8, #60]	; 0x3c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22f14:	f2c0 220f 	movt	r2, #527	; 0x20f
   22f18:	edd2 4a00 	vldr	s9, [r2]
   22f1c:	eef4 6a64 	vcmp.f32	s13, s9
   22f20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22f24:	d021      	beq.n	22f6a <SFXRhodesFrame+0x27e>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   22f26:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   22f2a:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   22f2e:	ee74 6ae6 	vsub.f32	s13, s9, s13
   22f32:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22f36:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   22f3a:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22f3e:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   22f42:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22f46:	eef0 6a46 	vmov.f32	s13, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   22f4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22f4e:	f100 8406 	bmi.w	2375e <SFXRhodesFrame+0xa72>
			else rate += 1.0f;
   22f52:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   22f56:	ee36 6a86 	vadd.f32	s12, s13, s12
			FM_freqRatios[4][k-15] = rate;
   22f5a:	f246 0240 	movw	r2, #24640	; 0x6040
			displayValues[k] = rate;
   22f5e:	ed84 6a10 	vstr	s12, [r4, #64]	; 0x40
			FM_freqRatios[4][k-15] = rate;
   22f62:	f2c0 0206 	movt	r2, #6
   22f66:	ed82 6a19 	vstr	s12, [r2, #100]	; 0x64
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22f6a:	f24d 1260 	movw	r2, #53600	; 0xd160
   22f6e:	edd8 6a11 	vldr	s13, [r8, #68]	; 0x44
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   22f72:	edc8 4a10 	vstr	s9, [r8, #64]	; 0x40
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22f76:	f2c0 220f 	movt	r2, #527	; 0x20f
   22f7a:	ed92 5a00 	vldr	s10, [r2]
   22f7e:	eef4 6a45 	vcmp.f32	s13, s10
   22f82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22f86:	d021      	beq.n	22fcc <SFXRhodesFrame+0x2e0>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   22f88:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   22f8c:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   22f90:	ee75 6a66 	vsub.f32	s13, s10, s13
   22f94:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22f98:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   22f9c:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22fa0:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   22fa4:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22fa8:	eef0 6a46 	vmov.f32	s13, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   22fac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22fb0:	f100 83df 	bmi.w	23772 <SFXRhodesFrame+0xa86>
			else rate += 1.0f;
   22fb4:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   22fb8:	ee36 6a86 	vadd.f32	s12, s13, s12
			FM_freqRatios[4][k-15] = rate;
   22fbc:	f246 0240 	movw	r2, #24640	; 0x6040
			displayValues[k] = rate;
   22fc0:	ed84 6a11 	vstr	s12, [r4, #68]	; 0x44
			FM_freqRatios[4][k-15] = rate;
   22fc4:	f2c0 0206 	movt	r2, #6
   22fc8:	ed82 6a1a 	vstr	s12, [r2, #104]	; 0x68
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22fcc:	f24d 1264 	movw	r2, #53604	; 0xd164
   22fd0:	edd8 6a12 	vldr	s13, [r8, #72]	; 0x48
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   22fd4:	ed88 5a11 	vstr	s10, [r8, #68]	; 0x44
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   22fd8:	f2c0 220f 	movt	r2, #527	; 0x20f
   22fdc:	edd2 5a00 	vldr	s11, [r2]
   22fe0:	eef4 6a65 	vcmp.f32	s13, s11
   22fe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22fe8:	d021      	beq.n	2302e <SFXRhodesFrame+0x342>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   22fea:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   22fee:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   22ff2:	ee75 6ae6 	vsub.f32	s13, s11, s13
   22ff6:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   22ffa:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   22ffe:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   23002:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23006:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2300a:	eef0 6a46 	vmov.f32	s13, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2300e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23012:	f100 837c 	bmi.w	2370e <SFXRhodesFrame+0xa22>
			else rate += 1.0f;
   23016:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2301a:	ee36 6a86 	vadd.f32	s12, s13, s12
			FM_freqRatios[4][k-15] = rate;
   2301e:	f246 0240 	movw	r2, #24640	; 0x6040
			displayValues[k] = rate;
   23022:	ed84 6a12 	vstr	s12, [r4, #72]	; 0x48
			FM_freqRatios[4][k-15] = rate;
   23026:	f2c0 0206 	movt	r2, #6
   2302a:	ed82 6a1b 	vstr	s12, [r2, #108]	; 0x6c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2302e:	f24d 1268 	movw	r2, #53608	; 0xd168
   23032:	edd8 6a13 	vldr	s13, [r8, #76]	; 0x4c
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   23036:	edc8 5a12 	vstr	s11, [r8, #72]	; 0x48
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2303a:	f2c0 220f 	movt	r2, #527	; 0x20f
   2303e:	ed92 6a00 	vldr	s12, [r2]
   23042:	eef4 6a46 	vcmp.f32	s13, s12
   23046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2304a:	d021      	beq.n	23090 <SFXRhodesFrame+0x3a4>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2304c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   23050:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
   23054:	ee76 6a66 	vsub.f32	s13, s12, s13
   23058:	ee66 6aa3 	vmul.f32	s13, s13, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2305c:	ee67 3aa6 	vmul.f32	s7, s15, s13
			float snapRate = roundf(rawRate);
   23060:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   23064:	eee7 3a26 	vfma.f32	s7, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23068:	eef5 3ac0 	vcmpe.f32	s7, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2306c:	eef0 6a63 	vmov.f32	s13, s7
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23070:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23074:	f100 8354 	bmi.w	23720 <SFXRhodesFrame+0xa34>
			else rate += 1.0f;
   23078:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
   2307c:	ee76 3aa3 	vadd.f32	s7, s13, s7
			FM_freqRatios[4][k-15] = rate;
   23080:	f246 0240 	movw	r2, #24640	; 0x6040
			displayValues[k] = rate;
   23084:	edc4 3a13 	vstr	s7, [r4, #76]	; 0x4c
			FM_freqRatios[4][k-15] = rate;
   23088:	f2c0 0206 	movt	r2, #6
   2308c:	edc2 3a1c 	vstr	s7, [r2, #112]	; 0x70
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   23090:	f24d 126c 	movw	r2, #53612	; 0xd16c
   23094:	edd8 3a14 	vldr	s7, [r8, #80]	; 0x50
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   23098:	ed88 6a13 	vstr	s12, [r8, #76]	; 0x4c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2309c:	f2c0 220f 	movt	r2, #527	; 0x20f
   230a0:	edd2 6a00 	vldr	s13, [r2]
   230a4:	eef4 6a63 	vcmp.f32	s13, s7
   230a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   230ac:	d01f      	beq.n	230ee <SFXRhodesFrame+0x402>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   230ae:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
   230b2:	eeb2 3a0c 	vmov.f32	s6, #44	; 0x41600000  14.0
   230b6:	ee76 3ae3 	vsub.f32	s7, s13, s7
   230ba:	ee63 3a83 	vmul.f32	s7, s7, s6
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   230be:	ee67 7aa3 	vmul.f32	s15, s15, s7
			float snapRate = roundf(rawRate);
   230c2:	fef8 3a63 	vrinta.f32	s7, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   230c6:	eee7 7a23 	vfma.f32	s15, s14, s7
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   230ca:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   230ce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   230d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   230d6:	f100 832c 	bmi.w	23732 <SFXRhodesFrame+0xa46>
			else rate += 1.0f;
   230da:	ee77 7a87 	vadd.f32	s15, s15, s14
			FM_freqRatios[4][k-15] = rate;
   230de:	f246 0240 	movw	r2, #24640	; 0x6040
			displayValues[k] = rate;
   230e2:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
			FM_freqRatios[4][k-15] = rate;
   230e6:	f2c0 0206 	movt	r2, #6
   230ea:	edc2 7a1d 	vstr	s15, [r2, #116]	; 0x74
	if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
   230ee:	f24d 1274 	movw	r2, #53620	; 0xd174
   230f2:	edd8 7a16 	vldr	s15, [r8, #88]	; 0x58
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   230f6:	edc8 6a14 	vstr	s13, [r8, #80]	; 0x50
	if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
   230fa:	f2c0 220f 	movt	r2, #527	; 0x20f
   230fe:	ed92 7a00 	vldr	s14, [r2]
   23102:	eeb4 7a67 	vcmp.f32	s14, s15
   23106:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2310a:	f000 80ba 	beq.w	23282 <SFXRhodesFrame+0x596>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2310e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
		overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
   23112:	ed84 7a16 	vstr	s14, [r4, #88]	; 0x58
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23116:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
		overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
   2311a:	ed83 7a00 	vstr	s14, [r3]
   2311e:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23122:	ee34 4a67 	vsub.f32	s8, s8, s15
   23126:	ee73 7a47 	vsub.f32	s15, s6, s14
   2312a:	ee24 4a23 	vmul.f32	s8, s8, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2312e:	ee64 3a27 	vmul.f32	s7, s8, s15
			float snapRate = roundf(rawRate);
   23132:	feb8 4a44 	vrinta.f32	s8, s8
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   23136:	eee7 3a04 	vfma.f32	s7, s14, s8
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2313a:	eef5 3ac0 	vcmpe.f32	s7, #0.0
   2313e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23142:	f100 82fd 	bmi.w	23740 <SFXRhodesFrame+0xa54>
			else rate += 1.0f;
   23146:	ee33 4a83 	vadd.f32	s8, s7, s6
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2314a:	eeb6 3a00 	vmov.f32	s6, #96	; 0x3f000000  0.5
			FM_freqRatios[4][k-15] = rate;
   2314e:	f246 0340 	movw	r3, #24640	; 0x6040
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23152:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
			displayValues[k] = rate;
   23156:	ed84 4a0f 	vstr	s8, [r4, #60]	; 0x3c
			FM_freqRatios[4][k-15] = rate;
   2315a:	f2c0 0306 	movt	r3, #6
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2315e:	ee74 4ac3 	vsub.f32	s9, s9, s6
			FM_freqRatios[4][k-15] = rate;
   23162:	ed83 4a18 	vstr	s8, [r3, #96]	; 0x60
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23166:	ee64 4aa3 	vmul.f32	s9, s9, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2316a:	ee24 4aa7 	vmul.f32	s8, s9, s15
			float snapRate = roundf(rawRate);
   2316e:	fef8 4a64 	vrinta.f32	s9, s9
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   23172:	eea7 4a24 	vfma.f32	s8, s14, s9
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23176:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2317a:	eef0 4a44 	vmov.f32	s9, s8
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2317e:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
   23182:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23186:	f100 8319 	bmi.w	237bc <SFXRhodesFrame+0xad0>
			else rate += 1.0f;
   2318a:	ee74 4a84 	vadd.f32	s9, s9, s8
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2318e:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   23192:	edc4 4a10 	vstr	s9, [r4, #64]	; 0x40
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23196:	eeb2 4a0c 	vmov.f32	s8, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   2319a:	edc3 4a19 	vstr	s9, [r3, #100]	; 0x64
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2319e:	ee35 5a63 	vsub.f32	s10, s10, s7
   231a2:	ee25 5a04 	vmul.f32	s10, s10, s8
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   231a6:	ee65 4a27 	vmul.f32	s9, s10, s15
			float snapRate = roundf(rawRate);
   231aa:	feb8 5a45 	vrinta.f32	s10, s10
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   231ae:	eee7 4a05 	vfma.f32	s9, s14, s10
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   231b2:	eef5 4ac0 	vcmpe.f32	s9, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   231b6:	eeb0 5a64 	vmov.f32	s10, s9
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   231ba:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
   231be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   231c2:	f100 82f4 	bmi.w	237ae <SFXRhodesFrame+0xac2>
			else rate += 1.0f;
   231c6:	ee35 5a24 	vadd.f32	s10, s10, s9
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   231ca:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   231ce:	ed84 5a11 	vstr	s10, [r4, #68]	; 0x44
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   231d2:	eef2 4a0c 	vmov.f32	s9, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   231d6:	ed83 5a1a 	vstr	s10, [r3, #104]	; 0x68
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   231da:	ee75 5ac4 	vsub.f32	s11, s11, s8
   231de:	ee65 5aa4 	vmul.f32	s11, s11, s9
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   231e2:	ee25 5aa7 	vmul.f32	s10, s11, s15
			float snapRate = roundf(rawRate);
   231e6:	fef8 5a65 	vrinta.f32	s11, s11
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   231ea:	eea7 5a25 	vfma.f32	s10, s14, s11
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   231ee:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   231f2:	eef0 5a45 	vmov.f32	s11, s10
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   231f6:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   231fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   231fe:	f100 82cf 	bmi.w	237a0 <SFXRhodesFrame+0xab4>
			else rate += 1.0f;
   23202:	ee75 5a85 	vadd.f32	s11, s11, s10
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23206:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   2320a:	edc4 5a12 	vstr	s11, [r4, #72]	; 0x48
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2320e:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   23212:	edc3 5a1b 	vstr	s11, [r3, #108]	; 0x6c
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23216:	ee36 6a64 	vsub.f32	s12, s12, s9
   2321a:	ee26 6a05 	vmul.f32	s12, s12, s10
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2321e:	ee66 5a27 	vmul.f32	s11, s12, s15
			float snapRate = roundf(rawRate);
   23222:	feb8 6a46 	vrinta.f32	s12, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   23226:	eee7 5a06 	vfma.f32	s11, s14, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2322a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2322e:	eeb0 6a65 	vmov.f32	s12, s11
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23232:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   23236:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2323a:	f100 82aa 	bmi.w	23792 <SFXRhodesFrame+0xaa6>
			else rate += 1.0f;
   2323e:	ee36 6a25 	vadd.f32	s12, s12, s11
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23242:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   23246:	ed84 6a13 	vstr	s12, [r4, #76]	; 0x4c
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2324a:	eef2 5a0c 	vmov.f32	s11, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   2324e:	ed83 6a1c 	vstr	s12, [r3, #112]	; 0x70
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   23252:	ee76 6ac5 	vsub.f32	s13, s13, s10
   23256:	ee66 6aa5 	vmul.f32	s13, s13, s11
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2325a:	ee66 7aa7 	vmul.f32	s15, s13, s15
			float snapRate = roundf(rawRate);
   2325e:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   23262:	eee7 7a26 	vfma.f32	s15, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23266:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2326a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2326e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23272:	f100 8287 	bmi.w	23784 <SFXRhodesFrame+0xa98>
			else rate += 1.0f;
   23276:	ee77 7aa6 	vadd.f32	s15, s15, s13
			displayValues[k] = rate;
   2327a:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
			FM_freqRatios[4][k-15] = rate;
   2327e:	edc3 7a1d 	vstr	s15, [r3, #116]	; 0x74
	if (prevDisplayValues[23] != displayValues[23])
   23282:	f24d 335c 	movw	r3, #54108	; 0xd35c
	displayValues[23] = presetKnobValues[Rhodes][23];
   23286:	f24d 1278 	movw	r2, #53624	; 0xd178
	prevKnobValues[22] = presetKnobValues[Rhodes][22];
   2328a:	ed88 7a16 	vstr	s14, [r8, #88]	; 0x58
	if (prevDisplayValues[23] != displayValues[23])
   2328e:	f2c0 230f 	movt	r3, #527	; 0x20f
	displayValues[23] = presetKnobValues[Rhodes][23];
   23292:	f2c0 220f 	movt	r2, #527	; 0x20f
	if (prevDisplayValues[23] != displayValues[23])
   23296:	ed93 7a17 	vldr	s14, [r3, #92]	; 0x5c
	displayValues[23] = presetKnobValues[Rhodes][23];
   2329a:	edd2 7a00 	vldr	s15, [r2]
	if (prevDisplayValues[23] != displayValues[23])
   2329e:	9302      	str	r3, [sp, #8]
   232a0:	eef4 7a47 	vcmp.f32	s15, s14
	displayValues[23] = presetKnobValues[Rhodes][23];
   232a4:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
	if (prevDisplayValues[23] != displayValues[23])
   232a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   232ac:	d04a      	beq.n	23344 <SFXRhodesFrame+0x658>
   232ae:	f246 2978 	movw	r9, #25208	; 0x6278
			randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   232b2:	f248 531f 	movw	r3, #34079	; 0x851f
   232b6:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
   232ba:	f2c0 0906 	movt	r9, #6
   232be:	f6cb 736b 	movt	r3, #49003	; 0xbf6b
   232c2:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   232c6:	f109 0518 	add.w	r5, r9, #24
	if (prevDisplayValues[23] != displayValues[23])
   232ca:	464e      	mov	r6, r9
			randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   232cc:	ee08 3a10 	vmov	s16, r3
			float randomNumberDraw = (randomNumber() * 2.0f) + 0.08f;
   232d0:	f7f7 fe4e 	bl	1af70 <randomNumber>
			randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   232d4:	eeb0 7a48 	vmov.f32	s14, s16
   232d8:	eef0 6a68 	vmov.f32	s13, s17
   232dc:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
   232e0:	eea0 7a09 	vfma.f32	s14, s0, s18
   232e4:	eee7 6a27 	vfma.f32	s13, s14, s15
   232e8:	ece6 6a01 	vstmia	r6!, {s13}
		for (int i = 0; i < 6; i++)
   232ec:	42ae      	cmp	r6, r5
   232ee:	d1ef      	bne.n	232d0 <SFXRhodesFrame+0x5e4>
   232f0:	f64d 07c4 	movw	r7, #55492	; 0xd8c4
				tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
   232f4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   232f8:	f2c0 270f 	movt	r7, #527	; 0x20f
   232fc:	f2c4 639c 	movt	r3, #18076	; 0x469c
   23300:	f107 0ac0 	add.w	sl, r7, #192	; 0xc0
   23304:	ee08 3a10 	vmov	s16, r3
	if (prevDisplayValues[23] != displayValues[23])
   23308:	46bb      	mov	fp, r7
   2330a:	464d      	mov	r5, r9
				tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
   2330c:	ecf5 0a01 	vldmia	r5!, {s1}
   23310:	eeb0 1a48 	vmov.f32	s2, s16
   23314:	edd4 7a06 	vldr	s15, [r4, #24]
   23318:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   2331c:	ee60 0aa7 	vmul.f32	s1, s1, s15
   23320:	f009 fd5e 	bl	2cde0 <LEAF_clip>
   23324:	4658      	mov	r0, fp
   23326:	f007 fcc1 	bl	2acac <tADSR4_setDecay>
			for (int j = 0; j < 6; j++)
   2332a:	42b5      	cmp	r5, r6
   2332c:	f10b 0b04 	add.w	fp, fp, #4
   23330:	d1ec      	bne.n	2330c <SFXRhodesFrame+0x620>
   23332:	3718      	adds	r7, #24
		for (int i = 0; i < NUM_VOC_VOICES; i++)
   23334:	4557      	cmp	r7, sl
   23336:	d1e7      	bne.n	23308 <SFXRhodesFrame+0x61c>
   23338:	f24d 1378 	movw	r3, #53624	; 0xd178
   2333c:	f2c0 230f 	movt	r3, #527	; 0x20f
   23340:	ed93 7a00 	vldr	s14, [r3]
	displayValues[24] = presetKnobValues[Rhodes][24];
   23344:	f24d 137c 	movw	r3, #53628	; 0xd17c
	if (prevDisplayValues[24] != displayValues[24])
   23348:	9a02      	ldr	r2, [sp, #8]
	prevKnobValues[23] = presetKnobValues[Rhodes][23];
   2334a:	ed88 7a17 	vstr	s14, [r8, #92]	; 0x5c
	displayValues[24] = presetKnobValues[Rhodes][24];
   2334e:	f2c0 230f 	movt	r3, #527	; 0x20f
	if (prevDisplayValues[24] != displayValues[24])
   23352:	edd2 7a18 	vldr	s15, [r2, #96]	; 0x60
	displayValues[24] = presetKnobValues[Rhodes][24];
   23356:	edd3 6a00 	vldr	s13, [r3]
	if (prevDisplayValues[24] != displayValues[24])
   2335a:	eef4 6a67 	vcmp.f32	s13, s15
	displayValues[24] = presetKnobValues[Rhodes][24];
   2335e:	edc4 6a18 	vstr	s13, [r4, #96]	; 0x60
	if (prevDisplayValues[24] != displayValues[24])
   23362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23366:	d02a      	beq.n	233be <SFXRhodesFrame+0x6d2>
   23368:	f246 2590 	movw	r5, #25232	; 0x6290
   2336c:	f24c 7698 	movw	r6, #51096	; 0xc798
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   23370:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
   23374:	f2c0 0506 	movt	r5, #6
   23378:	eeff 8a00 	vmov.f32	s17, #240	; 0xbf800000 -1.0
   2337c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   23380:	f2c0 260f 	movt	r6, #527	; 0x20f
   23384:	f105 0718 	add.w	r7, r5, #24
			float randomNumberDraw = randomNumber() * 2.0f;
   23388:	f7f7 fdf2 	bl	1af70 <randomNumber>
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   2338c:	eeb0 7a68 	vmov.f32	s14, s17
   23390:	eef0 6a48 	vmov.f32	s13, s16
   23394:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
			tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   23398:	4630      	mov	r0, r6
   2339a:	3604      	adds	r6, #4
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   2339c:	eea0 7a09 	vfma.f32	s14, s0, s18
			tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   233a0:	ed94 0a07 	vldr	s0, [r4, #28]
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   233a4:	eee7 6a27 	vfma.f32	s13, s14, s15
   233a8:	ece5 6a01 	vstmia	r5!, {s13}
			tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   233ac:	ee26 0a80 	vmul.f32	s0, s13, s0
   233b0:	f008 f802 	bl	2b3b8 <tExpSmooth_setDest>
		for (int i = 0; i < 6; i++)
   233b4:	42bd      	cmp	r5, r7
   233b6:	d1e7      	bne.n	23388 <SFXRhodesFrame+0x69c>
   233b8:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
   233bc:	9a02      	ldr	r2, [sp, #8]
							tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   233be:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   233c2:	f64b 06f8 	movw	r6, #47352	; 0xb8f8
   233c6:	f24d 3870 	movw	r8, #54128	; 0xd370
	prevDisplayValues[24] = displayValues[24];
   233ca:	f04f 0a06 	mov.w	sl, #6
							tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   233ce:	f2c4 639c 	movt	r3, #18076	; 0x469c
   233d2:	f2c0 260f 	movt	r6, #527	; 0x20f
   233d6:	f2c0 280f 	movt	r8, #527	; 0x20f
	prevDisplayValues[24] = displayValues[24];
   233da:	edc2 7a18 	vstr	s15, [r2, #96]	; 0x60
							tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   233de:	ee08 3a10 	vmov	s16, r3
   233e2:	f64e 3340 	movw	r3, #60224	; 0xeb40
   233e6:	f2c0 230f 	movt	r3, #527	; 0x20f
   233ea:	9301      	str	r3, [sp, #4]
		if (prevDisplayValues[k] != displayValues[k])
   233ec:	ecf3 7a01 	vldmia	r3!, {s15}
   233f0:	ecb8 7a01 	vldmia	r8!, {s14}
   233f4:	9301      	str	r3, [sp, #4]
   233f6:	eeb4 7a67 	vcmp.f32	s14, s15
   233fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   233fe:	d035      	beq.n	2346c <SFXRhodesFrame+0x780>
			switch(k)
   23400:	f1aa 0307 	sub.w	r3, sl, #7
   23404:	2b03      	cmp	r3, #3
   23406:	d805      	bhi.n	23414 <SFXRhodesFrame+0x728>
   23408:	e8df f013 	tbh	[pc, r3, lsl #1]
   2340c:	010a0126 	.word	0x010a0126
   23410:	003900f2 	.word	0x003900f2
   23414:	f64d 0bc4 	movw	fp, #55492	; 0xd8c4
							uint64_t tempCount1 = DWT->CYCCNT;
   23418:	f44f 5580 	mov.w	r5, #4096	; 0x1000
   2341c:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   23420:	f2ce 0500 	movt	r5, #57344	; 0xe000
   23424:	f10b 0718 	add.w	r7, fp, #24
							cycleCountVals[1][2] = 0;
   23428:	2200      	movs	r2, #0
   2342a:	2300      	movs	r3, #0
							tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
   2342c:	4658      	mov	r0, fp
   2342e:	ed94 0a05 	vldr	s0, [r4, #20]
   23432:	f10b 0b04 	add.w	fp, fp, #4
							cycleCountVals[1][2] = 0;
   23436:	e9c6 230a 	strd	r2, r3, [r6, #40]	; 0x28
							uint64_t tempCount1 = DWT->CYCCNT;
   2343a:	f8d5 9004 	ldr.w	r9, [r5, #4]
							tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
   2343e:	f007 fc27 	bl	2ac90 <tADSR4_setAttack>
							uint64_t tempCount2 = DWT->CYCCNT;
   23442:	686a      	ldr	r2, [r5, #4]
							CycleCounterTrackMinAndMax(1);
   23444:	2001      	movs	r0, #1
							cycleCountVals[1][1] = tempCount2-tempCount1;
   23446:	ebb2 0209 	subs.w	r2, r2, r9
   2344a:	eb62 0302 	sbc.w	r3, r2, r2
   2344e:	e9c6 2308 	strd	r2, r3, [r6, #32]
							CycleCounterTrackMinAndMax(1);
   23452:	f7f7 fdd3 	bl	1affc <CycleCounterTrackMinAndMax>
						for (int j = 0; j < 6; j++)
   23456:	455f      	cmp	r7, fp
   23458:	d1e6      	bne.n	23428 <SFXRhodesFrame+0x73c>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   2345a:	f64d 1384 	movw	r3, #55684	; 0xd984
   2345e:	f2c0 230f 	movt	r3, #527	; 0x20f
   23462:	429f      	cmp	r7, r3
   23464:	d1de      	bne.n	23424 <SFXRhodesFrame+0x738>
   23466:	9b01      	ldr	r3, [sp, #4]
   23468:	ed53 7a01 	vldr	s15, [r3, #-4]
	for (int k = 5; k < 10; k++)
   2346c:	f1ba 0f0a 	cmp.w	sl, #10
		prevDisplayValues[k] = displayValues[k];
   23470:	ed48 7a01 	vstr	s15, [r8, #-4]
	for (int k = 5; k < 10; k++)
   23474:	d02c      	beq.n	234d0 <SFXRhodesFrame+0x7e4>
   23476:	f10a 0a01 	add.w	sl, sl, #1
   2347a:	9b01      	ldr	r3, [sp, #4]
   2347c:	e7b6      	b.n	233ec <SFXRhodesFrame+0x700>
   2347e:	f64d 05c4 	movw	r5, #55492	; 0xd8c4
							tADSR4_setLeakFactor(&FM_envs[i][j], ((1.0f - displayValues[9])  * 0.00004f) + 0.99996f);
   23482:	f24c 52ac 	movw	r2, #50604	; 0xc5ac
   23486:	f64f 5361 	movw	r3, #64865	; 0xfd61
   2348a:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   2348e:	f2c0 250f 	movt	r5, #527	; 0x20f
   23492:	f6c3 0227 	movt	r2, #14375	; 0x3827
   23496:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
   2349a:	f105 07c0 	add.w	r7, r5, #192	; 0xc0
   2349e:	ee08 2a90 	vmov	s17, r2
   234a2:	ee08 3a10 	vmov	s16, r3
   234a6:	f105 0618 	add.w	r6, r5, #24
   234aa:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   234ae:	eeb0 0a48 	vmov.f32	s0, s16
   234b2:	4628      	mov	r0, r5
   234b4:	3504      	adds	r5, #4
   234b6:	ee79 7a67 	vsub.f32	s15, s18, s15
   234ba:	eea7 0aa8 	vfma.f32	s0, s15, s17
   234be:	f007 fc27 	bl	2ad10 <tADSR4_setLeakFactor>
						for (int j = 0; j < 6; j++)
   234c2:	42b5      	cmp	r5, r6
   234c4:	d1f1      	bne.n	234aa <SFXRhodesFrame+0x7be>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   234c6:	42bd      	cmp	r5, r7
   234c8:	d1ed      	bne.n	234a6 <SFXRhodesFrame+0x7ba>
		prevDisplayValues[k] = displayValues[k];
   234ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
   234cc:	9a02      	ldr	r2, [sp, #8]
   234ce:	6253      	str	r3, [r2, #36]	; 0x24
	for (int i = 0; i < numVoices; i++)
   234d0:	9e03      	ldr	r6, [sp, #12]
   234d2:	7833      	ldrb	r3, [r6, #0]
   234d4:	2b00      	cmp	r3, #0
   234d6:	d07e      	beq.n	235d6 <SFXRhodesFrame+0x8ea>
   234d8:	f64d 0abc 	movw	sl, #55484	; 0xd8bc
   234dc:	f24d 1ba4 	movw	fp, #53668	; 0xd1a4
   234e0:	f646 1840 	movw	r8, #26944	; 0x6940
   234e4:	f646 1784 	movw	r7, #27012	; 0x6984
   234e8:	f646 13b8 	movw	r3, #27064	; 0x69b8
				if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   234ec:	f64d 02c4 	movw	r2, #55492	; 0xd8c4
   234f0:	f2c0 2a0f 	movt	sl, #527	; 0x20f
   234f4:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   234f8:	f2c0 280e 	movt	r8, #526	; 0x20e
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   234fc:	f64a 29ab 	movw	r9, #43691	; 0xaaab
   23500:	f2c0 270e 	movt	r7, #526	; 0x20e
   23504:	f2c0 230e 	movt	r3, #526	; 0x20e
				if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   23508:	f2c0 220f 	movt	r2, #527	; 0x20f
	for (int i = 0; i < numVoices; i++)
   2350c:	9403      	str	r4, [sp, #12]
   2350e:	9301      	str	r3, [sp, #4]
   23510:	465c      	mov	r4, fp
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   23512:	f6c2 29aa 	movt	r9, #10922	; 0x2aaa
	for (int i = 0; i < numVoices; i++)
   23516:	46d3      	mov	fp, sl
				if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   23518:	9202      	str	r2, [sp, #8]
	for (int i = 0; i < numVoices; i++)
   2351a:	46c2      	mov	sl, r8
   2351c:	2500      	movs	r5, #0
   2351e:	46b8      	mov	r8, r7
   23520:	e002      	b.n	23528 <SFXRhodesFrame+0x83c>
   23522:	3501      	adds	r5, #1
   23524:	42a9      	cmp	r1, r5
   23526:	dd55      	ble.n	235d4 <SFXRhodesFrame+0x8e8>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   23528:	b2ef      	uxtb	r7, r5
   2352a:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   2352e:	4639      	mov	r1, r7
   23530:	f2c0 200f 	movt	r0, #527	; 0x20f
   23534:	f00a faf4 	bl	2db20 <tSimplePoly_getPitch>
   23538:	ee07 0a90 	vmov	s15, r0
   2353c:	ed9a 0a00 	vldr	s0, [sl]
   23540:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   23544:	9b01      	ldr	r3, [sp, #4]
   23546:	7818      	ldrb	r0, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   23548:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2354c:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   23550:	ee17 1a90 	vmov	r1, s15
   23554:	1a09      	subs	r1, r1, r0
   23556:	fb89 3c01 	smull	r3, ip, r9, r1
   2355a:	17c8      	asrs	r0, r1, #31
   2355c:	ebc0 006c 	rsb	r0, r0, ip, asr #1
   23560:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   23564:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   23568:	ee07 0a90 	vmov	s15, r0
   2356c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   23570:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   23574:	ee17 1a90 	vmov	r1, s15
   23578:	eb08 0181 	add.w	r1, r8, r1, lsl #2
   2357c:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   23580:	ee37 0a00 	vadd.f32	s0, s14, s0
   23584:	f009 fd14 	bl	2cfb0 <LEAF_midiToFrequency>
		if (numVoices > 1)
   23588:	7831      	ldrb	r1, [r6, #0]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   2358a:	eca4 0a01 	vstmia	r4!, {s0}
		if (numVoices > 1)
   2358e:	2901      	cmp	r1, #1
   23590:	d9c7      	bls.n	23522 <SFXRhodesFrame+0x836>
			if (poly->voices[i][0] == -2)
   23592:	f8db 0000 	ldr.w	r0, [fp]
   23596:	6900      	ldr	r0, [r0, #16]
   23598:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
   2359c:	6800      	ldr	r0, [r0, #0]
   2359e:	3002      	adds	r0, #2
   235a0:	d1bf      	bne.n	23522 <SFXRhodesFrame+0x836>
   235a2:	eb05 0045 	add.w	r0, r5, r5, lsl #1
				if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   235a6:	9a02      	ldr	r2, [sp, #8]
   235a8:	f852 3030 	ldr.w	r3, [r2, r0, lsl #3]
   235ac:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
   235b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   235b2:	2b00      	cmp	r3, #0
   235b4:	d1b5      	bne.n	23522 <SFXRhodesFrame+0x836>
   235b6:	6880      	ldr	r0, [r0, #8]
   235b8:	6a80      	ldr	r0, [r0, #40]	; 0x28
   235ba:	2800      	cmp	r0, #0
   235bc:	d1b1      	bne.n	23522 <SFXRhodesFrame+0x836>
					tSimplePoly_deactivateVoice(&poly, i);
   235be:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   235c2:	4639      	mov	r1, r7
	for (int i = 0; i < numVoices; i++)
   235c4:	3501      	adds	r5, #1
					tSimplePoly_deactivateVoice(&poly, i);
   235c6:	f2c0 200f 	movt	r0, #527	; 0x20f
   235ca:	f00a f9cf 	bl	2d96c <tSimplePoly_deactivateVoice>
   235ce:	7831      	ldrb	r1, [r6, #0]
	for (int i = 0; i < numVoices; i++)
   235d0:	42a9      	cmp	r1, r5
   235d2:	dca9      	bgt.n	23528 <SFXRhodesFrame+0x83c>
   235d4:	9c03      	ldr	r4, [sp, #12]
	tCycle_setFreq(&tremolo, displayValues[2]);
   235d6:	f64d 3008 	movw	r0, #56072	; 0xdb08
   235da:	ed94 0a02 	vldr	s0, [r4, #8]
   235de:	f2c0 200f 	movt	r0, #527	; 0x20f
}
   235e2:	b005      	add	sp, #20
   235e4:	ecbd 8b04 	vpop	{d8-d9}
   235e8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tCycle_setFreq(&tremolo, displayValues[2]);
   235ec:	f00a bac6 	b.w	2db7c <tCycle_setFreq>
   235f0:	f64d 05c4 	movw	r5, #55492	; 0xd8c4
   235f4:	f2c0 250f 	movt	r5, #527	; 0x20f
   235f8:	f105 09c0 	add.w	r9, r5, #192	; 0xc0
   235fc:	f105 0718 	add.w	r7, r5, #24
							tADSR4_setRelease(&FM_envs[i][j], displayValues[8]);
   23600:	4628      	mov	r0, r5
   23602:	3504      	adds	r5, #4
   23604:	ed94 0a08 	vldr	s0, [r4, #32]
   23608:	f007 fb74 	bl	2acf4 <tADSR4_setRelease>
						for (int j = 0; j < 6; j++)
   2360c:	42af      	cmp	r7, r5
   2360e:	d1f7      	bne.n	23600 <SFXRhodesFrame+0x914>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   23610:	45a9      	cmp	r9, r5
   23612:	d1f3      	bne.n	235fc <SFXRhodesFrame+0x910>
		prevDisplayValues[k] = displayValues[k];
   23614:	9b01      	ldr	r3, [sp, #4]
   23616:	f853 3c04 	ldr.w	r3, [r3, #-4]
   2361a:	f848 3c04 	str.w	r3, [r8, #-4]
   2361e:	e72a      	b.n	23476 <SFXRhodesFrame+0x78a>
   23620:	f246 2590 	movw	r5, #25232	; 0x6290
   23624:	f24c 7798 	movw	r7, #51096	; 0xc798
   23628:	f2c0 0506 	movt	r5, #6
   2362c:	f2c0 270f 	movt	r7, #527	; 0x20f
   23630:	f105 0918 	add.w	r9, r5, #24
						tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   23634:	ecb5 0a01 	vldmia	r5!, {s0}
   23638:	4638      	mov	r0, r7
   2363a:	edd4 7a07 	vldr	s15, [r4, #28]
   2363e:	3704      	adds	r7, #4
   23640:	ee20 0a27 	vmul.f32	s0, s0, s15
   23644:	f007 feb8 	bl	2b3b8 <tExpSmooth_setDest>
					for (int i = 0; i < 6; i++)
   23648:	45a9      	cmp	r9, r5
   2364a:	d1f3      	bne.n	23634 <SFXRhodesFrame+0x948>
		prevDisplayValues[k] = displayValues[k];
   2364c:	9b01      	ldr	r3, [sp, #4]
   2364e:	f853 3c04 	ldr.w	r3, [r3, #-4]
   23652:	f848 3c04 	str.w	r3, [r8, #-4]
   23656:	e70e      	b.n	23476 <SFXRhodesFrame+0x78a>
   23658:	f64d 09c4 	movw	r9, #55492	; 0xd8c4
   2365c:	f246 2790 	movw	r7, #25232	; 0x6290
   23660:	f2c0 0706 	movt	r7, #6
   23664:	f2c0 290f 	movt	r9, #527	; 0x20f
   23668:	f246 2578 	movw	r5, #25208	; 0x6278
	prevDisplayValues[24] = displayValues[24];
   2366c:	46cb      	mov	fp, r9
   2366e:	f2c0 0506 	movt	r5, #6
							tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   23672:	ecf5 0a01 	vldmia	r5!, {s1}
   23676:	eeb0 1a48 	vmov.f32	s2, s16
   2367a:	edd4 7a06 	vldr	s15, [r4, #24]
   2367e:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
   23682:	ee60 0aa7 	vmul.f32	s1, s1, s15
   23686:	f009 fbab 	bl	2cde0 <LEAF_clip>
   2368a:	4658      	mov	r0, fp
   2368c:	f007 fb0e 	bl	2acac <tADSR4_setDecay>
						for (int j = 0; j < 6; j++)
   23690:	42af      	cmp	r7, r5
   23692:	f10b 0b04 	add.w	fp, fp, #4
   23696:	d1ec      	bne.n	23672 <SFXRhodesFrame+0x986>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   23698:	f64d 1384 	movw	r3, #55684	; 0xd984
   2369c:	f109 0918 	add.w	r9, r9, #24
   236a0:	f2c0 230f 	movt	r3, #527	; 0x20f
   236a4:	454b      	cmp	r3, r9
   236a6:	d1df      	bne.n	23668 <SFXRhodesFrame+0x97c>
		prevDisplayValues[k] = displayValues[k];
   236a8:	9b01      	ldr	r3, [sp, #4]
   236aa:	f853 3c04 	ldr.w	r3, [r3, #-4]
   236ae:	f848 3c04 	str.w	r3, [r8, #-4]
   236b2:	e6e0      	b.n	23476 <SFXRhodesFrame+0x78a>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   236b4:	f246 2554 	movw	r5, #25172	; 0x6254
		tSimplePoly_setNumVoices(&poly, numVoices);
   236b8:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   236bc:	f2c0 0506 	movt	r5, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   236c0:	f2c0 200f 	movt	r0, #527	; 0x20f
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   236c4:	782a      	ldrb	r2, [r5, #0]
   236c6:	9503      	str	r5, [sp, #12]
   236c8:	2a01      	cmp	r2, #1
   236ca:	bf98      	it	ls
   236cc:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   236ce:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   236d0:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   236d2:	f00a fa01 	bl	2dad8 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   236d6:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   236d8:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   236da:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   236de:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   236e0:	fab0 f080 	clz	r0, r0
   236e4:	0940      	lsrs	r0, r0, #5
   236e6:	f7f7 fd25 	bl	1b134 <setLED_A>
   236ea:	f7ff bb11 	b.w	22d10 <SFXRhodesFrame+0x24>
		tremoloStereo = !tremoloStereo;
   236ee:	f646 1274 	movw	r2, #26996	; 0x6974
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   236f2:	2300      	movs	r3, #0
		tremoloStereo = !tremoloStereo;
   236f4:	f2c0 220e 	movt	r2, #526	; 0x20e
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   236f8:	7723      	strb	r3, [r4, #28]
		tremoloStereo = !tremoloStereo;
   236fa:	7813      	ldrb	r3, [r2, #0]
   236fc:	fab3 f383 	clz	r3, r3
   23700:	095b      	lsrs	r3, r3, #5
		setLED_C(tremoloStereo == 1);
   23702:	4618      	mov	r0, r3
		tremoloStereo = !tremoloStereo;
   23704:	7013      	strb	r3, [r2, #0]
		setLED_C(tremoloStereo == 1);
   23706:	f7f7 fd35 	bl	1b174 <setLED_C>
   2370a:	f7ff bb1d 	b.w	22d48 <SFXRhodesFrame+0x5c>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2370e:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
   23712:	ee76 6a63 	vsub.f32	s13, s12, s7
   23716:	eef0 6ae6 	vabs.f32	s13, s13
   2371a:	ee83 6aa6 	vdiv.f32	s12, s7, s13
   2371e:	e47e      	b.n	2301e <SFXRhodesFrame+0x332>
   23720:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
   23724:	ee73 6ac3 	vsub.f32	s13, s7, s6
   23728:	eef0 6ae6 	vabs.f32	s13, s13
   2372c:	eec3 3a26 	vdiv.f32	s7, s6, s13
   23730:	e4a6      	b.n	23080 <SFXRhodesFrame+0x394>
   23732:	ee77 7ac7 	vsub.f32	s15, s15, s14
   23736:	eef0 3ae7 	vabs.f32	s7, s15
   2373a:	eec7 7a23 	vdiv.f32	s15, s14, s7
   2373e:	e4ce      	b.n	230de <SFXRhodesFrame+0x3f2>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23740:	ee33 4ac3 	vsub.f32	s8, s7, s6
   23744:	eef0 3ac4 	vabs.f32	s7, s8
   23748:	ee83 4a23 	vdiv.f32	s8, s6, s7
   2374c:	e4fd      	b.n	2314a <SFXRhodesFrame+0x45e>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2374e:	ee76 6a65 	vsub.f32	s13, s12, s11
   23752:	eef0 6ae6 	vabs.f32	s13, s13
   23756:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   2375a:	f7ff bbcd 	b.w	22ef8 <SFXRhodesFrame+0x20c>
   2375e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   23762:	ee76 6a65 	vsub.f32	s13, s12, s11
   23766:	eef0 6ae6 	vabs.f32	s13, s13
   2376a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   2376e:	f7ff bbf4 	b.w	22f5a <SFXRhodesFrame+0x26e>
   23772:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   23776:	ee76 6a65 	vsub.f32	s13, s12, s11
   2377a:	eef0 6ae6 	vabs.f32	s13, s13
   2377e:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   23782:	e41b      	b.n	22fbc <SFXRhodesFrame+0x2d0>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   23784:	ee77 7ae6 	vsub.f32	s15, s15, s13
   23788:	eeb0 6ae7 	vabs.f32	s12, s15
   2378c:	eec6 7a86 	vdiv.f32	s15, s13, s12
   23790:	e573      	b.n	2327a <SFXRhodesFrame+0x58e>
   23792:	ee36 6a65 	vsub.f32	s12, s12, s11
   23796:	eeb0 5ac6 	vabs.f32	s10, s12
   2379a:	ee85 6a85 	vdiv.f32	s12, s11, s10
   2379e:	e550      	b.n	23242 <SFXRhodesFrame+0x556>
   237a0:	ee75 5ac5 	vsub.f32	s11, s11, s10
   237a4:	eef0 4ae5 	vabs.f32	s9, s11
   237a8:	eec5 5a24 	vdiv.f32	s11, s10, s9
   237ac:	e52b      	b.n	23206 <SFXRhodesFrame+0x51a>
   237ae:	ee35 5a64 	vsub.f32	s10, s10, s9
   237b2:	eeb0 4ac5 	vabs.f32	s8, s10
   237b6:	ee84 5a84 	vdiv.f32	s10, s9, s8
   237ba:	e506      	b.n	231ca <SFXRhodesFrame+0x4de>
   237bc:	ee74 4ac4 	vsub.f32	s9, s9, s8
   237c0:	eef0 3ae4 	vabs.f32	s7, s9
   237c4:	eec4 4a23 	vdiv.f32	s9, s8, s7
   237c8:	e4e1      	b.n	2318e <SFXRhodesFrame+0x4a2>
   237ca:	bf00      	nop

000237cc <SFXRhodesTick>:
{
   237cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   237d0:	f24c 68b4 	movw	r8, #50868	; 0xc6b4
   237d4:	f24c 7498 	movw	r4, #51096	; 0xc798
   237d8:	f2c0 280f 	movt	r8, #527	; 0x20f
   237dc:	f2c0 240f 	movt	r4, #527	; 0x20f
   237e0:	ed2d 8b08 	vpush	{d8-d11}
   237e4:	f108 0518 	add.w	r5, r8, #24
   237e8:	b091      	sub	sp, #68	; 0x44
   237ea:	4646      	mov	r6, r8
   237ec:	900f      	str	r0, [sp, #60]	; 0x3c
		sustainsFinal[i] = tExpSmooth_tick(&susSmoothers[i]);
   237ee:	4620      	mov	r0, r4
   237f0:	3404      	adds	r4, #4
   237f2:	f007 fdeb 	bl	2b3cc <tExpSmooth_tick>
   237f6:	eca6 0a01 	vstmia	r6!, {s0}
	for (int i = 0; i < 6; i++)
   237fa:	42ae      	cmp	r6, r5
   237fc:	d1f7      	bne.n	237ee <SFXRhodesTick+0x22>
   237fe:	f64d 07c4 	movw	r7, #55492	; 0xd8c4
   23802:	f2c0 270f 	movt	r7, #527	; 0x20f
   23806:	f107 09c0 	add.w	r9, r7, #192	; 0xc0
   2380a:	9707      	str	r7, [sp, #28]
{
   2380c:	463d      	mov	r5, r7
   2380e:	4644      	mov	r4, r8
			tADSR4_setSustain(&FM_envs[i][j], sustainsFinal[j]); //FM_sustains[Rsound][j] * displayValues[7]);
   23810:	ecb4 0a01 	vldmia	r4!, {s0}
   23814:	4628      	mov	r0, r5
   23816:	f007 fa57 	bl	2acc8 <tADSR4_setSustain>
   2381a:	3504      	adds	r5, #4
		for (int j = 0; j < 6; j++)
   2381c:	42a6      	cmp	r6, r4
   2381e:	d1f7      	bne.n	23810 <SFXRhodesTick+0x44>
   23820:	3718      	adds	r7, #24
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   23822:	454f      	cmp	r7, r9
   23824:	d1f2      	bne.n	2380c <SFXRhodesTick+0x40>
	for (int i = 0; i < numVoices; i++)
   23826:	f246 2354 	movw	r3, #25172	; 0x6254
   2382a:	f2c0 0306 	movt	r3, #6
   2382e:	9308      	str	r3, [sp, #32]
   23830:	781b      	ldrb	r3, [r3, #0]
   23832:	2b00      	cmp	r3, #0
   23834:	f000 8191 	beq.w	23b5a <SFXRhodesTick+0x38e>
   23838:	f24d 10d4 	movw	r0, #53716	; 0xd1d4
   2383c:	f24d 13a4 	movw	r3, #53668	; 0xd1a4
   23840:	f24c 5184 	movw	r1, #50564	; 0xc584
   23844:	f646 0bf0 	movw	fp, #26864	; 0x68f0
   23848:	f2c0 200f 	movt	r0, #527	; 0x20f
	float rightSample = 0.0f;
   2384c:	2200      	movs	r2, #0
   2384e:	f2c0 230f 	movt	r3, #527	; 0x20f
   23852:	f2c0 2b0e 	movt	fp, #526	; 0x20e
   23856:	900e      	str	r0, [sp, #56]	; 0x38
   23858:	f646 0978 	movw	r9, #26744	; 0x6878
   2385c:	9807      	ldr	r0, [sp, #28]
   2385e:	f64e 382c 	movw	r8, #60204	; 0xeb2c
   23862:	f2c0 210f 	movt	r1, #527	; 0x20f
   23866:	ee09 2a10 	vmov	s18, r2
   2386a:	4606      	mov	r6, r0
   2386c:	f2c0 290e 	movt	r9, #526	; 0x20e
   23870:	f2c0 280f 	movt	r8, #527	; 0x20f
   23874:	f246 0440 	movw	r4, #24640	; 0x6040
   23878:	3614      	adds	r6, #20
   2387a:	f246 05b8 	movw	r5, #24760	; 0x60b8
	float leftSample = 0.0f;
   2387e:	ee09 2a90 	vmov	s19, r2
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   23882:	eef7 aa00 	vmov.f32	s21, #112	; 0x3f800000  1.0
   23886:	960d      	str	r6, [sp, #52]	; 0x34
   23888:	4606      	mov	r6, r0
   2388a:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
   2388e:	46c2      	mov	sl, r8
   23890:	3610      	adds	r6, #16
   23892:	f2c0 0406 	movt	r4, #6
   23896:	f2c0 0506 	movt	r5, #6
   2389a:	960c      	str	r6, [sp, #48]	; 0x30
   2389c:	4606      	mov	r6, r0
   2389e:	e9cd 1304 	strd	r1, r3, [sp, #16]
   238a2:	360c      	adds	r6, #12
   238a4:	4613      	mov	r3, r2
   238a6:	465a      	mov	r2, fp
   238a8:	46cb      	mov	fp, r9
   238aa:	960b      	str	r6, [sp, #44]	; 0x2c
   238ac:	ee19 9a10 	vmov	r9, s18
   238b0:	1d06      	adds	r6, r0, #4
   238b2:	4690      	mov	r8, r2
   238b4:	3008      	adds	r0, #8
   238b6:	9609      	str	r6, [sp, #36]	; 0x24
   238b8:	900a      	str	r0, [sp, #40]	; 0x28
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   238ba:	f8db 7000 	ldr.w	r7, [fp]
	for (int i = 0; i < numVoices; i++)
   238be:	3301      	adds	r3, #1
		float myFrequency = freq[i];
   238c0:	9905      	ldr	r1, [sp, #20]
   238c2:	f24d 12e8 	movw	r2, #53736	; 0xd1e8
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   238c6:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   238ca:	ed9a 0a00 	vldr	s0, [sl]
		float myFrequency = freq[i];
   238ce:	ecf1 8a01 	vldmia	r1!, {s17}
   238d2:	f2c0 220f 	movt	r2, #527	; 0x20f
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   238d6:	00ff      	lsls	r7, r7, #3
   238d8:	edd8 7a00 	vldr	s15, [r8]
		float myFrequency = freq[i];
   238dc:	9105      	str	r1, [sp, #20]
   238de:	f24d 11dc 	movw	r1, #53724	; 0xd1dc
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   238e2:	eb05 0c07 	add.w	ip, r5, r7
   238e6:	ee67 7a80 	vmul.f32	s15, s15, s0
	for (int i = 0; i < numVoices; i++)
   238ea:	9306      	str	r3, [sp, #24]
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   238ec:	4427      	add	r7, r4
   238ee:	ed9c 0a05 	vldr	s0, [ip, #20]
   238f2:	f2c0 210f 	movt	r1, #527	; 0x20f
   238f6:	f24d 13e0 	movw	r3, #53728	; 0xd1e0
   238fa:	ed97 7a05 	vldr	s14, [r7, #20]
   238fe:	eb02 0609 	add.w	r6, r2, r9
   23902:	eb01 0709 	add.w	r7, r1, r9
   23906:	ee27 0a80 	vmul.f32	s0, s15, s0
   2390a:	3a04      	subs	r2, #4
   2390c:	f2c0 230f 	movt	r3, #527	; 0x20f
   23910:	3904      	subs	r1, #4
   23912:	444a      	add	r2, r9
   23914:	4630      	mov	r0, r6
   23916:	4449      	add	r1, r9
   23918:	444b      	add	r3, r9
   2391a:	eea7 0a28 	vfma.f32	s0, s14, s17
   2391e:	9203      	str	r2, [sp, #12]
   23920:	9101      	str	r1, [sp, #4]
   23922:	9302      	str	r3, [sp, #8]
   23924:	f00a f92a 	bl	2db7c <tCycle_setFreq>
		feedback_output = tCycle_tick(&FM_sines[i][5]);
   23928:	4630      	mov	r0, r6
   2392a:	f00a f935 	bl	2db98 <tCycle_tick>
		tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
   2392e:	f8db 0000 	ldr.w	r0, [fp]
   23932:	edda 7a00 	vldr	s15, [sl]
   23936:	eb00 0040 	add.w	r0, r0, r0, lsl #1
		feedback_output = tCycle_tick(&FM_sines[i][5]);
   2393a:	ed88 0a00 	vstr	s0, [r8]
		tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
   2393e:	00c0      	lsls	r0, r0, #3
   23940:	eb05 0c00 	add.w	ip, r5, r0
   23944:	1826      	adds	r6, r4, r0
   23946:	980d      	ldr	r0, [sp, #52]	; 0x34
   23948:	ed9c 8a04 	vldr	s16, [ip, #16]
   2394c:	4448      	add	r0, r9
   2394e:	ed96 ba04 	vldr	s22, [r6, #16]
   23952:	ee28 8a27 	vmul.f32	s16, s16, s15
   23956:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   23958:	444e      	add	r6, r9
   2395a:	ee28 8a00 	vmul.f32	s16, s16, s0
   2395e:	f007 f9f5 	bl	2ad4c <tADSR4_tick>
   23962:	9803      	ldr	r0, [sp, #12]
   23964:	ee28 0a00 	vmul.f32	s0, s16, s0
   23968:	eeab 0a28 	vfma.f32	s0, s22, s17
   2396c:	f00a f906 	bl	2db7c <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][3], (myFrequency  * FM_freqRatios[Rsound][3]) + (FM_indices[Rsound][3] * displayValues[0] * tCycle_tick(&FM_sines[i][4]) * tADSR4_tickNoInterp(&FM_envs[i][4])));
   23970:	f8db 2000 	ldr.w	r2, [fp]
   23974:	edda 7a00 	vldr	s15, [sl]
   23978:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   2397c:	9803      	ldr	r0, [sp, #12]
   2397e:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   23982:	eb05 0e0c 	add.w	lr, r5, ip
   23986:	44a4      	add	ip, r4
   23988:	ed9e 8a03 	vldr	s16, [lr, #12]
   2398c:	ed9c ba03 	vldr	s22, [ip, #12]
   23990:	ee28 8a27 	vmul.f32	s16, s16, s15
   23994:	f00a f900 	bl	2db98 <tCycle_tick>
   23998:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   2399a:	ee28 8a00 	vmul.f32	s16, s16, s0
   2399e:	eb02 0009 	add.w	r0, r2, r9
   239a2:	f007 fb2d 	bl	2b000 <tADSR4_tickNoInterp>
   239a6:	9802      	ldr	r0, [sp, #8]
   239a8:	ee28 0a00 	vmul.f32	s0, s16, s0
   239ac:	eeab 0a28 	vfma.f32	s0, s22, s17
   239b0:	f00a f8e4 	bl	2db7c <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][2], (myFrequency  * FM_freqRatios[Rsound][2]) + (FM_indices[Rsound][2] * displayValues[0] * tCycle_tick(&FM_sines[i][3]) * tADSR4_tickNoInterp(&FM_envs[i][3])));
   239b4:	f8db 2000 	ldr.w	r2, [fp]
   239b8:	edda 7a00 	vldr	s15, [sl]
   239bc:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   239c0:	9802      	ldr	r0, [sp, #8]
   239c2:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   239c6:	eb05 0e0c 	add.w	lr, r5, ip
   239ca:	44a4      	add	ip, r4
   239cc:	ed9e 8a02 	vldr	s16, [lr, #8]
   239d0:	ed9c ba02 	vldr	s22, [ip, #8]
   239d4:	ee28 8a27 	vmul.f32	s16, s16, s15
   239d8:	f00a f8de 	bl	2db98 <tCycle_tick>
   239dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   239de:	ee28 8a00 	vmul.f32	s16, s16, s0
   239e2:	eb03 0009 	add.w	r0, r3, r9
   239e6:	f007 fb0b 	bl	2b000 <tADSR4_tickNoInterp>
   239ea:	4638      	mov	r0, r7
   239ec:	ee28 0a00 	vmul.f32	s0, s16, s0
   239f0:	eeab 0a28 	vfma.f32	s0, s22, s17
   239f4:	f00a f8c2 	bl	2db7c <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][1], myFrequency  * FM_freqRatios[Rsound][1]);
   239f8:	f8db 2000 	ldr.w	r2, [fp]
   239fc:	9801      	ldr	r0, [sp, #4]
   239fe:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   23a02:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
   23a06:	ed9c 0a01 	vldr	s0, [ip, #4]
   23a0a:	ee28 0a80 	vmul.f32	s0, s17, s0
   23a0e:	f00a f8b5 	bl	2db7c <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][0],( myFrequency  * FM_freqRatios[Rsound][0]) + (FM_indices[Rsound][0] * displayValues[0] * tCycle_tick(&FM_sines[i][1]) * tADSR4_tickNoInterp(&FM_envs[i][1])));
   23a12:	f8db 2000 	ldr.w	r2, [fp]
   23a16:	edda 7a00 	vldr	s15, [sl]
   23a1a:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   23a1e:	9801      	ldr	r0, [sp, #4]
   23a20:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   23a24:	eb05 0e0c 	add.w	lr, r5, ip
   23a28:	44a4      	add	ip, r4
   23a2a:	ed9e 8a00 	vldr	s16, [lr]
   23a2e:	ed9c ba00 	vldr	s22, [ip]
   23a32:	ee28 8a27 	vmul.f32	s16, s16, s15
   23a36:	f00a f8af 	bl	2db98 <tCycle_tick>
   23a3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   23a3c:	ee28 8a00 	vmul.f32	s16, s16, s0
   23a40:	eb03 0009 	add.w	r0, r3, r9
   23a44:	f007 fadc 	bl	2b000 <tADSR4_tickNoInterp>
   23a48:	4630      	mov	r0, r6
   23a4a:	ee28 0a00 	vmul.f32	s0, s16, s0
   23a4e:	eeab 0a28 	vfma.f32	s0, s22, s17
   23a52:	f00a f893 	bl	2db7c <tCycle_setFreq>
		sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
   23a56:	4638      	mov	r0, r7
   23a58:	f00a f89e 	bl	2db98 <tCycle_tick>
   23a5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   23a5e:	eeb0 ba40 	vmov.f32	s22, s0
   23a62:	eb03 0009 	add.w	r0, r3, r9
   23a66:	f007 facb 	bl	2b000 <tADSR4_tickNoInterp>
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   23a6a:	4630      	mov	r0, r6
		sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
   23a6c:	eef0 8a40 	vmov.f32	s17, s0
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   23a70:	f00a f892 	bl	2db98 <tCycle_tick>
   23a74:	9b07      	ldr	r3, [sp, #28]
   23a76:	eeb0 8a40 	vmov.f32	s16, s0
   23a7a:	eb03 0009 	add.w	r0, r3, r9
   23a7e:	f109 0918 	add.w	r9, r9, #24
   23a82:	f007 fabd 	bl	2b000 <tADSR4_tickNoInterp>
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   23a86:	9b04      	ldr	r3, [sp, #16]
   23a88:	edda 7a04 	vldr	s15, [sl, #16]
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   23a8c:	ee28 0a00 	vmul.f32	s0, s16, s0
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   23a90:	ecf3 6a01 	vldmia	r3!, {s13}
   23a94:	ee3a 6ae7 	vsub.f32	s12, s21, s15
   23a98:	ee3a 7ae6 	vsub.f32	s14, s21, s13
   23a9c:	9304      	str	r3, [sp, #16]
		rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   23a9e:	ee67 6aa6 	vmul.f32	s13, s15, s13
	for (int i = 0; i < numVoices; i++)
   23aa2:	9b08      	ldr	r3, [sp, #32]
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   23aa4:	eeab 0a28 	vfma.f32	s0, s22, s17
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   23aa8:	ee67 7a27 	vmul.f32	s15, s14, s15
	for (int i = 0; i < numVoices; i++)
   23aac:	7818      	ldrb	r0, [r3, #0]
		rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   23aae:	eee6 6a0a 	vfma.f32	s13, s12, s20
	for (int i = 0; i < numVoices; i++)
   23ab2:	9b06      	ldr	r3, [sp, #24]
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   23ab4:	eee6 7a0a 	vfma.f32	s15, s12, s20
	for (int i = 0; i < numVoices; i++)
   23ab8:	4298      	cmp	r0, r3
		rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   23aba:	eea6 9a80 	vfma.f32	s18, s13, s0
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   23abe:	eee7 9a80 	vfma.f32	s19, s15, s0
	for (int i = 0; i < numVoices; i++)
   23ac2:	f73f aefa 	bgt.w	238ba <SFXRhodesTick+0xee>
   23ac6:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   23aca:	46d0      	mov	r8, sl
   23acc:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
   23ad0:	ee07 3a90 	vmov	s15, r3
   23ad4:	ee69 9aa7 	vmul.f32	s19, s19, s15
   23ad8:	ee29 9a27 	vmul.f32	s18, s18, s15
	float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   23adc:	f64d 3008 	movw	r0, #56072	; 0xdb08
   23ae0:	f2c0 200f 	movt	r0, #527	; 0x20f
   23ae4:	f00a f858 	bl	2db98 <tCycle_tick>
   23ae8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   23aec:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   23af0:	edd8 6a01 	vldr	s13, [r8, #4]
	if (tremoloStereo)
   23af4:	f646 1374 	movw	r3, #26996	; 0x6974
	float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   23af8:	ee30 0a27 	vadd.f32	s0, s0, s15
   23afc:	ee26 7a87 	vmul.f32	s14, s13, s14
	if (tremoloStereo)
   23b00:	f2c0 230e 	movt	r3, #526	; 0x20e
   23b04:	ee77 7ae6 	vsub.f32	s15, s15, s13
   23b08:	781b      	ldrb	r3, [r3, #0]
	float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   23b0a:	ee20 7a07 	vmul.f32	s14, s0, s14
   23b0e:	ee37 0a87 	vadd.f32	s0, s15, s14
	if (tremoloStereo)
   23b12:	b9cb      	cbnz	r3, 23b48 <SFXRhodesTick+0x37c>
		rightSample *= ((tremoloSignal) + (1.0f - displayValues[1]));
   23b14:	ee29 9a00 	vmul.f32	s18, s18, s0
	leftSample *= displayValues[3]; //drive
   23b18:	ed98 8a03 	vldr	s16, [r8, #12]
   23b1c:	ee68 9a29 	vmul.f32	s19, s16, s19
	leftSample = tanhf(leftSample);
   23b20:	ee29 0a80 	vmul.f32	s0, s19, s0
   23b24:	f00c ff82 	bl	30a2c <tanhf>
   23b28:	eef0 8a40 	vmov.f32	s17, s0
	rightSample = tanhf(rightSample);
   23b2c:	ee28 0a09 	vmul.f32	s0, s16, s18
   23b30:	f00c ff7c 	bl	30a2c <tanhf>
	input[0] = leftSample;
   23b34:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   23b36:	edc3 8a00 	vstr	s17, [r3]
	input[1] = rightSample;
   23b3a:	ed83 0a01 	vstr	s0, [r3, #4]
}
   23b3e:	b011      	add	sp, #68	; 0x44
   23b40:	ecbd 8b08 	vpop	{d8-d11}
   23b44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rightSample *= ((1.0f-tremoloSignal) + (1.0f - displayValues[1]));
   23b48:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   23b4c:	ee77 6ae6 	vsub.f32	s13, s15, s13
   23b50:	ee36 7ac7 	vsub.f32	s14, s13, s14
   23b54:	ee27 9a09 	vmul.f32	s18, s14, s18
   23b58:	e7de      	b.n	23b18 <SFXRhodesTick+0x34c>
   23b5a:	f64e 382c 	movw	r8, #60204	; 0xeb2c
	for (int i = 0; i < numVoices; i++)
   23b5e:	ee09 3a10 	vmov	s18, r3
   23b62:	ee09 3a90 	vmov	s19, r3
   23b66:	f2c0 280f 	movt	r8, #527	; 0x20f
   23b6a:	e7b7      	b.n	23adc <SFXRhodesTick+0x310>

00023b6c <SFXRhodesFree>:
{
   23b6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23b6e:	f24d 17d4 	movw	r7, #53716	; 0xd1d4
   23b72:	f64d 06c4 	movw	r6, #55492	; 0xd8c4
   23b76:	2400      	movs	r4, #0
   23b78:	f2c0 270f 	movt	r7, #527	; 0x20f
   23b7c:	f2c0 260f 	movt	r6, #527	; 0x20f
   23b80:	f104 0518 	add.w	r5, r4, #24
			tCycle_free(&FM_sines[i][j]);
   23b84:	1938      	adds	r0, r7, r4
   23b86:	f009 fff5 	bl	2db74 <tCycle_free>
			tADSR4_free(&FM_envs[i][j]);
   23b8a:	1930      	adds	r0, r6, r4
   23b8c:	3404      	adds	r4, #4
   23b8e:	f007 f87b 	bl	2ac88 <tADSR4_free>
		for (int j = 0; j < 6; j++)
   23b92:	42ac      	cmp	r4, r5
   23b94:	d1f6      	bne.n	23b84 <SFXRhodesFree+0x18>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   23b96:	2cc0      	cmp	r4, #192	; 0xc0
   23b98:	d1f2      	bne.n	23b80 <SFXRhodesFree+0x14>
		tExpSmooth_free(&susSmoothers[i]);
   23b9a:	f24c 7098 	movw	r0, #51096	; 0xc798
   23b9e:	f2c0 200f 	movt	r0, #527	; 0x20f
   23ba2:	f007 fbf3 	bl	2b38c <tExpSmooth_free>
   23ba6:	f24c 709c 	movw	r0, #51100	; 0xc79c
   23baa:	f2c0 200f 	movt	r0, #527	; 0x20f
   23bae:	f007 fbed 	bl	2b38c <tExpSmooth_free>
   23bb2:	f24c 70a0 	movw	r0, #51104	; 0xc7a0
   23bb6:	f2c0 200f 	movt	r0, #527	; 0x20f
   23bba:	f007 fbe7 	bl	2b38c <tExpSmooth_free>
   23bbe:	f24c 70a4 	movw	r0, #51108	; 0xc7a4
   23bc2:	f2c0 200f 	movt	r0, #527	; 0x20f
   23bc6:	f007 fbe1 	bl	2b38c <tExpSmooth_free>
   23bca:	f24c 70a8 	movw	r0, #51112	; 0xc7a8
   23bce:	f2c0 200f 	movt	r0, #527	; 0x20f
   23bd2:	f007 fbdb 	bl	2b38c <tExpSmooth_free>
   23bd6:	f24c 70ac 	movw	r0, #51116	; 0xc7ac
   23bda:	f2c0 200f 	movt	r0, #527	; 0x20f
   23bde:	f007 fbd5 	bl	2b38c <tExpSmooth_free>
	tCycle_free(&tremolo);
   23be2:	f64d 3008 	movw	r0, #56072	; 0xdb08
}
   23be6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	tCycle_free(&tremolo);
   23bea:	f2c0 200f 	movt	r0, #527	; 0x20f
   23bee:	f009 bfc1 	b.w	2db74 <tCycle_free>
   23bf2:	bf00      	nop

00023bf4 <calculateNoteArray>:
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   23bf4:	f646 13b8 	movw	r3, #27064	; 0x69b8
   23bf8:	f24c 70b0 	movw	r0, #51120	; 0xc7b0
	for (int i = 0; i < 128; i++)
   23bfc:	2100      	movs	r1, #0
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   23bfe:	f2c0 230e 	movt	r3, #526	; 0x20e
   23c02:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   23c06:	b4f0      	push	{r4, r5, r6, r7}
   23c08:	f646 1584 	movw	r5, #27012	; 0x6984
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   23c0c:	f64a 26ab 	movw	r6, #43691	; 0xaaab
   23c10:	781f      	ldrb	r7, [r3, #0]
   23c12:	f2c0 250e 	movt	r5, #526	; 0x20e
   23c16:	f6c2 26aa 	movt	r6, #10922	; 0x2aaa
		float tempNote = i;
   23c1a:	ee07 1a90 	vmov	s15, r1
	for (int i = 0; i < 128; i++)
   23c1e:	3101      	adds	r1, #1
		float tempNote = i;
   23c20:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	for (int i = 0; i < 128; i++)
   23c24:	2980      	cmp	r1, #128	; 0x80
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   23c26:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   23c2a:	ee17 3a90 	vmov	r3, s15
   23c2e:	eba3 0307 	sub.w	r3, r3, r7
   23c32:	fb86 2403 	smull	r2, r4, r6, r3
   23c36:	ea4f 72e3 	mov.w	r2, r3, asr #31
   23c3a:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   23c3e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   23c42:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   23c46:	ee07 3a90 	vmov	s15, r3
   23c4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   23c4e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   23c52:	ee17 3a90 	vmov	r3, s15
   23c56:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   23c5a:	edd3 7a00 	vldr	s15, [r3]
   23c5e:	ee77 7a87 	vadd.f32	s15, s15, s14
		notes[i] = tunedNote;
   23c62:	ece0 7a01 	vstmia	r0!, {s15}
	for (int i = 0; i < 128; i++)
   23c66:	d1d8      	bne.n	23c1a <calculateNoteArray+0x26>
	}
}
   23c68:	bcf0      	pop	{r4, r5, r6, r7}
   23c6a:	4770      	bx	lr

00023c6c <nearestNoteWithHysteresis>:

int lastNearNote = -1;


float nearestNoteWithHysteresis(float note, float hysteresis)
{
   23c6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	float leastDifference = fastabsf(note - notes[0]);
   23c70:	f24c 77b0 	movw	r7, #51120	; 0xc7b0
	int* chord;
	float output = 0.0f;

	if (autotuneChromatic > 0)
	{
		chord = chromaticArray;
   23c74:	f646 0898 	movw	r8, #26776	; 0x6898
	float leastDifference = fastabsf(note - notes[0]);
   23c78:	f2c0 270f 	movt	r7, #527	; 0x20f
		chord = chromaticArray;
   23c7c:	f2c0 280e 	movt	r8, #526	; 0x20e
{
   23c80:	ed2d 8b04 	vpush	{d8-d9}
   23c84:	eef0 8a40 	vmov.f32	s17, s0
	float leastDifference = fastabsf(note - notes[0]);
   23c88:	ed97 0a00 	vldr	s0, [r7]
{
   23c8c:	eeb0 9a60 	vmov.f32	s18, s1
	float leastDifference = fastabsf(note - notes[0]);
   23c90:	ee38 0ac0 	vsub.f32	s0, s17, s0
   23c94:	f008 ffb8 	bl	2cc08 <fastabsf>
	if (autotuneChromatic > 0)
   23c98:	f646 0384 	movw	r3, #26756	; 0x6884
		chord = chromaticArray;
   23c9c:	f246 12f4 	movw	r2, #25076	; 0x61f4
	}
	else
	{
		chord = chordArray;
	}
	if (autotuneLock > 0)
   23ca0:	f646 0188 	movw	r1, #26760	; 0x6888
	if (autotuneChromatic > 0)
   23ca4:	f2c0 230e 	movt	r3, #526	; 0x20e
	float leastDifference = fastabsf(note - notes[0]);
   23ca8:	eeb0 8a40 	vmov.f32	s16, s0
		chord = chromaticArray;
   23cac:	f2c0 0206 	movt	r2, #6
	if (autotuneLock > 0)
   23cb0:	f2c0 210e 	movt	r1, #526	; 0x20e
	if (autotuneChromatic > 0)
   23cb4:	7818      	ldrb	r0, [r3, #0]
	{
		chord = lockArray;
   23cb6:	f646 1310 	movw	r3, #26896	; 0x6910
	if (autotuneLock > 0)
   23cba:	6809      	ldr	r1, [r1, #0]
		chord = chromaticArray;
   23cbc:	2800      	cmp	r0, #0
   23cbe:	bf18      	it	ne
   23cc0:	4690      	movne	r8, r2
		chord = lockArray;
   23cc2:	f2c0 230e 	movt	r3, #526	; 0x20e
   23cc6:	2900      	cmp	r1, #0
   23cc8:	bf18      	it	ne
   23cca:	4698      	movne	r8, r3
	}
	int hasNotes = 0;
	for (int i = 0; i < 12; i++)
	{
		if (chord[i] > 0)
   23ccc:	e9d8 3200 	ldrd	r3, r2, [r8]
   23cd0:	f8d8 0008 	ldr.w	r0, [r8, #8]
   23cd4:	2b00      	cmp	r3, #0
   23cd6:	bfcc      	ite	gt
   23cd8:	2301      	movgt	r3, #1
   23cda:	2300      	movle	r3, #0
		{
			hasNotes = 1;
   23cdc:	2a00      	cmp	r2, #0
		if (chord[i] > 0)
   23cde:	e9d8 1203 	ldrd	r1, r2, [r8, #12]
			hasNotes = 1;
   23ce2:	bfc8      	it	gt
   23ce4:	2301      	movgt	r3, #1
   23ce6:	2800      	cmp	r0, #0
		if (chord[i] > 0)
   23ce8:	f8d8 0014 	ldr.w	r0, [r8, #20]
			hasNotes = 1;
   23cec:	bfc8      	it	gt
   23cee:	2301      	movgt	r3, #1
   23cf0:	2900      	cmp	r1, #0
		if (chord[i] > 0)
   23cf2:	f8d8 1018 	ldr.w	r1, [r8, #24]
			hasNotes = 1;
   23cf6:	bfc8      	it	gt
   23cf8:	2301      	movgt	r3, #1
   23cfa:	2a00      	cmp	r2, #0
		if (chord[i] > 0)
   23cfc:	f8d8 201c 	ldr.w	r2, [r8, #28]
			hasNotes = 1;
   23d00:	bfc8      	it	gt
   23d02:	2301      	movgt	r3, #1
   23d04:	2800      	cmp	r0, #0
		if (chord[i] > 0)
   23d06:	f8d8 0020 	ldr.w	r0, [r8, #32]
			hasNotes = 1;
   23d0a:	bfc8      	it	gt
   23d0c:	2301      	movgt	r3, #1
   23d0e:	2900      	cmp	r1, #0
		if (chord[i] > 0)
   23d10:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
			hasNotes = 1;
   23d14:	bfc8      	it	gt
   23d16:	2301      	movgt	r3, #1
   23d18:	2a00      	cmp	r2, #0
		if (chord[i] > 0)
   23d1a:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
			hasNotes = 1;
   23d1e:	bfc8      	it	gt
   23d20:	2301      	movgt	r3, #1
   23d22:	2800      	cmp	r0, #0
   23d24:	bfc8      	it	gt
   23d26:	2301      	movgt	r3, #1
   23d28:	2900      	cmp	r1, #0
   23d2a:	bfc8      	it	gt
   23d2c:	2301      	movgt	r3, #1
		if (chord[i] > 0)
   23d2e:	2a00      	cmp	r2, #0
   23d30:	f340 809a 	ble.w	23e68 <nearestNoteWithHysteresis+0x1fc>
	if (hasNotes)
	{

		for(int i = 1; i < 128; i++)
		{
			if (chord[i%12] > 0)
   23d34:	f64a 29ab 	movw	r9, #43691	; 0xaaab
   23d38:	f24c 75b4 	movw	r5, #51124	; 0xc7b4
		for(int i = 1; i < 128; i++)
   23d3c:	2401      	movs	r4, #1
	int nearIndex = 0;
   23d3e:	2600      	movs	r6, #0
   23d40:	f2c0 250f 	movt	r5, #527	; 0x20f
			if (chord[i%12] > 0)
   23d44:	f6ca 29aa 	movt	r9, #43690	; 0xaaaa
   23d48:	e003      	b.n	23d52 <nearestNoteWithHysteresis+0xe6>
		for(int i = 1; i < 128; i++)
   23d4a:	3401      	adds	r4, #1
   23d4c:	3504      	adds	r5, #4
   23d4e:	2c80      	cmp	r4, #128	; 0x80
   23d50:	d01c      	beq.n	23d8c <nearestNoteWithHysteresis+0x120>
			if (chord[i%12] > 0)
   23d52:	fba9 2304 	umull	r2, r3, r9, r4
   23d56:	08db      	lsrs	r3, r3, #3
   23d58:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   23d5c:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
   23d60:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   23d64:	2b00      	cmp	r3, #0
   23d66:	ddf0      	ble.n	23d4a <nearestNoteWithHysteresis+0xde>
			{
				difference = fastabsf(note - notes[i]);
   23d68:	ed95 0a00 	vldr	s0, [r5]
   23d6c:	ee38 0ac0 	vsub.f32	s0, s17, s0
   23d70:	f008 ff4a 	bl	2cc08 <fastabsf>
				if(difference < leastDifference)
   23d74:	eeb4 0ac8 	vcmpe.f32	s0, s16
   23d78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23d7c:	d5e5      	bpl.n	23d4a <nearestNoteWithHysteresis+0xde>
   23d7e:	4626      	mov	r6, r4
		for(int i = 1; i < 128; i++)
   23d80:	3401      	adds	r4, #1
				{
					leastDifference = difference;
   23d82:	eeb0 8a40 	vmov.f32	s16, s0
   23d86:	3504      	adds	r5, #4
		for(int i = 1; i < 128; i++)
   23d88:	2c80      	cmp	r4, #128	; 0x80
   23d8a:	d1e2      	bne.n	23d52 <nearestNoteWithHysteresis+0xe6>
					nearIndex = i;
				}
			}
		}

		if (lastNearNote == -1)
   23d8c:	f246 204c 	movw	r0, #25164	; 0x624c
   23d90:	f2c0 0006 	movt	r0, #6
   23d94:	6801      	ldr	r1, [r0, #0]
   23d96:	1c4b      	adds	r3, r1, #1
   23d98:	d05d      	beq.n	23e56 <nearestNoteWithHysteresis+0x1ea>
   23d9a:	eb07 0381 	add.w	r3, r7, r1, lsl #2
		{
			output = notes[nearIndex];
			lastNearNote = nearIndex;
			return output;
		}
		if (nearIndex != lastNearNote)
   23d9e:	42b1      	cmp	r1, r6
   23da0:	ed93 0a00 	vldr	s0, [r3]
   23da4:	d05c      	beq.n	23e60 <nearestNoteWithHysteresis+0x1f4>
			int downNote = 128;
			int i = lastNearNote;
			while ((i < 128) && (upNote == 0))
			{
				i++;
				if (chord[i%12] > 0)
   23da6:	f64a 2cab 	movw	ip, #43691	; 0xaaab
   23daa:	460b      	mov	r3, r1
			int upNote = 0;
   23dac:	2400      	movs	r4, #0
				if (chord[i%12] > 0)
   23dae:	f6c2 2caa 	movt	ip, #10922	; 0x2aaa
   23db2:	e00f      	b.n	23dd4 <nearestNoteWithHysteresis+0x168>
   23db4:	ebc2 0265 	rsb	r2, r2, r5, asr #1
			while ((i < 128) && (upNote == 0))
   23db8:	b9a4      	cbnz	r4, 23de4 <nearestNoteWithHysteresis+0x178>
				if (chord[i%12] > 0)
   23dba:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   23dbe:	eba3 0282 	sub.w	r2, r3, r2, lsl #2
   23dc2:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
   23dc6:	2a00      	cmp	r2, #0
   23dc8:	bfcc      	ite	gt
   23dca:	461c      	movgt	r4, r3
   23dcc:	2400      	movle	r4, #0
				{
					upNote = i;
				}
				if (i == 128)
				{
					upNote = 128;
   23dce:	2b80      	cmp	r3, #128	; 0x80
   23dd0:	bf08      	it	eq
   23dd2:	461c      	moveq	r4, r3
			while ((i < 128) && (upNote == 0))
   23dd4:	2b7f      	cmp	r3, #127	; 0x7f
				i++;
   23dd6:	f103 0301 	add.w	r3, r3, #1
				if (chord[i%12] > 0)
   23dda:	fb8c 2503 	smull	r2, r5, ip, r3
   23dde:	ea4f 72e3 	mov.w	r2, r3, asr #31
			while ((i < 128) && (upNote == 0))
   23de2:	dde7      	ble.n	23db4 <nearestNoteWithHysteresis+0x148>
			}
			i = lastNearNote;
			while ((i > 0) && (downNote == 128))
			{
				i--;
				if (chord[i%12] > 0)
   23de4:	f64a 25ab 	movw	r5, #43691	; 0xaaab
			int downNote = 128;
   23de8:	2280      	movs	r2, #128	; 0x80
				if (chord[i%12] > 0)
   23dea:	f6ca 25aa 	movt	r5, #43690	; 0xaaaa
   23dee:	e010      	b.n	23e12 <nearestNoteWithHysteresis+0x1a6>
			while ((i > 0) && (downNote == 128))
   23df0:	2a80      	cmp	r2, #128	; 0x80
				if (chord[i%12] > 0)
   23df2:	ea4f 03d3 	mov.w	r3, r3, lsr #3
			while ((i > 0) && (downNote == 128))
   23df6:	d112      	bne.n	23e1e <nearestNoteWithHysteresis+0x1b2>
				if (chord[i%12] > 0)
   23df8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   23dfc:	eba1 0383 	sub.w	r3, r1, r3, lsl #2
   23e00:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   23e04:	2b00      	cmp	r3, #0
   23e06:	bfcc      	ite	gt
   23e08:	460a      	movgt	r2, r1
   23e0a:	2280      	movle	r2, #128	; 0x80
				{
					downNote = i;
				}
				if (i == 0)
				{
					downNote = 0;
   23e0c:	2900      	cmp	r1, #0
   23e0e:	bf08      	it	eq
   23e10:	460a      	moveq	r2, r1
			while ((i > 0) && (downNote == 128))
   23e12:	2900      	cmp	r1, #0
				i--;
   23e14:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
				if (chord[i%12] > 0)
   23e18:	fba5 c301 	umull	ip, r3, r5, r1
			while ((i > 0) && (downNote == 128))
   23e1c:	dce8      	bgt.n	23df0 <nearestNoteWithHysteresis+0x184>
				}
			}
			//now should have adjacent notes in array available
			//calculate the differences that should be necessary to move away
			float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
			float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
   23e1e:	eb07 0282 	add.w	r2, r7, r2, lsl #2

			float theDifference = note - notes[lastNearNote];
   23e22:	ee78 8ac0 	vsub.f32	s17, s17, s0
			float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
   23e26:	edd2 7a00 	vldr	s15, [r2]
   23e2a:	ee70 7a67 	vsub.f32	s15, s0, s15
			if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
   23e2e:	ee69 7a67 	vnmul.f32	s15, s18, s15
   23e32:	eef4 7ae8 	vcmpe.f32	s15, s17
   23e36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23e3a:	dc0c      	bgt.n	23e56 <nearestNoteWithHysteresis+0x1ea>
			float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
   23e3c:	eb07 0484 	add.w	r4, r7, r4, lsl #2
   23e40:	edd4 7a00 	vldr	s15, [r4]
   23e44:	ee77 7ac0 	vsub.f32	s15, s15, s0
   23e48:	ee27 9a89 	vmul.f32	s18, s15, s18
			if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
   23e4c:	eeb4 9a68 	vcmp.f32	s18, s17
   23e50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23e54:	d504      	bpl.n	23e60 <nearestNoteWithHysteresis+0x1f4>
			{
				output = notes[nearIndex];
   23e56:	eb07 0786 	add.w	r7, r7, r6, lsl #2
				lastNearNote = nearIndex;
   23e5a:	6006      	str	r6, [r0, #0]
				output = notes[nearIndex];
   23e5c:	ed97 0a00 	vldr	s0, [r7]
	else
	{
		output = -1.0f; //signal that there are no notes to snap to
	}
	return output;
}
   23e60:	ecbd 8b04 	vpop	{d8-d9}
   23e64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (chord[i] > 0)
   23e68:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
   23e6c:	2a00      	cmp	r2, #0
   23e6e:	f73f af61 	bgt.w	23d34 <nearestNoteWithHysteresis+0xc8>
	if (hasNotes)
   23e72:	2b00      	cmp	r3, #0
   23e74:	f47f af5e 	bne.w	23d34 <nearestNoteWithHysteresis+0xc8>
		output = -1.0f; //signal that there are no notes to snap to
   23e78:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
}
   23e7c:	ecbd 8b04 	vpop	{d8-d9}
   23e80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00023e84 <SFXNeartuneTick>:
{
   23e84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   23e88:	f24e 1348 	movw	r3, #57672	; 0xe148
   23e8c:	f64c 2578 	movw	r5, #51832	; 0xca78
   23e90:	f64e 342c 	movw	r4, #60204	; 0xeb2c
{
   23e94:	4680      	mov	r8, r0
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   23e96:	f2c0 250f 	movt	r5, #527	; 0x20f
   23e9a:	f6c3 63fa 	movt	r3, #16122	; 0x3efa
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   23e9e:	f64d 00b4 	movw	r0, #55476	; 0xd8b4
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   23ea2:	f2c0 240f 	movt	r4, #527	; 0x20f
   23ea6:	ee07 3a90 	vmov	s15, r3
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   23eaa:	f2c0 200f 	movt	r0, #527	; 0x20f
{
   23eae:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   23eb2:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
   23eb6:	ed95 7a4b 	vldr	s14, [r5, #300]	; 0x12c
{
   23eba:	b083      	sub	sp, #12
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   23ebc:	eef0 6a48 	vmov.f32	s13, s16
   23ec0:	eee7 6a27 	vfma.f32	s13, s14, s15
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   23ec4:	eeb0 0a66 	vmov.f32	s0, s13
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   23ec8:	edc4 6a00 	vstr	s13, [r4]
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   23ecc:	f006 f958 	bl	2a180 <tRetune_setFidelityThreshold>
	displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
   23ed0:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   23ed4:	edd5 0a4c 	vldr	s1, [r5, #304]	; 0x130
   23ed8:	2200      	movs	r2, #0
   23eda:	f6c3 738c 	movt	r3, #16268	; 0x3f8c
   23ede:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   23ee2:	ee00 2a10 	vmov	s0, r2
   23ee6:	ee07 3a90 	vmov	s15, r3
   23eea:	ee60 0aa7 	vmul.f32	s1, s1, s15
   23eee:	f008 ff77 	bl	2cde0 <LEAF_clip>
	if (displayValues[2] > .90f)
   23ef2:	f246 6366 	movw	r3, #26214	; 0x6666
	displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   23ef6:	eef2 6a08 	vmov.f32	s13, #40	; 0x41400000  12.0
   23efa:	edd5 7a4e 	vldr	s15, [r5, #312]	; 0x138
	if (displayValues[2] > .90f)
   23efe:	f6c3 7366 	movt	r3, #16230	; 0x3f66
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   23f02:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
   23f06:	ed95 6a4d 	vldr	s12, [r5, #308]	; 0x134
	displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   23f0a:	ee67 7aa6 	vmul.f32	s15, s15, s13
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   23f0e:	ed95 7a4f 	vldr	s14, [r5, #316]	; 0x13c
	if (displayValues[2] > .90f)
   23f12:	ee06 3a90 	vmov	s13, r3
	displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
   23f16:	ed84 0a01 	vstr	s0, [r4, #4]
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   23f1a:	ee37 7a25 	vadd.f32	s14, s14, s11
	displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
   23f1e:	ed84 6a02 	vstr	s12, [r4, #8]
	if (displayValues[2] > .90f)
   23f22:	eeb4 6ae6 	vcmpe.f32	s12, s13
	displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   23f26:	edc4 7a03 	vstr	s15, [r4, #12]
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   23f2a:	ee27 7a08 	vmul.f32	s14, s14, s16
	if (displayValues[2] > .90f)
   23f2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   23f32:	ed84 7a04 	vstr	s14, [r4, #16]
	if (displayValues[2] > .90f)
   23f36:	f300 80b8 	bgt.w	240aa <SFXNeartuneTick+0x226>
   23f3a:	ee66 7a06 	vmul.f32	s15, s12, s12
   23f3e:	ee67 7a86 	vmul.f32	s15, s15, s12
	tExpSmooth_setFactor(&neartune_smoother, expBuffer[(int)(displayValues[2] * displayValues[2] * displayValues[2] * expBufferSizeMinusOne)]);
   23f42:	f246 223c 	movw	r2, #25148	; 0x623c
   23f46:	f24d 33e4 	movw	r3, #54244	; 0xd3e4
   23f4a:	f64d 1084 	movw	r0, #55684	; 0xd984
   23f4e:	f2c0 0206 	movt	r2, #6
   23f52:	f2c0 230f 	movt	r3, #527	; 0x20f
   23f56:	f2c0 200f 	movt	r0, #527	; 0x20f
   23f5a:	ed92 7a00 	vldr	s14, [r2]
   23f5e:	ee67 7a87 	vmul.f32	s15, s15, s14
   23f62:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   23f66:	ee17 2a90 	vmov	r2, s15
   23f6a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   23f6e:	ed93 0a00 	vldr	s0, [r3]
   23f72:	f007 fa0f 	bl	2b394 <tExpSmooth_setFactor>
	float destFactor = tExpSmooth_tick(&neartune_smoother);
   23f76:	f64d 1084 	movw	r0, #55684	; 0xd984
   23f7a:	f2c0 200f 	movt	r0, #527	; 0x20f
   23f7e:	f007 fa25 	bl	2b3cc <tExpSmooth_tick>
	float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
   23f82:	f64d 00b4 	movw	r0, #55476	; 0xd8b4
	float destFactor = tExpSmooth_tick(&neartune_smoother);
   23f86:	eef0 8a40 	vmov.f32	s17, s0
	float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
   23f8a:	f2c0 200f 	movt	r0, #527	; 0x20f
   23f8e:	f006 f8fb 	bl	2a188 <tRetune_getInputPeriod>
	if (detectedPeriod > 0.0f)
   23f92:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   23f96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23f9a:	dd56      	ble.n	2404a <SFXNeartuneTick+0x1c6>
		detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
   23f9c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   23fa0:	f246 2534 	movw	r5, #25140	; 0x6234
   23fa4:	f2c0 0506 	movt	r5, #6
   23fa8:	ee88 0a00 	vdiv.f32	s0, s16, s0
   23fac:	f008 fe9e 	bl	2ccec <LEAF_frequencyToMidi>
		desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   23fb0:	edd4 0a04 	vldr	s1, [r4, #16]
		detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
   23fb4:	ed85 0a00 	vstr	s0, [r5]
		desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   23fb8:	f7ff fe58 	bl	23c6c <nearestNoteWithHysteresis>
   23fbc:	f246 2328 	movw	r3, #25128	; 0x6228
		if (desiredSnap > 0.0f)
   23fc0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
		desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   23fc4:	f2c0 0306 	movt	r3, #6
   23fc8:	ed83 0a00 	vstr	s0, [r3]
		if (desiredSnap > 0.0f)
   23fcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   23fd0:	f340 808e 	ble.w	240f0 <SFXNeartuneTick+0x26c>
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   23fd4:	edd4 6a01 	vldr	s13, [r4, #4]
			factorDiff = (fabsf(destinationNote-lastSnap));
   23fd8:	f246 2450 	movw	r4, #25168	; 0x6250
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   23fdc:	edd5 7a00 	vldr	s15, [r5]
			if ((changeAmount < 11.9))
   23fe0:	f64c 46cd 	movw	r6, #52429	; 0xcccd
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   23fe4:	ee38 8a66 	vsub.f32	s16, s16, s13
			if ((changeAmount < 11.9))
   23fe8:	f64c 47cc 	movw	r7, #52428	; 0xcccc
			factorDiff = (fabsf(destinationNote-lastSnap));
   23fec:	f2c0 0406 	movt	r4, #6
			if ((changeAmount < 11.9))
   23ff0:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
   23ff4:	f2c4 0727 	movt	r7, #16423	; 0x4027
			changeAmount = (fabsf(destinationNote-detectedNote));
   23ff8:	f646 0294 	movw	r2, #26772	; 0x6894
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   23ffc:	ee28 8a27 	vmul.f32	s16, s16, s15
			factorDiff = (fabsf(destinationNote-lastSnap));
   24000:	ed94 7a00 	vldr	s14, [r4]
   24004:	f646 03e8 	movw	r3, #26856	; 0x68e8
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   24008:	f246 2930 	movw	r9, #25136	; 0x6230
			changeAmount = (fabsf(destinationNote-detectedNote));
   2400c:	f2c0 220e 	movt	r2, #526	; 0x20e
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   24010:	eea0 8a26 	vfma.f32	s16, s0, s13
			factorDiff = (fabsf(destinationNote-lastSnap));
   24014:	f2c0 230e 	movt	r3, #526	; 0x20e
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   24018:	f2c0 0906 	movt	r9, #6
			if ((changeAmount < 11.9))
   2401c:	ec47 6b16 	vmov	d6, r6, r7
			changeAmount = (fabsf(destinationNote-detectedNote));
   24020:	ee78 7a67 	vsub.f32	s15, s16, s15
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   24024:	ed89 8a00 	vstr	s16, [r9]
			factorDiff = (fabsf(destinationNote-lastSnap));
   24028:	ee38 7a47 	vsub.f32	s14, s16, s14
			changeAmount = (fabsf(destinationNote-detectedNote));
   2402c:	eef0 7ae7 	vabs.f32	s15, s15
			factorDiff = (fabsf(destinationNote-lastSnap));
   24030:	eeb0 7ac7 	vabs.f32	s14, s14
			if ((changeAmount < 11.9))
   24034:	eeb7 5ae7 	vcvt.f64.f32	d5, s15
			changeAmount = (fabsf(destinationNote-detectedNote));
   24038:	edc2 7a00 	vstr	s15, [r2]
			factorDiff = (fabsf(destinationNote-lastSnap));
   2403c:	ed83 7a00 	vstr	s14, [r3]
			if ((changeAmount < 11.9))
   24040:	eeb4 5bc6 	vcmpe.f64	d5, d6
   24044:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24048:	d434      	bmi.n	240b4 <SFXNeartuneTick+0x230>
	tRetune_setPitchFactor(&autotuneMono, destFactor, 0);
   2404a:	f64d 00b4 	movw	r0, #55476	; 0xd8b4
   2404e:	2100      	movs	r1, #0
   24050:	eeb0 0a68 	vmov.f32	s0, s17
   24054:	f2c0 200f 	movt	r0, #527	; 0x20f
   24058:	f006 f880 	bl	2a15c <tRetune_setPitchFactor>
	float* samples = tRetune_tick(&autotuneMono, input[1]);
   2405c:	f64d 00b4 	movw	r0, #55476	; 0xd8b4
   24060:	ed98 0a01 	vldr	s0, [r8, #4]
   24064:	f2c0 200f 	movt	r0, #527	; 0x20f
   24068:	f005 ffa2 	bl	29fb0 <tRetune_tick>
   2406c:	4604      	mov	r4, r0
	LEAF_crossfade(tRamp_tick(&nearWetRamp), fades);
   2406e:	f24e 60fc 	movw	r0, #59132	; 0xe6fc
   24072:	f2c0 200f 	movt	r0, #527	; 0x20f
   24076:	f007 f90d 	bl	2b294 <tRamp_tick>
   2407a:	4668      	mov	r0, sp
   2407c:	f008 fe20 	bl	2ccc0 <LEAF_crossfade>
	sample += input[1] * fades[1]; // crossfade to dry signal if no notes held down.
   24080:	edd8 7a01 	vldr	s15, [r8, #4]
   24084:	ed9d 7a01 	vldr	s14, [sp, #4]
   24088:	edd4 6a00 	vldr	s13, [r4]
   2408c:	ee67 7a87 	vmul.f32	s15, s15, s14
   24090:	ed9d 7a00 	vldr	s14, [sp]
   24094:	eee6 7a87 	vfma.f32	s15, s13, s14
	input[0] = sample;
   24098:	edc8 7a00 	vstr	s15, [r8]
	input[1] = sample;
   2409c:	edc8 7a01 	vstr	s15, [r8, #4]
}
   240a0:	b003      	add	sp, #12
   240a2:	ecbd 8b02 	vpop	{d8}
   240a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		displayValues[2] = 1.0f;
   240aa:	eef0 7a65 	vmov.f32	s15, s11
   240ae:	edc4 5a02 	vstr	s11, [r4, #8]
   240b2:	e746      	b.n	23f42 <SFXNeartuneTick+0xbe>
				destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   240b4:	eeb0 0a48 	vmov.f32	s0, s16
   240b8:	f008 ff7a 	bl	2cfb0 <LEAF_midiToFrequency>
   240bc:	eeb0 8a40 	vmov.f32	s16, s0
   240c0:	ed95 0a00 	vldr	s0, [r5]
   240c4:	f008 ff74 	bl	2cfb0 <LEAF_midiToFrequency>
   240c8:	f246 232c 	movw	r3, #25132	; 0x622c
   240cc:	eec8 7a00 	vdiv.f32	s15, s16, s0
				tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   240d0:	f64d 1084 	movw	r0, #55684	; 0xd984
				destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   240d4:	f2c0 0306 	movt	r3, #6
				tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   240d8:	f2c0 200f 	movt	r0, #527	; 0x20f
   240dc:	eeb0 0a67 	vmov.f32	s0, s15
				destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   240e0:	edc3 7a00 	vstr	s15, [r3]
				tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   240e4:	f007 f968 	bl	2b3b8 <tExpSmooth_setDest>
				lastSnap = destinationNote;
   240e8:	f8d9 3000 	ldr.w	r3, [r9]
   240ec:	6023      	str	r3, [r4, #0]
   240ee:	e7ac      	b.n	2404a <SFXNeartuneTick+0x1c6>
			tExpSmooth_setDest(&neartune_smoother, 1.0f);
   240f0:	f64d 1084 	movw	r0, #55684	; 0xd984
   240f4:	eeb0 0a48 	vmov.f32	s0, s16
   240f8:	f2c0 200f 	movt	r0, #527	; 0x20f
   240fc:	f007 f95c 	bl	2b3b8 <tExpSmooth_setDest>
   24100:	e7a3      	b.n	2404a <SFXNeartuneTick+0x1c6>
   24102:	bf00      	nop

00024104 <noteOff>:
}

void noteOff(int key, int velocity)
{
	UNUSED(velocity);
	if (chordArray[key%12] > 0) chordArray[key%12]--;
   24104:	f64a 22ab 	movw	r2, #43691	; 0xaaab
   24108:	17c3      	asrs	r3, r0, #31
   2410a:	f646 0198 	movw	r1, #26776	; 0x6898
   2410e:	f6c2 22aa 	movt	r2, #10922	; 0x2aaa
   24112:	f2c0 210e 	movt	r1, #526	; 0x20e
{
   24116:	b570      	push	{r4, r5, r6, lr}
   24118:	4604      	mov	r4, r0
	if (chordArray[key%12] > 0) chordArray[key%12]--;
   2411a:	fb82 0204 	smull	r0, r2, r2, r4
   2411e:	ebc3 0362 	rsb	r3, r3, r2, asr #1
   24122:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   24126:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
   2412a:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
   2412e:	2a00      	cmp	r2, #0
   24130:	dd02      	ble.n	24138 <noteOff+0x34>
   24132:	3a01      	subs	r2, #1
   24134:	f841 2023 	str.w	r2, [r1, r3, lsl #2]



	if (currentPreset == Rhodes)
   24138:	f646 13b9 	movw	r3, #27065	; 0x69b9
   2413c:	f2c0 230e 	movt	r3, #526	; 0x20e
   24140:	781b      	ldrb	r3, [r3, #0]
   24142:	2b11      	cmp	r3, #17
   24144:	d045      	beq.n	241d2 <noteOff+0xce>
				tADSR4_off(&FM_envs[voice][j]);
			}
		}

	}
	else if (currentPreset == ClassicSynth)
   24146:	2b10      	cmp	r3, #16
   24148:	d069      	beq.n	2421e <noteOff+0x11a>
			tADSR4_off(&polyEnvs[voice]);
			tADSR4_off(&polyFiltEnvs[voice]);
		}
	}

	else if (currentPreset == SamplerKeyboard)
   2414a:	2b06      	cmp	r3, #6
   2414c:	d012      	beq.n	24174 <noteOff+0x70>
	}
	else if (currentPreset == LivingStringSynth)
	{
		int voice;

		voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   2414e:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
	else if (currentPreset == LivingStringSynth)
   24152:	2b0f      	cmp	r3, #15
   24154:	b2e1      	uxtb	r1, r4
		voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   24156:	f2c0 200f 	movt	r0, #527	; 0x20f
	else if (currentPreset == LivingStringSynth)
   2415a:	f000 8081 	beq.w	24260 <noteOff+0x15c>
			tADSR4_off(&pluckEnvs[voice]);
		}
	}
	else
	{
		tSimplePoly_noteOff(&poly, key);
   2415e:	f009 fb6b 	bl	2d838 <tSimplePoly_noteOff>
	}

	if (tSimplePoly_getNumActiveVoices(&poly) < 1)
   24162:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   24166:	f2c0 200f 	movt	r0, #527	; 0x20f
   2416a:	f009 fcc1 	bl	2daf0 <tSimplePoly_getNumActiveVoices>
   2416e:	2800      	cmp	r0, #0
   24170:	dd2a      	ble.n	241c8 <noteOff+0xc4>
	{
		setLED_2(0);
	}

}
   24172:	bd70      	pop	{r4, r5, r6, pc}
		if (key >= LOWEST_SAMPLER_KEY && key < LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS)
   24174:	3c24      	subs	r4, #36	; 0x24
   24176:	2c30      	cmp	r4, #48	; 0x30
   24178:	d8f3      	bhi.n	24162 <noteOff+0x5e>
			if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
   2417a:	f24e 5000 	movw	r0, #58624	; 0xe500
   2417e:	00a6      	lsls	r6, r4, #2
   24180:	f2c0 200f 	movt	r0, #527	; 0x20f
   24184:	1835      	adds	r5, r6, r0
   24186:	4628      	mov	r0, r5
   24188:	f00b f968 	bl	2f45c <tBuffer_isActive>
   2418c:	2801      	cmp	r0, #1
   2418e:	d078      	beq.n	24282 <noteOff+0x17e>
				tExpSmooth_setDest(&kSamplerGains[key-LOWEST_SAMPLER_KEY], 0.0f);
   24190:	f24c 30f4 	movw	r0, #50164	; 0xc3f4
   24194:	2300      	movs	r3, #0
   24196:	f2c0 200f 	movt	r0, #527	; 0x20f
   2419a:	ee00 3a10 	vmov	s0, r3
   2419e:	4430      	add	r0, r6
   241a0:	f007 f90a 	bl	2b3b8 <tExpSmooth_setDest>
			samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
   241a4:	f64d 23d4 	movw	r3, #56020	; 0xdad4
   241a8:	2200      	movs	r2, #0
			UISamplerKButtons(ButtonC, ActionHoldContinuous);
   241aa:	2103      	movs	r1, #3
   241ac:	2007      	movs	r0, #7
			samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
   241ae:	f2c0 230f 	movt	r3, #527	; 0x20f
   241b2:	551a      	strb	r2, [r3, r4]
			UISamplerKButtons(ButtonC, ActionHoldContinuous);
   241b4:	f002 f956 	bl	26464 <UISamplerKButtons>
			tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
   241b8:	f24d 2094 	movw	r0, #53908	; 0xd294
   241bc:	f2c0 200f 	movt	r0, #527	; 0x20f
   241c0:	4430      	add	r0, r6
   241c2:	f00b fa51 	bl	2f668 <tSampler_stop>
   241c6:	e7cc      	b.n	24162 <noteOff+0x5e>
		setLED_2(0);
   241c8:	2000      	movs	r0, #0
}
   241ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		setLED_2(0);
   241ce:	f7f6 bfa1 	b.w	1b114 <setLED_2>
		if (tSimplePoly_getNumVoices(&poly) > 1)
   241d2:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   241d6:	f2c0 200f 	movt	r0, #527	; 0x20f
   241da:	f009 fc85 	bl	2dae8 <tSimplePoly_getNumVoices>
   241de:	2801      	cmp	r0, #1
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   241e0:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   241e4:	b2e1      	uxtb	r1, r4
   241e6:	f2c0 200f 	movt	r0, #527	; 0x20f
		if (tSimplePoly_getNumVoices(&poly) > 1)
   241ea:	dd15      	ble.n	24218 <noteOff+0x114>
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   241ec:	f009 fc08 	bl	2da00 <tSimplePoly_markPendingNoteOff>
		if (voice >= 0)
   241f0:	2800      	cmp	r0, #0
   241f2:	dbb6      	blt.n	24162 <noteOff+0x5e>
   241f4:	f64d 04c4 	movw	r4, #55492	; 0xd8c4
   241f8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   241fc:	f2c0 240f 	movt	r4, #527	; 0x20f
   24200:	00c0      	lsls	r0, r0, #3
   24202:	f104 0518 	add.w	r5, r4, #24
   24206:	4404      	add	r4, r0
   24208:	4405      	add	r5, r0
				tADSR4_off(&FM_envs[voice][j]);
   2420a:	4620      	mov	r0, r4
   2420c:	3404      	adds	r4, #4
   2420e:	f006 fd95 	bl	2ad3c <tADSR4_off>
			for (int j = 0; j < 6; j++)
   24212:	42a5      	cmp	r5, r4
   24214:	d1f9      	bne.n	2420a <noteOff+0x106>
   24216:	e7a4      	b.n	24162 <noteOff+0x5e>
			voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   24218:	f009 fb0e 	bl	2d838 <tSimplePoly_noteOff>
   2421c:	e7e8      	b.n	241f0 <noteOff+0xec>
		if (tSimplePoly_getNumVoices(&poly) > 1)
   2421e:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   24222:	f2c0 200f 	movt	r0, #527	; 0x20f
   24226:	f009 fc5f 	bl	2dae8 <tSimplePoly_getNumVoices>
   2422a:	2801      	cmp	r0, #1
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   2422c:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   24230:	b2e1      	uxtb	r1, r4
   24232:	f2c0 200f 	movt	r0, #527	; 0x20f
		if (tSimplePoly_getNumVoices(&poly) > 1)
   24236:	dd21      	ble.n	2427c <noteOff+0x178>
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   24238:	f009 fbe2 	bl	2da00 <tSimplePoly_markPendingNoteOff>
		if (voice >= 0)
   2423c:	2800      	cmp	r0, #0
   2423e:	db90      	blt.n	24162 <noteOff+0x5e>
			tADSR4_off(&polyEnvs[voice]);
   24240:	f64d 2338 	movw	r3, #55864	; 0xda38
   24244:	0084      	lsls	r4, r0, #2
   24246:	f2c0 230f 	movt	r3, #527	; 0x20f
   2424a:	1918      	adds	r0, r3, r4
   2424c:	f006 fd76 	bl	2ad3c <tADSR4_off>
			tADSR4_off(&polyFiltEnvs[voice]);
   24250:	f64b 40b0 	movw	r0, #48304	; 0xbcb0
   24254:	f2c0 200f 	movt	r0, #527	; 0x20f
   24258:	4420      	add	r0, r4
   2425a:	f006 fd6f 	bl	2ad3c <tADSR4_off>
   2425e:	e780      	b.n	24162 <noteOff+0x5e>
		voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   24260:	f009 faea 	bl	2d838 <tSimplePoly_noteOff>
		if (voice >= 0)
   24264:	2800      	cmp	r0, #0
   24266:	f6ff af7c 	blt.w	24162 <noteOff+0x5e>
			tADSR4_off(&pluckEnvs[voice]);
   2426a:	f24d 73a8 	movw	r3, #55208	; 0xd7a8
   2426e:	f2c0 230f 	movt	r3, #527	; 0x20f
   24272:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   24276:	f006 fd61 	bl	2ad3c <tADSR4_off>
   2427a:	e772      	b.n	24162 <noteOff+0x5e>
			voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   2427c:	f009 fadc 	bl	2d838 <tSimplePoly_noteOff>
   24280:	e7dc      	b.n	2423c <noteOff+0x138>
				tBuffer_stop(&keyBuff[key-LOWEST_SAMPLER_KEY]);
   24282:	4628      	mov	r0, r5
   24284:	f00b f8d2 	bl	2f42c <tBuffer_stop>
				UISamplerKButtons(ButtonUp, ActionPress);
   24288:	2100      	movs	r1, #0
   2428a:	2004      	movs	r0, #4
   2428c:	f002 f8ea 	bl	26464 <UISamplerKButtons>
   24290:	e788      	b.n	241a4 <noteOff+0xa0>
   24292:	bf00      	nop

00024294 <noteOn>:
	if (!velocity)
   24294:	2900      	cmp	r1, #0
   24296:	d048      	beq.n	2432a <noteOn+0x96>
		chordArray[key%12]++;
   24298:	f646 0298 	movw	r2, #26776	; 0x6898
{
   2429c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   242a0:	460d      	mov	r5, r1
		chordArray[key%12]++;
   242a2:	f64a 21ab 	movw	r1, #43691	; 0xaaab
   242a6:	4604      	mov	r4, r0
   242a8:	17c3      	asrs	r3, r0, #31
   242aa:	f6c2 21aa 	movt	r1, #10922	; 0x2aaa
		if (currentPreset == AutotuneMono)
   242ae:	f646 10b9 	movw	r0, #27065	; 0x69b9
		chordArray[key%12]++;
   242b2:	f2c0 220e 	movt	r2, #526	; 0x20e
   242b6:	fb81 6104 	smull	r6, r1, r1, r4
		if (currentPreset == AutotuneMono)
   242ba:	f2c0 200e 	movt	r0, #526	; 0x20e
		chordArray[key%12]++;
   242be:	ebc3 0361 	rsb	r3, r3, r1, asr #1
   242c2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   242c6:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
{
   242ca:	ed2d 8b02 	vpush	{d8}
		chordArray[key%12]++;
   242ce:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
		if (currentPreset == AutotuneMono)
   242d2:	7800      	ldrb	r0, [r0, #0]
		chordArray[key%12]++;
   242d4:	3101      	adds	r1, #1
		if (currentPreset == AutotuneMono)
   242d6:	2803      	cmp	r0, #3
		chordArray[key%12]++;
   242d8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		if (currentPreset == AutotuneMono)
   242dc:	d010      	beq.n	24300 <noteOn+0x6c>
		if (currentPreset == Rhodes)
   242de:	2811      	cmp	r0, #17
   242e0:	d049      	beq.n	24376 <noteOn+0xe2>
		else if (currentPreset == ClassicSynth)
   242e2:	2810      	cmp	r0, #16
   242e4:	d077      	beq.n	243d6 <noteOn+0x142>
		else if (currentPreset == SamplerKeyboard)
   242e6:	2806      	cmp	r0, #6
   242e8:	d12c      	bne.n	24344 <noteOn+0xb0>
			if ((key >= LOWEST_SAMPLER_KEY) && key < (LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS))
   242ea:	3c24      	subs	r4, #36	; 0x24
   242ec:	2c30      	cmp	r4, #48	; 0x30
   242ee:	f240 8094 	bls.w	2441a <noteOn+0x186>
		setLED_2(1);
   242f2:	2001      	movs	r0, #1
}
   242f4:	ecbd 8b02 	vpop	{d8}
   242f8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		setLED_2(1);
   242fc:	f7f6 bf0a 	b.w	1b114 <setLED_2>
			if (autotuneLock)
   24300:	f646 0288 	movw	r2, #26760	; 0x6888
   24304:	f2c0 220e 	movt	r2, #526	; 0x20e
   24308:	6812      	ldr	r2, [r2, #0]
   2430a:	b982      	cbnz	r2, 2432e <noteOn+0x9a>
   2430c:	b2ea      	uxtb	r2, r5
			tSimplePoly_noteOn(&poly, key, velocity);
   2430e:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   24312:	4621      	mov	r1, r4
   24314:	f2c0 200f 	movt	r0, #527	; 0x20f
   24318:	f009 f962 	bl	2d5e0 <tSimplePoly_noteOn>
		setLED_2(1);
   2431c:	2001      	movs	r0, #1
}
   2431e:	ecbd 8b02 	vpop	{d8}
   24322:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		setLED_2(1);
   24326:	f7f6 bef5 	b.w	1b114 <setLED_2>
		noteOff(key, velocity);
   2432a:	f7ff beeb 	b.w	24104 <noteOff>
				lockArray[key%12]++;
   2432e:	f646 1110 	movw	r1, #26896	; 0x6910
   24332:	b2ea      	uxtb	r2, r5
   24334:	f2c0 210e 	movt	r1, #526	; 0x20e
   24338:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
   2433c:	3001      	adds	r0, #1
   2433e:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
   24342:	e7e4      	b.n	2430e <noteOn+0x7a>
		else if (currentPreset == LivingStringSynth)
   24344:	280f      	cmp	r0, #15
   24346:	b2ea      	uxtb	r2, r5
   24348:	d1e1      	bne.n	2430e <noteOn+0x7a>
			int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   2434a:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   2434e:	4621      	mov	r1, r4
   24350:	f2c0 200f 	movt	r0, #527	; 0x20f
   24354:	f009 f944 	bl	2d5e0 <tSimplePoly_noteOn>
			if (whichVoice >= 0)
   24358:	2800      	cmp	r0, #0
   2435a:	dbca      	blt.n	242f2 <noteOn+0x5e>
				tADSR4_on(&pluckEnvs[whichVoice], velocity * 0.0078125f);
   2435c:	f24d 73a8 	movw	r3, #55208	; 0xd7a8
   24360:	ee00 5a10 	vmov	s0, r5
   24364:	f2c0 230f 	movt	r3, #527	; 0x20f
   24368:	eeba 0aec 	vcvt.f32.s32	s0, s0, #7
   2436c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   24370:	f006 fcd2 	bl	2ad18 <tADSR4_on>
   24374:	e7bd      	b.n	242f2 <noteOn+0x5e>
			int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   24376:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   2437a:	b2ea      	uxtb	r2, r5
   2437c:	4621      	mov	r1, r4
   2437e:	f2c0 200f 	movt	r0, #527	; 0x20f
   24382:	f009 f92d 	bl	2d5e0 <tSimplePoly_noteOn>
			if (whichVoice >= 0)
   24386:	1e07      	subs	r7, r0, #0
   24388:	dbb3      	blt.n	242f2 <noteOn+0x5e>
   2438a:	f64d 03c4 	movw	r3, #55492	; 0xd8c4
   2438e:	eb07 0647 	add.w	r6, r7, r7, lsl #1
					tADSR4_on(&FM_envs[whichVoice][j], velocity * 0.0078125f);
   24392:	ee08 5a10 	vmov	s16, r5
   24396:	f2c0 230f 	movt	r3, #527	; 0x20f
   2439a:	00f2      	lsls	r2, r6, #3
   2439c:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
   243a0:	f103 0618 	add.w	r6, r3, #24
   243a4:	18d5      	adds	r5, r2, r3
   243a6:	4416      	add	r6, r2
   243a8:	4628      	mov	r0, r5
   243aa:	3504      	adds	r5, #4
   243ac:	eeb0 0a48 	vmov.f32	s0, s16
   243b0:	f006 fcb2 	bl	2ad18 <tADSR4_on>
				for (int j = 0; j < 6; j++)
   243b4:	42ae      	cmp	r6, r5
   243b6:	d1f7      	bne.n	243a8 <noteOn+0x114>
				panValues[whichVoice] = key * 0.0078125; // divide by 128.0f
   243b8:	f24c 5384 	movw	r3, #50564	; 0xc584
   243bc:	ee07 4a10 	vmov	s14, r4
   243c0:	eeba 7bec 	vcvt.f64.s32	d7, d7, #7
   243c4:	f2c0 230f 	movt	r3, #527	; 0x20f
   243c8:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   243cc:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   243d0:	ed87 7a00 	vstr	s14, [r7]
   243d4:	e78d      	b.n	242f2 <noteOn+0x5e>
			int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   243d6:	f64d 00bc 	movw	r0, #55484	; 0xd8bc
   243da:	4621      	mov	r1, r4
   243dc:	b2ea      	uxtb	r2, r5
   243de:	f2c0 200f 	movt	r0, #527	; 0x20f
   243e2:	f009 f8fd 	bl	2d5e0 <tSimplePoly_noteOn>
			if (whichVoice >= 0)
   243e6:	2800      	cmp	r0, #0
   243e8:	db83      	blt.n	242f2 <noteOn+0x5e>
				tADSR4_on(&polyEnvs[whichVoice], velocity * 0.0078125f);
   243ea:	ee08 5a10 	vmov	s16, r5
   243ee:	f64d 2338 	movw	r3, #55864	; 0xda38
   243f2:	0084      	lsls	r4, r0, #2
   243f4:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
   243f8:	f2c0 230f 	movt	r3, #527	; 0x20f
   243fc:	1918      	adds	r0, r3, r4
   243fe:	eeb0 0a48 	vmov.f32	s0, s16
   24402:	f006 fc89 	bl	2ad18 <tADSR4_on>
				tADSR4_on(&polyFiltEnvs[whichVoice], velocity * 0.0078125f);
   24406:	f64b 40b0 	movw	r0, #48304	; 0xbcb0
   2440a:	eeb0 0a48 	vmov.f32	s0, s16
   2440e:	f2c0 200f 	movt	r0, #527	; 0x20f
   24412:	4420      	add	r0, r4
   24414:	f006 fc80 	bl	2ad18 <tADSR4_on>
   24418:	e76b      	b.n	242f2 <noteOn+0x5e>
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   2441a:	f24e 5700 	movw	r7, #58624	; 0xe500
					currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   2441e:	f246 2624 	movw	r6, #25124	; 0x6224
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   24422:	f2c0 270f 	movt	r7, #527	; 0x20f
					currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   24426:	f2c0 0606 	movt	r6, #6
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   2442a:	eb07 0084 	add.w	r0, r7, r4, lsl #2
					currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   2442e:	6034      	str	r4, [r6, #0]
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   24430:	f00b f80c 	bl	2f44c <tBuffer_getRecordedLength>
   24434:	2800      	cmp	r0, #0
   24436:	f000 808d 	beq.w	24554 <noteOn+0x2c0>
						keySampler[currentSamplerKeyGlobal]->active = -1;
   2443a:	6832      	ldr	r2, [r6, #0]
   2443c:	f24d 2494 	movw	r4, #53908	; 0xd294
						tSampler_forceStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   24440:	f24d 63e4 	movw	r3, #55012	; 0xd6e4
						keySampler[currentSamplerKeyGlobal]->active = -1;
   24444:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   24448:	f2c0 240f 	movt	r4, #527	; 0x20f
						tSampler_forceStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   2444c:	0090      	lsls	r0, r2, #2
   2444e:	f2c0 230f 	movt	r3, #527	; 0x20f
						tSampler_forceLength(&keySampler[currentSamplerKeyGlobal], samplePlayLengths[currentSamplerKeyGlobal]);
   24452:	f24c 58e8 	movw	r8, #50664	; 0xc5e8
						keySampler[currentSamplerKeyGlobal]->active = -1;
   24456:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
						if (newBuffer[currentSamplerKeyGlobal])
   2445a:	f24c 49bc 	movw	r9, #50364	; 0xc4bc
						tSampler_forceStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   2445e:	4403      	add	r3, r0
   24460:	4420      	add	r0, r4
						keySampler[currentSamplerKeyGlobal]->active = -1;
   24462:	6451      	str	r1, [r2, #68]	; 0x44
						tSampler_forceLength(&keySampler[currentSamplerKeyGlobal], samplePlayLengths[currentSamplerKeyGlobal]);
   24464:	f2c0 280f 	movt	r8, #527	; 0x20f
						tSampler_forceStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   24468:	edd3 7a00 	vldr	s15, [r3]
						if (newBuffer[currentSamplerKeyGlobal])
   2446c:	f2c0 290f 	movt	r9, #527	; 0x20f
						tSampler_forceStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   24470:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   24474:	ee17 1a90 	vmov	r1, s15
   24478:	f00b f996 	bl	2f7a8 <tSampler_forceStart>
						tSampler_forceLength(&keySampler[currentSamplerKeyGlobal], samplePlayLengths[currentSamplerKeyGlobal]);
   2447c:	6830      	ldr	r0, [r6, #0]
   2447e:	0080      	lsls	r0, r0, #2
   24480:	eb08 0300 	add.w	r3, r8, r0
   24484:	4420      	add	r0, r4
   24486:	edd3 7a00 	vldr	s15, [r3]
   2448a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2448e:	ee17 1a90 	vmov	r1, s15
   24492:	f00b fdcd 	bl	30030 <tSampler_forceLength>
						tSampler_setCrossfadeLength(&keySampler[currentSamplerKeyGlobal], crossfadeLengths[currentSamplerKeyGlobal]);
   24496:	6832      	ldr	r2, [r6, #0]
   24498:	f64d 3324 	movw	r3, #56100	; 0xdb24
   2449c:	0092      	lsls	r2, r2, #2
   2449e:	f2c0 230f 	movt	r3, #527	; 0x20f
   244a2:	18a0      	adds	r0, r4, r2
   244a4:	4413      	add	r3, r2
   244a6:	edd3 7a00 	vldr	s15, [r3]
   244aa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   244ae:	ee17 1a90 	vmov	r1, s15
   244b2:	f00b f877 	bl	2f5a4 <tSampler_setCrossfadeLength>
						tSampler_setRate(&keySampler[currentSamplerKeyGlobal], sampleRates[currentSamplerKeyGlobal] * sampleRatesMult[currentSamplerKeyGlobal]);
   244b6:	6830      	ldr	r0, [r6, #0]
   244b8:	f24c 62d0 	movw	r2, #50896	; 0xc6d0
   244bc:	f64d 33ec 	movw	r3, #56300	; 0xdbec
   244c0:	0080      	lsls	r0, r0, #2
   244c2:	f2c0 220f 	movt	r2, #527	; 0x20f
   244c6:	f2c0 230f 	movt	r3, #527	; 0x20f
   244ca:	4402      	add	r2, r0
   244cc:	4403      	add	r3, r0
   244ce:	4420      	add	r0, r4
   244d0:	edd3 7a00 	vldr	s15, [r3]
   244d4:	ed92 0a00 	vldr	s0, [r2]
   244d8:	ee20 0a27 	vmul.f32	s0, s0, s15
   244dc:	f00b fdda 	bl	30094 <tSampler_setRate>
						tSampler_setMode(&keySampler[currentSamplerKeyGlobal], loopOns[currentSamplerKeyGlobal]);
   244e0:	f64c 13b4 	movw	r3, #51636	; 0xc9b4
   244e4:	6832      	ldr	r2, [r6, #0]
   244e6:	f2c0 230f 	movt	r3, #527	; 0x20f
   244ea:	eb04 0082 	add.w	r0, r4, r2, lsl #2
   244ee:	f813 1022 	ldrb.w	r1, [r3, r2, lsl #2]
   244f2:	f00b f853 	bl	2f59c <tSampler_setMode>
						tSampler_play(&keySampler[currentSamplerKeyGlobal]);
   244f6:	6830      	ldr	r0, [r6, #0]
   244f8:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   244fc:	f00b f866 	bl	2f5cc <tSampler_play>
						if (newBuffer[currentSamplerKeyGlobal])
   24500:	6833      	ldr	r3, [r6, #0]
   24502:	f859 2023 	ldr.w	r2, [r9, r3, lsl #2]
   24506:	bb9a      	cbnz	r2, 24570 <noteOn+0x2dc>
   24508:	0098      	lsls	r0, r3, #2
						float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   2450a:	f64e 312c 	movw	r1, #60204	; 0xeb2c
   2450e:	f04f 5370 	mov.w	r3, #1006632960	; 0x3c000000
   24512:	ee07 5a90 	vmov	s15, r5
   24516:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2451a:	f2c0 210f 	movt	r1, #527	; 0x20f
   2451e:	ee07 3a10 	vmov	s14, r3
   24522:	eef8 6ae7 	vcvt.f32.s32	s13, s15
						tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   24526:	f24c 32f4 	movw	r2, #50164	; 0xc3f4
						float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   2452a:	edd1 7a06 	vldr	s15, [r1, #24]
						tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   2452e:	f2c0 220f 	movt	r2, #527	; 0x20f
						float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   24532:	ee30 0a67 	vsub.f32	s0, s0, s15
   24536:	ee67 7a87 	vmul.f32	s15, s15, s14
						tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   2453a:	4410      	add	r0, r2
   2453c:	eea6 0aa7 	vfma.f32	s0, s13, s15
   24540:	f006 ff3a 	bl	2b3b8 <tExpSmooth_setDest>
   24544:	6832      	ldr	r2, [r6, #0]
					samplerKeyHeld[currentSamplerKeyGlobal] = 1;
   24546:	f64d 23d4 	movw	r3, #56020	; 0xdad4
   2454a:	2101      	movs	r1, #1
   2454c:	f2c0 230f 	movt	r3, #527	; 0x20f
   24550:	5499      	strb	r1, [r3, r2]
   24552:	e6ce      	b.n	242f2 <noteOn+0x5e>
						tBuffer_record(&keyBuff[currentSamplerKeyGlobal]);
   24554:	6830      	ldr	r0, [r6, #0]
   24556:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   2455a:	f00a ff61 	bl	2f420 <tBuffer_record>
						newBuffer[currentSamplerKeyGlobal] = 1;
   2455e:	f24c 43bc 	movw	r3, #50364	; 0xc4bc
   24562:	6832      	ldr	r2, [r6, #0]
   24564:	2101      	movs	r1, #1
   24566:	f2c0 230f 	movt	r3, #527	; 0x20f
   2456a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   2456e:	e7ea      	b.n	24546 <noteOn+0x2b2>
							int recordLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]);
   24570:	eb07 0083 	add.w	r0, r7, r3, lsl #2
   24574:	f00a ff6a 	bl	2f44c <tBuffer_getRecordedLength>
							samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   24578:	6833      	ldr	r3, [r6, #0]
   2457a:	ee07 0a90 	vmov	s15, r0
							newBuffer[currentSamplerKeyGlobal] = 0;
   2457e:	2200      	movs	r2, #0
							samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   24580:	0098      	lsls	r0, r3, #2
   24582:	eef8 7ae7 	vcvt.f32.s32	s15, s15
							newBuffer[currentSamplerKeyGlobal] = 0;
   24586:	f849 2023 	str.w	r2, [r9, r3, lsl #2]
							samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   2458a:	4480      	add	r8, r0
   2458c:	edc8 7a00 	vstr	s15, [r8]
   24590:	e7bb      	b.n	2450a <noteOn+0x276>
   24592:	bf00      	nop

00024594 <pitchBend>:


void pitchBend(int data)
{
	pitchBendValue = (data - 8192) * 0.000244140625f;
   24594:	f5a0 5300 	sub.w	r3, r0, #8192	; 0x2000
   24598:	ee07 3a90 	vmov	s15, r3
   2459c:	f646 1340 	movw	r3, #26944	; 0x6940
   245a0:	eefa 7aca 	vcvt.f32.s32	s15, s15, #12
   245a4:	f2c0 230e 	movt	r3, #526	; 0x20e
   245a8:	edc3 7a00 	vstr	s15, [r3]
}
   245ac:	4770      	bx	lr
   245ae:	bf00      	nop

000245b0 <sustainOff>:
   245b0:	4770      	bx	lr
   245b2:	bf00      	nop

000245b4 <sustainOn>:
}

void sustainOn()
{

}
   245b4:	4770      	bx	lr
   245b6:	bf00      	nop

000245b8 <ssd1306_begin>:
uint8_t OLED_i2c_address;
uint8_t OLED_externalVCC;
I2C_HandleTypeDef* OLED_i2c_handle;

void ssd1306_begin(I2C_HandleTypeDef* hi2c, uint8_t vccstate, uint8_t i2caddr)
{
   245b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	OLED_i2c_address = i2caddr;
	OLED_externalVCC = vccstate;
	OLED_i2c_handle = hi2c;
   245bc:	f64e 14d0 	movw	r4, #59856	; 0xe9d0
	OLED_i2c_address = i2caddr;
   245c0:	f64e 15d4 	movw	r5, #59860	; 0xe9d4
	OLED_externalVCC = vccstate;
   245c4:	f64e 13cc 	movw	r3, #59852	; 0xe9cc
{
   245c8:	4688      	mov	r8, r1
	OLED_i2c_handle = hi2c;
   245ca:	f2c0 240f 	movt	r4, #527	; 0x20f
	OLED_i2c_address = i2caddr;
   245ce:	f2c0 250f 	movt	r5, #527	; 0x20f
	OLED_externalVCC = vccstate;
   245d2:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   245d6:	b084      	sub	sp, #16
	OLED_i2c_handle = hi2c;
   245d8:	6020      	str	r0, [r4, #0]

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   245da:	2000      	movs	r0, #0
   245dc:	f44f 7100 	mov.w	r1, #512	; 0x200
	OLED_i2c_address = i2caddr;
   245e0:	702a      	strb	r2, [r5, #0]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   245e2:	f6c5 0002 	movt	r0, #22530	; 0x5802
   245e6:	2201      	movs	r2, #1
	OLED_externalVCC = vccstate;
   245e8:	f883 8000 	strb.w	r8, [r3]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   245ec:	f7e8 fb7e 	bl	ccec <HAL_GPIO_WritePin>
	// VDD (3.3V) goes high at start, lets just chill for a ms
	HAL_Delay(1);
   245f0:	2001      	movs	r0, #1

void ssd1306_command(uint8_t c) {
	// I2C
	//	uint8_t control = 0x00;   // Co = 0, D/C = 0

	uint8_t i2c_message[2] = {0,0};
   245f2:	ae04      	add	r6, sp, #16
	HAL_Delay(1);
   245f4:	f7e3 ff2a 	bl	844c <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
   245f8:	2000      	movs	r0, #0
   245fa:	f44f 7100 	mov.w	r1, #512	; 0x200
	i2c_message[1] = c;
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   245fe:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
   24602:	4602      	mov	r2, r0
   24604:	f6c5 0002 	movt	r0, #22530	; 0x5802
   24608:	f7e8 fb70 	bl	ccec <HAL_GPIO_WritePin>
	HAL_Delay(10);
   2460c:	200a      	movs	r0, #10
   2460e:	f7e3 ff1d 	bl	844c <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   24612:	2000      	movs	r0, #0
   24614:	2201      	movs	r2, #1
   24616:	f44f 7100 	mov.w	r1, #512	; 0x200
   2461a:	f6c5 0002 	movt	r0, #22530	; 0x5802
   2461e:	f7e8 fb65 	bl	ccec <HAL_GPIO_WritePin>
	uint8_t i2c_message[2] = {0,0};
   24622:	f44f 432e 	mov.w	r3, #44544	; 0xae00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24626:	7829      	ldrb	r1, [r5, #0]
   24628:	6820      	ldr	r0, [r4, #0]
   2462a:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   2462c:	f826 3d04 	strh.w	r3, [r6, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24630:	2302      	movs	r3, #2
   24632:	4632      	mov	r2, r6
   24634:	f7e8 fea6 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24638:	f44f 4c55 	mov.w	ip, #54528	; 0xd500
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2463c:	7829      	ldrb	r1, [r5, #0]
   2463e:	4632      	mov	r2, r6
   24640:	6820      	ldr	r0, [r4, #0]
   24642:	2302      	movs	r3, #2
   24644:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   24646:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2464a:	f7e8 fe9b 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2464e:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24652:	7829      	ldrb	r1, [r5, #0]
   24654:	6820      	ldr	r0, [r4, #0]
   24656:	4632      	mov	r2, r6
   24658:	9700      	str	r7, [sp, #0]
   2465a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2465c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24660:	f7e8 fe90 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24664:	f44f 4c28 	mov.w	ip, #43008	; 0xa800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24668:	7829      	ldrb	r1, [r5, #0]
   2466a:	6820      	ldr	r0, [r4, #0]
   2466c:	4632      	mov	r2, r6
   2466e:	9700      	str	r7, [sp, #0]
   24670:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24672:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24676:	f7e8 fe85 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2467a:	f44f 5cf8 	mov.w	ip, #7936	; 0x1f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2467e:	7829      	ldrb	r1, [r5, #0]
   24680:	6820      	ldr	r0, [r4, #0]
   24682:	4632      	mov	r2, r6
   24684:	9700      	str	r7, [sp, #0]
   24686:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24688:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2468c:	f7e8 fe7a 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24690:	f44f 4c53 	mov.w	ip, #54016	; 0xd300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24694:	7829      	ldrb	r1, [r5, #0]
   24696:	6820      	ldr	r0, [r4, #0]
   24698:	4632      	mov	r2, r6
   2469a:	9700      	str	r7, [sp, #0]
   2469c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2469e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246a2:	f7e8 fe6f 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   246a6:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246aa:	7829      	ldrb	r1, [r5, #0]
   246ac:	6820      	ldr	r0, [r4, #0]
   246ae:	4632      	mov	r2, r6
   246b0:	9700      	str	r7, [sp, #0]
   246b2:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   246b4:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246b8:	f7e8 fe64 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   246bc:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246c0:	7829      	ldrb	r1, [r5, #0]
   246c2:	6820      	ldr	r0, [r4, #0]
   246c4:	4632      	mov	r2, r6
   246c6:	9700      	str	r7, [sp, #0]
   246c8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   246ca:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246ce:	f7e8 fe59 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   246d2:	f44f 4c0d 	mov.w	ip, #36096	; 0x8d00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246d6:	7829      	ldrb	r1, [r5, #0]
   246d8:	6820      	ldr	r0, [r4, #0]
   246da:	4632      	mov	r2, r6
   246dc:	9700      	str	r7, [sp, #0]
   246de:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   246e0:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246e4:	f7e8 fe4e 	bl	d384 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
   246e8:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246ec:	6820      	ldr	r0, [r4, #0]
   246ee:	7829      	ldrb	r1, [r5, #0]
   246f0:	4632      	mov	r2, r6
	uint8_t i2c_message[2] = {0,0};
   246f2:	bf0c      	ite	eq
   246f4:	f44f 5c80 	moveq.w	ip, #4096	; 0x1000
   246f8:	f44f 5ca0 	movne.w	ip, #5120	; 0x1400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   246fc:	9700      	str	r7, [sp, #0]
   246fe:	2302      	movs	r3, #2
   24700:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   24704:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24708:	f7e8 fe3c 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2470c:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24710:	7829      	ldrb	r1, [r5, #0]
   24712:	4632      	mov	r2, r6
   24714:	6820      	ldr	r0, [r4, #0]
   24716:	2302      	movs	r3, #2
   24718:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   2471a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2471e:	f7e8 fe31 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24722:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24726:	7829      	ldrb	r1, [r5, #0]
   24728:	6820      	ldr	r0, [r4, #0]
   2472a:	4632      	mov	r2, r6
   2472c:	9700      	str	r7, [sp, #0]
   2472e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24730:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24734:	f7e8 fe26 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24738:	f44f 4c21 	mov.w	ip, #41216	; 0xa100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2473c:	7829      	ldrb	r1, [r5, #0]
   2473e:	6820      	ldr	r0, [r4, #0]
   24740:	4632      	mov	r2, r6
   24742:	9700      	str	r7, [sp, #0]
   24744:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24746:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2474a:	f7e8 fe1b 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2474e:	f44f 4c48 	mov.w	ip, #51200	; 0xc800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24752:	7829      	ldrb	r1, [r5, #0]
   24754:	6820      	ldr	r0, [r4, #0]
   24756:	4632      	mov	r2, r6
   24758:	9700      	str	r7, [sp, #0]
   2475a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2475c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24760:	f7e8 fe10 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24764:	f44f 4c5a 	mov.w	ip, #55808	; 0xda00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24768:	7829      	ldrb	r1, [r5, #0]
   2476a:	6820      	ldr	r0, [r4, #0]
   2476c:	4632      	mov	r2, r6
   2476e:	9700      	str	r7, [sp, #0]
   24770:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24772:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24776:	f7e8 fe05 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2477a:	f44f 7c00 	mov.w	ip, #512	; 0x200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2477e:	7829      	ldrb	r1, [r5, #0]
   24780:	6820      	ldr	r0, [r4, #0]
   24782:	4632      	mov	r2, r6
   24784:	9700      	str	r7, [sp, #0]
   24786:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24788:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2478c:	f7e8 fdfa 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24790:	f44f 4c01 	mov.w	ip, #33024	; 0x8100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24794:	7829      	ldrb	r1, [r5, #0]
   24796:	6820      	ldr	r0, [r4, #0]
   24798:	4632      	mov	r2, r6
   2479a:	9700      	str	r7, [sp, #0]
   2479c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2479e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247a2:	f7e8 fdef 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   247a6:	f44f 4c0f 	mov.w	ip, #36608	; 0x8f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247aa:	7829      	ldrb	r1, [r5, #0]
   247ac:	6820      	ldr	r0, [r4, #0]
   247ae:	4632      	mov	r2, r6
   247b0:	9700      	str	r7, [sp, #0]
   247b2:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   247b4:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247b8:	f7e8 fde4 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   247bc:	f44f 4c59 	mov.w	ip, #55552	; 0xd900
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247c0:	7829      	ldrb	r1, [r5, #0]
   247c2:	6820      	ldr	r0, [r4, #0]
   247c4:	4632      	mov	r2, r6
   247c6:	9700      	str	r7, [sp, #0]
   247c8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   247ca:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247ce:	f7e8 fdd9 	bl	d384 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
   247d2:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247d6:	6820      	ldr	r0, [r4, #0]
   247d8:	7829      	ldrb	r1, [r5, #0]
   247da:	4632      	mov	r2, r6
	uint8_t i2c_message[2] = {0,0};
   247dc:	bf0c      	ite	eq
   247de:	f44f 5c08 	moveq.w	ip, #8704	; 0x2200
   247e2:	f44f 4c71 	movne.w	ip, #61696	; 0xf100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247e6:	9700      	str	r7, [sp, #0]
   247e8:	2302      	movs	r3, #2
   247ea:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   247ee:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247f2:	f7e8 fdc7 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   247f6:	f44f 4c5b 	mov.w	ip, #56064	; 0xdb00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   247fa:	7829      	ldrb	r1, [r5, #0]
   247fc:	4632      	mov	r2, r6
   247fe:	6820      	ldr	r0, [r4, #0]
   24800:	2302      	movs	r3, #2
   24802:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   24804:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24808:	f7e8 fdbc 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2480c:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24810:	7829      	ldrb	r1, [r5, #0]
   24812:	6820      	ldr	r0, [r4, #0]
   24814:	4632      	mov	r2, r6
   24816:	9700      	str	r7, [sp, #0]
   24818:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2481a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2481e:	f7e8 fdb1 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24822:	f44f 4c24 	mov.w	ip, #41984	; 0xa400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24826:	7829      	ldrb	r1, [r5, #0]
   24828:	6820      	ldr	r0, [r4, #0]
   2482a:	4632      	mov	r2, r6
   2482c:	9700      	str	r7, [sp, #0]
   2482e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24830:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24834:	f7e8 fda6 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   24838:	f44f 4c26 	mov.w	ip, #42496	; 0xa600
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2483c:	7829      	ldrb	r1, [r5, #0]
   2483e:	6820      	ldr	r0, [r4, #0]
   24840:	4632      	mov	r2, r6
   24842:	9700      	str	r7, [sp, #0]
   24844:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   24846:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2484a:	f7e8 fd9b 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2484e:	f44f 5c38 	mov.w	ip, #11776	; 0x2e00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24852:	7829      	ldrb	r1, [r5, #0]
   24854:	6820      	ldr	r0, [r4, #0]
   24856:	4632      	mov	r2, r6
   24858:	9700      	str	r7, [sp, #0]
   2485a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2485c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24860:	f7e8 fd90 	bl	d384 <HAL_I2C_Master_Transmit>
   24864:	6820      	ldr	r0, [r4, #0]
   24866:	4632      	mov	r2, r6
   24868:	7829      	ldrb	r1, [r5, #0]
	uint8_t i2c_message[2] = {0,0};
   2486a:	f44f 442f 	mov.w	r4, #44800	; 0xaf00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2486e:	2302      	movs	r3, #2
   24870:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   24872:	f8ad 400c 	strh.w	r4, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24876:	f7e8 fd85 	bl	d384 <HAL_I2C_Master_Transmit>
}
   2487a:	b004      	add	sp, #16
   2487c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024880 <ssd1306_display_full_buffer>:
  ssd1306_command(contrast);
}



void ssd1306_display_full_buffer(void) {
   24880:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24884:	f64e 15d4 	movw	r5, #59860	; 0xe9d4
void ssd1306_display_full_buffer(void) {
   24888:	b085      	sub	sp, #20
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2488a:	f64e 14d0 	movw	r4, #59856	; 0xe9d0
   2488e:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   24892:	ae04      	add	r6, sp, #16
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24894:	f2c0 250f 	movt	r5, #527	; 0x20f
   24898:	f2c0 240f 	movt	r4, #527	; 0x20f
	uint8_t i2c_message[2] = {0,0};
   2489c:	f44f 5304 	mov.w	r3, #8448	; 0x2100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248a0:	7829      	ldrb	r1, [r5, #0]
	uint8_t i2c_message[2] = {0,0};
   248a2:	f04f 0900 	mov.w	r9, #0
   248a6:	f826 3d04 	strh.w	r3, [r6, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248aa:	2302      	movs	r3, #2
   248ac:	4632      	mov	r2, r6
   248ae:	6820      	ldr	r0, [r4, #0]
   248b0:	9700      	str	r7, [sp, #0]
//		HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17);
////		HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17, 2000);
////		HAL_Delay(1);
//		i--;
//	}
	displayBufferChunk[0] = 0x40;
   248b2:	f246 6800 	movw	r8, #26112	; 0x6600
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248b6:	f7e8 fd65 	bl	d384 <HAL_I2C_Master_Transmit>
   248ba:	7829      	ldrb	r1, [r5, #0]
   248bc:	4632      	mov	r2, r6
   248be:	6820      	ldr	r0, [r4, #0]
   248c0:	9700      	str	r7, [sp, #0]
   248c2:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   248c4:	f8ad 900c 	strh.w	r9, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248c8:	f7e8 fd5c 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   248cc:	f44f 4cfe 	mov.w	ip, #32512	; 0x7f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248d0:	7829      	ldrb	r1, [r5, #0]
   248d2:	4632      	mov	r2, r6
   248d4:	6820      	ldr	r0, [r4, #0]
   248d6:	9700      	str	r7, [sp, #0]
   248d8:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   248da:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248de:	f7e8 fd51 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   248e2:	f44f 5c08 	mov.w	ip, #8704	; 0x2200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248e6:	7829      	ldrb	r1, [r5, #0]
   248e8:	4632      	mov	r2, r6
   248ea:	6820      	ldr	r0, [r4, #0]
   248ec:	9700      	str	r7, [sp, #0]
   248ee:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   248f0:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   248f4:	f7e8 fd46 	bl	d384 <HAL_I2C_Master_Transmit>
   248f8:	7829      	ldrb	r1, [r5, #0]
   248fa:	4632      	mov	r2, r6
   248fc:	6820      	ldr	r0, [r4, #0]
   248fe:	2302      	movs	r3, #2
   24900:	9700      	str	r7, [sp, #0]
	displayBufferChunk[0] = 0x40;
   24902:	f2c0 280e 	movt	r8, #526	; 0x20e
	uint8_t i2c_message[2] = {0,0};
   24906:	f8ad 900c 	strh.w	r9, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2490a:	f7e8 fd3b 	bl	d384 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2490e:	f44f 7c40 	mov.w	ip, #768	; 0x300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24912:	7829      	ldrb	r1, [r5, #0]
   24914:	4632      	mov	r2, r6
   24916:	6820      	ldr	r0, [r4, #0]
   24918:	9700      	str	r7, [sp, #0]
   2491a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2491c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   24920:	f7e8 fd30 	bl	d384 <HAL_I2C_Master_Transmit>
	displayBufferChunk[0] = 0x40;
   24924:	4640      	mov	r0, r8
   24926:	2340      	movs	r3, #64	; 0x40
   24928:	f24e 71cc 	movw	r1, #59340	; 0xe7cc
   2492c:	f44f 7200 	mov.w	r2, #512	; 0x200
   24930:	f800 3b01 	strb.w	r3, [r0], #1
   24934:	f2c0 210f 	movt	r1, #527	; 0x20f
   24938:	f00b fc30 	bl	3019c <memcpy>
	for (int i = 0; i < 512; i++)
	{
		displayBufferChunk[i+1] = buffer[i];
	}
	HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 513);
   2493c:	4642      	mov	r2, r8
   2493e:	7829      	ldrb	r1, [r5, #0]
   24940:	f240 2301 	movw	r3, #513	; 0x201
   24944:	6820      	ldr	r0, [r4, #0]
   24946:	f7e8 fe6f 	bl	d628 <HAL_I2C_Master_Transmit_DMA>
}
   2494a:	b005      	add	sp, #20
   2494c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00024950 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
   24950:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
   24954:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
   24956:	f6c5 0302 	movt	r3, #22530	; 0x5802
   2495a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
   2495e:	f042 0202 	orr.w	r2, r2, #2
   24962:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
   24966:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
   2496a:	f003 0302 	and.w	r3, r3, #2
   2496e:	9301      	str	r3, [sp, #4]
   24970:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
   24972:	b002      	add	sp, #8
   24974:	4770      	bx	lr
   24976:	bf00      	nop

00024978 <_exit>:
	errno = EINVAL;
	return -1;
}

void _exit (int status)
{
   24978:	b508      	push	{r3, lr}
	errno = EINVAL;
   2497a:	f00b fbcb 	bl	30114 <__errno>
   2497e:	2316      	movs	r3, #22
   24980:	6003      	str	r3, [r0, #0]
   24982:	e7fe      	b.n	24982 <_exit+0xa>

00024984 <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

/* TIM3 init function */
void MX_TIM3_Init(void)
{
   24984:	b530      	push	{r4, r5, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  htim3.Instance = TIM3;
   24986:	f64e 2418 	movw	r4, #59928	; 0xea18
   2498a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   2498e:	2300      	movs	r3, #0
{
   24990:	b093      	sub	sp, #76	; 0x4c
  htim3.Instance = TIM3;
   24992:	f2c0 240f 	movt	r4, #527	; 0x20f
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1024;
   24996:	4611      	mov	r1, r2
  htim3.Instance = TIM3;
   24998:	f2c4 0200 	movt	r2, #16384	; 0x4000
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   2499c:	9303      	str	r3, [sp, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   2499e:	4620      	mov	r0, r4
  htim3.Init.Period = 1024;
   249a0:	60e1      	str	r1, [r4, #12]
  htim3.Instance = TIM3;
   249a2:	6022      	str	r2, [r4, #0]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   249a4:	6123      	str	r3, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   249a6:	61a3      	str	r3, [r4, #24]
  TIM_OC_InitTypeDef sConfigOC = {0};
   249a8:	930b      	str	r3, [sp, #44]	; 0x2c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
   249aa:	e9c4 3301 	strd	r3, r3, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   249ae:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
   249b2:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
   249b6:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
   249ba:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   249be:	f7ee ff53 	bl	13868 <HAL_TIM_PWM_Init>
   249c2:	bb98      	cbnz	r0, 24a2c <MX_TIM3_Init+0xa8>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   249c4:	f64e 2018 	movw	r0, #59928	; 0xea18
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   249c8:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   249ca:	a903      	add	r1, sp, #12
   249cc:	f2c0 200f 	movt	r0, #527	; 0x20f
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   249d0:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   249d2:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   249d4:	f7f0 f8f2 	bl	14bbc <HAL_TIMEx_MasterConfigSynchronization>
   249d8:	bb28      	cbnz	r0, 24a26 <MX_TIM3_Init+0xa2>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   249da:	f64e 2018 	movw	r0, #59928	; 0xea18
  sConfigOC.Pulse = 0;
   249de:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   249e0:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   249e2:	a90b      	add	r1, sp, #44	; 0x2c
   249e4:	f2c0 200f 	movt	r0, #527	; 0x20f
   249e8:	2204      	movs	r2, #4
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   249ea:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   249ec:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 0;
   249ee:	e9cd 530b 	strd	r5, r3, [sp, #44]	; 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   249f2:	f7ef fddb 	bl	145ac <HAL_TIM_PWM_ConfigChannel>
   249f6:	b108      	cbz	r0, 249fc <MX_TIM3_Init+0x78>
  {
    Error_Handler();
   249f8:	f7f6 fb58 	bl	1b0ac <Error_Handler>
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM3)
   249fc:	f44f 6280 	mov.w	r2, #1024	; 0x400
   24a00:	6821      	ldr	r1, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   24a02:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
   24a04:	f2c4 0200 	movt	r2, #16384	; 0x4000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   24a08:	930a      	str	r3, [sp, #40]	; 0x28
  if(timHandle->Instance==TIM3)
   24a0a:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   24a0c:	e9cd 3306 	strd	r3, r3, [sp, #24]
   24a10:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if(timHandle->Instance==TIM3)
   24a14:	d02a      	beq.n	24a6c <MX_TIM3_Init+0xe8>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
   24a16:	f44f 6300 	mov.w	r3, #2048	; 0x800
   24a1a:	f2c4 0300 	movt	r3, #16384	; 0x4000
   24a1e:	4299      	cmp	r1, r3
   24a20:	d007      	beq.n	24a32 <MX_TIM3_Init+0xae>
}
   24a22:	b013      	add	sp, #76	; 0x4c
   24a24:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   24a26:	f7f6 fb41 	bl	1b0ac <Error_Handler>
   24a2a:	e7d6      	b.n	249da <MX_TIM3_Init+0x56>
    Error_Handler();
   24a2c:	f7f6 fb3e 	bl	1b0ac <Error_Handler>
   24a30:	e7c8      	b.n	249c4 <MX_TIM3_Init+0x40>
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a32:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24a36:	2402      	movs	r4, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24a38:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   24a3c:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a40:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24a44:	a906      	add	r1, sp, #24
   24a46:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a4a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   24a4e:	4322      	orrs	r2, r4
   24a50:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   24a54:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   24a58:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a5a:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24a5c:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
   24a5e:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a60:	9302      	str	r3, [sp, #8]
   24a62:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24a64:	f7e7 fd98 	bl	c598 <HAL_GPIO_Init>
}
   24a68:	b013      	add	sp, #76	; 0x4c
   24a6a:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a6c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24a70:	2402      	movs	r4, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24a72:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   24a76:	2520      	movs	r5, #32
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a78:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24a7c:	a906      	add	r1, sp, #24
   24a7e:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a82:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   24a86:	4322      	orrs	r2, r4
   24a88:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   24a8c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   24a90:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a92:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24a94:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
   24a96:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24a98:	9301      	str	r3, [sp, #4]
   24a9a:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24a9c:	f7e7 fd7c 	bl	c598 <HAL_GPIO_Init>
}
   24aa0:	b013      	add	sp, #76	; 0x4c
   24aa2:	bd30      	pop	{r4, r5, pc}

00024aa4 <MX_TIM4_Init>:
{
   24aa4:	b530      	push	{r4, r5, lr}
  htim4.Instance = TIM4;
   24aa6:	f64e 14d8 	movw	r4, #59864	; 0xe9d8
   24aaa:	f44f 6200 	mov.w	r2, #2048	; 0x800
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   24aae:	2300      	movs	r3, #0
{
   24ab0:	b097      	sub	sp, #92	; 0x5c
  htim4.Instance = TIM4;
   24ab2:	f2c0 240f 	movt	r4, #527	; 0x20f
  htim4.Init.Period = 1024;
   24ab6:	f44f 6180 	mov.w	r1, #1024	; 0x400
  htim4.Instance = TIM4;
   24aba:	f2c4 0200 	movt	r2, #16384	; 0x4000
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   24abe:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
   24ac0:	4620      	mov	r0, r4
  htim4.Init.Period = 1024;
   24ac2:	60e1      	str	r1, [r4, #12]
  htim4.Instance = TIM4;
   24ac4:	6022      	str	r2, [r4, #0]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   24ac6:	6123      	str	r3, [r4, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   24ac8:	61a3      	str	r3, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   24aca:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
   24acc:	930f      	str	r3, [sp, #60]	; 0x3c
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   24ace:	9309      	str	r3, [sp, #36]	; 0x24
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
   24ad0:	e9c4 3301 	strd	r3, r3, [r4, #4]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   24ad4:	e9cd 3307 	strd	r3, r3, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   24ad8:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
   24adc:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
   24ae0:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
   24ae4:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
   24ae8:	f7ee fd70 	bl	135cc <HAL_TIM_Base_Init>
   24aec:	2800      	cmp	r0, #0
   24aee:	d166      	bne.n	24bbe <MX_TIM4_Init+0x11a>
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   24af0:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   24af4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   24af8:	a906      	add	r1, sp, #24
   24afa:	f2c0 200f 	movt	r0, #527	; 0x20f
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   24afe:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   24b00:	f7ef f92c 	bl	13d5c <HAL_TIM_ConfigClockSource>
   24b04:	2800      	cmp	r0, #0
   24b06:	d157      	bne.n	24bb8 <MX_TIM4_Init+0x114>
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
   24b08:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
   24b0c:	f2c0 200f 	movt	r0, #527	; 0x20f
   24b10:	f7ee feaa 	bl	13868 <HAL_TIM_PWM_Init>
   24b14:	2800      	cmp	r0, #0
   24b16:	d14c      	bne.n	24bb2 <MX_TIM4_Init+0x10e>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   24b18:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   24b1c:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   24b1e:	a903      	add	r1, sp, #12
   24b20:	f2c0 200f 	movt	r0, #527	; 0x20f
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   24b24:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   24b26:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   24b28:	f7f0 f848 	bl	14bbc <HAL_TIMEx_MasterConfigSynchronization>
   24b2c:	2800      	cmp	r0, #0
   24b2e:	d13d      	bne.n	24bac <MX_TIM4_Init+0x108>
  sConfigOC.Pulse = 0;
   24b30:	2300      	movs	r3, #0
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   24b32:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   24b36:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   24b38:	a90f      	add	r1, sp, #60	; 0x3c
   24b3a:	f2c0 200f 	movt	r0, #527	; 0x20f
   24b3e:	461a      	mov	r2, r3
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   24b40:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   24b42:	950f      	str	r5, [sp, #60]	; 0x3c
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   24b44:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   24b48:	f7ef fd30 	bl	145ac <HAL_TIM_PWM_ConfigChannel>
   24b4c:	bb58      	cbnz	r0, 24ba6 <MX_TIM4_Init+0x102>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   24b4e:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
   24b52:	2204      	movs	r2, #4
   24b54:	a90f      	add	r1, sp, #60	; 0x3c
   24b56:	f2c0 200f 	movt	r0, #527	; 0x20f
   24b5a:	f7ef fd27 	bl	145ac <HAL_TIM_PWM_ConfigChannel>
   24b5e:	b9f8      	cbnz	r0, 24ba0 <MX_TIM4_Init+0xfc>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
   24b60:	f64e 10d8 	movw	r0, #59864	; 0xe9d8
   24b64:	a90f      	add	r1, sp, #60	; 0x3c
   24b66:	2208      	movs	r2, #8
   24b68:	f2c0 200f 	movt	r0, #527	; 0x20f
   24b6c:	f7ef fd1e 	bl	145ac <HAL_TIM_PWM_ConfigChannel>
   24b70:	b108      	cbz	r0, 24b76 <MX_TIM4_Init+0xd2>
    Error_Handler();
   24b72:	f7f6 fa9b 	bl	1b0ac <Error_Handler>
  if(timHandle->Instance==TIM3)
   24b76:	f44f 6280 	mov.w	r2, #1024	; 0x400
   24b7a:	6821      	ldr	r1, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   24b7c:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
   24b7e:	f2c4 0200 	movt	r2, #16384	; 0x4000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   24b82:	930e      	str	r3, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM3)
   24b84:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   24b86:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
   24b8a:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if(timHandle->Instance==TIM3)
   24b8e:	d036      	beq.n	24bfe <MX_TIM4_Init+0x15a>
  else if(timHandle->Instance==TIM4)
   24b90:	f44f 6300 	mov.w	r3, #2048	; 0x800
   24b94:	f2c4 0300 	movt	r3, #16384	; 0x4000
   24b98:	4299      	cmp	r1, r3
   24b9a:	d013      	beq.n	24bc4 <MX_TIM4_Init+0x120>
}
   24b9c:	b017      	add	sp, #92	; 0x5c
   24b9e:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   24ba0:	f7f6 fa84 	bl	1b0ac <Error_Handler>
   24ba4:	e7dc      	b.n	24b60 <MX_TIM4_Init+0xbc>
    Error_Handler();
   24ba6:	f7f6 fa81 	bl	1b0ac <Error_Handler>
   24baa:	e7d0      	b.n	24b4e <MX_TIM4_Init+0xaa>
    Error_Handler();
   24bac:	f7f6 fa7e 	bl	1b0ac <Error_Handler>
   24bb0:	e7be      	b.n	24b30 <MX_TIM4_Init+0x8c>
    Error_Handler();
   24bb2:	f7f6 fa7b 	bl	1b0ac <Error_Handler>
   24bb6:	e7af      	b.n	24b18 <MX_TIM4_Init+0x74>
    Error_Handler();
   24bb8:	f7f6 fa78 	bl	1b0ac <Error_Handler>
   24bbc:	e7a4      	b.n	24b08 <MX_TIM4_Init+0x64>
    Error_Handler();
   24bbe:	f7f6 fa75 	bl	1b0ac <Error_Handler>
   24bc2:	e795      	b.n	24af0 <MX_TIM4_Init+0x4c>
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24bc4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24bc8:	2402      	movs	r4, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24bca:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   24bce:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24bd2:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24bd6:	a90a      	add	r1, sp, #40	; 0x28
   24bd8:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24bdc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   24be0:	4322      	orrs	r2, r4
   24be2:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   24be6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   24bea:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24bec:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24bee:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
   24bf0:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24bf2:	9302      	str	r3, [sp, #8]
   24bf4:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24bf6:	f7e7 fccf 	bl	c598 <HAL_GPIO_Init>
}
   24bfa:	b017      	add	sp, #92	; 0x5c
   24bfc:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24bfe:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24c02:	2402      	movs	r4, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24c04:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   24c08:	2520      	movs	r5, #32
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24c0a:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24c0e:	a90a      	add	r1, sp, #40	; 0x28
   24c10:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24c14:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   24c18:	4322      	orrs	r2, r4
   24c1a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   24c1e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   24c22:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24c24:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   24c26:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
   24c28:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
   24c2a:	9301      	str	r3, [sp, #4]
   24c2c:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   24c2e:	f7e7 fcb3 	bl	c598 <HAL_GPIO_Init>
}
   24c32:	b017      	add	sp, #92	; 0x5c
   24c34:	bd30      	pop	{r4, r5, pc}
   24c36:	bf00      	nop

00024c38 <HAL_TIM_PWM_MspInit>:
  if(tim_pwmHandle->Instance==TIM3)
   24c38:	f44f 6380 	mov.w	r3, #1024	; 0x400
   24c3c:	6802      	ldr	r2, [r0, #0]
   24c3e:	f2c4 0300 	movt	r3, #16384	; 0x4000
   24c42:	429a      	cmp	r2, r3
   24c44:	d000      	beq.n	24c48 <HAL_TIM_PWM_MspInit+0x10>
   24c46:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_ENABLE();
   24c48:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
   24c4c:	b082      	sub	sp, #8
    __HAL_RCC_TIM3_CLK_ENABLE();
   24c4e:	f6c5 0302 	movt	r3, #22530	; 0x5802
   24c52:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   24c56:	f042 0202 	orr.w	r2, r2, #2
   24c5a:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
   24c5e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
   24c62:	f003 0302 	and.w	r3, r3, #2
   24c66:	9301      	str	r3, [sp, #4]
   24c68:	9b01      	ldr	r3, [sp, #4]
}
   24c6a:	b002      	add	sp, #8
   24c6c:	4770      	bx	lr
   24c6e:	bf00      	nop

00024c70 <HAL_TIM_Base_MspInit>:
  if(tim_baseHandle->Instance==TIM4)
   24c70:	f44f 6300 	mov.w	r3, #2048	; 0x800
   24c74:	6802      	ldr	r2, [r0, #0]
   24c76:	f2c4 0300 	movt	r3, #16384	; 0x4000
   24c7a:	429a      	cmp	r2, r3
   24c7c:	d000      	beq.n	24c80 <HAL_TIM_Base_MspInit+0x10>
   24c7e:	4770      	bx	lr
    __HAL_RCC_TIM4_CLK_ENABLE();
   24c80:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
   24c84:	b082      	sub	sp, #8
    __HAL_RCC_TIM4_CLK_ENABLE();
   24c86:	f6c5 0302 	movt	r3, #22530	; 0x5802
   24c8a:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   24c8e:	f042 0204 	orr.w	r2, r2, #4
   24c92:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
   24c96:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
   24c9a:	f003 0304 	and.w	r3, r3, #4
   24c9e:	9301      	str	r3, [sp, #4]
   24ca0:	9b01      	ldr	r3, [sp, #4]
}
   24ca2:	b002      	add	sp, #8
   24ca4:	4770      	bx	lr
   24ca6:	bf00      	nop

00024ca8 <initModeNames>:
VocodecPresetType currentPreset = 0;
VocodecPresetType previousPreset = PresetNil;
uint8_t loadingPreset = 0;

void initModeNames(void)
{
   24ca8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int i = 0; i < PresetNil; i++)
	{
		cvAddParam[i] = -1;
	}

	modeNames[Vocoder] = "VOCODER1";
   24cac:	f64e 27a8 	movw	r7, #60072	; 0xeaa8
{
   24cb0:	b08b      	sub	sp, #44	; 0x2c
	shortModeNames[Vocoder] = "VL";
	modeNamesDetails[Vocoder] = "LPC";
   24cb2:	f64e 4058 	movw	r0, #60504	; 0xec58
		floatADCUI[i] = -1.0f;
   24cb6:	f64e 32a4 	movw	r2, #60324	; 0xeba4
	modeNames[Vocoder] = "VOCODER1";
   24cba:	f2c0 270f 	movt	r7, #527	; 0x20f
		floatADCUI[i] = -1.0f;
   24cbe:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   24cc2:	f2c0 220f 	movt	r2, #527	; 0x20f
		orderedParams[i] = i;
   24cc6:	f64e 24f0 	movw	r4, #60144	; 0xeaf0
	modeNames[Vocoder] = "VOCODER1";
   24cca:	9702      	str	r7, [sp, #8]
	shortModeNames[Vocoder] = "VL";
   24ccc:	f64e 37e8 	movw	r7, #60392	; 0xebe8
		orderedParams[i] = i;
   24cd0:	f44f 7b80 	mov.w	fp, #256	; 0x100
	modeNames[Vocoder] = "VOCODER1";
   24cd4:	f645 0e90 	movw	lr, #22672	; 0x5890
	shortModeNames[Vocoder] = "VL";
   24cd8:	f2c0 270f 	movt	r7, #527	; 0x20f
		orderedParams[i] = i;
   24cdc:	f2c0 240f 	movt	r4, #527	; 0x20f
		floatADCUI[i] = -1.0f;
   24ce0:	edc2 7a00 	vstr	s15, [r2]
		orderedParams[i] = i;
   24ce4:	f2c0 3b02 	movt	fp, #770	; 0x302
	shortModeNames[Vocoder] = "VL";
   24ce8:	9700      	str	r7, [sp, #0]
	modeNamesDetails[Vocoder] = "LPC";
   24cea:	4607      	mov	r7, r0
	numPages[Vocoder] = 2;
	knobParamNames[Vocoder][0] = "VOLUME";
   24cec:	f645 00a4 	movw	r0, #22692	; 0x58a4
		floatADCUI[i] = -1.0f;
   24cf0:	edc2 7a01 	vstr	s15, [r2, #4]
	modeNamesDetails[Vocoder] = "LPC";
   24cf4:	f2c0 270f 	movt	r7, #527	; 0x20f
		floatADCUI[i] = -1.0f;
   24cf8:	edc2 7a02 	vstr	s15, [r2, #8]
   24cfc:	edc2 7a03 	vstr	s15, [r2, #12]
	modeNames[Vocoder] = "VOCODER1";
   24d00:	f2c0 0e03 	movt	lr, #3
	modeNamesDetails[Vocoder] = "LPC";
   24d04:	9701      	str	r7, [sp, #4]
	knobParamNames[Vocoder][1] = "WARP";
	knobParamNames[Vocoder][2] = "QUALITY";
   24d06:	f645 07b4 	movw	r7, #22708	; 0x58b4
		floatADCUI[i] = -1.0f;
   24d0a:	edc2 7a04 	vstr	s15, [r2, #16]
	knobParamNames[Vocoder][0] = "VOLUME";
   24d0e:	f2c0 0003 	movt	r0, #3
	knobParamNames[Vocoder][2] = "QUALITY";
   24d12:	f2c0 0703 	movt	r7, #3
		floatADCUI[i] = -1.0f;
   24d16:	edc2 7a05 	vstr	s15, [r2, #20]
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
	knobParamNames[Vocoder][8] = "PULSESHAPE";
	knobParamNames[Vocoder][9] = "";


	modeNames[VocoderCh] = "VOCODER2";
   24d1a:	f645 0cfc 	movw	ip, #22780	; 0x58fc
	orderedParams[7] = ButtonB;
   24d1e:	2206      	movs	r2, #6
	knobParamNames[Vocoder][2] = "QUALITY";
   24d20:	9705      	str	r7, [sp, #20]
	knobParamNames[Vocoder][5] = "BREATH";
   24d22:	f645 07d4 	movw	r7, #22740	; 0x58d4
	knobParamNames[Vocoder][0] = "VOLUME";
   24d26:	9004      	str	r0, [sp, #16]
	modeNames[VocoderCh] = "VOCODER2";
   24d28:	f2c0 0c03 	movt	ip, #3
	knobParamNames[Vocoder][5] = "BREATH";
   24d2c:	f2c0 0703 	movt	r7, #3
		orderedParams[i] = i;
   24d30:	f8c4 b000 	str.w	fp, [r4]
	orderedParams[7] = ButtonB;
   24d34:	71e2      	strb	r2, [r4, #7]
		orderedParams[i] = i;
   24d36:	f04f 0b05 	mov.w	fp, #5
	knobParamNames[Vocoder][5] = "BREATH";
   24d3a:	9708      	str	r7, [sp, #32]
	knobParamNames[Vocoder][6] = "TILT";
   24d3c:	f645 07dc 	movw	r7, #22748	; 0x58dc
   24d40:	f64e 41a0 	movw	r1, #60576	; 0xeca0
	shortModeNames[Vocoder] = "VL";
   24d44:	f645 069c 	movw	r6, #22684	; 0x589c
	knobParamNames[Vocoder][6] = "TILT";
   24d48:	f2c0 0703 	movt	r7, #3
	shortModeNames[VocoderCh] = "VC";
   24d4c:	f645 1a08 	movw	sl, #22792	; 0x5908
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   24d50:	f645 00bc 	movw	r0, #22716	; 0x58bc
	knobParamNames[Vocoder][9] = "";
   24d54:	f645 020c 	movw	r2, #22540	; 0x580c
	knobParamNames[Vocoder][6] = "TILT";
   24d58:	9707      	str	r7, [sp, #28]
   24d5a:	f2c0 210f 	movt	r1, #527	; 0x20f
	modeNames[Vocoder] = "VOCODER1";
   24d5e:	9f02      	ldr	r7, [sp, #8]
	shortModeNames[Vocoder] = "VL";
   24d60:	f2c0 0603 	movt	r6, #3
		orderedParams[i] = i;
   24d64:	f884 b005 	strb.w	fp, [r4, #5]
	shortModeNames[VocoderCh] = "VC";
   24d68:	f2c0 0a03 	movt	sl, #3
	modeNames[Vocoder] = "VOCODER1";
   24d6c:	f8c7 e000 	str.w	lr, [r7]
		orderedParams[i] = i;
   24d70:	f04f 0e04 	mov.w	lr, #4
	modeNames[VocoderCh] = "VOCODER2";
   24d74:	f8c7 c004 	str.w	ip, [r7, #4]
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   24d78:	f2c0 0003 	movt	r0, #3
	shortModeNames[Vocoder] = "VL";
   24d7c:	9f00      	ldr	r7, [sp, #0]
	knobParamNames[Vocoder][9] = "";
   24d7e:	f2c0 0203 	movt	r2, #3
		orderedParams[i] = i;
   24d82:	f884 e004 	strb.w	lr, [r4, #4]
	modeNamesDetails[VocoderCh] = "CHANNEL";
   24d86:	f645 150c 	movw	r5, #22796	; 0x590c
	orderedParams[6] = ButtonA;
   24d8a:	f884 b006 	strb.w	fp, [r4, #6]
   24d8e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   24d92:	9006      	str	r0, [sp, #24]
	modeNamesDetails[VocoderCh] = "CHANNEL";
   24d94:	f2c0 0503 	movt	r5, #3
   24d98:	600c      	str	r4, [r1, #0]
	knobParamNames[Vocoder][0] = "VOLUME";
   24d9a:	f64e 43cc 	movw	r3, #60620	; 0xeccc
   24d9e:	604c      	str	r4, [r1, #4]
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
   24da0:	f645 0ee4 	movw	lr, #22756	; 0x58e4
	knobParamNames[Vocoder][9] = "";
   24da4:	9203      	str	r2, [sp, #12]
	knobParamNames[Vocoder][0] = "VOLUME";
   24da6:	f2c0 230f 	movt	r3, #527	; 0x20f
   24daa:	608c      	str	r4, [r1, #8]
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
   24dac:	f2c0 0e03 	movt	lr, #3
   24db0:	60cc      	str	r4, [r1, #12]
	knobParamNames[Vocoder][1] = "WARP";
   24db2:	f645 08ac 	movw	r8, #22700	; 0x58ac
   24db6:	820c      	strh	r4, [r1, #16]
	knobParamNames[Vocoder][4] = "NOISTHRESH";
   24db8:	f645 00c8 	movw	r0, #22728	; 0x58c8
	shortModeNames[Vocoder] = "VL";
   24dbc:	603e      	str	r6, [r7, #0]
	knobParamNames[Vocoder][1] = "WARP";
   24dbe:	f2c0 0803 	movt	r8, #3
	shortModeNames[VocoderCh] = "VC";
   24dc2:	f8c7 a004 	str.w	sl, [r7, #4]
	modeNamesDetails[Vocoder] = "LPC";
   24dc6:	f645 09a0 	movw	r9, #22688	; 0x58a0
   24dca:	9f01      	ldr	r7, [sp, #4]
	knobParamNames[Vocoder][8] = "PULSESHAPE";
   24dcc:	f645 0cf0 	movw	ip, #22768	; 0x58f0
	knobParamNames[Vocoder][0] = "VOLUME";
   24dd0:	9a04      	ldr	r2, [sp, #16]
	knobParamNames[VocoderCh][6] = "PULSEWIDTH";
	knobParamNames[VocoderCh][7] = "PULSESHAPE";
	knobParamNames[VocoderCh][8] = "BREATH";
	knobParamNames[VocoderCh][9] = "SPEED";
	knobParamNames[VocoderCh][10] = "BANDSQUISH";
	knobParamNames[VocoderCh][11] = "BANDOFF";
   24dd2:	f645 1434 	movw	r4, #22836	; 0x5934
	modeNamesDetails[VocoderCh] = "CHANNEL";
   24dd6:	607d      	str	r5, [r7, #4]
	knobParamNames[Vocoder][4] = "NOISTHRESH";
   24dd8:	f2c0 0003 	movt	r0, #3
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   24ddc:	9d06      	ldr	r5, [sp, #24]
	knobParamNames[VocoderCh][10] = "BANDSQUISH";
   24dde:	f645 1a28 	movw	sl, #22824	; 0x5928
	knobParamNames[Vocoder][2] = "QUALITY";
   24de2:	9905      	ldr	r1, [sp, #20]
	knobParamNames[Vocoder][8] = "PULSESHAPE";
   24de4:	f2c0 0c03 	movt	ip, #3
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   24de8:	60dd      	str	r5, [r3, #12]
	modeNamesDetails[Vocoder] = "LPC";
   24dea:	f2c0 0903 	movt	r9, #3
	knobParamNames[Vocoder][5] = "BREATH";
   24dee:	9d08      	ldr	r5, [sp, #32]
	knobParamNames[VocoderCh][11] = "BANDOFF";
   24df0:	f2c0 0403 	movt	r4, #3
	knobParamNames[Vocoder][0] = "VOLUME";
   24df4:	601a      	str	r2, [r3, #0]
	knobParamNames[VocoderCh][10] = "BANDSQUISH";
   24df6:	f2c0 0a03 	movt	sl, #3
	knobParamNames[Vocoder][5] = "BREATH";
   24dfa:	615d      	str	r5, [r3, #20]
	knobParamNames[VocoderCh][12] = "TILT";
	knobParamNames[VocoderCh][13] = "STEREO";
	knobParamNames[VocoderCh][14] = "BARKPULL";

	modeNames[Pitchshift] = "PITCHSHIFT";
   24dfc:	f645 1650 	movw	r6, #22864	; 0x5950
	knobParamNames[Vocoder][6] = "TILT";
   24e00:	9d07      	ldr	r5, [sp, #28]
	knobParamNames[VocoderCh][3] = "BANDWIDTH";
   24e02:	f645 1b14 	movw	fp, #22804	; 0x5914
	knobParamNames[Vocoder][4] = "NOISTHRESH";
   24e06:	6118      	str	r0, [r3, #16]
	modeNames[Pitchshift] = "PITCHSHIFT";
   24e08:	f2c0 0603 	movt	r6, #3
	knobParamNames[VocoderCh][4] = "NOISTHRESH";
   24e0c:	6758      	str	r0, [r3, #116]	; 0x74
	shortModeNames[Pitchshift] = "PS";
	modeNamesDetails[Pitchshift] = "";
	numPages[Pitchshift] = 2;
	knobParamNames[Pitchshift][0] = "SHIFT";
	knobParamNames[Pitchshift][1] = "FINE";
   24e0e:	f645 1068 	movw	r0, #22888	; 0x5968
	modeNamesDetails[Vocoder] = "LPC";
   24e12:	f8c7 9000 	str.w	r9, [r7]
	knobParamNames[Pitchshift][0] = "SHIFT";
   24e16:	f645 1960 	movw	r9, #22880	; 0x5960
	knobParamNames[VocoderCh][11] = "BANDOFF";
   24e1a:	9409      	str	r4, [sp, #36]	; 0x24
	knobParamNames[Pitchshift][1] = "FINE";
   24e1c:	f2c0 0003 	movt	r0, #3
	knobParamNames[Vocoder][1] = "WARP";
   24e20:	f8c3 8004 	str.w	r8, [r3, #4]
	knobParamNames[VocoderCh][14] = "BARKPULL";
   24e24:	f645 1444 	movw	r4, #22852	; 0x5944
	knobParamNames[Vocoder][2] = "QUALITY";
   24e28:	6099      	str	r1, [r3, #8]
	shortModeNames[Pitchshift] = "PS";
   24e2a:	f645 115c 	movw	r1, #22876	; 0x595c
	knobParamNames[Vocoder][8] = "PULSESHAPE";
   24e2e:	f8c3 c020 	str.w	ip, [r3, #32]
	knobParamNames[VocoderCh][14] = "BARKPULL";
   24e32:	f2c0 0403 	movt	r4, #3
	knobParamNames[VocoderCh][6] = "PULSEWIDTH";
   24e36:	f8c3 e07c 	str.w	lr, [r3, #124]	; 0x7c
	shortModeNames[Pitchshift] = "PS";
   24e3a:	f2c0 0103 	movt	r1, #3
	knobParamNames[VocoderCh][7] = "PULSESHAPE";
   24e3e:	f8c3 c080 	str.w	ip, [r3, #128]	; 0x80
	knobParamNames[Pitchshift][2] = "F AMT";
	knobParamNames[Pitchshift][3] = "FORMANT";
	knobParamNames[Pitchshift][4] = "RANGE";
   24e42:	f645 1c80 	movw	ip, #22912	; 0x5980
	knobParamNames[VocoderCh][3] = "BANDWIDTH";
   24e46:	f2c0 0b03 	movt	fp, #3
	knobParamNames[Pitchshift][0] = "SHIFT";
   24e4a:	f2c0 0903 	movt	r9, #3
	knobParamNames[Pitchshift][4] = "RANGE";
   24e4e:	f2c0 0c03 	movt	ip, #3
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
   24e52:	e9c3 5e06 	strd	r5, lr, [r3, #24]
	knobParamNames[Vocoder][9] = "";
   24e56:	9d03      	ldr	r5, [sp, #12]
	knobParamNames[Pitchshift][3] = "FORMANT";
   24e58:	f645 1e78 	movw	lr, #22904	; 0x5978
	knobParamNames[Vocoder][9] = "";
   24e5c:	625d      	str	r5, [r3, #36]	; 0x24
	knobParamNames[Pitchshift][3] = "FORMANT";
   24e5e:	f2c0 0e03 	movt	lr, #3
	knobParamNames[VocoderCh][5] = "SAWtoPULSE";
   24e62:	9d06      	ldr	r5, [sp, #24]
   24e64:	679d      	str	r5, [r3, #120]	; 0x78
	knobParamNames[VocoderCh][8] = "BREATH";
   24e66:	9d08      	ldr	r5, [sp, #32]
	knobParamNames[VocoderCh][1] = "WARP";
   24e68:	e9c3 2819 	strd	r2, r8, [r3, #100]	; 0x64
	knobParamNames[VocoderCh][8] = "BREATH";
   24e6c:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
	knobParamNames[Pitchshift][2] = "F AMT";
   24e70:	f645 1870 	movw	r8, #22896	; 0x5970
	knobParamNames[VocoderCh][2] = "QUALITY";
   24e74:	9a05      	ldr	r2, [sp, #20]
	knobParamNames[VocoderCh][12] = "TILT";
   24e76:	9d07      	ldr	r5, [sp, #28]
	knobParamNames[Pitchshift][2] = "F AMT";
   24e78:	f2c0 0803 	movt	r8, #3
	knobParamNames[VocoderCh][2] = "QUALITY";
   24e7c:	66da      	str	r2, [r3, #108]	; 0x6c
	knobParamNames[VocoderCh][12] = "TILT";
   24e7e:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	knobParamNames[Pitchshift][5] = "OFFSET";
   24e82:	f645 1588 	movw	r5, #22920	; 0x5988
	modeNamesDetails[Pitchshift] = "";
   24e86:	9a03      	ldr	r2, [sp, #12]
	knobParamNames[VocoderCh][10] = "BANDSQUISH";
   24e88:	f8c3 a08c 	str.w	sl, [r3, #140]	; 0x8c
	knobParamNames[VocoderCh][13] = "STEREO";
   24e8c:	f645 1a3c 	movw	sl, #22844	; 0x593c
	knobParamNames[Pitchshift][5] = "OFFSET";
   24e90:	f2c0 0503 	movt	r5, #3
	knobParamNames[Pitchshift][8] = "";
	knobParamNames[Pitchshift][9] = "";

	modeNames[AutotuneMono] = "AUTOTUNE";
	shortModeNames[AutotuneMono] = "NT";
	modeNamesDetails[AutotuneMono] = "";
   24e94:	60fa      	str	r2, [r7, #12]
	modeNamesDetails[Pitchshift] = "";
   24e96:	60ba      	str	r2, [r7, #8]
	knobParamNames[Pitchshift][6] = "";
   24e98:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
	knobParamNames[Pitchshift][9] = "";
   24e9c:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
	knobParamNames[Pitchshift][1] = "FINE";
   24ea0:	f8c3 00cc 	str.w	r0, [r3, #204]	; 0xcc
	knobParamNames[VocoderCh][13] = "STEREO";
   24ea4:	4650      	mov	r0, sl
	knobParamNames[Pitchshift][5] = "OFFSET";
   24ea6:	9506      	str	r5, [sp, #24]
	knobParamNames[AutotuneMono][2] = "SPEED";
	knobParamNames[AutotuneMono][3] = "LEAPALLOW";
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";


	modeNames[AutotunePoly] = "HARMONIZE";
   24ea8:	f645 1ac8 	movw	sl, #22984	; 0x59c8
	knobParamNames[VocoderCh][11] = "BANDOFF";
   24eac:	9d09      	ldr	r5, [sp, #36]	; 0x24
	knobParamNames[VocoderCh][13] = "STEREO";
   24eae:	f2c0 0003 	movt	r0, #3
	knobParamNames[Pitchshift][5] = "OFFSET";
   24eb2:	9f06      	ldr	r7, [sp, #24]
	modeNames[AutotunePoly] = "HARMONIZE";
   24eb4:	f2c0 0a03 	movt	sl, #3
	knobParamNames[VocoderCh][13] = "STEREO";
   24eb8:	9008      	str	r0, [sp, #32]
	knobParamNames[AutotuneMono][0] = "PICKINESS";
   24eba:	f645 109c 	movw	r0, #22940	; 0x599c
	knobParamNames[VocoderCh][11] = "BANDOFF";
   24ebe:	f8c3 5090 	str.w	r5, [r3, #144]	; 0x90
	shortModeNames[AutotuneMono] = "NT";
   24ec2:	f645 15ac 	movw	r5, #22956	; 0x59ac
	knobParamNames[VocoderCh][14] = "BARKPULL";
   24ec6:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
	knobParamNames[AutotuneMono][1] = "AMOUNT";
   24eca:	f645 14a8 	movw	r4, #22952	; 0x59a8
	knobParamNames[Pitchshift][5] = "OFFSET";
   24ece:	f8c3 70dc 	str.w	r7, [r3, #220]	; 0xdc
	knobParamNames[AutotuneMono][0] = "PICKINESS";
   24ed2:	f2c0 0003 	movt	r0, #3
	modeNames[AutotuneMono] = "AUTOTUNE";
   24ed6:	9f02      	ldr	r7, [sp, #8]
	shortModeNames[AutotuneMono] = "NT";
   24ed8:	f2c0 0503 	movt	r5, #3
	knobParamNames[AutotuneMono][1] = "AMOUNT";
   24edc:	f2c0 0403 	movt	r4, #3
	knobParamNames[VocoderCh][3] = "BANDWIDTH";
   24ee0:	f8c3 b070 	str.w	fp, [r3, #112]	; 0x70
	knobParamNames[Pitchshift][0] = "SHIFT";
   24ee4:	f8c3 90c8 	str.w	r9, [r3, #200]	; 0xc8
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   24ee8:	f645 1bbc 	movw	fp, #22972	; 0x59bc
	knobParamNames[Pitchshift][2] = "F AMT";
   24eec:	f8c3 80d0 	str.w	r8, [r3, #208]	; 0xd0
	knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   24ef0:	f645 18b0 	movw	r8, #22960	; 0x59b0
	knobParamNames[Pitchshift][3] = "FORMANT";
   24ef4:	f8c3 e0d4 	str.w	lr, [r3, #212]	; 0xd4
	shortModeNames[AutotunePoly] = "AT";
   24ef8:	f645 1ed4 	movw	lr, #22996	; 0x59d4
	knobParamNames[Pitchshift][4] = "RANGE";
   24efc:	f8c3 c0d8 	str.w	ip, [r3, #216]	; 0xd8
	knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   24f00:	f2c0 0803 	movt	r8, #3
	knobParamNames[AutotuneMono][1] = "AMOUNT";
   24f04:	f8c3 4130 	str.w	r4, [r3, #304]	; 0x130
	shortModeNames[AutotunePoly] = "AT";
   24f08:	f2c0 0e03 	movt	lr, #3
	knobParamNames[AutotunePoly][2] = "";
	knobParamNames[AutotunePoly][3] = "";
	knobParamNames[AutotunePoly][4] = "";


	modeNames[SamplerButtonPress] = "SAMPLER BP";
   24f0c:	f645 1cd8 	movw	ip, #23000	; 0x59d8
	knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";



	modeNames[SamplerKeyboard] = "KEYSAMPLER";
   24f10:	f645 2420 	movw	r4, #23072	; 0x5a20
	shortModeNames[SamplerKeyboard] = "KS";
   24f14:	f645 292c 	movw	r9, #23084	; 0x5a2c
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   24f18:	f2c0 0b03 	movt	fp, #3
	modeNames[SamplerButtonPress] = "SAMPLER BP";
   24f1c:	f2c0 0c03 	movt	ip, #3
	modeNames[SamplerKeyboard] = "KEYSAMPLER";
   24f20:	f2c0 0403 	movt	r4, #3
	shortModeNames[SamplerKeyboard] = "KS";
   24f24:	f2c0 0903 	movt	r9, #3
	knobParamNames[Pitchshift][8] = "";
   24f28:	e9c3 2239 	strd	r2, r2, [r3, #228]	; 0xe4
	modeNames[Pitchshift] = "PITCHSHIFT";
   24f2c:	9a02      	ldr	r2, [sp, #8]
   24f2e:	6096      	str	r6, [r2, #8]
	modeNames[AutotuneMono] = "AUTOTUNE";
   24f30:	f645 1690 	movw	r6, #22928	; 0x5990
	shortModeNames[Pitchshift] = "PS";
   24f34:	9a00      	ldr	r2, [sp, #0]
	modeNames[AutotuneMono] = "AUTOTUNE";
   24f36:	f2c0 0603 	movt	r6, #3
	shortModeNames[Pitchshift] = "PS";
   24f3a:	6091      	str	r1, [r2, #8]
	knobParamNames[VocoderCh][9] = "SPEED";
   24f3c:	f645 1120 	movw	r1, #22816	; 0x5920
	modeNames[AutotuneMono] = "AUTOTUNE";
   24f40:	60fe      	str	r6, [r7, #12]
	shortModeNames[SamplerButtonPress] = "SB";
   24f42:	f645 17e4 	movw	r7, #23012	; 0x59e4
	knobParamNames[VocoderCh][9] = "SPEED";
   24f46:	f2c0 0103 	movt	r1, #3
	knobParamNames[VocoderCh][13] = "STEREO";
   24f4a:	9e08      	ldr	r6, [sp, #32]
	shortModeNames[AutotuneMono] = "NT";
   24f4c:	60d5      	str	r5, [r2, #12]
	shortModeNames[SamplerButtonPress] = "SB";
   24f4e:	f2c0 0703 	movt	r7, #3
	knobParamNames[VocoderCh][9] = "SPEED";
   24f52:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
	modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   24f56:	f645 15e8 	movw	r5, #23016	; 0x59e8
	knobParamNames[VocoderCh][13] = "STEREO";
   24f5a:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
	knobParamNames[AutotuneMono][0] = "PICKINESS";
   24f5e:	f8c3 012c 	str.w	r0, [r3, #300]	; 0x12c
	modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   24f62:	f2c0 0503 	movt	r5, #3
	modeNamesDetails[AutotunePoly] = "";
   24f66:	9a03      	ldr	r2, [sp, #12]
   24f68:	9e01      	ldr	r6, [sp, #4]
	knobParamNames[AutotunePoly][1] = "";
   24f6a:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
	modeNamesDetails[AutotunePoly] = "";
   24f6e:	6132      	str	r2, [r6, #16]
	modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   24f70:	f645 2630 	movw	r6, #23088	; 0x5a30
	knobParamNames[AutotunePoly][2] = "";
   24f74:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
	knobParamNames[AutotunePoly][3] = "";
   24f78:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
	modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   24f7c:	f2c0 0603 	movt	r6, #3
	knobParamNames[AutotunePoly][4] = "";
   24f80:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
	knobParamNames[SamplerKeyboard][2] = "SPEED";
	knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
	knobParamNames[SamplerKeyboard][4] = "LOOP ON";
	knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
	knobParamNames[SamplerKeyboard][6] = "VELO SENS";
	knobParamNames[SamplerKeyboard][7] = "";
   24f84:	f8c3 2274 	str.w	r2, [r3, #628]	; 0x274
	knobParamNames[SamplerKeyboard][8] = "";
   24f88:	f8c3 2278 	str.w	r2, [r3, #632]	; 0x278
	knobParamNames[SamplerKeyboard][9] = "";
   24f8c:	f8c3 227c 	str.w	r2, [r3, #636]	; 0x27c
	shortModeNames[AutotunePoly] = "AT";
   24f90:	9a00      	ldr	r2, [sp, #0]
	knobParamNames[AutotunePoly][0] = "PICKINESS";
   24f92:	f8c3 0190 	str.w	r0, [r3, #400]	; 0x190
	shortModeNames[AutotunePoly] = "AT";
   24f96:	f8c2 e010 	str.w	lr, [r2, #16]
	knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   24f9a:	f645 2e44 	movw	lr, #23108	; 0x5a44
	shortModeNames[SamplerButtonPress] = "SB";
   24f9e:	9a00      	ldr	r2, [sp, #0]
	modeNames[AutotunePoly] = "HARMONIZE";
   24fa0:	9802      	ldr	r0, [sp, #8]
	knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   24fa2:	f2c0 0e03 	movt	lr, #3
	shortModeNames[SamplerButtonPress] = "SB";
   24fa6:	6157      	str	r7, [r2, #20]
	knobParamNames[SamplerButtonPress][0] = "START";
   24fa8:	f645 17f8 	movw	r7, #23032	; 0x59f8
	modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   24fac:	9a01      	ldr	r2, [sp, #4]
	knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   24fae:	f8c3 8138 	str.w	r8, [r3, #312]	; 0x138
	knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   24fb2:	f645 283c 	movw	r8, #23100	; 0x5a3c
	modeNames[SamplerKeyboard] = "KEYSAMPLER";
   24fb6:	6184      	str	r4, [r0, #24]
	knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   24fb8:	f645 2408 	movw	r4, #23048	; 0x5a08
	modeNames[AutotunePoly] = "HARMONIZE";
   24fbc:	f8c0 a010 	str.w	sl, [r0, #16]
	knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   24fc0:	f2c0 0803 	movt	r8, #3
	modeNames[SamplerButtonPress] = "SAMPLER BP";
   24fc4:	f8c0 c014 	str.w	ip, [r0, #20]


	modeNames[SamplerAutoGrab] = "AUTOSAMP";
   24fc8:	f645 2c50 	movw	ip, #23120	; 0x5a50
	shortModeNames[SamplerKeyboard] = "KS";
   24fcc:	9800      	ldr	r0, [sp, #0]
	knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   24fce:	f2c0 0403 	movt	r4, #3
	modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   24fd2:	6155      	str	r5, [r2, #20]
	modeNames[SamplerAutoGrab] = "AUTOSAMP";
   24fd4:	f2c0 0c03 	movt	ip, #3
	modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   24fd8:	9a01      	ldr	r2, [sp, #4]
	knobParamNames[SamplerButtonPress][0] = "START";
   24fda:	f2c0 0703 	movt	r7, #3
	knobParamNames[AutotuneMono][2] = "SPEED";
   24fde:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134
	knobParamNames[SamplerButtonPress][1] = "LENGTH";
   24fe2:	f645 2500 	movw	r5, #23040	; 0x5a00
	knobParamNames[SamplerButtonPress][2] = "SPEED";
   24fe6:	f8c3 11fc 	str.w	r1, [r3, #508]	; 0x1fc
	shortModeNames[SamplerAutoGrab] = "AS";
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
	numPages[SamplerAutoGrab] = 2;
	knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   24fea:	f645 2a70 	movw	sl, #23152	; 0x5a70
	knobParamNames[SamplerKeyboard][2] = "SPEED";
   24fee:	f8c3 1260 	str.w	r1, [r3, #608]	; 0x260
	knobParamNames[SamplerButtonPress][1] = "LENGTH";
   24ff2:	f2c0 0503 	movt	r5, #3
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   24ff6:	f8c3 b13c 	str.w	fp, [r3, #316]	; 0x13c
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   24ffa:	f645 2b60 	movw	fp, #23136	; 0x5a60
	shortModeNames[SamplerKeyboard] = "KS";
   24ffe:	f8c0 9018 	str.w	r9, [r0, #24]
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   25002:	f645 2014 	movw	r0, #23060	; 0x5a14
	knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   25006:	f8c3 8268 	str.w	r8, [r3, #616]	; 0x268
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   2500a:	f2c0 0b03 	movt	fp, #3
	knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   2500e:	f8c3 e270 	str.w	lr, [r3, #624]	; 0x270
	knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   25012:	f645 297c 	movw	r9, #23164	; 0x5a7c
	modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   25016:	6196      	str	r6, [r2, #24]
	shortModeNames[SamplerAutoGrab] = "AS";
   25018:	f645 265c 	movw	r6, #23132	; 0x5a5c
	modeNames[SamplerAutoGrab] = "AUTOSAMP";
   2501c:	9a02      	ldr	r2, [sp, #8]
	knobParamNames[SamplerAutoGrab][2] = "SPEED";
	knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
	knobParamNames[SamplerAutoGrab][4] = "";
	knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   2501e:	f645 2884 	movw	r8, #23172	; 0x5a84
	knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   25022:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
	shortModeNames[SamplerAutoGrab] = "AS";
   25026:	f2c0 0603 	movt	r6, #3
	modeNames[SamplerAutoGrab] = "AUTOSAMP";
   2502a:	f8c2 c01c 	str.w	ip, [r2, #28]
	knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   2502e:	f645 2e90 	movw	lr, #23184	; 0x5a90
	knobParamNames[SamplerAutoGrab][4] = "";
   25032:	9a03      	ldr	r2, [sp, #12]
	knobParamNames[SamplerAutoGrab][7] = "";
	knobParamNames[SamplerAutoGrab][8] = "";
	knobParamNames[SamplerAutoGrab][9] = "";

	modeNames[Distortion] = "DISTORT";
   25034:	f645 2c9c 	movw	ip, #23196	; 0x5a9c
	knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
   25038:	f8c3 4264 	str.w	r4, [r3, #612]	; 0x264
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   2503c:	f2c0 0003 	movt	r0, #3
	shortModeNames[SamplerAutoGrab] = "AS";
   25040:	9c00      	ldr	r4, [sp, #0]
	knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   25042:	f2c0 0a03 	movt	sl, #3
	knobParamNames[SamplerAutoGrab][4] = "";
   25046:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
	knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   2504a:	f2c0 0903 	movt	r9, #3
	knobParamNames[SamplerAutoGrab][7] = "";
   2504e:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8
	knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   25052:	f2c0 0803 	movt	r8, #3
	knobParamNames[SamplerAutoGrab][8] = "";
   25056:	f8c3 22dc 	str.w	r2, [r3, #732]	; 0x2dc
	knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   2505a:	f2c0 0e03 	movt	lr, #3
	knobParamNames[SamplerAutoGrab][9] = "";
   2505e:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
	modeNames[Distortion] = "DISTORT";
   25062:	f2c0 0c03 	movt	ip, #3
	numPages[Wavefolder] = 1;
	knobParamNames[Wavefolder][0] = "GAIN";
	knobParamNames[Wavefolder][1] = "OFFSET1";
	knobParamNames[Wavefolder][2] = "OFFSET2";
	knobParamNames[Wavefolder][3] = "POST GAIN";
	knobParamNames[Wavefolder][4] = "";
   25066:	f8c3 2394 	str.w	r2, [r3, #916]	; 0x394
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   2506a:	9a01      	ldr	r2, [sp, #4]
	knobParamNames[SamplerButtonPress][0] = "START";
   2506c:	f8c3 71f4 	str.w	r7, [r3, #500]	; 0x1f4
	knobParamNames[SamplerKeyboard][0] = "START";
   25070:	f8c3 7258 	str.w	r7, [r3, #600]	; 0x258
	shortModeNames[Distortion] = "DT";
   25074:	f645 27a4 	movw	r7, #23204	; 0x5aa4
	shortModeNames[SamplerAutoGrab] = "AS";
   25078:	61e6      	str	r6, [r4, #28]
	modeNamesDetails[Distortion] = "WITH EQ";
   2507a:	f645 26a8 	movw	r6, #23208	; 0x5aa8

	modeNames[BitCrusher] = "BITCRUSH";
	shortModeNames[BitCrusher] = "BC";
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
	numPages[BitCrusher] = 2;
	knobParamNames[BitCrusher][0] = "QUALITY";
   2507e:	9c05      	ldr	r4, [sp, #20]
	shortModeNames[Distortion] = "DT";
   25080:	f2c0 0703 	movt	r7, #3
	knobParamNames[SamplerAutoGrab][2] = "SPEED";
   25084:	f8c3 12c4 	str.w	r1, [r3, #708]	; 0x2c4
	modeNamesDetails[Distortion] = "WITH EQ";
   25088:	f2c0 0603 	movt	r6, #3
	knobParamNames[Distortion][1] = "TILT";
   2508c:	9907      	ldr	r1, [sp, #28]
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   2508e:	f8c2 b01c 	str.w	fp, [r2, #28]
	modeNames[Distortion] = "DISTORT";
   25092:	9a02      	ldr	r2, [sp, #8]
	knobParamNames[SamplerButtonPress][1] = "LENGTH";
   25094:	f8c3 51f8 	str.w	r5, [r3, #504]	; 0x1f8
	knobParamNames[SamplerKeyboard][1] = "LENGTH";
   25098:	f8c3 525c 	str.w	r5, [r3, #604]	; 0x25c
	knobParamNames[Distortion][2] = "MID GAIN";
   2509c:	f645 25bc 	movw	r5, #23228	; 0x5abc
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   250a0:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
	knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
   250a4:	f8c3 026c 	str.w	r0, [r3, #620]	; 0x26c
	knobParamNames[Distortion][2] = "MID GAIN";
   250a8:	f2c0 0503 	movt	r5, #3
	knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
   250ac:	f8c3 02c8 	str.w	r0, [r3, #712]	; 0x2c8
	knobParamNames[Distortion][3] = "MID FREQ";
   250b0:	f645 20c8 	movw	r0, #23240	; 0x5ac8
	knobParamNames[Distortion][1] = "TILT";
   250b4:	f8c3 1324 	str.w	r1, [r3, #804]	; 0x324
	modeNames[Wavefolder] = "WAVEFOLD";
   250b8:	f645 21e0 	movw	r1, #23264	; 0x5ae0
	knobParamNames[BitCrusher][0] = "QUALITY";
   250bc:	f8c3 43e8 	str.w	r4, [r3, #1000]	; 0x3e8
	knobParamNames[Distortion][3] = "MID FREQ";
   250c0:	f2c0 0003 	movt	r0, #3
	knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   250c4:	f8c3 a2bc 	str.w	sl, [r3, #700]	; 0x2bc
	modeNames[Wavefolder] = "WAVEFOLD";
   250c8:	f2c0 0103 	movt	r1, #3
	knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   250cc:	f8c3 92c0 	str.w	r9, [r3, #704]	; 0x2c0
	modeNamesDetails[Wavefolder] = "SERGE STYLE";
   250d0:	f645 2af0 	movw	sl, #23280	; 0x5af0
	knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   250d4:	f8c3 82d0 	str.w	r8, [r3, #720]	; 0x2d0
	shortModeNames[Wavefolder] = "WF";
   250d8:	f645 24ec 	movw	r4, #23276	; 0x5aec
	knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   250dc:	f8c3 e2d4 	str.w	lr, [r3, #724]	; 0x2d4
	modeNamesDetails[Wavefolder] = "SERGE STYLE";
   250e0:	f2c0 0a03 	movt	sl, #3
	modeNames[Distortion] = "DISTORT";
   250e4:	f8c2 c020 	str.w	ip, [r2, #32]
	modeNames[BitCrusher] = "BITCRUSH";
   250e8:	f645 3c0c 	movw	ip, #23308	; 0x5b0c
	shortModeNames[Distortion] = "DT";
   250ec:	9a00      	ldr	r2, [sp, #0]
	shortModeNames[Wavefolder] = "WF";
   250ee:	f2c0 0403 	movt	r4, #3
	knobParamNames[Distortion][3] = "MID FREQ";
   250f2:	f8c3 032c 	str.w	r0, [r3, #812]	; 0x32c
	modeNames[BitCrusher] = "BITCRUSH";
   250f6:	f2c0 0c03 	movt	ip, #3
	shortModeNames[Distortion] = "DT";
   250fa:	6217      	str	r7, [r2, #32]
   250fc:	4693      	mov	fp, r2
	shortModeNames[BitCrusher] = "BC";
   250fe:	f645 3718 	movw	r7, #23320	; 0x5b18
	modeNamesDetails[Distortion] = "WITH EQ";
   25102:	9a01      	ldr	r2, [sp, #4]
	knobParamNames[Distortion][0] = "PRE GAIN";
   25104:	f645 20b0 	movw	r0, #23216	; 0x5ab0
	knobParamNames[Distortion][2] = "MID GAIN";
   25108:	f8c3 5328 	str.w	r5, [r3, #808]	; 0x328
	modeNamesDetails[Distortion] = "WITH EQ";
   2510c:	6216      	str	r6, [r2, #32]
	shortModeNames[BitCrusher] = "BC";
   2510e:	f2c0 0703 	movt	r7, #3
	modeNames[Wavefolder] = "WAVEFOLD";
   25112:	9a02      	ldr	r2, [sp, #8]
	knobParamNames[Distortion][0] = "PRE GAIN";
   25114:	f2c0 0003 	movt	r0, #3
	shortModeNames[BitCrusher] = "BC";
   25118:	9705      	str	r7, [sp, #20]
	knobParamNames[BitCrusher][1] = "SAMP RATIO";
	knobParamNames[BitCrusher][2] = "ROUNDING";
	knobParamNames[BitCrusher][3] = "OPERATION";
   2511a:	f645 3740 	movw	r7, #23360	; 0x5b40
	modeNames[Wavefolder] = "WAVEFOLD";
   2511e:	6251      	str	r1, [r2, #36]	; 0x24
	knobParamNames[Wavefolder][0] = "GAIN";
   25120:	f645 29c0 	movw	r9, #23232	; 0x5ac0
	modeNamesDetails[Wavefolder] = "SERGE STYLE";
   25124:	9a01      	ldr	r2, [sp, #4]
	knobParamNames[Wavefolder][1] = "OFFSET1";
   25126:	f645 28fc 	movw	r8, #23292	; 0x5afc
	shortModeNames[Wavefolder] = "WF";
   2512a:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
	knobParamNames[Wavefolder][2] = "OFFSET2";
   2512e:	f645 3e04 	movw	lr, #23300	; 0x5b04
	modeNamesDetails[Wavefolder] = "SERGE STYLE";
   25132:	f8c2 a024 	str.w	sl, [r2, #36]	; 0x24
	knobParamNames[BitCrusher][3] = "OPERATION";
   25136:	46ba      	mov	sl, r7
	knobParamNames[BitCrusher][6] = "";
	knobParamNames[BitCrusher][7] = "";
	knobParamNames[BitCrusher][8] = "";
	knobParamNames[BitCrusher][9] = "";

	modeNames[Delay] = "DELAY";
   25138:	f645 374c 	movw	r7, #23372	; 0x5b4c
	modeNames[BitCrusher] = "BITCRUSH";
   2513c:	9a02      	ldr	r2, [sp, #8]
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
   2513e:	f645 361c 	movw	r6, #23324	; 0x5b1c
	knobParamNames[BitCrusher][1] = "SAMP RATIO";
   25142:	f645 3528 	movw	r5, #23336	; 0x5b28
	modeNames[Delay] = "DELAY";
   25146:	f2c0 0703 	movt	r7, #3
	modeNames[BitCrusher] = "BITCRUSH";
   2514a:	f8c2 c028 	str.w	ip, [r2, #40]	; 0x28
	knobParamNames[Distortion][4] = "POST GAIN";
   2514e:	f645 21d4 	movw	r1, #23252	; 0x5ad4
	shortModeNames[BitCrusher] = "BC";
   25152:	9a00      	ldr	r2, [sp, #0]
	modeNames[Delay] = "DELAY";
   25154:	9706      	str	r7, [sp, #24]
	knobParamNames[BitCrusher][2] = "ROUNDING";
   25156:	f645 3434 	movw	r4, #23348	; 0x5b34
	shortModeNames[BitCrusher] = "BC";
   2515a:	9f05      	ldr	r7, [sp, #20]
	knobParamNames[Distortion][4] = "POST GAIN";
   2515c:	f2c0 0103 	movt	r1, #3
	knobParamNames[Distortion][0] = "PRE GAIN";
   25160:	f8c3 0320 	str.w	r0, [r3, #800]	; 0x320
	knobParamNames[Wavefolder][0] = "GAIN";
   25164:	f2c0 0903 	movt	r9, #3
	shortModeNames[BitCrusher] = "BC";
   25168:	6297      	str	r7, [r2, #40]	; 0x28
	knobParamNames[Wavefolder][1] = "OFFSET1";
   2516a:	f2c0 0803 	movt	r8, #3
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
   2516e:	9a01      	ldr	r2, [sp, #4]
	knobParamNames[Wavefolder][2] = "OFFSET2";
   25170:	f2c0 0e03 	movt	lr, #3
	knobParamNames[BitCrusher][5] = "PRE GAIN";
   25174:	f8c3 03fc 	str.w	r0, [r3, #1020]	; 0x3fc
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
   25178:	f2c0 0603 	movt	r6, #3
	knobParamNames[BitCrusher][6] = "";
   2517c:	9803      	ldr	r0, [sp, #12]
	knobParamNames[BitCrusher][1] = "SAMP RATIO";
   2517e:	f2c0 0503 	movt	r5, #3
	knobParamNames[BitCrusher][2] = "ROUNDING";
   25182:	f2c0 0403 	movt	r4, #3
	knobParamNames[BitCrusher][3] = "OPERATION";
   25186:	f2c0 0a03 	movt	sl, #3
	knobParamNames[Wavefolder][0] = "GAIN";
   2518a:	f8c3 9384 	str.w	r9, [r3, #900]	; 0x384
	shortModeNames[Delay] = "DL";
   2518e:	f645 3b54 	movw	fp, #23380	; 0x5b54
	knobParamNames[BitCrusher][3] = "OPERATION";
   25192:	f8cd a01c 	str.w	sl, [sp, #28]
	modeNamesDetails[Delay] = "STEREO";
	numPages[Delay] = 2;
	knobParamNames[Delay][0] = "DELAY_L";
   25196:	f645 3a58 	movw	sl, #23384	; 0x5b58
	knobParamNames[Wavefolder][1] = "OFFSET1";
   2519a:	f8c3 8388 	str.w	r8, [r3, #904]	; 0x388
	shortModeNames[Delay] = "DL";
   2519e:	f2c0 0b03 	movt	fp, #3
	knobParamNames[Wavefolder][2] = "OFFSET2";
   251a2:	f8c3 e38c 	str.w	lr, [r3, #908]	; 0x38c
	knobParamNames[Delay][0] = "DELAY_L";
   251a6:	f2c0 0a03 	movt	sl, #3
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
   251aa:	6296      	str	r6, [r2, #40]	; 0x28
	knobParamNames[Delay][6] = "POST GAIN";
	knobParamNames[Delay][7] = "POST GAIN";
	knobParamNames[Delay][8] = "POST GAIN";
	knobParamNames[Delay][9] = "";

	modeNames[Reverb] = "REVERB1";
   251ac:	f645 3888 	movw	r8, #23432	; 0x5b88
	knobParamNames[BitCrusher][1] = "SAMP RATIO";
   251b0:	f8c3 53ec 	str.w	r5, [r3, #1004]	; 0x3ec
	knobParamNames[Delay][1] = "DELAY_R";
   251b4:	f645 3960 	movw	r9, #23392	; 0x5b60
	knobParamNames[Distortion][4] = "POST GAIN";
   251b8:	f8c3 1330 	str.w	r1, [r3, #816]	; 0x330
	modeNames[Reverb] = "REVERB1";
   251bc:	f2c0 0803 	movt	r8, #3
	knobParamNames[Wavefolder][3] = "POST GAIN";
   251c0:	f8c3 1390 	str.w	r1, [r3, #912]	; 0x390
	shortModeNames[Reverb] = "RV";
	modeNamesDetails[Reverb] = "DATTORRO ALG";
	numPages[Reverb] = 1;
	knobParamNames[Reverb][0] = "SIZE";
	knobParamNames[Reverb][1] = "FB LOPASS";
   251c4:	f645 3eac 	movw	lr, #23468	; 0x5bac
	knobParamNames[BitCrusher][2] = "ROUNDING";
   251c8:	f8c3 43f0 	str.w	r4, [r3, #1008]	; 0x3f0
	knobParamNames[Reverb][2] = "IN HIPASS";
   251cc:	f645 3cb8 	movw	ip, #23480	; 0x5bb8
	knobParamNames[BitCrusher][4] = "POST GAIN";
   251d0:	f8c3 13f8 	str.w	r1, [r3, #1016]	; 0x3f8
	knobParamNames[Reverb][3] = "IN LOPASS";
   251d4:	f645 37c4 	movw	r7, #23492	; 0x5bc4
	knobParamNames[BitCrusher][6] = "";
   251d8:	f8c3 0400 	str.w	r0, [r3, #1024]	; 0x400
	knobParamNames[Reverb][4] = "FB GAIN";
   251dc:	f645 36d0 	movw	r6, #23504	; 0x5bd0
	knobParamNames[BitCrusher][7] = "";
   251e0:	f8c3 0404 	str.w	r0, [r3, #1028]	; 0x404
	modeNamesDetails[Reverb] = "DATTORRO ALG";
   251e4:	f645 3594 	movw	r5, #23444	; 0x5b94
	knobParamNames[BitCrusher][8] = "";
   251e8:	f8c3 0408 	str.w	r0, [r3, #1032]	; 0x408


	modeNames[Reverb2] = "REVERB2";
   251ec:	f645 34d8 	movw	r4, #23512	; 0x5bd8
	knobParamNames[BitCrusher][9] = "";
   251f0:	f8c3 040c 	str.w	r0, [r3, #1036]	; 0x40c
	knobParamNames[Delay][1] = "DELAY_R";
   251f4:	f2c0 0903 	movt	r9, #3
	modeNamesDetails[Delay] = "STEREO";
   251f8:	9808      	ldr	r0, [sp, #32]
	knobParamNames[Reverb][1] = "FB LOPASS";
   251fa:	f2c0 0e03 	movt	lr, #3
	knobParamNames[Delay][5] = "POST GAIN";
   251fe:	f8c3 1460 	str.w	r1, [r3, #1120]	; 0x460
	knobParamNames[Reverb][2] = "IN HIPASS";
   25202:	f2c0 0c03 	movt	ip, #3
	modeNamesDetails[Delay] = "STEREO";
   25206:	62d0      	str	r0, [r2, #44]	; 0x2c
	knobParamNames[Reverb][3] = "IN LOPASS";
   25208:	f2c0 0703 	movt	r7, #3
	knobParamNames[Delay][9] = "";
   2520c:	9a03      	ldr	r2, [sp, #12]
	knobParamNames[Reverb][4] = "FB GAIN";
   2520e:	f2c0 0603 	movt	r6, #3
	knobParamNames[Delay][6] = "POST GAIN";
   25212:	f8c3 1464 	str.w	r1, [r3, #1124]	; 0x464
	modeNamesDetails[Reverb] = "DATTORRO ALG";
   25216:	f2c0 0503 	movt	r5, #3
	knobParamNames[Delay][7] = "POST GAIN";
   2521a:	f8c3 1468 	str.w	r1, [r3, #1128]	; 0x468
	modeNames[Reverb2] = "REVERB2";
   2521e:	f2c0 0403 	movt	r4, #3
	knobParamNames[Delay][8] = "POST GAIN";
   25222:	f8c3 146c 	str.w	r1, [r3, #1132]	; 0x46c
	knobParamNames[Delay][2] = "HIGHPASS";
   25226:	f645 3168 	movw	r1, #23400	; 0x5b68
	knobParamNames[Delay][9] = "";
   2522a:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
	shortModeNames[Reverb2] = "RV";
	modeNamesDetails[Reverb2] = "NREVERB ALG";
   2522e:	f645 30e0 	movw	r0, #23520	; 0x5be0
	knobParamNames[Delay][2] = "HIGHPASS";
   25232:	460a      	mov	r2, r1
	knobParamNames[BitCrusher][3] = "OPERATION";
   25234:	9907      	ldr	r1, [sp, #28]
	knobParamNames[Delay][0] = "DELAY_L";
   25236:	f8c3 a44c 	str.w	sl, [r3, #1100]	; 0x44c
	knobParamNames[Delay][4] = "FEEDBACK";
   2523a:	f645 3a7c 	movw	sl, #23420	; 0x5b7c
	knobParamNames[BitCrusher][3] = "OPERATION";
   2523e:	f8c3 13f4 	str.w	r1, [r3, #1012]	; 0x3f4
	knobParamNames[Delay][2] = "HIGHPASS";
   25242:	4611      	mov	r1, r2
	modeNames[Delay] = "DELAY";
   25244:	9a02      	ldr	r2, [sp, #8]
	knobParamNames[Delay][4] = "FEEDBACK";
   25246:	f2c0 0a03 	movt	sl, #3
	knobParamNames[Delay][2] = "HIGHPASS";
   2524a:	f2c0 0103 	movt	r1, #3
	knobParamNames[Delay][1] = "DELAY_R";
   2524e:	f8c3 9450 	str.w	r9, [r3, #1104]	; 0x450
	knobParamNames[Delay][4] = "FEEDBACK";
   25252:	f8cd a020 	str.w	sl, [sp, #32]
	modeNamesDetails[Reverb2] = "NREVERB ALG";
   25256:	f2c0 0003 	movt	r0, #3
	knobParamNames[Delay][2] = "HIGHPASS";
   2525a:	9107      	str	r1, [sp, #28]
	shortModeNames[Reverb] = "RV";
   2525c:	f645 3990 	movw	r9, #23440	; 0x5b90
	modeNames[Delay] = "DELAY";
   25260:	9906      	ldr	r1, [sp, #24]
	knobParamNames[LivingString][6] = "PREP FORCE";
	knobParamNames[LivingString][7] = "LET RING";
	knobParamNames[LivingString][8] = "";
	knobParamNames[LivingString][9] = "";
	knobParamNames[LivingString][10] = "FREQ2";
	knobParamNames[LivingString][11] = "FREQ3";
   25262:	f645 4a74 	movw	sl, #23668	; 0x5c74
	knobParamNames[Reverb][1] = "FB LOPASS";
   25266:	f8c3 e4b4 	str.w	lr, [r3, #1204]	; 0x4b4
	knobParamNames[Reverb2][3] = "PEAK_FREQ";
   2526a:	f645 3eec 	movw	lr, #23532	; 0x5bec
	modeNames[Delay] = "DELAY";
   2526e:	62d1      	str	r1, [r2, #44]	; 0x2c
	knobParamNames[Delay][3] = "LOWPASS";
   25270:	f645 3174 	movw	r1, #23412	; 0x5b74
	shortModeNames[Delay] = "DL";
   25274:	9a00      	ldr	r2, [sp, #0]
	shortModeNames[Reverb] = "RV";
   25276:	f2c0 0903 	movt	r9, #3
	knobParamNames[Delay][3] = "LOWPASS";
   2527a:	f2c0 0103 	movt	r1, #3
	knobParamNames[Reverb][2] = "IN HIPASS";
   2527e:	f8c3 c4b8 	str.w	ip, [r3, #1208]	; 0x4b8
	shortModeNames[Delay] = "DL";
   25282:	f8c2 b02c 	str.w	fp, [r2, #44]	; 0x2c
	knobParamNames[Reverb2][4] = "PEAK_GAIN";
   25286:	f645 3cf8 	movw	ip, #23544	; 0x5bf8
	modeNames[Reverb] = "REVERB1";
   2528a:	9a02      	ldr	r2, [sp, #8]
	knobParamNames[LivingString][12] = "FREQ4";
   2528c:	f645 4b7c 	movw	fp, #23676	; 0x5c7c
	knobParamNames[Delay][3] = "LOWPASS";
   25290:	9105      	str	r1, [sp, #20]
	knobParamNames[Reverb2][3] = "PEAK_FREQ";
   25292:	f2c0 0e03 	movt	lr, #3
	modeNamesDetails[Reverb] = "DATTORRO ALG";
   25296:	9901      	ldr	r1, [sp, #4]
	knobParamNames[Reverb2][4] = "PEAK_GAIN";
   25298:	f2c0 0c03 	movt	ip, #3
	modeNames[Reverb] = "REVERB1";
   2529c:	f8c2 8030 	str.w	r8, [r2, #48]	; 0x30
	knobParamNames[Reverb][0] = "SIZE";
   252a0:	f645 38a4 	movw	r8, #23460	; 0x5ba4
	modeNames[Reverb2] = "REVERB2";
   252a4:	9a02      	ldr	r2, [sp, #8]
	knobParamNames[LivingString][11] = "FREQ3";
   252a6:	f2c0 0a03 	movt	sl, #3
	knobParamNames[Reverb][3] = "IN LOPASS";
   252aa:	f8c3 74bc 	str.w	r7, [r3, #1212]	; 0x4bc
	knobParamNames[LivingString][0] = "FREQ1";
   252ae:	f645 471c 	movw	r7, #23580	; 0x5c1c
	knobParamNames[Reverb][4] = "FB GAIN";
   252b2:	f8c3 64c0 	str.w	r6, [r3, #1216]	; 0x4c0
	knobParamNames[Reverb][0] = "SIZE";
   252b6:	f2c0 0803 	movt	r8, #3
	modeNamesDetails[Reverb] = "DATTORRO ALG";
   252ba:	630d      	str	r5, [r1, #48]	; 0x30
	knobParamNames[LivingString][0] = "FREQ1";
   252bc:	f2c0 0703 	movt	r7, #3
	modeNames[Reverb2] = "REVERB2";
   252c0:	6354      	str	r4, [r2, #52]	; 0x34
	knobParamNames[LivingString][13] = "FREQ5";
   252c2:	f645 4284 	movw	r2, #23684	; 0x5c84
	knobParamNames[Delay][3] = "LOWPASS";
   252c6:	9c05      	ldr	r4, [sp, #20]
	knobParamNames[LivingString][10] = "FREQ2";
   252c8:	f645 456c 	movw	r5, #23660	; 0x5c6c
	knobParamNames[LivingString][13] = "FREQ5";
   252cc:	f2c0 0203 	movt	r2, #3
	modeNamesDetails[Reverb2] = "NREVERB ALG";
   252d0:	6348      	str	r0, [r1, #52]	; 0x34
	knobParamNames[Delay][3] = "LOWPASS";
   252d2:	f8c3 4458 	str.w	r4, [r3, #1112]	; 0x458
	knobParamNames[LivingString][10] = "FREQ2";
   252d6:	f2c0 0503 	movt	r5, #3
	knobParamNames[Delay][2] = "HIGHPASS";
   252da:	9907      	ldr	r1, [sp, #28]
	knobParamNames[LivingString][4] = "PICK POS";
   252dc:	f645 463c 	movw	r6, #23612	; 0x5c3c
	knobParamNames[Reverb2][1] = "LOWPASS";
   252e0:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
	knobParamNames[LivingString][12] = "FREQ4";
   252e4:	f2c0 0b03 	movt	fp, #3
	knobParamNames[LivingString][8] = "";
   252e8:	9c03      	ldr	r4, [sp, #12]
	knobParamNames[LivingString][4] = "PICK POS";
   252ea:	f2c0 0603 	movt	r6, #3
	knobParamNames[LivingString][13] = "FREQ5";
   252ee:	9206      	str	r2, [sp, #24]
	knobParamNames[Delay][4] = "FEEDBACK";
   252f0:	9808      	ldr	r0, [sp, #32]
	knobParamNames[Delay][2] = "HIGHPASS";
   252f2:	f8c3 1454 	str.w	r1, [r3, #1108]	; 0x454
	knobParamNames[LivingString][8] = "";
   252f6:	f8c3 4598 	str.w	r4, [r3, #1432]	; 0x598
	knobParamNames[Reverb2][2] = "HIGHPASS";
   252fa:	9907      	ldr	r1, [sp, #28]
	knobParamNames[LivingString][9] = "";
   252fc:	f8c3 459c 	str.w	r4, [r3, #1436]	; 0x59c
	knobParamNames[LivingString][13] = "FREQ5";
   25300:	9c06      	ldr	r4, [sp, #24]
	knobParamNames[Delay][4] = "FEEDBACK";
   25302:	f8c3 045c 	str.w	r0, [r3, #1116]	; 0x45c
	knobParamNames[LivingString][14] = "FREQ6";
   25306:	f645 408c 	movw	r0, #23692	; 0x5c8c
	knobParamNames[Reverb][0] = "SIZE";
   2530a:	f8c3 84b0 	str.w	r8, [r3, #1200]	; 0x4b0
	knobParamNames[Reverb2][0] = "SIZE";
   2530e:	f8c3 8514 	str.w	r8, [r3, #1300]	; 0x514

	modeNames[LivingStringSynth] = "STRING2";
	shortModeNames[LivingStringSynth] = "SS";
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
	numPages[LivingStringSynth] = 2;
	knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   25312:	f645 48ac 	movw	r8, #23724	; 0x5cac
	knobParamNames[Reverb2][2] = "HIGHPASS";
   25316:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
	knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   2531a:	f645 41b8 	movw	r1, #23736	; 0x5cb8
	knobParamNames[LivingString][0] = "FREQ1";
   2531e:	f8c3 7578 	str.w	r7, [r3, #1400]	; 0x578
	shortModeNames[LivingString] = "LS";
   25322:	f645 470c 	movw	r7, #23564	; 0x5c0c
	knobParamNames[LivingString][13] = "FREQ5";
   25326:	f8c3 45ac 	str.w	r4, [r3, #1452]	; 0x5ac
	knobParamNames[LivingString][2] = "DECAY";
   2532a:	f645 442c 	movw	r4, #23596	; 0x5c2c
	shortModeNames[Reverb] = "RV";
   2532e:	9a00      	ldr	r2, [sp, #0]
	knobParamNames[LivingString][14] = "FREQ6";
   25330:	f2c0 0003 	movt	r0, #3
	knobParamNames[LivingString][10] = "FREQ2";
   25334:	f8c3 55a0 	str.w	r5, [r3, #1440]	; 0x5a0
	knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   25338:	f2c0 0803 	movt	r8, #3
	knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   2533c:	f2c0 0103 	movt	r1, #3
	shortModeNames[LivingString] = "LS";
   25340:	f2c0 0703 	movt	r7, #3
	knobParamNames[LivingString][2] = "DECAY";
   25344:	f2c0 0403 	movt	r4, #3
	modeNames[LivingStringSynth] = "STRING2";
   25348:	f645 4594 	movw	r5, #23700	; 0x5c94
	shortModeNames[Reverb] = "RV";
   2534c:	f8c2 9030 	str.w	r9, [r2, #48]	; 0x30
	shortModeNames[Reverb2] = "RV";
   25350:	f8c2 9034 	str.w	r9, [r2, #52]	; 0x34
	modeNames[LivingStringSynth] = "STRING2";
   25354:	f2c0 0503 	movt	r5, #3
	knobParamNames[Reverb2][3] = "PEAK_FREQ";
   25358:	f8c3 e520 	str.w	lr, [r3, #1312]	; 0x520
	shortModeNames[LivingStringSynth] = "SS";
   2535c:	f645 5e94 	movw	lr, #23956	; 0x5d94
	knobParamNames[Reverb2][4] = "PEAK_GAIN";
   25360:	f8c3 c524 	str.w	ip, [r3, #1316]	; 0x524
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   25364:	f645 499c 	movw	r9, #23708	; 0x5c9c
	knobParamNames[LivingString][4] = "PICK POS";
   25368:	f8c3 6588 	str.w	r6, [r3, #1416]	; 0x588
	shortModeNames[LivingStringSynth] = "SS";
   2536c:	f2c0 0e03 	movt	lr, #3
	knobParamNames[LivingString][11] = "FREQ3";
   25370:	f8c3 a5a4 	str.w	sl, [r3, #1444]	; 0x5a4
	modeNamesDetails[LivingString] = "SYMP STRING";
   25374:	f645 4610 	movw	r6, #23568	; 0x5c10
	knobParamNames[LivingString][12] = "FREQ4";
   25378:	f8c3 b5a8 	str.w	fp, [r3, #1448]	; 0x5a8
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   2537c:	f2c0 0903 	movt	r9, #3
	knobParamNames[LivingString][14] = "FREQ6";
   25380:	f8c3 05b0 	str.w	r0, [r3, #1456]	; 0x5b0
	modeNamesDetails[LivingString] = "SYMP STRING";
   25384:	f2c0 0603 	movt	r6, #3
	knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   25388:	f8c3 85dc 	str.w	r8, [r3, #1500]	; 0x5dc
	modeNames[LivingString] = "STRING1";
   2538c:	f645 4c04 	movw	ip, #23556	; 0x5c04
	knobParamNames[LivingString][2] = "DECAY";
   25390:	9406      	str	r4, [sp, #24]
	knobParamNames[LivingString][5] = "PREP POS";
   25392:	f645 4448 	movw	r4, #23624	; 0x5c48
	knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   25396:	f8c3 15e0 	str.w	r1, [r3, #1504]	; 0x5e0
	numPages[Vocoder] = 2;
   2539a:	f64e 3b90 	movw	fp, #60304	; 0xeb90
	modeNames[LivingString] = "STRING1";
   2539e:	9902      	ldr	r1, [sp, #8]
	knobParamNames[LivingString][5] = "PREP POS";
   253a0:	f2c0 0403 	movt	r4, #3
	shortModeNames[LivingString] = "LS";
   253a4:	6397      	str	r7, [r2, #56]	; 0x38
	numPages[Vocoder] = 2;
   253a6:	f2c0 2b0f 	movt	fp, #527	; 0x20f
	modeNames[LivingStringSynth] = "STRING2";
   253aa:	9a02      	ldr	r2, [sp, #8]
	modeNames[LivingString] = "STRING1";
   253ac:	f2c0 0c03 	movt	ip, #3
	modeNamesDetails[LivingString] = "SYMP STRING";
   253b0:	9f01      	ldr	r7, [sp, #4]
	knobParamNames[LivingString][6] = "PREP FORCE";
   253b2:	f645 4054 	movw	r0, #23636	; 0x5c54
	modeNames[LivingStringSynth] = "STRING2";
   253b6:	63d5      	str	r5, [r2, #60]	; 0x3c
	knobParamNames[LivingString][1] = "DETUNE";
   253b8:	f645 4a24 	movw	sl, #23588	; 0x5c24
	shortModeNames[LivingStringSynth] = "SS";
   253bc:	9d00      	ldr	r5, [sp, #0]
	knobParamNames[LivingString][6] = "PREP FORCE";
   253be:	f2c0 0003 	movt	r0, #3
	modeNamesDetails[LivingString] = "SYMP STRING";
   253c2:	63be      	str	r6, [r7, #56]	; 0x38
	numPages[Vocoder] = 2;
   253c4:	f240 1701 	movw	r7, #257	; 0x101
	shortModeNames[LivingStringSynth] = "SS";
   253c8:	f8c5 e03c 	str.w	lr, [r5, #60]	; 0x3c
	knobParamNames[LivingStringSynth][2] = "DECAY";
	knobParamNames[LivingStringSynth][3] = "DAMPING";
	knobParamNames[LivingStringSynth][4] = "PICK_POS";
   253cc:	f645 45c4 	movw	r5, #23748	; 0x5cc4
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   253d0:	9e01      	ldr	r6, [sp, #4]
	knobParamNames[LivingString][3] = "DAMPING";
   253d2:	f645 4834 	movw	r8, #23604	; 0x5c34
	knobParamNames[LivingString][5] = "PREP POS";
   253d6:	f8c3 458c 	str.w	r4, [r3, #1420]	; 0x58c
	knobParamNames[LivingStringSynth][4] = "PICK_POS";
   253da:	f2c0 0503 	movt	r5, #3
	knobParamNames[LivingStringSynth][5] = "PREP POS";
   253de:	f8c3 45f0 	str.w	r4, [r3, #1520]	; 0x5f0
	knobParamNames[ClassicSynth][8] = "RELEASE";
	knobParamNames[ClassicSynth][9] = "LEAK";
	knobParamNames[ClassicSynth][10] = "F_ATTACK";
	knobParamNames[ClassicSynth][11] = "F_DECAY";
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   253e2:	f645 544c 	movw	r4, #23884	; 0x5d4c
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   253e6:	f8c6 903c 	str.w	r9, [r6, #60]	; 0x3c
	numPages[Vocoder] = 2;
   253ea:	463e      	mov	r6, r7
	knobParamNames[LivingStringSynth][4] = "PICK_POS";
   253ec:	f8c3 55ec 	str.w	r5, [r3, #1516]	; 0x5ec
	numPages[Vocoder] = 2;
   253f0:	f2c0 2703 	movt	r7, #515	; 0x203
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   253f4:	f2c0 0403 	movt	r4, #3
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   253f8:	f645 5558 	movw	r5, #23896	; 0x5d58
	modeNames[LivingString] = "STRING1";
   253fc:	f8c1 c038 	str.w	ip, [r1, #56]	; 0x38
	numPages[Vocoder] = 2;
   25400:	f2c0 2602 	movt	r6, #514	; 0x202
   25404:	f8cb 700c 	str.w	r7, [fp, #12]
	knobParamNames[LivingString][7] = "LET RING";
   25408:	f645 4160 	movw	r1, #23648	; 0x5c60
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   2540c:	9407      	str	r4, [sp, #28]
	numPages[Vocoder] = 2;
   2540e:	f240 3c02 	movw	ip, #770	; 0x302
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   25412:	462c      	mov	r4, r5
	knobParamNames[ClassicSynth][10] = "F_ATTACK";
   25414:	f645 572c 	movw	r7, #23852	; 0x5d2c
	knobParamNames[LivingString][2] = "DECAY";
   25418:	9a06      	ldr	r2, [sp, #24]
	knobParamNames[LivingString][1] = "DETUNE";
   2541a:	f2c0 0a03 	movt	sl, #3
	knobParamNames[LivingString][3] = "DAMPING";
   2541e:	f2c0 0803 	movt	r8, #3
	knobParamNames[LivingString][7] = "LET RING";
   25422:	f2c0 0103 	movt	r1, #3
	knobParamNames[LivingString][6] = "PREP FORCE";
   25426:	f8c3 0590 	str.w	r0, [r3, #1424]	; 0x590
	numPages[Vocoder] = 2;
   2542a:	f2c0 1c02 	movt	ip, #258	; 0x102
   2542e:	f8cb 6004 	str.w	r6, [fp, #4]
	numPages[ClassicSynth] = 4;
   25432:	f04f 0904 	mov.w	r9, #4
	numPages[Vocoder] = 2;
   25436:	f8cb 6008 	str.w	r6, [fp, #8]
	knobParamNames[ClassicSynth][10] = "F_ATTACK";
   2543a:	f2c0 0703 	movt	r7, #3
	knobParamNames[LivingStringSynth][6] = "PREP FORCE";
   2543e:	f8c3 05f4 	str.w	r0, [r3, #1524]	; 0x5f4
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   25442:	f2c0 0403 	movt	r4, #3
	knobParamNames[ClassicSynth][0] = "VOLUME";
   25446:	9804      	ldr	r0, [sp, #16]
	knobParamNames[ClassicSynth][11] = "F_DECAY";
   25448:	f645 5638 	movw	r6, #23864	; 0x5d38
	knobParamNames[LivingString][1] = "DETUNE";
   2544c:	f8c3 a57c 	str.w	sl, [r3, #1404]	; 0x57c
	knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   25450:	f645 4efc 	movw	lr, #23804	; 0x5cfc
	knobParamNames[LivingString][2] = "DECAY";
   25454:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
	knobParamNames[ClassicSynth][11] = "F_DECAY";
   25458:	f2c0 0603 	movt	r6, #3
	knobParamNames[LivingStringSynth][2] = "DECAY";
   2545c:	f8c3 25e4 	str.w	r2, [r3, #1508]	; 0x5e4
	knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   25460:	f645 5560 	movw	r5, #23904	; 0x5d60
	knobParamNames[LivingString][3] = "DAMPING";
   25464:	f8c3 8584 	str.w	r8, [r3, #1412]	; 0x584
	knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   25468:	f2c0 0e03 	movt	lr, #3
	knobParamNames[LivingStringSynth][3] = "DAMPING";
   2546c:	f8c3 85e8 	str.w	r8, [r3, #1512]	; 0x5e8
	knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   25470:	f2c0 0503 	movt	r5, #3
	knobParamNames[LivingString][7] = "LET RING";
   25474:	f8c3 1594 	str.w	r1, [r3, #1428]	; 0x594
	knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   25478:	f645 48d0 	movw	r8, #23760	; 0x5cd0
	numPages[Vocoder] = 2;
   2547c:	f8cb c000 	str.w	ip, [fp]
	knobParamNames[ClassicSynth][4] = "FILTER Q";
   25480:	f645 5c08 	movw	ip, #23816	; 0x5d08
	numPages[ClassicSynth] = 4;
   25484:	f88b 9010 	strb.w	r9, [fp, #16]
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   25488:	f645 5940 	movw	r9, #23872	; 0x5d40
	knobParamNames[LivingStringSynth][7] = "LET RING";
   2548c:	f8c3 15f8 	str.w	r1, [r3, #1528]	; 0x5f8
	knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   25490:	f2c0 0803 	movt	r8, #3
	knobParamNames[ClassicSynth][0] = "VOLUME";
   25494:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
	modeNames[ClassicSynth] = "POLYSYNTH";
   25498:	f645 40e4 	movw	r0, #23780	; 0x5ce4
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   2549c:	9404      	str	r4, [sp, #16]
	knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   2549e:	f645 546c 	movw	r4, #23916	; 0x5d6c
	knobParamNames[ClassicSynth][10] = "F_ATTACK";
   254a2:	f8c3 7668 	str.w	r7, [r3, #1640]	; 0x668
	knobParamNames[ClassicSynth][18] = "";
	knobParamNames[ClassicSynth][19] = "";

	modeNames[Rhodes] = "RHODES";
	shortModeNames[Rhodes] = "RD";
	modeNamesDetails[Rhodes] = "DARK";
   254a6:	f645 5784 	movw	r7, #23940	; 0x5d84
	knobParamNames[ClassicSynth][11] = "F_DECAY";
   254aa:	f8c3 666c 	str.w	r6, [r3, #1644]	; 0x66c
	knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   254ae:	f2c0 0403 	movt	r4, #3
	modeNamesDetails[Rhodes] = "DARK";
   254b2:	463e      	mov	r6, r7
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   254b4:	9f07      	ldr	r7, [sp, #28]
	knobParamNames[ClassicSynth][1] = "LOWPASS";
   254b6:	9905      	ldr	r1, [sp, #20]
	modeNames[ClassicSynth] = "POLYSYNTH";
   254b8:	f2c0 0003 	movt	r0, #3
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   254bc:	f8c3 7674 	str.w	r7, [r3, #1652]	; 0x674
	knobParamNames[ClassicSynth][4] = "FILTER Q";
   254c0:	f2c0 0c03 	movt	ip, #3
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   254c4:	9f04      	ldr	r7, [sp, #16]
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   254c6:	f2c0 0903 	movt	r9, #3
	knobParamNames[ClassicSynth][1] = "LOWPASS";
   254ca:	f8c3 1644 	str.w	r1, [r3, #1604]	; 0x644
	shortModeNames[ClassicSynth] = "CS";
   254ce:	f645 41f0 	movw	r1, #23792	; 0x5cf0
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   254d2:	f8c3 7678 	str.w	r7, [r3, #1656]	; 0x678
	numPages[Rhodes] = 5;
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   254d6:	f645 578c 	movw	r7, #23948	; 0x5d8c
	knobParamNames[ClassicSynth][6] = "DECAY";
   254da:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
	shortModeNames[ClassicSynth] = "CS";
   254de:	f2c0 0103 	movt	r1, #3
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   254e2:	f2c0 0703 	movt	r7, #3
	knobParamNames[ClassicSynth][17] = "";
   254e6:	9a03      	ldr	r2, [sp, #12]
	knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   254e8:	f8c3 e648 	str.w	lr, [r3, #1608]	; 0x648
	modeNames[Rhodes] = "RHODES";
   254ec:	f645 5e78 	movw	lr, #23928	; 0x5d78
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   254f0:	9704      	str	r7, [sp, #16]
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   254f2:	f645 5798 	movw	r7, #23960	; 0x5d98
	knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   254f6:	f8c3 567c 	str.w	r5, [r3, #1660]	; 0x67c
	modeNames[Rhodes] = "RHODES";
   254fa:	f2c0 0e03 	movt	lr, #3
	knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   254fe:	f8c3 4680 	str.w	r4, [r3, #1664]	; 0x680
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   25502:	463d      	mov	r5, r7
	modeNames[ClassicSynth] = "POLYSYNTH";
   25504:	9c02      	ldr	r4, [sp, #8]
	modeNamesDetails[Rhodes] = "DARK";
   25506:	f2c0 0603 	movt	r6, #3
	knobParamNames[ClassicSynth][17] = "";
   2550a:	f8c3 2684 	str.w	r2, [r3, #1668]	; 0x684
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   2550e:	f2c0 0503 	movt	r5, #3
	knobParamNames[ClassicSynth][18] = "";
   25512:	f8c3 2688 	str.w	r2, [r3, #1672]	; 0x688
	knobParamNames[ClassicSynth][19] = "";
   25516:	f8c3 268c 	str.w	r2, [r3, #1676]	; 0x68c
	modeNamesDetails[ClassicSynth] = "VCO+VCF";
   2551a:	f645 42f4 	movw	r2, #23796	; 0x5cf4
	modeNames[ClassicSynth] = "POLYSYNTH";
   2551e:	6420      	str	r0, [r4, #64]	; 0x40
	shortModeNames[ClassicSynth] = "CS";
   25520:	9800      	ldr	r0, [sp, #0]
	modeNamesDetails[ClassicSynth] = "VCO+VCF";
   25522:	f2c0 0203 	movt	r2, #3
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   25526:	9503      	str	r5, [sp, #12]
	knobParamNames[Rhodes][2] = "TREM RATE";
   25528:	f645 55a4 	movw	r5, #23972	; 0x5da4
	shortModeNames[ClassicSynth] = "CS";
   2552c:	6401      	str	r1, [r0, #64]	; 0x40
	modeNames[Rhodes] = "RHODES";
   2552e:	f8c4 e044 	str.w	lr, [r4, #68]	; 0x44
	knobParamNames[Rhodes][3] = "DRIVE";
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   25532:	f645 54b8 	movw	r4, #23992	; 0x5db8
	modeNamesDetails[ClassicSynth] = "VCO+VCF";
   25536:	9901      	ldr	r1, [sp, #4]
	knobParamNames[Rhodes][2] = "TREM RATE";
   25538:	462f      	mov	r7, r5
	knobParamNames[Rhodes][3] = "DRIVE";
   2553a:	f645 55b0 	movw	r5, #23984	; 0x5db0
	knobParamNames[ClassicSynth][3] = "DETUNE";
   2553e:	f8c3 a64c 	str.w	sl, [r3, #1612]	; 0x64c
	modeNamesDetails[ClassicSynth] = "VCO+VCF";
   25542:	640a      	str	r2, [r1, #64]	; 0x40
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   25544:	4622      	mov	r2, r4
	knobParamNames[Rhodes][2] = "TREM RATE";
   25546:	463c      	mov	r4, r7
	knobParamNames[Rhodes][3] = "DRIVE";
   25548:	f2c0 0503 	movt	r5, #3
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   2554c:	4696      	mov	lr, r2
	knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   2554e:	f8c3 85fc 	str.w	r8, [r3, #1532]	; 0x5fc
	knobParamNames[Rhodes][2] = "TREM RATE";
   25552:	f2c0 0403 	movt	r4, #3
	knobParamNames[ClassicSynth][4] = "FILTER Q";
   25556:	f8c3 c650 	str.w	ip, [r3, #1616]	; 0x650
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   2555a:	f2c0 0e03 	movt	lr, #3
	modeNamesDetails[Rhodes] = "DARK";
   2555e:	9605      	str	r6, [sp, #20]
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   25560:	f8c3 9670 	str.w	r9, [r3, #1648]	; 0x670
	shortModeNames[Rhodes] = "RD";
   25564:	f645 5c80 	movw	ip, #23936	; 0x5d80
	knobParamNames[Rhodes][2] = "TREM RATE";
   25568:	9401      	str	r4, [sp, #4]
	knobParamNames[Rhodes][5] = "ATTACK";
	knobParamNames[Rhodes][6] = "DECAY";
	knobParamNames[Rhodes][7] = "SUSTAIN";
	knobParamNames[Rhodes][8] = "RELEASE";
	knobParamNames[Rhodes][9] = "LEAK";
	knobParamNames[Rhodes][10] = "INDEX1";
   2556a:	f645 54c4 	movw	r4, #24004	; 0x5dc4
	knobParamNames[Rhodes][3] = "DRIVE";
   2556e:	9502      	str	r5, [sp, #8]
	knobParamNames[LivingStringSynth][9] = "RELEASE";
   25570:	f645 46dc 	movw	r6, #23772	; 0x5cdc
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   25574:	f8cd e01c 	str.w	lr, [sp, #28]
	knobParamNames[Rhodes][10] = "INDEX1";
   25578:	f2c0 0403 	movt	r4, #3
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   2557c:	9f04      	ldr	r7, [sp, #16]
	knobParamNames[ClassicSynth][5] = "ATTACK";
   2557e:	f645 5914 	movw	r9, #23828	; 0x5d14
	modeNamesDetails[Rhodes] = "DARK";
   25582:	9a05      	ldr	r2, [sp, #20]
	knobParamNames[ClassicSynth][7] = "SUSTAIN";
   25584:	f645 5a1c 	movw	sl, #23836	; 0x5d1c
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   25588:	f8c3 76a4 	str.w	r7, [r3, #1700]	; 0x6a4
	knobParamNames[ClassicSynth][9] = "LEAK";
   2558c:	f645 5824 	movw	r8, #23844	; 0x5d24
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   25590:	9f03      	ldr	r7, [sp, #12]
	knobParamNames[Rhodes][11] = "INDEX2";
   25592:	f645 5ecc 	movw	lr, #24012	; 0x5dcc
	modeNamesDetails[Rhodes] = "DARK";
   25596:	644a      	str	r2, [r1, #68]	; 0x44
	knobParamNames[Rhodes][12] = "INDEX3";
	knobParamNames[Rhodes][13] = "INDEX4";
	knobParamNames[Rhodes][14] = "INDEX5";
   25598:	f645 52e4 	movw	r2, #24036	; 0x5de4
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   2559c:	f8c3 76a8 	str.w	r7, [r3, #1704]	; 0x6a8
	knobParamNames[Rhodes][13] = "INDEX4";
   255a0:	f645 51dc 	movw	r1, #24028	; 0x5ddc
	knobParamNames[Rhodes][2] = "TREM RATE";
   255a4:	9f01      	ldr	r7, [sp, #4]
	knobParamNames[Rhodes][14] = "INDEX5";
   255a6:	f2c0 0203 	movt	r2, #3
	knobParamNames[Rhodes][13] = "INDEX4";
   255aa:	f2c0 0103 	movt	r1, #3
	knobParamNames[Rhodes][10] = "INDEX1";
   255ae:	9400      	str	r4, [sp, #0]
	knobParamNames[Rhodes][2] = "TREM RATE";
   255b0:	f8c3 76ac 	str.w	r7, [r3, #1708]	; 0x6ac
	knobParamNames[LivingStringSynth][9] = "RELEASE";
   255b4:	f2c0 0603 	movt	r6, #3
	knobParamNames[Rhodes][3] = "DRIVE";
   255b8:	9f02      	ldr	r7, [sp, #8]
	knobParamNames[ClassicSynth][5] = "ATTACK";
   255ba:	f2c0 0903 	movt	r9, #3
	knobParamNames[Rhodes][14] = "INDEX5";
   255be:	9209      	str	r2, [sp, #36]	; 0x24
	knobParamNames[ClassicSynth][7] = "SUSTAIN";
   255c0:	f2c0 0a03 	movt	sl, #3
	knobParamNames[Rhodes][6] = "DECAY";
   255c4:	9a06      	ldr	r2, [sp, #24]
	knobParamNames[ClassicSynth][9] = "LEAK";
   255c6:	f2c0 0803 	movt	r8, #3
	knobParamNames[Rhodes][3] = "DRIVE";
   255ca:	f8c3 76b0 	str.w	r7, [r3, #1712]	; 0x6b0
	shortModeNames[Rhodes] = "RD";
   255ce:	f2c0 0c03 	movt	ip, #3
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   255d2:	9f07      	ldr	r7, [sp, #28]
	knobParamNames[Rhodes][11] = "INDEX2";
   255d4:	f2c0 0e03 	movt	lr, #3
	knobParamNames[Rhodes][13] = "INDEX4";
   255d8:	9105      	str	r1, [sp, #20]
	numPages[Rhodes] = 5;
   255da:	f04f 0105 	mov.w	r1, #5
	knobParamNames[Rhodes][6] = "DECAY";
   255de:	f8c3 26bc 	str.w	r2, [r3, #1724]	; 0x6bc
	knobParamNames[Rhodes][15] = "RATIO1";
   255e2:	f645 55ec 	movw	r5, #24044	; 0x5dec
	knobParamNames[Rhodes][16] = "RATIO2";
	knobParamNames[Rhodes][17] = "RATIO3";
	knobParamNames[Rhodes][18] = "RATIO4";
	knobParamNames[Rhodes][19] = "RATIO5";
	knobParamNames[Rhodes][20] = "RATIO6";
	knobParamNames[Rhodes][21] = "FEEDBACK";
   255e6:	9a08      	ldr	r2, [sp, #32]
	knobParamNames[Rhodes][16] = "RATIO2";
   255e8:	f645 54f4 	movw	r4, #24052	; 0x5df4
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   255ec:	f8c3 76b4 	str.w	r7, [r3, #1716]	; 0x6b4
	knobParamNames[Rhodes][15] = "RATIO1";
   255f0:	f2c0 0503 	movt	r5, #3
	knobParamNames[Rhodes][10] = "INDEX1";
   255f4:	9f00      	ldr	r7, [sp, #0]
	knobParamNames[Rhodes][16] = "RATIO2";
   255f6:	f2c0 0403 	movt	r4, #3
	shortModeNames[Rhodes] = "RD";
   255fa:	f8c0 c044 	str.w	ip, [r0, #68]	; 0x44
	knobParamNames[Rhodes][12] = "INDEX3";
   255fe:	f645 5cd4 	movw	ip, #24020	; 0x5dd4
	knobParamNames[LivingStringSynth][9] = "RELEASE";
   25602:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
	knobParamNames[Rhodes][17] = "RATIO3";
   25606:	f645 50fc 	movw	r0, #24060	; 0x5dfc
	knobParamNames[ClassicSynth][8] = "RELEASE";
   2560a:	f8c3 6660 	str.w	r6, [r3, #1632]	; 0x660
	knobParamNames[Rhodes][12] = "INDEX3";
   2560e:	f2c0 0c03 	movt	ip, #3
	knobParamNames[ClassicSynth][5] = "ATTACK";
   25612:	f8c3 9654 	str.w	r9, [r3, #1620]	; 0x654
	knobParamNames[Rhodes][17] = "RATIO3";
   25616:	f2c0 0003 	movt	r0, #3
	knobParamNames[ClassicSynth][7] = "SUSTAIN";
   2561a:	f8c3 a65c 	str.w	sl, [r3, #1628]	; 0x65c
	knobParamNames[ClassicSynth][9] = "LEAK";
   2561e:	f8c3 8664 	str.w	r8, [r3, #1636]	; 0x664
	numPages[Rhodes] = 5;
   25622:	f88b 1011 	strb.w	r1, [fp, #17]
	knobParamNames[Rhodes][18] = "RATIO4";
   25626:	f645 6104 	movw	r1, #24068	; 0x5e04
	knobParamNames[Rhodes][5] = "ATTACK";
   2562a:	f8c3 96b8 	str.w	r9, [r3, #1720]	; 0x6b8
	knobParamNames[Rhodes][19] = "RATIO5";
   2562e:	f645 690c 	movw	r9, #24076	; 0x5e0c
	knobParamNames[Rhodes][7] = "SUSTAIN";
   25632:	f8c3 a6c0 	str.w	sl, [r3, #1728]	; 0x6c0
	knobParamNames[Rhodes][20] = "RATIO6";
   25636:	f645 6a14 	movw	sl, #24084	; 0x5e14
	knobParamNames[Rhodes][8] = "RELEASE";
   2563a:	f8c3 66c4 	str.w	r6, [r3, #1732]	; 0x6c4
	knobParamNames[Rhodes][22] = "TUNE SNAP";
   2563e:	f645 661c 	movw	r6, #24092	; 0x5e1c
	knobParamNames[Rhodes][9] = "LEAK";
   25642:	f8c3 86c8 	str.w	r8, [r3, #1736]	; 0x6c8
	knobParamNames[Rhodes][23] = "RAND DECAY";
   25646:	f645 6828 	movw	r8, #24104	; 0x5e28
	knobParamNames[Rhodes][21] = "FEEDBACK";
   2564a:	f8c3 26f8 	str.w	r2, [r3, #1784]	; 0x6f8
	knobParamNames[Rhodes][24] = "RAND SUST";
   2564e:	f645 6234 	movw	r2, #24116	; 0x5e34
	knobParamNames[Rhodes][10] = "INDEX1";
   25652:	f8c3 76cc 	str.w	r7, [r3, #1740]	; 0x6cc
	knobParamNames[Rhodes][18] = "RATIO4";
   25656:	f2c0 0103 	movt	r1, #3
	knobParamNames[Rhodes][11] = "INDEX2";
   2565a:	f8c3 e6d0 	str.w	lr, [r3, #1744]	; 0x6d0
	knobParamNames[Rhodes][19] = "RATIO5";
   2565e:	f2c0 0903 	movt	r9, #3
	knobParamNames[Rhodes][13] = "INDEX4";
   25662:	9f05      	ldr	r7, [sp, #20]
	knobParamNames[Rhodes][20] = "RATIO6";
   25664:	f2c0 0a03 	movt	sl, #3
	knobParamNames[Rhodes][22] = "TUNE SNAP";
   25668:	f2c0 0603 	movt	r6, #3
	knobParamNames[Rhodes][23] = "RAND DECAY";
   2566c:	f2c0 0803 	movt	r8, #3
	knobParamNames[Rhodes][24] = "RAND SUST";
   25670:	f2c0 0203 	movt	r2, #3
	knobParamNames[Rhodes][13] = "INDEX4";
   25674:	f8c3 76d8 	str.w	r7, [r3, #1752]	; 0x6d8
	knobParamNames[Rhodes][14] = "INDEX5";
   25678:	9f09      	ldr	r7, [sp, #36]	; 0x24
	knobParamNames[Rhodes][12] = "INDEX3";
   2567a:	f8c3 c6d4 	str.w	ip, [r3, #1748]	; 0x6d4
	knobParamNames[Rhodes][14] = "INDEX5";
   2567e:	f8c3 76dc 	str.w	r7, [r3, #1756]	; 0x6dc
	knobParamNames[Rhodes][15] = "RATIO1";
   25682:	f8c3 56e0 	str.w	r5, [r3, #1760]	; 0x6e0
	knobParamNames[Rhodes][16] = "RATIO2";
   25686:	f8c3 46e4 	str.w	r4, [r3, #1764]	; 0x6e4
	knobParamNames[Rhodes][17] = "RATIO3";
   2568a:	f8c3 06e8 	str.w	r0, [r3, #1768]	; 0x6e8
	knobParamNames[Rhodes][18] = "RATIO4";
   2568e:	f8c3 16ec 	str.w	r1, [r3, #1772]	; 0x6ec
	knobParamNames[Rhodes][19] = "RATIO5";
   25692:	f8c3 96f0 	str.w	r9, [r3, #1776]	; 0x6f0
	knobParamNames[Rhodes][20] = "RATIO6";
   25696:	f8c3 a6f4 	str.w	sl, [r3, #1780]	; 0x6f4
	knobParamNames[Rhodes][22] = "TUNE SNAP";
   2569a:	f8c3 66fc 	str.w	r6, [r3, #1788]	; 0x6fc
	knobParamNames[Rhodes][23] = "RAND DECAY";
   2569e:	f8c3 8700 	str.w	r8, [r3, #1792]	; 0x700
	knobParamNames[Rhodes][24] = "RAND SUST";
   256a2:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
}
   256a6:	b00b      	add	sp, #44	; 0x2c
   256a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000256ac <buttonCheck>:

void buttonCheck(void)
{
	if (codecReady)
   256ac:	f646 0360 	movw	r3, #26720	; 0x6860
   256b0:	f2c0 230e 	movt	r3, #526	; 0x20e
   256b4:	781b      	ldrb	r3, [r3, #0]
   256b6:	2b00      	cmp	r3, #0
   256b8:	f000 8112 	beq.w	258e0 <buttonCheck+0x234>
		buttonValues[8] = !HAL_GPIO_ReadPin(GPIOG, GPIO_PIN_11); // D
		buttonValues[9] = !HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_10); // E
		 */

		//A little more efficient since it avoids a function call
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   256bc:	f44f 6180 	mov.w	r1, #1024	; 0x400
		buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
		buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
		buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   256c0:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   256c4:	f24f 32d4 	movw	r2, #62420	; 0xf3d4
   256c8:	f246 20d2 	movw	r0, #25298	; 0x62d2
   256cc:	f6c5 0102 	movt	r1, #22530	; 0x5802
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   256d0:	f6c5 0302 	movt	r3, #22530	; 0x5802
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   256d4:	f2c0 220f 	movt	r2, #527	; 0x20f
   256d8:	f2c0 0006 	movt	r0, #6
{
   256dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   256e0:	b08b      	sub	sp, #44	; 0x2c
   256e2:	f246 26d1 	movw	r6, #25297	; 0x62d1
   256e6:	4605      	mov	r5, r0
				writeButtonFlag = i;
				writeActionFlag = ActionHoldContinuous;
			}
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
			{
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   256e8:	f246 28c0 	movw	r8, #25280	; 0x62c0
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   256ec:	9303      	str	r3, [sp, #12]
   256ee:	f2c0 0606 	movt	r6, #6
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   256f2:	690b      	ldr	r3, [r1, #16]
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   256f4:	f2c0 0806 	movt	r8, #6
   256f8:	9608      	str	r6, [sp, #32]
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   256fa:	f246 27c4 	movw	r7, #25284	; 0x62c4
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   256fe:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
   25702:	9009      	str	r0, [sp, #36]	; 0x24
   25704:	f995 5000 	ldrsb.w	r5, [r5]
		buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   25708:	f44f 6440 	mov.w	r4, #3072	; 0xc00
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   2570c:	f3c3 3340 	ubfx	r3, r3, #13, #1
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   25710:	f2c0 0706 	movt	r7, #6
		buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   25714:	f6c5 0402 	movt	r4, #22530	; 0x5802
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   25718:	f246 29c8 	movw	r9, #25288	; 0x62c8
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   2571c:	7013      	strb	r3, [r2, #0]
   2571e:	f64e 36bc 	movw	r6, #60348	; 0xebbc
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   25722:	6908      	ldr	r0, [r1, #16]
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   25724:	f2c0 0906 	movt	r9, #6
   25728:	9501      	str	r5, [sp, #4]
		for (int i = 0; i < NUM_BUTTONS; i++)
   2572a:	2300      	movs	r3, #0
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   2572c:	f480 5080 	eor.w	r0, r0, #4096	; 0x1000
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   25730:	f8d8 5000 	ldr.w	r5, [r8]
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   25734:	683f      	ldr	r7, [r7, #0]
   25736:	f64e 3e20 	movw	lr, #60192	; 0xeb20
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   2573a:	f3c0 3000 	ubfx	r0, r0, #12, #1
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   2573e:	f8d9 9000 	ldr.w	r9, [r9]
   25742:	f64e 4a30 	movw	sl, #60464	; 0xec30
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   25746:	f64e 2b7c 	movw	fp, #60028	; 0xea7c
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   2574a:	7050      	strb	r0, [r2, #1]
   2574c:	f2c0 260f 	movt	r6, #527	; 0x20f
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   25750:	6908      	ldr	r0, [r1, #16]
   25752:	4694      	mov	ip, r2
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   25754:	9506      	str	r5, [sp, #24]
   25756:	f2c0 2e0f 	movt	lr, #527	; 0x20f
   2575a:	9d08      	ldr	r5, [sp, #32]
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   2575c:	f480 4080 	eor.w	r0, r0, #16384	; 0x4000
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   25760:	9707      	str	r7, [sp, #28]
   25762:	f64e 2757 	movw	r7, #59991	; 0xea57
   25766:	f995 5000 	ldrsb.w	r5, [r5]
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   2576a:	f3c0 3080 	ubfx	r0, r0, #14, #1
   2576e:	f2c0 2a0f 	movt	sl, #527	; 0x20f
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   25772:	f2c0 2b0f 	movt	fp, #527	; 0x20f
   25776:	9502      	str	r5, [sp, #8]
				}
			}
			else
			{
				cleanButtonValues[i] = buttonValues[i];
				buttonHysteresis[i] = 0;
   25778:	4698      	mov	r8, r3
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   2577a:	7090      	strb	r0, [r2, #2]
   2577c:	f2c0 270f 	movt	r7, #527	; 0x20f
		buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   25780:	6920      	ldr	r0, [r4, #16]
   25782:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
   25786:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   2578a:	70d0      	strb	r0, [r2, #3]
		buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   2578c:	6908      	ldr	r0, [r1, #16]
   2578e:	f480 4000 	eor.w	r0, r0, #32768	; 0x8000
   25792:	f3c0 30c0 	ubfx	r0, r0, #15, #1
   25796:	7110      	strb	r0, [r2, #4]
		buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   25798:	6908      	ldr	r0, [r1, #16]
   2579a:	f080 0002 	eor.w	r0, r0, #2
   2579e:	f3c0 0040 	ubfx	r0, r0, #1, #1
   257a2:	7150      	strb	r0, [r2, #5]
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   257a4:	6920      	ldr	r0, [r4, #16]
   257a6:	f64e 24f4 	movw	r4, #60148	; 0xeaf4
   257aa:	f080 0080 	eor.w	r0, r0, #128	; 0x80
   257ae:	f2c0 240f 	movt	r4, #527	; 0x20f
   257b2:	f3c0 10c0 	ubfx	r0, r0, #7, #1
   257b6:	7190      	strb	r0, [r2, #6]
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   257b8:	6908      	ldr	r0, [r1, #16]
   257ba:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
   257be:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   257c2:	71d0      	strb	r0, [r2, #7]
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   257c4:	9803      	ldr	r0, [sp, #12]
   257c6:	6900      	ldr	r0, [r0, #16]
   257c8:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
   257cc:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   257d0:	7210      	strb	r0, [r2, #8]
		buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   257d2:	6909      	ldr	r1, [r1, #16]
   257d4:	9603      	str	r6, [sp, #12]
   257d6:	f481 6180 	eor.w	r1, r1, #1024	; 0x400
   257da:	f3c1 2180 	ubfx	r1, r1, #10, #1
   257de:	7251      	strb	r1, [r2, #9]
   257e0:	e00f      	b.n	25802 <buttonCheck+0x156>
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   257e2:	f85a 1002 	ldr.w	r1, [sl, r2]
   257e6:	9806      	ldr	r0, [sp, #24]
   257e8:	4281      	cmp	r1, r0
   257ea:	d202      	bcs.n	257f2 <buttonCheck+0x146>
   257ec:	3101      	adds	r1, #1
   257ee:	f84a 1002 	str.w	r1, [sl, r2]
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   257f2:	9807      	ldr	r0, [sp, #28]
   257f4:	4288      	cmp	r0, r1
   257f6:	d801      	bhi.n	257fc <buttonCheck+0x150>
   257f8:	2d01      	cmp	r5, #1
   257fa:	d072      	beq.n	258e2 <buttonCheck+0x236>
		for (int i = 0; i < NUM_BUTTONS; i++)
   257fc:	3301      	adds	r3, #1
   257fe:	2b0a      	cmp	r3, #10
   25800:	d035      	beq.n	2586e <buttonCheck+0x1c2>
			if (buttonValues[i] != buttonValuesPrev[i])
   25802:	f81c 1b01 	ldrb.w	r1, [ip], #1
   25806:	f817 2f01 	ldrb.w	r2, [r7, #1]!
   2580a:	f854 0f04 	ldr.w	r0, [r4, #4]!
   2580e:	428a      	cmp	r2, r1
   25810:	d001      	beq.n	25816 <buttonCheck+0x16a>
				buttonHysteresis[i]++;
   25812:	3001      	adds	r0, #1
   25814:	6020      	str	r0, [r4, #0]
			if (cleanButtonValues[i] == 1)
   25816:	f81e 5003 	ldrb.w	r5, [lr, r3]
   2581a:	009a      	lsls	r2, r3, #2
   2581c:	2d01      	cmp	r5, #1
   2581e:	d10d      	bne.n	2583c <buttonCheck+0x190>
				writeActionFlag = ActionHoldContinuous;
   25820:	2603      	movs	r6, #3
   25822:	9602      	str	r6, [sp, #8]
				writeButtonFlag = i;
   25824:	b25e      	sxtb	r6, r3
   25826:	9601      	str	r6, [sp, #4]
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   25828:	eb0b 0602 	add.w	r6, fp, r2
   2582c:	9604      	str	r6, [sp, #16]
				buttonActionsUI[i][ActionHoldContinuous] = TRUE;
   2582e:	9e03      	ldr	r6, [sp, #12]
   25830:	4416      	add	r6, r2
   25832:	9605      	str	r6, [sp, #20]
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   25834:	9e04      	ldr	r6, [sp, #16]
   25836:	70f5      	strb	r5, [r6, #3]
				buttonActionsUI[i][ActionHoldContinuous] = TRUE;
   25838:	9e05      	ldr	r6, [sp, #20]
   2583a:	70f5      	strb	r5, [r6, #3]
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   2583c:	4581      	cmp	r9, r0
   2583e:	d8d0      	bhi.n	257e2 <buttonCheck+0x136>
				buttonCounters[i] = 0;

				if (cleanButtonValues[i] == 1)
   25840:	2901      	cmp	r1, #1
				cleanButtonValues[i] = buttonValues[i];
   25842:	f80e 1003 	strb.w	r1, [lr, r3]
				buttonHysteresis[i] = 0;
   25846:	f8c4 8000 	str.w	r8, [r4]
				buttonCounters[i] = 0;
   2584a:	f84a 8002 	str.w	r8, [sl, r2]
				if (cleanButtonValues[i] == 1)
   2584e:	d03d      	beq.n	258cc <buttonCheck+0x220>
					buttonActionsSFX[i][ActionPress] = TRUE;
					buttonActionsUI[i][ActionPress] = TRUE;
					writeButtonFlag = i;
					writeActionFlag = ActionPress;
				}
				else if (cleanButtonValues[i] == 0)
   25850:	b949      	cbnz	r1, 25866 <buttonCheck+0x1ba>
				{
					buttonActionsSFX[i][ActionRelease] = TRUE;
					buttonActionsUI[i][ActionRelease] = TRUE;
   25852:	9d03      	ldr	r5, [sp, #12]
					buttonActionsSFX[i][ActionRelease] = TRUE;
   25854:	eb0b 0002 	add.w	r0, fp, r2
					buttonActionsUI[i][ActionRelease] = TRUE;
   25858:	442a      	add	r2, r5
					writeButtonFlag = i;
   2585a:	b25d      	sxtb	r5, r3
   2585c:	9501      	str	r5, [sp, #4]
					writeActionFlag = ActionRelease;
   2585e:	2501      	movs	r5, #1
   25860:	9502      	str	r5, [sp, #8]
					buttonActionsSFX[i][ActionRelease] = TRUE;
   25862:	7045      	strb	r5, [r0, #1]
					buttonActionsUI[i][ActionRelease] = TRUE;
   25864:	7055      	strb	r5, [r2, #1]
				}
				buttonValuesPrev[i] = buttonValues[i];
   25866:	7039      	strb	r1, [r7, #0]
		for (int i = 0; i < NUM_BUTTONS; i++)
   25868:	3301      	adds	r3, #1
   2586a:	2b0a      	cmp	r3, #10
   2586c:	d1c9      	bne.n	25802 <buttonCheck+0x156>
   2586e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   25870:	9e03      	ldr	r6, [sp, #12]
   25872:	4611      	mov	r1, r2
   25874:	9a01      	ldr	r2, [sp, #4]

		// make some if statements if you want to find the "attack" of the buttons (getting the "press" action)

		/// DEFINE GLOBAL BUTTON BEHAVIOR HERE

		if (buttonActionsUI[ButtonLeft][ActionPress] == 1)
   25876:	7933      	ldrb	r3, [r6, #4]
   25878:	700a      	strb	r2, [r1, #0]
   2587a:	9a08      	ldr	r2, [sp, #32]
   2587c:	2b01      	cmp	r3, #1
   2587e:	4611      	mov	r1, r2
   25880:	9a02      	ldr	r2, [sp, #8]
   25882:	700a      	strb	r2, [r1, #0]
   25884:	f000 8172 	beq.w	25b6c <buttonCheck+0x4c0>
			loadingPreset = 1;
			OLED_writePreset();
			writeCurrentPresetToFlash();
			clearButtonActions();
		}
		if (buttonActionsUI[ButtonRight][ActionPress] == 1)
   25888:	7a33      	ldrb	r3, [r6, #8]
   2588a:	2b01      	cmp	r3, #1
   2588c:	f000 81b8 	beq.w	25c00 <buttonCheck+0x554>
			loadingPreset = 1;
			OLED_writePreset();
			writeCurrentPresetToFlash();
			clearButtonActions();
		}
		if (buttonActionsUI[ButtonD][ActionPress] == 1)
   25890:	f896 3020 	ldrb.w	r3, [r6, #32]
   25894:	2b01      	cmp	r3, #1
   25896:	f000 81fe 	beq.w	25c96 <buttonCheck+0x5ea>
			}
			changeTuning();
			OLED_writeTuning();
			buttonActionsUI[ButtonD][ActionPress] = 0;
		}
		if (buttonActionsUI[ButtonE][ActionPress] == 1)
   2589a:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
   2589e:	2b01      	cmp	r3, #1
   258a0:	f000 823d 	beq.w	25d1e <buttonCheck+0x672>
			changeTuning();
			OLED_writeTuning();
			buttonActionsUI[ButtonE][ActionPress] = 0;
		}

		if (buttonActionsUI[ButtonEdit][ActionPress])
   258a4:	7833      	ldrb	r3, [r6, #0]
   258a6:	2b00      	cmp	r3, #0
   258a8:	f040 822d 	bne.w	25d06 <buttonCheck+0x65a>
		{
			OLED_writeEditScreen();
			setLED_Edit(1);
			buttonActionsUI[ButtonEdit][ActionPress] = 0;
		}
		if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   258ac:	78f3      	ldrb	r3, [r6, #3]
   258ae:	2b01      	cmp	r3, #1
   258b0:	d024      	beq.n	258fc <buttonCheck+0x250>
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
			}

//			OLEDdrawFloatArray(audioDisplayBuffer, -1.0f, 1.0f, 128, displayBufferIndex, 0, BothLines);
		}
		if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
   258b2:	7873      	ldrb	r3, [r6, #1]
   258b4:	2b01      	cmp	r3, #1
   258b6:	d03d      	beq.n	25934 <buttonCheck+0x288>
			buttonActionsUI[ButtonEdit][ActionRelease] = 0;
			buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
			buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;

		}
		if (buttonActionsUI[ButtonDown][ActionPress] == 1)
   258b8:	7b33      	ldrb	r3, [r6, #12]
   258ba:	2b01      	cmp	r3, #1
   258bc:	d04b      	beq.n	25956 <buttonCheck+0x2aa>
			decrementPage();
			OLEDwriteString("P", 1, 110, FirstLine);
			OLEDwriteInt(knobPage, 1, 120, FirstLine);
			buttonActionsUI[ButtonDown][ActionPress] = 0;
		}
		if (buttonActionsUI[ButtonUp][ActionPress] == 1)
   258be:	7c33      	ldrb	r3, [r6, #16]
   258c0:	2b01      	cmp	r3, #1
   258c2:	f000 80e2 	beq.w	25a8a <buttonCheck+0x3de>
//			OLEDwriteString(" ", 1, getCursorX(), SecondLine);
//			OLEDwriteString(paramNames[orderedParams[currentParamIndex]], getCursorX(), SecondLine);
//			buttonActionsUI[ButtonEdit][ActionPress] = 0;
//		}
	}
}
   258c6:	b00b      	add	sp, #44	; 0x2c
   258c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					writeButtonFlag = i;
   258cc:	b258      	sxtb	r0, r3
					buttonActionsSFX[i][ActionPress] = TRUE;
   258ce:	f80b 1002 	strb.w	r1, [fp, r2]
				buttonValuesPrev[i] = buttonValues[i];
   258d2:	7039      	strb	r1, [r7, #0]
					writeButtonFlag = i;
   258d4:	9001      	str	r0, [sp, #4]
					buttonActionsUI[i][ActionPress] = TRUE;
   258d6:	9803      	ldr	r0, [sp, #12]
   258d8:	5481      	strb	r1, [r0, r2]
					writeActionFlag = ActionPress;
   258da:	2200      	movs	r2, #0
   258dc:	9202      	str	r2, [sp, #8]
   258de:	e7c3      	b.n	25868 <buttonCheck+0x1bc>
   258e0:	4770      	bx	lr
					buttonActionsUI[i][ActionHoldInstant] = TRUE;
   258e2:	9803      	ldr	r0, [sp, #12]
					buttonActionsSFX[i][ActionHoldInstant] = TRUE;
   258e4:	eb0b 0102 	add.w	r1, fp, r2
					buttonActionsUI[i][ActionHoldInstant] = TRUE;
   258e8:	4402      	add	r2, r0
					writeButtonFlag = i;
   258ea:	b258      	sxtb	r0, r3
   258ec:	9001      	str	r0, [sp, #4]
					buttonActionsSFX[i][ActionHoldInstant] = TRUE;
   258ee:	f04f 0001 	mov.w	r0, #1
   258f2:	7088      	strb	r0, [r1, #2]
					writeActionFlag = ActionHoldInstant;
   258f4:	2102      	movs	r1, #2
					buttonActionsUI[i][ActionHoldInstant] = TRUE;
   258f6:	7090      	strb	r0, [r2, #2]
					writeActionFlag = ActionHoldInstant;
   258f8:	9102      	str	r1, [sp, #8]
   258fa:	e77f      	b.n	257fc <buttonCheck+0x150>
			if (buttonActionsUI[ButtonC][ActionPress] == 1)
   258fc:	7f34      	ldrb	r4, [r6, #28]
   258fe:	2c01      	cmp	r4, #1
   25900:	f000 828f 	beq.w	25e22 <buttonCheck+0x776>
			if (buttonActionsUI[ButtonDown][ActionPress])
   25904:	7b33      	ldrb	r3, [r6, #12]
   25906:	b193      	cbz	r3, 2592e <buttonCheck+0x282>
				cvAddParam[currentPreset] = -1;
   25908:	f646 11b9 	movw	r1, #27065	; 0x69b9
   2590c:	f64e 47a0 	movw	r7, #60576	; 0xeca0
				buttonActionsSFX[ButtonDown][ActionPress] = 0;
   25910:	f64e 227c 	movw	r2, #60028	; 0xea7c
				buttonActionsUI[ButtonDown][ActionPress] = 0;
   25914:	2300      	movs	r3, #0
				cvAddParam[currentPreset] = -1;
   25916:	f2c0 210e 	movt	r1, #526	; 0x20e
   2591a:	20ff      	movs	r0, #255	; 0xff
   2591c:	f2c0 270f 	movt	r7, #527	; 0x20f
				buttonActionsSFX[ButtonDown][ActionPress] = 0;
   25920:	f2c0 220f 	movt	r2, #527	; 0x20f
				cvAddParam[currentPreset] = -1;
   25924:	7809      	ldrb	r1, [r1, #0]
				buttonActionsSFX[ButtonDown][ActionPress] = 0;
   25926:	7313      	strb	r3, [r2, #12]
				cvAddParam[currentPreset] = -1;
   25928:	5478      	strb	r0, [r7, r1]
				buttonActionsUI[ButtonDown][ActionPress] = 0;
   2592a:	7333      	strb	r3, [r6, #12]
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   2592c:	70f3      	strb	r3, [r6, #3]
		if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
   2592e:	7873      	ldrb	r3, [r6, #1]
   25930:	2b01      	cmp	r3, #1
   25932:	d1c4      	bne.n	258be <buttonCheck+0x212>
			OLED_writePreset();
   25934:	f7f5 fc6e 	bl	1b214 <OLED_writePreset>
			setLED_Edit(0);
   25938:	2000      	movs	r0, #0
   2593a:	f7f5 fbbb 	bl	1b0b4 <setLED_Edit>
			buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
   2593e:	f64e 227c 	movw	r2, #60028	; 0xea7c
   25942:	2300      	movs	r3, #0
   25944:	f2c0 220f 	movt	r2, #527	; 0x20f
			buttonActionsUI[ButtonEdit][ActionRelease] = 0;
   25948:	7073      	strb	r3, [r6, #1]
			buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
   2594a:	7053      	strb	r3, [r2, #1]
			buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;
   2594c:	70d3      	strb	r3, [r2, #3]
			buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   2594e:	70f3      	strb	r3, [r6, #3]
		if (buttonActionsUI[ButtonDown][ActionPress] == 1)
   25950:	7b33      	ldrb	r3, [r6, #12]
   25952:	2b01      	cmp	r3, #1
   25954:	d1b3      	bne.n	258be <buttonCheck+0x212>

}

void decrementPage(void)
{
	if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
   25956:	f646 14ba 	movw	r4, #27066	; 0x69ba
   2595a:	f646 18b9 	movw	r8, #27065	; 0x69b9
   2595e:	f2c0 240e 	movt	r4, #526	; 0x20e
   25962:	f2c0 280e 	movt	r8, #526	; 0x20e
   25966:	7823      	ldrb	r3, [r4, #0]
   25968:	f898 1000 	ldrb.w	r1, [r8]
   2596c:	2b00      	cmp	r3, #0
   2596e:	f000 824d 	beq.w	25e0c <buttonCheck+0x760>
	else knobPage--;
   25972:	3b01      	subs	r3, #1
   25974:	b2db      	uxtb	r3, r3
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25976:	f64c 2278 	movw	r2, #51832	; 0xca78
   2597a:	f04f 0c64 	mov.w	ip, #100	; 0x64
   2597e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
   25982:	f64d 45b0 	movw	r5, #56496	; 0xdcb0
   25986:	f2c0 220f 	movt	r2, #527	; 0x20f
   2598a:	f64e 3ea4 	movw	lr, #60324	; 0xeba4
   2598e:	0080      	lsls	r0, r0, #2
   25990:	f2c0 250f 	movt	r5, #527	; 0x20f
   25994:	fb0c 2201 	mla	r2, ip, r1, r2
   25998:	f64e 47a0 	movw	r7, #60576	; 0xeca0
   2599c:	9003      	str	r0, [sp, #12]
   2599e:	f2c0 2e0f 	movt	lr, #527	; 0x20f
   259a2:	9202      	str	r2, [sp, #8]
		{
			knob = 5;
		}
		knobActive[knob] = 0;
		floatADCUI[knob] = -1.0f;
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   259a4:	f100 0214 	add.w	r2, r0, #20
   259a8:	9802      	ldr	r0, [sp, #8]
   259aa:	f2c0 270f 	movt	r7, #527	; 0x20f
   259ae:	9502      	str	r5, [sp, #8]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   259b0:	f04f 0a00 	mov.w	sl, #0
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   259b4:	1882      	adds	r2, r0, r2
   259b6:	9606      	str	r6, [sp, #24]
   259b8:	7023      	strb	r3, [r4, #0]
   259ba:	4606      	mov	r6, r0
   259bc:	9205      	str	r2, [sp, #20]
   259be:	f24a 6268 	movw	r2, #42600	; 0xa668
   259c2:	9404      	str	r4, [sp, #16]
   259c4:	4675      	mov	r5, lr
   259c6:	f2c0 220f 	movt	r2, #527	; 0x20f
   259ca:	9201      	str	r2, [sp, #4]
   259cc:	e017      	b.n	259fe <buttonCheck+0x352>
		knobActive[knob] = 0;
   259ce:	9b02      	ldr	r3, [sp, #8]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   259d0:	ed9b 0a00 	vldr	s0, [fp]
		knobActive[knob] = 0;
   259d4:	f803 e00a 	strb.w	lr, [r3, sl]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   259d8:	f10a 0a01 	add.w	sl, sl, #1
		floatADCUI[knob] = -1.0f;
   259dc:	edcc 7a00 	vstr	s15, [ip]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   259e0:	f005 fcee 	bl	2b3c0 <tExpSmooth_setValAndDest>

		smoothedADC[knob] = values[knob];
   259e4:	9b01      	ldr	r3, [sp, #4]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   259e6:	f1ba 0f05 	cmp.w	sl, #5
		smoothedADC[knob] = values[knob];
   259ea:	4499      	add	r9, r3
   259ec:	f8db 3000 	ldr.w	r3, [fp]
   259f0:	f8c9 3000 	str.w	r3, [r9]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   259f4:	d032      	beq.n	25a5c <buttonCheck+0x3b0>
   259f6:	9b04      	ldr	r3, [sp, #16]
   259f8:	f898 1000 	ldrb.w	r1, [r8]
   259fc:	781b      	ldrb	r3, [r3, #0]
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   259fe:	2205      	movs	r2, #5
   25a00:	ea4f 098a 	mov.w	r9, sl, lsl #2
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25a04:	f24a 6008 	movw	r0, #42504	; 0xa608
   25a08:	9c03      	ldr	r4, [sp, #12]
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25a0a:	5679      	ldrsb	r1, [r7, r1]
   25a0c:	fb12 a203 	smlabb	r2, r2, r3, sl
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25a10:	eb04 0b09 	add.w	fp, r4, r9
   25a14:	f2c0 200f 	movt	r0, #527	; 0x20f
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25a18:	428a      	cmp	r2, r1
		floatADCUI[knob] = -1.0f;
   25a1a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
		knobActive[knob] = 0;
   25a1e:	f04f 0e00 	mov.w	lr, #0
		floatADCUI[knob] = -1.0f;
   25a22:	eb05 0c09 	add.w	ip, r5, r9
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25a26:	44b3      	add	fp, r6
   25a28:	4448      	add	r0, r9
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25a2a:	d1d0      	bne.n	259ce <buttonCheck+0x322>
		floatADCUI[knob] = -1.0f;
   25a2c:	2300      	movs	r3, #0
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25a2e:	9c05      	ldr	r4, [sp, #20]
   25a30:	f24a 601c 	movw	r0, #42524	; 0xa61c
		knobActive[knob] = 0;
   25a34:	2200      	movs	r2, #0
		floatADCUI[knob] = -1.0f;
   25a36:	f6cb 7380 	movt	r3, #49024	; 0xbf80
		knobActive[knob] = 0;
   25a3a:	9902      	ldr	r1, [sp, #8]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25a3c:	f10a 0a01 	add.w	sl, sl, #1
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25a40:	ed94 0a00 	vldr	s0, [r4]
   25a44:	f2c0 200f 	movt	r0, #527	; 0x20f
		knobActive[knob] = 0;
   25a48:	714a      	strb	r2, [r1, #5]
		floatADCUI[knob] = -1.0f;
   25a4a:	616b      	str	r3, [r5, #20]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25a4c:	f005 fcb8 	bl	2b3c0 <tExpSmooth_setValAndDest>
		smoothedADC[knob] = values[knob];
   25a50:	6823      	ldr	r3, [r4, #0]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25a52:	f1ba 0f05 	cmp.w	sl, #5
		smoothedADC[knob] = values[knob];
   25a56:	9a01      	ldr	r2, [sp, #4]
   25a58:	6153      	str	r3, [r2, #20]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25a5a:	d1cc      	bne.n	259f6 <buttonCheck+0x34a>
			OLEDwriteString("P", 1, 110, FirstLine);
   25a5c:	f645 6024 	movw	r0, #24100	; 0x5e24
   25a60:	9c04      	ldr	r4, [sp, #16]
   25a62:	2300      	movs	r3, #0
   25a64:	226e      	movs	r2, #110	; 0x6e
   25a66:	2101      	movs	r1, #1
   25a68:	f2c0 0003 	movt	r0, #3
   25a6c:	9e06      	ldr	r6, [sp, #24]
   25a6e:	f7f5 fe17 	bl	1b6a0 <OLEDwriteString>
			OLEDwriteInt(knobPage, 1, 120, FirstLine);
   25a72:	2300      	movs	r3, #0
   25a74:	7820      	ldrb	r0, [r4, #0]
   25a76:	2278      	movs	r2, #120	; 0x78
   25a78:	2101      	movs	r1, #1
   25a7a:	f7f5 fe45 	bl	1b708 <OLEDwriteInt>
			buttonActionsUI[ButtonDown][ActionPress] = 0;
   25a7e:	2300      	movs	r3, #0
   25a80:	7333      	strb	r3, [r6, #12]
		if (buttonActionsUI[ButtonUp][ActionPress] == 1)
   25a82:	7c33      	ldrb	r3, [r6, #16]
   25a84:	2b01      	cmp	r3, #1
   25a86:	f47f af1e 	bne.w	258c6 <buttonCheck+0x21a>
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25a8a:	f646 18b9 	movw	r8, #27065	; 0x69b9
   25a8e:	f646 14ba 	movw	r4, #27066	; 0x69ba
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25a92:	f64c 2278 	movw	r2, #51832	; 0xca78
   25a96:	2564      	movs	r5, #100	; 0x64
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25a98:	f2c0 280e 	movt	r8, #526	; 0x20e
   25a9c:	f2c0 240e 	movt	r4, #526	; 0x20e
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25aa0:	f2c0 220f 	movt	r2, #527	; 0x20f
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25aa4:	f64e 3090 	movw	r0, #60304	; 0xeb90
   25aa8:	f898 1000 	ldrb.w	r1, [r8]
   25aac:	f64e 3ea4 	movw	lr, #60324	; 0xeba4
   25ab0:	7823      	ldrb	r3, [r4, #0]
   25ab2:	f2c0 200f 	movt	r0, #527	; 0x20f
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25ab6:	fb05 2201 	mla	r2, r5, r1, r2
   25aba:	f24a 6568 	movw	r5, #42600	; 0xa668
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25abe:	5c40      	ldrb	r0, [r0, r1]
   25ac0:	f64e 47a0 	movw	r7, #60576	; 0xeca0
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25ac4:	9204      	str	r2, [sp, #16]
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25ac6:	1c5a      	adds	r2, r3, #1
   25ac8:	f64d 43b0 	movw	r3, #56496	; 0xdcb0
   25acc:	f2c0 250f 	movt	r5, #527	; 0x20f
   25ad0:	f2c0 2e0f 	movt	lr, #527	; 0x20f
   25ad4:	f2c0 270f 	movt	r7, #527	; 0x20f
   25ad8:	f2c0 230f 	movt	r3, #527	; 0x20f
   25adc:	9501      	str	r5, [sp, #4]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25ade:	f04f 0a00 	mov.w	sl, #0
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25ae2:	4675      	mov	r5, lr
   25ae4:	9302      	str	r3, [sp, #8]
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25ae6:	fb92 f3f0 	sdiv	r3, r2, r0
   25aea:	fb00 2313 	mls	r3, r0, r3, r2
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25aee:	9804      	ldr	r0, [sp, #16]
   25af0:	9404      	str	r4, [sp, #16]
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25af2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25af6:	b2db      	uxtb	r3, r3
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25af8:	0092      	lsls	r2, r2, #2
	knobPage = (knobPage + 1) % numPages[currentPreset];
   25afa:	7023      	strb	r3, [r4, #0]
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   25afc:	9203      	str	r2, [sp, #12]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25afe:	3214      	adds	r2, #20
   25b00:	1882      	adds	r2, r0, r2
   25b02:	e9cd 2605 	strd	r2, r6, [sp, #20]
   25b06:	4606      	mov	r6, r0
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25b08:	2205      	movs	r2, #5
   25b0a:	ea4f 098a 	mov.w	r9, sl, lsl #2
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25b0e:	f24a 6008 	movw	r0, #42504	; 0xa608
   25b12:	9c03      	ldr	r4, [sp, #12]
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25b14:	5679      	ldrsb	r1, [r7, r1]
   25b16:	fb12 a203 	smlabb	r2, r2, r3, sl
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25b1a:	eb04 0b09 	add.w	fp, r4, r9
   25b1e:	f2c0 200f 	movt	r0, #527	; 0x20f
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25b22:	428a      	cmp	r2, r1
		floatADCUI[knob] = -1.0f;
   25b24:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
		knobActive[knob] = 0;
   25b28:	f04f 0e00 	mov.w	lr, #0
		floatADCUI[knob] = -1.0f;
   25b2c:	eb05 0c09 	add.w	ip, r5, r9
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25b30:	44b3      	add	fp, r6
   25b32:	4448      	add	r0, r9
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   25b34:	f000 8135 	beq.w	25da2 <buttonCheck+0x6f6>
		knobActive[knob] = 0;
   25b38:	9b02      	ldr	r3, [sp, #8]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25b3a:	ed9b 0a00 	vldr	s0, [fp]
		knobActive[knob] = 0;
   25b3e:	f803 e00a 	strb.w	lr, [r3, sl]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25b42:	f10a 0a01 	add.w	sl, sl, #1
		floatADCUI[knob] = -1.0f;
   25b46:	edcc 7a00 	vstr	s15, [ip]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25b4a:	f005 fc39 	bl	2b3c0 <tExpSmooth_setValAndDest>
		smoothedADC[knob] = values[knob];
   25b4e:	9b01      	ldr	r3, [sp, #4]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25b50:	f1ba 0f05 	cmp.w	sl, #5
		smoothedADC[knob] = values[knob];
   25b54:	4499      	add	r9, r3
   25b56:	f8db 3000 	ldr.w	r3, [fp]
   25b5a:	f8c9 3000 	str.w	r3, [r9]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25b5e:	f000 8139 	beq.w	25dd4 <buttonCheck+0x728>
   25b62:	9b04      	ldr	r3, [sp, #16]
   25b64:	f898 1000 	ldrb.w	r1, [r8]
   25b68:	781b      	ldrb	r3, [r3, #0]
   25b6a:	e7cd      	b.n	25b08 <buttonCheck+0x45c>
			previousPreset = currentPreset;
   25b6c:	f646 18b9 	movw	r8, #27065	; 0x69b9
   25b70:	f246 22d0 	movw	r2, #25296	; 0x62d0
   25b74:	f2c0 280e 	movt	r8, #526	; 0x20e
   25b78:	f2c0 0206 	movt	r2, #6
   25b7c:	f898 3000 	ldrb.w	r3, [r8]
   25b80:	7013      	strb	r3, [r2, #0]
			if (currentPreset <= 0) currentPreset = PresetNil - 1;
   25b82:	2b00      	cmp	r3, #0
   25b84:	f000 8140 	beq.w	25e08 <buttonCheck+0x75c>
			else currentPreset--;
   25b88:	3b01      	subs	r3, #1
   25b8a:	b2db      	uxtb	r3, r3
			loadingPreset = 1;
   25b8c:	f646 12bb 	movw	r2, #27067	; 0x69bb
   25b90:	2101      	movs	r1, #1
   25b92:	f888 3000 	strb.w	r3, [r8]
   25b96:	f2c0 220e 	movt	r2, #526	; 0x20e
   25b9a:	7011      	strb	r1, [r2, #0]
			OLED_writePreset();
   25b9c:	f7f5 fb3a 	bl	1b214 <OLED_writePreset>
	if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
   25ba0:	f246 031c 	movw	r3, #24604	; 0x601c
   25ba4:	f898 1000 	ldrb.w	r1, [r8]
   25ba8:	f2c0 0306 	movt	r3, #6
   25bac:	8818      	ldrh	r0, [r3, #0]
   25bae:	f7f3 fcd9 	bl	19564 <EE_WriteVariable>
   25bb2:	b108      	cbz	r0, 25bb8 <buttonCheck+0x50c>
		Error_Handler();
   25bb4:	f7f5 fa7a 	bl	1b0ac <Error_Handler>
			buttonActionsSFX[b][a] = 0;
   25bb8:	f64e 227c 	movw	r2, #60028	; 0xea7c
			buttonActionsUI[b][a] = 0;
   25bbc:	2300      	movs	r3, #0
   25bbe:	21ff      	movs	r1, #255	; 0xff
			buttonActionsSFX[b][a] = 0;
   25bc0:	f2c0 220f 	movt	r2, #527	; 0x20f
			buttonActionsUI[b][a] = 0;
   25bc4:	60b3      	str	r3, [r6, #8]
   25bc6:	6033      	str	r3, [r6, #0]
   25bc8:	6073      	str	r3, [r6, #4]
			buttonActionsSFX[b][a] = 0;
   25bca:	6013      	str	r3, [r2, #0]
   25bcc:	6053      	str	r3, [r2, #4]
   25bce:	6093      	str	r3, [r2, #8]
   25bd0:	60d3      	str	r3, [r2, #12]
   25bd2:	6113      	str	r3, [r2, #16]
   25bd4:	6153      	str	r3, [r2, #20]
   25bd6:	6193      	str	r3, [r2, #24]
   25bd8:	61d3      	str	r3, [r2, #28]
   25bda:	6213      	str	r3, [r2, #32]
   25bdc:	6253      	str	r3, [r2, #36]	; 0x24
   25bde:	6293      	str	r3, [r2, #40]	; 0x28
			buttonActionsUI[b][a] = 0;
   25be0:	60f3      	str	r3, [r6, #12]
   25be2:	6133      	str	r3, [r6, #16]
   25be4:	6173      	str	r3, [r6, #20]
   25be6:	61b3      	str	r3, [r6, #24]
   25be8:	61f3      	str	r3, [r6, #28]
   25bea:	6233      	str	r3, [r6, #32]
   25bec:	6273      	str	r3, [r6, #36]	; 0x24
   25bee:	62b3      	str	r3, [r6, #40]	; 0x28
   25bf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   25bf2:	7019      	strb	r1, [r3, #0]
   25bf4:	9b08      	ldr	r3, [sp, #32]
   25bf6:	7019      	strb	r1, [r3, #0]
		if (buttonActionsUI[ButtonRight][ActionPress] == 1)
   25bf8:	7a33      	ldrb	r3, [r6, #8]
   25bfa:	2b01      	cmp	r3, #1
   25bfc:	f47f ae48 	bne.w	25890 <buttonCheck+0x1e4>
			previousPreset = currentPreset;
   25c00:	f646 18b9 	movw	r8, #27065	; 0x69b9
   25c04:	f246 22d0 	movw	r2, #25296	; 0x62d0
   25c08:	f2c0 280e 	movt	r8, #526	; 0x20e
   25c0c:	f2c0 0206 	movt	r2, #6
   25c10:	f898 3000 	ldrb.w	r3, [r8]
			if (currentPreset >= PresetNil - 1) currentPreset = 0;
   25c14:	2b10      	cmp	r3, #16
			previousPreset = currentPreset;
   25c16:	7013      	strb	r3, [r2, #0]
			if (currentPreset >= PresetNil - 1) currentPreset = 0;
   25c18:	f200 80f4 	bhi.w	25e04 <buttonCheck+0x758>
			else currentPreset++;
   25c1c:	3301      	adds	r3, #1
   25c1e:	b2db      	uxtb	r3, r3
			loadingPreset = 1;
   25c20:	f646 12bb 	movw	r2, #27067	; 0x69bb
   25c24:	2101      	movs	r1, #1
   25c26:	f888 3000 	strb.w	r3, [r8]
   25c2a:	f2c0 220e 	movt	r2, #526	; 0x20e
   25c2e:	7011      	strb	r1, [r2, #0]
			OLED_writePreset();
   25c30:	f7f5 faf0 	bl	1b214 <OLED_writePreset>
	if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
   25c34:	f246 031c 	movw	r3, #24604	; 0x601c
   25c38:	f898 1000 	ldrb.w	r1, [r8]
   25c3c:	f2c0 0306 	movt	r3, #6
   25c40:	8818      	ldrh	r0, [r3, #0]
   25c42:	f7f3 fc8f 	bl	19564 <EE_WriteVariable>
   25c46:	b108      	cbz	r0, 25c4c <buttonCheck+0x5a0>
		Error_Handler();
   25c48:	f7f5 fa30 	bl	1b0ac <Error_Handler>
			buttonActionsSFX[b][a] = 0;
   25c4c:	f64e 227c 	movw	r2, #60028	; 0xea7c
			buttonActionsUI[b][a] = 0;
   25c50:	2300      	movs	r3, #0
   25c52:	21ff      	movs	r1, #255	; 0xff
			buttonActionsSFX[b][a] = 0;
   25c54:	f2c0 220f 	movt	r2, #527	; 0x20f
			buttonActionsUI[b][a] = 0;
   25c58:	6233      	str	r3, [r6, #32]
   25c5a:	6033      	str	r3, [r6, #0]
   25c5c:	6073      	str	r3, [r6, #4]
			buttonActionsSFX[b][a] = 0;
   25c5e:	6013      	str	r3, [r2, #0]
   25c60:	6053      	str	r3, [r2, #4]
   25c62:	6093      	str	r3, [r2, #8]
   25c64:	60d3      	str	r3, [r2, #12]
   25c66:	6113      	str	r3, [r2, #16]
   25c68:	6153      	str	r3, [r2, #20]
   25c6a:	6193      	str	r3, [r2, #24]
   25c6c:	61d3      	str	r3, [r2, #28]
   25c6e:	6213      	str	r3, [r2, #32]
   25c70:	6253      	str	r3, [r2, #36]	; 0x24
   25c72:	6293      	str	r3, [r2, #40]	; 0x28
			buttonActionsUI[b][a] = 0;
   25c74:	60b3      	str	r3, [r6, #8]
   25c76:	60f3      	str	r3, [r6, #12]
   25c78:	6133      	str	r3, [r6, #16]
   25c7a:	6173      	str	r3, [r6, #20]
   25c7c:	61b3      	str	r3, [r6, #24]
   25c7e:	61f3      	str	r3, [r6, #28]
   25c80:	6273      	str	r3, [r6, #36]	; 0x24
   25c82:	62b3      	str	r3, [r6, #40]	; 0x28
   25c84:	9b09      	ldr	r3, [sp, #36]	; 0x24
   25c86:	7019      	strb	r1, [r3, #0]
   25c88:	9b08      	ldr	r3, [sp, #32]
   25c8a:	7019      	strb	r1, [r3, #0]
		if (buttonActionsUI[ButtonD][ActionPress] == 1)
   25c8c:	f896 3020 	ldrb.w	r3, [r6, #32]
   25c90:	2b01      	cmp	r3, #1
   25c92:	f47f ae02 	bne.w	2589a <buttonCheck+0x1ee>
			if (currentTuning == 0)
   25c96:	f646 12b4 	movw	r2, #27060	; 0x69b4
   25c9a:	f2c0 220e 	movt	r2, #526	; 0x20e
   25c9e:	6813      	ldr	r3, [r2, #0]
   25ca0:	2b00      	cmp	r3, #0
   25ca2:	f040 80ad 	bne.w	25e00 <buttonCheck+0x754>
				currentTuning = NUM_TUNINGS - 1;
   25ca6:	233e      	movs	r3, #62	; 0x3e
		centsDeviation[i] = tuningPresets[currentTuning][i];
   25ca8:	f644 24c8 	movw	r4, #19144	; 0x4ac8
   25cac:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   25cb0:	f646 1784 	movw	r7, #27012	; 0x6984
   25cb4:	6013      	str	r3, [r2, #0]
   25cb6:	f2c0 0403 	movt	r4, #3
   25cba:	f2c0 270e 	movt	r7, #526	; 0x20e
   25cbe:	eb04 1401 	add.w	r4, r4, r1, lsl #4
   25cc2:	f104 0c30 	add.w	ip, r4, #48	; 0x30
   25cc6:	6820      	ldr	r0, [r4, #0]
   25cc8:	3410      	adds	r4, #16
   25cca:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   25cce:	463d      	mov	r5, r7
   25cd0:	f854 2c08 	ldr.w	r2, [r4, #-8]
   25cd4:	3710      	adds	r7, #16
   25cd6:	f854 3c04 	ldr.w	r3, [r4, #-4]
   25cda:	4564      	cmp	r4, ip
   25cdc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   25cde:	d1f2      	bne.n	25cc6 <buttonCheck+0x61a>
	if (currentPreset == AutotuneMono)
   25ce0:	f646 13b9 	movw	r3, #27065	; 0x69b9
   25ce4:	f2c0 230e 	movt	r3, #526	; 0x20e
   25ce8:	781b      	ldrb	r3, [r3, #0]
   25cea:	2b03      	cmp	r3, #3
   25cec:	f000 8096 	beq.w	25e1c <buttonCheck+0x770>
			OLED_writeTuning();
   25cf0:	f7f5 fc22 	bl	1b538 <OLED_writeTuning>
			buttonActionsUI[ButtonD][ActionPress] = 0;
   25cf4:	2300      	movs	r3, #0
   25cf6:	f886 3020 	strb.w	r3, [r6, #32]
		if (buttonActionsUI[ButtonE][ActionPress] == 1)
   25cfa:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
   25cfe:	2b01      	cmp	r3, #1
   25d00:	f47f add0 	bne.w	258a4 <buttonCheck+0x1f8>
   25d04:	e00b      	b.n	25d1e <buttonCheck+0x672>
			OLED_writeEditScreen();
   25d06:	f7f5 fbb9 	bl	1b47c <OLED_writeEditScreen>
			setLED_Edit(1);
   25d0a:	2001      	movs	r0, #1
   25d0c:	f7f5 f9d2 	bl	1b0b4 <setLED_Edit>
			buttonActionsUI[ButtonEdit][ActionPress] = 0;
   25d10:	2300      	movs	r3, #0
   25d12:	7033      	strb	r3, [r6, #0]
		if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   25d14:	78f3      	ldrb	r3, [r6, #3]
   25d16:	2b01      	cmp	r3, #1
   25d18:	f47f adcb 	bne.w	258b2 <buttonCheck+0x206>
   25d1c:	e5ee      	b.n	258fc <buttonCheck+0x250>
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   25d1e:	f646 11b4 	movw	r1, #27060	; 0x69b4
   25d22:	f244 1305 	movw	r3, #16645	; 0x4105
		centsDeviation[i] = tuningPresets[currentTuning][i];
   25d26:	f644 24c8 	movw	r4, #19144	; 0x4ac8
   25d2a:	f646 1784 	movw	r7, #27012	; 0x6984
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   25d2e:	f2c0 210e 	movt	r1, #526	; 0x20e
   25d32:	f2c0 4310 	movt	r3, #1040	; 0x410
		centsDeviation[i] = tuningPresets[currentTuning][i];
   25d36:	f2c0 0403 	movt	r4, #3
   25d3a:	f2c0 270e 	movt	r7, #526	; 0x20e
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   25d3e:	680a      	ldr	r2, [r1, #0]
   25d40:	3201      	adds	r2, #1
   25d42:	fba3 0302 	umull	r0, r3, r3, r2
   25d46:	1ad0      	subs	r0, r2, r3
   25d48:	eb03 0350 	add.w	r3, r3, r0, lsr #1
   25d4c:	095b      	lsrs	r3, r3, #5
   25d4e:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
   25d52:	1ad3      	subs	r3, r2, r3
		centsDeviation[i] = tuningPresets[currentTuning][i];
   25d54:	eb03 0243 	add.w	r2, r3, r3, lsl #1
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   25d58:	600b      	str	r3, [r1, #0]
		centsDeviation[i] = tuningPresets[currentTuning][i];
   25d5a:	eb04 1402 	add.w	r4, r4, r2, lsl #4
   25d5e:	f104 0c30 	add.w	ip, r4, #48	; 0x30
   25d62:	6820      	ldr	r0, [r4, #0]
   25d64:	3410      	adds	r4, #16
   25d66:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   25d6a:	463d      	mov	r5, r7
   25d6c:	f854 2c08 	ldr.w	r2, [r4, #-8]
   25d70:	3710      	adds	r7, #16
   25d72:	f854 3c04 	ldr.w	r3, [r4, #-4]
   25d76:	4564      	cmp	r4, ip
   25d78:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   25d7a:	d1f2      	bne.n	25d62 <buttonCheck+0x6b6>
	if (currentPreset == AutotuneMono)
   25d7c:	f646 13b9 	movw	r3, #27065	; 0x69b9
   25d80:	f2c0 230e 	movt	r3, #526	; 0x20e
   25d84:	781b      	ldrb	r3, [r3, #0]
   25d86:	2b03      	cmp	r3, #3
   25d88:	d101      	bne.n	25d8e <buttonCheck+0x6e2>
		calculateNoteArray();
   25d8a:	f7fd ff33 	bl	23bf4 <calculateNoteArray>
			OLED_writeTuning();
   25d8e:	f7f5 fbd3 	bl	1b538 <OLED_writeTuning>
			buttonActionsUI[ButtonE][ActionPress] = 0;
   25d92:	2300      	movs	r3, #0
   25d94:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
		if (buttonActionsUI[ButtonEdit][ActionPress])
   25d98:	7833      	ldrb	r3, [r6, #0]
   25d9a:	2b00      	cmp	r3, #0
   25d9c:	f43f ad86 	beq.w	258ac <buttonCheck+0x200>
   25da0:	e7b1      	b.n	25d06 <buttonCheck+0x65a>
		floatADCUI[knob] = -1.0f;
   25da2:	2300      	movs	r3, #0
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25da4:	9c05      	ldr	r4, [sp, #20]
   25da6:	f24a 601c 	movw	r0, #42524	; 0xa61c
		knobActive[knob] = 0;
   25daa:	2200      	movs	r2, #0
		floatADCUI[knob] = -1.0f;
   25dac:	f6cb 7380 	movt	r3, #49024	; 0xbf80
		knobActive[knob] = 0;
   25db0:	9902      	ldr	r1, [sp, #8]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25db2:	f10a 0a01 	add.w	sl, sl, #1
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25db6:	ed94 0a00 	vldr	s0, [r4]
   25dba:	f2c0 200f 	movt	r0, #527	; 0x20f
		knobActive[knob] = 0;
   25dbe:	714a      	strb	r2, [r1, #5]
		floatADCUI[knob] = -1.0f;
   25dc0:	616b      	str	r3, [r5, #20]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   25dc2:	f005 fafd 	bl	2b3c0 <tExpSmooth_setValAndDest>
		smoothedADC[knob] = values[knob];
   25dc6:	6823      	ldr	r3, [r4, #0]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25dc8:	f1ba 0f05 	cmp.w	sl, #5
		smoothedADC[knob] = values[knob];
   25dcc:	9a01      	ldr	r2, [sp, #4]
   25dce:	6153      	str	r3, [r2, #20]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   25dd0:	f47f aec7 	bne.w	25b62 <buttonCheck+0x4b6>
			OLEDwriteString("P", 1, 110, FirstLine);
   25dd4:	f645 6024 	movw	r0, #24100	; 0x5e24
   25dd8:	9c04      	ldr	r4, [sp, #16]
   25dda:	2300      	movs	r3, #0
   25ddc:	226e      	movs	r2, #110	; 0x6e
   25dde:	2101      	movs	r1, #1
   25de0:	f2c0 0003 	movt	r0, #3
   25de4:	9e06      	ldr	r6, [sp, #24]
   25de6:	f7f5 fc5b 	bl	1b6a0 <OLEDwriteString>
			OLEDwriteInt(knobPage, 1, 120, FirstLine);
   25dea:	7820      	ldrb	r0, [r4, #0]
   25dec:	2300      	movs	r3, #0
   25dee:	2278      	movs	r2, #120	; 0x78
   25df0:	2101      	movs	r1, #1
   25df2:	f7f5 fc89 	bl	1b708 <OLEDwriteInt>
			buttonActionsUI[ButtonUp][ActionPress] = 0;
   25df6:	2300      	movs	r3, #0
   25df8:	7433      	strb	r3, [r6, #16]
}
   25dfa:	b00b      	add	sp, #44	; 0x2c
   25dfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				currentTuning = (currentTuning - 1);
   25e00:	3b01      	subs	r3, #1
   25e02:	e751      	b.n	25ca8 <buttonCheck+0x5fc>
			if (currentPreset >= PresetNil - 1) currentPreset = 0;
   25e04:	2300      	movs	r3, #0
   25e06:	e70b      	b.n	25c20 <buttonCheck+0x574>
			if (currentPreset <= 0) currentPreset = PresetNil - 1;
   25e08:	2311      	movs	r3, #17
   25e0a:	e6bf      	b.n	25b8c <buttonCheck+0x4e0>
	if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
   25e0c:	f64e 3390 	movw	r3, #60304	; 0xeb90
   25e10:	f2c0 230f 	movt	r3, #527	; 0x20f
   25e14:	5c5b      	ldrb	r3, [r3, r1]
   25e16:	3b01      	subs	r3, #1
   25e18:	b2db      	uxtb	r3, r3
   25e1a:	e5ac      	b.n	25976 <buttonCheck+0x2ca>
		calculateNoteArray();
   25e1c:	f7fd feea 	bl	23bf4 <calculateNoteArray>
   25e20:	e766      	b.n	25cf0 <buttonCheck+0x644>
				keyCenter = (keyCenter + 1) % 12;
   25e22:	f646 15b8 	movw	r5, #27064	; 0x69b8
   25e26:	f64a 23ab 	movw	r3, #43691	; 0xaaab
				OLEDclearLine(SecondLine);
   25e2a:	4620      	mov	r0, r4
				keyCenter = (keyCenter + 1) % 12;
   25e2c:	f2c0 250e 	movt	r5, #526	; 0x20e
   25e30:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
   25e34:	782a      	ldrb	r2, [r5, #0]
   25e36:	3201      	adds	r2, #1
   25e38:	fba3 1302 	umull	r1, r3, r3, r2
   25e3c:	08db      	lsrs	r3, r3, #3
   25e3e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   25e42:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
   25e46:	702b      	strb	r3, [r5, #0]
				OLEDclearLine(SecondLine);
   25e48:	f7f5 fc14 	bl	1b674 <OLEDclearLine>
				OLEDwriteString("KEY: ", 5, 0, SecondLine);
   25e4c:	f645 0088 	movw	r0, #22664	; 0x5888
   25e50:	2200      	movs	r2, #0
   25e52:	4623      	mov	r3, r4
   25e54:	2105      	movs	r1, #5
   25e56:	f2c0 0003 	movt	r0, #3
   25e5a:	f7f5 fc21 	bl	1b6a0 <OLEDwriteString>
				OLEDwritePitchClass(keyCenter+60, 64, SecondLine);
   25e5e:	782b      	ldrb	r3, [r5, #0]
   25e60:	4621      	mov	r1, r4
   25e62:	2040      	movs	r0, #64	; 0x40
   25e64:	333c      	adds	r3, #60	; 0x3c
   25e66:	ee00 3a10 	vmov	s0, r3
   25e6a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   25e6e:	f7f5 fcc1 	bl	1b7f4 <OLEDwritePitchClass>
				buttonActionsSFX[ButtonC][ActionPress] = 0;
   25e72:	f64e 227c 	movw	r2, #60028	; 0xea7c
				buttonActionsUI[ButtonC][ActionPress] = 0;
   25e76:	2300      	movs	r3, #0
				buttonActionsSFX[ButtonC][ActionPress] = 0;
   25e78:	f2c0 220f 	movt	r2, #527	; 0x20f
				buttonActionsUI[ButtonC][ActionPress] = 0;
   25e7c:	7733      	strb	r3, [r6, #28]
				buttonActionsSFX[ButtonC][ActionPress] = 0;
   25e7e:	7713      	strb	r3, [r2, #28]
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   25e80:	70f3      	strb	r3, [r6, #3]
   25e82:	e53f      	b.n	25904 <buttonCheck+0x258>

00025e84 <adcCheck>:
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   25e84:	f247 5120 	movw	r1, #29984	; 0x7520
   25e88:	f04f 526a 	mov.w	r2, #981467136	; 0x3a800000
   25e8c:	f64e 2364 	movw	r3, #60004	; 0xea64
   25e90:	f2c0 0106 	movt	r1, #6
   25e94:	ee07 2a90 	vmov	s15, r2
   25e98:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   25e9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   25ea0:	880c      	ldrh	r4, [r1, #0]
	if (firstADCPass)
   25ea2:	f246 25cc 	movw	r5, #25292	; 0x62cc
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   25ea6:	8848      	ldrh	r0, [r1, #2]
{
   25ea8:	b083      	sub	sp, #12
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   25eaa:	888a      	ldrh	r2, [r1, #4]
   25eac:	09a4      	lsrs	r4, r4, #6
   25eae:	0980      	lsrs	r0, r0, #6
	if (firstADCPass)
   25eb0:	f2c0 0506 	movt	r5, #6
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   25eb4:	ee04 4a90 	vmov	s9, r4
   25eb8:	0992      	lsrs	r2, r2, #6
   25eba:	88cc      	ldrh	r4, [r1, #6]
   25ebc:	ee05 0a10 	vmov	s10, r0
   25ec0:	ee05 2a90 	vmov	s11, r2
   25ec4:	8908      	ldrh	r0, [r1, #8]
   25ec6:	894a      	ldrh	r2, [r1, #10]
   25ec8:	09a1      	lsrs	r1, r4, #6
   25eca:	eef8 4ae4 	vcvt.f32.s32	s9, s9
   25ece:	ee06 1a10 	vmov	s12, r1
   25ed2:	0992      	lsrs	r2, r2, #6
   25ed4:	0981      	lsrs	r1, r0, #6
   25ed6:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
   25eda:	ee07 2a10 	vmov	s14, r2
   25ede:	eef8 5ae5 	vcvt.f32.s32	s11, s11
   25ee2:	ee06 1a90 	vmov	s13, r1
   25ee6:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   25eea:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	if (firstADCPass)
   25eee:	6829      	ldr	r1, [r5, #0]
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   25ef0:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   25ef4:	ee64 4aa7 	vmul.f32	s9, s9, s15
   25ef8:	ee25 5a27 	vmul.f32	s10, s10, s15
   25efc:	ee65 5aa7 	vmul.f32	s11, s11, s15
   25f00:	ee26 6a27 	vmul.f32	s12, s12, s15
   25f04:	edc3 4a00 	vstr	s9, [r3]
   25f08:	ee66 6aa7 	vmul.f32	s13, s13, s15
   25f0c:	ed83 5a01 	vstr	s10, [r3, #4]
   25f10:	ee67 7a27 	vmul.f32	s15, s14, s15
   25f14:	edc3 5a02 	vstr	s11, [r3, #8]
   25f18:	ed83 6a03 	vstr	s12, [r3, #12]
   25f1c:	edc3 6a04 	vstr	s13, [r3, #16]
   25f20:	edc3 7a05 	vstr	s15, [r3, #20]
	if (firstADCPass)
   25f24:	b161      	cbz	r1, 25f40 <adcCheck+0xbc>
   25f26:	461c      	mov	r4, r3
   25f28:	f64e 46b4 	movw	r6, #60596	; 0xecb4
		firstADCPass = 0;
   25f2c:	2300      	movs	r3, #0
   25f2e:	f2c0 260f 	movt	r6, #527	; 0x20f
   25f32:	602b      	str	r3, [r5, #0]
   25f34:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   25f36:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   25f38:	e894 0003 	ldmia.w	r4, {r0, r1}
   25f3c:	e886 0003 	stmia.w	r6, {r0, r1}
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   25f40:	f24a 6308 	movw	r3, #42504	; 0xa608
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   25f44:	f64e 42a0 	movw	r2, #60576	; 0xeca0
   25f48:	f64e 2564 	movw	r5, #60004	; 0xea64
   25f4c:	f64e 46b4 	movw	r6, #60596	; 0xecb4
   25f50:	f64e 34a4 	movw	r4, #60324	; 0xeba4
   25f54:	f24a 6768 	movw	r7, #42600	; 0xa668
   25f58:	f246 28bc 	movw	r8, #25276	; 0x62bc
   25f5c:	f64d 49b0 	movw	r9, #56496	; 0xdcb0
				else writeKnobFlag = i;
   25f60:	f246 2ad3 	movw	sl, #25299	; 0x62d3
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   25f64:	f2c0 230f 	movt	r3, #527	; 0x20f
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   25f68:	f2c0 220f 	movt	r2, #527	; 0x20f
   25f6c:	f2c0 250f 	movt	r5, #527	; 0x20f
   25f70:	f2c0 260f 	movt	r6, #527	; 0x20f
   25f74:	f2c0 240f 	movt	r4, #527	; 0x20f
   25f78:	f2c0 270f 	movt	r7, #527	; 0x20f
   25f7c:	f2c0 0806 	movt	r8, #6
   25f80:	f2c0 290f 	movt	r9, #527	; 0x20f
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   25f84:	9300      	str	r3, [sp, #0]
				else writeKnobFlag = i;
   25f86:	f2c0 0a06 	movt	sl, #6
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   25f8a:	9201      	str	r2, [sp, #4]
{
   25f8c:	f04f 0b00 	mov.w	fp, #0
   25f90:	e03a      	b.n	26008 <adcCheck+0x184>
			if (buttonActionsUI[ButtonEdit][ActionHoldContinuous])
   25f92:	f64e 32bc 	movw	r2, #60348	; 0xebbc
   25f96:	f2c0 220f 	movt	r2, #527	; 0x20f
   25f9a:	78d1      	ldrb	r1, [r2, #3]
   25f9c:	b199      	cbz	r1, 25fc6 <adcCheck+0x142>
				if (i != 5) cvAddParam[currentPreset] = i + (knobPage * KNOB_PAGE_SIZE);;
   25f9e:	f1bb 0f05 	cmp.w	fp, #5
   25fa2:	d00e      	beq.n	25fc2 <adcCheck+0x13e>
   25fa4:	f646 11ba 	movw	r1, #27066	; 0x69ba
   25fa8:	f646 10b9 	movw	r0, #27065	; 0x69b9
   25fac:	9b01      	ldr	r3, [sp, #4]
   25fae:	f2c0 210e 	movt	r1, #526	; 0x20e
   25fb2:	f2c0 200e 	movt	r0, #526	; 0x20e
   25fb6:	7809      	ldrb	r1, [r1, #0]
   25fb8:	7800      	ldrb	r0, [r0, #0]
   25fba:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   25fbe:	4459      	add	r1, fp
   25fc0:	5419      	strb	r1, [r3, r0]
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   25fc2:	2100      	movs	r1, #0
   25fc4:	70d1      	strb	r1, [r2, #3]
			lastFloatADC[i] = floatADC[i];
   25fc6:	ed15 0a01 	vldr	s0, [r5, #-4]
			if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   25fca:	f1bb 0f05 	cmp.w	fp, #5
			lastFloatADC[i] = floatADC[i];
   25fce:	ed06 0a01 	vstr	s0, [r6, #-4]
			if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   25fd2:	d065      	beq.n	260a0 <adcCheck+0x21c>
			else writeKnobFlag = i;
   25fd4:	fa4f f28b 	sxtb.w	r2, fp
		if (floatADCUI[i] >= 0.0f)
   25fd8:	edd4 7a00 	vldr	s15, [r4]
			knobActive[i] = 1;
   25fdc:	2101      	movs	r1, #1
   25fde:	f88a 2000 	strb.w	r2, [sl]
		if (floatADCUI[i] >= 0.0f)
   25fe2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
			knobActive[i] = 1;
   25fe6:	f809 100b 	strb.w	r1, [r9, fp]
		if (floatADCUI[i] >= 0.0f)
   25fea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25fee:	da28      	bge.n	26042 <adcCheck+0x1be>
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   25ff0:	9b00      	ldr	r3, [sp, #0]
   25ff2:	eb03 008b 	add.w	r0, r3, fp, lsl #2
   25ff6:	f005 f9df 	bl	2b3b8 <tExpSmooth_setDest>
	for (int i = 0; i < 6; i++)
   25ffa:	f10b 0b01 	add.w	fp, fp, #1
   25ffe:	3404      	adds	r4, #4
   26000:	3704      	adds	r7, #4
   26002:	f1bb 0f06 	cmp.w	fp, #6
   26006:	d048      	beq.n	2609a <adcCheck+0x216>
		if (fastabsf(floatADC[i] - lastFloatADC[i]) > adcHysteresisThreshold)
   26008:	ecf6 7a01 	vldmia	r6!, {s15}
   2600c:	ecb5 0a01 	vldmia	r5!, {s0}
   26010:	ee30 0a67 	vsub.f32	s0, s0, s15
   26014:	f006 fdf8 	bl	2cc08 <fastabsf>
   26018:	edd8 7a00 	vldr	s15, [r8]
   2601c:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26024:	dcb5      	bgt.n	25f92 <adcCheck+0x10e>
		if (floatADCUI[i] >= 0.0f)
   26026:	edd4 7a00 	vldr	s15, [r4]
   2602a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2602e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26032:	da06      	bge.n	26042 <adcCheck+0x1be>
   26034:	f819 200b 	ldrb.w	r2, [r9, fp]
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   26038:	2a00      	cmp	r2, #0
   2603a:	d0de      	beq.n	25ffa <adcCheck+0x176>
   2603c:	ed15 0a01 	vldr	s0, [r5, #-4]
   26040:	e7d6      	b.n	25ff0 <adcCheck+0x16c>
			if (fastabsf(smoothedADC[i] - floatADCUI[i]) > adcHysteresisThreshold)
   26042:	ed97 0a00 	vldr	s0, [r7]
   26046:	ee30 0a67 	vsub.f32	s0, s0, s15
   2604a:	f006 fddd 	bl	2cc08 <fastabsf>
   2604e:	edd8 7a00 	vldr	s15, [r8]
   26052:	f819 200b 	ldrb.w	r2, [r9, fp]
   26056:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2605a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2605e:	ddeb      	ble.n	26038 <adcCheck+0x1b4>
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   26060:	f1bb 0f05 	cmp.w	fp, #5
   26064:	d004      	beq.n	26070 <adcCheck+0x1ec>
				else writeKnobFlag = i;
   26066:	f88a b000 	strb.w	fp, [sl]
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   2606a:	2a00      	cmp	r2, #0
   2606c:	d0c5      	beq.n	25ffa <adcCheck+0x176>
   2606e:	e7e5      	b.n	2603c <adcCheck+0x1b8>
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   26070:	f646 11ba 	movw	r1, #27066	; 0x69ba
   26074:	f646 10b9 	movw	r0, #27065	; 0x69b9
   26078:	9b01      	ldr	r3, [sp, #4]
   2607a:	f2c0 210e 	movt	r1, #526	; 0x20e
   2607e:	f2c0 200e 	movt	r0, #526	; 0x20e
   26082:	7809      	ldrb	r1, [r1, #0]
   26084:	7800      	ldrb	r0, [r0, #0]
   26086:	ebc1 1c81 	rsb	ip, r1, r1, lsl #6
   2608a:	5c18      	ldrb	r0, [r3, r0]
   2608c:	ebc1 018c 	rsb	r1, r1, ip, lsl #2
   26090:	4401      	add	r1, r0
   26092:	f88a 1000 	strb.w	r1, [sl]
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   26096:	2a00      	cmp	r2, #0
   26098:	d1d0      	bne.n	2603c <adcCheck+0x1b8>
}
   2609a:	b003      	add	sp, #12
   2609c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   260a0:	f646 11ba 	movw	r1, #27066	; 0x69ba
   260a4:	f646 12b9 	movw	r2, #27065	; 0x69b9
   260a8:	9b01      	ldr	r3, [sp, #4]
   260aa:	f2c0 210e 	movt	r1, #526	; 0x20e
   260ae:	f2c0 220e 	movt	r2, #526	; 0x20e
   260b2:	7809      	ldrb	r1, [r1, #0]
   260b4:	7812      	ldrb	r2, [r2, #0]
   260b6:	ebc1 1081 	rsb	r0, r1, r1, lsl #6
   260ba:	5c9a      	ldrb	r2, [r3, r2]
   260bc:	ebc1 0180 	rsb	r1, r1, r0, lsl #2
   260c0:	440a      	add	r2, r1
   260c2:	b252      	sxtb	r2, r2
   260c4:	e788      	b.n	25fd8 <adcCheck+0x154>
   260c6:	bf00      	nop

000260c8 <resetKnobValues>:
{
   260c8:	f24a 6368 	movw	r3, #42600	; 0xa668
		floatADCUI[i] = -1.0f;
   260cc:	2000      	movs	r0, #0
		knobActive[i] = 0;
   260ce:	f04f 0c00 	mov.w	ip, #0
		floatADCUI[i] = -1.0f;
   260d2:	f6cb 7080 	movt	r0, #49024	; 0xbf80
   260d6:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   260da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		knobActive[i] = 0;
   260de:	f64d 49b0 	movw	r9, #56496	; 0xdcb0
		floatADCUI[i] = -1.0f;
   260e2:	f64e 3ba4 	movw	fp, #60324	; 0xeba4
   260e6:	f24a 6508 	movw	r5, #42504	; 0xa608
   260ea:	f64c 2878 	movw	r8, #51832	; 0xca78
   260ee:	f646 17b9 	movw	r7, #27065	; 0x69b9
   260f2:	f646 16ba 	movw	r6, #27066	; 0x69ba
		knobActive[i] = 0;
   260f6:	f2c0 290f 	movt	r9, #527	; 0x20f
		floatADCUI[i] = -1.0f;
   260fa:	f2c0 2b0f 	movt	fp, #527	; 0x20f
	for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   260fe:	4664      	mov	r4, ip
   26100:	469a      	mov	sl, r3
   26102:	f2c0 250f 	movt	r5, #527	; 0x20f
   26106:	f2c0 280f 	movt	r8, #527	; 0x20f
   2610a:	f2c0 270e 	movt	r7, #526	; 0x20e
   2610e:	f2c0 260e 	movt	r6, #526	; 0x20e
		knobActive[i] = 0;
   26112:	f809 cb01 	strb.w	ip, [r9], #1
		floatADCUI[i] = -1.0f;
   26116:	f84b 0b04 	str.w	r0, [fp], #4
{
   2611a:	ed2d 8b02 	vpush	{d8}
		floatADCUI[i] = -1.0f;
   2611e:	ee08 0a90 	vmov	s17, r0
{
   26122:	b083      	sub	sp, #12
   26124:	9301      	str	r3, [sp, #4]
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   26126:	783b      	ldrb	r3, [r7, #0]
   26128:	2105      	movs	r1, #5
   2612a:	7832      	ldrb	r2, [r6, #0]
		tExpSmooth_setValAndDest(&adc[i], value);
   2612c:	4628      	mov	r0, r5
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   2612e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   26132:	3504      	adds	r5, #4
   26134:	fb11 4202 	smlabb	r2, r1, r2, r4
	for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   26138:	3401      	adds	r4, #1
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   2613a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   2613e:	4413      	add	r3, r2
   26140:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   26144:	ed93 8a00 	vldr	s16, [r3]
		tExpSmooth_setValAndDest(&adc[i], value);
   26148:	eeb0 0a48 	vmov.f32	s0, s16
   2614c:	f005 f938 	bl	2b3c0 <tExpSmooth_setValAndDest>
		knobActive[i] = 0;
   26150:	f04f 0300 	mov.w	r3, #0
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   26154:	2c05      	cmp	r4, #5
		smoothedADC[i] = value;
   26156:	ecaa 8a01 	vstmia	sl!, {s16}
		knobActive[i] = 0;
   2615a:	f809 3b01 	strb.w	r3, [r9], #1
		floatADCUI[i] = -1.0f;
   2615e:	eceb 8a01 	vstmia	fp!, {s17}
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   26162:	d1e0      	bne.n	26126 <resetKnobValues+0x5e>
		tExpSmooth_setValAndDest(&adc[i], value);
   26164:	2300      	movs	r3, #0
   26166:	f24a 601c 	movw	r0, #42524	; 0xa61c
   2616a:	ee00 3a10 	vmov	s0, r3
   2616e:	f2c0 200f 	movt	r0, #527	; 0x20f
   26172:	ee08 3a10 	vmov	s16, r3
   26176:	f005 f923 	bl	2b3c0 <tExpSmooth_setValAndDest>
		smoothedADC[i] = value;
   2617a:	9b01      	ldr	r3, [sp, #4]
   2617c:	ed83 8a05 	vstr	s16, [r3, #20]
}
   26180:	b003      	add	sp, #12
   26182:	ecbd 8b02 	vpop	{d8}
   26186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2618a:	bf00      	nop

0002618c <UIVocoderButtons>:
}

char* UIVocoderButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2618c:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   26190:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   26194:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   26196:	7d1a      	ldrb	r2, [r3, #20]
   26198:	2a01      	cmp	r2, #1
   2619a:	d030      	beq.n	261fe <UIVocoderButtons+0x72>
	char* writeString = "";
   2619c:	f645 000c 	movw	r0, #22540	; 0x580c
   261a0:	f2c0 0003 	movt	r0, #3
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   261a4:	7e1a      	ldrb	r2, [r3, #24]
   261a6:	2a01      	cmp	r2, #1
   261a8:	d111      	bne.n	261ce <UIVocoderButtons+0x42>
	{
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   261aa:	f646 1104 	movw	r1, #26884	; 0x6904
   261ae:	f645 0040 	movw	r0, #22592	; 0x5840
   261b2:	f645 024c 	movw	r2, #22604	; 0x584c
		buttonActionsUI[ButtonB][ActionPress] = 0;
   261b6:	2400      	movs	r4, #0
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   261b8:	f2c0 210e 	movt	r1, #526	; 0x20e
   261bc:	f2c0 0003 	movt	r0, #3
   261c0:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonB][ActionPress] = 0;
   261c4:	761c      	strb	r4, [r3, #24]
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   261c6:	7809      	ldrb	r1, [r1, #0]
   261c8:	42a1      	cmp	r1, r4
   261ca:	bf08      	it	eq
   261cc:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   261ce:	7f1a      	ldrb	r2, [r3, #28]
   261d0:	2a01      	cmp	r2, #1
   261d2:	d111      	bne.n	261f8 <UIVocoderButtons+0x6c>
	{
		writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   261d4:	f646 117c 	movw	r1, #27004	; 0x697c
		buttonActionsUI[ButtonC][ActionPress] = 0;
   261d8:	2400      	movs	r4, #0
		writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   261da:	f645 0058 	movw	r0, #22616	; 0x5858
   261de:	f645 0260 	movw	r2, #22624	; 0x5860
   261e2:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonC][ActionPress] = 0;
   261e6:	771c      	strb	r4, [r3, #28]
		writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   261e8:	f2c0 0003 	movt	r0, #3
   261ec:	f2c0 0203 	movt	r2, #3
   261f0:	680b      	ldr	r3, [r1, #0]
   261f2:	42a3      	cmp	r3, r4
   261f4:	bf08      	it	eq
   261f6:	4610      	moveq	r0, r2
	}
	return writeString;
}
   261f8:	f85d 4b04 	ldr.w	r4, [sp], #4
   261fc:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   261fe:	f246 2154 	movw	r1, #25172	; 0x6254
   26202:	f645 0030 	movw	r0, #22576	; 0x5830
   26206:	f645 0238 	movw	r2, #22584	; 0x5838
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2620a:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   2620c:	f2c0 0106 	movt	r1, #6
   26210:	f2c0 0003 	movt	r0, #3
   26214:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   26218:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   2621a:	7809      	ldrb	r1, [r1, #0]
   2621c:	2901      	cmp	r1, #1
   2621e:	bf98      	it	ls
   26220:	4610      	movls	r0, r2
   26222:	e7bf      	b.n	261a4 <UIVocoderButtons+0x18>

00026224 <UIVocoderChButtons>:

char* UIVocoderChButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   26224:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   26228:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   2622c:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2622e:	7d1a      	ldrb	r2, [r3, #20]
   26230:	2a01      	cmp	r2, #1
   26232:	d030      	beq.n	26296 <UIVocoderChButtons+0x72>
	char* writeString = "";
   26234:	f645 000c 	movw	r0, #22540	; 0x580c
   26238:	f2c0 0003 	movt	r0, #3
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2623c:	7e1a      	ldrb	r2, [r3, #24]
   2623e:	2a01      	cmp	r2, #1
   26240:	d111      	bne.n	26266 <UIVocoderChButtons+0x42>
	{
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   26242:	f646 1104 	movw	r1, #26884	; 0x6904
   26246:	f645 0040 	movw	r0, #22592	; 0x5840
   2624a:	f645 024c 	movw	r2, #22604	; 0x584c
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2624e:	2400      	movs	r4, #0
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   26250:	f2c0 210e 	movt	r1, #526	; 0x20e
   26254:	f2c0 0003 	movt	r0, #3
   26258:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2625c:	761c      	strb	r4, [r3, #24]
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   2625e:	7809      	ldrb	r1, [r1, #0]
   26260:	42a1      	cmp	r1, r4
   26262:	bf08      	it	eq
   26264:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   26266:	7f1a      	ldrb	r2, [r3, #28]
   26268:	2a01      	cmp	r2, #1
   2626a:	d111      	bne.n	26290 <UIVocoderChButtons+0x6c>
	{
		writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   2626c:	f646 1178 	movw	r1, #27000	; 0x6978
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26270:	2400      	movs	r4, #0
		writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   26272:	f645 0058 	movw	r0, #22616	; 0x5858
   26276:	f645 0260 	movw	r2, #22624	; 0x5860
   2627a:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonC][ActionPress] = 0;
   2627e:	771c      	strb	r4, [r3, #28]
		writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   26280:	f2c0 0003 	movt	r0, #3
   26284:	f2c0 0203 	movt	r2, #3
   26288:	680b      	ldr	r3, [r1, #0]
   2628a:	42a3      	cmp	r3, r4
   2628c:	bf08      	it	eq
   2628e:	4610      	moveq	r0, r2
	}
	return writeString;
}
   26290:	f85d 4b04 	ldr.w	r4, [sp], #4
   26294:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   26296:	f246 2154 	movw	r1, #25172	; 0x6254
   2629a:	f645 0030 	movw	r0, #22576	; 0x5830
   2629e:	f645 0238 	movw	r2, #22584	; 0x5838
		buttonActionsUI[ButtonA][ActionPress] = 0;
   262a2:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   262a4:	f2c0 0106 	movt	r1, #6
   262a8:	f2c0 0003 	movt	r0, #3
   262ac:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   262b0:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   262b2:	7809      	ldrb	r1, [r1, #0]
   262b4:	2901      	cmp	r1, #1
   262b6:	bf98      	it	ls
   262b8:	4610      	movls	r0, r2
   262ba:	e7bf      	b.n	2623c <UIVocoderChButtons+0x18>

000262bc <UIPitchShiftButtons>:

char* UIPitchShiftButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	return writeString;
}
   262bc:	f645 000c 	movw	r0, #22540	; 0x580c
   262c0:	f2c0 0003 	movt	r0, #3
   262c4:	4770      	bx	lr
   262c6:	bf00      	nop

000262c8 <UINeartuneButtons>:

char* UINeartuneButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   262c8:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   262cc:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   262d0:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress])
   262d2:	7d1a      	ldrb	r2, [r3, #20]
   262d4:	b342      	cbz	r2, 26328 <UINeartuneButtons+0x60>
	{
		writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   262d6:	f646 0184 	movw	r1, #26756	; 0x6884
   262da:	f245 7034 	movw	r0, #22324	; 0x5734
   262de:	f245 7244 	movw	r2, #22340	; 0x5744
		buttonActionsUI[ButtonA][ActionPress] = 0;
   262e2:	2400      	movs	r4, #0
		writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   262e4:	f2c0 210e 	movt	r1, #526	; 0x20e
   262e8:	f2c0 0003 	movt	r0, #3
   262ec:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   262f0:	751c      	strb	r4, [r3, #20]
		writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   262f2:	7809      	ldrb	r1, [r1, #0]
   262f4:	42a1      	cmp	r1, r4
   262f6:	bf08      	it	eq
   262f8:	4610      	moveq	r0, r2
	}

	if (buttonActionsUI[ButtonC][ActionPress])
   262fa:	7f1a      	ldrb	r2, [r3, #28]
   262fc:	b18a      	cbz	r2, 26322 <UINeartuneButtons+0x5a>
	{
		writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   262fe:	f646 0188 	movw	r1, #26760	; 0x6888
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26302:	2400      	movs	r4, #0
		writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   26304:	f245 7054 	movw	r0, #22356	; 0x5754
   26308:	f245 7264 	movw	r2, #22372	; 0x5764
   2630c:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26310:	771c      	strb	r4, [r3, #28]
		writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   26312:	f2c0 0003 	movt	r0, #3
   26316:	f2c0 0203 	movt	r2, #3
   2631a:	680b      	ldr	r3, [r1, #0]
   2631c:	42a3      	cmp	r3, r4
   2631e:	bf08      	it	eq
   26320:	4610      	moveq	r0, r2
	}


	return writeString;
}
   26322:	f85d 4b04 	ldr.w	r4, [sp], #4
   26326:	4770      	bx	lr
	char* writeString = "";
   26328:	f645 000c 	movw	r0, #22540	; 0x580c
   2632c:	f2c0 0003 	movt	r0, #3
   26330:	e7e3      	b.n	262fa <UINeartuneButtons+0x32>
   26332:	bf00      	nop

00026334 <UIAutotuneButtons>:
   26334:	f645 000c 	movw	r0, #22540	; 0x580c
   26338:	f2c0 0003 	movt	r0, #3
   2633c:	4770      	bx	lr
   2633e:	bf00      	nop

00026340 <UISamplerBPButtons>:
	char* writeString = "";
	return writeString;
}

char* UISamplerBPButtons(VocodecButton button, ButtonAction action)
{
   26340:	b538      	push	{r3, r4, r5, lr}
	char* writeString = "";
	if (buttonActionsUI[ButtonC][ActionPress])
   26342:	f64e 34bc 	movw	r4, #60348	; 0xebbc
   26346:	f2c0 240f 	movt	r4, #527	; 0x20f
   2634a:	7f23      	ldrb	r3, [r4, #28]
   2634c:	2b00      	cmp	r3, #0
   2634e:	d163      	bne.n	26418 <UISamplerBPButtons+0xd8>
		OLEDwriteFloat(sampleLength, 0, SecondLine);
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
		buttonActionsUI[ButtonC][ActionPress] = 0;
	}

	if (buttonActionsUI[ButtonB][ActionPress])
   26350:	7e23      	ldrb	r3, [r4, #24]
   26352:	2b00      	cmp	r3, #0
   26354:	d145      	bne.n	263e2 <UISamplerBPButtons+0xa2>
	{
		OLEDclearLine(SecondLine);
		OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
		buttonActionsUI[ButtonB][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonA][ActionHoldContinuous])
   26356:	7de3      	ldrb	r3, [r4, #23]
   26358:	bb53      	cbnz	r3, 263b0 <UISamplerBPButtons+0x70>
		OLEDclearLine(SecondLine);
		OLEDwriteString("RECORDING", 9, 0, SecondLine);
		OLEDwriteFloat(sampleLength, 84, SecondLine);
		buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
	}
	if (buttonActionsUI[ButtonA][ActionRelease])
   2635a:	7d63      	ldrb	r3, [r4, #21]
   2635c:	b31b      	cbz	r3, 263a6 <UISamplerBPButtons+0x66>
	{
		OLEDclearLine(SecondLine);
   2635e:	2001      	movs	r0, #1
   26360:	f7f5 f988 	bl	1b674 <OLEDclearLine>
		OLEDwriteFloat(sampleLength, 0, SecondLine);
   26364:	f646 1364 	movw	r3, #26980	; 0x6964
   26368:	2101      	movs	r1, #1
   2636a:	2000      	movs	r0, #0
   2636c:	f2c0 230e 	movt	r3, #526	; 0x20e
   26370:	ed93 0a00 	vldr	s0, [r3]
   26374:	f7f5 fa78 	bl	1b868 <OLEDwriteFloat>
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   26378:	f246 22a8 	movw	r2, #25256	; 0x62a8
   2637c:	f245 70e0 	movw	r0, #22496	; 0x57e0
   26380:	f245 71e8 	movw	r1, #22504	; 0x57e8
   26384:	f2c0 0206 	movt	r2, #6
   26388:	2301      	movs	r3, #1
   2638a:	f2c0 0103 	movt	r1, #3
   2638e:	f2c0 0003 	movt	r0, #3
   26392:	7815      	ldrb	r5, [r2, #0]
   26394:	2230      	movs	r2, #48	; 0x30
   26396:	2d00      	cmp	r5, #0
   26398:	bf08      	it	eq
   2639a:	4608      	moveq	r0, r1
   2639c:	2107      	movs	r1, #7
   2639e:	f7f5 f97f 	bl	1b6a0 <OLEDwriteString>
		buttonActionsUI[ButtonA][ActionRelease] = 0;
   263a2:	2300      	movs	r3, #0
   263a4:	7563      	strb	r3, [r4, #21]
	}
	return writeString;
}
   263a6:	f645 000c 	movw	r0, #22540	; 0x580c
   263aa:	f2c0 0003 	movt	r0, #3
   263ae:	bd38      	pop	{r3, r4, r5, pc}
		OLEDclearLine(SecondLine);
   263b0:	2001      	movs	r0, #1
   263b2:	f7f5 f95f 	bl	1b674 <OLEDclearLine>
		OLEDwriteString("RECORDING", 9, 0, SecondLine);
   263b6:	f645 0010 	movw	r0, #22544	; 0x5810
   263ba:	2301      	movs	r3, #1
   263bc:	2200      	movs	r2, #0
   263be:	f2c0 0003 	movt	r0, #3
   263c2:	2109      	movs	r1, #9
   263c4:	f7f5 f96c 	bl	1b6a0 <OLEDwriteString>
		OLEDwriteFloat(sampleLength, 84, SecondLine);
   263c8:	f646 1364 	movw	r3, #26980	; 0x6964
   263cc:	2101      	movs	r1, #1
   263ce:	2054      	movs	r0, #84	; 0x54
   263d0:	f2c0 230e 	movt	r3, #526	; 0x20e
   263d4:	ed93 0a00 	vldr	s0, [r3]
   263d8:	f7f5 fa46 	bl	1b868 <OLEDwriteFloat>
		buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
   263dc:	2300      	movs	r3, #0
   263de:	75e3      	strb	r3, [r4, #23]
   263e0:	e7bb      	b.n	2635a <UISamplerBPButtons+0x1a>
		OLEDclearLine(SecondLine);
   263e2:	2001      	movs	r0, #1
   263e4:	f7f5 f946 	bl	1b674 <OLEDclearLine>
		OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
   263e8:	f646 028c 	movw	r2, #26764	; 0x688c
   263ec:	f245 70f0 	movw	r0, #22512	; 0x57f0
   263f0:	f645 0100 	movw	r1, #22528	; 0x5800
   263f4:	f2c0 220e 	movt	r2, #526	; 0x20e
   263f8:	2301      	movs	r3, #1
   263fa:	f2c0 0103 	movt	r1, #3
   263fe:	f2c0 0003 	movt	r0, #3
   26402:	6815      	ldr	r5, [r2, #0]
   26404:	2200      	movs	r2, #0
   26406:	4295      	cmp	r5, r2
   26408:	bf08      	it	eq
   2640a:	4608      	moveq	r0, r1
   2640c:	210c      	movs	r1, #12
   2640e:	f7f5 f947 	bl	1b6a0 <OLEDwriteString>
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26412:	2300      	movs	r3, #0
   26414:	7623      	strb	r3, [r4, #24]
   26416:	e79e      	b.n	26356 <UISamplerBPButtons+0x16>
		OLEDclearLine(SecondLine);
   26418:	2001      	movs	r0, #1
   2641a:	f7f5 f92b 	bl	1b674 <OLEDclearLine>
		OLEDwriteFloat(sampleLength, 0, SecondLine);
   2641e:	f646 1364 	movw	r3, #26980	; 0x6964
   26422:	2101      	movs	r1, #1
   26424:	2000      	movs	r0, #0
   26426:	f2c0 230e 	movt	r3, #526	; 0x20e
   2642a:	ed93 0a00 	vldr	s0, [r3]
   2642e:	f7f5 fa1b 	bl	1b868 <OLEDwriteFloat>
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   26432:	f246 22a8 	movw	r2, #25256	; 0x62a8
   26436:	f245 70e0 	movw	r0, #22496	; 0x57e0
   2643a:	f245 71e8 	movw	r1, #22504	; 0x57e8
   2643e:	f2c0 0206 	movt	r2, #6
   26442:	2301      	movs	r3, #1
   26444:	f2c0 0103 	movt	r1, #3
   26448:	f2c0 0003 	movt	r0, #3
   2644c:	7815      	ldrb	r5, [r2, #0]
   2644e:	2230      	movs	r2, #48	; 0x30
   26450:	2d00      	cmp	r5, #0
   26452:	bf08      	it	eq
   26454:	4608      	moveq	r0, r1
   26456:	2107      	movs	r1, #7
   26458:	f7f5 f922 	bl	1b6a0 <OLEDwriteString>
		buttonActionsUI[ButtonC][ActionPress] = 0;
   2645c:	2300      	movs	r3, #0
   2645e:	7723      	strb	r3, [r4, #28]
   26460:	e776      	b.n	26350 <UISamplerBPButtons+0x10>
   26462:	bf00      	nop

00026464 <UISamplerKButtons>:

char* UISamplerKButtons(VocodecButton button, ButtonAction action)
{
   26464:	b510      	push	{r4, lr}
	char* writeString = "";


	if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
   26466:	f64e 34bc 	movw	r4, #60348	; 0xebbc
   2646a:	f2c0 240f 	movt	r4, #527	; 0x20f
   2646e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
{
   26472:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
   26476:	b9cb      	cbnz	r3, 264ac <UISamplerKButtons+0x48>
   26478:	7d23      	ldrb	r3, [r4, #20]
   2647a:	b9bb      	cbnz	r3, 264ac <UISamplerKButtons+0x48>
		OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
		buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}

	if (buttonActionsUI[ButtonB][ActionPress])
   2647c:	7e23      	ldrb	r3, [r4, #24]
   2647e:	2b00      	cmp	r3, #0
   26480:	d03b      	beq.n	264fa <UISamplerKButtons+0x96>
	{
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   26482:	f646 02c8 	movw	r2, #26824	; 0x68c8
   26486:	f645 001c 	movw	r0, #22556	; 0x581c
   2648a:	f645 0324 	movw	r3, #22564	; 0x5824
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2648e:	2100      	movs	r1, #0
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   26490:	f2c0 220e 	movt	r2, #526	; 0x20e
   26494:	f2c0 0003 	movt	r0, #3
   26498:	f2c0 0303 	movt	r3, #3
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2649c:	7621      	strb	r1, [r4, #24]
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   2649e:	6812      	ldr	r2, [r2, #0]
	}
	return writeString;
}
   264a0:	ecbd 8b02 	vpop	{d8}
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   264a4:	428a      	cmp	r2, r1
   264a6:	bf08      	it	eq
   264a8:	4618      	moveq	r0, r3
}
   264aa:	bd10      	pop	{r4, pc}
		OLEDclearLine(SecondLine);
   264ac:	2001      	movs	r0, #1
   264ae:	f7f5 f8e1 	bl	1b674 <OLEDclearLine>
		OLEDwritePitch(currentSamplerKeyGlobal + LOWEST_SAMPLER_KEY, 0, SecondLine, false);
   264b2:	f246 2324 	movw	r3, #25124	; 0x6224
   264b6:	2200      	movs	r2, #0
   264b8:	2101      	movs	r1, #1
   264ba:	f2c0 0306 	movt	r3, #6
   264be:	4610      	mov	r0, r2
   264c0:	681b      	ldr	r3, [r3, #0]
   264c2:	3324      	adds	r3, #36	; 0x24
   264c4:	ee00 3a10 	vmov	s0, r3
   264c8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   264cc:	f7f5 f958 	bl	1b780 <OLEDwritePitch>
		OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
   264d0:	f646 1364 	movw	r3, #26980	; 0x6964
   264d4:	f2c0 230e 	movt	r3, #526	; 0x20e
   264d8:	ed93 8a00 	vldr	s16, [r3]
   264dc:	f7f5 fbce 	bl	1bc7c <OLEDgetCursor>
   264e0:	2101      	movs	r1, #1
   264e2:	b2c0      	uxtb	r0, r0
   264e4:	eeb0 0a48 	vmov.f32	s0, s16
   264e8:	f7f5 f9be 	bl	1b868 <OLEDwriteFloat>
		buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
   264ec:	2300      	movs	r3, #0
   264ee:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
		buttonActionsUI[ButtonA][ActionPress] = 0;
   264f2:	7523      	strb	r3, [r4, #20]
	if (buttonActionsUI[ButtonB][ActionPress])
   264f4:	7e23      	ldrb	r3, [r4, #24]
   264f6:	2b00      	cmp	r3, #0
   264f8:	d1c3      	bne.n	26482 <UISamplerKButtons+0x1e>
	char* writeString = "";
   264fa:	f645 000c 	movw	r0, #22540	; 0x580c
}
   264fe:	ecbd 8b02 	vpop	{d8}
	char* writeString = "";
   26502:	f2c0 0003 	movt	r0, #3
}
   26506:	bd10      	pop	{r4, pc}

00026508 <UISamplerAutoButtons>:

char* UISamplerAutoButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   26508:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   2650c:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   26510:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress])
   26512:	7d1a      	ldrb	r2, [r3, #20]
   26514:	b1a2      	cbz	r2, 26540 <UISamplerAutoButtons+0x38>
	{
		if (samplerMode == PlayLoop)
   26516:	f246 22a9 	movw	r2, #25257	; 0x62a9
   2651a:	f2c0 0206 	movt	r2, #6
   2651e:	7812      	ldrb	r2, [r2, #0]
   26520:	2a01      	cmp	r2, #1
   26522:	d03c      	beq.n	2659e <UISamplerAutoButtons+0x96>
		{
			writeString = "LOOP";
		}
		else if (samplerMode == PlayBackAndForth)
		{
			writeString = "BACK'N'FORTH";
   26524:	f645 000c 	movw	r0, #22540	; 0x580c
   26528:	f245 71a0 	movw	r1, #22432	; 0x57a0
   2652c:	f2c0 0003 	movt	r0, #3
   26530:	f2c0 0103 	movt	r1, #3
   26534:	2a02      	cmp	r2, #2
   26536:	bf08      	it	eq
   26538:	4608      	moveq	r0, r1
		}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2653a:	2200      	movs	r2, #0
   2653c:	751a      	strb	r2, [r3, #20]
   2653e:	e003      	b.n	26548 <UISamplerAutoButtons+0x40>
	char* writeString = "";
   26540:	f645 000c 	movw	r0, #22540	; 0x580c
   26544:	f2c0 0003 	movt	r0, #3
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   26548:	7e1a      	ldrb	r2, [r3, #24]
   2654a:	b18a      	cbz	r2, 26570 <UISamplerAutoButtons+0x68>
	{
		writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   2654c:	f646 1175 	movw	r1, #26997	; 0x6975
   26550:	f245 70b0 	movw	r0, #22448	; 0x57b0
   26554:	f245 72bc 	movw	r2, #22460	; 0x57bc
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26558:	2400      	movs	r4, #0
		writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   2655a:	f2c0 210e 	movt	r1, #526	; 0x20e
   2655e:	f2c0 0003 	movt	r0, #3
   26562:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26566:	761c      	strb	r4, [r3, #24]
		writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   26568:	7809      	ldrb	r1, [r1, #0]
   2656a:	42a1      	cmp	r1, r4
   2656c:	bf08      	it	eq
   2656e:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress])
   26570:	7f1a      	ldrb	r2, [r3, #28]
   26572:	b18a      	cbz	r2, 26598 <UISamplerAutoButtons+0x90>
	{
		writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   26574:	f646 1144 	movw	r1, #26948	; 0x6944
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26578:	2400      	movs	r4, #0
		writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   2657a:	f245 70c8 	movw	r0, #22472	; 0x57c8
   2657e:	f245 72d4 	movw	r2, #22484	; 0x57d4
   26582:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26586:	771c      	strb	r4, [r3, #28]
		writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   26588:	f2c0 0003 	movt	r0, #3
   2658c:	f2c0 0203 	movt	r2, #3
   26590:	680b      	ldr	r3, [r1, #0]
   26592:	42a3      	cmp	r3, r4
   26594:	bf08      	it	eq
   26596:	4610      	moveq	r0, r2
	}
	return writeString;
}
   26598:	f85d 4b04 	ldr.w	r4, [sp], #4
   2659c:	4770      	bx	lr
			writeString = "LOOP";
   2659e:	f245 7098 	movw	r0, #22424	; 0x5798
   265a2:	f2c0 0003 	movt	r0, #3
   265a6:	e7c8      	b.n	2653a <UISamplerAutoButtons+0x32>

000265a8 <UIDistortionButtons>:

char* UIDistortionButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   265a8:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   265ac:	f2c0 230f 	movt	r3, #527	; 0x20f
   265b0:	7d1a      	ldrb	r2, [r3, #20]
   265b2:	b1aa      	cbz	r2, 265e0 <UIDistortionButtons+0x38>
	{
		writeString = distortionMode ? "SHAPER" : "TANH";
   265b4:	f646 01e4 	movw	r1, #26852	; 0x68e4
   265b8:	f245 60c4 	movw	r0, #22212	; 0x56c4
   265bc:	f245 62cc 	movw	r2, #22220	; 0x56cc
   265c0:	f2c0 210e 	movt	r1, #526	; 0x20e
   265c4:	f2c0 0003 	movt	r0, #3
   265c8:	f2c0 0203 	movt	r2, #3
{
   265cc:	b410      	push	{r4}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   265ce:	2400      	movs	r4, #0
   265d0:	751c      	strb	r4, [r3, #20]
		writeString = distortionMode ? "SHAPER" : "TANH";
   265d2:	780b      	ldrb	r3, [r1, #0]
   265d4:	42a3      	cmp	r3, r4
   265d6:	bf08      	it	eq
   265d8:	4610      	moveq	r0, r2
	}
	return writeString;
}
   265da:	f85d 4b04 	ldr.w	r4, [sp], #4
   265de:	4770      	bx	lr
	char* writeString = "";
   265e0:	f645 000c 	movw	r0, #22540	; 0x580c
   265e4:	f2c0 0003 	movt	r0, #3
}
   265e8:	4770      	bx	lr
   265ea:	bf00      	nop

000265ec <UIWaveFolderButtons>:

char* UIWaveFolderButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   265ec:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   265f0:	f2c0 230f 	movt	r3, #527	; 0x20f
   265f4:	7d1a      	ldrb	r2, [r3, #20]
   265f6:	b1aa      	cbz	r2, 26624 <UIWaveFolderButtons+0x38>
	{
		writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   265f8:	f646 01f4 	movw	r1, #26868	; 0x68f4
   265fc:	f645 006c 	movw	r0, #22636	; 0x586c
   26600:	f645 027c 	movw	r2, #22652	; 0x587c
   26604:	f2c0 210e 	movt	r1, #526	; 0x20e
   26608:	f2c0 0003 	movt	r0, #3
   2660c:	f2c0 0203 	movt	r2, #3
{
   26610:	b410      	push	{r4}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   26612:	2400      	movs	r4, #0
   26614:	751c      	strb	r4, [r3, #20]
		writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   26616:	680b      	ldr	r3, [r1, #0]
   26618:	42a3      	cmp	r3, r4
   2661a:	bf08      	it	eq
   2661c:	4610      	moveq	r0, r2
	}
	return writeString;
}
   2661e:	f85d 4b04 	ldr.w	r4, [sp], #4
   26622:	4770      	bx	lr
	char* writeString = "";
   26624:	f645 000c 	movw	r0, #22540	; 0x580c
   26628:	f2c0 0003 	movt	r0, #3
}
   2662c:	4770      	bx	lr
   2662e:	bf00      	nop

00026630 <UIBitcrusherButtons>:

char* UIBitcrusherButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";

	if (buttonActionsUI[ButtonA][ActionPress])
   26630:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   26634:	f2c0 230f 	movt	r3, #527	; 0x20f
   26638:	7d1a      	ldrb	r2, [r3, #20]
   2663a:	b1aa      	cbz	r2, 26668 <UIBitcrusherButtons+0x38>
	{
		writeString = crusherStereo ? "STEREO" : "MONO";
   2663c:	f646 01d0 	movw	r1, #26832	; 0x68d0
   26640:	f645 103c 	movw	r0, #22844	; 0x593c
   26644:	f645 0238 	movw	r2, #22584	; 0x5838
   26648:	f2c0 210e 	movt	r1, #526	; 0x20e
   2664c:	f2c0 0003 	movt	r0, #3
   26650:	f2c0 0203 	movt	r2, #3
{
   26654:	b410      	push	{r4}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   26656:	2400      	movs	r4, #0
   26658:	751c      	strb	r4, [r3, #20]
		writeString = crusherStereo ? "STEREO" : "MONO";
   2665a:	680b      	ldr	r3, [r1, #0]
   2665c:	42a3      	cmp	r3, r4
   2665e:	bf08      	it	eq
   26660:	4610      	moveq	r0, r2
	}


	return writeString;
}
   26662:	f85d 4b04 	ldr.w	r4, [sp], #4
   26666:	4770      	bx	lr
	char* writeString = "";
   26668:	f645 000c 	movw	r0, #22540	; 0x580c
   2666c:	f2c0 0003 	movt	r0, #3
}
   26670:	4770      	bx	lr
   26672:	bf00      	nop

00026674 <UIDelayButtons>:

char* UIDelayButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   26674:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   26678:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   2667c:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress])
   2667e:	7d1a      	ldrb	r2, [r3, #20]
   26680:	b342      	cbz	r2, 266d4 <UIDelayButtons+0x60>
	{
		writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   26682:	f646 01e0 	movw	r1, #26848	; 0x68e0
   26686:	f245 6098 	movw	r0, #22168	; 0x5698
   2668a:	f245 62a4 	movw	r2, #22180	; 0x56a4
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2668e:	2400      	movs	r4, #0
		writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   26690:	f2c0 210e 	movt	r1, #526	; 0x20e
   26694:	f2c0 0003 	movt	r0, #3
   26698:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2669c:	751c      	strb	r4, [r3, #20]
		writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   2669e:	6809      	ldr	r1, [r1, #0]
   266a0:	42a1      	cmp	r1, r4
   266a2:	bf08      	it	eq
   266a4:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   266a6:	7e1a      	ldrb	r2, [r3, #24]
   266a8:	b18a      	cbz	r2, 266ce <UIDelayButtons+0x5a>
	{
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   266aa:	f646 0190 	movw	r1, #26768	; 0x6890
		buttonActionsUI[ButtonB][ActionPress] = 0;
   266ae:	2400      	movs	r4, #0
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   266b0:	f245 60b0 	movw	r0, #22192	; 0x56b0
   266b4:	f245 62b8 	movw	r2, #22200	; 0x56b8
   266b8:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonB][ActionPress] = 0;
   266bc:	761c      	strb	r4, [r3, #24]
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   266be:	f2c0 0003 	movt	r0, #3
   266c2:	f2c0 0203 	movt	r2, #3
   266c6:	780b      	ldrb	r3, [r1, #0]
   266c8:	42a3      	cmp	r3, r4
   266ca:	bf08      	it	eq
   266cc:	4610      	moveq	r0, r2
	}
	return writeString;
}
   266ce:	f85d 4b04 	ldr.w	r4, [sp], #4
   266d2:	4770      	bx	lr
	char* writeString = "";
   266d4:	f645 000c 	movw	r0, #22540	; 0x580c
   266d8:	f2c0 0003 	movt	r0, #3
   266dc:	e7e3      	b.n	266a6 <UIDelayButtons+0x32>
   266de:	bf00      	nop

000266e0 <UIReverbButtons>:

char* UIReverbButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonC][ActionPress])
   266e0:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   266e4:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   266e8:	b410      	push	{r4}
	if (buttonActionsUI[ButtonC][ActionPress])
   266ea:	7f1a      	ldrb	r2, [r3, #28]
   266ec:	b342      	cbz	r2, 26740 <UIReverbButtons+0x60>
	{
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   266ee:	f646 01f8 	movw	r1, #26872	; 0x68f8
   266f2:	f245 7074 	movw	r0, #22388	; 0x5774
   266f6:	f245 727c 	movw	r2, #22396	; 0x577c
		buttonActionsUI[ButtonC][ActionPress] = 0;
   266fa:	2400      	movs	r4, #0
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   266fc:	f2c0 210e 	movt	r1, #526	; 0x20e
   26700:	f2c0 0003 	movt	r0, #3
   26704:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26708:	771c      	strb	r4, [r3, #28]
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   2670a:	6809      	ldr	r1, [r1, #0]
   2670c:	42a1      	cmp	r1, r4
   2670e:	bf08      	it	eq
   26710:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   26712:	7e1a      	ldrb	r2, [r3, #24]
   26714:	b18a      	cbz	r2, 2673a <UIReverbButtons+0x5a>
	{
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   26716:	f646 0190 	movw	r1, #26768	; 0x6890
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2671a:	2400      	movs	r4, #0
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   2671c:	f245 60b0 	movw	r0, #22192	; 0x56b0
   26720:	f245 62b8 	movw	r2, #22200	; 0x56b8
   26724:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26728:	761c      	strb	r4, [r3, #24]
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   2672a:	f2c0 0003 	movt	r0, #3
   2672e:	f2c0 0203 	movt	r2, #3
   26732:	780b      	ldrb	r3, [r1, #0]
   26734:	42a3      	cmp	r3, r4
   26736:	bf08      	it	eq
   26738:	4610      	moveq	r0, r2
	}
	return writeString;
}
   2673a:	f85d 4b04 	ldr.w	r4, [sp], #4
   2673e:	4770      	bx	lr
	char* writeString = "";
   26740:	f645 000c 	movw	r0, #22540	; 0x580c
   26744:	f2c0 0003 	movt	r0, #3
   26748:	e7e3      	b.n	26712 <UIReverbButtons+0x32>
   2674a:	bf00      	nop

0002674c <UIReverb2Buttons>:

char* UIReverb2Buttons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonC][ActionPress])
   2674c:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   26750:	f2c0 230f 	movt	r3, #527	; 0x20f
   26754:	7f1a      	ldrb	r2, [r3, #28]
   26756:	b1aa      	cbz	r2, 26784 <UIReverb2Buttons+0x38>
	{
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   26758:	f646 01f8 	movw	r1, #26872	; 0x68f8
   2675c:	f245 7074 	movw	r0, #22388	; 0x5774
   26760:	f245 727c 	movw	r2, #22396	; 0x577c
   26764:	f2c0 210e 	movt	r1, #526	; 0x20e
   26768:	f2c0 0003 	movt	r0, #3
   2676c:	f2c0 0203 	movt	r2, #3
{
   26770:	b410      	push	{r4}
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26772:	2400      	movs	r4, #0
   26774:	771c      	strb	r4, [r3, #28]
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   26776:	680b      	ldr	r3, [r1, #0]
   26778:	42a3      	cmp	r3, r4
   2677a:	bf08      	it	eq
   2677c:	4610      	moveq	r0, r2
	}
	return writeString;
}
   2677e:	f85d 4b04 	ldr.w	r4, [sp], #4
   26782:	4770      	bx	lr
	char* writeString = "";
   26784:	f645 000c 	movw	r0, #22540	; 0x580c
   26788:	f2c0 0003 	movt	r0, #3
}
   2678c:	4770      	bx	lr
   2678e:	bf00      	nop

00026790 <UILivingStringButtons>:

char* UILivingStringButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   26790:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   26794:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   26798:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2679a:	7d1a      	ldrb	r2, [r3, #20]
   2679c:	2a01      	cmp	r2, #1
   2679e:	d030      	beq.n	26802 <UILivingStringButtons+0x72>
	char* writeString = "";
   267a0:	f645 000c 	movw	r0, #22540	; 0x580c
   267a4:	f2c0 0003 	movt	r0, #3
	{
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   267a8:	7f1a      	ldrb	r2, [r3, #28]
   267aa:	2a01      	cmp	r2, #1
   267ac:	d111      	bne.n	267d2 <UILivingStringButtons+0x42>
	{
		writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   267ae:	f646 1108 	movw	r1, #26888	; 0x6908
   267b2:	f245 60ec 	movw	r0, #22252	; 0x56ec
   267b6:	f245 62f4 	movw	r2, #22260	; 0x56f4
		buttonActionsUI[ButtonC][ActionPress] = 0;
   267ba:	2400      	movs	r4, #0
		writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   267bc:	f2c0 210e 	movt	r1, #526	; 0x20e
   267c0:	f2c0 0003 	movt	r0, #3
   267c4:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonC][ActionPress] = 0;
   267c8:	771c      	strb	r4, [r3, #28]
		writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   267ca:	6809      	ldr	r1, [r1, #0]
   267cc:	42a1      	cmp	r1, r4
   267ce:	bfd8      	it	le
   267d0:	4610      	movle	r0, r2
	}

	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   267d2:	7e1a      	ldrb	r2, [r3, #24]
   267d4:	2a01      	cmp	r2, #1
   267d6:	d111      	bne.n	267fc <UILivingStringButtons+0x6c>
	{
		writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   267d8:	f646 1100 	movw	r1, #26880	; 0x6900
		buttonActionsUI[ButtonB][ActionPress] = 0;
   267dc:	2400      	movs	r4, #0
		writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   267de:	f245 7000 	movw	r0, #22272	; 0x5700
   267e2:	f245 7210 	movw	r2, #22288	; 0x5710
   267e6:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonB][ActionPress] = 0;
   267ea:	761c      	strb	r4, [r3, #24]
		writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   267ec:	f2c0 0003 	movt	r0, #3
   267f0:	f2c0 0203 	movt	r2, #3
   267f4:	680b      	ldr	r3, [r1, #0]
   267f6:	42a3      	cmp	r3, r4
   267f8:	bfd8      	it	le
   267fa:	4610      	movle	r0, r2
	}

	return writeString;
}
   267fc:	f85d 4b04 	ldr.w	r4, [sp], #4
   26800:	4770      	bx	lr
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   26802:	f646 01fc 	movw	r1, #26876	; 0x68fc
   26806:	f245 60d4 	movw	r0, #22228	; 0x56d4
   2680a:	f245 62e0 	movw	r2, #22240	; 0x56e0
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2680e:	2400      	movs	r4, #0
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   26810:	f2c0 210e 	movt	r1, #526	; 0x20e
   26814:	f2c0 0003 	movt	r0, #3
   26818:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2681c:	751c      	strb	r4, [r3, #20]
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   2681e:	6809      	ldr	r1, [r1, #0]
   26820:	42a1      	cmp	r1, r4
   26822:	bfd8      	it	le
   26824:	4610      	movle	r0, r2
   26826:	e7bf      	b.n	267a8 <UILivingStringButtons+0x18>

00026828 <UILivingStringSynthButtons>:

char* UILivingStringSynthButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   26828:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   2682c:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   26830:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   26832:	7d1a      	ldrb	r2, [r3, #20]
   26834:	2a01      	cmp	r2, #1
   26836:	d030      	beq.n	2689a <UILivingStringSynthButtons+0x72>
	char* writeString = "";
   26838:	f645 000c 	movw	r0, #22540	; 0x580c
   2683c:	f2c0 0003 	movt	r0, #3
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   26840:	7e1a      	ldrb	r2, [r3, #24]
   26842:	2a01      	cmp	r2, #1
   26844:	d111      	bne.n	2686a <UILivingStringSynthButtons+0x42>
	{
		writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   26846:	f646 1180 	movw	r1, #27008	; 0x6980
   2684a:	f245 701c 	movw	r0, #22300	; 0x571c
   2684e:	f245 7228 	movw	r2, #22312	; 0x5728
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26852:	2400      	movs	r4, #0
		writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   26854:	f2c0 210e 	movt	r1, #526	; 0x20e
   26858:	f2c0 0003 	movt	r0, #3
   2685c:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26860:	761c      	strb	r4, [r3, #24]
		writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   26862:	6809      	ldr	r1, [r1, #0]
   26864:	42a1      	cmp	r1, r4
   26866:	bfd8      	it	le
   26868:	4610      	movle	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   2686a:	7f1a      	ldrb	r2, [r3, #28]
   2686c:	2a01      	cmp	r2, #1
   2686e:	d111      	bne.n	26894 <UILivingStringSynthButtons+0x6c>
	{
		writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   26870:	f646 110c 	movw	r1, #26892	; 0x690c
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26874:	2400      	movs	r4, #0
		writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   26876:	f245 60ec 	movw	r0, #22252	; 0x56ec
   2687a:	f245 62f4 	movw	r2, #22260	; 0x56f4
   2687e:	f2c0 210e 	movt	r1, #526	; 0x20e
		buttonActionsUI[ButtonC][ActionPress] = 0;
   26882:	771c      	strb	r4, [r3, #28]
		writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   26884:	f2c0 0003 	movt	r0, #3
   26888:	f2c0 0203 	movt	r2, #3
   2688c:	680b      	ldr	r3, [r1, #0]
   2688e:	42a3      	cmp	r3, r4
   26890:	bfd8      	it	le
   26892:	4610      	movle	r0, r2
	}
	return writeString;
}
   26894:	f85d 4b04 	ldr.w	r4, [sp], #4
   26898:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   2689a:	f246 2154 	movw	r1, #25172	; 0x6254
   2689e:	f645 0030 	movw	r0, #22576	; 0x5830
   268a2:	f645 0238 	movw	r2, #22584	; 0x5838
		buttonActionsUI[ButtonA][ActionPress] = 0;
   268a6:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   268a8:	f2c0 0106 	movt	r1, #6
   268ac:	f2c0 0003 	movt	r0, #3
   268b0:	f2c0 0203 	movt	r2, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   268b4:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   268b6:	7809      	ldrb	r1, [r1, #0]
   268b8:	2901      	cmp	r1, #1
   268ba:	bf98      	it	ls
   268bc:	4610      	movls	r0, r2
   268be:	e7bf      	b.n	26840 <UILivingStringSynthButtons+0x18>

000268c0 <UIClassicSynthButtons>:

char* UIClassicSynthButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   268c0:	f64e 33bc 	movw	r3, #60348	; 0xebbc
   268c4:	f2c0 230f 	movt	r3, #527	; 0x20f
   268c8:	7d1a      	ldrb	r2, [r3, #20]
   268ca:	2a01      	cmp	r2, #1
   268cc:	d009      	beq.n	268e2 <UIClassicSynthButtons+0x22>
	char* writeString = "";
   268ce:	f645 000c 	movw	r0, #22540	; 0x580c
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   268d2:	7e1a      	ldrb	r2, [r3, #24]
	char* writeString = "";
   268d4:	f2c0 0003 	movt	r0, #3
	if (buttonActionsUI[ButtonB][ActionPress])
   268d8:	b112      	cbz	r2, 268e0 <UIClassicSynthButtons+0x20>
	{
		//writeString = knobPage == 0 ? "SETTINGS" : "ADSR";
		buttonActionsUI[ButtonB][ActionPress] = 0;
   268da:	2200      	movs	r2, #0
   268dc:	761a      	strb	r2, [r3, #24]
   268de:	4770      	bx	lr
	}
	return writeString;
}
   268e0:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   268e2:	f246 2154 	movw	r1, #25172	; 0x6254
   268e6:	f645 0030 	movw	r0, #22576	; 0x5830
   268ea:	f645 0238 	movw	r2, #22584	; 0x5838
   268ee:	f2c0 0106 	movt	r1, #6
   268f2:	f2c0 0003 	movt	r0, #3
   268f6:	f2c0 0203 	movt	r2, #3
{
   268fa:	b410      	push	{r4}
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   268fc:	7809      	ldrb	r1, [r1, #0]
		buttonActionsUI[ButtonA][ActionPress] = 0;
   268fe:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   26900:	2901      	cmp	r1, #1
   26902:	bf98      	it	ls
   26904:	4610      	movls	r0, r2
	if (buttonActionsUI[ButtonB][ActionPress])
   26906:	7e1a      	ldrb	r2, [r3, #24]
		buttonActionsUI[ButtonA][ActionPress] = 0;
   26908:	751c      	strb	r4, [r3, #20]
	if (buttonActionsUI[ButtonB][ActionPress])
   2690a:	b10a      	cbz	r2, 26910 <UIClassicSynthButtons+0x50>
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2690c:	2200      	movs	r2, #0
   2690e:	761a      	strb	r2, [r3, #24]
}
   26910:	f85d 4b04 	ldr.w	r4, [sp], #4
   26914:	4770      	bx	lr
   26916:	bf00      	nop

00026918 <UIRhodesButtons>:

char* UIRhodesButtons(VocodecButton button, ButtonAction action)
{
   26918:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2691c:	f64e 34bc 	movw	r4, #60348	; 0xebbc
   26920:	f2c0 240f 	movt	r4, #527	; 0x20f
   26924:	7d23      	ldrb	r3, [r4, #20]
   26926:	2b01      	cmp	r3, #1
   26928:	d00c      	beq.n	26944 <UIRhodesButtons+0x2c>
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2692a:	7e26      	ldrb	r6, [r4, #24]
	char* writeString = "";
   2692c:	f645 050c 	movw	r5, #22540	; 0x580c
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   26930:	2e01      	cmp	r6, #1
	char* writeString = "";
   26932:	f2c0 0503 	movt	r5, #3
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   26936:	d01a      	beq.n	2696e <UIRhodesButtons+0x56>
	{
		buttonActionsUI[ButtonB][ActionPress] = 0;
		OLEDclearLine(SecondLine);
		OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   26938:	7f26      	ldrb	r6, [r4, #28]
   2693a:	2e01      	cmp	r6, #1
   2693c:	d031      	beq.n	269a2 <UIRhodesButtons+0x8a>
		OLEDclearLine(SecondLine);
		OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
		OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
	}
	return writeString;
}
   2693e:	4628      	mov	r0, r5
   26940:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   26944:	f246 2254 	movw	r2, #25172	; 0x6254
   26948:	f645 0530 	movw	r5, #22576	; 0x5830
   2694c:	f645 0338 	movw	r3, #22584	; 0x5838
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   26950:	7e26      	ldrb	r6, [r4, #24]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   26952:	f2c0 0206 	movt	r2, #6
   26956:	f2c0 0503 	movt	r5, #3
   2695a:	f2c0 0303 	movt	r3, #3
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2695e:	2100      	movs	r1, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   26960:	7812      	ldrb	r2, [r2, #0]
		buttonActionsUI[ButtonA][ActionPress] = 0;
   26962:	7521      	strb	r1, [r4, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   26964:	2a01      	cmp	r2, #1
   26966:	bf98      	it	ls
   26968:	461d      	movls	r5, r3
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2696a:	2e01      	cmp	r6, #1
   2696c:	d1e4      	bne.n	26938 <UIRhodesButtons+0x20>
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2696e:	f04f 0800 	mov.w	r8, #0
		OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   26972:	f646 0778 	movw	r7, #26744	; 0x6878
		OLEDclearLine(SecondLine);
   26976:	4630      	mov	r0, r6
		buttonActionsUI[ButtonB][ActionPress] = 0;
   26978:	f884 8018 	strb.w	r8, [r4, #24]
		OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   2697c:	f2c0 270e 	movt	r7, #526	; 0x20e
		OLEDclearLine(SecondLine);
   26980:	f7f4 fe78 	bl	1b674 <OLEDclearLine>
		OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   26984:	f64d 0088 	movw	r0, #55432	; 0xd888
   26988:	4633      	mov	r3, r6
   2698a:	683e      	ldr	r6, [r7, #0]
   2698c:	f2c0 200f 	movt	r0, #527	; 0x20f
   26990:	4642      	mov	r2, r8
   26992:	2106      	movs	r1, #6
   26994:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
   26998:	f7f4 fe82 	bl	1b6a0 <OLEDwriteString>
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   2699c:	7f26      	ldrb	r6, [r4, #28]
   2699e:	2e01      	cmp	r6, #1
   269a0:	d1cd      	bne.n	2693e <UIRhodesButtons+0x26>
		buttonActionsUI[ButtonC][ActionPress] = 0;
   269a2:	2700      	movs	r7, #0
		OLEDclearLine(SecondLine);
   269a4:	4630      	mov	r0, r6
		buttonActionsUI[ButtonC][ActionPress] = 0;
   269a6:	7727      	strb	r7, [r4, #28]
		OLEDclearLine(SecondLine);
   269a8:	f7f4 fe64 	bl	1b674 <OLEDclearLine>
		OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
   269ac:	f245 7088 	movw	r0, #22408	; 0x5788
   269b0:	4633      	mov	r3, r6
   269b2:	463a      	mov	r2, r7
   269b4:	210c      	movs	r1, #12
   269b6:	f2c0 0003 	movt	r0, #3
   269ba:	f7f4 fe71 	bl	1b6a0 <OLEDwriteString>
		OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
   269be:	f646 1074 	movw	r0, #26996	; 0x6974
   269c2:	4633      	mov	r3, r6
   269c4:	4631      	mov	r1, r6
   269c6:	f2c0 200e 	movt	r0, #526	; 0x20e
   269ca:	226e      	movs	r2, #110	; 0x6e
   269cc:	7800      	ldrb	r0, [r0, #0]
   269ce:	f7f4 fe9b 	bl	1b708 <OLEDwriteInt>
}
   269d2:	4628      	mov	r0, r5
   269d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000269d8 <USBH_UserProcess>:
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
   269d8:	2904      	cmp	r1, #4
   269da:	d011      	beq.n	26a00 <USBH_UserProcess+0x28>
   269dc:	2905      	cmp	r1, #5
   269de:	d008      	beq.n	269f2 <USBH_UserProcess+0x1a>
   269e0:	2902      	cmp	r1, #2
   269e2:	d000      	beq.n	269e6 <USBH_UserProcess+0xe>

  default:
  break;
  }
  /* USER CODE END CALL_BACK_1 */
}
   269e4:	4770      	bx	lr
  Appli_state = APPLICATION_READY;
   269e6:	f646 13bc 	movw	r3, #27068	; 0x69bc
   269ea:	f2c0 230e 	movt	r3, #526	; 0x20e
   269ee:	7019      	strb	r1, [r3, #0]
  break;
   269f0:	4770      	bx	lr
  Appli_state = APPLICATION_DISCONNECT;
   269f2:	f646 13bc 	movw	r3, #27068	; 0x69bc
   269f6:	2204      	movs	r2, #4
   269f8:	f2c0 230e 	movt	r3, #526	; 0x20e
   269fc:	701a      	strb	r2, [r3, #0]
  break;
   269fe:	4770      	bx	lr
  Appli_state = APPLICATION_START;
   26a00:	f646 13bc 	movw	r3, #27068	; 0x69bc
   26a04:	2201      	movs	r2, #1
   26a06:	f2c0 230e 	movt	r3, #526	; 0x20e
   26a0a:	701a      	strb	r2, [r3, #0]
}
   26a0c:	4770      	bx	lr
   26a0e:	bf00      	nop

00026a10 <MX_USB_HOST_Init>:
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
   26a10:	f646 11d9 	movw	r1, #27097	; 0x69d9
   26a14:	f247 5040 	movw	r0, #30016	; 0x7540
   26a18:	2201      	movs	r2, #1
   26a1a:	f2c0 0102 	movt	r1, #2
   26a1e:	f2c0 0006 	movt	r0, #6
{
   26a22:	b508      	push	{r3, lr}
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
   26a24:	f7ef fe84 	bl	16730 <USBH_Init>
   26a28:	b9d0      	cbnz	r0, 26a60 <MX_USB_HOST_Init+0x50>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MIDI_CLASS) != USBH_OK)
   26a2a:	f246 21d4 	movw	r1, #25300	; 0x62d4
   26a2e:	f247 5040 	movw	r0, #30016	; 0x7540
   26a32:	f2c0 0106 	movt	r1, #6
   26a36:	f2c0 0006 	movt	r0, #6
   26a3a:	f7ef fedf 	bl	167fc <USBH_RegisterClass>
   26a3e:	b960      	cbnz	r0, 26a5a <MX_USB_HOST_Init+0x4a>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
   26a40:	f247 5040 	movw	r0, #30016	; 0x7540
   26a44:	f2c0 0006 	movt	r0, #6
   26a48:	f7ef ffc8 	bl	169dc <USBH_Start>
   26a4c:	b108      	cbz	r0, 26a52 <MX_USB_HOST_Init+0x42>
    Error_Handler();
   26a4e:	f7f4 fb2d 	bl	1b0ac <Error_Handler>
}
   26a52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
   26a56:	f7e8 b93f 	b.w	ecd8 <HAL_PWREx_EnableUSBVoltageDetector>
    Error_Handler();
   26a5a:	f7f4 fb27 	bl	1b0ac <Error_Handler>
   26a5e:	e7ef      	b.n	26a40 <MX_USB_HOST_Init+0x30>
    Error_Handler();
   26a60:	f7f4 fb24 	bl	1b0ac <Error_Handler>
   26a64:	e7e1      	b.n	26a2a <MX_USB_HOST_Init+0x1a>
   26a66:	bf00      	nop

00026a68 <MX_USB_HOST_DeInit>:
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
   26a68:	f247 5040 	movw	r0, #30016	; 0x7540
{
   26a6c:	b508      	push	{r3, lr}
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
   26a6e:	f2c0 0006 	movt	r0, #6
   26a72:	f7ef ffbd 	bl	169f0 <USBH_Stop>
   26a76:	b960      	cbnz	r0, 26a92 <MX_USB_HOST_DeInit+0x2a>
  if (USBH_DeInit(&hUsbHostFS) != USBH_OK)
   26a78:	f247 5040 	movw	r0, #30016	; 0x7540
   26a7c:	f2c0 0006 	movt	r0, #6
   26a80:	f7ef fe8e 	bl	167a0 <USBH_DeInit>
   26a84:	b108      	cbz	r0, 26a8a <MX_USB_HOST_DeInit+0x22>
    Error_Handler();
   26a86:	f7f4 fb11 	bl	1b0ac <Error_Handler>
}
   26a8a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_DisableUSBVoltageDetector();
   26a8e:	f7e8 b92d 	b.w	ecec <HAL_PWREx_DisableUSBVoltageDetector>
    Error_Handler();
   26a92:	f7f4 fb0b 	bl	1b0ac <Error_Handler>
   26a96:	e7ef      	b.n	26a78 <MX_USB_HOST_DeInit+0x10>

00026a98 <MX_USB_HOST_Process>:
{
   26a98:	b508      	push	{r3, lr}
	MIDI_Application();
   26a9a:	f7f1 fa0f 	bl	17ebc <MIDI_Application>
	USBH_Process(&hUsbHostFS);
   26a9e:	f247 5040 	movw	r0, #30016	; 0x7540
}
   26aa2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	USBH_Process(&hUsbHostFS);
   26aa6:	f2c0 0006 	movt	r0, #6
   26aaa:	f7ef bfb3 	b.w	16a14 <USBH_Process>
   26aae:	bf00      	nop

00026ab0 <USBH_MIDI_ClassRequest>:
 *         for MIDI class.
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_ClassRequest (USBH_HandleTypeDef *phost)
{   
   26ab0:	b508      	push	{r3, lr}

	phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
   26ab2:	2102      	movs	r1, #2
   26ab4:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
   26ab8:	4798      	blx	r3

	return USBH_OK;
}
   26aba:	2000      	movs	r0, #0
   26abc:	bd08      	pop	{r3, pc}
   26abe:	bf00      	nop

00026ac0 <USBH_MIDI_Process>:
 *         (background process)
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_Process (USBH_HandleTypeDef *phost)
{
   26ac0:	b510      	push	{r4, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26ac2:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
   26ac6:	69dc      	ldr	r4, [r3, #28]

	switch(MIDI_Handle->state)
   26ac8:	7823      	ldrb	r3, [r4, #0]
   26aca:	b153      	cbz	r3, 26ae2 <USBH_MIDI_Process+0x22>
   26acc:	2b02      	cmp	r3, #2
   26ace:	d106      	bne.n	26ade <USBH_MIDI_Process+0x1e>
		//MIDI_ProcessTransmission(phost);
		//MIDI_ProcessReception(phost);
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
   26ad0:	2100      	movs	r1, #0
   26ad2:	f7f1 f82f 	bl	17b34 <USBH_ClrFeature>

		if(req_status == USBH_OK )
   26ad6:	b910      	cbnz	r0, 26ade <USBH_MIDI_Process+0x1e>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
   26ad8:	7020      	strb	r0, [r4, #0]
	USBH_StatusTypeDef status = USBH_BUSY;
   26ada:	2001      	movs	r0, #1
		break;

	}

	return status;
}
   26adc:	bd10      	pop	{r4, pc}
	USBH_StatusTypeDef status = USBH_BUSY;
   26ade:	2001      	movs	r0, #1
}
   26ae0:	bd10      	pop	{r4, pc}
		status = USBH_OK;
   26ae2:	4618      	mov	r0, r3
}
   26ae4:	bd10      	pop	{r4, pc}
   26ae6:	bf00      	nop

00026ae8 <USBH_MIDI_SOFProcess>:
  *         The function is for managing SOF callback
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MIDI_SOFProcess (USBH_HandleTypeDef *phost)
{
   26ae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26aec:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
   26af0:	b083      	sub	sp, #12
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26af2:	69dc      	ldr	r4, [r3, #28]
	USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
	uint16_t length;
	switch(MIDI_Handle->state)
   26af4:	7823      	ldrb	r3, [r4, #0]
   26af6:	2b01      	cmp	r3, #1
   26af8:	d00a      	beq.n	26b10 <USBH_MIDI_SOFProcess+0x28>
   26afa:	2b02      	cmp	r3, #2
   26afc:	d104      	bne.n	26b08 <USBH_MIDI_SOFProcess+0x20>
				break;
		}
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
   26afe:	2100      	movs	r1, #0
   26b00:	f7f1 f818 	bl	17b34 <USBH_ClrFeature>

		if(req_status == USBH_OK )
   26b04:	b900      	cbnz	r0, 26b08 <USBH_MIDI_SOFProcess+0x20>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
   26b06:	7020      	strb	r0, [r4, #0]
		break;

	}

	return USBH_OK;
}
   26b08:	2000      	movs	r0, #0
   26b0a:	b003      	add	sp, #12
   26b0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(MIDI_Handle->data_rx_state)
   26b10:	7e63      	ldrb	r3, [r4, #25]
   26b12:	2b03      	cmp	r3, #3
   26b14:	f000 8084 	beq.w	26c20 <USBH_MIDI_SOFProcess+0x138>
   26b18:	2b04      	cmp	r3, #4
   26b1a:	d1f5      	bne.n	26b08 <USBH_MIDI_SOFProcess+0x20>
				URB_Status = USBH_LL_GetURBState(phost, MIDI_Handle->InPipe);
   26b1c:	7861      	ldrb	r1, [r4, #1]
   26b1e:	4605      	mov	r5, r0
   26b20:	f000 fa52 	bl	26fc8 <USBH_LL_GetURBState>
				if(URB_Status == USBH_URB_DONE )
   26b24:	2801      	cmp	r0, #1
   26b26:	d1ef      	bne.n	26b08 <USBH_MIDI_SOFProcess+0x20>
					length = USBH_LL_GetLastXferSize(phost, MIDI_Handle->InPipe);
   26b28:	7861      	ldrb	r1, [r4, #1]
   26b2a:	4628      	mov	r0, r5
   26b2c:	f000 f9fe 	bl	26f2c <USBH_LL_GetLastXferSize>
					if(((MIDI_Handle->RxDataLength - length) > 0) && (length > MIDI_Handle->InEpSize))
   26b30:	8ae3      	ldrh	r3, [r4, #22]
   26b32:	b286      	uxth	r6, r0
   26b34:	1b9a      	subs	r2, r3, r6
   26b36:	2a00      	cmp	r2, #0
   26b38:	dd02      	ble.n	26b40 <USBH_MIDI_SOFProcess+0x58>
   26b3a:	8922      	ldrh	r2, [r4, #8]
   26b3c:	42b2      	cmp	r2, r6
   26b3e:	d37a      	bcc.n	26c36 <USBH_MIDI_SOFProcess+0x14e>
						MIDI_write_buffer = !MIDI_write_buffer;
   26b40:	f246 000c 	movw	r0, #24588	; 0x600c
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   26b44:	f646 0134 	movw	r1, #26676	; 0x6834
						MIDI_Handle->data_rx_state = MIDI_IDLE;
   26b48:	2300      	movs	r3, #0
						MIDI_write_buffer = !MIDI_write_buffer;
   26b4a:	f2c0 0006 	movt	r0, #6
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   26b4e:	f2c0 210e 	movt	r1, #526	; 0x20e
						MIDI_Handle->data_rx_state = MIDI_IDLE;
   26b52:	7663      	strb	r3, [r4, #25]
						MIDI_write_buffer = !MIDI_write_buffer;
   26b54:	f890 c000 	ldrb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   26b58:	780a      	ldrb	r2, [r1, #0]
						MIDI_write_buffer = !MIDI_write_buffer;
   26b5a:	fabc fc8c 	clz	ip, ip
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   26b5e:	fab2 f282 	clz	r2, r2
						MIDI_write_buffer = !MIDI_write_buffer;
   26b62:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   26b66:	0952      	lsrs	r2, r2, #5
						MIDI_write_buffer = !MIDI_write_buffer;
   26b68:	f880 c000 	strb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   26b6c:	700a      	strb	r2, [r1, #0]
						for (int i = 0; i < length; i++)
   26b6e:	2e00      	cmp	r6, #0
   26b70:	d040      	beq.n	26bf4 <USBH_MIDI_SOFProcess+0x10c>
   26b72:	f246 47a0 	movw	r7, #25760	; 0x64a0
   26b76:	f646 11c0 	movw	r1, #27072	; 0x69c0
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   26b7a:	f24f 4044 	movw	r0, #62532	; 0xf444
								myUSB_FIFO_overflowBit = 1;
   26b7e:	f646 1ebd 	movw	lr, #27069	; 0x69bd
   26b82:	f2c0 0706 	movt	r7, #6
								myUSB_FIFO_writePointer = 0;
   26b86:	4698      	mov	r8, r3
   26b88:	f2c0 210e 	movt	r1, #526	; 0x20e
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   26b8c:	f2c0 200f 	movt	r0, #527	; 0x20f
   26b90:	eb07 1282 	add.w	r2, r7, r2, lsl #6
								myUSB_FIFO_overflowBit = 1;
   26b94:	f2c0 2e0e 	movt	lr, #526	; 0x20e
   26b98:	f04f 0901 	mov.w	r9, #1
   26b9c:	9401      	str	r4, [sp, #4]
							if ((i % 4) == 0)
   26b9e:	f003 0703 	and.w	r7, r3, #3
   26ba2:	3301      	adds	r3, #1
   26ba4:	b9df      	cbnz	r7, 26bde <USBH_MIDI_SOFProcess+0xf6>
								if (MIDI_RX_Buffer[MIDI_read_buffer][i] > 0)
   26ba6:	7817      	ldrb	r7, [r2, #0]
   26ba8:	b1cf      	cbz	r7, 26bde <USBH_MIDI_SOFProcess+0xf6>
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   26baa:	f8b1 b000 	ldrh.w	fp, [r1]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   26bae:	f892 a001 	ldrb.w	sl, [r2, #1]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   26bb2:	fa1f fb8b 	uxth.w	fp, fp
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
   26bb6:	7894      	ldrb	r4, [r2, #2]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   26bb8:	f800 700b 	strb.w	r7, [r0, fp]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   26bbc:	880f      	ldrh	r7, [r1, #0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
   26bbe:	f892 b003 	ldrb.w	fp, [r2, #3]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   26bc2:	3701      	adds	r7, #1
   26bc4:	f800 a007 	strb.w	sl, [r0, r7]
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
   26bc8:	880f      	ldrh	r7, [r1, #0]
   26bca:	3702      	adds	r7, #2
   26bcc:	55c4      	strb	r4, [r0, r7]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
   26bce:	880f      	ldrh	r7, [r1, #0]
   26bd0:	3703      	adds	r7, #3
   26bd2:	f800 b007 	strb.w	fp, [r0, r7]
									myUSB_FIFO_writePointer+=4;
   26bd6:	880f      	ldrh	r7, [r1, #0]
   26bd8:	3704      	adds	r7, #4
   26bda:	b2bf      	uxth	r7, r7
   26bdc:	800f      	strh	r7, [r1, #0]
							if (myUSB_FIFO_writePointer >= 256)
   26bde:	880f      	ldrh	r7, [r1, #0]
   26be0:	3201      	adds	r2, #1
   26be2:	2fff      	cmp	r7, #255	; 0xff
   26be4:	d903      	bls.n	26bee <USBH_MIDI_SOFProcess+0x106>
								myUSB_FIFO_writePointer = 0;
   26be6:	f8a1 8000 	strh.w	r8, [r1]
								myUSB_FIFO_overflowBit = 1;
   26bea:	f88e 9000 	strb.w	r9, [lr]
						for (int i = 0; i < length; i++)
   26bee:	429e      	cmp	r6, r3
   26bf0:	d1d5      	bne.n	26b9e <USBH_MIDI_SOFProcess+0xb6>
   26bf2:	9c01      	ldr	r4, [sp, #4]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   26bf4:	2304      	movs	r3, #4
   26bf6:	7663      	strb	r3, [r4, #25]
 * @retval None
 */
USBH_StatusTypeDef  USBH_MIDI_Receive(USBH_HandleTypeDef *phost, uint8_t *pbuff, uint16_t length)
{
	USBH_StatusTypeDef Status = USBH_BUSY;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26bf8:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
   26bfc:	69db      	ldr	r3, [r3, #28]

	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
   26bfe:	781a      	ldrb	r2, [r3, #0]
   26c00:	2a01      	cmp	r2, #1
   26c02:	d881      	bhi.n	26b08 <USBH_MIDI_SOFProcess+0x20>
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   26c04:	f246 42a0 	movw	r2, #25760	; 0x64a0
	{
		MIDI_Handle->pRxData = pbuff;
		MIDI_Handle->RxDataLength = length;
   26c08:	2440      	movs	r4, #64	; 0x40
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   26c0a:	2001      	movs	r0, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26c0c:	2103      	movs	r1, #3
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   26c0e:	f2c0 0206 	movt	r2, #6
		MIDI_Handle->RxDataLength = length;
   26c12:	82dc      	strh	r4, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   26c14:	7018      	strb	r0, [r3, #0]
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   26c16:	eb02 128c 	add.w	r2, r2, ip, lsl #6
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26c1a:	7659      	strb	r1, [r3, #25]
		MIDI_Handle->pRxData = pbuff;
   26c1c:	611a      	str	r2, [r3, #16]
   26c1e:	e773      	b.n	26b08 <USBH_MIDI_SOFProcess+0x20>
				USBH_BulkReceiveData (phost,
   26c20:	7863      	ldrb	r3, [r4, #1]
   26c22:	8922      	ldrh	r2, [r4, #8]
   26c24:	6921      	ldr	r1, [r4, #16]
   26c26:	f7f1 f8a5 	bl	17d74 <USBH_BulkReceiveData>
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   26c2a:	2304      	movs	r3, #4
}
   26c2c:	2000      	movs	r0, #0
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   26c2e:	7663      	strb	r3, [r4, #25]
}
   26c30:	b003      	add	sp, #12
   26c32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						MIDI_Handle->pRxData += length;
   26c36:	6922      	ldr	r2, [r4, #16]
						MIDI_Handle->RxDataLength -= length ;
   26c38:	1b98      	subs	r0, r3, r6
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26c3a:	2303      	movs	r3, #3
						MIDI_Handle->pRxData += length;
   26c3c:	4432      	add	r2, r6
						MIDI_Handle->RxDataLength -= length ;
   26c3e:	82e0      	strh	r0, [r4, #22]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26c40:	7663      	strb	r3, [r4, #25]
						MIDI_Handle->pRxData += length;
   26c42:	6122      	str	r2, [r4, #16]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26c44:	e760      	b.n	26b08 <USBH_MIDI_SOFProcess+0x20>
   26c46:	bf00      	nop

00026c48 <USBH_MIDI_InterfaceDeInit>:
{
   26c48:	b538      	push	{r3, r4, r5, lr}
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26c4a:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
   26c4e:	4605      	mov	r5, r0
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26c50:	69dc      	ldr	r4, [r3, #28]
	if ( MIDI_Handle->OutPipe)
   26c52:	78a1      	ldrb	r1, [r4, #2]
   26c54:	b949      	cbnz	r1, 26c6a <USBH_MIDI_InterfaceDeInit+0x22>
	if ( MIDI_Handle->InPipe)
   26c56:	7861      	ldrb	r1, [r4, #1]
   26c58:	b991      	cbnz	r1, 26c80 <USBH_MIDI_InterfaceDeInit+0x38>
	if(phost->pActiveClass->pData)
   26c5a:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
   26c5e:	69da      	ldr	r2, [r3, #28]
   26c60:	b10a      	cbz	r2, 26c66 <USBH_MIDI_InterfaceDeInit+0x1e>
		phost->pActiveClass->pData = 0;
   26c62:	2200      	movs	r2, #0
   26c64:	61da      	str	r2, [r3, #28]
}
   26c66:	2000      	movs	r0, #0
   26c68:	bd38      	pop	{r3, r4, r5, pc}
		USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
   26c6a:	f7f1 f8a5 	bl	17db8 <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->OutPipe);
   26c6e:	78a1      	ldrb	r1, [r4, #2]
   26c70:	4628      	mov	r0, r5
   26c72:	f7f1 f8f1 	bl	17e58 <USBH_FreePipe>
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
   26c76:	2300      	movs	r3, #0
	if ( MIDI_Handle->InPipe)
   26c78:	7861      	ldrb	r1, [r4, #1]
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
   26c7a:	70a3      	strb	r3, [r4, #2]
	if ( MIDI_Handle->InPipe)
   26c7c:	2900      	cmp	r1, #0
   26c7e:	d0ec      	beq.n	26c5a <USBH_MIDI_InterfaceDeInit+0x12>
		USBH_ClosePipe(phost, MIDI_Handle->InPipe);
   26c80:	4628      	mov	r0, r5
   26c82:	f7f1 f899 	bl	17db8 <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->InPipe);
   26c86:	7861      	ldrb	r1, [r4, #1]
   26c88:	4628      	mov	r0, r5
   26c8a:	f7f1 f8e5 	bl	17e58 <USBH_FreePipe>
		MIDI_Handle->InPipe = 0;     /* Reset the Channel as Free */
   26c8e:	2300      	movs	r3, #0
   26c90:	7063      	strb	r3, [r4, #1]
   26c92:	e7e2      	b.n	26c5a <USBH_MIDI_InterfaceDeInit+0x12>

00026c94 <USBH_MIDI_InterfaceInit>:
{	
   26c94:	b5f0      	push	{r4, r5, r6, r7, lr}
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   26c96:	23ff      	movs	r3, #255	; 0xff
{	
   26c98:	b085      	sub	sp, #20
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   26c9a:	2203      	movs	r2, #3
   26c9c:	2101      	movs	r1, #1
{	
   26c9e:	4605      	mov	r5, r0
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   26ca0:	f7ef fdc4 	bl	1682c <USBH_FindInterface>
	if(interface == 0xFF) /* No Valid Interface */
   26ca4:	28ff      	cmp	r0, #255	; 0xff
   26ca6:	d05b      	beq.n	26d60 <USBH_MIDI_InterfaceInit+0xcc>
		phost->pActiveClass->pData = &myMIDIHandle;
   26ca8:	f24f 4428 	movw	r4, #62504	; 0xf428
		USBH_SelectInterface (phost, interface);
   26cac:	4601      	mov	r1, r0
   26cae:	4628      	mov	r0, r5
   26cb0:	f7ef fdb2 	bl	16818 <USBH_SelectInterface>
		phost->pActiveClass->pData = &myMIDIHandle;
   26cb4:	f2c0 240f 	movt	r4, #527	; 0x20f
   26cb8:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   26cbc:	222a      	movs	r2, #42	; 0x2a
		phost->pActiveClass->pData = &myMIDIHandle;
   26cbe:	61dc      	str	r4, [r3, #28]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   26cc0:	f895 3324 	ldrb.w	r3, [r5, #804]	; 0x324
   26cc4:	fb02 5203 	mla	r2, r2, r3, r5
   26cc8:	f892 134e 	ldrb.w	r1, [r2, #846]	; 0x34e
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   26ccc:	f8b2 2350 	ldrh.w	r2, [r2, #848]	; 0x350
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   26cd0:	0608      	lsls	r0, r1, #24
   26cd2:	d442      	bmi.n	26d5a <USBH_MIDI_InterfaceInit+0xc6>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
   26cd4:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   26cd6:	80e2      	strh	r2, [r4, #6]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress & 0x80)
   26cd8:	222a      	movs	r2, #42	; 0x2a
   26cda:	fb02 5303 	mla	r3, r2, r3, r5
   26cde:	f893 1356 	ldrb.w	r1, [r3, #854]	; 0x356
   26ce2:	f8b3 3358 	ldrh.w	r3, [r3, #856]	; 0x358
   26ce6:	060a      	lsls	r2, r1, #24
   26ce8:	d43d      	bmi.n	26d66 <USBH_MIDI_InterfaceInit+0xd2>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
   26cea:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
   26cec:	80e3      	strh	r3, [r4, #6]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   26cee:	4628      	mov	r0, r5
		USBH_OpenPipe  (phost,
   26cf0:	2702      	movs	r7, #2
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   26cf2:	f7f1 f867 	bl	17dc4 <USBH_AllocPipe>
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   26cf6:	7921      	ldrb	r1, [r4, #4]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   26cf8:	70a0      	strb	r0, [r4, #2]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   26cfa:	4628      	mov	r0, r5
   26cfc:	f7f1 f862 	bl	17dc4 <USBH_AllocPipe>
		USBH_OpenPipe  (phost,
   26d00:	f8b4 c006 	ldrh.w	ip, [r4, #6]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   26d04:	7060      	strb	r0, [r4, #1]
		myMIDIHandle.state = MIDI_IDLE_STATE;
   26d06:	2600      	movs	r6, #0
		USBH_OpenPipe  (phost,
   26d08:	f895 031d 	ldrb.w	r0, [r5, #797]	; 0x31d
   26d0c:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
   26d10:	78e2      	ldrb	r2, [r4, #3]
   26d12:	78a1      	ldrb	r1, [r4, #2]
   26d14:	9000      	str	r0, [sp, #0]
   26d16:	4628      	mov	r0, r5
   26d18:	e9cd 7c01 	strd	r7, ip, [sp, #4]
   26d1c:	f7f1 f83c 	bl	17d98 <USBH_OpenPipe>
		USBH_OpenPipe  (phost,
   26d20:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
   26d24:	f8b4 c008 	ldrh.w	ip, [r4, #8]
   26d28:	4628      	mov	r0, r5
   26d2a:	9701      	str	r7, [sp, #4]
   26d2c:	f895 731d 	ldrb.w	r7, [r5, #797]	; 0x31d
   26d30:	7922      	ldrb	r2, [r4, #4]
   26d32:	f8cd c008 	str.w	ip, [sp, #8]
   26d36:	7861      	ldrb	r1, [r4, #1]
   26d38:	9700      	str	r7, [sp, #0]
   26d3a:	f7f1 f82d 	bl	17d98 <USBH_OpenPipe>
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
   26d3e:	4632      	mov	r2, r6
   26d40:	7861      	ldrb	r1, [r4, #1]
   26d42:	4628      	mov	r0, r5
		myMIDIHandle.state = MIDI_IDLE_STATE;
   26d44:	7026      	strb	r6, [r4, #0]
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
   26d46:	f000 f955 	bl	26ff4 <USBH_LL_SetToggle>
		USBH_LL_SetToggle  (phost, myMIDIHandle.OutPipe,0);
   26d4a:	4632      	mov	r2, r6
   26d4c:	78a1      	ldrb	r1, [r4, #2]
   26d4e:	4628      	mov	r0, r5
   26d50:	f000 f950 	bl	26ff4 <USBH_LL_SetToggle>
   26d54:	4630      	mov	r0, r6
}
   26d56:	b005      	add	sp, #20
   26d58:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
   26d5a:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   26d5c:	8122      	strh	r2, [r4, #8]
   26d5e:	e7bb      	b.n	26cd8 <USBH_MIDI_InterfaceInit+0x44>
		status = USBH_FAIL;
   26d60:	2002      	movs	r0, #2
}
   26d62:	b005      	add	sp, #20
   26d64:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
   26d66:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
   26d68:	8123      	strh	r3, [r4, #8]
   26d6a:	78e1      	ldrb	r1, [r4, #3]
   26d6c:	e7bf      	b.n	26cee <USBH_MIDI_InterfaceInit+0x5a>
   26d6e:	bf00      	nop

00026d70 <USBH_MIDI_Stop>:
  if(phost->gState == HOST_CLASS)
   26d70:	7802      	ldrb	r2, [r0, #0]
   26d72:	2a0b      	cmp	r2, #11
   26d74:	d001      	beq.n	26d7a <USBH_MIDI_Stop+0xa>
}
   26d76:	2000      	movs	r0, #0
   26d78:	4770      	bx	lr
{
   26d7a:	b538      	push	{r3, r4, r5, lr}
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26d7c:	f8d0 24ec 	ldr.w	r2, [r0, #1260]	; 0x4ec
    MIDI_Handle->state = MIDI_IDLE_STATE;
   26d80:	2300      	movs	r3, #0
   26d82:	4604      	mov	r4, r0
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26d84:	69d5      	ldr	r5, [r2, #28]
    MIDI_Handle->state = MIDI_IDLE_STATE;
   26d86:	702b      	strb	r3, [r5, #0]
    USBH_ClosePipe(phost, MIDI_Handle->InPipe);
   26d88:	7869      	ldrb	r1, [r5, #1]
   26d8a:	f7f1 f815 	bl	17db8 <USBH_ClosePipe>
    USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
   26d8e:	78a9      	ldrb	r1, [r5, #2]
   26d90:	4620      	mov	r0, r4
   26d92:	f7f1 f811 	bl	17db8 <USBH_ClosePipe>
}
   26d96:	2000      	movs	r0, #0
   26d98:	bd38      	pop	{r3, r4, r5, pc}
   26d9a:	bf00      	nop

00026d9c <USBH_MIDI_Receive>:
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   26d9c:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
   26da0:	69db      	ldr	r3, [r3, #28]
	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
   26da2:	7818      	ldrb	r0, [r3, #0]
   26da4:	2801      	cmp	r0, #1
   26da6:	d901      	bls.n	26dac <USBH_MIDI_Receive+0x10>
	USBH_StatusTypeDef Status = USBH_BUSY;
   26da8:	2001      	movs	r0, #1
#if (USBH_USE_OS == 1)
		osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);
#endif
	}
	return Status;
}
   26daa:	4770      	bx	lr
{
   26dac:	b430      	push	{r4, r5}
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   26dae:	2501      	movs	r5, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26db0:	2403      	movs	r4, #3
		MIDI_Handle->pRxData = pbuff;
   26db2:	6119      	str	r1, [r3, #16]
		Status = USBH_OK;
   26db4:	2000      	movs	r0, #0
		MIDI_Handle->RxDataLength = length;
   26db6:	82da      	strh	r2, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   26db8:	701d      	strb	r5, [r3, #0]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   26dba:	765c      	strb	r4, [r3, #25]
}
   26dbc:	bc30      	pop	{r4, r5}
   26dbe:	4770      	bx	lr

00026dc0 <HAL_HCD_MspInit>:
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcdHandle->Instance==USB_OTG_FS)
   26dc0:	2300      	movs	r3, #0
{
   26dc2:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   26dc4:	461c      	mov	r4, r3
  if(hcdHandle->Instance==USB_OTG_FS)
   26dc6:	6802      	ldr	r2, [r0, #0]
   26dc8:	f2c4 0308 	movt	r3, #16392	; 0x4008
{
   26dcc:	b088      	sub	sp, #32
  if(hcdHandle->Instance==USB_OTG_FS)
   26dce:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   26dd0:	9407      	str	r4, [sp, #28]
   26dd2:	e9cd 4403 	strd	r4, r4, [sp, #12]
   26dd6:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(hcdHandle->Instance==USB_OTG_FS)
   26dda:	d001      	beq.n	26de0 <HAL_HCD_MspInit+0x20>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
//
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
   26ddc:	b008      	add	sp, #32
   26dde:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
   26de0:	f44f 4588 	mov.w	r5, #17408	; 0x4400
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   26de4:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   26de8:	2202      	movs	r2, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   26dea:	4620      	mov	r0, r4
    __HAL_RCC_GPIOA_CLK_ENABLE();
   26dec:	f6c5 0502 	movt	r5, #22530	; 0x5802
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   26df0:	a903      	add	r1, sp, #12
   26df2:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOA_CLK_ENABLE();
   26df6:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
   26dfa:	f043 0301 	orr.w	r3, r3, #1
   26dfe:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
   26e02:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   26e06:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   26e08:	2603      	movs	r6, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
   26e0a:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   26e0e:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
   26e10:	220a      	movs	r2, #10
    __HAL_RCC_GPIOA_CLK_ENABLE();
   26e12:	9301      	str	r3, [sp, #4]
   26e14:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
   26e16:	e9cd 6206 	strd	r6, r2, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   26e1a:	f7e5 fbbd 	bl	c598 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   26e1e:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   26e22:	4622      	mov	r2, r4
   26e24:	2101      	movs	r1, #1
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   26e26:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   26e2a:	2065      	movs	r0, #101	; 0x65
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   26e2c:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
   26e30:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
   26e34:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
   26e38:	9302      	str	r3, [sp, #8]
   26e3a:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   26e3c:	f7e2 ff1e 	bl	9c7c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
   26e40:	2065      	movs	r0, #101	; 0x65
   26e42:	f7e2 ff6b 	bl	9d1c <HAL_NVIC_EnableIRQ>
}
   26e46:	b008      	add	sp, #32
   26e48:	bd70      	pop	{r4, r5, r6, pc}
   26e4a:	bf00      	nop

00026e4c <USBH_LL_Init>:
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
   26e4c:	f890 253c 	ldrb.w	r2, [r0, #1340]	; 0x53c
   26e50:	2a01      	cmp	r2, #1
   26e52:	d001      	beq.n	26e58 <USBH_LL_Init+0xc>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
  }
  return USBH_OK;
}
   26e54:	2000      	movs	r0, #0
   26e56:	4770      	bx	lr
{
   26e58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   26e5a:	f24f 5344 	movw	r3, #62788	; 0xf544
   26e5e:	2100      	movs	r1, #0
   26e60:	4604      	mov	r4, r0
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
   26e62:	2706      	movs	r7, #6
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   26e64:	f2c0 230f 	movt	r3, #527	; 0x20f
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
   26e68:	2602      	movs	r6, #2
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   26e6a:	f2c4 0108 	movt	r1, #16392	; 0x4008
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   26e6e:	2500      	movs	r5, #0
  phost->pData = &hhcd_USB_OTG_FS;
   26e70:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   26e74:	4618      	mov	r0, r3
  hhcd_USB_OTG_FS.pData = phost;
   26e76:	f8c3 42c0 	str.w	r4, [r3, #704]	; 0x2c0
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   26e7a:	6019      	str	r1, [r3, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
   26e7c:	609f      	str	r7, [r3, #8]
  hhcd_USB_OTG_FS.Init.dma_enable = ENABLE;
   26e7e:	e9c3 2203 	strd	r2, r2, [r3, #12]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   26e82:	e9c3 6506 	strd	r6, r5, [r3, #24]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   26e86:	f7e5 ff9d 	bl	cdc4 <HAL_HCD_Init>
   26e8a:	b958      	cbnz	r0, 26ea4 <USBH_LL_Init+0x58>
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
   26e8c:	f24f 5044 	movw	r0, #62788	; 0xf544
   26e90:	f2c0 200f 	movt	r0, #527	; 0x20f
   26e94:	f7e6 f8a2 	bl	cfdc <HAL_HCD_GetCurrentFrame>
   26e98:	4601      	mov	r1, r0
   26e9a:	4620      	mov	r0, r4
   26e9c:	f7f0 f81e 	bl	16edc <USBH_LL_SetTimer>
}
   26ea0:	2000      	movs	r0, #0
   26ea2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Error_Handler( );
   26ea4:	f7f4 f902 	bl	1b0ac <Error_Handler>
   26ea8:	e7f0      	b.n	26e8c <USBH_LL_Init+0x40>
   26eaa:	bf00      	nop

00026eac <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
   26eac:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Start(phost->pData);
   26eae:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26eb2:	f7e6 f859 	bl	cf68 <HAL_HCD_Start>
   26eb6:	2803      	cmp	r0, #3
   26eb8:	d805      	bhi.n	26ec6 <USBH_LL_Start+0x1a>
   26eba:	f645 634c 	movw	r3, #24140	; 0x5e4c
   26ebe:	f2c0 0303 	movt	r3, #3
   26ec2:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   26ec4:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Start(phost->pData);
   26ec6:	2002      	movs	r0, #2
}
   26ec8:	bd08      	pop	{r3, pc}
   26eca:	bf00      	nop

00026ecc <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
   26ecc:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Stop(phost->pData);
   26ece:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26ed2:	f7e6 f85f 	bl	cf94 <HAL_HCD_Stop>
   26ed6:	2803      	cmp	r0, #3
   26ed8:	d805      	bhi.n	26ee6 <USBH_LL_Stop+0x1a>
   26eda:	f645 634c 	movw	r3, #24140	; 0x5e4c
   26ede:	f2c0 0303 	movt	r3, #3
   26ee2:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
 
  return usb_status;
}
   26ee4:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Stop(phost->pData);
   26ee6:	2002      	movs	r0, #2
}
   26ee8:	bd08      	pop	{r3, pc}
   26eea:	bf00      	nop

00026eec <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
   26eec:	b508      	push	{r3, lr}
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   26eee:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26ef2:	f7e6 f877 	bl	cfe4 <HAL_HCD_GetCurrentSpeed>
   26ef6:	2802      	cmp	r0, #2
   26ef8:	d805      	bhi.n	26f06 <USBH_LL_GetSpeed+0x1a>
   26efa:	f645 6348 	movw	r3, #24136	; 0x5e48
   26efe:	f2c0 0303 	movt	r3, #3
   26f02:	5c18      	ldrb	r0, [r3, r0]
  default:
   speed = USBH_SPEED_FULL;
    break;
  }
  return  speed;
}
   26f04:	bd08      	pop	{r3, pc}
  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   26f06:	2001      	movs	r0, #1
}
   26f08:	bd08      	pop	{r3, pc}
   26f0a:	bf00      	nop

00026f0c <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
   26f0c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_ResetPort(phost->pData);
   26f0e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26f12:	f7e6 f851 	bl	cfb8 <HAL_HCD_ResetPort>
   26f16:	2803      	cmp	r0, #3
   26f18:	d805      	bhi.n	26f26 <USBH_LL_ResetPort+0x1a>
   26f1a:	f645 634c 	movw	r3, #24140	; 0x5e4c
   26f1e:	f2c0 0303 	movt	r3, #3
   26f22:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   26f24:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_ResetPort(phost->pData);
   26f26:	2002      	movs	r0, #2
}
   26f28:	bd08      	pop	{r3, pc}
   26f2a:	bf00      	nop

00026f2c <USBH_LL_GetLastXferSize>:
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
   26f2c:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26f30:	f7e6 b84e 	b.w	cfd0 <HAL_HCD_HC_GetXferCount>

00026f34 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
   26f34:	b530      	push	{r4, r5, lr}
   26f36:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   26f38:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
   26f3c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   26f40:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   26f44:	9400      	str	r4, [sp, #0]
{
   26f46:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   26f4a:	e9cd 5401 	strd	r5, r4, [sp, #4]
   26f4e:	f7e5 feeb 	bl	cd28 <HAL_HCD_HC_Init>
   26f52:	2803      	cmp	r0, #3
   26f54:	d806      	bhi.n	26f64 <USBH_LL_OpenPipe+0x30>
   26f56:	f645 634c 	movw	r3, #24140	; 0x5e4c
   26f5a:	f2c0 0303 	movt	r3, #3
   26f5e:	5c18      	ldrb	r0, [r3, r0]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   26f60:	b005      	add	sp, #20
   26f62:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   26f64:	2002      	movs	r0, #2
}
   26f66:	b005      	add	sp, #20
   26f68:	bd30      	pop	{r4, r5, pc}
   26f6a:	bf00      	nop

00026f6c <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
   26f6c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
   26f6e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26f72:	f7e5 ff15 	bl	cda0 <HAL_HCD_HC_Halt>
   26f76:	2803      	cmp	r0, #3
   26f78:	d805      	bhi.n	26f86 <USBH_LL_ClosePipe+0x1a>
   26f7a:	f645 634c 	movw	r3, #24140	; 0x5e4c
   26f7e:	f2c0 0303 	movt	r3, #3
   26f82:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   26f84:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
   26f86:	2002      	movs	r0, #2
}
   26f88:	bd08      	pop	{r3, pc}
   26f8a:	bf00      	nop

00026f8c <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
   26f8c:	b530      	push	{r4, r5, lr}
   26f8e:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   26f90:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
   26f94:	f89d 5020 	ldrb.w	r5, [sp, #32]
   26f98:	9c09      	ldr	r4, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   26f9a:	9500      	str	r5, [sp, #0]
   26f9c:	9401      	str	r4, [sp, #4]
{
   26f9e:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
   26fa2:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   26fa6:	e9cd 5402 	strd	r5, r4, [sp, #8]
   26faa:	f7e5 ff6d 	bl	ce88 <HAL_HCD_HC_SubmitRequest>
   26fae:	2803      	cmp	r0, #3
   26fb0:	d806      	bhi.n	26fc0 <USBH_LL_SubmitURB+0x34>
   26fb2:	f645 634c 	movw	r3, #24140	; 0x5e4c
   26fb6:	f2c0 0303 	movt	r3, #3
   26fba:	5c18      	ldrb	r0, [r3, r0]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   26fbc:	b005      	add	sp, #20
   26fbe:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   26fc0:	2002      	movs	r0, #2
}
   26fc2:	b005      	add	sp, #20
   26fc4:	bd30      	pop	{r4, r5, pc}
   26fc6:	bf00      	nop

00026fc8 <USBH_LL_GetURBState>:
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
   26fc8:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   26fcc:	f7e5 bff8 	b.w	cfc0 <HAL_HCD_HC_GetURBState>

00026fd0 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Active
  *           1 : VBUS Inactive
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
   26fd0:	b508      	push	{r3, lr}
  if (phost->id == HOST_FS) {
   26fd2:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
   26fd6:	2b01      	cmp	r3, #1
   26fd8:	d004      	beq.n	26fe4 <USBH_LL_DriverVBUS+0x14>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
   26fda:	20c8      	movs	r0, #200	; 0xc8
   26fdc:	f7e1 fa36 	bl	844c <HAL_Delay>
  return USBH_OK;
}
   26fe0:	2000      	movs	r0, #0
   26fe2:	bd08      	pop	{r3, pc}
    MX_DriverVbusFS(state);
   26fe4:	4608      	mov	r0, r1
   26fe6:	f000 f819 	bl	2701c <MX_DriverVbusFS>
  HAL_Delay(200);
   26fea:	20c8      	movs	r0, #200	; 0xc8
   26fec:	f7e1 fa2e 	bl	844c <HAL_Delay>
}
   26ff0:	2000      	movs	r0, #0
   26ff2:	bd08      	pop	{r3, pc}

00026ff4 <USBH_LL_SetToggle>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
   26ff4:	f8d0 3540 	ldr.w	r3, [r0, #1344]	; 0x540

  if(pHandle->hc[pipe].ep_is_in)
   26ff8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   26ffc:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   27000:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
   27004:	b91b      	cbnz	r3, 2700e <USBH_LL_SetToggle+0x1a>
  {
    pHandle->hc[pipe].toggle_in = toggle;
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
   27006:	f881 2051 	strb.w	r2, [r1, #81]	; 0x51
  }

  return USBH_OK;
}
   2700a:	2000      	movs	r0, #0
   2700c:	4770      	bx	lr
    pHandle->hc[pipe].toggle_in = toggle;
   2700e:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
}
   27012:	2000      	movs	r0, #0
   27014:	4770      	bx	lr
   27016:	bf00      	nop

00027018 <USBH_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
   27018:	f7e1 ba18 	b.w	844c <HAL_Delay>

0002701c <MX_DriverVbusFS>:
  {
    /* Drive low Charge pump */
    data = GPIO_PIN_RESET;
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,(GPIO_PinState)data);
   2701c:	fab0 f280 	clz	r2, r0
   27020:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
   27024:	2140      	movs	r1, #64	; 0x40
   27026:	0952      	lsrs	r2, r2, #5
   27028:	f6c5 0002 	movt	r0, #22530	; 0x5802
   2702c:	f7e5 be5e 	b.w	ccec <HAL_GPIO_WritePin>

00027030 <mayer_fht>:
 REAL f0,g0,f1,g1,f2,g2,f3,g3; */
 int  k,k1,k2,k3,k4,kx;
 REAL *fi,*fn,*gi;
 TRIG_VARS;

 for (k1=1,k2=0;k1<n;k1++)
   27030:	2901      	cmp	r1, #1
{
   27032:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27036:	468e      	mov	lr, r1
   27038:	ed2d 8b02 	vpush	{d8}
   2703c:	b08d      	sub	sp, #52	; 0x34
 for (k1=1,k2=0;k1<n;k1++)
   2703e:	f340 824b 	ble.w	274d8 <mayer_fht+0x4a8>
    {
     REAL aa;
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   27042:	ea4f 0a61 	mov.w	sl, r1, asr #1
   27046:	f100 0904 	add.w	r9, r0, #4
 for (k1=1,k2=0;k1<n;k1++)
   2704a:	f04f 0c00 	mov.w	ip, #0
   2704e:	f04f 0801 	mov.w	r8, #1
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   27052:	ea3a 010c 	bics.w	r1, sl, ip
   27056:	ea8a 040c 	eor.w	r4, sl, ip
   2705a:	f040 823b 	bne.w	274d4 <mayer_fht+0x4a4>
   2705e:	4651      	mov	r1, sl
   27060:	1049      	asrs	r1, r1, #1
   27062:	ea81 0c04 	eor.w	ip, r1, r4
   27066:	ea21 0504 	bic.w	r5, r1, r4
   2706a:	4664      	mov	r4, ip
   2706c:	2d00      	cmp	r5, #0
   2706e:	d0f7      	beq.n	27060 <mayer_fht+0x30>
     if (k1>k2)
   27070:	45c4      	cmp	ip, r8
   27072:	da07      	bge.n	27084 <mayer_fht+0x54>
        {
             aa=fz[k1];fz[k1]=fz[k2];fz[k2]=aa;
   27074:	eb00 018c 	add.w	r1, r0, ip, lsl #2
   27078:	f8d9 4000 	ldr.w	r4, [r9]
   2707c:	680d      	ldr	r5, [r1, #0]
   2707e:	f8c9 5000 	str.w	r5, [r9]
   27082:	600c      	str	r4, [r1, #0]
 for (k1=1,k2=0;k1<n;k1++)
   27084:	f108 0801 	add.w	r8, r8, #1
   27088:	f109 0904 	add.w	r9, r9, #4
   2708c:	45c6      	cmp	lr, r8
   2708e:	d1e0      	bne.n	27052 <mayer_fht+0x22>
        }
    }
 for ( k=0 ; (1<<k)<n ; k++ );
   27090:	2100      	movs	r1, #0
   27092:	2501      	movs	r5, #1
   27094:	3101      	adds	r1, #1
   27096:	fa05 f401 	lsl.w	r4, r5, r1
   2709a:	4544      	cmp	r4, r8
   2709c:	dbfa      	blt.n	27094 <mayer_fht+0x64>
 k  &= 1;
 if (k==0)
   2709e:	f011 0101 	ands.w	r1, r1, #1
   270a2:	eb00 0a88 	add.w	sl, r0, r8, lsl #2
   270a6:	9101      	str	r1, [sp, #4]
   270a8:	f000 8218 	beq.w	274dc <mayer_fht+0x4ac>
             fi[1 ] = (f1+f3);
            }
    }
 else
    {
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
   270ac:	4550      	cmp	r0, sl
   270ae:	d26e      	bcs.n	2718e <mayer_fht+0x15e>
   270b0:	f100 0420 	add.w	r4, r0, #32
             bf0     = (bs1 + bs2);
             bg1     = (bc1 - bc2);     
             bg0     = (bc1 + bc2);
             bf3     = (bs3 - bs4);     
             bf2     = (bs3 + bs4);
             bg3     = SQRT2*bc4;               
   270b4:	f643 36cd 	movw	r6, #15309	; 0x3bcd
   270b8:	f24a 079e 	movw	r7, #41118	; 0xa09e
   270bc:	f100 0540 	add.w	r5, r0, #64	; 0x40
   270c0:	f1c4 011f 	rsb	r1, r4, #31
   270c4:	f2c6 667f 	movt	r6, #26239	; 0x667f
   270c8:	f6c3 77f6 	movt	r7, #16374	; 0x3ff6
   270cc:	4451      	add	r1, sl
   270ce:	f021 011f 	bic.w	r1, r1, #31
   270d2:	4429      	add	r1, r5
   270d4:	ec47 6b13 	vmov	d3, r6, r7
             bc3     = fi[4 ] - gi[4 ];
   270d8:	ed54 7a03 	vldr	s15, [r4, #-12]
   270dc:	3420      	adds	r4, #32
             bc4     = fi[6 ] - gi[6 ];
   270de:	ed14 6a0a 	vldr	s12, [r4, #-40]	; 0xffffffd8
   270e2:	ed14 7a09 	vldr	s14, [r4, #-36]	; 0xffffffdc
             bc3     = fi[4 ] - gi[4 ];
   270e6:	ed54 6a0c 	vldr	s13, [r4, #-48]	; 0xffffffd0
             bc4     = fi[6 ] - gi[6 ];
   270ea:	ee36 2a47 	vsub.f32	s4, s12, s14
             bc1     = fi[0 ] - gi[0 ];
   270ee:	ed54 5a0f 	vldr	s11, [r4, #-60]	; 0xffffffc4
             bc3     = fi[4 ] - gi[4 ];
   270f2:	ee36 0ae7 	vsub.f32	s0, s13, s15
             bc2     = fi[2 ] - gi[2 ];
   270f6:	ed54 4a0e 	vldr	s9, [r4, #-56]	; 0xffffffc8
             bc1     = fi[0 ] - gi[0 ];
   270fa:	ed14 5a10 	vldr	s10, [r4, #-64]	; 0xffffffc0
             bs3     = fi[4 ] + gi[4 ];
   270fe:	ee76 6aa7 	vadd.f32	s13, s13, s15
             bg3     = SQRT2*bc4;               
   27102:	eeb7 2ac2 	vcvt.f64.f32	d2, s4
             bc2     = fi[2 ] - gi[2 ];
   27106:	ed54 7a0d 	vldr	s15, [r4, #-52]	; 0xffffffcc
             bg2     = SQRT2*bc3;
   2710a:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
             bc1     = fi[0 ] - gi[0 ];
   2710e:	ee75 1a65 	vsub.f32	s3, s10, s11
             bg3     = SQRT2*bc4;               
   27112:	ee22 2b03 	vmul.f64	d2, d2, d3
             bg2     = SQRT2*bc3;
   27116:	ee20 0b03 	vmul.f64	d0, d0, d3
             bc2     = fi[2 ] - gi[2 ];
   2711a:	ee34 4ae7 	vsub.f32	s8, s9, s15
             bs1     = fi[0 ] + gi[0 ];
   2711e:	ee35 5a25 	vadd.f32	s10, s10, s11
             bg3     = SQRT2*bc4;               
   27122:	eeb7 2bc2 	vcvt.f32.f64	s4, d2
             bs2     = fi[2 ] + gi[2 ];
   27126:	ee74 5aa7 	vadd.f32	s11, s9, s15
             bg2     = SQRT2*bc3;
   2712a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
             bs4     = fi[6 ] + gi[6 ];
   2712e:	ee76 7a07 	vadd.f32	s15, s12, s14
             bg0     = (bc1 + bc2);
   27132:	ee31 1a84 	vadd.f32	s2, s3, s8
             bg1     = (bc1 - bc2);     
   27136:	ee71 4ac4 	vsub.f32	s9, s3, s8
             bf1     = (bs1 - bs2);     
   2713a:	ee35 7a65 	vsub.f32	s14, s10, s11
             bf2     = (bs3 + bs4);
   2713e:	ee36 6aa7 	vadd.f32	s12, s13, s15
             bf0     = (bs1 + bs2);
   27142:	ee75 5a25 	vadd.f32	s11, s10, s11
             bf3     = (bs3 - bs4);     
   27146:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[4 ] = bf0 - bf2;
             fi[0 ] = bf0 + bf2;
             fi[6 ] = bf1 - bf3;
             fi[2 ] = bf1 + bf3;
             gi[4 ] = bg0 - bg2;
   2714a:	ee31 5a40 	vsub.f32	s10, s2, s0
             gi[0 ] = bg0 + bg2;
             gi[6 ] = bg1 - bg3;
   2714e:	ee74 6ac2 	vsub.f32	s13, s9, s4
             gi[0 ] = bg0 + bg2;
   27152:	ee31 0a00 	vadd.f32	s0, s2, s0
             gi[4 ] = bg0 - bg2;
   27156:	ed04 5a0b 	vstr	s10, [r4, #-44]	; 0xffffffd4
             gi[2 ] = bg1 + bg3;
   2715a:	ee34 2a82 	vadd.f32	s4, s9, s4
             gi[6 ] = bg1 - bg3;
   2715e:	ed44 6a09 	vstr	s13, [r4, #-36]	; 0xffffffdc
             fi[4 ] = bf0 - bf2;
   27162:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[6 ] = bf1 - bf3;
   27166:	ee77 6a67 	vsub.f32	s13, s14, s15
             gi[0 ] = bg0 + bg2;
   2716a:	ed04 0a0f 	vstr	s0, [r4, #-60]	; 0xffffffc4
             fi[0 ] = bf0 + bf2;
   2716e:	ee35 6a86 	vadd.f32	s12, s11, s12
             gi[2 ] = bg1 + bg3;
   27172:	ed04 2a0d 	vstr	s4, [r4, #-52]	; 0xffffffcc
             fi[2 ] = bf1 + bf3;
   27176:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[4 ] = bf0 - bf2;
   2717a:	ed04 5a0c 	vstr	s10, [r4, #-48]	; 0xffffffd0
             fi[6 ] = bf1 - bf3;
   2717e:	ed44 6a0a 	vstr	s13, [r4, #-40]	; 0xffffffd8
             fi[0 ] = bf0 + bf2;
   27182:	ed04 6a10 	vstr	s12, [r4, #-64]	; 0xffffffc0
             fi[2 ] = bf1 + bf3;
   27186:	ed44 7a0e 	vstr	s15, [r4, #-56]	; 0xffffffc8
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
   2718a:	42a1      	cmp	r1, r4
   2718c:	d1a4      	bne.n	270d8 <mayer_fht+0xa8>
            }
    }
 if (n<16) return;
   2718e:	f1be 0f0f 	cmp.w	lr, #15
   27192:	f340 819a 	ble.w	274ca <mayer_fht+0x49a>
   27196:	9901      	ldr	r1, [sp, #4]
             fi[0 ]  = f0         + f2;
             fi[k3]  = f1         - f3;
             fi[k1]  = f1         + f3;
             g1      = gi[0 ] - gi[k1];
             g0      = gi[0 ] + gi[k1];
             g3      = SQRT2  * gi[k3];
   27198:	f643 32cd 	movw	r2, #15309	; 0x3bcd
   2719c:	f24a 039e 	movw	r3, #41118	; 0xa09e
   271a0:	3101      	adds	r1, #1
   271a2:	f2c6 627f 	movt	r2, #26239	; 0x667f
   271a6:	f6c3 73f6 	movt	r3, #16374	; 0x3ff6
   271aa:	0089      	lsls	r1, r1, #2
   271ac:	9107      	str	r1, [sp, #28]
            } while (fi<fn);
     TRIG_INIT(k,c1,s1);
     for (ii=1;ii<kx;ii++)
        {
         REAL c2,s2;
         TRIG_NEXT(k,c1,s1);
   271ae:	f645 61a0 	movw	r1, #24224	; 0x5ea0
   271b2:	f2c0 0103 	movt	r1, #3
             g3      = SQRT2  * gi[k3];
   271b6:	ec43 2b18 	vmov	d8, r2, r3
   271ba:	e9cd 0e0a 	strd	r0, lr, [sp, #40]	; 0x28
         TRIG_NEXT(k,c1,s1);
   271be:	9108      	str	r1, [sp, #32]
     k  += 2;
   271c0:	9901      	ldr	r1, [sp, #4]
     k1  = 1  << k;
   271c2:	2501      	movs	r5, #1
             f1      = fi[0 ] - fi[k1];
   271c4:	2204      	movs	r2, #4
             gi     += k4;
   271c6:	980a      	ldr	r0, [sp, #40]	; 0x28
     k  += 2;
   271c8:	3102      	adds	r1, #2
             gi     += k4;
   271ca:	4603      	mov	r3, r0
     k1  = 1  << k;
   271cc:	408d      	lsls	r5, r1
             f1      = fi[0 ] - fi[k1];
   271ce:	fa02 f401 	lsl.w	r4, r2, r1
     k  += 2;
   271d2:	9101      	str	r1, [sp, #4]
     kx  = k1 >> 1;
   271d4:	106f      	asrs	r7, r5, #1
   271d6:	eb00 0e04 	add.w	lr, r0, r4
     k3  = k2 + k1;
   271da:	eb05 0145 	add.w	r1, r5, r5, lsl #1
             f1      = fi[0 ] - fi[k1];
   271de:	9404      	str	r4, [sp, #16]
         gi  = fi + kx;
   271e0:	eb00 0287 	add.w	r2, r0, r7, lsl #2
     kx  = k1 >> 1;
   271e4:	9703      	str	r7, [sp, #12]
             f3      = fi[k2] - fi[k3];
   271e6:	0089      	lsls	r1, r1, #2
   271e8:	00ee      	lsls	r6, r5, #3
   271ea:	eb02 0c04 	add.w	ip, r2, r4
   271ee:	460c      	mov	r4, r1
   271f0:	9106      	str	r1, [sp, #24]
   271f2:	9605      	str	r6, [sp, #20]
   271f4:	1857      	adds	r7, r2, r1
   271f6:	1906      	adds	r6, r0, r4
   271f8:	4601      	mov	r1, r0
   271fa:	00ec      	lsls	r4, r5, #3
   271fc:	1910      	adds	r0, r2, r4
   271fe:	4421      	add	r1, r4
     k4  = k2 << 1;
   27200:	00ac      	lsls	r4, r5, #2
   27202:	9409      	str	r4, [sp, #36]	; 0x24
             gi     += k4;
   27204:	012c      	lsls	r4, r5, #4
             f1      = fi[0 ] - fi[k1];
   27206:	ed93 6a00 	vldr	s12, [r3]
             f3      = fi[k2] - fi[k3];
   2720a:	edd6 6a00 	vldr	s13, [r6]
             f1      = fi[0 ] - fi[k1];
   2720e:	ed9e 7a00 	vldr	s14, [lr]
             f3      = fi[k2] - fi[k3];
   27212:	edd1 7a00 	vldr	s15, [r1]
             f0      = fi[0 ] + fi[k1];
   27216:	ee76 5a07 	vadd.f32	s11, s12, s14
             f1      = fi[0 ] - fi[k1];
   2721a:	ee36 7a47 	vsub.f32	s14, s12, s14
             f2      = fi[k2] + fi[k3];
   2721e:	ee37 6aa6 	vadd.f32	s12, s15, s13
             f3      = fi[k2] - fi[k3];
   27222:	ee77 7ae6 	vsub.f32	s15, s15, s13
             fi[k2]  = f0         - f2;
   27226:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[k3]  = f1         - f3;
   2722a:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ]  = f0         + f2;
   2722e:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[k1]  = f1         + f3;
   27232:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[k2]  = f0         - f2;
   27236:	ed81 5a00 	vstr	s10, [r1]
   2723a:	4421      	add	r1, r4
             fi[0 ]  = f0         + f2;
   2723c:	ed83 6a00 	vstr	s12, [r3]
             fi     += k4;
   27240:	4423      	add	r3, r4
             fi[k3]  = f1         - f3;
   27242:	edc6 6a00 	vstr	s13, [r6]
   27246:	4426      	add	r6, r4
             fi[k1]  = f1         + f3;
   27248:	edce 7a00 	vstr	s15, [lr]
            } while (fi<fn);
   2724c:	4553      	cmp	r3, sl
             g2      = SQRT2  * gi[k2];
   2724e:	ed90 5a00 	vldr	s10, [r0]
   27252:	44a6      	add	lr, r4
             g3      = SQRT2  * gi[k3];
   27254:	ed97 7a00 	vldr	s14, [r7]
             g2      = SQRT2  * gi[k2];
   27258:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
             g1      = gi[0 ] - gi[k1];
   2725c:	ed92 6a00 	vldr	s12, [r2]
             g3      = SQRT2  * gi[k3];
   27260:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
             g1      = gi[0 ] - gi[k1];
   27264:	eddc 6a00 	vldr	s13, [ip]
             g2      = SQRT2  * gi[k2];
   27268:	ee25 5b08 	vmul.f64	d5, d5, d8
             g3      = SQRT2  * gi[k3];
   2726c:	ee27 7b08 	vmul.f64	d7, d7, d8
             g2      = SQRT2  * gi[k2];
   27270:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
             g0      = gi[0 ] + gi[k1];
   27274:	ee76 5a26 	vadd.f32	s11, s12, s13
             g1      = gi[0 ] - gi[k1];
   27278:	ee76 6a66 	vsub.f32	s13, s12, s13
             g3      = SQRT2  * gi[k3];
   2727c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
             gi[k2]  = g0         - g2;
   27280:	ee35 6ac5 	vsub.f32	s12, s11, s10
             gi[0 ]  = g0         + g2;
   27284:	ee35 5a85 	vadd.f32	s10, s11, s10
             gi[k3]  = g1         - g3;
   27288:	ee76 7ac7 	vsub.f32	s15, s13, s14
             gi[k1]  = g1         + g3;
   2728c:	ee36 7a87 	vadd.f32	s14, s13, s14
             gi[k2]  = g0         - g2;
   27290:	ed80 6a00 	vstr	s12, [r0]
             gi[0 ]  = g0         + g2;
   27294:	ed82 5a00 	vstr	s10, [r2]
   27298:	4420      	add	r0, r4
             gi[k3]  = g1         - g3;
   2729a:	edc7 7a00 	vstr	s15, [r7]
             gi     += k4;
   2729e:	4422      	add	r2, r4
             gi[k1]  = g1         + g3;
   272a0:	ed8c 7a00 	vstr	s14, [ip]
   272a4:	4427      	add	r7, r4
   272a6:	44a4      	add	ip, r4
            } while (fi<fn);
   272a8:	d3ad      	bcc.n	27206 <mayer_fht+0x1d6>
   272aa:	9e07      	ldr	r6, [sp, #28]
   272ac:	f645 6158 	movw	r1, #24152	; 0x5e58
   272b0:	f246 20fc 	movw	r0, #25340	; 0x62fc
   272b4:	4632      	mov	r2, r6
   272b6:	f2c0 0103 	movt	r1, #3
   272ba:	f2c0 0006 	movt	r0, #6
   272be:	f008 ff6d 	bl	3019c <memcpy>
   272c2:	f645 61f8 	movw	r1, #24312	; 0x5ef8
   272c6:	f246 304c 	movw	r0, #25420	; 0x634c
   272ca:	4632      	mov	r2, r6
   272cc:	f2c0 0103 	movt	r1, #3
   272d0:	f2c0 0006 	movt	r0, #6
   272d4:	f008 ff62 	bl	3019c <memcpy>
     for (ii=1;ii<kx;ii++)
   272d8:	9b03      	ldr	r3, [sp, #12]
   272da:	2b01      	cmp	r3, #1
   272dc:	f340 80ed 	ble.w	274ba <mayer_fht+0x48a>
   272e0:	f64f 78ff 	movw	r8, #65535	; 0xffff
   272e4:	f246 21f4 	movw	r1, #25332	; 0x62f4
   272e8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   272ea:	f246 3b44 	movw	fp, #25412	; 0x6344
   272ee:	f6c3 78ff 	movt	r8, #16383	; 0x3fff
   272f2:	f2c0 0106 	movt	r1, #6
   272f6:	f102 0904 	add.w	r9, r2, #4
   272fa:	f2c0 0b06 	movt	fp, #6
   272fe:	44a8      	add	r8, r5
         TRIG_NEXT(k,c1,s1);
   27300:	f04f 0e01 	mov.w	lr, #1
   27304:	2300      	movs	r3, #0
   27306:	4608      	mov	r0, r1
   27308:	eb02 0888 	add.w	r8, r2, r8, lsl #2
   2730c:	9102      	str	r1, [sp, #8]
   2730e:	9a01      	ldr	r2, [sp, #4]
   27310:	1ad2      	subs	r2, r2, r3
   27312:	0091      	lsls	r1, r2, #2
   27314:	2a01      	cmp	r2, #1
   27316:	eb0b 0501 	add.w	r5, fp, r1
   2731a:	4408      	add	r0, r1
   2731c:	ed95 2a00 	vldr	s4, [r5]
   27320:	edd0 2a00 	vldr	s5, [r0]
   27324:	dd30      	ble.n	27388 <mayer_fht+0x358>
   27326:	3302      	adds	r3, #2
   27328:	fa4e f003 	asr.w	r0, lr, r3
   2732c:	07c5      	lsls	r5, r0, #31
   2732e:	d504      	bpl.n	2733a <mayer_fht+0x30a>
   27330:	3301      	adds	r3, #1
   27332:	fa4e f003 	asr.w	r0, lr, r3
   27336:	07c0      	lsls	r0, r0, #31
   27338:	d4fa      	bmi.n	27330 <mayer_fht+0x300>
   2733a:	9801      	ldr	r0, [sp, #4]
   2733c:	3a01      	subs	r2, #1
   2733e:	9e02      	ldr	r6, [sp, #8]
   27340:	1ac3      	subs	r3, r0, r3
   27342:	9808      	ldr	r0, [sp, #32]
   27344:	0092      	lsls	r2, r2, #2
   27346:	4408      	add	r0, r1
   27348:	009b      	lsls	r3, r3, #2
   2734a:	eb0b 0502 	add.w	r5, fp, r2
   2734e:	4432      	add	r2, r6
   27350:	edd0 7a00 	vldr	s15, [r0]
   27354:	eb0b 0003 	add.w	r0, fp, r3
   27358:	4433      	add	r3, r6
   2735a:	edd2 6a00 	vldr	s13, [r2]
   2735e:	ed90 6a00 	vldr	s12, [r0]
   27362:	eb0b 0001 	add.w	r0, fp, r1
   27366:	edd5 5a00 	vldr	s11, [r5]
   2736a:	4431      	add	r1, r6
   2736c:	ed93 7a00 	vldr	s14, [r3]
   27370:	ee35 6a86 	vadd.f32	s12, s11, s12
   27374:	ee36 7a87 	vadd.f32	s14, s13, s14
   27378:	ee66 6a27 	vmul.f32	s13, s12, s15
   2737c:	ee67 7a27 	vmul.f32	s15, s14, s15
   27380:	edc0 6a00 	vstr	s13, [r0]
   27384:	edc1 7a00 	vstr	s15, [r1]
   27388:	9a04      	ldr	r2, [sp, #16]
         c2 = c1*c1 - s1*s1;
   2738a:	ee22 3a42 	vnmul.f32	s6, s4, s4
         s2 = 2*(c1*s1);
   2738e:	ee62 3a22 	vmul.f32	s7, s4, s5
             fn = fz + n;
             fi = fz +ii;
   27392:	464b      	mov	r3, r9
   27394:	eb02 0709 	add.w	r7, r2, r9
   27398:	eb02 0608 	add.w	r6, r2, r8
   2739c:	9a06      	ldr	r2, [sp, #24]
         c2 = c1*c1 - s1*s1;
   2739e:	eea2 3aa2 	vfma.f32	s6, s5, s5
         s2 = 2*(c1*s1);
   273a2:	ee73 3aa3 	vadd.f32	s7, s7, s7
             gi = fz +k1-ii;
   273a6:	46c4      	mov	ip, r8
   273a8:	eb02 0509 	add.w	r5, r2, r9
   273ac:	eb02 0008 	add.w	r0, r2, r8
   273b0:	9a05      	ldr	r2, [sp, #20]
   273b2:	4611      	mov	r1, r2
   273b4:	4442      	add	r2, r8
   273b6:	4449      	add	r1, r9
                 a       = c2*fi[k1] + s2*gi[k1];
                 f1      = fi[0 ]    - a;
                 f0      = fi[0 ]    + a;
                 g1      = gi[0 ]    - b;
                 g0      = gi[0 ]    + b;
                 b       = s2*fi[k3] - c2*gi[k3];
   273b8:	edd0 4a00 	vldr	s9, [r0]
   273bc:	edd5 7a00 	vldr	s15, [r5]
   273c0:	ee63 1a64 	vnmul.f32	s3, s6, s9
                 a       = c2*fi[k3] + s2*gi[k3];
                 f3      = fi[k2]    - a;
                 f2      = fi[k2]    + a;
                 g3      = gi[k2]    - b;
   273c4:	ed92 1a00 	vldr	s2, [r2]
                 a       = c2*fi[k3] + s2*gi[k3];
   273c8:	ee64 4aa3 	vmul.f32	s9, s9, s7
                 b       = s2*fi[k1] - c2*gi[k1];
   273cc:	edd6 5a00 	vldr	s11, [r6]
                 f3      = fi[k2]    - a;
   273d0:	ed91 6a00 	vldr	s12, [r1]
                 b       = s2*fi[k3] - c2*gi[k3];
   273d4:	eee7 1aa3 	vfma.f32	s3, s15, s7
                 b       = s2*fi[k1] - c2*gi[k1];
   273d8:	ed97 0a00 	vldr	s0, [r7]
                 a       = c2*fi[k3] + s2*gi[k3];
   273dc:	eee7 4a83 	vfma.f32	s9, s15, s6
                 f1      = fi[0 ]    - a;
   273e0:	edd3 6a00 	vldr	s13, [r3]
                 a       = c2*fi[k1] + s2*gi[k1];
   273e4:	ee25 7aa3 	vmul.f32	s14, s11, s7
                 g1      = gi[0 ]    - b;
   273e8:	ed9c 5a00 	vldr	s10, [ip]
                 b       = s2*fi[k1] - c2*gi[k1];
   273ec:	ee63 5a65 	vnmul.f32	s11, s6, s11
                 a       = c2*fi[k1] + s2*gi[k1];
   273f0:	eea0 7a03 	vfma.f32	s14, s0, s6
                 g3      = gi[k2]    - b;
   273f4:	ee31 4a61 	vsub.f32	s8, s2, s3
                 f3      = fi[k2]    - a;
   273f8:	ee76 7a64 	vsub.f32	s15, s12, s9
                 g2      = gi[k2]    + b;
   273fc:	ee71 1a21 	vadd.f32	s3, s2, s3
                 b       = s1*f2     - c1*g3;
                 a       = c1*f2     + s1*g3;
   27400:	ee62 0a04 	vmul.f32	s1, s4, s8
                 f2      = fi[k2]    + a;
   27404:	ee76 4a24 	vadd.f32	s9, s12, s9
                 b       = s1*f2     - c1*g3;
   27408:	ee24 4a62 	vnmul.f32	s8, s8, s5
                 a       = c1*f2     + s1*g3;
   2740c:	eeb0 1a60 	vmov.f32	s2, s1
                 b       = s2*fi[k1] - c2*gi[k1];
   27410:	eee0 5a23 	vfma.f32	s11, s0, s7
                 fi[k2]  = f0        - a;
                 fi[0 ]  = f0        + a;
                 gi[k3]  = g1        - b;
                 gi[k1]  = g1        + b;
                 b       = c1*g2     - s1*f3;
                 a       = s1*g2     + c1*f3;
   27414:	ee22 6aa7 	vmul.f32	s12, s5, s15
                 a       = c1*f2     + s1*g3;
   27418:	eea2 1aa4 	vfma.f32	s2, s5, s9
                 b       = s1*f2     - c1*g3;
   2741c:	eea2 4a24 	vfma.f32	s8, s4, s9
                 b       = c1*g2     - s1*f3;
   27420:	ee67 7ac2 	vnmul.f32	s15, s15, s4
                 a       = s1*g2     + c1*f3;
   27424:	eea2 6a21 	vfma.f32	s12, s4, s3
                 b       = c1*g2     - s1*f3;
   27428:	eee2 7aa1 	vfma.f32	s15, s5, s3
                 f0      = fi[0 ]    + a;
   2742c:	ee76 1a87 	vadd.f32	s3, s13, s14
                 b       = s1*f2     - c1*g3;
   27430:	eef0 4a44 	vmov.f32	s9, s8
                 f1      = fi[0 ]    - a;
   27434:	ee36 7ac7 	vsub.f32	s14, s13, s14
                 g1      = gi[0 ]    - b;
   27438:	ee35 4a65 	vsub.f32	s8, s10, s11
                 g0      = gi[0 ]    + b;
   2743c:	ee75 6a25 	vadd.f32	s13, s10, s11
                 fi[k2]  = f0        - a;
   27440:	ee71 5ac1 	vsub.f32	s11, s3, s2
                 fi[0 ]  = f0        + a;
   27444:	ee31 1a81 	vadd.f32	s2, s3, s2
                 gi[k3]  = g1        - b;
   27448:	ee34 5a64 	vsub.f32	s10, s8, s9
                 fi[k2]  = f0        - a;
   2744c:	edc1 5a00 	vstr	s11, [r1]
                 gi[k1]  = g1        + b;
   27450:	ee74 4a24 	vadd.f32	s9, s8, s9
                 fi[0 ]  = f0        + a;
   27454:	ed83 1a00 	vstr	s2, [r3]
                 gi[k2]  = g0        - a;
                 gi[0 ]  = g0        + a;
                 fi[k3]  = f1        - b;
                 fi[k1]  = f1        + b;
                 gi     += k4;
                 fi     += k4;
   27458:	4423      	add	r3, r4
                 gi[k2]  = g0        - a;
   2745a:	ee76 5ac6 	vsub.f32	s11, s13, s12
                 gi[k3]  = g1        - b;
   2745e:	ed80 5a00 	vstr	s10, [r0]
                 gi[0 ]  = g0        + a;
   27462:	ee36 6a86 	vadd.f32	s12, s13, s12
                } while (fi<fn);
   27466:	4553      	cmp	r3, sl
                 fi[k3]  = f1        - b;
   27468:	ee77 6a67 	vsub.f32	s13, s14, s15
                 gi[k1]  = g1        + b;
   2746c:	edc6 4a00 	vstr	s9, [r6]
                 fi[k1]  = f1        + b;
   27470:	ee77 7a27 	vadd.f32	s15, s14, s15
                 gi[k2]  = g0        - a;
   27474:	edc2 5a00 	vstr	s11, [r2]
   27478:	4421      	add	r1, r4
                 gi[0 ]  = g0        + a;
   2747a:	ed8c 6a00 	vstr	s12, [ip]
   2747e:	4420      	add	r0, r4
                 fi[k3]  = f1        - b;
   27480:	edc5 6a00 	vstr	s13, [r5]
   27484:	4426      	add	r6, r4
                 fi[k1]  = f1        + b;
   27486:	edc7 7a00 	vstr	s15, [r7]
   2748a:	4422      	add	r2, r4
                 gi     += k4;
   2748c:	44a4      	add	ip, r4
   2748e:	4425      	add	r5, r4
   27490:	4427      	add	r7, r4
                } while (fi<fn);
   27492:	d391      	bcc.n	273b8 <mayer_fht+0x388>
     for (ii=1;ii<kx;ii++)
   27494:	f10e 0e01 	add.w	lr, lr, #1
   27498:	9b03      	ldr	r3, [sp, #12]
   2749a:	4573      	cmp	r3, lr
   2749c:	d00d      	beq.n	274ba <mayer_fht+0x48a>
         TRIG_NEXT(k,c1,s1);
   2749e:	f01e 0301 	ands.w	r3, lr, #1
   274a2:	d14d      	bne.n	27540 <mayer_fht+0x510>
   274a4:	3301      	adds	r3, #1
   274a6:	fa4e f203 	asr.w	r2, lr, r3
   274aa:	07d6      	lsls	r6, r2, #31
   274ac:	d5fa      	bpl.n	274a4 <mayer_fht+0x474>
   274ae:	f109 0904 	add.w	r9, r9, #4
   274b2:	f1a8 0804 	sub.w	r8, r8, #4
   274b6:	9802      	ldr	r0, [sp, #8]
   274b8:	e729      	b.n	2730e <mayer_fht+0x2de>
   274ba:	9b07      	ldr	r3, [sp, #28]
        }
     TRIG_RESET(k,c1,s1);
    } while (k4<n);
   274bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   274be:	3308      	adds	r3, #8
   274c0:	9307      	str	r3, [sp, #28]
   274c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   274c4:	4293      	cmp	r3, r2
   274c6:	f73f ae7b 	bgt.w	271c0 <mayer_fht+0x190>
}
   274ca:	b00d      	add	sp, #52	; 0x34
   274cc:	ecbd 8b02 	vpop	{d8}
   274d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   274d4:	46a4      	mov	ip, r4
   274d6:	e5cb      	b.n	27070 <mayer_fht+0x40>
   274d8:	eb00 0a81 	add.w	sl, r0, r1, lsl #2
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
   274dc:	4550      	cmp	r0, sl
   274de:	d22c      	bcs.n	2753a <mayer_fht+0x50a>
   274e0:	f100 0110 	add.w	r1, r0, #16
   274e4:	f100 0520 	add.w	r5, r0, #32
   274e8:	f1c1 040f 	rsb	r4, r1, #15
   274ec:	4454      	add	r4, sl
   274ee:	f024 040f 	bic.w	r4, r4, #15
   274f2:	442c      	add	r4, r5
             f1     = fi[0 ]-fi[1 ];
   274f4:	ed11 6a03 	vldr	s12, [r1, #-12]
   274f8:	3110      	adds	r1, #16
             f3     = fi[2 ]-fi[3 ];
   274fa:	ed51 6a06 	vldr	s13, [r1, #-24]	; 0xffffffe8
             f1     = fi[0 ]-fi[1 ];
   274fe:	ed51 5a08 	vldr	s11, [r1, #-32]	; 0xffffffe0
             f3     = fi[2 ]-fi[3 ];
   27502:	ed51 7a05 	vldr	s15, [r1, #-20]	; 0xffffffec
             f1     = fi[0 ]-fi[1 ];
   27506:	ee35 7ac6 	vsub.f32	s14, s11, s12
             f0     = fi[0 ]+fi[1 ];
   2750a:	ee75 5a86 	vadd.f32	s11, s11, s12
             f2     = fi[2 ]+fi[3 ];
   2750e:	ee36 6aa7 	vadd.f32	s12, s13, s15
             f3     = fi[2 ]-fi[3 ];
   27512:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[2 ] = (f0-f2);  
   27516:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[3 ] = (f1-f3);  
   2751a:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ] = (f0+f2);
   2751e:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[1 ] = (f1+f3);
   27522:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[2 ] = (f0-f2);  
   27526:	ed01 5a06 	vstr	s10, [r1, #-24]	; 0xffffffe8
             fi[3 ] = (f1-f3);  
   2752a:	ed41 6a05 	vstr	s13, [r1, #-20]	; 0xffffffec
             fi[0 ] = (f0+f2);
   2752e:	ed01 6a08 	vstr	s12, [r1, #-32]	; 0xffffffe0
             fi[1 ] = (f1+f3);
   27532:	ed41 7a07 	vstr	s15, [r1, #-28]	; 0xffffffe4
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
   27536:	428c      	cmp	r4, r1
   27538:	d1dc      	bne.n	274f4 <mayer_fht+0x4c4>
   2753a:	2100      	movs	r1, #0
   2753c:	9101      	str	r1, [sp, #4]
   2753e:	e626      	b.n	2718e <mayer_fht+0x15e>
         TRIG_NEXT(k,c1,s1);
   27540:	2300      	movs	r3, #0
   27542:	e7b4      	b.n	274ae <mayer_fht+0x47e>

00027544 <mayer_realfft>:
  real[i] = (q-t)*0.5;  real[j] = (q+t)*0.5;
 }
}

void mayer_realfft(int n, REAL *real)
{
   27544:	b538      	push	{r3, r4, r5, lr}
   27546:	460c      	mov	r4, r1
   27548:	4605      	mov	r5, r0
    REAL a,b;
 int i,j,k;
 mayer_fht(real,n);
   2754a:	4601      	mov	r1, r0
   2754c:	4620      	mov	r0, r4
   2754e:	f7ff fd6f 	bl	27030 <mayer_fht>
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   27552:	2d00      	cmp	r5, #0
   27554:	bfb4      	ite	lt
   27556:	1c6b      	addlt	r3, r5, #1
   27558:	462b      	movge	r3, r5
   2755a:	105b      	asrs	r3, r3, #1
   2755c:	2b01      	cmp	r3, #1
   2755e:	dd18      	ble.n	27592 <mayer_realfft+0x4e>
  a = real[i];
  b = real[j];
  real[j] = (a-b)*0.5;
   27560:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   27564:	eb04 0085 	add.w	r0, r4, r5, lsl #2
   27568:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   2756c:	1d21      	adds	r1, r4, #4
  a = real[i];
   2756e:	edd1 7a00 	vldr	s15, [r1]
  b = real[j];
   27572:	ed70 6a01 	vldmdb	r0!, {s13}
  real[j] = (a-b)*0.5;
   27576:	ee37 7ae6 	vsub.f32	s14, s15, s13
  real[i] = (a+b)*0.5;
   2757a:	ee77 7aa6 	vadd.f32	s15, s15, s13
  real[j] = (a-b)*0.5;
   2757e:	ee27 7a06 	vmul.f32	s14, s14, s12
  real[i] = (a+b)*0.5;
   27582:	ee67 7a86 	vmul.f32	s15, s15, s12
  real[j] = (a-b)*0.5;
   27586:	ed80 7a00 	vstr	s14, [r0]
  real[i] = (a+b)*0.5;
   2758a:	ece1 7a01 	vstmia	r1!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   2758e:	428b      	cmp	r3, r1
   27590:	d1ed      	bne.n	2756e <mayer_realfft+0x2a>
 }
}
   27592:	bd38      	pop	{r3, r4, r5, pc}

00027594 <mayer_realifft>:

void mayer_realifft(int n, REAL *real)
{
    REAL a,b;
 int i,j,k;
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   27594:	2800      	cmp	r0, #0
{
   27596:	b410      	push	{r4}
   27598:	460c      	mov	r4, r1
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   2759a:	bfb4      	ite	lt
   2759c:	1c41      	addlt	r1, r0, #1
   2759e:	4601      	movge	r1, r0
   275a0:	1049      	asrs	r1, r1, #1
   275a2:	2901      	cmp	r1, #1
   275a4:	dd12      	ble.n	275cc <mayer_realifft+0x38>
   275a6:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   275aa:	1d23      	adds	r3, r4, #4
   275ac:	eb04 0280 	add.w	r2, r4, r0, lsl #2
  a = real[i];
   275b0:	edd3 7a00 	vldr	s15, [r3]
  b = real[j];
   275b4:	ed32 7a01 	vldmdb	r2!, {s14}
  real[j] = (a-b);
   275b8:	ee77 6ac7 	vsub.f32	s13, s15, s14
  real[i] = (a+b);
   275bc:	ee77 7a87 	vadd.f32	s15, s15, s14
  real[j] = (a-b);
   275c0:	edc2 6a00 	vstr	s13, [r2]
  real[i] = (a+b);
   275c4:	ece3 7a01 	vstmia	r3!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   275c8:	4299      	cmp	r1, r3
   275ca:	d1f1      	bne.n	275b0 <mayer_realifft+0x1c>
 }
 mayer_fht(real,n);
   275cc:	4601      	mov	r1, r0
   275ce:	4620      	mov	r0, r4
}
   275d0:	f85d 4b04 	ldr.w	r4, [sp], #4
 mayer_fht(real,n);
   275d4:	f7ff bd2c 	b.w	27030 <mayer_fht>

000275d8 <tEnvelopeFollower_init>:
//===========================================================================
/* Envelope Follower */
//===========================================================================

void    tEnvelopeFollower_init(tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff)
{
   275d8:	b538      	push	{r3, r4, r5, lr}
    tEnvelopeFollower_initToPool(ef, attackThreshold, decayCoeff, &leaf.mempool);
}

void    tEnvelopeFollower_initToPool    (tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff, tMempool* const mp)
{
    _tMempool* m = *mp;
   275da:	f64f 0308 	movw	r3, #63496	; 0xf808
{
   275de:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   275e0:	2010      	movs	r0, #16
    _tMempool* m = *mp;
   275e2:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   275e6:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   275ea:	699c      	ldr	r4, [r3, #24]
{
   275ec:	eef0 8a40 	vmov.f32	s17, s0
   275f0:	eeb0 8a60 	vmov.f32	s16, s1
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   275f4:	4621      	mov	r1, r4
   275f6:	f005 fe0b 	bl	2d210 <mpool_alloc>
    e->mempool = m;
    
    e->y = 0.0f;
   275fa:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   275fc:	6028      	str	r0, [r5, #0]
    e->mempool = m;
   275fe:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
   27600:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
   27604:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
   27608:	6043      	str	r3, [r0, #4]
}
   2760a:	ecbd 8b02 	vpop	{d8}
   2760e:	bd38      	pop	{r3, r4, r5, pc}

00027610 <tEnvelopeFollower_initToPool>:
{
   27610:	b538      	push	{r3, r4, r5, lr}
   27612:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27616:	680c      	ldr	r4, [r1, #0]
{
   27618:	eef0 8a40 	vmov.f32	s17, s0
   2761c:	eeb0 8a60 	vmov.f32	s16, s1
   27620:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   27622:	4621      	mov	r1, r4
   27624:	2010      	movs	r0, #16
   27626:	f005 fdf3 	bl	2d210 <mpool_alloc>
    e->y = 0.0f;
   2762a:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   2762c:	6028      	str	r0, [r5, #0]
    e->mempool = m;
   2762e:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
   27630:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
   27634:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
   27638:	6043      	str	r3, [r0, #4]
}
   2763a:	ecbd 8b02 	vpop	{d8}
   2763e:	bd38      	pop	{r3, r4, r5, pc}

00027640 <tEnvelopeFollower_free>:

void    tEnvelopeFollower_free  (tEnvelopeFollower* const ef)
{
    _tEnvelopeFollower* e = *ef;
   27640:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)e, e->mempool);
   27642:	6801      	ldr	r1, [r0, #0]
   27644:	f005 be8e 	b.w	2d364 <mpool_free>

00027648 <tEnvelopeFollower_tick>:
}

float   tEnvelopeFollower_tick(tEnvelopeFollower* const ef, float x)
{
    _tEnvelopeFollower* e = *ef;
   27648:	6802      	ldr	r2, [r0, #0]
   2764a:	eeb0 0ac0 	vabs.f32	s0, s0
    
    if (x < 0.0f ) x = -x;  /* Absolute value. */
    
    if ((x >= e->y) && (x > e->a_thresh)) e->y = x;                      /* If we hit a peak, ride the peak to the top. */
   2764e:	edd2 7a01 	vldr	s15, [r2, #4]
   27652:	eef4 7ac0 	vcmpe.f32	s15, s0
   27656:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2765a:	d816      	bhi.n	2768a <tEnvelopeFollower_tick+0x42>
   2765c:	ed92 7a02 	vldr	s14, [r2, #8]
   27660:	eeb4 7ac0 	vcmpe.f32	s14, s0
   27664:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27668:	d50f      	bpl.n	2768a <tEnvelopeFollower_tick+0x42>
    //ef->y = envelope_pow[(uint16_t)(ef->y * (float)UINT16_MAX)] * ef->d_coeff; //not quite the right behavior - too much loss of precision?
    //ef->y = powf(ef->y, 1.000009f) * ef->d_coeff;  // too expensive
    
#ifdef NO_DENORMAL_CHECK
#else
    if( e->y < VSF)   e->y = 0.0f;
   2766a:	f24e 33ee 	movw	r3, #58350	; 0xe3ee
   2766e:	f2c0 036c 	movt	r3, #108	; 0x6c
   27672:	ee07 3a90 	vmov	s15, r3
   27676:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2767a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2767e:	d509      	bpl.n	27694 <tEnvelopeFollower_tick+0x4c>
   27680:	2300      	movs	r3, #0
   27682:	ee00 3a10 	vmov	s0, r3
   27686:	6053      	str	r3, [r2, #4]
#endif
    return e->y;
}
   27688:	4770      	bx	lr
    else                                    e->y = e->y * e->d_coeff;    /* Else, exponential decay of output. */
   2768a:	ed92 0a03 	vldr	s0, [r2, #12]
   2768e:	ee27 0a80 	vmul.f32	s0, s15, s0
   27692:	e7ea      	b.n	2766a <tEnvelopeFollower_tick+0x22>
   27694:	ed82 0a01 	vstr	s0, [r2, #4]
   27698:	4770      	bx	lr
   2769a:	bf00      	nop

0002769c <tZeroCrossing_initToPool>:
{
    tZeroCrossing_initToPool   (zc, maxWindowSize, &leaf.mempool);
}

void    tZeroCrossing_initToPool   (tZeroCrossing* const zc, int maxWindowSize, tMempool* const mp)
{
   2769c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2769e:	6816      	ldr	r6, [r2, #0]
{
   276a0:	460d      	mov	r5, r1
   276a2:	4607      	mov	r7, r0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   276a4:	2024      	movs	r0, #36	; 0x24
   276a6:	4631      	mov	r1, r6
   276a8:	f005 fdb2 	bl	2d210 <mpool_alloc>
    z->mempool = m;

    z->count = 0;
    z->maxWindowSize = maxWindowSize;
    z->currentWindowSize = maxWindowSize;
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   276ac:	ee07 5a90 	vmov	s15, r5
   276b0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   276b4:	4604      	mov	r4, r0
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   276b6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    z->count = 0;
   276ba:	2300      	movs	r3, #0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   276bc:	6038      	str	r0, [r7, #0]
    z->position = 0;
    z->prevPosition = maxWindowSize;
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   276be:	4631      	mov	r1, r6
    z->mempool = m;
   276c0:	6006      	str	r6, [r0, #0]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   276c2:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z->maxWindowSize = maxWindowSize;
   276c6:	6085      	str	r5, [r0, #8]
    z->count = 0;
   276c8:	6063      	str	r3, [r4, #4]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   276ca:	00a8      	lsls	r0, r5, #2
    z->position = 0;
   276cc:	6223      	str	r3, [r4, #32]
    z->currentWindowSize = maxWindowSize;
   276ce:	60e5      	str	r5, [r4, #12]
    z->prevPosition = maxWindowSize;
   276d0:	61e5      	str	r5, [r4, #28]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   276d2:	edc4 7a04 	vstr	s15, [r4, #16]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   276d6:	f005 fdf1 	bl	2d2bc <mpool_calloc>
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
   276da:	4631      	mov	r1, r6
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   276dc:	6160      	str	r0, [r4, #20]
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
   276de:	0068      	lsls	r0, r5, #1
   276e0:	f005 fdec 	bl	2d2bc <mpool_calloc>
   276e4:	61a0      	str	r0, [r4, #24]
}
   276e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000276e8 <tZeroCrossing_free>:

void    tZeroCrossing_free (tZeroCrossing* const zc)
{
   276e8:	b510      	push	{r4, lr}
    _tZeroCrossing* z = *zc;
   276ea:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)z->inBuffer, z->mempool);
   276ec:	6821      	ldr	r1, [r4, #0]
   276ee:	6960      	ldr	r0, [r4, #20]
   276f0:	f005 fe38 	bl	2d364 <mpool_free>
    mpool_free((char*)z->countBuffer, z->mempool);
   276f4:	6821      	ldr	r1, [r4, #0]
   276f6:	69a0      	ldr	r0, [r4, #24]
   276f8:	f005 fe34 	bl	2d364 <mpool_free>
    mpool_free((char*)z, z->mempool);
   276fc:	6821      	ldr	r1, [r4, #0]
   276fe:	4620      	mov	r0, r4
}
   27700:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)z, z->mempool);
   27704:	f005 be2e 	b.w	2d364 <mpool_free>

00027708 <tZeroCrossing_tick>:

//returns proportion of zero crossings within window size (0.0 would be none in window, 1.0 would be all zero crossings)
float   tZeroCrossing_tick         (tZeroCrossing* const zc, float input)
{
   27708:	b430      	push	{r4, r5}
    _tZeroCrossing* z = *zc;
   2770a:	6803      	ldr	r3, [r0, #0]

    z->inBuffer[z->position] = input;
   2770c:	6a19      	ldr	r1, [r3, #32]
   2770e:	695a      	ldr	r2, [r3, #20]
   27710:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27714:	ed82 0a00 	vstr	s0, [r2]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   27718:	6a18      	ldr	r0, [r3, #32]
    float output = 0.0f;

    //add new value to count
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   2771a:	695a      	ldr	r2, [r3, #20]
   2771c:	69dc      	ldr	r4, [r3, #28]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   2771e:	1c41      	adds	r1, r0, #1
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   27720:	eb02 0580 	add.w	r5, r2, r0, lsl #2
   27724:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   27728:	68dc      	ldr	r4, [r3, #12]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   2772a:	ed95 7a00 	vldr	s14, [r5]
   2772e:	edd2 7a00 	vldr	s15, [r2]
   27732:	ee67 7a87 	vmul.f32	s15, s15, s14
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   27736:	fb91 f2f4 	sdiv	r2, r1, r4
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   2773a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   2773e:	fb04 1112 	mls	r1, r4, r2, r1
    {
        //zero crossing happened, add it to the count array
        z->countBuffer[z->position] = 1;
   27742:	699a      	ldr	r2, [r3, #24]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   27744:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27748:	d41c      	bmi.n	27784 <tZeroCrossing_tick+0x7c>
        z->count++;
    }
    else
    {
        z->countBuffer[z->position] = 0;
   2774a:	2400      	movs	r4, #0
   2774c:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
   27750:	685a      	ldr	r2, [r3, #4]
    }

    //remove oldest value from count
    if (z->countBuffer[futurePosition] > 0)
   27752:	6998      	ldr	r0, [r3, #24]
   27754:	f830 0011 	ldrh.w	r0, [r0, r1, lsl #1]
   27758:	b110      	cbz	r0, 27760 <tZeroCrossing_tick+0x58>
    {
        z->count--;
        if (z->count < 0)
   2775a:	3a01      	subs	r2, #1
   2775c:	d40d      	bmi.n	2777a <tZeroCrossing_tick+0x72>
        z->count--;
   2775e:	605a      	str	r2, [r3, #4]
   27760:	ee07 2a90 	vmov	s15, r2
   27764:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        {
            z->count = 0;
        }
    }

    z->prevPosition = z->position;
   27768:	6a1a      	ldr	r2, [r3, #32]
    z->position = futurePosition;

    output = z->count * z->invCurrentWindowSize;
   2776a:	ed93 0a04 	vldr	s0, [r3, #16]
    z->position = futurePosition;
   2776e:	e9c3 2107 	strd	r2, r1, [r3, #28]

    return output;
}
   27772:	ee27 0a80 	vmul.f32	s0, s15, s0
   27776:	bc30      	pop	{r4, r5}
   27778:	4770      	bx	lr
            z->count = 0;
   2777a:	2200      	movs	r2, #0
   2777c:	ee07 2a90 	vmov	s15, r2
   27780:	605a      	str	r2, [r3, #4]
   27782:	e7f1      	b.n	27768 <tZeroCrossing_tick+0x60>
        z->countBuffer[z->position] = 1;
   27784:	2401      	movs	r4, #1
   27786:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
        z->count++;
   2778a:	685a      	ldr	r2, [r3, #4]
   2778c:	4422      	add	r2, r4
   2778e:	605a      	str	r2, [r3, #4]
   27790:	e7df      	b.n	27752 <tZeroCrossing_tick+0x4a>
   27792:	bf00      	nop

00027794 <tPowerFollower_initToPool>:
{
    tPowerFollower_initToPool(pf, factor, &leaf.mempool);
}

void    tPowerFollower_initToPool   (tPowerFollower* const pf, float factor, tMempool* const mp)
{
   27794:	b538      	push	{r3, r4, r5, lr}
   27796:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2779a:	680c      	ldr	r4, [r1, #0]
{
   2779c:	4605      	mov	r5, r0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   2779e:	2010      	movs	r0, #16
{
   277a0:	eeb0 8a40 	vmov.f32	s16, s0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   277a4:	4621      	mov	r1, r4
   277a6:	f005 fd33 	bl	2d210 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
    p->factor=factor;
    p->oneminusfactor=1.0f-factor;
   277aa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    p->curr=0.0f;
   277ae:	2300      	movs	r3, #0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   277b0:	6028      	str	r0, [r5, #0]
    p->mempool = m;
   277b2:	6004      	str	r4, [r0, #0]
    p->oneminusfactor=1.0f-factor;
   277b4:	ee77 7ac8 	vsub.f32	s15, s15, s16
    p->factor=factor;
   277b8:	ed80 8a01 	vstr	s16, [r0, #4]
    p->curr=0.0f;
   277bc:	60c3      	str	r3, [r0, #12]
    p->oneminusfactor=1.0f-factor;
   277be:	edc0 7a02 	vstr	s15, [r0, #8]
}
   277c2:	ecbd 8b02 	vpop	{d8}
   277c6:	bd38      	pop	{r3, r4, r5, pc}

000277c8 <tPowerFollower_free>:

void    tPowerFollower_free (tPowerFollower* const pf)
{
    _tPowerFollower* p = *pf;
   277c8:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)p, p->mempool);
   277ca:	6801      	ldr	r1, [r0, #0]
   277cc:	f005 bdca 	b.w	2d364 <mpool_free>

000277d0 <tPowerFollower_tick>:
    return 0;
}

float   tPowerFollower_tick(tPowerFollower* const pf, float input)
{
    _tPowerFollower* p = *pf;
   277d0:	6803      	ldr	r3, [r0, #0]
    p->curr = p->factor*input*input+p->oneminusfactor*p->curr;
   277d2:	ee20 7a00 	vmul.f32	s14, s0, s0
   277d6:	edd3 7a02 	vldr	s15, [r3, #8]
   277da:	ed93 0a03 	vldr	s0, [r3, #12]
   277de:	edd3 6a01 	vldr	s13, [r3, #4]
   277e2:	ee27 0a80 	vmul.f32	s0, s15, s0
   277e6:	eea6 0a87 	vfma.f32	s0, s13, s14
   277ea:	ed83 0a03 	vstr	s0, [r3, #12]
    return p->curr;
}
   277ee:	4770      	bx	lr

000277f0 <tEnvPD_initToPool>:
{
    tEnvPD_initToPool(xpd, ws, hs, bs, &leaf.mempool);
}

void    tEnvPD_initToPool       (tEnvPD* const xpd, int ws, int hs, int bs, tMempool* const mp)
{
   277f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   277f4:	ed2d 8b04 	vpush	{d8-d9}
   277f8:	b083      	sub	sp, #12
   277fa:	4688      	mov	r8, r1
   277fc:	4605      	mov	r5, r0
    _tMempool* m = *mp;
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   277fe:	f241 109c 	movw	r0, #4508	; 0x119c
{
   27802:	9c10      	ldr	r4, [sp, #64]	; 0x40
   27804:	4616      	mov	r6, r2
   27806:	461f      	mov	r7, r3
    _tMempool* m = *mp;
   27808:	6824      	ldr	r4, [r4, #0]
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   2780a:	4621      	mov	r1, r4
   2780c:	f005 fd56 	bl	2d2bc <mpool_calloc>
    
    int period = hs, npoints = ws;
    
    int i;
    
    if (npoints < 1) npoints = 1024;
   27810:	f1b8 0f00 	cmp.w	r8, #0
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   27814:	6028      	str	r0, [r5, #0]
   27816:	4682      	mov	sl, r0
    x->mempool = m;
   27818:	6004      	str	r4, [r0, #0]
    if (npoints < 1) npoints = 1024;
   2781a:	f340 8085 	ble.w	27928 <tEnvPD_initToPool+0x138>
   2781e:	ee07 8a90 	vmov	s15, r8
   27822:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27826:	f108 033f 	add.w	r3, r8, #63	; 0x3f
   2782a:	ea4f 1068 	mov.w	r0, r8, asr #5
   2782e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   27832:	fa1f f288 	uxth.w	r2, r8
   27836:	9301      	str	r3, [sp, #4]
   27838:	ee87 8a27 	vdiv.f32	s16, s14, s15
    if (period < 1) period = npoints/2;
   2783c:	2e00      	cmp	r6, #0
    if (period < npoints / MAXOVERLAP + 1)
        period = npoints / MAXOVERLAP + 1;
    
    x->x_npoints = npoints;
    x->x_phase = 0;
    x->x_period = period;
   2783e:	f241 1506 	movw	r5, #4358	; 0x1106
    
    x->windowSize = npoints;
    x->hopSize = period;
   27842:	f241 1196 	movw	r1, #4502	; 0x1196
    x->blockSize = bs;
   27846:	f241 1498 	movw	r4, #4504	; 0x1198
    if (period < 1) period = npoints/2;
   2784a:	bfd8      	it	le
   2784c:	ea4f 0668 	movle.w	r6, r8, asr #1
    x->blockSize = bs;
   27850:	b2bf      	uxth	r7, r7
    if (period < npoints / MAXOVERLAP + 1)
   27852:	4286      	cmp	r6, r0
   27854:	ea4f 0b88 	mov.w	fp, r8, lsl #2
        period = npoints / MAXOVERLAP + 1;
   27858:	bfd8      	it	le
   2785a:	1c46      	addle	r6, r0, #1
    x->x_npoints = npoints;
   2785c:	f241 100a 	movw	r0, #4362	; 0x110a
    x->x_period = period;
   27860:	b2b6      	uxth	r6, r6
   27862:	f82a 6005 	strh.w	r6, [sl, r5]
    x->x_phase = 0;
   27866:	f241 1504 	movw	r5, #4356	; 0x1104
    x->hopSize = period;
   2786a:	f82a 6001 	strh.w	r6, [sl, r1]
    x->x_phase = 0;
   2786e:	2100      	movs	r1, #0
    x->blockSize = bs;
   27870:	f82a 7004 	strh.w	r7, [sl, r4]
    x->windowSize = npoints;
   27874:	f241 1494 	movw	r4, #4500	; 0x1194
    x->x_npoints = npoints;
   27878:	f82a 2000 	strh.w	r2, [sl, r0]
   2787c:	f241 1010 	movw	r0, #4368	; 0x1110
    x->x_phase = 0;
   27880:	f82a 1005 	strh.w	r1, [sl, r5]
    
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
    for (i = 0; i < npoints; i++)
   27884:	460d      	mov	r5, r1
    x->windowSize = npoints;
   27886:	f82a 2004 	strh.w	r2, [sl, r4]
   2788a:	4450      	add	r0, sl
   2788c:	2280      	movs	r2, #128	; 0x80
   2788e:	f10a 0404 	add.w	r4, sl, #4
   27892:	f008 fc8e 	bl	301b2 <memset>
   27896:	f640 72db 	movw	r2, #4059	; 0xfdb
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
   2789a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2789e:	eb04 090b 	add.w	r9, r4, fp
   278a2:	f2c4 02c9 	movt	r2, #16585	; 0x40c9
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
   278a6:	eeb0 9a40 	vmov.f32	s18, s0
   278aa:	ee08 2a90 	vmov	s17, r2
   278ae:	e001      	b.n	278b4 <tEnvPD_initToPool+0xc4>
   278b0:	f008 fda8 	bl	30404 <cosf>
    for (i = 0; i < npoints; i++)
   278b4:	3501      	adds	r5, #1
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
   278b6:	ee39 0a40 	vsub.f32	s0, s18, s0
   278ba:	ee07 5a90 	vmov	s15, r5
   278be:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   278c2:	ee60 7a08 	vmul.f32	s15, s0, s16
   278c6:	ee27 0a28 	vmul.f32	s0, s14, s17
   278ca:	ece4 7a01 	vstmia	r4!, {s15}
    for (i = 0; i < npoints; i++)
   278ce:	45a1      	cmp	r9, r4
   278d0:	ee20 0a08 	vmul.f32	s0, s0, s16
   278d4:	d1ec      	bne.n	278b0 <tEnvPD_initToPool+0xc0>
    for (; i < npoints+INITVSTAKEN; i++) x->buf[i] = 0;
   278d6:	9b01      	ldr	r3, [sp, #4]
   278d8:	4598      	cmp	r8, r3
   278da:	dc09      	bgt.n	278f0 <tEnvPD_initToPool+0x100>
   278dc:	3301      	adds	r3, #1
   278de:	f10b 0004 	add.w	r0, fp, #4
   278e2:	2100      	movs	r1, #0
   278e4:	eba3 0208 	sub.w	r2, r3, r8
   278e8:	4450      	add	r0, sl
   278ea:	0092      	lsls	r2, r2, #2
   278ec:	f008 fc61 	bl	301b2 <memset>
    
    x->x_f = 0;
   278f0:	f241 1190 	movw	r1, #4496	; 0x1190
   278f4:	2000      	movs	r0, #0
    
    x->x_allocforvs = INITVSTAKEN;
   278f6:	f241 149a 	movw	r4, #4506	; 0x119a
   278fa:	2540      	movs	r5, #64	; 0x40
    x->x_f = 0;
   278fc:	4451      	add	r1, sl
    
    // ~ ~ ~ dsp ~ ~ ~
    if (x->x_period % x->blockSize)
   278fe:	fbb6 f2f7 	udiv	r2, r6, r7
   27902:	fb07 6212 	mls	r2, r7, r2, r6
    x->x_f = 0;
   27906:	6008      	str	r0, [r1, #0]
    if (x->x_period % x->blockSize)
   27908:	b292      	uxth	r2, r2
    x->x_allocforvs = INITVSTAKEN;
   2790a:	f82a 5004 	strh.w	r5, [sl, r4]
    if (x->x_period % x->blockSize)
   2790e:	b112      	cbz	r2, 27916 <tEnvPD_initToPool+0x126>
    {
        x->x_realperiod = x->x_period + x->blockSize - (x->x_period % x->blockSize);
   27910:	443e      	add	r6, r7
   27912:	1ab2      	subs	r2, r6, r2
   27914:	b296      	uxth	r6, r2
   27916:	f241 1208 	movw	r2, #4360	; 0x1108
   2791a:	f82a 6002 	strh.w	r6, [sl, r2]
    else
    {
        x->x_realperiod = x->x_period;
    }
    // ~ ~ ~ ~ ~ ~ ~ ~
}
   2791e:	b003      	add	sp, #12
   27920:	ecbd 8b04 	vpop	{d8-d9}
   27924:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27928:	f04f 516a 	mov.w	r1, #981467136	; 0x3a800000
   2792c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   27930:	f240 433f 	movw	r3, #1087	; 0x43f
   27934:	2020      	movs	r0, #32
   27936:	ee08 1a10 	vmov	s16, r1
    if (npoints < 1) npoints = 1024;
   2793a:	4690      	mov	r8, r2
   2793c:	9301      	str	r3, [sp, #4]
   2793e:	e77d      	b.n	2783c <tEnvPD_initToPool+0x4c>

00027940 <tEnvPD_tick>:
}

float tEnvPD_tick (tEnvPD* const xpd)
{
    _tEnvPD* x = *xpd;
    return powtodb(x->x_result);
   27940:	6802      	ldr	r2, [r0, #0]
   27942:	f241 130c 	movw	r3, #4364	; 0x110c
   27946:	4413      	add	r3, r2
   27948:	ed93 0a00 	vldr	s0, [r3]
   2794c:	f005 bbea 	b.w	2d124 <powtodb>

00027950 <tSNAC_initToPool>:
{
    tSNAC_initToPool(snac, overlaparg, &leaf.mempool);
}

void    tSNAC_initToPool    (tSNAC* const snac, int overlaparg, tMempool* const mp)
{
   27950:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   27954:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27958:	6816      	ldr	r6, [r2, #0]
{
   2795a:	4681      	mov	r9, r0
   2795c:	4688      	mov	r8, r1
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   2795e:	202c      	movs	r0, #44	; 0x2c
   27960:	4631      	mov	r1, r6
    s->mempool = m;
    
    s->biasfactor = DEFBIAS;
    s->timeindex = 0;
    s->periodindex = 0;
    s->periodlength = 0.;
   27962:	2500      	movs	r5, #0
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   27964:	f005 fc54 	bl	2d210 <mpool_alloc>
    s->biasfactor = DEFBIAS;
   27968:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    s->fidelity = 0.;
    s->minrms = DEFMINRMS;
   2796c:	f649 33a6 	movw	r3, #39846	; 0x9ba6
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   27970:	4604      	mov	r4, r0
    s->biasfactor = DEFBIAS;
   27972:	f6c3 624c 	movt	r2, #15948	; 0x3e4c
    s->timeindex = 0;
   27976:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
    s->minrms = DEFMINRMS;
   2797a:	f6c3 3344 	movt	r3, #15172	; 0x3b44
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   2797e:	f8c9 0000 	str.w	r0, [r9]
    s->framesize = SNAC_FRAME_SIZE;

    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   27982:	4631      	mov	r1, r6
    s->biasfactor = DEFBIAS;
   27984:	6242      	str	r2, [r0, #36]	; 0x24
    s->minrms = DEFMINRMS;
   27986:	6283      	str	r3, [r0, #40]	; 0x28
    s->mempool = m;
   27988:	6006      	str	r6, [r0, #0]
    s->periodindex = 0;
   2798a:	8345      	strh	r5, [r0, #26]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   2798c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    s->timeindex = 0;
   27990:	6167      	str	r7, [r4, #20]
    s->periodlength = 0.;
   27992:	61e5      	str	r5, [r4, #28]
    s->fidelity = 0.;
   27994:	6225      	str	r5, [r4, #32]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   27996:	f005 fc91 	bl	2d2bc <mpool_calloc>
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   2799a:	4631      	mov	r1, r6
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   2799c:	6060      	str	r0, [r4, #4]
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   2799e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   279a2:	f005 fc8b 	bl	2d2bc <mpool_calloc>
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   279a6:	4631      	mov	r1, r6
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   279a8:	60a0      	str	r0, [r4, #8]
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   279aa:	f44f 6000 	mov.w	r0, #2048	; 0x800
   279ae:	f005 fc85 	bl	2d2bc <mpool_calloc>
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   279b2:	4631      	mov	r1, r6
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   279b4:	60e0      	str	r0, [r4, #12]
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   279b6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   279ba:	f005 fc7f 	bl	2d2bc <mpool_calloc>
   279be:	6120      	str	r0, [r4, #16]
    
    snac_biasbuf(snac);
   279c0:	f8d9 4000 	ldr.w	r4, [r9]
static void snac_biasbuf(tSNAC* const snac)
{
    _tSNAC* s = *snac;
    
    int n;
    int maxperiod = (int)(s->framesize * (float)SEEK);
   279c4:	f649 139a 	movw	r3, #39322	; 0x999a
   279c8:	8ae2      	ldrh	r2, [r4, #22]
   279ca:	f6c3 7359 	movt	r3, #16217	; 0x3f59
   279ce:	ee07 2a90 	vmov	s15, r2
   279d2:	ee07 3a10 	vmov	s14, r3
   279d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   279da:	ee67 7a87 	vmul.f32	s15, s15, s14
   279de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   279e2:	ee17 7a90 	vmov	r7, s15
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
   279e6:	1f3b      	subs	r3, r7, #4
   279e8:	ee00 3a10 	vmov	s0, r3
   279ec:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   279f0:	f008 fdce 	bl	30590 <logf>
   279f4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    for(n=0; n<5; n++)    // periods < 5 samples can't be tracked
    {
        biasbuf[n] = 0.0f;
    }
    
    for(n=5; n<maxperiod; n++)
   279f8:	2f05      	cmp	r7, #5
    float *biasbuf = s->biasbuf;
   279fa:	6924      	ldr	r4, [r4, #16]
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
   279fc:	ee87 8a80 	vdiv.f32	s16, s15, s0
        biasbuf[n] = 0.0f;
   27a00:	6025      	str	r5, [r4, #0]
   27a02:	6065      	str	r5, [r4, #4]
   27a04:	60a5      	str	r5, [r4, #8]
   27a06:	60e5      	str	r5, [r4, #12]
   27a08:	6125      	str	r5, [r4, #16]
    for(n=5; n<maxperiod; n++)
   27a0a:	dd17      	ble.n	27a3c <tSNAC_initToPool+0xec>
   27a0c:	eb04 0787 	add.w	r7, r4, r7, lsl #2
    {
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
   27a10:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   27a14:	3414      	adds	r4, #20
    for(n=5; n<maxperiod; n++)
   27a16:	2602      	movs	r6, #2
   27a18:	ee00 5a10 	vmov	s0, r5
   27a1c:	e001      	b.n	27a22 <tSNAC_initToPool+0xd2>
   27a1e:	f008 fdb7 	bl	30590 <logf>
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
   27a22:	eef0 7a68 	vmov.f32	s15, s17
   27a26:	ee07 6a10 	vmov	s14, r6
   27a2a:	3601      	adds	r6, #1
   27a2c:	eee0 7a48 	vfms.f32	s15, s0, s16
   27a30:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
   27a34:	ece4 7a01 	vstmia	r4!, {s15}
    for(n=5; n<maxperiod; n++)
   27a38:	42bc      	cmp	r4, r7
   27a3a:	d1f0      	bne.n	27a1e <tSNAC_initToPool+0xce>
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   27a3c:	f1b8 0f08 	cmp.w	r8, #8
    _tSNAC* s = *snac;
   27a40:	f8d9 2000 	ldr.w	r2, [r9]
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   27a44:	d907      	bls.n	27a56 <tSNAC_initToPool+0x106>
   27a46:	f04f 0801 	mov.w	r8, #1
    s->overlap = lap;
   27a4a:	f8a2 8018 	strh.w	r8, [r2, #24]
}
   27a4e:	ecbd 8b02 	vpop	{d8}
   27a52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   27a56:	f44f 738b 	mov.w	r3, #278	; 0x116
   27a5a:	fa23 f308 	lsr.w	r3, r3, r8
   27a5e:	07db      	lsls	r3, r3, #31
   27a60:	d5f1      	bpl.n	27a46 <tSNAC_initToPool+0xf6>
   27a62:	fa1f f888 	uxth.w	r8, r8
    s->overlap = lap;
   27a66:	f8a2 8018 	strh.w	r8, [r2, #24]
}
   27a6a:	ecbd 8b02 	vpop	{d8}
   27a6e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   27a72:	bf00      	nop

00027a74 <tSNAC_ioSamples>:
{
   27a74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27a78:	ed2d 8b02 	vpush	{d8}
   27a7c:	b08b      	sub	sp, #44	; 0x2c
   27a7e:	460d      	mov	r5, r1
   27a80:	9204      	str	r2, [sp, #16]
    _tSNAC* s = *snac;
   27a82:	6802      	ldr	r2, [r0, #0]
{
   27a84:	9002      	str	r0, [sp, #8]
   27a86:	9301      	str	r3, [sp, #4]
    int mask = s->framesize - 1;
   27a88:	8ad0      	ldrh	r0, [r2, #22]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   27a8a:	8b13      	ldrh	r3, [r2, #24]
    int timeindex = s->timeindex;
   27a8c:	8a94      	ldrh	r4, [r2, #20]
    int mask = s->framesize - 1;
   27a8e:	1e46      	subs	r6, r0, #1
    _tSNAC* s = *snac;
   27a90:	9203      	str	r2, [sp, #12]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   27a92:	fbb0 f3f3 	udiv	r3, r0, r3
   27a96:	3b01      	subs	r3, #1
   27a98:	4023      	ands	r3, r4
    float *processbuf = s->processbuf;
   27a9a:	e9d2 7801 	ldrd	r7, r8, [r2, #4]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   27a9e:	9305      	str	r3, [sp, #20]
   27aa0:	d019      	beq.n	27ad6 <tSNAC_ioSamples+0x62>
    while(size--)
   27aa2:	9b01      	ldr	r3, [sp, #4]
   27aa4:	b183      	cbz	r3, 27ac8 <tSNAC_ioSamples+0x54>
   27aa6:	9a04      	ldr	r2, [sp, #16]
   27aa8:	eb05 0c83 	add.w	ip, r5, r3, lsl #2
        inputbuf[timeindex] = *in++;
   27aac:	00a3      	lsls	r3, r4, #2
   27aae:	f855 0b04 	ldr.w	r0, [r5], #4
        out[outindex++] = processbuf[timeindex++];
   27ab2:	3401      	adds	r4, #1
        inputbuf[timeindex] = *in++;
   27ab4:	18f9      	adds	r1, r7, r3
        out[outindex++] = processbuf[timeindex++];
   27ab6:	4443      	add	r3, r8
    while(size--)
   27ab8:	4565      	cmp	r5, ip
        timeindex &= mask;
   27aba:	ea04 0406 	and.w	r4, r4, r6
        inputbuf[timeindex] = *in++;
   27abe:	6008      	str	r0, [r1, #0]
        out[outindex++] = processbuf[timeindex++];
   27ac0:	681b      	ldr	r3, [r3, #0]
   27ac2:	f842 3b04 	str.w	r3, [r2], #4
    while(size--)
   27ac6:	d1f1      	bne.n	27aac <tSNAC_ioSamples+0x38>
    s->timeindex = timeindex;
   27ac8:	9b03      	ldr	r3, [sp, #12]
   27aca:	829c      	strh	r4, [r3, #20]
}
   27acc:	b00b      	add	sp, #44	; 0x2c
   27ace:	ecbd 8b02 	vpop	{d8}
   27ad2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    float norm = 1. / sqrt((float)(framesize * 2));
   27ad6:	ea4f 0e40 	mov.w	lr, r0, lsl #1
   27ada:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
   27ade:	ee07 ea90 	vmov	s15, lr
   27ae2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   27ae6:	eeb1 6bc7 	vsqrt.f64	d6, d7
   27aea:	ee85 7b06 	vdiv.f64	d7, d5, d6
   27aee:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    for(n=0; n<framesize; n++)
   27af2:	b178      	cbz	r0, 27b14 <tSNAC_ioSamples+0xa0>
   27af4:	4642      	mov	r2, r8
   27af6:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
    int timeindex = s->timeindex;
   27afa:	4623      	mov	r3, r4
        processbuf[n] = inputbuf[tindex] * norm;
   27afc:	eb07 0183 	add.w	r1, r7, r3, lsl #2
        tindex++;
   27b00:	3301      	adds	r3, #1
        processbuf[n] = inputbuf[tindex] * norm;
   27b02:	edd1 7a00 	vldr	s15, [r1]
        tindex &= mask;
   27b06:	4033      	ands	r3, r6
        processbuf[n] = inputbuf[tindex] * norm;
   27b08:	ee67 7a87 	vmul.f32	s15, s15, s14
   27b0c:	ece2 7a01 	vstmia	r2!, {s15}
    for(n=0; n<framesize; n++)
   27b10:	4594      	cmp	ip, r2
   27b12:	d1f3      	bne.n	27afc <tSNAC_ioSamples+0x88>
    for(n=framesize; n<(framesize<<1); n++) processbuf[n] = 0.;
   27b14:	4570      	cmp	r0, lr
   27b16:	da07      	bge.n	27b28 <tSNAC_ioSamples+0xb4>
   27b18:	ebae 0200 	sub.w	r2, lr, r0
   27b1c:	2100      	movs	r1, #0
   27b1e:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   27b22:	0092      	lsls	r2, r2, #2
   27b24:	f008 fb45 	bl	301b2 <memset>
    snac_autocorrelation(snac);
   27b28:	9b02      	ldr	r3, [sp, #8]
   27b2a:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
   27b2c:	f8b3 9016 	ldrh.w	r9, [r3, #22]
    float *processbuf = s->processbuf;
   27b30:	f8d3 a008 	ldr.w	sl, [r3, #8]
    int fftsize = framesize * 2;
   27b34:	ea4f 0b49 	mov.w	fp, r9, lsl #1
    float *spectrumbuf = s->spectrumbuf;
   27b38:	68db      	ldr	r3, [r3, #12]
    REALFFT(fftsize, processbuf);
   27b3a:	4651      	mov	r1, sl
   27b3c:	4658      	mov	r0, fp
    float *spectrumbuf = s->spectrumbuf;
   27b3e:	9306      	str	r3, [sp, #24]
    REALFFT(fftsize, processbuf);
   27b40:	f7ff fd00 	bl	27544 <mayer_realfft>
    processbuf[0] *= processbuf[0];                      // DC
   27b44:	edda 7a00 	vldr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
   27b48:	eb0a 0189 	add.w	r1, sl, r9, lsl #2
    for(n=1; n<framesize; n++)
   27b4c:	f1b9 0f01 	cmp.w	r9, #1
    processbuf[0] *= processbuf[0];                      // DC
   27b50:	ee67 7aa7 	vmul.f32	s15, s15, s15
   27b54:	edca 7a00 	vstr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
   27b58:	edd1 7a00 	vldr	s15, [r1]
   27b5c:	ee67 7aa7 	vmul.f32	s15, s15, s15
   27b60:	edc1 7a00 	vstr	s15, [r1]
    for(n=1; n<framesize; n++)
   27b64:	dd11      	ble.n	27b8a <tSNAC_ioSamples+0x116>
        processbuf[fftsize-n] = 0.;
   27b66:	2000      	movs	r0, #0
   27b68:	f10a 0304 	add.w	r3, sl, #4
   27b6c:	eb0a 02c9 	add.w	r2, sl, r9, lsl #3
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
   27b70:	ed72 7a01 	vldmdb	r2!, {s15}
        processbuf[n] = processbuf[n] * processbuf[n]
   27b74:	ed93 7a00 	vldr	s14, [r3]
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
   27b78:	ee67 7aa7 	vmul.f32	s15, s15, s15
   27b7c:	eee7 7a07 	vfma.f32	s15, s14, s14
        processbuf[n] = processbuf[n] * processbuf[n]
   27b80:	ece3 7a01 	vstmia	r3!, {s15}
    for(n=1; n<framesize; n++)
   27b84:	4299      	cmp	r1, r3
        processbuf[fftsize-n] = 0.;
   27b86:	6010      	str	r0, [r2, #0]
    for(n=1; n<framesize; n++)
   27b88:	d1f2      	bne.n	27b70 <tSNAC_ioSamples+0xfc>
    for(m=0; m<(framesize>>1); m++)
   27b8a:	ea5f 0969 	movs.w	r9, r9, asr #1
   27b8e:	d009      	beq.n	27ba4 <tSNAC_ioSamples+0x130>
   27b90:	9a06      	ldr	r2, [sp, #24]
   27b92:	eb0a 0989 	add.w	r9, sl, r9, lsl #2
   27b96:	4653      	mov	r3, sl
        spectrumbuf[m] = processbuf[m];
   27b98:	f853 1b04 	ldr.w	r1, [r3], #4
    for(m=0; m<(framesize>>1); m++)
   27b9c:	4599      	cmp	r9, r3
        spectrumbuf[m] = processbuf[m];
   27b9e:	f842 1b04 	str.w	r1, [r2], #4
    for(m=0; m<(framesize>>1); m++)
   27ba2:	d1f9      	bne.n	27b98 <tSNAC_ioSamples+0x124>
    REALIFFT(fftsize, processbuf);
   27ba4:	4651      	mov	r1, sl
   27ba6:	4658      	mov	r0, fp
   27ba8:	f7ff fcf4 	bl	27594 <mayer_realifft>
    snac_normalize(snac);
   27bac:	9b02      	ldr	r3, [sp, #8]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   27bae:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    int seek = framesize * SEEK;
   27bb2:	f649 129a 	movw	r2, #39322	; 0x999a
    snac_normalize(snac);
   27bb6:	681b      	ldr	r3, [r3, #0]
    int seek = framesize * SEEK;
   27bb8:	f6c3 7259 	movt	r2, #16217	; 0x3f59
    int framesize = s->framesize;
   27bbc:	8ad9      	ldrh	r1, [r3, #22]
    int seek = framesize * SEEK;
   27bbe:	ee07 2a10 	vmov	s14, r2
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   27bc2:	ed93 5a0a 	vldr	s10, [r3, #40]	; 0x28
    int seek = framesize * SEEK;
   27bc6:	ee07 1a90 	vmov	s15, r1
    int framesize = s->framesize;
   27bca:	9106      	str	r1, [sp, #24]
    float *processbuf= s->processbuf;
   27bcc:	6899      	ldr	r1, [r3, #8]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   27bce:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
    int seek = framesize * SEEK;
   27bd2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    int framesizeplustimeindex = s->framesize + s->timeindex;
   27bd6:	f8b3 a014 	ldrh.w	sl, [r3, #20]
    float rzero = processbuf[0];
   27bda:	460a      	mov	r2, r1
   27bdc:	ed91 6a00 	vldr	s12, [r1]
    float *inputbuf = s->inputbuf;
   27be0:	f8d3 9004 	ldr.w	r9, [r3, #4]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   27be4:	eec4 6aa7 	vdiv.f32	s13, s9, s15
    processbuf[0] = 1;
   27be8:	edc2 4a00 	vstr	s9, [r2]
    float *processbuf= s->processbuf;
   27bec:	9107      	str	r1, [sp, #28]
    int mask = framesize - 1;
   27bee:	9906      	ldr	r1, [sp, #24]
   27bf0:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
    int framesizeplustimeindex = s->framesize + s->timeindex;
   27bf4:	eb0a 0b01 	add.w	fp, sl, r1
    int seek = framesize * SEEK;
   27bf8:	ee67 7a87 	vmul.f32	s15, s15, s14
   27bfc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   27c00:	ee17 0a90 	vmov	r0, s15
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   27c04:	2801      	cmp	r0, #1
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   27c06:	eeb7 7ae6 	vcvt.f64.f32	d7, s13
   27c0a:	eeb1 4bc7 	vsqrt.f64	d4, d7
   27c0e:	ee85 7b04 	vdiv.f64	d7, d5, d4
   27c12:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    float minrzero = rms * rms;
   27c16:	ee27 7a07 	vmul.f32	s14, s14, s14
    double normintegral = (double)rzero * 2.;
   27c1a:	fe87 6a06 	vmaxnm.f32	s12, s14, s12
   27c1e:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
   27c22:	ee36 6b06 	vadd.f64	d6, d6, d6
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   27c26:	dd2b      	ble.n	27c80 <tSNAC_ioSamples+0x20c>
        processbuf[n] /= (float)normintegral * 0.5f;
   27c28:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
   27c2c:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   27c30:	f102 0c04 	add.w	ip, r2, #4
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   27c34:	2101      	movs	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   27c36:	ebab 0201 	sub.w	r2, fp, r1
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   27c3a:	eb0a 0301 	add.w	r3, sl, r1
        processbuf[n] /= (float)normintegral * 0.5f;
   27c3e:	eddc 5a00 	vldr	s11, [ip]
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   27c42:	3101      	adds	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   27c44:	ea02 020e 	and.w	r2, r2, lr
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   27c48:	ea03 030e 	and.w	r3, r3, lr
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   27c4c:	4288      	cmp	r0, r1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   27c4e:	eb09 0282 	add.w	r2, r9, r2, lsl #2
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   27c52:	eb09 0383 	add.w	r3, r9, r3, lsl #2
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   27c56:	ed92 7a00 	vldr	s14, [r2]
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   27c5a:	edd3 7a00 	vldr	s15, [r3]
        normintegral -= (double)(signal1 * signal1 + signal2 * signal2);
   27c5e:	ee27 7a07 	vmul.f32	s14, s14, s14
   27c62:	eea7 7aa7 	vfma.f32	s14, s15, s15
   27c66:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   27c6a:	ee36 6b47 	vsub.f64	d6, d6, d7
        processbuf[n] /= (float)normintegral * 0.5f;
   27c6e:	eef7 7bc6 	vcvt.f32.f64	s15, d6
   27c72:	ee67 7a85 	vmul.f32	s15, s15, s10
   27c76:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   27c7a:	ecac 7a01 	vstmia	ip!, {s14}
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   27c7e:	d1da      	bne.n	27c36 <tSNAC_ioSamples+0x1c2>
    for(n = seek; n<framesize; n++) processbuf[n] = 0.;
   27c80:	9b06      	ldr	r3, [sp, #24]
   27c82:	4283      	cmp	r3, r0
   27c84:	dd07      	ble.n	27c96 <tSNAC_ioSamples+0x222>
   27c86:	1a1a      	subs	r2, r3, r0
   27c88:	9b07      	ldr	r3, [sp, #28]
   27c8a:	2100      	movs	r1, #0
   27c8c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   27c90:	0092      	lsls	r2, r2, #2
   27c92:	f008 fa8e 	bl	301b2 <memset>
    snac_pickpeak(snac);
   27c96:	9b02      	ldr	r3, [sp, #8]
   27c98:	6819      	ldr	r1, [r3, #0]
    int seek = s->framesize * SEEK;
   27c9a:	f649 139a 	movw	r3, #39322	; 0x999a
   27c9e:	8aca      	ldrh	r2, [r1, #22]
   27ca0:	f6c3 7359 	movt	r3, #16217	; 0x3f59
    snac_pickpeak(snac);
   27ca4:	9107      	str	r1, [sp, #28]
    int seek = s->framesize * SEEK;
   27ca6:	ee07 2a90 	vmov	s15, r2
   27caa:	ee07 3a10 	vmov	s14, r3
    float *processbuf= s->processbuf;
   27cae:	688a      	ldr	r2, [r1, #8]
    int seek = s->framesize * SEEK;
   27cb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float *biasbuf = s->biasbuf;
   27cb4:	690b      	ldr	r3, [r1, #16]
    int seek = s->framesize * SEEK;
   27cb6:	ee67 7a87 	vmul.f32	s15, s15, s14
   27cba:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   27cbe:	ee17 ba90 	vmov	fp, s15
    for(n=1; n<seek; n++)
   27cc2:	f1bb 0f01 	cmp.w	fp, #1
   27cc6:	f340 808b 	ble.w	27de0 <tSNAC_ioSamples+0x36c>
        if(processbuf[n] < 0.) break;
   27cca:	edd2 7a01 	vldr	s15, [r2, #4]
   27cce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   27cd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27cd6:	f100 8083 	bmi.w	27de0 <tSNAC_ioSamples+0x36c>
   27cda:	f102 0108 	add.w	r1, r2, #8
    for(n=1; n<seek; n++)
   27cde:	f04f 0901 	mov.w	r9, #1
   27ce2:	e006      	b.n	27cf2 <tSNAC_ioSamples+0x27e>
        if(processbuf[n] < 0.) break;
   27ce4:	ecf1 7a01 	vldmia	r1!, {s15}
   27ce8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   27cec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27cf0:	d404      	bmi.n	27cfc <tSNAC_ioSamples+0x288>
    for(n=1; n<seek; n++)
   27cf2:	f109 0901 	add.w	r9, r9, #1
   27cf6:	45cb      	cmp	fp, r9
   27cf8:	d1f4      	bne.n	27ce4 <tSNAC_ioSamples+0x270>
   27cfa:	46d9      	mov	r9, fp
    for(; n<seek-1; n++)
   27cfc:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   27d00:	45cb      	cmp	fp, r9
   27d02:	dd6b      	ble.n	27ddc <tSNAC_ioSamples+0x368>
   27d04:	ea4f 0a89 	mov.w	sl, r9, lsl #2
   27d08:	2100      	movs	r1, #0
   27d0a:	9408      	str	r4, [sp, #32]
   27d0c:	4614      	mov	r4, r2
   27d0e:	4453      	add	r3, sl
   27d10:	f1aa 0a04 	sub.w	sl, sl, #4
   27d14:	9509      	str	r5, [sp, #36]	; 0x24
   27d16:	ee08 1a10 	vmov	s16, r1
   27d1a:	465d      	mov	r5, fp
   27d1c:	9106      	str	r1, [sp, #24]
   27d1e:	4492      	add	sl, r2
   27d20:	469b      	mov	fp, r3
   27d22:	e005      	b.n	27d30 <tSNAC_ioSamples+0x2bc>
   27d24:	f109 0901 	add.w	r9, r9, #1
   27d28:	f10b 0b04 	add.w	fp, fp, #4
   27d2c:	45a9      	cmp	r9, r5
   27d2e:	d029      	beq.n	27d84 <tSNAC_ioSamples+0x310>
   27d30:	4651      	mov	r1, sl
        if(processbuf[n] >= processbuf[n-1])
   27d32:	f10a 0a04 	add.w	sl, sl, #4
   27d36:	ed91 7a00 	vldr	s14, [r1]
   27d3a:	edda 7a00 	vldr	s15, [sl]
   27d3e:	eef4 7ac7 	vcmpe.f32	s15, s14
   27d42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27d46:	dbed      	blt.n	27d24 <tSNAC_ioSamples+0x2b0>
            if(processbuf[n] > processbuf[n+1])     // we have a local peak
   27d48:	ed9a 7a01 	vldr	s14, [sl, #4]
   27d4c:	eef4 7ac7 	vcmpe.f32	s15, s14
   27d50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27d54:	dde6      	ble.n	27d24 <tSNAC_ioSamples+0x2b0>
                biasedpeak = interpolate3max(processbuf, n) * biasbuf[n];
   27d56:	4649      	mov	r1, r9
   27d58:	4620      	mov	r0, r4
   27d5a:	f004 ff01 	bl	2cb60 <interpolate3max>
   27d5e:	eddb 7a00 	vldr	s15, [fp]
   27d62:	ee20 0a27 	vmul.f32	s0, s0, s15
                if(biasedpeak > maxvalue)
   27d66:	eeb4 0ac8 	vcmpe.f32	s0, s16
   27d6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27d6e:	ddd9      	ble.n	27d24 <tSNAC_ioSamples+0x2b0>
   27d70:	f8cd 9018 	str.w	r9, [sp, #24]
    for(; n<seek-1; n++)
   27d74:	f109 0901 	add.w	r9, r9, #1
                    maxvalue = biasedpeak;
   27d78:	eeb0 8a40 	vmov.f32	s16, s0
   27d7c:	f10b 0b04 	add.w	fp, fp, #4
    for(; n<seek-1; n++)
   27d80:	45a9      	cmp	r9, r5
   27d82:	d1d5      	bne.n	27d30 <tSNAC_ioSamples+0x2bc>
   27d84:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   27d88:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    s->periodindex = peakindex;
   27d8c:	9a07      	ldr	r2, [sp, #28]
   27d8e:	8353      	strh	r3, [r2, #26]
    _tSNAC* s = *snac;
   27d90:	9b02      	ldr	r3, [sp, #8]
   27d92:	f8d3 a000 	ldr.w	sl, [r3]
    if(s->periodindex)
   27d96:	f8ba 901a 	ldrh.w	r9, [sl, #26]
   27d9a:	f1b9 0f00 	cmp.w	r9, #0
   27d9e:	f43f ae80 	beq.w	27aa2 <tSNAC_ioSamples+0x2e>
        interpolate3phase(s->processbuf, s->periodindex);
   27da2:	4649      	mov	r1, r9
   27da4:	f8da 0008 	ldr.w	r0, [sl, #8]
   27da8:	f004 fefa 	bl	2cba0 <interpolate3phase>
        periodlength = (float)s->periodindex +
   27dac:	ee07 9a90 	vmov	s15, r9
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   27db0:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
        periodlength = (float)s->periodindex +
   27db4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   27db8:	ee37 0a80 	vadd.f32	s0, s15, s0
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   27dbc:	eeb4 0ac7 	vcmpe.f32	s0, s14
   27dc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27dc4:	d40f      	bmi.n	27de6 <tSNAC_ioSamples+0x372>
        s->periodlength = periodlength;
   27dc6:	ed8a 0a07 	vstr	s0, [sl, #28]
        s->fidelity = interpolate3max(s->processbuf, s->periodindex);
   27dca:	f8ba 101a 	ldrh.w	r1, [sl, #26]
   27dce:	f8da 0008 	ldr.w	r0, [sl, #8]
   27dd2:	f004 fec5 	bl	2cb60 <interpolate3max>
   27dd6:	ed8a 0a08 	vstr	s0, [sl, #32]
   27dda:	e662      	b.n	27aa2 <tSNAC_ioSamples+0x2e>
    for(; n<seek-1; n++)
   27ddc:	2300      	movs	r3, #0
   27dde:	e7d5      	b.n	27d8c <tSNAC_ioSamples+0x318>
    for(n=1; n<seek; n++)
   27de0:	f04f 0901 	mov.w	r9, #1
   27de4:	e78a      	b.n	27cfc <tSNAC_ioSamples+0x288>
    if(periodlength < 4.0f) return periodlength;
   27de6:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
   27dea:	eeb4 0ae7 	vcmpe.f32	s0, s15
   27dee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27df2:	d4e8      	bmi.n	27dc6 <tSNAC_ioSamples+0x352>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   27df4:	9b02      	ldr	r3, [sp, #8]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   27df6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   27dfa:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   27dfe:	eef7 5a04 	vmov.f32	s11, #116	; 0x3fa00000  1.250
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   27e02:	f8d3 9000 	ldr.w	r9, [r3]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   27e06:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
    int spectrumsize = s->framesize>>1;
   27e0a:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    float *spectrumbuf = s->spectrumbuf;
   27e0e:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   27e12:	ee07 3a10 	vmov	s14, r3
    int spectrumsize = s->framesize>>1;
   27e16:	085b      	lsrs	r3, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   27e18:	eef8 6ac7 	vcvt.f32.s32	s13, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   27e1c:	ee07 2a10 	vmov	s14, r2
    if(stopbin >= spectrumsize - 1) stopbin = spectrumsize - 1;
   27e20:	1e5a      	subs	r2, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   27e22:	ee76 6aa6 	vadd.f32	s13, s13, s13
   27e26:	ee86 6a80 	vdiv.f32	s12, s13, s0
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   27e2a:	eef0 6a67 	vmov.f32	s13, s15
   27e2e:	eee6 6a25 	vfma.f32	s13, s12, s11
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   27e32:	eee6 7a07 	vfma.f32	s15, s12, s14
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   27e36:	eebd 7ae6 	vcvt.s32.f32	s14, s13
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   27e3a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   27e3e:	ee17 1a10 	vmov	r1, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   27e42:	ee17 3a90 	vmov	r3, s15
   27e46:	4291      	cmp	r1, r2
   27e48:	bfa8      	it	ge
   27e4a:	4611      	movge	r1, r2
   27e4c:	2b01      	cmp	r3, #1
   27e4e:	bfb8      	it	lt
   27e50:	2301      	movlt	r3, #1
    for(n=startbin; n<stopbin; n++)
   27e52:	4299      	cmp	r1, r3
   27e54:	dd67      	ble.n	27f26 <tSNAC_ioSamples+0x4b2>
   27e56:	f64f 72ff 	movw	r2, #65535	; 0xffff
    float max = 0.;
   27e5a:	2000      	movs	r0, #0
   27e5c:	f6c3 72ff 	movt	r2, #16383	; 0x3fff
   27e60:	ee06 0a90 	vmov	s13, r0
   27e64:	441a      	add	r2, r3
   27e66:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
   27e6a:	4610      	mov	r0, r2
        if(spectrumbuf[n] >= spectrumbuf[n-1])
   27e6c:	3204      	adds	r2, #4
   27e6e:	ed90 7a00 	vldr	s14, [r0]
   27e72:	edd2 7a00 	vldr	s15, [r2]
   27e76:	eef4 7ac7 	vcmpe.f32	s15, s14
   27e7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27e7e:	db0e      	blt.n	27e9e <tSNAC_ioSamples+0x42a>
            if(spectrumbuf[n] > spectrumbuf[n+1])
   27e80:	ed92 7a01 	vldr	s14, [r2, #4]
                if(spectrumbuf[n] > max)
   27e84:	eef4 7a47 	vcmp.f32	s15, s14
   27e88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27e8c:	dd07      	ble.n	27e9e <tSNAC_ioSamples+0x42a>
   27e8e:	eef4 7a66 	vcmp.f32	s15, s13
   27e92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27e96:	dd02      	ble.n	27e9e <tSNAC_ioSamples+0x42a>
                    max = spectrumbuf[n];
   27e98:	eef0 6a67 	vmov.f32	s13, s15
                if(spectrumbuf[n] > max)
   27e9c:	9305      	str	r3, [sp, #20]
    for(n=startbin; n<stopbin; n++)
   27e9e:	3301      	adds	r3, #1
   27ea0:	4299      	cmp	r1, r3
   27ea2:	d1e2      	bne.n	27e6a <tSNAC_ioSamples+0x3f6>
    for(n=(peakbin-1); n<(peakbin+2); n++)
   27ea4:	9b05      	ldr	r3, [sp, #20]
   27ea6:	461a      	mov	r2, r3
   27ea8:	1e58      	subs	r0, r3, #1
   27eaa:	3301      	adds	r3, #1
   27eac:	ee07 2a90 	vmov	s15, r2
   27eb0:	4283      	cmp	r3, r0
   27eb2:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   27eb6:	db25      	blt.n	27f04 <tSNAC_ioSamples+0x490>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27eb8:	0080      	lsls	r0, r0, #2
    for(n=(peakbin-1); n<(peakbin+2); n++)
   27eba:	469e      	mov	lr, r3
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27ebc:	eb0c 0100 	add.w	r1, ip, r0
   27ec0:	3004      	adds	r0, #4
   27ec2:	ed91 7a00 	vldr	s14, [r1]
   27ec6:	eb0c 0200 	add.w	r2, ip, r0
   27eca:	eef1 7ac7 	vsqrt.f32	s15, s14
   27ece:	edc1 7a00 	vstr	s15, [r1]
   27ed2:	ed92 7a00 	vldr	s14, [r2]
   27ed6:	eef1 7ac7 	vsqrt.f32	s15, s14
   27eda:	edc2 7a00 	vstr	s15, [r2]
   27ede:	1d02      	adds	r2, r0, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
   27ee0:	459e      	cmp	lr, r3
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27ee2:	4462      	add	r2, ip
   27ee4:	ed92 7a00 	vldr	s14, [r2]
   27ee8:	eef1 7ac7 	vsqrt.f32	s15, s14
   27eec:	edc2 7a00 	vstr	s15, [r2]
    for(n=(peakbin-1); n<(peakbin+2); n++)
   27ef0:	da08      	bge.n	27f04 <tSNAC_ioSamples+0x490>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27ef2:	f100 0308 	add.w	r3, r0, #8
   27ef6:	4463      	add	r3, ip
   27ef8:	ed93 7a00 	vldr	s14, [r3]
   27efc:	eef1 7ac7 	vsqrt.f32	s15, s14
   27f00:	edc3 7a00 	vstr	s15, [r3]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
   27f04:	9905      	ldr	r1, [sp, #20]
   27f06:	4660      	mov	r0, ip
   27f08:	f004 fe4a 	bl	2cba0 <interpolate3phase>
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
   27f0c:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
   27f10:	ee30 8a08 	vadd.f32	s16, s0, s16
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
   27f14:	ee07 3a90 	vmov	s15, r3
   27f18:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   27f1c:	ee77 7aa7 	vadd.f32	s15, s15, s15
   27f20:	ee87 0a88 	vdiv.f32	s0, s15, s16
   27f24:	e74f      	b.n	27dc6 <tSNAC_ioSamples+0x352>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27f26:	ed5c 7a01 	vldr	s15, [ip, #-4]
   27f2a:	2200      	movs	r2, #0
   27f2c:	eddc 6a00 	vldr	s13, [ip]
    for(n=(peakbin-1); n<(peakbin+2); n++)
   27f30:	f04f 0e01 	mov.w	lr, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27f34:	eeb1 7ae7 	vsqrt.f32	s14, s15
   27f38:	ee08 2a10 	vmov	s16, r2
    for(n=(peakbin-1); n<(peakbin+2); n++)
   27f3c:	4673      	mov	r3, lr
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   27f3e:	4610      	mov	r0, r2
   27f40:	eef1 7ae6 	vsqrt.f32	s15, s13
   27f44:	ed0c 7a01 	vstr	s14, [ip, #-4]
   27f48:	edcc 7a00 	vstr	s15, [ip]
   27f4c:	e7c7      	b.n	27ede <tSNAC_ioSamples+0x46a>
   27f4e:	bf00      	nop

00027f50 <tPeriodDetection_initToPool>:
{
    tPeriodDetection_initToPool(pd, in, out, bufSize, frameSize, &leaf.mempool);
}

void tPeriodDetection_initToPool (tPeriodDetection* const pd, float* in, float* out, int bufSize, int frameSize, tMempool* const mp)
{
   27f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27f54:	b085      	sub	sp, #20
   27f56:	4682      	mov	sl, r0
   27f58:	468b      	mov	fp, r1
    _tMempool* m = *mp;
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   27f5a:	2068      	movs	r0, #104	; 0x68
{
   27f5c:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   27f5e:	461d      	mov	r5, r3
   27f60:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    p->inBuffer = in;
    p->outBuffer = out;
    p->bufSize = bufSize;
    p->frameSize = frameSize;
    p->framesPerBuffer = p->bufSize / p->frameSize;
    p->curBlock = 1;
   27f62:	f04f 0801 	mov.w	r8, #1
    _tMempool* m = *mp;
   27f66:	f8d6 9000 	ldr.w	r9, [r6]
{
   27f6a:	9203      	str	r2, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   27f6c:	4649      	mov	r1, r9
   27f6e:	f005 f9a5 	bl	2d2bc <mpool_calloc>
   27f72:	4604      	mov	r4, r0
    p->lastBlock = 0;
   27f74:	f04f 0c00 	mov.w	ip, #0
    p->outBuffer = out;
   27f78:	9b03      	ldr	r3, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   27f7a:	f8ca 4000 	str.w	r4, [sl]
    
    p->hopSize = DEFHOPSIZE;
    p->windowSize = DEFWINDOWSIZE;
    p->fba = FBA;
    
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   27f7e:	2240      	movs	r2, #64	; 0x40
    p->hopSize = DEFHOPSIZE;
   27f80:	f04f 1040 	mov.w	r0, #4194368	; 0x400040
    p->fba = FBA;
   27f84:	2114      	movs	r1, #20
    p->index = 0;
   27f86:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
    p->outBuffer = out;
   27f8a:	6123      	str	r3, [r4, #16]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   27f8c:	463b      	mov	r3, r7
    p->hopSize = DEFHOPSIZE;
   27f8e:	63e0      	str	r0, [r4, #60]	; 0x3c
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   27f90:	1d20      	adds	r0, r4, #4
    p->fba = FBA;
   27f92:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   27f96:	4611      	mov	r1, r2
    p->mempool = m;
   27f98:	f8c4 9000 	str.w	r9, [r4]
    p->inBuffer = in;
   27f9c:	f8c4 b00c 	str.w	fp, [r4, #12]
    p->frameSize = frameSize;
   27fa0:	e9c4 7505 	strd	r7, r5, [r4, #20]
    p->framesPerBuffer = p->bufSize / p->frameSize;
   27fa4:	fb95 f5f7 	sdiv	r5, r5, r7
    p->lastBlock = 0;
   27fa8:	e9c4 8c08 	strd	r8, ip, [r4, #32]
    p->framesPerBuffer = p->bufSize / p->frameSize;
   27fac:	61e5      	str	r5, [r4, #28]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   27fae:	9600      	str	r6, [sp, #0]
   27fb0:	f7ff fc1e 	bl	277f0 <tEnvPD_initToPool>
    
    tSNAC_initToPool(&p->snac, DEFOVERLAP, mp);
   27fb4:	4632      	mov	r2, r6
   27fb6:	4641      	mov	r1, r8
   27fb8:	f104 0008 	add.w	r0, r4, #8
   27fbc:	f7ff fcc8 	bl	27950 <tSNAC_initToPool>

    p->history = 0.0f;
    p->alpha = 1.0f;
    p->tolerance = 1.0f;
    p->timeConstant = DEFTIMECONSTANT;
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27fc0:	f64f 0108 	movw	r1, #63496	; 0xf808
   27fc4:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
   27fc6:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
   27fca:	f2c0 210f 	movt	r1, #527	; 0x20f
    p->timeConstant = DEFTIMECONSTANT;
   27fce:	2300      	movs	r3, #0
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27fd0:	ee00 2a10 	vmov	s0, r2
   27fd4:	edd1 7a01 	vldr	s15, [r1, #4]
    p->history = 0.0f;
   27fd8:	461a      	mov	r2, r3
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27fda:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    p->alpha = 1.0f;
   27fde:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27fe2:	ee67 7a87 	vmul.f32	s15, s15, s14
    p->timeConstant = DEFTIMECONSTANT;
   27fe6:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
    p->history = 0.0f;
   27fea:	65e2      	str	r2, [r4, #92]	; 0x5c
    p->timeConstant = DEFTIMECONSTANT;
   27fec:	6463      	str	r3, [r4, #68]	; 0x44
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27fee:	ee20 0a27 	vmul.f32	s0, s0, s15
    p->alpha = 1.0f;
   27ff2:	6621      	str	r1, [r4, #96]	; 0x60
    p->tolerance = 1.0f;
   27ff4:	6661      	str	r1, [r4, #100]	; 0x64
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27ff6:	f008 fa45 	bl	30484 <expf>
    p->fidelityThreshold = 0.95;
   27ffa:	f243 3333 	movw	r3, #13107	; 0x3333
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   27ffe:	ed84 0a12 	vstr	s0, [r4, #72]	; 0x48
    p->fidelityThreshold = 0.95;
   28002:	f6c3 7373 	movt	r3, #16243	; 0x3f73
   28006:	65a3      	str	r3, [r4, #88]	; 0x58
}
   28008:	b005      	add	sp, #20
   2800a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2800e:	bf00      	nop

00028010 <tPeriodDetection_free>:

void tPeriodDetection_free (tPeriodDetection* const pd)
{
   28010:	b538      	push	{r3, r4, r5, lr}
    _tPeriodDetection* p = *pd;
   28012:	6805      	ldr	r5, [r0, #0]
    _tEnvPD* x = *xpd;
   28014:	6868      	ldr	r0, [r5, #4]
    mpool_free((char*)x, x->mempool);
   28016:	6801      	ldr	r1, [r0, #0]
   28018:	f005 f9a4 	bl	2d364 <mpool_free>
    _tSNAC* s = *snac;
   2801c:	68ac      	ldr	r4, [r5, #8]
    mpool_free((char*)s->inputbuf, s->mempool);
   2801e:	e9d4 1000 	ldrd	r1, r0, [r4]
   28022:	f005 f99f 	bl	2d364 <mpool_free>
    mpool_free((char*)s->processbuf, s->mempool);
   28026:	6821      	ldr	r1, [r4, #0]
   28028:	68a0      	ldr	r0, [r4, #8]
   2802a:	f005 f99b 	bl	2d364 <mpool_free>
    mpool_free((char*)s->spectrumbuf, s->mempool);
   2802e:	6821      	ldr	r1, [r4, #0]
   28030:	68e0      	ldr	r0, [r4, #12]
   28032:	f005 f997 	bl	2d364 <mpool_free>
    mpool_free((char*)s->biasbuf, s->mempool);
   28036:	6821      	ldr	r1, [r4, #0]
   28038:	6920      	ldr	r0, [r4, #16]
   2803a:	f005 f993 	bl	2d364 <mpool_free>
    mpool_free((char*)s, s->mempool);
   2803e:	6821      	ldr	r1, [r4, #0]
   28040:	4620      	mov	r0, r4
   28042:	f005 f98f 	bl	2d364 <mpool_free>
    
    tEnvPD_free(&p->env);
    tSNAC_free(&p->snac);
    mpool_free((char*)p, p->mempool);
   28046:	6829      	ldr	r1, [r5, #0]
   28048:	4628      	mov	r0, r5
}
   2804a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mpool_free((char*)p, p->mempool);
   2804e:	f005 b989 	b.w	2d364 <mpool_free>
   28052:	bf00      	nop

00028054 <tPeriodDetection_tick>:

float tPeriodDetection_tick (tPeriodDetection* pd, float sample)
{
   28054:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tPeriodDetection* p = *pd;
   28058:	6804      	ldr	r4, [r0, #0]
    
    int i, iLast;
    
    i = (p->curBlock*p->frameSize);
   2805a:	6963      	ldr	r3, [r4, #20]
   2805c:	6a21      	ldr	r1, [r4, #32]
    iLast = (p->lastBlock*p->frameSize)+p->index;
   2805e:	6b62      	ldr	r2, [r4, #52]	; 0x34
    i = (p->curBlock*p->frameSize);
   28060:	fb01 f103 	mul.w	r1, r1, r3
    iLast = (p->lastBlock*p->frameSize)+p->index;
   28064:	6a65      	ldr	r5, [r4, #36]	; 0x24
    
    p->i = i;
    p->iLast = iLast;
    
    p->inBuffer[i+p->index] = sample;
   28066:	68e0      	ldr	r0, [r4, #12]
    iLast = (p->lastBlock*p->frameSize)+p->index;
   28068:	fb05 2303 	mla	r3, r5, r3, r2
    p->inBuffer[i+p->index] = sample;
   2806c:	440a      	add	r2, r1
    p->i = i;
   2806e:	62a1      	str	r1, [r4, #40]	; 0x28
    p->inBuffer[i+p->index] = sample;
   28070:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    p->iLast = iLast;
   28074:	6323      	str	r3, [r4, #48]	; 0x30
    p->inBuffer[i+p->index] = sample;
   28076:	ed82 0a00 	vstr	s0, [r2]
    
    p->index++;
   2807a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
    if (p->index >= p->frameSize)
   2807c:	6962      	ldr	r2, [r4, #20]
    p->index++;
   2807e:	3301      	adds	r3, #1
    if (p->index >= p->frameSize)
   28080:	4293      	cmp	r3, r2
    p->index++;
   28082:	6363      	str	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
   28084:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (p->index >= p->frameSize)
   28086:	da03      	bge.n	28090 <tPeriodDetection_tick+0x3c>
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
        p->lastBlock++;
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
    }
    return p->period;
}
   28088:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
   2808c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _tEnvPD* x = *xpd;
   28090:	f8d4 c004 	ldr.w	ip, [r4, #4]
        p->index = 0;
   28094:	2200      	movs	r2, #0
    int n = x->blockSize;
   28096:	f241 1398 	movw	r3, #4504	; 0x1198
    for (count = x->x_phase, sump = x->x_sumbuf;
   2809a:	f241 1004 	movw	r0, #4356	; 0x1104
        p->index = 0;
   2809e:	6362      	str	r2, [r4, #52]	; 0x34
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
   280a0:	0089      	lsls	r1, r1, #2
    int n = x->blockSize;
   280a2:	f83c 5003 	ldrh.w	r5, [ip, r3]
         count < x->x_npoints; count += x->x_realperiod, sump++)
   280a6:	f241 130a 	movw	r3, #4362	; 0x110a
    for (count = x->x_phase, sump = x->x_sumbuf;
   280aa:	f83c 6000 	ldrh.w	r6, [ip, r0]
   280ae:	f241 1b10 	movw	fp, #4368	; 0x1110
   280b2:	f83c 3003 	ldrh.w	r3, [ip, r3]
    in += n;
   280b6:	eb01 0985 	add.w	r9, r1, r5, lsl #2
   280ba:	68e2      	ldr	r2, [r4, #12]
    for (count = x->x_phase, sump = x->x_sumbuf;
   280bc:	44e3      	add	fp, ip
   280be:	42b3      	cmp	r3, r6
    in += n;
   280c0:	4491      	add	r9, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
   280c2:	d924      	bls.n	2810e <tPeriodDetection_tick+0xba>
   280c4:	f241 1808 	movw	r8, #4360	; 0x1108
   280c8:	f241 1e0a 	movw	lr, #4362	; 0x110a
   280cc:	465f      	mov	r7, fp
   280ce:	f10c 0a04 	add.w	sl, ip, #4
   280d2:	44e0      	add	r8, ip
   280d4:	44e6      	add	lr, ip
        t_sample *hp = x->buf + count;
   280d6:	eb0a 0286 	add.w	r2, sl, r6, lsl #2
        t_sample sum = *sump;
   280da:	ecb7 7a01 	vldmia	r7!, {s14}
        for (i = 0; i < n; i++)
   280de:	b165      	cbz	r5, 280fa <tPeriodDetection_tick+0xa6>
   280e0:	4648      	mov	r0, r9
   280e2:	2300      	movs	r3, #0
            sum += *hp++ * (*fp * *fp);
   280e4:	ed70 7a01 	vldmdb	r0!, {s15}
        for (i = 0; i < n; i++)
   280e8:	3301      	adds	r3, #1
            sum += *hp++ * (*fp * *fp);
   280ea:	ecf2 6a01 	vldmia	r2!, {s13}
   280ee:	ee67 7aa7 	vmul.f32	s15, s15, s15
        for (i = 0; i < n; i++)
   280f2:	429d      	cmp	r5, r3
            sum += *hp++ * (*fp * *fp);
   280f4:	eea6 7aa7 	vfma.f32	s14, s13, s15
        for (i = 0; i < n; i++)
   280f8:	d1f4      	bne.n	280e4 <tPeriodDetection_tick+0x90>
        *sump = sum;
   280fa:	ed07 7a01 	vstr	s14, [r7, #-4]
   280fe:	46bb      	mov	fp, r7
         count < x->x_npoints; count += x->x_realperiod, sump++)
   28100:	f8b8 2000 	ldrh.w	r2, [r8]
   28104:	f8be 3000 	ldrh.w	r3, [lr]
   28108:	4416      	add	r6, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
   2810a:	429e      	cmp	r6, r3
   2810c:	dbe3      	blt.n	280d6 <tPeriodDetection_tick+0x82>
    x->x_phase -= n;
   2810e:	f241 1204 	movw	r2, #4356	; 0x1104
    sump[0] = 0;
   28112:	2300      	movs	r3, #0
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
   28114:	f104 0008 	add.w	r0, r4, #8
    sump[0] = 0;
   28118:	f8cb 3000 	str.w	r3, [fp]
    x->x_phase -= n;
   2811c:	f83c 3002 	ldrh.w	r3, [ip, r2]
   28120:	1b5d      	subs	r5, r3, r5
   28122:	f82c 5002 	strh.w	r5, [ip, r2]
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
   28126:	6963      	ldr	r3, [r4, #20]
   28128:	e9d4 5203 	ldrd	r5, r2, [r4, #12]
   2812c:	440a      	add	r2, r1
   2812e:	4429      	add	r1, r5
   28130:	f7ff fca0 	bl	27a74 <tSNAC_ioSamples>
    _tSNAC* s = *snac;
   28134:	68a3      	ldr	r3, [r4, #8]
        if (fidelity > p->fidelityThreshold)
   28136:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
   2813a:	edd3 7a08 	vldr	s15, [r3, #32]
   2813e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   28142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28146:	d501      	bpl.n	2814c <tPeriodDetection_tick+0xf8>
    return(s->periodlength);
   28148:	69db      	ldr	r3, [r3, #28]
        	p->period = tSNAC_getPeriod(&p->snac);
   2814a:	63a3      	str	r3, [r4, #56]	; 0x38
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   2814c:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
        p->curBlock++;
   28150:	3301      	adds	r3, #1
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   28152:	4293      	cmp	r3, r2
        p->curBlock++;
   28154:	6223      	str	r3, [r4, #32]
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   28156:	db01      	blt.n	2815c <tPeriodDetection_tick+0x108>
   28158:	2300      	movs	r3, #0
   2815a:	6223      	str	r3, [r4, #32]
        p->lastBlock++;
   2815c:	6a63      	ldr	r3, [r4, #36]	; 0x24
}
   2815e:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
        p->lastBlock++;
   28162:	3301      	adds	r3, #1
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
   28164:	429a      	cmp	r2, r3
   28166:	bfd8      	it	le
   28168:	2300      	movle	r3, #0
   2816a:	6263      	str	r3, [r4, #36]	; 0x24
}
   2816c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00028170 <tPeriodDetection_getPeriod>:

float tPeriodDetection_getPeriod(tPeriodDetection* pd)
{
    _tPeriodDetection* p = *pd;
    return p->period;
   28170:	6803      	ldr	r3, [r0, #0]
}
   28172:	ed93 0a0e 	vldr	s0, [r3, #56]	; 0x38
   28176:	4770      	bx	lr

00028178 <tPeriodDetection_setFidelityThreshold>:
    p->windowSize = ws;
}

void tPeriodDetection_setFidelityThreshold(tPeriodDetection* pd, float threshold)
{
    _tPeriodDetection* p = *pd;
   28178:	6803      	ldr	r3, [r0, #0]
    p->fidelityThreshold = threshold;
   2817a:	ed83 0a16 	vstr	s0, [r3, #88]	; 0x58
}
   2817e:	4770      	bx	lr

00028180 <tLinearDelay_initToPool>:
{
    tLinearDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tLinearDelay_initToPool  (tLinearDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
   28180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28182:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   28186:	6816      	ldr	r6, [r2, #0]
{
   28188:	460d      	mov	r5, r1
   2818a:	4607      	mov	r7, r0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   2818c:	202c      	movs	r0, #44	; 0x2c
   2818e:	4631      	mov	r1, r6
{
   28190:	eeb0 8a40 	vmov.f32	s16, s0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   28194:	f005 f83c 	bl	2d210 <mpool_alloc>
    d->mempool = m;

    d->maxDelay = maxDelay;

    if (delay > maxDelay)   d->delay = maxDelay;
   28198:	ee07 5a90 	vmov	s15, r5
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   2819c:	6038      	str	r0, [r7, #0]
   2819e:	4604      	mov	r4, r0
    if (delay > maxDelay)   d->delay = maxDelay;
   281a0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    d->mempool = m;
   281a4:	6006      	str	r6, [r0, #0]
    d->maxDelay = maxDelay;
   281a6:	61c5      	str	r5, [r0, #28]
    if (delay > maxDelay)   d->delay = maxDelay;
   281a8:	eef4 7ac8 	vcmpe.f32	s15, s16
   281ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   281b0:	d453      	bmi.n	2825a <tLinearDelay_initToPool+0xda>
    else if (delay < 0.0f)  d->delay = 0.0f;
   281b2:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   281b6:	2300      	movs	r3, #0
   281b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   281bc:	bf4c      	ite	mi
   281be:	6203      	strmi	r3, [r0, #32]
    else                    d->delay = delay;
   281c0:	ed80 8a08 	vstrpl	s16, [r0, #32]

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   281c4:	4631      	mov	r1, r6
   281c6:	00a8      	lsls	r0, r5, #2
   281c8:	f005 f822 	bl	2d210 <mpool_alloc>

    d->gain = 1.0f;

    d->lastIn = 0.0f;
   281cc:	2300      	movs	r3, #0
    d->gain = 1.0f;
   281ce:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   281d2:	60a0      	str	r0, [r4, #8]
    d->lastOut = 0.0f;
    
    d->inPoint = 0;
   281d4:	6163      	str	r3, [r4, #20]

int     tLinearDelay_setDelay (tLinearDelay* const dl, float delay)
{
    _tLinearDelay* d = *dl;

    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   281d6:	ee00 3a10 	vmov	s0, r3
    d->lastIn = 0.0f;
   281da:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   281dc:	60e3      	str	r3, [r4, #12]
    d->gain = 1.0f;
   281de:	6061      	str	r1, [r4, #4]
    d->outPoint = 0;
   281e0:	61a3      	str	r3, [r4, #24]
    _tLinearDelay* d = *dl;
   281e2:	683d      	ldr	r5, [r7, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   281e4:	edd4 0a08 	vldr	s1, [r4, #32]
   281e8:	edd5 7a07 	vldr	s15, [r5, #28]
   281ec:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   281f0:	f004 fdf6 	bl	2cde0 <LEAF_clip>

    float outPointer = d->inPoint - d->delay;
   281f4:	edd5 7a05 	vldr	s15, [r5, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   281f8:	ed85 0a08 	vstr	s0, [r5, #32]
    float outPointer = d->inPoint - d->delay;
   281fc:	eef8 7a67 	vcvt.f32.u32	s15, s15

    while ( outPointer < 0 )
        outPointer += d->maxDelay; // modulo maximum length
   28200:	69ea      	ldr	r2, [r5, #28]
    float outPointer = d->inPoint - d->delay;
   28202:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
   28206:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2820a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2820e:	d50a      	bpl.n	28226 <tLinearDelay_initToPool+0xa6>
        outPointer += d->maxDelay; // modulo maximum length
   28210:	ee07 2a90 	vmov	s15, r2
   28214:	eef8 7a67 	vcvt.f32.u32	s15, s15
   28218:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
   2821c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   28220:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28224:	d4f8      	bmi.n	28218 <tLinearDelay_initToPool+0x98>

    d->outPoint = (uint32_t) outPointer;   // integer part
   28226:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   2822a:	ee17 3a90 	vmov	r3, s15

    d->alpha = outPointer - d->outPoint; // fractional part
    d->omAlpha = 1.0f - d->alpha;
   2822e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
   28232:	ee07 3a10 	vmov	s14, r3

    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   28236:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
   28238:	61ab      	str	r3, [r5, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
   2823a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   2823e:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
   28242:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
   28246:	ed85 0a09 	vstr	s0, [r5, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
   2824a:	edc5 7a0a 	vstr	s15, [r5, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   2824e:	d101      	bne.n	28254 <tLinearDelay_initToPool+0xd4>
   28250:	2300      	movs	r3, #0
   28252:	61ab      	str	r3, [r5, #24]
}
   28254:	ecbd 8b02 	vpop	{d8}
   28258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (delay > maxDelay)   d->delay = maxDelay;
   2825a:	edc0 7a08 	vstr	s15, [r0, #32]
   2825e:	e7b1      	b.n	281c4 <tLinearDelay_initToPool+0x44>

00028260 <tLinearDelay_free>:
{
   28260:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
   28262:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
   28264:	6821      	ldr	r1, [r4, #0]
   28266:	68a0      	ldr	r0, [r4, #8]
   28268:	f005 f87c 	bl	2d364 <mpool_free>
    mpool_free((char*)d, d->mempool);
   2826c:	6821      	ldr	r1, [r4, #0]
   2826e:	4620      	mov	r0, r4
}
   28270:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
   28274:	f005 b876 	b.w	2d364 <mpool_free>

00028278 <tLinearDelay_clear>:
	_tLinearDelay* d = *dl;
   28278:	6801      	ldr	r1, [r0, #0]
	for (int i = 0; i < d->maxDelay; i++)
   2827a:	69cb      	ldr	r3, [r1, #28]
   2827c:	b14b      	cbz	r3, 28292 <tLinearDelay_clear+0x1a>
		d->buff[i] = 0;
   2827e:	2000      	movs	r0, #0
	for (int i = 0; i < d->maxDelay; i++)
   28280:	4603      	mov	r3, r0
		d->buff[i] = 0;
   28282:	688a      	ldr	r2, [r1, #8]
   28284:	eb02 0283 	add.w	r2, r2, r3, lsl #2
	for (int i = 0; i < d->maxDelay; i++)
   28288:	3301      	adds	r3, #1
		d->buff[i] = 0;
   2828a:	6010      	str	r0, [r2, #0]
	for (int i = 0; i < d->maxDelay; i++)
   2828c:	69ca      	ldr	r2, [r1, #28]
   2828e:	429a      	cmp	r2, r3
   28290:	d8f7      	bhi.n	28282 <tLinearDelay_clear+0xa>
}
   28292:	4770      	bx	lr

00028294 <tLinearDelay_tick>:
{
   28294:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
   28296:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   28298:	edd3 7a01 	vldr	s15, [r3, #4]
   2829c:	6959      	ldr	r1, [r3, #20]
   2829e:	689a      	ldr	r2, [r3, #8]
   282a0:	ee27 0a80 	vmul.f32	s0, s15, s0
   282a4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   282a8:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   282ac:	695a      	ldr	r2, [r3, #20]
   282ae:	69d9      	ldr	r1, [r3, #28]
   282b0:	3201      	adds	r2, #1
   282b2:	428a      	cmp	r2, r1
   282b4:	615a      	str	r2, [r3, #20]
   282b6:	d101      	bne.n	282bc <tLinearDelay_tick+0x28>
   282b8:	2200      	movs	r2, #0
   282ba:	615a      	str	r2, [r3, #20]
    uint32_t idx = (uint32_t) d->outPoint;
   282bc:	699a      	ldr	r2, [r3, #24]
    d->lastOut = d->buff[idx] * d->omAlpha;
   282be:	6898      	ldr	r0, [r3, #8]
    if ((idx + 1) < d->maxDelay)
   282c0:	1c54      	adds	r4, r2, #1
    d->lastOut = d->buff[idx] * d->omAlpha;
   282c2:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
   282c6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   282ca:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    if ((idx + 1) < d->maxDelay)
   282ce:	42a1      	cmp	r1, r4
    d->lastOut = d->buff[idx] * d->omAlpha;
   282d0:	ed92 0a00 	vldr	s0, [r2]
   282d4:	ee20 0a07 	vmul.f32	s0, s0, s14
   282d8:	ed83 0a03 	vstr	s0, [r3, #12]
    if ((idx + 1) < d->maxDelay)
   282dc:	d909      	bls.n	282f2 <tLinearDelay_tick+0x5e>
        d->lastOut += d->buff[idx+1] * d->alpha;
   282de:	ed92 7a01 	vldr	s14, [r2, #4]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   282e2:	619c      	str	r4, [r3, #24]
        d->lastOut += d->buff[idx+1] * d->alpha;
   282e4:	eea7 0a27 	vfma.f32	s0, s14, s15
   282e8:	ed83 0a03 	vstr	s0, [r3, #12]
}
   282ec:	f85d 4b04 	ldr.w	r4, [sp], #4
   282f0:	4770      	bx	lr
        d->lastOut += d->buff[0] * d->alpha;
   282f2:	ed90 7a00 	vldr	s14, [r0]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   282f6:	2200      	movs	r2, #0
        d->lastOut += d->buff[0] * d->alpha;
   282f8:	eea7 0a27 	vfma.f32	s0, s14, s15
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   282fc:	619a      	str	r2, [r3, #24]
        d->lastOut += d->buff[0] * d->alpha;
   282fe:	ed83 0a03 	vstr	s0, [r3, #12]
}
   28302:	f85d 4b04 	ldr.w	r4, [sp], #4
   28306:	4770      	bx	lr

00028308 <tLinearDelay_tickIn>:
    _tLinearDelay* d = *dl;
   28308:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   2830a:	edd3 7a01 	vldr	s15, [r3, #4]
   2830e:	6959      	ldr	r1, [r3, #20]
   28310:	689a      	ldr	r2, [r3, #8]
   28312:	ee27 0a80 	vmul.f32	s0, s15, s0
   28316:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2831a:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   2831e:	695a      	ldr	r2, [r3, #20]
   28320:	69d9      	ldr	r1, [r3, #28]
   28322:	3201      	adds	r2, #1
   28324:	428a      	cmp	r2, r1
   28326:	615a      	str	r2, [r3, #20]
   28328:	d101      	bne.n	2832e <tLinearDelay_tickIn+0x26>
   2832a:	2200      	movs	r2, #0
   2832c:	615a      	str	r2, [r3, #20]
}
   2832e:	4770      	bx	lr

00028330 <tLinearDelay_tickOut>:
{
   28330:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
   28332:	6803      	ldr	r3, [r0, #0]
	uint32_t idx = (uint32_t) d->outPoint;
   28334:	699a      	ldr	r2, [r3, #24]
	d->lastOut = d->buff[idx] * d->omAlpha;
   28336:	6899      	ldr	r1, [r3, #8]
	if ((idx + 1) < d->maxDelay)
   28338:	1c50      	adds	r0, r2, #1
	d->lastOut = d->buff[idx] * d->omAlpha;
   2833a:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
   2833e:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	if ((idx + 1) < d->maxDelay)
   28342:	69dc      	ldr	r4, [r3, #28]
   28344:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
	d->lastOut = d->buff[idx] * d->omAlpha;
   28348:	ed92 0a00 	vldr	s0, [r2]
	if ((idx + 1) < d->maxDelay)
   2834c:	42a0      	cmp	r0, r4
	d->lastOut = d->buff[idx] * d->omAlpha;
   2834e:	ee20 0a07 	vmul.f32	s0, s0, s14
   28352:	ed83 0a03 	vstr	s0, [r3, #12]
	if ((idx + 1) < d->maxDelay)
   28356:	d209      	bcs.n	2836c <tLinearDelay_tickOut+0x3c>
		d->lastOut += d->buff[idx+1] * d->alpha;
   28358:	ed92 7a01 	vldr	s14, [r2, #4]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   2835c:	6198      	str	r0, [r3, #24]
		d->lastOut += d->buff[idx+1] * d->alpha;
   2835e:	eea7 0a27 	vfma.f32	s0, s14, s15
   28362:	ed83 0a03 	vstr	s0, [r3, #12]
}
   28366:	f85d 4b04 	ldr.w	r4, [sp], #4
   2836a:	4770      	bx	lr
		d->lastOut += d->buff[0] * d->alpha;
   2836c:	ed91 7a00 	vldr	s14, [r1]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   28370:	2200      	movs	r2, #0
		d->lastOut += d->buff[0] * d->alpha;
   28372:	eea7 0a27 	vfma.f32	s0, s14, s15
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   28376:	619a      	str	r2, [r3, #24]
		d->lastOut += d->buff[0] * d->alpha;
   28378:	ed83 0a03 	vstr	s0, [r3, #12]
}
   2837c:	f85d 4b04 	ldr.w	r4, [sp], #4
   28380:	4770      	bx	lr
   28382:	bf00      	nop

00028384 <tLinearDelay_setDelay>:
{
   28384:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
   28386:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   28388:	2300      	movs	r3, #0
   2838a:	eef0 0a40 	vmov.f32	s1, s0
   2838e:	edd4 7a07 	vldr	s15, [r4, #28]
   28392:	ee00 3a10 	vmov	s0, r3
   28396:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   2839a:	f004 fd21 	bl	2cde0 <LEAF_clip>
    float outPointer = d->inPoint - d->delay;
   2839e:	edd4 7a05 	vldr	s15, [r4, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   283a2:	ed84 0a08 	vstr	s0, [r4, #32]
    float outPointer = d->inPoint - d->delay;
   283a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
        outPointer += d->maxDelay; // modulo maximum length
   283aa:	69e2      	ldr	r2, [r4, #28]
    float outPointer = d->inPoint - d->delay;
   283ac:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
   283b0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   283b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   283b8:	d50a      	bpl.n	283d0 <tLinearDelay_setDelay+0x4c>
        outPointer += d->maxDelay; // modulo maximum length
   283ba:	ee07 2a90 	vmov	s15, r2
   283be:	eef8 7a67 	vcvt.f32.u32	s15, s15
   283c2:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
   283c6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   283ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   283ce:	d4f8      	bmi.n	283c2 <tLinearDelay_setDelay+0x3e>
    d->outPoint = (uint32_t) outPointer;   // integer part
   283d0:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   283d4:	ee17 3a90 	vmov	r3, s15
    d->omAlpha = 1.0f - d->alpha;
   283d8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
   283dc:	ee07 3a10 	vmov	s14, r3
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   283e0:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
   283e2:	61a3      	str	r3, [r4, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
   283e4:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   283e8:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
   283ec:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
   283f0:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
   283f4:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   283f8:	d101      	bne.n	283fe <tLinearDelay_setDelay+0x7a>
   283fa:	2300      	movs	r3, #0
   283fc:	61a3      	str	r3, [r4, #24]

    return 0;
}
   283fe:	2000      	movs	r0, #0
   28400:	bd10      	pop	{r4, pc}
   28402:	bf00      	nop

00028404 <tLinearDelay_getDelay>:
}

float   tLinearDelay_getDelay (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->delay;
   28404:	6803      	ldr	r3, [r0, #0]
}
   28406:	ed93 0a08 	vldr	s0, [r3, #32]
   2840a:	4770      	bx	lr

0002840c <tLinearDelay_getLastOut>:

float   tLinearDelay_getLastOut (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->lastOut;
   2840c:	6803      	ldr	r3, [r0, #0]
}
   2840e:	ed93 0a03 	vldr	s0, [r3, #12]
   28412:	4770      	bx	lr

00028414 <tTapeDelay_init>:
    return d->gain;
}

// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ TapeDelay ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ //
void tTapeDelay_init (tTapeDelay* const dl, float delay, uint32_t maxDelay)
{
   28414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tTapeDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tTapeDelay_initToPool (tTapeDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
    _tMempool* m = *mp;
   28416:	f64f 0308 	movw	r3, #63496	; 0xf808
{
   2841a:	4606      	mov	r6, r0
   2841c:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   2841e:	202c      	movs	r0, #44	; 0x2c
    _tMempool* m = *mp;
   28420:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   28424:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   28428:	699d      	ldr	r5, [r3, #24]
{
   2842a:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   2842e:	4629      	mov	r1, r5
   28430:	f004 feee 	bl	2d210 <mpool_alloc>
   28434:	4604      	mov	r4, r0
    d->mempool = m;

    d->maxDelay = maxDelay;

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   28436:	4629      	mov	r1, r5
   28438:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   2843a:	6034      	str	r4, [r6, #0]
    d->mempool = m;
   2843c:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
   2843e:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   28440:	f004 fee6 	bl	2d210 <mpool_alloc>

    d->gain = 1.0f;
   28444:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

    d->lastIn = 0.0f;
   28448:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   2844a:	60a0      	str	r0, [r4, #8]
}

void     tTapeDelay_setDelay (tTapeDelay* const dl, float delay)
{
    _tTapeDelay* d = *dl;
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   2844c:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
   28450:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   28454:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
   28458:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
   2845c:	6163      	str	r3, [r4, #20]
    d->lastIn = 0.0f;
   2845e:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   28460:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
   28462:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
   28464:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   28466:	edd4 7a06 	vldr	s15, [r4, #24]
   2846a:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   2846e:	f004 fcb7 	bl	2cde0 <LEAF_clip>
   28472:	ed84 0a07 	vstr	s0, [r4, #28]
}
   28476:	ecbd 8b02 	vpop	{d8}
   2847a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002847c <tTapeDelay_initToPool>:
{
   2847c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2847e:	6815      	ldr	r5, [r2, #0]
{
   28480:	4606      	mov	r6, r0
   28482:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   28484:	202c      	movs	r0, #44	; 0x2c
   28486:	4629      	mov	r1, r5
{
   28488:	ed2d 8b02 	vpush	{d8}
   2848c:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   28490:	f004 febe 	bl	2d210 <mpool_alloc>
   28494:	4604      	mov	r4, r0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   28496:	4629      	mov	r1, r5
   28498:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   2849a:	6034      	str	r4, [r6, #0]
    d->mempool = m;
   2849c:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
   2849e:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   284a0:	f004 feb6 	bl	2d210 <mpool_alloc>
    d->gain = 1.0f;
   284a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->lastIn = 0.0f;
   284a8:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   284aa:	60a0      	str	r0, [r4, #8]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   284ac:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
   284b0:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   284b4:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
   284b8:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
   284bc:	6163      	str	r3, [r4, #20]
    d->lastIn = 0.0f;
   284be:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   284c0:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
   284c2:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
   284c4:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   284c6:	edd4 7a06 	vldr	s15, [r4, #24]
   284ca:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   284ce:	f004 fc87 	bl	2cde0 <LEAF_clip>
   284d2:	ed84 0a07 	vstr	s0, [r4, #28]
}
   284d6:	ecbd 8b02 	vpop	{d8}
   284da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000284dc <tTapeDelay_free>:
{
   284dc:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
   284de:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
   284e0:	6821      	ldr	r1, [r4, #0]
   284e2:	68a0      	ldr	r0, [r4, #8]
   284e4:	f004 ff3e 	bl	2d364 <mpool_free>
    mpool_free((char*)d, d->mempool);
   284e8:	6821      	ldr	r1, [r4, #0]
   284ea:	4620      	mov	r0, r4
}
   284ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
   284f0:	f004 bf38 	b.w	2d364 <mpool_free>

000284f4 <tTapeDelay_tick>:
{
   284f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tTapeDelay* d = *dl;
   284f6:	6804      	ldr	r4, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   284f8:	edd4 7a01 	vldr	s15, [r4, #4]
   284fc:	6962      	ldr	r2, [r4, #20]
   284fe:	68a3      	ldr	r3, [r4, #8]
   28500:	ee27 0a80 	vmul.f32	s0, s15, s0
   28504:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   28508:	ed83 0a00 	vstr	s0, [r3]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   2850c:	e9d4 2305 	ldrd	r2, r3, [r4, #20]
   28510:	3201      	adds	r2, #1
   28512:	429a      	cmp	r2, r3
   28514:	6162      	str	r2, [r4, #20]
   28516:	d101      	bne.n	2851c <tTapeDelay_tick+0x28>
   28518:	2200      	movs	r2, #0
   2851a:	6162      	str	r2, [r4, #20]
    int idx =  (int) d->idx;
   2851c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   28520:	1e5e      	subs	r6, r3, #1
   28522:	68a1      	ldr	r1, [r4, #8]
    int idx =  (int) d->idx;
   28524:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   28528:	ee17 2a10 	vmov	r2, s14
    float alpha = d->idx - idx;
   2852c:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[(idx + 1) % d->maxDelay],
   28530:	1c57      	adds	r7, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
   28532:	f102 0c02 	add.w	ip, r2, #2
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   28536:	4416      	add	r6, r2
   28538:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   2853c:	ee37 2ac2 	vsub.f32	s4, s15, s4
   28540:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
   28544:	fbb7 f0f3 	udiv	r0, r7, r3
   28548:	fb03 7010 	mls	r0, r3, r0, r7
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2854c:	eb01 0280 	add.w	r2, r1, r0, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
   28550:	fbbc f5f3 	udiv	r5, ip, r3
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   28554:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
   28558:	fb03 c515 	mls	r5, r3, r5, ip
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2855c:	fbb6 f2f3 	udiv	r2, r6, r3
   28560:	fb03 6312 	mls	r3, r3, r2, r6
   28564:	eb01 0585 	add.w	r5, r1, r5, lsl #2
   28568:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   2856c:	edd5 1a00 	vldr	s3, [r5]
   28570:	ed91 0a00 	vldr	s0, [r1]
   28574:	f004 fd52 	bl	2d01c <LEAF_interpolate_hermite_x>
    float diff = (d->inPoint - d->idx);
   28578:	edd4 7a05 	vldr	s15, [r4, #20]
   2857c:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
   28580:	eef8 7a67 	vcvt.f32.u32	s15, s15
    while (diff < 0.f) diff += d->maxDelay;
   28584:	ed94 7a06 	vldr	s14, [r4, #24]
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   28588:	ed84 0a03 	vstr	s0, [r4, #12]
    while (diff < 0.f) diff += d->maxDelay;
   2858c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    float diff = (d->inPoint - d->idx);
   28590:	ee77 7ae6 	vsub.f32	s15, s15, s13
    while (diff < 0.f) diff += d->maxDelay;
   28594:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   28598:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2859c:	d506      	bpl.n	285ac <tTapeDelay_tick+0xb8>
   2859e:	ee77 7a87 	vadd.f32	s15, s15, s14
   285a2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   285a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   285aa:	d4f8      	bmi.n	2859e <tTapeDelay_tick+0xaa>
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
   285ac:	edd4 5a07 	vldr	s11, [r4, #28]
   285b0:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   285b4:	ee77 7ae5 	vsub.f32	s15, s15, s11
   285b8:	ee87 6aa5 	vdiv.f32	s12, s15, s11
   285bc:	ee76 7a05 	vadd.f32	s15, s12, s10
    d->idx += d->inc;
   285c0:	ee76 6aa7 	vadd.f32	s13, s13, s15
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
   285c4:	edc4 7a08 	vstr	s15, [r4, #32]
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
   285c8:	eef4 6ac7 	vcmpe.f32	s13, s14
   285cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   285d0:	da02      	bge.n	285d8 <tTapeDelay_tick+0xe4>
    d->idx += d->inc;
   285d2:	edc4 6a09 	vstr	s13, [r4, #36]	; 0x24
}
   285d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
   285d8:	2300      	movs	r3, #0
   285da:	6263      	str	r3, [r4, #36]	; 0x24
}
   285dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   285de:	bf00      	nop

000285e0 <tTapeDelay_setDelay>:
{
   285e0:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
   285e2:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   285e4:	eef0 0a40 	vmov.f32	s1, s0
   285e8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   285ec:	edd4 7a06 	vldr	s15, [r4, #24]
   285f0:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   285f4:	f004 fbf4 	bl	2cde0 <LEAF_clip>
   285f8:	ed84 0a07 	vstr	s0, [r4, #28]
}
   285fc:	bd10      	pop	{r4, pc}
   285fe:	bf00      	nop

00028600 <tTapeDelay_tapOut>:

float tTapeDelay_tapOut (tTapeDelay* const dl, float tapDelay)
{
   28600:	b4f0      	push	{r4, r5, r6, r7}
    _tTapeDelay* d = *dl;
   28602:	6801      	ldr	r1, [r0, #0]

    float tap = (float) d->inPoint - tapDelay - 1.f;
   28604:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   28608:	edd1 7a05 	vldr	s15, [r1, #20]
   2860c:	698b      	ldr	r3, [r1, #24]
   2860e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   28612:	ee37 0ac0 	vsub.f32	s0, s15, s0

    // Check for wraparound.
    while ( tap < 0.f )   tap += (float)d->maxDelay;
   28616:	eeb4 0ac7 	vcmpe.f32	s0, s14
    float tap = (float) d->inPoint - tapDelay - 1.f;
   2861a:	ee70 7a47 	vsub.f32	s15, s0, s14
    while ( tap < 0.f )   tap += (float)d->maxDelay;
   2861e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28622:	d50a      	bpl.n	2863a <tTapeDelay_tapOut+0x3a>
   28624:	ee07 3a10 	vmov	s14, r3
   28628:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   2862c:	ee77 7a87 	vadd.f32	s15, s15, s14
   28630:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   28634:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28638:	d4f8      	bmi.n	2862c <tTapeDelay_tapOut+0x2c>

    int idx =  (int) tap;
   2863a:	eebd 7ae7 	vcvt.s32.f32	s14, s15

    float alpha = tap - idx;

    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2863e:	6889      	ldr	r1, [r1, #8]
   28640:	1e5d      	subs	r5, r3, #1
    int idx =  (int) tap;
   28642:	ee17 2a10 	vmov	r2, s14
    float alpha = tap - idx;
   28646:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[idx],
                                              d->buff[(idx + 1) % d->maxDelay],
   2864a:	1c56      	adds	r6, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
   2864c:	1c97      	adds	r7, r2, #2
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2864e:	4415      	add	r5, r2
   28650:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   28654:	ee37 2ac2 	vsub.f32	s4, s15, s4
   28658:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
   2865c:	fbb6 f0f3 	udiv	r0, r6, r3
   28660:	fb03 6210 	mls	r2, r3, r0, r6
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   28664:	eb01 0282 	add.w	r2, r1, r2, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
   28668:	fbb7 f4f3 	udiv	r4, r7, r3
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2866c:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
   28670:	fb03 7414 	mls	r4, r3, r4, r7
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   28674:	fbb5 f2f3 	udiv	r2, r5, r3
   28678:	fb03 5312 	mls	r3, r3, r2, r5
   2867c:	eb01 0084 	add.w	r0, r1, r4, lsl #2
   28680:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   28684:	edd0 1a00 	vldr	s3, [r0]
   28688:	ed91 0a00 	vldr	s0, [r1]
                                              alpha);

    return samp;

}
   2868c:	bcf0      	pop	{r4, r5, r6, r7}
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2868e:	f004 bcc5 	b.w	2d01c <LEAF_interpolate_hermite_x>
   28692:	bf00      	nop

00028694 <tOversampler_initToPool>:
{
    tOversampler_initToPool(osr, ratio, extraQuality, &leaf.mempool);
}

void tOversampler_initToPool (tOversampler* const osr, int ratio, oBool extraQuality, tMempool* const mp)
{
   28694:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
   28698:	681e      	ldr	r6, [r3, #0]
{
   2869a:	4690      	mov	r8, r2
   2869c:	460d      	mov	r5, r1
   2869e:	4607      	mov	r7, r0
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   286a0:	4631      	mov	r1, r6
   286a2:	201c      	movs	r0, #28
   286a4:	f004 fdb4 	bl	2d210 <mpool_alloc>
    os->mempool = m;
    
    uint8_t offset = 0;
    if (extraQuality) offset = 6;
   286a8:	f1b8 0f00 	cmp.w	r8, #0
    if (ratio == 2 || ratio == 4  ||
   286ac:	f1a5 0102 	sub.w	r1, r5, #2
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   286b0:	6038      	str	r0, [r7, #0]
    if (extraQuality) offset = 6;
   286b2:	bf14      	ite	ne
   286b4:	f04f 0806 	movne.w	r8, #6
   286b8:	f04f 0800 	moveq.w	r8, #0
    if (ratio == 2 || ratio == 4  ||
   286bc:	291e      	cmp	r1, #30
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   286be:	4604      	mov	r4, r0
    os->mempool = m;
   286c0:	6006      	str	r6, [r0, #0]
    if (ratio == 2 || ratio == 4  ||
   286c2:	d933      	bls.n	2872c <tOversampler_initToPool+0x98>
        ratio == 8 || ratio == 16 ||
        ratio == 32 || ratio == 64) {
   286c4:	2d40      	cmp	r5, #64	; 0x40
   286c6:	d12f      	bne.n	28728 <tOversampler_initToPool+0x94>
        os->ratio = ratio;
        int idx = (int)(log2f(os->ratio))-1+offset;
   286c8:	ee07 5a90 	vmov	s15, r5
        os->ratio = ratio;
   286cc:	6065      	str	r5, [r4, #4]
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
        os->phaseLength = os->numTaps / os->ratio;
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   286ce:	f246 37b8 	movw	r7, #25528	; 0x63b8
        int idx = (int)(log2f(os->ratio))-1+offset;
   286d2:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   286d6:	f007 ffc3 	bl	30660 <log2f>
   286da:	eebd 0ac0 	vcvt.s32.f32	s0, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   286de:	f245 620c 	movw	r2, #22028	; 0x560c
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   286e2:	f2c0 0706 	movt	r7, #6
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   286e6:	4631      	mov	r1, r6
        int idx = (int)(log2f(os->ratio))-1+offset;
   286e8:	ee10 3a10 	vmov	r3, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   286ec:	f2c0 0205 	movt	r2, #5
        int idx = (int)(log2f(os->ratio))-1+offset;
   286f0:	3b01      	subs	r3, #1
   286f2:	4443      	add	r3, r8
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   286f4:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   286f8:	edd2 7a00 	vldr	s15, [r2]
   286fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   28700:	ee17 0a90 	vmov	r0, s15
   28704:	edc4 7a05 	vstr	s15, [r4, #20]
        os->phaseLength = os->numTaps / os->ratio;
   28708:	fb90 f5f5 	sdiv	r5, r0, r5
   2870c:	61a5      	str	r5, [r4, #24]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2870e:	00c0      	lsls	r0, r0, #3
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   28710:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
   28714:	60a3      	str	r3, [r4, #8]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   28716:	f004 fd7b 	bl	2d210 <mpool_alloc>
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2871a:	6963      	ldr	r3, [r4, #20]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2871c:	60e0      	str	r0, [r4, #12]
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2871e:	4631      	mov	r1, r6
   28720:	00d8      	lsls	r0, r3, #3
   28722:	f004 fd75 	bl	2d210 <mpool_alloc>
   28726:	6120      	str	r0, [r4, #16]
    }
}
   28728:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (ratio == 2 || ratio == 4  ||
   2872c:	f244 0245 	movw	r2, #16453	; 0x4045
   28730:	f2c4 0200 	movt	r2, #16384	; 0x4000
   28734:	40ca      	lsrs	r2, r1
   28736:	07d3      	lsls	r3, r2, #31
   28738:	d4c6      	bmi.n	286c8 <tOversampler_initToPool+0x34>
}
   2873a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2873e:	bf00      	nop

00028740 <tOversampler_free>:

void tOversampler_free (tOversampler* const osr)
{
   28740:	b510      	push	{r4, lr}
    _tOversampler* os = *osr;
   28742:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)os->upState, os->mempool);
   28744:	6821      	ldr	r1, [r4, #0]
   28746:	68e0      	ldr	r0, [r4, #12]
   28748:	f004 fe0c 	bl	2d364 <mpool_free>
    mpool_free((char*)os->downState, os->mempool);
   2874c:	6821      	ldr	r1, [r4, #0]
   2874e:	6920      	ldr	r0, [r4, #16]
   28750:	f004 fe08 	bl	2d364 <mpool_free>
    mpool_free((char*)os, os->mempool);
   28754:	6821      	ldr	r1, [r4, #0]
   28756:	4620      	mov	r0, r4
}
   28758:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)os, os->mempool);
   2875c:	f004 be02 	b.w	2d364 <mpool_free>

00028760 <tOversampler_tick>:

float tOversampler_tick(tOversampler* const osr, float input, float* oversample, float (*effectTick)(float))
{
   28760:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tOversampler* os = *osr;
   28764:	f8d0 9000 	ldr.w	r9, [r0]
{
   28768:	b083      	sub	sp, #12
   2876a:	468a      	mov	sl, r1
   2876c:	4690      	mov	r8, r2
// From CMSIS DSP Library
void tOversampler_upsample(tOversampler* const osr, float input, float* output)
{
    _tOversampler* os = *osr;
    
    float *pState = os->upState;                 /* State pointer */
   2876e:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float *pStateCur;
    float *ptr1;                               /* Temporary pointer for state buffer */
    float *ptr2;                               /* Temporary pointer for coefficient buffer */
    float sum0;                                /* Accumulators */
    uint32_t i, tapCnt;                    /* Loop counters */
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
   28772:	f8d9 6018 	ldr.w	r6, [r9, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
   28776:	f8d9 e008 	ldr.w	lr, [r9, #8]
    /* os->pState buffer contains previous frame (phaseLen - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->upState + (phaseLen - 1U);
    
    /* Copy new input sample into the state buffer */
    *pStateCur = input;
   2877a:	eb0c 0386 	add.w	r3, ip, r6, lsl #2
{
   2877e:	9001      	str	r0, [sp, #4]
    *pStateCur = input;
   28780:	ed03 0a01 	vstr	s0, [r3, #-4]
    
    /* Address modifier index of coefficient buffer */
    j = 1U;
    
    /* Loop over the Interpolation factor. */
    i = os->ratio;
   28784:	f8d9 5004 	ldr.w	r5, [r9, #4]
    
    while (i > 0U)
   28788:	b33d      	cbz	r5, 287da <tOversampler_tick+0x7a>
         Repeat until we've computed numTaps-(4*os->L) coefficients. */
        
        /* Initialize tapCnt with number of samples */
        tapCnt = phaseLen;
        
        while (tapCnt > 0U)
   2878a:	2300      	movs	r3, #0
   2878c:	f105 0b01 	add.w	fp, r5, #1
    j = 1U;
   28790:	2701      	movs	r7, #1
        while (tapCnt > 0U)
   28792:	ee05 3a90 	vmov	s11, r3
        ptr2 = pCoeffs + (os->ratio - j);
   28796:	1beb      	subs	r3, r5, r7
   28798:	ee07 5a90 	vmov	s15, r5
   2879c:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
   287a0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
        while (tapCnt > 0U)
   287a4:	2e00      	cmp	r6, #0
   287a6:	d067      	beq.n	28878 <tOversampler_tick+0x118>
        sum0 = 0.0f;
   287a8:	2000      	movs	r0, #0
            sum0 += *ptr1++ * *ptr2;
            
            /* Upsampling is done by stuffing L-1 zeros between each sample.
             * So instead of multiplying zeros with coefficients,
             * Increment the coefficient pointer by interpolation factor times. */
            ptr2 += os->ratio;
   287aa:	00ad      	lsls	r5, r5, #2
   287ac:	4632      	mov	r2, r6
        ptr1 = pState;
   287ae:	4664      	mov	r4, ip
        sum0 = 0.0f;
   287b0:	ee07 0a90 	vmov	s15, r0
            sum0 += *ptr1++ * *ptr2;
   287b4:	edd3 6a00 	vldr	s13, [r3]
        while (tapCnt > 0U)
   287b8:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
   287ba:	ecb4 6a01 	vldmia	r4!, {s12}
            ptr2 += os->ratio;
   287be:	442b      	add	r3, r5
            sum0 += *ptr1++ * *ptr2;
   287c0:	eee6 7a26 	vfma.f32	s15, s12, s13
        while (tapCnt > 0U)
   287c4:	d1f6      	bne.n	287b4 <tOversampler_tick+0x54>
   287c6:	ee67 7a87 	vmul.f32	s15, s15, s14
        
        /* The result is in the accumulator, store in the destination buffer. */
        *output++ = sum0 * os->ratio;
        
        /* Increment the address modifier index of coefficient buffer */
        j++;
   287ca:	3701      	adds	r7, #1
        *output++ = sum0 * os->ratio;
   287cc:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
   287d0:	455f      	cmp	r7, fp
   287d2:	d002      	beq.n	287da <tOversampler_tick+0x7a>
   287d4:	f8d9 5004 	ldr.w	r5, [r9, #4]
   287d8:	e7dd      	b.n	28796 <tOversampler_tick+0x36>
    
    /* Initialize tapCnt with number of samples */
    tapCnt = (phaseLen - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
   287da:	3e01      	subs	r6, #1
    pState = pState + 1;
   287dc:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
   287e0:	f8d9 300c 	ldr.w	r3, [r9, #12]
    while (tapCnt > 0U)
   287e4:	d005      	beq.n	287f2 <tOversampler_tick+0x92>
    {
        *pStateCur++ = *pState++;
   287e6:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
   287ea:	3e01      	subs	r6, #1
        *pStateCur++ = *pState++;
   287ec:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
   287f0:	d1f9      	bne.n	287e6 <tOversampler_tick+0x86>
    for (int i = 0; i < os->ratio; ++i) {
   287f2:	f8d9 3004 	ldr.w	r3, [r9, #4]
   287f6:	2b00      	cmp	r3, #0
   287f8:	dd0c      	ble.n	28814 <tOversampler_tick+0xb4>
   287fa:	4655      	mov	r5, sl
   287fc:	2400      	movs	r4, #0
   287fe:	4646      	mov	r6, r8
        oversample[i] = effectTick(oversample[i]);
   28800:	ed95 0a00 	vldr	s0, [r5]
    for (int i = 0; i < os->ratio; ++i) {
   28804:	3401      	adds	r4, #1
        oversample[i] = effectTick(oversample[i]);
   28806:	47b0      	blx	r6
   28808:	eca5 0a01 	vstmia	r5!, {s0}
    for (int i = 0; i < os->ratio; ++i) {
   2880c:	f8d9 3004 	ldr.w	r3, [r9, #4]
   28810:	42a3      	cmp	r3, r4
   28812:	dcf5      	bgt.n	28800 <tOversampler_tick+0xa0>
}

// From CMSIS DSP Library
float tOversampler_downsample(tOversampler *const osr, float* input)
{
    _tOversampler* os = *osr;
   28814:	9b01      	ldr	r3, [sp, #4]
    uint32_t i, tapCnt;
    float output;
    
    /* os->pState buffer contains previous frame (numTaps - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->downState + (numTaps - 1U);
   28816:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tOversampler* os = *osr;
   2881a:	681d      	ldr	r5, [r3, #0]
    pStateCur = os->downState + (numTaps - 1U);
   2881c:	f6c3 72ff 	movt	r2, #16383	; 0x3fff
    uint32_t numTaps = os->numTaps;                 /* Number of filter coefficients in the filter */
   28820:	696f      	ldr	r7, [r5, #20]
    float *pState = os->downState;                 /* State pointer */
   28822:	692c      	ldr	r4, [r5, #16]
    pStateCur = os->downState + (numTaps - 1U);
   28824:	443a      	add	r2, r7
    
    /* Copy decimation factor number of new input samples into the state buffer */
    i = os->ratio;
   28826:	e9d5 3601 	ldrd	r3, r6, [r5, #4]
    pStateCur = os->downState + (numTaps - 1U);
   2882a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
    
    do
    {
        *pStateCur++ = *input++;
   2882e:	f85a 1b04 	ldr.w	r1, [sl], #4
        
    } while (--i);
   28832:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
   28834:	f842 1b04 	str.w	r1, [r2], #4
    } while (--i);
   28838:	d1f9      	bne.n	2882e <tOversampler_tick+0xce>
   2883a:	6868      	ldr	r0, [r5, #4]
   2883c:	1e7b      	subs	r3, r7, #1
   2883e:	692d      	ldr	r5, [r5, #16]
   28840:	461a      	mov	r2, r3
   28842:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    pb = pCoeffs;
    
    /* Initialize tapCnt with number of taps */
    tapCnt = numTaps;
    
    while (tapCnt > 0U)
   28846:	b1d7      	cbz	r7, 2887e <tOversampler_tick+0x11e>
    acc0 = 0.0f;
   28848:	2100      	movs	r1, #0
   2884a:	ee00 1a10 	vmov	s0, r1
   2884e:	e000      	b.n	28852 <tOversampler_tick+0xf2>
   28850:	3a01      	subs	r2, #1
        
        /* Fetch 1 state variable */
        x0 = *px0++;
        
        /* Perform the multiply-accumulate */
        acc0 += x0 * c0;
   28852:	ecb6 7a01 	vldmia	r6!, {s14}
   28856:	ecf4 7a01 	vldmia	r4!, {s15}
   2885a:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
   2885e:	2a00      	cmp	r2, #0
   28860:	d1f6      	bne.n	28850 <tOversampler_tick+0xf0>
    
    /* Initialize tapCnt with number of taps */
    tapCnt = (numTaps - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
   28862:	b133      	cbz	r3, 28872 <tOversampler_tick+0x112>
   28864:	462a      	mov	r2, r5
    {
        *pStateCur++ = *pState++;
   28866:	f850 1b04 	ldr.w	r1, [r0], #4
    while (tapCnt > 0U)
   2886a:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   2886c:	f842 1b04 	str.w	r1, [r2], #4
    while (tapCnt > 0U)
   28870:	d1f9      	bne.n	28866 <tOversampler_tick+0x106>
}
   28872:	b003      	add	sp, #12
   28874:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (tapCnt > 0U)
   28878:	eef0 7a65 	vmov.f32	s15, s11
   2887c:	e7a5      	b.n	287ca <tOversampler_tick+0x6a>
    acc0 = 0.0f;
   2887e:	2200      	movs	r2, #0
   28880:	ee00 2a10 	vmov	s0, r2
   28884:	e7ee      	b.n	28864 <tOversampler_tick+0x104>
   28886:	bf00      	nop

00028888 <tOversampler_upsample>:
{
   28888:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tOversampler* os = *osr;
   2888c:	f8d0 e000 	ldr.w	lr, [r0]
    float *pState = os->upState;                 /* State pointer */
   28890:	f8de c00c 	ldr.w	ip, [lr, #12]
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
   28894:	f8de 6018 	ldr.w	r6, [lr, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
   28898:	f8de 8008 	ldr.w	r8, [lr, #8]
    *pStateCur = input;
   2889c:	eb0c 0386 	add.w	r3, ip, r6, lsl #2
   288a0:	ed03 0a01 	vstr	s0, [r3, #-4]
    i = os->ratio;
   288a4:	f8de 5004 	ldr.w	r5, [lr, #4]
    while (i > 0U)
   288a8:	b335      	cbz	r5, 288f8 <tOversampler_upsample+0x70>
        while (tapCnt > 0U)
   288aa:	2300      	movs	r3, #0
   288ac:	f105 0901 	add.w	r9, r5, #1
    j = 1U;
   288b0:	2701      	movs	r7, #1
        while (tapCnt > 0U)
   288b2:	ee05 3a90 	vmov	s11, r3
        ptr2 = pCoeffs + (os->ratio - j);
   288b6:	1beb      	subs	r3, r5, r7
   288b8:	ee07 5a90 	vmov	s15, r5
   288bc:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   288c0:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
   288c4:	b336      	cbz	r6, 28914 <tOversampler_upsample+0x8c>
        sum0 = 0.0f;
   288c6:	2000      	movs	r0, #0
            ptr2 += os->ratio;
   288c8:	00ad      	lsls	r5, r5, #2
   288ca:	4632      	mov	r2, r6
        ptr1 = pState;
   288cc:	4664      	mov	r4, ip
        sum0 = 0.0f;
   288ce:	ee07 0a90 	vmov	s15, r0
            sum0 += *ptr1++ * *ptr2;
   288d2:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
   288d6:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
   288d8:	ecf4 6a01 	vldmia	r4!, {s13}
            ptr2 += os->ratio;
   288dc:	442b      	add	r3, r5
            sum0 += *ptr1++ * *ptr2;
   288de:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
   288e2:	d1f6      	bne.n	288d2 <tOversampler_upsample+0x4a>
   288e4:	ee67 7a86 	vmul.f32	s15, s15, s12
        j++;
   288e8:	3701      	adds	r7, #1
        *output++ = sum0 * os->ratio;
   288ea:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
   288ee:	454f      	cmp	r7, r9
   288f0:	d002      	beq.n	288f8 <tOversampler_upsample+0x70>
   288f2:	f8de 5004 	ldr.w	r5, [lr, #4]
   288f6:	e7de      	b.n	288b6 <tOversampler_upsample+0x2e>
    while (tapCnt > 0U)
   288f8:	3e01      	subs	r6, #1
    pState = pState + 1;
   288fa:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
   288fe:	f8de 300c 	ldr.w	r3, [lr, #12]
    while (tapCnt > 0U)
   28902:	d005      	beq.n	28910 <tOversampler_upsample+0x88>
        *pStateCur++ = *pState++;
   28904:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
   28908:	3e01      	subs	r6, #1
        *pStateCur++ = *pState++;
   2890a:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
   2890e:	d1f9      	bne.n	28904 <tOversampler_upsample+0x7c>
}
   28910:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        while (tapCnt > 0U)
   28914:	eef0 7a65 	vmov.f32	s15, s11
   28918:	e7e6      	b.n	288e8 <tOversampler_upsample+0x60>
   2891a:	bf00      	nop

0002891c <tOversampler_downsample>:
{
   2891c:	b4f0      	push	{r4, r5, r6, r7}
    pStateCur = os->downState + (numTaps - 1U);
   2891e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tOversampler* os = *osr;
   28922:	6805      	ldr	r5, [r0, #0]
    pStateCur = os->downState + (numTaps - 1U);
   28924:	f6c3 72ff 	movt	r2, #16383	; 0x3fff
    uint32_t numTaps = os->numTaps;                 /* Number of filter coefficients in the filter */
   28928:	696f      	ldr	r7, [r5, #20]
    float *pState = os->downState;                 /* State pointer */
   2892a:	692c      	ldr	r4, [r5, #16]
    pStateCur = os->downState + (numTaps - 1U);
   2892c:	443a      	add	r2, r7
    i = os->ratio;
   2892e:	e9d5 3601 	ldrd	r3, r6, [r5, #4]
    pStateCur = os->downState + (numTaps - 1U);
   28932:	eb04 0282 	add.w	r2, r4, r2, lsl #2
        *pStateCur++ = *input++;
   28936:	f851 0b04 	ldr.w	r0, [r1], #4
    } while (--i);
   2893a:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
   2893c:	f842 0b04 	str.w	r0, [r2], #4
    } while (--i);
   28940:	d1f9      	bne.n	28936 <tOversampler_downsample+0x1a>
   28942:	6868      	ldr	r0, [r5, #4]
   28944:	1e7b      	subs	r3, r7, #1
   28946:	692d      	ldr	r5, [r5, #16]
   28948:	461a      	mov	r2, r3
   2894a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    while (tapCnt > 0U)
   2894e:	b1b7      	cbz	r7, 2897e <tOversampler_downsample+0x62>
    acc0 = 0.0f;
   28950:	2100      	movs	r1, #0
   28952:	ee00 1a10 	vmov	s0, r1
   28956:	e000      	b.n	2895a <tOversampler_downsample+0x3e>
   28958:	3a01      	subs	r2, #1
        acc0 += x0 * c0;
   2895a:	ecb6 7a01 	vldmia	r6!, {s14}
   2895e:	ecf4 7a01 	vldmia	r4!, {s15}
   28962:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
   28966:	2a00      	cmp	r2, #0
   28968:	d1f6      	bne.n	28958 <tOversampler_downsample+0x3c>
    while (tapCnt > 0U)
   2896a:	b133      	cbz	r3, 2897a <tOversampler_downsample+0x5e>
   2896c:	462a      	mov	r2, r5
        *pStateCur++ = *pState++;
   2896e:	f850 1b04 	ldr.w	r1, [r0], #4
    while (tapCnt > 0U)
   28972:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   28974:	f842 1b04 	str.w	r1, [r2], #4
    while (tapCnt > 0U)
   28978:	d1f9      	bne.n	2896e <tOversampler_downsample+0x52>
        /* Decrement loop counter */
        tapCnt--;
    }
    
    return output;
}
   2897a:	bcf0      	pop	{r4, r5, r6, r7}
   2897c:	4770      	bx	lr
    acc0 = 0.0f;
   2897e:	2200      	movs	r2, #0
   28980:	ee00 2a10 	vmov	s0, r2
   28984:	e7f2      	b.n	2896c <tOversampler_downsample+0x50>
   28986:	bf00      	nop

00028988 <tLockhartWavefolder_initToPool>:
{
	tLockhartWavefolder_initToPool   (wf,  &leaf.mempool);
}

void tLockhartWavefolder_initToPool (tLockhartWavefolder* const wf, tMempool* const mp)
{
   28988:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    w->R = 15e3;
    w->VT = 26e-3;
    w->Is = 10e-16;
    
    w->a = 2.0*w->RL/w->R;
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   2898c:	f241 34b1 	movw	r4, #5041	; 0x13b1
{
   28990:	b08f      	sub	sp, #60	; 0x3c
    w->half_a = 0.5 * w->a;
    w->longthing = (0.5*w->VT/w->b);
    
    
    // Antialiasing error threshold
    w->AAthresh = 10e-10; //10
   28992:	f24d 6295 	movw	r2, #54933	; 0xd695
   28996:	f642 630b 	movw	r3, #11787	; 0x2e0b
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   2899a:	f2cb 143b 	movt	r4, #45371	; 0xb13b
    _tMempool* m = *mp;
   2899e:	6809      	ldr	r1, [r1, #0]
    w->AAthresh = 10e-10; //10
   289a0:	f6ce 0226 	movt	r2, #59430	; 0xe826
   289a4:	f6c3 6311 	movt	r3, #15889	; 0x3e11
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   289a8:	9400      	str	r4, [sp, #0]
    w->longthing = (0.5*w->VT/w->b);
   289aa:	f243 34a4 	movw	r4, #13220	; 0x33a4
{
   289ae:	900a      	str	r0, [sp, #40]	; 0x28
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   289b0:	20e0      	movs	r0, #224	; 0xe0
    w->longthing = (0.5*w->VT/w->b);
   289b2:	f2cf 2430 	movt	r4, #62000	; 0xf230
    _tMempool* m = *mp;
   289b6:	460d      	mov	r5, r1
    w->Is = 10e-16;
   289b8:	f245 6616 	movw	r6, #22038	; 0x5616
   289bc:	f240 37af 	movw	r7, #943	; 0x3af
    w->longthing = (0.5*w->VT/w->b);
   289c0:	9402      	str	r4, [sp, #8]
    w->RL = 7.5e3;
   289c2:	2400      	movs	r4, #0
    w->Is = 10e-16;
   289c4:	f6c9 66e7 	movt	r6, #40679	; 0x9ee7
   289c8:	f6c3 47d2 	movt	r7, #15570	; 0x3cd2
    w->RL = 7.5e3;
   289cc:	9404      	str	r4, [sp, #16]
    w->VT = 26e-3;
   289ce:	f24b 4a39 	movw	sl, #46137	; 0xb439
    w->R = 15e3;
   289d2:	9406      	str	r4, [sp, #24]
    w->Ln1 = 0.0;
   289d4:	2400      	movs	r4, #0
    w->d = (w->RL*w->Is)/w->VT;
   289d6:	f64b 4884 	movw	r8, #48260	; 0xbc84
    w->VT = 26e-3;
   289da:	f649 7bbe 	movw	fp, #40894	; 0x9fbe
    w->Ln1 = 0.0;
   289de:	9408      	str	r4, [sp, #32]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   289e0:	f643 3413 	movw	r4, #15123	; 0x3b13
    w->d = (w->RL*w->Is)/w->VT;
   289e4:	f24d 29ab 	movw	r9, #53931	; 0xd2ab
    w->VT = 26e-3;
   289e8:	f2c7 6ac8 	movt	sl, #30408	; 0x76c8
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   289ec:	f2c4 0453 	movt	r4, #16467	; 0x4053
    w->d = (w->RL*w->Is)/w->VT;
   289f0:	f2c4 68f1 	movt	r8, #18161	; 0x46f1
    w->VT = 26e-3;
   289f4:	f6c3 7b9a 	movt	fp, #16282	; 0x3f9a
    w->d = (w->RL*w->Is)/w->VT;
   289f8:	f6c3 59f3 	movt	r9, #15859	; 0x3df3
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   289fc:	9401      	str	r4, [sp, #4]
    w->longthing = (0.5*w->VT/w->b);
   289fe:	f242 64b2 	movw	r4, #9906	; 0x26b2
    w->AAthresh = 10e-10; //10
   28a02:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    w->RL = 7.5e3;
   28a06:	f44f 4398 	mov.w	r3, #19456	; 0x4c00
    w->longthing = (0.5*w->VT/w->b);
   28a0a:	f6c3 7426 	movt	r4, #16166	; 0x3f26
    w->RL = 7.5e3;
   28a0e:	f2c4 03bd 	movt	r3, #16573	; 0x40bd
    w->longthing = (0.5*w->VT/w->b);
   28a12:	9403      	str	r4, [sp, #12]
    w->RL = 7.5e3;
   28a14:	9305      	str	r3, [sp, #20]
    w->R = 15e3;
   28a16:	f44f 4398 	mov.w	r3, #19456	; 0x4c00
   28a1a:	f2c4 03cd 	movt	r3, #16589	; 0x40cd
   28a1e:	9307      	str	r3, [sp, #28]
    w->Ln1 = 0.0;
   28a20:	2300      	movs	r3, #0
   28a22:	9309      	str	r3, [sp, #36]	; 0x24
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   28a24:	f004 fbf4 	bl	2d210 <mpool_alloc>
   28a28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   28a2a:	4684      	mov	ip, r0
    w->a = 2.0*w->RL/w->R;
   28a2c:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    w->Is = 10e-16;
   28a30:	4639      	mov	r1, r7
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   28a32:	6018      	str	r0, [r3, #0]
    w->half_a = 0.5 * w->a;
   28a34:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    w->mempool = m;
   28a38:	f8cc 5000 	str.w	r5, [ip]
    w->Is = 10e-16;
   28a3c:	4630      	mov	r0, r6
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   28a3e:	ed9d 5b00 	vldr	d5, [sp]
    w->AAthresh = 10e-10; //10
   28a42:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    w->R = 15e3;
   28a46:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   28a4a:	ed8d 5b0a 	vstr	d5, [sp, #40]	; 0x28
    w->RL = 7.5e3;
   28a4e:	ed9d 5b04 	vldr	d5, [sp, #16]
    w->AAthresh = 10e-10; //10
   28a52:	4614      	mov	r4, r2
   28a54:	461d      	mov	r5, r3
    w->RL = 7.5e3;
   28a56:	ed8d 5b00 	vstr	d5, [sp]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   28a5a:	ed9d 5b0a 	vldr	d5, [sp, #40]	; 0x28
    w->Ln1 = 0.0;
   28a5e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    w->VT = 26e-3;
   28a62:	e9cc ab0c 	strd	sl, fp, [ip, #48]	; 0x30
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   28a66:	ed8c 5b12 	vstr	d5, [ip, #72]	; 0x48
    w->longthing = (0.5*w->VT/w->b);
   28a6a:	ed9d 5b02 	vldr	d5, [sp, #8]
    w->Is = 10e-16;
   28a6e:	e9cc 010e 	strd	r0, r1, [ip, #56]	; 0x38
    w->d = (w->RL*w->Is)/w->VT;
   28a72:	e9cc 8914 	strd	r8, r9, [ip, #80]	; 0x50
    w->longthing = (0.5*w->VT/w->b);
   28a76:	ed8c 5b1a 	vstr	d5, [ip, #104]	; 0x68
    w->RL = 7.5e3;
   28a7a:	ed9d 5b00 	vldr	d5, [sp]
    w->AAthresh = 10e-10; //10
   28a7e:	e9cc 4516 	strd	r4, r5, [ip, #88]	; 0x58

	w->LambertThresh = 10e-10; //12  //was 8
   28a82:	e9cc 451c 	strd	r4, r5, [ip, #112]	; 0x70
    w->RL = 7.5e3;
   28a86:	ed8c 5b08 	vstr	d5, [ip, #32]
    w->R = 15e3;
   28a8a:	e9cc 670a 	strd	r6, r7, [ip, #40]	; 0x28
    w->Ln1 = 0.0;
   28a8e:	e9cc 2302 	strd	r2, r3, [ip, #8]
    w->Fn1 = 0.0;
   28a92:	e9cc 2304 	strd	r2, r3, [ip, #16]
    w->xn1 = 0.0;
   28a96:	e9cc 2306 	strd	r2, r3, [ip, #24]


    w->w = 0.0f;
   28a9a:	e9cc 231e 	strd	r2, r3, [ip, #120]	; 0x78
    w->expw = 0.0f;
   28a9e:	e9cc 2320 	strd	r2, r3, [ip, #128]	; 0x80
    w->p = 0.0f;
   28aa2:	e9cc 2322 	strd	r2, r3, [ip, #136]	; 0x88
    w->r = 0.0f;
   28aa6:	e9cc 2324 	strd	r2, r3, [ip, #144]	; 0x90
    w->s= 0.0f;
   28aaa:	e9cc 2326 	strd	r2, r3, [ip, #152]	; 0x98
    w->myerr = 0.0f;
   28aae:	e9cc 2328 	strd	r2, r3, [ip, #160]	; 0xa0
    w->l = 0.0f;
   28ab2:	e9cc 232a 	strd	r2, r3, [ip, #168]	; 0xa8
    w->u = 0.0f;
   28ab6:	e9cc 232c 	strd	r2, r3, [ip, #176]	; 0xb0
    w->Ln = 0.0f;
   28aba:	e9cc 232e 	strd	r2, r3, [ip, #184]	; 0xb8
	w->Fn = 0.0f;
   28abe:	e9cc 2330 	strd	r2, r3, [ip, #192]	; 0xc0
    w->tempsDenom = 0.0f;
   28ac2:	e9cc 2332 	strd	r2, r3, [ip, #200]	; 0xc8
    w->tempErrDenom = 0.0f;
   28ac6:	e9cc 2334 	strd	r2, r3, [ip, #208]	; 0xd0
    w->tempOutDenom = 0.0f;
   28aca:	e9cc 2336 	strd	r2, r3, [ip, #216]	; 0xd8
    w->a = 2.0*w->RL/w->R;
   28ace:	ed8c 6b10 	vstr	d6, [ip, #64]	; 0x40
    w->half_a = 0.5 * w->a;
   28ad2:	ed8c 7b18 	vstr	d7, [ip, #96]	; 0x60


}
   28ad6:	b00f      	add	sp, #60	; 0x3c
   28ad8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00028adc <tLockhartWavefolder_free>:

void tLockhartWavefolder_free (tLockhartWavefolder* const wf)
{
    _tLockhartWavefolder* w = *wf;
   28adc:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)w, w->mempool);
   28ade:	6801      	ldr	r1, [r0, #0]
   28ae0:	f004 bc40 	b.w	2d364 <mpool_free>

00028ae4 <tLockhartWavefolder_tick>:
    _tLockhartWavefolder* w = *wf;

    float out = 0.0f;
    
    // Compute Antiderivative
    w->l = (in > 0.0) - (in < 0.0);
   28ae4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   28ae8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    w->l = (in > 0.0) - (in < 0.0);
   28aea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    _tLockhartWavefolder* w = *wf;
   28aee:	6806      	ldr	r6, [r0, #0]
{
   28af0:	4607      	mov	r7, r0
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   28af2:	f640 34b8 	movw	r4, #3000	; 0xbb8
{
   28af6:	ed2d 8b0e 	vpush	{d8-d14}
    w->l = (in > 0.0) - (in < 0.0);
   28afa:	bfc8      	it	gt
   28afc:	2301      	movgt	r3, #1
    w->u = w->d*exp(w->l*w->b*in);
   28afe:	eeb7 eac0 	vcvt.f64.f32	d14, s0
    w->l = (in > 0.0) - (in < 0.0);
   28b02:	bfd8      	it	le
   28b04:	2300      	movle	r3, #0
   28b06:	bf4c      	ite	mi
   28b08:	2201      	movmi	r2, #1
   28b0a:	2200      	movpl	r2, #0
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   28b0c:	eeb7 bb00 	vmov.f64	d11, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   28b10:	eeb0 9b00 	vmov.f64	d9, #0	; 0x40000000  2.0
    w->l = (in > 0.0) - (in < 0.0);
   28b14:	1a9b      	subs	r3, r3, r2
    w->u = w->d*exp(w->l*w->b*in);
   28b16:	ed96 0b12 	vldr	d0, [r6, #72]	; 0x48
    w->l = (in > 0.0) - (in < 0.0);
   28b1a:	ee07 3a90 	vmov	s15, r3
    w->u = w->d*exp(w->l*w->b*in);
   28b1e:	ee2e 0b00 	vmul.f64	d0, d14, d0
    w->l = (in > 0.0) - (in < 0.0);
   28b22:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   28b26:	ed86 7b2a 	vstr	d7, [r6, #168]	; 0xa8
    w->u = w->d*exp(w->l*w->b*in);
   28b2a:	ee20 0b07 	vmul.f64	d0, d0, d7
   28b2e:	f007 ffcf 	bl	30ad0 <exp>
   28b32:	ed96 cb14 	vldr	d12, [r6, #80]	; 0x50
    	w->u = 10e-5;
    	LEAF_error();
    }
    */

    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   28b36:	ed96 8b02 	vldr	d8, [r6, #8]
    w->u = w->d*exp(w->l*w->b*in);
   28b3a:	ee20 cb0c 	vmul.f64	d12, d0, d12
   28b3e:	ed86 cb2c 	vstr	d12, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
   28b42:	683d      	ldr	r5, [r7, #0]
   28b44:	eeb1 cb4c 	vneg.f64	d12, d12
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   28b48:	ed95 db1c 	vldr	d13, [r5, #112]	; 0x70
	mwf->w = ln;
   28b4c:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
   28b50:	e006      	b.n	28b60 <tLockhartWavefolder_tick+0x7c>
        mwf->w = mwf->w - mwf->myerr;
   28b52:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
   28b56:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
   28b58:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
   28b5c:	f000 80c9 	beq.w	28cf2 <tLockhartWavefolder_tick+0x20e>
    	mwf->expw = exp(mwf->w);
   28b60:	eeb0 0b48 	vmov.f64	d0, d8
   28b64:	f007 ffb4 	bl	30ad0 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   28b68:	ee38 7b0b 	vadd.f64	d7, d8, d11
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   28b6c:	ee38 4b09 	vadd.f64	d4, d8, d9
    	mwf->p = mwf->w*mwf->expw - x;
   28b70:	eeb0 6b4c 	vmov.f64	d6, d12
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
   28b74:	ee37 1b07 	vadd.f64	d1, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   28b78:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   28b7c:	ee84 2b01 	vdiv.f64	d2, d4, d1
    	mwf->p = mwf->w*mwf->expw - x;
   28b80:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
   28b84:	eeb0 3b47 	vmov.f64	d3, d7
   28b88:	eea6 3b42 	vfms.f64	d3, d6, d2
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
   28b8c:	ee86 5b03 	vdiv.f64	d5, d6, d3
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   28b90:	eeb0 abc5 	vabs.f64	d10, d5
   28b94:	eeb4 abcd 	vcmpe.f64	d10, d13
   28b98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28b9c:	d5d9      	bpl.n	28b52 <tLockhartWavefolder_tick+0x6e>
   28b9e:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   28ba2:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   28ba6:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   28baa:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
   28bae:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
   28bb2:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
   28bb6:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
	{
		w->Ln = 10e-5;
		LEAF_error();
	}
*/
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   28bba:	ee2e 5b0e 	vmul.f64	d5, d14, d14
   28bbe:	ee24 4b08 	vmul.f64	d4, d4, d8
   28bc2:	ed96 7b18 	vldr	d7, [r6, #96]	; 0x60
		LEAF_error();
	}
	*/
    // Check for ill-conditioning

    if (fabs(in-w->xn1)<w->AAthresh)
   28bc6:	ed96 db06 	vldr	d13, [r6, #24]
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   28bca:	ed96 6b1a 	vldr	d6, [r6, #104]	; 0x68
   28bce:	ee27 5b45 	vnmul.f64	d5, d7, d5
    if (fabs(in-w->xn1)<w->AAthresh)
   28bd2:	ee3e 3b4d 	vsub.f64	d3, d14, d13
   28bd6:	ed96 7b16 	vldr	d7, [r6, #88]	; 0x58
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   28bda:	eea6 5b04 	vfma.f64	d5, d6, d4
    if (fabs(in-w->xn1)<w->AAthresh)
   28bde:	eeb0 6bc3 	vabs.f64	d6, d3
    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   28be2:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
    if (fabs(in-w->xn1)<w->AAthresh)
   28be6:	eeb4 6bc7 	vcmpe.f64	d6, d7
   28bea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   28bee:	ed86 5b30 	vstr	d5, [r6, #192]	; 0xc0
    if (fabs(in-w->xn1)<w->AAthresh)
   28bf2:	d412      	bmi.n	28c1a <tLockhartWavefolder_tick+0x136>
    	{
    		w->tempOutDenom = 10e-5;
    		LEAF_error();
    	}
    	*/
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
   28bf4:	ed96 7b04 	vldr	d7, [r6, #16]
    	w->tempOutDenom = (in-w->xn1);
   28bf8:	ed86 3b36 	vstr	d3, [r6, #216]	; 0xd8
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
   28bfc:	ee35 7b47 	vsub.f64	d7, d5, d7
   28c00:	ee87 0b03 	vdiv.f64	d0, d7, d3
   28c04:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
		*/

    }

    // Update States
    w->Ln1 = w->Ln;
   28c08:	ed86 8b02 	vstr	d8, [r6, #8]
    w->Fn1 = w->Fn;
   28c0c:	ed86 5b04 	vstr	d5, [r6, #16]
    w->xn1 = (double)in;
   28c10:	ed86 eb06 	vstr	d14, [r6, #24]
    
    return out;
}
   28c14:	ecbd 8b0e 	vpop	{d8-d14}
   28c18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    	double xn = 0.5*(in+w->xn1);
   28c1a:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   28c1e:	f640 34b8 	movw	r4, #3000	; 0xbb8
    	double xn = 0.5*(in+w->xn1);
   28c22:	ee3e db0d 	vadd.f64	d13, d14, d13
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   28c26:	eeb7 9b00 	vmov.f64	d9, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   28c2a:	eeb0 ab00 	vmov.f64	d10, #0	; 0x40000000  2.0
    	double xn = 0.5*(in+w->xn1);
   28c2e:	ee2d db07 	vmul.f64	d13, d13, d7
    	w->u = w->d*exp(w->l*w->b*xn);
   28c32:	ed96 0b2a 	vldr	d0, [r6, #168]	; 0xa8
   28c36:	ed96 7b12 	vldr	d7, [r6, #72]	; 0x48
   28c3a:	ee20 0b07 	vmul.f64	d0, d0, d7
   28c3e:	ee20 0b0d 	vmul.f64	d0, d0, d13
   28c42:	f007 ff45 	bl	30ad0 <exp>
   28c46:	ed96 bb14 	vldr	d11, [r6, #80]	; 0x50
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   28c4a:	ed96 8b02 	vldr	d8, [r6, #8]
    	w->u = w->d*exp(w->l*w->b*xn);
   28c4e:	ee20 bb0b 	vmul.f64	d11, d0, d11
   28c52:	ed86 bb2c 	vstr	d11, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
   28c56:	683d      	ldr	r5, [r7, #0]
   28c58:	eeb1 bb4b 	vneg.f64	d11, d11
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   28c5c:	ed95 cb1c 	vldr	d12, [r5, #112]	; 0x70
	mwf->w = ln;
   28c60:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
   28c64:	e005      	b.n	28c72 <tLockhartWavefolder_tick+0x18e>
        mwf->w = mwf->w - mwf->myerr;
   28c66:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
   28c6a:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
   28c6c:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
   28c70:	d01e      	beq.n	28cb0 <tLockhartWavefolder_tick+0x1cc>
    	mwf->expw = exp(mwf->w);
   28c72:	eeb0 0b48 	vmov.f64	d0, d8
   28c76:	f007 ff2b 	bl	30ad0 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   28c7a:	ee38 7b09 	vadd.f64	d7, d8, d9
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   28c7e:	ee38 5b0a 	vadd.f64	d5, d8, d10
    	mwf->p = mwf->w*mwf->expw - x;
   28c82:	eeb0 6b4b 	vmov.f64	d6, d11
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
   28c86:	ee37 2b07 	vadd.f64	d2, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   28c8a:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   28c8e:	ee85 3b02 	vdiv.f64	d3, d5, d2
    	mwf->p = mwf->w*mwf->expw - x;
   28c92:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
   28c96:	eeb0 4b47 	vmov.f64	d4, d7
   28c9a:	eea6 4b43 	vfms.f64	d4, d6, d3
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
   28c9e:	ee86 5b04 	vdiv.f64	d5, d6, d4
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   28ca2:	eeb0 1bc5 	vabs.f64	d1, d5
   28ca6:	eeb4 1bcc 	vcmpe.f64	d1, d12
   28caa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28cae:	d5da      	bpl.n	28c66 <tLockhartWavefolder_tick+0x182>
   28cb0:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   28cb4:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   28cb8:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   28cbc:	ed85 2b32 	vstr	d2, [r5, #200]	; 0xc8
   28cc0:	ed85 3b26 	vstr	d3, [r5, #152]	; 0x98
   28cc4:	ed85 4b34 	vstr	d4, [r5, #208]	; 0xd0
   28cc8:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
   28ccc:	ed96 5b10 	vldr	d5, [r6, #64]	; 0x40
   28cd0:	ed96 7b2a 	vldr	d7, [r6, #168]	; 0xa8
   28cd4:	ed96 6b0c 	vldr	d6, [r6, #48]	; 0x30
   28cd8:	ee25 db4d 	vnmul.f64	d13, d5, d13
   28cdc:	ee27 7b06 	vmul.f64	d7, d7, d6
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   28ce0:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
   28ce4:	ed96 5b30 	vldr	d5, [r6, #192]	; 0xc0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
   28ce8:	eea7 db08 	vfma.f64	d13, d7, d8
   28cec:	eeb7 0bcd 	vcvt.f32.f64	s0, d13
   28cf0:	e78a      	b.n	28c08 <tLockhartWavefolder_tick+0x124>
   28cf2:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   28cf6:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   28cfa:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   28cfe:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
   28d02:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
   28d06:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
   28d0a:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
   28d0e:	ee38 4b09 	vadd.f64	d4, d8, d9
   28d12:	e752      	b.n	28bba <tLockhartWavefolder_tick+0xd6>

00028d14 <tCrusher_initToPool>:
{
    tCrusher_initToPool(cr, &leaf.mempool);
}

void tCrusher_initToPool (tCrusher* const cr, tMempool* const mp)
{
   28d14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   28d16:	680e      	ldr	r6, [r1, #0]
{
   28d18:	460d      	mov	r5, r1
   28d1a:	4607      	mov	r7, r0
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   28d1c:	2020      	movs	r0, #32
   28d1e:	4631      	mov	r1, r6
   28d20:	f004 fa76 	bl	2d210 <mpool_alloc>
    c->mempool = m;
    
    c->op = 4;
    c->div = SCALAR;
   28d24:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   28d28:	4604      	mov	r4, r0
    c->rnd = 0.25f;
   28d2a:	f04f 527a 	mov.w	r2, #1048576000	; 0x3e800000
    c->div = SCALAR;
   28d2e:	f2c4 539c 	movt	r3, #17820	; 0x459c
    c->op = 4;
   28d32:	2104      	movs	r1, #4
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   28d34:	6038      	str	r0, [r7, #0]
    c->mempool = m;
   28d36:	6006      	str	r6, [r0, #0]
    s->invRatio = 1.0f;
   28d38:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
    c->op = 4;
   28d3c:	6141      	str	r1, [r0, #20]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   28d3e:	2010      	movs	r0, #16
    c->rnd = 0.25f;
   28d40:	6122      	str	r2, [r4, #16]
    c->srr = 0.25f;
   28d42:	6062      	str	r2, [r4, #4]
    c->div = SCALAR;
   28d44:	60e3      	str	r3, [r4, #12]
    _tMempool* m = *mp;
   28d46:	682d      	ldr	r5, [r5, #0]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   28d48:	4629      	mov	r1, r5
   28d4a:	f004 fa61 	bl	2d210 <mpool_alloc>
    tSampleReducer_initToPool(&c->sReducer, mp);
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28d4e:	f64c 42f6 	movw	r2, #52470	; 0xccf6
   28d52:	f649 139a 	movw	r3, #39322	; 0x999a
    s->hold = 0.0f;
   28d56:	2100      	movs	r1, #0
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28d58:	f6c3 1212 	movt	r2, #14610	; 0x3912
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   28d5c:	61e0      	str	r0, [r4, #28]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28d5e:	f6c3 6399 	movt	r3, #16025	; 0x3e99
    s->mempool = m;
   28d62:	6005      	str	r5, [r0, #0]
    s->invRatio = 1.0f;
   28d64:	6046      	str	r6, [r0, #4]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28d66:	ee07 2a10 	vmov	s14, r2
    s->hold = 0.0f;
   28d6a:	6081      	str	r1, [r0, #8]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28d6c:	ee07 3a90 	vmov	s15, r3
    s->count = 0;
   28d70:	60c1      	str	r1, [r0, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28d72:	edd4 6a03 	vldr	s13, [r4, #12]
   28d76:	eee6 7a87 	vfma.f32	s15, s13, s14
   28d7a:	edc4 7a06 	vstr	s15, [r4, #24]
}
   28d7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00028d80 <tCrusher_free>:

void tCrusher_free (tCrusher* const cr)
{
   28d80:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
   28d82:	6804      	ldr	r4, [r0, #0]
    _tSampleReducer* s = *sr;
   28d84:	69e0      	ldr	r0, [r4, #28]
    mpool_free((char*)s, s->mempool);
   28d86:	6801      	ldr	r1, [r0, #0]
   28d88:	f004 faec 	bl	2d364 <mpool_free>
    
    tSampleReducer_free(&c->sReducer);
    mpool_free((char*)c, c->mempool);
   28d8c:	6821      	ldr	r1, [r4, #0]
   28d8e:	4620      	mov	r0, r4
}
   28d90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)c, c->mempool);
   28d94:	f004 bae6 	b.w	2d364 <mpool_free>

00028d98 <tCrusher_tick>:
{
    _tCrusher* c = *cr;
    
    float sample = input;
    
    sample *= SCALAR; // SCALAR is 5000 by default
   28d98:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   28d9c:	f2c4 539c 	movt	r3, #17820	; 0x459c
   28da0:	ee07 3a90 	vmov	s15, r3
   28da4:	ee20 0a27 	vmul.f32	s0, s0, s15
{
   28da8:	b510      	push	{r4, lr}
    
    sample = (int32_t) sample;
   28daa:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tCrusher* c = *cr;
   28dae:	6804      	ldr	r4, [r0, #0]
    
    sample /= c->div;
   28db0:	ed94 7a03 	vldr	s14, [r4, #12]
    sample = (int32_t) sample;
   28db4:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    
    sample = LEAF_bitwise_xor(sample, c->op << 23);
   28db8:	6960      	ldr	r0, [r4, #20]
   28dba:	05c0      	lsls	r0, r0, #23
   28dbc:	ee80 0a07 	vdiv.f32	s0, s0, s14
   28dc0:	f004 f808 	bl	2cdd4 <LEAF_bitwise_xor>
    
    sample = LEAF_clip(-1.f, sample, 1.f);
   28dc4:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   28dc8:	eef0 0a40 	vmov.f32	s1, s0
   28dcc:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   28dd0:	f004 f806 	bl	2cde0 <LEAF_clip>
    
    sample = LEAF_round(sample, c->rnd);
   28dd4:	edd4 0a04 	vldr	s1, [r4, #16]
   28dd8:	f003 ffe8 	bl	2cdac <LEAF_round>
    _tSampleReducer* s = *sr;
   28ddc:	69e3      	ldr	r3, [r4, #28]
    if (s->count > s->invRatio)
   28dde:	68da      	ldr	r2, [r3, #12]
   28de0:	edd3 7a01 	vldr	s15, [r3, #4]
   28de4:	ee07 2a10 	vmov	s14, r2
   28de8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   28dec:	eeb4 7ae7 	vcmpe.f32	s14, s15
   28df0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28df4:	dd08      	ble.n	28e08 <tCrusher_tick+0x70>
        s->hold = input;
   28df6:	2201      	movs	r2, #1
   28df8:	ed83 0a02 	vstr	s0, [r3, #8]
    s->count++;
   28dfc:	60da      	str	r2, [r3, #12]
    
    sample = tSampleReducer_tick(&c->sReducer, sample);
    
    return sample * c->gain;
   28dfe:	edd4 7a06 	vldr	s15, [r4, #24]
    
}
   28e02:	ee20 0a27 	vmul.f32	s0, s0, s15
   28e06:	bd10      	pop	{r4, pc}
   28e08:	3201      	adds	r2, #1
   28e0a:	ed93 0a02 	vldr	s0, [r3, #8]
    s->count++;
   28e0e:	60da      	str	r2, [r3, #12]
    return sample * c->gain;
   28e10:	edd4 7a06 	vldr	s15, [r4, #24]
}
   28e14:	ee20 0a27 	vmul.f32	s0, s0, s15
   28e18:	bd10      	pop	{r4, pc}
   28e1a:	bf00      	nop

00028e1c <tCrusher_setOperation>:

void    tCrusher_setOperation (tCrusher* const cr, float op)
{
    _tCrusher* c = *cr;
    c->op = (uint32_t) (op * 8.0f);
   28e1c:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    _tCrusher* c = *cr;
   28e20:	6803      	ldr	r3, [r0, #0]
    c->op = (uint32_t) (op * 8.0f);
   28e22:	ee20 0a27 	vmul.f32	s0, s0, s15
   28e26:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   28e2a:	ed83 0a05 	vstr	s0, [r3, #20]
}
   28e2e:	4770      	bx	lr

00028e30 <tCrusher_setQuality>:
// 0.0 - 1.0
void    tCrusher_setQuality (tCrusher* const cr, float val)
{
    _tCrusher* c = *cr;
    
    val = LEAF_clip(0.0f, val, 1.0f);
   28e30:	2300      	movs	r3, #0
   28e32:	eef0 0a40 	vmov.f32	s1, s0
   28e36:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   28e3a:	ee00 3a10 	vmov	s0, r3
{
   28e3e:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
   28e40:	6804      	ldr	r4, [r0, #0]
    val = LEAF_clip(0.0f, val, 1.0f);
   28e42:	f003 ffcd 	bl	2cde0 <LEAF_clip>
    
    c->div = 0.01f + val * SCALAR;
   28e46:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   28e4a:	f24d 730a 	movw	r3, #55050	; 0xd70a
    
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28e4e:	f64c 41f6 	movw	r1, #52470	; 0xccf6
   28e52:	f649 129a 	movw	r2, #39322	; 0x999a
    c->div = 0.01f + val * SCALAR;
   28e56:	f2c4 509c 	movt	r0, #17820	; 0x459c
   28e5a:	f6c3 4323 	movt	r3, #15395	; 0x3c23
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28e5e:	f6c3 1112 	movt	r1, #14610	; 0x3912
   28e62:	f6c3 6299 	movt	r2, #16025	; 0x3e99
    c->div = 0.01f + val * SCALAR;
   28e66:	ee06 0a10 	vmov	s12, r0
   28e6a:	ee07 3a90 	vmov	s15, r3
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28e6e:	ee06 1a90 	vmov	s13, r1
   28e72:	ee07 2a10 	vmov	s14, r2
    c->div = 0.01f + val * SCALAR;
   28e76:	eee0 7a06 	vfma.f32	s15, s0, s12
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28e7a:	eea7 7aa6 	vfma.f32	s14, s15, s13
    c->div = 0.01f + val * SCALAR;
   28e7e:	edc4 7a03 	vstr	s15, [r4, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   28e82:	ed84 7a06 	vstr	s14, [r4, #24]
}
   28e86:	bd10      	pop	{r4, pc}

00028e88 <tCrusher_setRound>:

// what decimal to round to
void    tCrusher_setRound (tCrusher* const cr, float rnd)
{
    _tCrusher* c = *cr;
    c->rnd = fabsf(rnd);
   28e88:	eeb0 0ac0 	vabs.f32	s0, s0
    _tCrusher* c = *cr;
   28e8c:	6803      	ldr	r3, [r0, #0]
    c->rnd = fabsf(rnd);
   28e8e:	ed83 0a04 	vstr	s0, [r3, #16]
}
   28e92:	4770      	bx	lr

00028e94 <tCrusher_setSamplingRatio>:
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
   28e94:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

void    tCrusher_setSamplingRatio (tCrusher* const cr, float ratio)
{
    _tCrusher* c = *cr;
   28e98:	6803      	ldr	r3, [r0, #0]
    c->srr = ratio;
   28e9a:	ed83 0a01 	vstr	s0, [r3, #4]
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
   28e9e:	eeb4 0a67 	vcmp.f32	s0, s15
   28ea2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28ea6:	d809      	bhi.n	28ebc <tCrusher_setSamplingRatio+0x28>
   28ea8:	eeb5 0a40 	vcmp.f32	s0, #0.0
   28eac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28eb0:	db04      	blt.n	28ebc <tCrusher_setSamplingRatio+0x28>
        s->invRatio = 1.0f / ratio;
   28eb2:	ee87 7a80 	vdiv.f32	s14, s15, s0
    _tSampleReducer* s = *sr;
   28eb6:	69db      	ldr	r3, [r3, #28]
        s->invRatio = 1.0f / ratio;
   28eb8:	ed83 7a01 	vstr	s14, [r3, #4]
    tSampleReducer_setRatio(&c->sReducer, ratio);

}
   28ebc:	4770      	bx	lr
   28ebe:	bf00      	nop

00028ec0 <tFeedbackLeveler_init>:
}

/* Feedback Leveler */

void tFeedbackLeveler_init (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode)
{
   28ec0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tFeedbackLeveler_initToPool(fb, targetLevel, factor, strength, mode, &leaf.mempool);
}

void tFeedbackLeveler_initToPool (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode, tMempool* const mp)
{
    _tMempool* m = *mp;
   28ec4:	f64f 0508 	movw	r5, #63496	; 0xf808
{
   28ec8:	4680      	mov	r8, r0
   28eca:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28ecc:	2018      	movs	r0, #24
    _tMempool* m = *mp;
   28ece:	f2c0 250f 	movt	r5, #527	; 0x20f
   28ed2:	f855 6f18 	ldr.w	r6, [r5, #24]!
{
   28ed6:	ed2d 8b04 	vpush	{d8-d9}
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28eda:	4631      	mov	r1, r6
{
   28edc:	eef0 8a40 	vmov.f32	s17, s0
   28ee0:	eeb0 9a60 	vmov.f32	s18, s1
   28ee4:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28ee8:	f004 f992 	bl	2d210 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
   28eec:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28eee:	4604      	mov	r4, r0
   28ef0:	f8c8 0000 	str.w	r0, [r8]
    p->targetLevel=targetLevel;
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28ef4:	eeb0 0a49 	vmov.f32	s0, s18
    p->targetLevel=targetLevel;
   28ef8:	edc0 8a01 	vstr	s17, [r0, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28efc:	4629      	mov	r1, r5
    p->mempool = m;
   28efe:	6006      	str	r6, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28f00:	3014      	adds	r0, #20
    p->curr=0.0f;
   28f02:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28f04:	f7fe fc46 	bl	27794 <tPowerFollower_initToPool>
    p->mode=mode;
   28f08:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
   28f0a:	ed84 8a02 	vstr	s16, [r4, #8]
}
   28f0e:	ecbd 8b04 	vpop	{d8-d9}
   28f12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   28f16:	bf00      	nop

00028f18 <tFeedbackLeveler_initToPool>:
{
   28f18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
   28f1c:	6815      	ldr	r5, [r2, #0]
{
   28f1e:	4680      	mov	r8, r0
   28f20:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28f22:	2018      	movs	r0, #24
   28f24:	4629      	mov	r1, r5
{
   28f26:	4616      	mov	r6, r2
   28f28:	ed2d 8b04 	vpush	{d8-d9}
   28f2c:	eef0 8a40 	vmov.f32	s17, s0
   28f30:	eeb0 9a60 	vmov.f32	s18, s1
   28f34:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28f38:	f004 f96a 	bl	2d210 <mpool_alloc>
    p->curr=0.0f;
   28f3c:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   28f3e:	4604      	mov	r4, r0
   28f40:	f8c8 0000 	str.w	r0, [r8]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28f44:	eeb0 0a49 	vmov.f32	s0, s18
    p->targetLevel=targetLevel;
   28f48:	edc0 8a01 	vstr	s17, [r0, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28f4c:	4631      	mov	r1, r6
    p->mempool = m;
   28f4e:	6005      	str	r5, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28f50:	3014      	adds	r0, #20
    p->curr=0.0f;
   28f52:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   28f54:	f7fe fc1e 	bl	27794 <tPowerFollower_initToPool>
    p->mode=mode;
   28f58:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
   28f5a:	ed84 8a02 	vstr	s16, [r4, #8]
}
   28f5e:	ecbd 8b04 	vpop	{d8-d9}
   28f62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   28f66:	bf00      	nop

00028f68 <tFeedbackLeveler_free>:

void tFeedbackLeveler_free (tFeedbackLeveler* const fb)
{
   28f68:	b510      	push	{r4, lr}
    _tFeedbackLeveler* p = *fb;
   28f6a:	6804      	ldr	r4, [r0, #0]
    
    tPowerFollower_free(&p->pwrFlw);
   28f6c:	f104 0014 	add.w	r0, r4, #20
   28f70:	f7fe fc2a 	bl	277c8 <tPowerFollower_free>
    mpool_free((char*)p, p->mempool);
   28f74:	6821      	ldr	r1, [r4, #0]
   28f76:	4620      	mov	r0, r4
}
   28f78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   28f7c:	f004 b9f2 	b.w	2d364 <mpool_free>

00028f80 <tFeedbackLeveler_setMode>:
    tPowerFollower_setFactor(&p->pwrFlw,factor);
}

void     tFeedbackLeveler_setMode(tFeedbackLeveler* const fb, int mode)
{    // 0 for decaying with upwards lev limiting, 1 for constrained absolute level (also downwards limiting)
    _tFeedbackLeveler* p = *fb;
   28f80:	6803      	ldr	r3, [r0, #0]
    p->mode=mode;
   28f82:	60d9      	str	r1, [r3, #12]
}
   28f84:	4770      	bx	lr
   28f86:	bf00      	nop

00028f88 <tFeedbackLeveler_tick>:

float   tFeedbackLeveler_tick(tFeedbackLeveler* const fb, float input)
{
   28f88:	b510      	push	{r4, lr}
   28f8a:	ed2d 8b02 	vpush	{d8}
    _tFeedbackLeveler* p = *fb;
   28f8e:	6804      	ldr	r4, [r0, #0]
{
   28f90:	eeb0 8a40 	vmov.f32	s16, s0
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
   28f94:	f104 0014 	add.w	r0, r4, #20
   28f98:	f7fe fc1a 	bl	277d0 <tPowerFollower_tick>
   28f9c:	edd4 7a01 	vldr	s15, [r4, #4]
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
   28fa0:	68e3      	ldr	r3, [r4, #12]
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
   28fa2:	ee70 7a67 	vsub.f32	s15, s0, s15
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
   28fa6:	b943      	cbnz	r3, 28fba <tFeedbackLeveler_tick+0x32>
   28fa8:	eef5 7a40 	vcmp.f32	s15, #0.0
   28fac:	ee07 3a10 	vmov	s14, r3
   28fb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28fb4:	bf48      	it	mi
   28fb6:	eef0 7a47 	vmovmi.f32	s15, s14
    p->curr=input*(1.0f-p->strength*levdiff);
   28fba:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   28fbe:	ed94 7a02 	vldr	s14, [r4, #8]
   28fc2:	eea7 0a67 	vfms.f32	s0, s14, s15
   28fc6:	ee20 0a08 	vmul.f32	s0, s0, s16
   28fca:	ed84 0a04 	vstr	s0, [r4, #16]
    return p->curr;
}
   28fce:	ecbd 8b02 	vpop	{d8}
   28fd2:	bd10      	pop	{r4, pc}

00028fd4 <tFeedbackLeveler_setTargetLevel>:
}


void     tFeedbackLeveler_setTargetLevel   (tFeedbackLeveler* const fb, float TargetLevel)
{
    _tFeedbackLeveler* p = *fb;
   28fd4:	6803      	ldr	r3, [r0, #0]
    p->targetLevel=TargetLevel;
   28fd6:	ed83 0a01 	vstr	s0, [r3, #4]
}
   28fda:	4770      	bx	lr

00028fdc <tTalkbox_lpcDurbin>:
    }

}

void tTalkbox_lpcDurbin(float *r, int p, float *k, float *g)
{
   28fdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i, j;
    float a[ORD_MAX], at[ORD_MAX], e=r[0];

    for(i=0; i<=p; i++)
   28fe0:	f1b1 0900 	subs.w	r9, r1, #0
{
   28fe4:	4615      	mov	r5, r2
   28fe6:	ed2d 8b04 	vpush	{d8-d9}
   28fea:	b0c7      	sub	sp, #284	; 0x11c
    float a[ORD_MAX], at[ORD_MAX], e=r[0];
   28fec:	edd0 8a00 	vldr	s17, [r0]
{
   28ff0:	9301      	str	r3, [sp, #4]
    for(i=0; i<=p; i++)
   28ff2:	f2c0 8087 	blt.w	29104 <tTalkbox_lpcDurbin+0x128>
    {
    	a[i] = 0.0f; //probably don't need to clear at[] or k[]
   28ff6:	f109 0201 	add.w	r2, r9, #1
   28ffa:	4604      	mov	r4, r0
   28ffc:	2100      	movs	r1, #0
   28ffe:	a802      	add	r0, sp, #8
   29000:	0092      	lsls	r2, r2, #2
   29002:	f007 f8d6 	bl	301b2 <memset>
    }
	k[0] = 0.0f;
   29006:	2300      	movs	r3, #0
    at[0] = 0.0f;
    for(i=1; i<=p; i++)
   29008:	4599      	cmp	r9, r3
	k[0] = 0.0f;
   2900a:	602b      	str	r3, [r5, #0]
    at[0] = 0.0f;
   2900c:	9324      	str	r3, [sp, #144]	; 0x90
    for(i=1; i<=p; i++)
   2900e:	dd54      	ble.n	290ba <tTalkbox_lpcDurbin+0xde>
        for(j=1; j<i; j++)
        {
            at[j] = a[j];
            k[i] -= a[j] * r[i-j];
        }
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   29010:	f24e 5308 	movw	r3, #58632	; 0xe508
   29014:	1d26      	adds	r6, r4, #4
   29016:	f06f 0a07 	mvn.w	sl, #7
   2901a:	3504      	adds	r5, #4
   2901c:	f6c1 633c 	movt	r3, #7740	; 0x1e3c
   29020:	f10d 0808 	add.w	r8, sp, #8
   29024:	ebaa 0a04 	sub.w	sl, sl, r4
    for(i=1; i<=p; i++)
   29028:	2701      	movs	r7, #1
   2902a:	4634      	mov	r4, r6
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   2902c:	ee09 3a90 	vmov	s19, r3
        k[i] = -r[i];
   29030:	ed94 8a00 	vldr	s16, [r4]
        for(j=1; j<i; j++)
   29034:	2f01      	cmp	r7, #1
   29036:	f104 0b04 	add.w	fp, r4, #4
   2903a:	eeb0 9ae8 	vabs.f32	s18, s17
        k[i] = -r[i];
   2903e:	eeb1 8a48 	vneg.f32	s16, s16
   29042:	eca5 8a01 	vstmia	r5!, {s16}
        for(j=1; j<i; j++)
   29046:	d051      	beq.n	290ec <tTalkbox_lpcDurbin+0x110>
   29048:	ab25      	add	r3, sp, #148	; 0x94
   2904a:	eb0a 020b 	add.w	r2, sl, fp
   2904e:	a903      	add	r1, sp, #12
   29050:	4618      	mov	r0, r3
   29052:	f007 f8a3 	bl	3019c <memcpy>
   29056:	a903      	add	r1, sp, #12
   29058:	4603      	mov	r3, r0
   2905a:	460a      	mov	r2, r1
            k[i] -= a[j] * r[i-j];
   2905c:	ed74 7a01 	vldmdb	r4!, {s15}
            at[j] = a[j];
   29060:	ecb2 7a01 	vldmia	r2!, {s14}
        for(j=1; j<i; j++)
   29064:	42a6      	cmp	r6, r4
            k[i] -= a[j] * r[i-j];
   29066:	eea7 8a67 	vfms.f32	s16, s14, s15
   2906a:	ed05 8a01 	vstr	s16, [r5, #-4]
        for(j=1; j<i; j++)
   2906e:	d1f5      	bne.n	2905c <tTalkbox_lpcDurbin+0x80>
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   29070:	eeb4 9ae9 	vcmpe.f32	s18, s19
   29074:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29078:	d42d      	bmi.n	290d6 <tTalkbox_lpcDurbin+0xfa>
        k[i] /= e;
   2907a:	eec8 6a28 	vdiv.f32	s13, s16, s17
   2907e:	aa24      	add	r2, sp, #144	; 0x90
   29080:	4618      	mov	r0, r3
   29082:	eb02 0287 	add.w	r2, r2, r7, lsl #2
   29086:	ed45 6a01 	vstr	s13, [r5, #-4]

        a[i] = k[i];
   2908a:	edc8 6a01 	vstr	s13, [r8, #4]
        for(j=1; j<i; j++) a[j] = at[j] + k[i] * at[i-j];
   2908e:	ed32 7a01 	vldmdb	r2!, {s14}
   29092:	ecf0 7a01 	vldmia	r0!, {s15}
   29096:	4293      	cmp	r3, r2
   29098:	eee7 7a26 	vfma.f32	s15, s14, s13
   2909c:	ece1 7a01 	vstmia	r1!, {s15}
   290a0:	d1f5      	bne.n	2908e <tTalkbox_lpcDurbin+0xb2>

        e *= 1.0f - k[i] * k[i];
   290a2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    for(i=1; i<=p; i++)
   290a6:	3701      	adds	r7, #1
   290a8:	f108 0804 	add.w	r8, r8, #4
   290ac:	465c      	mov	r4, fp
   290ae:	45b9      	cmp	r9, r7
        e *= 1.0f - k[i] * k[i];
   290b0:	eee6 7ae6 	vfms.f32	s15, s13, s13
   290b4:	ee68 8aa7 	vmul.f32	s17, s17, s15
    for(i=1; i<=p; i++)
   290b8:	daba      	bge.n	29030 <tTalkbox_lpcDurbin+0x54>
    }

    if(e < 1.0e-20f) e = 0.0f;
   290ba:	f24e 5308 	movw	r3, #58632	; 0xe508
   290be:	f6c1 633c 	movt	r3, #7740	; 0x1e3c
   290c2:	ee07 3a90 	vmov	s15, r3
   290c6:	eef4 8ae7 	vcmpe.f32	s17, s15
   290ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   290ce:	d402      	bmi.n	290d6 <tTalkbox_lpcDurbin+0xfa>
   290d0:	eef1 7ae8 	vsqrt.f32	s15, s17
   290d4:	e002      	b.n	290dc <tTalkbox_lpcDurbin+0x100>
        for(j=1; j<i; j++)
   290d6:	2300      	movs	r3, #0
   290d8:	ee07 3a90 	vmov	s15, r3
    *g = sqrtf(e);
   290dc:	9b01      	ldr	r3, [sp, #4]
   290de:	edc3 7a00 	vstr	s15, [r3]
}
   290e2:	b047      	add	sp, #284	; 0x11c
   290e4:	ecbd 8b04 	vpop	{d8-d9}
   290e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   290ec:	eeb4 9ae9 	vcmpe.f32	s18, s19
   290f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   290f4:	d4ef      	bmi.n	290d6 <tTalkbox_lpcDurbin+0xfa>
        k[i] /= e;
   290f6:	eec8 6a28 	vdiv.f32	s13, s16, s17
   290fa:	ed45 6a01 	vstr	s13, [r5, #-4]
        a[i] = k[i];
   290fe:	edc8 6a01 	vstr	s13, [r8, #4]
   29102:	e7ce      	b.n	290a2 <tTalkbox_lpcDurbin+0xc6>
	k[0] = 0.0f;
   29104:	2300      	movs	r3, #0
   29106:	6013      	str	r3, [r2, #0]
   29108:	e7d7      	b.n	290ba <tTalkbox_lpcDurbin+0xde>
   2910a:	bf00      	nop

0002910c <tTalkboxFloat_free>:
    tTalkboxFloat_update(voc);
    tTalkboxFloat_suspend(voc);
}

void tTalkboxFloat_free (tTalkboxFloat* const voc)
{
   2910c:	b510      	push	{r4, lr}
    _tTalkboxFloat* v = *voc;
   2910e:	6804      	ldr	r4, [r0, #0]

    mpool_free((char*)v->buf1, v->mempool);
   29110:	6821      	ldr	r1, [r4, #0]
   29112:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   29114:	f004 f926 	bl	2d364 <mpool_free>
    mpool_free((char*)v->buf0, v->mempool);
   29118:	6821      	ldr	r1, [r4, #0]
   2911a:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2911c:	f004 f922 	bl	2d364 <mpool_free>
    mpool_free((char*)v->window, v->mempool);
   29120:	6821      	ldr	r1, [r4, #0]
   29122:	6a20      	ldr	r0, [r4, #32]
   29124:	f004 f91e 	bl	2d364 <mpool_free>
    mpool_free((char*)v->car1, v->mempool);
   29128:	6821      	ldr	r1, [r4, #0]
   2912a:	69e0      	ldr	r0, [r4, #28]
   2912c:	f004 f91a 	bl	2d364 <mpool_free>
    mpool_free((char*)v->car0, v->mempool);
   29130:	6821      	ldr	r1, [r4, #0]
   29132:	69a0      	ldr	r0, [r4, #24]
   29134:	f004 f916 	bl	2d364 <mpool_free>

    mpool_free((char*)v->dl, v->mempool);
   29138:	6821      	ldr	r1, [r4, #0]
   2913a:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   2913e:	f004 f911 	bl	2d364 <mpool_free>
    mpool_free((char*)v->Rt, v->mempool);
   29142:	6821      	ldr	r1, [r4, #0]
   29144:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   29148:	f004 f90c 	bl	2d364 <mpool_free>
    mpool_free((char*)v->k, v->mempool);
   2914c:	6821      	ldr	r1, [r4, #0]
   2914e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   29150:	f004 f908 	bl	2d364 <mpool_free>
    mpool_free((char*)v, v->mempool);
   29154:	6821      	ldr	r1, [r4, #0]
   29156:	4620      	mov	r0, r4
}
   29158:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)v, v->mempool);
   2915c:	f004 b902 	b.w	2d364 <mpool_free>

00029160 <tTalkboxFloat_update>:

    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
    if(n > v->bufsize) n = v->bufsize;

    //O = (VstInt32)(0.0005f * fs);
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   29160:	f24b 7217 	movw	r2, #46871	; 0xb717
   29164:	f44f 4100 	mov.w	r1, #32768	; 0x8000
{
   29168:	b538      	push	{r3, r4, r5, lr}
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   2916a:	4613      	mov	r3, r2
   2916c:	f6c3 12d1 	movt	r2, #14801	; 0x39d1
   29170:	f2c4 71bb 	movt	r1, #18363	; 0x47bb
   29174:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   29178:	ee07 2a90 	vmov	s15, r2
   2917c:	2200      	movs	r2, #0
   2917e:	ee05 1a90 	vmov	s11, r1
   29182:	ee07 3a10 	vmov	s14, r3
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   29186:	f24c 637e 	movw	r3, #50814	; 0xc67e
   2918a:	f2c4 52fa 	movt	r2, #17914	; 0x45fa
   2918e:	f6c3 4385 	movt	r3, #15493	; 0x3c85
   29192:	ee06 2a10 	vmov	s12, r2
{
   29196:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
   2919a:	6804      	ldr	r4, [r0, #0]
    float fs = leaf.sampleRate;
   2919c:	f64f 0008 	movw	r0, #63496	; 0xf808
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   291a0:	edd4 6a04 	vldr	s13, [r4, #16]
    float fs = leaf.sampleRate;
   291a4:	f2c0 200f 	movt	r0, #527	; 0x20f
   291a8:	6961      	ldr	r1, [r4, #20]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   291aa:	eea6 7aa7 	vfma.f32	s14, s13, s15
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   291ae:	ee07 3a90 	vmov	s15, r3
   291b2:	edd0 6a00 	vldr	s13, [r0]

    if(n != v->N) //recalc hanning window
   291b6:	6c62      	ldr	r2, [r4, #68]	; 0x44
   291b8:	fec6 6ae5 	vminnm.f32	s13, s13, s11
   291bc:	fec6 6a86 	vmaxnm.f32	s13, s13, s12
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   291c0:	ee66 7aa7 	vmul.f32	s15, s13, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   291c4:	ee27 7a26 	vmul.f32	s14, s14, s13
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   291c8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   291cc:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   291d0:	ee17 3a90 	vmov	r3, s15
   291d4:	428b      	cmp	r3, r1
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   291d6:	ed84 7a12 	vstr	s14, [r4, #72]	; 0x48
   291da:	bfa8      	it	ge
   291dc:	460b      	movge	r3, r1
    if(n != v->N) //recalc hanning window
   291de:	429a      	cmp	r2, r3
   291e0:	d02c      	beq.n	2923c <tTalkboxFloat_update+0xdc>
    {
        v->N = n;
        float dp = TWO_PI / v->N;
   291e2:	f640 72db 	movw	r2, #4059	; 0xfdb
   291e6:	ee07 3a90 	vmov	s15, r3
        float p = 0.0f;
        for(n=0; n<v->N; n++)
   291ea:	2b00      	cmp	r3, #0
        v->N = n;
   291ec:	6463      	str	r3, [r4, #68]	; 0x44
        float dp = TWO_PI / v->N;
   291ee:	f2c4 02c9 	movt	r2, #16585	; 0x40c9
   291f2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   291f6:	ee07 2a90 	vmov	s15, r2
   291fa:	eec7 8a87 	vdiv.f32	s17, s15, s14
        for(n=0; n<v->N; n++)
   291fe:	dd1d      	ble.n	2923c <tTalkboxFloat_update+0xdc>
        float p = 0.0f;
   29200:	2300      	movs	r3, #0
        for(n=0; n<v->N; n++)
   29202:	461d      	mov	r5, r3
        float p = 0.0f;
   29204:	ee08 3a10 	vmov	s16, r3
        for(n=0; n<v->N; n++)
   29208:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        {
            v->window[n] = 0.5f - 0.5f * cosf(p);
   2920c:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
   29210:	eeb0 9a40 	vmov.f32	s18, s0
   29214:	e001      	b.n	2921a <tTalkboxFloat_update+0xba>
   29216:	f007 f8f5 	bl	30404 <cosf>
   2921a:	ee39 0a40 	vsub.f32	s0, s18, s0
   2921e:	6a23      	ldr	r3, [r4, #32]
            p += dp;
   29220:	ee38 8a28 	vadd.f32	s16, s16, s17
            v->window[n] = 0.5f - 0.5f * cosf(p);
   29224:	eb03 0385 	add.w	r3, r3, r5, lsl #2
        for(n=0; n<v->N; n++)
   29228:	3501      	adds	r5, #1
            v->window[n] = 0.5f - 0.5f * cosf(p);
   2922a:	ee60 7a29 	vmul.f32	s15, s0, s19
   2922e:	eeb0 0a48 	vmov.f32	s0, s16
   29232:	edc3 7a00 	vstr	s15, [r3]
        for(n=0; n<v->N; n++)
   29236:	6c63      	ldr	r3, [r4, #68]	; 0x44
   29238:	42ab      	cmp	r3, r5
   2923a:	dcec      	bgt.n	29216 <tTalkboxFloat_update+0xb6>
        }
    }
    v->wet = 0.5f * v->param[0] * v->param[0];
   2923c:	ed94 7a01 	vldr	s14, [r4, #4]
   29240:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    v->dry = 2.0f * v->param[1] * v->param[1];
   29244:	edd4 7a02 	vldr	s15, [r4, #8]
    v->wet = 0.5f * v->param[0] * v->param[0];
   29248:	ee27 7a07 	vmul.f32	s14, s14, s14
    v->dry = 2.0f * v->param[1] * v->param[1];
   2924c:	ee67 7aa7 	vmul.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
   29250:	ee27 7a26 	vmul.f32	s14, s14, s13
    v->dry = 2.0f * v->param[1] * v->param[1];
   29254:	ee77 7aa7 	vadd.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
   29258:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
    v->dry = 2.0f * v->param[1] * v->param[1];
   2925c:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
   29260:	ecbd 8b04 	vpop	{d8-d9}
   29264:	bd38      	pop	{r3, r4, r5, pc}
   29266:	bf00      	nop

00029268 <tTalkboxFloat_initToPool>:
{
   29268:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   2926c:	6817      	ldr	r7, [r2, #0]
{
   2926e:	4680      	mov	r8, r0
   29270:	4689      	mov	r9, r1
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   29272:	2090      	movs	r0, #144	; 0x90
   29274:	4639      	mov	r1, r7
    v->warpOn = 0;
   29276:	2500      	movs	r5, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   29278:	f003 ffca 	bl	2d210 <mpool_alloc>
    v->param[3] = 1.0f;  //quality
   2927c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   29280:	4606      	mov	r6, r0
    v->param[0] = 0.5f;  //wet
   29282:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   29286:	f8c8 0000 	str.w	r0, [r8]
    v->mempool = m;
   2928a:	6007      	str	r7, [r0, #0]
    v->bufsize = bufsize;
   2928c:	f8c0 9014 	str.w	r9, [r0, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   29290:	ea4f 0089 	mov.w	r0, r9, lsl #2
    v->param[0] = 0.5f;  //wet
   29294:	6071      	str	r1, [r6, #4]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   29296:	4639      	mov	r1, r7
    v->param[3] = 1.0f;  //quality
   29298:	6133      	str	r3, [r6, #16]
    v->param[1] = 0.0f;  //dry
   2929a:	60b5      	str	r5, [r6, #8]
    v->param[2] = 0; // Swap
   2929c:	60f5      	str	r5, [r6, #12]
    v->warpFactor = 0.0f;
   2929e:	6335      	str	r5, [r6, #48]	; 0x30
    v->G = 0.0f;
   292a0:	f8c6 5084 	str.w	r5, [r6, #132]	; 0x84
    v->freeze = 0;
   292a4:	e9c6 550d 	strd	r5, r5, [r6, #52]	; 0x34
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292a8:	f003 ffb2 	bl	2d210 <mpool_alloc>
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292ac:	6973      	ldr	r3, [r6, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292ae:	61b0      	str	r0, [r6, #24]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292b0:	4639      	mov	r1, r7
   292b2:	0098      	lsls	r0, r3, #2
   292b4:	f003 ffac 	bl	2d210 <mpool_alloc>
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292b8:	6973      	ldr	r3, [r6, #20]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292ba:	61f0      	str	r0, [r6, #28]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292bc:	4639      	mov	r1, r7
   292be:	0098      	lsls	r0, r3, #2
   292c0:	f003 ffa6 	bl	2d210 <mpool_alloc>
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292c4:	6973      	ldr	r3, [r6, #20]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292c6:	6230      	str	r0, [r6, #32]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292c8:	4639      	mov	r1, r7
   292ca:	0098      	lsls	r0, r3, #2
   292cc:	f003 ffa0 	bl	2d210 <mpool_alloc>
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292d0:	6973      	ldr	r3, [r6, #20]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292d2:	6270      	str	r0, [r6, #36]	; 0x24
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292d4:	4639      	mov	r1, r7
   292d6:	0098      	lsls	r0, r3, #2
   292d8:	f003 ff9a 	bl	2d210 <mpool_alloc>
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292dc:	6973      	ldr	r3, [r6, #20]
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292de:	62b0      	str	r0, [r6, #40]	; 0x28
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292e0:	4639      	mov	r1, r7
   292e2:	0098      	lsls	r0, r3, #2
   292e4:	f003 ff94 	bl	2d210 <mpool_alloc>
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292e8:	6973      	ldr	r3, [r6, #20]
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292ea:	f8c6 0088 	str.w	r0, [r6, #136]	; 0x88
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292ee:	4639      	mov	r1, r7
   292f0:	0098      	lsls	r0, r3, #2
   292f2:	f003 ff8d 	bl	2d210 <mpool_alloc>
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
   292f6:	4639      	mov	r1, r7
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   292f8:	f8c6 008c 	str.w	r0, [r6, #140]	; 0x8c
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
   292fc:	2088      	movs	r0, #136	; 0x88
   292fe:	f003 ff87 	bl	2d210 <mpool_alloc>
   29302:	62f0      	str	r0, [r6, #44]	; 0x2c
    tTalkboxFloat_update(voc);
   29304:	4640      	mov	r0, r8
   29306:	f7ff ff2b 	bl	29160 <tTalkboxFloat_update>

void tTalkboxFloat_suspend(tTalkboxFloat* const voc) ///clear any buffers...
{
    _tTalkboxFloat* v = *voc;
   2930a:	f8d8 3000 	ldr.w	r3, [r8]
    v->FX = 0;

    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;

    for (int32_t i = 0; i < v->bufsize; i++)
   2930e:	695a      	ldr	r2, [r3, #20]
    v->pos = v->K = 0;
   29310:	641d      	str	r5, [r3, #64]	; 0x40
    for (int32_t i = 0; i < v->bufsize; i++)
   29312:	42aa      	cmp	r2, r5
    v->pos = v->K = 0;
   29314:	64dd      	str	r5, [r3, #76]	; 0x4c
    v->emphasis = 0.0f;
   29316:	63dd      	str	r5, [r3, #60]	; 0x3c
    v->FX = 0;
   29318:	659d      	str	r5, [r3, #88]	; 0x58
    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
   2931a:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
   2931e:	67dd      	str	r5, [r3, #124]	; 0x7c
   29320:	679d      	str	r5, [r3, #120]	; 0x78
   29322:	675d      	str	r5, [r3, #116]	; 0x74
   29324:	671d      	str	r5, [r3, #112]	; 0x70
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;
   29326:	66dd      	str	r5, [r3, #108]	; 0x6c
   29328:	669d      	str	r5, [r3, #104]	; 0x68
   2932a:	665d      	str	r5, [r3, #100]	; 0x64
   2932c:	661d      	str	r5, [r3, #96]	; 0x60
   2932e:	65dd      	str	r5, [r3, #92]	; 0x5c
    for (int32_t i = 0; i < v->bufsize; i++)
   29330:	dd12      	ble.n	29358 <tTalkboxFloat_initToPool+0xf0>
   29332:	4629      	mov	r1, r5
    {
        v->buf0[i] = 0;
   29334:	462a      	mov	r2, r5
   29336:	0088      	lsls	r0, r1, #2
   29338:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    for (int32_t i = 0; i < v->bufsize; i++)
   2933a:	3101      	adds	r1, #1
        v->buf0[i] = 0;
   2933c:	4404      	add	r4, r0
   2933e:	6022      	str	r2, [r4, #0]
        v->buf1[i] = 0;
   29340:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   29342:	4404      	add	r4, r0
   29344:	6022      	str	r2, [r4, #0]
        v->car0[i] = 0;
   29346:	699c      	ldr	r4, [r3, #24]
   29348:	4404      	add	r4, r0
   2934a:	6022      	str	r2, [r4, #0]
        v->car1[i] = 0;
   2934c:	69dc      	ldr	r4, [r3, #28]
   2934e:	4420      	add	r0, r4
   29350:	6002      	str	r2, [r0, #0]
    for (int32_t i = 0; i < v->bufsize; i++)
   29352:	6958      	ldr	r0, [r3, #20]
   29354:	4281      	cmp	r1, r0
   29356:	dbee      	blt.n	29336 <tTalkboxFloat_initToPool+0xce>
}
   29358:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0002935c <tTalkboxFloat_warpedAutocorrelate>:

// warped autocorrelation adapted from ten.enegatum@liam's post on music-dsp 2004-04-07 09:37:51
//find the order-P autocorrelation array, R, for the sequence x of length L and warping of lambda
//wAutocorrelate(&pfSrc[stIndex],siglen,R,P,0);
void tTalkboxFloat_warpedAutocorrelate(float * x, float* dl, float* Rt, unsigned int L, float * R, unsigned int P, float lambda)
{
   2935c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    float r1,r2,r1t;
    R[0]=0;
   29360:	2400      	movs	r4, #0
{
   29362:	e9dd e507 	ldrd	lr, r5, [sp, #28]
    R[0]=0;
   29366:	f8ce 4000 	str.w	r4, [lr]
    Rt[0]=0;
   2936a:	6014      	str	r4, [r2, #0]
    r1=0;
    r2=0;
    r1t=0;
    for(uint32_t m=0; m<L;m++)
   2936c:	b303      	cbz	r3, 293b0 <tTalkboxFloat_warpedAutocorrelate+0x54>
   2936e:	ee07 4a90 	vmov	s15, r4
   29372:	460e      	mov	r6, r1
   29374:	4604      	mov	r4, r0
   29376:	eb00 0783 	add.w	r7, r0, r3, lsl #2
    r2=0;
   2937a:	eeb0 7a67 	vmov.f32	s14, s15
    r1=0;
   2937e:	eeb0 6a67 	vmov.f32	s12, s15
   29382:	e001      	b.n	29388 <tTalkboxFloat_warpedAutocorrelate+0x2c>
   29384:	edd2 7a00 	vldr	s15, [r2]
    {
                    Rt[0] += (x[m]) * (x[m]);
   29388:	edd4 6a00 	vldr	s13, [r4]
   2938c:	eee6 7aa6 	vfma.f32	s15, s13, s13
   29390:	edc2 7a00 	vstr	s15, [r2]

                    dl[m]= r1 - lambda * (x[m]-r2);
   29394:	ecf4 7a01 	vldmia	r4!, {s15}
   29398:	ee37 7a67 	vsub.f32	s14, s14, s15
    for(uint32_t m=0; m<L;m++)
   2939c:	42bc      	cmp	r4, r7
                    dl[m]= r1 - lambda * (x[m]-r2);
   2939e:	eea7 6a00 	vfma.f32	s12, s14, s0
   293a2:	eeb0 7a46 	vmov.f32	s14, s12
   293a6:	eca6 6a01 	vstmia	r6!, {s12}
                    r1 = x[m];
   293aa:	ed14 6a01 	vldr	s12, [r4, #-4]
    for(uint32_t m=0; m<L;m++)
   293ae:	d1e9      	bne.n	29384 <tTalkboxFloat_warpedAutocorrelate+0x28>
                    r2 = dl[m];
    }
    for(uint32_t i=1; i<=P; i++)
   293b0:	b3dd      	cbz	r5, 2942a <tTalkboxFloat_warpedAutocorrelate+0xce>
   293b2:	ea4f 0885 	mov.w	r8, r5, lsl #2
    {
            Rt[i]=0;
   293b6:	2400      	movs	r4, #0
   293b8:	1d15      	adds	r5, r2, #4
   293ba:	4694      	mov	ip, r2
   293bc:	f108 0804 	add.w	r8, r8, #4
   293c0:	ee05 4a10 	vmov	s10, r4
   293c4:	eb01 0783 	add.w	r7, r1, r3, lsl #2
   293c8:	eb02 0908 	add.w	r9, r2, r8
   293cc:	eca5 5a01 	vstmia	r5!, {s10}
            r1=0;
            r2=0;
            for(unsigned int m=0; m<L;m++)
   293d0:	b303      	cbz	r3, 29414 <tTalkboxFloat_warpedAutocorrelate+0xb8>
   293d2:	4606      	mov	r6, r0
   293d4:	460c      	mov	r4, r1
   293d6:	eeb0 7a45 	vmov.f32	s14, s10
            r2=0;
   293da:	eef0 7a45 	vmov.f32	s15, s10
            r1=0;
   293de:	eef0 6a45 	vmov.f32	s13, s10
   293e2:	e001      	b.n	293e8 <tTalkboxFloat_warpedAutocorrelate+0x8c>
   293e4:	ed15 7a01 	vldr	s14, [r5, #-4]
            {
                    Rt[i] +=  (dl[m]) * (x[m]);
   293e8:	edd4 5a00 	vldr	s11, [r4]
   293ec:	ecb6 6a01 	vldmia	r6!, {s12}
   293f0:	eea5 7a86 	vfma.f32	s14, s11, s12
   293f4:	ed05 7a01 	vstr	s14, [r5, #-4]

                    r1t = dl[m];
   293f8:	ecb4 7a01 	vldmia	r4!, {s14}
                    dl[m]= r1 - lambda * (r1t-r2);
   293fc:	ee77 7ac7 	vsub.f32	s15, s15, s14
            for(unsigned int m=0; m<L;m++)
   29400:	42a7      	cmp	r7, r4
                    dl[m]= r1 - lambda * (r1t-r2);
   29402:	eee7 6a80 	vfma.f32	s13, s15, s0
   29406:	eef0 7a66 	vmov.f32	s15, s13
                    r1 = r1t;
   2940a:	eef0 6a47 	vmov.f32	s13, s14
                    dl[m]= r1 - lambda * (r1t-r2);
   2940e:	ed44 7a01 	vstr	s15, [r4, #-4]
            for(unsigned int m=0; m<L;m++)
   29412:	d1e7      	bne.n	293e4 <tTalkboxFloat_warpedAutocorrelate+0x88>
    for(uint32_t i=1; i<=P; i++)
   29414:	45a9      	cmp	r9, r5
   29416:	d1d9      	bne.n	293cc <tTalkboxFloat_warpedAutocorrelate+0x70>
   29418:	4442      	add	r2, r8
                    r2 = dl[m];
            }
    }
    for(uint32_t i=0; i<=P; i++)
    {
            R[i]=Rt[i];
   2941a:	f85c 3b04 	ldr.w	r3, [ip], #4
    for(uint32_t i=0; i<=P; i++)
   2941e:	4562      	cmp	r2, ip
            R[i]=Rt[i];
   29420:	f84e 3b04 	str.w	r3, [lr], #4
    for(uint32_t i=0; i<=P; i++)
   29424:	d1f9      	bne.n	2941a <tTalkboxFloat_warpedAutocorrelate+0xbe>
    }

}
   29426:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            R[i]=Rt[i];
   2942a:	6813      	ldr	r3, [r2, #0]
   2942c:	f8ce 3000 	str.w	r3, [lr]
}
   29430:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00029434 <tTalkboxFloat_lpc>:
    return o;
}


void tTalkboxFloat_lpc(float *buf, float *car, float* dl, float* Rt, int32_t n, int32_t o, float warp, int warpOn, float *k, int freeze, float *G)
{
   29434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29438:	ed2d 8b02 	vpush	{d8}
   2943c:	b0c9      	sub	sp, #292	; 0x124
   2943e:	4604      	mov	r4, r0
   29440:	9f56      	ldr	r7, [sp, #344]	; 0x158
   29442:	9103      	str	r1, [sp, #12]
   29444:	9d54      	ldr	r5, [sp, #336]	; 0x150
   29446:	9e55      	ldr	r6, [sp, #340]	; 0x154
   29448:	f8dd 8164 	ldr.w	r8, [sp, #356]	; 0x164
    float z[ORD_MAX], r[ORD_MAX], x;
    int32_t i, j, nn=n;


	if (warpOn == 0)
   2944c:	2f00      	cmp	r7, #0
   2944e:	d042      	beq.n	294d6 <tTalkboxFloat_lpc+0xa2>
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
		}
	}
	else
	{
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   29450:	2e00      	cmp	r6, #0
   29452:	4691      	mov	r9, r2
   29454:	469a      	mov	sl, r3
   29456:	eeb0 8a40 	vmov.f32	s16, s0
   2945a:	f2c0 80c1 	blt.w	295e0 <tTalkboxFloat_lpc+0x1ac>
		{
			z[j] = r[j] = 0.0f;
   2945e:	1c77      	adds	r7, r6, #1
   29460:	f10d 0b98 	add.w	fp, sp, #152	; 0x98
   29464:	2100      	movs	r1, #0
   29466:	00bf      	lsls	r7, r7, #2
   29468:	4658      	mov	r0, fp
   2946a:	463a      	mov	r2, r7
   2946c:	f006 fea1 	bl	301b2 <memset>
   29470:	463a      	mov	r2, r7
   29472:	2100      	movs	r1, #0
   29474:	a804      	add	r0, sp, #16
   29476:	f006 fe9c 	bl	301b2 <memset>
		}
		tTalkboxFloat_warpedAutocorrelate(buf, dl, Rt, n, r, o, warp);
   2947a:	9601      	str	r6, [sp, #4]
   2947c:	eeb0 0a48 	vmov.f32	s0, s16
   29480:	f8cd b000 	str.w	fp, [sp]
   29484:	4652      	mov	r2, sl
   29486:	4649      	mov	r1, r9
   29488:	462b      	mov	r3, r5
   2948a:	4620      	mov	r0, r4
   2948c:	f7ff ff66 	bl	2935c <tTalkboxFloat_warpedAutocorrelate>
	}

	r[0] *= 1.001f;  //stability fix
   29490:	f242 03c5 	movw	r3, #8389	; 0x20c5
   29494:	ed9d 7a26 	vldr	s14, [sp, #152]	; 0x98
   29498:	f6c3 7380 	movt	r3, #16256	; 0x3f80
   2949c:	ee07 3a90 	vmov	s15, r3

	float min = 0.000001f;
	if (!freeze)
   294a0:	9b58      	ldr	r3, [sp, #352]	; 0x160
	r[0] *= 1.001f;  //stability fix
   294a2:	ee67 7a27 	vmul.f32	s15, s14, s15
   294a6:	edcd 7a26 	vstr	s15, [sp, #152]	; 0x98
	if (!freeze)
   294aa:	2b00      	cmp	r3, #0
   294ac:	d13e      	bne.n	2952c <tTalkboxFloat_lpc+0xf8>
	{
		if(r[0] < min)
		{
			for(i=0; i<n; i++)
   294ae:	2d00      	cmp	r5, #0
   294b0:	dd6a      	ble.n	29588 <tTalkboxFloat_lpc+0x154>
		if(r[0] < min)
   294b2:	f243 73bd 	movw	r3, #14269	; 0x37bd
   294b6:	f2c3 5386 	movt	r3, #13702	; 0x3586
   294ba:	ee07 3a10 	vmov	s14, r3
			for(i=0; i<n; i++)
   294be:	eef4 7a47 	vcmp.f32	s15, s14
   294c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   294c6:	d55f      	bpl.n	29588 <tTalkboxFloat_lpc+0x154>
			{
				buf[i] = 0.0f;
   294c8:	2300      	movs	r3, #0
   294ca:	6023      	str	r3, [r4, #0]
            x -= k[j] * z[j-1];
            z[j] = z[j-1] + k[j] * x;
        }
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
    }
}
   294cc:	b049      	add	sp, #292	; 0x124
   294ce:	ecbd 8b02 	vpop	{d8}
   294d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   294d6:	2e00      	cmp	r6, #0
   294d8:	dbda      	blt.n	29490 <tTalkboxFloat_lpc+0x5c>
   294da:	ea6f 0b06 	mvn.w	fp, r6
			z[j] = r[j] = 0.0f;
   294de:	f04f 0900 	mov.w	r9, #0
   294e2:	f10d 0e98 	add.w	lr, sp, #152	; 0x98
   294e6:	f10d 0a10 	add.w	sl, sp, #16
   294ea:	44ab      	add	fp, r5
   294ec:	eb00 0085 	add.w	r0, r0, r5, lsl #2
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   294f0:	46a4      	mov	ip, r4
   294f2:	462f      	mov	r7, r5
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   294f4:	2f00      	cmp	r7, #0
			z[j] = r[j] = 0.0f;
   294f6:	f84e 9b04 	str.w	r9, [lr], #4
   294fa:	f84a 9b04 	str.w	r9, [sl], #4
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   294fe:	dd0e      	ble.n	2951e <tTalkboxFloat_lpc+0xea>
   29500:	2100      	movs	r1, #0
   29502:	4662      	mov	r2, ip
   29504:	4623      	mov	r3, r4
   29506:	ee07 1a90 	vmov	s15, r1
   2950a:	ecf3 6a01 	vldmia	r3!, {s13}
   2950e:	ecb2 7a01 	vldmia	r2!, {s14}
   29512:	4298      	cmp	r0, r3
   29514:	eee6 7a87 	vfma.f32	s15, s13, s14
   29518:	d1f7      	bne.n	2950a <tTalkboxFloat_lpc+0xd6>
   2951a:	ed4e 7a01 	vstr	s15, [lr, #-4]
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   2951e:	3f01      	subs	r7, #1
   29520:	f10c 0c04 	add.w	ip, ip, #4
   29524:	3804      	subs	r0, #4
   29526:	45bb      	cmp	fp, r7
   29528:	d1e4      	bne.n	294f4 <tTalkboxFloat_lpc+0xc0>
   2952a:	e7b1      	b.n	29490 <tTalkboxFloat_lpc+0x5c>
    for(i=0; i<n; i++)
   2952c:	2d00      	cmp	r5, #0
   2952e:	ddcd      	ble.n	294cc <tTalkboxFloat_lpc+0x98>
   29530:	1c77      	adds	r7, r6, #1
   29532:	9b57      	ldr	r3, [sp, #348]	; 0x15c
   29534:	9803      	ldr	r0, [sp, #12]
   29536:	00bf      	lsls	r7, r7, #2
   29538:	1d19      	adds	r1, r3, #4
   2953a:	eb00 0585 	add.w	r5, r0, r5, lsl #2
   2953e:	eb03 0c07 	add.w	ip, r3, r7
   29542:	ab04      	add	r3, sp, #16
   29544:	441f      	add	r7, r3
        x = G[0] * car[i];
   29546:	ecb0 7a01 	vldmia	r0!, {s14}
        for(j=o; j>0; j--)  //lattice filter
   2954a:	2e00      	cmp	r6, #0
        x = G[0] * car[i];
   2954c:	edd8 7a00 	vldr	s15, [r8]
   29550:	ee27 7a27 	vmul.f32	s14, s14, s15
        for(j=o; j>0; j--)  //lattice filter
   29554:	dd0d      	ble.n	29572 <tTalkboxFloat_lpc+0x13e>
   29556:	463a      	mov	r2, r7
   29558:	4663      	mov	r3, ip
            x -= k[j] * z[j-1];
   2955a:	ed73 6a01 	vldmdb	r3!, {s13}
   2955e:	ed52 7a02 	vldr	s15, [r2, #-8]
        for(j=o; j>0; j--)  //lattice filter
   29562:	4299      	cmp	r1, r3
            x -= k[j] * z[j-1];
   29564:	eea6 7ae7 	vfms.f32	s14, s13, s15
            z[j] = z[j-1] + k[j] * x;
   29568:	eee6 7a87 	vfma.f32	s15, s13, s14
   2956c:	ed62 7a01 	vstmdb	r2!, {s15}
        for(j=o; j>0; j--)  //lattice filter
   29570:	d1f3      	bne.n	2955a <tTalkboxFloat_lpc+0x126>
    for(i=0; i<n; i++)
   29572:	4285      	cmp	r5, r0
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
   29574:	ed8d 7a04 	vstr	s14, [sp, #16]
   29578:	eca4 7a01 	vstmia	r4!, {s14}
    for(i=0; i<n; i++)
   2957c:	d1e3      	bne.n	29546 <tTalkboxFloat_lpc+0x112>
}
   2957e:	b049      	add	sp, #292	; 0x124
   29580:	ecbd 8b02 	vpop	{d8}
   29584:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tTalkbox_lpcDurbin(r, o, k, G);  //calc reflection coeffs
   29588:	4643      	mov	r3, r8
   2958a:	9a57      	ldr	r2, [sp, #348]	; 0x15c
   2958c:	4631      	mov	r1, r6
   2958e:	a826      	add	r0, sp, #152	; 0x98
   29590:	f7ff fd24 	bl	28fdc <tTalkbox_lpcDurbin>
		for(i=0; i<=o; i++)
   29594:	2e00      	cmp	r6, #0
   29596:	dbc9      	blt.n	2952c <tTalkboxFloat_lpc+0xf8>
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
   29598:	f647 43ee 	movw	r3, #31982	; 0x7cee
   2959c:	9a57      	ldr	r2, [sp, #348]	; 0x15c
   2959e:	4619      	mov	r1, r3
   295a0:	3204      	adds	r2, #4
   295a2:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
   295a6:	f6cb 717f 	movt	r1, #49023	; 0xbf7f
   295aa:	eb02 0286 	add.w	r2, r2, r6, lsl #2
   295ae:	ee07 3a10 	vmov	s14, r3
   295b2:	9b57      	ldr	r3, [sp, #348]	; 0x15c
   295b4:	ee06 1a90 	vmov	s13, r1
   295b8:	e003      	b.n	295c2 <tTalkboxFloat_lpc+0x18e>
   295ba:	ed03 7a01 	vstr	s14, [r3, #-4]
		for(i=0; i<=o; i++)
   295be:	429a      	cmp	r2, r3
   295c0:	d0b4      	beq.n	2952c <tTalkboxFloat_lpc+0xf8>
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
   295c2:	ecf3 7a01 	vldmia	r3!, {s15}
   295c6:	eef4 7ac7 	vcmpe.f32	s15, s14
   295ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   295ce:	dcf4      	bgt.n	295ba <tTalkboxFloat_lpc+0x186>
   295d0:	eef4 7ae6 	vcmpe.f32	s15, s13
   295d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   295d8:	bf48      	it	mi
   295da:	ed43 6a01 	vstrmi	s13, [r3, #-4]
   295de:	e7ee      	b.n	295be <tTalkboxFloat_lpc+0x18a>
   295e0:	f10d 0b98 	add.w	fp, sp, #152	; 0x98
   295e4:	e749      	b.n	2947a <tTalkboxFloat_lpc+0x46>
   295e6:	bf00      	nop

000295e8 <tTalkboxFloat_tick>:
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   295e8:	f649 129a 	movw	r2, #39322	; 0x999a
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   295ec:	f641 63b8 	movw	r3, #7864	; 0x1eb8
{
   295f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   295f4:	f6c3 6299 	movt	r2, #16025	; 0x3e99
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   295f8:	f6c3 7345 	movt	r3, #16197	; 0x3f45
{
   295fc:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
   29600:	6804      	ldr	r4, [r0, #0]
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   29602:	ee07 3a10 	vmov	s14, r3
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   29606:	ee06 2a90 	vmov	s13, r2
{
   2960a:	b086      	sub	sp, #24
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   2960c:	ed94 6a1b 	vldr	s12, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   29610:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   29614:	edd4 5a19 	vldr	s11, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   29618:	eee0 7a26 	vfma.f32	s15, s0, s13
    v->d4 = x;
   2961c:	ed84 0a1b 	vstr	s0, [r4, #108]	; 0x6c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   29620:	eee6 5a07 	vfma.f32	s11, s12, s14
   29624:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   29626:	6e21      	ldr	r1, [r4, #96]	; 0x60
    if(v->K++)
   29628:	6c22      	ldr	r2, [r4, #64]	; 0x40
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   2962a:	6663      	str	r3, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   2962c:	65e1      	str	r1, [r4, #92]	; 0x5c
   2962e:	eea7 0ae6 	vfms.f32	s0, s15, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   29632:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   29634:	eea5 6ac7 	vfms.f32	s12, s11, s14
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   29638:	6c63      	ldr	r3, [r4, #68]	; 0x44
    float e=v->emphasis, w, o, x, fx=v->FX;
   2963a:	ed94 7a0f 	vldr	s14, [r4, #60]	; 0x3c
   2963e:	ed94 8a16 	vldr	s16, [r4, #88]	; 0x58
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   29642:	ed84 0a18 	vstr	s0, [r4, #96]	; 0x60
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   29646:	ed84 6a1a 	vstr	s12, [r4, #104]	; 0x68
    if(v->K++)
   2964a:	2a00      	cmp	r2, #0
   2964c:	d073      	beq.n	29736 <tTalkboxFloat_tick+0x14e>
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   2964e:	2b00      	cmp	r3, #0
   29650:	461e      	mov	r6, r3
        v->car0[p0] = v->car1[p1] = x; //carrier input
   29652:	69e0      	ldr	r0, [r4, #28]
    x = p + q;
   29654:	ee77 7aa5 	vadd.f32	s15, s15, s11
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   29658:	bfb8      	it	lt
   2965a:	1c5e      	addlt	r6, r3, #1
        v->K = 0;
   2965c:	2700      	movs	r7, #0
        v->car0[p0] = v->car1[p1] = x; //carrier input
   2965e:	00a9      	lsls	r1, r5, #2
        x = o - e;  e = o;  //6dB/oct pre-emphasis
   29660:	ee70 8ac7 	vsub.f32	s17, s1, s14
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   29664:	eb05 0266 	add.w	r2, r5, r6, asr #1
        v->K = 0;
   29668:	6427      	str	r7, [r4, #64]	; 0x40
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   2966a:	3501      	adds	r5, #1
   2966c:	eeb0 9a60 	vmov.f32	s18, s1
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   29670:	fb92 f6f3 	sdiv	r6, r2, r3
   29674:	fb03 2616 	mls	r6, r3, r6, r2
        v->car0[p0] = v->car1[p1] = x; //carrier input
   29678:	ea4f 0886 	mov.w	r8, r6, lsl #2
   2967c:	4440      	add	r0, r8
   2967e:	edc0 7a00 	vstr	s15, [r0]
   29682:	69a3      	ldr	r3, [r4, #24]
   29684:	440b      	add	r3, r1
   29686:	edc3 7a00 	vstr	s15, [r3]
        w = v->window[p0]; fx = v->buf0[p0] * w;  v->buf0[p0] = x * w;  //50% overlapping hanning windows
   2968a:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
   2968e:	440a      	add	r2, r1
   29690:	440b      	add	r3, r1
   29692:	edd2 9a00 	vldr	s19, [r2]
   29696:	ed93 8a00 	vldr	s16, [r3]
   2969a:	ee68 7aa9 	vmul.f32	s15, s17, s19
   2969e:	ee29 8a88 	vmul.f32	s16, s19, s16
   296a2:	edc3 7a00 	vstr	s15, [r3]
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   296a6:	f8d4 c044 	ldr.w	ip, [r4, #68]	; 0x44
   296aa:	45ac      	cmp	ip, r5
   296ac:	dd5d      	ble.n	2976a <tTalkboxFloat_tick+0x182>
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
   296ae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   296b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   296b4:	3601      	adds	r6, #1
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
   296b6:	4498      	add	r8, r3
   296b8:	ee77 7ae9 	vsub.f32	s15, s15, s19
   296bc:	edd8 6a00 	vldr	s13, [r8]
   296c0:	ee28 7aa7 	vmul.f32	s14, s17, s15
   296c4:	eea6 8aa7 	vfma.f32	s16, s13, s15
   296c8:	ed88 7a00 	vstr	s14, [r8]
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   296cc:	6c67      	ldr	r7, [r4, #68]	; 0x44
   296ce:	42b7      	cmp	r7, r6
   296d0:	dd36      	ble.n	29740 <tTalkboxFloat_tick+0x158>
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   296d2:	f649 129a 	movw	r2, #39322	; 0x999a
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   296d6:	f641 63b8 	movw	r3, #7864	; 0x1eb8
   296da:	edd4 6a20 	vldr	s13, [r4, #128]	; 0x80
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   296de:	eef0 5a48 	vmov.f32	s11, s16
   296e2:	f6c3 6299 	movt	r2, #16025	; 0x3e99
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   296e6:	f6c3 7345 	movt	r3, #16197	; 0x3f45
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   296ea:	ed94 0a1c 	vldr	s0, [r4, #112]	; 0x70
   296ee:	ee07 2a10 	vmov	s14, r2
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   296f2:	ee07 3a90 	vmov	s15, r3
   296f6:	ed94 6a1e 	vldr	s12, [r4, #120]	; 0x78
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   296fa:	eea8 0a07 	vfma.f32	s0, s16, s14
   296fe:	6f62      	ldr	r2, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   29700:	eea6 6aa7 	vfma.f32	s12, s13, s15
   29704:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    v->emphasis = e;
   29706:	ed84 9a0f 	vstr	s18, [r4, #60]	; 0x3c
    v->pos = p0;
   2970a:	64e5      	str	r5, [r4, #76]	; 0x4c
    v->FX = fx;
   2970c:	ed84 8a16 	vstr	s16, [r4, #88]	; 0x58
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   29710:	6722      	str	r2, [r4, #112]	; 0x70
   29712:	eee0 5a47 	vfms.f32	s11, s0, s14
    v->u4 = fx;
   29716:	ed84 8a20 	vstr	s16, [r4, #128]	; 0x80
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   2971a:	eee6 6a67 	vfms.f32	s13, s12, s15
   2971e:	67a3      	str	r3, [r4, #120]	; 0x78
}
   29720:	ee30 0a06 	vadd.f32	s0, s0, s12
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   29724:	edc4 5a1d 	vstr	s11, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   29728:	edc4 6a1f 	vstr	s13, [r4, #124]	; 0x7c
}
   2972c:	b006      	add	sp, #24
   2972e:	ecbd 8b04 	vpop	{d8-d9}
   29732:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(v->K++)
   29736:	2301      	movs	r3, #1
    float e=v->emphasis, w, o, x, fx=v->FX;
   29738:	eeb0 9a47 	vmov.f32	s18, s14
    if(v->K++)
   2973c:	6423      	str	r3, [r4, #64]	; 0x40
   2973e:	e7c8      	b.n	296d2 <tTalkboxFloat_tick+0xea>
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   29740:	f104 0684 	add.w	r6, r4, #132	; 0x84
   29744:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   29748:	69e1      	ldr	r1, [r4, #28]
   2974a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2974c:	e9d4 2322 	ldrd	r2, r3, [r4, #136]	; 0x88
   29750:	9605      	str	r6, [sp, #20]
   29752:	6ba6      	ldr	r6, [r4, #56]	; 0x38
   29754:	9604      	str	r6, [sp, #16]
   29756:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   29758:	9603      	str	r6, [sp, #12]
   2975a:	6b66      	ldr	r6, [r4, #52]	; 0x34
   2975c:	9602      	str	r6, [sp, #8]
   2975e:	6ca6      	ldr	r6, [r4, #72]	; 0x48
   29760:	e9cd 7600 	strd	r7, r6, [sp]
   29764:	f7ff fe66 	bl	29434 <tTalkboxFloat_lpc>
   29768:	e7b3      	b.n	296d2 <tTalkboxFloat_tick+0xea>
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   2976a:	f104 0e84 	add.w	lr, r4, #132	; 0x84
   2976e:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   29772:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   29776:	463d      	mov	r5, r7
   29778:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
   2977c:	69a1      	ldr	r1, [r4, #24]
   2977e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   29780:	f8cd e014 	str.w	lr, [sp, #20]
   29784:	6ba7      	ldr	r7, [r4, #56]	; 0x38
   29786:	9704      	str	r7, [sp, #16]
   29788:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   2978a:	9703      	str	r7, [sp, #12]
   2978c:	6b67      	ldr	r7, [r4, #52]	; 0x34
   2978e:	9702      	str	r7, [sp, #8]
   29790:	6ca7      	ldr	r7, [r4, #72]	; 0x48
   29792:	e9cd c700 	strd	ip, r7, [sp]
   29796:	f7ff fe4d 	bl	29434 <tTalkboxFloat_lpc>
   2979a:	e788      	b.n	296ae <tTalkboxFloat_tick+0xc6>

0002979c <tTalkboxFloat_setQuality>:

void tTalkboxFloat_setQuality(tTalkboxFloat* const voc, float quality)
{
    _tTalkboxFloat* v = *voc;
    v->param[3] = quality;
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   2979c:	f24b 7217 	movw	r2, #46871	; 0xb717
   297a0:	f64f 0108 	movw	r1, #63496	; 0xf808
    _tTalkboxFloat* v = *voc;
   297a4:	6800      	ldr	r0, [r0, #0]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   297a6:	4613      	mov	r3, r2
   297a8:	f6c3 12d1 	movt	r2, #14801	; 0x39d1
   297ac:	f2c0 210f 	movt	r1, #527	; 0x20f
    v->param[3] = quality;
   297b0:	ed80 0a04 	vstr	s0, [r0, #16]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   297b4:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
   297b8:	ee07 2a10 	vmov	s14, r2
   297bc:	edd1 6a00 	vldr	s13, [r1]
   297c0:	ee07 3a90 	vmov	s15, r3
   297c4:	eee0 7a07 	vfma.f32	s15, s0, s14
   297c8:	ee67 7aa6 	vmul.f32	s15, s15, s13
   297cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   297d0:	ee17 3a90 	vmov	r3, s15
    if (v->O >= ORD_MAX)
   297d4:	2b21      	cmp	r3, #33	; 0x21
    {
    	v->O = ORD_MAX-1;
   297d6:	bfc8      	it	gt
   297d8:	2321      	movgt	r3, #33	; 0x21
   297da:	6483      	str	r3, [r0, #72]	; 0x48
    }
}
   297dc:	4770      	bx	lr
   297de:	bf00      	nop

000297e0 <tTalkboxFloat_setWarpFactor>:

void tTalkboxFloat_setWarpFactor(tTalkboxFloat* const voc, float warpFactor)
{
    _tTalkboxFloat* v = *voc;
   297e0:	6803      	ldr	r3, [r0, #0]

    v->warpFactor = warpFactor;
   297e2:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
}
   297e6:	4770      	bx	lr

000297e8 <tTalkboxFloat_setWarpOn>:

void tTalkboxFloat_setWarpOn(tTalkboxFloat* const voc, float warpOn)
{
    _tTalkboxFloat* v = *voc;

    v->warpOn = warpOn;
   297e8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
   297ec:	6803      	ldr	r3, [r0, #0]
    v->warpOn = warpOn;
   297ee:	ed83 0a0d 	vstr	s0, [r3, #52]	; 0x34
}
   297f2:	4770      	bx	lr

000297f4 <tTalkboxFloat_setFreeze>:

void tTalkboxFloat_setFreeze(tTalkboxFloat* const voc, float freeze)
{
    _tTalkboxFloat* v = *voc;

    v->freeze = freeze;
   297f4:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
   297f8:	6803      	ldr	r3, [r0, #0]
    v->freeze = freeze;
   297fa:	ed83 0a0e 	vstr	s0, [r3, #56]	; 0x38
}
   297fe:	4770      	bx	lr

00029800 <tRosenbergGlottalPulse_initToPool>:
{
    tRosenbergGlottalPulse_initToPool(gp, &leaf.mempool);
}

void tRosenbergGlottalPulse_initToPool (tRosenbergGlottalPulse* const gp, tMempool* const mp)
{
   29800:	b538      	push	{r3, r4, r5, lr}
     _tMempool* m = *mp;
   29802:	680c      	ldr	r4, [r1, #0]
{
   29804:	4605      	mov	r5, r0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
   29806:	201c      	movs	r0, #28
   29808:	4621      	mov	r1, r4
   2980a:	f003 fd01 	bl	2d210 <mpool_alloc>
    g->mempool = m;

    g->phase  = 0.0f;
   2980e:	2300      	movs	r3, #0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
   29810:	6028      	str	r0, [r5, #0]
    g->mempool = m;
   29812:	6004      	str	r4, [r0, #0]
    g->phase  = 0.0f;
   29814:	6043      	str	r3, [r0, #4]
    g->openLength = 0.0f;
   29816:	6083      	str	r3, [r0, #8]
    g->pulseLength = 0.0f;
   29818:	60c3      	str	r3, [r0, #12]
    g->freq = 0.0f;
   2981a:	6143      	str	r3, [r0, #20]
    g->inc = 0.0f;
   2981c:	6183      	str	r3, [r0, #24]


}
   2981e:	bd38      	pop	{r3, r4, r5, pc}

00029820 <tRosenbergGlottalPulse_free>:
void tRosenbergGlottalPulse_free (tRosenbergGlottalPulse* const gp)
{
    _tRosenbergGlottalPulse* g = *gp;
   29820:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)g, g->mempool);
   29822:	6801      	ldr	r1, [r0, #0]
   29824:	f003 bd9e 	b.w	2d364 <mpool_free>

00029828 <tRosenbergGlottalPulse_tick>:
}

float   tRosenbergGlottalPulse_tick           (tRosenbergGlottalPulse* const gp)
{
   29828:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
   2982a:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   2982c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
   29830:	ed93 7a01 	vldr	s14, [r3, #4]
   29834:	edd3 7a06 	vldr	s15, [r3, #24]
   29838:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   2983c:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
   29840:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   29844:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29848:	db5a      	blt.n	29900 <tRosenbergGlottalPulse_tick+0xd8>
   2984a:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2984e:	eeb4 7ac6 	vcmpe.f32	s14, s12
   29852:	ee77 7a66 	vsub.f32	s15, s14, s13
   29856:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2985a:	eeb0 7a67 	vmov.f32	s14, s15
   2985e:	daf6      	bge.n	2984e <tRosenbergGlottalPulse_tick+0x26>
   29860:	edc3 7a01 	vstr	s15, [r3, #4]
    while (g->phase < 0.0f) g->phase += 1.0f;
   29864:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   29868:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2986c:	d545      	bpl.n	298fa <tRosenbergGlottalPulse_tick+0xd2>
   2986e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   29872:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   29876:	eef4 7ac7 	vcmpe.f32	s15, s14
   2987a:	ee37 0aa6 	vadd.f32	s0, s15, s13
   2987e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29882:	eef0 7a40 	vmov.f32	s15, s0
   29886:	d4f6      	bmi.n	29876 <tRosenbergGlottalPulse_tick+0x4e>
   29888:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
   2988c:	edd3 7a02 	vldr	s15, [r3, #8]
   29890:	eef4 7ac0 	vcmpe.f32	s15, s0
   29894:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29898:	dc1c      	bgt.n	298d4 <tRosenbergGlottalPulse_tick+0xac>
    {
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
   2989a:	ed93 7a03 	vldr	s14, [r3, #12]
   2989e:	eeb4 7ac0 	vcmpe.f32	s14, s0
   298a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   298a6:	dc03      	bgt.n	298b0 <tRosenbergGlottalPulse_tick+0x88>
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
    }

    else
    {
        output = 0.0f;
   298a8:	2300      	movs	r3, #0
   298aa:	ee00 3a10 	vmov	s0, r3
    }
    return output;
}
   298ae:	bd08      	pop	{r3, pc}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   298b0:	f640 72db 	movw	r2, #4059	; 0xfdb
   298b4:	ed93 7a04 	vldr	s14, [r3, #16]
   298b8:	ee30 0a67 	vsub.f32	s0, s0, s15
   298bc:	f6c3 72c9 	movt	r2, #16329	; 0x3fc9
   298c0:	ee07 2a90 	vmov	s15, r2
   298c4:	ee67 7a27 	vmul.f32	s15, s14, s15
}
   298c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   298cc:	ee27 0a80 	vmul.f32	s0, s15, s0
   298d0:	f003 b984 	b.w	2cbdc <fastercosf>
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
   298d4:	f640 73db 	movw	r3, #4059	; 0xfdb
   298d8:	f2c4 0349 	movt	r3, #16457	; 0x4049
   298dc:	ee07 3a90 	vmov	s15, r3
   298e0:	ee20 0a27 	vmul.f32	s0, s0, s15
   298e4:	f003 f97a 	bl	2cbdc <fastercosf>
   298e8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   298ec:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   298f0:	ee37 0ac0 	vsub.f32	s0, s15, s0
   298f4:	ee20 0a07 	vmul.f32	s0, s0, s14
}
   298f8:	bd08      	pop	{r3, pc}
    while (g->phase < 0.0f) g->phase += 1.0f;
   298fa:	eeb0 0a67 	vmov.f32	s0, s15
   298fe:	e7c5      	b.n	2988c <tRosenbergGlottalPulse_tick+0x64>
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   29900:	eef0 7a47 	vmov.f32	s15, s14
   29904:	e7ae      	b.n	29864 <tRosenbergGlottalPulse_tick+0x3c>
   29906:	bf00      	nop

00029908 <tRosenbergGlottalPulse_tickHQ>:


float   tRosenbergGlottalPulse_tickHQ           (tRosenbergGlottalPulse* const gp)
{
   29908:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
   2990a:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   2990c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
   29910:	ed93 7a01 	vldr	s14, [r3, #4]
   29914:	edd3 7a06 	vldr	s15, [r3, #24]
   29918:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   2991c:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
   29920:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   29924:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29928:	db57      	blt.n	299da <tRosenbergGlottalPulse_tickHQ+0xd2>
   2992a:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2992e:	eeb4 7ac6 	vcmpe.f32	s14, s12
   29932:	ee77 7a66 	vsub.f32	s15, s14, s13
   29936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2993a:	eeb0 7a67 	vmov.f32	s14, s15
   2993e:	daf6      	bge.n	2992e <tRosenbergGlottalPulse_tickHQ+0x26>
    while (g->phase < 0.0f) g->phase += 1.0f;
   29940:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   29944:	edc3 7a01 	vstr	s15, [r3, #4]
   29948:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2994c:	d54c      	bpl.n	299e8 <tRosenbergGlottalPulse_tickHQ+0xe0>
   2994e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   29952:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   29956:	eef4 7ac7 	vcmpe.f32	s15, s14
   2995a:	ee37 0aa6 	vadd.f32	s0, s15, s13
   2995e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29962:	eef0 7a40 	vmov.f32	s15, s0
   29966:	d4f6      	bmi.n	29956 <tRosenbergGlottalPulse_tickHQ+0x4e>
   29968:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
   2996c:	edd3 7a02 	vldr	s15, [r3, #8]
   29970:	eef4 7ac0 	vcmpe.f32	s15, s0
   29974:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29978:	dc1c      	bgt.n	299b4 <tRosenbergGlottalPulse_tickHQ+0xac>
    {
        output = 0.5f*(1.0f-cosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
   2997a:	ed93 7a03 	vldr	s14, [r3, #12]
   2997e:	eeb4 7ac0 	vcmpe.f32	s14, s0
   29982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29986:	dd11      	ble.n	299ac <tRosenbergGlottalPulse_tickHQ+0xa4>
    {
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   29988:	f640 72db 	movw	r2, #4059	; 0xfdb
   2998c:	ed93 7a04 	vldr	s14, [r3, #16]
   29990:	ee30 0a67 	vsub.f32	s0, s0, s15
   29994:	f6c3 72c9 	movt	r2, #16329	; 0x3fc9
   29998:	ee07 2a90 	vmov	s15, r2
   2999c:	ee67 7a27 	vmul.f32	s15, s14, s15
    else
    {
        output = 0.0f;
    }
    return output;
}
   299a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   299a4:	ee27 0a80 	vmul.f32	s0, s15, s0
   299a8:	f006 bd2c 	b.w	30404 <cosf>
        output = 0.0f;
   299ac:	2300      	movs	r3, #0
   299ae:	ee00 3a10 	vmov	s0, r3
}
   299b2:	bd08      	pop	{r3, pc}
        output = 0.5f*(1.0f-cosf(PI * g->phase));
   299b4:	f640 73db 	movw	r3, #4059	; 0xfdb
   299b8:	f2c4 0349 	movt	r3, #16457	; 0x4049
   299bc:	ee07 3a90 	vmov	s15, r3
   299c0:	ee20 0a27 	vmul.f32	s0, s0, s15
   299c4:	f006 fd1e 	bl	30404 <cosf>
   299c8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   299cc:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   299d0:	ee37 0ac0 	vsub.f32	s0, s15, s0
   299d4:	ee20 0a07 	vmul.f32	s0, s0, s14
}
   299d8:	bd08      	pop	{r3, pc}
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   299da:	eef0 7a47 	vmov.f32	s15, s14
    while (g->phase < 0.0f) g->phase += 1.0f;
   299de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   299e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   299e6:	d4b2      	bmi.n	2994e <tRosenbergGlottalPulse_tickHQ+0x46>
   299e8:	eeb0 0a67 	vmov.f32	s0, s15
   299ec:	e7be      	b.n	2996c <tRosenbergGlottalPulse_tickHQ+0x64>
   299ee:	bf00      	nop

000299f0 <tRosenbergGlottalPulse_setFreq>:

void   tRosenbergGlottalPulse_setFreq           (tRosenbergGlottalPulse* const gp, float freq)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->freq = freq;
    g->inc = freq * leaf.invSampleRate;
   299f0:	f64f 0308 	movw	r3, #63496	; 0xf808
    _tRosenbergGlottalPulse* g = *gp;
   299f4:	6802      	ldr	r2, [r0, #0]
    g->inc = freq * leaf.invSampleRate;
   299f6:	f2c0 230f 	movt	r3, #527	; 0x20f
    g->freq = freq;
   299fa:	ed82 0a05 	vstr	s0, [r2, #20]
    g->inc = freq * leaf.invSampleRate;
   299fe:	edd3 7a01 	vldr	s15, [r3, #4]
   29a02:	ee27 0a80 	vmul.f32	s0, s15, s0
   29a06:	ed82 0a06 	vstr	s0, [r2, #24]
}
   29a0a:	4770      	bx	lr

00029a0c <tRosenbergGlottalPulse_setOpenLength>:

void   tRosenbergGlottalPulse_setOpenLength           (tRosenbergGlottalPulse* const gp, float openLength)
{
    _tRosenbergGlottalPulse* g = *gp;
   29a0c:	6803      	ldr	r3, [r0, #0]
    g->openLength = openLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a0e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   29a12:	edd3 7a03 	vldr	s15, [r3, #12]
    g->openLength = openLength;
   29a16:	ed83 0a02 	vstr	s0, [r3, #8]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a1a:	ee37 0ac0 	vsub.f32	s0, s15, s0
   29a1e:	eec7 7a00 	vdiv.f32	s15, s14, s0
   29a22:	edc3 7a04 	vstr	s15, [r3, #16]
}
   29a26:	4770      	bx	lr

00029a28 <tRosenbergGlottalPulse_setPulseLength>:

void   tRosenbergGlottalPulse_setPulseLength           (tRosenbergGlottalPulse* const gp, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
   29a28:	6803      	ldr	r3, [r0, #0]
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a2a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   29a2e:	edd3 7a02 	vldr	s15, [r3, #8]
    g->pulseLength = pulseLength;
   29a32:	ed83 0a03 	vstr	s0, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a36:	ee30 0a67 	vsub.f32	s0, s0, s15
   29a3a:	eec7 7a00 	vdiv.f32	s15, s14, s0
   29a3e:	edc3 7a04 	vstr	s15, [r3, #16]
}
   29a42:	4770      	bx	lr

00029a44 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>:
void   tRosenbergGlottalPulse_setOpenLengthAndPulseLength           (tRosenbergGlottalPulse* const gp, float openLength, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->openLength = openLength;
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a44:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tRosenbergGlottalPulse* g = *gp;
   29a48:	6803      	ldr	r3, [r0, #0]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a4a:	ee30 7ac0 	vsub.f32	s14, s1, s0
    g->openLength = openLength;
   29a4e:	ed83 0a02 	vstr	s0, [r3, #8]
    g->pulseLength = pulseLength;
   29a52:	edc3 0a03 	vstr	s1, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   29a56:	eec6 7a87 	vdiv.f32	s15, s13, s14
   29a5a:	edc3 7a04 	vstr	s15, [r3, #16]
}
   29a5e:	4770      	bx	lr

00029a60 <tSOLAD_ioSamples>:
    mpool_free((char*)w, w->mempool);
}

// send one block of input samples, receive one block of output samples
void tSOLAD_ioSamples(tSOLAD* const wp, float* in, float* out, int blocksize)
{
   29a60:	b4f0      	push	{r4, r5, r6, r7}
   29a62:	ed2d 8b02 	vpush	{d8}
    _tSOLAD* w = *wp;
   29a66:	6800      	ldr	r0, [r0, #0]
    
    int i = w->timeindex;
    int n = w->blocksize = blocksize;
   29a68:	b29d      	uxth	r5, r3
    int i = w->timeindex;
   29a6a:	8886      	ldrh	r6, [r0, #4]
   29a6c:	462b      	mov	r3, r5
    int n = w->blocksize = blocksize;
   29a6e:	80c5      	strh	r5, [r0, #6]
    
    if(!i) w->delaybuf[LOOPSIZE] = in[0];   // copy one sample for interpolation
   29a70:	b926      	cbnz	r6, 29a7c <tSOLAD_ioSamples+0x1c>
   29a72:	6a04      	ldr	r4, [r0, #32]
   29a74:	680f      	ldr	r7, [r1, #0]
   29a76:	f504 4480 	add.w	r4, r4, #16384	; 0x4000
   29a7a:	6027      	str	r7, [r4, #0]
    while(n--) w->delaybuf[i++] = *in++;    // copy one input block to delay buffer
   29a7c:	b163      	cbz	r3, 29a98 <tSOLAD_ioSamples+0x38>
   29a7e:	eb01 0483 	add.w	r4, r1, r3, lsl #2
   29a82:	ebc1 0c86 	rsb	ip, r1, r6, lsl #2
   29a86:	eb0c 0701 	add.w	r7, ip, r1
   29a8a:	6a03      	ldr	r3, [r0, #32]
   29a8c:	f851 6b04 	ldr.w	r6, [r1], #4
   29a90:	443b      	add	r3, r7
   29a92:	428c      	cmp	r4, r1
   29a94:	601e      	str	r6, [r3, #0]
   29a96:	d1f6      	bne.n	29a86 <tSOLAD_ioSamples+0x26>
    
    if(w->pitchfactor > 1) pitchup(w, out);
   29a98:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
   29a9c:	edd0 6a02 	vldr	s13, [r0, #8]
   29aa0:	8883      	ldrh	r3, [r0, #4]
   29aa2:	edd0 3a04 	vldr	s7, [r0, #16]
   29aa6:	eef4 6ac2 	vcmpe.f32	s13, s4
   29aaa:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
   29aae:	edd0 7a03 	vldr	s15, [r0, #12]
   29ab2:	ee06 1a10 	vmov	s12, r1
   29ab6:	88c6      	ldrh	r6, [r0, #6]
   29ab8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29abc:	edd0 5a05 	vldr	s11, [r0, #20]
   29ac0:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   29ac4:	ed90 7a07 	vldr	s14, [r0, #28]
   29ac8:	ed90 3a06 	vldr	s6, [r0, #24]
   29acc:	f340 80bc 	ble.w	29c48 <tSOLAD_ioSamples+0x1e8>
    float xfadelength = w->xfadelength;
    
    float readlagstep = pitchfactor - 1;
    float xfadespeed = pitchfactor * pitchfactor;
    float xfadestep = xfadespeed / xfadelength;
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
   29ad0:	f247 01a4 	movw	r1, #28836	; 0x70a4
    float xfadespeed = pitchfactor * pitchfactor;
   29ad4:	ee66 1aa6 	vmul.f32	s3, s13, s13
    float readlagstep = pitchfactor - 1;
   29ad8:	ee36 2ac2 	vsub.f32	s4, s13, s4
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
   29adc:	f6c3 717d 	movt	r1, #16253	; 0x3f7d
   29ae0:	ee05 1a10 	vmov	s10, r1
   29ae4:	ee76 6ac5 	vsub.f32	s13, s13, s10
   29ae8:	ee86 5aa1 	vdiv.f32	s10, s13, s3
    float limit = period * limitfactor;
   29aec:	ee25 1a23 	vmul.f32	s2, s10, s7
    float readindex, outputsample;
    
    if((readlag > (period + 2 * limit)) & (xfadevalue < 0))
   29af0:	ee71 6a01 	vadd.f32	s13, s2, s2
   29af4:	ee76 4aa3 	vadd.f32	s9, s13, s7
   29af8:	eef4 4a67 	vcmp.f32	s9, s15
   29afc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b00:	f140 808a 	bpl.w	29c18 <tSOLAD_ioSamples+0x1b8>
   29b04:	eeb5 7a40 	vcmp.f32	s14, #0.0
   29b08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b0c:	f140 8084 	bpl.w	29c18 <tSOLAD_ioSamples+0x1b8>
   29b10:	ee77 6ae6 	vsub.f32	s13, s15, s13
    {
        jump = period;                                        // jump forward
   29b14:	eef0 5a63 	vmov.f32	s11, s7
   29b18:	e001      	b.n	29b1e <tSOLAD_ioSamples+0xbe>
        while((jump * 2) < (readlag - 2 * limit)) jump *= 2;  // use available space
   29b1a:	eef0 5a47 	vmov.f32	s11, s14
   29b1e:	ee35 7aa5 	vadd.f32	s14, s11, s11
   29b22:	eeb4 7ae6 	vcmpe.f32	s14, s13
   29b26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b2a:	d4f6      	bmi.n	29b1a <tSOLAD_ioSamples+0xba>
        readlag -= jump;                                      // reduce read pointer lag
        xfadevalue = 1;                                       // start crossfade
        xfadelength = period - 1;
   29b2c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        readlag -= jump;                                      // reduce read pointer lag
   29b30:	ee77 7ae5 	vsub.f32	s15, s15, s11
        xfadelength = period - 1;
   29b34:	ee33 3ac7 	vsub.f32	s6, s7, s14
        xfadestep = xfadespeed / xfadelength;
   29b38:	eec1 0a83 	vdiv.f32	s1, s3, s6
    }
    
    while(n--)
   29b3c:	1e74      	subs	r4, r6, #1
   29b3e:	2e00      	cmp	r6, #0
   29b40:	d05a      	beq.n	29bf8 <tSOLAD_ioSamples+0x198>
   29b42:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
            {
                xfadelength = readlag / limitfactor;
                if(xfadelength < 1) xfadelength = 1;
                xfadestep = xfadespeed / xfadelength;
                
                jump = -period;         // jump backward
   29b46:	eeb1 8a63 	vneg.f32	s16, s7
   29b4a:	ee82 0a85 	vdiv.f32	s0, s5, s10
        if(readlag < limit)  // check if read pointer should jump backward...
   29b4e:	eeb4 1ae7 	vcmpe.f32	s2, s15
   29b52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b56:	dd0b      	ble.n	29b70 <tSOLAD_ioSamples+0x110>
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
   29b58:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
                xfadelength = readlag / limitfactor;
   29b5c:	ee60 6a27 	vmul.f32	s13, s0, s15
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
   29b60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b64:	d465      	bmi.n	29c32 <tSOLAD_ioSamples+0x1d2>
   29b66:	eef5 7a40 	vcmp.f32	s15, #0.0
   29b6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b6e:	d460      	bmi.n	29c32 <tSOLAD_ioSamples+0x1d2>
                readlag += period;      // increase read pointer lag
                xfadevalue = 1;         // start crossfade
            }
        }
        
        readindex = refindex - readlag;
   29b70:	ee76 6a67 	vsub.f32	s13, s12, s15
        outputsample = read_sample(w, readindex);
   29b74:	6a03      	ldr	r3, [r0, #32]
        
        if(xfadevalue > 0)
   29b76:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
        {
            outputsample *= (1 - xfadevalue);
   29b7a:	ee72 8ac7 	vsub.f32	s17, s5, s14
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   29b7e:	ee36 4ae5 	vsub.f32	s8, s13, s11
}

// read one sample from delay buffer, with linear interpolation
static inline float read_sample(_tSOLAD* const w, float floatindex)
{
    int index = (int)floatindex;
   29b82:	eefd 4ae6 	vcvt.s32.f32	s9, s13
        if(xfadevalue > 0)
   29b86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    int index = (int)floatindex;
   29b8a:	eebd 5ac4 	vcvt.s32.f32	s10, s8
    float fraction = floatindex - (float)index;
    float *buf = w->delaybuf;
    index &= LOOPMASK;
   29b8e:	ee14 1a90 	vmov	r1, s9
    float fraction = floatindex - (float)index;
   29b92:	eef8 4ae4 	vcvt.f32.s32	s9, s9
    index &= LOOPMASK;
   29b96:	f3c1 010b 	ubfx	r1, r1, #0, #12
   29b9a:	ee15 6a10 	vmov	r6, s10
    float fraction = floatindex - (float)index;
   29b9e:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
    
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29ba2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    float fraction = floatindex - (float)index;
   29ba6:	ee76 6ae4 	vsub.f32	s13, s13, s9
    index &= LOOPMASK;
   29baa:	f3c6 060b 	ubfx	r6, r6, #0, #12
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29bae:	edd1 4a00 	vldr	s9, [r1]
    float fraction = floatindex - (float)index;
   29bb2:	ee34 5a45 	vsub.f32	s10, s8, s10
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29bb6:	ed91 4a01 	vldr	s8, [r1, #4]
   29bba:	eb03 0386 	add.w	r3, r3, r6, lsl #2
   29bbe:	ee34 4a64 	vsub.f32	s8, s8, s9
   29bc2:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
   29bc6:	dd2a      	ble.n	29c1e <tSOLAD_ioSamples+0x1be>
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29bc8:	edd3 6a00 	vldr	s13, [r3]
    while(n--)
   29bcc:	3c01      	subs	r4, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29bce:	ed93 4a01 	vldr	s8, [r3, #4]
        refindex += 1;
   29bd2:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   29bd6:	1c67      	adds	r7, r4, #1
        readlag -= readlagstep;
   29bd8:	ee77 7ac2 	vsub.f32	s15, s15, s4
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29bdc:	ee34 4a66 	vsub.f32	s8, s8, s13
   29be0:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   29be4:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
   29be8:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   29bec:	eee4 6aa8 	vfma.f32	s13, s9, s17
        *out++ = outputsample;
   29bf0:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
   29bf4:	d1ab      	bne.n	29b4e <tSOLAD_ioSamples+0xee>
   29bf6:	8883      	ldrh	r3, [r0, #4]
    w->readlag = readlag;               // state variables
   29bf8:	edc0 7a03 	vstr	s15, [r0, #12]
    w->jump = jump;
   29bfc:	edc0 5a05 	vstr	s11, [r0, #20]
    w->xfadelength = xfadelength;
   29c00:	ed80 3a06 	vstr	s6, [r0, #24]
    w->xfadevalue = xfadevalue;
   29c04:	ed80 7a07 	vstr	s14, [r0, #28]
    w->timeindex += blocksize;
   29c08:	441d      	add	r5, r3
    w->timeindex &= LOOPMASK;
   29c0a:	f3c5 050b 	ubfx	r5, r5, #0, #12
   29c0e:	8085      	strh	r5, [r0, #4]
}
   29c10:	ecbd 8b02 	vpop	{d8}
   29c14:	bcf0      	pop	{r4, r5, r6, r7}
   29c16:	4770      	bx	lr
    float xfadestep = xfadespeed / xfadelength;
   29c18:	eec1 0a83 	vdiv.f32	s1, s3, s6
   29c1c:	e78e      	b.n	29b3c <tSOLAD_ioSamples+0xdc>
    while(n--)
   29c1e:	3c01      	subs	r4, #1
        *out++ = outputsample;
   29c20:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
   29c24:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   29c28:	1c66      	adds	r6, r4, #1
        readlag -= readlagstep;
   29c2a:	ee77 7ac2 	vsub.f32	s15, s15, s4
    while(n--)
   29c2e:	d18e      	bne.n	29b4e <tSOLAD_ioSamples+0xee>
   29c30:	e7e1      	b.n	29bf6 <tSOLAD_ioSamples+0x196>
   29c32:	fe86 3aa2 	vmaxnm.f32	s6, s13, s5
                jump = -period;         // jump backward
   29c36:	eef0 5a48 	vmov.f32	s11, s16
                xfadestep = xfadespeed / xfadelength;
   29c3a:	eec1 0a83 	vdiv.f32	s1, s3, s6
                readlag += period;      // increase read pointer lag
   29c3e:	ee77 7aa3 	vadd.f32	s15, s15, s7
                xfadevalue = 1;         // start crossfade
   29c42:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   29c46:	e793      	b.n	29b70 <tSOLAD_ioSamples+0x110>
    if(pitchfactor > 0.5) xfadespeed = pitchfactor;
   29c48:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
    while(n--)
   29c4c:	1e74      	subs	r4, r6, #1
    float readlagstep = 1 - pitchfactor;
   29c4e:	ee72 1a66 	vsub.f32	s3, s4, s13
    else xfadespeed = 1 - pitchfactor;
   29c52:	eef4 6ac5 	vcmpe.f32	s13, s10
   29c56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29c5a:	fe76 6aa1 	vselgt.f32	s13, s13, s3
    xfadestep = xfadespeed / xfadelength;
   29c5e:	eec6 0a83 	vdiv.f32	s1, s13, s6
    while(n--)
   29c62:	2e00      	cmp	r6, #0
   29c64:	d053      	beq.n	29d0e <tSOLAD_ioSamples+0x2ae>
        refindex += 1;
   29c66:	eef0 2a42 	vmov.f32	s5, s4
                xfadelength = period - 1;
   29c6a:	ee33 2ac2 	vsub.f32	s4, s7, s4
                xfadestep = xfadespeed / xfadelength;
   29c6e:	ee86 0a82 	vdiv.f32	s0, s13, s4
            if(xfadevalue <= 0)      // ...but do not interrupt crossfade
   29c72:	eeb5 7a40 	vcmp.f32	s14, #0.0
   29c76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29c7a:	d804      	bhi.n	29c86 <tSOLAD_ioSamples+0x226>
   29c7c:	eef4 7a63 	vcmp.f32	s15, s7
   29c80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29c84:	dc56      	bgt.n	29d34 <tSOLAD_ioSamples+0x2d4>
        readindex = refindex - readlag;
   29c86:	ee36 5a67 	vsub.f32	s10, s12, s15
        outputsample = read_sample(w, readindex);
   29c8a:	6a01      	ldr	r1, [r0, #32]
        if(xfadevalue > 0)
   29c8c:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
    int index = (int)floatindex;
   29c90:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        if(xfadevalue > 0)
   29c94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    index &= LOOPMASK;
   29c98:	ee16 3a90 	vmov	r3, s13
    float fraction = floatindex - (float)index;
   29c9c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
   29ca0:	f3c3 030b 	ubfx	r3, r3, #0, #12
    float fraction = floatindex - (float)index;
   29ca4:	ee75 6a66 	vsub.f32	s13, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29ca8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   29cac:	edd3 4a00 	vldr	s9, [r3]
   29cb0:	ed93 4a01 	vldr	s8, [r3, #4]
   29cb4:	ee34 4a64 	vsub.f32	s8, s8, s9
   29cb8:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
   29cbc:	dd30      	ble.n	29d20 <tSOLAD_ioSamples+0x2c0>
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   29cbe:	ee35 5a65 	vsub.f32	s10, s10, s11
    while(n--)
   29cc2:	3c01      	subs	r4, #1
            outputsample *= (1 - xfadevalue);                               // fadein
   29cc4:	ee32 1ac7 	vsub.f32	s2, s5, s14
        refindex += 1;
   29cc8:	ee36 6a22 	vadd.f32	s12, s12, s5
    int index = (int)floatindex;
   29ccc:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        readlag += readlagstep;
   29cd0:	ee77 7aa1 	vadd.f32	s15, s15, s3
    index &= LOOPMASK;
   29cd4:	ee16 3a90 	vmov	r3, s13
    float fraction = floatindex - (float)index;
   29cd8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
   29cdc:	f3c3 030b 	ubfx	r3, r3, #0, #12
    float fraction = floatindex - (float)index;
   29ce0:	ee35 5a66 	vsub.f32	s10, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29ce4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   29ce8:	edd1 6a00 	vldr	s13, [r1]
   29cec:	ed91 4a01 	vldr	s8, [r1, #4]
    while(n--)
   29cf0:	1c61      	adds	r1, r4, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   29cf2:	ee34 4a66 	vsub.f32	s8, s8, s13
   29cf6:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   29cfa:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
   29cfe:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   29d02:	eee4 6a81 	vfma.f32	s13, s9, s2
        *out++ = outputsample;
   29d06:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
   29d0a:	d1b2      	bne.n	29c72 <tSOLAD_ioSamples+0x212>
   29d0c:	8883      	ldrh	r3, [r0, #4]
    w->jump = jump;                 // state variables
   29d0e:	edc0 5a05 	vstr	s11, [r0, #20]
    w->readlag = readlag;
   29d12:	edc0 7a03 	vstr	s15, [r0, #12]
    w->xfadevalue = xfadevalue;
   29d16:	ed80 7a07 	vstr	s14, [r0, #28]
    w->xfadelength = xfadelength;
   29d1a:	ed80 3a06 	vstr	s6, [r0, #24]
   29d1e:	e773      	b.n	29c08 <tSOLAD_ioSamples+0x1a8>
    while(n--)
   29d20:	3c01      	subs	r4, #1
        *out++ = outputsample;
   29d22:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
   29d26:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   29d2a:	1c63      	adds	r3, r4, #1
        readlag += readlagstep;
   29d2c:	ee77 7aa1 	vadd.f32	s15, s15, s3
    while(n--)
   29d30:	d19f      	bne.n	29c72 <tSOLAD_ioSamples+0x212>
   29d32:	e7eb      	b.n	29d0c <tSOLAD_ioSamples+0x2ac>
                jump = period;                           // jump forward
   29d34:	eef0 5a63 	vmov.f32	s11, s7
   29d38:	e001      	b.n	29d3e <tSOLAD_ioSamples+0x2de>
                while((jump * 2) < readlag) jump *= 2;   // use available space
   29d3a:	eef0 5a47 	vmov.f32	s11, s14
   29d3e:	ee35 7aa5 	vadd.f32	s14, s11, s11
   29d42:	eeb4 7ae7 	vcmpe.f32	s14, s15
   29d46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29d4a:	d4f6      	bmi.n	29d3a <tSOLAD_ioSamples+0x2da>
                readlag -= jump;                         // reduce read pointer lag
   29d4c:	ee77 7ae5 	vsub.f32	s15, s15, s11
                xfadestep = xfadespeed / xfadelength;
   29d50:	eef0 0a40 	vmov.f32	s1, s0
                xfadevalue = 1;                          // start crossfade
   29d54:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
                xfadelength = period - 1;
   29d58:	eeb0 3a42 	vmov.f32	s6, s4
   29d5c:	e793      	b.n	29c86 <tSOLAD_ioSamples+0x226>
   29d5e:	bf00      	nop

00029d60 <tRetune_initToPool>:
{
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tRetune_initToPool (tRetune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
   29d60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29d64:	ed2d 8b02 	vpush	{d8}
   29d68:	b085      	sub	sp, #20
   29d6a:	4604      	mov	r4, r0
   29d6c:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
   29d6e:	203c      	movs	r0, #60	; 0x3c
{
   29d70:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   29d74:	4617      	mov	r7, r2
   29d76:	469a      	mov	sl, r3
    _tMempool* m = *mp;
   29d78:	f8d8 6000 	ldr.w	r6, [r8]
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
   29d7c:	4631      	mov	r1, r6
   29d7e:	f003 fa47 	bl	2d210 <mpool_alloc>
   29d82:	4605      	mov	r5, r0
   29d84:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   29d86:	4631      	mov	r1, r6
    r->mempool = *mp;
   29d88:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
   29d8c:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   29d90:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
   29d92:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
   29d94:	61ef      	str	r7, [r5, #28]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
    
    r->hopSize = DEFHOPSIZE;
   29d96:	f04f 1740 	mov.w	r7, #4194368	; 0x400040
    r->numVoices = numVoices;
   29d9a:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   29d9e:	f003 fa8d 	bl	2d2bc <mpool_calloc>
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   29da2:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   29da4:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   29da6:	4631      	mov	r1, r6
   29da8:	0098      	lsls	r0, r3, #2
   29daa:	f003 fa87 	bl	2d2bc <mpool_calloc>
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
   29dae:	2114      	movs	r1, #20
void tRetune_setTimeConstant(tRetune* const rt, float tc)
{
    _tRetune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29db0:	f64f 0208 	movw	r2, #63496	; 0xf808
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   29db4:	6128      	str	r0, [r5, #16]
    r->fba = FBA;
   29db6:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29dba:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->hopSize = DEFHOPSIZE;
   29dbe:	622f      	str	r7, [r5, #32]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29dc0:	f2c0 220f 	movt	r2, #527	; 0x20f
    _tRetune* r = *rt;
   29dc4:	6824      	ldr	r4, [r4, #0]
    r->timeConstant = tc;
   29dc6:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29dc8:	ed92 0a01 	vldr	s0, [r2, #4]
   29dcc:	8c22      	ldrh	r2, [r4, #32]
    r->timeConstant = tc;
   29dce:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29dd2:	ee20 0a07 	vmul.f32	s0, s0, s14
   29dd6:	ee07 2a90 	vmov	s15, r2
    r->timeConstant = tc;
   29dda:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29ddc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   29de0:	ee20 0a27 	vmul.f32	s0, s0, s15
   29de4:	f006 fb4e 	bl	30484 <expf>
    r->inputPeriod = 0.0f;
   29de8:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   29dea:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   29dee:	4631      	mov	r1, r6
   29df0:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
   29df2:	636b      	str	r3, [r5, #52]	; 0x34
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   29df4:	0080      	lsls	r0, r0, #2
   29df6:	f003 fa61 	bl	2d2bc <mpool_calloc>
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   29dfa:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   29dfc:	60a8      	str	r0, [r5, #8]
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   29dfe:	4631      	mov	r1, r6
   29e00:	0098      	lsls	r0, r3, #2
   29e02:	f003 fa5b 	bl	2d2bc <mpool_calloc>
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   29e06:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   29e08:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   29e0a:	4631      	mov	r1, r6
   29e0c:	0098      	lsls	r0, r3, #2
   29e0e:	f003 fa55 	bl	2d2bc <mpool_calloc>
    for (int i = 0; i < r->numVoices; ++i)
   29e12:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   29e14:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
   29e16:	2b00      	cmp	r3, #0
   29e18:	dd0c      	ble.n	29e34 <tRetune_initToPool+0xd4>
   29e1a:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   29e1c:	69e8      	ldr	r0, [r5, #28]
   29e1e:	4631      	mov	r1, r6
   29e20:	692f      	ldr	r7, [r5, #16]
   29e22:	0080      	lsls	r0, r0, #2
   29e24:	f003 fa4a 	bl	2d2bc <mpool_calloc>
   29e28:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   29e2c:	3401      	adds	r4, #1
   29e2e:	6bab      	ldr	r3, [r5, #56]	; 0x38
   29e30:	42a3      	cmp	r3, r4
   29e32:	dcf3      	bgt.n	29e1c <tRetune_initToPool+0xbc>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
   29e34:	692a      	ldr	r2, [r5, #16]
   29e36:	1d28      	adds	r0, r5, #4
   29e38:	69eb      	ldr	r3, [r5, #28]
   29e3a:	6812      	ldr	r2, [r2, #0]
   29e3c:	68e9      	ldr	r1, [r5, #12]
   29e3e:	f8cd 8004 	str.w	r8, [sp, #4]
   29e42:	69ac      	ldr	r4, [r5, #24]
   29e44:	9003      	str	r0, [sp, #12]
   29e46:	9400      	str	r4, [sp, #0]
   29e48:	f7fe f882 	bl	27f50 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
   29e4c:	6bab      	ldr	r3, [r5, #56]	; 0x38
   29e4e:	2b00      	cmp	r3, #0
   29e50:	dd5b      	ble.n	29f0a <tRetune_initToPool+0x1aa>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   29e52:	2300      	movs	r3, #0
    w->period = INITPERIOD;
   29e54:	f04f 4985 	mov.w	r9, #1115684864	; 0x42800000
    for (int i = 0; i < r->numVoices; ++i)
   29e58:	461f      	mov	r7, r3
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   29e5a:	f2c4 2320 	movt	r3, #16928	; 0x4220
   29e5e:	ee08 3a90 	vmov	s17, r3
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   29e62:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   29e64:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
   29e66:	f8d8 b000 	ldr.w	fp, [r8]
    ps->pitchFactor = 1.0f;
   29e6a:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   29e6e:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   29e72:	4659      	mov	r1, fp
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   29e74:	69ee      	ldr	r6, [r5, #28]
   29e76:	f8d5 a008 	ldr.w	sl, [r5, #8]
   29e7a:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   29e7c:	f003 fa1e 	bl	2d2bc <mpool_calloc>
    ps->outBuffer = out;
   29e80:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   29e82:	4604      	mov	r4, r0
    ps->curBlock = 1;
   29e84:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
   29e88:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   29e8a:	f84a 4027 	str.w	r4, [sl, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   29e8e:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
   29e90:	f8c4 b000 	str.w	fp, [r4]
    for (int i = 0; i < r->numVoices; ++i)
   29e94:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
   29e96:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
   29e98:	6121      	str	r1, [r4, #16]
    ps->p = pd;
   29e9a:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
   29e9c:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
   29e9e:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
   29ea0:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
   29ea2:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
   29ea6:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
   29ea8:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   29eac:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
   29eb0:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   29eb4:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
   29eb6:	f8d8 b000 	ldr.w	fp, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   29eba:	4659      	mov	r1, fp
   29ebc:	f003 f9fe 	bl	2d2bc <mpool_calloc>
   29ec0:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   29ec2:	4659      	mov	r1, fp
   29ec4:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   29ec8:	6066      	str	r6, [r4, #4]
    w->mempool = m;
   29eca:	f8c6 b000 	str.w	fp, [r6]
    w->pitchfactor = 1.;
   29ece:	ed86 8a02 	vstr	s16, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   29ed2:	f003 f9f3 	bl	2d2bc <mpool_calloc>
    w->xfadevalue = -1;
   29ed6:	2200      	movs	r2, #0
    w->timeindex = 0;
   29ed8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   29edc:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
   29ede:	f6cb 7280 	movt	r2, #49024	; 0xbf80
    w->period = INITPERIOD;
   29ee2:	f8c6 9010 	str.w	r9, [r6, #16]
    w->timeindex = 0;
   29ee6:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   29ee8:	f104 0008 	add.w	r0, r4, #8
    w->xfadevalue = -1;
   29eec:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   29eee:	4641      	mov	r1, r8
    w->readlag = INITPERIOD;
   29ef0:	f8c6 900c 	str.w	r9, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   29ef4:	eeb0 0a68 	vmov.f32	s0, s17
   29ef8:	f001 fd7a 	bl	2b9f0 <tHighpass_initToPool>
    _tSOLAD* w = *wp;
   29efc:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
   29efe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   29f02:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
   29f04:	6bab      	ldr	r3, [r5, #56]	; 0x38
   29f06:	42bb      	cmp	r3, r7
   29f08:	dcab      	bgt.n	29e62 <tRetune_initToPool+0x102>
}
   29f0a:	b005      	add	sp, #20
   29f0c:	ecbd 8b02 	vpop	{d8}
   29f10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00029f14 <tRetune_init>:
{
   29f14:	b510      	push	{r4, lr}
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   29f16:	f64f 0420 	movw	r4, #63520	; 0xf820
{
   29f1a:	b082      	sub	sp, #8
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   29f1c:	f2c0 240f 	movt	r4, #527	; 0x20f
   29f20:	9400      	str	r4, [sp, #0]
   29f22:	f7ff ff1d 	bl	29d60 <tRetune_initToPool>
}
   29f26:	b002      	add	sp, #8
   29f28:	bd10      	pop	{r4, pc}
   29f2a:	bf00      	nop

00029f2c <tRetune_free>:
{
   29f2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tRetune* r = *rt;
   29f2e:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
   29f30:	1d20      	adds	r0, r4, #4
   29f32:	f7fe f86d 	bl	28010 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
   29f36:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   29f38:	2b00      	cmp	r3, #0
   29f3a:	dd1e      	ble.n	29f7a <tRetune_free+0x4e>
   29f3c:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
   29f3e:	68a3      	ldr	r3, [r4, #8]
   29f40:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
   29f44:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
   29f46:	6839      	ldr	r1, [r7, #0]
   29f48:	6a38      	ldr	r0, [r7, #32]
   29f4a:	f003 fa0b 	bl	2d364 <mpool_free>
    mpool_free((char*)w, w->mempool);
   29f4e:	6839      	ldr	r1, [r7, #0]
   29f50:	4638      	mov	r0, r7
   29f52:	f003 fa07 	bl	2d364 <mpool_free>
    tHighpass_free(&ps->hp);
   29f56:	f106 0008 	add.w	r0, r6, #8
   29f5a:	f001 fd6b 	bl	2ba34 <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
   29f5e:	6831      	ldr	r1, [r6, #0]
   29f60:	4630      	mov	r0, r6
   29f62:	f003 f9ff 	bl	2d364 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
   29f66:	6923      	ldr	r3, [r4, #16]
   29f68:	6821      	ldr	r1, [r4, #0]
   29f6a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   29f6e:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
   29f70:	f003 f9f8 	bl	2d364 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
   29f74:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   29f76:	42ab      	cmp	r3, r5
   29f78:	dce1      	bgt.n	29f3e <tRetune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
   29f7a:	6821      	ldr	r1, [r4, #0]
   29f7c:	6960      	ldr	r0, [r4, #20]
   29f7e:	f003 f9f1 	bl	2d364 <mpool_free>
    mpool_free((char*)r->pitchFactor, r->mempool);
   29f82:	6821      	ldr	r1, [r4, #0]
   29f84:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   29f86:	f003 f9ed 	bl	2d364 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
   29f8a:	6821      	ldr	r1, [r4, #0]
   29f8c:	68a0      	ldr	r0, [r4, #8]
   29f8e:	f003 f9e9 	bl	2d364 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
   29f92:	6821      	ldr	r1, [r4, #0]
   29f94:	68e0      	ldr	r0, [r4, #12]
   29f96:	f003 f9e5 	bl	2d364 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
   29f9a:	6821      	ldr	r1, [r4, #0]
   29f9c:	6920      	ldr	r0, [r4, #16]
   29f9e:	f003 f9e1 	bl	2d364 <mpool_free>
    mpool_free((char*)r, r->mempool);
   29fa2:	6821      	ldr	r1, [r4, #0]
   29fa4:	4620      	mov	r0, r4
}
   29fa6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   29faa:	f003 b9db 	b.w	2d364 <mpool_free>
   29fae:	bf00      	nop

00029fb0 <tRetune_tick>:
{
   29fb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   29fb4:	ed2d 8b04 	vpush	{d8-d9}
    _tRetune* r = *rt;
   29fb8:	6807      	ldr	r7, [r0, #0]
{
   29fba:	b083      	sub	sp, #12
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
   29fbc:	1d38      	adds	r0, r7, #4
   29fbe:	f7fe f849 	bl	28054 <tPeriodDetection_tick>
    for (int v = 0; v < r->numVoices; ++v)
   29fc2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
   29fc4:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    for (int v = 0; v < r->numVoices; ++v)
   29fc8:	2b00      	cmp	r3, #0
   29fca:	f340 808a 	ble.w	2a0e2 <tRetune_tick+0x132>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   29fce:	2300      	movs	r3, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
   29fd0:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    for (int v = 0; v < r->numVoices; ++v)
   29fd4:	461d      	mov	r5, r3
    if(period > MAXPERIOD) period = MAXPERIOD;
   29fd6:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   29fda:	f2c4 2370 	movt	r3, #17008	; 0x4270
    if(period > MAXPERIOD) period = MAXPERIOD;
   29fde:	ee08 2a90 	vmov	s17, r2
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   29fe2:	ee09 3a10 	vmov	s18, r3
   29fe6:	e005      	b.n	29ff4 <tRetune_tick+0x44>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   29fe8:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
   29fec:	3501      	adds	r5, #1
   29fee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   29ff0:	42ab      	cmp	r3, r5
   29ff2:	dd76      	ble.n	2a0e2 <tRetune_tick+0x132>
    _tPitchShift* ps = *psr;
   29ff4:	68bb      	ldr	r3, [r7, #8]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   29ff6:	697e      	ldr	r6, [r7, #20]
    _tPitchShift* ps = *psr;
   29ff8:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   29ffc:	eb06 0685 	add.w	r6, r6, r5, lsl #2
    _tPeriodDetection* p = *ps->p;
   2a000:	68e2      	ldr	r2, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a002:	f104 0008 	add.w	r0, r4, #8
   2a006:	6923      	ldr	r3, [r4, #16]
    _tPeriodDetection* p = *ps->p;
   2a008:	6812      	ldr	r2, [r2, #0]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a00a:	6b11      	ldr	r1, [r2, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
   2a00c:	9201      	str	r2, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a00e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    i = p->i;
   2a012:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a016:	ed93 0a00 	vldr	s0, [r3]
   2a01a:	f001 fd1f 	bl	2ba5c <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
   2a01e:	9a01      	ldr	r2, [sp, #4]
   2a020:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a022:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->indexstore >= ps->frameSize)
   2a026:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   2a028:	429a      	cmp	r2, r3
   2a02a:	dbdd      	blt.n	29fe8 <tRetune_tick+0x38>
        period = tPeriodDetection_getPeriod(&p);
   2a02c:	a801      	add	r0, sp, #4
   2a02e:	f7fe f89f 	bl	28170 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
   2a032:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
   2a034:	eef0 9a40 	vmov.f32	s19, s0
    _tPeriodDetection* p = *ps->p;
   2a038:	f8d3 9000 	ldr.w	r9, [r3]
    envout = tEnvPD_tick(&p->env);
   2a03c:	f109 0004 	add.w	r0, r9, #4
   2a040:	f7fd fc7e 	bl	27940 <tEnvPD_tick>
    if (envout >= 1.0f)
   2a044:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2a048:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2a04c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a050:	db0e      	blt.n	2a070 <tRetune_tick+0xc0>
        p->lastmax = p->max;
   2a052:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
        if (envout > p->max)
   2a056:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
   2a05a:	edc9 7a14 	vstr	s15, [r9, #80]	; 0x50
   2a05e:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
   2a062:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a066:	dd6e      	ble.n	2a146 <tRetune_tick+0x196>
            p->max = envout;
   2a068:	ed89 0a13 	vstr	s0, [r9, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
   2a06c:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
   2a070:	f899 3040 	ldrb.w	r3, [r9, #64]	; 0x40
   2a074:	9901      	ldr	r1, [sp, #4]
   2a076:	2b00      	cmp	r3, #0
   2a078:	d039      	beq.n	2a0ee <tRetune_tick+0x13e>
   2a07a:	3b01      	subs	r3, #1
   2a07c:	b2db      	uxtb	r3, r3
   2a07e:	f889 3040 	strb.w	r3, [r9, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a082:	b3a3      	cbz	r3, 2a0ee <tRetune_tick+0x13e>
   2a084:	6862      	ldr	r2, [r4, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a086:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   2a088:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a08c:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   2a090:	ee00 3a10 	vmov	s0, r3
   2a094:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   2a098:	ee20 0a28 	vmul.f32	s0, s0, s17
   2a09c:	fe80 0a69 	vminnm.f32	s0, s0, s19
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   2a0a0:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2a0a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a0a8:	dd02      	ble.n	2a0b0 <tRetune_tick+0x100>
   2a0aa:	ed82 0a04 	vstr	s0, [r2, #16]
   2a0ae:	6862      	ldr	r2, [r4, #4]
        tSOLAD_setPitchFactor(&ps->sola, ps->pitchFactor);
   2a0b0:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   2a0b4:	ea4f 0888 	mov.w	r8, r8, lsl #2
   2a0b8:	1d20      	adds	r0, r4, #4
    for (int v = 0; v < r->numVoices; ++v)
   2a0ba:	3501      	adds	r5, #1
    if (pitchfactor <= 0.0f) return;
   2a0bc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a0c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->pitchfactor = pitchfactor;
   2a0c4:	bf88      	it	hi
   2a0c6:	edc2 7a02 	vstrhi	s15, [r2, #8]
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   2a0ca:	68c9      	ldr	r1, [r1, #12]
   2a0cc:	6922      	ldr	r2, [r4, #16]
   2a0ce:	6963      	ldr	r3, [r4, #20]
   2a0d0:	4441      	add	r1, r8
   2a0d2:	4442      	add	r2, r8
   2a0d4:	f7ff fcc4 	bl	29a60 <tSOLAD_ioSamples>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   2a0d8:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
   2a0dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2a0de:	42ab      	cmp	r3, r5
   2a0e0:	dc88      	bgt.n	29ff4 <tRetune_tick+0x44>
}
   2a0e2:	6978      	ldr	r0, [r7, #20]
   2a0e4:	b003      	add	sp, #12
   2a0e6:	ecbd 8b04 	vpop	{d8-d9}
   2a0ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a0ee:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
   2a0f2:	eef4 7ac9 	vcmpe.f32	s15, s18
   2a0f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a0fa:	ddc3      	ble.n	2a084 <tRetune_tick+0xd4>
   2a0fc:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
   2a100:	ed99 7a15 	vldr	s14, [r9, #84]	; 0x54
   2a104:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2a108:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a10c:	ddba      	ble.n	2a084 <tRetune_tick+0xd4>
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2a10e:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
   2a110:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2a112:	ee07 2a90 	vmov	s15, r2
            p->fba = 5;
   2a116:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
    _tSOLAD* w = *wp;
   2a11a:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2a11c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
   2a120:	ed92 7a03 	vldr	s14, [r2, #12]
   2a124:	eef4 7ac7 	vcmpe.f32	s15, s14
   2a128:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a12c:	d5ab      	bpl.n	2a086 <tRetune_tick+0xd6>
        w->jump = w->readlag - readlag;
   2a12e:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
   2a132:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
   2a136:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
   2a13a:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
   2a13e:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
   2a142:	61d3      	str	r3, [r2, #28]
   2a144:	e79e      	b.n	2a084 <tRetune_tick+0xd4>
            p->deltamax = envout - p->max;
   2a146:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
            p->max = p->max * ps->radius;
   2a14a:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
   2a14e:	ee67 6aa6 	vmul.f32	s13, s15, s13
   2a152:	ee36 7ae7 	vsub.f32	s14, s13, s15
   2a156:	edc9 6a13 	vstr	s13, [r9, #76]	; 0x4c
   2a15a:	e787      	b.n	2a06c <tRetune_tick+0xbc>

0002a15c <tRetune_setPitchFactor>:
{
   2a15c:	b410      	push	{r4}
    _tRetune* r = *rt;
   2a15e:	6802      	ldr	r2, [r0, #0]
    r->pitchFactor[voice] = pf;
   2a160:	008c      	lsls	r4, r1, #2
   2a162:	6a90      	ldr	r0, [r2, #40]	; 0x28
   2a164:	4420      	add	r0, r4
   2a166:	ed80 0a00 	vstr	s0, [r0]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   2a16a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    _tPitchShift* ps = *psr;
   2a16c:	6892      	ldr	r2, [r2, #8]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   2a16e:	4423      	add	r3, r4
    _tPitchShift* ps = *psr;
   2a170:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   2a174:	681b      	ldr	r3, [r3, #0]
    ps->pitchFactor = pf;
   2a176:	62d3      	str	r3, [r2, #44]	; 0x2c
}
   2a178:	f85d 4b04 	ldr.w	r4, [sp], #4
   2a17c:	4770      	bx	lr
   2a17e:	bf00      	nop

0002a180 <tRetune_setFidelityThreshold>:

void tRetune_setFidelityThreshold(tRetune* const rt, float threshold)
{
    _tRetune* r = *rt;
    
    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
   2a180:	6800      	ldr	r0, [r0, #0]
   2a182:	3004      	adds	r0, #4
   2a184:	f7fd bff8 	b.w	28178 <tPeriodDetection_setFidelityThreshold>

0002a188 <tRetune_getInputPeriod>:

float tRetune_getInputPeriod(tRetune* const rt)
{
    _tRetune* r = *rt;
    
    return (r->inputPeriod * leaf.invSampleRate);
   2a188:	f64f 0308 	movw	r3, #63496	; 0xf808
   2a18c:	6802      	ldr	r2, [r0, #0]
   2a18e:	f2c0 230f 	movt	r3, #527	; 0x20f
   2a192:	ed92 0a0d 	vldr	s0, [r2, #52]	; 0x34
   2a196:	edd3 7a01 	vldr	s15, [r3, #4]
}
   2a19a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2a19e:	4770      	bx	lr

0002a1a0 <tAutotune_initToPool>:
{
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tAutotune_initToPool (tAutotune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
   2a1a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a1a4:	ed2d 8b02 	vpush	{d8}
   2a1a8:	b085      	sub	sp, #20
   2a1aa:	4604      	mov	r4, r0
   2a1ac:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
   2a1ae:	2040      	movs	r0, #64	; 0x40
{
   2a1b0:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   2a1b4:	4617      	mov	r7, r2
   2a1b6:	469a      	mov	sl, r3
    _tMempool* m = *mp;
   2a1b8:	f8d8 6000 	ldr.w	r6, [r8]
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
   2a1bc:	4631      	mov	r1, r6
   2a1be:	f003 f827 	bl	2d210 <mpool_alloc>
   2a1c2:	4605      	mov	r5, r0
   2a1c4:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   2a1c6:	4631      	mov	r1, r6
    r->mempool = *mp;
   2a1c8:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
   2a1cc:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   2a1d0:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
   2a1d2:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
   2a1d4:	61ef      	str	r7, [r5, #28]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
    
    r->hopSize = DEFHOPSIZE;
   2a1d6:	f04f 1740 	mov.w	r7, #4194368	; 0x400040
    r->numVoices = numVoices;
   2a1da:	f8c5 903c 	str.w	r9, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   2a1de:	f003 f817 	bl	2d210 <mpool_alloc>
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   2a1e2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   2a1e4:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   2a1e6:	4631      	mov	r1, r6
   2a1e8:	0098      	lsls	r0, r3, #2
   2a1ea:	f003 f811 	bl	2d210 <mpool_alloc>
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
   2a1ee:	2114      	movs	r1, #20
void tAutotune_setTimeConstant(tAutotune* const rt, float tc)
{
    _tAutotune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2a1f0:	f64f 0208 	movw	r2, #63496	; 0xf808
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   2a1f4:	6128      	str	r0, [r5, #16]
    r->fba = FBA;
   2a1f6:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2a1fa:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->hopSize = DEFHOPSIZE;
   2a1fe:	622f      	str	r7, [r5, #32]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2a200:	f2c0 220f 	movt	r2, #527	; 0x20f
    _tAutotune* r = *rt;
   2a204:	6824      	ldr	r4, [r4, #0]
    r->timeConstant = tc;
   2a206:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2a208:	ed92 0a01 	vldr	s0, [r2, #4]
   2a20c:	8c22      	ldrh	r2, [r4, #32]
    r->timeConstant = tc;
   2a20e:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2a212:	ee20 0a07 	vmul.f32	s0, s0, s14
   2a216:	ee07 2a90 	vmov	s15, r2
    r->timeConstant = tc;
   2a21a:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2a21c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2a220:	ee20 0a27 	vmul.f32	s0, s0, s15
   2a224:	f006 f92e 	bl	30484 <expf>
   2a228:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
   2a22c:	6be8      	ldr	r0, [r5, #60]	; 0x3c
   2a22e:	4631      	mov	r1, r6
   2a230:	0080      	lsls	r0, r0, #2
   2a232:	f002 ffed 	bl	2d210 <mpool_alloc>
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   2a236:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
   2a238:	60a8      	str	r0, [r5, #8]
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   2a23a:	4631      	mov	r1, r6
   2a23c:	0098      	lsls	r0, r3, #2
   2a23e:	f002 ffe7 	bl	2d210 <mpool_alloc>
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   2a242:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   2a244:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   2a246:	4631      	mov	r1, r6
   2a248:	0098      	lsls	r0, r3, #2
   2a24a:	f002 ffe1 	bl	2d210 <mpool_alloc>
    for (int i = 0; i < r->numVoices; ++i)
   2a24e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   2a250:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
   2a252:	2b00      	cmp	r3, #0
   2a254:	dd0c      	ble.n	2a270 <tAutotune_initToPool+0xd0>
   2a256:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   2a258:	69e8      	ldr	r0, [r5, #28]
   2a25a:	4631      	mov	r1, r6
   2a25c:	692f      	ldr	r7, [r5, #16]
   2a25e:	0080      	lsls	r0, r0, #2
   2a260:	f002 ffd6 	bl	2d210 <mpool_alloc>
   2a264:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   2a268:	3401      	adds	r4, #1
   2a26a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   2a26c:	42a3      	cmp	r3, r4
   2a26e:	dcf3      	bgt.n	2a258 <tAutotune_initToPool+0xb8>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
   2a270:	692a      	ldr	r2, [r5, #16]
   2a272:	1d28      	adds	r0, r5, #4
   2a274:	69eb      	ldr	r3, [r5, #28]
   2a276:	6812      	ldr	r2, [r2, #0]
   2a278:	68e9      	ldr	r1, [r5, #12]
   2a27a:	f8cd 8004 	str.w	r8, [sp, #4]
   2a27e:	69ac      	ldr	r4, [r5, #24]
   2a280:	9003      	str	r0, [sp, #12]
   2a282:	9400      	str	r4, [sp, #0]
   2a284:	f7fd fe64 	bl	27f50 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
   2a288:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   2a28a:	2b00      	cmp	r3, #0
   2a28c:	dd5b      	ble.n	2a346 <tAutotune_initToPool+0x1a6>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   2a28e:	2300      	movs	r3, #0
    w->period = INITPERIOD;
   2a290:	f04f 4985 	mov.w	r9, #1115684864	; 0x42800000
    for (int i = 0; i < r->numVoices; ++i)
   2a294:	461f      	mov	r7, r3
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   2a296:	f2c4 2320 	movt	r3, #16928	; 0x4220
   2a29a:	ee08 3a90 	vmov	s17, r3
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   2a29e:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   2a2a0:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
   2a2a2:	f8d8 b000 	ldr.w	fp, [r8]
    ps->pitchFactor = 1.0f;
   2a2a6:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   2a2aa:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   2a2ae:	4659      	mov	r1, fp
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   2a2b0:	69ee      	ldr	r6, [r5, #28]
   2a2b2:	f8d5 a008 	ldr.w	sl, [r5, #8]
   2a2b6:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   2a2b8:	f003 f800 	bl	2d2bc <mpool_calloc>
    ps->outBuffer = out;
   2a2bc:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   2a2be:	4604      	mov	r4, r0
    ps->curBlock = 1;
   2a2c0:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
   2a2c4:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   2a2c6:	f84a 4027 	str.w	r4, [sl, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   2a2ca:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
   2a2cc:	f8c4 b000 	str.w	fp, [r4]
    for (int i = 0; i < r->numVoices; ++i)
   2a2d0:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
   2a2d2:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
   2a2d4:	6121      	str	r1, [r4, #16]
    ps->p = pd;
   2a2d6:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
   2a2d8:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
   2a2da:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
   2a2dc:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
   2a2de:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
   2a2e2:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
   2a2e4:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   2a2e8:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
   2a2ec:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   2a2f0:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
   2a2f2:	f8d8 b000 	ldr.w	fp, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   2a2f6:	4659      	mov	r1, fp
   2a2f8:	f002 ffe0 	bl	2d2bc <mpool_calloc>
   2a2fc:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   2a2fe:	4659      	mov	r1, fp
   2a300:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   2a304:	6066      	str	r6, [r4, #4]
    w->mempool = m;
   2a306:	f8c6 b000 	str.w	fp, [r6]
    w->pitchfactor = 1.;
   2a30a:	ed86 8a02 	vstr	s16, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   2a30e:	f002 ffd5 	bl	2d2bc <mpool_calloc>
    w->xfadevalue = -1;
   2a312:	2200      	movs	r2, #0
    w->timeindex = 0;
   2a314:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   2a318:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
   2a31a:	f6cb 7280 	movt	r2, #49024	; 0xbf80
    w->period = INITPERIOD;
   2a31e:	f8c6 9010 	str.w	r9, [r6, #16]
    w->timeindex = 0;
   2a322:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   2a324:	f104 0008 	add.w	r0, r4, #8
    w->xfadevalue = -1;
   2a328:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   2a32a:	4641      	mov	r1, r8
    w->readlag = INITPERIOD;
   2a32c:	f8c6 900c 	str.w	r9, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   2a330:	eeb0 0a68 	vmov.f32	s0, s17
   2a334:	f001 fb5c 	bl	2b9f0 <tHighpass_initToPool>
    _tSOLAD* w = *wp;
   2a338:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
   2a33a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   2a33e:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
   2a340:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   2a342:	42bb      	cmp	r3, r7
   2a344:	dcab      	bgt.n	2a29e <tAutotune_initToPool+0xfe>
    r->inputPeriod = 0.0f;
   2a346:	2300      	movs	r3, #0
    r->shiftOn = 0;
   2a348:	63ab      	str	r3, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
   2a34a:	636b      	str	r3, [r5, #52]	; 0x34
}
   2a34c:	b005      	add	sp, #20
   2a34e:	ecbd 8b02 	vpop	{d8}
   2a352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a356:	bf00      	nop

0002a358 <tAutotune_init>:
{
   2a358:	b510      	push	{r4, lr}
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   2a35a:	f64f 0420 	movw	r4, #63520	; 0xf820
{
   2a35e:	b082      	sub	sp, #8
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   2a360:	f2c0 240f 	movt	r4, #527	; 0x20f
   2a364:	9400      	str	r4, [sp, #0]
   2a366:	f7ff ff1b 	bl	2a1a0 <tAutotune_initToPool>
}
   2a36a:	b002      	add	sp, #8
   2a36c:	bd10      	pop	{r4, pc}
   2a36e:	bf00      	nop

0002a370 <tAutotune_free>:
{
   2a370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tAutotune* r = *rt;
   2a372:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
   2a374:	1d20      	adds	r0, r4, #4
   2a376:	f7fd fe4b 	bl	28010 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
   2a37a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2a37c:	2b00      	cmp	r3, #0
   2a37e:	dd1e      	ble.n	2a3be <tAutotune_free+0x4e>
   2a380:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
   2a382:	68a3      	ldr	r3, [r4, #8]
   2a384:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
   2a388:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
   2a38a:	6839      	ldr	r1, [r7, #0]
   2a38c:	6a38      	ldr	r0, [r7, #32]
   2a38e:	f002 ffe9 	bl	2d364 <mpool_free>
    mpool_free((char*)w, w->mempool);
   2a392:	6839      	ldr	r1, [r7, #0]
   2a394:	4638      	mov	r0, r7
   2a396:	f002 ffe5 	bl	2d364 <mpool_free>
    tHighpass_free(&ps->hp);
   2a39a:	f106 0008 	add.w	r0, r6, #8
   2a39e:	f001 fb49 	bl	2ba34 <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
   2a3a2:	6831      	ldr	r1, [r6, #0]
   2a3a4:	4630      	mov	r0, r6
   2a3a6:	f002 ffdd 	bl	2d364 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
   2a3aa:	6923      	ldr	r3, [r4, #16]
   2a3ac:	6821      	ldr	r1, [r4, #0]
   2a3ae:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   2a3b2:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
   2a3b4:	f002 ffd6 	bl	2d364 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
   2a3b8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2a3ba:	42ab      	cmp	r3, r5
   2a3bc:	dce1      	bgt.n	2a382 <tAutotune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
   2a3be:	6821      	ldr	r1, [r4, #0]
   2a3c0:	6960      	ldr	r0, [r4, #20]
   2a3c2:	f002 ffcf 	bl	2d364 <mpool_free>
    mpool_free((char*)r->freq, r->mempool);
   2a3c6:	6821      	ldr	r1, [r4, #0]
   2a3c8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2a3ca:	f002 ffcb 	bl	2d364 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
   2a3ce:	6821      	ldr	r1, [r4, #0]
   2a3d0:	68a0      	ldr	r0, [r4, #8]
   2a3d2:	f002 ffc7 	bl	2d364 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
   2a3d6:	6821      	ldr	r1, [r4, #0]
   2a3d8:	68e0      	ldr	r0, [r4, #12]
   2a3da:	f002 ffc3 	bl	2d364 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
   2a3de:	6821      	ldr	r1, [r4, #0]
   2a3e0:	6920      	ldr	r0, [r4, #16]
   2a3e2:	f002 ffbf 	bl	2d364 <mpool_free>
    mpool_free((char*)r, r->mempool);
   2a3e6:	6821      	ldr	r1, [r4, #0]
   2a3e8:	4620      	mov	r0, r4
}
   2a3ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   2a3ee:	f002 bfb9 	b.w	2d364 <mpool_free>
   2a3f2:	bf00      	nop

0002a3f4 <tAutotune_tick>:
{
   2a3f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a3f8:	ed2d 8b06 	vpush	{d8-d10}
    _tAutotune* r = *rt;
   2a3fc:	6806      	ldr	r6, [r0, #0]
{
   2a3fe:	b082      	sub	sp, #8
    float tempPeriod = tPeriodDetection_tick(&r->pd, sample);
   2a400:	1d30      	adds	r0, r6, #4
   2a402:	f7fd fe27 	bl	28054 <tPeriodDetection_tick>
    if (tempPeriod < 1000.0f) //to avoid trying to follow consonants JS
   2a406:	2300      	movs	r3, #0
   2a408:	f2c4 437a 	movt	r3, #17530	; 0x447a
   2a40c:	ee07 3a90 	vmov	s15, r3
   2a410:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2a414:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a418:	d501      	bpl.n	2a41e <tAutotune_tick+0x2a>
		r->inputPeriod = tempPeriod;
   2a41a:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
	for (int v = 0; v < r->numVoices; ++v)
   2a41e:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   2a420:	2b00      	cmp	r3, #0
   2a422:	f340 80a0 	ble.w	2a566 <tAutotune_tick+0x172>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a426:	2300      	movs	r3, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a428:	f64c 42cd 	movw	r2, #52429	; 0xcccd
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   2a42c:	f64f 0808 	movw	r8, #63496	; 0xf808
	for (int v = 0; v < r->numVoices; ++v)
   2a430:	461d      	mov	r5, r3
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a432:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a436:	f2c4 2370 	movt	r3, #17008	; 0x4270
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   2a43a:	f2c0 280f 	movt	r8, #527	; 0x20f
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a43e:	ee09 2a90 	vmov	s19, r2
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a442:	ee0a 3a10 	vmov	s20, r3
   2a446:	e006      	b.n	2a456 <tAutotune_tick+0x62>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2a448:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
   2a44c:	3501      	adds	r5, #1
   2a44e:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   2a450:	42ab      	cmp	r3, r5
   2a452:	f340 8088 	ble.w	2a566 <tAutotune_tick+0x172>
    _tPitchShift* ps = *psr;
   2a456:	68b1      	ldr	r1, [r6, #8]
   2a458:	00ab      	lsls	r3, r5, #2
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2a45a:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    _tPitchShift* ps = *psr;
   2a45c:	f851 4025 	ldr.w	r4, [r1, r5, lsl #2]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2a460:	6977      	ldr	r7, [r6, #20]
   2a462:	eb02 0c03 	add.w	ip, r2, r3
    _tPeriodDetection* p = *ps->p;
   2a466:	68e1      	ldr	r1, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a468:	f104 0008 	add.w	r0, r4, #8
   2a46c:	6922      	ldr	r2, [r4, #16]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2a46e:	441f      	add	r7, r3
    _tPeriodDetection* p = *ps->p;
   2a470:	6809      	ldr	r1, [r1, #0]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2a472:	ed9c 8a00 	vldr	s16, [ip]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a476:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
   2a478:	9101      	str	r1, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a47a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    i = p->i;
   2a47e:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a482:	ed92 0a00 	vldr	s0, [r2]
   2a486:	f001 fae9 	bl	2ba5c <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
   2a48a:	9a01      	ldr	r2, [sp, #4]
   2a48c:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2a48e:	eef0 8a40 	vmov.f32	s17, s0
    if (p->indexstore >= ps->frameSize)
   2a492:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   2a494:	429a      	cmp	r2, r3
   2a496:	dbd7      	blt.n	2a448 <tAutotune_tick+0x54>
        period = tPeriodDetection_getPeriod(&p);
   2a498:	a801      	add	r0, sp, #4
   2a49a:	f7fd fe69 	bl	28170 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
   2a49e:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
   2a4a0:	eeb0 9a40 	vmov.f32	s18, s0
    _tPeriodDetection* p = *ps->p;
   2a4a4:	f8d3 a000 	ldr.w	sl, [r3]
    envout = tEnvPD_tick(&p->env);
   2a4a8:	f10a 0004 	add.w	r0, sl, #4
   2a4ac:	f7fd fa48 	bl	27940 <tEnvPD_tick>
    if (envout >= 1.0f)
   2a4b0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2a4b4:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2a4b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a4bc:	db0f      	blt.n	2a4de <tAutotune_tick+0xea>
        p->lastmax = p->max;
   2a4be:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
        if (envout > p->max)
   2a4c2:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
   2a4c6:	edca 7a14 	vstr	s15, [sl, #80]	; 0x50
   2a4ca:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
   2a4ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a4d2:	f340 8083 	ble.w	2a5dc <tAutotune_tick+0x1e8>
            p->max = envout;
   2a4d6:	ed8a 0a13 	vstr	s0, [sl, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
   2a4da:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
   2a4de:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
   2a4e2:	2b00      	cmp	r3, #0
   2a4e4:	d04c      	beq.n	2a580 <tAutotune_tick+0x18c>
   2a4e6:	3b01      	subs	r3, #1
   2a4e8:	b2db      	uxtb	r3, r3
   2a4ea:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a4ee:	2b00      	cmp	r3, #0
   2a4f0:	d046      	beq.n	2a580 <tAutotune_tick+0x18c>
   2a4f2:	6862      	ldr	r2, [r4, #4]
   2a4f4:	9901      	ldr	r1, [sp, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a4f6:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   2a4f8:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
   2a4fc:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   2a500:	ee07 3a90 	vmov	s15, r3
   2a504:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2a508:	ee67 7aa9 	vmul.f32	s15, s15, s19
   2a50c:	fec7 7ac9 	vminnm.f32	s15, s15, s18
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   2a510:	eef4 7ac7 	vcmpe.f32	s15, s14
   2a514:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a518:	dd02      	ble.n	2a520 <tAutotune_tick+0x12c>
   2a51a:	edc2 7a04 	vstr	s15, [r2, #16]
   2a51e:	6862      	ldr	r2, [r4, #4]
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   2a520:	eeb5 9a40 	vcmp.f32	s18, #0.0
   2a524:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a528:	d023      	beq.n	2a572 <tAutotune_tick+0x17e>
   2a52a:	edd8 7a01 	vldr	s15, [r8, #4]
   2a52e:	ee28 8a27 	vmul.f32	s16, s16, s15
   2a532:	ee28 8a09 	vmul.f32	s16, s16, s18
    if (pitchfactor <= 0.0f) return;
   2a536:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   2a53a:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
   2a53e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a542:	d81a      	bhi.n	2a57a <tAutotune_tick+0x186>
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   2a544:	ea4f 0989 	mov.w	r9, r9, lsl #2
   2a548:	68c9      	ldr	r1, [r1, #12]
   2a54a:	6922      	ldr	r2, [r4, #16]
   2a54c:	1d20      	adds	r0, r4, #4
   2a54e:	6963      	ldr	r3, [r4, #20]
   2a550:	4449      	add	r1, r9
   2a552:	444a      	add	r2, r9
	for (int v = 0; v < r->numVoices; ++v)
   2a554:	3501      	adds	r5, #1
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   2a556:	f7ff fa83 	bl	29a60 <tSOLAD_ioSamples>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2a55a:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
   2a55e:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   2a560:	42ab      	cmp	r3, r5
   2a562:	f73f af78 	bgt.w	2a456 <tAutotune_tick+0x62>
    return r->tickOutput;
   2a566:	6970      	ldr	r0, [r6, #20]
}
   2a568:	b002      	add	sp, #8
   2a56a:	ecbd 8b06 	vpop	{d8-d10}
   2a56e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a572:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   2a576:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    w->pitchfactor = pitchfactor;
   2a57a:	ed82 8a02 	vstr	s16, [r2, #8]
   2a57e:	e7e1      	b.n	2a544 <tAutotune_tick+0x150>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2a580:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
   2a584:	eef4 7aca 	vcmpe.f32	s15, s20
   2a588:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a58c:	ddb1      	ble.n	2a4f2 <tAutotune_tick+0xfe>
   2a58e:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
   2a592:	ed9a 7a15 	vldr	s14, [sl, #84]	; 0x54
   2a596:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2a59a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a59e:	dda8      	ble.n	2a4f2 <tAutotune_tick+0xfe>
            p->fba = 5;
   2a5a0:	9901      	ldr	r1, [sp, #4]
   2a5a2:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2a5a4:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
   2a5a6:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2a5aa:	ee07 2a90 	vmov	s15, r2
    _tSOLAD* w = *wp;
   2a5ae:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2a5b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
   2a5b4:	ed92 7a03 	vldr	s14, [r2, #12]
   2a5b8:	eef4 7ac7 	vcmpe.f32	s15, s14
   2a5bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a5c0:	d599      	bpl.n	2a4f6 <tAutotune_tick+0x102>
        w->jump = w->readlag - readlag;
   2a5c2:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
   2a5c6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
   2a5ca:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
   2a5ce:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
   2a5d2:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
   2a5d6:	61d3      	str	r3, [r2, #28]
   2a5d8:	6862      	ldr	r2, [r4, #4]
   2a5da:	e78c      	b.n	2a4f6 <tAutotune_tick+0x102>
            p->deltamax = envout - p->max;
   2a5dc:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
            p->max = p->max * ps->radius;
   2a5e0:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
   2a5e4:	ee67 6aa6 	vmul.f32	s13, s15, s13
   2a5e8:	ee36 7ae7 	vsub.f32	s14, s13, s15
   2a5ec:	edca 6a13 	vstr	s13, [sl, #76]	; 0x4c
   2a5f0:	e773      	b.n	2a4da <tAutotune_tick+0xe6>
   2a5f2:	bf00      	nop

0002a5f4 <tAutotune_setFreq>:
    r->freq[voice] = f;
   2a5f4:	6803      	ldr	r3, [r0, #0]
   2a5f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2a5f8:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2a5fc:	ed81 0a00 	vstr	s0, [r1]
}
   2a600:	4770      	bx	lr
   2a602:	bf00      	nop

0002a604 <tAutotune_setFidelityThreshold>:

void tAutotune_setFidelityThreshold(tAutotune* const rt, float threshold)
{
    _tAutotune* r = *rt;

    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
   2a604:	6800      	ldr	r0, [r0, #0]
   2a606:	3004      	adds	r0, #4
   2a608:	f7fd bdb6 	b.w	28178 <tPeriodDetection_setFidelityThreshold>

0002a60c <tFormantShifter_initToPool>:
{
    tFormantShifter_initToPool(fsr, order, &leaf.mempool);
}

void tFormantShifter_initToPool (tFormantShifter* const fsr, int order, tMempool* const mp)
{
   2a60c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2a610:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2a614:	6815      	ldr	r5, [r2, #0]
{
   2a616:	4688      	mov	r8, r1
   2a618:	4681      	mov	r9, r0
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
   2a61a:	2068      	movs	r0, #104	; 0x68
   2a61c:	4629      	mov	r1, r5
{
   2a61e:	4616      	mov	r6, r2
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
   2a620:	f002 fdf6 	bl	2d210 <mpool_alloc>
   2a624:	4604      	mov	r4, r0
   2a626:	f8c9 0000 	str.w	r0, [r9]
    fs->mempool = m;
    
    fs->ford = order;
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a62a:	4629      	mov	r1, r5
   2a62c:	ea4f 0088 	mov.w	r0, r8, lsl #2
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
    
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);

    
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a630:	f64f 0708 	movw	r7, #63496	; 0xf808
    fs->ford = order;
   2a634:	e9c4 5800 	strd	r5, r8, [r4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a638:	f002 fe40 	bl	2d2bc <mpool_calloc>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a63c:	6863      	ldr	r3, [r4, #4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a63e:	6120      	str	r0, [r4, #16]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a640:	4629      	mov	r1, r5
   2a642:	0098      	lsls	r0, r3, #2
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a644:	f2c0 270f 	movt	r7, #527	; 0x20f
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a648:	f002 fe38 	bl	2d2bc <mpool_calloc>
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a64c:	6863      	ldr	r3, [r4, #4]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a64e:	6160      	str	r0, [r4, #20]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a650:	4629      	mov	r1, r5
   2a652:	0098      	lsls	r0, r3, #2
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
    fs->fhp = 0.0f;
    fs->flp = 0.0f;
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
    fs->fmute = 1.0f;
   2a654:	f04f 587e 	mov.w	r8, #1065353216	; 0x3f800000
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a658:	f002 fe30 	bl	2d2bc <mpool_calloc>
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a65c:	6863      	ldr	r3, [r4, #4]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a65e:	61a0      	str	r0, [r4, #24]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a660:	4629      	mov	r1, r5
   2a662:	0098      	lsls	r0, r3, #2
   2a664:	f002 fe2a 	bl	2d2bc <mpool_calloc>
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a668:	6863      	ldr	r3, [r4, #4]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a66a:	61e0      	str	r0, [r4, #28]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a66c:	4629      	mov	r1, r5
   2a66e:	0098      	lsls	r0, r3, #2
   2a670:	f002 fe24 	bl	2d2bc <mpool_calloc>
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a674:	6863      	ldr	r3, [r4, #4]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a676:	6220      	str	r0, [r4, #32]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a678:	4629      	mov	r1, r5
   2a67a:	0098      	lsls	r0, r3, #2
   2a67c:	f002 fe1e 	bl	2d2bc <mpool_calloc>
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a680:	6863      	ldr	r3, [r4, #4]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a682:	6260      	str	r0, [r4, #36]	; 0x24
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a684:	4629      	mov	r1, r5
   2a686:	0098      	lsls	r0, r3, #2
   2a688:	f002 fe18 	bl	2d2bc <mpool_calloc>
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a68c:	6863      	ldr	r3, [r4, #4]
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a68e:	62a0      	str	r0, [r4, #40]	; 0x28
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a690:	4629      	mov	r1, r5
   2a692:	0098      	lsls	r0, r3, #2
   2a694:	f002 fe12 	bl	2d2bc <mpool_calloc>
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   2a698:	6863      	ldr	r3, [r4, #4]
   2a69a:	4629      	mov	r1, r5
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2a69c:	63e0      	str	r0, [r4, #60]	; 0x3c
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   2a69e:	0098      	lsls	r0, r3, #2
   2a6a0:	f002 fe0c 	bl	2d2bc <mpool_calloc>
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a6a4:	f241 236f 	movw	r3, #4719	; 0x126f
   2a6a8:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
   2a6ac:	ed97 9a01 	vldr	s18, [r7, #4]
   2a6b0:	f6c3 2383 	movt	r3, #14979	; 0x3a83
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   2a6b4:	63a0      	str	r0, [r4, #56]	; 0x38
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a6b6:	ee69 0a20 	vmul.f32	s1, s18, s1
   2a6ba:	ee00 3a10 	vmov	s0, r3
   2a6be:	ee08 3a10 	vmov	s16, r3
   2a6c2:	f006 f84d 	bl	30760 <powf>
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2a6c6:	f24d 13e1 	movw	r3, #53729	; 0xd1e1
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a6ca:	eef0 8a40 	vmov.f32	s17, s0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2a6ce:	ed97 0a00 	vldr	s0, [r7]
   2a6d2:	f6c3 5386 	movt	r3, #15750	; 0x3d86
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a6d6:	edc4 8a02 	vstr	s17, [r4, #8]
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2a6da:	ee07 3a90 	vmov	s15, r3
   2a6de:	ee20 0a27 	vmul.f32	s0, s0, s15
   2a6e2:	f005 fdbd 	bl	30260 <atanf>
   2a6e6:	eef1 6ac0 	vsqrt.f32	s13, s0
   2a6ea:	f640 1203 	movw	r2, #2307	; 0x903
   2a6ee:	f243 23ca 	movw	r3, #13002	; 0x32ca
    fs->fhp = 0.0f;
   2a6f2:	2100      	movs	r1, #0
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
   2a6f4:	edc4 8a0d 	vstr	s17, [r4, #52]	; 0x34
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2a6f8:	f6c3 725a 	movt	r2, #16218	; 0x3f5a
   2a6fc:	f6c3 6344 	movt	r3, #15940	; 0x3e44
    fs->fhp = 0.0f;
   2a700:	62e1      	str	r1, [r4, #44]	; 0x2c
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2a702:	ee07 2a10 	vmov	s14, r2
   2a706:	ee07 3a90 	vmov	s15, r3
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   2a70a:	eef0 0a49 	vmov.f32	s1, s18
    fs->flp = 0.0f;
   2a70e:	6321      	str	r1, [r4, #48]	; 0x30
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   2a710:	eeb0 0a48 	vmov.f32	s0, s16
    fs->fmute = 1.0f;
   2a714:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2a718:	eee6 7ac7 	vfms.f32	s15, s13, s14
   2a71c:	edc4 7a03 	vstr	s15, [r4, #12]
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   2a720:	f006 f81e 	bl	30760 <powf>
    fs->cbi = 0;
   2a724:	2300      	movs	r3, #0
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   2a726:	ed84 0a11 	vstr	s0, [r4, #68]	; 0x44
    fs->intensity = 1.0f;
    fs->invIntensity = 1.0f;
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   2a72a:	4631      	mov	r1, r6
    fs->cbi = 0;
   2a72c:	64a3      	str	r3, [r4, #72]	; 0x48
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   2a72e:	f104 0058 	add.w	r0, r4, #88	; 0x58
    fs->intensity = 1.0f;
   2a732:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   2a736:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
    fs->invIntensity = 1.0f;
   2a73a:	f8c4 8054 	str.w	r8, [r4, #84]	; 0x54
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   2a73e:	f001 f957 	bl	2b9f0 <tHighpass_initToPool>
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
   2a742:	4631      	mov	r1, r6
   2a744:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2a748:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2a74c:	f001 f950 	bl	2b9f0 <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
   2a750:	f24d 710a 	movw	r1, #55050	; 0xd70a
   2a754:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   2a758:	4632      	mov	r2, r6
   2a75a:	f6c3 31a3 	movt	r1, #15267	; 0x3ba3
   2a75e:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2a762:	f6c3 734c 	movt	r3, #16204	; 0x3f4c
   2a766:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
   2a76a:	ee08 1a90 	vmov	s17, r1
   2a76e:	2101      	movs	r1, #1
   2a770:	ee08 3a10 	vmov	s16, r3
   2a774:	ee00 3a10 	vmov	s0, r3
   2a778:	eef0 0a68 	vmov.f32	s1, s17
   2a77c:	f7fe fbcc 	bl	28f18 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
   2a780:	eef0 0a68 	vmov.f32	s1, s17
   2a784:	eeb0 0a48 	vmov.f32	s0, s16
   2a788:	4632      	mov	r2, r6
   2a78a:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2a78e:	2101      	movs	r1, #1
   2a790:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
}
   2a794:	ecbd 8b04 	vpop	{d8-d9}
   2a798:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
   2a79c:	f7fe bbbc 	b.w	28f18 <tFeedbackLeveler_initToPool>

0002a7a0 <tFormantShifter_free>:

void tFormantShifter_free (tFormantShifter* const fsr)
{
   2a7a0:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
   2a7a2:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)fs->fk, fs->mempool);
   2a7a4:	6821      	ldr	r1, [r4, #0]
   2a7a6:	6920      	ldr	r0, [r4, #16]
   2a7a8:	f002 fddc 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->fb, fs->mempool);
   2a7ac:	6821      	ldr	r1, [r4, #0]
   2a7ae:	6960      	ldr	r0, [r4, #20]
   2a7b0:	f002 fdd8 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->fc, fs->mempool);
   2a7b4:	6821      	ldr	r1, [r4, #0]
   2a7b6:	69a0      	ldr	r0, [r4, #24]
   2a7b8:	f002 fdd4 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->frb, fs->mempool);
   2a7bc:	6821      	ldr	r1, [r4, #0]
   2a7be:	69e0      	ldr	r0, [r4, #28]
   2a7c0:	f002 fdd0 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->frc, fs->mempool);
   2a7c4:	6821      	ldr	r1, [r4, #0]
   2a7c6:	6a20      	ldr	r0, [r4, #32]
   2a7c8:	f002 fdcc 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->fsig, fs->mempool);
   2a7cc:	6821      	ldr	r1, [r4, #0]
   2a7ce:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2a7d0:	f002 fdc8 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->fsmooth, fs->mempool);
   2a7d4:	6821      	ldr	r1, [r4, #0]
   2a7d6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2a7d8:	f002 fdc4 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->ftvec, fs->mempool);
   2a7dc:	6821      	ldr	r1, [r4, #0]
   2a7de:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   2a7e0:	f002 fdc0 	bl	2d364 <mpool_free>
    mpool_free((char*)fs->fbuff, fs->mempool);
   2a7e4:	6821      	ldr	r1, [r4, #0]
   2a7e6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   2a7e8:	f002 fdbc 	bl	2d364 <mpool_free>
    tHighpass_free(&fs->hp);
   2a7ec:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2a7f0:	f001 f920 	bl	2ba34 <tHighpass_free>
    tHighpass_free(&fs->hp2);
   2a7f4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2a7f8:	f001 f91c 	bl	2ba34 <tHighpass_free>
    tFeedbackLeveler_free(&fs->fbl1);
   2a7fc:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2a800:	f7fe fbb2 	bl	28f68 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&fs->fbl2);
   2a804:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2a808:	f7fe fbae 	bl	28f68 <tFeedbackLeveler_free>
    mpool_free((char*)fs, fs->mempool);
   2a80c:	6821      	ldr	r1, [r4, #0]
   2a80e:	4620      	mov	r0, r4
}
   2a810:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)fs, fs->mempool);
   2a814:	f002 bda6 	b.w	2d364 <mpool_free>

0002a818 <tFormantShifter_remove>:
{
    return tFormantShifter_add(fsr, tFormantShifter_remove(fsr, in));
}

float tFormantShifter_remove(tFormantShifter* const fsr, float in)
{
   2a818:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
   2a81a:	6804      	ldr	r4, [r0, #0]
    in = tFeedbackLeveler_tick(&fs->fbl1, in);
   2a81c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2a820:	f7fe fbb2 	bl	28f88 <tFeedbackLeveler_tick>
    in = tHighpass_tick(&fs->hp, in * fs->intensity);
   2a824:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
   2a828:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2a82c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2a830:	f001 f914 	bl	2ba5c <tHighpass_tick>
    

    float fa, fb, fc, foma, falph, ford, flamb, tf, fk;

    ford = fs->ford;
   2a834:	edd4 7a01 	vldr	s15, [r4, #4]
    falph = fs->falph;
    foma = (1.0f - falph);
   2a838:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    flamb = fs->flamb;
    
    tf = in;
    
    fa = tf - fs->fhp;
   2a83c:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c
    ford = fs->ford;
   2a840:	eef8 3ae7 	vcvt.f32.s32	s7, s15
    falph = fs->falph;
   2a844:	ed94 5a02 	vldr	s10, [r4, #8]
    fs->fhp = tf;
   2a848:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
    fa = tf - fs->fhp;
   2a84c:	ee70 6a66 	vsub.f32	s13, s0, s13
    foma = (1.0f - falph);
   2a850:	ee75 5ac5 	vsub.f32	s11, s11, s10
    flamb = fs->flamb;
   2a854:	edd4 2a03 	vldr	s5, [r4, #12]
    fb = fa;
    for(int i = 0; i < ford; i++)
   2a858:	eef5 3ac0 	vcmpe.f32	s7, #0.0
   2a85c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a860:	dd5a      	ble.n	2a918 <tFormantShifter_remove+0x100>
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
        fs->fc[i] = fc;
        fs->fb[i] = fb;
        fk = fa*fc*foma + fs->fk[i]*falph;
        fs->fk[i] = fk;
        tf = fk/(fs->fsig[i] + 0.000001f);
   2a862:	f243 73bd 	movw	r3, #14269	; 0x37bd
    fa = tf - fs->fhp;
   2a866:	eeb0 0a66 	vmov.f32	s0, s13
    for(int i = 0; i < ford; i++)
   2a86a:	2100      	movs	r1, #0
        tf = fk/(fs->fsig[i] + 0.000001f);
   2a86c:	f2c3 5386 	movt	r3, #13702	; 0x3586
   2a870:	ee03 3a10 	vmov	s6, r3
   2a874:	008b      	lsls	r3, r1, #2
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   2a876:	6a62      	ldr	r2, [r4, #36]	; 0x24
    for(int i = 0; i < ford; i++)
   2a878:	3101      	adds	r1, #1
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   2a87a:	ee20 7a00 	vmul.f32	s14, s0, s0
   2a87e:	441a      	add	r2, r3
        fk = fa*fc*foma + fs->fk[i]*falph;
   2a880:	ee25 6a80 	vmul.f32	s12, s11, s0
    for(int i = 0; i < ford; i++)
   2a884:	ee07 1a90 	vmov	s15, r1
   2a888:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   2a88c:	edd2 7a00 	vldr	s15, [r2]
   2a890:	ee65 7a27 	vmul.f32	s15, s10, s15
    for(int i = 0; i < ford; i++)
   2a894:	eef4 4ae3 	vcmpe.f32	s9, s7
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   2a898:	eee5 7a87 	vfma.f32	s15, s11, s14
    for(int i = 0; i < ford; i++)
   2a89c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   2a8a0:	edc2 7a00 	vstr	s15, [r2]
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
   2a8a4:	e9d4 0205 	ldrd	r0, r2, [r4, #20]
   2a8a8:	441a      	add	r2, r3
   2a8aa:	4418      	add	r0, r3
   2a8ac:	edd2 7a00 	vldr	s15, [r2]
   2a8b0:	ed90 7a00 	vldr	s14, [r0]
   2a8b4:	ee76 7ae7 	vsub.f32	s15, s13, s15
   2a8b8:	eea7 7aa2 	vfma.f32	s14, s15, s5
        fs->fc[i] = fc;
   2a8bc:	ed82 7a00 	vstr	s14, [r2]
        fs->fb[i] = fb;
   2a8c0:	6962      	ldr	r2, [r4, #20]
   2a8c2:	441a      	add	r2, r3
   2a8c4:	edc2 6a00 	vstr	s13, [r2]
        fk = fa*fc*foma + fs->fk[i]*falph;
   2a8c8:	6922      	ldr	r2, [r4, #16]
   2a8ca:	441a      	add	r2, r3
   2a8cc:	edd2 6a00 	vldr	s13, [r2]
   2a8d0:	ee65 6a26 	vmul.f32	s13, s10, s13
   2a8d4:	eee6 6a07 	vfma.f32	s13, s12, s14
        fs->fk[i] = fk;
   2a8d8:	edc2 6a00 	vstr	s13, [r2]
        tf = tf*foma + fs->fsmooth[i]*falph;
   2a8dc:	e9d4 0209 	ldrd	r0, r2, [r4, #36]	; 0x24
        tf = fk/(fs->fsig[i] + 0.000001f);
   2a8e0:	4418      	add	r0, r3
        tf = tf*foma + fs->fsmooth[i]*falph;
   2a8e2:	441a      	add	r2, r3
        tf = fk/(fs->fsig[i] + 0.000001f);
   2a8e4:	ed90 6a00 	vldr	s12, [r0]
        tf = tf*foma + fs->fsmooth[i]*falph;
   2a8e8:	edd2 7a00 	vldr	s15, [r2]
        tf = fk/(fs->fsig[i] + 0.000001f);
   2a8ec:	ee36 6a03 	vadd.f32	s12, s12, s6
        tf = tf*foma + fs->fsmooth[i]*falph;
   2a8f0:	ee65 7a27 	vmul.f32	s15, s10, s15
        tf = fk/(fs->fsig[i] + 0.000001f);
   2a8f4:	ee86 4a86 	vdiv.f32	s8, s13, s12
        fs->fsmooth[i] = tf;
        fs->fbuff[i] = tf;
        fb = fc - tf*fa;
   2a8f8:	eef0 6a47 	vmov.f32	s13, s14
        tf = tf*foma + fs->fsmooth[i]*falph;
   2a8fc:	eee5 7a84 	vfma.f32	s15, s11, s8
        fs->fsmooth[i] = tf;
   2a900:	edc2 7a00 	vstr	s15, [r2]
        fb = fc - tf*fa;
   2a904:	eee7 6ac0 	vfms.f32	s13, s15, s0
        fs->fbuff[i] = tf;
   2a908:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        fa = fa - tf*fc;
   2a90a:	eea7 0a67 	vfms.f32	s0, s14, s15
        fs->fbuff[i] = tf;
   2a90e:	4413      	add	r3, r2
   2a910:	edc3 7a00 	vstr	s15, [r3]
    for(int i = 0; i < ford; i++)
   2a914:	d4ae      	bmi.n	2a874 <tFormantShifter_remove+0x5c>
    }

    //return fa * 0.1f;
    return fa;
}
   2a916:	bd10      	pop	{r4, pc}
    fa = tf - fs->fhp;
   2a918:	eeb0 0a66 	vmov.f32	s0, s13
}
   2a91c:	bd10      	pop	{r4, pc}
   2a91e:	bf00      	nop

0002a920 <tFormantShifter_add>:

float tFormantShifter_add(tFormantShifter* const fsr, float in)
{
   2a920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a922:	ed2d 8b02 	vpush	{d8}
    _tFormantShifter* fs = *fsr;
   2a926:	6804      	ldr	r4, [r0, #0]
    float fa, fb, fc, ford, flpa, flamb, tf, tf2, f0resp, f1resp, frlamb;
    ford = fs->ford;

    flpa = fs->flpa;
    flamb = fs->flamb;
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   2a928:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    frlamb = (tf-1.0f)/(tf+1.0f);
    
    tf2 = in;
    fa = 0.0f;
    fb = fa;
   2a92c:	2300      	movs	r3, #0
    flamb = fs->flamb;
   2a92e:	edd4 7a03 	vldr	s15, [r4, #12]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   2a932:	ed94 5a13 	vldr	s10, [r4, #76]	; 0x4c
   2a936:	ee37 6a87 	vadd.f32	s12, s15, s14
    flpa = fs->flpa;
   2a93a:	ed94 3a0d 	vldr	s6, [r4, #52]	; 0x34
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   2a93e:	ee77 6a67 	vsub.f32	s13, s14, s15
    ford = fs->ford;
   2a942:	edd4 7a01 	vldr	s15, [r4, #4]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   2a946:	ee26 6a05 	vmul.f32	s12, s12, s10
    ford = fs->ford;
   2a94a:	eef8 5ae7 	vcvt.f32.s32	s11, s15
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   2a94e:	eec6 7a26 	vdiv.f32	s15, s12, s13
    for (int i=0; i<ford; i++)
   2a952:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2a956:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    frlamb = (tf-1.0f)/(tf+1.0f);
   2a95a:	ee77 6ac7 	vsub.f32	s13, s15, s14
   2a95e:	ee77 7a87 	vadd.f32	s15, s15, s14
   2a962:	ee86 5aa7 	vdiv.f32	s10, s13, s15
    for (int i=0; i<ford; i++)
   2a966:	f340 8109 	ble.w	2ab7c <tFormantShifter_add+0x25c>
   2a96a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2a96c:	4619      	mov	r1, r3
    fb = fa;
   2a96e:	ee06 3a90 	vmov	s13, r3
    fa = 0.0f;
   2a972:	ee07 3a90 	vmov	s15, r3
   2a976:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   2a978:	3101      	adds	r1, #1
   2a97a:	ee04 1a90 	vmov	s9, r1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
   2a97e:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2a980:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
   2a984:	eef8 4ae4 	vcvt.f32.s32	s9, s9
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2a988:	18c6      	adds	r6, r0, r3
   2a98a:	441d      	add	r5, r3
        tf = fs->fbuff[i];
   2a98c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2a98e:	ed96 6a00 	vldr	s12, [r6]
    for (int i=0; i<ford; i++)
   2a992:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2a996:	ed95 7a00 	vldr	s14, [r5]
        tf = fs->fbuff[i];
   2a99a:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2a99c:	ee76 6ac6 	vsub.f32	s13, s13, s12
        tf = fs->fbuff[i];
   2a9a0:	ed90 6a00 	vldr	s12, [r0]
    for (int i=0; i<ford; i++)
   2a9a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2a9a8:	eea6 7a85 	vfma.f32	s14, s13, s10
        fs->ftvec[i] = tf*fc;
   2a9ac:	ee27 4a06 	vmul.f32	s8, s14, s12
        fb = fc - tf*fa;
   2a9b0:	eea6 7a67 	vfms.f32	s14, s12, s15
        fs->ftvec[i] = tf*fc;
   2a9b4:	ed82 4a00 	vstr	s8, [r2]
        fa = fa - fs->ftvec[i];
   2a9b8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2a9ba:	4413      	add	r3, r2
        fb = fc - tf*fa;
   2a9bc:	eef0 6a47 	vmov.f32	s13, s14
        fa = fa - fs->ftvec[i];
   2a9c0:	ed93 7a00 	vldr	s14, [r3]
   2a9c4:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for (int i=0; i<ford; i++)
   2a9c8:	d4d5      	bmi.n	2a976 <tFormantShifter_add+0x56>
   2a9ca:	eeb1 7a67 	vneg.f32	s14, s15
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
   2a9ce:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2a9d2:	ee75 7ae7 	vsub.f32	s15, s11, s15
   2a9d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2a9da:	ee17 7a90 	vmov	r7, s15
   2a9de:	2f00      	cmp	r7, #0
   2a9e0:	f2c0 80c4 	blt.w	2ab6c <tFormantShifter_add+0x24c>
    {
        tf = tf + fs->ftvec[i];
   2a9e4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2a9e6:	1c7b      	adds	r3, r7, #1
   2a9e8:	eb02 0183 	add.w	r1, r2, r3, lsl #2
   2a9ec:	ed71 7a01 	vldmdb	r1!, {s15}
    for (int i=ford-1; i>=0; i--)
   2a9f0:	428a      	cmp	r2, r1
        tf = tf + fs->ftvec[i];
   2a9f2:	ee37 7a27 	vadd.f32	s14, s14, s15
    for (int i=ford-1; i>=0; i--)
   2a9f6:	d1f9      	bne.n	2a9ec <tFormantShifter_add+0xcc>
    f0resp = tf;
    
    //  second time: compute 1-response
    fa = 1.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
   2a9f8:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2a9fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2aa00:	f340 80c1 	ble.w	2ab86 <tFormantShifter_add+0x266>
    fb = fa;
   2aa04:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    for (int i=0; i<ford; i++)
   2aa08:	2100      	movs	r1, #0
    fa = 1.0f;
   2aa0a:	eef0 7a46 	vmov.f32	s15, s12
   2aa0e:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   2aa10:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aa12:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
   2aa16:	ee04 1a10 	vmov	s8, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
   2aa1a:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aa1c:	18c6      	adds	r6, r0, r3
   2aa1e:	441d      	add	r5, r3
        tf = fs->fbuff[i];
   2aa20:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
   2aa22:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aa26:	edd6 4a00 	vldr	s9, [r6]
   2aa2a:	edd5 6a00 	vldr	s13, [r5]
        tf = fs->fbuff[i];
   2aa2e:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aa30:	ee36 6a64 	vsub.f32	s12, s12, s9
        tf = fs->fbuff[i];
   2aa34:	edd0 4a00 	vldr	s9, [r0]
    for (int i=0; i<ford; i++)
   2aa38:	eeb4 4ae5 	vcmpe.f32	s8, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aa3c:	eee6 6a05 	vfma.f32	s13, s12, s10
    for (int i=0; i<ford; i++)
   2aa40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
   2aa44:	ee66 3aa4 	vmul.f32	s7, s13, s9
        fb = fc - tf*fa;
   2aa48:	eee4 6ae7 	vfms.f32	s13, s9, s15
        fs->ftvec[i] = tf*fc;
   2aa4c:	edc2 3a00 	vstr	s7, [r2]
        fa = fa - fs->ftvec[i];
   2aa50:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2aa52:	4413      	add	r3, r2
        fb = fc - tf*fa;
   2aa54:	eeb0 6a66 	vmov.f32	s12, s13
        fa = fa - fs->ftvec[i];
   2aa58:	edd3 6a00 	vldr	s13, [r3]
   2aa5c:	ee77 7ae6 	vsub.f32	s15, s15, s13
    for (int i=0; i<ford; i++)
   2aa60:	d4d5      	bmi.n	2aa0e <tFormantShifter_add+0xee>
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
   2aa62:	2f00      	cmp	r7, #0
   2aa64:	eef1 7a67 	vneg.f32	s15, s15
   2aa68:	db08      	blt.n	2aa7c <tFormantShifter_add+0x15c>
   2aa6a:	1c7b      	adds	r3, r7, #1
   2aa6c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    {
        tf = tf + fs->ftvec[i];
   2aa70:	ed73 6a01 	vldmdb	r3!, {s13}
    for (int i=ford-1; i>=0; i--)
   2aa74:	429a      	cmp	r2, r3
        tf = tf + fs->ftvec[i];
   2aa76:	ee77 7aa6 	vadd.f32	s15, s15, s13
    for (int i=ford-1; i>=0; i--)
   2aa7a:	d1f9      	bne.n	2aa70 <tFormantShifter_add+0x150>
    f1resp = tf;
    
    //  now solve equations for output, based on 0-response and 1-response
    tf = 2.0f*tf2;
    tf2 = tf;
    tf = (1.0f - f1resp + f0resp);
   2aa7c:	ee77 7a67 	vsub.f32	s15, s14, s15
    if (tf!=0.0f)
   2aa80:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2aa84:	eef4 7a66 	vcmp.f32	s15, s13
   2aa88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2aa8c:	d066      	beq.n	2ab5c <tFormantShifter_add+0x23c>
    {
        tf2 = (tf2 + f0resp) / tf;
   2aa8e:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
    tf = (1.0f - f1resp + f0resp);
   2aa92:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
        tf2 = (tf2 + f0resp) / tf;
   2aa96:	eea0 7a06 	vfma.f32	s14, s0, s12
    tf = (1.0f - f1resp + f0resp);
   2aa9a:	ee77 7aa6 	vadd.f32	s15, s15, s13
        tf2 = (tf2 + f0resp) / tf;
   2aa9e:	ee87 0a27 	vdiv.f32	s0, s14, s15
    }
    
    //  third time: update delay registers
    fa = tf2;
    fb = fa;
    for (int i=0; i<ford; i++)
   2aaa2:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2aaa6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2aaaa:	dd2b      	ble.n	2ab04 <tFormantShifter_add+0x1e4>
    fb = fa;
   2aaac:	eeb0 6a40 	vmov.f32	s12, s0
    for (int i=0; i<ford; i++)
   2aab0:	2100      	movs	r1, #0
    fa = tf2;
   2aab2:	eef0 6a40 	vmov.f32	s13, s0
   2aab6:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   2aab8:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aaba:	e9d4 0207 	ldrd	r0, r2, [r4, #28]
    for (int i=0; i<ford; i++)
   2aabe:	ee07 1a90 	vmov	s15, r1
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aac2:	441a      	add	r2, r3
   2aac4:	4418      	add	r0, r3
    for (int i=0; i<ford; i++)
   2aac6:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aaca:	ed92 7a00 	vldr	s14, [r2]
   2aace:	edd0 7a00 	vldr	s15, [r0]
   2aad2:	ee36 7a47 	vsub.f32	s14, s12, s14
    for (int i=0; i<ford; i++)
   2aad6:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2aada:	eee7 7a05 	vfma.f32	s15, s14, s10
    for (int i=0; i<ford; i++)
   2aade:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->frc[i] = fc;
   2aae2:	edc2 7a00 	vstr	s15, [r2]
        fs->frb[i] = fb;
   2aae6:	69e2      	ldr	r2, [r4, #28]
   2aae8:	441a      	add	r2, r3
   2aaea:	ed82 6a00 	vstr	s12, [r2]
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
   2aaee:	eeb0 6a67 	vmov.f32	s12, s15
        tf = fs->fbuff[i];
   2aaf2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   2aaf4:	4413      	add	r3, r2
   2aaf6:	ed93 7a00 	vldr	s14, [r3]
        fb = fc - tf*fa;
   2aafa:	eea7 6a66 	vfms.f32	s12, s14, s13
        fa = fa - tf*fc;
   2aafe:	eee7 6ac7 	vfms.f32	s13, s15, s14
    for (int i=0; i<ford; i++)
   2ab02:	d4d8      	bmi.n	2aab6 <tFormantShifter_add+0x196>
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
    fs->flp = tf;
    
    // Bring up the gain slowly when formant correction goes from disabled
    // to enabled, while things stabilize.
    if (fs->fmute>0.5f)
   2ab04:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
   2ab08:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
   2ab0c:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
   2ab10:	eea7 0a03 	vfma.f32	s0, s14, s6
    if (fs->fmute>0.5f)
   2ab14:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2ab18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    fs->flp = tf;
   2ab1c:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
   2ab20:	dd20      	ble.n	2ab64 <tFormantShifter_add+0x244>
    {
        tf = tf*(fs->fmute - 0.5f)*2.0f;
   2ab22:	ee78 7a67 	vsub.f32	s15, s16, s15
   2ab26:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2ab2a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ab2e:	f005 ff7d 	bl	30a2c <tanhf>
    else
    {
        tf = 0.0f;
    }
    tf2 = fs->fmutealph;
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
   2ab32:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2ab36:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
    // now tf is signal output
    // ...and we're done messing with formants
    //tf = tFeedbackLeveler_tick(&fs->fbl2, tf);
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
   2ab3a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
   2ab3e:	ee38 8a67 	vsub.f32	s16, s16, s15
   2ab42:	eee8 7a07 	vfma.f32	s15, s16, s14
   2ab46:	edc4 7a10 	vstr	s15, [r4, #64]	; 0x40
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
   2ab4a:	f000 ff87 	bl	2ba5c <tHighpass_tick>

    return tf * fs->invIntensity;
   2ab4e:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
}
   2ab52:	ecbd 8b02 	vpop	{d8}
    return tf * fs->invIntensity;
   2ab56:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   2ab5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tf2 = 0.0f;
   2ab5c:	2300      	movs	r3, #0
   2ab5e:	ee00 3a10 	vmov	s0, r3
   2ab62:	e79e      	b.n	2aaa2 <tFormantShifter_add+0x182>
   2ab64:	2300      	movs	r3, #0
   2ab66:	ee00 3a10 	vmov	s0, r3
   2ab6a:	e7e2      	b.n	2ab32 <tFormantShifter_add+0x212>
    for (int i=0; i<ford; i++)
   2ab6c:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2ab70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ab74:	dc05      	bgt.n	2ab82 <tFormantShifter_add+0x262>
   2ab76:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   2ab7a:	e77f      	b.n	2aa7c <tFormantShifter_add+0x15c>
    for (int i=0; i<ford; i++)
   2ab7c:	ee07 3a10 	vmov	s14, r3
   2ab80:	e725      	b.n	2a9ce <tFormantShifter_add+0xae>
   2ab82:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2ab84:	e73e      	b.n	2aa04 <tFormantShifter_add+0xe4>
    for (int i=0; i<ford; i++)
   2ab86:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   2ab8a:	e76f      	b.n	2aa6c <tFormantShifter_add+0x14c>

0002ab8c <tFormantShifter_setShiftFactor>:

// 1.0f is no change, 2.0f is an octave up, 0.5f is an octave down
void tFormantShifter_setShiftFactor(tFormantShifter* const fsr, float shiftFactor)
{
    _tFormantShifter* fs = *fsr;
   2ab8c:	6803      	ldr	r3, [r0, #0]
    fs->shiftFactor = shiftFactor;
   2ab8e:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
   2ab92:	4770      	bx	lr

0002ab94 <tFormantShifter_setIntensity>:
{
    _tFormantShifter* fs = *fsr;



    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   2ab94:	2300      	movs	r3, #0
   2ab96:	eef0 0a40 	vmov.f32	s1, s0
   2ab9a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2ab9e:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
{
   2aba2:	b510      	push	{r4, lr}
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   2aba4:	ee01 3a10 	vmov	s2, r3
    _tFormantShifter* fs = *fsr;
   2aba8:	6804      	ldr	r4, [r0, #0]
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   2abaa:	f002 f919 	bl	2cde0 <LEAF_clip>

   // tFeedbackLeveler_setTargetLevel(&fs->fbl1, fs->intensity);
    //tFeedbackLeveler_setTargetLevel(&fs->fbl2, fs->intensity);
    //make sure you don't divide by zero, doofies
    if (fs->intensity != 0.0f)
   2abae:	eeb5 0a40 	vcmp.f32	s0, #0.0
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   2abb2:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
    if (fs->intensity != 0.0f)
   2abb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2abba:	d104      	bne.n	2abc6 <tFormantShifter_setIntensity+0x32>
    {
    	fs->invIntensity = 1.0f/fs->intensity;
    }
    else
    {
    	fs->invIntensity = 1.0f;
   2abbc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2abc0:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
    }

}
   2abc4:	bd10      	pop	{r4, pc}
    	fs->invIntensity = 1.0f/fs->intensity;
   2abc6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2abca:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2abce:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
   2abd2:	bd10      	pop	{r4, pc}

0002abd4 <tADSR4_initToPool>:
}

//initialize with an exponential function that decays -- i.e. a call to LEAF_generate_exp(expBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, EXP_BUFFER_SIZE);
//times are in ms
void    tADSR4_initToPool    (tADSR4* const adsrenv, float attack, float decay, float sustain, float release, float* expBuffer, int bufferSize, tMempool* const mp)
{
   2abd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2abd6:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2abda:	681d      	ldr	r5, [r3, #0]
{
   2abdc:	4607      	mov	r7, r0
   2abde:	460e      	mov	r6, r1
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   2abe0:	2050      	movs	r0, #80	; 0x50
   2abe2:	4629      	mov	r1, r5
{
   2abe4:	4614      	mov	r4, r2
   2abe6:	eef0 8a61 	vmov.f32	s17, s3
   2abea:	eef0 9a40 	vmov.f32	s19, s0
   2abee:	eeb0 9a60 	vmov.f32	s18, s1
   2abf2:	eeb0 8a41 	vmov.f32	s16, s2
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   2abf6:	f002 fb0b 	bl	2d210 <mpool_alloc>

    adsr->exp_buff = expBuffer;
    adsr->buff_size = bufferSize;
    adsr->buff_sizeMinusOne = bufferSize - 1;

    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2abfa:	f64f 0208 	movw	r2, #63496	; 0xf808
   2abfe:	f241 216f 	movw	r1, #4719	; 0x126f
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   2ac02:	6038      	str	r0, [r7, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2ac04:	ee07 4a90 	vmov	s15, r4
   2ac08:	f2c0 220f 	movt	r2, #527	; 0x20f
   2ac0c:	f6c3 2183 	movt	r1, #14979	; 0x3a83
    adsr->mempool = m;
   2ac10:	6005      	str	r5, [r0, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2ac12:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
   2ac16:	ed92 6a00 	vldr	s12, [r2]
   2ac1a:	ee06 1a90 	vmov	s13, r1
   2ac1e:	2300      	movs	r3, #0
    adsr->sustain = sustain;

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   2ac20:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2ac24:	ee66 6a26 	vmul.f32	s13, s12, s13
    adsr->buff_sizeMinusOne = bufferSize - 1;
   2ac28:	1e62      	subs	r2, r4, #1
    adsr->sustain = sustain;
   2ac2a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2ac2e:	ee07 3a10 	vmov	s14, r3
    adsr->exp_buff = expBuffer;
   2ac32:	6046      	str	r6, [r0, #4]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2ac34:	eec5 7a26 	vdiv.f32	s15, s10, s13
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   2ac38:	fec9 9a87 	vmaxnm.f32	s19, s19, s14
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   2ac3c:	fe89 9a07 	vmaxnm.f32	s18, s18, s14
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   2ac40:	fec8 1a87 	vmaxnm.f32	s3, s17, s14
   2ac44:	fe88 8a07 	vmaxnm.f32	s16, s16, s14

    adsr->leakFactor = 1.0f;
   2ac48:	ed80 6a13 	vstr	s12, [r0, #76]	; 0x4c
    adsr->sustain = sustain;
   2ac4c:	fe88 8a46 	vminnm.f32	s16, s16, s12
    adsr->buff_size = bufferSize;
   2ac50:	6084      	str	r4, [r0, #8]
    adsr->buff_sizeMinusOne = bufferSize - 1;
   2ac52:	60c2      	str	r2, [r0, #12]
    adsr->whichStage = env_idle;
   2ac54:	6283      	str	r3, [r0, #40]	; 0x28
    adsr->next = 0.0f;
   2ac56:	6143      	str	r3, [r0, #20]
    adsr->sustain = sustain;
   2ac58:	ed80 8a0b 	vstr	s16, [r0, #44]	; 0x2c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   2ac5c:	ee87 6aa9 	vdiv.f32	s12, s15, s19
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2ac60:	edc0 7a04 	vstr	s15, [r0, #16]
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   2ac64:	eec7 6a89 	vdiv.f32	s13, s15, s18
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   2ac68:	ee87 7aa1 	vdiv.f32	s14, s15, s3
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   2ac6c:	ee67 7aa5 	vmul.f32	s15, s15, s11
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   2ac70:	ed80 6a06 	vstr	s12, [r0, #24]
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   2ac74:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   2ac78:	edc0 6a07 	vstr	s13, [r0, #28]
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   2ac7c:	ed80 7a08 	vstr	s14, [r0, #32]
}
   2ac80:	ecbd 8b04 	vpop	{d8-d9}
   2ac84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2ac86:	bf00      	nop

0002ac88 <tADSR4_free>:

void    tADSR4_free  (tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   2ac88:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)adsr, adsr->mempool);
   2ac8a:	6801      	ldr	r1, [r0, #0]
   2ac8c:	f002 bb6a 	b.w	2d364 <mpool_free>

0002ac90 <tADSR4_setAttack>:
}

void     tADSR4_setAttack(tADSR4* const adsrenv, float attack)
{
    _tADSR4* adsr = *adsrenv;
   2ac90:	6802      	ldr	r2, [r0, #0]
    if (attack < 0.0f)
    {
        attack = 0.0f;
    }

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   2ac92:	2300      	movs	r3, #0
   2ac94:	ed92 7a04 	vldr	s14, [r2, #16]
   2ac98:	ee07 3a90 	vmov	s15, r3
   2ac9c:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   2aca0:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2aca4:	edc2 7a06 	vstr	s15, [r2, #24]
}
   2aca8:	4770      	bx	lr
   2acaa:	bf00      	nop

0002acac <tADSR4_setDecay>:

void     tADSR4_setDecay(tADSR4* const adsrenv, float decay)
{
    _tADSR4* adsr = *adsrenv;
   2acac:	6802      	ldr	r2, [r0, #0]

    if (decay < 0.0f)
    {
        decay = 0.0f;
    }
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   2acae:	2300      	movs	r3, #0
   2acb0:	ed92 7a04 	vldr	s14, [r2, #16]
   2acb4:	ee07 3a90 	vmov	s15, r3
   2acb8:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   2acbc:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2acc0:	edc2 7a07 	vstr	s15, [r2, #28]
}
   2acc4:	4770      	bx	lr
   2acc6:	bf00      	nop

0002acc8 <tADSR4_setSustain>:

void     tADSR4_setSustain(tADSR4* const adsrenv, float sustain)
{
    _tADSR4* adsr = *adsrenv;

    if (sustain > 1.0f)      adsr->sustain = 1.0f;
   2acc8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tADSR4* adsr = *adsrenv;
   2accc:	6803      	ldr	r3, [r0, #0]
    if (sustain > 1.0f)      adsr->sustain = 1.0f;
   2acce:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2acd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2acd6:	dd02      	ble.n	2acde <tADSR4_setSustain+0x16>
   2acd8:	edc3 7a0b 	vstr	s15, [r3, #44]	; 0x2c
   2acdc:	4770      	bx	lr
    else if (sustain < 0.0f) adsr->sustain = 0.0f;
   2acde:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2ace2:	2200      	movs	r2, #0
   2ace4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ace8:	bf4c      	ite	mi
   2acea:	62da      	strmi	r2, [r3, #44]	; 0x2c
    else                     adsr->sustain = sustain;
   2acec:	ed83 0a0b 	vstrpl	s0, [r3, #44]	; 0x2c
}
   2acf0:	4770      	bx	lr
   2acf2:	bf00      	nop

0002acf4 <tADSR4_setRelease>:

void     tADSR4_setRelease(tADSR4* const adsrenv, float release)
{
    _tADSR4* adsr = *adsrenv;
   2acf4:	6802      	ldr	r2, [r0, #0]

    if (release < 0.0f)
    {
        release = 0.0f;
    }
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   2acf6:	2300      	movs	r3, #0
   2acf8:	ed92 7a04 	vldr	s14, [r2, #16]
   2acfc:	ee07 3a90 	vmov	s15, r3
   2ad00:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   2ad04:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2ad08:	edc2 7a08 	vstr	s15, [r2, #32]
}
   2ad0c:	4770      	bx	lr
   2ad0e:	bf00      	nop

0002ad10 <tADSR4_setLeakFactor>:

// 0.999999 is slow leak, 0.9 is fast leak
void     tADSR4_setLeakFactor(tADSR4* const adsrenv, float leakFactor)
{
    _tADSR4* adsr = *adsrenv;
   2ad10:	6803      	ldr	r3, [r0, #0]


    adsr->leakFactor = leakFactor;
   2ad12:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
   2ad16:	4770      	bx	lr

0002ad18 <tADSR4_on>:

void tADSR4_on(tADSR4* const adsrenv, float velocity)
{
    _tADSR4* adsr = *adsrenv;
   2ad18:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage != env_idle) // In case ADSR retriggered while it is still happening.
   2ad1a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2ad1c:	b942      	cbnz	r2, 2ad30 <tADSR4_on+0x18>
        adsr->whichStage = env_ramp;
        adsr->rampPeak = adsr->next;
    }
    else // Normal start.
    {
        adsr->whichStage = env_attack;
   2ad1e:	2101      	movs	r1, #1
    }

    adsr->attackPhase = 0;
   2ad20:	2200      	movs	r2, #0
   2ad22:	6299      	str	r1, [r3, #40]	; 0x28
    adsr->decayPhase = 0;
    adsr->releasePhase = 0;
    adsr->gain = velocity;
   2ad24:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
    adsr->attackPhase = 0;
   2ad28:	63da      	str	r2, [r3, #60]	; 0x3c
    adsr->decayPhase = 0;
   2ad2a:	641a      	str	r2, [r3, #64]	; 0x40
    adsr->releasePhase = 0;
   2ad2c:	645a      	str	r2, [r3, #68]	; 0x44
}
   2ad2e:	4770      	bx	lr
        adsr->rampPhase = 0;
   2ad30:	2200      	movs	r2, #0
        adsr->rampPeak = adsr->next;
   2ad32:	6958      	ldr	r0, [r3, #20]
        adsr->whichStage = env_ramp;
   2ad34:	2105      	movs	r1, #5
        adsr->rampPeak = adsr->next;
   2ad36:	6358      	str	r0, [r3, #52]	; 0x34
        adsr->rampPhase = 0;
   2ad38:	649a      	str	r2, [r3, #72]	; 0x48
   2ad3a:	e7f1      	b.n	2ad20 <tADSR4_on+0x8>

0002ad3c <tADSR4_off>:

void tADSR4_off(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   2ad3c:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage == env_idle)
   2ad3e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2ad40:	b11a      	cbz	r2, 2ad4a <tADSR4_off+0xe>
    {
        return;
    }
    else
    {
        adsr->whichStage = env_release;
   2ad42:	2104      	movs	r1, #4
        adsr->releasePeak = adsr->next;
   2ad44:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_release;
   2ad46:	6299      	str	r1, [r3, #40]	; 0x28
        adsr->releasePeak = adsr->next;
   2ad48:	639a      	str	r2, [r3, #56]	; 0x38
    }
}
   2ad4a:	4770      	bx	lr

0002ad4c <tADSR4_tick>:

float   tADSR4_tick(tADSR4* const adsrenv)
{
   2ad4c:	b510      	push	{r4, lr}
    _tADSR4* adsr = *adsrenv;
   2ad4e:	6804      	ldr	r4, [r0, #0]
{
   2ad50:	ed2d 8b02 	vpush	{d8}

    switch (adsr->whichStage)
   2ad54:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2ad56:	3b01      	subs	r3, #1
   2ad58:	2b04      	cmp	r3, #4
   2ad5a:	f200 8087 	bhi.w	2ae6c <tADSR4_tick+0x120>
   2ad5e:	e8df f003 	tbb	[pc, r3]
   2ad62:	4920      	.short	0x4920
   2ad64:	693c      	.short	0x693c
   2ad66:	03          	.byte	0x03
   2ad67:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
   2ad68:	edd4 7a03 	vldr	s15, [r4, #12]
   2ad6c:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
   2ad70:	eef8 7a67 	vcvt.f32.u32	s15, s15
   2ad74:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2ad78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ad7c:	f340 80de 	ble.w	2af3c <tADSR4_tick+0x1f0>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
   2ad80:	2300      	movs	r3, #0
                adsr->whichStage = env_attack;
   2ad82:	2201      	movs	r2, #1
                adsr->next = 0.0f;
   2ad84:	ee08 3a10 	vmov	s16, r3
                adsr->whichStage = env_attack;
   2ad88:	62a2      	str	r2, [r4, #40]	; 0x28
                adsr->next = 0.0f;
   2ad8a:	6163      	str	r3, [r4, #20]
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
                }
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
            }

            adsr->rampPhase += adsr->rampInc;
   2ad8c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
            break;
    }
    return adsr->next;
}
   2ad90:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->rampPhase += adsr->rampInc;
   2ad94:	ee37 1a81 	vadd.f32	s2, s15, s2
   2ad98:	ed84 1a12 	vstr	s2, [r4, #72]	; 0x48
}
   2ad9c:	ecbd 8b02 	vpop	{d8}
   2ada0:	bd10      	pop	{r4, pc}
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
   2ada2:	edd4 7a03 	vldr	s15, [r4, #12]
   2ada6:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
   2adaa:	eef8 7a67 	vcvt.f32.u32	s15, s15
   2adae:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
   2adb2:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2adb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2adba:	dd5e      	ble.n	2ae7a <tADSR4_tick+0x12e>
                adsr->whichStage = env_decay;
   2adbc:	2302      	movs	r3, #2
                adsr->next = adsr->gain;
   2adbe:	ed84 8a05 	vstr	s16, [r4, #20]
                adsr->whichStage = env_decay;
   2adc2:	62a3      	str	r3, [r4, #40]	; 0x28
            adsr->attackPhase += adsr->attackInc;
   2adc4:	edd4 7a06 	vldr	s15, [r4, #24]
}
   2adc8:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->attackPhase += adsr->attackInc;
   2adcc:	ee37 1a81 	vadd.f32	s2, s15, s2
   2add0:	ed84 1a0f 	vstr	s2, [r4, #60]	; 0x3c
}
   2add4:	ecbd 8b02 	vpop	{d8}
   2add8:	bd10      	pop	{r4, pc}
            adsr->next = adsr->next * adsr->leakFactor;
   2adda:	ed94 8a05 	vldr	s16, [r4, #20]
   2adde:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2ade2:	ee28 8a27 	vmul.f32	s16, s16, s15
}
   2ade6:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->next = adsr->next * adsr->leakFactor;
   2adea:	ed84 8a05 	vstr	s16, [r4, #20]
}
   2adee:	ecbd 8b02 	vpop	{d8}
   2adf2:	bd10      	pop	{r4, pc}
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
   2adf4:	edd4 7a03 	vldr	s15, [r4, #12]
   2adf8:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
   2adfc:	eef8 7a67 	vcvt.f32.u32	s15, s15
   2ae00:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2ae04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ae08:	dd63      	ble.n	2aed2 <tADSR4_tick+0x186>
                adsr->next = adsr->gain * adsr->sustain;
   2ae0a:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
                adsr->whichStage = env_sustain;
   2ae0e:	2303      	movs	r3, #3
                adsr->next = adsr->gain * adsr->sustain;
   2ae10:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
                adsr->whichStage = env_sustain;
   2ae14:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = adsr->gain * adsr->sustain;
   2ae16:	ee28 8a27 	vmul.f32	s16, s16, s15
   2ae1a:	ed84 8a05 	vstr	s16, [r4, #20]
            adsr->decayPhase += adsr->decayInc;
   2ae1e:	edd4 7a07 	vldr	s15, [r4, #28]
}
   2ae22:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->decayPhase += adsr->decayInc;
   2ae26:	ee37 1a81 	vadd.f32	s2, s15, s2
   2ae2a:	ed84 1a10 	vstr	s2, [r4, #64]	; 0x40
}
   2ae2e:	ecbd 8b02 	vpop	{d8}
   2ae32:	bd10      	pop	{r4, pc}
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
   2ae34:	edd4 7a03 	vldr	s15, [r4, #12]
   2ae38:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
   2ae3c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   2ae40:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2ae44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ae48:	f340 80a1 	ble.w	2af8e <tADSR4_tick+0x242>
                adsr->next = 0.0f;
   2ae4c:	2300      	movs	r3, #0
   2ae4e:	ee08 3a10 	vmov	s16, r3
                adsr->whichStage = env_idle;
   2ae52:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
   2ae54:	6163      	str	r3, [r4, #20]
            adsr->releasePhase += adsr->releaseInc;
   2ae56:	edd4 7a08 	vldr	s15, [r4, #32]
}
   2ae5a:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->releasePhase += adsr->releaseInc;
   2ae5e:	ee37 1a81 	vadd.f32	s2, s15, s2
   2ae62:	ed84 1a11 	vstr	s2, [r4, #68]	; 0x44
}
   2ae66:	ecbd 8b02 	vpop	{d8}
   2ae6a:	bd10      	pop	{r4, pc}
   2ae6c:	ed94 8a05 	vldr	s16, [r4, #20]
   2ae70:	eeb0 0a48 	vmov.f32	s0, s16
   2ae74:	ecbd 8b02 	vpop	{d8}
   2ae78:	bd10      	pop	{r4, pc}
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   2ae7a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2ae7e:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->attackPhase;
   2ae80:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   2ae84:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->attackPhase - intPart;
   2ae88:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   2ae8c:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->attackPhase - intPart;
   2ae90:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   2ae94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ae98:	f100 80ae 	bmi.w	2aff8 <tADSR4_tick+0x2ac>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->attackPhase)+1)];
   2ae9c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2aea0:	ee17 3a90 	vmov	r3, s15
   2aea4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2aea8:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->gain * (1.0f - LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // inverted and backwards to get proper rising exponential shape/perception
   2aeac:	ee16 3a90 	vmov	r3, s13
   2aeb0:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   2aeb4:	ed92 0a00 	vldr	s0, [r2]
   2aeb8:	f002 f8ce 	bl	2d058 <LEAF_interpolation_linear>
   2aebc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2aec0:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
   2aec4:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2aec8:	ee28 8a00 	vmul.f32	s16, s16, s0
   2aecc:	ed84 8a05 	vstr	s16, [r4, #20]
   2aed0:	e778      	b.n	2adc4 <tADSR4_tick+0x78>
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   2aed2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2aed6:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->decayPhase;
   2aed8:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   2aedc:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->decayPhase - intPart;
   2aee0:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   2aee4:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->decayPhase - intPart;
   2aee8:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   2aeec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2aef0:	d47e      	bmi.n	2aff0 <tADSR4_tick+0x2a4>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->decayPhase)+1)];
   2aef2:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2aef6:	ee17 3a90 	vmov	r3, s15
   2aefa:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2aefe:	edd3 0a00 	vldr	s1, [r3]
                float interpValue = (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart));
   2af02:	ee16 3a90 	vmov	r3, s13
   2af06:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   2af0a:	ed92 0a00 	vldr	s0, [r2]
   2af0e:	f002 f8a3 	bl	2d058 <LEAF_interpolation_linear>
                adsr->next = (adsr->gain * (adsr->sustain + (interpValue * (1.0f - adsr->sustain)))) * adsr->leakFactor; // do interpolation !
   2af12:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2af16:	ed94 8a0b 	vldr	s16, [r4, #44]	; 0x2c
   2af1a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2af1e:	ee37 7a48 	vsub.f32	s14, s14, s16
   2af22:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
   2af26:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
   2af2a:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2af2e:	eea7 8a00 	vfma.f32	s16, s14, s0
   2af32:	ee27 8a88 	vmul.f32	s16, s15, s16
   2af36:	ed84 8a05 	vstr	s16, [r4, #20]
   2af3a:	e770      	b.n	2ae1e <tADSR4_tick+0xd2>
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   2af3c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2af40:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->rampPhase;
   2af42:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   2af46:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->rampPhase - intPart;
   2af4a:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   2af4e:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->rampPhase - intPart;
   2af52:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   2af56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2af5a:	d445      	bmi.n	2afe8 <tADSR4_tick+0x29c>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
   2af5c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2af60:	ee17 3a90 	vmov	r3, s15
   2af64:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2af68:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
   2af6c:	ee16 3a90 	vmov	r3, s13
   2af70:	ed94 8a0d 	vldr	s16, [r4, #52]	; 0x34
   2af74:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   2af78:	ed92 0a00 	vldr	s0, [r2]
   2af7c:	f002 f86c 	bl	2d058 <LEAF_interpolation_linear>
   2af80:	ee28 8a00 	vmul.f32	s16, s16, s0
   2af84:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
   2af88:	ed84 8a05 	vstr	s16, [r4, #20]
   2af8c:	e6fe      	b.n	2ad8c <tADSR4_tick+0x40>
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   2af8e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2af92:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->releasePhase;
   2af94:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   2af98:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->releasePhase - intPart;
   2af9c:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   2afa0:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->releasePhase - intPart;
   2afa4:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   2afa8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2afac:	d418      	bmi.n	2afe0 <tADSR4_tick+0x294>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->releasePhase)+1)];
   2afae:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2afb2:	ee17 3a90 	vmov	r3, s15
   2afb6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2afba:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->releasePeak * (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // do interpolation !
   2afbe:	ee16 3a90 	vmov	r3, s13
   2afc2:	ed94 8a0e 	vldr	s16, [r4, #56]	; 0x38
   2afc6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   2afca:	ed92 0a00 	vldr	s0, [r2]
   2afce:	f002 f843 	bl	2d058 <LEAF_interpolation_linear>
   2afd2:	ee28 8a00 	vmul.f32	s16, s16, s0
   2afd6:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
   2afda:	ed84 8a05 	vstr	s16, [r4, #20]
   2afde:	e73a      	b.n	2ae56 <tADSR4_tick+0x10a>
                    secondValue = 0.0f;
   2afe0:	2300      	movs	r3, #0
   2afe2:	ee00 3a90 	vmov	s1, r3
   2afe6:	e7ea      	b.n	2afbe <tADSR4_tick+0x272>
                    secondValue = 0.0f;
   2afe8:	2300      	movs	r3, #0
   2afea:	ee00 3a90 	vmov	s1, r3
   2afee:	e7bd      	b.n	2af6c <tADSR4_tick+0x220>
                    secondValue = 0.0f;
   2aff0:	2300      	movs	r3, #0
   2aff2:	ee00 3a90 	vmov	s1, r3
   2aff6:	e784      	b.n	2af02 <tADSR4_tick+0x1b6>
                    secondValue = 0.0f;
   2aff8:	2300      	movs	r3, #0
   2affa:	ee00 3a90 	vmov	s1, r3
   2affe:	e755      	b.n	2aeac <tADSR4_tick+0x160>

0002b000 <tADSR4_tickNoInterp>:

float   tADSR4_tickNoInterp(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   2b000:	6803      	ldr	r3, [r0, #0]

    switch (adsr->whichStage)
   2b002:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2b004:	3a01      	subs	r2, #1
   2b006:	2a04      	cmp	r2, #4
   2b008:	d873      	bhi.n	2b0f2 <tADSR4_tickNoInterp+0xf2>
   2b00a:	e8df f002 	tbb	[pc, r2]
   2b00e:	3e1d      	.short	0x3e1d
   2b010:	5a35      	.short	0x5a35
   2b012:	03          	.byte	0x03
   2b013:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
   2b014:	edd3 7a03 	vldr	s15, [r3, #12]
   2b018:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
   2b01c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   2b020:	eef4 6ac7 	vcmpe.f32	s13, s14
   2b024:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b028:	f340 808c 	ble.w	2b144 <tADSR4_tickNoInterp+0x144>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
   2b02c:	2200      	movs	r2, #0
                adsr->whichStage = env_attack;
   2b02e:	2101      	movs	r1, #1
                adsr->next = 0.0f;
   2b030:	ee00 2a10 	vmov	s0, r2
                adsr->whichStage = env_attack;
   2b034:	6299      	str	r1, [r3, #40]	; 0x28
            else
            {
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
            }

            adsr->rampPhase += adsr->rampInc;
   2b036:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
   2b03a:	ed83 0a05 	vstr	s0, [r3, #20]
   2b03e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2b042:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
            break;
   2b046:	4770      	bx	lr


        case env_attack:

            // If attack done, time to turn around.
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
   2b048:	edd3 7a03 	vldr	s15, [r3, #12]
   2b04c:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
   2b050:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   2b054:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
   2b058:	eef4 6ac7 	vcmpe.f32	s13, s14
   2b05c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b060:	dd4a      	ble.n	2b0f8 <tADSR4_tickNoInterp+0xf8>
            {
                adsr->whichStage = env_decay;
   2b062:	2202      	movs	r2, #2
   2b064:	629a      	str	r2, [r3, #40]	; 0x28
            {
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
            }

            // Increment ADSR attack.
            adsr->attackPhase += adsr->attackInc;
   2b066:	edd3 7a06 	vldr	s15, [r3, #24]
   2b06a:	ed83 0a05 	vstr	s0, [r3, #20]
   2b06e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2b072:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
            break;
   2b076:	4770      	bx	lr
            // Increment ADSR decay.
            adsr->decayPhase += adsr->decayInc;
            break;

        case env_sustain:
            adsr->next = adsr->next * adsr->leakFactor;
   2b078:	ed93 0a05 	vldr	s0, [r3, #20]
   2b07c:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
   2b080:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b084:	ed83 0a05 	vstr	s0, [r3, #20]
            break;
   2b088:	4770      	bx	lr
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
   2b08a:	edd3 7a03 	vldr	s15, [r3, #12]
   2b08e:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
   2b092:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   2b096:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
   2b09a:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
   2b09e:	eef4 6ac7 	vcmpe.f32	s13, s14
   2b0a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b0a6:	dd37      	ble.n	2b118 <tADSR4_tickNoInterp+0x118>
                adsr->next = adsr->gain * adsr->sustain;
   2b0a8:	ee20 0a27 	vmul.f32	s0, s0, s15
                adsr->whichStage = env_sustain;
   2b0ac:	2203      	movs	r2, #3
   2b0ae:	629a      	str	r2, [r3, #40]	; 0x28
            adsr->decayPhase += adsr->decayInc;
   2b0b0:	edd3 7a07 	vldr	s15, [r3, #28]
   2b0b4:	ed83 0a05 	vstr	s0, [r3, #20]
   2b0b8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2b0bc:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
            break;
   2b0c0:	4770      	bx	lr

        case env_release:
            // If release done, finish.
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
   2b0c2:	edd3 7a03 	vldr	s15, [r3, #12]
   2b0c6:	edd3 6a11 	vldr	s13, [r3, #68]	; 0x44
   2b0ca:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   2b0ce:	eef4 6ac7 	vcmpe.f32	s13, s14
   2b0d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b0d6:	dd43      	ble.n	2b160 <tADSR4_tickNoInterp+0x160>
            {
                adsr->whichStage = env_idle;
   2b0d8:	2100      	movs	r1, #0
                adsr->next = 0.0f;
   2b0da:	ee00 1a10 	vmov	s0, r1
                adsr->whichStage = env_idle;
   2b0de:	6299      	str	r1, [r3, #40]	; 0x28
            else {
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
            }

            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
   2b0e0:	edd3 7a08 	vldr	s15, [r3, #32]
   2b0e4:	ed83 0a05 	vstr	s0, [r3, #20]
   2b0e8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2b0ec:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
            break;
    }
    return adsr->next;
}
   2b0f0:	4770      	bx	lr
   2b0f2:	ed93 0a05 	vldr	s0, [r3, #20]
   2b0f6:	4770      	bx	lr
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
   2b0f8:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   2b0fc:	685a      	ldr	r2, [r3, #4]
   2b0fe:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2b102:	ee17 1a10 	vmov	r1, s14
   2b106:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2b10a:	ed92 7a00 	vldr	s14, [r2]
   2b10e:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b112:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b116:	e7a6      	b.n	2b066 <tADSR4_tickNoInterp+0x66>
                adsr->next = (adsr->gain * (adsr->sustain + (adsr->exp_buff[(uint32_t)adsr->decayPhase] * (1.0f - adsr->sustain)))) * adsr->leakFactor;
   2b118:	eefc 5ae6 	vcvt.u32.f32	s11, s13
   2b11c:	685a      	ldr	r2, [r3, #4]
   2b11e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2b122:	ed93 6a13 	vldr	s12, [r3, #76]	; 0x4c
   2b126:	ee15 1a90 	vmov	r1, s11
   2b12a:	ee67 7a86 	vmul.f32	s15, s15, s12
   2b12e:	ee37 7a40 	vsub.f32	s14, s14, s0
   2b132:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2b136:	ed92 6a00 	vldr	s12, [r2]
   2b13a:	eea6 0a07 	vfma.f32	s0, s12, s14
   2b13e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b142:	e7b5      	b.n	2b0b0 <tADSR4_tickNoInterp+0xb0>
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
   2b144:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   2b148:	685a      	ldr	r2, [r3, #4]
   2b14a:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
   2b14e:	ee17 1a10 	vmov	r1, s14
   2b152:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2b156:	ed92 0a00 	vldr	s0, [r2]
   2b15a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b15e:	e76a      	b.n	2b036 <tADSR4_tickNoInterp+0x36>
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
   2b160:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   2b164:	685a      	ldr	r2, [r3, #4]
   2b166:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
   2b16a:	ee17 1a10 	vmov	r1, s14
   2b16e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2b172:	ed92 0a00 	vldr	s0, [r2]
   2b176:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b17a:	e7b1      	b.n	2b0e0 <tADSR4_tickNoInterp+0xe0>

0002b17c <tRamp_init>:


/////-----------------
/* Ramp */
void    tRamp_init(tRamp* const r, float time, int samples_per_tick)
{
   2b17c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tRamp_initToPool(r, time, samples_per_tick, &leaf.mempool);
}

void    tRamp_initToPool    (tRamp* const r, float time, int samples_per_tick, tMempool* const mp)
{
    _tMempool* m = *mp;
   2b17e:	f64f 0408 	movw	r4, #63496	; 0xf808
{
   2b182:	460d      	mov	r5, r1
   2b184:	4607      	mov	r7, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b186:	2024      	movs	r0, #36	; 0x24
    _tMempool* m = *mp;
   2b188:	f2c0 240f 	movt	r4, #527	; 0x20f
   2b18c:	69a6      	ldr	r6, [r4, #24]
{
   2b18e:	ed2d 8b02 	vpush	{d8}
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b192:	4631      	mov	r1, r6
{
   2b194:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b198:	f002 f83a 	bl	2d210 <mpool_alloc>
    ramp->mempool = m;
    
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b19c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b1a0:	6038      	str	r0, [r7, #0]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b1a2:	ee07 5a90 	vmov	s15, r5
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b1a6:	f2c4 4279 	movt	r2, #17529	; 0x4479
    ramp->mempool = m;
   2b1aa:	6006      	str	r6, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b1ac:	ed94 6a00 	vldr	s12, [r4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b1b0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b1b4:	ee07 2a10 	vmov	s14, r2
    ramp->curr = 0.0f;
   2b1b8:	2300      	movs	r3, #0
    }
    else
    {
        ramp->time = time;
    }
    ramp->samples_per_tick = samples_per_tick;
   2b1ba:	6205      	str	r5, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b1bc:	eec7 6a06 	vdiv.f32	s13, s14, s12
    ramp->curr = 0.0f;
   2b1c0:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
   2b1c2:	6143      	str	r3, [r0, #20]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
   2b1c4:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b1c6:	ee67 7aa6 	vmul.f32	s15, s15, s13
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b1ca:	edc0 6a02 	vstr	s13, [r0, #8]
   2b1ce:	fe88 0a27 	vmaxnm.f32	s0, s16, s15
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   2b1d2:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2b1d6:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b1da:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   2b1de:	ed80 7a07 	vstr	s14, [r0, #28]
}
   2b1e2:	ecbd 8b02 	vpop	{d8}
   2b1e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002b1e8 <tRamp_initToPool>:
{
   2b1e8:	b570      	push	{r4, r5, r6, lr}
   2b1ea:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b1ee:	6815      	ldr	r5, [r2, #0]
{
   2b1f0:	460c      	mov	r4, r1
   2b1f2:	4606      	mov	r6, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b1f4:	2024      	movs	r0, #36	; 0x24
   2b1f6:	4629      	mov	r1, r5
{
   2b1f8:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b1fc:	f002 f808 	bl	2d210 <mpool_alloc>
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b200:	f64f 0108 	movw	r1, #63496	; 0xf808
   2b204:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   2b208:	6030      	str	r0, [r6, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b20a:	f2c0 210f 	movt	r1, #527	; 0x20f
    ramp->mempool = m;
   2b20e:	6005      	str	r5, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b210:	f2c4 4279 	movt	r2, #17529	; 0x4479
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b214:	ee07 4a90 	vmov	s15, r4
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b218:	ed91 6a00 	vldr	s12, [r1]
    ramp->curr = 0.0f;
   2b21c:	2300      	movs	r3, #0
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b21e:	ee07 2a10 	vmov	s14, r2
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b222:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->samples_per_tick = samples_per_tick;
   2b226:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b228:	eec7 6a06 	vdiv.f32	s13, s14, s12
    ramp->curr = 0.0f;
   2b22c:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
   2b22e:	6143      	str	r3, [r0, #20]
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
   2b230:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b232:	ee67 7aa6 	vmul.f32	s15, s15, s13
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   2b236:	edc0 6a02 	vstr	s13, [r0, #8]
   2b23a:	fe87 0a88 	vmaxnm.f32	s0, s15, s16
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   2b23e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2b242:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   2b246:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   2b24a:	ed80 7a07 	vstr	s14, [r0, #28]
}
   2b24e:	ecbd 8b02 	vpop	{d8}
   2b252:	bd70      	pop	{r4, r5, r6, pc}

0002b254 <tRamp_free>:

void    tRamp_free (tRamp* const r)
{
    _tRamp* ramp = *r;
   2b254:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)ramp, ramp->mempool);
   2b256:	6801      	ldr	r1, [r0, #0]
   2b258:	f002 b884 	b.w	2d364 <mpool_free>

0002b25c <tRamp_setDest>:

}

void     tRamp_setDest(tRamp* const ramp, float dest)
{
    _tRamp* r = *ramp;
   2b25c:	6803      	ldr	r3, [r0, #0]
    r->dest = dest;
    r->inc = (r->dest - r->curr) * r->factor;
   2b25e:	edd3 7a04 	vldr	s15, [r3, #16]
   2b262:	ed93 7a07 	vldr	s14, [r3, #28]
   2b266:	ee70 7a67 	vsub.f32	s15, s0, s15
    r->dest = dest;
   2b26a:	ed83 0a05 	vstr	s0, [r3, #20]
    r->inc = (r->dest - r->curr) * r->factor;
   2b26e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2b272:	edc3 7a01 	vstr	s15, [r3, #4]
}
   2b276:	4770      	bx	lr

0002b278 <tRamp_setVal>:

void     tRamp_setVal(tRamp* const ramp, float val)
{
    _tRamp* r = *ramp;
   2b278:	6803      	ldr	r3, [r0, #0]
    r->curr = val;
    r->inc = (r->dest - r->curr) * r->factor;
   2b27a:	edd3 7a05 	vldr	s15, [r3, #20]
   2b27e:	ed93 7a07 	vldr	s14, [r3, #28]
   2b282:	ee77 7ac0 	vsub.f32	s15, s15, s0
    r->curr = val;
   2b286:	ed83 0a04 	vstr	s0, [r3, #16]
    r->inc = (r->dest - r->curr) * r->factor;
   2b28a:	ee67 7a87 	vmul.f32	s15, s15, s14
   2b28e:	edc3 7a01 	vstr	s15, [r3, #4]
}
   2b292:	4770      	bx	lr

0002b294 <tRamp_tick>:

float   tRamp_tick(tRamp* const ramp)
{
    _tRamp* r = *ramp;
   2b294:	6803      	ldr	r3, [r0, #0]
    
    r->curr += r->inc;
   2b296:	edd3 7a01 	vldr	s15, [r3, #4]
   2b29a:	ed93 0a04 	vldr	s0, [r3, #16]
    
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   2b29e:	eef5 7a40 	vcmp.f32	s15, #0.0
   2b2a2:	ed93 7a05 	vldr	s14, [r3, #20]
    r->curr += r->inc;
   2b2a6:	ee37 0a80 	vadd.f32	s0, s15, s0
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   2b2aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    r->curr += r->inc;
   2b2ae:	ed83 0a04 	vstr	s0, [r3, #16]
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   2b2b2:	dd04      	ble.n	2b2be <tRamp_tick+0x2a>
   2b2b4:	eeb4 0ac7 	vcmpe.f32	s0, s14
   2b2b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b2bc:	da0a      	bge.n	2b2d4 <tRamp_tick+0x40>
   2b2be:	eef5 7a40 	vcmp.f32	s15, #0.0
   2b2c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b2c6:	d504      	bpl.n	2b2d2 <tRamp_tick+0x3e>
   2b2c8:	eeb4 0a47 	vcmp.f32	s0, s14
   2b2cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b2d0:	d900      	bls.n	2b2d4 <tRamp_tick+0x40>
		r->inc = 0.0f;
		r->curr=r->dest;
	}
    
    return r->curr;
}
   2b2d2:	4770      	bx	lr
		r->inc = 0.0f;
   2b2d4:	2200      	movs	r2, #0
		r->curr=r->dest;
   2b2d6:	eeb0 0a47 	vmov.f32	s0, s14
   2b2da:	ed83 7a04 	vstr	s14, [r3, #16]
		r->inc = 0.0f;
   2b2de:	605a      	str	r2, [r3, #4]
}
   2b2e0:	4770      	bx	lr
   2b2e2:	bf00      	nop

0002b2e4 <tRamp_sample>:

float   tRamp_sample(tRamp* const ramp)
{
    _tRamp* r = *ramp;
    return r->curr;
   2b2e4:	6803      	ldr	r3, [r0, #0]
}
   2b2e6:	ed93 0a04 	vldr	s0, [r3, #16]
   2b2ea:	4770      	bx	lr

0002b2ec <tExpSmooth_init>:



/* Exponential Smoother */
void    tExpSmooth_init(tExpSmooth* const expsmooth, float val, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   2b2ec:	b538      	push	{r3, r4, r5, lr}
    tExpSmooth_initToPool(expsmooth, val, factor, &leaf.mempool);
}

void    tExpSmooth_initToPool   (tExpSmooth* const expsmooth, float val, float factor, tMempool* const mp)
{
    _tMempool* m = *mp;
   2b2ee:	f64f 0308 	movw	r3, #63496	; 0xf808
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   2b2f2:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   2b2f4:	2014      	movs	r0, #20
    _tMempool* m = *mp;
   2b2f6:	f2c0 230f 	movt	r3, #527	; 0x20f
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   2b2fa:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b2fe:	699c      	ldr	r4, [r3, #24]
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   2b300:	eef0 8a40 	vmov.f32	s17, s0
   2b304:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   2b308:	4621      	mov	r1, r4
   2b30a:	f001 ff81 	bl	2d210 <mpool_alloc>
   2b30e:	2300      	movs	r3, #0
   2b310:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2b314:	6028      	str	r0, [r5, #0]
   2b316:	ee07 3a10 	vmov	s14, r3
    smooth->mempool = m;
   2b31a:	6004      	str	r4, [r0, #0]
    
    smooth->curr=val;
   2b31c:	edc0 8a03 	vstr	s17, [r0, #12]
   2b320:	fec8 0a67 	vminnm.f32	s1, s16, s15
   2b324:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->dest=val;
    if (factor<0) factor=0;
    if (factor>1) factor=1;
    smooth->factor=factor;
    smooth->oneminusfactor=1.0f-factor;
   2b328:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->dest=val;
   2b32c:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
   2b330:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
   2b334:	edc0 7a02 	vstr	s15, [r0, #8]
}
   2b338:	ecbd 8b02 	vpop	{d8}
   2b33c:	bd38      	pop	{r3, r4, r5, pc}
   2b33e:	bf00      	nop

0002b340 <tExpSmooth_initToPool>:
{
   2b340:	b538      	push	{r3, r4, r5, lr}
   2b342:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b346:	680c      	ldr	r4, [r1, #0]
{
   2b348:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   2b34a:	2014      	movs	r0, #20
{
   2b34c:	eef0 8a40 	vmov.f32	s17, s0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   2b350:	4621      	mov	r1, r4
{
   2b352:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   2b356:	f001 ff5b 	bl	2d210 <mpool_alloc>
   2b35a:	2300      	movs	r3, #0
   2b35c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2b360:	6028      	str	r0, [r5, #0]
   2b362:	ee07 3a10 	vmov	s14, r3
    smooth->mempool = m;
   2b366:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
   2b368:	edc0 8a03 	vstr	s17, [r0, #12]
   2b36c:	fec8 0a67 	vminnm.f32	s1, s16, s15
   2b370:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->oneminusfactor=1.0f-factor;
   2b374:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->dest=val;
   2b378:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
   2b37c:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
   2b380:	edc0 7a02 	vstr	s15, [r0, #8]
}
   2b384:	ecbd 8b02 	vpop	{d8}
   2b388:	bd38      	pop	{r3, r4, r5, pc}
   2b38a:	bf00      	nop

0002b38c <tExpSmooth_free>:

void    tExpSmooth_free (tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
   2b38c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)smooth, smooth->mempool);
   2b38e:	6801      	ldr	r1, [r0, #0]
   2b390:	f001 bfe8 	b.w	2d364 <mpool_free>

0002b394 <tExpSmooth_setFactor>:
}

void     tExpSmooth_setFactor(tExpSmooth* const expsmooth, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   2b394:	2300      	movs	r3, #0
   2b396:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tExpSmooth* smooth = *expsmooth;
   2b39a:	6802      	ldr	r2, [r0, #0]
   2b39c:	ee07 3a10 	vmov	s14, r3
   2b3a0:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2b3a4:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
	if (factor<0)
		factor=0;
	else
		if (factor>1) factor=1;
	smooth->factor=factor;
	smooth->oneminusfactor=1.0f-factor;
   2b3a8:	ee77 7ac0 	vsub.f32	s15, s15, s0
	smooth->factor=factor;
   2b3ac:	ed82 0a01 	vstr	s0, [r2, #4]
	smooth->oneminusfactor=1.0f-factor;
   2b3b0:	edc2 7a02 	vstr	s15, [r2, #8]
}
   2b3b4:	4770      	bx	lr
   2b3b6:	bf00      	nop

0002b3b8 <tExpSmooth_setDest>:

void     tExpSmooth_setDest(tExpSmooth* const expsmooth, float dest)
{
    _tExpSmooth* smooth = *expsmooth;
   2b3b8:	6803      	ldr	r3, [r0, #0]
	smooth->dest=dest;
   2b3ba:	ed83 0a04 	vstr	s0, [r3, #16]
}
   2b3be:	4770      	bx	lr

0002b3c0 <tExpSmooth_setValAndDest>:
	smooth->curr=val;
}

void     tExpSmooth_setValAndDest(tExpSmooth* const expsmooth, float val)
{
    _tExpSmooth* smooth = *expsmooth;
   2b3c0:	6803      	ldr	r3, [r0, #0]
	smooth->curr=val;
   2b3c2:	ed83 0a03 	vstr	s0, [r3, #12]
	smooth->dest=val;
   2b3c6:	ed83 0a04 	vstr	s0, [r3, #16]
}
   2b3ca:	4770      	bx	lr

0002b3cc <tExpSmooth_tick>:

float   tExpSmooth_tick(tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
   2b3cc:	6803      	ldr	r3, [r0, #0]
    smooth->curr = smooth->factor*smooth->dest+smooth->oneminusfactor*smooth->curr;
   2b3ce:	edd3 7a03 	vldr	s15, [r3, #12]
   2b3d2:	ed93 0a02 	vldr	s0, [r3, #8]
   2b3d6:	ed93 7a01 	vldr	s14, [r3, #4]
   2b3da:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b3de:	edd3 7a04 	vldr	s15, [r3, #16]
   2b3e2:	eea7 0a27 	vfma.f32	s0, s14, s15
   2b3e6:	ed83 0a03 	vstr	s0, [r3, #12]
    return smooth->curr;
}
   2b3ea:	4770      	bx	lr

0002b3ec <tSlide_initToPool>:
{
	tSlide_initToPool    (sl, upSlide, downSlide, &leaf.mempool);
}

void    tSlide_initToPool    (tSlide* const sl, float upSlide, float downSlide, tMempool* const mp)
{
   2b3ec:	b538      	push	{r3, r4, r5, lr}
   2b3ee:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b3f2:	680c      	ldr	r4, [r1, #0]
{
   2b3f4:	4605      	mov	r5, r0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   2b3f6:	201c      	movs	r0, #28
{
   2b3f8:	eeb0 8a60 	vmov.f32	s16, s1
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   2b3fc:	4621      	mov	r1, r4
{
   2b3fe:	eef0 8a40 	vmov.f32	s17, s0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   2b402:	f001 ff05 	bl	2d210 <mpool_alloc>

    if (downSlide < 1.0f)
    {
    	downSlide = 1.0f;
    }
    s->invUpSlide = 1.0f / upSlide;
   2b406:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    s->prevIn = 0.0f;
   2b40a:	2300      	movs	r3, #0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   2b40c:	6028      	str	r0, [r5, #0]
    s->mempool = m;
   2b40e:	6004      	str	r4, [r0, #0]
    s->invUpSlide = 1.0f / upSlide;
   2b410:	fec8 8aa7 	vmaxnm.f32	s17, s17, s15
    s->invDownSlide = 1.0f / downSlide;
   2b414:	fec8 0a27 	vmaxnm.f32	s1, s16, s15
    s->invUpSlide = 1.0f / upSlide;
   2b418:	eec7 6aa8 	vdiv.f32	s13, s15, s17
    s->prevIn = 0.0f;
   2b41c:	60c3      	str	r3, [r0, #12]
    s->currentOut = 0.0f;
   2b41e:	6083      	str	r3, [r0, #8]
    s->prevOut = 0.0f;
   2b420:	6043      	str	r3, [r0, #4]
    s->dest = 0.0f;
   2b422:	6183      	str	r3, [r0, #24]
    s->invDownSlide = 1.0f / downSlide;
   2b424:	ee87 7aa0 	vdiv.f32	s14, s15, s1
    s->invUpSlide = 1.0f / upSlide;
   2b428:	edc0 6a04 	vstr	s13, [r0, #16]
    s->invDownSlide = 1.0f / downSlide;
   2b42c:	ed80 7a05 	vstr	s14, [r0, #20]
}
   2b430:	ecbd 8b02 	vpop	{d8}
   2b434:	bd38      	pop	{r3, r4, r5, pc}
   2b436:	bf00      	nop

0002b438 <tSlide_free>:

void    tSlide_free  (tSlide* const sl)
{
    _tSlide* s = *sl;
   2b438:	6800      	ldr	r0, [r0, #0]

    mpool_free((char*)s, s->mempool);
   2b43a:	6801      	ldr	r1, [r0, #0]
   2b43c:	f001 bf92 	b.w	2d364 <mpool_free>

0002b440 <tSlide_setDownSlide>:
}

void tSlide_setDownSlide(tSlide* const sl, float downSlide)
{
	_tSlide* s = *sl;
	s->invDownSlide = 1.0f / downSlide;
   2b440:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	_tSlide* s = *sl;
   2b444:	6803      	ldr	r3, [r0, #0]
	s->invDownSlide = 1.0f / downSlide;
   2b446:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2b44a:	ed83 0a05 	vstr	s0, [r3, #20]
}
   2b44e:	4770      	bx	lr

0002b450 <tSlide_setDest>:

void tSlide_setDest(tSlide* const sl, float dest)
{
	_tSlide* s = *sl;
   2b450:	6803      	ldr	r3, [r0, #0]
	s->dest = dest;
   2b452:	ed83 0a06 	vstr	s0, [r3, #24]
}
   2b456:	4770      	bx	lr

0002b458 <tSlide_tickNoInput>:

float tSlide_tickNoInput(tSlide* const sl)
{
	_tSlide* s = *sl;
   2b458:	6803      	ldr	r3, [r0, #0]
	{
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
	}
#ifdef NO_DENORMAL_CHECK
#else
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   2b45a:	f24e 32ee 	movw	r2, #58350	; 0xe3ee
	if (in >= s->prevOut)
   2b45e:	edd3 7a01 	vldr	s15, [r3, #4]
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   2b462:	f2c0 026c 	movt	r2, #108	; 0x6c
	float in = s->dest;
   2b466:	edd3 6a06 	vldr	s13, [r3, #24]
	if (in >= s->prevOut)
   2b46a:	eef4 7ae6 	vcmpe.f32	s15, s13
   2b46e:	ee36 7ae7 	vsub.f32	s14, s13, s15
   2b472:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invUpSlide);
   2b476:	bf94      	ite	ls
   2b478:	ed93 6a04 	vldrls	s12, [r3, #16]
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
   2b47c:	ed93 6a05 	vldrhi	s12, [r3, #20]
   2b480:	eee6 7a07 	vfma.f32	s15, s12, s14
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   2b484:	ee07 2a10 	vmov	s14, r2
   2b488:	eef4 7ac7 	vcmpe.f32	s15, s14
   2b48c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b490:	d50a      	bpl.n	2b4a8 <tSlide_tickNoInput+0x50>
   2b492:	2200      	movs	r2, #0
#endif
	s->prevIn = in;
   2b494:	edc3 6a03 	vstr	s13, [r3, #12]
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   2b498:	ee07 2a90 	vmov	s15, r2
   2b49c:	609a      	str	r2, [r3, #8]
	s->prevOut = s->currentOut;
	return s->currentOut;
}
   2b49e:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevOut = s->currentOut;
   2b4a2:	edc3 7a01 	vstr	s15, [r3, #4]
}
   2b4a6:	4770      	bx	lr
   2b4a8:	edc3 7a02 	vstr	s15, [r3, #8]
   2b4ac:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevIn = in;
   2b4b0:	edc3 6a03 	vstr	s13, [r3, #12]
	s->prevOut = s->currentOut;
   2b4b4:	edc3 7a01 	vstr	s15, [r3, #4]
}
   2b4b8:	4770      	bx	lr
   2b4ba:	bf00      	nop

0002b4bc <tAllpass_initToPool>:
{
    tAllpass_initToPool(ft, initDelay, maxDelay, &leaf.mempool);
}

void    tAllpass_initToPool     (tAllpass* const ft, float initDelay, uint32_t maxDelay, tMempool* const mp)
{
   2b4bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b4c0:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b4c4:	6814      	ldr	r4, [r2, #0]
{
   2b4c6:	4680      	mov	r8, r0
   2b4c8:	460f      	mov	r7, r1
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   2b4ca:	2010      	movs	r0, #16
   2b4cc:	4621      	mov	r1, r4
{
   2b4ce:	4616      	mov	r6, r2
   2b4d0:	eeb0 8a40 	vmov.f32	s16, s0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   2b4d4:	f001 fe9c 	bl	2d210 <mpool_alloc>
   2b4d8:	4603      	mov	r3, r0
    f->mempool = m;
    
    f->gain = 0.7f;
   2b4da:	f243 3033 	movw	r0, #13107	; 0x3333
    
    f->lastOut = 0.0f;
   2b4de:	2500      	movs	r5, #0
    
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   2b4e0:	4632      	mov	r2, r6
    f->gain = 0.7f;
   2b4e2:	f6c3 7033 	movt	r0, #16179	; 0x3f33
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   2b4e6:	f8c8 3000 	str.w	r3, [r8]
    f->mempool = m;
   2b4ea:	601c      	str	r4, [r3, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   2b4ec:	eeb0 0a48 	vmov.f32	s0, s16
    f->gain = 0.7f;
   2b4f0:	4604      	mov	r4, r0
    f->lastOut = 0.0f;
   2b4f2:	60dd      	str	r5, [r3, #12]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   2b4f4:	4639      	mov	r1, r7
   2b4f6:	f103 0008 	add.w	r0, r3, #8
    f->gain = 0.7f;
   2b4fa:	605c      	str	r4, [r3, #4]
}
   2b4fc:	ecbd 8b02 	vpop	{d8}
   2b500:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   2b504:	f7fc be3c 	b.w	28180 <tLinearDelay_initToPool>

0002b508 <tAllpass_free>:

void    tAllpass_free  (tAllpass* const ft)
{
   2b508:	b510      	push	{r4, lr}
    _tAllpass* f = *ft;
   2b50a:	6804      	ldr	r4, [r0, #0]
    
    tLinearDelay_free(&f->delay);
   2b50c:	f104 0008 	add.w	r0, r4, #8
   2b510:	f7fc fea6 	bl	28260 <tLinearDelay_free>
    mpool_free((char*)f, f->mempool);
   2b514:	6821      	ldr	r1, [r4, #0]
   2b516:	4620      	mov	r0, r4
}
   2b518:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)f, f->mempool);
   2b51c:	f001 bf22 	b.w	2d364 <mpool_free>

0002b520 <tAllpass_setDelay>:

void    tAllpass_setDelay(tAllpass* const ft, float delay)
{
    _tAllpass* f = *ft;
    
    tLinearDelay_setDelay(&f->delay, delay);
   2b520:	6800      	ldr	r0, [r0, #0]
   2b522:	3008      	adds	r0, #8
   2b524:	f7fc bf2e 	b.w	28384 <tLinearDelay_setDelay>

0002b528 <tAllpass_setGain>:
}

void    tAllpass_setGain(tAllpass* const ft, float gain)
{
    _tAllpass* f = *ft;
   2b528:	6803      	ldr	r3, [r0, #0]
    
    f->gain = gain;
   2b52a:	ed83 0a01 	vstr	s0, [r3, #4]
}
   2b52e:	4770      	bx	lr

0002b530 <tAllpass_tick>:

float   tAllpass_tick(tAllpass* const ft, float input)
{
   2b530:	b510      	push	{r4, lr}
   2b532:	ed2d 8b02 	vpush	{d8}
    _tAllpass* f = *ft;
   2b536:	6804      	ldr	r4, [r0, #0]
{
   2b538:	eeb0 8a40 	vmov.f32	s16, s0
    
    float s1 = (-f->gain) * f->lastOut + input;
    
    float s2 = tLinearDelay_tick(&f->delay, s1) + (f->gain) * input;
   2b53c:	edd4 7a03 	vldr	s15, [r4, #12]
   2b540:	f104 0008 	add.w	r0, r4, #8
   2b544:	ed94 7a01 	vldr	s14, [r4, #4]
   2b548:	eea7 0a67 	vfms.f32	s0, s14, s15
   2b54c:	f7fc fea2 	bl	28294 <tLinearDelay_tick>
   2b550:	edd4 7a01 	vldr	s15, [r4, #4]
   2b554:	eea7 0a88 	vfma.f32	s0, s15, s16
    
    f->lastOut = s2;
   2b558:	ed84 0a03 	vstr	s0, [r4, #12]
    
    return f->lastOut;
}
   2b55c:	ecbd 8b02 	vpop	{d8}
   2b560:	bd10      	pop	{r4, pc}
   2b562:	bf00      	nop

0002b564 <tOnePole_initToPool>:
{
    tOnePole_initToPool(ft, freq, &leaf.mempool);
}

void    tOnePole_initToPool     (tOnePole* const ft, float freq, tMempool* const mp)
{
   2b564:	b570      	push	{r4, r5, r6, lr}
   2b566:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2b56a:	680e      	ldr	r6, [r1, #0]
{
   2b56c:	4605      	mov	r5, r0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2b56e:	2020      	movs	r0, #32
{
   2b570:	eeb0 9a40 	vmov.f32	s18, s0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2b574:	4631      	mov	r1, r6
    f->mempool = m;
    
    f->gain = 1.0f;
   2b576:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2b57a:	f001 fe49 	bl	2d210 <mpool_alloc>
}

void        tOnePole_setFreq        (tOnePole* const ft, float freq)
{
    _tOnePole* f = *ft;
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b57e:	f64f 0208 	movw	r2, #63496	; 0xf808
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2b582:	6028      	str	r0, [r5, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b584:	2300      	movs	r3, #0
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b586:	f2c0 220f 	movt	r2, #527	; 0x20f
    f->gain = 1.0f;
   2b58a:	ed80 8a01 	vstr	s16, [r0, #4]
    f->a0 = 1.0;
   2b58e:	ed80 8a02 	vstr	s16, [r0, #8]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b592:	eeb0 1a48 	vmov.f32	s2, s16
    f->mempool = m;
   2b596:	6006      	str	r6, [r0, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b598:	ee00 3a10 	vmov	s0, r3
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b59c:	edd2 0a03 	vldr	s1, [r2, #12]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b5a0:	ee08 3a90 	vmov	s17, r3
    _tOnePole* f = *ft;
   2b5a4:	682d      	ldr	r5, [r5, #0]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2b5a6:	4604      	mov	r4, r0
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b5a8:	ee69 0a20 	vmul.f32	s1, s18, s1
   2b5ac:	edc5 0a04 	vstr	s1, [r5, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b5b0:	f001 fc16 	bl	2cde0 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
   2b5b4:	ee38 8a40 	vsub.f32	s16, s16, s0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b5b8:	ed85 0a04 	vstr	s0, [r5, #16]
    f->a1 = 1.0f - f->b0;
   2b5bc:	ed85 8a03 	vstr	s16, [r5, #12]
    f->lastIn = 0.0f;
   2b5c0:	edc4 8a06 	vstr	s17, [r4, #24]
    f->lastOut = 0.0f;
   2b5c4:	edc4 8a07 	vstr	s17, [r4, #28]
}
   2b5c8:	ecbd 8b04 	vpop	{d8-d9}
   2b5cc:	bd70      	pop	{r4, r5, r6, pc}
   2b5ce:	bf00      	nop

0002b5d0 <tOnePole_free>:
    _tOnePole* f = *ft;
   2b5d0:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
   2b5d2:	6801      	ldr	r1, [r0, #0]
   2b5d4:	f001 bec6 	b.w	2d364 <mpool_free>

0002b5d8 <tOnePole_setFreq>:
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b5d8:	f64f 0308 	movw	r3, #63496	; 0xf808
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b5dc:	2200      	movs	r2, #0
   2b5de:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b5e2:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   2b5e6:	b510      	push	{r4, lr}
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b5e8:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
   2b5ec:	6804      	ldr	r4, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b5ee:	ee60 0a20 	vmul.f32	s1, s0, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b5f2:	ee00 2a10 	vmov	s0, r2
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2b5f6:	edc4 0a04 	vstr	s1, [r4, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b5fa:	f001 fbf1 	bl	2cde0 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
   2b5fe:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2b602:	ed84 0a04 	vstr	s0, [r4, #16]
    f->a1 = 1.0f - f->b0;
   2b606:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2b60a:	ed84 0a03 	vstr	s0, [r4, #12]
}
   2b60e:	bd10      	pop	{r4, pc}

0002b610 <tOnePole_tick>:
    f->gain = gain;
}

float   tOnePole_tick(tOnePole* const ft, float input)
{
    _tOnePole* f = *ft;
   2b610:	6803      	ldr	r3, [r0, #0]
    
    float in = input * f->gain;
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   2b612:	ed93 6a07 	vldr	s12, [r3, #28]
    float in = input * f->gain;
   2b616:	ed93 7a01 	vldr	s14, [r3, #4]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   2b61a:	edd3 7a03 	vldr	s15, [r3, #12]
    float in = input * f->gain;
   2b61e:	ee20 7a07 	vmul.f32	s14, s0, s14
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   2b622:	edd3 6a04 	vldr	s13, [r3, #16]
   2b626:	ee27 0a86 	vmul.f32	s0, s15, s12
    
    f->lastIn = in;
   2b62a:	ed83 7a06 	vstr	s14, [r3, #24]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   2b62e:	eea6 0a87 	vfma.f32	s0, s13, s14
    f->lastOut = out;
   2b632:	ed83 0a07 	vstr	s0, [r3, #28]
    
    return out;
}
   2b636:	4770      	bx	lr

0002b638 <tSVF_init>:
}

// Less efficient, more accurate version of SVF, in which cutoff frequency is taken as floating point Hz value and tanf
// is calculated when frequency changes.
void tSVF_init(tSVF* const svff, SVFType type, float freq, float Q)
{
   2b638:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

}

void    tSVF_initToPool     (tSVF* const svff, SVFType type, float freq, float Q, tMempool* const mp)
{
    _tMempool* m = *mp;
   2b63c:	f64f 0608 	movw	r6, #63496	; 0xf808
{
   2b640:	460f      	mov	r7, r1
   2b642:	4681      	mov	r9, r0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   2b644:	203c      	movs	r0, #60	; 0x3c
    _tMempool* m = *mp;
   2b646:	f2c0 260f 	movt	r6, #527	; 0x20f
    svf->mempool = m;

    svf->type = type;

    svf->ic1eq = 0;
   2b64a:	2500      	movs	r5, #0
    _tMempool* m = *mp;
   2b64c:	f8d6 8018 	ldr.w	r8, [r6, #24]
{
   2b650:	ed2d 8b02 	vpush	{d8}
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   2b654:	4641      	mov	r1, r8
{
   2b656:	eeb0 8a60 	vmov.f32	s16, s1
   2b65a:	eef0 8a40 	vmov.f32	s17, s0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   2b65e:	f001 fdd7 	bl	2d210 <mpool_alloc>
    svf->ic2eq = 0;
    svf->Q = Q;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b662:	f640 73db 	movw	r3, #4059	; 0xfdb
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   2b666:	f8c9 0000 	str.w	r0, [r9]
    svf->mempool = m;
   2b66a:	f8c0 8000 	str.w	r8, [r0]
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   2b66e:	4604      	mov	r4, r0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b670:	f2c4 0349 	movt	r3, #16457	; 0x4049
    svf->type = type;
   2b674:	7107      	strb	r7, [r0, #4]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b676:	ed96 7a01 	vldr	s14, [r6, #4]
   2b67a:	ee07 3a90 	vmov	s15, r3
    svf->Q = Q;
   2b67e:	ed80 8a03 	vstr	s16, [r0, #12]
    svf->cutoff = freq;
   2b682:	edc0 8a02 	vstr	s17, [r0, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b686:	ee67 7a27 	vmul.f32	s15, s14, s15
    svf->ic1eq = 0;
   2b68a:	6105      	str	r5, [r0, #16]
    svf->ic2eq = 0;
   2b68c:	6145      	str	r5, [r0, #20]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b68e:	ee27 0aa8 	vmul.f32	s0, s15, s17
   2b692:	f005 f9a3 	bl	309dc <tanf>
    svf->k = 1.0f/Q;
   2b696:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b69a:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a3 = svf->g*svf->a2;
    svf->cH = 0.0f;
    svf->cB = 0.0f;
    svf->cL = 1.0f;

    if (type == SVFTypeLowpass)
   2b69e:	2f01      	cmp	r7, #1
    svf->cH = 0.0f;
   2b6a0:	62e5      	str	r5, [r4, #44]	; 0x2c
    svf->k = 1.0f/Q;
   2b6a2:	ee87 7a88 	vdiv.f32	s14, s15, s16
    svf->cB = 0.0f;
   2b6a6:	6325      	str	r5, [r4, #48]	; 0x30
    svf->cL = 1.0f;
   2b6a8:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b6ac:	ee70 6a07 	vadd.f32	s13, s0, s14
    svf->k = 1.0f/Q;
   2b6b0:	ed84 7a07 	vstr	s14, [r4, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b6b4:	eeb0 7a67 	vmov.f32	s14, s15
   2b6b8:	eea0 7a26 	vfma.f32	s14, s0, s13
   2b6bc:	eec7 6a87 	vdiv.f32	s13, s15, s14
    svf->a2 = svf->g*svf->a1;
   2b6c0:	ee20 7a26 	vmul.f32	s14, s0, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b6c4:	edc4 6a08 	vstr	s13, [r4, #32]
    svf->a3 = svf->g*svf->a2;
   2b6c8:	ee20 0a07 	vmul.f32	s0, s0, s14
    svf->a2 = svf->g*svf->a1;
   2b6cc:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
   2b6d0:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    if (type == SVFTypeLowpass)
   2b6d4:	d018      	beq.n	2b708 <tSVF_init+0xd0>
        svf->cH = 0.0f;
        svf->cB = 0.0f;
        svf->cBK = 0.0f;
        svf->cL = 1.0f;
    }
    else if (type == SVFTypeBandpass)
   2b6d6:	2f02      	cmp	r7, #2
   2b6d8:	d00e      	beq.n	2b6f8 <tSVF_init+0xc0>
        svf->cB = 1.0f;
        svf->cBK = 0.0f;
        svf->cL = 0.0f;
    }

    else if (type == SVFTypeHighpass)
   2b6da:	b1d7      	cbz	r7, 2b712 <tSVF_init+0xda>
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
        svf->cL = -1.0f;
    }

    else if (type == SVFTypeNotch)
   2b6dc:	2f03      	cmp	r7, #3
   2b6de:	d023      	beq.n	2b728 <tSVF_init+0xf0>
        svf->cBK = -1.0f;
        svf->cL = 0.0f;
    }


    else if (type == SVFTypePeak)
   2b6e0:	2f04      	cmp	r7, #4
   2b6e2:	d10d      	bne.n	2b700 <tSVF_init+0xc8>
    {
        svf->cH = 1.0f;
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
   2b6e4:	2200      	movs	r2, #0
        svf->cL = -2.0f;
   2b6e6:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
        svf->cH = 1.0f;
   2b6ea:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
   2b6ee:	f6cb 7280 	movt	r2, #49024	; 0xbf80
        svf->cL = -2.0f;
   2b6f2:	6363      	str	r3, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
   2b6f4:	63a2      	str	r2, [r4, #56]	; 0x38
}
   2b6f6:	e003      	b.n	2b700 <tSVF_init+0xc8>
        svf->cB = 1.0f;
   2b6f8:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
        svf->cBK = 0.0f;
   2b6fc:	63a5      	str	r5, [r4, #56]	; 0x38
        svf->cL = 0.0f;
   2b6fe:	6365      	str	r5, [r4, #52]	; 0x34
}
   2b700:	ecbd 8b02 	vpop	{d8}
   2b704:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = 0.0f;
   2b708:	63a5      	str	r5, [r4, #56]	; 0x38
}
   2b70a:	ecbd 8b02 	vpop	{d8}
   2b70e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
   2b712:	2300      	movs	r3, #0
        svf->cH = 1.0f;
   2b714:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
   2b718:	f6cb 7380 	movt	r3, #49024	; 0xbf80
   2b71c:	63a3      	str	r3, [r4, #56]	; 0x38
        svf->cL = -1.0f;
   2b71e:	6363      	str	r3, [r4, #52]	; 0x34
}
   2b720:	ecbd 8b02 	vpop	{d8}
   2b724:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
   2b728:	2300      	movs	r3, #0
        svf->cH = 1.0f;
   2b72a:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cL = 0.0f;
   2b72e:	6365      	str	r5, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
   2b730:	f6cb 7380 	movt	r3, #49024	; 0xbf80
   2b734:	63a3      	str	r3, [r4, #56]	; 0x38
   2b736:	e7e3      	b.n	2b700 <tSVF_init+0xc8>

0002b738 <tSVF_free>:
    }
}

void    tSVF_free   (tSVF* const svff)
{
    _tSVF* svf = *svff;
   2b738:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
   2b73a:	6801      	ldr	r1, [r0, #0]
   2b73c:	f001 be12 	b.w	2d364 <mpool_free>

0002b740 <tSVF_tick>:
}

float   tSVF_tick(tSVF* const svff, float v0)
{
    _tSVF* svf = *svff;
   2b740:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2b742:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
   2b746:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b74a:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b74e:	eef0 5a66 	vmov.f32	s11, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b752:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
   2b756:	ee30 4a66 	vsub.f32	s8, s0, s13
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b75a:	edd3 2a0a 	vldr	s5, [r3, #40]	; 0x28
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   2b75e:	edd3 3a0e 	vldr	s7, [r3, #56]	; 0x38
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b762:	eee6 5a27 	vfma.f32	s11, s12, s15
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b766:	ed93 3a08 	vldr	s6, [r3, #32]
   2b76a:	ee67 7a84 	vmul.f32	s15, s15, s8
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   2b76e:	ed93 2a07 	vldr	s4, [r3, #28]
   2b772:	ed93 5a0c 	vldr	s10, [r3, #48]	; 0x30
   2b776:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
   2b77a:	eea2 5a23 	vfma.f32	s10, s4, s7
   2b77e:	edd3 3a0b 	vldr	s7, [r3, #44]	; 0x2c
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b782:	eee3 7a06 	vfma.f32	s15, s6, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b786:	eee2 5a84 	vfma.f32	s11, s5, s8
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2b78a:	ee97 6aa4 	vfnms.f32	s12, s15, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   2b78e:	ee25 7a87 	vmul.f32	s14, s11, s14
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   2b792:	eed5 6aa4 	vfnms.f32	s13, s11, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   2b796:	eea7 7a85 	vfma.f32	s14, s15, s10
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2b79a:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   2b79e:	edc3 6a05 	vstr	s13, [r3, #20]
}
   2b7a2:	eea3 7a80 	vfma.f32	s14, s7, s0
   2b7a6:	eeb0 0a47 	vmov.f32	s0, s14
   2b7aa:	4770      	bx	lr

0002b7ac <tSVF_setFreq>:

void     tSVF_setFreq(tSVF* const svff, float freq)
{
    _tSVF* svf = *svff;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b7ac:	f64f 0208 	movw	r2, #63496	; 0xf808
   2b7b0:	f640 73db 	movw	r3, #4059	; 0xfdb
   2b7b4:	f2c0 220f 	movt	r2, #527	; 0x20f
   2b7b8:	f2c4 0349 	movt	r3, #16457	; 0x4049
{
   2b7bc:	b510      	push	{r4, lr}
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b7be:	ee07 3a90 	vmov	s15, r3
   2b7c2:	ed92 7a01 	vldr	s14, [r2, #4]
    _tSVF* svf = *svff;
   2b7c6:	6804      	ldr	r4, [r0, #0]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b7c8:	ee67 7a27 	vmul.f32	s15, s14, s15
    svf->cutoff = freq;
   2b7cc:	ed84 0a02 	vstr	s0, [r4, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b7d0:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b7d4:	f005 f902 	bl	309dc <tanf>
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b7d8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2b7dc:	edd4 7a07 	vldr	s15, [r4, #28]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2b7e0:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b7e4:	ee70 7a27 	vadd.f32	s15, s0, s15
   2b7e8:	eeb0 7a66 	vmov.f32	s14, s13
   2b7ec:	eea0 7a27 	vfma.f32	s14, s0, s15
   2b7f0:	eef0 7a47 	vmov.f32	s15, s14
   2b7f4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    svf->a2 = svf->g * svf->a1;
   2b7f8:	ee60 7a07 	vmul.f32	s15, s0, s14
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b7fc:	ed84 7a08 	vstr	s14, [r4, #32]
    svf->a3 = svf->g * svf->a2;
   2b800:	ee20 0a27 	vmul.f32	s0, s0, s15
    svf->a2 = svf->g * svf->a1;
   2b804:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   2b808:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
}
   2b80c:	bd10      	pop	{r4, pc}
   2b80e:	bf00      	nop

0002b810 <tEfficientSVF_initToPool>:
{
    tEfficientSVF_initToPool(svff, type, input, Q, &leaf.mempool);
}

void    tEfficientSVF_initToPool    (tEfficientSVF* const svff, SVFType type, uint16_t input, float Q, tMempool* const mp)
{
   2b810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2b812:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b816:	681c      	ldr	r4, [r3, #0]
{
   2b818:	4607      	mov	r7, r0
   2b81a:	460d      	mov	r5, r1
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   2b81c:	202c      	movs	r0, #44	; 0x2c
   2b81e:	4621      	mov	r1, r4
{
   2b820:	eeb0 8a40 	vmov.f32	s16, s0
   2b824:	4616      	mov	r6, r2
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   2b826:	f001 fcf3 	bl	2d210 <mpool_alloc>
    
    svf->ic1eq = 0;
    svf->ic2eq = 0;
    
    svf->g = __leaf_table_filtertan[input];
    svf->k = 1.0f/Q;
   2b82a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
   2b82e:	f645 738c 	movw	r3, #24460	; 0x5f8c
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   2b832:	6038      	str	r0, [r7, #0]
    svf->ic1eq = 0;
   2b834:	2100      	movs	r1, #0
    svf->g = __leaf_table_filtertan[input];
   2b836:	f2c0 0303 	movt	r3, #3
    svf->mempool = m;
   2b83a:	6004      	str	r4, [r0, #0]
    svf->k = 1.0f/Q;
   2b83c:	eec7 6a08 	vdiv.f32	s13, s14, s16
    svf->type = type;
   2b840:	7105      	strb	r5, [r0, #4]
    svf->g = __leaf_table_filtertan[input];
   2b842:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    svf->ic1eq = 0;
   2b846:	6101      	str	r1, [r0, #16]
    svf->ic2eq = 0;
   2b848:	6141      	str	r1, [r0, #20]
    svf->g = __leaf_table_filtertan[input];
   2b84a:	edd3 7a00 	vldr	s15, [r3]
   2b84e:	edc0 7a06 	vstr	s15, [r0, #24]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   2b852:	ee37 6aa6 	vadd.f32	s12, s15, s13
    svf->k = 1.0f/Q;
   2b856:	edc0 6a07 	vstr	s13, [r0, #28]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   2b85a:	eef0 6a47 	vmov.f32	s13, s14
   2b85e:	eee7 6a86 	vfma.f32	s13, s15, s12
   2b862:	eeb0 6a66 	vmov.f32	s12, s13
   2b866:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g*svf->a1;
   2b86a:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   2b86e:	edc0 6a08 	vstr	s13, [r0, #32]
    svf->a3 = svf->g*svf->a2;
   2b872:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g*svf->a1;
   2b876:	ed80 7a09 	vstr	s14, [r0, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
   2b87a:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
}
   2b87e:	ecbd 8b02 	vpop	{d8}
   2b882:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002b884 <tEfficientSVF_free>:

void    tEfficientSVF_free (tEfficientSVF* const svff)
{
    _tEfficientSVF* svf = *svff;
   2b884:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
   2b886:	6801      	ldr	r1, [r0, #0]
   2b888:	f001 bd6c 	b.w	2d364 <mpool_free>

0002b88c <tEfficientSVF_tick>:
}

float   tEfficientSVF_tick(tEfficientSVF* const svff, float v0)
{
    _tEfficientSVF* svf = *svff;
   2b88c:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2b88e:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
   2b892:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b896:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b89a:	eeb0 7a66 	vmov.f32	s14, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b89e:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
   2b8a2:	ee70 5a66 	vsub.f32	s11, s0, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b8a6:	ed93 4a08 	vldr	s8, [r3, #32]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b8aa:	edd3 4a0a 	vldr	s9, [r3, #40]	; 0x28
   2b8ae:	eea6 7a27 	vfma.f32	s14, s12, s15
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    if (svf->type == SVFTypeLowpass)        return v2;
   2b8b2:	791a      	ldrb	r2, [r3, #4]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b8b4:	ee67 7aa5 	vmul.f32	s15, s15, s11
    if (svf->type == SVFTypeLowpass)        return v2;
   2b8b8:	2a01      	cmp	r2, #1
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2b8ba:	eee4 7a06 	vfma.f32	s15, s8, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2b8be:	eea4 7aa5 	vfma.f32	s14, s9, s11
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2b8c2:	ee97 6a85 	vfnms.f32	s12, s15, s10
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   2b8c6:	ee77 5a07 	vadd.f32	s11, s14, s14
   2b8ca:	ee75 6ae6 	vsub.f32	s13, s11, s13
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2b8ce:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   2b8d2:	edc3 6a05 	vstr	s13, [r3, #20]
    if (svf->type == SVFTypeLowpass)        return v2;
   2b8d6:	d009      	beq.n	2b8ec <tEfficientSVF_tick+0x60>
    else if (svf->type == SVFTypeBandpass)  return v1;
   2b8d8:	2a02      	cmp	r2, #2
   2b8da:	d00a      	beq.n	2b8f2 <tEfficientSVF_tick+0x66>
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
   2b8dc:	b172      	cbz	r2, 2b8fc <tEfficientSVF_tick+0x70>
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
   2b8de:	2a03      	cmp	r2, #3
   2b8e0:	d015      	beq.n	2b90e <tEfficientSVF_tick+0x82>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
   2b8e2:	2a04      	cmp	r2, #4
   2b8e4:	d01a      	beq.n	2b91c <tEfficientSVF_tick+0x90>
    else                                    return 0.0f;
   2b8e6:	2300      	movs	r3, #0
   2b8e8:	ee07 3a10 	vmov	s14, r3
    
}
   2b8ec:	eeb0 0a47 	vmov.f32	s0, s14
   2b8f0:	4770      	bx	lr
    else if (svf->type == SVFTypeBandpass)  return v1;
   2b8f2:	eeb0 7a67 	vmov.f32	s14, s15
}
   2b8f6:	eeb0 0a47 	vmov.f32	s0, s14
   2b8fa:	4770      	bx	lr
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
   2b8fc:	edd3 6a07 	vldr	s13, [r3, #28]
   2b900:	eea6 0ae7 	vfms.f32	s0, s13, s15
   2b904:	ee30 7a47 	vsub.f32	s14, s0, s14
}
   2b908:	eeb0 0a47 	vmov.f32	s0, s14
   2b90c:	4770      	bx	lr
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
   2b90e:	ed93 7a07 	vldr	s14, [r3, #28]
   2b912:	eea7 0a67 	vfms.f32	s0, s14, s15
   2b916:	eeb0 7a40 	vmov.f32	s14, s0
   2b91a:	e7e7      	b.n	2b8ec <tEfficientSVF_tick+0x60>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
   2b91c:	ed93 7a07 	vldr	s14, [r3, #28]
   2b920:	eea7 0a67 	vfms.f32	s0, s14, s15
   2b924:	ee30 7a65 	vsub.f32	s14, s0, s11
   2b928:	e7e0      	b.n	2b8ec <tEfficientSVF_tick+0x60>
   2b92a:	bf00      	nop

0002b92c <tEfficientSVF_setFreq>:

void     tEfficientSVF_setFreq(tEfficientSVF* const svff, uint16_t input)
{
    _tEfficientSVF* svf = *svff;
    
    svf->g = __leaf_table_filtertan[input];
   2b92c:	f645 728c 	movw	r2, #24460	; 0x5f8c
    _tEfficientSVF* svf = *svff;
   2b930:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b932:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
   2b936:	f2c0 0203 	movt	r2, #3
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b93a:	ed93 7a07 	vldr	s14, [r3, #28]
    svf->g = __leaf_table_filtertan[input];
   2b93e:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b942:	eef0 6a46 	vmov.f32	s13, s12
    svf->g = __leaf_table_filtertan[input];
   2b946:	edd1 7a00 	vldr	s15, [r1]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b94a:	ee37 7a87 	vadd.f32	s14, s15, s14
    svf->g = __leaf_table_filtertan[input];
   2b94e:	edc3 7a06 	vstr	s15, [r3, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b952:	eee7 6a87 	vfma.f32	s13, s15, s14
   2b956:	eeb0 7a66 	vmov.f32	s14, s13
   2b95a:	eec6 6a07 	vdiv.f32	s13, s12, s14
    svf->a2 = svf->g * svf->a1;
   2b95e:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b962:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
   2b966:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
   2b96a:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   2b96e:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
   2b972:	4770      	bx	lr

0002b974 <tEfficientSVF_setQ>:

void     tEfficientSVF_setQ(tEfficientSVF* const svff, float Q)
{
    _tEfficientSVF* svf = *svff;
    
    svf->k = 1.0f/Q;
   2b974:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
   2b978:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b97a:	edd3 7a06 	vldr	s15, [r3, #24]
    svf->k = 1.0f/Q;
   2b97e:	ee87 0a00 	vdiv.f32	s0, s14, s0
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b982:	eeb0 6a47 	vmov.f32	s12, s14
   2b986:	ee70 6a27 	vadd.f32	s13, s0, s15
    svf->k = 1.0f/Q;
   2b98a:	ed83 0a07 	vstr	s0, [r3, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b98e:	eea7 6aa6 	vfma.f32	s12, s15, s13
   2b992:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g * svf->a1;
   2b996:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2b99a:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
   2b99e:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
   2b9a2:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   2b9a6:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
   2b9aa:	4770      	bx	lr

0002b9ac <tHighpass_init>:

/* Highpass */
void    tHighpass_init(tHighpass* const ft, float freq)
{
   2b9ac:	b570      	push	{r4, r5, r6, lr}
    tHighpass_initToPool(ft, freq, &leaf.mempool);
}

void    tHighpass_initToPool    (tHighpass* const ft, float freq, tMempool* const mp)
{
    _tMempool* m = *mp;
   2b9ae:	f64f 0408 	movw	r4, #63496	; 0xf808
{
   2b9b2:	4606      	mov	r6, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2b9b4:	2014      	movs	r0, #20
    _tMempool* m = *mp;
   2b9b6:	f2c0 240f 	movt	r4, #527	; 0x20f
   2b9ba:	69a5      	ldr	r5, [r4, #24]
{
   2b9bc:	ed2d 8b02 	vpush	{d8}
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2b9c0:	4629      	mov	r1, r5
{
   2b9c2:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2b9c6:	f001 fc79 	bl	2d2bc <mpool_calloc>
    f->mempool = m;
    
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2b9ca:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2b9ce:	6030      	str	r0, [r6, #0]
    f->ys = 0.0f;
   2b9d0:	2300      	movs	r3, #0
    f->mempool = m;
   2b9d2:	6005      	str	r5, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2b9d4:	ed94 7a03 	vldr	s14, [r4, #12]
    f->xs = 0.0f;
    
    f->frequency = freq;
   2b9d8:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2b9dc:	eee8 7a47 	vfms.f32	s15, s16, s14
    f->ys = 0.0f;
   2b9e0:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
   2b9e2:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2b9e4:	edc0 7a03 	vstr	s15, [r0, #12]
}
   2b9e8:	ecbd 8b02 	vpop	{d8}
   2b9ec:	bd70      	pop	{r4, r5, r6, pc}
   2b9ee:	bf00      	nop

0002b9f0 <tHighpass_initToPool>:
{
   2b9f0:	b538      	push	{r3, r4, r5, lr}
   2b9f2:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2b9f6:	680c      	ldr	r4, [r1, #0]
{
   2b9f8:	4605      	mov	r5, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2b9fa:	2014      	movs	r0, #20
{
   2b9fc:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2ba00:	4621      	mov	r1, r4
   2ba02:	f001 fc5b 	bl	2d2bc <mpool_calloc>
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba06:	f64f 0208 	movw	r2, #63496	; 0xf808
   2ba0a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2ba0e:	6028      	str	r0, [r5, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba10:	f2c0 220f 	movt	r2, #527	; 0x20f
    f->mempool = m;
   2ba14:	6004      	str	r4, [r0, #0]
    f->ys = 0.0f;
   2ba16:	2300      	movs	r3, #0
    f->frequency = freq;
   2ba18:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba1c:	ed92 7a03 	vldr	s14, [r2, #12]
    f->ys = 0.0f;
   2ba20:	6083      	str	r3, [r0, #8]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba22:	eee7 7a48 	vfms.f32	s15, s14, s16
    f->xs = 0.0f;
   2ba26:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba28:	edc0 7a03 	vstr	s15, [r0, #12]
}
   2ba2c:	ecbd 8b02 	vpop	{d8}
   2ba30:	bd38      	pop	{r3, r4, r5, pc}
   2ba32:	bf00      	nop

0002ba34 <tHighpass_free>:

void    tHighpass_free  (tHighpass* const ft)
{
    _tHighpass* f = *ft;
   2ba34:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)f, f->mempool);
   2ba36:	6801      	ldr	r1, [r0, #0]
   2ba38:	f001 bc94 	b.w	2d364 <mpool_free>

0002ba3c <tHighpass_setFreq>:

void     tHighpass_setFreq(tHighpass* const ft, float freq)
{
    _tHighpass* f = *ft;
    f->frequency = freq;
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba3c:	f64f 0308 	movw	r3, #63496	; 0xf808
   2ba40:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft;
   2ba44:	6802      	ldr	r2, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba46:	f2c0 230f 	movt	r3, #527	; 0x20f
    f->frequency = freq;
   2ba4a:	ed82 0a04 	vstr	s0, [r2, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2ba4e:	ed93 7a03 	vldr	s14, [r3, #12]
   2ba52:	eee7 7a40 	vfms.f32	s15, s14, s0
   2ba56:	edc2 7a03 	vstr	s15, [r2, #12]
    
}
   2ba5a:	4770      	bx	lr

0002ba5c <tHighpass_tick>:
}

// From JOS DC Blocker
float   tHighpass_tick(tHighpass* const ft, float x)
{
    _tHighpass* f = *ft;
   2ba5c:	6803      	ldr	r3, [r0, #0]
    f->ys = x - f->xs + f->R * f->ys;
   2ba5e:	edd3 7a01 	vldr	s15, [r3, #4]
   2ba62:	ed93 7a02 	vldr	s14, [r3, #8]
   2ba66:	edd3 6a03 	vldr	s13, [r3, #12]
    f->xs = x;
   2ba6a:	ed83 0a01 	vstr	s0, [r3, #4]
    f->ys = x - f->xs + f->R * f->ys;
   2ba6e:	eed6 7a87 	vfnms.f32	s15, s13, s14
   2ba72:	ee37 0a80 	vadd.f32	s0, s15, s0
   2ba76:	ed83 0a02 	vstr	s0, [r3, #8]
    return f->ys;
}
   2ba7a:	4770      	bx	lr

0002ba7c <tVZFilter_initToPool>:
{
	tVZFilter_initToPool(vf, type, freq, bandWidth, &leaf.mempool);
}

void    tVZFilter_initToPool     (tVZFilter* const vf, VZFilterType type, float freq, float bandWidth, tMempool* const mp)
{
   2ba7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ba7e:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2ba82:	6816      	ldr	r6, [r2, #0]
{
   2ba84:	4605      	mov	r5, r0
   2ba86:	460f      	mov	r7, r1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   2ba88:	2044      	movs	r0, #68	; 0x44
   2ba8a:	4631      	mov	r1, r6
{
   2ba8c:	eef0 8a40 	vmov.f32	s17, s0
   2ba90:	eeb0 8a60 	vmov.f32	s16, s1
	f->invG    = 1.0f/ONE_OVER_SQRT2;
	f->B    = bandWidth;
	f->m    = 0.0f;
	f->s1 = 0.0f;
	f->s2 = 0.0f;
	f->sr = leaf.sampleRate;
   2ba94:	f64f 0408 	movw	r4, #63496	; 0xf808
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   2ba98:	f001 fbba 	bl	2d210 <mpool_alloc>
	f->G    = ONE_OVER_SQRT2;
   2ba9c:	f240 41f3 	movw	r1, #1267	; 0x4f3
	f->sr = leaf.sampleRate;
   2baa0:	f2c0 240f 	movt	r4, #527	; 0x20f
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   2baa4:	6028      	str	r0, [r5, #0]
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   2baa6:	460a      	mov	r2, r1
    f->mempool = m;
   2baa8:	6006      	str	r6, [r0, #0]
	f->type = type;
   2baaa:	7107      	strb	r7, [r0, #4]
	f->m    = 0.0f;
   2baac:	2300      	movs	r3, #0
	f->G    = ONE_OVER_SQRT2;
   2baae:	f6c3 7135 	movt	r1, #16181	; 0x3f35
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   2bab2:	f6c3 72b5 	movt	r2, #16309	; 0x3fb5
	f->sr = leaf.sampleRate;
   2bab6:	6826      	ldr	r6, [r4, #0]
	f->inv_sr = leaf.invSampleRate;
   2bab8:	6864      	ldr	r4, [r4, #4]
	f->fc   = freq;
   2baba:	edc0 8a0a 	vstr	s17, [r0, #40]	; 0x28
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   2babe:	6302      	str	r2, [r0, #48]	; 0x30

void   tVZFilter_calcCoeffs           (tVZFilter* const vf)
{

	_tVZFilter* f = *vf;
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2bac0:	f640 72db 	movw	r2, #4059	; 0xfdb
	f->m    = 0.0f;
   2bac4:	6383      	str	r3, [r0, #56]	; 0x38
	f->s1 = 0.0f;
   2bac6:	6083      	str	r3, [r0, #8]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2bac8:	f2c4 0249 	movt	r2, #16457	; 0x4049
	f->s2 = 0.0f;
   2bacc:	60c3      	str	r3, [r0, #12]
	f->B    = bandWidth;
   2bace:	ed80 8a0d 	vstr	s16, [r0, #52]	; 0x34
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2bad2:	ee07 2a90 	vmov	s15, r2
	f->G    = ONE_OVER_SQRT2;
   2bad6:	62c1      	str	r1, [r0, #44]	; 0x2c
	f->sr = leaf.sampleRate;
   2bad8:	63c6      	str	r6, [r0, #60]	; 0x3c
	f->inv_sr = leaf.invSampleRate;
   2bada:	6404      	str	r4, [r0, #64]	; 0x40
	_tVZFilter* f = *vf;
   2badc:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2bade:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   2bae2:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   2bae6:	ee28 8a07 	vmul.f32	s16, s16, s14
   2baea:	ee28 8a27 	vmul.f32	s16, s16, s15
   2baee:	eeb0 0a48 	vmov.f32	s0, s16
   2baf2:	f004 ff73 	bl	309dc <tanf>

	  switch( f->type )
   2baf6:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2baf8:	eef0 8a40 	vmov.f32	s17, s0
   2bafc:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   2bb00:	2b0a      	cmp	r3, #10
   2bb02:	f200 81be 	bhi.w	2be82 <tVZFilter_initToPool+0x406>
   2bb06:	e8df f013 	tbh	[pc, r3, lsl #1]
   2bb0a:	0057      	.short	0x0057
   2bb0c:	006d0062 	.word	0x006d0062
   2bb10:	00b30078 	.word	0x00b30078
   2bb14:	012200ef 	.word	0x012200ef
   2bb18:	016a0146 	.word	0x016a0146
   2bb1c:	000b01b1 	.word	0x000b01b1
}

float tVZFilter_BandwidthToR(tVZFilter* const vf, float B)
{
	_tVZFilter* f = *vf;
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2bb20:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2bb24:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2bb28:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2bb2a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2bb2e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2bb32:	f004 fe15 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2bb36:	f640 73db 	movw	r3, #4059	; 0xfdb
   2bb3a:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2bb3e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2bb42:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2bb46:	ee67 7a87 	vmul.f32	s15, s15, s14
   2bb4a:	ee07 3a10 	vmov	s14, r3
   2bb4e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2bb52:	ee27 0a80 	vmul.f32	s0, s15, s0
   2bb56:	f004 ff41 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2bb5a:	ed95 7a04 	vldr	s14, [r5, #16]
							   // unwarped: r = pow(2, -B/2) -> approximation for low
							   // center-frequencies
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2bb5e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2bb62:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2bb66:	edc4 7a07 	vstr	s15, [r4, #28]
   2bb6a:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2bb6e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2bb72:	ee20 0a00 	vmul.f32	s0, s0, s0
   2bb76:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2bb7a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2bb7e:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2bb82:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2bb86:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2bb8a:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2bb8e:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2bb92:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2bb96:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   2bb9a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2bb9e:	ee77 7aa8 	vadd.f32	s15, s15, s17
   2bba2:	eef0 6a47 	vmov.f32	s13, s14
   2bba6:	eee7 6aa8 	vfma.f32	s13, s15, s17
   2bbaa:	eec7 7a26 	vdiv.f32	s15, s14, s13
   2bbae:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2bbb2:	ecbd 8b04 	vpop	{d8-d9}
   2bbb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2bbb8:	2300      	movs	r3, #0
   2bbba:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2bbbe:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2bbc2:	6262      	str	r2, [r4, #36]	; 0x24
   2bbc4:	61e3      	str	r3, [r4, #28]
   2bbc6:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
   2bbc8:	edc4 7a05 	vstr	s15, [r4, #20]
   2bbcc:	e7e5      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2bbce:	2300      	movs	r3, #0
   2bbd0:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2bbd4:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2bbd8:	61e2      	str	r2, [r4, #28]
   2bbda:	6223      	str	r3, [r4, #32]
   2bbdc:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2bbde:	edc4 7a05 	vstr	s15, [r4, #20]
   2bbe2:	e7da      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2bbe4:	2300      	movs	r3, #0
   2bbe6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2bbea:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2bbee:	6222      	str	r2, [r4, #32]
   2bbf0:	61e3      	str	r3, [r4, #28]
   2bbf2:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2bbf4:	edc4 7a05 	vstr	s15, [r4, #20]
   2bbf8:	e7cf      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2bbfa:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2bbfe:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2bc02:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2bc04:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2bc08:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2bc0c:	f004 fda8 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2bc10:	f640 73db 	movw	r3, #4059	; 0xfdb
   2bc14:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2bc18:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2bc1c:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2bc20:	ee67 7a87 	vmul.f32	s15, s15, s14
   2bc24:	ee07 3a10 	vmov	s14, r3
   2bc28:	ee67 7a87 	vmul.f32	s15, s15, s14
   2bc2c:	ee27 0a80 	vmul.f32	s0, s15, s0
   2bc30:	f004 fed4 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2bc34:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2bc38:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2bc3c:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2bc3e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2bc42:	61e3      	str	r3, [r4, #28]
   2bc44:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2bc46:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2bc4a:	ee20 0a00 	vmul.f32	s0, s0, s0
   2bc4e:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2bc52:	ee20 0a07 	vmul.f32	s0, s0, s14
   2bc56:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2bc5a:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2bc5e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2bc62:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2bc66:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2bc6a:	edc4 7a08 	vstr	s15, [r4, #32]
   2bc6e:	e794      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2bc70:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2bc74:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2bc78:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2bc7a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2bc7e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2bc82:	f004 fd6d 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2bc86:	f640 73db 	movw	r3, #4059	; 0xfdb
   2bc8a:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2bc8e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2bc92:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2bc96:	ee67 7a87 	vmul.f32	s15, s15, s14
   2bc9a:	ee07 3a10 	vmov	s14, r3
   2bc9e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2bca2:	ee27 0a80 	vmul.f32	s0, s15, s0
   2bca6:	f004 fe99 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2bcaa:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2bcae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2bcb2:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2bcb4:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2bcb8:	6223      	str	r3, [r4, #32]
   2bcba:	edc4 7a07 	vstr	s15, [r4, #28]
   2bcbe:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2bcc2:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2bcc6:	ee20 0a00 	vmul.f32	s0, s0, s0
   2bcca:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2bcce:	ee20 0a07 	vmul.f32	s0, s0, s14
   2bcd2:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2bcd6:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2bcda:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2bcde:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2bce2:	edc4 7a05 	vstr	s15, [r4, #20]
   2bce6:	e758      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   2bce8:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2bcec:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   2bcf0:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2bcf4:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2bcf8:	f004 fd32 	bl	30760 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2bcfc:	ee28 0a00 	vmul.f32	s0, s16, s0
   2bd00:	f004 fe6c 	bl	309dc <tanf>
			float r  = f->g/wl;
   2bd04:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2bd08:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   2bd0c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2bd10:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   2bd14:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2bd18:	edc4 7a07 	vstr	s15, [r4, #28]
   2bd1c:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2bd20:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   2bd24:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2bd28:	eee0 7a00 	vfma.f32	s15, s0, s0
   2bd2c:	ee87 6a80 	vdiv.f32	s12, s15, s0
   2bd30:	ee76 7a65 	vsub.f32	s15, s12, s11
   2bd34:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   2bd38:	eef1 7ac6 	vsqrt.f32	s15, s12
   2bd3c:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2bd40:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2bd44:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2bd48:	ed84 7a08 	vstr	s14, [r4, #32]
   2bd4c:	e725      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
			float A = sqrtf(f->G);
   2bd4e:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2bd52:	f247 2318 	movw	r3, #29208	; 0x7218
   2bd56:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2bd5a:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
   2bd5e:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2bd62:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2bd66:	ee07 3a90 	vmov	s15, r3
   2bd6a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2bd6e:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2bd72:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   2bd76:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2bd7a:	f005 f919 	bl	30fb0 <sinhf>
   2bd7e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2bd82:	ed84 9a07 	vstr	s18, [r4, #28]
   2bd86:	6265      	str	r5, [r4, #36]	; 0x24
   2bd88:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2bd8c:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2bd90:	ed84 8a08 	vstr	s16, [r4, #32]
   2bd94:	e701      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
		  float A = sqrtf(f->G);
   2bd96:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2bd9a:	f247 2318 	movw	r3, #29208	; 0x7218
   2bd9e:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
   2bda2:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2bda6:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2bdaa:	ee07 3a90 	vmov	s15, r3
   2bdae:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2bdb2:	eef1 7ac8 	vsqrt.f32	s15, s16
   2bdb6:	ee68 8aa7 	vmul.f32	s17, s17, s15
   2bdba:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2bdbe:	f005 f8f7 	bl	30fb0 <sinhf>
   2bdc2:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2bdc6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2bdca:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   2bdce:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2bdd2:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2bdd6:	61e3      	str	r3, [r4, #28]
   2bdd8:	ed84 8a08 	vstr	s16, [r4, #32]
   2bddc:	e6dd      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
		  float x  = 2.0f*f->m-1.0f;
   2bdde:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2bde2:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   2bde6:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2bdea:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2bdec:	2300      	movs	r3, #0
			f->R2 = f->invG;
   2bdee:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   2bdf0:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2bdf4:	ee00 3a90 	vmov	s1, r3
   2bdf8:	eef1 8a48 	vneg.f32	s17, s16
   2bdfc:	eeb0 0a68 	vmov.f32	s0, s17
   2be00:	f001 f9e6 	bl	2d1d0 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2be04:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2be06:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2be0a:	eeb0 0a48 	vmov.f32	s0, s16
   2be0e:	ee00 3a90 	vmov	s1, r3
   2be12:	f001 f9e1 	bl	2d1d8 <minimum>
		  f->cB = 1.0f-x*x;
   2be16:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2be1a:	edd4 6a07 	vldr	s13, [r4, #28]
   2be1e:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   2be22:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2be26:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   2be2a:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2be2e:	edd4 8a04 	vldr	s17, [r4, #16]
   2be32:	ee67 4aa7 	vmul.f32	s9, s15, s15
   2be36:	ee27 6a07 	vmul.f32	s12, s14, s14
   2be3a:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2be3e:	eea0 6a00 	vfma.f32	s12, s0, s0
   2be42:	eea0 6a45 	vfms.f32	s12, s0, s10
   2be46:	ee84 5a86 	vdiv.f32	s10, s9, s12
   2be4a:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2be4e:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   2be52:	ee66 6a86 	vmul.f32	s13, s13, s12
   2be56:	ee27 7a06 	vmul.f32	s14, s14, s12
   2be5a:	ee20 0a06 	vmul.f32	s0, s0, s12
   2be5e:	edc4 6a07 	vstr	s13, [r4, #28]
   2be62:	ed84 7a08 	vstr	s14, [r4, #32]
   2be66:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   2be6a:	e696      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
		  f->cL = 1.0f;
   2be6c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2be70:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   2be74:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2be76:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   2be7a:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2be7c:	edc4 7a08 	vstr	s15, [r4, #32]
   2be80:	e68b      	b.n	2bb9a <tVZFilter_initToPool+0x11e>
   2be82:	edd4 7a05 	vldr	s15, [r4, #20]
   2be86:	e688      	b.n	2bb9a <tVZFilter_initToPool+0x11e>

0002be88 <tVZFilter_free>:
    _tVZFilter* f = *vf;
   2be88:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
   2be8a:	6801      	ldr	r1, [r0, #0]
   2be8c:	f001 ba6a 	b.w	2d364 <mpool_free>

0002be90 <tVZFilter_setSampleRate>:
	f->inv_sr = 1.0f/sampleRate;
   2be90:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	_tVZFilter* f = *vf;
   2be94:	6803      	ldr	r3, [r0, #0]
	f->sr = sampleRate;
   2be96:	ed83 0a0f 	vstr	s0, [r3, #60]	; 0x3c
	f->inv_sr = 1.0f/sampleRate;
   2be9a:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2be9e:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
}
   2bea2:	4770      	bx	lr

0002bea4 <tVZFilter_tick>:
{
   2bea4:	b510      	push	{r4, lr}
	_tVZFilter* f = *vf;
   2bea6:	6804      	ldr	r4, [r0, #0]
{
   2bea8:	ed2d 8b06 	vpush	{d8-d10}
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   2beac:	ed94 8a02 	vldr	s16, [r4, #8]
   2beb0:	edd4 7a05 	vldr	s15, [r4, #20]
   2beb4:	ed94 9a04 	vldr	s18, [r4, #16]
   2beb8:	eea7 0ac8 	vfms.f32	s0, s15, s16
   2bebc:	edd4 9a03 	vldr	s19, [r4, #12]
   2bec0:	edd4 7a06 	vldr	s15, [r4, #24]
   2bec4:	eea8 0a49 	vfms.f32	s0, s16, s18
   2bec8:	ee70 8a69 	vsub.f32	s17, s0, s19
   2becc:	ee68 8aa7 	vmul.f32	s17, s17, s15
	yB = tanhf(f->g*yH) + f->s1;
   2bed0:	ee29 aa28 	vmul.f32	s20, s18, s17
   2bed4:	eeb0 0a4a 	vmov.f32	s0, s20
   2bed8:	f004 fda8 	bl	30a2c <tanhf>
   2bedc:	ee38 8a00 	vadd.f32	s16, s16, s0
	yL = tanhf(f->g*yB) + f->s2;
   2bee0:	ee29 9a08 	vmul.f32	s18, s18, s16
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2bee4:	ee3a aa08 	vadd.f32	s20, s20, s16
	yL = tanhf(f->g*yB) + f->s2;
   2bee8:	eeb0 0a49 	vmov.f32	s0, s18
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2beec:	ed84 aa02 	vstr	s20, [r4, #8]
	yL = tanhf(f->g*yB) + f->s2;
   2bef0:	f004 fd9c 	bl	30a2c <tanhf>
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2bef4:	edd4 7a08 	vldr	s15, [r4, #32]
	yL = tanhf(f->g*yB) + f->s2;
   2bef8:	ee79 9a80 	vadd.f32	s19, s19, s0
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2befc:	ed94 7a07 	vldr	s14, [r4, #28]
   2bf00:	ee28 0a27 	vmul.f32	s0, s16, s15
   2bf04:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2bf08:	ee39 9a29 	vadd.f32	s18, s18, s19
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2bf0c:	eea7 0a29 	vfma.f32	s0, s14, s19
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2bf10:	ed84 9a03 	vstr	s18, [r4, #12]
}
   2bf14:	eea7 0aa8 	vfma.f32	s0, s15, s17
   2bf18:	ecbd 8b06 	vpop	{d8-d10}
   2bf1c:	bd10      	pop	{r4, pc}
   2bf1e:	bf00      	nop

0002bf20 <tVZFilter_tickEfficient>:
	_tVZFilter* f = *vf;
   2bf20:	6803      	ldr	r3, [r0, #0]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   2bf22:	ed93 7a02 	vldr	s14, [r3, #8]
   2bf26:	edd3 7a05 	vldr	s15, [r3, #20]
   2bf2a:	edd3 5a04 	vldr	s11, [r3, #16]
   2bf2e:	eea7 0ac7 	vfms.f32	s0, s15, s14
   2bf32:	ed93 6a03 	vldr	s12, [r3, #12]
   2bf36:	ed93 4a06 	vldr	s8, [r3, #24]
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2bf3a:	edd3 6a09 	vldr	s13, [r3, #36]	; 0x24
   2bf3e:	edd3 4a08 	vldr	s9, [r3, #32]
   2bf42:	ed93 5a07 	vldr	s10, [r3, #28]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   2bf46:	eea7 0a65 	vfms.f32	s0, s14, s11
   2bf4a:	ee70 7a46 	vsub.f32	s15, s0, s12
   2bf4e:	ee67 7a84 	vmul.f32	s15, s15, s8
	yB = (f->g*yH) + f->s1;
   2bf52:	eea5 7aa7 	vfma.f32	s14, s11, s15
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2bf56:	ee27 0aa6 	vmul.f32	s0, s15, s13
	yL = (f->g*yB) + f->s2;
   2bf5a:	eef0 6a46 	vmov.f32	s13, s12
   2bf5e:	eee5 6a87 	vfma.f32	s13, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2bf62:	eeb0 6a47 	vmov.f32	s12, s14
	return f->cL*yL + f->cB*yB + f->cH*yH;
   2bf66:	eea4 0a87 	vfma.f32	s0, s9, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2bf6a:	eea5 6aa7 	vfma.f32	s12, s11, s15
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2bf6e:	eef0 7a66 	vmov.f32	s15, s13
}
   2bf72:	eea5 0a26 	vfma.f32	s0, s10, s13
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2bf76:	eee5 7a87 	vfma.f32	s15, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   2bf7a:	ed83 6a02 	vstr	s12, [r3, #8]
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   2bf7e:	edc3 7a03 	vstr	s15, [r3, #12]
}
   2bf82:	4770      	bx	lr

0002bf84 <tVZFilter_setFreq>:
{
   2bf84:	b538      	push	{r3, r4, r5, lr}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2bf86:	f64f 0308 	movw	r3, #63496	; 0xf808
   2bf8a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2bf8e:	2200      	movs	r2, #0
	_tVZFilter* f = *vf;
   2bf90:	6804      	ldr	r4, [r0, #0]
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2bf92:	f2c0 230f 	movt	r3, #527	; 0x20f
{
   2bf96:	4605      	mov	r5, r0
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2bf98:	eef0 0a40 	vmov.f32	s1, s0
   2bf9c:	ee00 2a10 	vmov	s0, r2
{
   2bfa0:	ed2d 8b04 	vpush	{d8-d9}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2bfa4:	ed93 1a00 	vldr	s2, [r3]
   2bfa8:	ee21 1a27 	vmul.f32	s2, s2, s15
   2bfac:	f000 ff18 	bl	2cde0 <LEAF_clip>
   2bfb0:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
   2bfb4:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2bfb6:	f640 73db 	movw	r3, #4059	; 0xfdb
   2bfba:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   2bfbe:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2bfc2:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   2bfc6:	ee07 3a90 	vmov	s15, r3
   2bfca:	ee28 8a07 	vmul.f32	s16, s16, s14
   2bfce:	ee28 8a27 	vmul.f32	s16, s16, s15
   2bfd2:	eeb0 0a48 	vmov.f32	s0, s16
   2bfd6:	f004 fd01 	bl	309dc <tanf>
	  switch( f->type )
   2bfda:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2bfdc:	eef0 8a40 	vmov.f32	s17, s0
   2bfe0:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   2bfe4:	2b0a      	cmp	r3, #10
   2bfe6:	f200 81be 	bhi.w	2c366 <tVZFilter_setFreq+0x3e2>
   2bfea:	e8df f013 	tbh	[pc, r3, lsl #1]
   2bfee:	0057      	.short	0x0057
   2bff0:	006d0062 	.word	0x006d0062
   2bff4:	00b30078 	.word	0x00b30078
   2bff8:	012200ef 	.word	0x012200ef
   2bffc:	016a0146 	.word	0x016a0146
   2c000:	000b01b1 	.word	0x000b01b1
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c004:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c008:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c00c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c00e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c012:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c016:	f004 fba3 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c01a:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c01e:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c022:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c026:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c02a:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c02e:	ee07 3a10 	vmov	s14, r3
   2c032:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c036:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c03a:	f004 fccf 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c03e:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c042:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c046:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c04a:	edc4 7a07 	vstr	s15, [r4, #28]
   2c04e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c052:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c056:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c05a:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c05e:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c062:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c066:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c06a:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c06e:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c072:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c076:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c07a:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   2c07e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2c082:	ee77 7aa8 	vadd.f32	s15, s15, s17
   2c086:	eef0 6a47 	vmov.f32	s13, s14
   2c08a:	eee7 6aa8 	vfma.f32	s13, s15, s17
   2c08e:	eec7 7a26 	vdiv.f32	s15, s14, s13
   2c092:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2c096:	ecbd 8b04 	vpop	{d8-d9}
   2c09a:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c09c:	2300      	movs	r3, #0
   2c09e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c0a2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c0a6:	6262      	str	r2, [r4, #36]	; 0x24
   2c0a8:	61e3      	str	r3, [r4, #28]
   2c0aa:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
   2c0ac:	edc4 7a05 	vstr	s15, [r4, #20]
   2c0b0:	e7e5      	b.n	2c07e <tVZFilter_setFreq+0xfa>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2c0b2:	2300      	movs	r3, #0
   2c0b4:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c0b8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2c0bc:	61e2      	str	r2, [r4, #28]
   2c0be:	6223      	str	r3, [r4, #32]
   2c0c0:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2c0c2:	edc4 7a05 	vstr	s15, [r4, #20]
   2c0c6:	e7da      	b.n	2c07e <tVZFilter_setFreq+0xfa>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2c0c8:	2300      	movs	r3, #0
   2c0ca:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c0ce:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2c0d2:	6222      	str	r2, [r4, #32]
   2c0d4:	61e3      	str	r3, [r4, #28]
   2c0d6:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2c0d8:	edc4 7a05 	vstr	s15, [r4, #20]
   2c0dc:	e7cf      	b.n	2c07e <tVZFilter_setFreq+0xfa>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c0de:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c0e2:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c0e6:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c0e8:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c0ec:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c0f0:	f004 fb36 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c0f4:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c0f8:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c0fc:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c100:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c104:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c108:	ee07 3a10 	vmov	s14, r3
   2c10c:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c110:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c114:	f004 fc62 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c118:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c11c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c120:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c122:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c126:	61e3      	str	r3, [r4, #28]
   2c128:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c12a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c12e:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c132:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c136:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c13a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c13e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c142:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c146:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2c14a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c14e:	edc4 7a08 	vstr	s15, [r4, #32]
   2c152:	e794      	b.n	2c07e <tVZFilter_setFreq+0xfa>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c154:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c158:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c15c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c15e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c162:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c166:	f004 fafb 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c16a:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c16e:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c172:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c176:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c17a:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c17e:	ee07 3a10 	vmov	s14, r3
   2c182:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c186:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c18a:	f004 fc27 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c18e:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c192:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c196:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c198:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c19c:	6223      	str	r3, [r4, #32]
   2c19e:	edc4 7a07 	vstr	s15, [r4, #28]
   2c1a2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c1a6:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c1aa:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c1ae:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c1b2:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c1b6:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c1ba:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c1be:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c1c2:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2c1c6:	edc4 7a05 	vstr	s15, [r4, #20]
   2c1ca:	e758      	b.n	2c07e <tVZFilter_setFreq+0xfa>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   2c1cc:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c1d0:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   2c1d4:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c1d8:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c1dc:	f004 fac0 	bl	30760 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c1e0:	ee28 0a00 	vmul.f32	s0, s16, s0
   2c1e4:	f004 fbfa 	bl	309dc <tanf>
			float r  = f->g/wl;
   2c1e8:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c1ec:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   2c1f0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2c1f4:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   2c1f8:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c1fc:	edc4 7a07 	vstr	s15, [r4, #28]
   2c200:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c204:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   2c208:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c20c:	eee0 7a00 	vfma.f32	s15, s0, s0
   2c210:	ee87 6a80 	vdiv.f32	s12, s15, s0
   2c214:	ee76 7a65 	vsub.f32	s15, s12, s11
   2c218:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   2c21c:	eef1 7ac6 	vsqrt.f32	s15, s12
   2c220:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c224:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c228:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c22c:	ed84 7a08 	vstr	s14, [r4, #32]
   2c230:	e725      	b.n	2c07e <tVZFilter_setFreq+0xfa>
			float A = sqrtf(f->G);
   2c232:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c236:	f247 2318 	movw	r3, #29208	; 0x7218
   2c23a:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2c23e:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
   2c242:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c246:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2c24a:	ee07 3a90 	vmov	s15, r3
   2c24e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2c252:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2c256:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   2c25a:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c25e:	f004 fea7 	bl	30fb0 <sinhf>
   2c262:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2c266:	ed84 9a07 	vstr	s18, [r4, #28]
   2c26a:	6265      	str	r5, [r4, #36]	; 0x24
   2c26c:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c270:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2c274:	ed84 8a08 	vstr	s16, [r4, #32]
   2c278:	e701      	b.n	2c07e <tVZFilter_setFreq+0xfa>
		  float A = sqrtf(f->G);
   2c27a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c27e:	f247 2318 	movw	r3, #29208	; 0x7218
   2c282:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
   2c286:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c28a:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2c28e:	ee07 3a90 	vmov	s15, r3
   2c292:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2c296:	eef1 7ac8 	vsqrt.f32	s15, s16
   2c29a:	ee68 8aa7 	vmul.f32	s17, s17, s15
   2c29e:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c2a2:	f004 fe85 	bl	30fb0 <sinhf>
   2c2a6:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2c2aa:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2c2ae:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   2c2b2:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c2b6:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2c2ba:	61e3      	str	r3, [r4, #28]
   2c2bc:	ed84 8a08 	vstr	s16, [r4, #32]
   2c2c0:	e6dd      	b.n	2c07e <tVZFilter_setFreq+0xfa>
		  float x  = 2.0f*f->m-1.0f;
   2c2c2:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2c2c6:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   2c2ca:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2c2ce:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2c2d0:	2300      	movs	r3, #0
			f->R2 = f->invG;
   2c2d2:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   2c2d4:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2c2d8:	ee00 3a90 	vmov	s1, r3
   2c2dc:	eef1 8a48 	vneg.f32	s17, s16
   2c2e0:	eeb0 0a68 	vmov.f32	s0, s17
   2c2e4:	f000 ff74 	bl	2d1d0 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2c2e8:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2c2ea:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2c2ee:	eeb0 0a48 	vmov.f32	s0, s16
   2c2f2:	ee00 3a90 	vmov	s1, r3
   2c2f6:	f000 ff6f 	bl	2d1d8 <minimum>
		  f->cB = 1.0f-x*x;
   2c2fa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2c2fe:	edd4 6a07 	vldr	s13, [r4, #28]
   2c302:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   2c306:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2c30a:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   2c30e:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2c312:	edd4 8a04 	vldr	s17, [r4, #16]
   2c316:	ee67 4aa7 	vmul.f32	s9, s15, s15
   2c31a:	ee27 6a07 	vmul.f32	s12, s14, s14
   2c31e:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2c322:	eea0 6a00 	vfma.f32	s12, s0, s0
   2c326:	eea0 6a45 	vfms.f32	s12, s0, s10
   2c32a:	ee84 5a86 	vdiv.f32	s10, s9, s12
   2c32e:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2c332:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   2c336:	ee66 6a86 	vmul.f32	s13, s13, s12
   2c33a:	ee27 7a06 	vmul.f32	s14, s14, s12
   2c33e:	ee20 0a06 	vmul.f32	s0, s0, s12
   2c342:	edc4 6a07 	vstr	s13, [r4, #28]
   2c346:	ed84 7a08 	vstr	s14, [r4, #32]
   2c34a:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   2c34e:	e696      	b.n	2c07e <tVZFilter_setFreq+0xfa>
		  f->cL = 1.0f;
   2c350:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2c354:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   2c358:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2c35a:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   2c35e:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2c360:	edc4 7a08 	vstr	s15, [r4, #32]
   2c364:	e68b      	b.n	2c07e <tVZFilter_setFreq+0xfa>
   2c366:	edd4 7a05 	vldr	s15, [r4, #20]
   2c36a:	e688      	b.n	2c07e <tVZFilter_setFreq+0xfa>

0002c36c <tVZFilter_setFreqAndBandwidth>:
{
   2c36c:	b538      	push	{r3, r4, r5, lr}
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   2c36e:	2300      	movs	r3, #0
	_tVZFilter* f = *vf;
   2c370:	6804      	ldr	r4, [r0, #0]
{
   2c372:	4605      	mov	r5, r0
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   2c374:	461a      	mov	r2, r3
   2c376:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
{
   2c37a:	ed2d 8b04 	vpush	{d8-d9}
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   2c37e:	ee01 3a10 	vmov	s2, r3
{
   2c382:	eeb0 8a40 	vmov.f32	s16, s0
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   2c386:	ee00 2a10 	vmov	s0, r2
   2c38a:	f000 fd29 	bl	2cde0 <LEAF_clip>
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2c38e:	f64f 0308 	movw	r3, #63496	; 0xf808
   2c392:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2c396:	2200      	movs	r2, #0
   2c398:	f2c0 230f 	movt	r3, #527	; 0x20f
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   2c39c:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   2c3a0:	eef0 0a48 	vmov.f32	s1, s16
   2c3a4:	ee00 2a10 	vmov	s0, r2
   2c3a8:	ed93 1a00 	vldr	s2, [r3]
   2c3ac:	ee21 1a27 	vmul.f32	s2, s2, s15
   2c3b0:	f000 fd16 	bl	2cde0 <LEAF_clip>
   2c3b4:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
   2c3b8:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2c3ba:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c3be:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   2c3c2:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c3c6:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   2c3ca:	ee07 3a90 	vmov	s15, r3
   2c3ce:	ee28 8a07 	vmul.f32	s16, s16, s14
   2c3d2:	ee28 8a27 	vmul.f32	s16, s16, s15
   2c3d6:	eeb0 0a48 	vmov.f32	s0, s16
   2c3da:	f004 faff 	bl	309dc <tanf>
	  switch( f->type )
   2c3de:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2c3e0:	eef0 8a40 	vmov.f32	s17, s0
   2c3e4:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   2c3e8:	2b0a      	cmp	r3, #10
   2c3ea:	f200 81be 	bhi.w	2c76a <tVZFilter_setFreqAndBandwidth+0x3fe>
   2c3ee:	e8df f013 	tbh	[pc, r3, lsl #1]
   2c3f2:	0057      	.short	0x0057
   2c3f4:	006d0062 	.word	0x006d0062
   2c3f8:	00b30078 	.word	0x00b30078
   2c3fc:	012200ef 	.word	0x012200ef
   2c400:	016a0146 	.word	0x016a0146
   2c404:	000b01b1 	.word	0x000b01b1
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c408:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c40c:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c410:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c412:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c416:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c41a:	f004 f9a1 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c41e:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c422:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c426:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c42a:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c42e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c432:	ee07 3a10 	vmov	s14, r3
   2c436:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c43a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c43e:	f004 facd 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c442:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c446:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c44a:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c44e:	edc4 7a07 	vstr	s15, [r4, #28]
   2c452:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c456:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c45a:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c45e:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c462:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c466:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c46a:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c46e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c472:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c476:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c47a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c47e:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   2c482:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2c486:	ee77 7aa8 	vadd.f32	s15, s15, s17
   2c48a:	eef0 6a47 	vmov.f32	s13, s14
   2c48e:	eee7 6aa8 	vfma.f32	s13, s15, s17
   2c492:	eec7 7a26 	vdiv.f32	s15, s14, s13
   2c496:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2c49a:	ecbd 8b04 	vpop	{d8-d9}
   2c49e:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c4a0:	2300      	movs	r3, #0
   2c4a2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c4a6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c4aa:	6262      	str	r2, [r4, #36]	; 0x24
   2c4ac:	61e3      	str	r3, [r4, #28]
   2c4ae:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
   2c4b0:	edc4 7a05 	vstr	s15, [r4, #20]
   2c4b4:	e7e5      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2c4b6:	2300      	movs	r3, #0
   2c4b8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c4bc:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2c4c0:	61e2      	str	r2, [r4, #28]
   2c4c2:	6223      	str	r3, [r4, #32]
   2c4c4:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2c4c6:	edc4 7a05 	vstr	s15, [r4, #20]
   2c4ca:	e7da      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2c4cc:	2300      	movs	r3, #0
   2c4ce:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c4d2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2c4d6:	6222      	str	r2, [r4, #32]
   2c4d8:	61e3      	str	r3, [r4, #28]
   2c4da:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2c4dc:	edc4 7a05 	vstr	s15, [r4, #20]
   2c4e0:	e7cf      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c4e2:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c4e6:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c4ea:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c4ec:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c4f0:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c4f4:	f004 f934 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c4f8:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c4fc:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c500:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c504:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c508:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c50c:	ee07 3a10 	vmov	s14, r3
   2c510:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c514:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c518:	f004 fa60 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c51c:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c520:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c524:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c526:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c52a:	61e3      	str	r3, [r4, #28]
   2c52c:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c52e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c532:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c536:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c53a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c53e:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c542:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c546:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c54a:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2c54e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c552:	edc4 7a08 	vstr	s15, [r4, #32]
   2c556:	e794      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c558:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c55c:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c560:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c562:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c566:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c56a:	f004 f8f9 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c56e:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c572:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c576:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c57a:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c57e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c582:	ee07 3a10 	vmov	s14, r3
   2c586:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c58a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c58e:	f004 fa25 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c592:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c596:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c59a:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c59c:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c5a0:	6223      	str	r3, [r4, #32]
   2c5a2:	edc4 7a07 	vstr	s15, [r4, #28]
   2c5a6:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c5aa:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c5ae:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c5b2:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c5b6:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c5ba:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c5be:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c5c2:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c5c6:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2c5ca:	edc4 7a05 	vstr	s15, [r4, #20]
   2c5ce:	e758      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   2c5d0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c5d4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   2c5d8:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c5dc:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c5e0:	f004 f8be 	bl	30760 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c5e4:	ee28 0a00 	vmul.f32	s0, s16, s0
   2c5e8:	f004 f9f8 	bl	309dc <tanf>
			float r  = f->g/wl;
   2c5ec:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c5f0:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   2c5f4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2c5f8:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   2c5fc:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c600:	edc4 7a07 	vstr	s15, [r4, #28]
   2c604:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c608:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   2c60c:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c610:	eee0 7a00 	vfma.f32	s15, s0, s0
   2c614:	ee87 6a80 	vdiv.f32	s12, s15, s0
   2c618:	ee76 7a65 	vsub.f32	s15, s12, s11
   2c61c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   2c620:	eef1 7ac6 	vsqrt.f32	s15, s12
   2c624:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c628:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c62c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c630:	ed84 7a08 	vstr	s14, [r4, #32]
   2c634:	e725      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
			float A = sqrtf(f->G);
   2c636:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c63a:	f247 2318 	movw	r3, #29208	; 0x7218
   2c63e:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2c642:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
   2c646:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c64a:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2c64e:	ee07 3a90 	vmov	s15, r3
   2c652:	ee20 0a27 	vmul.f32	s0, s0, s15
   2c656:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2c65a:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   2c65e:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c662:	f004 fca5 	bl	30fb0 <sinhf>
   2c666:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2c66a:	ed84 9a07 	vstr	s18, [r4, #28]
   2c66e:	6265      	str	r5, [r4, #36]	; 0x24
   2c670:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2c674:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2c678:	ed84 8a08 	vstr	s16, [r4, #32]
   2c67c:	e701      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
		  float A = sqrtf(f->G);
   2c67e:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c682:	f247 2318 	movw	r3, #29208	; 0x7218
   2c686:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
   2c68a:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c68e:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2c692:	ee07 3a90 	vmov	s15, r3
   2c696:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2c69a:	eef1 7ac8 	vsqrt.f32	s15, s16
   2c69e:	ee68 8aa7 	vmul.f32	s17, s17, s15
   2c6a2:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c6a6:	f004 fc83 	bl	30fb0 <sinhf>
   2c6aa:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2c6ae:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2c6b2:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   2c6b6:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2c6ba:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2c6be:	61e3      	str	r3, [r4, #28]
   2c6c0:	ed84 8a08 	vstr	s16, [r4, #32]
   2c6c4:	e6dd      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
		  float x  = 2.0f*f->m-1.0f;
   2c6c6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2c6ca:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   2c6ce:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2c6d2:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2c6d4:	2300      	movs	r3, #0
			f->R2 = f->invG;
   2c6d6:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   2c6d8:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2c6dc:	ee00 3a90 	vmov	s1, r3
   2c6e0:	eef1 8a48 	vneg.f32	s17, s16
   2c6e4:	eeb0 0a68 	vmov.f32	s0, s17
   2c6e8:	f000 fd72 	bl	2d1d0 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2c6ec:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2c6ee:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2c6f2:	eeb0 0a48 	vmov.f32	s0, s16
   2c6f6:	ee00 3a90 	vmov	s1, r3
   2c6fa:	f000 fd6d 	bl	2d1d8 <minimum>
		  f->cB = 1.0f-x*x;
   2c6fe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2c702:	edd4 6a07 	vldr	s13, [r4, #28]
   2c706:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   2c70a:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2c70e:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   2c712:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2c716:	edd4 8a04 	vldr	s17, [r4, #16]
   2c71a:	ee67 4aa7 	vmul.f32	s9, s15, s15
   2c71e:	ee27 6a07 	vmul.f32	s12, s14, s14
   2c722:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2c726:	eea0 6a00 	vfma.f32	s12, s0, s0
   2c72a:	eea0 6a45 	vfms.f32	s12, s0, s10
   2c72e:	ee84 5a86 	vdiv.f32	s10, s9, s12
   2c732:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2c736:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   2c73a:	ee66 6a86 	vmul.f32	s13, s13, s12
   2c73e:	ee27 7a06 	vmul.f32	s14, s14, s12
   2c742:	ee20 0a06 	vmul.f32	s0, s0, s12
   2c746:	edc4 6a07 	vstr	s13, [r4, #28]
   2c74a:	ed84 7a08 	vstr	s14, [r4, #32]
   2c74e:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   2c752:	e696      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
		  f->cL = 1.0f;
   2c754:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2c758:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   2c75c:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2c75e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   2c762:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2c764:	edc4 7a08 	vstr	s15, [r4, #32]
   2c768:	e68b      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>
   2c76a:	edd4 7a05 	vldr	s15, [r4, #20]
   2c76e:	e688      	b.n	2c482 <tVZFilter_setFreqAndBandwidth+0x116>

0002c770 <tVZFilter_setGain>:
{
   2c770:	b538      	push	{r3, r4, r5, lr}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2c772:	2200      	movs	r2, #0
   2c774:	f243 73bd 	movw	r3, #14269	; 0x37bd
   2c778:	eef0 0a40 	vmov.f32	s1, s0
	_tVZFilter* f = *vf;
   2c77c:	6804      	ldr	r4, [r0, #0]
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2c77e:	f2c4 22c8 	movt	r2, #17096	; 0x42c8
   2c782:	f2c3 5386 	movt	r3, #13702	; 0x3586
{
   2c786:	4605      	mov	r5, r0
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2c788:	ee01 2a10 	vmov	s2, r2
   2c78c:	ee00 3a10 	vmov	s0, r3
{
   2c790:	ed2d 8b04 	vpush	{d8-d9}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2c794:	f000 fb24 	bl	2cde0 <LEAF_clip>
	f->invG = 1.0f/f->G;
   2c798:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2c79c:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2c7a0:	f640 73db 	movw	r3, #4059	; 0xfdb
	f->invG = 1.0f/f->G;
   2c7a4:	ee87 7a80 	vdiv.f32	s14, s15, s0
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2c7a8:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c7ac:	ee07 3a90 	vmov	s15, r3
	f->invG = 1.0f/f->G;
   2c7b0:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
	_tVZFilter* f = *vf;
   2c7b4:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2c7b6:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   2c7ba:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   2c7be:	ee28 8a07 	vmul.f32	s16, s16, s14
   2c7c2:	ee28 8a27 	vmul.f32	s16, s16, s15
   2c7c6:	eeb0 0a48 	vmov.f32	s0, s16
   2c7ca:	f004 f907 	bl	309dc <tanf>
	  switch( f->type )
   2c7ce:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2c7d0:	eef0 8a40 	vmov.f32	s17, s0
   2c7d4:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   2c7d8:	2b0a      	cmp	r3, #10
   2c7da:	f200 81be 	bhi.w	2cb5a <tVZFilter_setGain+0x3ea>
   2c7de:	e8df f013 	tbh	[pc, r3, lsl #1]
   2c7e2:	0057      	.short	0x0057
   2c7e4:	006d0062 	.word	0x006d0062
   2c7e8:	00b30078 	.word	0x00b30078
   2c7ec:	012200ef 	.word	0x012200ef
   2c7f0:	016a0146 	.word	0x016a0146
   2c7f4:	000b01b1 	.word	0x000b01b1
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c7f8:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c7fc:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c800:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c802:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c806:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c80a:	f003 ffa9 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c80e:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c812:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c816:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c81a:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c81e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c822:	ee07 3a10 	vmov	s14, r3
   2c826:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c82a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c82e:	f004 f8d5 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c832:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c836:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c83a:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c83e:	edc4 7a07 	vstr	s15, [r4, #28]
   2c842:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c846:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c84a:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c84e:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c852:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c856:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c85a:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c85e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c862:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c866:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c86a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   2c86e:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   2c872:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2c876:	ee77 7aa8 	vadd.f32	s15, s15, s17
   2c87a:	eef0 6a47 	vmov.f32	s13, s14
   2c87e:	eee7 6aa8 	vfma.f32	s13, s15, s17
   2c882:	eec7 7a26 	vdiv.f32	s15, s14, s13
   2c886:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2c88a:	ecbd 8b04 	vpop	{d8-d9}
   2c88e:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c890:	2300      	movs	r3, #0
   2c892:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c896:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c89a:	6262      	str	r2, [r4, #36]	; 0x24
   2c89c:	61e3      	str	r3, [r4, #28]
   2c89e:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
   2c8a0:	edc4 7a05 	vstr	s15, [r4, #20]
   2c8a4:	e7e5      	b.n	2c872 <tVZFilter_setGain+0x102>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2c8a6:	2300      	movs	r3, #0
   2c8a8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c8ac:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2c8b0:	61e2      	str	r2, [r4, #28]
   2c8b2:	6223      	str	r3, [r4, #32]
   2c8b4:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2c8b6:	edc4 7a05 	vstr	s15, [r4, #20]
   2c8ba:	e7da      	b.n	2c872 <tVZFilter_setGain+0x102>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2c8bc:	2300      	movs	r3, #0
   2c8be:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2c8c2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2c8c6:	6222      	str	r2, [r4, #32]
   2c8c8:	61e3      	str	r3, [r4, #28]
   2c8ca:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2c8cc:	edc4 7a05 	vstr	s15, [r4, #20]
   2c8d0:	e7cf      	b.n	2c872 <tVZFilter_setGain+0x102>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c8d2:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c8d6:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c8da:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c8dc:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c8e0:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c8e4:	f003 ff3c 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c8e8:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c8ec:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c8f0:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c8f4:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c8f8:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c8fc:	ee07 3a10 	vmov	s14, r3
   2c900:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c904:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c908:	f004 f868 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c90c:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c910:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c914:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c916:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c91a:	61e3      	str	r3, [r4, #28]
   2c91c:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c91e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c922:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c926:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c92a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c92e:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c932:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c936:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c93a:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2c93e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2c942:	edc4 7a08 	vstr	s15, [r4, #32]
   2c946:	e794      	b.n	2c872 <tVZFilter_setGain+0x102>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c948:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c94c:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2c950:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2c952:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c956:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c95a:	f003 ff01 	bl	30760 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c95e:	f640 73db 	movw	r3, #4059	; 0xfdb
   2c962:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
   2c966:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   2c96a:	f2c4 0349 	movt	r3, #16457	; 0x4049
   2c96e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c972:	ee07 3a10 	vmov	s14, r3
   2c976:	ee67 7a87 	vmul.f32	s15, s15, s14
   2c97a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2c97e:	f004 f82d 	bl	309dc <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c982:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c986:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c98a:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2c98c:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2c990:	6223      	str	r3, [r4, #32]
   2c992:	edc4 7a07 	vstr	s15, [r4, #28]
   2c996:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2c99a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2c99e:	ee20 0a00 	vmul.f32	s0, s0, s0
   2c9a2:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2c9a6:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c9aa:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2c9ae:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2c9b2:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2c9b6:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2c9ba:	edc4 7a05 	vstr	s15, [r4, #20]
   2c9be:	e758      	b.n	2c872 <tVZFilter_setGain+0x102>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   2c9c0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2c9c4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   2c9c8:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2c9cc:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2c9d0:	f003 fec6 	bl	30760 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2c9d4:	ee28 0a00 	vmul.f32	s0, s16, s0
   2c9d8:	f004 f800 	bl	309dc <tanf>
			float r  = f->g/wl;
   2c9dc:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c9e0:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   2c9e4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2c9e8:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   2c9ec:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2c9f0:	edc4 7a07 	vstr	s15, [r4, #28]
   2c9f4:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2c9f8:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   2c9fc:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2ca00:	eee0 7a00 	vfma.f32	s15, s0, s0
   2ca04:	ee87 6a80 	vdiv.f32	s12, s15, s0
   2ca08:	ee76 7a65 	vsub.f32	s15, s12, s11
   2ca0c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   2ca10:	eef1 7ac6 	vsqrt.f32	s15, s12
   2ca14:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2ca18:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2ca1c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2ca20:	ed84 7a08 	vstr	s14, [r4, #32]
   2ca24:	e725      	b.n	2c872 <tVZFilter_setGain+0x102>
			float A = sqrtf(f->G);
   2ca26:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2ca2a:	f247 2318 	movw	r3, #29208	; 0x7218
   2ca2e:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2ca32:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
   2ca36:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2ca3a:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2ca3e:	ee07 3a90 	vmov	s15, r3
   2ca42:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ca46:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2ca4a:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   2ca4e:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2ca52:	f004 faad 	bl	30fb0 <sinhf>
   2ca56:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2ca5a:	ed84 9a07 	vstr	s18, [r4, #28]
   2ca5e:	6265      	str	r5, [r4, #36]	; 0x24
   2ca60:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2ca64:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2ca68:	ed84 8a08 	vstr	s16, [r4, #32]
   2ca6c:	e701      	b.n	2c872 <tVZFilter_setGain+0x102>
		  float A = sqrtf(f->G);
   2ca6e:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2ca72:	f247 2318 	movw	r3, #29208	; 0x7218
   2ca76:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
   2ca7a:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2ca7e:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
   2ca82:	ee07 3a90 	vmov	s15, r3
   2ca86:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2ca8a:	eef1 7ac8 	vsqrt.f32	s15, s16
   2ca8e:	ee68 8aa7 	vmul.f32	s17, s17, s15
   2ca92:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2ca96:	f004 fa8b 	bl	30fb0 <sinhf>
   2ca9a:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2ca9e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2caa2:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   2caa6:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2caaa:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2caae:	61e3      	str	r3, [r4, #28]
   2cab0:	ed84 8a08 	vstr	s16, [r4, #32]
   2cab4:	e6dd      	b.n	2c872 <tVZFilter_setGain+0x102>
		  float x  = 2.0f*f->m-1.0f;
   2cab6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2caba:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   2cabe:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2cac2:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2cac4:	2300      	movs	r3, #0
			f->R2 = f->invG;
   2cac6:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   2cac8:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2cacc:	ee00 3a90 	vmov	s1, r3
   2cad0:	eef1 8a48 	vneg.f32	s17, s16
   2cad4:	eeb0 0a68 	vmov.f32	s0, s17
   2cad8:	f000 fb7a 	bl	2d1d0 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2cadc:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2cade:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2cae2:	eeb0 0a48 	vmov.f32	s0, s16
   2cae6:	ee00 3a90 	vmov	s1, r3
   2caea:	f000 fb75 	bl	2d1d8 <minimum>
		  f->cB = 1.0f-x*x;
   2caee:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2caf2:	edd4 6a07 	vldr	s13, [r4, #28]
   2caf6:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   2cafa:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   2cafe:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   2cb02:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2cb06:	edd4 8a04 	vldr	s17, [r4, #16]
   2cb0a:	ee67 4aa7 	vmul.f32	s9, s15, s15
   2cb0e:	ee27 6a07 	vmul.f32	s12, s14, s14
   2cb12:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2cb16:	eea0 6a00 	vfma.f32	s12, s0, s0
   2cb1a:	eea0 6a45 	vfms.f32	s12, s0, s10
   2cb1e:	ee84 5a86 	vdiv.f32	s10, s9, s12
   2cb22:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2cb26:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   2cb2a:	ee66 6a86 	vmul.f32	s13, s13, s12
   2cb2e:	ee27 7a06 	vmul.f32	s14, s14, s12
   2cb32:	ee20 0a06 	vmul.f32	s0, s0, s12
   2cb36:	edc4 6a07 	vstr	s13, [r4, #28]
   2cb3a:	ed84 7a08 	vstr	s14, [r4, #32]
   2cb3e:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   2cb42:	e696      	b.n	2c872 <tVZFilter_setGain+0x102>
		  f->cL = 1.0f;
   2cb44:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2cb48:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   2cb4c:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2cb4e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   2cb52:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2cb54:	edc4 7a08 	vstr	s15, [r4, #32]
   2cb58:	e68b      	b.n	2c872 <tVZFilter_setGain+0x102>
   2cb5a:	edd4 7a05 	vldr	s15, [r4, #20]
   2cb5e:	e688      	b.n	2c872 <tVZFilter_setGain+0x102>

0002cb60 <interpolate3max>:
    return(Y);
}

float interpolate3max(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
   2cb60:	f64f 73ff 	movw	r3, #65535	; 0xffff
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float realpeak;
    
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
   2cb64:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
   2cb68:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    float a = buf[peakindex-1];
   2cb6c:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
   2cb70:	440b      	add	r3, r1
   2cb72:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2cb76:	edd0 7a00 	vldr	s15, [r0]
    float c = buf[peakindex+1];
   2cb7a:	ed90 6a02 	vldr	s12, [r0, #8]
    float b = buf[peakindex];
   2cb7e:	edd0 6a01 	vldr	s13, [r0, #4]
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
   2cb82:	ee36 7a67 	vsub.f32	s14, s12, s15
   2cb86:	eed6 7a85 	vfnms.f32	s15, s13, s10
   2cb8a:	ee27 7a07 	vmul.f32	s14, s14, s14
   2cb8e:	ee27 7a25 	vmul.f32	s14, s14, s11
   2cb92:	ee77 7ac6 	vsub.f32	s15, s15, s12
   2cb96:	ee87 0a27 	vdiv.f32	s0, s14, s15
    
    return(realpeak);
}
   2cb9a:	ee30 0a26 	vadd.f32	s0, s0, s13
   2cb9e:	4770      	bx	lr

0002cba0 <interpolate3phase>:

float interpolate3phase(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
   2cba0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float fraction;
    
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2cba4:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2cba8:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    float a = buf[peakindex-1];
   2cbac:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
   2cbb0:	440b      	add	r3, r1
   2cbb2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2cbb6:	edd0 7a00 	vldr	s15, [r0]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2cbba:	edd0 5a01 	vldr	s11, [r0, #4]
   2cbbe:	eeb0 0a67 	vmov.f32	s0, s15
    float c = buf[peakindex+1];
   2cbc2:	ed90 7a02 	vldr	s14, [r0, #8]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2cbc6:	ee77 7a67 	vsub.f32	s15, s14, s15
   2cbca:	ee95 0a86 	vfnms.f32	s0, s11, s12
   2cbce:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2cbd2:	ee30 0a47 	vsub.f32	s0, s0, s14
    
    return(fraction);
}
   2cbd6:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2cbda:	4770      	bx	lr

0002cbdc <fastercosf>:
float fastercosf(float fAngle)
{
    float fASqr = fAngle*fAngle;
    float fResult = 3.705e-02f;
    fResult *= fASqr;
    fResult -= 4.967e-01f;
   2cbdc:	f24c 12be 	movw	r2, #49598	; 0xc1be
   2cbe0:	f644 7376 	movw	r3, #20342	; 0x4f76
    float fASqr = fAngle*fAngle;
   2cbe4:	ee60 6a00 	vmul.f32	s13, s0, s0
    fResult -= 4.967e-01f;
   2cbe8:	f6c3 5217 	movt	r2, #15639	; 0x3d17
   2cbec:	f6cb 63fe 	movt	r3, #48894	; 0xbefe
    fResult *= fASqr;
    fResult += 1.0f;
   2cbf0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fResult -= 4.967e-01f;
   2cbf4:	ee07 2a10 	vmov	s14, r2
   2cbf8:	ee07 3a90 	vmov	s15, r3
   2cbfc:	eee6 7a87 	vfma.f32	s15, s13, s14
    return fResult;
}
   2cc00:	eea6 0aa7 	vfma.f32	s0, s13, s15
   2cc04:	4770      	bx	lr
   2cc06:	bf00      	nop

0002cc08 <fastabsf>:
        unsigned int ui;
    }alias;
    
    alias.f = f;
    alias.ui &= 0x7fffffff;
    return alias.f;
   2cc08:	ee10 3a10 	vmov	r3, s0
   2cc0c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
}
   2cc10:	ee00 3a10 	vmov	s0, r3
   2cc14:	4770      	bx	lr
   2cc16:	bf00      	nop

0002cc18 <fastexp2f>:

// fast floating-point exp2 function taken from Robert Bristow Johnson's
// post in the music-dsp list on Date: Tue, 02 Sep 2014 16:50:11 -0400
float fastexp2f(float x)
{
    if (x >= -127.0)
   2cc18:	2300      	movs	r3, #0
   2cc1a:	f2cc 23fe 	movt	r3, #49918	; 0xc2fe
   2cc1e:	ee07 3a90 	vmov	s15, r3
   2cc22:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cc26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cc2a:	db44      	blt.n	2ccb6 <fastexp2f+0x9e>
    {
        float accumulator, xPower;
        union {float f; int32_t i;} xBits;
        
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2cc2c:	f04f 438b 	mov.w	r3, #1166016512	; 0x45800000
        xPower = x*x;
        accumulator += 0.24137976293709f*xPower;
        xPower *= x;
        accumulator += 0.05203236900844f*xPower;
        xPower *= x;
        accumulator += 0.01355574723481f*xPower;
   2cc30:	f642 4242 	movw	r2, #11330	; 0x2c42
   2cc34:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2cc38:	f641 71e5 	movw	r1, #8165	; 0x1fe5
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2cc3c:	ee07 3a10 	vmov	s14, r3
        accumulator += 0.01355574723481f*xPower;
   2cc40:	f6c3 6277 	movt	r2, #15991	; 0x3e77
   2cc44:	f641 00ed 	movw	r0, #6381	; 0x18ed
   2cc48:	f6c3 5155 	movt	r1, #15701	; 0x3d55
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2cc4c:	ee30 7a07 	vadd.f32	s14, s0, s14
        accumulator += 0.01355574723481f*xPower;
   2cc50:	ee04 2a90 	vmov	s9, r2
   2cc54:	f646 228e 	movw	r2, #27278	; 0x6a8e
   2cc58:	f6c3 405e 	movt	r0, #15454	; 0x3c5e
   2cc5c:	ee05 1a90 	vmov	s11, r1
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2cc60:	eebd 7ac7 	vcvt.s32.f32	s14, s14
        accumulator += 0.01355574723481f*xPower;
   2cc64:	f6c3 7231 	movt	r2, #16177	; 0x3f31
   2cc68:	ee05 0a10 	vmov	s10, r0
   2cc6c:	ee06 2a90 	vmov	s13, r2
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2cc70:	ee17 3a10 	vmov	r3, s14
   2cc74:	f5a3 5280 	sub.w	r2, r3, #4096	; 0x1000
   2cc78:	ee07 2a10 	vmov	s14, r2
        
        xBits.i += 127;                                                    /* bias integer part */
   2cc7c:	f46f 6278 	mvn.w	r2, #3968	; 0xf80
        x -= (float)(xBits.i);                                             /* fractional part */
   2cc80:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
        xBits.i += 127;                                                    /* bias integer part */
   2cc84:	4413      	add	r3, r2
        xBits.i<<= 23;                                                     /* move biased int part into exponent bits */
   2cc86:	05db      	lsls	r3, r3, #23
        x -= (float)(xBits.i);                                             /* fractional part */
   2cc88:	ee30 7a47 	vsub.f32	s14, s0, s14
        xPower = x*x;
   2cc8c:	ee27 6a07 	vmul.f32	s12, s14, s14
        accumulator += 0.01355574723481f*xPower;
   2cc90:	eee6 7a24 	vfma.f32	s15, s12, s9
        xPower *= x;
   2cc94:	ee27 6a06 	vmul.f32	s12, s14, s12
        accumulator += 0.01355574723481f*xPower;
   2cc98:	eeb0 0a67 	vmov.f32	s0, s15
   2cc9c:	eef0 7a66 	vmov.f32	s15, s13
   2cca0:	eea6 0a25 	vfma.f32	s0, s12, s11
   2cca4:	eee6 7a05 	vfma.f32	s15, s12, s10
   2cca8:	eea7 0a27 	vfma.f32	s0, s14, s15
        
        return accumulator * xBits.f;
   2ccac:	ee07 3a10 	vmov	s14, r3
   2ccb0:	ee20 0a07 	vmul.f32	s0, s0, s14
   2ccb4:	4770      	bx	lr
    }
    else
    {
        return 0.0f;
   2ccb6:	2300      	movs	r3, #0
   2ccb8:	ee00 3a10 	vmov	s0, r3
    }
}
   2ccbc:	4770      	bx	lr
   2ccbe:	bf00      	nop

0002ccc0 <LEAF_crossfade>:
 when t = 0, volumes[0] = 0.707, volumes[1] = 0.707 (equal-power cross fade)
 when t = 1, volumes[0] = 1, volumes[1] = 0
 */

void LEAF_crossfade(float fade, float* volumes) {
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   2ccc0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2ccc4:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   2ccc8:	ee30 7a27 	vadd.f32	s14, s0, s15
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2cccc:	ee77 7ac0 	vsub.f32	s15, s15, s0
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   2ccd0:	ee27 7a26 	vmul.f32	s14, s14, s13
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2ccd4:	ee67 7aa6 	vmul.f32	s15, s15, s13
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   2ccd8:	eef1 6ac7 	vsqrt.f32	s13, s14
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2ccdc:	eeb1 7ae7 	vsqrt.f32	s14, s15
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   2cce0:	edc0 6a00 	vstr	s13, [r0]
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2cce4:	ed80 7a01 	vstr	s14, [r0, #4]
}
   2cce8:	4770      	bx	lr
   2ccea:	bf00      	nop

0002ccec <LEAF_frequencyToMidi>:
    return out / amp ;
}
#endif

float LEAF_frequencyToMidi(float f)
{
   2ccec:	b508      	push	{r3, lr}
    return (69.0f + 12.0f * log2f(f * INV_440));
   2ccee:	f24f 2309 	movw	r3, #61961	; 0xf209
   2ccf2:	f6c3 3314 	movt	r3, #15124	; 0x3b14
   2ccf6:	ee07 3a90 	vmov	s15, r3
   2ccfa:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ccfe:	f003 fcaf 	bl	30660 <log2f>
   2cd02:	2300      	movs	r3, #0
   2cd04:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
   2cd08:	f2c4 238a 	movt	r3, #17034	; 0x428a
   2cd0c:	ee07 3a90 	vmov	s15, r3
}
   2cd10:	eee0 7a07 	vfma.f32	s15, s0, s14
   2cd14:	eeb0 0a67 	vmov.f32	s0, s15
   2cd18:	bd08      	pop	{r3, pc}
   2cd1a:	bf00      	nop

0002cd1c <LEAF_shaper>:

// Jones shaper
float LEAF_shaper(float input, float m_drive)
{
   2cd1c:	f240 43f3 	movw	r3, #1267	; 0x4f3
    float fx = input * 2.0f;    // prescale
   2cd20:	ee30 0a00 	vadd.f32	s0, s0, s0
    
    xc = LEAF_clip(-SQRT8, fx, SQRT8);
    xc2 = xc*xc;
    c = 0.5f*fx*(3.0f - (xc2));
    xc4 = xc2 * xc2;
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd24:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd28:	f64c 42cd 	movw	r2, #52429	; 0xcccd
   2cd2c:	4619      	mov	r1, r3
   2cd2e:	f2c4 0335 	movt	r3, #16437	; 0x4035
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd32:	f04f 5072 	mov.w	r0, #1015021568	; 0x3c800000
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd36:	f6c3 524c 	movt	r2, #15692	; 0x3d4c
   2cd3a:	f2cc 0135 	movt	r1, #49205	; 0xc035
   2cd3e:	ee07 3a90 	vmov	s15, r3
   2cd42:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
   2cd46:	ee05 2a10 	vmov	s10, r2
   2cd4a:	ee06 1a90 	vmov	s13, r1
   2cd4e:	fec0 7a67 	vminnm.f32	s15, s0, s15
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd52:	ee04 0a10 	vmov	s8, r0
    shaperOut *= 0.5f;    // post_scale
   2cd56:	f642 7305 	movw	r3, #12037	; 0x2f05
   2cd5a:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
    xc2 = xc*xc;
   2cd5e:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd62:	ee60 5a25 	vmul.f32	s11, s0, s11
    shaperOut *= 0.5f;    // post_scale
   2cd66:	f6c3 7327 	movt	r3, #16167	; 0x3f27
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd6a:	eef6 6a08 	vmov.f32	s13, #104	; 0x3f400000  0.750
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd6e:	ee67 3aa7 	vmul.f32	s7, s15, s15
    shaperOut *= 0.5f;    // post_scale
   2cd72:	ee06 3a10 	vmov	s12, r3
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd76:	ee27 7a67 	vnmul.f32	s14, s14, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd7a:	ee27 0a85 	vmul.f32	s0, s15, s10
    c = 0.5f*fx*(3.0f - (xc2));
   2cd7e:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd82:	eea3 7a84 	vfma.f32	s14, s7, s8
   2cd86:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    c = 0.5f*fx*(3.0f - (xc2));
   2cd8a:	ee74 4ae7 	vsub.f32	s9, s9, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd8e:	ee70 0aa6 	vadd.f32	s1, s1, s13
   2cd92:	eef0 7a40 	vmov.f32	s15, s0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2cd96:	ee37 7a05 	vadd.f32	s14, s14, s10
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   2cd9a:	eee4 7aa5 	vfma.f32	s15, s9, s11
    shaperOut *= 0.5f;    // post_scale
   2cd9e:	ee20 0a86 	vmul.f32	s0, s1, s12
   2cda2:	ee27 0a00 	vmul.f32	s0, s14, s0
    return shaperOut;
}
   2cda6:	ee20 0a27 	vmul.f32	s0, s0, s15
   2cdaa:	4770      	bx	lr

0002cdac <LEAF_round>:
// round input to nearest rnd
float LEAF_round (float input, float rnd)
{
    rnd = fabsf(rnd);
    
    if (rnd <= 0.0000001f) return input;
   2cdac:	f64b 7395 	movw	r3, #49045	; 0xbf95
    rnd = fabsf(rnd);
   2cdb0:	eef0 0ae0 	vabs.f32	s1, s1
    if (rnd <= 0.0000001f) return input;
   2cdb4:	f2c3 33d6 	movt	r3, #13270	; 0x33d6
   2cdb8:	ee07 3a90 	vmov	s15, r3
   2cdbc:	eef4 0ae7 	vcmpe.f32	s1, s15
   2cdc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cdc4:	d905      	bls.n	2cdd2 <LEAF_round+0x26>
    
    float scale = 1.f / rnd;
    
    return roundf(input * scale) / scale;
   2cdc6:	eec0 7a20 	vdiv.f32	s15, s0, s1
   2cdca:	feb8 0a67 	vrinta.f32	s0, s15
   2cdce:	ee20 0a20 	vmul.f32	s0, s0, s1
}
   2cdd2:	4770      	bx	lr

0002cdd4 <LEAF_bitwise_xor>:
{
    union unholy_t unholy;
    unholy.f = input;
    unholy.i = (unholy.i ^ op);
    
    return unholy.f;
   2cdd4:	ee10 3a10 	vmov	r3, s0
   2cdd8:	4058      	eors	r0, r3
}
   2cdda:	ee00 0a10 	vmov	s0, r0
   2cdde:	4770      	bx	lr

0002cde0 <LEAF_clip>:

float   LEAF_clip(float min, float val, float max)
{
    float tempmin = min;
    float tempmax = max;
    if (min > max)
   2cde0:	eeb4 0ac1 	vcmpe.f32	s0, s2
   2cde4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cde8:	dd05      	ble.n	2cdf6 <LEAF_clip+0x16>
   2cdea:	eef0 7a40 	vmov.f32	s15, s0
    {
        tempmin = max;
   2cdee:	eeb0 0a41 	vmov.f32	s0, s2
        tempmax = min;
   2cdf2:	eeb0 1a67 	vmov.f32	s2, s15
    }
    if (val < tempmin)
   2cdf6:	eeb4 0ae0 	vcmpe.f32	s0, s1
   2cdfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cdfe:	dc01      	bgt.n	2ce04 <LEAF_clip+0x24>
   2ce00:	fe81 0a60 	vminnm.f32	s0, s2, s1
    }
    else
    {
        return val;
    }
}
   2ce04:	4770      	bx	lr
   2ce06:	bf00      	nop

0002ce08 <LEAF_clipInt>:

int   LEAF_clipInt(int min, int val, int max)
{
    int tempmin = min;
    int tempmax = max;
    if (min > max)
   2ce08:	4290      	cmp	r0, r2
   2ce0a:	dd02      	ble.n	2ce12 <LEAF_clipInt+0xa>
   2ce0c:	4603      	mov	r3, r0
   2ce0e:	4610      	mov	r0, r2
   2ce10:	461a      	mov	r2, r3
    {
        tempmin = max;
        tempmax = min;
    }
    if (val < tempmin) {
   2ce12:	4288      	cmp	r0, r1
   2ce14:	dc03      	bgt.n	2ce1e <LEAF_clipInt+0x16>
   2ce16:	428a      	cmp	r2, r1
   2ce18:	bfa8      	it	ge
   2ce1a:	460a      	movge	r2, r1
   2ce1c:	4610      	mov	r0, r2
    } else if (val > tempmax) {
        return tempmax;
    } else {
        return val;
    }
}
   2ce1e:	4770      	bx	lr

0002ce20 <LEAF_isPrime>:

oBool     LEAF_isPrime(uint64_t number )
{
    if ( number == 2 ) return OTRUE;
   2ce20:	2900      	cmp	r1, #0
   2ce22:	bf08      	it	eq
   2ce24:	2802      	cmpeq	r0, #2
   2ce26:	d029      	beq.n	2ce7c <LEAF_isPrime+0x5c>
{
   2ce28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if ( number & 1 ) {
   2ce2c:	f000 0401 	and.w	r4, r0, #1
   2ce30:	2500      	movs	r5, #0
   2ce32:	4606      	mov	r6, r0
   2ce34:	ea54 0305 	orrs.w	r3, r4, r5
   2ce38:	d01d      	beq.n	2ce76 <LEAF_isPrime+0x56>
   2ce3a:	460f      	mov	r7, r1
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   2ce3c:	f006 f922 	bl	33084 <__aeabi_ul2d>
   2ce40:	2403      	movs	r4, #3
   2ce42:	2500      	movs	r5, #0
   2ce44:	ec41 0b17 	vmov	d7, r0, r1
   2ce48:	eeb1 7bc7 	vsqrt.f64	d7, d7
   2ce4c:	eefd 7bc7 	vcvt.s32.f64	s15, d7
   2ce50:	ee17 8a90 	vmov	r8, s15
   2ce54:	e006      	b.n	2ce64 <LEAF_isPrime+0x44>
            if ( (number % i) == 0 ) return OFALSE;
   2ce56:	f006 fa59 	bl	3330c <__aeabi_uldivmod>
   2ce5a:	3402      	adds	r4, #2
   2ce5c:	f145 0500 	adc.w	r5, r5, #0
   2ce60:	4313      	orrs	r3, r2
   2ce62:	d008      	beq.n	2ce76 <LEAF_isPrime+0x56>
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   2ce64:	45a0      	cmp	r8, r4
            if ( (number % i) == 0 ) return OFALSE;
   2ce66:	4622      	mov	r2, r4
   2ce68:	462b      	mov	r3, r5
   2ce6a:	4630      	mov	r0, r6
   2ce6c:	4639      	mov	r1, r7
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   2ce6e:	daf2      	bge.n	2ce56 <LEAF_isPrime+0x36>
    if ( number == 2 ) return OTRUE;
   2ce70:	2001      	movs	r0, #1
        return OTRUE; // prime
    }
    else return OFALSE; // even
}
   2ce72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else return OFALSE; // even
   2ce76:	2000      	movs	r0, #0
}
   2ce78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( number == 2 ) return OTRUE;
   2ce7c:	2001      	movs	r0, #1
}
   2ce7e:	4770      	bx	lr

0002ce80 <LEAF_tanh>:

// Adapted from MusicDSP: http://www.musicdsp.org/showone.php?id=238
float LEAF_tanh(float x)
{
    
    if( x < -3.0f )
   2ce80:	eef8 7a08 	vmov.f32	s15, #136	; 0xc0400000 -3.0
   2ce84:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2ce88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ce8c:	d418      	bmi.n	2cec0 <LEAF_tanh+0x40>
        return -1.0f;
    else if( x > 3.0f )
   2ce8e:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   2ce92:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2ce96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ce9a:	dc0e      	bgt.n	2ceba <LEAF_tanh+0x3a>
        return 1.0f;
    else
        return x * ( 27.0f + x * x ) / ( 27.0f + 9.0f * x * x );
   2ce9c:	ee60 6a00 	vmul.f32	s13, s0, s0
   2cea0:	eef3 7a0b 	vmov.f32	s15, #59	; 0x41d80000  27.0
   2cea4:	eeb2 6a02 	vmov.f32	s12, #34	; 0x41100000  9.0
   2cea8:	ee36 7aa7 	vadd.f32	s14, s13, s15
   2ceac:	eee6 7a86 	vfma.f32	s15, s13, s12
   2ceb0:	ee27 7a00 	vmul.f32	s14, s14, s0
   2ceb4:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2ceb8:	4770      	bx	lr
        return 1.0f;
   2ceba:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
}
   2cebe:	4770      	bx	lr
        return -1.0f;
   2cec0:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   2cec4:	4770      	bx	lr
   2cec6:	bf00      	nop

0002cec8 <LEAF_generate_exp>:


//0.001 base gives a good curve that goes from 1 to near zero
void LEAF_generate_exp(float* buffer, float base, float start, float end, float offset, int size)
{
	float increment = (end - start) / (float)size;
   2cec8:	ee07 1a90 	vmov	s15, r1
   2cecc:	ee31 1a60 	vsub.f32	s2, s2, s1
	float x = start;
	for (int i = 0; i < size; i++)
   2ced0:	2900      	cmp	r1, #0
	float increment = (end - start) / (float)size;
   2ced2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
{
   2ced6:	b538      	push	{r3, r4, r5, lr}
   2ced8:	ed2d 8b04 	vpush	{d8-d9}
	float increment = (end - start) / (float)size;
   2cedc:	eec1 8a27 	vdiv.f32	s17, s2, s15
	for (int i = 0; i < size; i++)
   2cee0:	dd16      	ble.n	2cf10 <LEAF_generate_exp+0x48>
   2cee2:	4604      	mov	r4, r0
   2cee4:	eb00 0581 	add.w	r5, r0, r1, lsl #2
   2cee8:	eeb0 8a60 	vmov.f32	s16, s1
   2ceec:	eeb0 9a40 	vmov.f32	s18, s0
   2cef0:	eef0 9a61 	vmov.f32	s19, s3
	{
		buffer[i] = powf(base, x) + offset;
   2cef4:	eef0 0a48 	vmov.f32	s1, s16
   2cef8:	eeb0 0a49 	vmov.f32	s0, s18
   2cefc:	f003 fc30 	bl	30760 <powf>
   2cf00:	ee30 0a29 	vadd.f32	s0, s0, s19
		x += increment;
   2cf04:	ee38 8a28 	vadd.f32	s16, s16, s17
		buffer[i] = powf(base, x) + offset;
   2cf08:	eca4 0a01 	vstmia	r4!, {s0}
	for (int i = 0; i < size; i++)
   2cf0c:	42a5      	cmp	r5, r4
   2cf0e:	d1f1      	bne.n	2cef4 <LEAF_generate_exp+0x2c>
    }
}
   2cf10:	ecbd 8b04 	vpop	{d8-d9}
   2cf14:	bd38      	pop	{r3, r4, r5, pc}
   2cf16:	bf00      	nop

0002cf18 <LEAF_generate_atodbPositiveClipped>:
    }
}


void LEAF_generate_atodbPositiveClipped(float* buffer, float lowerThreshold, float range, int size)
{
   2cf18:	b538      	push	{r3, r4, r5, lr}
    alias.ui &= 0x7fffffff;
   2cf1a:	ee10 3a10 	vmov	r3, s0
    float increment = 1.0f / (float)size;
   2cf1e:	ee07 1a90 	vmov	s15, r1
   2cf22:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    float x = 0.0f;
    float scalar = range / fastabsf(lowerThreshold);
    for (int i = 0; i < size; i++)
   2cf26:	2900      	cmp	r1, #0
    alias.ui &= 0x7fffffff;
   2cf28:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    float increment = 1.0f / (float)size;
   2cf2c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float scalar = range / fastabsf(lowerThreshold);
   2cf30:	ee06 3a90 	vmov	s13, r3
{
   2cf34:	ed2d 8b08 	vpush	{d8-d11}
    float scalar = range / fastabsf(lowerThreshold);
   2cf38:	eec0 9aa6 	vdiv.f32	s19, s1, s13
    float increment = 1.0f / (float)size;
   2cf3c:	eec7 aa27 	vdiv.f32	s21, s14, s15
    for (int i = 0; i < size; i++)
   2cf40:	dd2a      	ble.n	2cf98 <LEAF_generate_atodbPositiveClipped+0x80>
   2cf42:	2300      	movs	r3, #0
   2cf44:	4604      	mov	r4, r0
   2cf46:	eb00 0581 	add.w	r5, r0, r1, lsl #2
   2cf4a:	ee09 3a10 	vmov	s18, r3
    float x = 0.0f;
   2cf4e:	ee08 3a10 	vmov	s16, r3
   2cf52:	fe80 aa49 	vminnm.f32	s20, s0, s18
    {
        float temp = atodb(x);
        temp = LEAF_clip(lowerThreshold, temp, 0.0f);
        buffer[i] = (temp-lowerThreshold) * scalar;
   2cf56:	ee7a ba40 	vsub.f32	s23, s20, s0
   2cf5a:	eef0 8a40 	vmov.f32	s17, s0
   2cf5e:	fe80 9a09 	vmaxnm.f32	s18, s0, s18
}


float atodb(float a)
{
    return 20.0f*log10f(a);
   2cf62:	eeb3 ba04 	vmov.f32	s22, #52	; 0x41a00000  20.0
        buffer[i] = (temp-lowerThreshold) * scalar;
   2cf66:	ee6b baa9 	vmul.f32	s23, s23, s19
    return 20.0f*log10f(a);
   2cf6a:	eeb0 0a48 	vmov.f32	s0, s16
   2cf6e:	f003 ffab 	bl	30ec8 <log10f>
   2cf72:	ee20 0a0b 	vmul.f32	s0, s0, s22
    if (val < tempmin)
   2cf76:	eeb4 aac0 	vcmpe.f32	s20, s0
        buffer[i] = (temp-lowerThreshold) * scalar;
   2cf7a:	fec9 7a40 	vminnm.f32	s15, s18, s0
   2cf7e:	ee77 7ae8 	vsub.f32	s15, s15, s17
    if (val < tempmin)
   2cf82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        buffer[i] = (temp-lowerThreshold) * scalar;
   2cf86:	ee67 7aa9 	vmul.f32	s15, s15, s19
    if (val < tempmin)
   2cf8a:	dc08      	bgt.n	2cf9e <LEAF_generate_atodbPositiveClipped+0x86>
        buffer[i] = (temp-lowerThreshold) * scalar;
   2cf8c:	ece4 7a01 	vstmia	r4!, {s15}
    for (int i = 0; i < size; i++)
   2cf90:	42ac      	cmp	r4, r5
        x += increment;
   2cf92:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
   2cf96:	d1e8      	bne.n	2cf6a <LEAF_generate_atodbPositiveClipped+0x52>
}
   2cf98:	ecbd 8b08 	vpop	{d8-d11}
   2cf9c:	bd38      	pop	{r3, r4, r5, pc}
        buffer[i] = (temp-lowerThreshold) * scalar;
   2cf9e:	ece4 ba01 	vstmia	r4!, {s23}
    for (int i = 0; i < size; i++)
   2cfa2:	42a5      	cmp	r5, r4
        x += increment;
   2cfa4:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
   2cfa8:	d1df      	bne.n	2cf6a <LEAF_generate_atodbPositiveClipped+0x52>
}
   2cfaa:	ecbd 8b08 	vpop	{d8-d11}
   2cfae:	bd38      	pop	{r3, r4, r5, pc}

0002cfb0 <LEAF_midiToFrequency>:
{
   2cfb0:	b508      	push	{r3, lr}
    if( f <= -1500.0f ) return (0);
   2cfb2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   2cfb6:	f2cc 43bb 	movt	r3, #50363	; 0xc4bb
   2cfba:	ee07 3a90 	vmov	s15, r3
   2cfbe:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cfc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cfc6:	d924      	bls.n	2d012 <LEAF_midiToFrequency+0x62>
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
   2cfc8:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
   2cfcc:	2200      	movs	r2, #0
   2cfce:	eef0 7a40 	vmov.f32	s15, s0
   2cfd2:	f64a 23ab 	movw	r3, #43691	; 0xaaab
   2cfd6:	f2c4 41bb 	movt	r1, #17595	; 0x44bb
   2cfda:	f2c4 228a 	movt	r2, #17034	; 0x428a
   2cfde:	f6c3 53aa 	movt	r3, #15786	; 0x3daa
   2cfe2:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2cfe6:	ee06 1a90 	vmov	s13, r1
   2cfea:	ee07 2a10 	vmov	s14, r2
   2cfee:	ee00 3a90 	vmov	s1, r3
   2cff2:	fec7 7ae6 	vminnm.f32	s15, s15, s13
   2cff6:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2cffa:	ee67 0aa0 	vmul.f32	s1, s15, s1
   2cffe:	f003 fbaf 	bl	30760 <powf>
   2d002:	2300      	movs	r3, #0
   2d004:	f2c4 33dc 	movt	r3, #17372	; 0x43dc
   2d008:	ee07 3a90 	vmov	s15, r3
   2d00c:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   2d010:	bd08      	pop	{r3, pc}
    if( f <= -1500.0f ) return (0);
   2d012:	2300      	movs	r3, #0
   2d014:	ee00 3a10 	vmov	s0, r3
}
   2d018:	bd08      	pop	{r3, pc}
   2d01a:	bf00      	nop

0002d01c <LEAF_interpolate_hermite_x>:
    float y0my1 = yy0 - yy1;
   2d01c:	ee70 7a60 	vsub.f32	s15, s0, s1
    float c1 = 0.5f * (yy2 - yy0);
   2d020:	ee31 7a40 	vsub.f32	s14, s2, s0
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
   2d024:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   2d028:	ee71 1ae7 	vsub.f32	s3, s3, s15
   2d02c:	ee70 6ac1 	vsub.f32	s13, s1, s2
    float c2 = y0my1 + c1 - c3;
   2d030:	eee7 7a06 	vfma.f32	s15, s14, s12
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
   2d034:	ee31 1ac1 	vsub.f32	s2, s3, s2
   2d038:	eee1 6a06 	vfma.f32	s13, s2, s12
    float c2 = y0my1 + c1 - c3;
   2d03c:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return ((c3 * xx + c2) * xx + c1) * xx + c0;
   2d040:	eee6 7a82 	vfma.f32	s15, s13, s4
   2d044:	ee67 7a82 	vmul.f32	s15, s15, s4
   2d048:	eee7 7a06 	vfma.f32	s15, s14, s12
}
   2d04c:	eee7 0a82 	vfma.f32	s1, s15, s4
   2d050:	eeb0 0a60 	vmov.f32	s0, s1
   2d054:	4770      	bx	lr
   2d056:	bf00      	nop

0002d058 <LEAF_interpolation_linear>:
{
   2d058:	2300      	movs	r3, #0
   2d05a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2d05e:	ee07 3a10 	vmov	s14, r3
   2d062:	fe81 1a67 	vminnm.f32	s2, s2, s15
   2d066:	fe81 1a07 	vmaxnm.f32	s2, s2, s14
    float omAlpha = 1.0f - alpha;
   2d06a:	ee77 7ac1 	vsub.f32	s15, s15, s2
    out += B * alpha;
   2d06e:	ee20 1a81 	vmul.f32	s2, s1, s2
}
   2d072:	eea7 1a80 	vfma.f32	s2, s15, s0
   2d076:	eeb0 0a41 	vmov.f32	s0, s2
   2d07a:	4770      	bx	lr

0002d07c <mtof>:
{
   2d07c:	b508      	push	{r3, lr}
    if (f <= -1500.0f) return(0);
   2d07e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   2d082:	f2cc 43bb 	movt	r3, #50363	; 0xc4bb
   2d086:	ee07 3a90 	vmov	s15, r3
   2d08a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2d08e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d092:	d91a      	bls.n	2d0ca <mtof+0x4e>
    else return (8.17579891564f * expf(0.0577622650f * f));
   2d094:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
   2d098:	f649 0320 	movw	r3, #38944	; 0x9820
   2d09c:	f2c4 42bb 	movt	r2, #17595	; 0x44bb
   2d0a0:	f6c3 536c 	movt	r3, #15724	; 0x3d6c
   2d0a4:	ee07 2a10 	vmov	s14, r2
   2d0a8:	ee07 3a90 	vmov	s15, r3
   2d0ac:	fe80 0a47 	vminnm.f32	s0, s0, s14
   2d0b0:	ee20 0a27 	vmul.f32	s0, s0, s15
   2d0b4:	f003 f9e6 	bl	30484 <expf>
   2d0b8:	f24d 0313 	movw	r3, #53267	; 0xd013
   2d0bc:	f2c4 1302 	movt	r3, #16642	; 0x4102
   2d0c0:	ee07 3a90 	vmov	s15, r3
   2d0c4:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   2d0c8:	bd08      	pop	{r3, pc}
    if (f <= -1500.0f) return(0);
   2d0ca:	2300      	movs	r3, #0
   2d0cc:	ee00 3a10 	vmov	s0, r3
}
   2d0d0:	bd08      	pop	{r3, pc}
   2d0d2:	bf00      	nop

0002d0d4 <faster_mtof>:
   2d0d4:	f649 0220 	movw	r2, #38944	; 0x9820
   2d0d8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2d0dc:	f24d 0313 	movw	r3, #53267	; 0xd013
   2d0e0:	f6c3 026c 	movt	r2, #14444	; 0x386c
   2d0e4:	f2c4 1302 	movt	r3, #16642	; 0x4102
   2d0e8:	ee06 2a90 	vmov	s13, r2
   2d0ec:	ee07 3a10 	vmov	s14, r3
   2d0f0:	eee0 7a26 	vfma.f32	s15, s0, s13
   2d0f4:	ee27 0aa7 	vmul.f32	s0, s15, s15
   2d0f8:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d0fc:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d100:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d104:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d108:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d10c:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d110:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d114:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d118:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d11c:	ee20 0a07 	vmul.f32	s0, s0, s14
   2d120:	4770      	bx	lr
   2d122:	bf00      	nop

0002d124 <powtodb>:
    if (f <= 0) return (0);
   2d124:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   2d128:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (f <= 0) return (0);
   2d12a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d12e:	f04f 0300 	mov.w	r3, #0
{
   2d132:	ed2d 8b02 	vpush	{d8}
    if (f <= 0) return (0);
   2d136:	ee08 3a10 	vmov	s16, r3
   2d13a:	d91d      	bls.n	2d178 <powtodb+0x54>
        float val = 100.0f + 10.0f/LOGTEN * logf(f);
   2d13c:	ee18 5a10 	vmov	r5, s16
   2d140:	f644 768a 	movw	r6, #20362	; 0x4f8a
   2d144:	f645 772c 	movw	r7, #24364	; 0x5f2c
   2d148:	461c      	mov	r4, r3
   2d14a:	f6ce 5638 	movt	r6, #60728	; 0xed38
   2d14e:	f003 fa1f 	bl	30590 <logf>
   2d152:	f2c4 0559 	movt	r5, #16473	; 0x4059
   2d156:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
   2d15a:	f2c4 0711 	movt	r7, #16401	; 0x4011
   2d15e:	ec45 4b10 	vmov	d0, r4, r5
   2d162:	ec47 6b17 	vmov	d7, r6, r7
   2d166:	eea6 0b07 	vfma.f64	d0, d6, d7
   2d16a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
        return (val < 0.0f ? 0.0f : val);
   2d16e:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
}
   2d172:	ecbd 8b02 	vpop	{d8}
   2d176:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2d178:	ecbd 8b02 	vpop	{d8}
    if (f <= 0) return (0);
   2d17c:	ee00 3a10 	vmov	s0, r3
}
   2d180:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2d182:	bf00      	nop

0002d184 <fastdbtoa>:


float fastdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return expf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
   2d184:	f64c 03e3 	movw	r3, #51427	; 0xc8e3
   2d188:	f6c3 53eb 	movt	r3, #15851	; 0x3deb
   2d18c:	ee07 3a90 	vmov	s15, r3
   2d190:	ee20 0a27 	vmul.f32	s0, s0, s15
   2d194:	f003 b976 	b.w	30484 <expf>

0002d198 <fasterdbtoa>:
    x = 1.0f + (x * 0.00390625f);
   2d198:	f64c 03e3 	movw	r3, #51427	; 0xc8e3
   2d19c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2d1a0:	f6c3 13eb 	movt	r3, #14827	; 0x39eb
   2d1a4:	ee07 3a10 	vmov	s14, r3
   2d1a8:	eee0 7a07 	vfma.f32	s15, s0, s14
    x *= x; x *= x; x *= x; x *= x;
   2d1ac:	ee27 0aa7 	vmul.f32	s0, s15, s15
   2d1b0:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d1b4:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d1b8:	ee20 0a00 	vmul.f32	s0, s0, s0
    x *= x; x *= x; x *= x; x *= x;
   2d1bc:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d1c0:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d1c4:	ee20 0a00 	vmul.f32	s0, s0, s0

float fasterdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return fasterexpf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
}
   2d1c8:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d1cc:	4770      	bx	lr
   2d1ce:	bf00      	nop

0002d1d0 <maximum>:


float maximum (float num1, float num2)
{
    return (num1 > num2 ) ? num1 : num2;
}
   2d1d0:	fe80 0a80 	vmaxnm.f32	s0, s1, s0
   2d1d4:	4770      	bx	lr
   2d1d6:	bf00      	nop

0002d1d8 <minimum>:

float minimum (float num1, float num2)
{
    return (num1 < num2 ) ? num1 : num2;
}
   2d1d8:	fe80 0ac0 	vminnm.f32	s0, s1, s0
   2d1dc:	4770      	bx	lr
   2d1de:	bf00      	nop

0002d1e0 <leaf_pool_init>:
/**
 * create memory pool
 */
void mpool_create (char* memory, size_t size, _tMempool* pool)
{
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d1e0:	f64f 0308 	movw	r3, #63496	; 0xf808
    
    pool->mpool = (char*)memory;
    pool->usize  = 0;
   2d1e4:	2200      	movs	r2, #0
    */
    //is zeroing out the memory necessary? This takes a long time on large pools - JS
}

void leaf_pool_init(char* memory, size_t size)
{
   2d1e6:	b4f0      	push	{r4, r5, r6, r7}
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d1e8:	f2c0 230f 	movt	r3, #527	; 0x20f
   2d1ec:	2710      	movs	r7, #16
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   2d1ee:	f1a1 0610 	sub.w	r6, r1, #16
}

static inline mpool_node_t* create_node(char* block_location, mpool_node_t* next, mpool_node_t* prev, size_t size)
{
    mpool_node_t* node = (mpool_node_t*)block_location;
    node->pool = block_location + leaf.header_size;
   2d1f2:	19c5      	adds	r5, r0, r7
    leaf.mempool = &leaf._mempool;
   2d1f4:	f103 041c 	add.w	r4, r3, #28
    pool->mpool = (char*)memory;
   2d1f8:	61d8      	str	r0, [r3, #28]
    pool->msize  = size;
   2d1fa:	6259      	str	r1, [r3, #36]	; 0x24
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d1fc:	62df      	str	r7, [r3, #44]	; 0x2c
    pool->usize  = 0;
   2d1fe:	621a      	str	r2, [r3, #32]
    node->next = next;
    node->prev = prev;
    node->size = size;
   2d200:	60c6      	str	r6, [r0, #12]
    node->pool = block_location + leaf.header_size;
   2d202:	6005      	str	r5, [r0, #0]
    node->prev = prev;
   2d204:	e9c0 2201 	strd	r2, r2, [r0, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   2d208:	6298      	str	r0, [r3, #40]	; 0x28
    leaf.mempool = &leaf._mempool;
   2d20a:	619c      	str	r4, [r3, #24]
}
   2d20c:	bcf0      	pop	{r4, r5, r6, r7}
   2d20e:	4770      	bx	lr

0002d210 <mpool_alloc>:
{
   2d210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
   2d212:	68cb      	ldr	r3, [r1, #12]
   2d214:	2b00      	cmp	r3, #0
   2d216:	d04c      	beq.n	2d2b2 <mpool_alloc+0xa2>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
   2d218:	3007      	adds	r0, #7
   2d21a:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
   2d21e:	e002      	b.n	2d226 <mpool_alloc+0x16>
        if (node_to_alloc == NULL)
   2d220:	4623      	mov	r3, r4
   2d222:	2c00      	cmp	r4, #0
   2d224:	d045      	beq.n	2d2b2 <mpool_alloc+0xa2>
    while (node_to_alloc->size < size_to_alloc)
   2d226:	68da      	ldr	r2, [r3, #12]
   2d228:	685c      	ldr	r4, [r3, #4]
   2d22a:	4282      	cmp	r2, r0
   2d22c:	d3f8      	bcc.n	2d220 <mpool_alloc+0x10>
    if (leftover > leaf.header_size)
   2d22e:	f64f 0508 	movw	r5, #63496	; 0xf808
    node_to_alloc->size = size_to_alloc;
   2d232:	60d8      	str	r0, [r3, #12]
    size_t leftover = node_to_alloc->size - size_to_alloc;
   2d234:	1a17      	subs	r7, r2, r0
    if (leftover > leaf.header_size)
   2d236:	f2c0 250f 	movt	r5, #527	; 0x20f
   2d23a:	6aee      	ldr	r6, [r5, #44]	; 0x2c
   2d23c:	42be      	cmp	r6, r7
   2d23e:	d327      	bcc.n	2d290 <mpool_alloc+0x80>
        node_to_alloc->size += leftover;
   2d240:	46a4      	mov	ip, r4
   2d242:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
   2d244:	68ca      	ldr	r2, [r1, #12]
   2d246:	429a      	cmp	r2, r3
        pool->head = new_node;
   2d248:	bf08      	it	eq
   2d24a:	f8c1 c00c 	streq.w	ip, [r1, #12]
   2d24e:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
}

static inline void delink_node(mpool_node_t* node)
{
    // If there is a node after the node to remove
    if (node->next != NULL)
   2d252:	b108      	cbz	r0, 2d258 <mpool_alloc+0x48>
    {
        // Close the link
        node->next->prev = node->prev;
   2d254:	6082      	str	r2, [r0, #8]
   2d256:	689a      	ldr	r2, [r3, #8]
    }
    // If there is a node before the node to remove
    if (node->prev != NULL)
   2d258:	b10a      	cbz	r2, 2d25e <mpool_alloc+0x4e>
    {
        // Close the link
        node->prev->next = node->next;
   2d25a:	6858      	ldr	r0, [r3, #4]
   2d25c:	6050      	str	r0, [r2, #4]
    }
    
    node->next = NULL;
   2d25e:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d260:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
   2d262:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d266:	6848      	ldr	r0, [r1, #4]
   2d268:	6aee      	ldr	r6, [r5, #44]	; 0x2c
   2d26a:	4430      	add	r0, r6
   2d26c:	4420      	add	r0, r4
   2d26e:	6048      	str	r0, [r1, #4]
    if (leaf.clearOnAllocation > 0)
   2d270:	6969      	ldr	r1, [r5, #20]
   2d272:	4291      	cmp	r1, r2
   2d274:	dd0a      	ble.n	2d28c <mpool_alloc+0x7c>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   2d276:	68d9      	ldr	r1, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
   2d278:	6818      	ldr	r0, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   2d27a:	b141      	cbz	r1, 2d28e <mpool_alloc+0x7e>
   2d27c:	3801      	subs	r0, #1
   2d27e:	4614      	mov	r4, r2
   2d280:	f800 4f01 	strb.w	r4, [r0, #1]!
   2d284:	3201      	adds	r2, #1
   2d286:	68d9      	ldr	r1, [r3, #12]
   2d288:	4291      	cmp	r1, r2
   2d28a:	d8f9      	bhi.n	2d280 <mpool_alloc+0x70>
   2d28c:	6818      	ldr	r0, [r3, #0]
}
   2d28e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   2d290:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
   2d292:	4430      	add	r0, r6
                               node_to_alloc->prev,
   2d294:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
   2d298:	1bbf      	subs	r7, r7, r6
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   2d29a:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
   2d29e:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
   2d2a0:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
   2d2a4:	4466      	add	r6, ip
   2d2a6:	5016      	str	r6, [r2, r0]
    node->size = size;
   2d2a8:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
   2d2ac:	e9cc 4e01 	strd	r4, lr, [ip, #4]
   2d2b0:	e7c8      	b.n	2d244 <mpool_alloc+0x34>
}

void leaf_mempool_overrun(void)
{
    LEAF_error(1);
   2d2b2:	2001      	movs	r0, #1
   2d2b4:	f7ed fe9c 	bl	1aff0 <LEAF_error>
        return NULL;
   2d2b8:	2000      	movs	r0, #0
}
   2d2ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002d2bc <mpool_calloc>:
{
   2d2bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
   2d2be:	68cb      	ldr	r3, [r1, #12]
   2d2c0:	2b00      	cmp	r3, #0
   2d2c2:	d049      	beq.n	2d358 <mpool_calloc+0x9c>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
   2d2c4:	3007      	adds	r0, #7
   2d2c6:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
   2d2ca:	e002      	b.n	2d2d2 <mpool_calloc+0x16>
        if (node_to_alloc == NULL)
   2d2cc:	4623      	mov	r3, r4
   2d2ce:	2c00      	cmp	r4, #0
   2d2d0:	d042      	beq.n	2d358 <mpool_calloc+0x9c>
    while (node_to_alloc->size < size_to_alloc)
   2d2d2:	68da      	ldr	r2, [r3, #12]
   2d2d4:	685c      	ldr	r4, [r3, #4]
   2d2d6:	4282      	cmp	r2, r0
   2d2d8:	d3f8      	bcc.n	2d2cc <mpool_calloc+0x10>
    if (leftover > leaf.header_size)
   2d2da:	f64f 0508 	movw	r5, #63496	; 0xf808
    node_to_alloc->size = size_to_alloc;
   2d2de:	60d8      	str	r0, [r3, #12]
    size_t leftover = node_to_alloc->size - size_to_alloc;
   2d2e0:	1a17      	subs	r7, r2, r0
    if (leftover > leaf.header_size)
   2d2e2:	f2c0 250f 	movt	r5, #527	; 0x20f
   2d2e6:	6aee      	ldr	r6, [r5, #44]	; 0x2c
   2d2e8:	42be      	cmp	r6, r7
   2d2ea:	d324      	bcc.n	2d336 <mpool_calloc+0x7a>
        node_to_alloc->size += leftover;
   2d2ec:	46a4      	mov	ip, r4
   2d2ee:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
   2d2f0:	68ca      	ldr	r2, [r1, #12]
   2d2f2:	429a      	cmp	r2, r3
        pool->head = new_node;
   2d2f4:	bf08      	it	eq
   2d2f6:	f8c1 c00c 	streq.w	ip, [r1, #12]
   2d2fa:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
    if (node->next != NULL)
   2d2fe:	b108      	cbz	r0, 2d304 <mpool_calloc+0x48>
        node->next->prev = node->prev;
   2d300:	6082      	str	r2, [r0, #8]
   2d302:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   2d304:	b10a      	cbz	r2, 2d30a <mpool_calloc+0x4e>
        node->prev->next = node->next;
   2d306:	6858      	ldr	r0, [r3, #4]
   2d308:	6050      	str	r0, [r2, #4]
    node->next = NULL;
   2d30a:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d30c:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
   2d30e:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d312:	6848      	ldr	r0, [r1, #4]
   2d314:	6aed      	ldr	r5, [r5, #44]	; 0x2c
   2d316:	4428      	add	r0, r5
   2d318:	4420      	add	r0, r4
   2d31a:	6048      	str	r0, [r1, #4]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   2d31c:	68d9      	ldr	r1, [r3, #12]
    char* new_pool = (char*)node_to_alloc->pool;
   2d31e:	6818      	ldr	r0, [r3, #0]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   2d320:	b141      	cbz	r1, 2d334 <mpool_calloc+0x78>
   2d322:	3801      	subs	r0, #1
   2d324:	4614      	mov	r4, r2
   2d326:	f800 4f01 	strb.w	r4, [r0, #1]!
   2d32a:	3201      	adds	r2, #1
   2d32c:	68d9      	ldr	r1, [r3, #12]
   2d32e:	4291      	cmp	r1, r2
   2d330:	d8f9      	bhi.n	2d326 <mpool_calloc+0x6a>
   2d332:	6818      	ldr	r0, [r3, #0]
}
   2d334:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   2d336:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
   2d338:	4430      	add	r0, r6
                               node_to_alloc->prev,
   2d33a:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
   2d33e:	1bbf      	subs	r7, r7, r6
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   2d340:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
   2d344:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
   2d346:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
   2d34a:	4466      	add	r6, ip
   2d34c:	5016      	str	r6, [r2, r0]
    node->size = size;
   2d34e:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
   2d352:	e9cc 4e01 	strd	r4, lr, [ip, #4]
   2d356:	e7cb      	b.n	2d2f0 <mpool_calloc+0x34>
    LEAF_error(1);
   2d358:	2001      	movs	r0, #1
   2d35a:	f7ed fe49 	bl	1aff0 <LEAF_error>
        return NULL;
   2d35e:	2000      	movs	r0, #0
}
   2d360:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2d362:	bf00      	nop

0002d364 <mpool_free>:
{
   2d364:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   2d368:	f64f 0708 	movw	r7, #63496	; 0xf808
    pool->usize -= leaf.header_size + freed_node->size;
   2d36c:	684a      	ldr	r2, [r1, #4]
    mpool_node_t* other_node = pool->head;
   2d36e:	68cb      	ldr	r3, [r1, #12]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   2d370:	f2c0 270f 	movt	r7, #527	; 0x20f
   2d374:	6afc      	ldr	r4, [r7, #44]	; 0x2c
   2d376:	1b00      	subs	r0, r0, r4
    pool->usize -= leaf.header_size + freed_node->size;
   2d378:	1b12      	subs	r2, r2, r4
   2d37a:	68c4      	ldr	r4, [r0, #12]
   2d37c:	1b12      	subs	r2, r2, r4
   2d37e:	604a      	str	r2, [r1, #4]
    while (other_node != NULL)
   2d380:	2b00      	cmp	r3, #0
   2d382:	d03e      	beq.n	2d402 <mpool_free+0x9e>
        if ((long) other_node < (long) pool->mpool ||
   2d384:	680a      	ldr	r2, [r1, #0]
   2d386:	4293      	cmp	r3, r2
   2d388:	db1f      	blt.n	2d3ca <mpool_free+0x66>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
   2d38a:	688c      	ldr	r4, [r1, #8]
   2d38c:	461d      	mov	r5, r3
   2d38e:	4422      	add	r2, r4
        if ((long) other_node < (long) pool->mpool ||
   2d390:	429a      	cmp	r2, r3
   2d392:	d91a      	bls.n	2d3ca <mpool_free+0x66>
    node->next = NULL;
   2d394:	f04f 0c00 	mov.w	ip, #0
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
   2d398:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   2d39a:	68c4      	ldr	r4, [r0, #12]
        next_node = other_node->next;
   2d39c:	685e      	ldr	r6, [r3, #4]
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
   2d39e:	eb02 0e04 	add.w	lr, r2, r4
   2d3a2:	f8d3 800c 	ldr.w	r8, [r3, #12]
   2d3a6:	eb0e 0900 	add.w	r9, lr, r0
   2d3aa:	45a9      	cmp	r9, r5
   2d3ac:	d030      	beq.n	2d410 <mpool_free+0xac>
        else if (((long) other_node) + (leaf.header_size + other_node->size) == (long) freed_node)
   2d3ae:	442a      	add	r2, r5
   2d3b0:	4442      	add	r2, r8
   2d3b2:	4290      	cmp	r0, r2
   2d3b4:	d00e      	beq.n	2d3d4 <mpool_free+0x70>
    while (other_node != NULL)
   2d3b6:	b31e      	cbz	r6, 2d400 <mpool_free+0x9c>
        if ((long) other_node < (long) pool->mpool ||
   2d3b8:	680b      	ldr	r3, [r1, #0]
   2d3ba:	42b3      	cmp	r3, r6
   2d3bc:	dc05      	bgt.n	2d3ca <mpool_free+0x66>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
   2d3be:	688c      	ldr	r4, [r1, #8]
   2d3c0:	4635      	mov	r5, r6
   2d3c2:	441c      	add	r4, r3
   2d3c4:	4633      	mov	r3, r6
        if ((long) other_node < (long) pool->mpool ||
   2d3c6:	42b4      	cmp	r4, r6
   2d3c8:	d8e6      	bhi.n	2d398 <mpool_free+0x34>
            LEAF_error(2);
   2d3ca:	2002      	movs	r0, #2
}
   2d3cc:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            LEAF_error(2);
   2d3d0:	f7ed be0e 	b.w	1aff0 <LEAF_error>
            other_node->size += leaf.header_size + freed_node->size;
   2d3d4:	eb0e 0408 	add.w	r4, lr, r8
   2d3d8:	60dc      	str	r4, [r3, #12]
            if (other_node != pool->head)
   2d3da:	68ca      	ldr	r2, [r1, #12]
   2d3dc:	429a      	cmp	r2, r3
   2d3de:	d02b      	beq.n	2d438 <mpool_free+0xd4>
   2d3e0:	689a      	ldr	r2, [r3, #8]
    if (node->next != NULL)
   2d3e2:	b10e      	cbz	r6, 2d3e8 <mpool_free+0x84>
        node->next->prev = node->prev;
   2d3e4:	60b2      	str	r2, [r6, #8]
   2d3e6:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   2d3e8:	b10a      	cbz	r2, 2d3ee <mpool_free+0x8a>
        node->prev->next = node->next;
   2d3ea:	6858      	ldr	r0, [r3, #4]
   2d3ec:	6050      	str	r0, [r2, #4]
    node->next = NULL;
   2d3ee:	f8c3 c004 	str.w	ip, [r3, #4]
   2d3f2:	4618      	mov	r0, r3
    node->prev = NULL;
   2d3f4:	f8c3 c008 	str.w	ip, [r3, #8]
                other_node->next = pool->head;
   2d3f8:	68ca      	ldr	r2, [r1, #12]
   2d3fa:	605a      	str	r2, [r3, #4]
    while (other_node != NULL)
   2d3fc:	2e00      	cmp	r6, #0
   2d3fe:	d1db      	bne.n	2d3b8 <mpool_free+0x54>
   2d400:	68cb      	ldr	r3, [r1, #12]
    freed_node->next = pool->head;
   2d402:	6043      	str	r3, [r0, #4]
    if (pool->head != NULL) pool->head->prev = freed_node;
   2d404:	68cb      	ldr	r3, [r1, #12]
   2d406:	b103      	cbz	r3, 2d40a <mpool_free+0xa6>
   2d408:	6098      	str	r0, [r3, #8]
    pool->head = freed_node;
   2d40a:	60c8      	str	r0, [r1, #12]
}
   2d40c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            freed_node->size += leaf.header_size + other_node->size;
   2d410:	4444      	add	r4, r8
   2d412:	4422      	add	r2, r4
   2d414:	60c2      	str	r2, [r0, #12]
            if (other_node == pool->head) pool->head = pool->head->next;
   2d416:	68ca      	ldr	r2, [r1, #12]
   2d418:	429a      	cmp	r2, r3
   2d41a:	d00a      	beq.n	2d432 <mpool_free+0xce>
   2d41c:	e9d3 4201 	ldrd	r4, r2, [r3, #4]
    if (node->next != NULL)
   2d420:	b10c      	cbz	r4, 2d426 <mpool_free+0xc2>
        node->next->prev = node->prev;
   2d422:	60a2      	str	r2, [r4, #8]
   2d424:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   2d426:	b10a      	cbz	r2, 2d42c <mpool_free+0xc8>
        node->prev->next = node->next;
   2d428:	685c      	ldr	r4, [r3, #4]
   2d42a:	6054      	str	r4, [r2, #4]
    node->prev = NULL;
   2d42c:	e9c3 cc01 	strd	ip, ip, [r3, #4]
   2d430:	e7c1      	b.n	2d3b6 <mpool_free+0x52>
            if (other_node == pool->head) pool->head = pool->head->next;
   2d432:	685a      	ldr	r2, [r3, #4]
   2d434:	60ca      	str	r2, [r1, #12]
   2d436:	e7f1      	b.n	2d41c <mpool_free+0xb8>
                pool->head = pool->head->next;
   2d438:	4618      	mov	r0, r3
   2d43a:	60ce      	str	r6, [r1, #12]
   2d43c:	e7bb      	b.n	2d3b6 <mpool_free+0x52>
   2d43e:	bf00      	nop

0002d440 <tMempool_init>:
    //TODO: we should make a set of real error codes that are in an enum type
}

void tMempool_init(tMempool* const mp, char* memory, size_t size)
{
   2d440:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    tMempool_freeFromPool(mp, &leaf.mempool);
}

void    tMempool_initToPool     (tMempool* const mp, char* memory, size_t size, tMempool* const mem)
{
    _tMempool* mm = *mem;
   2d444:	f64f 0608 	movw	r6, #63496	; 0xf808
{
   2d448:	b082      	sub	sp, #8
    _tMempool* mm = *mem;
   2d44a:	f2c0 260f 	movt	r6, #527	; 0x20f
   2d44e:	f8d6 c018 	ldr.w	ip, [r6, #24]
    if (pool->head == NULL)
   2d452:	f8dc 300c 	ldr.w	r3, [ip, #12]
   2d456:	b91b      	cbnz	r3, 2d460 <tMempool_init+0x20>
   2d458:	e04c      	b.n	2d4f4 <tMempool_init+0xb4>
        if (node_to_alloc == NULL)
   2d45a:	462b      	mov	r3, r5
   2d45c:	2d00      	cmp	r5, #0
   2d45e:	d049      	beq.n	2d4f4 <tMempool_init+0xb4>
    while (node_to_alloc->size < size_to_alloc)
   2d460:	68dc      	ldr	r4, [r3, #12]
   2d462:	685d      	ldr	r5, [r3, #4]
   2d464:	2c0f      	cmp	r4, #15
   2d466:	d9f8      	bls.n	2d45a <tMempool_init+0x1a>
    node_to_alloc->size = size_to_alloc;
   2d468:	2710      	movs	r7, #16
    size_t leftover = node_to_alloc->size - size_to_alloc;
   2d46a:	f1a4 0e10 	sub.w	lr, r4, #16
    node_to_alloc->size = size_to_alloc;
   2d46e:	60df      	str	r7, [r3, #12]
    if (leftover > leaf.header_size)
   2d470:	6af7      	ldr	r7, [r6, #44]	; 0x2c
   2d472:	45be      	cmp	lr, r7
   2d474:	d849      	bhi.n	2d50a <tMempool_init+0xca>
        node_to_alloc->size += leftover;
   2d476:	46ae      	mov	lr, r5
   2d478:	60dc      	str	r4, [r3, #12]
    if (pool->head == node_to_alloc)
   2d47a:	f8dc 400c 	ldr.w	r4, [ip, #12]
   2d47e:	42a3      	cmp	r3, r4
        pool->head = new_node;
   2d480:	bf08      	it	eq
   2d482:	f8cc e00c 	streq.w	lr, [ip, #12]
   2d486:	e9d3 5401 	ldrd	r5, r4, [r3, #4]
    if (node->next != NULL)
   2d48a:	b10d      	cbz	r5, 2d490 <tMempool_init+0x50>
        node->next->prev = node->prev;
   2d48c:	60ac      	str	r4, [r5, #8]
   2d48e:	689c      	ldr	r4, [r3, #8]
    if (node->prev != NULL)
   2d490:	b10c      	cbz	r4, 2d496 <tMempool_init+0x56>
        node->prev->next = node->next;
   2d492:	685d      	ldr	r5, [r3, #4]
   2d494:	6065      	str	r5, [r4, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d496:	68dc      	ldr	r4, [r3, #12]
    node->next = NULL;
   2d498:	2500      	movs	r5, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d49a:	9401      	str	r4, [sp, #4]
    node->prev = NULL;
   2d49c:	e9c3 5501 	strd	r5, r5, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   2d4a0:	6af4      	ldr	r4, [r6, #44]	; 0x2c
   2d4a2:	f8dc 7004 	ldr.w	r7, [ip, #4]
   2d4a6:	4427      	add	r7, r4
   2d4a8:	463c      	mov	r4, r7
   2d4aa:	9f01      	ldr	r7, [sp, #4]
   2d4ac:	4427      	add	r7, r4
   2d4ae:	f8cc 7004 	str.w	r7, [ip, #4]
    if (leaf.clearOnAllocation > 0)
   2d4b2:	6974      	ldr	r4, [r6, #20]
   2d4b4:	42ac      	cmp	r4, r5
   2d4b6:	dd0a      	ble.n	2d4ce <tMempool_init+0x8e>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   2d4b8:	68df      	ldr	r7, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
   2d4ba:	681c      	ldr	r4, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   2d4bc:	b147      	cbz	r7, 2d4d0 <tMempool_init+0x90>
   2d4be:	3c01      	subs	r4, #1
   2d4c0:	46ac      	mov	ip, r5
   2d4c2:	f804 cf01 	strb.w	ip, [r4, #1]!
   2d4c6:	3501      	adds	r5, #1
   2d4c8:	68df      	ldr	r7, [r3, #12]
   2d4ca:	42bd      	cmp	r5, r7
   2d4cc:	d3f9      	bcc.n	2d4c2 <tMempool_init+0x82>
   2d4ce:	681c      	ldr	r4, [r3, #0]
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   2d4d0:	6004      	str	r4, [r0, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d4d2:	2310      	movs	r3, #16
    pool->usize  = 0;
   2d4d4:	2000      	movs	r0, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d4d6:	62f3      	str	r3, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
   2d4d8:	6021      	str	r1, [r4, #0]
    pool->usize  = 0;
   2d4da:	e9c4 0201 	strd	r0, r2, [r4, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   2d4de:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    node->next = next;
   2d4e0:	6048      	str	r0, [r1, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   2d4e2:	1ad2      	subs	r2, r2, r3
    node->pool = block_location + leaf.header_size;
   2d4e4:	440b      	add	r3, r1
    node->size = size;
   2d4e6:	e9c1 0202 	strd	r0, r2, [r1, #8]
    node->pool = block_location + leaf.header_size;
   2d4ea:	600b      	str	r3, [r1, #0]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   2d4ec:	60e1      	str	r1, [r4, #12]
}
   2d4ee:	b002      	add	sp, #8
   2d4f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2d4f4:	4605      	mov	r5, r0
    LEAF_error(1);
   2d4f6:	2001      	movs	r0, #1
   2d4f8:	460c      	mov	r4, r1
   2d4fa:	f7ed fd79 	bl	1aff0 <LEAF_error>
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   2d4fe:	2300      	movs	r3, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d500:	2210      	movs	r2, #16
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   2d502:	602b      	str	r3, [r5, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   2d504:	62f2      	str	r2, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
   2d506:	601c      	str	r4, [r3, #0]
   2d508:	deff      	udf	#255	; 0xff
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   2d50a:	f8dc 9000 	ldr.w	r9, [ip]
        new_node = create_node(&pool->mpool[offset],
   2d50e:	ebae 0407 	sub.w	r4, lr, r7
        offset += leaf.header_size + node_to_alloc->size;
   2d512:	f107 0810 	add.w	r8, r7, #16
                               node_to_alloc->prev,
   2d516:	f8d3 a008 	ldr.w	sl, [r3, #8]
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   2d51a:	eba3 0e09 	sub.w	lr, r3, r9
        offset += leaf.header_size + node_to_alloc->size;
   2d51e:	44f0      	add	r8, lr
        new_node = create_node(&pool->mpool[offset],
   2d520:	eb09 0e08 	add.w	lr, r9, r8
    node->pool = block_location + leaf.header_size;
   2d524:	4477      	add	r7, lr
   2d526:	f849 7008 	str.w	r7, [r9, r8]
    node->size = size;
   2d52a:	f8ce 400c 	str.w	r4, [lr, #12]
    node->prev = prev;
   2d52e:	e9ce 5a01 	strd	r5, sl, [lr, #4]
   2d532:	e7a2      	b.n	2d47a <tMempool_init+0x3a>

0002d534 <tSimplePoly_initToPool>:
{
    tSimplePoly_initToPool(polyh, maxNumVoices, &leaf.mempool);
}

void    tSimplePoly_initToPool            (tSimplePoly* const polyh, int maxNumVoices, tMempool* const mp)
{
   2d534:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   2d538:	6816      	ldr	r6, [r2, #0]
{
   2d53a:	4680      	mov	r8, r0
   2d53c:	460c      	mov	r4, r1
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   2d53e:	f240 401c 	movw	r0, #1052	; 0x41c
   2d542:	4631      	mov	r1, r6
{
   2d544:	4617      	mov	r7, r2
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   2d546:	f7ff fe63 	bl	2d210 <mpool_alloc>
   2d54a:	4605      	mov	r5, r0
    poly->maxNumVoices = maxNumVoices;

    for (int i = 0; i < 128; i++)
    {
        poly->notes[i][0] = -1;
        poly->notes[i][1] = 0;
   2d54c:	2100      	movs	r1, #0
        poly->notes[i][0] = -1;
   2d54e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2d552:	462b      	mov	r3, r5
   2d554:	f505 6280 	add.w	r2, r5, #1024	; 0x400
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   2d558:	f8c8 5000 	str.w	r5, [r8]
    poly->mempool = m;
   2d55c:	602e      	str	r6, [r5, #0]
    poly->maxNumVoices = maxNumVoices;
   2d55e:	e9c5 4402 	strd	r4, r4, [r5, #8]
        poly->notes[i][1] = 0;
   2d562:	e9c3 0107 	strd	r0, r1, [r3, #28]
   2d566:	3308      	adds	r3, #8
    for (int i = 0; i < 128; i++)
   2d568:	4293      	cmp	r3, r2
   2d56a:	d1fa      	bne.n	2d562 <tSimplePoly_initToPool+0x2e>
    }
    poly->stealing_on = 1;
   2d56c:	2301      	movs	r3, #1
    poly->recover_stolen = 1;
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   2d56e:	00a0      	lsls	r0, r4, #2
   2d570:	4631      	mov	r1, r6
    poly->recover_stolen = 1;
   2d572:	e9c5 3305 	strd	r3, r3, [r5, #20]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   2d576:	f7ff fe4b 	bl	2d210 <mpool_alloc>

    for (int i = 0; i < poly->maxNumVoices; ++i)
   2d57a:	68eb      	ldr	r3, [r5, #12]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   2d57c:	4680      	mov	r8, r0
   2d57e:	6128      	str	r0, [r5, #16]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   2d580:	2b00      	cmp	r3, #0
   2d582:	dd14      	ble.n	2d5ae <tSimplePoly_initToPool+0x7a>
   2d584:	2400      	movs	r4, #0
    {
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
        poly->voices[i][0] = -1;
   2d586:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2d58a:	e001      	b.n	2d590 <tSimplePoly_initToPool+0x5c>
   2d58c:	f8d5 8010 	ldr.w	r8, [r5, #16]
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
   2d590:	4631      	mov	r1, r6
   2d592:	200c      	movs	r0, #12
   2d594:	f7ff fe3c 	bl	2d210 <mpool_alloc>
   2d598:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
        poly->voices[i][0] = -1;
   2d59c:	692b      	ldr	r3, [r5, #16]
   2d59e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   2d5a2:	3401      	adds	r4, #1
        poly->voices[i][0] = -1;
   2d5a4:	f8c3 9000 	str.w	r9, [r3]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   2d5a8:	68eb      	ldr	r3, [r5, #12]
   2d5aa:	42a3      	cmp	r3, r4
   2d5ac:	dcee      	bgt.n	2d58c <tSimplePoly_initToPool+0x58>
    _tMempool* m = *mp;
   2d5ae:	683e      	ldr	r6, [r7, #0]
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   2d5b0:	f44f 7003 	mov.w	r0, #524	; 0x20c
    ns->ordered = OFALSE;
   2d5b4:	2400      	movs	r4, #0
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   2d5b6:	4631      	mov	r1, r6
   2d5b8:	f7ff fe2a 	bl	2d210 <mpool_alloc>
    ns->capacity = STACK_SIZE;
   2d5bc:	2180      	movs	r1, #128	; 0x80
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   2d5be:	4603      	mov	r3, r0
   2d5c0:	6068      	str	r0, [r5, #4]
   2d5c2:	f44f 7200 	mov.w	r2, #512	; 0x200
   2d5c6:	3004      	adds	r0, #4
    ns->capacity = STACK_SIZE;
   2d5c8:	f8a3 1208 	strh.w	r1, [r3, #520]	; 0x208
   2d5cc:	21ff      	movs	r1, #255	; 0xff
    ns->mempool = m;
   2d5ce:	601e      	str	r6, [r3, #0]
    ns->ordered = OFALSE;
   2d5d0:	f883 420a 	strb.w	r4, [r3, #522]	; 0x20a
    ns->pos = 0;
   2d5d4:	f8c3 4204 	str.w	r4, [r3, #516]	; 0x204
    }
    tStack_initToPool(&poly->stack, mp);

}
   2d5d8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2d5dc:	f002 bde9 	b.w	301b2 <memset>

0002d5e0 <tSimplePoly_noteOn>:
    mpool_free((char*)poly->voices, poly->mempool);
    mpool_free((char*)poly, poly->mempool);
}

int tSimplePoly_noteOn(tSimplePoly* const polyh, int note, uint8_t vel)
{
   2d5e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tSimplePoly* poly = *polyh;
   2d5e4:	6806      	ldr	r6, [r0, #0]
    _tStack* ns = *stack;
   2d5e6:	f8d6 c004 	ldr.w	ip, [r6, #4]
    for (int i = 0; i < ns->size; i++)
   2d5ea:	f8bc 7206 	ldrh.w	r7, [ip, #518]	; 0x206
   2d5ee:	b18f      	cbz	r7, 2d614 <tSimplePoly_noteOn+0x34>
   2d5f0:	b28d      	uxth	r5, r1
        if (ns->data[i] == noteVal)    return i;
   2d5f2:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2d5f6:	429d      	cmp	r5, r3
   2d5f8:	f000 809f 	beq.w	2d73a <tSimplePoly_noteOn+0x15a>
   2d5fc:	f10c 0004 	add.w	r0, ip, #4
    for (int i = 0; i < ns->size; i++)
   2d600:	2300      	movs	r3, #0
   2d602:	e004      	b.n	2d60e <tSimplePoly_noteOn+0x2e>
        if (ns->data[i] == noteVal)    return i;
   2d604:	f850 4f04 	ldr.w	r4, [r0, #4]!
   2d608:	42ac      	cmp	r4, r5
   2d60a:	f000 8096 	beq.w	2d73a <tSimplePoly_noteOn+0x15a>
    for (int i = 0; i < ns->size; i++)
   2d60e:	3301      	adds	r3, #1
   2d610:	42bb      	cmp	r3, r7
   2d612:	d1f7      	bne.n	2d604 <tSimplePoly_noteOn+0x24>
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
    else
    {
        alteredVoice = -1;
        oBool found = OFALSE;
        for (int i = 0; i < poly->numVoices; i++)
   2d614:	f8d6 8008 	ldr.w	r8, [r6, #8]
   2d618:	f1b8 0f00 	cmp.w	r8, #0
   2d61c:	dd29      	ble.n	2d672 <tSimplePoly_noteOn+0x92>
        {
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2d61e:	6933      	ldr	r3, [r6, #16]
   2d620:	f8d3 9000 	ldr.w	r9, [r3]
   2d624:	f8d9 b000 	ldr.w	fp, [r9]
   2d628:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
   2d62c:	f000 8089 	beq.w	2d742 <tSimplePoly_noteOn+0x162>
   2d630:	469e      	mov	lr, r3
        for (int i = 0; i < poly->numVoices; i++)
   2d632:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2d634:	461c      	mov	r4, r3
   2d636:	e005      	b.n	2d644 <tSimplePoly_noteOn+0x64>
   2d638:	f854 3f04 	ldr.w	r3, [r4, #4]!
   2d63c:	681d      	ldr	r5, [r3, #0]
   2d63e:	3501      	adds	r5, #1
   2d640:	f000 8082 	beq.w	2d748 <tSimplePoly_noteOn+0x168>
        for (int i = 0; i < poly->numVoices; i++)
   2d644:	3001      	adds	r0, #1
   2d646:	4540      	cmp	r0, r8
   2d648:	ea4f 0a80 	mov.w	sl, r0, lsl #2
   2d64c:	d1f4      	bne.n	2d638 <tSimplePoly_noteOn+0x58>
        if (!found)
        {
            //second preference is grabbing one that is in release phase but not finished sounding yet
            for (int i = 0 ; i < poly->numVoices; i++)
            {
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2d64e:	f11b 0f02 	cmn.w	fp, #2
            for (int i = 0 ; i < poly->numVoices; i++)
   2d652:	f04f 0300 	mov.w	r3, #0
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2d656:	d107      	bne.n	2d668 <tSimplePoly_noteOn+0x88>
   2d658:	e0b4      	b.n	2d7c4 <tSimplePoly_noteOn+0x1e4>
   2d65a:	f85e 9f04 	ldr.w	r9, [lr, #4]!
   2d65e:	f8d9 4000 	ldr.w	r4, [r9]
   2d662:	3402      	adds	r4, #2
   2d664:	f000 80af 	beq.w	2d7c6 <tSimplePoly_noteOn+0x1e6>
            for (int i = 0 ; i < poly->numVoices; i++)
   2d668:	3301      	adds	r3, #1
   2d66a:	4298      	cmp	r0, r3
   2d66c:	ea4f 0583 	mov.w	r5, r3, lsl #2
   2d670:	d1f3      	bne.n	2d65a <tSimplePoly_noteOn+0x7a>
                    tStack_add(&poly->stack, note);
                    break;
                }
            }
        }
        if ((!found) && (poly->stealing_on)) //steal
   2d672:	6973      	ldr	r3, [r6, #20]
   2d674:	2b00      	cmp	r3, #0
   2d676:	d060      	beq.n	2d73a <tSimplePoly_noteOn+0x15a>
        {
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
   2d678:	1e78      	subs	r0, r7, #1
   2d67a:	2f00      	cmp	r7, #0
   2d67c:	d05f      	beq.n	2d73e <tSimplePoly_noteOn+0x15e>
    return ns->data[which];
   2d67e:	eb0c 0380 	add.w	r3, ip, r0, lsl #2
            {
                whichNote = tStack_get(&poly->stack, j);
                whichVoice = poly->notes[whichNote][0];
   2d682:	685b      	ldr	r3, [r3, #4]
   2d684:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
   2d688:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
   2d68a:	2b00      	cmp	r3, #0
   2d68c:	da0b      	bge.n	2d6a6 <tSimplePoly_noteOn+0xc6>
   2d68e:	eb0c 0787 	add.w	r7, ip, r7, lsl #2
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
   2d692:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
   2d696:	d352      	bcc.n	2d73e <tSimplePoly_noteOn+0x15e>
                whichVoice = poly->notes[whichNote][0];
   2d698:	f857 3d04 	ldr.w	r3, [r7, #-4]!
   2d69c:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
   2d6a0:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
   2d6a2:	2b00      	cmp	r3, #0
   2d6a4:	dbf5      	blt.n	2d692 <tSimplePoly_noteOn+0xb2>
                {
                    oldNote = poly->voices[whichVoice][0];
   2d6a6:	6930      	ldr	r0, [r6, #16]
                    poly->voices[whichVoice][0] = note;
                    poly->voices[whichVoice][1] = vel;
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
                    poly->notes[note][0] = whichVoice;
   2d6a8:	eb06 05c1 	add.w	r5, r6, r1, lsl #3
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   2d6ac:	f06f 0702 	mvn.w	r7, #2
                    oldNote = poly->voices[whichVoice][0];
   2d6b0:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   2d6b4:	6820      	ldr	r0, [r4, #0]
                    poly->voices[whichVoice][0] = note;
   2d6b6:	6021      	str	r1, [r4, #0]
                    poly->voices[whichVoice][1] = vel;
   2d6b8:	6934      	ldr	r4, [r6, #16]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   2d6ba:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
                    poly->voices[whichVoice][1] = vel;
   2d6be:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
   2d6c2:	f8cc 2004 	str.w	r2, [ip, #4]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   2d6c6:	61c7      	str	r7, [r0, #28]
   2d6c8:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = whichVoice;
   2d6ca:	61eb      	str	r3, [r5, #28]
                    poly->notes[note][1] = vel;
   2d6cc:	622a      	str	r2, [r5, #32]

                    poly->voices[whichVoice][2] = note;
   2d6ce:	6932      	ldr	r2, [r6, #16]
   2d6d0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2d6d4:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
   2d6d6:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
   2d6d8:	f891 020a 	ldrb.w	r0, [r1, #522]	; 0x20a
        for (j = 0; j < ns->size; j++)
   2d6dc:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
   2d6e0:	b1a0      	cbz	r0, 2d70c <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
   2d6e2:	f1bc 0f00 	cmp.w	ip, #0
   2d6e6:	f000 80a3 	beq.w	2d830 <tSimplePoly_noteOn+0x250>
   2d6ea:	2200      	movs	r2, #0
   2d6ec:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d6f0:	1c54      	adds	r4, r2, #1
            if (noteVal > ns->data[j])
   2d6f2:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d6f4:	4620      	mov	r0, r4
            if (noteVal > ns->data[j])
   2d6f6:	42be      	cmp	r6, r7
   2d6f8:	da04      	bge.n	2d704 <tSimplePoly_noteOn+0x124>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d6fa:	68aa      	ldr	r2, [r5, #8]
   2d6fc:	1c55      	adds	r5, r2, #1
   2d6fe:	d005      	beq.n	2d70c <tSimplePoly_noteOn+0x12c>
   2d700:	42ba      	cmp	r2, r7
   2d702:	dc03      	bgt.n	2d70c <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
   2d704:	b2e2      	uxtb	r2, r4
   2d706:	4562      	cmp	r2, ip
   2d708:	d3f0      	bcc.n	2d6ec <tSimplePoly_noteOn+0x10c>
    int whereToInsert = 0;
   2d70a:	2000      	movs	r0, #0
    for (j = ns->size; j > whereToInsert; j--)
   2d70c:	fa5f f28c 	uxtb.w	r2, ip
   2d710:	4290      	cmp	r0, r2
   2d712:	da08      	bge.n	2d726 <tSimplePoly_noteOn+0x146>
   2d714:	1e56      	subs	r6, r2, #1
   2d716:	eb01 0482 	add.w	r4, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2d71a:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2d71e:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
   2d720:	6065      	str	r5, [r4, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2d722:	4282      	cmp	r2, r0
   2d724:	dcf6      	bgt.n	2d714 <tSimplePoly_noteOn+0x134>
    ns->data[whereToInsert] = noteVal;
   2d726:	eb01 0280 	add.w	r2, r1, r0, lsl #2
    ns->size++;
   2d72a:	f10c 0c01 	add.w	ip, ip, #1
   2d72e:	4618      	mov	r0, r3
    ns->data[whereToInsert] = noteVal;
   2d730:	6057      	str	r7, [r2, #4]
    ns->size++;
   2d732:	f8a1 c206 	strh.w	ip, [r1, #518]	; 0x206
                }
            }
        }
        return alteredVoice;
    }
}
   2d736:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
   2d73a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   2d73e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (int i = 0; i < poly->numVoices; i++)
   2d742:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2d744:	464b      	mov	r3, r9
   2d746:	4682      	mov	sl, r0
                poly->voices[i][0] = note;
   2d748:	6019      	str	r1, [r3, #0]
                poly->notes[note][0] = i;
   2d74a:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                poly->voices[i][1] = vel;
   2d74e:	6935      	ldr	r5, [r6, #16]
   2d750:	b28f      	uxth	r7, r1
   2d752:	f855 500a 	ldr.w	r5, [r5, sl]
   2d756:	606a      	str	r2, [r5, #4]
                poly->notes[note][0] = i;
   2d758:	61e0      	str	r0, [r4, #28]
                poly->notes[note][1] = vel;
   2d75a:	6222      	str	r2, [r4, #32]
                poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
   2d75c:	6933      	ldr	r3, [r6, #16]
   2d75e:	f853 300a 	ldr.w	r3, [r3, sl]
   2d762:	6099      	str	r1, [r3, #8]
    _tStack* ns = *stack;
   2d764:	6872      	ldr	r2, [r6, #4]
    if (ns->ordered)
   2d766:	f892 120a 	ldrb.w	r1, [r2, #522]	; 0x20a
        for (j = 0; j < ns->size; j++)
   2d76a:	f8b2 c206 	ldrh.w	ip, [r2, #518]	; 0x206
    if (ns->ordered)
   2d76e:	b199      	cbz	r1, 2d798 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
   2d770:	f1bc 0f00 	cmp.w	ip, #0
   2d774:	d05e      	beq.n	2d834 <tSimplePoly_noteOn+0x254>
   2d776:	2300      	movs	r3, #0
   2d778:	eb02 0583 	add.w	r5, r2, r3, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d77c:	1c5c      	adds	r4, r3, #1
            if (noteVal > ns->data[j])
   2d77e:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d780:	4621      	mov	r1, r4
            if (noteVal > ns->data[j])
   2d782:	42be      	cmp	r6, r7
   2d784:	da04      	bge.n	2d790 <tSimplePoly_noteOn+0x1b0>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d786:	68ab      	ldr	r3, [r5, #8]
   2d788:	1c5d      	adds	r5, r3, #1
   2d78a:	d005      	beq.n	2d798 <tSimplePoly_noteOn+0x1b8>
   2d78c:	42bb      	cmp	r3, r7
   2d78e:	dc03      	bgt.n	2d798 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
   2d790:	b2e3      	uxtb	r3, r4
   2d792:	459c      	cmp	ip, r3
   2d794:	d8f0      	bhi.n	2d778 <tSimplePoly_noteOn+0x198>
    int whereToInsert = 0;
   2d796:	2100      	movs	r1, #0
    for (j = ns->size; j > whereToInsert; j--)
   2d798:	fa5f f38c 	uxtb.w	r3, ip
   2d79c:	428b      	cmp	r3, r1
   2d79e:	dd08      	ble.n	2d7b2 <tSimplePoly_noteOn+0x1d2>
   2d7a0:	1e5e      	subs	r6, r3, #1
   2d7a2:	eb02 0483 	add.w	r4, r2, r3, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2d7a6:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2d7aa:	b2f3      	uxtb	r3, r6
        ns->data[j] = ns->data[(j - 1)];
   2d7ac:	6065      	str	r5, [r4, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2d7ae:	428b      	cmp	r3, r1
   2d7b0:	dcf6      	bgt.n	2d7a0 <tSimplePoly_noteOn+0x1c0>
    ns->data[whereToInsert] = noteVal;
   2d7b2:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    ns->size++;
   2d7b6:	f10c 0c01 	add.w	ip, ip, #1
    ns->data[whereToInsert] = noteVal;
   2d7ba:	604f      	str	r7, [r1, #4]
    ns->size++;
   2d7bc:	f8a2 c206 	strh.w	ip, [r2, #518]	; 0x206
}
   2d7c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2d7c4:	461d      	mov	r5, r3
                    poly->voices[i][0] = note;
   2d7c6:	f8c9 1000 	str.w	r1, [r9]
                    poly->notes[note][0] = i;
   2d7ca:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                    poly->voices[i][1] = vel;
   2d7ce:	6937      	ldr	r7, [r6, #16]
   2d7d0:	597f      	ldr	r7, [r7, r5]
   2d7d2:	607a      	str	r2, [r7, #4]
   2d7d4:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = i;
   2d7d6:	61e3      	str	r3, [r4, #28]
                    poly->notes[note][1] = vel;
   2d7d8:	6222      	str	r2, [r4, #32]
                    poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
   2d7da:	6932      	ldr	r2, [r6, #16]
   2d7dc:	5952      	ldr	r2, [r2, r5]
   2d7de:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
   2d7e0:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
   2d7e2:	f891 020a 	ldrb.w	r0, [r1, #522]	; 0x20a
        for (j = 0; j < ns->size; j++)
   2d7e6:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
   2d7ea:	b198      	cbz	r0, 2d814 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
   2d7ec:	f1bc 0f00 	cmp.w	ip, #0
   2d7f0:	d01e      	beq.n	2d830 <tSimplePoly_noteOn+0x250>
   2d7f2:	2200      	movs	r2, #0
   2d7f4:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d7f8:	1c54      	adds	r4, r2, #1
            if (noteVal > ns->data[j])
   2d7fa:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d7fc:	4620      	mov	r0, r4
            if (noteVal > ns->data[j])
   2d7fe:	42be      	cmp	r6, r7
   2d800:	da04      	bge.n	2d80c <tSimplePoly_noteOn+0x22c>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2d802:	68aa      	ldr	r2, [r5, #8]
   2d804:	1c56      	adds	r6, r2, #1
   2d806:	d005      	beq.n	2d814 <tSimplePoly_noteOn+0x234>
   2d808:	42ba      	cmp	r2, r7
   2d80a:	dc03      	bgt.n	2d814 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
   2d80c:	b2e2      	uxtb	r2, r4
   2d80e:	4562      	cmp	r2, ip
   2d810:	d3f0      	bcc.n	2d7f4 <tSimplePoly_noteOn+0x214>
    int whereToInsert = 0;
   2d812:	2000      	movs	r0, #0
    for (j = ns->size; j > whereToInsert; j--)
   2d814:	fa5f f28c 	uxtb.w	r2, ip
   2d818:	4290      	cmp	r0, r2
   2d81a:	da84      	bge.n	2d726 <tSimplePoly_noteOn+0x146>
   2d81c:	1e56      	subs	r6, r2, #1
   2d81e:	eb01 0482 	add.w	r4, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2d822:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2d826:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
   2d828:	6065      	str	r5, [r4, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2d82a:	4282      	cmp	r2, r0
   2d82c:	dcf6      	bgt.n	2d81c <tSimplePoly_noteOn+0x23c>
   2d82e:	e77a      	b.n	2d726 <tSimplePoly_noteOn+0x146>
    int whereToInsert = 0;
   2d830:	4660      	mov	r0, ip
   2d832:	e778      	b.n	2d726 <tSimplePoly_noteOn+0x146>
   2d834:	4661      	mov	r1, ip
   2d836:	e7bc      	b.n	2d7b2 <tSimplePoly_noteOn+0x1d2>

0002d838 <tSimplePoly_noteOff>:



int tSimplePoly_noteOff(tSimplePoly* const polyh, uint8_t note)
{
   2d838:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
   2d83c:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
   2d83e:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
   2d842:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
   2d846:	b178      	cbz	r0, 2d868 <tSimplePoly_noteOff+0x30>
        if (ns->data[i] == noteVal)    return i;
   2d848:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2d84c:	428b      	cmp	r3, r1
   2d84e:	f000 808a 	beq.w	2d966 <tSimplePoly_noteOff+0x12e>
   2d852:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
   2d856:	2600      	movs	r6, #0
   2d858:	e003      	b.n	2d862 <tSimplePoly_noteOff+0x2a>
        if (ns->data[i] == noteVal)    return i;
   2d85a:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2d85e:	428a      	cmp	r2, r1
   2d860:	d057      	beq.n	2d912 <tSimplePoly_noteOff+0xda>
    for (int i = 0; i < ns->size; i++)
   2d862:	3601      	adds	r6, #1
   2d864:	4286      	cmp	r6, r0
   2d866:	d1f8      	bne.n	2d85a <tSimplePoly_noteOff+0x22>
    int16_t noteToTest = -1;

    tStack_remove(&poly->stack, note);
    poly->notes[note][0] = -1;
   2d868:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
   2d86c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2d870:	61d8      	str	r0, [r3, #28]

    int deactivatedVoice = -1;
    for (int i = 0; i < poly->maxNumVoices; i++)
   2d872:	68ee      	ldr	r6, [r5, #12]
   2d874:	2e00      	cmp	r6, #0
   2d876:	dd12      	ble.n	2d89e <tSimplePoly_noteOff+0x66>
    {
        if (poly->voices[i][0] == note)
   2d878:	692b      	ldr	r3, [r5, #16]
   2d87a:	681a      	ldr	r2, [r3, #0]
   2d87c:	6810      	ldr	r0, [r2, #0]
   2d87e:	4288      	cmp	r0, r1
   2d880:	d00f      	beq.n	2d8a2 <tSimplePoly_noteOff+0x6a>
    for (int i = 0; i < poly->maxNumVoices; i++)
   2d882:	2000      	movs	r0, #0
   2d884:	e004      	b.n	2d890 <tSimplePoly_noteOff+0x58>
        if (poly->voices[i][0] == note)
   2d886:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2d88a:	6814      	ldr	r4, [r2, #0]
   2d88c:	428c      	cmp	r4, r1
   2d88e:	d00a      	beq.n	2d8a6 <tSimplePoly_noteOff+0x6e>
    for (int i = 0; i < poly->maxNumVoices; i++)
   2d890:	3001      	adds	r0, #1
   2d892:	42b0      	cmp	r0, r6
   2d894:	ea4f 0780 	mov.w	r7, r0, lsl #2
   2d898:	d1f5      	bne.n	2d886 <tSimplePoly_noteOff+0x4e>
                {
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
                    poly->voices[deactivatedVoice][2] = noteToTest;
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
                    return -1;
   2d89a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                }
            }
        }
    }
    return deactivatedVoice;
}
   2d89e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    for (int i = 0; i < poly->maxNumVoices; i++)
   2d8a2:	2000      	movs	r0, #0
        if (poly->voices[i][0] == note)
   2d8a4:	4607      	mov	r7, r0
            poly->voices[i][0] = -1;
   2d8a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
            poly->voices[i][1] = 0;
   2d8aa:	2600      	movs	r6, #0
            poly->voices[i][0] = -1;
   2d8ac:	6013      	str	r3, [r2, #0]
            poly->voices[i][1] = 0;
   2d8ae:	692b      	ldr	r3, [r5, #16]
   2d8b0:	59db      	ldr	r3, [r3, r7]
   2d8b2:	605e      	str	r6, [r3, #4]
    if (poly->recover_stolen)
   2d8b4:	69ab      	ldr	r3, [r5, #24]
   2d8b6:	2b00      	cmp	r3, #0
   2d8b8:	d0f1      	beq.n	2d89e <tSimplePoly_noteOff+0x66>
    _tStack* ns = *stack;
   2d8ba:	6869      	ldr	r1, [r5, #4]
    return ns->size;
   2d8bc:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2d8c0:	f1bc 0f00 	cmp.w	ip, #0
   2d8c4:	d0eb      	beq.n	2d89e <tSimplePoly_noteOff+0x66>
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2d8c6:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   2d8ca:	1cdc      	adds	r4, r3, #3
   2d8cc:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   2d8d0:	6852      	ldr	r2, [r2, #4]
   2d8d2:	3203      	adds	r2, #3
   2d8d4:	d00d      	beq.n	2d8f2 <tSimplePoly_noteOff+0xba>
   2d8d6:	3104      	adds	r1, #4
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2d8d8:	4632      	mov	r2, r6
   2d8da:	3201      	adds	r2, #1
   2d8dc:	4562      	cmp	r2, ip
   2d8de:	d0de      	beq.n	2d89e <tSimplePoly_noteOff+0x66>
                noteToTest = tStack_get(&poly->stack, j);
   2d8e0:	f851 3f04 	ldr.w	r3, [r1, #4]!
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2d8e4:	b21b      	sxth	r3, r3
   2d8e6:	1cdc      	adds	r4, r3, #3
   2d8e8:	eb05 06c4 	add.w	r6, r5, r4, lsl #3
   2d8ec:	6876      	ldr	r6, [r6, #4]
   2d8ee:	3603      	adds	r6, #3
   2d8f0:	d1f3      	bne.n	2d8da <tSimplePoly_noteOff+0xa2>
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2d8f2:	692a      	ldr	r2, [r5, #16]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2d8f4:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
   2d8f8:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2d8fc:	59d2      	ldr	r2, [r2, r7]
   2d8fe:	6013      	str	r3, [r2, #0]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2d900:	692a      	ldr	r2, [r5, #16]
   2d902:	6a09      	ldr	r1, [r1, #32]
   2d904:	59d2      	ldr	r2, [r2, r7]
   2d906:	6051      	str	r1, [r2, #4]
                    poly->voices[deactivatedVoice][2] = noteToTest;
   2d908:	692a      	ldr	r2, [r5, #16]
   2d90a:	59d2      	ldr	r2, [r2, r7]
   2d90c:	6093      	str	r3, [r2, #8]
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
   2d90e:	6060      	str	r0, [r4, #4]
   2d910:	e7c3      	b.n	2d89a <tSimplePoly_noteOff+0x62>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2d912:	eba0 0806 	sub.w	r8, r0, r6
   2d916:	f1b8 0f00 	cmp.w	r8, #0
   2d91a:	dd22      	ble.n	2d962 <tSimplePoly_noteOff+0x12a>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2d91c:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
   2d920:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
   2d922:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2d926:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
   2d928:	4613      	mov	r3, r2
   2d92a:	44ce      	add	lr, r9
   2d92c:	e006      	b.n	2d93c <tSimplePoly_noteOff+0x104>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2d92e:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
   2d930:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2d934:	b2d2      	uxtb	r2, r2
   2d936:	4590      	cmp	r8, r2
   2d938:	4613      	mov	r3, r2
   2d93a:	dd0f      	ble.n	2d95c <tSimplePoly_noteOff+0x124>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2d93c:	4433      	add	r3, r6
   2d93e:	4573      	cmp	r3, lr
   2d940:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
   2d944:	daf3      	bge.n	2d92e <tSimplePoly_noteOff+0xf6>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2d946:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
   2d948:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2d94a:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2d94c:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
   2d94e:	bf08      	it	eq
   2d950:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2d954:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2d956:	4590      	cmp	r8, r2
   2d958:	4613      	mov	r3, r2
   2d95a:	dcef      	bgt.n	2d93c <tSimplePoly_noteOff+0x104>
        ns->size--;
   2d95c:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
   2d960:	e782      	b.n	2d868 <tSimplePoly_noteOff+0x30>
   2d962:	3801      	subs	r0, #1
   2d964:	e7fa      	b.n	2d95c <tSimplePoly_noteOff+0x124>
        if (ns->data[i] == noteVal)    return i;
   2d966:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
   2d968:	2600      	movs	r6, #0
   2d96a:	e7d7      	b.n	2d91c <tSimplePoly_noteOff+0xe4>

0002d96c <tSimplePoly_deactivateVoice>:


void tSimplePoly_deactivateVoice(tSimplePoly* const polyh, uint8_t voice)
{
   2d96c:	b4f0      	push	{r4, r5, r6, r7}
    _tSimplePoly* poly = *polyh;
   2d96e:	6803      	ldr	r3, [r0, #0]

    if (poly->voices[voice][0] == -2) //only do this if the voice is waiting for deactivation (not already reassigned while waiting)
   2d970:	b208      	sxth	r0, r1
   2d972:	691a      	ldr	r2, [r3, #16]
   2d974:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
   2d978:	6822      	ldr	r2, [r4, #0]
   2d97a:	3202      	adds	r2, #2
   2d97c:	d001      	beq.n	2d982 <tSimplePoly_deactivateVoice+0x16>
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
                }
            }
        }
    }
}
   2d97e:	bcf0      	pop	{r4, r5, r6, r7}
   2d980:	4770      	bx	lr
        poly->voices[voice][0] = -1;
   2d982:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2d986:	0085      	lsls	r5, r0, #2
        poly->voices[voice][1] = 0;
   2d988:	2200      	movs	r2, #0
        poly->voices[voice][0] = -1;
   2d98a:	6026      	str	r6, [r4, #0]
        poly->voices[voice][1] = 0;
   2d98c:	691c      	ldr	r4, [r3, #16]
   2d98e:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
   2d992:	6042      	str	r2, [r0, #4]
        if (poly->recover_stolen)
   2d994:	6998      	ldr	r0, [r3, #24]
   2d996:	2800      	cmp	r0, #0
   2d998:	d0f1      	beq.n	2d97e <tSimplePoly_deactivateVoice+0x12>
    _tStack* ns = *stack;
   2d99a:	6858      	ldr	r0, [r3, #4]
    return ns->size;
   2d99c:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2d9a0:	2e00      	cmp	r6, #0
   2d9a2:	d0ec      	beq.n	2d97e <tSimplePoly_deactivateVoice+0x12>
   2d9a4:	f246 3c94 	movw	ip, #25492	; 0x6394
   2d9a8:	4607      	mov	r7, r0
   2d9aa:	f2c0 0c06 	movt	ip, #6
    return ns->data[which];
   2d9ae:	eb00 0082 	add.w	r0, r0, r2, lsl #2
                noteToTest = tStack_get(&poly->stack, j);
   2d9b2:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2d9b6:	eb03 04c0 	add.w	r4, r3, r0, lsl #3
                noteToTest = tStack_get(&poly->stack, j);
   2d9ba:	f8ac 0000 	strh.w	r0, [ip]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2d9be:	69e4      	ldr	r4, [r4, #28]
   2d9c0:	3403      	adds	r4, #3
   2d9c2:	d004      	beq.n	2d9ce <tSimplePoly_deactivateVoice+0x62>
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2d9c4:	3201      	adds	r2, #1
   2d9c6:	42b2      	cmp	r2, r6
   2d9c8:	dad9      	bge.n	2d97e <tSimplePoly_deactivateVoice+0x12>
{
   2d9ca:	4638      	mov	r0, r7
   2d9cc:	e7ef      	b.n	2d9ae <tSimplePoly_deactivateVoice+0x42>
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2d9ce:	691c      	ldr	r4, [r3, #16]
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2d9d0:	3201      	adds	r2, #1
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2d9d2:	5964      	ldr	r4, [r4, r5]
   2d9d4:	6020      	str	r0, [r4, #0]
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2d9d6:	f9bc 0000 	ldrsh.w	r0, [ip]
   2d9da:	691c      	ldr	r4, [r3, #16]
   2d9dc:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
   2d9e0:	5967      	ldr	r7, [r4, r5]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
   2d9e2:	4634      	mov	r4, r6
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2d9e4:	6a36      	ldr	r6, [r6, #32]
   2d9e6:	607e      	str	r6, [r7, #4]
                    poly->voices[voice][2] = noteToTest;
   2d9e8:	691e      	ldr	r6, [r3, #16]
   2d9ea:	5976      	ldr	r6, [r6, r5]
   2d9ec:	60b0      	str	r0, [r6, #8]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
   2d9ee:	61e1      	str	r1, [r4, #28]
   2d9f0:	685f      	ldr	r7, [r3, #4]
   2d9f2:	f8b7 6206 	ldrh.w	r6, [r7, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2d9f6:	4296      	cmp	r6, r2
   2d9f8:	ddc1      	ble.n	2d97e <tSimplePoly_deactivateVoice+0x12>
{
   2d9fa:	4638      	mov	r0, r7
   2d9fc:	e7d7      	b.n	2d9ae <tSimplePoly_deactivateVoice+0x42>
   2d9fe:	bf00      	nop

0002da00 <tSimplePoly_markPendingNoteOff>:
    return voiceWithThatNote;
}


int tSimplePoly_markPendingNoteOff(tSimplePoly* const polyh, uint8_t note)
{
   2da00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
   2da04:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
   2da06:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
   2da0a:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
   2da0e:	b170      	cbz	r0, 2da2e <tSimplePoly_markPendingNoteOff+0x2e>
        if (ns->data[i] == noteVal)    return i;
   2da10:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2da14:	428b      	cmp	r3, r1
   2da16:	d05c      	beq.n	2dad2 <tSimplePoly_markPendingNoteOff+0xd2>
   2da18:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
   2da1c:	2600      	movs	r6, #0
   2da1e:	e003      	b.n	2da28 <tSimplePoly_markPendingNoteOff+0x28>
        if (ns->data[i] == noteVal)    return i;
   2da20:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2da24:	4291      	cmp	r1, r2
   2da26:	d006      	beq.n	2da36 <tSimplePoly_markPendingNoteOff+0x36>
    for (int i = 0; i < ns->size; i++)
   2da28:	3601      	adds	r6, #1
   2da2a:	42b0      	cmp	r0, r6
   2da2c:	d1f8      	bne.n	2da20 <tSimplePoly_markPendingNoteOff+0x20>
    int deactivatedVoice = -1;
   2da2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }


    }
    return deactivatedVoice;
}
   2da32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
   2da36:	eba0 0806 	sub.w	r8, r0, r6
   2da3a:	f1b8 0f00 	cmp.w	r8, #0
   2da3e:	dd46      	ble.n	2dace <tSimplePoly_markPendingNoteOff+0xce>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2da40:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
   2da44:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
   2da46:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2da4a:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
   2da4c:	4613      	mov	r3, r2
   2da4e:	44ce      	add	lr, r9
   2da50:	e006      	b.n	2da60 <tSimplePoly_markPendingNoteOff+0x60>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2da52:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
   2da54:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2da58:	b2d2      	uxtb	r2, r2
   2da5a:	4590      	cmp	r8, r2
   2da5c:	4613      	mov	r3, r2
   2da5e:	dd0f      	ble.n	2da80 <tSimplePoly_markPendingNoteOff+0x80>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2da60:	4433      	add	r3, r6
   2da62:	4573      	cmp	r3, lr
   2da64:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
   2da68:	daf3      	bge.n	2da52 <tSimplePoly_markPendingNoteOff+0x52>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2da6a:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
   2da6c:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2da6e:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2da70:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
   2da72:	bf08      	it	eq
   2da74:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2da78:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2da7a:	4590      	cmp	r8, r2
   2da7c:	4613      	mov	r3, r2
   2da7e:	dcef      	bgt.n	2da60 <tSimplePoly_markPendingNoteOff+0x60>
        poly->notes[note][0] = -2;
   2da80:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
   2da84:	f06f 0201 	mvn.w	r2, #1
        ns->size--;
   2da88:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
        poly->notes[note][0] = -2;
   2da8c:	61da      	str	r2, [r3, #28]
        for (int i = 0; i < poly->maxNumVoices; i++)
   2da8e:	68ee      	ldr	r6, [r5, #12]
   2da90:	2e00      	cmp	r6, #0
   2da92:	ddcc      	ble.n	2da2e <tSimplePoly_markPendingNoteOff+0x2e>
            if (poly->voices[i][0] == note)
   2da94:	692b      	ldr	r3, [r5, #16]
   2da96:	681a      	ldr	r2, [r3, #0]
   2da98:	6810      	ldr	r0, [r2, #0]
   2da9a:	4281      	cmp	r1, r0
   2da9c:	d00c      	beq.n	2dab8 <tSimplePoly_markPendingNoteOff+0xb8>
        for (int i = 0; i < poly->maxNumVoices; i++)
   2da9e:	2000      	movs	r0, #0
   2daa0:	e004      	b.n	2daac <tSimplePoly_markPendingNoteOff+0xac>
            if (poly->voices[i][0] == note)
   2daa2:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2daa6:	6814      	ldr	r4, [r2, #0]
   2daa8:	428c      	cmp	r4, r1
   2daaa:	d007      	beq.n	2dabc <tSimplePoly_markPendingNoteOff+0xbc>
        for (int i = 0; i < poly->maxNumVoices; i++)
   2daac:	3001      	adds	r0, #1
   2daae:	42b0      	cmp	r0, r6
   2dab0:	ea4f 0780 	mov.w	r7, r0, lsl #2
   2dab4:	d1f5      	bne.n	2daa2 <tSimplePoly_markPendingNoteOff+0xa2>
   2dab6:	e7ba      	b.n	2da2e <tSimplePoly_markPendingNoteOff+0x2e>
   2dab8:	2000      	movs	r0, #0
            if (poly->voices[i][0] == note)
   2daba:	4607      	mov	r7, r0
                poly->voices[i][0] = -2;
   2dabc:	f06f 0301 	mvn.w	r3, #1
                poly->voices[i][1] = 0;
   2dac0:	2100      	movs	r1, #0
                poly->voices[i][0] = -2;
   2dac2:	6013      	str	r3, [r2, #0]
                poly->voices[i][1] = 0;
   2dac4:	692b      	ldr	r3, [r5, #16]
   2dac6:	59db      	ldr	r3, [r3, r7]
   2dac8:	6059      	str	r1, [r3, #4]
}
   2daca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2dace:	3801      	subs	r0, #1
   2dad0:	e7d6      	b.n	2da80 <tSimplePoly_markPendingNoteOff+0x80>
        if (ns->data[i] == noteVal)    return i;
   2dad2:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
   2dad4:	2600      	movs	r6, #0
   2dad6:	e7b3      	b.n	2da40 <tSimplePoly_markPendingNoteOff+0x40>

0002dad8 <tSimplePoly_setNumVoices>:

void tSimplePoly_setNumVoices(tSimplePoly* const polyh, uint8_t numVoices)
{
    _tSimplePoly* poly = *polyh;
   2dad8:	6802      	ldr	r2, [r0, #0]
    poly->numVoices = (numVoices > poly->maxNumVoices) ? poly->maxNumVoices : numVoices;
   2dada:	68d3      	ldr	r3, [r2, #12]
   2dadc:	4299      	cmp	r1, r3
   2dade:	bfa8      	it	ge
   2dae0:	4619      	movge	r1, r3
   2dae2:	6091      	str	r1, [r2, #8]
}
   2dae4:	4770      	bx	lr
   2dae6:	bf00      	nop

0002dae8 <tSimplePoly_getNumVoices>:


int tSimplePoly_getNumVoices(tSimplePoly* const polyh)
{
    _tSimplePoly* poly = *polyh;
    return poly->numVoices;
   2dae8:	6803      	ldr	r3, [r0, #0]
}
   2daea:	6898      	ldr	r0, [r3, #8]
   2daec:	4770      	bx	lr
   2daee:	bf00      	nop

0002daf0 <tSimplePoly_getNumActiveVoices>:

int tSimplePoly_getNumActiveVoices(tSimplePoly* const polyh)
{
   2daf0:	b508      	push	{r3, lr}
    _tSimplePoly* poly = *polyh;
   2daf2:	6803      	ldr	r3, [r0, #0]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2daf4:	2100      	movs	r1, #0
    return ns->size;
   2daf6:	685a      	ldr	r2, [r3, #4]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2daf8:	ee00 1a10 	vmov	s0, r1
   2dafc:	ed93 1a02 	vldr	s2, [r3, #8]
    return ns->size;
   2db00:	f8b2 3206 	ldrh.w	r3, [r2, #518]	; 0x206
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2db04:	eeb8 1ac1 	vcvt.f32.s32	s2, s2
    return ns->size;
   2db08:	ee00 3a90 	vmov	s1, r3
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2db0c:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   2db10:	f7ff f966 	bl	2cde0 <LEAF_clip>
}
   2db14:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2db18:	ee17 0a90 	vmov	r0, s15
   2db1c:	bd08      	pop	{r3, pc}
   2db1e:	bf00      	nop

0002db20 <tSimplePoly_getPitch>:


int tSimplePoly_getPitch(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][2];
   2db20:	6803      	ldr	r3, [r0, #0]
   2db22:	691b      	ldr	r3, [r3, #16]
   2db24:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2db28:	6898      	ldr	r0, [r3, #8]
   2db2a:	4770      	bx	lr

0002db2c <tSimplePoly_getPitchAndCheckActive>:

//this one returns negative one if the voice is inactive
int tSimplePoly_getPitchAndCheckActive(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][0];
   2db2c:	6803      	ldr	r3, [r0, #0]
   2db2e:	691b      	ldr	r3, [r3, #16]
   2db30:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2db34:	6818      	ldr	r0, [r3, #0]
   2db36:	4770      	bx	lr

0002db38 <tSimplePoly_getVelocity>:

int tSimplePoly_getVelocity(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][1];
   2db38:	6803      	ldr	r3, [r0, #0]
   2db3a:	691b      	ldr	r3, [r3, #16]
   2db3c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2db40:	6858      	ldr	r0, [r3, #4]
   2db42:	4770      	bx	lr

0002db44 <tSimplePoly_isOn>:

int tSimplePoly_isOn(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return (poly->voices[voice][0] > 0) ? 1 : 0;
   2db44:	6803      	ldr	r3, [r0, #0]
   2db46:	691b      	ldr	r3, [r3, #16]
   2db48:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   2db4c:	6818      	ldr	r0, [r3, #0]
}
   2db4e:	2800      	cmp	r0, #0
   2db50:	bfd4      	ite	le
   2db52:	2000      	movle	r0, #0
   2db54:	2001      	movgt	r0, #1
   2db56:	4770      	bx	lr

0002db58 <tCycle_initToPool>:
{
    tCycle_initToPool(cy, &leaf.mempool);
}

void    tCycle_initToPool   (tCycle* const cy, tMempool* const mp)
{
   2db58:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
   2db5a:	680c      	ldr	r4, [r1, #0]
{
   2db5c:	4605      	mov	r5, r0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
   2db5e:	2010      	movs	r0, #16
   2db60:	4621      	mov	r1, r4
   2db62:	f7ff fb55 	bl	2d210 <mpool_alloc>
    c->mempool = m;
    
    c->inc      =  0.0f;
   2db66:	2300      	movs	r3, #0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
   2db68:	6028      	str	r0, [r5, #0]
    c->mempool = m;
   2db6a:	6004      	str	r4, [r0, #0]
    c->inc      =  0.0f;
   2db6c:	6083      	str	r3, [r0, #8]
    c->phase    =  0.0f;
   2db6e:	6043      	str	r3, [r0, #4]
}
   2db70:	bd38      	pop	{r3, r4, r5, pc}
   2db72:	bf00      	nop

0002db74 <tCycle_free>:

void    tCycle_free (tCycle* const cy)
{
    _tCycle* c = *cy;
   2db74:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)c, c->mempool);
   2db76:	6801      	ldr	r1, [r0, #0]
   2db78:	f7ff bbf4 	b.w	2d364 <mpool_free>

0002db7c <tCycle_setFreq>:
{
    _tCycle* c = *cy;
    
    c->freq  = freq;

    c->inc = freq * leaf.invSampleRate;
   2db7c:	f64f 0308 	movw	r3, #63496	; 0xf808
    _tCycle* c = *cy;
   2db80:	6802      	ldr	r2, [r0, #0]
    c->inc = freq * leaf.invSampleRate;
   2db82:	f2c0 230f 	movt	r3, #527	; 0x20f
    c->freq  = freq;
   2db86:	ed82 0a03 	vstr	s0, [r2, #12]
    c->inc = freq * leaf.invSampleRate;
   2db8a:	edd3 7a01 	vldr	s15, [r3, #4]
   2db8e:	ee27 0a80 	vmul.f32	s0, s15, s0
   2db92:	ed82 0a02 	vstr	s0, [r2, #8]
}
   2db96:	4770      	bx	lr

0002db98 <tCycle_tick>:

//need to check bounds and wrap table properly to allow through-zero FM
float   tCycle_tick(tCycle* const cy)
{
    _tCycle* c = *cy;
   2db98:	6803      	ldr	r3, [r0, #0]
    float samp0;
    float samp1;
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2db9a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
   2db9e:	ed93 7a01 	vldr	s14, [r3, #4]
   2dba2:	edd3 7a02 	vldr	s15, [r3, #8]
   2dba6:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2dbaa:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
   2dbae:	ed83 7a01 	vstr	s14, [r3, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2dbb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dbb6:	db44      	blt.n	2dc42 <tCycle_tick+0xaa>
   2dbb8:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2dbbc:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2dbc0:	ee77 7a66 	vsub.f32	s15, s14, s13
   2dbc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dbc8:	eeb0 7a67 	vmov.f32	s14, s15
   2dbcc:	daf6      	bge.n	2dbbc <tCycle_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
   2dbce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2dbd2:	edc3 7a01 	vstr	s15, [r3, #4]
   2dbd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dbda:	d539      	bpl.n	2dc50 <tCycle_tick+0xb8>
   2dbdc:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2dbe0:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2dbe4:	eef4 7ae6 	vcmpe.f32	s15, s13
   2dbe8:	ee37 7a86 	vadd.f32	s14, s15, s12
   2dbec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dbf0:	eef0 7a47 	vmov.f32	s15, s14
   2dbf4:	d4f6      	bmi.n	2dbe4 <tCycle_tick+0x4c>
   2dbf6:	ed83 7a01 	vstr	s14, [r3, #4]

    // Wavetable synthesis

	temp = SINE_TABLE_SIZE * c->phase;
   2dbfa:	f04f 428a 	mov.w	r2, #1157627904	; 0x45000000
	intPart = (int)temp;
	fracPart = temp - (float)intPart;
	samp0 = __leaf_table_sinewave[intPart];
   2dbfe:	f243 630c 	movw	r3, #13836	; 0x360c
	temp = SINE_TABLE_SIZE * c->phase;
   2dc02:	ee07 2a90 	vmov	s15, r2
	samp0 = __leaf_table_sinewave[intPart];
   2dc06:	f2c0 0305 	movt	r3, #5
	temp = SINE_TABLE_SIZE * c->phase;
   2dc0a:	ee27 7a27 	vmul.f32	s14, s14, s15
	intPart = (int)temp;
   2dc0e:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   2dc12:	ee17 2a90 	vmov	r2, s15
	fracPart = temp - (float)intPart;
   2dc16:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2dc1a:	1c51      	adds	r1, r2, #1
	samp0 = __leaf_table_sinewave[intPart];
   2dc1c:	eb03 0082 	add.w	r0, r3, r2, lsl #2
	fracPart = temp - (float)intPart;
   2dc20:	ee37 7a67 	vsub.f32	s14, s14, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2dc24:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
	samp0 = __leaf_table_sinewave[intPart];
   2dc28:	ed90 0a00 	vldr	s0, [r0]
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2dc2c:	bfa8      	it	ge
   2dc2e:	2100      	movge	r1, #0
	samp1 = __leaf_table_sinewave[intPart];
   2dc30:	eb03 0381 	add.w	r3, r3, r1, lsl #2

    return (samp0 + (samp1 - samp0) * fracPart);
   2dc34:	edd3 7a00 	vldr	s15, [r3]
   2dc38:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
   2dc3c:	eea7 0a87 	vfma.f32	s0, s15, s14
   2dc40:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2dc42:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
   2dc46:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2dc4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dc4e:	d4c5      	bmi.n	2dbdc <tCycle_tick+0x44>
   2dc50:	eeb0 7a67 	vmov.f32	s14, s15
   2dc54:	e7d1      	b.n	2dbfa <tCycle_tick+0x62>
   2dc56:	bf00      	nop

0002dc58 <tSawtooth_initToPool>:
{
    tSawtooth_initToPool(cy, &leaf.mempool);
}

void    tSawtooth_initToPool    (tSawtooth* const cy, tMempool* const mp)
{
   2dc58:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
   2dc5a:	680d      	ldr	r5, [r1, #0]
{
   2dc5c:	4604      	mov	r4, r0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2dc5e:	2018      	movs	r0, #24
   2dc60:	4629      	mov	r1, r5
   2dc62:	f7ff fad5 	bl	2d210 <mpool_alloc>
    c->mempool = m;
    
    c->inc      = 0.0f;
   2dc66:	2200      	movs	r2, #0
{
    _tSawtooth* c = *cy;
    
    c->freq  = freq;
    
    c->inc = c->freq * leaf.invSampleRate;
   2dc68:	f64f 0108 	movw	r1, #63496	; 0xf808
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2dc6c:	6020      	str	r0, [r4, #0]
    c->freq  = freq;
   2dc6e:	4613      	mov	r3, r2
    c->mempool = m;
   2dc70:	6005      	str	r5, [r0, #0]
    c->inc = c->freq * leaf.invSampleRate;
   2dc72:	f2c0 210f 	movt	r1, #527	; 0x20f
    c->phase    = 0.0f;
   2dc76:	6042      	str	r2, [r0, #4]
    c->freq  = freq;
   2dc78:	f2c4 335c 	movt	r3, #17244	; 0x435c
    c->w = c->freq * INV_20;
    for (c->oct = 0; c->w > 2.0f; c->oct++)
    {
        c->w = 0.5f * c->w;
    }
    c->w = 2.0f - c->w;
   2dc7c:	2500      	movs	r5, #0
    c->inc = c->freq * leaf.invSampleRate;
   2dc7e:	ed91 7a01 	vldr	s14, [r1, #4]
    c->freq  = freq;
   2dc82:	ee07 3a90 	vmov	s15, r3
    c->inc      = 0.0f;
   2dc86:	6082      	str	r2, [r0, #8]
    c->w = 2.0f - c->w;
   2dc88:	f6c3 7520 	movt	r5, #16160	; 0x3f20
    _tSawtooth* c = *cy;
   2dc8c:	6823      	ldr	r3, [r4, #0]
    c->inc = c->freq * leaf.invSampleRate;
   2dc8e:	ee27 7a27 	vmul.f32	s14, s14, s15
   2dc92:	2203      	movs	r2, #3
    c->freq  = freq;
   2dc94:	edc3 7a03 	vstr	s15, [r3, #12]
   2dc98:	611a      	str	r2, [r3, #16]
    c->inc = c->freq * leaf.invSampleRate;
   2dc9a:	ed83 7a02 	vstr	s14, [r3, #8]
    c->w = 2.0f - c->w;
   2dc9e:	615d      	str	r5, [r3, #20]
}
   2dca0:	bd38      	pop	{r3, r4, r5, pc}
   2dca2:	bf00      	nop

0002dca4 <tSawtooth_free>:
    _tSawtooth* c = *cy;
   2dca4:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)c, c->mempool);
   2dca6:	6801      	ldr	r1, [r0, #0]
   2dca8:	f7ff bb5c 	b.w	2d364 <mpool_free>

0002dcac <tSawtooth_setFreq>:
    c->inc = c->freq * leaf.invSampleRate;
   2dcac:	f64f 0108 	movw	r1, #63496	; 0xf808
    c->w = c->freq * INV_20;
   2dcb0:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    _tSawtooth* c = *cy;
   2dcb4:	6802      	ldr	r2, [r0, #0]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dcb6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
    c->inc = c->freq * leaf.invSampleRate;
   2dcba:	f2c0 210f 	movt	r1, #527	; 0x20f
    c->w = c->freq * INV_20;
   2dcbe:	f6c3 534c 	movt	r3, #15692	; 0x3d4c
    c->freq  = freq;
   2dcc2:	ed82 0a03 	vstr	s0, [r2, #12]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dcc6:	2000      	movs	r0, #0
    c->inc = c->freq * leaf.invSampleRate;
   2dcc8:	edd1 6a01 	vldr	s13, [r1, #4]
    c->w = c->freq * INV_20;
   2dccc:	ee07 3a10 	vmov	s14, r3
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dcd0:	6110      	str	r0, [r2, #16]
    c->inc = c->freq * leaf.invSampleRate;
   2dcd2:	ee66 6a80 	vmul.f32	s13, s13, s0
    c->w = c->freq * INV_20;
   2dcd6:	ee20 0a07 	vmul.f32	s0, s0, s14
    c->inc = c->freq * leaf.invSampleRate;
   2dcda:	edc2 6a02 	vstr	s13, [r2, #8]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dcde:	eeb4 0ae7 	vcmpe.f32	s0, s15
    c->w = c->freq * INV_20;
   2dce2:	ed82 0a05 	vstr	s0, [r2, #20]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dce6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dcea:	dd0c      	ble.n	2dd06 <tSawtooth_setFreq+0x5a>
        c->w = 0.5f * c->w;
   2dcec:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dcf0:	2301      	movs	r3, #1
        c->w = 0.5f * c->w;
   2dcf2:	ee20 0a07 	vmul.f32	s0, s0, s14
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2dcf6:	4619      	mov	r1, r3
   2dcf8:	3301      	adds	r3, #1
   2dcfa:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2dcfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dd02:	dcf6      	bgt.n	2dcf2 <tSawtooth_setFreq+0x46>
   2dd04:	6111      	str	r1, [r2, #16]
    c->w = 2.0f - c->w;
   2dd06:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2dd0a:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2dd0e:	ed82 0a05 	vstr	s0, [r2, #20]
}
   2dd12:	4770      	bx	lr

0002dd14 <tSawtooth_tick>:

float   tSawtooth_tick(tSawtooth* const cy)
{
    _tSawtooth* c = *cy;
   2dd14:	6802      	ldr	r2, [r0, #0]
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2dd16:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
   2dd1a:	ed92 7a01 	vldr	s14, [r2, #4]
   2dd1e:	edd2 7a02 	vldr	s15, [r2, #8]
   2dd22:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2dd26:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
   2dd2a:	ed82 7a01 	vstr	s14, [r2, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2dd2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dd32:	db3f      	blt.n	2ddb4 <tSawtooth_tick+0xa0>
   2dd34:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2dd38:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2dd3c:	ee77 7a66 	vsub.f32	s15, s14, s13
   2dd40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dd44:	eeb0 7a67 	vmov.f32	s14, s15
   2dd48:	daf6      	bge.n	2dd38 <tSawtooth_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
   2dd4a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2dd4e:	edc2 7a01 	vstr	s15, [r2, #4]
   2dd52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dd56:	d534      	bpl.n	2ddc2 <tSawtooth_tick+0xae>
   2dd58:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2dd5c:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2dd60:	eef4 7ae6 	vcmpe.f32	s15, s13
   2dd64:	ee37 7a86 	vadd.f32	s14, s15, s12
   2dd68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2dd6c:	eef0 7a47 	vmov.f32	s15, s14
   2dd70:	d4f6      	bmi.n	2dd60 <tSawtooth_tick+0x4c>
   2dd72:	ed82 7a01 	vstr	s14, [r2, #4]
    
    float out = 0.0f;
    
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2dd76:	eef0 7a47 	vmov.f32	s15, s14
    
    // Wavetable synthesis
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2dd7a:	6910      	ldr	r0, [r2, #16]
   2dd7c:	ed92 7a05 	vldr	s14, [r2, #20]
   2dd80:	f24d 610c 	movw	r1, #54796	; 0xd60c
   2dd84:	1c42      	adds	r2, r0, #1
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2dd86:	eefe 7aea 	vcvt.s32.f32	s15, s15, #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2dd8a:	f2c0 0103 	movt	r1, #3
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2dd8e:	ee17 3a90 	vmov	r3, s15
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2dd92:	eb03 20c0 	add.w	r0, r3, r0, lsl #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2dd96:	eb03 23c2 	add.w	r3, r3, r2, lsl #11
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2dd9a:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2dd9e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2dda2:	edd0 7a00 	vldr	s15, [r0]
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2dda6:	ed93 0a00 	vldr	s0, [r3]
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2ddaa:	ee77 7ac0 	vsub.f32	s15, s15, s0
    
    return out;
}
   2ddae:	eea7 0a87 	vfma.f32	s0, s15, s14
   2ddb2:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2ddb4:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
   2ddb8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2ddbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ddc0:	d4ca      	bmi.n	2dd58 <tSawtooth_tick+0x44>
   2ddc2:	eeb0 7a67 	vmov.f32	s14, s15
   2ddc6:	e7d6      	b.n	2dd76 <tSawtooth_tick+0x62>

0002ddc8 <tNoise_initToPool>:
{
    tNoise_initToPool(ns, type, &leaf.mempool);
}

void    tNoise_initToPool   (tNoise* const ns, NoiseType type, tMempool* const mp)
{
   2ddc8:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   2ddca:	6814      	ldr	r4, [r2, #0]
{
   2ddcc:	4606      	mov	r6, r0
   2ddce:	460d      	mov	r5, r1
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
   2ddd0:	2018      	movs	r0, #24
   2ddd2:	4621      	mov	r1, r4
   2ddd4:	f7ff fa1c 	bl	2d210 <mpool_alloc>
    n->mempool = m;
    
    n->type = type;
    n->rand = leaf.random;
   2ddd8:	f64f 0308 	movw	r3, #63496	; 0xf808
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
   2dddc:	6030      	str	r0, [r6, #0]
    n->rand = leaf.random;
   2ddde:	f2c0 230f 	movt	r3, #527	; 0x20f
    n->mempool = m;
   2dde2:	6004      	str	r4, [r0, #0]
    n->type = type;
   2dde4:	7105      	strb	r5, [r0, #4]
    n->rand = leaf.random;
   2dde6:	691b      	ldr	r3, [r3, #16]
   2dde8:	6143      	str	r3, [r0, #20]
}
   2ddea:	bd70      	pop	{r4, r5, r6, pc}

0002ddec <tNoise_free>:

void    tNoise_free (tNoise* const ns)
{
    _tNoise* n = *ns;
   2ddec:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)n, n->mempool);
   2ddee:	6801      	ldr	r1, [r0, #0]
   2ddf0:	f7ff bab8 	b.w	2d364 <mpool_free>

0002ddf4 <tNoise_tick>:
}

float   tNoise_tick(tNoise* const ns)
{
   2ddf4:	b510      	push	{r4, lr}
    _tNoise* n = *ns;
   2ddf6:	6804      	ldr	r4, [r0, #0]
    
    float rand = (n->rand() * 2.0f) - 1.0f;
   2ddf8:	6963      	ldr	r3, [r4, #20]
   2ddfa:	4798      	blx	r3
   2ddfc:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   2de00:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    
    if (n->type == PinkNoise)
   2de04:	7923      	ldrb	r3, [r4, #4]
   2de06:	2b01      	cmp	r3, #1
    float rand = (n->rand() * 2.0f) - 1.0f;
   2de08:	eee0 7a07 	vfma.f32	s15, s0, s14
   2de0c:	eeb0 0a67 	vmov.f32	s0, s15
    if (n->type == PinkNoise)
   2de10:	d000      	beq.n	2de14 <tNoise_tick+0x20>
    }
    else // WhiteNoise
    {
        return rand;
    }
}
   2de12:	bd10      	pop	{r4, pc}
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de14:	f64d 03a1 	movw	r3, #55457	; 0xd8a1
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de18:	f24d 02ff 	movw	r2, #53503	; 0xd0ff
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de1c:	f246 50fe 	movw	r0, #26110	; 0x65fe
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de20:	f248 712b 	movw	r1, #34603	; 0x872b
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de24:	f6c3 53ca 	movt	r3, #15818	; 0x3dca
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de28:	f6c3 6297 	movt	r2, #16023	; 0x3e97
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de2c:	f6c3 707f 	movt	r0, #16255	; 0x3f7f
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de30:	f6c3 7176 	movt	r1, #16246	; 0x3f76
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de34:	ee07 3a90 	vmov	s15, r3
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de38:	ee06 2a90 	vmov	s13, r2
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de3c:	ed94 5a02 	vldr	s10, [r4, #8]
   2de40:	ee06 0a10 	vmov	s12, r0
   2de44:	ee60 7a27 	vmul.f32	s15, s0, s15
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de48:	edd4 5a03 	vldr	s11, [r4, #12]
   2de4c:	ee60 6a26 	vmul.f32	s13, s0, s13
   2de50:	ee07 1a10 	vmov	s14, r1
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2de54:	f64b 6397 	movw	r3, #48791	; 0xbe97
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2de58:	f643 4236 	movw	r2, #15414	; 0x3c36
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de5c:	eee5 7a06 	vfma.f32	s15, s10, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2de60:	f64e 3185 	movw	r1, #60293	; 0xeb85
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de64:	eee5 6a87 	vfma.f32	s13, s11, s14
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2de68:	f6c3 7386 	movt	r3, #16262	; 0x3f86
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2de6c:	f6c3 623d 	movt	r2, #15933	; 0x3e3d
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2de70:	f6c3 7111 	movt	r1, #16145	; 0x3f11
   2de74:	ee07 3a10 	vmov	s14, r3
   2de78:	ed94 5a04 	vldr	s10, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2de7c:	ee06 2a10 	vmov	s12, r2
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2de80:	ee05 1a90 	vmov	s11, r1
   2de84:	ee20 7a07 	vmul.f32	s14, s0, s14
        return (tmp * 0.05f);
   2de88:	f64c 43cd 	movw	r3, #52429	; 0xcccd
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2de8c:	edc4 7a02 	vstr	s15, [r4, #8]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2de90:	ee77 7aa6 	vadd.f32	s15, s15, s13
        return (tmp * 0.05f);
   2de94:	f6c3 534c 	movt	r3, #15692	; 0x3d4c
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2de98:	eea5 7a25 	vfma.f32	s14, s10, s11
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2de9c:	edc4 6a03 	vstr	s13, [r4, #12]
        return (tmp * 0.05f);
   2dea0:	ee06 3a90 	vmov	s13, r3
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2dea4:	eee0 7a06 	vfma.f32	s15, s0, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2dea8:	ed84 7a04 	vstr	s14, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2deac:	ee37 0a87 	vadd.f32	s0, s15, s14
        return (tmp * 0.05f);
   2deb0:	ee20 0a26 	vmul.f32	s0, s0, s13
}
   2deb4:	bd10      	pop	{r4, pc}
   2deb6:	bf00      	nop

0002deb8 <tComplexLivingString_initToPool>:
}

void    tComplexLivingString_initToPool    (tComplexLivingString* const pl, float freq, float pickPos, float prepPos, float prepIndex,
                                     float dampFreq, float decay, float targetLev, float levSmoothFactor,
                                     float levStrength, int levMode, tMempool* const mp)
{
   2deb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2debc:	ed2d 8b0c 	vpush	{d8-d13}
   2dec0:	b083      	sub	sp, #12
    _tMempool* m = *mp;
   2dec2:	f8d2 8000 	ldr.w	r8, [r2]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
    p->mempool = m;

    p->curr=0.0f;
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2dec6:	f64f 0708 	movw	r7, #63496	; 0xf808
{
   2deca:	4606      	mov	r6, r0
   2decc:	9100      	str	r1, [sp, #0]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2dece:	2070      	movs	r0, #112	; 0x70
   2ded0:	4641      	mov	r1, r8
{
   2ded2:	eef0 9a42 	vmov.f32	s19, s4
   2ded6:	eef0 aa41 	vmov.f32	s21, s2
   2deda:	4615      	mov	r5, r2
   2dedc:	eef0 ba43 	vmov.f32	s23, s6
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2dee0:	f2c0 270f 	movt	r7, #527	; 0x20f
{
   2dee4:	eeb0 ca63 	vmov.f32	s24, s7
   2dee8:	eef0 ca44 	vmov.f32	s25, s8
   2deec:	eeb0 da61 	vmov.f32	s26, s3
   2def0:	eef0 da62 	vmov.f32	s27, s5
   2def4:	eeb0 ba40 	vmov.f32	s22, s0
   2def8:	eeb0 aa60 	vmov.f32	s20, s1
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2defc:	f7ff f988 	bl	2d210 <mpool_alloc>
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2df00:	f24d 720a 	movw	r2, #55050	; 0xd70a
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2df04:	6030      	str	r0, [r6, #0]
    p->mempool = m;
   2df06:	f8c0 8000 	str.w	r8, [r0]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2df0a:	4604      	mov	r4, r0
    p->curr=0.0f;
   2df0c:	2300      	movs	r3, #0
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2df0e:	f6c3 4223 	movt	r2, #15395	; 0x3c23
   2df12:	ed97 0a00 	vldr	s0, [r7]
   2df16:	4629      	mov	r1, r5
   2df18:	ee00 2a90 	vmov	s1, r2
    p->curr=0.0f;
   2df1c:	62a3      	str	r3, [r4, #40]	; 0x28
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2df1e:	ee80 0a0b 	vdiv.f32	s0, s0, s22
   2df22:	3064      	adds	r0, #100	; 0x64
   2df24:	ee08 2a90 	vmov	s17, r2
    p->curr=0.0f;
   2df28:	ee09 3a10 	vmov	s18, r3
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2df2c:	f7fd fa08 	bl	2b340 <tExpSmooth_initToPool>
void     tComplexLivingString_setFreq(tComplexLivingString* const pl, float freq)
{    // NOTE: It is faster to set wavelength in samples directly
    _tComplexLivingString* p = *pl;
    if (freq<20.0f) freq=20.0f;
    else if (freq>10000.0f) freq=10000.0f;
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2df30:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   2df34:	ed97 7a00 	vldr	s14, [r7]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2df38:	f104 0b2c 	add.w	fp, r4, #44	; 0x2c
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2df3c:	f2c4 631c 	movt	r3, #17948	; 0x461c
    _tComplexLivingString* p = *pl;
   2df40:	6832      	ldr	r2, [r6, #0]
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2df42:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
   2df46:	f104 0a34 	add.w	sl, r4, #52	; 0x34
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2df4a:	ee07 3a90 	vmov	s15, r3
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2df4e:	f104 0340 	add.w	r3, r4, #64	; 0x40
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2df52:	f102 0064 	add.w	r0, r2, #100	; 0x64
   2df56:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2df5a:	fecb 7a67 	vminnm.f32	s15, s22, s15
   2df5e:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
   2df62:	ee87 0a27 	vdiv.f32	s0, s14, s15
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2df66:	9301      	str	r3, [sp, #4]
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
   2df68:	f104 0930 	add.w	r9, r4, #48	; 0x30
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
   2df6c:	f104 083c 	add.w	r8, r4, #60	; 0x3c
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
   2df70:	f104 0738 	add.w	r7, r4, #56	; 0x38
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2df74:	ed82 0a02 	vstr	s0, [r2, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2df78:	f7fd fa1e 	bl	2b3b8 <tExpSmooth_setDest>
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
   2df7c:	eef0 0a68 	vmov.f32	s1, s17
   2df80:	4629      	mov	r1, r5
   2df82:	eeb0 0a4a 	vmov.f32	s0, s20
   2df86:	f104 0068 	add.w	r0, r4, #104	; 0x68
    p->freq = freq;
   2df8a:	ed84 ba01 	vstr	s22, [r4, #4]
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
   2df8e:	f7fd f9d7 	bl	2b340 <tExpSmooth_initToPool>
    tExpSmooth_initToPool(&p->prepPosSmooth, prepPos, 0.01f, mp); // smoother for pick position
   2df92:	eef0 0a68 	vmov.f32	s1, s17
   2df96:	4629      	mov	r1, r5
   2df98:	eeb0 0a6a 	vmov.f32	s0, s21
   2df9c:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2dfa0:	f7fd f9ce 	bl	2b340 <tExpSmooth_initToPool>
   2dfa4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
}

void     tComplexLivingString_setPickPos(tComplexLivingString* const pl, float pickPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
   2dfa8:	6833      	ldr	r3, [r6, #0]
   2dfaa:	fe8a 0a40 	vminnm.f32	s0, s20, s0
    if (pickPos<0.5f) pickPos=0.5f;
    else if (pickPos>1.f) pickPos=1.f;
    p->pickPos = pickPos;
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2dfae:	f103 0068 	add.w	r0, r3, #104	; 0x68
   2dfb2:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
    p->pickPos = pickPos;
   2dfb6:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2dfba:	f7fd f9fd 	bl	2b3b8 <tExpSmooth_setDest>
}

void     tComplexLivingString_setPrepPos(tComplexLivingString* const pl, float prepPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
   2dfbe:	6833      	ldr	r3, [r6, #0]
   2dfc0:	fe8a 0ac8 	vminnm.f32	s0, s21, s16
   2dfc4:	fe80 0a09 	vmaxnm.f32	s0, s0, s18
    if (prepPos<0.f) prepPos=0.f;
    else if (prepPos>0.5f) prepPos=0.5f;
    p->prepPos = prepPos;
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2dfc8:	f103 006c 	add.w	r0, r3, #108	; 0x6c
    p->prepPos = prepPos;
   2dfcc:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2dfd0:	f7fd f9f2 	bl	2b3b8 <tExpSmooth_setDest>
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2dfd4:	4658      	mov	r0, fp
   2dfd6:	462a      	mov	r2, r5
   2dfd8:	ed94 0a02 	vldr	s0, [r4, #8]
    p->prepPos=prepPos;
   2dfdc:	edc4 aa04 	vstr	s21, [r4, #16]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2dfe0:	f44f 6116 	mov.w	r1, #2400	; 0x960
    p->pickPos=pickPos;
   2dfe4:	ed84 aa03 	vstr	s20, [r4, #12]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2dfe8:	f7fa f8ca 	bl	28180 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
   2dfec:	4650      	mov	r0, sl
   2dfee:	462a      	mov	r2, r5
   2dff0:	ed94 0a02 	vldr	s0, [r4, #8]
   2dff4:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2dff8:	f7fa f8c2 	bl	28180 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
   2dffc:	4648      	mov	r0, r9
   2dffe:	462a      	mov	r2, r5
   2e000:	ed94 0a02 	vldr	s0, [r4, #8]
   2e004:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2e008:	f7fa f8ba 	bl	28180 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
   2e00c:	4640      	mov	r0, r8
   2e00e:	462a      	mov	r2, r5
   2e010:	ed94 0a02 	vldr	s0, [r4, #8]
   2e014:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2e018:	f7fa f8b2 	bl	28180 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
   2e01c:	4638      	mov	r0, r7
   2e01e:	462a      	mov	r2, r5
   2e020:	ed94 0a02 	vldr	s0, [r4, #8]
   2e024:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2e028:	f7fa f8aa 	bl	28180 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2e02c:	9e01      	ldr	r6, [sp, #4]
   2e02e:	462a      	mov	r2, r5
   2e030:	ed94 0a02 	vldr	s0, [r4, #8]
   2e034:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2e038:	4630      	mov	r0, r6
   2e03a:	f7fa f8a1 	bl	28180 <tLinearDelay_initToPool>
    tLinearDelay_clear(&p->delLF);
   2e03e:	4658      	mov	r0, fp
   2e040:	f7fa f91a 	bl	28278 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMF);
   2e044:	4650      	mov	r0, sl
   2e046:	f7fa f917 	bl	28278 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUF);
   2e04a:	4648      	mov	r0, r9
   2e04c:	f7fa f914 	bl	28278 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUB);
   2e050:	4640      	mov	r0, r8
   2e052:	f7fa f911 	bl	28278 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMB);
   2e056:	4638      	mov	r0, r7
   2e058:	f7fa f90e 	bl	28278 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delLB);
   2e05c:	4630      	mov	r0, r6
   2e05e:	f7fa f90b 	bl	28278 <tLinearDelay_clear>
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
   2e062:	4629      	mov	r1, r5
   2e064:	eeb0 0a69 	vmov.f32	s0, s19
   2e068:	f104 0044 	add.w	r0, r4, #68	; 0x44
    p->dampFreq = dampFreq;
   2e06c:	edc4 9a07 	vstr	s19, [r4, #28]
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
   2e070:	f7fd fa78 	bl	2b564 <tOnePole_initToPool>
    tOnePole_initToPool(&p->nutFilter, dampFreq, mp);
   2e074:	4629      	mov	r1, r5
   2e076:	eeb0 0a69 	vmov.f32	s0, s19
   2e07a:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2e07e:	f7fd fa71 	bl	2b564 <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterU, dampFreq, mp);
   2e082:	4629      	mov	r1, r5
   2e084:	eeb0 0a69 	vmov.f32	s0, s19
   2e088:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2e08c:	f7fd fa6a 	bl	2b564 <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterL, dampFreq, mp);
   2e090:	4629      	mov	r1, r5
   2e092:	eeb0 0a69 	vmov.f32	s0, s19
   2e096:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2e09a:	f7fd fa63 	bl	2b564 <tOnePole_initToPool>
    tHighpass_initToPool(&p->DCblockerU,13, mp);
   2e09e:	4629      	mov	r1, r5
   2e0a0:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2e0a4:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
   2e0a8:	f7fd fca2 	bl	2b9f0 <tHighpass_initToPool>
    tHighpass_initToPool(&p->DCblockerL,13, mp);
   2e0ac:	4629      	mov	r1, r5
   2e0ae:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2e0b2:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
   2e0b6:	f7fd fc9b 	bl	2b9f0 <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2e0ba:	462a      	mov	r2, r5
   2e0bc:	9900      	ldr	r1, [sp, #0]
   2e0be:	eeb0 1a6c 	vmov.f32	s2, s25
   2e0c2:	eef0 0a4c 	vmov.f32	s1, s24
   2e0c6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2e0ca:	eeb0 0a6b 	vmov.f32	s0, s23
    p->decay=decay;
   2e0ce:	edc4 da08 	vstr	s27, [r4, #32]
    p->prepIndex = prepIndex;
   2e0d2:	ed84 da06 	vstr	s26, [r4, #24]
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2e0d6:	f7fa ff1f 	bl	28f18 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevL, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2e0da:	462a      	mov	r2, r5
   2e0dc:	9900      	ldr	r1, [sp, #0]
   2e0de:	eeb0 1a6c 	vmov.f32	s2, s25
   2e0e2:	eef0 0a4c 	vmov.f32	s1, s24
   2e0e6:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2e0ea:	eeb0 0a6b 	vmov.f32	s0, s23
   2e0ee:	f7fa ff13 	bl	28f18 <tFeedbackLeveler_initToPool>
    p->levMode=levMode;
   2e0f2:	eddd 7a00 	vldr	s15, [sp]
   2e0f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e0fa:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
   2e0fe:	b003      	add	sp, #12
   2e100:	ecbd 8b0c 	vpop	{d8-d13}
   2e104:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0002e108 <tComplexLivingString_init>:
    tComplexLivingString_initToPool(pl, freq, pickPos, prepPos, prepIndex, dampFreq, decay, targetLev, levSmoothFactor, levStrength, levMode, &leaf.mempool);
   2e108:	f64f 0220 	movw	r2, #63520	; 0xf820
   2e10c:	f2c0 220f 	movt	r2, #527	; 0x20f
   2e110:	f7ff bed2 	b.w	2deb8 <tComplexLivingString_initToPool>

0002e114 <tComplexLivingString_free>:
{
   2e114:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
   2e116:	6804      	ldr	r4, [r0, #0]
    tExpSmooth_free(&p->wlSmooth);
   2e118:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2e11c:	f7fd f936 	bl	2b38c <tExpSmooth_free>
    tExpSmooth_free(&p->pickPosSmooth);
   2e120:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2e124:	f7fd f932 	bl	2b38c <tExpSmooth_free>
    tExpSmooth_free(&p->prepPosSmooth);
   2e128:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2e12c:	f7fd f92e 	bl	2b38c <tExpSmooth_free>
    tLinearDelay_free(&p->delLF);
   2e130:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   2e134:	f7fa f894 	bl	28260 <tLinearDelay_free>
    tLinearDelay_free(&p->delMF);
   2e138:	f104 0034 	add.w	r0, r4, #52	; 0x34
   2e13c:	f7fa f890 	bl	28260 <tLinearDelay_free>
    tLinearDelay_free(&p->delUF);
   2e140:	f104 0030 	add.w	r0, r4, #48	; 0x30
   2e144:	f7fa f88c 	bl	28260 <tLinearDelay_free>
    tLinearDelay_free(&p->delUB);
   2e148:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2e14c:	f7fa f888 	bl	28260 <tLinearDelay_free>
    tLinearDelay_free(&p->delMB);
   2e150:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2e154:	f7fa f884 	bl	28260 <tLinearDelay_free>
    tLinearDelay_free(&p->delLB);
   2e158:	f104 0040 	add.w	r0, r4, #64	; 0x40
   2e15c:	f7fa f880 	bl	28260 <tLinearDelay_free>
    tOnePole_free(&p->bridgeFilter);
   2e160:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2e164:	f7fd fa34 	bl	2b5d0 <tOnePole_free>
    tOnePole_free(&p->nutFilter);
   2e168:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2e16c:	f7fd fa30 	bl	2b5d0 <tOnePole_free>
    tOnePole_free(&p->prepFilterU);
   2e170:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2e174:	f7fd fa2c 	bl	2b5d0 <tOnePole_free>
    tOnePole_free(&p->prepFilterL);
   2e178:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2e17c:	f7fd fa28 	bl	2b5d0 <tOnePole_free>
    tHighpass_free(&p->DCblockerU);
   2e180:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2e184:	f7fd fc56 	bl	2ba34 <tHighpass_free>
    tHighpass_free(&p->DCblockerL);
   2e188:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2e18c:	f7fd fc52 	bl	2ba34 <tHighpass_free>
    tFeedbackLeveler_free(&p->fbLevU);
   2e190:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2e194:	f7fa fee8 	bl	28f68 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&p->fbLevL);
   2e198:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2e19c:	f7fa fee4 	bl	28f68 <tFeedbackLeveler_free>
    mpool_free((char*)p, p->mempool);
   2e1a0:	6821      	ldr	r1, [r4, #0]
   2e1a2:	4620      	mov	r0, r4
}
   2e1a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   2e1a8:	f7ff b8dc 	b.w	2d364 <mpool_free>

0002e1ac <tComplexLivingString_setFreq>:
{    // NOTE: It is faster to set wavelength in samples directly
   2e1ac:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2e1b0:	f64f 0208 	movw	r2, #63496	; 0xf808
   2e1b4:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    _tComplexLivingString* p = *pl;
   2e1b8:	6801      	ldr	r1, [r0, #0]
   2e1ba:	f2c4 631c 	movt	r3, #17948	; 0x461c
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2e1be:	f2c0 220f 	movt	r2, #527	; 0x20f
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2e1c2:	f101 0064 	add.w	r0, r1, #100	; 0x64
   2e1c6:	ee07 3a90 	vmov	s15, r3
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2e1ca:	ed92 7a00 	vldr	s14, [r2]
   2e1ce:	fec0 7a67 	vminnm.f32	s15, s0, s15
   2e1d2:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
   2e1d6:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2e1da:	ed81 0a02 	vstr	s0, [r1, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2e1de:	f7fd b8eb 	b.w	2b3b8 <tExpSmooth_setDest>
   2e1e2:	bf00      	nop

0002e1e4 <tComplexLivingString_setPickPos>:
{    // between 0 and 1
   2e1e4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
   2e1e8:	6803      	ldr	r3, [r0, #0]
   2e1ea:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2e1ee:	f103 0068 	add.w	r0, r3, #104	; 0x68
   2e1f2:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2e1f6:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->pickPos = pickPos;
   2e1fa:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2e1fe:	f7fd b8db 	b.w	2b3b8 <tExpSmooth_setDest>
   2e202:	bf00      	nop

0002e204 <tComplexLivingString_setPrepPos>:
{    // between 0 and 1
   2e204:	2300      	movs	r3, #0
   2e206:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    _tComplexLivingString* p = *pl;
   2e20a:	6802      	ldr	r2, [r0, #0]
   2e20c:	ee07 3a10 	vmov	s14, r3
   2e210:	fe80 0a67 	vminnm.f32	s0, s0, s15
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2e214:	f102 006c 	add.w	r0, r2, #108	; 0x6c
   2e218:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->prepPos = prepPos;
   2e21c:	ed82 0a04 	vstr	s0, [r2, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2e220:	f7fd b8ca 	b.w	2b3b8 <tExpSmooth_setDest>

0002e224 <tComplexLivingString_setPrepIndex>:
void     tComplexLivingString_setPrepIndex(tComplexLivingString* const pl, float prepIndex)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
    if (prepIndex<0.f) prepIndex=0.f;
    else if (prepIndex>1.f) prepIndex=1.f;
    p->prepIndex = prepIndex;
   2e224:	2300      	movs	r3, #0
   2e226:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
   2e22a:	6802      	ldr	r2, [r0, #0]
    p->prepIndex = prepIndex;
   2e22c:	ee07 3a10 	vmov	s14, r3
   2e230:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2e234:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
   2e238:	ed82 0a06 	vstr	s0, [r2, #24]
}
   2e23c:	4770      	bx	lr
   2e23e:	bf00      	nop

0002e240 <tComplexLivingString_setDampFreq>:

void     tComplexLivingString_setDampFreq(tComplexLivingString* const pl, float dampFreq)
{
   2e240:	b510      	push	{r4, lr}
   2e242:	ed2d 8b02 	vpush	{d8}
   2e246:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
   2e24a:	6804      	ldr	r4, [r0, #0]
    tOnePole_setFreq(&p->bridgeFilter, dampFreq);
   2e24c:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2e250:	f7fd f9c2 	bl	2b5d8 <tOnePole_setFreq>
    tOnePole_setFreq(&p->nutFilter, dampFreq);
   2e254:	eeb0 0a48 	vmov.f32	s0, s16
   2e258:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2e25c:	f7fd f9bc 	bl	2b5d8 <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterU, dampFreq);
   2e260:	eeb0 0a48 	vmov.f32	s0, s16
   2e264:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2e268:	f7fd f9b6 	bl	2b5d8 <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
   2e26c:	eeb0 0a48 	vmov.f32	s0, s16
   2e270:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
   2e274:	ecbd 8b02 	vpop	{d8}
   2e278:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
   2e27c:	f7fd b9ac 	b.w	2b5d8 <tOnePole_setFreq>

0002e280 <tComplexLivingString_setDecay>:

void     tComplexLivingString_setDecay(tComplexLivingString* const pl, float decay)
{
    _tComplexLivingString* p = *pl;
   2e280:	6803      	ldr	r3, [r0, #0]
    p->decay=decay;
   2e282:	ed83 0a08 	vstr	s0, [r3, #32]
}
   2e286:	4770      	bx	lr

0002e288 <tComplexLivingString_setTargetLev>:

void     tComplexLivingString_setTargetLev(tComplexLivingString* const pl, float targetLev)
{
   2e288:	b510      	push	{r4, lr}
   2e28a:	ed2d 8b02 	vpush	{d8}
   2e28e:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
   2e292:	6804      	ldr	r4, [r0, #0]
    tFeedbackLeveler_setTargetLevel(&p->fbLevU, targetLev);
   2e294:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2e298:	f7fa fe9c 	bl	28fd4 <tFeedbackLeveler_setTargetLevel>
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
   2e29c:	eeb0 0a48 	vmov.f32	s0, s16
   2e2a0:	f104 0060 	add.w	r0, r4, #96	; 0x60
}
   2e2a4:	ecbd 8b02 	vpop	{d8}
   2e2a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
   2e2ac:	f7fa be92 	b.w	28fd4 <tFeedbackLeveler_setTargetLevel>

0002e2b0 <tComplexLivingString_setLevMode>:
    tFeedbackLeveler_setStrength(&p->fbLevU, levStrength);
    tFeedbackLeveler_setStrength(&p->fbLevL, levStrength);
}

void     tComplexLivingString_setLevMode(tComplexLivingString* const pl, int levMode)
{
   2e2b0:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
   2e2b2:	6804      	ldr	r4, [r0, #0]
{
   2e2b4:	b082      	sub	sp, #8
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
   2e2b6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
{
   2e2ba:	9101      	str	r1, [sp, #4]
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
   2e2bc:	f7fa fe60 	bl	28f80 <tFeedbackLeveler_setMode>
    tFeedbackLeveler_setMode(&p->fbLevL, levMode);
   2e2c0:	9901      	ldr	r1, [sp, #4]
   2e2c2:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2e2c6:	f7fa fe5b 	bl	28f80 <tFeedbackLeveler_setMode>
    p->levMode=levMode;
   2e2ca:	eddd 7a01 	vldr	s15, [sp, #4]
   2e2ce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e2d2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
   2e2d6:	b002      	add	sp, #8
   2e2d8:	bd10      	pop	{r4, pc}
   2e2da:	bf00      	nop

0002e2dc <tComplexLivingString_tick>:

float   tComplexLivingString_tick(tComplexLivingString* const pl, float input)
{
   2e2dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e2e0:	ed2d 8b08 	vpush	{d8-d11}
    _tComplexLivingString* p = *pl;
   2e2e4:	6804      	ldr	r4, [r0, #0]
{
   2e2e6:	eef0 8a40 	vmov.f32	s17, s0

    // from pickPos upwards=forwards
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2e2ea:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2e2ee:	f104 0834 	add.w	r8, r4, #52	; 0x34
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2e2f2:	f104 0630 	add.w	r6, r4, #48	; 0x30
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2e2f6:	f104 053c 	add.w	r5, r4, #60	; 0x3c
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2e2fa:	4650      	mov	r0, sl
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2e2fc:	f104 0738 	add.w	r7, r4, #56	; 0x38
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2e300:	f7fa f816 	bl	28330 <tLinearDelay_tickOut>
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2e304:	4640      	mov	r0, r8
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2e306:	eeb0 9a40 	vmov.f32	s18, s0
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2e30a:	f7fa f811 	bl	28330 <tLinearDelay_tickOut>
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2e30e:	4630      	mov	r0, r6
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2e310:	f104 0940 	add.w	r9, r4, #64	; 0x40
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2e314:	eef0 aa40 	vmov.f32	s21, s0
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2e318:	f7fa f80a 	bl	28330 <tLinearDelay_tickOut>
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2e31c:	4628      	mov	r0, r5
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2e31e:	eef0 9a40 	vmov.f32	s19, s0
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2e322:	f7fa f805 	bl	28330 <tLinearDelay_tickOut>
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2e326:	4638      	mov	r0, r7
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2e328:	eeb0 aa40 	vmov.f32	s20, s0
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2e32c:	f7fa f800 	bl	28330 <tLinearDelay_tickOut>
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2e330:	4648      	mov	r0, r9
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2e332:	eef0 ba40 	vmov.f32	s23, s0
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2e336:	f7f9 fffb 	bl	28330 <tLinearDelay_tickOut>

    // into upper part of string, from bridge, going backwards
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2e33a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2e33e:	eeb0 ba40 	vmov.f32	s22, s0
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2e342:	f104 0b5c 	add.w	fp, r4, #92	; 0x5c
   2e346:	eef5 7a40 	vcmp.f32	s15, #0.0
   2e34a:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2e34e:	eeb0 0a69 	vmov.f32	s0, s19
   2e352:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e356:	bf14      	ite	ne
   2e358:	eeb7 8a00 	vmovne.f32	s16, #112	; 0x3f800000  1.0
   2e35c:	ed94 8a08 	vldreq	s16, [r4, #32]
   2e360:	f7fd f956 	bl	2b610 <tOnePole_tick>
   2e364:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2e368:	f7fd fb78 	bl	2ba5c <tHighpass_tick>
   2e36c:	4658      	mov	r0, fp
   2e36e:	ee20 0a08 	vmul.f32	s0, s0, s16
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
    tLinearDelay_tickIn(&p->delLB, intoLower);

    // into lower part of string, from nut, going forwards toward prep position
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
   2e372:	f104 0b60 	add.w	fp, r4, #96	; 0x60
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2e376:	f7fa fe07 	bl	28f88 <tFeedbackLeveler_tick>
   2e37a:	eef1 9a40 	vneg.f32	s19, s0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
   2e37e:	4628      	mov	r0, r5
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2e380:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
   2e384:	eeb0 0a69 	vmov.f32	s0, s19
   2e388:	f7f9 ffbe 	bl	28308 <tLinearDelay_tickIn>
    tLinearDelay_tickIn(&p->delMB, fromUB+input);
   2e38c:	ee3a 0a28 	vadd.f32	s0, s20, s17
   2e390:	4638      	mov	r0, r7
   2e392:	f7f9 ffb9 	bl	28308 <tLinearDelay_tickIn>
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
   2e396:	eeb0 0a49 	vmov.f32	s0, s18
   2e39a:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2e39e:	f7fd f937 	bl	2b610 <tOnePole_tick>
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2e3a2:	ed94 7a06 	vldr	s14, [r4, #24]
    tLinearDelay_tickIn(&p->delLB, intoLower);
   2e3a6:	4648      	mov	r0, r9
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2e3a8:	ee78 7a47 	vsub.f32	s15, s16, s14
   2e3ac:	ee67 7aab 	vmul.f32	s15, s15, s23
    tLinearDelay_tickIn(&p->delLB, intoLower);
   2e3b0:	eee0 7a47 	vfms.f32	s15, s0, s14
   2e3b4:	eeb0 0a67 	vmov.f32	s0, s15
   2e3b8:	f7f9 ffa6 	bl	28308 <tLinearDelay_tickIn>
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
   2e3bc:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2e3c0:	eeb0 0a4b 	vmov.f32	s0, s22
   2e3c4:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2e3c8:	eef5 7a40 	vcmp.f32	s15, #0.0
   2e3cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e3d0:	bf08      	it	eq
   2e3d2:	ed94 8a08 	vldreq	s16, [r4, #32]
   2e3d6:	f7fd f91b 	bl	2b610 <tOnePole_tick>
   2e3da:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2e3de:	f7fd fb3d 	bl	2ba5c <tHighpass_tick>
   2e3e2:	4658      	mov	r0, fp
   2e3e4:	ee20 0a08 	vmul.f32	s0, s0, s16
   2e3e8:	f7fa fdce 	bl	28f88 <tFeedbackLeveler_tick>
    tLinearDelay_tickIn(&p->delLF, fromNut);
   2e3ec:	4650      	mov	r0, sl
   2e3ee:	eeb1 0a40 	vneg.f32	s0, s0
   2e3f2:	f7f9 ff89 	bl	28308 <tLinearDelay_tickIn>

    // into middle part of string, from prep going toward pick position
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2e3f6:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
   2e3fa:	eeb0 0a4a 	vmov.f32	s0, s20
   2e3fe:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2e402:	f7fd f905 	bl	2b610 <tOnePole_tick>
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2e406:	edd4 7a06 	vldr	s15, [r4, #24]

    //pick position, take input and add it into the waveguide, going to come out of middle segment
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
   2e40a:	4640      	mov	r0, r8
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2e40c:	ee38 7a67 	vsub.f32	s14, s16, s15
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
   2e410:	eee7 8a09 	vfma.f32	s17, s14, s18
   2e414:	eee0 8a67 	vfms.f32	s17, s0, s15
   2e418:	eeb0 0a68 	vmov.f32	s0, s17
   2e41c:	f7f9 ff74 	bl	28308 <tLinearDelay_tickIn>

    //take output of middle segment and put it into upper segment connecting to the bridge
    tLinearDelay_tickIn(&p->delUF, fromMF);
   2e420:	eeb0 0a6a 	vmov.f32	s0, s21
   2e424:	4630      	mov	r0, r6
   2e426:	f7f9 ff6f 	bl	28308 <tLinearDelay_tickIn>

    // update all delay lengths
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
   2e42a:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2e42e:	f7fc ffcd 	bl	2b3cc <tExpSmooth_tick>
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
   2e432:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
   2e436:	eeb0 9a40 	vmov.f32	s18, s0
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
   2e43a:	f7fc ffc7 	bl	2b3cc <tExpSmooth_tick>
   2e43e:	eef0 8a40 	vmov.f32	s17, s0
    float wLen=tExpSmooth_tick(&p->wlSmooth);
   2e442:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2e446:	f7fc ffc1 	bl	2b3cc <tExpSmooth_tick>
   2e44a:	eef0 7a40 	vmov.f32	s15, s0

    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
    float lowLen = prepP*wLen; // the length from prep to nut
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
   2e44e:	ee38 8a49 	vsub.f32	s16, s16, s18


    tLinearDelay_setDelay(&p->delLF, lowLen);
   2e452:	4650      	mov	r0, sl
    float lowLen = prepP*wLen; // the length from prep to nut
   2e454:	ee28 aa80 	vmul.f32	s20, s17, s0
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
   2e458:	ee79 8a68 	vsub.f32	s17, s18, s17
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
   2e45c:	ee28 8a00 	vmul.f32	s16, s16, s0
    tLinearDelay_setDelay(&p->delLF, lowLen);
   2e460:	eeb0 0a4a 	vmov.f32	s0, s20
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
   2e464:	ee68 8aa7 	vmul.f32	s17, s17, s15
    tLinearDelay_setDelay(&p->delLF, lowLen);
   2e468:	f7f9 ff8c 	bl	28384 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delLB, lowLen);
   2e46c:	eeb0 0a4a 	vmov.f32	s0, s20
   2e470:	4648      	mov	r0, r9
   2e472:	f7f9 ff87 	bl	28384 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delMF, midLen);
   2e476:	4640      	mov	r0, r8
   2e478:	eeb0 0a68 	vmov.f32	s0, s17
   2e47c:	f7f9 ff82 	bl	28384 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delMB, midLen);
   2e480:	eeb0 0a68 	vmov.f32	s0, s17
   2e484:	4638      	mov	r0, r7
   2e486:	f7f9 ff7d 	bl	28384 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delUF, upLen);
   2e48a:	eeb0 0a48 	vmov.f32	s0, s16
   2e48e:	4630      	mov	r0, r6
   2e490:	f7f9 ff78 	bl	28384 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delUB, upLen);
   2e494:	eeb0 0a48 	vmov.f32	s0, s16
   2e498:	4628      	mov	r0, r5
   2e49a:	f7f9 ff73 	bl	28384 <tLinearDelay_setDelay>

    //update this to allow pickup position variation
    p->curr = fromBridge;
    return p->curr;
}
   2e49e:	eeb0 0a69 	vmov.f32	s0, s19
    p->curr = fromBridge;
   2e4a2:	edc4 9a0a 	vstr	s19, [r4, #40]	; 0x28
}
   2e4a6:	ecbd 8b08 	vpop	{d8-d11}
   2e4aa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2e4ae:	bf00      	nop

0002e4b0 <tNReverb_initToPool>:
{
    tNReverb_initToPool(rev, t60, &leaf.mempool);
}

void    tNReverb_initToPool     (tNReverb* const rev, float t60, tMempool* const mp)
{
   2e4b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e4b4:	ed2d 8b06 	vpush	{d8-d10}
   2e4b8:	eeb0 aa40 	vmov.f32	s20, s0
    _tMempool* m = *mp;
   2e4bc:	680c      	ldr	r4, [r1, #0]
{
   2e4be:	b097      	sub	sp, #92	; 0x5c
   2e4c0:	4605      	mov	r5, r0
   2e4c2:	460f      	mov	r7, r1
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2e4c4:	4621      	mov	r1, r4
{
   2e4c6:	9004      	str	r0, [sp, #16]
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2e4c8:	2074      	movs	r0, #116	; 0x74
   2e4ca:	f7fe fea1 	bl	2d210 <mpool_alloc>
    r->mempool = m;
    
    if (t60 <= 0.0f) t60 = 0.001f;
   2e4ce:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2e4d2:	6028      	str	r0, [r5, #0]
   2e4d4:	4682      	mov	sl, r0
    r->mempool = m;
   2e4d6:	6004      	str	r4, [r0, #0]
    if (t60 <= 0.0f) t60 = 0.001f;
   2e4d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e4dc:	f240 80dd 	bls.w	2e69a <tNReverb_initToPool+0x1ea>
   2e4e0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2e4e4:	ee87 8a8a 	vdiv.f32	s16, s15, s20
    
    r->inv_441 = 1.0f/44100.0f;
    
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
    double scaler = leaf.sampleRate / 25641.0f;
   2e4e8:	f64f 0608 	movw	r6, #63496	; 0xf808
   2e4ec:	f249 34f9 	movw	r4, #37881	; 0x93f9
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2e4f0:	f645 7e50 	movw	lr, #24400	; 0x5f50
   2e4f4:	f10d 0c1c 	add.w	ip, sp, #28
    double scaler = leaf.sampleRate / 25641.0f;
   2e4f8:	f6c3 0423 	movt	r4, #14371	; 0x3823
   2e4fc:	f2c0 260f 	movt	r6, #527	; 0x20f
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2e500:	f2c0 0e03 	movt	lr, #3
    double scaler = leaf.sampleRate / 25641.0f;
   2e504:	ed96 7a00 	vldr	s14, [r6]
   2e508:	ee07 4a90 	vmov	s15, r4
    r->inv_441 = 1.0f/44100.0f;
   2e50c:	f243 74c6 	movw	r4, #14278	; 0x37c6
    double scaler = leaf.sampleRate / 25641.0f;
   2e510:	ee67 7a27 	vmul.f32	s15, s14, s15
    r->inv_441 = 1.0f/44100.0f;
   2e514:	f2c3 74be 	movt	r4, #14270	; 0x37be
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2e518:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   2e51c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2e520:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   2e524:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    r->inv_441 = 1.0f/44100.0f;
   2e528:	f8ca 4010 	str.w	r4, [sl, #16]
   2e52c:	ac06      	add	r4, sp, #24
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2e52e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2e532:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   2e536:	ee17 ba90 	vmov	fp, s15
   2e53a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2e53e:	ab07      	add	r3, sp, #28
   2e540:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
   2e544:	9303      	str	r3, [sp, #12]
   2e546:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
    
    int delay, i;
    
    for (i=0; i < 15; i++)
    {
        delay = (int) scaler * lengths[i];
   2e54a:	f854 5f04 	ldr.w	r5, [r4, #4]!
   2e54e:	fb05 f50b 	mul.w	r5, r5, fp
        if ( (delay & 1) == 0)
   2e552:	07eb      	lsls	r3, r5, #31
            delay++;
   2e554:	bf58      	it	pl
   2e556:	3501      	addpl	r5, #1
   2e558:	46a8      	mov	r8, r5
   2e55a:	ea4f 79e5 	mov.w	r9, r5, asr #31
   2e55e:	e000      	b.n	2e562 <tNReverb_initToPool+0xb2>
        while ( !LEAF_isPrime(delay) )
            delay += 2;
   2e560:	3502      	adds	r5, #2
        while ( !LEAF_isPrime(delay) )
   2e562:	4640      	mov	r0, r8
   2e564:	f118 0802 	adds.w	r8, r8, #2
   2e568:	4649      	mov	r1, r9
   2e56a:	f149 0900 	adc.w	r9, r9, #0
   2e56e:	f7fe fc57 	bl	2ce20 <LEAF_isPrime>
   2e572:	2800      	cmp	r0, #0
   2e574:	d0f4      	beq.n	2e560 <tNReverb_initToPool+0xb0>
    for (i=0; i < 15; i++)
   2e576:	ab15      	add	r3, sp, #84	; 0x54
        lengths[i] = delay;
   2e578:	6025      	str	r5, [r4, #0]
    for (i=0; i < 15; i++)
   2e57a:	429c      	cmp	r4, r3
   2e57c:	d1e5      	bne.n	2e54a <tNReverb_initToPool+0x9a>
   2e57e:	f10a 0850 	add.w	r8, sl, #80	; 0x50
   2e582:	f10a 0968 	add.w	r9, sl, #104	; 0x68
   2e586:	f8dd b00c 	ldr.w	fp, [sp, #12]
   2e58a:	9405      	str	r4, [sp, #20]
    }
    
    for ( i=0; i<6; i++ )
    {
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
   2e58c:	f85b 5b04 	ldr.w	r5, [fp], #4
   2e590:	f1a8 041c 	sub.w	r4, r8, #28
   2e594:	463a      	mov	r2, r7
   2e596:	ee07 5a90 	vmov	s15, r5
   2e59a:	4620      	mov	r0, r4
        tLinearDelay_clear(&r->combDelays[i]);
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
   2e59c:	eba5 0585 	sub.w	r5, r5, r5, lsl #2
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
   2e5a0:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   2e5a4:	ee70 7a00 	vadd.f32	s15, s0, s0
   2e5a8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2e5ac:	ee17 1a90 	vmov	r1, s15
   2e5b0:	f7f9 fde6 	bl	28180 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->combDelays[i]);
   2e5b4:	4620      	mov	r0, r4
   2e5b6:	f7f9 fe5f 	bl	28278 <tLinearDelay_clear>
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
   2e5ba:	edd6 7a01 	vldr	s15, [r6, #4]
   2e5be:	ee07 5a10 	vmov	s14, r5
   2e5c2:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2e5c6:	ee68 7a27 	vmul.f32	s15, s16, s15
   2e5ca:	eeb8 1ac7 	vcvt.f32.s32	s2, s14
   2e5ce:	ee21 1a27 	vmul.f32	s2, s2, s15
   2e5d2:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
   2e5d6:	f002 faef 	bl	30bb8 <pow>
   2e5da:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2e5de:	eca8 0a01 	vstmia	r8!, {s0}
    for ( i=0; i<6; i++ )
   2e5e2:	45c1      	cmp	r9, r8
   2e5e4:	d1d2      	bne.n	2e58c <tNReverb_initToPool+0xdc>
   2e5e6:	9c05      	ldr	r4, [sp, #20]
   2e5e8:	f10d 0834 	add.w	r8, sp, #52	; 0x34
   2e5ec:	f10a 0514 	add.w	r5, sl, #20
    }
    
    for ( i=0; i<8; i++ )
    {
        tLinearDelay_initToPool(&r->allpassDelays[i], lengths[i+6], lengths[i+6] * 2.0f, mp);
   2e5f0:	ecb8 0a01 	vldmia	r8!, {s0}
   2e5f4:	4628      	mov	r0, r5
   2e5f6:	463a      	mov	r2, r7
   2e5f8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   2e5fc:	ee70 7a00 	vadd.f32	s15, s0, s0
   2e600:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2e604:	ee17 1a90 	vmov	r1, s15
   2e608:	f7f9 fdba 	bl	28180 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->allpassDelays[i]);
   2e60c:	4628      	mov	r0, r5
   2e60e:	f7f9 fe33 	bl	28278 <tLinearDelay_clear>
    for ( i=0; i<8; i++ )
   2e612:	4544      	cmp	r4, r8
   2e614:	f105 0504 	add.w	r5, r5, #4
   2e618:	d1ea      	bne.n	2e5f0 <tNReverb_initToPool+0x140>

void    tNReverb_setT60(tNReverb* const rev, float t60)
{
    _tNReverb* r = *rev;
    
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e61a:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev;
   2e61e:	9b04      	ldr	r3, [sp, #16]
   2e620:	681b      	ldr	r3, [r3, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e622:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e626:	d945      	bls.n	2e6b4 <tNReverb_initToPool+0x204>
   2e628:	eeb7 7aca 	vcvt.f64.f32	d7, s20
   2e62c:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2e630:	ee86 9b07 	vdiv.f64	d9, d6, d7
   2e634:	f103 0450 	add.w	r4, r3, #80	; 0x50
   2e638:	f103 0568 	add.w	r5, r3, #104	; 0x68
    
    r->t60 = t60;
   2e63c:	ed83 aa02 	vstr	s20, [r3, #8]
    
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
   2e640:	eeb8 8b08 	vmov.f64	d8, #136	; 0xc0400000 -3.0
   2e644:	f1a4 001c 	sub.w	r0, r4, #28
   2e648:	f7f9 fedc 	bl	28404 <tLinearDelay_getDelay>
   2e64c:	ed96 7a01 	vldr	s14, [r6, #4]
   2e650:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
   2e654:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2e658:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2e65c:	ee27 7b08 	vmul.f64	d7, d7, d8
   2e660:	ee27 7b09 	vmul.f64	d7, d7, d9
   2e664:	ee27 1b01 	vmul.f64	d1, d7, d1
   2e668:	f002 faa6 	bl	30bb8 <pow>
   2e66c:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2e670:	eca4 0a01 	vstmia	r4!, {s0}
   2e674:	42a5      	cmp	r5, r4
   2e676:	d1e5      	bne.n	2e644 <tNReverb_initToPool+0x194>
    r->allpassCoeff = 0.7f;
   2e678:	f243 3233 	movw	r2, #13107	; 0x3333
    r->mix = 0.3f;
   2e67c:	f649 139a 	movw	r3, #39322	; 0x999a
    r->allpassCoeff = 0.7f;
   2e680:	f6c3 7233 	movt	r2, #16179	; 0x3f33
    r->mix = 0.3f;
   2e684:	f6c3 6399 	movt	r3, #16025	; 0x3e99
    r->allpassCoeff = 0.7f;
   2e688:	f8ca 204c 	str.w	r2, [sl, #76]	; 0x4c
    r->mix = 0.3f;
   2e68c:	f8ca 3004 	str.w	r3, [sl, #4]
}
   2e690:	b017      	add	sp, #92	; 0x5c
   2e692:	ecbd 8b06 	vpop	{d8-d10}
   2e696:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2e69a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    if (t60 <= 0.0f) t60 = 0.001f;
   2e69e:	f241 226f 	movw	r2, #4719	; 0x126f
   2e6a2:	f2c4 4379 	movt	r3, #17529	; 0x4479
   2e6a6:	f6c3 2283 	movt	r2, #14979	; 0x3a83
   2e6aa:	ee08 3a10 	vmov	s16, r3
   2e6ae:	ee0a 2a10 	vmov	s20, r2
   2e6b2:	e719      	b.n	2e4e8 <tNReverb_initToPool+0x38>
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e6b4:	2114      	movs	r1, #20
   2e6b6:	f241 226f 	movw	r2, #4719	; 0x126f
   2e6ba:	f2ce 7119 	movt	r1, #59161	; 0xe719
   2e6be:	f6c3 2283 	movt	r2, #14979	; 0x3a83
   2e6c2:	9100      	str	r1, [sp, #0]
   2e6c4:	f643 71ff 	movw	r1, #16383	; 0x3fff
   2e6c8:	ee0a 2a10 	vmov	s20, r2
   2e6cc:	460a      	mov	r2, r1
   2e6ce:	f2c4 028f 	movt	r2, #16527	; 0x408f
   2e6d2:	9201      	str	r2, [sp, #4]
   2e6d4:	ed9d 9b00 	vldr	d9, [sp]
   2e6d8:	e7ac      	b.n	2e634 <tNReverb_initToPool+0x184>
   2e6da:	bf00      	nop

0002e6dc <tNReverb_init>:
    tNReverb_initToPool(rev, t60, &leaf.mempool);
   2e6dc:	f64f 0120 	movw	r1, #63520	; 0xf820
   2e6e0:	f2c0 210f 	movt	r1, #527	; 0x20f
   2e6e4:	f7ff bee4 	b.w	2e4b0 <tNReverb_initToPool>

0002e6e8 <tNReverb_free>:
{
   2e6e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tNReverb* r = *rev;
   2e6ea:	6807      	ldr	r7, [r0, #0]
   2e6ec:	f107 0534 	add.w	r5, r7, #52	; 0x34
   2e6f0:	f107 064c 	add.w	r6, r7, #76	; 0x4c
   2e6f4:	462c      	mov	r4, r5
        tLinearDelay_free(&r->combDelays[i]);
   2e6f6:	4620      	mov	r0, r4
   2e6f8:	3404      	adds	r4, #4
   2e6fa:	f7f9 fdb1 	bl	28260 <tLinearDelay_free>
    for (int i = 0; i < 6; i++)
   2e6fe:	42b4      	cmp	r4, r6
   2e700:	d1f9      	bne.n	2e6f6 <tNReverb_free+0xe>
   2e702:	f107 0414 	add.w	r4, r7, #20
        tLinearDelay_free(&r->allpassDelays[i]);
   2e706:	4620      	mov	r0, r4
   2e708:	3404      	adds	r4, #4
   2e70a:	f7f9 fda9 	bl	28260 <tLinearDelay_free>
    for (int i = 0; i < 8; i++)
   2e70e:	42a5      	cmp	r5, r4
   2e710:	d1f9      	bne.n	2e706 <tNReverb_free+0x1e>
    mpool_free((char*)r, r->mempool);
   2e712:	6839      	ldr	r1, [r7, #0]
   2e714:	4638      	mov	r0, r7
}
   2e716:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   2e71a:	f7fe be23 	b.w	2d364 <mpool_free>
   2e71e:	bf00      	nop

0002e720 <tNReverb_setT60>:
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e720:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   2e724:	b570      	push	{r4, r5, r6, lr}
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e726:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
   2e72a:	ed2d 8b04 	vpush	{d8-d9}
    _tNReverb* r = *rev;
   2e72e:	6802      	ldr	r2, [r0, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e730:	d92e      	bls.n	2e790 <tNReverb_setT60+0x70>
   2e732:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
   2e736:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2e73a:	ee86 8b07 	vdiv.f64	d8, d6, d7
   2e73e:	f64f 0508 	movw	r5, #63496	; 0xf808
   2e742:	f102 0450 	add.w	r4, r2, #80	; 0x50
   2e746:	f102 0668 	add.w	r6, r2, #104	; 0x68
    r->t60 = t60;
   2e74a:	ed82 0a02 	vstr	s0, [r2, #8]
   2e74e:	f2c0 250f 	movt	r5, #527	; 0x20f
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
   2e752:	eeb8 9b08 	vmov.f64	d9, #136	; 0xc0400000 -3.0
   2e756:	f1a4 001c 	sub.w	r0, r4, #28
   2e75a:	f7f9 fe53 	bl	28404 <tLinearDelay_getDelay>
   2e75e:	ed95 7a01 	vldr	s14, [r5, #4]
   2e762:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
   2e766:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2e76a:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2e76e:	ee27 7b09 	vmul.f64	d7, d7, d9
   2e772:	ee27 7b08 	vmul.f64	d7, d7, d8
   2e776:	ee27 1b01 	vmul.f64	d1, d7, d1
   2e77a:	f002 fa1d 	bl	30bb8 <pow>
   2e77e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2e782:	eca4 0a01 	vstmia	r4!, {s0}
   2e786:	42b4      	cmp	r4, r6
   2e788:	d1e5      	bne.n	2e756 <tNReverb_setT60+0x36>
    
}
   2e78a:	ecbd 8b04 	vpop	{d8-d9}
   2e78e:	bd70      	pop	{r4, r5, r6, pc}
   2e790:	2414      	movs	r4, #20
    if (t60 <= 0.0f)           t60 = 0.001f;
   2e792:	f241 236f 	movw	r3, #4719	; 0x126f
   2e796:	f643 75ff 	movw	r5, #16383	; 0x3fff
   2e79a:	f2ce 7419 	movt	r4, #59161	; 0xe719
   2e79e:	f6c3 2383 	movt	r3, #14979	; 0x3a83
   2e7a2:	f2c4 058f 	movt	r5, #16527	; 0x408f
   2e7a6:	ee00 3a10 	vmov	s0, r3
   2e7aa:	ec45 4b18 	vmov	d8, r4, r5
   2e7ae:	e7c6      	b.n	2e73e <tNReverb_setT60+0x1e>

0002e7b0 <tNReverb_setMix>:

void    tNReverb_setMix(tNReverb* const rev, float mix)
{
    _tNReverb* r = *rev;
   2e7b0:	6803      	ldr	r3, [r0, #0]
    r->mix = mix;
   2e7b2:	ed83 0a01 	vstr	s0, [r3, #4]
}
   2e7b6:	4770      	bx	lr

0002e7b8 <tNReverb_tickStereo>:

    return out;
}

void   tNReverb_tickStereo(tNReverb* const rev, float input, float* output)
{
   2e7b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    r->lastIn = input;

    float temp, temp0, temp1, temp2, temp3, out;
    int i;

    temp0 = 0.0;
   2e7bc:	2300      	movs	r3, #0
{
   2e7be:	4688      	mov	r8, r1
   2e7c0:	ed2d 8b06 	vpush	{d8-d10}
    _tNReverb* r = *rev;
   2e7c4:	6805      	ldr	r5, [r0, #0]
{
   2e7c6:	eeb0 9a40 	vmov.f32	s18, s0
    temp0 = 0.0;
   2e7ca:	ee08 3a10 	vmov	s16, r3
   2e7ce:	f105 0450 	add.w	r4, r5, #80	; 0x50
   2e7d2:	f105 0768 	add.w	r7, r5, #104	; 0x68
    r->lastIn = input;
   2e7d6:	ed85 0a1b 	vstr	s0, [r5, #108]	; 0x6c
   2e7da:	f1a4 061c 	sub.w	r6, r4, #28
    for ( i=0; i<6; i++ )
    {
        temp = input + (r->combCoeffs[i] * tLinearDelay_getLastOut(&r->combDelays[i]));
   2e7de:	ecf4 8a01 	vldmia	r4!, {s17}
   2e7e2:	4630      	mov	r0, r6
   2e7e4:	f7f9 fe12 	bl	2840c <tLinearDelay_getLastOut>
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
   2e7e8:	eef0 7a49 	vmov.f32	s15, s18
   2e7ec:	4630      	mov	r0, r6
   2e7ee:	eee8 7a80 	vfma.f32	s15, s17, s0
   2e7f2:	eeb0 0a67 	vmov.f32	s0, s15
   2e7f6:	f7f9 fd4d 	bl	28294 <tLinearDelay_tick>
    for ( i=0; i<6; i++ )
   2e7fa:	42bc      	cmp	r4, r7
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
   2e7fc:	ee38 8a00 	vadd.f32	s16, s16, s0
    for ( i=0; i<6; i++ )
   2e800:	d1eb      	bne.n	2e7da <tNReverb_tickStereo+0x22>
   2e802:	f105 0414 	add.w	r4, r5, #20
   2e806:	f105 0620 	add.w	r6, r5, #32
    }

    for ( i=0; i<3; i++ )
    {
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
   2e80a:	4620      	mov	r0, r4
   2e80c:	f7f9 fdfe 	bl	2840c <tLinearDelay_getLastOut>
        temp1 = r->allpassCoeff * temp;
        temp1 += temp0;
   2e810:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
   2e814:	eef0 8a40 	vmov.f32	s17, s0
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
   2e818:	4620      	mov	r0, r4
        temp1 += temp0;
   2e81a:	eea7 8a80 	vfma.f32	s16, s15, s0
   2e81e:	3404      	adds	r4, #4
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
   2e820:	eeb0 0a48 	vmov.f32	s0, s16
   2e824:	f7f9 fd36 	bl	28294 <tLinearDelay_tick>
        temp0 = -(r->allpassCoeff * temp1) + temp;
   2e828:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    for ( i=0; i<3; i++ )
   2e82c:	42a6      	cmp	r6, r4
        temp0 = -(r->allpassCoeff * temp1) + temp;
   2e82e:	eee7 8ac8 	vfms.f32	s17, s15, s16
   2e832:	eeb0 8a68 	vmov.f32	s16, s17
    for ( i=0; i<3; i++ )
   2e836:	d1e8      	bne.n	2e80a <tNReverb_tickStereo+0x52>
    }

    // One-pole lowpass filter.
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2e838:	f649 129a 	movw	r2, #39322	; 0x999a
   2e83c:	f243 3333 	movw	r3, #13107	; 0x3333
   2e840:	edd5 6a1a 	vldr	s13, [r5, #104]	; 0x68

    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2e844:	4630      	mov	r0, r6
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2e846:	f6c3 6299 	movt	r2, #16025	; 0x3e99
   2e84a:	f6c3 7333 	movt	r3, #16179	; 0x3f33
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
    temp1 = -(r->allpassCoeff * temp1) + temp;

    float drymix = ( 1.0f - r->mix ) * input;

    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2e84e:	f105 0724 	add.w	r7, r5, #36	; 0x24
    float drymix = ( 1.0f - r->mix ) * input;
   2e852:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2e856:	ee07 2a10 	vmov	s14, r2
   2e85a:	ee07 3a90 	vmov	s15, r3
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
    out = output[0];


    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2e85e:	f105 0428 	add.w	r4, r5, #40	; 0x28
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2e862:	ee28 8a87 	vmul.f32	s16, s17, s14
   2e866:	eea6 8aa7 	vfma.f32	s16, s13, s15
   2e86a:	ed85 8a1a 	vstr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2e86e:	f7f9 fdcd 	bl	2840c <tLinearDelay_getLastOut>
    temp1 += r->lowpassState;
   2e872:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
   2e876:	ed95 8a1a 	vldr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2e87a:	eef0 8a40 	vmov.f32	s17, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
   2e87e:	4630      	mov	r0, r6
    temp1 += r->lowpassState;
   2e880:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
   2e884:	eeb0 0a48 	vmov.f32	s0, s16
   2e888:	f7f9 fd04 	bl	28294 <tLinearDelay_tick>
    temp1 = -(r->allpassCoeff * temp1) + temp;
   2e88c:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
    float drymix = ( 1.0f - r->mix ) * input;
   2e890:	edd5 7a01 	vldr	s15, [r5, #4]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2e894:	4638      	mov	r0, r7
    temp1 = -(r->allpassCoeff * temp1) + temp;
   2e896:	eee7 8a48 	vfms.f32	s17, s14, s16
    float drymix = ( 1.0f - r->mix ) * input;
   2e89a:	ee3a aa67 	vsub.f32	s20, s20, s15
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2e89e:	f7f9 fdb5 	bl	2840c <tLinearDelay_getLastOut>
    temp2 += temp1;
   2e8a2:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2e8a6:	eef0 9a40 	vmov.f32	s19, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
   2e8aa:	4638      	mov	r0, r7
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2e8ac:	eeea 9a09 	vfma.f32	s19, s20, s18
    temp2 += temp1;
   2e8b0:	eeb0 8a68 	vmov.f32	s16, s17
   2e8b4:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
   2e8b8:	eeb0 0a48 	vmov.f32	s0, s16
   2e8bc:	f7f9 fcea 	bl	28294 <tLinearDelay_tick>
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2e8c0:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2e8c4:	4620      	mov	r0, r4
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2e8c6:	eee7 9ac8 	vfms.f32	s19, s15, s16
   2e8ca:	edc8 9a00 	vstr	s19, [r8]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2e8ce:	f7f9 fd9d 	bl	2840c <tLinearDelay_getLastOut>
    temp3 = r->allpassCoeff * temp;
    temp3 += temp1;
   2e8d2:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2e8d6:	eeb0 8a40 	vmov.f32	s16, s0
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
   2e8da:	4620      	mov	r0, r4
    temp3 += temp1;
   2e8dc:	eee7 8a80 	vfma.f32	s17, s15, s0
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
   2e8e0:	eeaa 8a09 	vfma.f32	s16, s20, s18
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
   2e8e4:	eeb0 0a68 	vmov.f32	s0, s17
   2e8e8:	f7f9 fcd4 	bl	28294 <tLinearDelay_tick>
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
   2e8ec:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
   2e8f0:	edd5 7a01 	vldr	s15, [r5, #4]
   2e8f4:	eea7 8a68 	vfms.f32	s16, s14, s17
   2e8f8:	ee28 8a27 	vmul.f32	s16, s16, s15
   2e8fc:	ed88 8a01 	vstr	s16, [r8, #4]

    r->lastOut = out;
   2e900:	edc5 9a1c 	vstr	s19, [r5, #112]	; 0x70
}
   2e904:	ecbd 8b06 	vpop	{d8-d10}
   2e908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002e90c <tDattorroReverb_initToPool>:
{
    tDattorroReverb_initToPool(rev, &leaf.mempool);
}

void    tDattorroReverb_initToPool        (tDattorroReverb* const rev, tMempool* const mp)
{
   2e90c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2e910:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2e914:	680d      	ldr	r5, [r1, #0]
{
   2e916:	460e      	mov	r6, r1
   2e918:	4681      	mov	r9, r0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2e91a:	2088      	movs	r0, #136	; 0x88
   2e91c:	4629      	mov	r1, r5
    r->mempool = m;
    
    r->size_max = 2.0f;
    r->size = 1.f;
   2e91e:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2e922:	f7fe fc75 	bl	2d210 <mpool_alloc>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e926:	f64f 0108 	movw	r1, #63496	; 0xf808
   2e92a:	f241 226f 	movw	r2, #4719	; 0x126f
    r->frozen = 0;
    // INPUT
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2e92e:	2300      	movs	r3, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e930:	f2c0 210f 	movt	r1, #527	; 0x20f
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2e934:	f8c9 0000 	str.w	r0, [r9]
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e938:	f6c3 2283 	movt	r2, #14979	; 0x3a83
    r->mempool = m;
   2e93c:	6005      	str	r5, [r0, #0]
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e93e:	ed91 7a00 	vldr	s14, [r1]
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2e942:	f2c4 3348 	movt	r3, #17224	; 0x4348
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e946:	ee06 2a90 	vmov	s13, r2
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2e94a:	4604      	mov	r4, r0
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2e94c:	ee07 3a90 	vmov	s15, r3
    r->frozen = 0;
   2e950:	2100      	movs	r1, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e952:	ee27 7a26 	vmul.f32	s14, s14, s13
    r->size_max = 2.0f;
   2e956:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   2e95a:	f246 3898 	movw	r8, #25496	; 0x6398
   2e95e:	f246 37a8 	movw	r7, #25512	; 0x63a8
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
    
    for (int i = 0; i < 4; i++)
    {
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
   2e962:	eeb3 8a04 	vmov.f32	s16, #52	; 0x41a00000  20.0
    r->size_max = 2.0f;
   2e966:	6202      	str	r2, [r0, #32]
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2e968:	ee67 7a27 	vmul.f32	s15, s14, s15
    r->frozen = 0;
   2e96c:	6181      	str	r1, [r0, #24]
    r->size = 1.f;
   2e96e:	edc0 8a07 	vstr	s17, [r0, #28]
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2e972:	ee00 1a10 	vmov	s0, r1
   2e976:	4632      	mov	r2, r6
   2e978:	3038      	adds	r0, #56	; 0x38
   2e97a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    r->t = r->size * leaf.sampleRate * 0.001f;
   2e97e:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
   2e982:	f2c0 0806 	movt	r8, #6
   2e986:	f2c0 0706 	movt	r7, #6
   2e98a:	f104 0540 	add.w	r5, r4, #64	; 0x40
   2e98e:	f104 0a50 	add.w	sl, r4, #80	; 0x50
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2e992:	ee17 1a90 	vmov	r1, s15
   2e996:	f7f9 fd71 	bl	2847c <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
   2e99a:	4631      	mov	r1, r6
   2e99c:	eeb0 0a68 	vmov.f32	s0, s17
   2e9a0:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2e9a4:	f7fc fdde 	bl	2b564 <tOnePole_initToPool>
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
   2e9a8:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2e9ac:	4628      	mov	r0, r5
   2e9ae:	ecb8 0a01 	vldmia	r8!, {s0}
   2e9b2:	4632      	mov	r2, r6
   2e9b4:	ee27 7a88 	vmul.f32	s14, s15, s16
   2e9b8:	ee20 0a27 	vmul.f32	s0, s0, s15
   2e9bc:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2e9c0:	ee17 1a90 	vmov	r1, s15
   2e9c4:	f7fc fd7a 	bl	2b4bc <tAllpass_initToPool>
        tAllpass_setGain(&r->in_allpass[i], in_allpass_gains[i]);
   2e9c8:	4628      	mov	r0, r5
   2e9ca:	3504      	adds	r5, #4
   2e9cc:	ecb7 0a01 	vldmia	r7!, {s0}
   2e9d0:	f7fc fdaa 	bl	2b528 <tAllpass_setGain>
    for (int i = 0; i < 4; i++)
   2e9d4:	4555      	cmp	r5, sl
   2e9d6:	d1e7      	bne.n	2e9a8 <tDattorroReverb_initToPool+0x9c>
    }
    
    // FEEDBACK 1
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2e9d8:	2100      	movs	r1, #0
   2e9da:	f241 437b 	movw	r3, #5243	; 0x147b
   2e9de:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2e9e2:	4632      	mov	r2, r6
   2e9e4:	f2c4 21c8 	movt	r1, #17096	; 0x42c8
   2e9e8:	f2c4 13f4 	movt	r3, #16884	; 0x41f4
   2e9ec:	4628      	mov	r0, r5
    tAllpass_setGain(&r->f1_allpass, 0.7f);
    
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2e9ee:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2e9f2:	ee09 1a10 	vmov	s18, r1
   2e9f6:	ee07 3a90 	vmov	s15, r3
    
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f1_lfo, mp);
   2e9fa:	f104 0868 	add.w	r8, r4, #104	; 0x68
    tCycle_setFreq(&r->f1_lfo, 0.1f);
    
    // FEEDBACK 2
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
   2e9fe:	f104 076c 	add.w	r7, r4, #108	; 0x6c
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2ea02:	ee20 7a09 	vmul.f32	s14, s0, s18
   2ea06:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ea0a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2ea0e:	ee17 1a90 	vmov	r1, s15
   2ea12:	f7fc fd53 	bl	2b4bc <tAllpass_initToPool>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
   2ea16:	f243 3333 	movw	r3, #13107	; 0x3333
   2ea1a:	4628      	mov	r0, r5
    
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f2_lfo, mp);
   2ea1c:	f104 0584 	add.w	r5, r4, #132	; 0x84
    tAllpass_setGain(&r->f1_allpass, 0.7f);
   2ea20:	f6c3 7333 	movt	r3, #16179	; 0x3f33
   2ea24:	ee00 3a10 	vmov	s0, r3
   2ea28:	f7fc fd7e 	bl	2b528 <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2ea2c:	2100      	movs	r1, #0
   2ea2e:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ea32:	eef0 6a48 	vmov.f32	s13, s16
   2ea36:	ed94 7a08 	vldr	s14, [r4, #32]
   2ea3a:	f2c4 3148 	movt	r1, #17224	; 0x4348
   2ea3e:	f24b 03a4 	movw	r3, #45220	; 0xb0a4
   2ea42:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2ea46:	ee20 7a07 	vmul.f32	s14, s0, s14
   2ea4a:	ee08 1a90 	vmov	s17, r1
   2ea4e:	f2c4 330d 	movt	r3, #17165	; 0x430d
   2ea52:	4632      	mov	r2, r6
   2ea54:	eee7 6a28 	vfma.f32	s13, s14, s17
   2ea58:	ee07 3a90 	vmov	s15, r3
   2ea5c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ea60:	eefc 7ae6 	vcvt.u32.f32	s15, s13
   2ea64:	ee17 1a90 	vmov	r1, s15
   2ea68:	f7f9 fd08 	bl	2847c <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_2, SAMP(89.24f), SAMP(100.0f) * r->size_max + 1, mp);
   2ea6c:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ea70:	ed94 7a08 	vldr	s14, [r4, #32]
   2ea74:	eef0 6a48 	vmov.f32	s13, s16
   2ea78:	f647 23e1 	movw	r3, #31457	; 0x7ae1
   2ea7c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2ea80:	ee20 7a07 	vmul.f32	s14, s0, s14
   2ea84:	4632      	mov	r2, r6
   2ea86:	f2c4 23b2 	movt	r3, #17074	; 0x42b2
   2ea8a:	eee7 6a09 	vfma.f32	s13, s14, s18
   2ea8e:	ee07 3a90 	vmov	s15, r3
   2ea92:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ea96:	eefc 7ae6 	vcvt.u32.f32	s15, s13
   2ea9a:	ee17 1a90 	vmov	r1, s15
   2ea9e:	f7f9 fced 	bl	2847c <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_3, SAMP(125.f), SAMP(200.0f) * r->size_max + 1, mp);
   2eaa2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2eaa6:	ed94 7a08 	vldr	s14, [r4, #32]
   2eaaa:	eef0 6a48 	vmov.f32	s13, s16
   2eaae:	2300      	movs	r3, #0
   2eab0:	4632      	mov	r2, r6
   2eab2:	ee20 7a07 	vmul.f32	s14, s0, s14
   2eab6:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2eaba:	f2c4 23fa 	movt	r3, #17146	; 0x42fa
   2eabe:	eee7 6a28 	vfma.f32	s13, s14, s17
   2eac2:	ee07 3a90 	vmov	s15, r3
   2eac6:	ee20 0a27 	vmul.f32	s0, s0, s15
   2eaca:	eefc 7ae6 	vcvt.u32.f32	s15, s13
   2eace:	ee17 1a90 	vmov	r1, s15
   2ead2:	f7f9 fcd3 	bl	2847c <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
   2ead6:	eeb0 0a48 	vmov.f32	s0, s16
   2eada:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2eade:	4631      	mov	r1, r6
   2eae0:	f7fc fd40 	bl	2b564 <tOnePole_initToPool>
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
   2eae4:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2eae8:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2eaec:	4631      	mov	r1, r6
   2eaee:	f7fc ff7f 	bl	2b9f0 <tHighpass_initToPool>
    tCycle_initToPool(&r->f1_lfo, mp);
   2eaf2:	4631      	mov	r1, r6
   2eaf4:	4640      	mov	r0, r8
   2eaf6:	f7ff f82f 	bl	2db58 <tCycle_initToPool>
    tCycle_setFreq(&r->f1_lfo, 0.1f);
   2eafa:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   2eafe:	4640      	mov	r0, r8
   2eb00:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
   2eb04:	ee00 3a10 	vmov	s0, r3
   2eb08:	f7ff f838 	bl	2db7c <tCycle_setFreq>
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
   2eb0c:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2eb10:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
   2eb14:	4632      	mov	r2, r6
   2eb16:	ee20 7a09 	vmul.f32	s14, s0, s18
   2eb1a:	4638      	mov	r0, r7
   2eb1c:	f2c4 13b4 	movt	r3, #16820	; 0x41b4
   2eb20:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2eb24:	ee07 3a90 	vmov	s15, r3
   2eb28:	ee20 0a27 	vmul.f32	s0, s0, s15
   2eb2c:	ee17 1a10 	vmov	r1, s14
   2eb30:	f7fc fcc4 	bl	2b4bc <tAllpass_initToPool>
    tAllpass_setGain(&r->f2_allpass, 0.7f);
   2eb34:	f243 3333 	movw	r3, #13107	; 0x3333
   2eb38:	4638      	mov	r0, r7
   2eb3a:	f6c3 7333 	movt	r3, #16179	; 0x3f33
   2eb3e:	ee00 3a10 	vmov	s0, r3
   2eb42:	f7fc fcf1 	bl	2b528 <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f2_delay_1, SAMP(149.62f), SAMP(200.f) * r->size_max + 1, mp);
   2eb46:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2eb4a:	ed94 7a08 	vldr	s14, [r4, #32]
   2eb4e:	eef0 6a48 	vmov.f32	s13, s16
   2eb52:	f649 63b8 	movw	r3, #40632	; 0x9eb8
   2eb56:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2eb5a:	ee20 7a07 	vmul.f32	s14, s0, s14
   2eb5e:	4632      	mov	r2, r6
   2eb60:	f2c4 3315 	movt	r3, #17173	; 0x4315
   2eb64:	eee7 6a28 	vfma.f32	s13, s14, s17
   2eb68:	ee07 3a90 	vmov	s15, r3
   2eb6c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2eb70:	eefc 7ae6 	vcvt.u32.f32	s15, s13
   2eb74:	ee17 1a90 	vmov	r1, s15
   2eb78:	f7f9 fc80 	bl	2847c <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_2, SAMP(60.48f), SAMP(100.f) * r->size_max + 1, mp);
   2eb7c:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2eb80:	ed94 7a08 	vldr	s14, [r4, #32]
   2eb84:	eef0 6a48 	vmov.f32	s13, s16
   2eb88:	f64e 3385 	movw	r3, #60293	; 0xeb85
   2eb8c:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2eb90:	ee20 7a07 	vmul.f32	s14, s0, s14
   2eb94:	4632      	mov	r2, r6
   2eb96:	f2c4 2371 	movt	r3, #17009	; 0x4271
   2eb9a:	eee7 6a09 	vfma.f32	s13, s14, s18
   2eb9e:	ee07 3a90 	vmov	s15, r3
   2eba2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2eba6:	eefc 7ae6 	vcvt.u32.f32	s15, s13
   2ebaa:	ee17 1a90 	vmov	r1, s15
   2ebae:	f7f9 fc65 	bl	2847c <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_3, SAMP(106.28f), SAMP(200.f) * r->size_max + 1, mp);
   2ebb2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ebb6:	ed94 7a08 	vldr	s14, [r4, #32]
   2ebba:	eef0 6a48 	vmov.f32	s13, s16
   2ebbe:	f648 735c 	movw	r3, #36700	; 0x8f5c
   2ebc2:	4632      	mov	r2, r6
   2ebc4:	ee20 7a07 	vmul.f32	s14, s0, s14
   2ebc8:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2ebcc:	f2c4 23d4 	movt	r3, #17108	; 0x42d4
   2ebd0:	eee7 6a28 	vfma.f32	s13, s14, s17
   2ebd4:	ee07 3a90 	vmov	s15, r3
   2ebd8:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ebdc:	eefc 7ae6 	vcvt.u32.f32	s15, s13
   2ebe0:	ee17 1a90 	vmov	r1, s15
   2ebe4:	f7f9 fc4a 	bl	2847c <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
   2ebe8:	eeb0 0a48 	vmov.f32	s0, s16
   2ebec:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2ebf0:	4631      	mov	r1, r6
   2ebf2:	f7fc fcb7 	bl	2b564 <tOnePole_initToPool>
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
   2ebf6:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2ebfa:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2ebfe:	4631      	mov	r1, r6
   2ec00:	f7fc fef6 	bl	2b9f0 <tHighpass_initToPool>
    tCycle_initToPool(&r->f2_lfo, mp);
   2ec04:	4631      	mov	r1, r6
   2ec06:	4628      	mov	r0, r5
   2ec08:	f7fe ffa6 	bl	2db58 <tCycle_initToPool>
    tCycle_setFreq(&r->f2_lfo, 0.07f);
   2ec0c:	f645 4329 	movw	r3, #23593	; 0x5c29
   2ec10:	4628      	mov	r0, r5
   2ec12:	f6c3 538f 	movt	r3, #15759	; 0x3d8f
   2ec16:	ee00 3a10 	vmov	s0, r3
   2ec1a:	f7fe ffaf 	bl	2db7c <tCycle_setFreq>
}

void    tDattorroReverb_setMix            (tDattorroReverb* const rev, float mix)
{
    _tDattorroReverb* r = *rev;
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2ec1e:	2300      	movs	r3, #0
   2ec20:	eeb0 1a48 	vmov.f32	s2, s16
    _tDattorroReverb* r = *rev;
   2ec24:	f8d9 4000 	ldr.w	r4, [r9]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2ec28:	eef6 0a00 	vmov.f32	s1, #96	; 0x3f000000  0.5
   2ec2c:	ee00 3a10 	vmov	s0, r3
   2ec30:	f7fe f8d6 	bl	2cde0 <LEAF_clip>

void    tDattorroReverb_setInputDelay     (tDattorroReverb* const rev, float preDelay)
{
    _tDattorroReverb* r = *rev;
    
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2ec34:	2300      	movs	r3, #0
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2ec36:	ed84 0a05 	vstr	s0, [r4, #20]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2ec3a:	eeb0 1a68 	vmov.f32	s2, s17
    _tDattorroReverb* r = *rev;
   2ec3e:	f8d9 4000 	ldr.w	r4, [r9]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2ec42:	ee00 3a90 	vmov	s1, r3
   2ec46:	ee00 3a10 	vmov	s0, r3
   2ec4a:	f7fe f8c9 	bl	2cde0 <LEAF_clip>
    
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
   2ec4e:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2ec52:	f104 0038 	add.w	r0, r4, #56	; 0x38
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2ec56:	ed84 0a01 	vstr	s0, [r4, #4]
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
   2ec5a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ec5e:	f7f9 fcbf 	bl	285e0 <tTapeDelay_setDelay>

void    tDattorroReverb_setInputFilter    (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
    
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2ec62:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   2ec66:	2100      	movs	r1, #0
    _tDattorroReverb* r = *rev;
   2ec68:	f8d9 4000 	ldr.w	r4, [r9]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2ec6c:	4613      	mov	r3, r2
   2ec6e:	f2c4 629c 	movt	r2, #18076	; 0x469c
   2ec72:	ee00 1a10 	vmov	s0, r1
   2ec76:	f2c4 631c 	movt	r3, #17948	; 0x461c
   2ec7a:	ee01 2a10 	vmov	s2, r2
   2ec7e:	ee00 3a90 	vmov	s1, r3
   2ec82:	f7fe f8ad 	bl	2cde0 <LEAF_clip>
    
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2ec86:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2ec8a:	ed84 0a02 	vstr	s0, [r4, #8]
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2ec8e:	f7fc fca3 	bl	2b5d8 <tOnePole_setFreq>

void    tDattorroReverb_setFeedbackFilter (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
    
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2ec92:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   2ec96:	2100      	movs	r1, #0
    _tDattorroReverb* r = *rev;
   2ec98:	f8d9 4000 	ldr.w	r4, [r9]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2ec9c:	4613      	mov	r3, r2
   2ec9e:	f2c4 629c 	movt	r2, #18076	; 0x469c
   2eca2:	ee00 1a10 	vmov	s0, r1
   2eca6:	f2c4 539c 	movt	r3, #17820	; 0x459c
   2ecaa:	ee01 2a10 	vmov	s2, r2
   2ecae:	ee00 3a90 	vmov	s1, r3
   2ecb2:	f7fe f895 	bl	2cde0 <LEAF_clip>
    
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2ecb6:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2ecba:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2ecbe:	f7fc fc8b 	bl	2b5d8 <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2ecc2:	ed94 0a03 	vldr	s0, [r4, #12]
   2ecc6:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2ecca:	f7fc fc85 	bl	2b5d8 <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackGain   (tDattorroReverb* const rev, float gain)
{
    _tDattorroReverb* r = *rev;
    r->feedback_gain = gain;
   2ecce:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    _tDattorroReverb* r = *rev;
   2ecd2:	f8d9 2000 	ldr.w	r2, [r9]
    r->feedback_gain = gain;
   2ecd6:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
   2ecda:	6113      	str	r3, [r2, #16]
}
   2ecdc:	ecbd 8b04 	vpop	{d8-d9}
   2ece0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0002ece4 <tDattorroReverb_init>:
    tDattorroReverb_initToPool(rev, &leaf.mempool);
   2ece4:	f64f 0120 	movw	r1, #63520	; 0xf820
   2ece8:	f2c0 210f 	movt	r1, #527	; 0x20f
   2ecec:	f7ff be0e 	b.w	2e90c <tDattorroReverb_initToPool>

0002ecf0 <tDattorroReverb_free>:
{
   2ecf0:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2ecf2:	6804      	ldr	r4, [r0, #0]
    tTapeDelay_free(&r->in_delay);
   2ecf4:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2ecf8:	f7f9 fbf0 	bl	284dc <tTapeDelay_free>
    tOnePole_free(&r->in_filter);
   2ecfc:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2ed00:	f7fc fc66 	bl	2b5d0 <tOnePole_free>
        tAllpass_free(&r->in_allpass[i]);
   2ed04:	f104 0040 	add.w	r0, r4, #64	; 0x40
   2ed08:	f7fc fbfe 	bl	2b508 <tAllpass_free>
   2ed0c:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2ed10:	f7fc fbfa 	bl	2b508 <tAllpass_free>
   2ed14:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2ed18:	f7fc fbf6 	bl	2b508 <tAllpass_free>
   2ed1c:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2ed20:	f7fc fbf2 	bl	2b508 <tAllpass_free>
    tAllpass_free(&r->f1_allpass);
   2ed24:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2ed28:	f7fc fbee 	bl	2b508 <tAllpass_free>
    tTapeDelay_free(&r->f1_delay_1);
   2ed2c:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2ed30:	f7f9 fbd4 	bl	284dc <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_2);
   2ed34:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2ed38:	f7f9 fbd0 	bl	284dc <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_3);
   2ed3c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2ed40:	f7f9 fbcc 	bl	284dc <tTapeDelay_free>
    tOnePole_free(&r->f1_filter);
   2ed44:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2ed48:	f7fc fc42 	bl	2b5d0 <tOnePole_free>
    tHighpass_free(&r->f1_hp);
   2ed4c:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2ed50:	f7fc fe70 	bl	2ba34 <tHighpass_free>
    tCycle_free(&r->f1_lfo);
   2ed54:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2ed58:	f7fe ff0c 	bl	2db74 <tCycle_free>
    tAllpass_free(&r->f2_allpass);
   2ed5c:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2ed60:	f7fc fbd2 	bl	2b508 <tAllpass_free>
    tTapeDelay_free(&r->f2_delay_1);
   2ed64:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2ed68:	f7f9 fbb8 	bl	284dc <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_2);
   2ed6c:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2ed70:	f7f9 fbb4 	bl	284dc <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_3);
   2ed74:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2ed78:	f7f9 fbb0 	bl	284dc <tTapeDelay_free>
    tOnePole_free(&r->f2_filter);
   2ed7c:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2ed80:	f7fc fc26 	bl	2b5d0 <tOnePole_free>
    tHighpass_free(&r->f2_hp);
   2ed84:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2ed88:	f7fc fe54 	bl	2ba34 <tHighpass_free>
    tCycle_free(&r->f2_lfo);
   2ed8c:	f104 0084 	add.w	r0, r4, #132	; 0x84
   2ed90:	f7fe fef0 	bl	2db74 <tCycle_free>
    mpool_free((char*)r, r->mempool);
   2ed94:	6821      	ldr	r1, [r4, #0]
   2ed96:	4620      	mov	r0, r4
}
   2ed98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)r, r->mempool);
   2ed9c:	f7fe bae2 	b.w	2d364 <mpool_free>

0002eda0 <tDattorroReverb_tickStereo>:
{
   2eda0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2eda4:	ed2d 8b06 	vpush	{d8-d10}
    _tDattorroReverb* r = *rev;
   2eda8:	6804      	ldr	r4, [r0, #0]
    	input = 0.0f;
   2edaa:	2300      	movs	r3, #0
{
   2edac:	460e      	mov	r6, r1
    if (r->frozen)
   2edae:	69a2      	ldr	r2, [r4, #24]
    	input = 0.0f;
   2edb0:	ee09 3a90 	vmov	s19, r3
	in_sample = tTapeDelay_tick(&r->in_delay, input);
   2edb4:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2edb8:	f104 0540 	add.w	r5, r4, #64	; 0x40
    	input = 0.0f;
   2edbc:	429a      	cmp	r2, r3
   2edbe:	f104 0750 	add.w	r7, r4, #80	; 0x50
   2edc2:	fe40 9a29 	vseleq.f32	s19, s0, s19
	in_sample = tTapeDelay_tick(&r->in_delay, input);
   2edc6:	eeb0 0a69 	vmov.f32	s0, s19
   2edca:	f7f9 fb93 	bl	284f4 <tTapeDelay_tick>
	in_sample = tOnePole_tick(&r->in_filter, in_sample);
   2edce:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2edd2:	f7fc fc1d 	bl	2b610 <tOnePole_tick>
   2edd6:	eeb0 8a40 	vmov.f32	s16, s0
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
   2edda:	4628      	mov	r0, r5
   2eddc:	3504      	adds	r5, #4
   2edde:	eeb0 0a48 	vmov.f32	s0, s16
   2ede2:	f7fc fba5 	bl	2b530 <tAllpass_tick>
	for (int i = 0; i < 4; i++)
   2ede6:	42bd      	cmp	r5, r7
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
   2ede8:	eeb0 8a40 	vmov.f32	s16, s0
	for (int i = 0; i < 4; i++)
   2edec:	d1f5      	bne.n	2edda <tDattorroReverb_tickStereo+0x3a>
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
   2edee:	edd4 8a0d 	vldr	s17, [r4, #52]	; 0x34
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2edf2:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2edf6:	ed94 9a09 	vldr	s18, [r4, #36]	; 0x24
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
   2edfa:	f104 0854 	add.w	r8, r4, #84	; 0x54
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
   2edfe:	ee70 8a28 	vadd.f32	s17, s0, s17
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2ee02:	f7fe fec9 	bl	2db98 <tCycle_tick>
   2ee06:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2ee0a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2ee0e:	f241 437b 	movw	r3, #5243	; 0x147b
   2ee12:	4628      	mov	r0, r5
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2ee14:	f104 075c 	add.w	r7, r4, #92	; 0x5c
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2ee18:	ee67 7a87 	vmul.f32	s15, s15, s14
   2ee1c:	f2c4 13f4 	movt	r3, #16884	; 0x41f4
   2ee20:	ee07 3a10 	vmov	s14, r3
   2ee24:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ee28:	eea9 0a07 	vfma.f32	s0, s18, s14
   2ee2c:	f7fc fb78 	bl	2b520 <tAllpass_setDelay>
		f1_sample = tAllpass_tick(&r->f1_allpass, f1_sample);
   2ee30:	eeb0 0a68 	vmov.f32	s0, s17
   2ee34:	4628      	mov	r0, r5
   2ee36:	f7fc fb7b 	bl	2b530 <tAllpass_tick>
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
   2ee3a:	4640      	mov	r0, r8
   2ee3c:	f7f9 fb5a 	bl	284f4 <tTapeDelay_tick>
		f1_sample = tOnePole_tick(&r->f1_filter, f1_sample);
   2ee40:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2ee44:	f7fc fbe4 	bl	2b610 <tOnePole_tick>
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
   2ee48:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2ee4c:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2ee50:	4638      	mov	r0, r7
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
   2ee52:	eea7 0a27 	vfma.f32	s0, s14, s15
   2ee56:	eef0 8a40 	vmov.f32	s17, s0
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2ee5a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ee5e:	f7f9 fb49 	bl	284f4 <tTapeDelay_tick>
   2ee62:	eef0 7a40 	vmov.f32	s15, s0
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
   2ee66:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2ee6a:	ee38 0a80 	vadd.f32	s0, s17, s0
		r->f1_delay_2_last = f1_delay_2_sample;
   2ee6e:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
   2ee72:	f7fc fdf3 	bl	2ba5c <tHighpass_tick>
		if (r->frozen)
   2ee76:	69a3      	ldr	r3, [r4, #24]
		f1_sample *= r->feedback_gain;
   2ee78:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
   2ee7c:	2b00      	cmp	r3, #0
   2ee7e:	f040 8150 	bne.w	2f122 <tDattorroReverb_tickStereo+0x382>
		f1_sample *= r->feedback_gain;
   2ee82:	ee27 0a80 	vmul.f32	s0, s15, s0
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2ee86:	f104 0560 	add.w	r5, r4, #96	; 0x60
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2ee8a:	f104 0b6c 	add.w	fp, r4, #108	; 0x6c
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
   2ee8e:	f104 0970 	add.w	r9, r4, #112	; 0x70
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2ee92:	f104 0a78 	add.w	sl, r4, #120	; 0x78
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2ee96:	4628      	mov	r0, r5
   2ee98:	f7f9 fb2c 	bl	284f4 <tTapeDelay_tick>
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2ee9c:	f104 0084 	add.w	r0, r4, #132	; 0x84
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2eea0:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
		f2_sample = in_sample + r->f1_last;
   2eea4:	ee30 8a08 	vadd.f32	s16, s0, s16
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2eea8:	edd4 8a09 	vldr	s17, [r4, #36]	; 0x24
   2eeac:	f7fe fe74 	bl	2db98 <tCycle_tick>
   2eeb0:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2eeb4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2eeb8:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
   2eebc:	4658      	mov	r0, fp
   2eebe:	ee67 7a87 	vmul.f32	s15, s15, s14
   2eec2:	f2c4 13b4 	movt	r3, #16820	; 0x41b4
   2eec6:	ee07 3a10 	vmov	s14, r3
   2eeca:	ee27 0a80 	vmul.f32	s0, s15, s0
   2eece:	eea8 0a87 	vfma.f32	s0, s17, s14
   2eed2:	f7fc fb25 	bl	2b520 <tAllpass_setDelay>
		f2_sample = tAllpass_tick(&r->f2_allpass, f2_sample);
   2eed6:	eeb0 0a48 	vmov.f32	s0, s16
   2eeda:	4658      	mov	r0, fp
   2eedc:	f7fc fb28 	bl	2b530 <tAllpass_tick>
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
   2eee0:	4648      	mov	r0, r9
   2eee2:	f7f9 fb07 	bl	284f4 <tTapeDelay_tick>
		f2_sample = tOnePole_tick(&r->f2_filter, f2_sample);
   2eee6:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2eeea:	f7fc fb91 	bl	2b610 <tOnePole_tick>
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
   2eeee:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2eef2:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2eef6:	4650      	mov	r0, sl
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
   2eef8:	eea7 0a27 	vfma.f32	s0, s14, s15
   2eefc:	eeb0 8a40 	vmov.f32	s16, s0
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2ef00:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ef04:	f7f9 faf6 	bl	284f4 <tTapeDelay_tick>
   2ef08:	eef0 7a40 	vmov.f32	s15, s0
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
   2ef0c:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2ef10:	ee38 0a00 	vadd.f32	s0, s16, s0
		r->f2_delay_2_last = f2_delay_2_sample;
   2ef14:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
   2ef18:	f7fc fda0 	bl	2ba5c <tHighpass_tick>
		if (r->frozen)
   2ef1c:	69a3      	ldr	r3, [r4, #24]
		f2_sample *= r->feedback_gain;
   2ef1e:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
   2ef22:	2b00      	cmp	r3, #0
   2ef24:	f000 8101 	beq.w	2f12a <tDattorroReverb_tickStereo+0x38a>
			f2_sample = 0.0f;
   2ef28:	2300      	movs	r3, #0
   2ef2a:	ee00 3a10 	vmov	s0, r3
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2ef2e:	f104 0b7c 	add.w	fp, r4, #124	; 0x7c
   2ef32:	4658      	mov	r0, fp
   2ef34:	f7f9 fade 	bl	284f4 <tTapeDelay_tick>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2ef38:	f246 6366 	movw	r3, #26214	; 0x6666
   2ef3c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2ef40:	4640      	mov	r0, r8
   2ef42:	f2c4 130e 	movt	r3, #16654	; 0x410e
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2ef46:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2ef4a:	ee00 3a10 	vmov	s0, r3
   2ef4e:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ef52:	f7f9 fb55 	bl	28600 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
   2ef56:	f649 139a 	movw	r3, #39322	; 0x999a
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2ef5a:	eeb0 8a40 	vmov.f32	s16, s0
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
   2ef5e:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ef62:	f2c4 23c7 	movt	r3, #17095	; 0x42c7
   2ef66:	4640      	mov	r0, r8
   2ef68:	ee07 3a90 	vmov	s15, r3
   2ef6c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ef70:	f7f9 fb46 	bl	28600 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
   2ef74:	f246 6366 	movw	r3, #26214	; 0x6666
   2ef78:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2ef7c:	ee38 8a00 	vadd.f32	s16, s16, s0
   2ef80:	f2c4 2380 	movt	r3, #17024	; 0x4280
   2ef84:	4638      	mov	r0, r7
   2ef86:	ee00 3a10 	vmov	s0, r3
   2ef8a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ef8e:	f7f9 fb37 	bl	28600 <tTapeDelay_tapOut>
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2ef92:	2300      	movs	r3, #0
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
   2ef94:	eef0 8a40 	vmov.f32	s17, s0
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2ef98:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2ef9c:	f2c4 2386 	movt	r3, #17030	; 0x4286
   2efa0:	4628      	mov	r0, r5
   2efa2:	ee07 3a90 	vmov	s15, r3
   2efa6:	ee20 0a27 	vmul.f32	s0, s0, s15
   2efaa:	f7f9 fb29 	bl	28600 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2efae:	f649 139a 	movw	r3, #39322	; 0x999a
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2efb2:	ee30 9a08 	vadd.f32	s18, s0, s16
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2efb6:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2efba:	f2c4 2385 	movt	r3, #17029	; 0x4285
   2efbe:	4648      	mov	r0, r9
   2efc0:	ee07 3a90 	vmov	s15, r3
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2efc4:	ee39 9a68 	vsub.f32	s18, s18, s17
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2efc8:	ee20 0a27 	vmul.f32	s0, s0, s15
   2efcc:	f7f9 fb18 	bl	28600 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2efd0:	f649 139a 	movw	r3, #39322	; 0x999a
   2efd4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2efd8:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2efdc:	f2c4 03c9 	movt	r3, #16585	; 0x40c9
   2efe0:	4650      	mov	r0, sl
   2efe2:	ee08 3a10 	vmov	s16, r3
   2efe6:	ee27 0a88 	vmul.f32	s0, s15, s16
   2efea:	f7f9 fb09 	bl	28600 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2efee:	f243 3333 	movw	r3, #13107	; 0x3333
   2eff2:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2eff6:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2effa:	f2c4 230f 	movt	r3, #16911	; 0x420f
   2effe:	4658      	mov	r0, fp
   2f000:	ee00 3a10 	vmov	s0, r3
   2f004:	ee27 0a80 	vmul.f32	s0, s15, s0
   2f008:	f7f9 fafa 	bl	28600 <tTapeDelay_tapOut>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2f00c:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   2f010:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2f014:	ee39 9a40 	vsub.f32	s18, s18, s0
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2f018:	f2c4 133c 	movt	r3, #16700	; 0x413c
   2f01c:	4648      	mov	r0, r9
   2f01e:	ee00 3a10 	vmov	s0, r3
   2f022:	ee27 0a80 	vmul.f32	s0, s15, s0
   2f026:	f7f9 faeb 	bl	28600 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
   2f02a:	f246 6366 	movw	r3, #26214	; 0x6666
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2f02e:	eef0 8a40 	vmov.f32	s17, s0
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
   2f032:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f036:	f2c4 23f3 	movt	r3, #17139	; 0x42f3
   2f03a:	4648      	mov	r0, r9
   2f03c:	ee07 3a90 	vmov	s15, r3
   2f040:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f044:	f7f9 fadc 	bl	28600 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2f048:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2f04c:	ee78 8a80 	vadd.f32	s17, s17, s0
   2f050:	4650      	mov	r0, sl
   2f052:	ee27 0a88 	vmul.f32	s0, s15, s16
   2f056:	f7f9 fad3 	bl	28600 <tTapeDelay_tapOut>
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2f05a:	f246 6366 	movw	r3, #26214	; 0x6666
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2f05e:	eeb0 aa40 	vmov.f32	s20, s0
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2f062:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f066:	f2c4 23b3 	movt	r3, #17075	; 0x42b3
   2f06a:	4658      	mov	r0, fp
   2f06c:	ee07 3a90 	vmov	s15, r3
   2f070:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f074:	f7f9 fac4 	bl	28600 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2f078:	f649 139a 	movw	r3, #39322	; 0x999a
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2f07c:	ee30 8a28 	vadd.f32	s16, s0, s17
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2f080:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f084:	f2c4 238d 	movt	r3, #17037	; 0x428d
   2f088:	4640      	mov	r0, r8
   2f08a:	ee07 3a90 	vmov	s15, r3
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2f08e:	ee38 8a4a 	vsub.f32	s16, s16, s20
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2f092:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f096:	f7f9 fab3 	bl	28600 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2f09a:	f243 3333 	movw	r3, #13107	; 0x3333
   2f09e:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2f0a2:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2f0a6:	f2c4 1333 	movt	r3, #16691	; 0x4133
   2f0aa:	4638      	mov	r0, r7
   2f0ac:	ee00 3a10 	vmov	s0, r3
   2f0b0:	ee27 0a80 	vmul.f32	s0, s15, s0
   2f0b4:	f7f9 faa4 	bl	28600 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2f0b8:	f243 3333 	movw	r3, #13107	; 0x3333
   2f0bc:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2f0c0:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2f0c4:	f2c4 0383 	movt	r3, #16515	; 0x4083
   2f0c8:	4628      	mov	r0, r5
   2f0ca:	ee00 3a10 	vmov	s0, r3
   2f0ce:	ee27 0a80 	vmul.f32	s0, s15, s0
   2f0d2:	f7f9 fa95 	bl	28600 <tTapeDelay_tapOut>
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
   2f0d6:	f645 4329 	movw	r3, #23593	; 0x5c29
   2f0da:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2f0de:	edd4 7a05 	vldr	s15, [r4, #20]
   2f0e2:	f6c3 630f 	movt	r3, #15887	; 0x3e0f
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2f0e6:	ee38 0a40 	vsub.f32	s0, s16, s0
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
   2f0ea:	ee07 3a10 	vmov	s14, r3
   2f0ee:	ee36 6ae7 	vsub.f32	s12, s13, s15
   2f0f2:	ee67 7a87 	vmul.f32	s15, s15, s14
   2f0f6:	ee27 9a89 	vmul.f32	s18, s15, s18
   2f0fa:	eea6 9a29 	vfma.f32	s18, s12, s19
   2f0fe:	ed86 9a00 	vstr	s18, [r6]
    output[1] = input * (1.0f - r->mix) + f2_sample * r->mix;
   2f102:	edd4 7a05 	vldr	s15, [r4, #20]
   2f106:	ee27 7a87 	vmul.f32	s14, s15, s14
   2f10a:	ee76 6ae7 	vsub.f32	s13, s13, s15
   2f10e:	ee20 0a07 	vmul.f32	s0, s0, s14
   2f112:	eea6 0aa9 	vfma.f32	s0, s13, s19
   2f116:	ed86 0a01 	vstr	s0, [r6, #4]
}
   2f11a:	ecbd 8b06 	vpop	{d8-d10}
   2f11e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			f1_sample = 0.0f;
   2f122:	2300      	movs	r3, #0
   2f124:	ee00 3a10 	vmov	s0, r3
   2f128:	e6ad      	b.n	2ee86 <tDattorroReverb_tickStereo+0xe6>
		f2_sample *= r->feedback_gain;
   2f12a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2f12e:	e6fe      	b.n	2ef2e <tDattorroReverb_tickStereo+0x18e>

0002f130 <tDattorroReverb_setMix>:
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2f130:	2300      	movs	r3, #0
   2f132:	eef0 0a40 	vmov.f32	s1, s0
   2f136:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   2f13a:	ee00 3a10 	vmov	s0, r3
{
   2f13e:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2f140:	6804      	ldr	r4, [r0, #0]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2f142:	f7fd fe4d 	bl	2cde0 <LEAF_clip>
   2f146:	ed84 0a05 	vstr	s0, [r4, #20]
}
   2f14a:	bd10      	pop	{r4, pc}

0002f14c <tDattorroReverb_setFreeze>:
{
   2f14c:	b570      	push	{r4, r5, r6, lr}
    _tDattorroReverb* r = *rev;
   2f14e:	6804      	ldr	r4, [r0, #0]
    r->frozen = freeze;
   2f150:	61a1      	str	r1, [r4, #24]
   2f152:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2f156:	f104 0650 	add.w	r6, r4, #80	; 0x50
   2f15a:	f104 0568 	add.w	r5, r4, #104	; 0x68
   2f15e:	3484      	adds	r4, #132	; 0x84
    if (freeze)
   2f160:	bb21      	cbnz	r1, 2f1ac <tDattorroReverb_setFreeze+0x60>
    	tAllpass_setGain(&r->f2_allpass, 0.7f);
   2f162:	f243 3333 	movw	r3, #13107	; 0x3333
   2f166:	f6c3 7333 	movt	r3, #16179	; 0x3f33
   2f16a:	ee00 3a10 	vmov	s0, r3
   2f16e:	f7fc f9db 	bl	2b528 <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 0.7f);
   2f172:	f243 3333 	movw	r3, #13107	; 0x3333
   2f176:	4630      	mov	r0, r6
   2f178:	f6c3 7333 	movt	r3, #16179	; 0x3f33
   2f17c:	ee00 3a10 	vmov	s0, r3
   2f180:	f7fc f9d2 	bl	2b528 <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.1f);
   2f184:	f64c 43cd 	movw	r3, #52429	; 0xcccd
   2f188:	4628      	mov	r0, r5
   2f18a:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
   2f18e:	ee00 3a10 	vmov	s0, r3
   2f192:	f7fe fcf3 	bl	2db7c <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
   2f196:	f645 4329 	movw	r3, #23593	; 0x5c29
   2f19a:	4620      	mov	r0, r4
   2f19c:	f6c3 538f 	movt	r3, #15759	; 0x3d8f
}
   2f1a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
   2f1a4:	ee00 3a10 	vmov	s0, r3
   2f1a8:	f7fe bce8 	b.w	2db7c <tCycle_setFreq>
    	tAllpass_setGain(&r->f2_allpass, 1.0f);
   2f1ac:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2f1b0:	f7fc f9ba 	bl	2b528 <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 1.0f);
   2f1b4:	4630      	mov	r0, r6
   2f1b6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2f1ba:	f7fc f9b5 	bl	2b528 <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.0f);
   2f1be:	2300      	movs	r3, #0
   2f1c0:	4628      	mov	r0, r5
   2f1c2:	ee00 3a10 	vmov	s0, r3
   2f1c6:	f7fe fcd9 	bl	2db7c <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
   2f1ca:	2300      	movs	r3, #0
   2f1cc:	4620      	mov	r0, r4
   2f1ce:	ee00 3a10 	vmov	s0, r3
}
   2f1d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
   2f1d6:	f7fe bcd1 	b.w	2db7c <tCycle_setFreq>
   2f1da:	bf00      	nop

0002f1dc <tDattorroReverb_setHP>:
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2f1dc:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   2f1e0:	eef0 0a40 	vmov.f32	s1, s0
   2f1e4:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2f1e8:	f2c4 639c 	movt	r3, #18076	; 0x469c
{
   2f1ec:	b510      	push	{r4, lr}
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2f1ee:	ee01 3a10 	vmov	s2, r3
{
   2f1f2:	ed2d 8b02 	vpush	{d8}
    _tDattorroReverb* r = *rev;
   2f1f6:	6804      	ldr	r4, [r0, #0]
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2f1f8:	f7fd fdf2 	bl	2cde0 <LEAF_clip>
   2f1fc:	eeb0 8a40 	vmov.f32	s16, s0
    tHighpass_setFreq(&r->f1_hp, newFreq);
   2f200:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2f204:	f7fc fc1a 	bl	2ba3c <tHighpass_setFreq>
    tHighpass_setFreq(&r->f2_hp, newFreq);
   2f208:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2f20c:	eeb0 0a48 	vmov.f32	s0, s16
}
   2f210:	ecbd 8b02 	vpop	{d8}
   2f214:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tHighpass_setFreq(&r->f2_hp, newFreq);
   2f218:	f7fc bc10 	b.w	2ba3c <tHighpass_setFreq>

0002f21c <tDattorroReverb_setSize>:
{
   2f21c:	b510      	push	{r4, lr}
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2f21e:	f24d 730a 	movw	r3, #55050	; 0xd70a
    _tDattorroReverb* r = *rev;
   2f222:	6804      	ldr	r4, [r0, #0]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2f224:	f6c3 4323 	movt	r3, #15395	; 0x3c23
   2f228:	ed94 1a08 	vldr	s2, [r4, #32]
   2f22c:	ee61 0a00 	vmul.f32	s1, s2, s0
   2f230:	ee00 3a10 	vmov	s0, r3
   2f234:	f7fd fdd4 	bl	2cde0 <LEAF_clip>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2f238:	f64f 0108 	movw	r1, #63496	; 0xf808
   2f23c:	f241 226f 	movw	r2, #4719	; 0x126f
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2f240:	f24b 03a4 	movw	r3, #45220	; 0xb0a4
    r->t = r->size * leaf.sampleRate * 0.001f;
   2f244:	f2c0 210f 	movt	r1, #527	; 0x20f
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2f248:	ed84 0a07 	vstr	s0, [r4, #28]
    r->t = r->size * leaf.sampleRate * 0.001f;
   2f24c:	f6c3 2283 	movt	r2, #14979	; 0x3a83
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2f250:	f2c4 330d 	movt	r3, #17165	; 0x430d
    r->t = r->size * leaf.sampleRate * 0.001f;
   2f254:	edd1 7a00 	vldr	s15, [r1]
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2f258:	f104 0054 	add.w	r0, r4, #84	; 0x54
    r->t = r->size * leaf.sampleRate * 0.001f;
   2f25c:	ee06 2a90 	vmov	s13, r2
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2f260:	ee07 3a10 	vmov	s14, r3
    r->t = r->size * leaf.sampleRate * 0.001f;
   2f264:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2f268:	ee27 0a80 	vmul.f32	s0, s15, s0
   2f26c:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2f270:	ee20 0a07 	vmul.f32	s0, s0, s14
   2f274:	f7f9 f9b4 	bl	285e0 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_2, SAMP(89.24f));
   2f278:	f647 23e1 	movw	r3, #31457	; 0x7ae1
   2f27c:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f280:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2f284:	f2c4 23b2 	movt	r3, #17074	; 0x42b2
   2f288:	ee07 3a90 	vmov	s15, r3
   2f28c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f290:	f7f9 f9a6 	bl	285e0 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_3, SAMP(125.f));
   2f294:	2300      	movs	r3, #0
   2f296:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f29a:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2f29e:	f2c4 23fa 	movt	r3, #17146	; 0x42fa
   2f2a2:	ee07 3a90 	vmov	s15, r3
   2f2a6:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f2aa:	f7f9 f999 	bl	285e0 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_1, SAMP(149.62f));
   2f2ae:	f649 63b8 	movw	r3, #40632	; 0x9eb8
   2f2b2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f2b6:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2f2ba:	f2c4 3315 	movt	r3, #17173	; 0x4315
   2f2be:	ee07 3a90 	vmov	s15, r3
   2f2c2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f2c6:	f7f9 f98b 	bl	285e0 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_2, SAMP(60.48f));
   2f2ca:	f64e 3385 	movw	r3, #60293	; 0xeb85
   2f2ce:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f2d2:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2f2d6:	f2c4 2371 	movt	r3, #17009	; 0x4271
   2f2da:	ee07 3a90 	vmov	s15, r3
   2f2de:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f2e2:	f7f9 f97d 	bl	285e0 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
   2f2e6:	f648 735c 	movw	r3, #36700	; 0x8f5c
   2f2ea:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2f2ee:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2f2f2:	f2c4 23d4 	movt	r3, #17108	; 0x42d4
   2f2f6:	ee07 3a90 	vmov	s15, r3
}
   2f2fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
   2f2fe:	ee20 0a27 	vmul.f32	s0, s0, s15
   2f302:	f7f9 b96d 	b.w	285e0 <tTapeDelay_setDelay>
   2f306:	bf00      	nop

0002f308 <tDattorroReverb_setInputFilter>:
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2f308:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   2f30c:	2200      	movs	r2, #0
   2f30e:	eef0 0a40 	vmov.f32	s1, s0
   2f312:	f2c4 639c 	movt	r3, #18076	; 0x469c
   2f316:	ee00 2a10 	vmov	s0, r2
{
   2f31a:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2f31c:	6804      	ldr	r4, [r0, #0]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2f31e:	ee01 3a10 	vmov	s2, r3
   2f322:	f7fd fd5d 	bl	2cde0 <LEAF_clip>
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2f326:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2f32a:	ed84 0a02 	vstr	s0, [r4, #8]
}
   2f32e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2f332:	f7fc b951 	b.w	2b5d8 <tOnePole_setFreq>
   2f336:	bf00      	nop

0002f338 <tDattorroReverb_setFeedbackFilter>:
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2f338:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   2f33c:	2200      	movs	r2, #0
   2f33e:	eef0 0a40 	vmov.f32	s1, s0
   2f342:	f2c4 639c 	movt	r3, #18076	; 0x469c
   2f346:	ee00 2a10 	vmov	s0, r2
{
   2f34a:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2f34c:	6804      	ldr	r4, [r0, #0]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2f34e:	ee01 3a10 	vmov	s2, r3
   2f352:	f7fd fd45 	bl	2cde0 <LEAF_clip>
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2f356:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2f35a:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2f35e:	f7fc f93b 	bl	2b5d8 <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2f362:	ed94 0a03 	vldr	s0, [r4, #12]
   2f366:	f104 0074 	add.w	r0, r4, #116	; 0x74
}
   2f36a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2f36e:	f7fc b933 	b.w	2b5d8 <tOnePole_setFreq>
   2f372:	bf00      	nop

0002f374 <tDattorroReverb_setFeedbackGain>:
    _tDattorroReverb* r = *rev;
   2f374:	6803      	ldr	r3, [r0, #0]
    r->feedback_gain = gain;
   2f376:	ed83 0a04 	vstr	s0, [r3, #16]
}
   2f37a:	4770      	bx	lr

0002f37c <tBuffer_initToPool>:
{
    tBuffer_initToPool(sb, length, &leaf.mempool);
}

void  tBuffer_initToPool (tBuffer* const sb, uint32_t length, tMempool* const mp)
{
   2f37c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2f37e:	6815      	ldr	r5, [r2, #0]
{
   2f380:	460e      	mov	r6, r1
   2f382:	4607      	mov	r7, r0
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
   2f384:	201c      	movs	r0, #28
   2f386:	4629      	mov	r1, r5
   2f388:	f7fd ff42 	bl	2d210 <mpool_alloc>
   2f38c:	4604      	mov	r4, r0
    s->mempool = m;
    
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2f38e:	4629      	mov	r1, r5
   2f390:	00b0      	lsls	r0, r6, #2
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
   2f392:	603c      	str	r4, [r7, #0]
    s->mempool = m;
   2f394:	6025      	str	r5, [r4, #0]
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2f396:	f7fd ff3b 	bl	2d210 <mpool_alloc>
    
    s->bufferLength = length;
    s->recordedLength = 0;
   2f39a:	2300      	movs	r3, #0
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2f39c:	6060      	str	r0, [r4, #4]
    s->active = 0;
   2f39e:	61a3      	str	r3, [r4, #24]
    s->idx = 0;
   2f3a0:	60a3      	str	r3, [r4, #8]
    s->mode = RecordOneShot;
   2f3a2:	7523      	strb	r3, [r4, #20]
    s->recordedLength = 0;
   2f3a4:	e9c4 6303 	strd	r6, r3, [r4, #12]
}
   2f3a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2f3aa:	bf00      	nop

0002f3ac <tBuffer_free>:

void  tBuffer_free (tBuffer* const sb)
{
   2f3ac:	b510      	push	{r4, lr}
    _tBuffer* s = *sb;
   2f3ae:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)s->buff, s->mempool);
   2f3b0:	e9d4 1000 	ldrd	r1, r0, [r4]
   2f3b4:	f7fd ffd6 	bl	2d364 <mpool_free>
    mpool_free((char*)s, s->mempool);
   2f3b8:	6821      	ldr	r1, [r4, #0]
   2f3ba:	4620      	mov	r0, r4
}
   2f3bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)s, s->mempool);
   2f3c0:	f7fd bfd0 	b.w	2d364 <mpool_free>

0002f3c4 <tBuffer_tick>:

void tBuffer_tick (tBuffer* const sb, float sample)
{
    _tBuffer* s = *sb;
   2f3c4:	6803      	ldr	r3, [r0, #0]
    
    if (s->active == 1)
   2f3c6:	699a      	ldr	r2, [r3, #24]
   2f3c8:	2a01      	cmp	r2, #1
   2f3ca:	d000      	beq.n	2f3ce <tBuffer_tick+0xa>
                s->idx = 0;
            }
        }
        s->recordedLength = s->idx;
    }
}
   2f3cc:	4770      	bx	lr
        s->buff[s->idx] = sample;
   2f3ce:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   2f3d2:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2f3d6:	ed82 0a00 	vstr	s0, [r2]
        if (s->idx >= s->bufferLength)
   2f3da:	e9d3 2102 	ldrd	r2, r1, [r3, #8]
        s->idx += 1;
   2f3de:	3201      	adds	r2, #1
        if (s->idx >= s->bufferLength)
   2f3e0:	428a      	cmp	r2, r1
        s->idx += 1;
   2f3e2:	609a      	str	r2, [r3, #8]
        if (s->idx >= s->bufferLength)
   2f3e4:	d304      	bcc.n	2f3f0 <tBuffer_tick+0x2c>
            if (s->mode == RecordOneShot)
   2f3e6:	7d19      	ldrb	r1, [r3, #20]
   2f3e8:	b921      	cbnz	r1, 2f3f4 <tBuffer_tick+0x30>
    s->idx = 0;
}

void  tBuffer_stop(tBuffer* const sb)
{
    _tBuffer* s = *sb;
   2f3ea:	6802      	ldr	r2, [r0, #0]
    s->active = 0;
   2f3ec:	6191      	str	r1, [r2, #24]
   2f3ee:	689a      	ldr	r2, [r3, #8]
        s->recordedLength = s->idx;
   2f3f0:	611a      	str	r2, [r3, #16]
}
   2f3f2:	4770      	bx	lr
            else if (s->mode == RecordLoop)
   2f3f4:	2901      	cmp	r1, #1
   2f3f6:	d1fb      	bne.n	2f3f0 <tBuffer_tick+0x2c>
                s->idx = 0;
   2f3f8:	2100      	movs	r1, #0
   2f3fa:	460a      	mov	r2, r1
   2f3fc:	6099      	str	r1, [r3, #8]
   2f3fe:	e7f7      	b.n	2f3f0 <tBuffer_tick+0x2c>

0002f400 <tBuffer_get>:
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2f400:	2900      	cmp	r1, #0
   2f402:	db09      	blt.n	2f418 <tBuffer_get+0x18>
    _tBuffer* s = *sb;
   2f404:	6803      	ldr	r3, [r0, #0]
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2f406:	68da      	ldr	r2, [r3, #12]
   2f408:	428a      	cmp	r2, r1
   2f40a:	d905      	bls.n	2f418 <tBuffer_get+0x18>
    return s->buff[idx];
   2f40c:	685b      	ldr	r3, [r3, #4]
   2f40e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2f412:	ed91 0a00 	vldr	s0, [r1]
   2f416:	4770      	bx	lr
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2f418:	2300      	movs	r3, #0
   2f41a:	ee00 3a10 	vmov	s0, r3
}
   2f41e:	4770      	bx	lr

0002f420 <tBuffer_record>:
    _tBuffer* s = *sb;
   2f420:	6803      	ldr	r3, [r0, #0]
    s->active = 1;
   2f422:	2101      	movs	r1, #1
    s->idx = 0;
   2f424:	2200      	movs	r2, #0
    s->active = 1;
   2f426:	6199      	str	r1, [r3, #24]
    s->idx = 0;
   2f428:	609a      	str	r2, [r3, #8]
}
   2f42a:	4770      	bx	lr

0002f42c <tBuffer_stop>:
    _tBuffer* s = *sb;
   2f42c:	6803      	ldr	r3, [r0, #0]
    s->active = 0;
   2f42e:	2200      	movs	r2, #0
   2f430:	619a      	str	r2, [r3, #24]
}
   2f432:	4770      	bx	lr

0002f434 <tBuffer_getRecordPosition>:

int   tBuffer_getRecordPosition(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->idx;
   2f434:	6803      	ldr	r3, [r0, #0]
}
   2f436:	6898      	ldr	r0, [r3, #8]
   2f438:	4770      	bx	lr
   2f43a:	bf00      	nop

0002f43c <tBuffer_setRecordPosition>:

void   tBuffer_setRecordPosition(tBuffer* const sb, int pos)
{
    _tBuffer* s = *sb;
   2f43c:	6803      	ldr	r3, [r0, #0]
    s->idx = pos;
   2f43e:	6099      	str	r1, [r3, #8]
}
   2f440:	4770      	bx	lr
   2f442:	bf00      	nop

0002f444 <tBuffer_setRecordMode>:

void  tBuffer_setRecordMode (tBuffer* const sb, RecordMode mode)
{
    _tBuffer* s = *sb;
   2f444:	6803      	ldr	r3, [r0, #0]
    s->mode = mode;
   2f446:	7519      	strb	r1, [r3, #20]
}
   2f448:	4770      	bx	lr
   2f44a:	bf00      	nop

0002f44c <tBuffer_getRecordedLength>:
}

uint32_t tBuffer_getRecordedLength(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->recordedLength;
   2f44c:	6803      	ldr	r3, [r0, #0]
}
   2f44e:	6918      	ldr	r0, [r3, #16]
   2f450:	4770      	bx	lr
   2f452:	bf00      	nop

0002f454 <tBuffer_setRecordedLength>:

void tBuffer_setRecordedLength(tBuffer* const sb, int length)
{
    _tBuffer* s = *sb;
   2f454:	6803      	ldr	r3, [r0, #0]
    s->recordedLength = length;
   2f456:	6119      	str	r1, [r3, #16]
}
   2f458:	4770      	bx	lr
   2f45a:	bf00      	nop

0002f45c <tBuffer_isActive>:

int tBuffer_isActive(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->active;
   2f45c:	6803      	ldr	r3, [r0, #0]
}
   2f45e:	6998      	ldr	r0, [r3, #24]
   2f460:	4770      	bx	lr
   2f462:	bf00      	nop

0002f464 <tSampler_init>:
static void handleStartEndChange(tSampler* const sp);

static void attemptStartEndChange(tSampler* const sp);

void tSampler_init(tSampler* const sp, tBuffer* const b)
{
   2f464:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tSampler_initToPool(sp, b, &leaf.mempool);
}

void tSampler_initToPool(tSampler* const sp, tBuffer* const b, tMempool* const mp)
{
    _tMempool* m = *mp;
   2f468:	f64f 0608 	movw	r6, #63496	; 0xf808
{
   2f46c:	4681      	mov	r9, r0
   2f46e:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2f470:	2054      	movs	r0, #84	; 0x54
    _tMempool* m = *mp;
   2f472:	f2c0 260f 	movt	r6, #527	; 0x20f
    
    _tBuffer* s = *b;
    
    p->samp = s;
    
    p->active = 0;
   2f476:	2500      	movs	r5, #0
{
   2f478:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2f47c:	f856 7f18 	ldr.w	r7, [r6, #24]!
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2f480:	4639      	mov	r1, r7
   2f482:	f7fd fec5 	bl	2d210 <mpool_alloc>
    
    p->mode = PlayNormal;
    
    p->cfxlen = 500; // default 300 sample crossfade
    
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f486:	4632      	mov	r2, r6
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2f488:	4604      	mov	r4, r0
   2f48a:	f8c9 0000 	str.w	r0, [r9]
    p->inc = 1.f;
   2f48e:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    p->mempool = m;
   2f492:	6007      	str	r7, [r0, #0]
    p->iinc = 1.f;
   2f494:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tBuffer* s = *b;
   2f498:	f8d8 6000 	ldr.w	r6, [r8]
    p->iinc = 1.f;
   2f49c:	f240 1001 	movw	r0, #257	; 0x101
    p->inc = 1.f;
   2f4a0:	6121      	str	r1, [r4, #16]
    p->samp = s;
   2f4a2:	6066      	str	r6, [r4, #4]
    p->cfxlen = 500; // default 300 sample crossfade
   2f4a4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f4a8:	f104 0608 	add.w	r6, r4, #8
    p->iinc = 1.f;
   2f4ac:	61a3      	str	r3, [r4, #24]
    p->flip = 1;
   2f4ae:	2301      	movs	r3, #1
    p->iinc = 1.f;
   2f4b0:	83a0      	strh	r0, [r4, #28]
    p->cfxlen = 500; // default 300 sample crossfade
   2f4b2:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f4b4:	4630      	mov	r0, r6
   2f4b6:	4619      	mov	r1, r3
    p->flip = 1;
   2f4b8:	77a3      	strb	r3, [r4, #30]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f4ba:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->idx = 0.f;
   2f4be:	60e5      	str	r5, [r4, #12]
    p->active = 0;
   2f4c0:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
   2f4c2:	6225      	str	r5, [r4, #32]
    p->end = 0;
   2f4c4:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
   2f4c6:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
   2f4c8:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f4cc:	f7fb fe8c 	bl	2b1e8 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
   2f4d0:	ee00 5a10 	vmov	s0, r5
   2f4d4:	4630      	mov	r0, r6
   2f4d6:	f7fb fecf 	bl	2b278 <tRamp_setVal>
    
    p->targetstart = -1;
    p->targetend = -1;
    
    p->inCrossfade = 0;
    p->flipStart = -1;
   2f4da:	2300      	movs	r3, #0
    p->targetstart = -1;
   2f4dc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
   2f4e0:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
   2f4e4:	f6cb 7380 	movt	r3, #49024	; 0xbf80
    p->targetstart = -1;
   2f4e8:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
   2f4ea:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipStart = -1;
   2f4ec:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->flipIdx = -1;
   2f4ee:	6523      	str	r3, [r4, #80]	; 0x50
}
   2f4f0:	ecbd 8b02 	vpop	{d8}
   2f4f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0002f4f8 <tSampler_initToPool>:
{
   2f4f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2f4fc:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2f500:	6816      	ldr	r6, [r2, #0]
{
   2f502:	4681      	mov	r9, r0
   2f504:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2f506:	2054      	movs	r0, #84	; 0x54
   2f508:	4631      	mov	r1, r6
{
   2f50a:	4617      	mov	r7, r2
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2f50c:	f7fd fe80 	bl	2d210 <mpool_alloc>
    p->inc = 1.f;
   2f510:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2f514:	4604      	mov	r4, r0
   2f516:	f8c9 0000 	str.w	r0, [r9]
    p->iinc = 1.f;
   2f51a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    p->mempool = m;
   2f51e:	6006      	str	r6, [r0, #0]
    _tBuffer* s = *b;
   2f520:	f8d8 6000 	ldr.w	r6, [r8]
    p->active = 0;
   2f524:	2500      	movs	r5, #0
    p->iinc = 1.f;
   2f526:	f240 1001 	movw	r0, #257	; 0x101
    p->inc = 1.f;
   2f52a:	6121      	str	r1, [r4, #16]
    p->samp = s;
   2f52c:	6066      	str	r6, [r4, #4]
    p->cfxlen = 500; // default 300 sample crossfade
   2f52e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f532:	f104 0608 	add.w	r6, r4, #8
    p->iinc = 1.f;
   2f536:	61a3      	str	r3, [r4, #24]
    p->flip = 1;
   2f538:	2301      	movs	r3, #1
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f53a:	463a      	mov	r2, r7
    p->iinc = 1.f;
   2f53c:	83a0      	strh	r0, [r4, #28]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f53e:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->flip = 1;
   2f542:	77a3      	strb	r3, [r4, #30]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f544:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
   2f546:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f548:	4619      	mov	r1, r3
    p->idx = 0.f;
   2f54a:	60e5      	str	r5, [r4, #12]
    p->active = 0;
   2f54c:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
   2f54e:	6225      	str	r5, [r4, #32]
    p->end = 0;
   2f550:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
   2f552:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
   2f554:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2f558:	f7fb fe46 	bl	2b1e8 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
   2f55c:	ee00 5a10 	vmov	s0, r5
   2f560:	4630      	mov	r0, r6
   2f562:	f7fb fe89 	bl	2b278 <tRamp_setVal>
    p->flipStart = -1;
   2f566:	2300      	movs	r3, #0
    p->targetstart = -1;
   2f568:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
   2f56c:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
   2f570:	f6cb 7380 	movt	r3, #49024	; 0xbf80
    p->targetstart = -1;
   2f574:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
   2f576:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipStart = -1;
   2f578:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->flipIdx = -1;
   2f57a:	6523      	str	r3, [r4, #80]	; 0x50
}
   2f57c:	ecbd 8b02 	vpop	{d8}
   2f580:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0002f584 <tSampler_free>:

void tSampler_free (tSampler* const sp)
{
   2f584:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2f586:	6804      	ldr	r4, [r0, #0]
    tRamp_free(&p->gain);
   2f588:	f104 0008 	add.w	r0, r4, #8
   2f58c:	f7fb fe62 	bl	2b254 <tRamp_free>
    
    mpool_free((char*)p, p->mempool);
   2f590:	6821      	ldr	r1, [r4, #0]
   2f592:	4620      	mov	r0, r4
}
   2f594:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   2f598:	f7fd bee4 	b.w	2d364 <mpool_free>

0002f59c <tSampler_setMode>:
    return p->last;
}

void tSampler_setMode      (tSampler* const sp, PlayMode mode)
{
    _tSampler* p = *sp;
   2f59c:	6803      	ldr	r3, [r0, #0]
    p->mode = mode;
   2f59e:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
}
   2f5a2:	4770      	bx	lr

0002f5a4 <tSampler_setCrossfadeLength>:

void tSampler_setCrossfadeLength  (tSampler* const sp, uint32_t length)
{
   2f5a4:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2f5a6:	6804      	ldr	r4, [r0, #0]
    
    uint32_t cfxlen = LEAF_clip(0, length, p->len * 0.25f);
   2f5a8:	2300      	movs	r3, #0
   2f5aa:	ee07 1a90 	vmov	s15, r1
   2f5ae:	ed94 1a0c 	vldr	s2, [r4, #48]	; 0x30
   2f5b2:	ee00 3a10 	vmov	s0, r3
   2f5b6:	eef8 0a67 	vcvt.f32.u32	s1, s15
   2f5ba:	eebb 1acf 	vcvt.f32.u32	s2, s2, #2
   2f5be:	f7fd fc0f 	bl	2cde0 <LEAF_clip>
   2f5c2:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   2f5c6:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    
    p->cfxlen = cfxlen;
}
   2f5ca:	bd10      	pop	{r4, pc}

0002f5cc <tSampler_play>:

void tSampler_play         (tSampler* const sp)
{
   2f5cc:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2f5ce:	6804      	ldr	r4, [r0, #0]
    
    if (p->active != 0)
   2f5d0:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2f5d2:	f104 0008 	add.w	r0, r4, #8
   2f5d6:	bb93      	cbnz	r3, 2f63e <tSampler_play+0x72>
        
        tRamp_setDest(&p->gain, 0.f);
    }
    else
    {
        p->active = 1;
   2f5d8:	2201      	movs	r2, #1
        p->retrigger = 0;
   2f5da:	6423      	str	r3, [r4, #64]	; 0x40
        
        tRamp_setDest(&p->gain, 1.f);
   2f5dc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        p->active = 1;
   2f5e0:	6462      	str	r2, [r4, #68]	; 0x44
        tRamp_setDest(&p->gain, 1.f);
   2f5e2:	f7fb fe3b 	bl	2b25c <tRamp_setDest>
        
        if (p->dir > 0)
   2f5e6:	f994 301c 	ldrsb.w	r3, [r4, #28]
   2f5ea:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   2f5ec:	2b00      	cmp	r3, #0
   2f5ee:	6a22      	ldr	r2, [r4, #32]
        {
            if (p->flip > 0)    p->idx = p->start;
   2f5f0:	f994 301d 	ldrsb.w	r3, [r4, #29]
        if (p->dir > 0)
   2f5f4:	dd2f      	ble.n	2f656 <tSampler_play+0x8a>
            if (p->flip > 0)    p->idx = p->start;
   2f5f6:	2b00      	cmp	r3, #0
   2f5f8:	dd2f      	ble.n	2f65a <tSampler_play+0x8e>
            else                p->idx = p->end;
        }
        else
        {
            if (p->flip > 0)    p->idx = p->end;
            else                p->idx = p->start;
   2f5fa:	ee07 2a90 	vmov	s15, r2
   2f5fe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f602:	edc4 7a03 	vstr	s15, [r4, #12]

static void handleStartEndChange(tSampler* const sp)
{
    _tSampler* p = *sp;
    
    p->len = abs(p->end - p->start);
   2f606:	1a8b      	subs	r3, r1, r2
    
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f608:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2f60c:	2b00      	cmp	r3, #0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f60e:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2f612:	bfb8      	it	lt
   2f614:	425b      	neglt	r3, r3
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f616:	ee07 3a10 	vmov	s14, r3
    p->len = abs(p->end - p->start);
   2f61a:	6323      	str	r3, [r4, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f61c:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2f620:	eef4 7ac7 	vcmpe.f32	s15, s14
   2f624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f628:	dd03      	ble.n	2f632 <tSampler_play+0x66>
   2f62a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2f62e:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
    
    if (p->start > p->end)
   2f632:	4291      	cmp	r1, r2
    {
        p->flip = -1;
   2f634:	bfb4      	ite	lt
   2f636:	23ff      	movlt	r3, #255	; 0xff
    }
    else
    {
        p->flip = 1;
   2f638:	2301      	movge	r3, #1
   2f63a:	7763      	strb	r3, [r4, #29]
}
   2f63c:	bd10      	pop	{r4, pc}
        p->active = -1;
   2f63e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        p->retrigger = 1;
   2f642:	2201      	movs	r2, #1
        tRamp_setDest(&p->gain, 0.f);
   2f644:	2300      	movs	r3, #0
        p->retrigger = 1;
   2f646:	e9c4 2110 	strd	r2, r1, [r4, #64]	; 0x40
        tRamp_setDest(&p->gain, 0.f);
   2f64a:	ee00 3a10 	vmov	s0, r3
}
   2f64e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        tRamp_setDest(&p->gain, 0.f);
   2f652:	f7fb be03 	b.w	2b25c <tRamp_setDest>
            if (p->flip > 0)    p->idx = p->end;
   2f656:	2b00      	cmp	r3, #0
   2f658:	ddcf      	ble.n	2f5fa <tSampler_play+0x2e>
   2f65a:	ee07 1a90 	vmov	s15, r1
   2f65e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f662:	edc4 7a03 	vstr	s15, [r4, #12]
   2f666:	e7ce      	b.n	2f606 <tSampler_play+0x3a>

0002f668 <tSampler_stop>:
    _tSampler* p = *sp;
   2f668:	6800      	ldr	r0, [r0, #0]
    p->active = -1;
   2f66a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    tRamp_setDest(&p->gain, 0.f);
   2f66e:	2300      	movs	r3, #0
    p->active = -1;
   2f670:	6442      	str	r2, [r0, #68]	; 0x44
    tRamp_setDest(&p->gain, 0.f);
   2f672:	3008      	adds	r0, #8
   2f674:	ee00 3a10 	vmov	s0, r3
   2f678:	f7fb bdf0 	b.w	2b25c <tRamp_setDest>

0002f67c <tSampler_setStart>:
        tSampler_setEnd(sp, p->targetend);
    }
}

void tSampler_setStart     (tSampler* const sp, int32_t start)
{
   2f67c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2f67e:	6804      	ldr	r4, [r0, #0]
    if (start == p->end)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
   2f680:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2f682:	2b00      	cmp	r3, #0
   2f684:	d042      	beq.n	2f70c <tSampler_setStart+0x90>
    {
        if (start > p->end)
   2f686:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2f688:	428b      	cmp	r3, r1
   2f68a:	db1d      	blt.n	2f6c8 <tSampler_setStart+0x4c>
   2f68c:	2501      	movs	r5, #1
   2f68e:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
   2f690:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
   2f692:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2f696:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2f69a:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
   2f69e:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2f6a2:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2f6a6:	eef4 7ae6 	vcmpe.f32	s15, s13
   2f6aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f6ae:	bf48      	it	mi
   2f6b0:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2f6b4:	b932      	cbnz	r2, 2f6c4 <tSampler_setStart+0x48>
   2f6b6:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2f6ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2f6be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f6c2:	db06      	blt.n	2f6d2 <tSampler_setStart+0x56>
        }
    }
    
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetstart = -1;
   2f6c4:	6261      	str	r1, [r4, #36]	; 0x24
    
}
   2f6c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (start > p->end)
   2f6c8:	2701      	movs	r7, #1
   2f6ca:	2500      	movs	r5, #0
            tempflip = -1;
   2f6cc:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2f6d0:	e7df      	b.n	2f692 <tSampler_setStart+0x16>
        int dir = p->bnf * p->dir * tempflip;
   2f6d2:	f994 201e 	ldrsb.w	r2, [r4, #30]
   2f6d6:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2f6da:	fb12 f20c 	smulbb	r2, r2, ip
   2f6de:	fb06 f202 	mul.w	r2, r6, r2
        if ((tempflip > 0) && (dir > 0)) // start is start and we're playing forward
   2f6e2:	2a00      	cmp	r2, #0
   2f6e4:	dd3c      	ble.n	2f760 <tSampler_setStart+0xe4>
   2f6e6:	2d00      	cmp	r5, #0
   2f6e8:	d03a      	beq.n	2f760 <tSampler_setStart+0xe4>
            if (start > p->idx)// start given is after current index or we're in a crossfade
   2f6ea:	ee07 1a90 	vmov	s15, r1
   2f6ee:	edd4 6a03 	vldr	s13, [r4, #12]
   2f6f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f6f6:	eef4 7ae6 	vcmpe.f32	s15, s13
   2f6fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f6fe:	dc3e      	bgt.n	2f77e <tSampler_setStart+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
   2f700:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2f704:	42b3      	cmp	r3, r6
   2f706:	d001      	beq.n	2f70c <tSampler_setStart+0x90>
            p->flipIdx = 0;
   2f708:	2300      	movs	r3, #0
   2f70a:	6523      	str	r3, [r4, #80]	; 0x50
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
   2f70c:	6863      	ldr	r3, [r4, #4]
   2f70e:	4605      	mov	r5, r0
   2f710:	2000      	movs	r0, #0
   2f712:	691a      	ldr	r2, [r3, #16]
   2f714:	3a01      	subs	r2, #1
   2f716:	f7fd fb77 	bl	2ce08 <LEAF_clipInt>
   2f71a:	6220      	str	r0, [r4, #32]
    handleStartEndChange(sp);
   2f71c:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2f71e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2f720:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f722:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2f726:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f728:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2f72c:	2900      	cmp	r1, #0
   2f72e:	bfb8      	it	lt
   2f730:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f732:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2f736:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f738:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2f73c:	eef4 7ac7 	vcmpe.f32	s15, s14
   2f740:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f744:	dd03      	ble.n	2f74e <tSampler_setStart+0xd2>
   2f746:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2f74a:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2f74e:	4282      	cmp	r2, r0
   2f750:	bfac      	ite	ge
   2f752:	2201      	movge	r2, #1
   2f754:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetstart = -1;
   2f758:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2f75c:	775a      	strb	r2, [r3, #29]
   2f75e:	e7b1      	b.n	2f6c4 <tSampler_setStart+0x48>
        else if ((tempflip < 0) && (dir < 0)) // start is end and we're playing in reverse
   2f760:	2a00      	cmp	r2, #0
   2f762:	dacd      	bge.n	2f700 <tSampler_setStart+0x84>
   2f764:	2f00      	cmp	r7, #0
   2f766:	d0cb      	beq.n	2f700 <tSampler_setStart+0x84>
            if (start < p->idx)// start given is before current index or we're in a crossfade
   2f768:	ee07 1a90 	vmov	s15, r1
   2f76c:	edd4 6a03 	vldr	s13, [r4, #12]
   2f770:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f774:	eef4 7ae6 	vcmpe.f32	s15, s13
   2f778:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f77c:	d5c0      	bpl.n	2f700 <tSampler_setStart+0x84>
                float tempLen = abs(p->end - start) * 0.25f;
   2f77e:	1a5b      	subs	r3, r3, r1
                if (cfxlen > tempLen)
   2f780:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetstart = start;
   2f784:	6261      	str	r1, [r4, #36]	; 0x24
                float tempLen = abs(p->end - start) * 0.25f;
   2f786:	2b00      	cmp	r3, #0
   2f788:	bfb8      	it	lt
   2f78a:	425b      	neglt	r3, r3
   2f78c:	ee07 3a90 	vmov	s15, r3
   2f790:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2f794:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2f798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f79c:	dd93      	ble.n	2f6c6 <tSampler_setStart+0x4a>
                    p->cfxlen = tempLen;
   2f79e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2f7a2:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2f7a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002f7a8 <tSampler_forceStart>:


void tSampler_forceStart     (tSampler* const sp, int32_t start)
{
   2f7a8:	b538      	push	{r3, r4, r5, lr}
   2f7aa:	4605      	mov	r5, r0
    _tSampler* p = *sp;

    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
   2f7ac:	2000      	movs	r0, #0
    _tSampler* p = *sp;
   2f7ae:	682c      	ldr	r4, [r5, #0]
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
   2f7b0:	6863      	ldr	r3, [r4, #4]
   2f7b2:	691a      	ldr	r2, [r3, #16]
   2f7b4:	3a01      	subs	r2, #1
   2f7b6:	f7fd fb27 	bl	2ce08 <LEAF_clipInt>
   2f7ba:	6220      	str	r0, [r4, #32]
    handleStartEndChange(sp);
   2f7bc:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2f7be:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2f7c0:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f7c2:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2f7c6:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f7c8:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2f7cc:	2900      	cmp	r1, #0
   2f7ce:	bfb8      	it	lt
   2f7d0:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f7d2:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2f7d6:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f7d8:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2f7dc:	eef4 7ac7 	vcmpe.f32	s15, s14
   2f7e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f7e4:	dd03      	ble.n	2f7ee <tSampler_forceStart+0x46>
   2f7e6:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2f7ea:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = 1;
   2f7ee:	4282      	cmp	r2, r0
   2f7f0:	bfb4      	ite	lt
   2f7f2:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
   2f7f6:	2201      	movge	r2, #1
    p->targetstart = -1;
   2f7f8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2f7fc:	775a      	strb	r2, [r3, #29]
   2f7fe:	6261      	str	r1, [r4, #36]	; 0x24

}
   2f800:	bd38      	pop	{r3, r4, r5, pc}
   2f802:	bf00      	nop

0002f804 <tSampler_setEnd>:

void tSampler_setEnd       (tSampler* const sp, int32_t end)
{
   2f804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2f806:	6804      	ldr	r4, [r0, #0]
    if (end == p->start)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
   2f808:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2f80a:	2b00      	cmp	r3, #0
   2f80c:	d042      	beq.n	2f894 <tSampler_setEnd+0x90>
    {
        if (p->start > end)
   2f80e:	6a23      	ldr	r3, [r4, #32]
   2f810:	428b      	cmp	r3, r1
   2f812:	dc1d      	bgt.n	2f850 <tSampler_setEnd+0x4c>
   2f814:	2501      	movs	r5, #1
   2f816:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
   2f818:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
   2f81a:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2f81e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2f822:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
   2f826:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2f82a:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2f82e:	eef4 7ae6 	vcmpe.f32	s15, s13
   2f832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f836:	bf48      	it	mi
   2f838:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2f83c:	b932      	cbnz	r2, 2f84c <tSampler_setEnd+0x48>
   2f83e:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2f842:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2f846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f84a:	db06      	blt.n	2f85a <tSampler_setEnd+0x56>
        }
    }
    
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetend = -1;
   2f84c:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   2f84e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
   2f850:	2701      	movs	r7, #1
   2f852:	2500      	movs	r5, #0
            tempflip = -1;
   2f854:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2f858:	e7df      	b.n	2f81a <tSampler_setEnd+0x16>
        int dir = p->bnf * p->dir * tempflip;
   2f85a:	f994 201e 	ldrsb.w	r2, [r4, #30]
   2f85e:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2f862:	fb12 f20c 	smulbb	r2, r2, ip
   2f866:	fb06 f202 	mul.w	r2, r6, r2
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
   2f86a:	2a00      	cmp	r2, #0
   2f86c:	da3c      	bge.n	2f8e8 <tSampler_setEnd+0xe4>
   2f86e:	2d00      	cmp	r5, #0
   2f870:	d03a      	beq.n	2f8e8 <tSampler_setEnd+0xe4>
            if (end < p->idx) // end given is before current index or we're in a crossfade
   2f872:	ee07 1a90 	vmov	s15, r1
   2f876:	edd4 6a03 	vldr	s13, [r4, #12]
   2f87a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f87e:	eef4 7ae6 	vcmpe.f32	s15, s13
   2f882:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f886:	d43e      	bmi.n	2f906 <tSampler_setEnd+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
   2f888:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2f88c:	42b3      	cmp	r3, r6
   2f88e:	d001      	beq.n	2f894 <tSampler_setEnd+0x90>
            p->flipIdx = 0;
   2f890:	2300      	movs	r3, #0
   2f892:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
   2f894:	6863      	ldr	r3, [r4, #4]
   2f896:	4605      	mov	r5, r0
   2f898:	2000      	movs	r0, #0
   2f89a:	691a      	ldr	r2, [r3, #16]
   2f89c:	3a01      	subs	r2, #1
   2f89e:	f7fd fab3 	bl	2ce08 <LEAF_clipInt>
   2f8a2:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   2f8a4:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2f8a6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2f8a8:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f8aa:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2f8ae:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f8b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2f8b4:	2900      	cmp	r1, #0
   2f8b6:	bfb8      	it	lt
   2f8b8:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f8ba:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2f8be:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2f8c0:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2f8c4:	eef4 7ac7 	vcmpe.f32	s15, s14
   2f8c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f8cc:	dd03      	ble.n	2f8d6 <tSampler_setEnd+0xd2>
   2f8ce:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2f8d2:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2f8d6:	4282      	cmp	r2, r0
   2f8d8:	bfac      	ite	ge
   2f8da:	2201      	movge	r2, #1
   2f8dc:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
   2f8e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2f8e4:	775a      	strb	r2, [r3, #29]
   2f8e6:	e7b1      	b.n	2f84c <tSampler_setEnd+0x48>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
   2f8e8:	2a00      	cmp	r2, #0
   2f8ea:	ddcd      	ble.n	2f888 <tSampler_setEnd+0x84>
   2f8ec:	2f00      	cmp	r7, #0
   2f8ee:	d0cb      	beq.n	2f888 <tSampler_setEnd+0x84>
            if (end > p->idx) // end given is after current index or we're in a crossfade
   2f8f0:	ee07 1a90 	vmov	s15, r1
   2f8f4:	edd4 6a03 	vldr	s13, [r4, #12]
   2f8f8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f8fc:	eef4 7ae6 	vcmpe.f32	s15, s13
   2f900:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f904:	ddc0      	ble.n	2f888 <tSampler_setEnd+0x84>
                float tempLen = abs(end - p->start) * 0.25f;
   2f906:	1acb      	subs	r3, r1, r3
                if (cfxlen > tempLen)
   2f908:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
   2f90c:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
   2f90e:	2b00      	cmp	r3, #0
   2f910:	bfb8      	it	lt
   2f912:	425b      	neglt	r3, r3
   2f914:	ee07 3a90 	vmov	s15, r3
   2f918:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2f91c:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2f920:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f924:	dd93      	ble.n	2f84e <tSampler_setEnd+0x4a>
                    p->cfxlen = tempLen;
   2f926:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2f92a:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2f92e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002f930 <tSampler_tick>:
{
   2f930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f934:	ed2d 8b04 	vpush	{d8-d9}
    _tSampler* p = *sp;
   2f938:	6804      	ldr	r4, [r0, #0]
{
   2f93a:	b087      	sub	sp, #28
   2f93c:	4605      	mov	r5, r0
    if (p->targetstart >= 0)
   2f93e:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2f940:	2900      	cmp	r1, #0
   2f942:	db01      	blt.n	2f948 <tSampler_tick+0x18>
        tSampler_setStart(sp, p->targetstart);
   2f944:	f7ff fe9a 	bl	2f67c <tSampler_setStart>
    if (p->targetend >= 0)
   2f948:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   2f94a:	2900      	cmp	r1, #0
   2f94c:	db02      	blt.n	2f954 <tSampler_tick+0x24>
        tSampler_setEnd(sp, p->targetend);
   2f94e:	4628      	mov	r0, r5
   2f950:	f7ff ff58 	bl	2f804 <tSampler_setEnd>
    if (p->active == 0)         return 0.f;
   2f954:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2f956:	2b00      	cmp	r3, #0
   2f958:	f000 8136 	beq.w	2fbc8 <tSampler_tick+0x298>
    if ((p->inc == 0.0f) || (p->len < 2))
   2f95c:	edd4 7a04 	vldr	s15, [r4, #16]
   2f960:	eef5 7a40 	vcmp.f32	s15, #0.0
   2f964:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f968:	f000 8125 	beq.w	2fbb6 <tSampler_tick+0x286>
   2f96c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2f96e:	2b01      	cmp	r3, #1
   2f970:	f240 8121 	bls.w	2fbb6 <tSampler_tick+0x286>
    if (p->flip < 0)
   2f974:	f994 801d 	ldrsb.w	r8, [r4, #29]
    float* buff = p->samp->buff;
   2f978:	6862      	ldr	r2, [r4, #4]
    if (p->flip < 0)
   2f97a:	f1b8 0f00 	cmp.w	r8, #0
    int myStart = p->start;
   2f97e:	f8d4 a020 	ldr.w	sl, [r4, #32]
    float* buff = p->samp->buff;
   2f982:	6851      	ldr	r1, [r2, #4]
    int myEnd = p->end;
   2f984:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
    if (p->flip < 0)
   2f988:	db02      	blt.n	2f990 <tSampler_tick+0x60>
   2f98a:	464b      	mov	r3, r9
    int myStart = p->start;
   2f98c:	46d1      	mov	r9, sl
    int myEnd = p->end;
   2f98e:	469a      	mov	sl, r3
    int dir = p->bnf * p->dir * p->flip;
   2f990:	f994 001c 	ldrsb.w	r0, [r4, #28]
   2f994:	f994 301e 	ldrsb.w	r3, [r4, #30]
    int idx = (int) p->idx;
   2f998:	edd4 7a03 	vldr	s15, [r4, #12]
    int dir = p->bnf * p->dir * p->flip;
   2f99c:	fb13 f300 	smulbb	r3, r3, r0
    int length = p->samp->recordedLength;
   2f9a0:	f8d2 b010 	ldr.w	fp, [r2, #16]
    int idx = (int) p->idx;
   2f9a4:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2f9a8:	9101      	str	r1, [sp, #4]
    int dir = p->bnf * p->dir * p->flip;
   2f9aa:	fb08 f803 	mul.w	r8, r8, r3
    idx += rev;
   2f9ae:	ee17 6a10 	vmov	r6, s14
    if (dir < 0) rev = 1;
   2f9b2:	ea4f 77d8 	mov.w	r7, r8, lsr #31
    float alpha = rev + (p->idx - idx) * dir;
   2f9b6:	eef8 6ac7 	vcvt.f32.s32	s13, s14
   2f9ba:	ee06 8a10 	vmov	s12, r8
    idx += rev;
   2f9be:	443e      	add	r6, r7
    float alpha = rev + (p->idx - idx) * dir;
   2f9c0:	ee07 7a10 	vmov	s14, r7
   2f9c4:	f1c7 0001 	rsb	r0, r7, #1
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2f9c8:	fb07 f70b 	mul.w	r7, r7, fp
    int i1 = idx-(1*dir);
   2f9cc:	eba6 0208 	sub.w	r2, r6, r8
    int i3 = idx+(1*dir);
   2f9d0:	eb08 0306 	add.w	r3, r8, r6
   2f9d4:	9003      	str	r0, [sp, #12]
    float alpha = rev + (p->idx - idx) * dir;
   2f9d6:	eef8 8ac7 	vcvt.f32.s32	s17, s14
   2f9da:	fb00 f00b 	mul.w	r0, r0, fp
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2f9de:	4297      	cmp	r7, r2
    float alpha = rev + (p->idx - idx) * dir;
   2f9e0:	ee77 7ae6 	vsub.f32	s15, s15, s13
    int i4 = idx+(2*dir);
   2f9e4:	eb08 0c03 	add.w	ip, r8, r3
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2f9e8:	bfcc      	ite	gt
   2f9ea:	1812      	addgt	r2, r2, r0
   2f9ec:	1bd2      	suble	r2, r2, r7
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
   2f9ee:	42b7      	cmp	r7, r6
    float alpha = rev + (p->idx - idx) * dir;
   2f9f0:	eeb8 9ac6 	vcvt.f32.s32	s18, s12
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2f9f4:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   2f9f8:	9002      	str	r0, [sp, #8]
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
   2f9fa:	bfcc      	ite	gt
   2f9fc:	eb06 0e00 	addgt.w	lr, r6, r0
   2fa00:	eba6 0e07 	suble.w	lr, r6, r7
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
   2fa04:	4283      	cmp	r3, r0
    float alpha = rev + (p->idx - idx) * dir;
   2fa06:	eee7 8a89 	vfma.f32	s17, s15, s18
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2fa0a:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
   2fa0e:	ed92 0a00 	vldr	s0, [r2]
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
   2fa12:	bfac      	ite	ge
   2fa14:	1a1b      	subge	r3, r3, r0
   2fa16:	19db      	addlt	r3, r3, r7
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
   2fa18:	4584      	cmp	ip, r0
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2fa1a:	edde 0a00 	vldr	s1, [lr]
   2fa1e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
   2fa22:	bfac      	ite	ge
   2fa24:	ebac 0c00 	subge.w	ip, ip, r0
   2fa28:	44bc      	addlt	ip, r7
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2fa2a:	eeb0 2a68 	vmov.f32	s4, s17
   2fa2e:	ed93 1a00 	vldr	s2, [r3]
   2fa32:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
   2fa36:	eddc 1a00 	vldr	s3, [ip]
   2fa3a:	f7fd faef 	bl	2d01c <LEAF_interpolate_hermite_x>
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2fa3e:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    int32_t cfxlen = p->cfxlen;
   2fa42:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2fa46:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
   2fa4a:	eef8 0a47 	vcvt.f32.u32	s1, s14
   2fa4e:	ee07 ca10 	vmov	s14, ip
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2fa52:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2fa56:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fa5a:	ee60 7aa7 	vmul.f32	s15, s1, s15
   2fa5e:	e9dd 1001 	ldrd	r1, r0, [sp, #4]
   2fa62:	eef4 7ac7 	vcmpe.f32	s15, s14
   2fa66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fa6a:	d503      	bpl.n	2fa74 <tSampler_tick+0x144>
   2fa6c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2fa70:	ee17 ca90 	vmov	ip, s15
    if (myStart >= cfxlen) fadeLeftStart = myStart - cfxlen;
   2fa74:	45e1      	cmp	r9, ip
   2fa76:	f2c0 80b1 	blt.w	2fbdc <tSampler_tick+0x2ac>
   2fa7a:	eba9 0e0c 	sub.w	lr, r9, ip
   2fa7e:	f8cd 9004 	str.w	r9, [sp, #4]
    if (p->mode == PlayLoop)
   2fa82:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
   2fa86:	2a01      	cmp	r2, #1
   2fa88:	f000 80d2 	beq.w	2fc30 <tSampler_tick+0x300>
   2fa8c:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
    float inc = fmodf(p->inc, (float)p->len);
   2fa90:	ed94 0a04 	vldr	s0, [r4, #16]
   2fa94:	f001 f9c0 	bl	30e18 <fmodf>
    p->idx += (dir * inc);
   2fa98:	edd4 7a03 	vldr	s15, [r4, #12]
    if (p->flipStart >= 0)
   2fa9c:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    p->idx += (dir * inc);
   2faa0:	eee9 7a00 	vfma.f32	s15, s18, s0
    if (p->flipStart >= 0)
   2faa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    p->idx += (dir * inc);
   2faa8:	edc4 7a03 	vstr	s15, [r4, #12]
    if (p->flipStart >= 0)
   2faac:	db29      	blt.n	2fb02 <tSampler_tick+0x1d2>
        p->flipIdx += (-dir * inc);
   2faae:	f1c8 0300 	rsb	r3, r8, #0
   2fab2:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
   2fab6:	ee07 3a10 	vmov	s14, r3
   2faba:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fabe:	eee7 6a00 	vfma.f32	s13, s14, s0
   2fac2:	eeb0 7a66 	vmov.f32	s14, s13
        if((int)p->flipIdx < 0)
   2fac6:	eefd 6ae6 	vcvt.s32.f32	s13, s13
        p->flipIdx += (-dir * inc);
   2faca:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
        if((int)p->flipIdx < 0)
   2face:	ee16 3a90 	vmov	r3, s13
   2fad2:	2b00      	cmp	r3, #0
   2fad4:	da07      	bge.n	2fae6 <tSampler_tick+0x1b6>
            p->idx += (float)length;
   2fad6:	ee07 ba10 	vmov	s14, fp
   2fada:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fade:	ee77 7a87 	vadd.f32	s15, s15, s14
   2fae2:	edc4 7a03 	vstr	s15, [r4, #12]
        if((int)p->idx >= length)
   2fae6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2faea:	ee17 3a10 	vmov	r3, s14
   2faee:	455b      	cmp	r3, fp
   2faf0:	db07      	blt.n	2fb02 <tSampler_tick+0x1d2>
            p->idx -= (float)length;
   2faf2:	ee07 ba10 	vmov	s14, fp
   2faf6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fafa:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2fafe:	edc4 7a03 	vstr	s15, [r4, #12]
    _tSampler* p = *sp;
   2fb02:	682f      	ldr	r7, [r5, #0]
    if (p->targetstart >= 0)
   2fb04:	6a79      	ldr	r1, [r7, #36]	; 0x24
   2fb06:	2900      	cmp	r1, #0
   2fb08:	db02      	blt.n	2fb10 <tSampler_tick+0x1e0>
        tSampler_setStart(sp, p->targetstart);
   2fb0a:	4628      	mov	r0, r5
   2fb0c:	f7ff fdb6 	bl	2f67c <tSampler_setStart>
    if (p->targetend >= 0)
   2fb10:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2fb12:	2900      	cmp	r1, #0
   2fb14:	db02      	blt.n	2fb1c <tSampler_tick+0x1ec>
        tSampler_setEnd(sp, p->targetend);
   2fb16:	4628      	mov	r0, r5
   2fb18:	f7ff fe74 	bl	2f804 <tSampler_setEnd>
    if (p->mode == PlayLoop)
   2fb1c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   2fb20:	f104 0508 	add.w	r5, r4, #8
   2fb24:	2b01      	cmp	r3, #1
   2fb26:	d05e      	beq.n	2fbe6 <tSampler_tick+0x2b6>
    else if (p->mode == PlayBackAndForth)
   2fb28:	2b02      	cmp	r3, #2
   2fb2a:	f000 810a 	beq.w	2fd42 <tSampler_tick+0x412>
    if (p->mode == PlayNormal)
   2fb2e:	bb83      	cbnz	r3, 2fb92 <tSampler_tick+0x262>
    	if (p->idx < myStart)
   2fb30:	ee07 9a90 	vmov	s15, r9
   2fb34:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2fb38:	edd4 7a03 	vldr	s15, [r4, #12]
   2fb3c:	eef4 7ac7 	vcmpe.f32	s15, s14
   2fb40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fb44:	f140 80e2 	bpl.w	2fd0c <tSampler_tick+0x3dc>
    		p->idx = myEnd;
   2fb48:	ed84 7a03 	vstr	s14, [r4, #12]
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2fb4c:	f1b8 0f00 	cmp.w	r8, #0
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2fb50:	f64f 0208 	movw	r2, #63496	; 0xf808
   2fb54:	edd4 7a06 	vldr	s15, [r4, #24]
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2fb58:	bfb4      	ite	lt
   2fb5a:	eba6 0309 	sublt.w	r3, r6, r9
   2fb5e:	ebaa 0306 	subge.w	r3, sl, r6
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2fb62:	f2c0 220f 	movt	r2, #527	; 0x20f
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2fb66:	ee07 3a10 	vmov	s14, r3
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2fb6a:	f246 0342 	movw	r3, #24642	; 0x6042
   2fb6e:	edd2 6a00 	vldr	s13, [r2]
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2fb72:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2fb76:	f6c3 33e5 	movt	r3, #15333	; 0x3be5
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2fb7a:	ee27 7a27 	vmul.f32	s14, s14, s15
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2fb7e:	ee07 3a90 	vmov	s15, r3
   2fb82:	ee66 7aa7 	vmul.f32	s15, s13, s15
   2fb86:	eef4 7ac7 	vcmpe.f32	s15, s14
   2fb8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fb8e:	f300 8160 	bgt.w	2fe52 <tSampler_tick+0x522>
    sample = sample * tRamp_tick(&p->gain);
   2fb92:	4628      	mov	r0, r5
   2fb94:	f7fb fb7e 	bl	2b294 <tRamp_tick>
    if (p->active < 0)
   2fb98:	6c63      	ldr	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
   2fb9a:	ee20 8a08 	vmul.f32	s16, s0, s16
    if (p->active < 0)
   2fb9e:	2b00      	cmp	r3, #0
   2fba0:	f2c0 80e7 	blt.w	2fd72 <tSampler_tick+0x442>
}
   2fba4:	eeb0 0a48 	vmov.f32	s0, s16
    p->last = sample;
   2fba8:	ed84 8a05 	vstr	s16, [r4, #20]
}
   2fbac:	b007      	add	sp, #28
   2fbae:	ecbd 8b04 	vpop	{d8-d9}
   2fbb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return p->last;
   2fbb6:	ed94 8a05 	vldr	s16, [r4, #20]
}
   2fbba:	eeb0 0a48 	vmov.f32	s0, s16
   2fbbe:	b007      	add	sp, #28
   2fbc0:	ecbd 8b04 	vpop	{d8-d9}
   2fbc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p->active == 0)         return 0.f;
   2fbc8:	2300      	movs	r3, #0
   2fbca:	ee08 3a10 	vmov	s16, r3
}
   2fbce:	eeb0 0a48 	vmov.f32	s0, s16
   2fbd2:	b007      	add	sp, #28
   2fbd4:	ecbd 8b04 	vpop	{d8-d9}
   2fbd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2fbdc:	f8cd c004 	str.w	ip, [sp, #4]
    int32_t fadeLeftStart = 0;
   2fbe0:	f04f 0e00 	mov.w	lr, #0
   2fbe4:	e74d      	b.n	2fa82 <tSampler_tick+0x152>
        if((int)p->idx < myStart)
   2fbe6:	edd4 7a03 	vldr	s15, [r4, #12]
   2fbea:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2fbee:	ee17 3a10 	vmov	r3, s14
   2fbf2:	454b      	cmp	r3, r9
   2fbf4:	da0e      	bge.n	2fc14 <tSampler_tick+0x2e4>
            p->idx += (float)(fadeRightEnd - fadeLeftEnd);
   2fbf6:	9b01      	ldr	r3, [sp, #4]
   2fbf8:	ebaa 0303 	sub.w	r3, sl, r3
   2fbfc:	ee07 3a10 	vmov	s14, r3
   2fc00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fc04:	ee77 7a87 	vadd.f32	s15, s15, s14
   2fc08:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2fc0c:	edc4 7a03 	vstr	s15, [r4, #12]
   2fc10:	ee17 3a10 	vmov	r3, s14
        if((int)p->idx > myEnd)
   2fc14:	459a      	cmp	sl, r3
   2fc16:	dabc      	bge.n	2fb92 <tSampler_tick+0x262>
            p->idx -= (float)(fadeRightEnd - fadeLeftEnd);
   2fc18:	9b01      	ldr	r3, [sp, #4]
   2fc1a:	ebaa 0a03 	sub.w	sl, sl, r3
   2fc1e:	ee07 aa10 	vmov	s14, sl
   2fc22:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fc26:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2fc2a:	edc4 7a03 	vstr	s15, [r4, #12]
   2fc2e:	e7b0      	b.n	2fb92 <tSampler_tick+0x262>
   2fc30:	ee07 ca90 	vmov	s15, ip
        if ((fadeLeftStart <= idx) && (idx <= fadeLeftEnd))
   2fc34:	45b6      	cmp	lr, r6
   2fc36:	eef8 9ae7 	vcvt.f32.s32	s19, s15
   2fc3a:	dc72      	bgt.n	2fd22 <tSampler_tick+0x3f2>
   2fc3c:	9b01      	ldr	r3, [sp, #4]
   2fc3e:	429e      	cmp	r6, r3
   2fc40:	dc6f      	bgt.n	2fd22 <tSampler_tick+0x3f2>
            offset = fadeLeftEnd - idx;
   2fc42:	1b9b      	subs	r3, r3, r6
            p->inCrossfade = 1;
   2fc44:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
            offset = fadeLeftEnd - idx;
   2fc48:	9302      	str	r3, [sp, #8]
            cdx = fadeRightEnd - offset;
   2fc4a:	ebaa 0303 	sub.w	r3, sl, r3
            int c1 = cdx-(1*dir);
   2fc4e:	eba3 0e08 	sub.w	lr, r3, r8
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
   2fc52:	4577      	cmp	r7, lr
   2fc54:	f340 812f 	ble.w	2feb6 <tSampler_tick+0x586>
   2fc58:	4486      	add	lr, r0
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
   2fc5a:	429f      	cmp	r7, r3
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2fc5c:	eeb0 2a68 	vmov.f32	s4, s17
   2fc60:	9005      	str	r0, [sp, #20]
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
   2fc62:	bfcc      	ite	gt
   2fc64:	eb03 0c00 	addgt.w	ip, r3, r0
   2fc68:	eba3 0c07 	suble.w	ip, r3, r7
            int c3 = cdx+(1*dir);
   2fc6c:	4443      	add	r3, r8
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2fc6e:	9104      	str	r1, [sp, #16]
   2fc70:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
   2fc74:	4283      	cmp	r3, r0
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2fc76:	eddc 0a00 	vldr	s1, [ip]
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
   2fc7a:	bfac      	ite	ge
   2fc7c:	1a1a      	subge	r2, r3, r0
   2fc7e:	18fa      	addlt	r2, r7, r3
            int c4 = cdx+(2*dir);
   2fc80:	4443      	add	r3, r8
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2fc82:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
   2fc86:	4283      	cmp	r3, r0
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2fc88:	ed92 1a00 	vldr	s2, [r2]
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
   2fc8c:	bfac      	ite	ge
   2fc8e:	1a1b      	subge	r3, r3, r0
   2fc90:	19db      	addlt	r3, r3, r7
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2fc92:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   2fc96:	edd3 1a00 	vldr	s3, [r3]
   2fc9a:	eb01 038e 	add.w	r3, r1, lr, lsl #2
   2fc9e:	ed93 0a00 	vldr	s0, [r3]
   2fca2:	f7fd f9bb 	bl	2d01c <LEAF_interpolate_hermite_x>
            crossfadeMix = (float) offset / (float) cfxlen;
   2fca6:	eddd 7a02 	vldr	s15, [sp, #8]
   2fcaa:	eef8 6ae7 	vcvt.f32.s32	s13, s15
   2fcae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2fcb2:	ee86 7aa9 	vdiv.f32	s14, s13, s19
   2fcb6:	e9dd 1004 	ldrd	r1, r0, [sp, #16]
   2fcba:	ee20 0a07 	vmul.f32	s0, s0, s14
   2fcbe:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2fcc2:	eea8 0a27 	vfma.f32	s0, s16, s15
   2fcc6:	eeb0 8a40 	vmov.f32	s16, s0
        float flipLength = fabsf(p->flipIdx - p->flipStart);
   2fcca:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
   2fcce:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
   2fcd2:	ee77 7a68 	vsub.f32	s15, s14, s17
   2fcd6:	eef0 7ae7 	vabs.f32	s15, s15
        if (flipLength > cfxlen)
   2fcda:	eef4 7ae9 	vcmpe.f32	s15, s19
   2fcde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fce2:	dd5c      	ble.n	2fd9e <tSampler_tick+0x46e>
            p->flipStart = -1;
   2fce4:	2300      	movs	r3, #0
    float inc = fmodf(p->inc, (float)p->len);
   2fce6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2fcea:	ed94 0a04 	vldr	s0, [r4, #16]
            p->flipStart = -1;
   2fcee:	f6cb 7380 	movt	r3, #49024	; 0xbf80
    float inc = fmodf(p->inc, (float)p->len);
   2fcf2:	eef8 0a67 	vcvt.f32.u32	s1, s15
            p->flipStart = -1;
   2fcf6:	64e3      	str	r3, [r4, #76]	; 0x4c
            p->flipIdx = -1;
   2fcf8:	6523      	str	r3, [r4, #80]	; 0x50
    float inc = fmodf(p->inc, (float)p->len);
   2fcfa:	f001 f88d 	bl	30e18 <fmodf>
    p->idx += (dir * inc);
   2fcfe:	edd4 7a03 	vldr	s15, [r4, #12]
   2fd02:	eee9 7a00 	vfma.f32	s15, s18, s0
   2fd06:	edc4 7a03 	vstr	s15, [r4, #12]
   2fd0a:	e6fa      	b.n	2fb02 <tSampler_tick+0x1d2>
    	else if (p->idx > myEnd)
   2fd0c:	ee07 aa10 	vmov	s14, sl
   2fd10:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2fd14:	eef4 7ac7 	vcmpe.f32	s15, s14
   2fd18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fd1c:	f77f af16 	ble.w	2fb4c <tSampler_tick+0x21c>
   2fd20:	e712      	b.n	2fb48 <tSampler_tick+0x218>
    int32_t fadeRightStart = fadeRightEnd - cfxlen;
   2fd22:	ebaa 0c0c 	sub.w	ip, sl, ip
        else if ((fadeRightStart <= idx) && (idx <= fadeRightEnd))
   2fd26:	4566      	cmp	r6, ip
   2fd28:	f2c0 80c1 	blt.w	2feae <tSampler_tick+0x57e>
   2fd2c:	45b2      	cmp	sl, r6
   2fd2e:	f2c0 80be 	blt.w	2feae <tSampler_tick+0x57e>
            offset = idx - fadeRightStart;
   2fd32:	eba6 030c 	sub.w	r3, r6, ip
            p->inCrossfade = 1;
   2fd36:	2201      	movs	r2, #1
            offset = idx - fadeRightStart;
   2fd38:	9302      	str	r3, [sp, #8]
            cdx = fadeLeftStart + offset;
   2fd3a:	4473      	add	r3, lr
            p->inCrossfade = 1;
   2fd3c:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
   2fd40:	e785      	b.n	2fc4e <tSampler_tick+0x31e>
        if (p->idx < myStart)
   2fd42:	ee07 9a90 	vmov	s15, r9
   2fd46:	ed94 7a03 	vldr	s14, [r4, #12]
   2fd4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fd4e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2fd52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fd56:	f140 8086 	bpl.w	2fe66 <tSampler_tick+0x536>
            p->idx = myStart + 1;
   2fd5a:	f109 0901 	add.w	r9, r9, #1
            p->bnf = -p->bnf;
   2fd5e:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myStart + 1;
   2fd60:	ee07 9a90 	vmov	s15, r9
            p->bnf = -p->bnf;
   2fd64:	425b      	negs	r3, r3
            p->idx = myStart + 1;
   2fd66:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
   2fd6a:	77a3      	strb	r3, [r4, #30]
            p->idx = myStart + 1;
   2fd6c:	edc4 7a03 	vstr	s15, [r4, #12]
   2fd70:	e70f      	b.n	2fb92 <tSampler_tick+0x262>
        if (tRamp_sample(&p->gain) <= 0.00001f)
   2fd72:	4628      	mov	r0, r5
   2fd74:	f7fb fab6 	bl	2b2e4 <tRamp_sample>
   2fd78:	f24c 53ac 	movw	r3, #50604	; 0xc5ac
   2fd7c:	f2c3 7327 	movt	r3, #14119	; 0x3727
   2fd80:	ee07 3a90 	vmov	s15, r3
   2fd84:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2fd88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fd8c:	f63f af0a 	bhi.w	2fba4 <tSampler_tick+0x274>
            if (p->retrigger == 1)
   2fd90:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2fd92:	2b01      	cmp	r3, #1
   2fd94:	f000 8092 	beq.w	2febc <tSampler_tick+0x58c>
                p->active = 0;
   2fd98:	2300      	movs	r3, #0
   2fd9a:	6463      	str	r3, [r4, #68]	; 0x44
   2fd9c:	e702      	b.n	2fba4 <tSampler_tick+0x274>
        if (p->flipIdx >= 0)
   2fd9e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
   2fda2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fda6:	db4f      	blt.n	2fe48 <tSampler_tick+0x518>
            if (p->flipStart == -1)
   2fda8:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2fdac:	eef4 8a66 	vcmp.f32	s17, s13
   2fdb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fdb4:	d06f      	beq.n	2fe96 <tSampler_tick+0x566>
   2fdb6:	ee79 7ae7 	vsub.f32	s15, s19, s15
   2fdba:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2fdbe:	eec7 8aa9 	vdiv.f32	s17, s15, s19
   2fdc2:	ee76 7ae8 	vsub.f32	s15, s13, s17
   2fdc6:	ee27 8a88 	vmul.f32	s16, s15, s16
            int fdx = (int) p->flipIdx;
   2fdca:	eefd 7ac7 	vcvt.s32.f32	s15, s14
            idx += (1-rev);
   2fdce:	9a03      	ldr	r2, [sp, #12]
   2fdd0:	4416      	add	r6, r2
            int fdx = (int) p->flipIdx;
   2fdd2:	eef0 6a67 	vmov.f32	s13, s15
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2fdd6:	ee07 2a90 	vmov	s15, r2
   2fdda:	eeb8 2ae7 	vcvt.f32.s32	s4, s15
            int f3 = fdx-(1*dir);
   2fdde:	ee16 3a90 	vmov	r3, s13
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2fde2:	eef8 7ae6 	vcvt.f32.s32	s15, s13
            int f1 = fdx+(1*dir);
   2fde6:	eb08 0e03 	add.w	lr, r8, r3
            int f3 = fdx-(1*dir);
   2fdea:	eba3 0208 	sub.w	r2, r3, r8
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2fdee:	ee37 7ac7 	vsub.f32	s14, s15, s14
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
   2fdf2:	4586      	cmp	lr, r0
            int f4 = fdx-(2*dir);
   2fdf4:	eba2 0c08 	sub.w	ip, r2, r8
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
   2fdf8:	bfb4      	ite	lt
   2fdfa:	44be      	addlt	lr, r7
   2fdfc:	ebae 0e00 	subge.w	lr, lr, r0
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2fe00:	4283      	cmp	r3, r0
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2fe02:	eea9 2a07 	vfma.f32	s4, s18, s14
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2fe06:	da44      	bge.n	2fe92 <tSampler_tick+0x562>
   2fe08:	443b      	add	r3, r7
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
   2fe0a:	4297      	cmp	r7, r2
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2fe0c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
   2fe10:	bfcc      	ite	gt
   2fe12:	1812      	addgt	r2, r2, r0
   2fe14:	1bd2      	suble	r2, r2, r7
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
   2fe16:	4567      	cmp	r7, ip
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2fe18:	edd3 0a00 	vldr	s1, [r3]
   2fe1c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
   2fe20:	bfcc      	ite	gt
   2fe22:	4460      	addgt	r0, ip
   2fe24:	ebac 0007 	suble.w	r0, ip, r7
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2fe28:	ed92 1a00 	vldr	s2, [r2]
   2fe2c:	eb01 0080 	add.w	r0, r1, r0, lsl #2
   2fe30:	eb01 018e 	add.w	r1, r1, lr, lsl #2
   2fe34:	edd0 1a00 	vldr	s3, [r0]
   2fe38:	ed91 0a00 	vldr	s0, [r1]
   2fe3c:	f7fd f8ee 	bl	2d01c <LEAF_interpolate_hermite_x>
   2fe40:	eea0 8a28 	vfma.f32	s16, s0, s17
   2fe44:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
   2fe48:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2fe4c:	eef8 0a67 	vcvt.f32.u32	s1, s15
   2fe50:	e61e      	b.n	2fa90 <tSampler_tick+0x160>
            tRamp_setDest(&p->gain, 0.f);
   2fe52:	2300      	movs	r3, #0
   2fe54:	4628      	mov	r0, r5
   2fe56:	ee00 3a10 	vmov	s0, r3
   2fe5a:	f7fb f9ff 	bl	2b25c <tRamp_setDest>
            p->active = -1;
   2fe5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2fe62:	6463      	str	r3, [r4, #68]	; 0x44
   2fe64:	e695      	b.n	2fb92 <tSampler_tick+0x262>
        else if (p->idx > myEnd)
   2fe66:	ee07 aa90 	vmov	s15, sl
   2fe6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fe6e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2fe72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fe76:	f77f ae8c 	ble.w	2fb92 <tSampler_tick+0x262>
            p->idx = myEnd - 1;
   2fe7a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
            p->bnf = -p->bnf;
   2fe7e:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myEnd - 1;
   2fe80:	ee07 aa90 	vmov	s15, sl
            p->bnf = -p->bnf;
   2fe84:	425b      	negs	r3, r3
            p->idx = myEnd - 1;
   2fe86:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
   2fe8a:	77a3      	strb	r3, [r4, #30]
            p->idx = myEnd - 1;
   2fe8c:	edc4 7a03 	vstr	s15, [r4, #12]
   2fe90:	e67f      	b.n	2fb92 <tSampler_tick+0x262>
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2fe92:	1a1b      	subs	r3, r3, r0
   2fe94:	e7b9      	b.n	2fe0a <tSampler_tick+0x4da>
                p->flipStart = p->idx;
   2fe96:	ed94 7a03 	vldr	s14, [r4, #12]
                p->flipIdx = p->idx;
   2fe9a:	2300      	movs	r3, #0
   2fe9c:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   2fea0:	ee08 3a10 	vmov	s16, r3
                p->flipStart = p->idx;
   2fea4:	ed84 7a13 	vstr	s14, [r4, #76]	; 0x4c
                p->flipIdx = p->idx;
   2fea8:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
   2feac:	e78d      	b.n	2fdca <tSampler_tick+0x49a>
        else p->inCrossfade = 0;
   2feae:	2300      	movs	r3, #0
   2feb0:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
   2feb4:	e709      	b.n	2fcca <tSampler_tick+0x39a>
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
   2feb6:	ebae 0e07 	sub.w	lr, lr, r7
   2feba:	e6ce      	b.n	2fc5a <tSampler_tick+0x32a>
                p->retrigger = 0;
   2febc:	2200      	movs	r2, #0
                p->active = 1;
   2febe:	6463      	str	r3, [r4, #68]	; 0x44
                tRamp_setDest(&p->gain, 1.f);
   2fec0:	4628      	mov	r0, r5
   2fec2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
                p->retrigger = 0;
   2fec6:	6422      	str	r2, [r4, #64]	; 0x40
                tRamp_setDest(&p->gain, 1.f);
   2fec8:	f7fb f9c8 	bl	2b25c <tRamp_setDest>
                if (p->dir > 0)
   2fecc:	f994 301c 	ldrsb.w	r3, [r4, #28]
   2fed0:	2b00      	cmp	r3, #0
                    if (p->flip > 0)    p->idx = p->start;
   2fed2:	f994 301d 	ldrsb.w	r3, [r4, #29]
                if (p->dir > 0)
   2fed6:	dd08      	ble.n	2feea <tSampler_tick+0x5ba>
                    if (p->flip > 0)    p->idx = p->start;
   2fed8:	2b00      	cmp	r3, #0
   2feda:	dd08      	ble.n	2feee <tSampler_tick+0x5be>
                    else                p->idx = p->start;
   2fedc:	edd4 7a08 	vldr	s15, [r4, #32]
   2fee0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fee4:	edc4 7a03 	vstr	s15, [r4, #12]
   2fee8:	e65c      	b.n	2fba4 <tSampler_tick+0x274>
                    if (p->flip > 0)    p->idx = p->end;
   2feea:	2b00      	cmp	r3, #0
   2feec:	ddf6      	ble.n	2fedc <tSampler_tick+0x5ac>
   2feee:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
   2fef2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fef6:	edc4 7a03 	vstr	s15, [r4, #12]
   2fefa:	e653      	b.n	2fba4 <tSampler_tick+0x274>

0002fefc <tSampler_setLength>:

void    tSampler_setLength    (tSampler* const sp, int32_t length)
{
   2fefc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2fefe:	6804      	ldr	r4, [r0, #0]
    if (length == 0) length = 1;
   2ff00:	2900      	cmp	r1, #0
   2ff02:	bf14      	ite	ne
   2ff04:	460a      	movne	r2, r1
   2ff06:	2201      	moveq	r2, #1
    tSampler_setEnd(sp, p->start + length);
   2ff08:	6a23      	ldr	r3, [r4, #32]
    if (p->active) // only bother with these checks if we're actually playing
   2ff0a:	6c65      	ldr	r5, [r4, #68]	; 0x44
    tSampler_setEnd(sp, p->start + length);
   2ff0c:	1899      	adds	r1, r3, r2
    if (p->active) // only bother with these checks if we're actually playing
   2ff0e:	2d00      	cmp	r5, #0
   2ff10:	d041      	beq.n	2ff96 <tSampler_setLength+0x9a>
        if (p->start > end)
   2ff12:	428b      	cmp	r3, r1
   2ff14:	dc1d      	bgt.n	2ff52 <tSampler_setLength+0x56>
   2ff16:	2501      	movs	r5, #1
   2ff18:	2700      	movs	r7, #0
            tempflip = 1;
   2ff1a:	462e      	mov	r6, r5
        uint32_t cfxlen = p->cfxlen;
   2ff1c:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2ff20:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2ff24:	eef8 6a47 	vcvt.f32.u32	s13, s14
        if (p->inCrossfade || p->flipStart >= 0)
   2ff28:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2ff2c:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2ff30:	eef4 7ae6 	vcmpe.f32	s15, s13
   2ff34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ff38:	bf48      	it	mi
   2ff3a:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2ff3e:	b933      	cbnz	r3, 2ff4e <tSampler_setLength+0x52>
   2ff40:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2ff44:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2ff48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ff4c:	db06      	blt.n	2ff5c <tSampler_setLength+0x60>
    p->targetend = -1;
   2ff4e:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   2ff50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
   2ff52:	2701      	movs	r7, #1
   2ff54:	2500      	movs	r5, #0
            tempflip = -1;
   2ff56:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2ff5a:	e7df      	b.n	2ff1c <tSampler_setLength+0x20>
        int dir = p->bnf * p->dir * tempflip;
   2ff5c:	f994 301e 	ldrsb.w	r3, [r4, #30]
   2ff60:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2ff64:	fb13 f30c 	smulbb	r3, r3, ip
   2ff68:	fb06 f303 	mul.w	r3, r6, r3
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
   2ff6c:	2b00      	cmp	r3, #0
   2ff6e:	da3c      	bge.n	2ffea <tSampler_setLength+0xee>
   2ff70:	2d00      	cmp	r5, #0
   2ff72:	d03a      	beq.n	2ffea <tSampler_setLength+0xee>
            if (end < p->idx) // end given is before current index or we're in a crossfade
   2ff74:	ee07 1a90 	vmov	s15, r1
   2ff78:	edd4 6a03 	vldr	s13, [r4, #12]
   2ff7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2ff80:	eef4 7ae6 	vcmpe.f32	s15, s13
   2ff84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ff88:	d43e      	bmi.n	30008 <tSampler_setLength+0x10c>
        if (tempflip != p->flip && p->flipStart < 0)
   2ff8a:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2ff8e:	429e      	cmp	r6, r3
   2ff90:	d001      	beq.n	2ff96 <tSampler_setLength+0x9a>
            p->flipIdx = 0;
   2ff92:	2300      	movs	r3, #0
   2ff94:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
   2ff96:	6863      	ldr	r3, [r4, #4]
   2ff98:	4605      	mov	r5, r0
   2ff9a:	2000      	movs	r0, #0
   2ff9c:	691a      	ldr	r2, [r3, #16]
   2ff9e:	3a01      	subs	r2, #1
   2ffa0:	f7fc ff32 	bl	2ce08 <LEAF_clipInt>
   2ffa4:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   2ffa6:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2ffa8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2ffaa:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2ffac:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2ffb0:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2ffb2:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2ffb6:	2900      	cmp	r1, #0
   2ffb8:	bfb8      	it	lt
   2ffba:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2ffbc:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2ffc0:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2ffc2:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2ffc6:	eef4 7ac7 	vcmpe.f32	s15, s14
   2ffca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ffce:	dd03      	ble.n	2ffd8 <tSampler_setLength+0xdc>
   2ffd0:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2ffd4:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2ffd8:	4282      	cmp	r2, r0
   2ffda:	bfac      	ite	ge
   2ffdc:	2201      	movge	r2, #1
   2ffde:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
   2ffe2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2ffe6:	775a      	strb	r2, [r3, #29]
   2ffe8:	e7b1      	b.n	2ff4e <tSampler_setLength+0x52>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
   2ffea:	2b00      	cmp	r3, #0
   2ffec:	ddcd      	ble.n	2ff8a <tSampler_setLength+0x8e>
   2ffee:	2f00      	cmp	r7, #0
   2fff0:	d0cb      	beq.n	2ff8a <tSampler_setLength+0x8e>
            if (end > p->idx) // end given is after current index or we're in a crossfade
   2fff2:	ee07 1a90 	vmov	s15, r1
   2fff6:	edd4 6a03 	vldr	s13, [r4, #12]
   2fffa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fffe:	eef4 7ae6 	vcmpe.f32	s15, s13
   30002:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30006:	ddc0      	ble.n	2ff8a <tSampler_setLength+0x8e>
                float tempLen = abs(end - p->start) * 0.25f;
   30008:	2a00      	cmp	r2, #0
                if (cfxlen > tempLen)
   3000a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
   3000e:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
   30010:	bfb8      	it	lt
   30012:	4252      	neglt	r2, r2
   30014:	ee07 2a90 	vmov	s15, r2
   30018:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   3001c:	eef4 7ac7 	vcmpe.f32	s15, s14
   30020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30024:	d594      	bpl.n	2ff50 <tSampler_setLength+0x54>
                    p->cfxlen = tempLen;
   30026:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   3002a:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   3002e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00030030 <tSampler_forceLength>:



void    tSampler_forceLength    (tSampler* const sp, int32_t length)
{
   30030:	b538      	push	{r3, r4, r5, lr}
   30032:	4605      	mov	r5, r0
    _tSampler* p = *sp;
    if (length == 0) length = 1;
   30034:	2900      	cmp	r1, #0
   30036:	bf08      	it	eq
   30038:	2101      	moveq	r1, #1
    p->end = LEAF_clipInt(0, p->start + length, p->samp->recordedLength-1);
   3003a:	2000      	movs	r0, #0
    _tSampler* p = *sp;
   3003c:	682c      	ldr	r4, [r5, #0]
    p->end = LEAF_clipInt(0, p->start + length, p->samp->recordedLength-1);
   3003e:	6862      	ldr	r2, [r4, #4]
   30040:	6a23      	ldr	r3, [r4, #32]
   30042:	6912      	ldr	r2, [r2, #16]
   30044:	4419      	add	r1, r3
   30046:	3a01      	subs	r2, #1
   30048:	f7fc fede 	bl	2ce08 <LEAF_clipInt>
   3004c:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   3004e:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   30050:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   30052:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   30054:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   30058:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   3005a:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   3005e:	2900      	cmp	r1, #0
   30060:	bfb8      	it	lt
   30062:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   30064:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   30068:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   3006a:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   3006e:	eef4 7ac7 	vcmpe.f32	s15, s14
   30072:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30076:	dd03      	ble.n	30080 <tSampler_forceLength+0x50>
   30078:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   3007c:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = 1;
   30080:	4282      	cmp	r2, r0
   30082:	bfb4      	ite	lt
   30084:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
   30088:	2201      	movge	r2, #1
    p->targetend = -1;
   3008a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   3008e:	775a      	strb	r2, [r3, #29]
   30090:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   30092:	bd38      	pop	{r3, r4, r5, pc}

00030094 <tSampler_setRate>:

void tSampler_setRate      (tSampler* const sp, float rate)
{
    _tSampler* p = *sp;
    
    if (rate < 0.f)
   30094:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    _tSampler* p = *sp;
   30098:	6803      	ldr	r3, [r0, #0]
    if (rate < 0.f)
   3009a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3009e:	d40a      	bmi.n	300b6 <tSampler_setRate+0x22>
        rate = -rate;
        p->dir = -1;
    }
    else
    {
        p->dir = 1;
   300a0:	2201      	movs	r2, #1
    }
    
    p->inc = rate;
    p->iinc = 1.f / p->inc;
   300a2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   300a6:	771a      	strb	r2, [r3, #28]
    p->inc = rate;
   300a8:	ed83 0a04 	vstr	s0, [r3, #16]
    p->iinc = 1.f / p->inc;
   300ac:	eec7 7a00 	vdiv.f32	s15, s14, s0
   300b0:	edc3 7a06 	vstr	s15, [r3, #24]
}
   300b4:	4770      	bx	lr
        rate = -rate;
   300b6:	eeb1 0a40 	vneg.f32	s0, s0
        p->dir = -1;
   300ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   300be:	e7f0      	b.n	300a2 <tSampler_setRate+0xe>

000300c0 <LEAF_init>:

LEAF leaf;

void LEAF_init(float sr, int blocksize, char* memory, size_t memorysize, float(*random)(void))

{
   300c0:	b538      	push	{r3, r4, r5, lr}
   300c2:	460c      	mov	r4, r1
   300c4:	4605      	mov	r5, r0
    leaf_pool_init(memory, memorysize);
   300c6:	4611      	mov	r1, r2
   300c8:	4620      	mov	r0, r4
{
   300ca:	461c      	mov	r4, r3
   300cc:	ed2d 8b02 	vpush	{d8}
   300d0:	eeb0 8a40 	vmov.f32	s16, s0
    leaf_pool_init(memory, memorysize);
   300d4:	f7fd f884 	bl	2d1e0 <leaf_pool_init>
    
    leaf.sampleRate = sr;

    leaf.blockSize = blocksize;
    
    leaf.invSampleRate = 1.0f/sr;
   300d8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   300dc:	f640 71db 	movw	r1, #4059	; 0xfdb
    leaf.sampleRate = sr;
   300e0:	f64f 0208 	movw	r2, #63496	; 0xf808

    leaf.random = random;
    
    leaf.clearOnAllocation = 0;
   300e4:	2000      	movs	r0, #0
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   300e6:	f2c4 01c9 	movt	r1, #16585	; 0x40c9
    leaf.invSampleRate = 1.0f/sr;
   300ea:	ee87 7a88 	vdiv.f32	s14, s15, s16
    leaf.sampleRate = sr;
   300ee:	f2c0 220f 	movt	r2, #527	; 0x20f
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   300f2:	ee07 1a90 	vmov	s15, r1
    leaf.blockSize = blocksize;
   300f6:	6095      	str	r5, [r2, #8]
    leaf.sampleRate = sr;
   300f8:	ed82 8a00 	vstr	s16, [r2]
    leaf.clearOnAllocation = 0;
   300fc:	e9c2 4004 	strd	r4, r0, [r2, #16]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   30100:	ee67 7a27 	vmul.f32	s15, s14, s15
    leaf.invSampleRate = 1.0f/sr;
   30104:	ed82 7a01 	vstr	s14, [r2, #4]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   30108:	edc2 7a03 	vstr	s15, [r2, #12]
}
   3010c:	ecbd 8b02 	vpop	{d8}
   30110:	bd38      	pop	{r3, r4, r5, pc}
   30112:	bf00      	nop

00030114 <__errno>:
   30114:	4b01      	ldr	r3, [pc, #4]	; (3011c <__errno+0x8>)
   30116:	6818      	ldr	r0, [r3, #0]
   30118:	4770      	bx	lr
   3011a:	bf00      	nop
   3011c:	00066438 	.word	0x00066438

00030120 <__libc_init_array>:
   30120:	b570      	push	{r4, r5, r6, lr}
   30122:	4e0d      	ldr	r6, [pc, #52]	; (30158 <__libc_init_array+0x38>)
   30124:	4c0d      	ldr	r4, [pc, #52]	; (3015c <__libc_init_array+0x3c>)
   30126:	1ba4      	subs	r4, r4, r6
   30128:	10a4      	asrs	r4, r4, #2
   3012a:	2500      	movs	r5, #0
   3012c:	42a5      	cmp	r5, r4
   3012e:	d109      	bne.n	30144 <__libc_init_array+0x24>
   30130:	4e0b      	ldr	r6, [pc, #44]	; (30160 <__libc_init_array+0x40>)
   30132:	4c0c      	ldr	r4, [pc, #48]	; (30164 <__libc_init_array+0x44>)
   30134:	f7d7 ff64 	bl	8000 <_init>
   30138:	1ba4      	subs	r4, r4, r6
   3013a:	10a4      	asrs	r4, r4, #2
   3013c:	2500      	movs	r5, #0
   3013e:	42a5      	cmp	r5, r4
   30140:	d105      	bne.n	3014e <__libc_init_array+0x2e>
   30142:	bd70      	pop	{r4, r5, r6, pc}
   30144:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   30148:	4798      	blx	r3
   3014a:	3501      	adds	r5, #1
   3014c:	e7ee      	b.n	3012c <__libc_init_array+0xc>
   3014e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   30152:	4798      	blx	r3
   30154:	3501      	adds	r5, #1
   30156:	e7f2      	b.n	3013e <__libc_init_array+0x1e>
   30158:	00065ffc 	.word	0x00065ffc
   3015c:	00065ffc 	.word	0x00065ffc
   30160:	00065ffc 	.word	0x00065ffc
   30164:	00066000 	.word	0x00066000

00030168 <__itoa>:
   30168:	1e93      	subs	r3, r2, #2
   3016a:	2b22      	cmp	r3, #34	; 0x22
   3016c:	b510      	push	{r4, lr}
   3016e:	460c      	mov	r4, r1
   30170:	d904      	bls.n	3017c <__itoa+0x14>
   30172:	2300      	movs	r3, #0
   30174:	700b      	strb	r3, [r1, #0]
   30176:	461c      	mov	r4, r3
   30178:	4620      	mov	r0, r4
   3017a:	bd10      	pop	{r4, pc}
   3017c:	2a0a      	cmp	r2, #10
   3017e:	d109      	bne.n	30194 <__itoa+0x2c>
   30180:	2800      	cmp	r0, #0
   30182:	da07      	bge.n	30194 <__itoa+0x2c>
   30184:	232d      	movs	r3, #45	; 0x2d
   30186:	700b      	strb	r3, [r1, #0]
   30188:	4240      	negs	r0, r0
   3018a:	2101      	movs	r1, #1
   3018c:	4421      	add	r1, r4
   3018e:	f000 f829 	bl	301e4 <__utoa>
   30192:	e7f1      	b.n	30178 <__itoa+0x10>
   30194:	2100      	movs	r1, #0
   30196:	e7f9      	b.n	3018c <__itoa+0x24>

00030198 <itoa>:
   30198:	f7ff bfe6 	b.w	30168 <__itoa>

0003019c <memcpy>:
   3019c:	b510      	push	{r4, lr}
   3019e:	1e43      	subs	r3, r0, #1
   301a0:	440a      	add	r2, r1
   301a2:	4291      	cmp	r1, r2
   301a4:	d100      	bne.n	301a8 <memcpy+0xc>
   301a6:	bd10      	pop	{r4, pc}
   301a8:	f811 4b01 	ldrb.w	r4, [r1], #1
   301ac:	f803 4f01 	strb.w	r4, [r3, #1]!
   301b0:	e7f7      	b.n	301a2 <memcpy+0x6>

000301b2 <memset>:
   301b2:	4402      	add	r2, r0
   301b4:	4603      	mov	r3, r0
   301b6:	4293      	cmp	r3, r2
   301b8:	d100      	bne.n	301bc <memset+0xa>
   301ba:	4770      	bx	lr
   301bc:	f803 1b01 	strb.w	r1, [r3], #1
   301c0:	e7f9      	b.n	301b6 <memset+0x4>

000301c2 <stpcpy>:
   301c2:	4603      	mov	r3, r0
   301c4:	f811 2b01 	ldrb.w	r2, [r1], #1
   301c8:	4618      	mov	r0, r3
   301ca:	f803 2b01 	strb.w	r2, [r3], #1
   301ce:	2a00      	cmp	r2, #0
   301d0:	d1f8      	bne.n	301c4 <stpcpy+0x2>
   301d2:	4770      	bx	lr

000301d4 <strlen>:
   301d4:	4603      	mov	r3, r0
   301d6:	f813 2b01 	ldrb.w	r2, [r3], #1
   301da:	2a00      	cmp	r2, #0
   301dc:	d1fb      	bne.n	301d6 <strlen+0x2>
   301de:	1a18      	subs	r0, r3, r0
   301e0:	3801      	subs	r0, #1
   301e2:	4770      	bx	lr

000301e4 <__utoa>:
   301e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   301e6:	4b1d      	ldr	r3, [pc, #116]	; (3025c <__utoa+0x78>)
   301e8:	b08b      	sub	sp, #44	; 0x2c
   301ea:	4605      	mov	r5, r0
   301ec:	460c      	mov	r4, r1
   301ee:	466e      	mov	r6, sp
   301f0:	f103 0c20 	add.w	ip, r3, #32
   301f4:	6818      	ldr	r0, [r3, #0]
   301f6:	6859      	ldr	r1, [r3, #4]
   301f8:	4637      	mov	r7, r6
   301fa:	c703      	stmia	r7!, {r0, r1}
   301fc:	3308      	adds	r3, #8
   301fe:	4563      	cmp	r3, ip
   30200:	463e      	mov	r6, r7
   30202:	d1f7      	bne.n	301f4 <__utoa+0x10>
   30204:	6818      	ldr	r0, [r3, #0]
   30206:	791b      	ldrb	r3, [r3, #4]
   30208:	713b      	strb	r3, [r7, #4]
   3020a:	1e93      	subs	r3, r2, #2
   3020c:	2b22      	cmp	r3, #34	; 0x22
   3020e:	6038      	str	r0, [r7, #0]
   30210:	f04f 0300 	mov.w	r3, #0
   30214:	d904      	bls.n	30220 <__utoa+0x3c>
   30216:	7023      	strb	r3, [r4, #0]
   30218:	461c      	mov	r4, r3
   3021a:	4620      	mov	r0, r4
   3021c:	b00b      	add	sp, #44	; 0x2c
   3021e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   30220:	1e66      	subs	r6, r4, #1
   30222:	fbb5 f0f2 	udiv	r0, r5, r2
   30226:	af0a      	add	r7, sp, #40	; 0x28
   30228:	fb02 5510 	mls	r5, r2, r0, r5
   3022c:	443d      	add	r5, r7
   3022e:	1c59      	adds	r1, r3, #1
   30230:	f815 5c28 	ldrb.w	r5, [r5, #-40]
   30234:	f806 5f01 	strb.w	r5, [r6, #1]!
   30238:	4605      	mov	r5, r0
   3023a:	b968      	cbnz	r0, 30258 <__utoa+0x74>
   3023c:	5460      	strb	r0, [r4, r1]
   3023e:	4423      	add	r3, r4
   30240:	4622      	mov	r2, r4
   30242:	1b19      	subs	r1, r3, r4
   30244:	1b10      	subs	r0, r2, r4
   30246:	4281      	cmp	r1, r0
   30248:	dde7      	ble.n	3021a <__utoa+0x36>
   3024a:	7811      	ldrb	r1, [r2, #0]
   3024c:	7818      	ldrb	r0, [r3, #0]
   3024e:	f802 0b01 	strb.w	r0, [r2], #1
   30252:	f803 1901 	strb.w	r1, [r3], #-1
   30256:	e7f4      	b.n	30242 <__utoa+0x5e>
   30258:	460b      	mov	r3, r1
   3025a:	e7e2      	b.n	30222 <__utoa+0x3e>
   3025c:	00055690 	.word	0x00055690

00030260 <atanf>:
   30260:	b538      	push	{r3, r4, r5, lr}
   30262:	ee10 5a10 	vmov	r5, s0
   30266:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
   3026a:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
   3026e:	eef0 7a40 	vmov.f32	s15, s0
   30272:	db0f      	blt.n	30294 <atanf+0x34>
   30274:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   30278:	dd04      	ble.n	30284 <atanf+0x24>
   3027a:	ee70 7a00 	vadd.f32	s15, s0, s0
   3027e:	eeb0 0a67 	vmov.f32	s0, s15
   30282:	bd38      	pop	{r3, r4, r5, pc}
   30284:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 303b8 <atanf+0x158>
   30288:	eddf 7a4c 	vldr	s15, [pc, #304]	; 303bc <atanf+0x15c>
   3028c:	2d00      	cmp	r5, #0
   3028e:	fe77 7a87 	vselgt.f32	s15, s15, s14
   30292:	e7f4      	b.n	3027e <atanf+0x1e>
   30294:	4b4a      	ldr	r3, [pc, #296]	; (303c0 <atanf+0x160>)
   30296:	429c      	cmp	r4, r3
   30298:	dc10      	bgt.n	302bc <atanf+0x5c>
   3029a:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
   3029e:	da0a      	bge.n	302b6 <atanf+0x56>
   302a0:	ed9f 7a48 	vldr	s14, [pc, #288]	; 303c4 <atanf+0x164>
   302a4:	ee30 7a07 	vadd.f32	s14, s0, s14
   302a8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   302ac:	eeb4 7ae6 	vcmpe.f32	s14, s13
   302b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   302b4:	dce3      	bgt.n	3027e <atanf+0x1e>
   302b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   302ba:	e013      	b.n	302e4 <atanf+0x84>
   302bc:	f000 f960 	bl	30580 <fabsf>
   302c0:	4b41      	ldr	r3, [pc, #260]	; (303c8 <atanf+0x168>)
   302c2:	429c      	cmp	r4, r3
   302c4:	dc4f      	bgt.n	30366 <atanf+0x106>
   302c6:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
   302ca:	429c      	cmp	r4, r3
   302cc:	dc41      	bgt.n	30352 <atanf+0xf2>
   302ce:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   302d2:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   302d6:	eea0 7a27 	vfma.f32	s14, s0, s15
   302da:	2300      	movs	r3, #0
   302dc:	ee30 0a27 	vadd.f32	s0, s0, s15
   302e0:	eec7 7a00 	vdiv.f32	s15, s14, s0
   302e4:	1c5a      	adds	r2, r3, #1
   302e6:	ee27 6aa7 	vmul.f32	s12, s15, s15
   302ea:	ed9f 7a38 	vldr	s14, [pc, #224]	; 303cc <atanf+0x16c>
   302ee:	eddf 5a38 	vldr	s11, [pc, #224]	; 303d0 <atanf+0x170>
   302f2:	ed9f 5a38 	vldr	s10, [pc, #224]	; 303d4 <atanf+0x174>
   302f6:	ee66 6a06 	vmul.f32	s13, s12, s12
   302fa:	eee6 5a87 	vfma.f32	s11, s13, s14
   302fe:	ed9f 7a36 	vldr	s14, [pc, #216]	; 303d8 <atanf+0x178>
   30302:	eea5 7aa6 	vfma.f32	s14, s11, s13
   30306:	eddf 5a35 	vldr	s11, [pc, #212]	; 303dc <atanf+0x17c>
   3030a:	eee7 5a26 	vfma.f32	s11, s14, s13
   3030e:	ed9f 7a34 	vldr	s14, [pc, #208]	; 303e0 <atanf+0x180>
   30312:	eea5 7aa6 	vfma.f32	s14, s11, s13
   30316:	eddf 5a33 	vldr	s11, [pc, #204]	; 303e4 <atanf+0x184>
   3031a:	eee7 5a26 	vfma.f32	s11, s14, s13
   3031e:	ed9f 7a32 	vldr	s14, [pc, #200]	; 303e8 <atanf+0x188>
   30322:	eea6 5a87 	vfma.f32	s10, s13, s14
   30326:	ed9f 7a31 	vldr	s14, [pc, #196]	; 303ec <atanf+0x18c>
   3032a:	eea5 7a26 	vfma.f32	s14, s10, s13
   3032e:	ed9f 5a30 	vldr	s10, [pc, #192]	; 303f0 <atanf+0x190>
   30332:	eea7 5a26 	vfma.f32	s10, s14, s13
   30336:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 303f4 <atanf+0x194>
   3033a:	eea5 7a26 	vfma.f32	s14, s10, s13
   3033e:	ee27 7a26 	vmul.f32	s14, s14, s13
   30342:	eea5 7a86 	vfma.f32	s14, s11, s12
   30346:	ee27 7a27 	vmul.f32	s14, s14, s15
   3034a:	d121      	bne.n	30390 <atanf+0x130>
   3034c:	ee77 7ac7 	vsub.f32	s15, s15, s14
   30350:	e795      	b.n	3027e <atanf+0x1e>
   30352:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   30356:	ee30 7a67 	vsub.f32	s14, s0, s15
   3035a:	ee30 0a27 	vadd.f32	s0, s0, s15
   3035e:	2301      	movs	r3, #1
   30360:	eec7 7a00 	vdiv.f32	s15, s14, s0
   30364:	e7be      	b.n	302e4 <atanf+0x84>
   30366:	4b24      	ldr	r3, [pc, #144]	; (303f8 <atanf+0x198>)
   30368:	429c      	cmp	r4, r3
   3036a:	dc0b      	bgt.n	30384 <atanf+0x124>
   3036c:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
   30370:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   30374:	eea0 7a27 	vfma.f32	s14, s0, s15
   30378:	2302      	movs	r3, #2
   3037a:	ee70 6a67 	vsub.f32	s13, s0, s15
   3037e:	eec6 7a87 	vdiv.f32	s15, s13, s14
   30382:	e7af      	b.n	302e4 <atanf+0x84>
   30384:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   30388:	eec7 7a00 	vdiv.f32	s15, s14, s0
   3038c:	2303      	movs	r3, #3
   3038e:	e7a9      	b.n	302e4 <atanf+0x84>
   30390:	4a1a      	ldr	r2, [pc, #104]	; (303fc <atanf+0x19c>)
   30392:	491b      	ldr	r1, [pc, #108]	; (30400 <atanf+0x1a0>)
   30394:	009b      	lsls	r3, r3, #2
   30396:	441a      	add	r2, r3
   30398:	440b      	add	r3, r1
   3039a:	edd3 6a00 	vldr	s13, [r3]
   3039e:	ee37 7a66 	vsub.f32	s14, s14, s13
   303a2:	2d00      	cmp	r5, #0
   303a4:	ee77 7a67 	vsub.f32	s15, s14, s15
   303a8:	ed92 7a00 	vldr	s14, [r2]
   303ac:	ee77 7a67 	vsub.f32	s15, s14, s15
   303b0:	bfb8      	it	lt
   303b2:	eef1 7a67 	vneglt.f32	s15, s15
   303b6:	e762      	b.n	3027e <atanf+0x1e>
   303b8:	bfc90fdb 	.word	0xbfc90fdb
   303bc:	3fc90fdb 	.word	0x3fc90fdb
   303c0:	3edfffff 	.word	0x3edfffff
   303c4:	7149f2ca 	.word	0x7149f2ca
   303c8:	3f97ffff 	.word	0x3f97ffff
   303cc:	3c8569d7 	.word	0x3c8569d7
   303d0:	3d4bda59 	.word	0x3d4bda59
   303d4:	bd6ef16b 	.word	0xbd6ef16b
   303d8:	3d886b35 	.word	0x3d886b35
   303dc:	3dba2e6e 	.word	0x3dba2e6e
   303e0:	3e124925 	.word	0x3e124925
   303e4:	3eaaaaab 	.word	0x3eaaaaab
   303e8:	bd15a221 	.word	0xbd15a221
   303ec:	bd9d8795 	.word	0xbd9d8795
   303f0:	bde38e38 	.word	0xbde38e38
   303f4:	be4ccccd 	.word	0xbe4ccccd
   303f8:	401bffff 	.word	0x401bffff
   303fc:	000556b8 	.word	0x000556b8
   30400:	000556c8 	.word	0x000556c8

00030404 <cosf>:
   30404:	ee10 3a10 	vmov	r3, s0
   30408:	b507      	push	{r0, r1, r2, lr}
   3040a:	4a1c      	ldr	r2, [pc, #112]	; (3047c <cosf+0x78>)
   3040c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   30410:	4293      	cmp	r3, r2
   30412:	dc04      	bgt.n	3041e <cosf+0x1a>
   30414:	eddf 0a1a 	vldr	s1, [pc, #104]	; 30480 <cosf+0x7c>
   30418:	f001 fd40 	bl	31e9c <__kernel_cosf>
   3041c:	e004      	b.n	30428 <cosf+0x24>
   3041e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   30422:	db04      	blt.n	3042e <cosf+0x2a>
   30424:	ee30 0a40 	vsub.f32	s0, s0, s0
   30428:	b003      	add	sp, #12
   3042a:	f85d fb04 	ldr.w	pc, [sp], #4
   3042e:	4668      	mov	r0, sp
   30430:	f001 fb9a 	bl	31b68 <__ieee754_rem_pio2f>
   30434:	f000 0003 	and.w	r0, r0, #3
   30438:	2801      	cmp	r0, #1
   3043a:	d007      	beq.n	3044c <cosf+0x48>
   3043c:	2802      	cmp	r0, #2
   3043e:	d00e      	beq.n	3045e <cosf+0x5a>
   30440:	b9a0      	cbnz	r0, 3046c <cosf+0x68>
   30442:	eddd 0a01 	vldr	s1, [sp, #4]
   30446:	ed9d 0a00 	vldr	s0, [sp]
   3044a:	e7e5      	b.n	30418 <cosf+0x14>
   3044c:	eddd 0a01 	vldr	s1, [sp, #4]
   30450:	ed9d 0a00 	vldr	s0, [sp]
   30454:	f002 f802 	bl	3245c <__kernel_sinf>
   30458:	eeb1 0a40 	vneg.f32	s0, s0
   3045c:	e7e4      	b.n	30428 <cosf+0x24>
   3045e:	eddd 0a01 	vldr	s1, [sp, #4]
   30462:	ed9d 0a00 	vldr	s0, [sp]
   30466:	f001 fd19 	bl	31e9c <__kernel_cosf>
   3046a:	e7f5      	b.n	30458 <cosf+0x54>
   3046c:	2001      	movs	r0, #1
   3046e:	eddd 0a01 	vldr	s1, [sp, #4]
   30472:	ed9d 0a00 	vldr	s0, [sp]
   30476:	f001 fff1 	bl	3245c <__kernel_sinf>
   3047a:	e7d5      	b.n	30428 <cosf+0x24>
   3047c:	3f490fd8 	.word	0x3f490fd8
   30480:	00000000 	.word	0x00000000

00030484 <expf>:
   30484:	ee10 2a10 	vmov	r2, s0
   30488:	f240 412a 	movw	r1, #1066	; 0x42a
   3048c:	f3c2 530a 	ubfx	r3, r2, #20, #11
   30490:	428b      	cmp	r3, r1
   30492:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
   30496:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
   3049a:	d92e      	bls.n	304fa <expf+0x76>
   3049c:	f512 0f00 	cmn.w	r2, #8388608	; 0x800000
   304a0:	d061      	beq.n	30566 <expf+0xe2>
   304a2:	f5b3 6fff 	cmp.w	r3, #2040	; 0x7f8
   304a6:	d304      	bcc.n	304b2 <expf+0x2e>
   304a8:	ee30 0a00 	vadd.f32	s0, s0, s0
   304ac:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   304b0:	4770      	bx	lr
   304b2:	eddf 7a2e 	vldr	s15, [pc, #184]	; 3056c <expf+0xe8>
   304b6:	eeb4 0ae7 	vcmpe.f32	s0, s15
   304ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   304be:	dd04      	ble.n	304ca <expf+0x46>
   304c0:	2000      	movs	r0, #0
   304c2:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   304c6:	f002 b91b 	b.w	32700 <__math_oflowf>
   304ca:	eddf 7a29 	vldr	s15, [pc, #164]	; 30570 <expf+0xec>
   304ce:	eeb4 0ae7 	vcmpe.f32	s0, s15
   304d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   304d6:	d504      	bpl.n	304e2 <expf+0x5e>
   304d8:	2000      	movs	r0, #0
   304da:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   304de:	f002 b903 	b.w	326e8 <__math_uflowf>
   304e2:	eddf 7a24 	vldr	s15, [pc, #144]	; 30574 <expf+0xf0>
   304e6:	eeb4 0ae7 	vcmpe.f32	s0, s15
   304ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   304ee:	d504      	bpl.n	304fa <expf+0x76>
   304f0:	2000      	movs	r0, #0
   304f2:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   304f6:	f002 b8fd 	b.w	326f4 <__math_may_uflowf>
   304fa:	491f      	ldr	r1, [pc, #124]	; (30578 <expf+0xf4>)
   304fc:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
   30500:	ed91 5b4a 	vldr	d5, [r1, #296]	; 0x128
   30504:	ed91 7b48 	vldr	d7, [r1, #288]	; 0x120
   30508:	eeb0 4b47 	vmov.f64	d4, d7
   3050c:	eea5 4b06 	vfma.f64	d4, d5, d6
   30510:	ec55 4b14 	vmov	r4, r5, d4
   30514:	ee34 7b47 	vsub.f64	d7, d4, d7
   30518:	f004 021f 	and.w	r2, r4, #31
   3051c:	ee95 7b06 	vfnms.f64	d7, d5, d6
   30520:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   30524:	ed91 6b50 	vldr	d6, [r1, #320]	; 0x140
   30528:	e9d2 4500 	ldrd	r4, r5, [r2]
   3052c:	eea6 0b07 	vfma.f64	d0, d6, d7
   30530:	ee14 0a10 	vmov	r0, s8
   30534:	ed91 5b4c 	vldr	d5, [r1, #304]	; 0x130
   30538:	ed91 6b4e 	vldr	d6, [r1, #312]	; 0x138
   3053c:	f04f 0b00 	mov.w	fp, #0
   30540:	eb1b 0204 	adds.w	r2, fp, r4
   30544:	ea4f 3cc0 	mov.w	ip, r0, lsl #15
   30548:	eb4c 0305 	adc.w	r3, ip, r5
   3054c:	eea5 6b07 	vfma.f64	d6, d5, d7
   30550:	ee27 7b07 	vmul.f64	d7, d7, d7
   30554:	eea6 0b07 	vfma.f64	d0, d6, d7
   30558:	ec43 2b17 	vmov	d7, r2, r3
   3055c:	ee20 0b07 	vmul.f64	d0, d0, d7
   30560:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   30564:	e7a2      	b.n	304ac <expf+0x28>
   30566:	ed9f 0a05 	vldr	s0, [pc, #20]	; 3057c <expf+0xf8>
   3056a:	e79f      	b.n	304ac <expf+0x28>
   3056c:	42b17217 	.word	0x42b17217
   30570:	c2cff1b4 	.word	0xc2cff1b4
   30574:	c2ce8ecf 	.word	0xc2ce8ecf
   30578:	000556d8 	.word	0x000556d8
   3057c:	00000000 	.word	0x00000000

00030580 <fabsf>:
   30580:	ee10 3a10 	vmov	r3, s0
   30584:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   30588:	ee00 3a10 	vmov	s0, r3
   3058c:	4770      	bx	lr
	...

00030590 <logf>:
   30590:	ee10 3a10 	vmov	r3, s0
   30594:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   30598:	b410      	push	{r4}
   3059a:	d057      	beq.n	3064c <logf+0xbc>
   3059c:	f5a3 0200 	sub.w	r2, r3, #8388608	; 0x800000
   305a0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   305a4:	d31a      	bcc.n	305dc <logf+0x4c>
   305a6:	005a      	lsls	r2, r3, #1
   305a8:	d104      	bne.n	305b4 <logf+0x24>
   305aa:	2001      	movs	r0, #1
   305ac:	f85d 4b04 	ldr.w	r4, [sp], #4
   305b0:	f002 b8ac 	b.w	3270c <__math_divzerof>
   305b4:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   305b8:	d045      	beq.n	30646 <logf+0xb6>
   305ba:	2b00      	cmp	r3, #0
   305bc:	db02      	blt.n	305c4 <logf+0x34>
   305be:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
   305c2:	d303      	bcc.n	305cc <logf+0x3c>
   305c4:	f85d 4b04 	ldr.w	r4, [sp], #4
   305c8:	f002 b8b0 	b.w	3272c <__math_invalidf>
   305cc:	eddf 7a21 	vldr	s15, [pc, #132]	; 30654 <logf+0xc4>
   305d0:	ee20 0a27 	vmul.f32	s0, s0, s15
   305d4:	ee10 3a10 	vmov	r3, s0
   305d8:	f1a3 6338 	sub.w	r3, r3, #192937984	; 0xb800000
   305dc:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
   305e0:	491d      	ldr	r1, [pc, #116]	; (30658 <logf+0xc8>)
   305e2:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   305e6:	f502 024d 	add.w	r2, r2, #13434880	; 0xcd0000
   305ea:	f3c2 40c3 	ubfx	r0, r2, #19, #4
   305ee:	0dd4      	lsrs	r4, r2, #23
   305f0:	eb01 1000 	add.w	r0, r1, r0, lsl #4
   305f4:	05e4      	lsls	r4, r4, #23
   305f6:	ed90 5b00 	vldr	d5, [r0]
   305fa:	1b1b      	subs	r3, r3, r4
   305fc:	ee07 3a90 	vmov	s15, r3
   30600:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   30604:	eea5 6b07 	vfma.f64	d6, d5, d7
   30608:	ed91 5b44 	vldr	d5, [r1, #272]	; 0x110
   3060c:	ee26 3b06 	vmul.f64	d3, d6, d6
   30610:	ed91 7b46 	vldr	d7, [r1, #280]	; 0x118
   30614:	eea5 7b06 	vfma.f64	d7, d5, d6
   30618:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
   3061c:	15d2      	asrs	r2, r2, #23
   3061e:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
   30622:	eea5 7b03 	vfma.f64	d7, d5, d3
   30626:	eeb0 5b47 	vmov.f64	d5, d7
   3062a:	ed90 0b02 	vldr	d0, [r0, #8]
   3062e:	ee07 2a90 	vmov	s15, r2
   30632:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   30636:	eea7 0b04 	vfma.f64	d0, d7, d4
   3063a:	ee30 0b06 	vadd.f64	d0, d0, d6
   3063e:	eea3 0b05 	vfma.f64	d0, d3, d5
   30642:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   30646:	f85d 4b04 	ldr.w	r4, [sp], #4
   3064a:	4770      	bx	lr
   3064c:	ed9f 0a03 	vldr	s0, [pc, #12]	; 3065c <logf+0xcc>
   30650:	e7f9      	b.n	30646 <logf+0xb6>
   30652:	bf00      	nop
   30654:	4b000000 	.word	0x4b000000
   30658:	00055940 	.word	0x00055940
   3065c:	00000000 	.word	0x00000000

00030660 <log2f>:
   30660:	ee10 2a10 	vmov	r2, s0
   30664:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
   30668:	b410      	push	{r4}
   3066a:	d057      	beq.n	3071c <log2f+0xbc>
   3066c:	f5a2 0300 	sub.w	r3, r2, #8388608	; 0x800000
   30670:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   30674:	d31a      	bcc.n	306ac <log2f+0x4c>
   30676:	0053      	lsls	r3, r2, #1
   30678:	d104      	bne.n	30684 <log2f+0x24>
   3067a:	2001      	movs	r0, #1
   3067c:	f85d 4b04 	ldr.w	r4, [sp], #4
   30680:	f002 b844 	b.w	3270c <__math_divzerof>
   30684:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   30688:	d045      	beq.n	30716 <log2f+0xb6>
   3068a:	2a00      	cmp	r2, #0
   3068c:	db02      	blt.n	30694 <log2f+0x34>
   3068e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   30692:	d303      	bcc.n	3069c <log2f+0x3c>
   30694:	f85d 4b04 	ldr.w	r4, [sp], #4
   30698:	f002 b848 	b.w	3272c <__math_invalidf>
   3069c:	eddf 7a21 	vldr	s15, [pc, #132]	; 30724 <log2f+0xc4>
   306a0:	ee20 0a27 	vmul.f32	s0, s0, s15
   306a4:	ee10 3a10 	vmov	r3, s0
   306a8:	f1a3 6238 	sub.w	r2, r3, #192937984	; 0xb800000
   306ac:	f102 4340 	add.w	r3, r2, #3221225472	; 0xc0000000
   306b0:	491d      	ldr	r1, [pc, #116]	; (30728 <log2f+0xc8>)
   306b2:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   306b6:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
   306ba:	f3c3 40c3 	ubfx	r0, r3, #19, #4
   306be:	0ddc      	lsrs	r4, r3, #23
   306c0:	eb01 1000 	add.w	r0, r1, r0, lsl #4
   306c4:	05e4      	lsls	r4, r4, #23
   306c6:	ed90 5b00 	vldr	d5, [r0]
   306ca:	1b12      	subs	r2, r2, r4
   306cc:	ee07 2a90 	vmov	s15, r2
   306d0:	ed91 4b42 	vldr	d4, [r1, #264]	; 0x108
   306d4:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   306d8:	eea5 6b07 	vfma.f64	d6, d5, d7
   306dc:	eeb0 7b46 	vmov.f64	d7, d6
   306e0:	ee26 5b06 	vmul.f64	d5, d6, d6
   306e4:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
   306e8:	eea4 6b07 	vfma.f64	d6, d4, d7
   306ec:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
   306f0:	15db      	asrs	r3, r3, #23
   306f2:	eea4 6b05 	vfma.f64	d6, d4, d5
   306f6:	ed90 4b02 	vldr	d4, [r0, #8]
   306fa:	ee00 3a10 	vmov	s0, r3
   306fe:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
   30702:	ee30 0b04 	vadd.f64	d0, d0, d4
   30706:	ed91 4b46 	vldr	d4, [r1, #280]	; 0x118
   3070a:	eea4 0b07 	vfma.f64	d0, d4, d7
   3070e:	eea5 0b06 	vfma.f64	d0, d5, d6
   30712:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   30716:	f85d 4b04 	ldr.w	r4, [sp], #4
   3071a:	4770      	bx	lr
   3071c:	ed9f 0a03 	vldr	s0, [pc, #12]	; 3072c <log2f+0xcc>
   30720:	e7f9      	b.n	30716 <log2f+0xb6>
   30722:	bf00      	nop
   30724:	4b000000 	.word	0x4b000000
   30728:	00055820 	.word	0x00055820
   3072c:	00000000 	.word	0x00000000

00030730 <checkint>:
   30730:	f3c0 53c7 	ubfx	r3, r0, #23, #8
   30734:	2b7e      	cmp	r3, #126	; 0x7e
   30736:	dd10      	ble.n	3075a <checkint+0x2a>
   30738:	2b96      	cmp	r3, #150	; 0x96
   3073a:	dc0c      	bgt.n	30756 <checkint+0x26>
   3073c:	2201      	movs	r2, #1
   3073e:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
   30742:	fa02 f303 	lsl.w	r3, r2, r3
   30746:	1e5a      	subs	r2, r3, #1
   30748:	4202      	tst	r2, r0
   3074a:	d106      	bne.n	3075a <checkint+0x2a>
   3074c:	4203      	tst	r3, r0
   3074e:	bf0c      	ite	eq
   30750:	2002      	moveq	r0, #2
   30752:	2001      	movne	r0, #1
   30754:	4770      	bx	lr
   30756:	2002      	movs	r0, #2
   30758:	4770      	bx	lr
   3075a:	2000      	movs	r0, #0
   3075c:	4770      	bx	lr
	...

00030760 <powf>:
   30760:	ee10 1a10 	vmov	r1, s0
   30764:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   30768:	ee10 4a90 	vmov	r4, s1
   3076c:	f5a1 0300 	sub.w	r3, r1, #8388608	; 0x800000
   30770:	0062      	lsls	r2, r4, #1
   30772:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   30776:	eef0 4a60 	vmov.f32	s9, s1
   3077a:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
   3077e:	4b92      	ldr	r3, [pc, #584]	; (309c8 <powf+0x268>)
   30780:	d255      	bcs.n	3082e <powf+0xce>
   30782:	4298      	cmp	r0, r3
   30784:	d855      	bhi.n	30832 <powf+0xd2>
   30786:	2000      	movs	r0, #0
   30788:	f101 4340 	add.w	r3, r1, #3221225472	; 0xc0000000
   3078c:	4a8f      	ldr	r2, [pc, #572]	; (309cc <powf+0x26c>)
   3078e:	eebf 2b00 	vmov.f64	d2, #240	; 0xbf800000 -1.0
   30792:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
   30796:	f3c3 44c3 	ubfx	r4, r3, #19, #4
   3079a:	0ddb      	lsrs	r3, r3, #23
   3079c:	eb02 1404 	add.w	r4, r2, r4, lsl #4
   307a0:	05db      	lsls	r3, r3, #23
   307a2:	ed94 6b00 	vldr	d6, [r4]
   307a6:	1ac9      	subs	r1, r1, r3
   307a8:	ee07 1a90 	vmov	s15, r1
   307ac:	ed92 5b40 	vldr	d5, [r2, #256]	; 0x100
   307b0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   307b4:	eea6 2b07 	vfma.f64	d2, d6, d7
   307b8:	ed92 7b42 	vldr	d7, [r2, #264]	; 0x108
   307bc:	ee22 6b02 	vmul.f64	d6, d2, d2
   307c0:	eea2 7b05 	vfma.f64	d7, d2, d5
   307c4:	15db      	asrs	r3, r3, #23
   307c6:	ed94 5b02 	vldr	d5, [r4, #8]
   307ca:	ee00 3a10 	vmov	s0, r3
   307ce:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
   307d2:	ee30 0b05 	vadd.f64	d0, d0, d5
   307d6:	ed92 5b48 	vldr	d5, [r2, #288]	; 0x120
   307da:	ed92 3b44 	vldr	d3, [r2, #272]	; 0x110
   307de:	eea2 0b05 	vfma.f64	d0, d2, d5
   307e2:	ed92 5b46 	vldr	d5, [r2, #280]	; 0x118
   307e6:	eea2 5b03 	vfma.f64	d5, d2, d3
   307ea:	eea6 0b05 	vfma.f64	d0, d6, d5
   307ee:	ee26 6b06 	vmul.f64	d6, d6, d6
   307f2:	eea7 0b06 	vfma.f64	d0, d7, d6
   307f6:	eeb7 7ae4 	vcvt.f64.f32	d7, s9
   307fa:	ee20 0b07 	vmul.f64	d0, d0, d7
   307fe:	ee10 3a90 	vmov	r3, s1
   30802:	2500      	movs	r5, #0
   30804:	0bda      	lsrs	r2, r3, #15
   30806:	2300      	movs	r3, #0
   30808:	b292      	uxth	r2, r2
   3080a:	f248 04be 	movw	r4, #32958	; 0x80be
   3080e:	429d      	cmp	r5, r3
   30810:	bf08      	it	eq
   30812:	4294      	cmpeq	r4, r2
   30814:	f080 8094 	bcs.w	30940 <powf+0x1e0>
   30818:	ed9f 7b65 	vldr	d7, [pc, #404]	; 309b0 <powf+0x250>
   3081c:	eeb4 0bc7 	vcmpe.f64	d0, d7
   30820:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30824:	dd76      	ble.n	30914 <powf+0x1b4>
   30826:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   3082a:	f001 bf69 	b.w	32700 <__math_oflowf>
   3082e:	4298      	cmp	r0, r3
   30830:	d92d      	bls.n	3088e <powf+0x12e>
   30832:	b952      	cbnz	r2, 3084a <powf+0xea>
   30834:	f481 0380 	eor.w	r3, r1, #4194304	; 0x400000
   30838:	005b      	lsls	r3, r3, #1
   3083a:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   3083e:	f240 80ae 	bls.w	3099e <powf+0x23e>
   30842:	ee30 0a24 	vadd.f32	s0, s0, s9
   30846:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   3084a:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
   3084e:	d105      	bne.n	3085c <powf+0xfc>
   30850:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
   30854:	0064      	lsls	r4, r4, #1
   30856:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
   3085a:	e7f0      	b.n	3083e <powf+0xde>
   3085c:	004b      	lsls	r3, r1, #1
   3085e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   30862:	d8ee      	bhi.n	30842 <powf+0xe2>
   30864:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
   30868:	d1eb      	bne.n	30842 <powf+0xe2>
   3086a:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   3086e:	f000 8096 	beq.w	3099e <powf+0x23e>
   30872:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   30876:	ea6f 0404 	mvn.w	r4, r4
   3087a:	bf34      	ite	cc
   3087c:	2300      	movcc	r3, #0
   3087e:	2301      	movcs	r3, #1
   30880:	0fe4      	lsrs	r4, r4, #31
   30882:	42a3      	cmp	r3, r4
   30884:	f040 808e 	bne.w	309a4 <powf+0x244>
   30888:	ee24 0aa4 	vmul.f32	s0, s9, s9
   3088c:	e7db      	b.n	30846 <powf+0xe6>
   3088e:	004d      	lsls	r5, r1, #1
   30890:	1e6a      	subs	r2, r5, #1
   30892:	429a      	cmp	r2, r3
   30894:	d91b      	bls.n	308ce <powf+0x16e>
   30896:	2900      	cmp	r1, #0
   30898:	ee20 0a00 	vmul.f32	s0, s0, s0
   3089c:	da0e      	bge.n	308bc <powf+0x15c>
   3089e:	ee10 0a90 	vmov	r0, s1
   308a2:	f7ff ff45 	bl	30730 <checkint>
   308a6:	2801      	cmp	r0, #1
   308a8:	d108      	bne.n	308bc <powf+0x15c>
   308aa:	eeb1 0a40 	vneg.f32	s0, s0
   308ae:	b93d      	cbnz	r5, 308c0 <powf+0x160>
   308b0:	2c00      	cmp	r4, #0
   308b2:	dac8      	bge.n	30846 <powf+0xe6>
   308b4:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   308b8:	f001 bf28 	b.w	3270c <__math_divzerof>
   308bc:	2000      	movs	r0, #0
   308be:	e7f6      	b.n	308ae <powf+0x14e>
   308c0:	2c00      	cmp	r4, #0
   308c2:	dac0      	bge.n	30846 <powf+0xe6>
   308c4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   308c8:	ee87 0a80 	vdiv.f32	s0, s15, s0
   308cc:	e7bb      	b.n	30846 <powf+0xe6>
   308ce:	2900      	cmp	r1, #0
   308d0:	da1e      	bge.n	30910 <powf+0x1b0>
   308d2:	ee10 0a90 	vmov	r0, s1
   308d6:	f7ff ff2b 	bl	30730 <checkint>
   308da:	b918      	cbnz	r0, 308e4 <powf+0x184>
   308dc:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   308e0:	f001 bf24 	b.w	3272c <__math_invalidf>
   308e4:	2801      	cmp	r0, #1
   308e6:	bf0c      	ite	eq
   308e8:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   308ec:	2000      	movne	r0, #0
   308ee:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   308f2:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   308f6:	f4bf af47 	bcs.w	30788 <powf+0x28>
   308fa:	eddf 0a35 	vldr	s1, [pc, #212]	; 309d0 <powf+0x270>
   308fe:	ee20 0a20 	vmul.f32	s0, s0, s1
   30902:	ee10 3a10 	vmov	r3, s0
   30906:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3090a:	f1a3 6138 	sub.w	r1, r3, #192937984	; 0xb800000
   3090e:	e73b      	b.n	30788 <powf+0x28>
   30910:	2000      	movs	r0, #0
   30912:	e7ee      	b.n	308f2 <powf+0x192>
   30914:	ed9f 7b28 	vldr	d7, [pc, #160]	; 309b8 <powf+0x258>
   30918:	eeb4 0bc7 	vcmpe.f64	d0, d7
   3091c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30920:	d803      	bhi.n	3092a <powf+0x1ca>
   30922:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   30926:	f001 bedf 	b.w	326e8 <__math_uflowf>
   3092a:	ed9f 7b25 	vldr	d7, [pc, #148]	; 309c0 <powf+0x260>
   3092e:	eeb4 0bc7 	vcmpe.f64	d0, d7
   30932:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30936:	d503      	bpl.n	30940 <powf+0x1e0>
   30938:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   3093c:	f001 beda 	b.w	326f4 <__math_may_uflowf>
   30940:	4924      	ldr	r1, [pc, #144]	; (309d4 <powf+0x274>)
   30942:	ed91 7b40 	vldr	d7, [r1, #256]	; 0x100
   30946:	ee30 6b07 	vadd.f64	d6, d0, d7
   3094a:	ec55 4b16 	vmov	r4, r5, d6
   3094e:	ee36 7b47 	vsub.f64	d7, d6, d7
   30952:	f004 021f 	and.w	r2, r4, #31
   30956:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   3095a:	ed91 6b46 	vldr	d6, [r1, #280]	; 0x118
   3095e:	ee30 0b47 	vsub.f64	d0, d0, d7
   30962:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   30966:	e9d2 6700 	ldrd	r6, r7, [r2]
   3096a:	eea0 7b06 	vfma.f64	d7, d0, d6
   3096e:	1824      	adds	r4, r4, r0
   30970:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
   30974:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
   30978:	2000      	movs	r0, #0
   3097a:	1982      	adds	r2, r0, r6
   3097c:	ea4f 31c4 	mov.w	r1, r4, lsl #15
   30980:	eb41 0307 	adc.w	r3, r1, r7
   30984:	eea0 6b05 	vfma.f64	d6, d0, d5
   30988:	ee20 0b00 	vmul.f64	d0, d0, d0
   3098c:	eea6 7b00 	vfma.f64	d7, d6, d0
   30990:	ec43 2b16 	vmov	d6, r2, r3
   30994:	ee27 0b06 	vmul.f64	d0, d7, d6
   30998:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   3099c:	e753      	b.n	30846 <powf+0xe6>
   3099e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   309a2:	e750      	b.n	30846 <powf+0xe6>
   309a4:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 309d8 <powf+0x278>
   309a8:	e74d      	b.n	30846 <powf+0xe6>
   309aa:	bf00      	nop
   309ac:	f3af 8000 	nop.w
   309b0:	ffd1d571 	.word	0xffd1d571
   309b4:	405fffff 	.word	0x405fffff
   309b8:	00000000 	.word	0x00000000
   309bc:	c062c000 	.word	0xc062c000
   309c0:	00000000 	.word	0x00000000
   309c4:	c062a000 	.word	0xc062a000
   309c8:	fefffffe 	.word	0xfefffffe
   309cc:	00055a60 	.word	0x00055a60
   309d0:	4b000000 	.word	0x4b000000
   309d4:	000556d8 	.word	0x000556d8
   309d8:	00000000 	.word	0x00000000

000309dc <tanf>:
   309dc:	ee10 3a10 	vmov	r3, s0
   309e0:	b507      	push	{r0, r1, r2, lr}
   309e2:	4a10      	ldr	r2, [pc, #64]	; (30a24 <tanf+0x48>)
   309e4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   309e8:	4293      	cmp	r3, r2
   309ea:	dc05      	bgt.n	309f8 <tanf+0x1c>
   309ec:	eddf 0a0e 	vldr	s1, [pc, #56]	; 30a28 <tanf+0x4c>
   309f0:	2001      	movs	r0, #1
   309f2:	f001 fd7b 	bl	324ec <__kernel_tanf>
   309f6:	e004      	b.n	30a02 <tanf+0x26>
   309f8:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   309fc:	db04      	blt.n	30a08 <tanf+0x2c>
   309fe:	ee30 0a40 	vsub.f32	s0, s0, s0
   30a02:	b003      	add	sp, #12
   30a04:	f85d fb04 	ldr.w	pc, [sp], #4
   30a08:	4668      	mov	r0, sp
   30a0a:	f001 f8ad 	bl	31b68 <__ieee754_rem_pio2f>
   30a0e:	0040      	lsls	r0, r0, #1
   30a10:	f000 0002 	and.w	r0, r0, #2
   30a14:	f1c0 0001 	rsb	r0, r0, #1
   30a18:	eddd 0a01 	vldr	s1, [sp, #4]
   30a1c:	ed9d 0a00 	vldr	s0, [sp]
   30a20:	e7e7      	b.n	309f2 <tanf+0x16>
   30a22:	bf00      	nop
   30a24:	3f490fda 	.word	0x3f490fda
   30a28:	00000000 	.word	0x00000000

00030a2c <tanhf>:
   30a2c:	b510      	push	{r4, lr}
   30a2e:	ee10 4a10 	vmov	r4, s0
   30a32:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
   30a36:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   30a3a:	ed2d 8b02 	vpush	{d8}
   30a3e:	eef0 7a40 	vmov.f32	s15, s0
   30a42:	db0c      	blt.n	30a5e <tanhf+0x32>
   30a44:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   30a48:	ee87 0a27 	vdiv.f32	s0, s14, s15
   30a4c:	2c00      	cmp	r4, #0
   30a4e:	bfac      	ite	ge
   30a50:	ee30 0a07 	vaddge.f32	s0, s0, s14
   30a54:	ee30 0a47 	vsublt.f32	s0, s0, s14
   30a58:	ecbd 8b02 	vpop	{d8}
   30a5c:	bd10      	pop	{r4, pc}
   30a5e:	4a1b      	ldr	r2, [pc, #108]	; (30acc <tanhf+0xa0>)
   30a60:	4293      	cmp	r3, r2
   30a62:	dc30      	bgt.n	30ac6 <tanhf+0x9a>
   30a64:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
   30a68:	da06      	bge.n	30a78 <tanhf+0x4c>
   30a6a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30a6e:	ee37 0a80 	vadd.f32	s0, s15, s0
   30a72:	ee20 0a27 	vmul.f32	s0, s0, s15
   30a76:	e7ef      	b.n	30a58 <tanhf+0x2c>
   30a78:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   30a7c:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
   30a80:	db12      	blt.n	30aa8 <tanhf+0x7c>
   30a82:	f7ff fd7d 	bl	30580 <fabsf>
   30a86:	ee30 0a00 	vadd.f32	s0, s0, s0
   30a8a:	f001 ff83 	bl	32994 <expm1f>
   30a8e:	ee30 0a08 	vadd.f32	s0, s0, s16
   30a92:	eec8 7a00 	vdiv.f32	s15, s16, s0
   30a96:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30a9a:	ee30 0a67 	vsub.f32	s0, s0, s15
   30a9e:	2c00      	cmp	r4, #0
   30aa0:	bfb8      	it	lt
   30aa2:	eeb1 0a40 	vneglt.f32	s0, s0
   30aa6:	e7d7      	b.n	30a58 <tanhf+0x2c>
   30aa8:	f7ff fd6a 	bl	30580 <fabsf>
   30aac:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
   30ab0:	ee20 0a27 	vmul.f32	s0, s0, s15
   30ab4:	f001 ff6e 	bl	32994 <expm1f>
   30ab8:	ee70 7a08 	vadd.f32	s15, s0, s16
   30abc:	eeb1 7a40 	vneg.f32	s14, s0
   30ac0:	ee87 0a27 	vdiv.f32	s0, s14, s15
   30ac4:	e7eb      	b.n	30a9e <tanhf+0x72>
   30ac6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30aca:	e7e8      	b.n	30a9e <tanhf+0x72>
   30acc:	41afffff 	.word	0x41afffff

00030ad0 <exp>:
   30ad0:	b510      	push	{r4, lr}
   30ad2:	ed2d 8b04 	vpush	{d8-d9}
   30ad6:	eeb0 8b40 	vmov.f64	d8, d0
   30ada:	4c33      	ldr	r4, [pc, #204]	; (30ba8 <exp+0xd8>)
   30adc:	b08a      	sub	sp, #40	; 0x28
   30ade:	f000 fad3 	bl	31088 <__ieee754_exp>
   30ae2:	f994 3000 	ldrsb.w	r3, [r4]
   30ae6:	eeb0 9b40 	vmov.f64	d9, d0
   30aea:	3301      	adds	r3, #1
   30aec:	d029      	beq.n	30b42 <exp+0x72>
   30aee:	eeb0 0b48 	vmov.f64	d0, d8
   30af2:	f001 fe33 	bl	3275c <finite>
   30af6:	b320      	cbz	r0, 30b42 <exp+0x72>
   30af8:	ed9f 7b27 	vldr	d7, [pc, #156]	; 30b98 <exp+0xc8>
   30afc:	eeb4 8bc7 	vcmpe.f64	d8, d7
   30b00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30b04:	dd2e      	ble.n	30b64 <exp+0x94>
   30b06:	2303      	movs	r3, #3
   30b08:	9300      	str	r3, [sp, #0]
   30b0a:	4b28      	ldr	r3, [pc, #160]	; (30bac <exp+0xdc>)
   30b0c:	9301      	str	r3, [sp, #4]
   30b0e:	2300      	movs	r3, #0
   30b10:	9308      	str	r3, [sp, #32]
   30b12:	f994 3000 	ldrsb.w	r3, [r4]
   30b16:	ed8d 8b04 	vstr	d8, [sp, #16]
   30b1a:	ed8d 8b02 	vstr	d8, [sp, #8]
   30b1e:	b9b3      	cbnz	r3, 30b4e <exp+0x7e>
   30b20:	4b23      	ldr	r3, [pc, #140]	; (30bb0 <exp+0xe0>)
   30b22:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   30b26:	e9cd 2306 	strd	r2, r3, [sp, #24]
   30b2a:	4668      	mov	r0, sp
   30b2c:	f001 fe1e 	bl	3276c <matherr>
   30b30:	b198      	cbz	r0, 30b5a <exp+0x8a>
   30b32:	9b08      	ldr	r3, [sp, #32]
   30b34:	b11b      	cbz	r3, 30b3e <exp+0x6e>
   30b36:	f7ff faed 	bl	30114 <__errno>
   30b3a:	9b08      	ldr	r3, [sp, #32]
   30b3c:	6003      	str	r3, [r0, #0]
   30b3e:	ed9d 9b06 	vldr	d9, [sp, #24]
   30b42:	eeb0 0b49 	vmov.f64	d0, d9
   30b46:	b00a      	add	sp, #40	; 0x28
   30b48:	ecbd 8b04 	vpop	{d8-d9}
   30b4c:	bd10      	pop	{r4, pc}
   30b4e:	4919      	ldr	r1, [pc, #100]	; (30bb4 <exp+0xe4>)
   30b50:	2000      	movs	r0, #0
   30b52:	e9cd 0106 	strd	r0, r1, [sp, #24]
   30b56:	2b02      	cmp	r3, #2
   30b58:	d1e7      	bne.n	30b2a <exp+0x5a>
   30b5a:	f7ff fadb 	bl	30114 <__errno>
   30b5e:	2322      	movs	r3, #34	; 0x22
   30b60:	6003      	str	r3, [r0, #0]
   30b62:	e7e6      	b.n	30b32 <exp+0x62>
   30b64:	ed9f 7b0e 	vldr	d7, [pc, #56]	; 30ba0 <exp+0xd0>
   30b68:	eeb4 8bc7 	vcmpe.f64	d8, d7
   30b6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30b70:	d5e7      	bpl.n	30b42 <exp+0x72>
   30b72:	2304      	movs	r3, #4
   30b74:	9300      	str	r3, [sp, #0]
   30b76:	4b0d      	ldr	r3, [pc, #52]	; (30bac <exp+0xdc>)
   30b78:	9301      	str	r3, [sp, #4]
   30b7a:	2300      	movs	r3, #0
   30b7c:	9308      	str	r3, [sp, #32]
   30b7e:	2200      	movs	r2, #0
   30b80:	2300      	movs	r3, #0
   30b82:	e9cd 2306 	strd	r2, r3, [sp, #24]
   30b86:	ed8d 8b04 	vstr	d8, [sp, #16]
   30b8a:	ed8d 8b02 	vstr	d8, [sp, #8]
   30b8e:	f994 3000 	ldrsb.w	r3, [r4]
   30b92:	e7e0      	b.n	30b56 <exp+0x86>
   30b94:	f3af 8000 	nop.w
   30b98:	fefa39ef 	.word	0xfefa39ef
   30b9c:	40862e42 	.word	0x40862e42
   30ba0:	d52d3051 	.word	0xd52d3051
   30ba4:	c0874910 	.word	0xc0874910
   30ba8:	0006649c 	.word	0x0006649c
   30bac:	00055b88 	.word	0x00055b88
   30bb0:	47efffff 	.word	0x47efffff
   30bb4:	7ff00000 	.word	0x7ff00000

00030bb8 <pow>:
   30bb8:	b570      	push	{r4, r5, r6, lr}
   30bba:	ed2d 8b0a 	vpush	{d8-d12}
   30bbe:	eeb0 9b40 	vmov.f64	d9, d0
   30bc2:	eeb0 8b41 	vmov.f64	d8, d1
   30bc6:	4c8c      	ldr	r4, [pc, #560]	; (30df8 <pow+0x240>)
   30bc8:	b08a      	sub	sp, #40	; 0x28
   30bca:	f000 fb65 	bl	31298 <__ieee754_pow>
   30bce:	f994 3000 	ldrsb.w	r3, [r4]
   30bd2:	eeb0 ab40 	vmov.f64	d10, d0
   30bd6:	1c5a      	adds	r2, r3, #1
   30bd8:	4626      	mov	r6, r4
   30bda:	d04b      	beq.n	30c74 <pow+0xbc>
   30bdc:	eeb4 8b48 	vcmp.f64	d8, d8
   30be0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30be4:	d646      	bvs.n	30c74 <pow+0xbc>
   30be6:	eeb4 9b49 	vcmp.f64	d9, d9
   30bea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30bee:	d719      	bvc.n	30c24 <pow+0x6c>
   30bf0:	eeb5 8b40 	vcmp.f64	d8, #0.0
   30bf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30bf8:	d13c      	bne.n	30c74 <pow+0xbc>
   30bfa:	2201      	movs	r2, #1
   30bfc:	9200      	str	r2, [sp, #0]
   30bfe:	497f      	ldr	r1, [pc, #508]	; (30dfc <pow+0x244>)
   30c00:	4a7f      	ldr	r2, [pc, #508]	; (30e00 <pow+0x248>)
   30c02:	9201      	str	r2, [sp, #4]
   30c04:	2000      	movs	r0, #0
   30c06:	2200      	movs	r2, #0
   30c08:	2b02      	cmp	r3, #2
   30c0a:	9208      	str	r2, [sp, #32]
   30c0c:	ed8d 9b02 	vstr	d9, [sp, #8]
   30c10:	ed8d 8b04 	vstr	d8, [sp, #16]
   30c14:	e9cd 0106 	strd	r0, r1, [sp, #24]
   30c18:	d02a      	beq.n	30c70 <pow+0xb8>
   30c1a:	4668      	mov	r0, sp
   30c1c:	f001 fda6 	bl	3276c <matherr>
   30c20:	bb00      	cbnz	r0, 30c64 <pow+0xac>
   30c22:	e04e      	b.n	30cc2 <pow+0x10a>
   30c24:	ed9f bb72 	vldr	d11, [pc, #456]	; 30df0 <pow+0x238>
   30c28:	eeb4 9b4b 	vcmp.f64	d9, d11
   30c2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30c30:	eeb0 cb4b 	vmov.f64	d12, d11
   30c34:	d14a      	bne.n	30ccc <pow+0x114>
   30c36:	eeb4 8b4b 	vcmp.f64	d8, d11
   30c3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30c3e:	d11f      	bne.n	30c80 <pow+0xc8>
   30c40:	2201      	movs	r2, #1
   30c42:	9200      	str	r2, [sp, #0]
   30c44:	4a6e      	ldr	r2, [pc, #440]	; (30e00 <pow+0x248>)
   30c46:	9201      	str	r2, [sp, #4]
   30c48:	2200      	movs	r2, #0
   30c4a:	9208      	str	r2, [sp, #32]
   30c4c:	ed8d 9b02 	vstr	d9, [sp, #8]
   30c50:	ed8d 8b04 	vstr	d8, [sp, #16]
   30c54:	ed8d bb06 	vstr	d11, [sp, #24]
   30c58:	2b00      	cmp	r3, #0
   30c5a:	d0de      	beq.n	30c1a <pow+0x62>
   30c5c:	4b67      	ldr	r3, [pc, #412]	; (30dfc <pow+0x244>)
   30c5e:	2200      	movs	r2, #0
   30c60:	e9cd 2306 	strd	r2, r3, [sp, #24]
   30c64:	9b08      	ldr	r3, [sp, #32]
   30c66:	b11b      	cbz	r3, 30c70 <pow+0xb8>
   30c68:	f7ff fa54 	bl	30114 <__errno>
   30c6c:	9b08      	ldr	r3, [sp, #32]
   30c6e:	6003      	str	r3, [r0, #0]
   30c70:	ed9d ab06 	vldr	d10, [sp, #24]
   30c74:	eeb0 0b4a 	vmov.f64	d0, d10
   30c78:	b00a      	add	sp, #40	; 0x28
   30c7a:	ecbd 8b0a 	vpop	{d8-d12}
   30c7e:	bd70      	pop	{r4, r5, r6, pc}
   30c80:	eeb0 0b48 	vmov.f64	d0, d8
   30c84:	f001 fd6a 	bl	3275c <finite>
   30c88:	2800      	cmp	r0, #0
   30c8a:	d0f3      	beq.n	30c74 <pow+0xbc>
   30c8c:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
   30c90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30c94:	d5ee      	bpl.n	30c74 <pow+0xbc>
   30c96:	2301      	movs	r3, #1
   30c98:	9300      	str	r3, [sp, #0]
   30c9a:	4b59      	ldr	r3, [pc, #356]	; (30e00 <pow+0x248>)
   30c9c:	9301      	str	r3, [sp, #4]
   30c9e:	2300      	movs	r3, #0
   30ca0:	9308      	str	r3, [sp, #32]
   30ca2:	f994 3000 	ldrsb.w	r3, [r4]
   30ca6:	ed8d 9b02 	vstr	d9, [sp, #8]
   30caa:	ed8d 8b04 	vstr	d8, [sp, #16]
   30cae:	b913      	cbnz	r3, 30cb6 <pow+0xfe>
   30cb0:	ed8d bb06 	vstr	d11, [sp, #24]
   30cb4:	e7b1      	b.n	30c1a <pow+0x62>
   30cb6:	4953      	ldr	r1, [pc, #332]	; (30e04 <pow+0x24c>)
   30cb8:	2000      	movs	r0, #0
   30cba:	e9cd 0106 	strd	r0, r1, [sp, #24]
   30cbe:	2b02      	cmp	r3, #2
   30cc0:	d1ab      	bne.n	30c1a <pow+0x62>
   30cc2:	f7ff fa27 	bl	30114 <__errno>
   30cc6:	2321      	movs	r3, #33	; 0x21
   30cc8:	6003      	str	r3, [r0, #0]
   30cca:	e7cb      	b.n	30c64 <pow+0xac>
   30ccc:	f001 fd46 	bl	3275c <finite>
   30cd0:	4605      	mov	r5, r0
   30cd2:	2800      	cmp	r0, #0
   30cd4:	d164      	bne.n	30da0 <pow+0x1e8>
   30cd6:	eeb0 0b49 	vmov.f64	d0, d9
   30cda:	f001 fd3f 	bl	3275c <finite>
   30cde:	2800      	cmp	r0, #0
   30ce0:	d05e      	beq.n	30da0 <pow+0x1e8>
   30ce2:	eeb0 0b48 	vmov.f64	d0, d8
   30ce6:	f001 fd39 	bl	3275c <finite>
   30cea:	2800      	cmp	r0, #0
   30cec:	d058      	beq.n	30da0 <pow+0x1e8>
   30cee:	eeb4 ab4a 	vcmp.f64	d10, d10
   30cf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30cf6:	f994 3000 	ldrsb.w	r3, [r4]
   30cfa:	4a41      	ldr	r2, [pc, #260]	; (30e00 <pow+0x248>)
   30cfc:	d70e      	bvc.n	30d1c <pow+0x164>
   30cfe:	2101      	movs	r1, #1
   30d00:	e9cd 1200 	strd	r1, r2, [sp]
   30d04:	9508      	str	r5, [sp, #32]
   30d06:	ed8d 9b02 	vstr	d9, [sp, #8]
   30d0a:	ed8d 8b04 	vstr	d8, [sp, #16]
   30d0e:	2b00      	cmp	r3, #0
   30d10:	d0ce      	beq.n	30cb0 <pow+0xf8>
   30d12:	ee8b 7b0b 	vdiv.f64	d7, d11, d11
   30d16:	ed8d 7b06 	vstr	d7, [sp, #24]
   30d1a:	e7d0      	b.n	30cbe <pow+0x106>
   30d1c:	2103      	movs	r1, #3
   30d1e:	ed8d 8b04 	vstr	d8, [sp, #16]
   30d22:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
   30d26:	ee28 8b07 	vmul.f64	d8, d8, d7
   30d2a:	e9cd 1200 	strd	r1, r2, [sp]
   30d2e:	9508      	str	r5, [sp, #32]
   30d30:	ed8d 9b02 	vstr	d9, [sp, #8]
   30d34:	b9fb      	cbnz	r3, 30d76 <pow+0x1be>
   30d36:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
   30d3a:	4b33      	ldr	r3, [pc, #204]	; (30e08 <pow+0x250>)
   30d3c:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   30d40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30d44:	e9cd 2306 	strd	r2, r3, [sp, #24]
   30d48:	d54b      	bpl.n	30de2 <pow+0x22a>
   30d4a:	eeb0 0b48 	vmov.f64	d0, d8
   30d4e:	f001 fd17 	bl	32780 <rint>
   30d52:	eeb4 0b48 	vcmp.f64	d0, d8
   30d56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30d5a:	d004      	beq.n	30d66 <pow+0x1ae>
   30d5c:	4b2b      	ldr	r3, [pc, #172]	; (30e0c <pow+0x254>)
   30d5e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   30d62:	e9cd 2306 	strd	r2, r3, [sp, #24]
   30d66:	f996 3000 	ldrsb.w	r3, [r6]
   30d6a:	2b02      	cmp	r3, #2
   30d6c:	d139      	bne.n	30de2 <pow+0x22a>
   30d6e:	f7ff f9d1 	bl	30114 <__errno>
   30d72:	2322      	movs	r3, #34	; 0x22
   30d74:	e7a8      	b.n	30cc8 <pow+0x110>
   30d76:	4b26      	ldr	r3, [pc, #152]	; (30e10 <pow+0x258>)
   30d78:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
   30d7c:	2200      	movs	r2, #0
   30d7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30d82:	e9cd 2306 	strd	r2, r3, [sp, #24]
   30d86:	d5ee      	bpl.n	30d66 <pow+0x1ae>
   30d88:	eeb0 0b48 	vmov.f64	d0, d8
   30d8c:	f001 fcf8 	bl	32780 <rint>
   30d90:	eeb4 0b48 	vcmp.f64	d0, d8
   30d94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30d98:	d0e5      	beq.n	30d66 <pow+0x1ae>
   30d9a:	2200      	movs	r2, #0
   30d9c:	4b19      	ldr	r3, [pc, #100]	; (30e04 <pow+0x24c>)
   30d9e:	e7e0      	b.n	30d62 <pow+0x1aa>
   30da0:	eeb5 ab40 	vcmp.f64	d10, #0.0
   30da4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30da8:	f47f af64 	bne.w	30c74 <pow+0xbc>
   30dac:	eeb0 0b49 	vmov.f64	d0, d9
   30db0:	f001 fcd4 	bl	3275c <finite>
   30db4:	2800      	cmp	r0, #0
   30db6:	f43f af5d 	beq.w	30c74 <pow+0xbc>
   30dba:	eeb0 0b48 	vmov.f64	d0, d8
   30dbe:	f001 fccd 	bl	3275c <finite>
   30dc2:	2800      	cmp	r0, #0
   30dc4:	f43f af56 	beq.w	30c74 <pow+0xbc>
   30dc8:	2304      	movs	r3, #4
   30dca:	9300      	str	r3, [sp, #0]
   30dcc:	4b0c      	ldr	r3, [pc, #48]	; (30e00 <pow+0x248>)
   30dce:	9301      	str	r3, [sp, #4]
   30dd0:	2300      	movs	r3, #0
   30dd2:	9308      	str	r3, [sp, #32]
   30dd4:	ed8d 9b02 	vstr	d9, [sp, #8]
   30dd8:	ed8d 8b04 	vstr	d8, [sp, #16]
   30ddc:	ed8d cb06 	vstr	d12, [sp, #24]
   30de0:	e7c1      	b.n	30d66 <pow+0x1ae>
   30de2:	4668      	mov	r0, sp
   30de4:	f001 fcc2 	bl	3276c <matherr>
   30de8:	2800      	cmp	r0, #0
   30dea:	f47f af3b 	bne.w	30c64 <pow+0xac>
   30dee:	e7be      	b.n	30d6e <pow+0x1b6>
	...
   30df8:	0006649c 	.word	0x0006649c
   30dfc:	3ff00000 	.word	0x3ff00000
   30e00:	00055b8c 	.word	0x00055b8c
   30e04:	fff00000 	.word	0xfff00000
   30e08:	47efffff 	.word	0x47efffff
   30e0c:	c7efffff 	.word	0xc7efffff
   30e10:	7ff00000 	.word	0x7ff00000
   30e14:	00000000 	.word	0x00000000

00030e18 <fmodf>:
   30e18:	b500      	push	{lr}
   30e1a:	ed2d 8b02 	vpush	{d8}
   30e1e:	b08b      	sub	sp, #44	; 0x2c
   30e20:	eeb0 8a40 	vmov.f32	s16, s0
   30e24:	eef0 8a60 	vmov.f32	s17, s1
   30e28:	f000 fdc0 	bl	319ac <__ieee754_fmodf>
   30e2c:	4b24      	ldr	r3, [pc, #144]	; (30ec0 <fmodf+0xa8>)
   30e2e:	f993 3000 	ldrsb.w	r3, [r3]
   30e32:	1c5a      	adds	r2, r3, #1
   30e34:	d02d      	beq.n	30e92 <fmodf+0x7a>
   30e36:	eef4 8a68 	vcmp.f32	s17, s17
   30e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30e3e:	d628      	bvs.n	30e92 <fmodf+0x7a>
   30e40:	eeb4 8a48 	vcmp.f32	s16, s16
   30e44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30e48:	d623      	bvs.n	30e92 <fmodf+0x7a>
   30e4a:	eef5 8a40 	vcmp.f32	s17, #0.0
   30e4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30e52:	d11e      	bne.n	30e92 <fmodf+0x7a>
   30e54:	2201      	movs	r2, #1
   30e56:	9200      	str	r2, [sp, #0]
   30e58:	eeb7 0ac8 	vcvt.f64.f32	d0, s16
   30e5c:	4a19      	ldr	r2, [pc, #100]	; (30ec4 <fmodf+0xac>)
   30e5e:	9201      	str	r2, [sp, #4]
   30e60:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
   30e64:	2200      	movs	r2, #0
   30e66:	9208      	str	r2, [sp, #32]
   30e68:	ed8d 0b02 	vstr	d0, [sp, #8]
   30e6c:	ed8d 7b04 	vstr	d7, [sp, #16]
   30e70:	b9a3      	cbnz	r3, 30e9c <fmodf+0x84>
   30e72:	ed8d 0b06 	vstr	d0, [sp, #24]
   30e76:	4668      	mov	r0, sp
   30e78:	f001 fc78 	bl	3276c <matherr>
   30e7c:	b1b0      	cbz	r0, 30eac <fmodf+0x94>
   30e7e:	9b08      	ldr	r3, [sp, #32]
   30e80:	b11b      	cbz	r3, 30e8a <fmodf+0x72>
   30e82:	f7ff f947 	bl	30114 <__errno>
   30e86:	9b08      	ldr	r3, [sp, #32]
   30e88:	6003      	str	r3, [r0, #0]
   30e8a:	ed9d 0b06 	vldr	d0, [sp, #24]
   30e8e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   30e92:	b00b      	add	sp, #44	; 0x2c
   30e94:	ecbd 8b02 	vpop	{d8}
   30e98:	f85d fb04 	ldr.w	pc, [sp], #4
   30e9c:	ed9f 7b06 	vldr	d7, [pc, #24]	; 30eb8 <fmodf+0xa0>
   30ea0:	2b02      	cmp	r3, #2
   30ea2:	ee87 6b07 	vdiv.f64	d6, d7, d7
   30ea6:	ed8d 6b06 	vstr	d6, [sp, #24]
   30eaa:	d1e4      	bne.n	30e76 <fmodf+0x5e>
   30eac:	f7ff f932 	bl	30114 <__errno>
   30eb0:	2321      	movs	r3, #33	; 0x21
   30eb2:	6003      	str	r3, [r0, #0]
   30eb4:	e7e3      	b.n	30e7e <fmodf+0x66>
   30eb6:	bf00      	nop
	...
   30ec0:	0006649c 	.word	0x0006649c
   30ec4:	00055b90 	.word	0x00055b90

00030ec8 <log10f>:
   30ec8:	b500      	push	{lr}
   30eca:	ed2d 8b02 	vpush	{d8}
   30ece:	b08b      	sub	sp, #44	; 0x2c
   30ed0:	eeb0 8a40 	vmov.f32	s16, s0
   30ed4:	f000 fdf2 	bl	31abc <__ieee754_log10f>
   30ed8:	4b2f      	ldr	r3, [pc, #188]	; (30f98 <log10f+0xd0>)
   30eda:	f993 3000 	ldrsb.w	r3, [r3]
   30ede:	1c5a      	adds	r2, r3, #1
   30ee0:	d055      	beq.n	30f8e <log10f+0xc6>
   30ee2:	eeb4 8a48 	vcmp.f32	s16, s16
   30ee6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30eea:	d650      	bvs.n	30f8e <log10f+0xc6>
   30eec:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   30ef0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30ef4:	d84b      	bhi.n	30f8e <log10f+0xc6>
   30ef6:	4a29      	ldr	r2, [pc, #164]	; (30f9c <log10f+0xd4>)
   30ef8:	9201      	str	r2, [sp, #4]
   30efa:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
   30efe:	2200      	movs	r2, #0
   30f00:	9208      	str	r2, [sp, #32]
   30f02:	ed8d 7b04 	vstr	d7, [sp, #16]
   30f06:	ed8d 7b02 	vstr	d7, [sp, #8]
   30f0a:	b993      	cbnz	r3, 30f32 <log10f+0x6a>
   30f0c:	4924      	ldr	r1, [pc, #144]	; (30fa0 <log10f+0xd8>)
   30f0e:	eeb5 8a40 	vcmp.f32	s16, #0.0
   30f12:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
   30f16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30f1a:	e9cd 0106 	strd	r0, r1, [sp, #24]
   30f1e:	d025      	beq.n	30f6c <log10f+0xa4>
   30f20:	2201      	movs	r2, #1
   30f22:	2b02      	cmp	r3, #2
   30f24:	9200      	str	r2, [sp, #0]
   30f26:	d116      	bne.n	30f56 <log10f+0x8e>
   30f28:	f7ff f8f4 	bl	30114 <__errno>
   30f2c:	2321      	movs	r3, #33	; 0x21
   30f2e:	6003      	str	r3, [r0, #0]
   30f30:	e016      	b.n	30f60 <log10f+0x98>
   30f32:	491c      	ldr	r1, [pc, #112]	; (30fa4 <log10f+0xdc>)
   30f34:	eeb5 8a40 	vcmp.f32	s16, #0.0
   30f38:	2000      	movs	r0, #0
   30f3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30f3e:	e9cd 0106 	strd	r0, r1, [sp, #24]
   30f42:	d1ed      	bne.n	30f20 <log10f+0x58>
   30f44:	2202      	movs	r2, #2
   30f46:	4293      	cmp	r3, r2
   30f48:	9200      	str	r2, [sp, #0]
   30f4a:	d111      	bne.n	30f70 <log10f+0xa8>
   30f4c:	f7ff f8e2 	bl	30114 <__errno>
   30f50:	2322      	movs	r3, #34	; 0x22
   30f52:	6003      	str	r3, [r0, #0]
   30f54:	e011      	b.n	30f7a <log10f+0xb2>
   30f56:	4668      	mov	r0, sp
   30f58:	f001 fc08 	bl	3276c <matherr>
   30f5c:	2800      	cmp	r0, #0
   30f5e:	d0e3      	beq.n	30f28 <log10f+0x60>
   30f60:	4811      	ldr	r0, [pc, #68]	; (30fa8 <log10f+0xe0>)
   30f62:	f001 fc05 	bl	32770 <nan>
   30f66:	ed8d 0b06 	vstr	d0, [sp, #24]
   30f6a:	e006      	b.n	30f7a <log10f+0xb2>
   30f6c:	2302      	movs	r3, #2
   30f6e:	9300      	str	r3, [sp, #0]
   30f70:	4668      	mov	r0, sp
   30f72:	f001 fbfb 	bl	3276c <matherr>
   30f76:	2800      	cmp	r0, #0
   30f78:	d0e8      	beq.n	30f4c <log10f+0x84>
   30f7a:	9b08      	ldr	r3, [sp, #32]
   30f7c:	b11b      	cbz	r3, 30f86 <log10f+0xbe>
   30f7e:	f7ff f8c9 	bl	30114 <__errno>
   30f82:	9b08      	ldr	r3, [sp, #32]
   30f84:	6003      	str	r3, [r0, #0]
   30f86:	ed9d 0b06 	vldr	d0, [sp, #24]
   30f8a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   30f8e:	b00b      	add	sp, #44	; 0x2c
   30f90:	ecbd 8b02 	vpop	{d8}
   30f94:	f85d fb04 	ldr.w	pc, [sp], #4
   30f98:	0006649c 	.word	0x0006649c
   30f9c:	00055b96 	.word	0x00055b96
   30fa0:	c7efffff 	.word	0xc7efffff
   30fa4:	fff00000 	.word	0xfff00000
   30fa8:	00055b9c 	.word	0x00055b9c
   30fac:	00000000 	.word	0x00000000

00030fb0 <sinhf>:
   30fb0:	b530      	push	{r4, r5, lr}
   30fb2:	ed2d 8b02 	vpush	{d8}
   30fb6:	4c32      	ldr	r4, [pc, #200]	; (31080 <sinhf+0xd0>)
   30fb8:	b08b      	sub	sp, #44	; 0x2c
   30fba:	eef0 8a40 	vmov.f32	s17, s0
   30fbe:	f000 feff 	bl	31dc0 <__ieee754_sinhf>
   30fc2:	f994 3000 	ldrsb.w	r3, [r4]
   30fc6:	3301      	adds	r3, #1
   30fc8:	eeb0 8a40 	vmov.f32	s16, s0
   30fcc:	d030      	beq.n	31030 <sinhf+0x80>
   30fce:	f001 fe0b 	bl	32be8 <finitef>
   30fd2:	4605      	mov	r5, r0
   30fd4:	bb60      	cbnz	r0, 31030 <sinhf+0x80>
   30fd6:	eeb0 0a68 	vmov.f32	s0, s17
   30fda:	f001 fe05 	bl	32be8 <finitef>
   30fde:	b338      	cbz	r0, 31030 <sinhf+0x80>
   30fe0:	2303      	movs	r3, #3
   30fe2:	9300      	str	r3, [sp, #0]
   30fe4:	4b27      	ldr	r3, [pc, #156]	; (31084 <sinhf+0xd4>)
   30fe6:	9301      	str	r3, [sp, #4]
   30fe8:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
   30fec:	f994 3000 	ldrsb.w	r3, [r4]
   30ff0:	9508      	str	r5, [sp, #32]
   30ff2:	ed8d 7b04 	vstr	d7, [sp, #16]
   30ff6:	ed8d 7b02 	vstr	d7, [sp, #8]
   30ffa:	eef5 8ac0 	vcmpe.f32	s17, #0.0
   30ffe:	b9eb      	cbnz	r3, 3103c <sinhf+0x8c>
   31000:	ed9f 7b17 	vldr	d7, [pc, #92]	; 31060 <sinhf+0xb0>
   31004:	ed9f 6b18 	vldr	d6, [pc, #96]	; 31068 <sinhf+0xb8>
   31008:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3100c:	fe37 7b06 	vselgt.f64	d7, d7, d6
   31010:	ed8d 7b06 	vstr	d7, [sp, #24]
   31014:	4668      	mov	r0, sp
   31016:	f001 fba9 	bl	3276c <matherr>
   3101a:	b1d8      	cbz	r0, 31054 <sinhf+0xa4>
   3101c:	9b08      	ldr	r3, [sp, #32]
   3101e:	b11b      	cbz	r3, 31028 <sinhf+0x78>
   31020:	f7ff f878 	bl	30114 <__errno>
   31024:	9b08      	ldr	r3, [sp, #32]
   31026:	6003      	str	r3, [r0, #0]
   31028:	ed9d 8b06 	vldr	d8, [sp, #24]
   3102c:	eeb7 8bc8 	vcvt.f32.f64	s16, d8
   31030:	eeb0 0a48 	vmov.f32	s0, s16
   31034:	b00b      	add	sp, #44	; 0x2c
   31036:	ecbd 8b02 	vpop	{d8}
   3103a:	bd30      	pop	{r4, r5, pc}
   3103c:	ed9f 7b0c 	vldr	d7, [pc, #48]	; 31070 <sinhf+0xc0>
   31040:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 31078 <sinhf+0xc8>
   31044:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   31048:	fe37 7b06 	vselgt.f64	d7, d7, d6
   3104c:	2b02      	cmp	r3, #2
   3104e:	ed8d 7b06 	vstr	d7, [sp, #24]
   31052:	d1df      	bne.n	31014 <sinhf+0x64>
   31054:	f7ff f85e 	bl	30114 <__errno>
   31058:	2322      	movs	r3, #34	; 0x22
   3105a:	6003      	str	r3, [r0, #0]
   3105c:	e7de      	b.n	3101c <sinhf+0x6c>
   3105e:	bf00      	nop
   31060:	e0000000 	.word	0xe0000000
   31064:	47efffff 	.word	0x47efffff
   31068:	e0000000 	.word	0xe0000000
   3106c:	c7efffff 	.word	0xc7efffff
   31070:	00000000 	.word	0x00000000
   31074:	7ff00000 	.word	0x7ff00000
   31078:	00000000 	.word	0x00000000
   3107c:	fff00000 	.word	0xfff00000
   31080:	0006649c 	.word	0x0006649c
   31084:	00055b9d 	.word	0x00055b9d

00031088 <__ieee754_exp>:
   31088:	ee10 1a90 	vmov	r1, s1
   3108c:	4b7a      	ldr	r3, [pc, #488]	; (31278 <__ieee754_exp+0x1f0>)
   3108e:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   31092:	429a      	cmp	r2, r3
   31094:	b082      	sub	sp, #8
   31096:	ea4f 70d1 	mov.w	r0, r1, lsr #31
   3109a:	d928      	bls.n	310ee <__ieee754_exp+0x66>
   3109c:	4b77      	ldr	r3, [pc, #476]	; (3127c <__ieee754_exp+0x1f4>)
   3109e:	429a      	cmp	r2, r3
   310a0:	d90f      	bls.n	310c2 <__ieee754_exp+0x3a>
   310a2:	ee10 3a10 	vmov	r3, s0
   310a6:	f3c1 0113 	ubfx	r1, r1, #0, #20
   310aa:	430b      	orrs	r3, r1
   310ac:	d003      	beq.n	310b6 <__ieee754_exp+0x2e>
   310ae:	ee30 0b00 	vadd.f64	d0, d0, d0
   310b2:	b002      	add	sp, #8
   310b4:	4770      	bx	lr
   310b6:	ed9f 7b56 	vldr	d7, [pc, #344]	; 31210 <__ieee754_exp+0x188>
   310ba:	2800      	cmp	r0, #0
   310bc:	fe00 0b07 	vseleq.f64	d0, d0, d7
   310c0:	e7f7      	b.n	310b2 <__ieee754_exp+0x2a>
   310c2:	ed9f 7b55 	vldr	d7, [pc, #340]	; 31218 <__ieee754_exp+0x190>
   310c6:	eeb4 0bc7 	vcmpe.f64	d0, d7
   310ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   310ce:	dd04      	ble.n	310da <__ieee754_exp+0x52>
   310d0:	ed9f 0b53 	vldr	d0, [pc, #332]	; 31220 <__ieee754_exp+0x198>
   310d4:	ee20 0b00 	vmul.f64	d0, d0, d0
   310d8:	e7eb      	b.n	310b2 <__ieee754_exp+0x2a>
   310da:	ed9f 7b53 	vldr	d7, [pc, #332]	; 31228 <__ieee754_exp+0x1a0>
   310de:	eeb4 0bc7 	vcmpe.f64	d0, d7
   310e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   310e6:	d505      	bpl.n	310f4 <__ieee754_exp+0x6c>
   310e8:	ed9f 0b49 	vldr	d0, [pc, #292]	; 31210 <__ieee754_exp+0x188>
   310ec:	e7e1      	b.n	310b2 <__ieee754_exp+0x2a>
   310ee:	4b64      	ldr	r3, [pc, #400]	; (31280 <__ieee754_exp+0x1f8>)
   310f0:	429a      	cmp	r2, r3
   310f2:	d956      	bls.n	311a2 <__ieee754_exp+0x11a>
   310f4:	4b63      	ldr	r3, [pc, #396]	; (31284 <__ieee754_exp+0x1fc>)
   310f6:	429a      	cmp	r2, r3
   310f8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   310fc:	d838      	bhi.n	31170 <__ieee754_exp+0xe8>
   310fe:	4b62      	ldr	r3, [pc, #392]	; (31288 <__ieee754_exp+0x200>)
   31100:	4413      	add	r3, r2
   31102:	ed93 6b00 	vldr	d6, [r3]
   31106:	4b61      	ldr	r3, [pc, #388]	; (3128c <__ieee754_exp+0x204>)
   31108:	ee30 6b46 	vsub.f64	d6, d0, d6
   3110c:	4413      	add	r3, r2
   3110e:	ed93 7b00 	vldr	d7, [r3]
   31112:	f1c0 0301 	rsb	r3, r0, #1
   31116:	1a1b      	subs	r3, r3, r0
   31118:	ee36 0b47 	vsub.f64	d0, d6, d7
   3111c:	ed9f 4b44 	vldr	d4, [pc, #272]	; 31230 <__ieee754_exp+0x1a8>
   31120:	ee20 5b00 	vmul.f64	d5, d0, d0
   31124:	ed9f 3b44 	vldr	d3, [pc, #272]	; 31238 <__ieee754_exp+0x1b0>
   31128:	eea5 3b04 	vfma.f64	d3, d5, d4
   3112c:	ed9f 4b44 	vldr	d4, [pc, #272]	; 31240 <__ieee754_exp+0x1b8>
   31130:	eea3 4b05 	vfma.f64	d4, d3, d5
   31134:	ed9f 3b44 	vldr	d3, [pc, #272]	; 31248 <__ieee754_exp+0x1c0>
   31138:	eea4 3b05 	vfma.f64	d3, d4, d5
   3113c:	ed9f 4b44 	vldr	d4, [pc, #272]	; 31250 <__ieee754_exp+0x1c8>
   31140:	eea3 4b05 	vfma.f64	d4, d3, d5
   31144:	eeb0 3b40 	vmov.f64	d3, d0
   31148:	eea4 3b45 	vfms.f64	d3, d4, d5
   3114c:	eeb0 4b00 	vmov.f64	d4, #0	; 0x40000000  2.0
   31150:	eeb0 5b43 	vmov.f64	d5, d3
   31154:	ee20 2b03 	vmul.f64	d2, d0, d3
   31158:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
   3115c:	bba3      	cbnz	r3, 311c8 <__ieee754_exp+0x140>
   3115e:	ee35 5b44 	vsub.f64	d5, d5, d4
   31162:	ee82 7b05 	vdiv.f64	d7, d2, d5
   31166:	ee37 0b40 	vsub.f64	d0, d7, d0
   3116a:	ee33 0b40 	vsub.f64	d0, d3, d0
   3116e:	e7a0      	b.n	310b2 <__ieee754_exp+0x2a>
   31170:	4b47      	ldr	r3, [pc, #284]	; (31290 <__ieee754_exp+0x208>)
   31172:	4413      	add	r3, r2
   31174:	ed93 7b00 	vldr	d7, [r3]
   31178:	ed9f 6b37 	vldr	d6, [pc, #220]	; 31258 <__ieee754_exp+0x1d0>
   3117c:	ed9f 5b38 	vldr	d5, [pc, #224]	; 31260 <__ieee754_exp+0x1d8>
   31180:	eea0 7b06 	vfma.f64	d7, d0, d6
   31184:	ed9f 6b38 	vldr	d6, [pc, #224]	; 31268 <__ieee754_exp+0x1e0>
   31188:	eefd 7bc7 	vcvt.s32.f64	s15, d7
   3118c:	ee17 3a90 	vmov	r3, s15
   31190:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   31194:	eea7 0b46 	vfms.f64	d0, d7, d6
   31198:	ee27 7b05 	vmul.f64	d7, d7, d5
   3119c:	eeb0 6b40 	vmov.f64	d6, d0
   311a0:	e7ba      	b.n	31118 <__ieee754_exp+0x90>
   311a2:	4b3c      	ldr	r3, [pc, #240]	; (31294 <__ieee754_exp+0x20c>)
   311a4:	429a      	cmp	r2, r3
   311a6:	d80d      	bhi.n	311c4 <__ieee754_exp+0x13c>
   311a8:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
   311ac:	ed9f 5b1c 	vldr	d5, [pc, #112]	; 31220 <__ieee754_exp+0x198>
   311b0:	ee30 5b05 	vadd.f64	d5, d0, d5
   311b4:	eeb4 5bc4 	vcmpe.f64	d5, d4
   311b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   311bc:	dd02      	ble.n	311c4 <__ieee754_exp+0x13c>
   311be:	ee30 0b04 	vadd.f64	d0, d0, d4
   311c2:	e776      	b.n	310b2 <__ieee754_exp+0x2a>
   311c4:	2300      	movs	r3, #0
   311c6:	e7a9      	b.n	3111c <__ieee754_exp+0x94>
   311c8:	f46f 717f 	mvn.w	r1, #1020	; 0x3fc
   311cc:	ee34 5b45 	vsub.f64	d5, d4, d5
   311d0:	428b      	cmp	r3, r1
   311d2:	ee82 4b05 	vdiv.f64	d4, d2, d5
   311d6:	ee37 7b44 	vsub.f64	d7, d7, d4
   311da:	ee37 7b46 	vsub.f64	d7, d7, d6
   311de:	ee33 7b47 	vsub.f64	d7, d3, d7
   311e2:	ed8d 7b00 	vstr	d7, [sp]
   311e6:	9a01      	ldr	r2, [sp, #4]
   311e8:	e9dd 0100 	ldrd	r0, r1, [sp]
   311ec:	db04      	blt.n	311f8 <__ieee754_exp+0x170>
   311ee:	eb02 5103 	add.w	r1, r2, r3, lsl #20
   311f2:	ec41 0b10 	vmov	d0, r0, r1
   311f6:	e75c      	b.n	310b2 <__ieee754_exp+0x2a>
   311f8:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
   311fc:	eb02 5103 	add.w	r1, r2, r3, lsl #20
   31200:	ed9f 7b1b 	vldr	d7, [pc, #108]	; 31270 <__ieee754_exp+0x1e8>
   31204:	ec41 0b10 	vmov	d0, r0, r1
   31208:	ee20 0b07 	vmul.f64	d0, d0, d7
   3120c:	e751      	b.n	310b2 <__ieee754_exp+0x2a>
   3120e:	bf00      	nop
	...
   31218:	fefa39ef 	.word	0xfefa39ef
   3121c:	40862e42 	.word	0x40862e42
   31220:	8800759c 	.word	0x8800759c
   31224:	7e37e43c 	.word	0x7e37e43c
   31228:	d52d3051 	.word	0xd52d3051
   3122c:	c0874910 	.word	0xc0874910
   31230:	72bea4d0 	.word	0x72bea4d0
   31234:	3e663769 	.word	0x3e663769
   31238:	c5d26bf1 	.word	0xc5d26bf1
   3123c:	bebbbd41 	.word	0xbebbbd41
   31240:	af25de2c 	.word	0xaf25de2c
   31244:	3f11566a 	.word	0x3f11566a
   31248:	16bebd93 	.word	0x16bebd93
   3124c:	bf66c16c 	.word	0xbf66c16c
   31250:	5555553e 	.word	0x5555553e
   31254:	3fc55555 	.word	0x3fc55555
   31258:	652b82fe 	.word	0x652b82fe
   3125c:	3ff71547 	.word	0x3ff71547
   31260:	35793c76 	.word	0x35793c76
   31264:	3dea39ef 	.word	0x3dea39ef
   31268:	fee00000 	.word	0xfee00000
   3126c:	3fe62e42 	.word	0x3fe62e42
   31270:	00000000 	.word	0x00000000
   31274:	01700000 	.word	0x01700000
   31278:	40862e41 	.word	0x40862e41
   3127c:	7fefffff 	.word	0x7fefffff
   31280:	3fd62e42 	.word	0x3fd62e42
   31284:	3ff0a2b1 	.word	0x3ff0a2b1
   31288:	00055bb8 	.word	0x00055bb8
   3128c:	00055bc8 	.word	0x00055bc8
   31290:	00055ba8 	.word	0x00055ba8
   31294:	3e2fffff 	.word	0x3e2fffff

00031298 <__ieee754_pow>:
   31298:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3129c:	ec57 6b11 	vmov	r6, r7, d1
   312a0:	ed2d 8b02 	vpush	{d8}
   312a4:	eeb0 8b40 	vmov.f64	d8, d0
   312a8:	f027 4800 	bic.w	r8, r7, #2147483648	; 0x80000000
   312ac:	ea58 0306 	orrs.w	r3, r8, r6
   312b0:	b085      	sub	sp, #20
   312b2:	46b9      	mov	r9, r7
   312b4:	ee11 2a10 	vmov	r2, s2
   312b8:	f000 8306 	beq.w	318c8 <__ieee754_pow+0x630>
   312bc:	ee18 aa90 	vmov	sl, s17
   312c0:	4bb9      	ldr	r3, [pc, #740]	; (315a8 <__ieee754_pow+0x310>)
   312c2:	f02a 4400 	bic.w	r4, sl, #2147483648	; 0x80000000
   312c6:	429c      	cmp	r4, r3
   312c8:	ee10 ba10 	vmov	fp, s0
   312cc:	dc0b      	bgt.n	312e6 <__ieee754_pow+0x4e>
   312ce:	d105      	bne.n	312dc <__ieee754_pow+0x44>
   312d0:	f1bb 0f00 	cmp.w	fp, #0
   312d4:	d107      	bne.n	312e6 <__ieee754_pow+0x4e>
   312d6:	45a0      	cmp	r8, r4
   312d8:	dc0d      	bgt.n	312f6 <__ieee754_pow+0x5e>
   312da:	e001      	b.n	312e0 <__ieee754_pow+0x48>
   312dc:	4598      	cmp	r8, r3
   312de:	dc02      	bgt.n	312e6 <__ieee754_pow+0x4e>
   312e0:	4598      	cmp	r8, r3
   312e2:	d110      	bne.n	31306 <__ieee754_pow+0x6e>
   312e4:	b17a      	cbz	r2, 31306 <__ieee754_pow+0x6e>
   312e6:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
   312ea:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   312ee:	ea54 030b 	orrs.w	r3, r4, fp
   312f2:	f000 82e9 	beq.w	318c8 <__ieee754_pow+0x630>
   312f6:	48ad      	ldr	r0, [pc, #692]	; (315ac <__ieee754_pow+0x314>)
   312f8:	b005      	add	sp, #20
   312fa:	ecbd 8b02 	vpop	{d8}
   312fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31302:	f001 ba35 	b.w	32770 <nan>
   31306:	f1ba 0f00 	cmp.w	sl, #0
   3130a:	da4e      	bge.n	313aa <__ieee754_pow+0x112>
   3130c:	4ba8      	ldr	r3, [pc, #672]	; (315b0 <__ieee754_pow+0x318>)
   3130e:	4598      	cmp	r8, r3
   31310:	dc49      	bgt.n	313a6 <__ieee754_pow+0x10e>
   31312:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
   31316:	4598      	cmp	r8, r3
   31318:	dd47      	ble.n	313aa <__ieee754_pow+0x112>
   3131a:	ea4f 5328 	mov.w	r3, r8, asr #20
   3131e:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   31322:	2b14      	cmp	r3, #20
   31324:	dd24      	ble.n	31370 <__ieee754_pow+0xd8>
   31326:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
   3132a:	fa22 f503 	lsr.w	r5, r2, r3
   3132e:	fa05 f303 	lsl.w	r3, r5, r3
   31332:	4293      	cmp	r3, r2
   31334:	d139      	bne.n	313aa <__ieee754_pow+0x112>
   31336:	f005 0501 	and.w	r5, r5, #1
   3133a:	f1c5 0502 	rsb	r5, r5, #2
   3133e:	2a00      	cmp	r2, #0
   31340:	d15a      	bne.n	313f8 <__ieee754_pow+0x160>
   31342:	4b99      	ldr	r3, [pc, #612]	; (315a8 <__ieee754_pow+0x310>)
   31344:	4598      	cmp	r8, r3
   31346:	d122      	bne.n	3138e <__ieee754_pow+0xf6>
   31348:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
   3134c:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
   31350:	ea53 030b 	orrs.w	r3, r3, fp
   31354:	f000 82b8 	beq.w	318c8 <__ieee754_pow+0x630>
   31358:	4b96      	ldr	r3, [pc, #600]	; (315b4 <__ieee754_pow+0x31c>)
   3135a:	429c      	cmp	r4, r3
   3135c:	dd27      	ble.n	313ae <__ieee754_pow+0x116>
   3135e:	f1b9 0f00 	cmp.w	r9, #0
   31362:	f280 82b4 	bge.w	318ce <__ieee754_pow+0x636>
   31366:	ed9f 7b84 	vldr	d7, [pc, #528]	; 31578 <__ieee754_pow+0x2e0>
   3136a:	ed8d 7b00 	vstr	d7, [sp]
   3136e:	e026      	b.n	313be <__ieee754_pow+0x126>
   31370:	2a00      	cmp	r2, #0
   31372:	d140      	bne.n	313f6 <__ieee754_pow+0x15e>
   31374:	f1c3 0314 	rsb	r3, r3, #20
   31378:	fa48 f503 	asr.w	r5, r8, r3
   3137c:	fa05 f303 	lsl.w	r3, r5, r3
   31380:	4543      	cmp	r3, r8
   31382:	f040 82aa 	bne.w	318da <__ieee754_pow+0x642>
   31386:	f005 0501 	and.w	r5, r5, #1
   3138a:	f1c5 0502 	rsb	r5, r5, #2
   3138e:	4b8a      	ldr	r3, [pc, #552]	; (315b8 <__ieee754_pow+0x320>)
   31390:	4598      	cmp	r8, r3
   31392:	d11b      	bne.n	313cc <__ieee754_pow+0x134>
   31394:	f1b9 0f00 	cmp.w	r9, #0
   31398:	f280 829c 	bge.w	318d4 <__ieee754_pow+0x63c>
   3139c:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   313a0:	ee87 7b08 	vdiv.f64	d7, d7, d8
   313a4:	e7e1      	b.n	3136a <__ieee754_pow+0xd2>
   313a6:	2502      	movs	r5, #2
   313a8:	e7c9      	b.n	3133e <__ieee754_pow+0xa6>
   313aa:	2500      	movs	r5, #0
   313ac:	e7c7      	b.n	3133e <__ieee754_pow+0xa6>
   313ae:	f1b9 0f00 	cmp.w	r9, #0
   313b2:	dad8      	bge.n	31366 <__ieee754_pow+0xce>
   313b4:	f087 4400 	eor.w	r4, r7, #2147483648	; 0x80000000
   313b8:	4633      	mov	r3, r6
   313ba:	e9cd 3400 	strd	r3, r4, [sp]
   313be:	ed9d 0b00 	vldr	d0, [sp]
   313c2:	b005      	add	sp, #20
   313c4:	ecbd 8b02 	vpop	{d8}
   313c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   313cc:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
   313d0:	d102      	bne.n	313d8 <__ieee754_pow+0x140>
   313d2:	ee28 7b08 	vmul.f64	d7, d8, d8
   313d6:	e7c8      	b.n	3136a <__ieee754_pow+0xd2>
   313d8:	4b78      	ldr	r3, [pc, #480]	; (315bc <__ieee754_pow+0x324>)
   313da:	4599      	cmp	r9, r3
   313dc:	d10c      	bne.n	313f8 <__ieee754_pow+0x160>
   313de:	f1ba 0f00 	cmp.w	sl, #0
   313e2:	db09      	blt.n	313f8 <__ieee754_pow+0x160>
   313e4:	eeb0 0b48 	vmov.f64	d0, d8
   313e8:	b005      	add	sp, #20
   313ea:	ecbd 8b02 	vpop	{d8}
   313ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   313f2:	f000 bad7 	b.w	319a4 <__ieee754_sqrt>
   313f6:	2500      	movs	r5, #0
   313f8:	eeb0 0b48 	vmov.f64	d0, d8
   313fc:	f001 f9a5 	bl	3274a <fabs>
   31400:	ed8d 0b00 	vstr	d0, [sp]
   31404:	f1bb 0f00 	cmp.w	fp, #0
   31408:	d128      	bne.n	3145c <__ieee754_pow+0x1c4>
   3140a:	b124      	cbz	r4, 31416 <__ieee754_pow+0x17e>
   3140c:	4b6a      	ldr	r3, [pc, #424]	; (315b8 <__ieee754_pow+0x320>)
   3140e:	f02a 4240 	bic.w	r2, sl, #3221225472	; 0xc0000000
   31412:	429a      	cmp	r2, r3
   31414:	d122      	bne.n	3145c <__ieee754_pow+0x1c4>
   31416:	f1b9 0f00 	cmp.w	r9, #0
   3141a:	da07      	bge.n	3142c <__ieee754_pow+0x194>
   3141c:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   31420:	ed9d 6b00 	vldr	d6, [sp]
   31424:	ee87 7b06 	vdiv.f64	d7, d7, d6
   31428:	ed8d 7b00 	vstr	d7, [sp]
   3142c:	f1ba 0f00 	cmp.w	sl, #0
   31430:	dac5      	bge.n	313be <__ieee754_pow+0x126>
   31432:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
   31436:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   3143a:	ea54 0305 	orrs.w	r3, r4, r5
   3143e:	d106      	bne.n	3144e <__ieee754_pow+0x1b6>
   31440:	ed9d 7b00 	vldr	d7, [sp]
   31444:	ee37 7b47 	vsub.f64	d7, d7, d7
   31448:	ee87 7b07 	vdiv.f64	d7, d7, d7
   3144c:	e78d      	b.n	3136a <__ieee754_pow+0xd2>
   3144e:	2d01      	cmp	r5, #1
   31450:	d1b5      	bne.n	313be <__ieee754_pow+0x126>
   31452:	ed9d 7b00 	vldr	d7, [sp]
   31456:	eeb1 7b47 	vneg.f64	d7, d7
   3145a:	e786      	b.n	3136a <__ieee754_pow+0xd2>
   3145c:	ea4f 7ada 	mov.w	sl, sl, lsr #31
   31460:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   31464:	ea55 030a 	orrs.w	r3, r5, sl
   31468:	d104      	bne.n	31474 <__ieee754_pow+0x1dc>
   3146a:	ee38 8b48 	vsub.f64	d8, d8, d8
   3146e:	ee88 7b08 	vdiv.f64	d7, d8, d8
   31472:	e77a      	b.n	3136a <__ieee754_pow+0xd2>
   31474:	4b52      	ldr	r3, [pc, #328]	; (315c0 <__ieee754_pow+0x328>)
   31476:	4598      	cmp	r8, r3
   31478:	f340 80a8 	ble.w	315cc <__ieee754_pow+0x334>
   3147c:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
   31480:	4598      	cmp	r8, r3
   31482:	dd0b      	ble.n	3149c <__ieee754_pow+0x204>
   31484:	4b4b      	ldr	r3, [pc, #300]	; (315b4 <__ieee754_pow+0x31c>)
   31486:	429c      	cmp	r4, r3
   31488:	dc0e      	bgt.n	314a8 <__ieee754_pow+0x210>
   3148a:	f1b9 0f00 	cmp.w	r9, #0
   3148e:	f6bf af6a 	bge.w	31366 <__ieee754_pow+0xce>
   31492:	ed9f 7b3b 	vldr	d7, [pc, #236]	; 31580 <__ieee754_pow+0x2e8>
   31496:	ee27 7b07 	vmul.f64	d7, d7, d7
   3149a:	e766      	b.n	3136a <__ieee754_pow+0xd2>
   3149c:	4b49      	ldr	r3, [pc, #292]	; (315c4 <__ieee754_pow+0x32c>)
   3149e:	429c      	cmp	r4, r3
   314a0:	ddf3      	ble.n	3148a <__ieee754_pow+0x1f2>
   314a2:	4b45      	ldr	r3, [pc, #276]	; (315b8 <__ieee754_pow+0x320>)
   314a4:	429c      	cmp	r4, r3
   314a6:	dd03      	ble.n	314b0 <__ieee754_pow+0x218>
   314a8:	f1b9 0f00 	cmp.w	r9, #0
   314ac:	dcf1      	bgt.n	31492 <__ieee754_pow+0x1fa>
   314ae:	e75a      	b.n	31366 <__ieee754_pow+0xce>
   314b0:	ed9d 7b00 	vldr	d7, [sp]
   314b4:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   314b8:	ed9f 5b33 	vldr	d5, [pc, #204]	; 31588 <__ieee754_pow+0x2f0>
   314bc:	ee37 6b46 	vsub.f64	d6, d7, d6
   314c0:	eeb5 7b00 	vmov.f64	d7, #80	; 0x3e800000  0.250
   314c4:	eeb1 3b46 	vneg.f64	d3, d6
   314c8:	eea3 5b07 	vfma.f64	d5, d3, d7
   314cc:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
   314d0:	eea5 7b46 	vfms.f64	d7, d5, d6
   314d4:	ee26 5b06 	vmul.f64	d5, d6, d6
   314d8:	ee27 5b05 	vmul.f64	d5, d7, d5
   314dc:	ed9f 7b2c 	vldr	d7, [pc, #176]	; 31590 <__ieee754_pow+0x2f8>
   314e0:	ee27 7b45 	vnmul.f64	d7, d7, d5
   314e4:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 31598 <__ieee754_pow+0x300>
   314e8:	eea6 7b05 	vfma.f64	d7, d6, d5
   314ec:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 315a0 <__ieee754_pow+0x308>
   314f0:	eeb0 4b47 	vmov.f64	d4, d7
   314f4:	eea6 4b05 	vfma.f64	d4, d6, d5
   314f8:	ec53 2b14 	vmov	r2, r3, d4
   314fc:	2200      	movs	r2, #0
   314fe:	ec43 2b14 	vmov	d4, r2, r3
   31502:	eeb0 6b44 	vmov.f64	d6, d4
   31506:	eea3 6b05 	vfma.f64	d6, d3, d5
   3150a:	ee37 7b46 	vsub.f64	d7, d7, d6
   3150e:	3d01      	subs	r5, #1
   31510:	ea55 030a 	orrs.w	r3, r5, sl
   31514:	f04f 0200 	mov.w	r2, #0
   31518:	463b      	mov	r3, r7
   3151a:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   3151e:	eeb7 8b00 	vmov.f64	d8, #112	; 0x3f800000  1.0
   31522:	ec47 6b15 	vmov	d5, r6, r7
   31526:	fe06 8b08 	vseleq.f64	d8, d6, d8
   3152a:	ec47 6b13 	vmov	d3, r6, r7
   3152e:	ec43 2b16 	vmov	d6, r2, r3
   31532:	ee27 7b03 	vmul.f64	d7, d7, d3
   31536:	ee35 5b46 	vsub.f64	d5, d5, d6
   3153a:	4b23      	ldr	r3, [pc, #140]	; (315c8 <__ieee754_pow+0x330>)
   3153c:	eea5 7b04 	vfma.f64	d7, d5, d4
   31540:	ee24 6b06 	vmul.f64	d6, d4, d6
   31544:	ee37 5b06 	vadd.f64	d5, d7, d6
   31548:	ee15 1a90 	vmov	r1, s11
   3154c:	4299      	cmp	r1, r3
   3154e:	ee15 2a10 	vmov	r2, s10
   31552:	f340 819b 	ble.w	3188c <__ieee754_pow+0x5f4>
   31556:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
   3155a:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
   3155e:	4313      	orrs	r3, r2
   31560:	f000 810a 	beq.w	31778 <__ieee754_pow+0x4e0>
   31564:	ed9f 7b06 	vldr	d7, [pc, #24]	; 31580 <__ieee754_pow+0x2e8>
   31568:	ee28 8b07 	vmul.f64	d8, d8, d7
   3156c:	ee28 7b07 	vmul.f64	d7, d8, d7
   31570:	e6fb      	b.n	3136a <__ieee754_pow+0xd2>
   31572:	bf00      	nop
   31574:	f3af 8000 	nop.w
	...
   31580:	8800759c 	.word	0x8800759c
   31584:	7e37e43c 	.word	0x7e37e43c
   31588:	55555555 	.word	0x55555555
   3158c:	3fd55555 	.word	0x3fd55555
   31590:	652b82fe 	.word	0x652b82fe
   31594:	3ff71547 	.word	0x3ff71547
   31598:	f85ddf44 	.word	0xf85ddf44
   3159c:	3e54ae0b 	.word	0x3e54ae0b
   315a0:	60000000 	.word	0x60000000
   315a4:	3ff71547 	.word	0x3ff71547
   315a8:	7ff00000 	.word	0x7ff00000
   315ac:	00055b9c 	.word	0x00055b9c
   315b0:	433fffff 	.word	0x433fffff
   315b4:	3fefffff 	.word	0x3fefffff
   315b8:	3ff00000 	.word	0x3ff00000
   315bc:	3fe00000 	.word	0x3fe00000
   315c0:	41e00000 	.word	0x41e00000
   315c4:	3feffffe 	.word	0x3feffffe
   315c8:	408fffff 	.word	0x408fffff
   315cc:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
   315d0:	f280 80ce 	bge.w	31770 <__ieee754_pow+0x4d8>
   315d4:	ed9d 6b00 	vldr	d6, [sp]
   315d8:	ed9f 7bc1 	vldr	d7, [pc, #772]	; 318e0 <__ieee754_pow+0x648>
   315dc:	ee26 7b07 	vmul.f64	d7, d6, d7
   315e0:	ed8d 7b00 	vstr	d7, [sp]
   315e4:	9c01      	ldr	r4, [sp, #4]
   315e6:	f06f 0334 	mvn.w	r3, #52	; 0x34
   315ea:	1521      	asrs	r1, r4, #20
   315ec:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
   315f0:	4419      	add	r1, r3
   315f2:	4be3      	ldr	r3, [pc, #908]	; (31980 <__ieee754_pow+0x6e8>)
   315f4:	f3c4 0413 	ubfx	r4, r4, #0, #20
   315f8:	f044 507f 	orr.w	r0, r4, #1069547520	; 0x3fc00000
   315fc:	429c      	cmp	r4, r3
   315fe:	f440 1040 	orr.w	r0, r0, #3145728	; 0x300000
   31602:	dd06      	ble.n	31612 <__ieee754_pow+0x37a>
   31604:	4bdf      	ldr	r3, [pc, #892]	; (31984 <__ieee754_pow+0x6ec>)
   31606:	429c      	cmp	r4, r3
   31608:	f340 80b4 	ble.w	31774 <__ieee754_pow+0x4dc>
   3160c:	3101      	adds	r1, #1
   3160e:	f5a0 1080 	sub.w	r0, r0, #1048576	; 0x100000
   31612:	2400      	movs	r4, #0
   31614:	e9dd 2300 	ldrd	r2, r3, [sp]
   31618:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
   3161c:	4603      	mov	r3, r0
   3161e:	ec43 2b17 	vmov	d7, r2, r3
   31622:	4bd9      	ldr	r3, [pc, #868]	; (31988 <__ieee754_pow+0x6f0>)
   31624:	ea4f 0cc4 	mov.w	ip, r4, lsl #3
   31628:	4463      	add	r3, ip
   3162a:	ed93 5b00 	vldr	d5, [r3]
   3162e:	1040      	asrs	r0, r0, #1
   31630:	ee37 2b45 	vsub.f64	d2, d7, d5
   31634:	ee35 6b07 	vadd.f64	d6, d5, d7
   31638:	ee84 1b06 	vdiv.f64	d1, d4, d6
   3163c:	ee22 6b01 	vmul.f64	d6, d2, d1
   31640:	ed8d 6b00 	vstr	d6, [sp]
   31644:	e9dd 8900 	ldrd	r8, r9, [sp]
   31648:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
   3164c:	f500 2000 	add.w	r0, r0, #524288	; 0x80000
   31650:	f04f 0800 	mov.w	r8, #0
   31654:	eb00 4384 	add.w	r3, r0, r4, lsl #18
   31658:	2200      	movs	r2, #0
   3165a:	ec49 8b14 	vmov	d4, r8, r9
   3165e:	ec43 2b16 	vmov	d6, r2, r3
   31662:	eeb1 3b44 	vneg.f64	d3, d4
   31666:	eea3 2b06 	vfma.f64	d2, d3, d6
   3166a:	ee36 6b45 	vsub.f64	d6, d6, d5
   3166e:	ee37 7b46 	vsub.f64	d7, d7, d6
   31672:	eea3 2b07 	vfma.f64	d2, d3, d7
   31676:	ed9d 7b00 	vldr	d7, [sp]
   3167a:	ee22 2b01 	vmul.f64	d2, d2, d1
   3167e:	ee27 5b07 	vmul.f64	d5, d7, d7
   31682:	ee37 6b04 	vadd.f64	d6, d7, d4
   31686:	ed9f 1b98 	vldr	d1, [pc, #608]	; 318e8 <__ieee754_pow+0x650>
   3168a:	ee25 0b05 	vmul.f64	d0, d5, d5
   3168e:	ee26 6b02 	vmul.f64	d6, d6, d2
   31692:	ed9f 7b97 	vldr	d7, [pc, #604]	; 318f0 <__ieee754_pow+0x658>
   31696:	eea5 7b01 	vfma.f64	d7, d5, d1
   3169a:	ed9f 1b97 	vldr	d1, [pc, #604]	; 318f8 <__ieee754_pow+0x660>
   3169e:	eea7 1b05 	vfma.f64	d1, d7, d5
   316a2:	ed9f 7b97 	vldr	d7, [pc, #604]	; 31900 <__ieee754_pow+0x668>
   316a6:	eea1 7b05 	vfma.f64	d7, d1, d5
   316aa:	ed9f 1b97 	vldr	d1, [pc, #604]	; 31908 <__ieee754_pow+0x670>
   316ae:	eea7 1b05 	vfma.f64	d1, d7, d5
   316b2:	ed9f 7b97 	vldr	d7, [pc, #604]	; 31910 <__ieee754_pow+0x678>
   316b6:	eea1 7b05 	vfma.f64	d7, d1, d5
   316ba:	eea0 6b07 	vfma.f64	d6, d0, d7
   316be:	eeb0 7b08 	vmov.f64	d7, #8	; 0x40400000  3.0
   316c2:	eeb0 5b47 	vmov.f64	d5, d7
   316c6:	eea4 5b04 	vfma.f64	d5, d4, d4
   316ca:	ee35 5b06 	vadd.f64	d5, d5, d6
   316ce:	ed8d 5b02 	vstr	d5, [sp, #8]
   316d2:	f8cd 8008 	str.w	r8, [sp, #8]
   316d6:	ed9d 5b02 	vldr	d5, [sp, #8]
   316da:	ee35 7b47 	vsub.f64	d7, d5, d7
   316de:	eea3 7b04 	vfma.f64	d7, d3, d4
   316e2:	ee36 7b47 	vsub.f64	d7, d6, d7
   316e6:	ed9d 6b00 	vldr	d6, [sp]
   316ea:	ee27 7b06 	vmul.f64	d7, d7, d6
   316ee:	eea2 7b05 	vfma.f64	d7, d2, d5
   316f2:	eeb0 6b47 	vmov.f64	d6, d7
   316f6:	eea4 6b05 	vfma.f64	d6, d4, d5
   316fa:	ed8d 6b00 	vstr	d6, [sp]
   316fe:	f8cd 8000 	str.w	r8, [sp]
   31702:	ed9d 2b00 	vldr	d2, [sp]
   31706:	eeb0 6b42 	vmov.f64	d6, d2
   3170a:	eea3 6b05 	vfma.f64	d6, d3, d5
   3170e:	ee37 7b46 	vsub.f64	d7, d7, d6
   31712:	ed9f 6b81 	vldr	d6, [pc, #516]	; 31918 <__ieee754_pow+0x680>
   31716:	4b9d      	ldr	r3, [pc, #628]	; (3198c <__ieee754_pow+0x6f4>)
   31718:	ee27 7b06 	vmul.f64	d7, d7, d6
   3171c:	ed9f 6b80 	vldr	d6, [pc, #512]	; 31920 <__ieee754_pow+0x688>
   31720:	4463      	add	r3, ip
   31722:	eea2 7b06 	vfma.f64	d7, d2, d6
   31726:	ed93 6b00 	vldr	d6, [r3]
   3172a:	4b99      	ldr	r3, [pc, #612]	; (31990 <__ieee754_pow+0x6f8>)
   3172c:	ee37 6b06 	vadd.f64	d6, d7, d6
   31730:	449c      	add	ip, r3
   31732:	ed9c 1b00 	vldr	d1, [ip]
   31736:	eeb0 4b46 	vmov.f64	d4, d6
   3173a:	ed9f 3b7b 	vldr	d3, [pc, #492]	; 31928 <__ieee754_pow+0x690>
   3173e:	ee07 1a90 	vmov	s15, r1
   31742:	eea2 4b03 	vfma.f64	d4, d2, d3
   31746:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   3174a:	ee34 4b01 	vadd.f64	d4, d4, d1
   3174e:	ee34 5b07 	vadd.f64	d5, d4, d7
   31752:	ed8d 5b00 	vstr	d5, [sp]
   31756:	f8cd 8000 	str.w	r8, [sp]
   3175a:	ed9d 4b00 	vldr	d4, [sp]
   3175e:	ee34 7b47 	vsub.f64	d7, d4, d7
   31762:	ee37 7b41 	vsub.f64	d7, d7, d1
   31766:	eea2 7b43 	vfms.f64	d7, d2, d3
   3176a:	ee36 7b47 	vsub.f64	d7, d6, d7
   3176e:	e6ce      	b.n	3150e <__ieee754_pow+0x276>
   31770:	2300      	movs	r3, #0
   31772:	e73a      	b.n	315ea <__ieee754_pow+0x352>
   31774:	2401      	movs	r4, #1
   31776:	e74d      	b.n	31614 <__ieee754_pow+0x37c>
   31778:	ed9f 4b6d 	vldr	d4, [pc, #436]	; 31930 <__ieee754_pow+0x698>
   3177c:	ee35 5b46 	vsub.f64	d5, d5, d6
   31780:	ee37 4b04 	vadd.f64	d4, d7, d4
   31784:	eeb4 4bc5 	vcmpe.f64	d4, d5
   31788:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3178c:	f73f aeea 	bgt.w	31564 <__ieee754_pow+0x2cc>
   31790:	4a80      	ldr	r2, [pc, #512]	; (31994 <__ieee754_pow+0x6fc>)
   31792:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   31796:	4293      	cmp	r3, r2
   31798:	f340 808e 	ble.w	318b8 <__ieee754_pow+0x620>
   3179c:	151b      	asrs	r3, r3, #20
   3179e:	f2a3 30fe 	subw	r0, r3, #1022	; 0x3fe
   317a2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   317a6:	4103      	asrs	r3, r0
   317a8:	440b      	add	r3, r1
   317aa:	f3c3 520a 	ubfx	r2, r3, #20, #11
   317ae:	487a      	ldr	r0, [pc, #488]	; (31998 <__ieee754_pow+0x700>)
   317b0:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
   317b4:	4110      	asrs	r0, r2
   317b6:	ea23 0500 	bic.w	r5, r3, r0
   317ba:	f3c3 0013 	ubfx	r0, r3, #0, #20
   317be:	2400      	movs	r4, #0
   317c0:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
   317c4:	f1c2 0214 	rsb	r2, r2, #20
   317c8:	ec45 4b15 	vmov	d5, r4, r5
   317cc:	4110      	asrs	r0, r2
   317ce:	2900      	cmp	r1, #0
   317d0:	bfb8      	it	lt
   317d2:	4240      	neglt	r0, r0
   317d4:	ee36 6b45 	vsub.f64	d6, d6, d5
   317d8:	ee36 5b07 	vadd.f64	d5, d6, d7
   317dc:	ec53 2b15 	vmov	r2, r3, d5
   317e0:	2200      	movs	r2, #0
   317e2:	ec43 2b15 	vmov	d5, r2, r3
   317e6:	ed9f 4b54 	vldr	d4, [pc, #336]	; 31938 <__ieee754_pow+0x6a0>
   317ea:	ee35 6b46 	vsub.f64	d6, d5, d6
   317ee:	ee37 6b46 	vsub.f64	d6, d7, d6
   317f2:	ed9f 7b53 	vldr	d7, [pc, #332]	; 31940 <__ieee754_pow+0x6a8>
   317f6:	ee25 7b07 	vmul.f64	d7, d5, d7
   317fa:	eea6 7b04 	vfma.f64	d7, d6, d4
   317fe:	ed9f 6b52 	vldr	d6, [pc, #328]	; 31948 <__ieee754_pow+0x6b0>
   31802:	eeb0 4b47 	vmov.f64	d4, d7
   31806:	eea5 4b06 	vfma.f64	d4, d5, d6
   3180a:	eeb0 3b44 	vmov.f64	d3, d4
   3180e:	eea5 3b46 	vfms.f64	d3, d5, d6
   31812:	ed9f 5b4f 	vldr	d5, [pc, #316]	; 31950 <__ieee754_pow+0x6b8>
   31816:	ee37 7b43 	vsub.f64	d7, d7, d3
   3181a:	ee24 6b04 	vmul.f64	d6, d4, d4
   3181e:	ed9f 3b4e 	vldr	d3, [pc, #312]	; 31958 <__ieee754_pow+0x6c0>
   31822:	eea4 7b07 	vfma.f64	d7, d4, d7
   31826:	eea6 3b05 	vfma.f64	d3, d6, d5
   3182a:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 31960 <__ieee754_pow+0x6c8>
   3182e:	eea3 5b06 	vfma.f64	d5, d3, d6
   31832:	ed9f 3b4d 	vldr	d3, [pc, #308]	; 31968 <__ieee754_pow+0x6d0>
   31836:	eea5 3b06 	vfma.f64	d3, d5, d6
   3183a:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 31970 <__ieee754_pow+0x6d8>
   3183e:	eea3 5b06 	vfma.f64	d5, d3, d6
   31842:	eeb0 3b44 	vmov.f64	d3, d4
   31846:	eea5 3b46 	vfms.f64	d3, d5, d6
   3184a:	eeb0 5b00 	vmov.f64	d5, #0	; 0x40000000  2.0
   3184e:	eeb0 6b43 	vmov.f64	d6, d3
   31852:	ee24 3b03 	vmul.f64	d3, d4, d3
   31856:	ee36 5b45 	vsub.f64	d5, d6, d5
   3185a:	ee83 6b05 	vdiv.f64	d6, d3, d5
   3185e:	ee36 7b47 	vsub.f64	d7, d6, d7
   31862:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   31866:	ee37 7b44 	vsub.f64	d7, d7, d4
   3186a:	ee36 7b47 	vsub.f64	d7, d6, d7
   3186e:	ed8d 7b00 	vstr	d7, [sp]
   31872:	9901      	ldr	r1, [sp, #4]
   31874:	eb01 5100 	add.w	r1, r1, r0, lsl #20
   31878:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   3187c:	da1e      	bge.n	318bc <__ieee754_pow+0x624>
   3187e:	eeb0 0b47 	vmov.f64	d0, d7
   31882:	f001 f809 	bl	32898 <scalbn>
   31886:	ee20 7b08 	vmul.f64	d7, d0, d8
   3188a:	e56e      	b.n	3136a <__ieee754_pow+0xd2>
   3188c:	4b43      	ldr	r3, [pc, #268]	; (3199c <__ieee754_pow+0x704>)
   3188e:	f021 4000 	bic.w	r0, r1, #2147483648	; 0x80000000
   31892:	4298      	cmp	r0, r3
   31894:	f77f af7c 	ble.w	31790 <__ieee754_pow+0x4f8>
   31898:	4b41      	ldr	r3, [pc, #260]	; (319a0 <__ieee754_pow+0x708>)
   3189a:	440b      	add	r3, r1
   3189c:	4313      	orrs	r3, r2
   3189e:	d002      	beq.n	318a6 <__ieee754_pow+0x60e>
   318a0:	ed9f 7b35 	vldr	d7, [pc, #212]	; 31978 <__ieee754_pow+0x6e0>
   318a4:	e660      	b.n	31568 <__ieee754_pow+0x2d0>
   318a6:	ee35 5b46 	vsub.f64	d5, d5, d6
   318aa:	eeb4 5bc7 	vcmpe.f64	d5, d7
   318ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   318b2:	f6ff af6d 	blt.w	31790 <__ieee754_pow+0x4f8>
   318b6:	e7f3      	b.n	318a0 <__ieee754_pow+0x608>
   318b8:	2000      	movs	r0, #0
   318ba:	e78d      	b.n	317d8 <__ieee754_pow+0x540>
   318bc:	e9dd 2300 	ldrd	r2, r3, [sp]
   318c0:	460b      	mov	r3, r1
   318c2:	ec43 2b10 	vmov	d0, r2, r3
   318c6:	e7de      	b.n	31886 <__ieee754_pow+0x5ee>
   318c8:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   318cc:	e54d      	b.n	3136a <__ieee754_pow+0xd2>
   318ce:	e9cd 6700 	strd	r6, r7, [sp]
   318d2:	e574      	b.n	313be <__ieee754_pow+0x126>
   318d4:	ed8d 8b00 	vstr	d8, [sp]
   318d8:	e571      	b.n	313be <__ieee754_pow+0x126>
   318da:	4615      	mov	r5, r2
   318dc:	e557      	b.n	3138e <__ieee754_pow+0xf6>
   318de:	bf00      	nop
   318e0:	00000000 	.word	0x00000000
   318e4:	43400000 	.word	0x43400000
   318e8:	4a454eef 	.word	0x4a454eef
   318ec:	3fca7e28 	.word	0x3fca7e28
   318f0:	93c9db65 	.word	0x93c9db65
   318f4:	3fcd864a 	.word	0x3fcd864a
   318f8:	a91d4101 	.word	0xa91d4101
   318fc:	3fd17460 	.word	0x3fd17460
   31900:	518f264d 	.word	0x518f264d
   31904:	3fd55555 	.word	0x3fd55555
   31908:	db6fabff 	.word	0xdb6fabff
   3190c:	3fdb6db6 	.word	0x3fdb6db6
   31910:	33333303 	.word	0x33333303
   31914:	3fe33333 	.word	0x3fe33333
   31918:	dc3a03fd 	.word	0xdc3a03fd
   3191c:	3feec709 	.word	0x3feec709
   31920:	145b01f5 	.word	0x145b01f5
   31924:	be3e2fe0 	.word	0xbe3e2fe0
   31928:	e0000000 	.word	0xe0000000
   3192c:	3feec709 	.word	0x3feec709
   31930:	652b82fe 	.word	0x652b82fe
   31934:	3c971547 	.word	0x3c971547
   31938:	fefa39ef 	.word	0xfefa39ef
   3193c:	3fe62e42 	.word	0x3fe62e42
   31940:	0ca86c39 	.word	0x0ca86c39
   31944:	be205c61 	.word	0xbe205c61
   31948:	00000000 	.word	0x00000000
   3194c:	3fe62e43 	.word	0x3fe62e43
   31950:	72bea4d0 	.word	0x72bea4d0
   31954:	3e663769 	.word	0x3e663769
   31958:	c5d26bf1 	.word	0xc5d26bf1
   3195c:	bebbbd41 	.word	0xbebbbd41
   31960:	af25de2c 	.word	0xaf25de2c
   31964:	3f11566a 	.word	0x3f11566a
   31968:	16bebd93 	.word	0x16bebd93
   3196c:	bf66c16c 	.word	0xbf66c16c
   31970:	5555553e 	.word	0x5555553e
   31974:	3fc55555 	.word	0x3fc55555
   31978:	c2f8f359 	.word	0xc2f8f359
   3197c:	01a56e1f 	.word	0x01a56e1f
   31980:	0003988e 	.word	0x0003988e
   31984:	000bb679 	.word	0x000bb679
   31988:	00055bd8 	.word	0x00055bd8
   3198c:	00055bf8 	.word	0x00055bf8
   31990:	00055be8 	.word	0x00055be8
   31994:	3fe00000 	.word	0x3fe00000
   31998:	000fffff 	.word	0x000fffff
   3199c:	4090cbff 	.word	0x4090cbff
   319a0:	3f6f3400 	.word	0x3f6f3400

000319a4 <__ieee754_sqrt>:
   319a4:	eeb1 0bc0 	vsqrt.f64	d0, d0
   319a8:	4770      	bx	lr
	...

000319ac <__ieee754_fmodf>:
   319ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   319ae:	ee10 6a90 	vmov	r6, s1
   319b2:	f036 4500 	bics.w	r5, r6, #2147483648	; 0x80000000
   319b6:	ee10 3a10 	vmov	r3, s0
   319ba:	d009      	beq.n	319d0 <__ieee754_fmodf+0x24>
   319bc:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   319c0:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   319c4:	ee10 7a10 	vmov	r7, s0
   319c8:	da02      	bge.n	319d0 <__ieee754_fmodf+0x24>
   319ca:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
   319ce:	dd0a      	ble.n	319e6 <__ieee754_fmodf+0x3a>
   319d0:	ee07 3a90 	vmov	s15, r3
   319d4:	ee67 0aa0 	vmul.f32	s1, s15, s1
   319d8:	eec0 7aa0 	vdiv.f32	s15, s1, s1
   319dc:	ee17 3a90 	vmov	r3, s15
   319e0:	ee00 3a10 	vmov	s0, r3
   319e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   319e6:	42a9      	cmp	r1, r5
   319e8:	dbfa      	blt.n	319e0 <__ieee754_fmodf+0x34>
   319ea:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
   319ee:	d105      	bne.n	319fc <__ieee754_fmodf+0x50>
   319f0:	4a30      	ldr	r2, [pc, #192]	; (31ab4 <__ieee754_fmodf+0x108>)
   319f2:	0fe3      	lsrs	r3, r4, #31
   319f4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   319f8:	681b      	ldr	r3, [r3, #0]
   319fa:	e7f1      	b.n	319e0 <__ieee754_fmodf+0x34>
   319fc:	4b2e      	ldr	r3, [pc, #184]	; (31ab8 <__ieee754_fmodf+0x10c>)
   319fe:	4299      	cmp	r1, r3
   31a00:	dc3e      	bgt.n	31a80 <__ieee754_fmodf+0xd4>
   31a02:	020a      	lsls	r2, r1, #8
   31a04:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   31a08:	2a00      	cmp	r2, #0
   31a0a:	dc36      	bgt.n	31a7a <__ieee754_fmodf+0xce>
   31a0c:	429d      	cmp	r5, r3
   31a0e:	dc3a      	bgt.n	31a86 <__ieee754_fmodf+0xda>
   31a10:	022b      	lsls	r3, r5, #8
   31a12:	f06f 027d 	mvn.w	r2, #125	; 0x7d
   31a16:	005b      	lsls	r3, r3, #1
   31a18:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
   31a1c:	d5fb      	bpl.n	31a16 <__ieee754_fmodf+0x6a>
   31a1e:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
   31a22:	bfbb      	ittet	lt
   31a24:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
   31a28:	1a1b      	sublt	r3, r3, r0
   31a2a:	f3c7 0116 	ubfxge	r1, r7, #0, #23
   31a2e:	4099      	lsllt	r1, r3
   31a30:	bfa8      	it	ge
   31a32:	f441 0100 	orrge.w	r1, r1, #8388608	; 0x800000
   31a36:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
   31a3a:	bfb5      	itete	lt
   31a3c:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
   31a40:	f3c6 0516 	ubfxge	r5, r6, #0, #23
   31a44:	1a9b      	sublt	r3, r3, r2
   31a46:	f445 0500 	orrge.w	r5, r5, #8388608	; 0x800000
   31a4a:	bfb8      	it	lt
   31a4c:	409d      	lsllt	r5, r3
   31a4e:	1a80      	subs	r0, r0, r2
   31a50:	1b4b      	subs	r3, r1, r5
   31a52:	b9d8      	cbnz	r0, 31a8c <__ieee754_fmodf+0xe0>
   31a54:	ea33 0323 	bics.w	r3, r3, r3, asr #32
   31a58:	bf28      	it	cs
   31a5a:	460b      	movcs	r3, r1
   31a5c:	2b00      	cmp	r3, #0
   31a5e:	d0c7      	beq.n	319f0 <__ieee754_fmodf+0x44>
   31a60:	4915      	ldr	r1, [pc, #84]	; (31ab8 <__ieee754_fmodf+0x10c>)
   31a62:	428b      	cmp	r3, r1
   31a64:	dd1a      	ble.n	31a9c <__ieee754_fmodf+0xf0>
   31a66:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
   31a6a:	db1a      	blt.n	31aa2 <__ieee754_fmodf+0xf6>
   31a6c:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   31a70:	4323      	orrs	r3, r4
   31a72:	327f      	adds	r2, #127	; 0x7f
   31a74:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   31a78:	e7b2      	b.n	319e0 <__ieee754_fmodf+0x34>
   31a7a:	3801      	subs	r0, #1
   31a7c:	0052      	lsls	r2, r2, #1
   31a7e:	e7c3      	b.n	31a08 <__ieee754_fmodf+0x5c>
   31a80:	15c8      	asrs	r0, r1, #23
   31a82:	387f      	subs	r0, #127	; 0x7f
   31a84:	e7c2      	b.n	31a0c <__ieee754_fmodf+0x60>
   31a86:	15ea      	asrs	r2, r5, #23
   31a88:	3a7f      	subs	r2, #127	; 0x7f
   31a8a:	e7c8      	b.n	31a1e <__ieee754_fmodf+0x72>
   31a8c:	2b00      	cmp	r3, #0
   31a8e:	da02      	bge.n	31a96 <__ieee754_fmodf+0xea>
   31a90:	0049      	lsls	r1, r1, #1
   31a92:	3801      	subs	r0, #1
   31a94:	e7dc      	b.n	31a50 <__ieee754_fmodf+0xa4>
   31a96:	d0ab      	beq.n	319f0 <__ieee754_fmodf+0x44>
   31a98:	0059      	lsls	r1, r3, #1
   31a9a:	e7fa      	b.n	31a92 <__ieee754_fmodf+0xe6>
   31a9c:	005b      	lsls	r3, r3, #1
   31a9e:	3a01      	subs	r2, #1
   31aa0:	e7df      	b.n	31a62 <__ieee754_fmodf+0xb6>
   31aa2:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
   31aa6:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
   31aaa:	3282      	adds	r2, #130	; 0x82
   31aac:	4113      	asrs	r3, r2
   31aae:	4323      	orrs	r3, r4
   31ab0:	e796      	b.n	319e0 <__ieee754_fmodf+0x34>
   31ab2:	bf00      	nop
   31ab4:	00055c08 	.word	0x00055c08
   31ab8:	007fffff 	.word	0x007fffff

00031abc <__ieee754_log10f>:
   31abc:	b508      	push	{r3, lr}
   31abe:	ee10 2a10 	vmov	r2, s0
   31ac2:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
   31ac6:	ed2d 8b02 	vpush	{d8}
   31aca:	d108      	bne.n	31ade <__ieee754_log10f+0x22>
   31acc:	ed9f 7a20 	vldr	s14, [pc, #128]	; 31b50 <__ieee754_log10f+0x94>
   31ad0:	eddf 7a20 	vldr	s15, [pc, #128]	; 31b54 <__ieee754_log10f+0x98>
   31ad4:	ee87 0a27 	vdiv.f32	s0, s14, s15
   31ad8:	ecbd 8b02 	vpop	{d8}
   31adc:	bd08      	pop	{r3, pc}
   31ade:	2a00      	cmp	r2, #0
   31ae0:	da02      	bge.n	31ae8 <__ieee754_log10f+0x2c>
   31ae2:	ee30 7a40 	vsub.f32	s14, s0, s0
   31ae6:	e7f3      	b.n	31ad0 <__ieee754_log10f+0x14>
   31ae8:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   31aec:	db02      	blt.n	31af4 <__ieee754_log10f+0x38>
   31aee:	ee30 0a00 	vadd.f32	s0, s0, s0
   31af2:	e7f1      	b.n	31ad8 <__ieee754_log10f+0x1c>
   31af4:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   31af8:	bfbf      	itttt	lt
   31afa:	eddf 7a17 	vldrlt	s15, [pc, #92]	; 31b58 <__ieee754_log10f+0x9c>
   31afe:	ee60 7a27 	vmullt.f32	s15, s0, s15
   31b02:	f06f 0118 	mvnlt.w	r1, #24
   31b06:	ee17 2a90 	vmovlt	r2, s15
   31b0a:	ea4f 53e2 	mov.w	r3, r2, asr #23
   31b0e:	bfa8      	it	ge
   31b10:	2100      	movge	r1, #0
   31b12:	3b7f      	subs	r3, #127	; 0x7f
   31b14:	440b      	add	r3, r1
   31b16:	0fd9      	lsrs	r1, r3, #31
   31b18:	440b      	add	r3, r1
   31b1a:	f3c2 0216 	ubfx	r2, r2, #0, #23
   31b1e:	f1c1 017f 	rsb	r1, r1, #127	; 0x7f
   31b22:	ee07 3a90 	vmov	s15, r3
   31b26:	ea42 53c1 	orr.w	r3, r2, r1, lsl #23
   31b2a:	ee00 3a10 	vmov	s0, r3
   31b2e:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   31b32:	f7fe fd2d 	bl	30590 <logf>
   31b36:	eddf 7a09 	vldr	s15, [pc, #36]	; 31b5c <__ieee754_log10f+0xa0>
   31b3a:	ee20 0a27 	vmul.f32	s0, s0, s15
   31b3e:	eddf 7a08 	vldr	s15, [pc, #32]	; 31b60 <__ieee754_log10f+0xa4>
   31b42:	eea8 0a27 	vfma.f32	s0, s16, s15
   31b46:	eddf 7a07 	vldr	s15, [pc, #28]	; 31b64 <__ieee754_log10f+0xa8>
   31b4a:	eea8 0a27 	vfma.f32	s0, s16, s15
   31b4e:	e7c3      	b.n	31ad8 <__ieee754_log10f+0x1c>
   31b50:	cc000000 	.word	0xcc000000
   31b54:	00000000 	.word	0x00000000
   31b58:	4c000000 	.word	0x4c000000
   31b5c:	3ede5bd9 	.word	0x3ede5bd9
   31b60:	355427db 	.word	0x355427db
   31b64:	3e9a2080 	.word	0x3e9a2080

00031b68 <__ieee754_rem_pio2f>:
   31b68:	b5f0      	push	{r4, r5, r6, r7, lr}
   31b6a:	ee10 6a10 	vmov	r6, s0
   31b6e:	4b86      	ldr	r3, [pc, #536]	; (31d88 <__ieee754_rem_pio2f+0x220>)
   31b70:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
   31b74:	429c      	cmp	r4, r3
   31b76:	b087      	sub	sp, #28
   31b78:	4605      	mov	r5, r0
   31b7a:	dc05      	bgt.n	31b88 <__ieee754_rem_pio2f+0x20>
   31b7c:	2300      	movs	r3, #0
   31b7e:	ed85 0a00 	vstr	s0, [r5]
   31b82:	6043      	str	r3, [r0, #4]
   31b84:	2000      	movs	r0, #0
   31b86:	e020      	b.n	31bca <__ieee754_rem_pio2f+0x62>
   31b88:	4b80      	ldr	r3, [pc, #512]	; (31d8c <__ieee754_rem_pio2f+0x224>)
   31b8a:	429c      	cmp	r4, r3
   31b8c:	dc38      	bgt.n	31c00 <__ieee754_rem_pio2f+0x98>
   31b8e:	2e00      	cmp	r6, #0
   31b90:	f024 040f 	bic.w	r4, r4, #15
   31b94:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 31d90 <__ieee754_rem_pio2f+0x228>
   31b98:	4b7e      	ldr	r3, [pc, #504]	; (31d94 <__ieee754_rem_pio2f+0x22c>)
   31b9a:	dd18      	ble.n	31bce <__ieee754_rem_pio2f+0x66>
   31b9c:	429c      	cmp	r4, r3
   31b9e:	ee70 7a47 	vsub.f32	s15, s0, s14
   31ba2:	bf09      	itett	eq
   31ba4:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 31d98 <__ieee754_rem_pio2f+0x230>
   31ba8:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 31d9c <__ieee754_rem_pio2f+0x234>
   31bac:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
   31bb0:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 31da0 <__ieee754_rem_pio2f+0x238>
   31bb4:	ee77 6ac7 	vsub.f32	s13, s15, s14
   31bb8:	ee77 7ae6 	vsub.f32	s15, s15, s13
   31bbc:	edc0 6a00 	vstr	s13, [r0]
   31bc0:	ee77 7ac7 	vsub.f32	s15, s15, s14
   31bc4:	edc0 7a01 	vstr	s15, [r0, #4]
   31bc8:	2001      	movs	r0, #1
   31bca:	b007      	add	sp, #28
   31bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   31bce:	429c      	cmp	r4, r3
   31bd0:	ee70 7a07 	vadd.f32	s15, s0, s14
   31bd4:	bf09      	itett	eq
   31bd6:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 31d98 <__ieee754_rem_pio2f+0x230>
   31bda:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 31d9c <__ieee754_rem_pio2f+0x234>
   31bde:	ee77 7a87 	vaddeq.f32	s15, s15, s14
   31be2:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 31da0 <__ieee754_rem_pio2f+0x238>
   31be6:	ee77 6a87 	vadd.f32	s13, s15, s14
   31bea:	ee77 7ae6 	vsub.f32	s15, s15, s13
   31bee:	edc0 6a00 	vstr	s13, [r0]
   31bf2:	ee77 7a87 	vadd.f32	s15, s15, s14
   31bf6:	edc0 7a01 	vstr	s15, [r0, #4]
   31bfa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   31bfe:	e7e4      	b.n	31bca <__ieee754_rem_pio2f+0x62>
   31c00:	4b68      	ldr	r3, [pc, #416]	; (31da4 <__ieee754_rem_pio2f+0x23c>)
   31c02:	429c      	cmp	r4, r3
   31c04:	dc71      	bgt.n	31cea <__ieee754_rem_pio2f+0x182>
   31c06:	f7fe fcbb 	bl	30580 <fabsf>
   31c0a:	ed9f 7a67 	vldr	s14, [pc, #412]	; 31da8 <__ieee754_rem_pio2f+0x240>
   31c0e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   31c12:	eee0 7a07 	vfma.f32	s15, s0, s14
   31c16:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   31c1a:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
   31c1e:	ee17 0a90 	vmov	r0, s15
   31c22:	eddf 7a5b 	vldr	s15, [pc, #364]	; 31d90 <__ieee754_rem_pio2f+0x228>
   31c26:	eeb1 7a46 	vneg.f32	s14, s12
   31c2a:	eea7 0a27 	vfma.f32	s0, s14, s15
   31c2e:	281f      	cmp	r0, #31
   31c30:	eddf 7a5a 	vldr	s15, [pc, #360]	; 31d9c <__ieee754_rem_pio2f+0x234>
   31c34:	ee66 7a27 	vmul.f32	s15, s12, s15
   31c38:	ee70 6a67 	vsub.f32	s13, s0, s15
   31c3c:	ee16 3a90 	vmov	r3, s13
   31c40:	dc1c      	bgt.n	31c7c <__ieee754_rem_pio2f+0x114>
   31c42:	1e47      	subs	r7, r0, #1
   31c44:	4959      	ldr	r1, [pc, #356]	; (31dac <__ieee754_rem_pio2f+0x244>)
   31c46:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
   31c4a:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
   31c4e:	428a      	cmp	r2, r1
   31c50:	d014      	beq.n	31c7c <__ieee754_rem_pio2f+0x114>
   31c52:	602b      	str	r3, [r5, #0]
   31c54:	ed95 7a00 	vldr	s14, [r5]
   31c58:	ee30 0a47 	vsub.f32	s0, s0, s14
   31c5c:	2e00      	cmp	r6, #0
   31c5e:	ee30 0a67 	vsub.f32	s0, s0, s15
   31c62:	ed85 0a01 	vstr	s0, [r5, #4]
   31c66:	dab0      	bge.n	31bca <__ieee754_rem_pio2f+0x62>
   31c68:	eeb1 7a47 	vneg.f32	s14, s14
   31c6c:	eeb1 0a40 	vneg.f32	s0, s0
   31c70:	ed85 7a00 	vstr	s14, [r5]
   31c74:	ed85 0a01 	vstr	s0, [r5, #4]
   31c78:	4240      	negs	r0, r0
   31c7a:	e7a6      	b.n	31bca <__ieee754_rem_pio2f+0x62>
   31c7c:	15e4      	asrs	r4, r4, #23
   31c7e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   31c82:	1aa2      	subs	r2, r4, r2
   31c84:	2a08      	cmp	r2, #8
   31c86:	dde4      	ble.n	31c52 <__ieee754_rem_pio2f+0xea>
   31c88:	eddf 7a43 	vldr	s15, [pc, #268]	; 31d98 <__ieee754_rem_pio2f+0x230>
   31c8c:	eef0 6a40 	vmov.f32	s13, s0
   31c90:	eee7 6a27 	vfma.f32	s13, s14, s15
   31c94:	ee30 0a66 	vsub.f32	s0, s0, s13
   31c98:	eea7 0a27 	vfma.f32	s0, s14, s15
   31c9c:	eddf 7a40 	vldr	s15, [pc, #256]	; 31da0 <__ieee754_rem_pio2f+0x238>
   31ca0:	ee96 0a27 	vfnms.f32	s0, s12, s15
   31ca4:	ee76 5ac0 	vsub.f32	s11, s13, s0
   31ca8:	eef0 7a40 	vmov.f32	s15, s0
   31cac:	ee15 3a90 	vmov	r3, s11
   31cb0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   31cb4:	1aa4      	subs	r4, r4, r2
   31cb6:	2c19      	cmp	r4, #25
   31cb8:	dc04      	bgt.n	31cc4 <__ieee754_rem_pio2f+0x15c>
   31cba:	edc5 5a00 	vstr	s11, [r5]
   31cbe:	eeb0 0a66 	vmov.f32	s0, s13
   31cc2:	e7c7      	b.n	31c54 <__ieee754_rem_pio2f+0xec>
   31cc4:	eddf 5a3a 	vldr	s11, [pc, #232]	; 31db0 <__ieee754_rem_pio2f+0x248>
   31cc8:	eeb0 0a66 	vmov.f32	s0, s13
   31ccc:	eea7 0a25 	vfma.f32	s0, s14, s11
   31cd0:	ee76 7ac0 	vsub.f32	s15, s13, s0
   31cd4:	eee7 7a25 	vfma.f32	s15, s14, s11
   31cd8:	ed9f 7a36 	vldr	s14, [pc, #216]	; 31db4 <__ieee754_rem_pio2f+0x24c>
   31cdc:	eed6 7a07 	vfnms.f32	s15, s12, s14
   31ce0:	ee30 7a67 	vsub.f32	s14, s0, s15
   31ce4:	ed85 7a00 	vstr	s14, [r5]
   31ce8:	e7b4      	b.n	31c54 <__ieee754_rem_pio2f+0xec>
   31cea:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   31cee:	db06      	blt.n	31cfe <__ieee754_rem_pio2f+0x196>
   31cf0:	ee70 7a40 	vsub.f32	s15, s0, s0
   31cf4:	edc0 7a01 	vstr	s15, [r0, #4]
   31cf8:	edc0 7a00 	vstr	s15, [r0]
   31cfc:	e742      	b.n	31b84 <__ieee754_rem_pio2f+0x1c>
   31cfe:	15e2      	asrs	r2, r4, #23
   31d00:	3a86      	subs	r2, #134	; 0x86
   31d02:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
   31d06:	ee07 3a90 	vmov	s15, r3
   31d0a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   31d0e:	eddf 6a2a 	vldr	s13, [pc, #168]	; 31db8 <__ieee754_rem_pio2f+0x250>
   31d12:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   31d16:	ee77 7ac7 	vsub.f32	s15, s15, s14
   31d1a:	ed8d 7a03 	vstr	s14, [sp, #12]
   31d1e:	ee67 7aa6 	vmul.f32	s15, s15, s13
   31d22:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   31d26:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   31d2a:	ee77 7ac7 	vsub.f32	s15, s15, s14
   31d2e:	ed8d 7a04 	vstr	s14, [sp, #16]
   31d32:	ee67 7aa6 	vmul.f32	s15, s15, s13
   31d36:	eef5 7a40 	vcmp.f32	s15, #0.0
   31d3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   31d3e:	edcd 7a05 	vstr	s15, [sp, #20]
   31d42:	d11e      	bne.n	31d82 <__ieee754_rem_pio2f+0x21a>
   31d44:	eeb5 7a40 	vcmp.f32	s14, #0.0
   31d48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   31d4c:	bf0c      	ite	eq
   31d4e:	2301      	moveq	r3, #1
   31d50:	2302      	movne	r3, #2
   31d52:	491a      	ldr	r1, [pc, #104]	; (31dbc <__ieee754_rem_pio2f+0x254>)
   31d54:	9101      	str	r1, [sp, #4]
   31d56:	2102      	movs	r1, #2
   31d58:	9100      	str	r1, [sp, #0]
   31d5a:	a803      	add	r0, sp, #12
   31d5c:	4629      	mov	r1, r5
   31d5e:	f000 f8fb 	bl	31f58 <__kernel_rem_pio2f>
   31d62:	2e00      	cmp	r6, #0
   31d64:	f6bf af31 	bge.w	31bca <__ieee754_rem_pio2f+0x62>
   31d68:	edd5 7a00 	vldr	s15, [r5]
   31d6c:	eef1 7a67 	vneg.f32	s15, s15
   31d70:	edc5 7a00 	vstr	s15, [r5]
   31d74:	edd5 7a01 	vldr	s15, [r5, #4]
   31d78:	eef1 7a67 	vneg.f32	s15, s15
   31d7c:	edc5 7a01 	vstr	s15, [r5, #4]
   31d80:	e77a      	b.n	31c78 <__ieee754_rem_pio2f+0x110>
   31d82:	2303      	movs	r3, #3
   31d84:	e7e5      	b.n	31d52 <__ieee754_rem_pio2f+0x1ea>
   31d86:	bf00      	nop
   31d88:	3f490fd8 	.word	0x3f490fd8
   31d8c:	4016cbe3 	.word	0x4016cbe3
   31d90:	3fc90f80 	.word	0x3fc90f80
   31d94:	3fc90fd0 	.word	0x3fc90fd0
   31d98:	37354400 	.word	0x37354400
   31d9c:	37354443 	.word	0x37354443
   31da0:	2e85a308 	.word	0x2e85a308
   31da4:	43490f80 	.word	0x43490f80
   31da8:	3f22f984 	.word	0x3f22f984
   31dac:	00055c10 	.word	0x00055c10
   31db0:	2e85a300 	.word	0x2e85a300
   31db4:	248d3132 	.word	0x248d3132
   31db8:	43800000 	.word	0x43800000
   31dbc:	00055c90 	.word	0x00055c90

00031dc0 <__ieee754_sinhf>:
   31dc0:	b510      	push	{r4, lr}
   31dc2:	ee10 3a10 	vmov	r3, s0
   31dc6:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   31dca:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   31dce:	ed2d 8b02 	vpush	{d8}
   31dd2:	eef0 7a40 	vmov.f32	s15, s0
   31dd6:	db06      	blt.n	31de6 <__ieee754_sinhf+0x26>
   31dd8:	ee70 7a00 	vadd.f32	s15, s0, s0
   31ddc:	ecbd 8b02 	vpop	{d8}
   31de0:	eeb0 0a67 	vmov.f32	s0, s15
   31de4:	bd10      	pop	{r4, pc}
   31de6:	2b00      	cmp	r3, #0
   31de8:	4b28      	ldr	r3, [pc, #160]	; (31e8c <__ieee754_sinhf+0xcc>)
   31dea:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
   31dee:	eebe 8a00 	vmov.f32	s16, #224	; 0xbf000000 -0.5
   31df2:	fe28 8a88 	vselge.f32	s16, s17, s16
   31df6:	429c      	cmp	r4, r3
   31df8:	dc2a      	bgt.n	31e50 <__ieee754_sinhf+0x90>
   31dfa:	f1b4 5f46 	cmp.w	r4, #830472192	; 0x31800000
   31dfe:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   31e02:	da08      	bge.n	31e16 <__ieee754_sinhf+0x56>
   31e04:	ed9f 7a22 	vldr	s14, [pc, #136]	; 31e90 <__ieee754_sinhf+0xd0>
   31e08:	ee30 7a07 	vadd.f32	s14, s0, s14
   31e0c:	eeb4 7ae8 	vcmpe.f32	s14, s17
   31e10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   31e14:	dce2      	bgt.n	31ddc <__ieee754_sinhf+0x1c>
   31e16:	eeb0 0a67 	vmov.f32	s0, s15
   31e1a:	f7fe fbb1 	bl	30580 <fabsf>
   31e1e:	f000 fdb9 	bl	32994 <expm1f>
   31e22:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
   31e26:	bfbb      	ittet	lt
   31e28:	ee20 7a00 	vmullt.f32	s14, s0, s0
   31e2c:	ee70 8a28 	vaddlt.f32	s17, s0, s17
   31e30:	ee70 8a28 	vaddge.f32	s17, s0, s17
   31e34:	eec7 7a28 	vdivlt.f32	s15, s14, s17
   31e38:	bfad      	iteet	ge
   31e3a:	eec0 7a28 	vdivge.f32	s15, s0, s17
   31e3e:	eeb0 7a00 	vmovlt.f32	s14, #0	; 0x40000000  2.0
   31e42:	eed0 7a07 	vfnmslt.f32	s15, s0, s14
   31e46:	ee77 7a80 	vaddge.f32	s15, s15, s0
   31e4a:	ee67 7a88 	vmul.f32	s15, s15, s16
   31e4e:	e7c5      	b.n	31ddc <__ieee754_sinhf+0x1c>
   31e50:	4b10      	ldr	r3, [pc, #64]	; (31e94 <__ieee754_sinhf+0xd4>)
   31e52:	429c      	cmp	r4, r3
   31e54:	dc06      	bgt.n	31e64 <__ieee754_sinhf+0xa4>
   31e56:	f7fe fb93 	bl	30580 <fabsf>
   31e5a:	f7fe fb13 	bl	30484 <expf>
   31e5e:	ee60 7a08 	vmul.f32	s15, s0, s16
   31e62:	e7bb      	b.n	31ddc <__ieee754_sinhf+0x1c>
   31e64:	4b0c      	ldr	r3, [pc, #48]	; (31e98 <__ieee754_sinhf+0xd8>)
   31e66:	429c      	cmp	r4, r3
   31e68:	dc0a      	bgt.n	31e80 <__ieee754_sinhf+0xc0>
   31e6a:	f7fe fb89 	bl	30580 <fabsf>
   31e6e:	ee20 0a28 	vmul.f32	s0, s0, s17
   31e72:	f7fe fb07 	bl	30484 <expf>
   31e76:	ee68 7a00 	vmul.f32	s15, s16, s0
   31e7a:	ee67 7a80 	vmul.f32	s15, s15, s0
   31e7e:	e7ad      	b.n	31ddc <__ieee754_sinhf+0x1c>
   31e80:	ed9f 7a03 	vldr	s14, [pc, #12]	; 31e90 <__ieee754_sinhf+0xd0>
   31e84:	ee60 7a07 	vmul.f32	s15, s0, s14
   31e88:	e7a8      	b.n	31ddc <__ieee754_sinhf+0x1c>
   31e8a:	bf00      	nop
   31e8c:	41afffff 	.word	0x41afffff
   31e90:	7cf0bdc2 	.word	0x7cf0bdc2
   31e94:	42b17217 	.word	0x42b17217
   31e98:	42b2d4fc 	.word	0x42b2d4fc

00031e9c <__kernel_cosf>:
   31e9c:	ee10 3a10 	vmov	r3, s0
   31ea0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   31ea4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   31ea8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   31eac:	da05      	bge.n	31eba <__kernel_cosf+0x1e>
   31eae:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   31eb2:	ee17 2a90 	vmov	r2, s15
   31eb6:	2a00      	cmp	r2, #0
   31eb8:	d03b      	beq.n	31f32 <__kernel_cosf+0x96>
   31eba:	ee20 6a00 	vmul.f32	s12, s0, s0
   31ebe:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   31ec2:	eddf 5a1d 	vldr	s11, [pc, #116]	; 31f38 <__kernel_cosf+0x9c>
   31ec6:	4a1d      	ldr	r2, [pc, #116]	; (31f3c <__kernel_cosf+0xa0>)
   31ec8:	ee66 7a07 	vmul.f32	s15, s12, s14
   31ecc:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 31f40 <__kernel_cosf+0xa4>
   31ed0:	eea6 7a25 	vfma.f32	s14, s12, s11
   31ed4:	4293      	cmp	r3, r2
   31ed6:	eddf 5a1b 	vldr	s11, [pc, #108]	; 31f44 <__kernel_cosf+0xa8>
   31eda:	eee7 5a06 	vfma.f32	s11, s14, s12
   31ede:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 31f48 <__kernel_cosf+0xac>
   31ee2:	eea5 7a86 	vfma.f32	s14, s11, s12
   31ee6:	eddf 5a19 	vldr	s11, [pc, #100]	; 31f4c <__kernel_cosf+0xb0>
   31eea:	eee7 5a06 	vfma.f32	s11, s14, s12
   31eee:	ed9f 7a18 	vldr	s14, [pc, #96]	; 31f50 <__kernel_cosf+0xb4>
   31ef2:	eea5 7a86 	vfma.f32	s14, s11, s12
   31ef6:	ee60 0ac0 	vnmul.f32	s1, s1, s0
   31efa:	ee27 7a06 	vmul.f32	s14, s14, s12
   31efe:	eee6 0a07 	vfma.f32	s1, s12, s14
   31f02:	dc04      	bgt.n	31f0e <__kernel_cosf+0x72>
   31f04:	ee77 0ae0 	vsub.f32	s1, s15, s1
   31f08:	ee36 0ae0 	vsub.f32	s0, s13, s1
   31f0c:	4770      	bx	lr
   31f0e:	4a11      	ldr	r2, [pc, #68]	; (31f54 <__kernel_cosf+0xb8>)
   31f10:	4293      	cmp	r3, r2
   31f12:	bfda      	itte	le
   31f14:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
   31f18:	ee07 3a10 	vmovle	s14, r3
   31f1c:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
   31f20:	ee77 7ac7 	vsub.f32	s15, s15, s14
   31f24:	ee36 0ac7 	vsub.f32	s0, s13, s14
   31f28:	ee77 7ae0 	vsub.f32	s15, s15, s1
   31f2c:	ee30 0a67 	vsub.f32	s0, s0, s15
   31f30:	4770      	bx	lr
   31f32:	eeb0 0a66 	vmov.f32	s0, s13
   31f36:	4770      	bx	lr
   31f38:	ad47d74e 	.word	0xad47d74e
   31f3c:	3e999999 	.word	0x3e999999
   31f40:	310f74f6 	.word	0x310f74f6
   31f44:	b493f27c 	.word	0xb493f27c
   31f48:	37d00d01 	.word	0x37d00d01
   31f4c:	bab60b61 	.word	0xbab60b61
   31f50:	3d2aaaab 	.word	0x3d2aaaab
   31f54:	3f480000 	.word	0x3f480000

00031f58 <__kernel_rem_pio2f>:
   31f58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31f5c:	ed2d 8b04 	vpush	{d8-d9}
   31f60:	b0d7      	sub	sp, #348	; 0x15c
   31f62:	469b      	mov	fp, r3
   31f64:	460e      	mov	r6, r1
   31f66:	4bbe      	ldr	r3, [pc, #760]	; (32260 <__kernel_rem_pio2f+0x308>)
   31f68:	9964      	ldr	r1, [sp, #400]	; 0x190
   31f6a:	9002      	str	r0, [sp, #8]
   31f6c:	f853 9021 	ldr.w	r9, [r3, r1, lsl #2]
   31f70:	9865      	ldr	r0, [sp, #404]	; 0x194
   31f72:	ed9f 7abf 	vldr	s14, [pc, #764]	; 32270 <__kernel_rem_pio2f+0x318>
   31f76:	1ed1      	subs	r1, r2, #3
   31f78:	2308      	movs	r3, #8
   31f7a:	fb91 f1f3 	sdiv	r1, r1, r3
   31f7e:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   31f82:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
   31f86:	1c4c      	adds	r4, r1, #1
   31f88:	eba2 04c4 	sub.w	r4, r2, r4, lsl #3
   31f8c:	eba1 050a 	sub.w	r5, r1, sl
   31f90:	aa1a      	add	r2, sp, #104	; 0x68
   31f92:	eb09 070a 	add.w	r7, r9, sl
   31f96:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
   31f9a:	4696      	mov	lr, r2
   31f9c:	2300      	movs	r3, #0
   31f9e:	42bb      	cmp	r3, r7
   31fa0:	dd0f      	ble.n	31fc2 <__kernel_rem_pio2f+0x6a>
   31fa2:	af42      	add	r7, sp, #264	; 0x108
   31fa4:	2200      	movs	r2, #0
   31fa6:	454a      	cmp	r2, r9
   31fa8:	dc27      	bgt.n	31ffa <__kernel_rem_pio2f+0xa2>
   31faa:	f10d 0c68 	add.w	ip, sp, #104	; 0x68
   31fae:	eb0b 0302 	add.w	r3, fp, r2
   31fb2:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
   31fb6:	9d02      	ldr	r5, [sp, #8]
   31fb8:	eddf 7aad 	vldr	s15, [pc, #692]	; 32270 <__kernel_rem_pio2f+0x318>
   31fbc:	f04f 0c00 	mov.w	ip, #0
   31fc0:	e015      	b.n	31fee <__kernel_rem_pio2f+0x96>
   31fc2:	42dd      	cmn	r5, r3
   31fc4:	bf5d      	ittte	pl
   31fc6:	f85c 2023 	ldrpl.w	r2, [ip, r3, lsl #2]
   31fca:	ee07 2a90 	vmovpl	s15, r2
   31fce:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
   31fd2:	eef0 7a47 	vmovmi.f32	s15, s14
   31fd6:	ecee 7a01 	vstmia	lr!, {s15}
   31fda:	3301      	adds	r3, #1
   31fdc:	e7df      	b.n	31f9e <__kernel_rem_pio2f+0x46>
   31fde:	ecf5 6a01 	vldmia	r5!, {s13}
   31fe2:	ed33 7a01 	vldmdb	r3!, {s14}
   31fe6:	eee6 7a87 	vfma.f32	s15, s13, s14
   31fea:	f10c 0c01 	add.w	ip, ip, #1
   31fee:	45d4      	cmp	ip, sl
   31ff0:	ddf5      	ble.n	31fde <__kernel_rem_pio2f+0x86>
   31ff2:	ece7 7a01 	vstmia	r7!, {s15}
   31ff6:	3201      	adds	r2, #1
   31ff8:	e7d5      	b.n	31fa6 <__kernel_rem_pio2f+0x4e>
   31ffa:	ab06      	add	r3, sp, #24
   31ffc:	eb03 0389 	add.w	r3, r3, r9, lsl #2
   32000:	9304      	str	r3, [sp, #16]
   32002:	eddf 8a9a 	vldr	s17, [pc, #616]	; 3226c <__kernel_rem_pio2f+0x314>
   32006:	ed9f 9a98 	vldr	s18, [pc, #608]	; 32268 <__kernel_rem_pio2f+0x310>
   3200a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
   3200e:	9303      	str	r3, [sp, #12]
   32010:	464d      	mov	r5, r9
   32012:	ab56      	add	r3, sp, #344	; 0x158
   32014:	f105 4780 	add.w	r7, r5, #1073741824	; 0x40000000
   32018:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   3201c:	3f01      	subs	r7, #1
   3201e:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
   32022:	00bf      	lsls	r7, r7, #2
   32024:	ab56      	add	r3, sp, #344	; 0x158
   32026:	19da      	adds	r2, r3, r7
   32028:	3a4c      	subs	r2, #76	; 0x4c
   3202a:	2300      	movs	r3, #0
   3202c:	1ae9      	subs	r1, r5, r3
   3202e:	2900      	cmp	r1, #0
   32030:	dc4c      	bgt.n	320cc <__kernel_rem_pio2f+0x174>
   32032:	4620      	mov	r0, r4
   32034:	f000 fe24 	bl	32c80 <scalbnf>
   32038:	eeb0 8a40 	vmov.f32	s16, s0
   3203c:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
   32040:	ee28 0a00 	vmul.f32	s0, s16, s0
   32044:	f000 fdda 	bl	32bfc <floorf>
   32048:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   3204c:	eea0 8a67 	vfms.f32	s16, s0, s15
   32050:	2c00      	cmp	r4, #0
   32052:	eefd 7ac8 	vcvt.s32.f32	s15, s16
   32056:	edcd 7a01 	vstr	s15, [sp, #4]
   3205a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3205e:	ee38 8a67 	vsub.f32	s16, s16, s15
   32062:	dd48      	ble.n	320f6 <__kernel_rem_pio2f+0x19e>
   32064:	1e69      	subs	r1, r5, #1
   32066:	ab06      	add	r3, sp, #24
   32068:	f1c4 0008 	rsb	r0, r4, #8
   3206c:	f853 c021 	ldr.w	ip, [r3, r1, lsl #2]
   32070:	9a01      	ldr	r2, [sp, #4]
   32072:	fa4c f300 	asr.w	r3, ip, r0
   32076:	441a      	add	r2, r3
   32078:	4083      	lsls	r3, r0
   3207a:	9201      	str	r2, [sp, #4]
   3207c:	ebac 0203 	sub.w	r2, ip, r3
   32080:	ab06      	add	r3, sp, #24
   32082:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   32086:	f1c4 0307 	rsb	r3, r4, #7
   3208a:	fa42 f803 	asr.w	r8, r2, r3
   3208e:	f1b8 0f00 	cmp.w	r8, #0
   32092:	dd41      	ble.n	32118 <__kernel_rem_pio2f+0x1c0>
   32094:	9b01      	ldr	r3, [sp, #4]
   32096:	2000      	movs	r0, #0
   32098:	3301      	adds	r3, #1
   3209a:	9301      	str	r3, [sp, #4]
   3209c:	4601      	mov	r1, r0
   3209e:	4285      	cmp	r5, r0
   320a0:	dc6d      	bgt.n	3217e <__kernel_rem_pio2f+0x226>
   320a2:	2c00      	cmp	r4, #0
   320a4:	dd04      	ble.n	320b0 <__kernel_rem_pio2f+0x158>
   320a6:	2c01      	cmp	r4, #1
   320a8:	d07e      	beq.n	321a8 <__kernel_rem_pio2f+0x250>
   320aa:	2c02      	cmp	r4, #2
   320ac:	f000 8086 	beq.w	321bc <__kernel_rem_pio2f+0x264>
   320b0:	f1b8 0f02 	cmp.w	r8, #2
   320b4:	d130      	bne.n	32118 <__kernel_rem_pio2f+0x1c0>
   320b6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   320ba:	ee30 8a48 	vsub.f32	s16, s0, s16
   320be:	b359      	cbz	r1, 32118 <__kernel_rem_pio2f+0x1c0>
   320c0:	4620      	mov	r0, r4
   320c2:	f000 fddd 	bl	32c80 <scalbnf>
   320c6:	ee38 8a40 	vsub.f32	s16, s16, s0
   320ca:	e025      	b.n	32118 <__kernel_rem_pio2f+0x1c0>
   320cc:	ee60 7a28 	vmul.f32	s15, s0, s17
   320d0:	a806      	add	r0, sp, #24
   320d2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   320d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   320da:	eea7 0ac9 	vfms.f32	s0, s15, s18
   320de:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   320e2:	ee10 1a10 	vmov	r1, s0
   320e6:	ed32 0a01 	vldmdb	r2!, {s0}
   320ea:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
   320ee:	ee37 0a80 	vadd.f32	s0, s15, s0
   320f2:	3301      	adds	r3, #1
   320f4:	e79a      	b.n	3202c <__kernel_rem_pio2f+0xd4>
   320f6:	d106      	bne.n	32106 <__kernel_rem_pio2f+0x1ae>
   320f8:	1e6b      	subs	r3, r5, #1
   320fa:	aa06      	add	r2, sp, #24
   320fc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   32100:	ea4f 2822 	mov.w	r8, r2, asr #8
   32104:	e7c3      	b.n	3208e <__kernel_rem_pio2f+0x136>
   32106:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   3210a:	eeb4 8ae7 	vcmpe.f32	s16, s15
   3210e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   32112:	da31      	bge.n	32178 <__kernel_rem_pio2f+0x220>
   32114:	f04f 0800 	mov.w	r8, #0
   32118:	eeb5 8a40 	vcmp.f32	s16, #0.0
   3211c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   32120:	f040 80a8 	bne.w	32274 <__kernel_rem_pio2f+0x31c>
   32124:	1e6b      	subs	r3, r5, #1
   32126:	4618      	mov	r0, r3
   32128:	2200      	movs	r2, #0
   3212a:	4548      	cmp	r0, r9
   3212c:	da4d      	bge.n	321ca <__kernel_rem_pio2f+0x272>
   3212e:	2a00      	cmp	r2, #0
   32130:	f000 8087 	beq.w	32242 <__kernel_rem_pio2f+0x2ea>
   32134:	aa06      	add	r2, sp, #24
   32136:	3c08      	subs	r4, #8
   32138:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
   3213c:	2900      	cmp	r1, #0
   3213e:	f000 808d 	beq.w	3225c <__kernel_rem_pio2f+0x304>
   32142:	4620      	mov	r0, r4
   32144:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   32148:	9302      	str	r3, [sp, #8]
   3214a:	f000 fd99 	bl	32c80 <scalbnf>
   3214e:	9b02      	ldr	r3, [sp, #8]
   32150:	ed9f 7a46 	vldr	s14, [pc, #280]	; 3226c <__kernel_rem_pio2f+0x314>
   32154:	0099      	lsls	r1, r3, #2
   32156:	aa42      	add	r2, sp, #264	; 0x108
   32158:	1850      	adds	r0, r2, r1
   3215a:	1d05      	adds	r5, r0, #4
   3215c:	461c      	mov	r4, r3
   3215e:	2c00      	cmp	r4, #0
   32160:	f280 80b8 	bge.w	322d4 <__kernel_rem_pio2f+0x37c>
   32164:	2500      	movs	r5, #0
   32166:	1b5c      	subs	r4, r3, r5
   32168:	2c00      	cmp	r4, #0
   3216a:	f2c0 80d8 	blt.w	3231e <__kernel_rem_pio2f+0x3c6>
   3216e:	4f3d      	ldr	r7, [pc, #244]	; (32264 <__kernel_rem_pio2f+0x30c>)
   32170:	eddf 7a3f 	vldr	s15, [pc, #252]	; 32270 <__kernel_rem_pio2f+0x318>
   32174:	2400      	movs	r4, #0
   32176:	e0c6      	b.n	32306 <__kernel_rem_pio2f+0x3ae>
   32178:	f04f 0802 	mov.w	r8, #2
   3217c:	e78a      	b.n	32094 <__kernel_rem_pio2f+0x13c>
   3217e:	ab06      	add	r3, sp, #24
   32180:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   32184:	b949      	cbnz	r1, 3219a <__kernel_rem_pio2f+0x242>
   32186:	b12b      	cbz	r3, 32194 <__kernel_rem_pio2f+0x23c>
   32188:	aa06      	add	r2, sp, #24
   3218a:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
   3218e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   32192:	2301      	movs	r3, #1
   32194:	3001      	adds	r0, #1
   32196:	4619      	mov	r1, r3
   32198:	e781      	b.n	3209e <__kernel_rem_pio2f+0x146>
   3219a:	aa06      	add	r2, sp, #24
   3219c:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
   321a0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   321a4:	460b      	mov	r3, r1
   321a6:	e7f5      	b.n	32194 <__kernel_rem_pio2f+0x23c>
   321a8:	1e68      	subs	r0, r5, #1
   321aa:	ab06      	add	r3, sp, #24
   321ac:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   321b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   321b4:	aa06      	add	r2, sp, #24
   321b6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   321ba:	e779      	b.n	320b0 <__kernel_rem_pio2f+0x158>
   321bc:	1e68      	subs	r0, r5, #1
   321be:	ab06      	add	r3, sp, #24
   321c0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   321c4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   321c8:	e7f4      	b.n	321b4 <__kernel_rem_pio2f+0x25c>
   321ca:	a906      	add	r1, sp, #24
   321cc:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   321d0:	3801      	subs	r0, #1
   321d2:	430a      	orrs	r2, r1
   321d4:	e7a9      	b.n	3212a <__kernel_rem_pio2f+0x1d2>
   321d6:	f10c 0c01 	add.w	ip, ip, #1
   321da:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   321de:	2a00      	cmp	r2, #0
   321e0:	d0f9      	beq.n	321d6 <__kernel_rem_pio2f+0x27e>
   321e2:	eb0b 0305 	add.w	r3, fp, r5
   321e6:	aa1a      	add	r2, sp, #104	; 0x68
   321e8:	009b      	lsls	r3, r3, #2
   321ea:	1898      	adds	r0, r3, r2
   321ec:	3004      	adds	r0, #4
   321ee:	1c69      	adds	r1, r5, #1
   321f0:	3704      	adds	r7, #4
   321f2:	2200      	movs	r2, #0
   321f4:	4465      	add	r5, ip
   321f6:	9005      	str	r0, [sp, #20]
   321f8:	428d      	cmp	r5, r1
   321fa:	f6ff af0a 	blt.w	32012 <__kernel_rem_pio2f+0xba>
   321fe:	a81a      	add	r0, sp, #104	; 0x68
   32200:	eb02 0c03 	add.w	ip, r2, r3
   32204:	4484      	add	ip, r0
   32206:	9803      	ldr	r0, [sp, #12]
   32208:	f8dd e008 	ldr.w	lr, [sp, #8]
   3220c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
   32210:	9001      	str	r0, [sp, #4]
   32212:	ee07 0a90 	vmov	s15, r0
   32216:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3221a:	9805      	ldr	r0, [sp, #20]
   3221c:	edcc 7a00 	vstr	s15, [ip]
   32220:	eddf 7a13 	vldr	s15, [pc, #76]	; 32270 <__kernel_rem_pio2f+0x318>
   32224:	eb00 0802 	add.w	r8, r0, r2
   32228:	f04f 0c00 	mov.w	ip, #0
   3222c:	45d4      	cmp	ip, sl
   3222e:	dd0c      	ble.n	3224a <__kernel_rem_pio2f+0x2f2>
   32230:	eb02 0c07 	add.w	ip, r2, r7
   32234:	a842      	add	r0, sp, #264	; 0x108
   32236:	4484      	add	ip, r0
   32238:	edcc 7a01 	vstr	s15, [ip, #4]
   3223c:	3101      	adds	r1, #1
   3223e:	3204      	adds	r2, #4
   32240:	e7da      	b.n	321f8 <__kernel_rem_pio2f+0x2a0>
   32242:	9b04      	ldr	r3, [sp, #16]
   32244:	f04f 0c01 	mov.w	ip, #1
   32248:	e7c7      	b.n	321da <__kernel_rem_pio2f+0x282>
   3224a:	ecfe 6a01 	vldmia	lr!, {s13}
   3224e:	ed38 7a01 	vldmdb	r8!, {s14}
   32252:	f10c 0c01 	add.w	ip, ip, #1
   32256:	eee6 7a87 	vfma.f32	s15, s13, s14
   3225a:	e7e7      	b.n	3222c <__kernel_rem_pio2f+0x2d4>
   3225c:	3b01      	subs	r3, #1
   3225e:	e769      	b.n	32134 <__kernel_rem_pio2f+0x1dc>
   32260:	00055fd4 	.word	0x00055fd4
   32264:	00055fa8 	.word	0x00055fa8
   32268:	43800000 	.word	0x43800000
   3226c:	3b800000 	.word	0x3b800000
   32270:	00000000 	.word	0x00000000
   32274:	4260      	negs	r0, r4
   32276:	eeb0 0a48 	vmov.f32	s0, s16
   3227a:	f000 fd01 	bl	32c80 <scalbnf>
   3227e:	ed1f 7a06 	vldr	s14, [pc, #-24]	; 32268 <__kernel_rem_pio2f+0x310>
   32282:	eeb4 0ac7 	vcmpe.f32	s0, s14
   32286:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3228a:	db1a      	blt.n	322c2 <__kernel_rem_pio2f+0x36a>
   3228c:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 3226c <__kernel_rem_pio2f+0x314>
   32290:	ee60 7a27 	vmul.f32	s15, s0, s15
   32294:	aa06      	add	r2, sp, #24
   32296:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   3229a:	a906      	add	r1, sp, #24
   3229c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   322a0:	3408      	adds	r4, #8
   322a2:	eea7 0ac7 	vfms.f32	s0, s15, s14
   322a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   322aa:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   322ae:	ee10 3a10 	vmov	r3, s0
   322b2:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
   322b6:	1c6b      	adds	r3, r5, #1
   322b8:	ee17 2a90 	vmov	r2, s15
   322bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   322c0:	e73f      	b.n	32142 <__kernel_rem_pio2f+0x1ea>
   322c2:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   322c6:	aa06      	add	r2, sp, #24
   322c8:	ee10 3a10 	vmov	r3, s0
   322cc:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
   322d0:	462b      	mov	r3, r5
   322d2:	e736      	b.n	32142 <__kernel_rem_pio2f+0x1ea>
   322d4:	aa06      	add	r2, sp, #24
   322d6:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
   322da:	9202      	str	r2, [sp, #8]
   322dc:	ee07 2a90 	vmov	s15, r2
   322e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   322e4:	3c01      	subs	r4, #1
   322e6:	ee67 7a80 	vmul.f32	s15, s15, s0
   322ea:	ee20 0a07 	vmul.f32	s0, s0, s14
   322ee:	ed65 7a01 	vstmdb	r5!, {s15}
   322f2:	e734      	b.n	3215e <__kernel_rem_pio2f+0x206>
   322f4:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
   322f8:	ecf7 6a01 	vldmia	r7!, {s13}
   322fc:	ed9c 7a00 	vldr	s14, [ip]
   32300:	eee6 7a87 	vfma.f32	s15, s13, s14
   32304:	3401      	adds	r4, #1
   32306:	454c      	cmp	r4, r9
   32308:	dc01      	bgt.n	3230e <__kernel_rem_pio2f+0x3b6>
   3230a:	42a5      	cmp	r5, r4
   3230c:	daf2      	bge.n	322f4 <__kernel_rem_pio2f+0x39c>
   3230e:	aa56      	add	r2, sp, #344	; 0x158
   32310:	eb02 0485 	add.w	r4, r2, r5, lsl #2
   32314:	ed44 7a28 	vstr	s15, [r4, #-160]	; 0xffffff60
   32318:	3501      	adds	r5, #1
   3231a:	3804      	subs	r0, #4
   3231c:	e723      	b.n	32166 <__kernel_rem_pio2f+0x20e>
   3231e:	9a64      	ldr	r2, [sp, #400]	; 0x190
   32320:	2a03      	cmp	r2, #3
   32322:	d84d      	bhi.n	323c0 <__kernel_rem_pio2f+0x468>
   32324:	e8df f002 	tbb	[pc, r2]
   32328:	021f1f3e 	.word	0x021f1f3e
   3232c:	aa56      	add	r2, sp, #344	; 0x158
   3232e:	4411      	add	r1, r2
   32330:	399c      	subs	r1, #156	; 0x9c
   32332:	4608      	mov	r0, r1
   32334:	461c      	mov	r4, r3
   32336:	2c00      	cmp	r4, #0
   32338:	dc5f      	bgt.n	323fa <__kernel_rem_pio2f+0x4a2>
   3233a:	4608      	mov	r0, r1
   3233c:	461c      	mov	r4, r3
   3233e:	2c01      	cmp	r4, #1
   32340:	dc6b      	bgt.n	3241a <__kernel_rem_pio2f+0x4c2>
   32342:	ed5f 7a35 	vldr	s15, [pc, #-212]	; 32270 <__kernel_rem_pio2f+0x318>
   32346:	2b01      	cmp	r3, #1
   32348:	dc77      	bgt.n	3243a <__kernel_rem_pio2f+0x4e2>
   3234a:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
   3234e:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
   32352:	f1b8 0f00 	cmp.w	r8, #0
   32356:	d176      	bne.n	32446 <__kernel_rem_pio2f+0x4ee>
   32358:	edc6 6a00 	vstr	s13, [r6]
   3235c:	ed86 7a01 	vstr	s14, [r6, #4]
   32360:	edc6 7a02 	vstr	s15, [r6, #8]
   32364:	e02c      	b.n	323c0 <__kernel_rem_pio2f+0x468>
   32366:	aa56      	add	r2, sp, #344	; 0x158
   32368:	4411      	add	r1, r2
   3236a:	ed1f 7a3f 	vldr	s14, [pc, #-252]	; 32270 <__kernel_rem_pio2f+0x318>
   3236e:	399c      	subs	r1, #156	; 0x9c
   32370:	4618      	mov	r0, r3
   32372:	2800      	cmp	r0, #0
   32374:	da32      	bge.n	323dc <__kernel_rem_pio2f+0x484>
   32376:	f1b8 0f00 	cmp.w	r8, #0
   3237a:	d035      	beq.n	323e8 <__kernel_rem_pio2f+0x490>
   3237c:	eef1 7a47 	vneg.f32	s15, s14
   32380:	edc6 7a00 	vstr	s15, [r6]
   32384:	eddd 7a2e 	vldr	s15, [sp, #184]	; 0xb8
   32388:	ee77 7ac7 	vsub.f32	s15, s15, s14
   3238c:	a82f      	add	r0, sp, #188	; 0xbc
   3238e:	2101      	movs	r1, #1
   32390:	428b      	cmp	r3, r1
   32392:	da2c      	bge.n	323ee <__kernel_rem_pio2f+0x496>
   32394:	f1b8 0f00 	cmp.w	r8, #0
   32398:	d001      	beq.n	3239e <__kernel_rem_pio2f+0x446>
   3239a:	eef1 7a67 	vneg.f32	s15, s15
   3239e:	edc6 7a01 	vstr	s15, [r6, #4]
   323a2:	e00d      	b.n	323c0 <__kernel_rem_pio2f+0x468>
   323a4:	aa56      	add	r2, sp, #344	; 0x158
   323a6:	4411      	add	r1, r2
   323a8:	ed5f 7a4f 	vldr	s15, [pc, #-316]	; 32270 <__kernel_rem_pio2f+0x318>
   323ac:	399c      	subs	r1, #156	; 0x9c
   323ae:	2b00      	cmp	r3, #0
   323b0:	da0e      	bge.n	323d0 <__kernel_rem_pio2f+0x478>
   323b2:	f1b8 0f00 	cmp.w	r8, #0
   323b6:	d001      	beq.n	323bc <__kernel_rem_pio2f+0x464>
   323b8:	eef1 7a67 	vneg.f32	s15, s15
   323bc:	edc6 7a00 	vstr	s15, [r6]
   323c0:	9b01      	ldr	r3, [sp, #4]
   323c2:	f003 0007 	and.w	r0, r3, #7
   323c6:	b057      	add	sp, #348	; 0x15c
   323c8:	ecbd 8b04 	vpop	{d8-d9}
   323cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   323d0:	ed31 7a01 	vldmdb	r1!, {s14}
   323d4:	3b01      	subs	r3, #1
   323d6:	ee77 7a87 	vadd.f32	s15, s15, s14
   323da:	e7e8      	b.n	323ae <__kernel_rem_pio2f+0x456>
   323dc:	ed71 7a01 	vldmdb	r1!, {s15}
   323e0:	3801      	subs	r0, #1
   323e2:	ee37 7a27 	vadd.f32	s14, s14, s15
   323e6:	e7c4      	b.n	32372 <__kernel_rem_pio2f+0x41a>
   323e8:	eef0 7a47 	vmov.f32	s15, s14
   323ec:	e7c8      	b.n	32380 <__kernel_rem_pio2f+0x428>
   323ee:	ecb0 7a01 	vldmia	r0!, {s14}
   323f2:	3101      	adds	r1, #1
   323f4:	ee77 7a87 	vadd.f32	s15, s15, s14
   323f8:	e7ca      	b.n	32390 <__kernel_rem_pio2f+0x438>
   323fa:	ed50 7a02 	vldr	s15, [r0, #-8]
   323fe:	ed70 6a01 	vldmdb	r0!, {s13}
   32402:	ee37 7aa6 	vadd.f32	s14, s15, s13
   32406:	3c01      	subs	r4, #1
   32408:	ee77 7ac7 	vsub.f32	s15, s15, s14
   3240c:	ed00 7a01 	vstr	s14, [r0, #-4]
   32410:	ee77 7aa6 	vadd.f32	s15, s15, s13
   32414:	edc0 7a00 	vstr	s15, [r0]
   32418:	e78d      	b.n	32336 <__kernel_rem_pio2f+0x3de>
   3241a:	ed50 7a02 	vldr	s15, [r0, #-8]
   3241e:	ed70 6a01 	vldmdb	r0!, {s13}
   32422:	ee37 7aa6 	vadd.f32	s14, s15, s13
   32426:	3c01      	subs	r4, #1
   32428:	ee77 7ac7 	vsub.f32	s15, s15, s14
   3242c:	ed00 7a01 	vstr	s14, [r0, #-4]
   32430:	ee77 7aa6 	vadd.f32	s15, s15, s13
   32434:	edc0 7a00 	vstr	s15, [r0]
   32438:	e781      	b.n	3233e <__kernel_rem_pio2f+0x3e6>
   3243a:	ed31 7a01 	vldmdb	r1!, {s14}
   3243e:	3b01      	subs	r3, #1
   32440:	ee77 7a87 	vadd.f32	s15, s15, s14
   32444:	e77f      	b.n	32346 <__kernel_rem_pio2f+0x3ee>
   32446:	eef1 6a66 	vneg.f32	s13, s13
   3244a:	eeb1 7a47 	vneg.f32	s14, s14
   3244e:	edc6 6a00 	vstr	s13, [r6]
   32452:	ed86 7a01 	vstr	s14, [r6, #4]
   32456:	eef1 7a67 	vneg.f32	s15, s15
   3245a:	e781      	b.n	32360 <__kernel_rem_pio2f+0x408>

0003245c <__kernel_sinf>:
   3245c:	ee10 3a10 	vmov	r3, s0
   32460:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   32464:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   32468:	da04      	bge.n	32474 <__kernel_sinf+0x18>
   3246a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   3246e:	ee17 3a90 	vmov	r3, s15
   32472:	b35b      	cbz	r3, 324cc <__kernel_sinf+0x70>
   32474:	ee20 7a00 	vmul.f32	s14, s0, s0
   32478:	eddf 7a15 	vldr	s15, [pc, #84]	; 324d0 <__kernel_sinf+0x74>
   3247c:	ed9f 6a15 	vldr	s12, [pc, #84]	; 324d4 <__kernel_sinf+0x78>
   32480:	eea7 6a27 	vfma.f32	s12, s14, s15
   32484:	eddf 7a14 	vldr	s15, [pc, #80]	; 324d8 <__kernel_sinf+0x7c>
   32488:	eee6 7a07 	vfma.f32	s15, s12, s14
   3248c:	ed9f 6a13 	vldr	s12, [pc, #76]	; 324dc <__kernel_sinf+0x80>
   32490:	eea7 6a87 	vfma.f32	s12, s15, s14
   32494:	eddf 7a12 	vldr	s15, [pc, #72]	; 324e0 <__kernel_sinf+0x84>
   32498:	ee60 6a07 	vmul.f32	s13, s0, s14
   3249c:	eee6 7a07 	vfma.f32	s15, s12, s14
   324a0:	b930      	cbnz	r0, 324b0 <__kernel_sinf+0x54>
   324a2:	ed9f 6a10 	vldr	s12, [pc, #64]	; 324e4 <__kernel_sinf+0x88>
   324a6:	eea7 6a27 	vfma.f32	s12, s14, s15
   324aa:	eea6 0a26 	vfma.f32	s0, s12, s13
   324ae:	4770      	bx	lr
   324b0:	ee67 7ae6 	vnmul.f32	s15, s15, s13
   324b4:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   324b8:	eee0 7a86 	vfma.f32	s15, s1, s12
   324bc:	eed7 0a87 	vfnms.f32	s1, s15, s14
   324c0:	eddf 7a09 	vldr	s15, [pc, #36]	; 324e8 <__kernel_sinf+0x8c>
   324c4:	eee6 0aa7 	vfma.f32	s1, s13, s15
   324c8:	ee30 0a60 	vsub.f32	s0, s0, s1
   324cc:	4770      	bx	lr
   324ce:	bf00      	nop
   324d0:	2f2ec9d3 	.word	0x2f2ec9d3
   324d4:	b2d72f34 	.word	0xb2d72f34
   324d8:	3638ef1b 	.word	0x3638ef1b
   324dc:	b9500d01 	.word	0xb9500d01
   324e0:	3c088889 	.word	0x3c088889
   324e4:	be2aaaab 	.word	0xbe2aaaab
   324e8:	3e2aaaab 	.word	0x3e2aaaab

000324ec <__kernel_tanf>:
   324ec:	b508      	push	{r3, lr}
   324ee:	ee10 3a10 	vmov	r3, s0
   324f2:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
   324f6:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
   324fa:	eef0 7a40 	vmov.f32	s15, s0
   324fe:	da17      	bge.n	32530 <__kernel_tanf+0x44>
   32500:	eebd 7ac0 	vcvt.s32.f32	s14, s0
   32504:	ee17 1a10 	vmov	r1, s14
   32508:	bb41      	cbnz	r1, 3255c <__kernel_tanf+0x70>
   3250a:	1c43      	adds	r3, r0, #1
   3250c:	4313      	orrs	r3, r2
   3250e:	d108      	bne.n	32522 <__kernel_tanf+0x36>
   32510:	f7fe f836 	bl	30580 <fabsf>
   32514:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   32518:	eec7 7a00 	vdiv.f32	s15, s14, s0
   3251c:	eeb0 0a67 	vmov.f32	s0, s15
   32520:	bd08      	pop	{r3, pc}
   32522:	2801      	cmp	r0, #1
   32524:	d0fa      	beq.n	3251c <__kernel_tanf+0x30>
   32526:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   3252a:	eec7 7a00 	vdiv.f32	s15, s14, s0
   3252e:	e7f5      	b.n	3251c <__kernel_tanf+0x30>
   32530:	494e      	ldr	r1, [pc, #312]	; (3266c <__kernel_tanf+0x180>)
   32532:	428a      	cmp	r2, r1
   32534:	dd12      	ble.n	3255c <__kernel_tanf+0x70>
   32536:	2b00      	cmp	r3, #0
   32538:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 32670 <__kernel_tanf+0x184>
   3253c:	bfb8      	it	lt
   3253e:	eef1 7a40 	vneglt.f32	s15, s0
   32542:	ee77 7a67 	vsub.f32	s15, s14, s15
   32546:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 32674 <__kernel_tanf+0x188>
   3254a:	bfb8      	it	lt
   3254c:	eef1 0a60 	vneglt.f32	s1, s1
   32550:	ee77 0a60 	vsub.f32	s1, s14, s1
   32554:	ee70 7aa7 	vadd.f32	s15, s1, s15
   32558:	eddf 0a47 	vldr	s1, [pc, #284]	; 32678 <__kernel_tanf+0x18c>
   3255c:	ed9f 6a47 	vldr	s12, [pc, #284]	; 3267c <__kernel_tanf+0x190>
   32560:	eddf 5a47 	vldr	s11, [pc, #284]	; 32680 <__kernel_tanf+0x194>
   32564:	ed9f 5a47 	vldr	s10, [pc, #284]	; 32684 <__kernel_tanf+0x198>
   32568:	4940      	ldr	r1, [pc, #256]	; (3266c <__kernel_tanf+0x180>)
   3256a:	ee67 6aa7 	vmul.f32	s13, s15, s15
   3256e:	428a      	cmp	r2, r1
   32570:	ee26 7aa6 	vmul.f32	s14, s13, s13
   32574:	ee67 4aa6 	vmul.f32	s9, s15, s13
   32578:	eee7 5a06 	vfma.f32	s11, s14, s12
   3257c:	ed9f 6a42 	vldr	s12, [pc, #264]	; 32688 <__kernel_tanf+0x19c>
   32580:	eea5 6a87 	vfma.f32	s12, s11, s14
   32584:	eddf 5a41 	vldr	s11, [pc, #260]	; 3268c <__kernel_tanf+0x1a0>
   32588:	eee6 5a07 	vfma.f32	s11, s12, s14
   3258c:	ed9f 6a40 	vldr	s12, [pc, #256]	; 32690 <__kernel_tanf+0x1a4>
   32590:	eea5 6a87 	vfma.f32	s12, s11, s14
   32594:	eddf 5a3f 	vldr	s11, [pc, #252]	; 32694 <__kernel_tanf+0x1a8>
   32598:	eee6 5a07 	vfma.f32	s11, s12, s14
   3259c:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 32698 <__kernel_tanf+0x1ac>
   325a0:	eea7 6a05 	vfma.f32	s12, s14, s10
   325a4:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 3269c <__kernel_tanf+0x1b0>
   325a8:	eea6 5a07 	vfma.f32	s10, s12, s14
   325ac:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 326a0 <__kernel_tanf+0x1b4>
   325b0:	eea5 6a07 	vfma.f32	s12, s10, s14
   325b4:	ed9f 5a3b 	vldr	s10, [pc, #236]	; 326a4 <__kernel_tanf+0x1b8>
   325b8:	eea6 5a07 	vfma.f32	s10, s12, s14
   325bc:	ed9f 6a3a 	vldr	s12, [pc, #232]	; 326a8 <__kernel_tanf+0x1bc>
   325c0:	eea5 6a07 	vfma.f32	s12, s10, s14
   325c4:	eeb0 7a46 	vmov.f32	s14, s12
   325c8:	eea5 7aa6 	vfma.f32	s14, s11, s13
   325cc:	eeb0 6a60 	vmov.f32	s12, s1
   325d0:	eea7 6a24 	vfma.f32	s12, s14, s9
   325d4:	ed9f 7a35 	vldr	s14, [pc, #212]	; 326ac <__kernel_tanf+0x1c0>
   325d8:	eee6 0a26 	vfma.f32	s1, s12, s13
   325dc:	eee4 0a87 	vfma.f32	s1, s9, s14
   325e0:	ee77 6aa0 	vadd.f32	s13, s15, s1
   325e4:	dd1d      	ble.n	32622 <__kernel_tanf+0x136>
   325e6:	ee07 0a10 	vmov	s14, r0
   325ea:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   325ee:	ee66 5aa6 	vmul.f32	s11, s13, s13
   325f2:	ee76 6a87 	vadd.f32	s13, s13, s14
   325f6:	179b      	asrs	r3, r3, #30
   325f8:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   325fc:	f003 0302 	and.w	r3, r3, #2
   32600:	f1c3 0301 	rsb	r3, r3, #1
   32604:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
   32608:	ee76 0a60 	vsub.f32	s1, s12, s1
   3260c:	ee77 7ae0 	vsub.f32	s15, s15, s1
   32610:	eea7 7ae6 	vfms.f32	s14, s15, s13
   32614:	ee07 3a90 	vmov	s15, r3
   32618:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3261c:	ee67 7a27 	vmul.f32	s15, s14, s15
   32620:	e77c      	b.n	3251c <__kernel_tanf+0x30>
   32622:	2801      	cmp	r0, #1
   32624:	d01f      	beq.n	32666 <__kernel_tanf+0x17a>
   32626:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   3262a:	eec7 5a26 	vdiv.f32	s11, s14, s13
   3262e:	4b20      	ldr	r3, [pc, #128]	; (326b0 <__kernel_tanf+0x1c4>)
   32630:	ee16 2a90 	vmov	r2, s13
   32634:	401a      	ands	r2, r3
   32636:	ee06 2a10 	vmov	s12, r2
   3263a:	ee15 2a90 	vmov	r2, s11
   3263e:	4013      	ands	r3, r2
   32640:	ee07 3a10 	vmov	s14, r3
   32644:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   32648:	eee6 6a07 	vfma.f32	s13, s12, s14
   3264c:	ee76 7a67 	vsub.f32	s15, s12, s15
   32650:	ee70 0ae7 	vsub.f32	s1, s1, s15
   32654:	eef0 7a66 	vmov.f32	s15, s13
   32658:	eee7 7a20 	vfma.f32	s15, s14, s1
   3265c:	eea7 7aa5 	vfma.f32	s14, s15, s11
   32660:	eef0 7a47 	vmov.f32	s15, s14
   32664:	e75a      	b.n	3251c <__kernel_tanf+0x30>
   32666:	eef0 7a66 	vmov.f32	s15, s13
   3266a:	e757      	b.n	3251c <__kernel_tanf+0x30>
   3266c:	3f2ca13f 	.word	0x3f2ca13f
   32670:	3f490fda 	.word	0x3f490fda
   32674:	33222168 	.word	0x33222168
   32678:	00000000 	.word	0x00000000
   3267c:	37d95384 	.word	0x37d95384
   32680:	3895c07a 	.word	0x3895c07a
   32684:	b79bae5f 	.word	0xb79bae5f
   32688:	398137b9 	.word	0x398137b9
   3268c:	3abede48 	.word	0x3abede48
   32690:	3c11371f 	.word	0x3c11371f
   32694:	3d5d0dd1 	.word	0x3d5d0dd1
   32698:	38a3f445 	.word	0x38a3f445
   3269c:	3a1a26c8 	.word	0x3a1a26c8
   326a0:	3b6b6916 	.word	0x3b6b6916
   326a4:	3cb327a4 	.word	0x3cb327a4
   326a8:	3e088889 	.word	0x3e088889
   326ac:	3eaaaaab 	.word	0x3eaaaaab
   326b0:	fffff000 	.word	0xfffff000

000326b4 <with_errnof>:
   326b4:	b510      	push	{r4, lr}
   326b6:	ed2d 8b02 	vpush	{d8}
   326ba:	eeb0 8a40 	vmov.f32	s16, s0
   326be:	4604      	mov	r4, r0
   326c0:	f7fd fd28 	bl	30114 <__errno>
   326c4:	eeb0 0a48 	vmov.f32	s0, s16
   326c8:	ecbd 8b02 	vpop	{d8}
   326cc:	6004      	str	r4, [r0, #0]
   326ce:	bd10      	pop	{r4, pc}

000326d0 <xflowf>:
   326d0:	b130      	cbz	r0, 326e0 <xflowf+0x10>
   326d2:	eef1 7a40 	vneg.f32	s15, s0
   326d6:	2022      	movs	r0, #34	; 0x22
   326d8:	ee27 0a80 	vmul.f32	s0, s15, s0
   326dc:	f7ff bfea 	b.w	326b4 <with_errnof>
   326e0:	eef0 7a40 	vmov.f32	s15, s0
   326e4:	e7f7      	b.n	326d6 <xflowf+0x6>
	...

000326e8 <__math_uflowf>:
   326e8:	ed9f 0a01 	vldr	s0, [pc, #4]	; 326f0 <__math_uflowf+0x8>
   326ec:	f7ff bff0 	b.w	326d0 <xflowf>
   326f0:	10000000 	.word	0x10000000

000326f4 <__math_may_uflowf>:
   326f4:	ed9f 0a01 	vldr	s0, [pc, #4]	; 326fc <__math_may_uflowf+0x8>
   326f8:	f7ff bfea 	b.w	326d0 <xflowf>
   326fc:	1a200000 	.word	0x1a200000

00032700 <__math_oflowf>:
   32700:	ed9f 0a01 	vldr	s0, [pc, #4]	; 32708 <__math_oflowf+0x8>
   32704:	f7ff bfe4 	b.w	326d0 <xflowf>
   32708:	70000000 	.word	0x70000000

0003270c <__math_divzerof>:
   3270c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   32710:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   32714:	2800      	cmp	r0, #0
   32716:	fe40 7a27 	vseleq.f32	s15, s0, s15
   3271a:	ed9f 0a03 	vldr	s0, [pc, #12]	; 32728 <__math_divzerof+0x1c>
   3271e:	2022      	movs	r0, #34	; 0x22
   32720:	ee87 0a80 	vdiv.f32	s0, s15, s0
   32724:	f7ff bfc6 	b.w	326b4 <with_errnof>
   32728:	00000000 	.word	0x00000000

0003272c <__math_invalidf>:
   3272c:	eef0 7a40 	vmov.f32	s15, s0
   32730:	ee30 7a40 	vsub.f32	s14, s0, s0
   32734:	eef4 7a67 	vcmp.f32	s15, s15
   32738:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3273c:	ee87 0a07 	vdiv.f32	s0, s14, s14
   32740:	d602      	bvs.n	32748 <__math_invalidf+0x1c>
   32742:	2021      	movs	r0, #33	; 0x21
   32744:	f7ff bfb6 	b.w	326b4 <with_errnof>
   32748:	4770      	bx	lr

0003274a <fabs>:
   3274a:	ec51 0b10 	vmov	r0, r1, d0
   3274e:	ee10 2a10 	vmov	r2, s0
   32752:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   32756:	ec43 2b10 	vmov	d0, r2, r3
   3275a:	4770      	bx	lr

0003275c <finite>:
   3275c:	ee10 3a90 	vmov	r3, s1
   32760:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
   32764:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
   32768:	0fc0      	lsrs	r0, r0, #31
   3276a:	4770      	bx	lr

0003276c <matherr>:
   3276c:	2000      	movs	r0, #0
   3276e:	4770      	bx	lr

00032770 <nan>:
   32770:	ed9f 0b01 	vldr	d0, [pc, #4]	; 32778 <nan+0x8>
   32774:	4770      	bx	lr
   32776:	bf00      	nop
   32778:	00000000 	.word	0x00000000
   3277c:	7ff80000 	.word	0x7ff80000

00032780 <rint>:
   32780:	b530      	push	{r4, r5, lr}
   32782:	b085      	sub	sp, #20
   32784:	ed8d 0b00 	vstr	d0, [sp]
   32788:	e9dd 2300 	ldrd	r2, r3, [sp]
   3278c:	f3c3 510a 	ubfx	r1, r3, #20, #11
   32790:	f2a1 30ff 	subw	r0, r1, #1023	; 0x3ff
   32794:	2813      	cmp	r0, #19
   32796:	ea4f 74d3 	mov.w	r4, r3, lsr #31
   3279a:	dc5a      	bgt.n	32852 <rint+0xd2>
   3279c:	2800      	cmp	r0, #0
   3279e:	da2f      	bge.n	32800 <rint+0x80>
   327a0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   327a4:	4311      	orrs	r1, r2
   327a6:	d027      	beq.n	327f8 <rint+0x78>
   327a8:	f3c3 0513 	ubfx	r5, r3, #0, #20
   327ac:	4315      	orrs	r5, r2
   327ae:	426a      	negs	r2, r5
   327b0:	432a      	orrs	r2, r5
   327b2:	0b12      	lsrs	r2, r2, #12
   327b4:	0c5b      	lsrs	r3, r3, #17
   327b6:	045b      	lsls	r3, r3, #17
   327b8:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
   327bc:	e9dd 0100 	ldrd	r0, r1, [sp]
   327c0:	ea42 0103 	orr.w	r1, r2, r3
   327c4:	4b31      	ldr	r3, [pc, #196]	; (3288c <rint+0x10c>)
   327c6:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   327ca:	ed93 6b00 	vldr	d6, [r3]
   327ce:	ec41 0b17 	vmov	d7, r0, r1
   327d2:	ee36 7b07 	vadd.f64	d7, d6, d7
   327d6:	ed8d 7b02 	vstr	d7, [sp, #8]
   327da:	ed9d 7b02 	vldr	d7, [sp, #8]
   327de:	ee37 7b46 	vsub.f64	d7, d7, d6
   327e2:	ed8d 7b00 	vstr	d7, [sp]
   327e6:	9b01      	ldr	r3, [sp, #4]
   327e8:	e9dd 0100 	ldrd	r0, r1, [sp]
   327ec:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   327f0:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
   327f4:	e9cd 0100 	strd	r0, r1, [sp]
   327f8:	ed9d 0b00 	vldr	d0, [sp]
   327fc:	b005      	add	sp, #20
   327fe:	bd30      	pop	{r4, r5, pc}
   32800:	4923      	ldr	r1, [pc, #140]	; (32890 <rint+0x110>)
   32802:	4101      	asrs	r1, r0
   32804:	ea03 0501 	and.w	r5, r3, r1
   32808:	4315      	orrs	r5, r2
   3280a:	d0f5      	beq.n	327f8 <rint+0x78>
   3280c:	0849      	lsrs	r1, r1, #1
   3280e:	ea03 0501 	and.w	r5, r3, r1
   32812:	432a      	orrs	r2, r5
   32814:	d00b      	beq.n	3282e <rint+0xae>
   32816:	ea23 0101 	bic.w	r1, r3, r1
   3281a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   3281e:	2813      	cmp	r0, #19
   32820:	fa43 f300 	asr.w	r3, r3, r0
   32824:	bf0c      	ite	eq
   32826:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
   3282a:	2200      	movne	r2, #0
   3282c:	430b      	orrs	r3, r1
   3282e:	4619      	mov	r1, r3
   32830:	4b16      	ldr	r3, [pc, #88]	; (3288c <rint+0x10c>)
   32832:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   32836:	ed94 6b00 	vldr	d6, [r4]
   3283a:	4610      	mov	r0, r2
   3283c:	ec41 0b17 	vmov	d7, r0, r1
   32840:	ee36 7b07 	vadd.f64	d7, d6, d7
   32844:	ed8d 7b02 	vstr	d7, [sp, #8]
   32848:	ed9d 7b02 	vldr	d7, [sp, #8]
   3284c:	ee37 7b46 	vsub.f64	d7, d7, d6
   32850:	e008      	b.n	32864 <rint+0xe4>
   32852:	2833      	cmp	r0, #51	; 0x33
   32854:	dd09      	ble.n	3286a <rint+0xea>
   32856:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   3285a:	d1cd      	bne.n	327f8 <rint+0x78>
   3285c:	ed9d 7b00 	vldr	d7, [sp]
   32860:	ee37 7b07 	vadd.f64	d7, d7, d7
   32864:	ed8d 7b00 	vstr	d7, [sp]
   32868:	e7c6      	b.n	327f8 <rint+0x78>
   3286a:	f2a1 4013 	subw	r0, r1, #1043	; 0x413
   3286e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   32872:	40c1      	lsrs	r1, r0
   32874:	420a      	tst	r2, r1
   32876:	d0bf      	beq.n	327f8 <rint+0x78>
   32878:	0849      	lsrs	r1, r1, #1
   3287a:	420a      	tst	r2, r1
   3287c:	bf1f      	itttt	ne
   3287e:	ea22 0101 	bicne.w	r1, r2, r1
   32882:	f04f 4280 	movne.w	r2, #1073741824	; 0x40000000
   32886:	4102      	asrne	r2, r0
   32888:	430a      	orrne	r2, r1
   3288a:	e7d0      	b.n	3282e <rint+0xae>
   3288c:	00055fe0 	.word	0x00055fe0
   32890:	000fffff 	.word	0x000fffff
   32894:	00000000 	.word	0x00000000

00032898 <scalbn>:
   32898:	b500      	push	{lr}
   3289a:	ed2d 8b02 	vpush	{d8}
   3289e:	b083      	sub	sp, #12
   328a0:	ed8d 0b00 	vstr	d0, [sp]
   328a4:	9b01      	ldr	r3, [sp, #4]
   328a6:	f3c3 520a 	ubfx	r2, r3, #20, #11
   328aa:	b9a2      	cbnz	r2, 328d6 <scalbn+0x3e>
   328ac:	9a00      	ldr	r2, [sp, #0]
   328ae:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   328b2:	4313      	orrs	r3, r2
   328b4:	d03a      	beq.n	3292c <scalbn+0x94>
   328b6:	ed9f 7b2e 	vldr	d7, [pc, #184]	; 32970 <scalbn+0xd8>
   328ba:	4b35      	ldr	r3, [pc, #212]	; (32990 <scalbn+0xf8>)
   328bc:	ee20 7b07 	vmul.f64	d7, d0, d7
   328c0:	4298      	cmp	r0, r3
   328c2:	ed8d 7b00 	vstr	d7, [sp]
   328c6:	da11      	bge.n	328ec <scalbn+0x54>
   328c8:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 32978 <scalbn+0xe0>
   328cc:	ed9d 6b00 	vldr	d6, [sp]
   328d0:	ee27 7b06 	vmul.f64	d7, d7, d6
   328d4:	e007      	b.n	328e6 <scalbn+0x4e>
   328d6:	f240 71ff 	movw	r1, #2047	; 0x7ff
   328da:	428a      	cmp	r2, r1
   328dc:	d10a      	bne.n	328f4 <scalbn+0x5c>
   328de:	ed9d 7b00 	vldr	d7, [sp]
   328e2:	ee37 7b07 	vadd.f64	d7, d7, d7
   328e6:	ed8d 7b00 	vstr	d7, [sp]
   328ea:	e01f      	b.n	3292c <scalbn+0x94>
   328ec:	9b01      	ldr	r3, [sp, #4]
   328ee:	f3c3 520a 	ubfx	r2, r3, #20, #11
   328f2:	3a36      	subs	r2, #54	; 0x36
   328f4:	4402      	add	r2, r0
   328f6:	f240 71fe 	movw	r1, #2046	; 0x7fe
   328fa:	428a      	cmp	r2, r1
   328fc:	dd0a      	ble.n	32914 <scalbn+0x7c>
   328fe:	ed9f 8b20 	vldr	d8, [pc, #128]	; 32980 <scalbn+0xe8>
   32902:	eeb0 0b48 	vmov.f64	d0, d8
   32906:	ed9d 1b00 	vldr	d1, [sp]
   3290a:	f000 fa19 	bl	32d40 <copysign>
   3290e:	ee20 7b08 	vmul.f64	d7, d0, d8
   32912:	e7e8      	b.n	328e6 <scalbn+0x4e>
   32914:	2a00      	cmp	r2, #0
   32916:	dd10      	ble.n	3293a <scalbn+0xa2>
   32918:	e9dd 0100 	ldrd	r0, r1, [sp]
   3291c:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   32920:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   32924:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
   32928:	e9cd 0100 	strd	r0, r1, [sp]
   3292c:	ed9d 0b00 	vldr	d0, [sp]
   32930:	b003      	add	sp, #12
   32932:	ecbd 8b02 	vpop	{d8}
   32936:	f85d fb04 	ldr.w	pc, [sp], #4
   3293a:	f112 0f35 	cmn.w	r2, #53	; 0x35
   3293e:	da06      	bge.n	3294e <scalbn+0xb6>
   32940:	f24c 3350 	movw	r3, #50000	; 0xc350
   32944:	4298      	cmp	r0, r3
   32946:	dcda      	bgt.n	328fe <scalbn+0x66>
   32948:	ed9f 8b0b 	vldr	d8, [pc, #44]	; 32978 <scalbn+0xe0>
   3294c:	e7d9      	b.n	32902 <scalbn+0x6a>
   3294e:	e9dd 0100 	ldrd	r0, r1, [sp]
   32952:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   32956:	3236      	adds	r2, #54	; 0x36
   32958:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   3295c:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
   32960:	ec41 0b17 	vmov	d7, r0, r1
   32964:	ed9f 6b08 	vldr	d6, [pc, #32]	; 32988 <scalbn+0xf0>
   32968:	e7b2      	b.n	328d0 <scalbn+0x38>
   3296a:	bf00      	nop
   3296c:	f3af 8000 	nop.w
   32970:	00000000 	.word	0x00000000
   32974:	43500000 	.word	0x43500000
   32978:	c2f8f359 	.word	0xc2f8f359
   3297c:	01a56e1f 	.word	0x01a56e1f
   32980:	8800759c 	.word	0x8800759c
   32984:	7e37e43c 	.word	0x7e37e43c
   32988:	00000000 	.word	0x00000000
   3298c:	3c900000 	.word	0x3c900000
   32990:	ffff3cb0 	.word	0xffff3cb0

00032994 <expm1f>:
   32994:	ee10 2a10 	vmov	r2, s0
   32998:	4984      	ldr	r1, [pc, #528]	; (32bac <expm1f+0x218>)
   3299a:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
   3299e:	428b      	cmp	r3, r1
   329a0:	d923      	bls.n	329ea <expm1f+0x56>
   329a2:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   329a6:	d902      	bls.n	329ae <expm1f+0x1a>
   329a8:	ee30 0a00 	vadd.f32	s0, s0, s0
   329ac:	4770      	bx	lr
   329ae:	d105      	bne.n	329bc <expm1f+0x28>
   329b0:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   329b4:	2a00      	cmp	r2, #0
   329b6:	fe20 0a27 	vselge.f32	s0, s0, s15
   329ba:	4770      	bx	lr
   329bc:	2a00      	cmp	r2, #0
   329be:	db08      	blt.n	329d2 <expm1f+0x3e>
   329c0:	4a7b      	ldr	r2, [pc, #492]	; (32bb0 <expm1f+0x21c>)
   329c2:	4293      	cmp	r3, r2
   329c4:	f240 80ea 	bls.w	32b9c <expm1f+0x208>
   329c8:	ed9f 0a7a 	vldr	s0, [pc, #488]	; 32bb4 <expm1f+0x220>
   329cc:	ee20 0a00 	vmul.f32	s0, s0, s0
   329d0:	4770      	bx	lr
   329d2:	eddf 7a79 	vldr	s15, [pc, #484]	; 32bb8 <expm1f+0x224>
   329d6:	ee70 7a27 	vadd.f32	s15, s0, s15
   329da:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   329de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   329e2:	d554      	bpl.n	32a8e <expm1f+0xfa>
   329e4:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   329e8:	4770      	bx	lr
   329ea:	4974      	ldr	r1, [pc, #464]	; (32bbc <expm1f+0x228>)
   329ec:	428b      	cmp	r3, r1
   329ee:	d96c      	bls.n	32aca <expm1f+0x136>
   329f0:	4973      	ldr	r1, [pc, #460]	; (32bc0 <expm1f+0x22c>)
   329f2:	428b      	cmp	r3, r1
   329f4:	d84b      	bhi.n	32a8e <expm1f+0xfa>
   329f6:	ed9f 7a73 	vldr	s14, [pc, #460]	; 32bc4 <expm1f+0x230>
   329fa:	2a00      	cmp	r2, #0
   329fc:	bfa7      	ittee	ge
   329fe:	ee30 7a47 	vsubge.f32	s14, s0, s14
   32a02:	eddf 7a71 	vldrge	s15, [pc, #452]	; 32bc8 <expm1f+0x234>
   32a06:	eddf 7a71 	vldrlt	s15, [pc, #452]	; 32bcc <expm1f+0x238>
   32a0a:	ee30 7a07 	vaddlt.f32	s14, s0, s14
   32a0e:	bfac      	ite	ge
   32a10:	2301      	movge	r3, #1
   32a12:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   32a16:	ee37 0a67 	vsub.f32	s0, s14, s15
   32a1a:	ee37 7a40 	vsub.f32	s14, s14, s0
   32a1e:	ee77 7a67 	vsub.f32	s15, s14, s15
   32a22:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
   32a26:	ee20 5a25 	vmul.f32	s10, s0, s11
   32a2a:	eddf 6a69 	vldr	s13, [pc, #420]	; 32bd0 <expm1f+0x23c>
   32a2e:	ed9f 6a69 	vldr	s12, [pc, #420]	; 32bd4 <expm1f+0x240>
   32a32:	ee20 7a05 	vmul.f32	s14, s0, s10
   32a36:	eea7 6a26 	vfma.f32	s12, s14, s13
   32a3a:	eddf 6a67 	vldr	s13, [pc, #412]	; 32bd8 <expm1f+0x244>
   32a3e:	eee6 6a07 	vfma.f32	s13, s12, s14
   32a42:	ed9f 6a66 	vldr	s12, [pc, #408]	; 32bdc <expm1f+0x248>
   32a46:	eea6 6a87 	vfma.f32	s12, s13, s14
   32a4a:	eddf 6a65 	vldr	s13, [pc, #404]	; 32be0 <expm1f+0x24c>
   32a4e:	eee6 6a07 	vfma.f32	s13, s12, s14
   32a52:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   32a56:	eef0 4a46 	vmov.f32	s9, s12
   32a5a:	eee6 4a87 	vfma.f32	s9, s13, s14
   32a5e:	eef0 6a64 	vmov.f32	s13, s9
   32a62:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
   32a66:	eee5 4a66 	vfms.f32	s9, s10, s13
   32a6a:	ee36 5ae4 	vsub.f32	s10, s13, s9
   32a6e:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
   32a72:	eee0 6a64 	vfms.f32	s13, s0, s9
   32a76:	eef0 4a66 	vmov.f32	s9, s13
   32a7a:	eec5 6a24 	vdiv.f32	s13, s10, s9
   32a7e:	ee66 6a87 	vmul.f32	s13, s13, s14
   32a82:	bb83      	cbnz	r3, 32ae6 <expm1f+0x152>
   32a84:	eef0 7a47 	vmov.f32	s15, s14
   32a88:	eed0 7a26 	vfnms.f32	s15, s0, s13
   32a8c:	e026      	b.n	32adc <expm1f+0x148>
   32a8e:	eddf 7a55 	vldr	s15, [pc, #340]	; 32be4 <expm1f+0x250>
   32a92:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   32a96:	ee20 7a27 	vmul.f32	s14, s0, s15
   32a9a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   32a9e:	2a00      	cmp	r2, #0
   32aa0:	fe66 7aa7 	vselge.f32	s15, s13, s15
   32aa4:	ee77 7a87 	vadd.f32	s15, s15, s14
   32aa8:	ed9f 7a46 	vldr	s14, [pc, #280]	; 32bc4 <expm1f+0x230>
   32aac:	eddf 6a46 	vldr	s13, [pc, #280]	; 32bc8 <expm1f+0x234>
   32ab0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   32ab4:	ee17 3a90 	vmov	r3, s15
   32ab8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   32abc:	eea7 0ac7 	vfms.f32	s0, s15, s14
   32ac0:	ee67 7aa6 	vmul.f32	s15, s15, s13
   32ac4:	eeb0 7a40 	vmov.f32	s14, s0
   32ac8:	e7a5      	b.n	32a16 <expm1f+0x82>
   32aca:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
   32ace:	d208      	bcs.n	32ae2 <expm1f+0x14e>
   32ad0:	eddf 7a38 	vldr	s15, [pc, #224]	; 32bb4 <expm1f+0x220>
   32ad4:	ee70 7a27 	vadd.f32	s15, s0, s15
   32ad8:	ee77 7ae7 	vsub.f32	s15, s15, s15
   32adc:	ee30 0a67 	vsub.f32	s0, s0, s15
   32ae0:	4770      	bx	lr
   32ae2:	2300      	movs	r3, #0
   32ae4:	e79d      	b.n	32a22 <expm1f+0x8e>
   32ae6:	ee76 6ae7 	vsub.f32	s13, s13, s15
   32aea:	1c5a      	adds	r2, r3, #1
   32aec:	eed6 7a80 	vfnms.f32	s15, s13, s0
   32af0:	ee77 7ac7 	vsub.f32	s15, s15, s14
   32af4:	d106      	bne.n	32b04 <expm1f+0x170>
   32af6:	ee70 7a67 	vsub.f32	s15, s0, s15
   32afa:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
   32afe:	eea7 0aa5 	vfma.f32	s0, s15, s11
   32b02:	4770      	bx	lr
   32b04:	2b01      	cmp	r3, #1
   32b06:	d118      	bne.n	32b3a <expm1f+0x1a6>
   32b08:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
   32b0c:	eeb4 0ac7 	vcmpe.f32	s0, s14
   32b10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   32b14:	bf41      	itttt	mi
   32b16:	ee30 0a25 	vaddmi.f32	s0, s0, s11
   32b1a:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
   32b1e:	eef8 7a00 	vmovmi.f32	s15, #128	; 0xc0000000 -2.0
   32b22:	ee20 0a27 	vmulmi.f32	s0, s0, s15
   32b26:	bf5f      	itttt	pl
   32b28:	ee30 0a67 	vsubpl.f32	s0, s0, s15
   32b2c:	eef0 7a00 	vmovpl.f32	s15, #0	; 0x40000000  2.0
   32b30:	eea0 6a27 	vfmapl.f32	s12, s0, s15
   32b34:	eeb0 0a46 	vmovpl.f32	s0, s12
   32b38:	4770      	bx	lr
   32b3a:	1c5a      	adds	r2, r3, #1
   32b3c:	2a39      	cmp	r2, #57	; 0x39
   32b3e:	ea4f 51c3 	mov.w	r1, r3, lsl #23
   32b42:	d90b      	bls.n	32b5c <expm1f+0x1c8>
   32b44:	ee37 0ac0 	vsub.f32	s0, s15, s0
   32b48:	ee36 0a40 	vsub.f32	s0, s12, s0
   32b4c:	ee10 3a10 	vmov	r3, s0
   32b50:	440b      	add	r3, r1
   32b52:	ee00 3a10 	vmov	s0, r3
   32b56:	ee30 0a46 	vsub.f32	s0, s0, s12
   32b5a:	4770      	bx	lr
   32b5c:	2b16      	cmp	r3, #22
   32b5e:	dc11      	bgt.n	32b84 <expm1f+0x1f0>
   32b60:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   32b64:	fa42 f303 	asr.w	r3, r2, r3
   32b68:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
   32b6c:	ee37 0ac0 	vsub.f32	s0, s15, s0
   32b70:	ee07 3a90 	vmov	s15, r3
   32b74:	ee37 0ac0 	vsub.f32	s0, s15, s0
   32b78:	ee10 3a10 	vmov	r3, s0
   32b7c:	440b      	add	r3, r1
   32b7e:	ee00 3a10 	vmov	s0, r3
   32b82:	4770      	bx	lr
   32b84:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
   32b88:	05db      	lsls	r3, r3, #23
   32b8a:	ee07 3a10 	vmov	s14, r3
   32b8e:	ee77 7a87 	vadd.f32	s15, s15, s14
   32b92:	ee30 0a67 	vsub.f32	s0, s0, s15
   32b96:	ee30 0a06 	vadd.f32	s0, s0, s12
   32b9a:	e7ed      	b.n	32b78 <expm1f+0x1e4>
   32b9c:	eddf 7a11 	vldr	s15, [pc, #68]	; 32be4 <expm1f+0x250>
   32ba0:	ee20 7a27 	vmul.f32	s14, s0, s15
   32ba4:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   32ba8:	e77c      	b.n	32aa4 <expm1f+0x110>
   32baa:	bf00      	nop
   32bac:	4195b843 	.word	0x4195b843
   32bb0:	42b17217 	.word	0x42b17217
   32bb4:	7149f2ca 	.word	0x7149f2ca
   32bb8:	0da24260 	.word	0x0da24260
   32bbc:	3eb17218 	.word	0x3eb17218
   32bc0:	3f851591 	.word	0x3f851591
   32bc4:	3f317180 	.word	0x3f317180
   32bc8:	3717f7d1 	.word	0x3717f7d1
   32bcc:	b717f7d1 	.word	0xb717f7d1
   32bd0:	b457edbb 	.word	0xb457edbb
   32bd4:	36867e54 	.word	0x36867e54
   32bd8:	b8a670cd 	.word	0xb8a670cd
   32bdc:	3ad00d01 	.word	0x3ad00d01
   32be0:	bd088889 	.word	0xbd088889
   32be4:	3fb8aa3b 	.word	0x3fb8aa3b

00032be8 <finitef>:
   32be8:	ee10 3a10 	vmov	r3, s0
   32bec:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   32bf0:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
   32bf4:	bfac      	ite	ge
   32bf6:	2000      	movge	r0, #0
   32bf8:	2001      	movlt	r0, #1
   32bfa:	4770      	bx	lr

00032bfc <floorf>:
   32bfc:	ee10 3a10 	vmov	r3, s0
   32c00:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   32c04:	0dca      	lsrs	r2, r1, #23
   32c06:	3a7f      	subs	r2, #127	; 0x7f
   32c08:	2a16      	cmp	r2, #22
   32c0a:	dc2a      	bgt.n	32c62 <floorf+0x66>
   32c0c:	2a00      	cmp	r2, #0
   32c0e:	da11      	bge.n	32c34 <floorf+0x38>
   32c10:	eddf 7a18 	vldr	s15, [pc, #96]	; 32c74 <floorf+0x78>
   32c14:	ee30 0a27 	vadd.f32	s0, s0, s15
   32c18:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   32c1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   32c20:	dd05      	ble.n	32c2e <floorf+0x32>
   32c22:	2b00      	cmp	r3, #0
   32c24:	da23      	bge.n	32c6e <floorf+0x72>
   32c26:	4a14      	ldr	r2, [pc, #80]	; (32c78 <floorf+0x7c>)
   32c28:	2900      	cmp	r1, #0
   32c2a:	bf18      	it	ne
   32c2c:	4613      	movne	r3, r2
   32c2e:	ee00 3a10 	vmov	s0, r3
   32c32:	4770      	bx	lr
   32c34:	4911      	ldr	r1, [pc, #68]	; (32c7c <floorf+0x80>)
   32c36:	4111      	asrs	r1, r2
   32c38:	420b      	tst	r3, r1
   32c3a:	d0fa      	beq.n	32c32 <floorf+0x36>
   32c3c:	eddf 7a0d 	vldr	s15, [pc, #52]	; 32c74 <floorf+0x78>
   32c40:	ee30 0a27 	vadd.f32	s0, s0, s15
   32c44:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   32c48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   32c4c:	ddef      	ble.n	32c2e <floorf+0x32>
   32c4e:	2b00      	cmp	r3, #0
   32c50:	bfbe      	ittt	lt
   32c52:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
   32c56:	fa40 f202 	asrlt.w	r2, r0, r2
   32c5a:	189b      	addlt	r3, r3, r2
   32c5c:	ea23 0301 	bic.w	r3, r3, r1
   32c60:	e7e5      	b.n	32c2e <floorf+0x32>
   32c62:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   32c66:	d3e4      	bcc.n	32c32 <floorf+0x36>
   32c68:	ee30 0a00 	vadd.f32	s0, s0, s0
   32c6c:	4770      	bx	lr
   32c6e:	2300      	movs	r3, #0
   32c70:	e7dd      	b.n	32c2e <floorf+0x32>
   32c72:	bf00      	nop
   32c74:	7149f2ca 	.word	0x7149f2ca
   32c78:	bf800000 	.word	0xbf800000
   32c7c:	007fffff 	.word	0x007fffff

00032c80 <scalbnf>:
   32c80:	b508      	push	{r3, lr}
   32c82:	ee10 2a10 	vmov	r2, s0
   32c86:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
   32c8a:	ed2d 8b02 	vpush	{d8}
   32c8e:	eef0 0a40 	vmov.f32	s1, s0
   32c92:	d004      	beq.n	32c9e <scalbnf+0x1e>
   32c94:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   32c98:	d306      	bcc.n	32ca8 <scalbnf+0x28>
   32c9a:	ee70 0a00 	vadd.f32	s1, s0, s0
   32c9e:	ecbd 8b02 	vpop	{d8}
   32ca2:	eeb0 0a60 	vmov.f32	s0, s1
   32ca6:	bd08      	pop	{r3, pc}
   32ca8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   32cac:	d21c      	bcs.n	32ce8 <scalbnf+0x68>
   32cae:	4b1f      	ldr	r3, [pc, #124]	; (32d2c <scalbnf+0xac>)
   32cb0:	eddf 7a1f 	vldr	s15, [pc, #124]	; 32d30 <scalbnf+0xb0>
   32cb4:	4298      	cmp	r0, r3
   32cb6:	ee60 0a27 	vmul.f32	s1, s0, s15
   32cba:	db10      	blt.n	32cde <scalbnf+0x5e>
   32cbc:	ee10 2a90 	vmov	r2, s1
   32cc0:	f3c2 53c7 	ubfx	r3, r2, #23, #8
   32cc4:	3b19      	subs	r3, #25
   32cc6:	4403      	add	r3, r0
   32cc8:	2bfe      	cmp	r3, #254	; 0xfe
   32cca:	dd0f      	ble.n	32cec <scalbnf+0x6c>
   32ccc:	ed9f 8a19 	vldr	s16, [pc, #100]	; 32d34 <scalbnf+0xb4>
   32cd0:	eeb0 0a48 	vmov.f32	s0, s16
   32cd4:	f000 f843 	bl	32d5e <copysignf>
   32cd8:	ee60 0a08 	vmul.f32	s1, s0, s16
   32cdc:	e7df      	b.n	32c9e <scalbnf+0x1e>
   32cde:	eddf 7a16 	vldr	s15, [pc, #88]	; 32d38 <scalbnf+0xb8>
   32ce2:	ee60 0aa7 	vmul.f32	s1, s1, s15
   32ce6:	e7da      	b.n	32c9e <scalbnf+0x1e>
   32ce8:	0ddb      	lsrs	r3, r3, #23
   32cea:	e7ec      	b.n	32cc6 <scalbnf+0x46>
   32cec:	2b00      	cmp	r3, #0
   32cee:	dd06      	ble.n	32cfe <scalbnf+0x7e>
   32cf0:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   32cf4:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
   32cf8:	ee00 3a90 	vmov	s1, r3
   32cfc:	e7cf      	b.n	32c9e <scalbnf+0x1e>
   32cfe:	f113 0f16 	cmn.w	r3, #22
   32d02:	da06      	bge.n	32d12 <scalbnf+0x92>
   32d04:	f24c 3350 	movw	r3, #50000	; 0xc350
   32d08:	4298      	cmp	r0, r3
   32d0a:	dcdf      	bgt.n	32ccc <scalbnf+0x4c>
   32d0c:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 32d38 <scalbnf+0xb8>
   32d10:	e7de      	b.n	32cd0 <scalbnf+0x50>
   32d12:	3319      	adds	r3, #25
   32d14:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   32d18:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
   32d1c:	eddf 7a07 	vldr	s15, [pc, #28]	; 32d3c <scalbnf+0xbc>
   32d20:	ee07 3a10 	vmov	s14, r3
   32d24:	ee67 0a27 	vmul.f32	s1, s14, s15
   32d28:	e7b9      	b.n	32c9e <scalbnf+0x1e>
   32d2a:	bf00      	nop
   32d2c:	ffff3cb0 	.word	0xffff3cb0
   32d30:	4c000000 	.word	0x4c000000
   32d34:	7149f2ca 	.word	0x7149f2ca
   32d38:	0da24260 	.word	0x0da24260
   32d3c:	33000000 	.word	0x33000000

00032d40 <copysign>:
   32d40:	ec51 0b10 	vmov	r0, r1, d0
   32d44:	ee11 0a90 	vmov	r0, s3
   32d48:	ee10 2a10 	vmov	r2, s0
   32d4c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   32d50:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   32d54:	ea41 0300 	orr.w	r3, r1, r0
   32d58:	ec43 2b10 	vmov	d0, r2, r3
   32d5c:	4770      	bx	lr

00032d5e <copysignf>:
   32d5e:	ee10 3a10 	vmov	r3, s0
   32d62:	ee10 2a90 	vmov	r2, s1
   32d66:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   32d6a:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
   32d6e:	4313      	orrs	r3, r2
   32d70:	ee00 3a10 	vmov	s0, r3
   32d74:	4770      	bx	lr
	...

00032d78 <__aeabi_drsub>:
   32d78:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   32d7c:	e002      	b.n	32d84 <__adddf3>
   32d7e:	bf00      	nop

00032d80 <__aeabi_dsub>:
   32d80:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00032d84 <__adddf3>:
   32d84:	b530      	push	{r4, r5, lr}
   32d86:	ea4f 0441 	mov.w	r4, r1, lsl #1
   32d8a:	ea4f 0543 	mov.w	r5, r3, lsl #1
   32d8e:	ea94 0f05 	teq	r4, r5
   32d92:	bf08      	it	eq
   32d94:	ea90 0f02 	teqeq	r0, r2
   32d98:	bf1f      	itttt	ne
   32d9a:	ea54 0c00 	orrsne.w	ip, r4, r0
   32d9e:	ea55 0c02 	orrsne.w	ip, r5, r2
   32da2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   32da6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   32daa:	f000 80e2 	beq.w	32f72 <__adddf3+0x1ee>
   32dae:	ea4f 5454 	mov.w	r4, r4, lsr #21
   32db2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   32db6:	bfb8      	it	lt
   32db8:	426d      	neglt	r5, r5
   32dba:	dd0c      	ble.n	32dd6 <__adddf3+0x52>
   32dbc:	442c      	add	r4, r5
   32dbe:	ea80 0202 	eor.w	r2, r0, r2
   32dc2:	ea81 0303 	eor.w	r3, r1, r3
   32dc6:	ea82 0000 	eor.w	r0, r2, r0
   32dca:	ea83 0101 	eor.w	r1, r3, r1
   32dce:	ea80 0202 	eor.w	r2, r0, r2
   32dd2:	ea81 0303 	eor.w	r3, r1, r3
   32dd6:	2d36      	cmp	r5, #54	; 0x36
   32dd8:	bf88      	it	hi
   32dda:	bd30      	pophi	{r4, r5, pc}
   32ddc:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   32de0:	ea4f 3101 	mov.w	r1, r1, lsl #12
   32de4:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   32de8:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   32dec:	d002      	beq.n	32df4 <__adddf3+0x70>
   32dee:	4240      	negs	r0, r0
   32df0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   32df4:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   32df8:	ea4f 3303 	mov.w	r3, r3, lsl #12
   32dfc:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   32e00:	d002      	beq.n	32e08 <__adddf3+0x84>
   32e02:	4252      	negs	r2, r2
   32e04:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   32e08:	ea94 0f05 	teq	r4, r5
   32e0c:	f000 80a7 	beq.w	32f5e <__adddf3+0x1da>
   32e10:	f1a4 0401 	sub.w	r4, r4, #1
   32e14:	f1d5 0e20 	rsbs	lr, r5, #32
   32e18:	db0d      	blt.n	32e36 <__adddf3+0xb2>
   32e1a:	fa02 fc0e 	lsl.w	ip, r2, lr
   32e1e:	fa22 f205 	lsr.w	r2, r2, r5
   32e22:	1880      	adds	r0, r0, r2
   32e24:	f141 0100 	adc.w	r1, r1, #0
   32e28:	fa03 f20e 	lsl.w	r2, r3, lr
   32e2c:	1880      	adds	r0, r0, r2
   32e2e:	fa43 f305 	asr.w	r3, r3, r5
   32e32:	4159      	adcs	r1, r3
   32e34:	e00e      	b.n	32e54 <__adddf3+0xd0>
   32e36:	f1a5 0520 	sub.w	r5, r5, #32
   32e3a:	f10e 0e20 	add.w	lr, lr, #32
   32e3e:	2a01      	cmp	r2, #1
   32e40:	fa03 fc0e 	lsl.w	ip, r3, lr
   32e44:	bf28      	it	cs
   32e46:	f04c 0c02 	orrcs.w	ip, ip, #2
   32e4a:	fa43 f305 	asr.w	r3, r3, r5
   32e4e:	18c0      	adds	r0, r0, r3
   32e50:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   32e54:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   32e58:	d507      	bpl.n	32e6a <__adddf3+0xe6>
   32e5a:	f04f 0e00 	mov.w	lr, #0
   32e5e:	f1dc 0c00 	rsbs	ip, ip, #0
   32e62:	eb7e 0000 	sbcs.w	r0, lr, r0
   32e66:	eb6e 0101 	sbc.w	r1, lr, r1
   32e6a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   32e6e:	d31b      	bcc.n	32ea8 <__adddf3+0x124>
   32e70:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   32e74:	d30c      	bcc.n	32e90 <__adddf3+0x10c>
   32e76:	0849      	lsrs	r1, r1, #1
   32e78:	ea5f 0030 	movs.w	r0, r0, rrx
   32e7c:	ea4f 0c3c 	mov.w	ip, ip, rrx
   32e80:	f104 0401 	add.w	r4, r4, #1
   32e84:	ea4f 5244 	mov.w	r2, r4, lsl #21
   32e88:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   32e8c:	f080 809a 	bcs.w	32fc4 <__adddf3+0x240>
   32e90:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   32e94:	bf08      	it	eq
   32e96:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   32e9a:	f150 0000 	adcs.w	r0, r0, #0
   32e9e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   32ea2:	ea41 0105 	orr.w	r1, r1, r5
   32ea6:	bd30      	pop	{r4, r5, pc}
   32ea8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   32eac:	4140      	adcs	r0, r0
   32eae:	eb41 0101 	adc.w	r1, r1, r1
   32eb2:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   32eb6:	f1a4 0401 	sub.w	r4, r4, #1
   32eba:	d1e9      	bne.n	32e90 <__adddf3+0x10c>
   32ebc:	f091 0f00 	teq	r1, #0
   32ec0:	bf04      	itt	eq
   32ec2:	4601      	moveq	r1, r0
   32ec4:	2000      	moveq	r0, #0
   32ec6:	fab1 f381 	clz	r3, r1
   32eca:	bf08      	it	eq
   32ecc:	3320      	addeq	r3, #32
   32ece:	f1a3 030b 	sub.w	r3, r3, #11
   32ed2:	f1b3 0220 	subs.w	r2, r3, #32
   32ed6:	da0c      	bge.n	32ef2 <__adddf3+0x16e>
   32ed8:	320c      	adds	r2, #12
   32eda:	dd08      	ble.n	32eee <__adddf3+0x16a>
   32edc:	f102 0c14 	add.w	ip, r2, #20
   32ee0:	f1c2 020c 	rsb	r2, r2, #12
   32ee4:	fa01 f00c 	lsl.w	r0, r1, ip
   32ee8:	fa21 f102 	lsr.w	r1, r1, r2
   32eec:	e00c      	b.n	32f08 <__adddf3+0x184>
   32eee:	f102 0214 	add.w	r2, r2, #20
   32ef2:	bfd8      	it	le
   32ef4:	f1c2 0c20 	rsble	ip, r2, #32
   32ef8:	fa01 f102 	lsl.w	r1, r1, r2
   32efc:	fa20 fc0c 	lsr.w	ip, r0, ip
   32f00:	bfdc      	itt	le
   32f02:	ea41 010c 	orrle.w	r1, r1, ip
   32f06:	4090      	lslle	r0, r2
   32f08:	1ae4      	subs	r4, r4, r3
   32f0a:	bfa2      	ittt	ge
   32f0c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   32f10:	4329      	orrge	r1, r5
   32f12:	bd30      	popge	{r4, r5, pc}
   32f14:	ea6f 0404 	mvn.w	r4, r4
   32f18:	3c1f      	subs	r4, #31
   32f1a:	da1c      	bge.n	32f56 <__adddf3+0x1d2>
   32f1c:	340c      	adds	r4, #12
   32f1e:	dc0e      	bgt.n	32f3e <__adddf3+0x1ba>
   32f20:	f104 0414 	add.w	r4, r4, #20
   32f24:	f1c4 0220 	rsb	r2, r4, #32
   32f28:	fa20 f004 	lsr.w	r0, r0, r4
   32f2c:	fa01 f302 	lsl.w	r3, r1, r2
   32f30:	ea40 0003 	orr.w	r0, r0, r3
   32f34:	fa21 f304 	lsr.w	r3, r1, r4
   32f38:	ea45 0103 	orr.w	r1, r5, r3
   32f3c:	bd30      	pop	{r4, r5, pc}
   32f3e:	f1c4 040c 	rsb	r4, r4, #12
   32f42:	f1c4 0220 	rsb	r2, r4, #32
   32f46:	fa20 f002 	lsr.w	r0, r0, r2
   32f4a:	fa01 f304 	lsl.w	r3, r1, r4
   32f4e:	ea40 0003 	orr.w	r0, r0, r3
   32f52:	4629      	mov	r1, r5
   32f54:	bd30      	pop	{r4, r5, pc}
   32f56:	fa21 f004 	lsr.w	r0, r1, r4
   32f5a:	4629      	mov	r1, r5
   32f5c:	bd30      	pop	{r4, r5, pc}
   32f5e:	f094 0f00 	teq	r4, #0
   32f62:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   32f66:	bf06      	itte	eq
   32f68:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   32f6c:	3401      	addeq	r4, #1
   32f6e:	3d01      	subne	r5, #1
   32f70:	e74e      	b.n	32e10 <__adddf3+0x8c>
   32f72:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   32f76:	bf18      	it	ne
   32f78:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   32f7c:	d029      	beq.n	32fd2 <__adddf3+0x24e>
   32f7e:	ea94 0f05 	teq	r4, r5
   32f82:	bf08      	it	eq
   32f84:	ea90 0f02 	teqeq	r0, r2
   32f88:	d005      	beq.n	32f96 <__adddf3+0x212>
   32f8a:	ea54 0c00 	orrs.w	ip, r4, r0
   32f8e:	bf04      	itt	eq
   32f90:	4619      	moveq	r1, r3
   32f92:	4610      	moveq	r0, r2
   32f94:	bd30      	pop	{r4, r5, pc}
   32f96:	ea91 0f03 	teq	r1, r3
   32f9a:	bf1e      	ittt	ne
   32f9c:	2100      	movne	r1, #0
   32f9e:	2000      	movne	r0, #0
   32fa0:	bd30      	popne	{r4, r5, pc}
   32fa2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   32fa6:	d105      	bne.n	32fb4 <__adddf3+0x230>
   32fa8:	0040      	lsls	r0, r0, #1
   32faa:	4149      	adcs	r1, r1
   32fac:	bf28      	it	cs
   32fae:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   32fb2:	bd30      	pop	{r4, r5, pc}
   32fb4:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   32fb8:	bf3c      	itt	cc
   32fba:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   32fbe:	bd30      	popcc	{r4, r5, pc}
   32fc0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   32fc4:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   32fc8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   32fcc:	f04f 0000 	mov.w	r0, #0
   32fd0:	bd30      	pop	{r4, r5, pc}
   32fd2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   32fd6:	bf1a      	itte	ne
   32fd8:	4619      	movne	r1, r3
   32fda:	4610      	movne	r0, r2
   32fdc:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   32fe0:	bf1c      	itt	ne
   32fe2:	460b      	movne	r3, r1
   32fe4:	4602      	movne	r2, r0
   32fe6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   32fea:	bf06      	itte	eq
   32fec:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   32ff0:	ea91 0f03 	teqeq	r1, r3
   32ff4:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   32ff8:	bd30      	pop	{r4, r5, pc}
   32ffa:	bf00      	nop

00032ffc <__aeabi_ui2d>:
   32ffc:	f090 0f00 	teq	r0, #0
   33000:	bf04      	itt	eq
   33002:	2100      	moveq	r1, #0
   33004:	4770      	bxeq	lr
   33006:	b530      	push	{r4, r5, lr}
   33008:	f44f 6480 	mov.w	r4, #1024	; 0x400
   3300c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   33010:	f04f 0500 	mov.w	r5, #0
   33014:	f04f 0100 	mov.w	r1, #0
   33018:	e750      	b.n	32ebc <__adddf3+0x138>
   3301a:	bf00      	nop

0003301c <__aeabi_i2d>:
   3301c:	f090 0f00 	teq	r0, #0
   33020:	bf04      	itt	eq
   33022:	2100      	moveq	r1, #0
   33024:	4770      	bxeq	lr
   33026:	b530      	push	{r4, r5, lr}
   33028:	f44f 6480 	mov.w	r4, #1024	; 0x400
   3302c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   33030:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   33034:	bf48      	it	mi
   33036:	4240      	negmi	r0, r0
   33038:	f04f 0100 	mov.w	r1, #0
   3303c:	e73e      	b.n	32ebc <__adddf3+0x138>
   3303e:	bf00      	nop

00033040 <__aeabi_f2d>:
   33040:	0042      	lsls	r2, r0, #1
   33042:	ea4f 01e2 	mov.w	r1, r2, asr #3
   33046:	ea4f 0131 	mov.w	r1, r1, rrx
   3304a:	ea4f 7002 	mov.w	r0, r2, lsl #28
   3304e:	bf1f      	itttt	ne
   33050:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   33054:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   33058:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   3305c:	4770      	bxne	lr
   3305e:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   33062:	bf08      	it	eq
   33064:	4770      	bxeq	lr
   33066:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   3306a:	bf04      	itt	eq
   3306c:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   33070:	4770      	bxeq	lr
   33072:	b530      	push	{r4, r5, lr}
   33074:	f44f 7460 	mov.w	r4, #896	; 0x380
   33078:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   3307c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   33080:	e71c      	b.n	32ebc <__adddf3+0x138>
   33082:	bf00      	nop

00033084 <__aeabi_ul2d>:
   33084:	ea50 0201 	orrs.w	r2, r0, r1
   33088:	bf08      	it	eq
   3308a:	4770      	bxeq	lr
   3308c:	b530      	push	{r4, r5, lr}
   3308e:	f04f 0500 	mov.w	r5, #0
   33092:	e00a      	b.n	330aa <__aeabi_l2d+0x16>

00033094 <__aeabi_l2d>:
   33094:	ea50 0201 	orrs.w	r2, r0, r1
   33098:	bf08      	it	eq
   3309a:	4770      	bxeq	lr
   3309c:	b530      	push	{r4, r5, lr}
   3309e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   330a2:	d502      	bpl.n	330aa <__aeabi_l2d+0x16>
   330a4:	4240      	negs	r0, r0
   330a6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   330aa:	f44f 6480 	mov.w	r4, #1024	; 0x400
   330ae:	f104 0432 	add.w	r4, r4, #50	; 0x32
   330b2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   330b6:	f43f aed8 	beq.w	32e6a <__adddf3+0xe6>
   330ba:	f04f 0203 	mov.w	r2, #3
   330be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   330c2:	bf18      	it	ne
   330c4:	3203      	addne	r2, #3
   330c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   330ca:	bf18      	it	ne
   330cc:	3203      	addne	r2, #3
   330ce:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   330d2:	f1c2 0320 	rsb	r3, r2, #32
   330d6:	fa00 fc03 	lsl.w	ip, r0, r3
   330da:	fa20 f002 	lsr.w	r0, r0, r2
   330de:	fa01 fe03 	lsl.w	lr, r1, r3
   330e2:	ea40 000e 	orr.w	r0, r0, lr
   330e6:	fa21 f102 	lsr.w	r1, r1, r2
   330ea:	4414      	add	r4, r2
   330ec:	e6bd      	b.n	32e6a <__adddf3+0xe6>
   330ee:	bf00      	nop

000330f0 <__aeabi_frsub>:
   330f0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   330f4:	e002      	b.n	330fc <__addsf3>
   330f6:	bf00      	nop

000330f8 <__aeabi_fsub>:
   330f8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

000330fc <__addsf3>:
   330fc:	0042      	lsls	r2, r0, #1
   330fe:	bf1f      	itttt	ne
   33100:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   33104:	ea92 0f03 	teqne	r2, r3
   33108:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   3310c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   33110:	d06a      	beq.n	331e8 <__addsf3+0xec>
   33112:	ea4f 6212 	mov.w	r2, r2, lsr #24
   33116:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   3311a:	bfc1      	itttt	gt
   3311c:	18d2      	addgt	r2, r2, r3
   3311e:	4041      	eorgt	r1, r0
   33120:	4048      	eorgt	r0, r1
   33122:	4041      	eorgt	r1, r0
   33124:	bfb8      	it	lt
   33126:	425b      	neglt	r3, r3
   33128:	2b19      	cmp	r3, #25
   3312a:	bf88      	it	hi
   3312c:	4770      	bxhi	lr
   3312e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   33132:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   33136:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   3313a:	bf18      	it	ne
   3313c:	4240      	negne	r0, r0
   3313e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   33142:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   33146:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   3314a:	bf18      	it	ne
   3314c:	4249      	negne	r1, r1
   3314e:	ea92 0f03 	teq	r2, r3
   33152:	d03f      	beq.n	331d4 <__addsf3+0xd8>
   33154:	f1a2 0201 	sub.w	r2, r2, #1
   33158:	fa41 fc03 	asr.w	ip, r1, r3
   3315c:	eb10 000c 	adds.w	r0, r0, ip
   33160:	f1c3 0320 	rsb	r3, r3, #32
   33164:	fa01 f103 	lsl.w	r1, r1, r3
   33168:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   3316c:	d502      	bpl.n	33174 <__addsf3+0x78>
   3316e:	4249      	negs	r1, r1
   33170:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   33174:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   33178:	d313      	bcc.n	331a2 <__addsf3+0xa6>
   3317a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   3317e:	d306      	bcc.n	3318e <__addsf3+0x92>
   33180:	0840      	lsrs	r0, r0, #1
   33182:	ea4f 0131 	mov.w	r1, r1, rrx
   33186:	f102 0201 	add.w	r2, r2, #1
   3318a:	2afe      	cmp	r2, #254	; 0xfe
   3318c:	d251      	bcs.n	33232 <__addsf3+0x136>
   3318e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   33192:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   33196:	bf08      	it	eq
   33198:	f020 0001 	biceq.w	r0, r0, #1
   3319c:	ea40 0003 	orr.w	r0, r0, r3
   331a0:	4770      	bx	lr
   331a2:	0049      	lsls	r1, r1, #1
   331a4:	eb40 0000 	adc.w	r0, r0, r0
   331a8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   331ac:	f1a2 0201 	sub.w	r2, r2, #1
   331b0:	d1ed      	bne.n	3318e <__addsf3+0x92>
   331b2:	fab0 fc80 	clz	ip, r0
   331b6:	f1ac 0c08 	sub.w	ip, ip, #8
   331ba:	ebb2 020c 	subs.w	r2, r2, ip
   331be:	fa00 f00c 	lsl.w	r0, r0, ip
   331c2:	bfaa      	itet	ge
   331c4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   331c8:	4252      	neglt	r2, r2
   331ca:	4318      	orrge	r0, r3
   331cc:	bfbc      	itt	lt
   331ce:	40d0      	lsrlt	r0, r2
   331d0:	4318      	orrlt	r0, r3
   331d2:	4770      	bx	lr
   331d4:	f092 0f00 	teq	r2, #0
   331d8:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   331dc:	bf06      	itte	eq
   331de:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   331e2:	3201      	addeq	r2, #1
   331e4:	3b01      	subne	r3, #1
   331e6:	e7b5      	b.n	33154 <__addsf3+0x58>
   331e8:	ea4f 0341 	mov.w	r3, r1, lsl #1
   331ec:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   331f0:	bf18      	it	ne
   331f2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   331f6:	d021      	beq.n	3323c <__addsf3+0x140>
   331f8:	ea92 0f03 	teq	r2, r3
   331fc:	d004      	beq.n	33208 <__addsf3+0x10c>
   331fe:	f092 0f00 	teq	r2, #0
   33202:	bf08      	it	eq
   33204:	4608      	moveq	r0, r1
   33206:	4770      	bx	lr
   33208:	ea90 0f01 	teq	r0, r1
   3320c:	bf1c      	itt	ne
   3320e:	2000      	movne	r0, #0
   33210:	4770      	bxne	lr
   33212:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   33216:	d104      	bne.n	33222 <__addsf3+0x126>
   33218:	0040      	lsls	r0, r0, #1
   3321a:	bf28      	it	cs
   3321c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   33220:	4770      	bx	lr
   33222:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   33226:	bf3c      	itt	cc
   33228:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   3322c:	4770      	bxcc	lr
   3322e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   33232:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   33236:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   3323a:	4770      	bx	lr
   3323c:	ea7f 6222 	mvns.w	r2, r2, asr #24
   33240:	bf16      	itet	ne
   33242:	4608      	movne	r0, r1
   33244:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   33248:	4601      	movne	r1, r0
   3324a:	0242      	lsls	r2, r0, #9
   3324c:	bf06      	itte	eq
   3324e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   33252:	ea90 0f01 	teqeq	r0, r1
   33256:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   3325a:	4770      	bx	lr

0003325c <__aeabi_ui2f>:
   3325c:	f04f 0300 	mov.w	r3, #0
   33260:	e004      	b.n	3326c <__aeabi_i2f+0x8>
   33262:	bf00      	nop

00033264 <__aeabi_i2f>:
   33264:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   33268:	bf48      	it	mi
   3326a:	4240      	negmi	r0, r0
   3326c:	ea5f 0c00 	movs.w	ip, r0
   33270:	bf08      	it	eq
   33272:	4770      	bxeq	lr
   33274:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   33278:	4601      	mov	r1, r0
   3327a:	f04f 0000 	mov.w	r0, #0
   3327e:	e01c      	b.n	332ba <__aeabi_l2f+0x2a>

00033280 <__aeabi_ul2f>:
   33280:	ea50 0201 	orrs.w	r2, r0, r1
   33284:	bf08      	it	eq
   33286:	4770      	bxeq	lr
   33288:	f04f 0300 	mov.w	r3, #0
   3328c:	e00a      	b.n	332a4 <__aeabi_l2f+0x14>
   3328e:	bf00      	nop

00033290 <__aeabi_l2f>:
   33290:	ea50 0201 	orrs.w	r2, r0, r1
   33294:	bf08      	it	eq
   33296:	4770      	bxeq	lr
   33298:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   3329c:	d502      	bpl.n	332a4 <__aeabi_l2f+0x14>
   3329e:	4240      	negs	r0, r0
   332a0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   332a4:	ea5f 0c01 	movs.w	ip, r1
   332a8:	bf02      	ittt	eq
   332aa:	4684      	moveq	ip, r0
   332ac:	4601      	moveq	r1, r0
   332ae:	2000      	moveq	r0, #0
   332b0:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   332b4:	bf08      	it	eq
   332b6:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   332ba:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   332be:	fabc f28c 	clz	r2, ip
   332c2:	3a08      	subs	r2, #8
   332c4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   332c8:	db10      	blt.n	332ec <__aeabi_l2f+0x5c>
   332ca:	fa01 fc02 	lsl.w	ip, r1, r2
   332ce:	4463      	add	r3, ip
   332d0:	fa00 fc02 	lsl.w	ip, r0, r2
   332d4:	f1c2 0220 	rsb	r2, r2, #32
   332d8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   332dc:	fa20 f202 	lsr.w	r2, r0, r2
   332e0:	eb43 0002 	adc.w	r0, r3, r2
   332e4:	bf08      	it	eq
   332e6:	f020 0001 	biceq.w	r0, r0, #1
   332ea:	4770      	bx	lr
   332ec:	f102 0220 	add.w	r2, r2, #32
   332f0:	fa01 fc02 	lsl.w	ip, r1, r2
   332f4:	f1c2 0220 	rsb	r2, r2, #32
   332f8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   332fc:	fa21 f202 	lsr.w	r2, r1, r2
   33300:	eb43 0002 	adc.w	r0, r3, r2
   33304:	bf08      	it	eq
   33306:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   3330a:	4770      	bx	lr

0003330c <__aeabi_uldivmod>:
   3330c:	b953      	cbnz	r3, 33324 <__aeabi_uldivmod+0x18>
   3330e:	b94a      	cbnz	r2, 33324 <__aeabi_uldivmod+0x18>
   33310:	2900      	cmp	r1, #0
   33312:	bf08      	it	eq
   33314:	2800      	cmpeq	r0, #0
   33316:	bf1c      	itt	ne
   33318:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   3331c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   33320:	f000 b972 	b.w	33608 <__aeabi_idiv0>
   33324:	f1ad 0c08 	sub.w	ip, sp, #8
   33328:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   3332c:	f000 f806 	bl	3333c <__udivmoddi4>
   33330:	f8dd e004 	ldr.w	lr, [sp, #4]
   33334:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   33338:	b004      	add	sp, #16
   3333a:	4770      	bx	lr

0003333c <__udivmoddi4>:
   3333c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   33340:	9e08      	ldr	r6, [sp, #32]
   33342:	4604      	mov	r4, r0
   33344:	4688      	mov	r8, r1
   33346:	2b00      	cmp	r3, #0
   33348:	d14b      	bne.n	333e2 <__udivmoddi4+0xa6>
   3334a:	428a      	cmp	r2, r1
   3334c:	4615      	mov	r5, r2
   3334e:	d967      	bls.n	33420 <__udivmoddi4+0xe4>
   33350:	fab2 f282 	clz	r2, r2
   33354:	b14a      	cbz	r2, 3336a <__udivmoddi4+0x2e>
   33356:	f1c2 0720 	rsb	r7, r2, #32
   3335a:	fa01 f302 	lsl.w	r3, r1, r2
   3335e:	fa20 f707 	lsr.w	r7, r0, r7
   33362:	4095      	lsls	r5, r2
   33364:	ea47 0803 	orr.w	r8, r7, r3
   33368:	4094      	lsls	r4, r2
   3336a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   3336e:	0c23      	lsrs	r3, r4, #16
   33370:	fbb8 f7fe 	udiv	r7, r8, lr
   33374:	fa1f fc85 	uxth.w	ip, r5
   33378:	fb0e 8817 	mls	r8, lr, r7, r8
   3337c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   33380:	fb07 f10c 	mul.w	r1, r7, ip
   33384:	4299      	cmp	r1, r3
   33386:	d909      	bls.n	3339c <__udivmoddi4+0x60>
   33388:	18eb      	adds	r3, r5, r3
   3338a:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   3338e:	f080 811b 	bcs.w	335c8 <__udivmoddi4+0x28c>
   33392:	4299      	cmp	r1, r3
   33394:	f240 8118 	bls.w	335c8 <__udivmoddi4+0x28c>
   33398:	3f02      	subs	r7, #2
   3339a:	442b      	add	r3, r5
   3339c:	1a5b      	subs	r3, r3, r1
   3339e:	b2a4      	uxth	r4, r4
   333a0:	fbb3 f0fe 	udiv	r0, r3, lr
   333a4:	fb0e 3310 	mls	r3, lr, r0, r3
   333a8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   333ac:	fb00 fc0c 	mul.w	ip, r0, ip
   333b0:	45a4      	cmp	ip, r4
   333b2:	d909      	bls.n	333c8 <__udivmoddi4+0x8c>
   333b4:	192c      	adds	r4, r5, r4
   333b6:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   333ba:	f080 8107 	bcs.w	335cc <__udivmoddi4+0x290>
   333be:	45a4      	cmp	ip, r4
   333c0:	f240 8104 	bls.w	335cc <__udivmoddi4+0x290>
   333c4:	3802      	subs	r0, #2
   333c6:	442c      	add	r4, r5
   333c8:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   333cc:	eba4 040c 	sub.w	r4, r4, ip
   333d0:	2700      	movs	r7, #0
   333d2:	b11e      	cbz	r6, 333dc <__udivmoddi4+0xa0>
   333d4:	40d4      	lsrs	r4, r2
   333d6:	2300      	movs	r3, #0
   333d8:	e9c6 4300 	strd	r4, r3, [r6]
   333dc:	4639      	mov	r1, r7
   333de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   333e2:	428b      	cmp	r3, r1
   333e4:	d909      	bls.n	333fa <__udivmoddi4+0xbe>
   333e6:	2e00      	cmp	r6, #0
   333e8:	f000 80eb 	beq.w	335c2 <__udivmoddi4+0x286>
   333ec:	2700      	movs	r7, #0
   333ee:	e9c6 0100 	strd	r0, r1, [r6]
   333f2:	4638      	mov	r0, r7
   333f4:	4639      	mov	r1, r7
   333f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   333fa:	fab3 f783 	clz	r7, r3
   333fe:	2f00      	cmp	r7, #0
   33400:	d147      	bne.n	33492 <__udivmoddi4+0x156>
   33402:	428b      	cmp	r3, r1
   33404:	d302      	bcc.n	3340c <__udivmoddi4+0xd0>
   33406:	4282      	cmp	r2, r0
   33408:	f200 80fa 	bhi.w	33600 <__udivmoddi4+0x2c4>
   3340c:	1a84      	subs	r4, r0, r2
   3340e:	eb61 0303 	sbc.w	r3, r1, r3
   33412:	2001      	movs	r0, #1
   33414:	4698      	mov	r8, r3
   33416:	2e00      	cmp	r6, #0
   33418:	d0e0      	beq.n	333dc <__udivmoddi4+0xa0>
   3341a:	e9c6 4800 	strd	r4, r8, [r6]
   3341e:	e7dd      	b.n	333dc <__udivmoddi4+0xa0>
   33420:	b902      	cbnz	r2, 33424 <__udivmoddi4+0xe8>
   33422:	deff      	udf	#255	; 0xff
   33424:	fab2 f282 	clz	r2, r2
   33428:	2a00      	cmp	r2, #0
   3342a:	f040 808f 	bne.w	3354c <__udivmoddi4+0x210>
   3342e:	1b49      	subs	r1, r1, r5
   33430:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   33434:	fa1f f885 	uxth.w	r8, r5
   33438:	2701      	movs	r7, #1
   3343a:	fbb1 fcfe 	udiv	ip, r1, lr
   3343e:	0c23      	lsrs	r3, r4, #16
   33440:	fb0e 111c 	mls	r1, lr, ip, r1
   33444:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   33448:	fb08 f10c 	mul.w	r1, r8, ip
   3344c:	4299      	cmp	r1, r3
   3344e:	d907      	bls.n	33460 <__udivmoddi4+0x124>
   33450:	18eb      	adds	r3, r5, r3
   33452:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   33456:	d202      	bcs.n	3345e <__udivmoddi4+0x122>
   33458:	4299      	cmp	r1, r3
   3345a:	f200 80cd 	bhi.w	335f8 <__udivmoddi4+0x2bc>
   3345e:	4684      	mov	ip, r0
   33460:	1a59      	subs	r1, r3, r1
   33462:	b2a3      	uxth	r3, r4
   33464:	fbb1 f0fe 	udiv	r0, r1, lr
   33468:	fb0e 1410 	mls	r4, lr, r0, r1
   3346c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   33470:	fb08 f800 	mul.w	r8, r8, r0
   33474:	45a0      	cmp	r8, r4
   33476:	d907      	bls.n	33488 <__udivmoddi4+0x14c>
   33478:	192c      	adds	r4, r5, r4
   3347a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   3347e:	d202      	bcs.n	33486 <__udivmoddi4+0x14a>
   33480:	45a0      	cmp	r8, r4
   33482:	f200 80b6 	bhi.w	335f2 <__udivmoddi4+0x2b6>
   33486:	4618      	mov	r0, r3
   33488:	eba4 0408 	sub.w	r4, r4, r8
   3348c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   33490:	e79f      	b.n	333d2 <__udivmoddi4+0x96>
   33492:	f1c7 0c20 	rsb	ip, r7, #32
   33496:	40bb      	lsls	r3, r7
   33498:	fa22 fe0c 	lsr.w	lr, r2, ip
   3349c:	ea4e 0e03 	orr.w	lr, lr, r3
   334a0:	fa01 f407 	lsl.w	r4, r1, r7
   334a4:	fa20 f50c 	lsr.w	r5, r0, ip
   334a8:	fa21 f30c 	lsr.w	r3, r1, ip
   334ac:	ea4f 481e 	mov.w	r8, lr, lsr #16
   334b0:	4325      	orrs	r5, r4
   334b2:	fbb3 f9f8 	udiv	r9, r3, r8
   334b6:	0c2c      	lsrs	r4, r5, #16
   334b8:	fb08 3319 	mls	r3, r8, r9, r3
   334bc:	fa1f fa8e 	uxth.w	sl, lr
   334c0:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   334c4:	fb09 f40a 	mul.w	r4, r9, sl
   334c8:	429c      	cmp	r4, r3
   334ca:	fa02 f207 	lsl.w	r2, r2, r7
   334ce:	fa00 f107 	lsl.w	r1, r0, r7
   334d2:	d90b      	bls.n	334ec <__udivmoddi4+0x1b0>
   334d4:	eb1e 0303 	adds.w	r3, lr, r3
   334d8:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   334dc:	f080 8087 	bcs.w	335ee <__udivmoddi4+0x2b2>
   334e0:	429c      	cmp	r4, r3
   334e2:	f240 8084 	bls.w	335ee <__udivmoddi4+0x2b2>
   334e6:	f1a9 0902 	sub.w	r9, r9, #2
   334ea:	4473      	add	r3, lr
   334ec:	1b1b      	subs	r3, r3, r4
   334ee:	b2ad      	uxth	r5, r5
   334f0:	fbb3 f0f8 	udiv	r0, r3, r8
   334f4:	fb08 3310 	mls	r3, r8, r0, r3
   334f8:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   334fc:	fb00 fa0a 	mul.w	sl, r0, sl
   33500:	45a2      	cmp	sl, r4
   33502:	d908      	bls.n	33516 <__udivmoddi4+0x1da>
   33504:	eb1e 0404 	adds.w	r4, lr, r4
   33508:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   3350c:	d26b      	bcs.n	335e6 <__udivmoddi4+0x2aa>
   3350e:	45a2      	cmp	sl, r4
   33510:	d969      	bls.n	335e6 <__udivmoddi4+0x2aa>
   33512:	3802      	subs	r0, #2
   33514:	4474      	add	r4, lr
   33516:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   3351a:	fba0 8902 	umull	r8, r9, r0, r2
   3351e:	eba4 040a 	sub.w	r4, r4, sl
   33522:	454c      	cmp	r4, r9
   33524:	46c2      	mov	sl, r8
   33526:	464b      	mov	r3, r9
   33528:	d354      	bcc.n	335d4 <__udivmoddi4+0x298>
   3352a:	d051      	beq.n	335d0 <__udivmoddi4+0x294>
   3352c:	2e00      	cmp	r6, #0
   3352e:	d069      	beq.n	33604 <__udivmoddi4+0x2c8>
   33530:	ebb1 050a 	subs.w	r5, r1, sl
   33534:	eb64 0403 	sbc.w	r4, r4, r3
   33538:	fa04 fc0c 	lsl.w	ip, r4, ip
   3353c:	40fd      	lsrs	r5, r7
   3353e:	40fc      	lsrs	r4, r7
   33540:	ea4c 0505 	orr.w	r5, ip, r5
   33544:	e9c6 5400 	strd	r5, r4, [r6]
   33548:	2700      	movs	r7, #0
   3354a:	e747      	b.n	333dc <__udivmoddi4+0xa0>
   3354c:	f1c2 0320 	rsb	r3, r2, #32
   33550:	fa20 f703 	lsr.w	r7, r0, r3
   33554:	4095      	lsls	r5, r2
   33556:	fa01 f002 	lsl.w	r0, r1, r2
   3355a:	fa21 f303 	lsr.w	r3, r1, r3
   3355e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   33562:	4338      	orrs	r0, r7
   33564:	0c01      	lsrs	r1, r0, #16
   33566:	fbb3 f7fe 	udiv	r7, r3, lr
   3356a:	fa1f f885 	uxth.w	r8, r5
   3356e:	fb0e 3317 	mls	r3, lr, r7, r3
   33572:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   33576:	fb07 f308 	mul.w	r3, r7, r8
   3357a:	428b      	cmp	r3, r1
   3357c:	fa04 f402 	lsl.w	r4, r4, r2
   33580:	d907      	bls.n	33592 <__udivmoddi4+0x256>
   33582:	1869      	adds	r1, r5, r1
   33584:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   33588:	d22f      	bcs.n	335ea <__udivmoddi4+0x2ae>
   3358a:	428b      	cmp	r3, r1
   3358c:	d92d      	bls.n	335ea <__udivmoddi4+0x2ae>
   3358e:	3f02      	subs	r7, #2
   33590:	4429      	add	r1, r5
   33592:	1acb      	subs	r3, r1, r3
   33594:	b281      	uxth	r1, r0
   33596:	fbb3 f0fe 	udiv	r0, r3, lr
   3359a:	fb0e 3310 	mls	r3, lr, r0, r3
   3359e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   335a2:	fb00 f308 	mul.w	r3, r0, r8
   335a6:	428b      	cmp	r3, r1
   335a8:	d907      	bls.n	335ba <__udivmoddi4+0x27e>
   335aa:	1869      	adds	r1, r5, r1
   335ac:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   335b0:	d217      	bcs.n	335e2 <__udivmoddi4+0x2a6>
   335b2:	428b      	cmp	r3, r1
   335b4:	d915      	bls.n	335e2 <__udivmoddi4+0x2a6>
   335b6:	3802      	subs	r0, #2
   335b8:	4429      	add	r1, r5
   335ba:	1ac9      	subs	r1, r1, r3
   335bc:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   335c0:	e73b      	b.n	3343a <__udivmoddi4+0xfe>
   335c2:	4637      	mov	r7, r6
   335c4:	4630      	mov	r0, r6
   335c6:	e709      	b.n	333dc <__udivmoddi4+0xa0>
   335c8:	4607      	mov	r7, r0
   335ca:	e6e7      	b.n	3339c <__udivmoddi4+0x60>
   335cc:	4618      	mov	r0, r3
   335ce:	e6fb      	b.n	333c8 <__udivmoddi4+0x8c>
   335d0:	4541      	cmp	r1, r8
   335d2:	d2ab      	bcs.n	3352c <__udivmoddi4+0x1f0>
   335d4:	ebb8 0a02 	subs.w	sl, r8, r2
   335d8:	eb69 020e 	sbc.w	r2, r9, lr
   335dc:	3801      	subs	r0, #1
   335de:	4613      	mov	r3, r2
   335e0:	e7a4      	b.n	3352c <__udivmoddi4+0x1f0>
   335e2:	4660      	mov	r0, ip
   335e4:	e7e9      	b.n	335ba <__udivmoddi4+0x27e>
   335e6:	4618      	mov	r0, r3
   335e8:	e795      	b.n	33516 <__udivmoddi4+0x1da>
   335ea:	4667      	mov	r7, ip
   335ec:	e7d1      	b.n	33592 <__udivmoddi4+0x256>
   335ee:	4681      	mov	r9, r0
   335f0:	e77c      	b.n	334ec <__udivmoddi4+0x1b0>
   335f2:	3802      	subs	r0, #2
   335f4:	442c      	add	r4, r5
   335f6:	e747      	b.n	33488 <__udivmoddi4+0x14c>
   335f8:	f1ac 0c02 	sub.w	ip, ip, #2
   335fc:	442b      	add	r3, r5
   335fe:	e72f      	b.n	33460 <__udivmoddi4+0x124>
   33600:	4638      	mov	r0, r7
   33602:	e708      	b.n	33416 <__udivmoddi4+0xda>
   33604:	4637      	mov	r7, r6
   33606:	e6e9      	b.n	333dc <__udivmoddi4+0xa0>

00033608 <__aeabi_idiv0>:
   33608:	4770      	bx	lr
   3360a:	bf00      	nop

Disassembly of section .fini:

0003360c <_fini>:
   3360c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3360e:	bf00      	nop
   33610:	bcf8      	pop	{r3, r4, r5, r6, r7}
   33612:	bc08      	pop	{r3}
   33614:	469e      	mov	lr, r3
   33616:	4770      	bx	lr
