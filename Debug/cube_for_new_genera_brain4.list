
cube_for_new_genera_brain4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .init         0000000c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00027e8c  00008010  00008010  00008010  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .fini         0000000c  0002fe9c  0002fe9c  0002fe9c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000229d8  0002fea8  0002fea8  0002fea8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.exidx    00000008  00052880  00052880  00052880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .eh_frame     00000004  00052888  00052888  00052888  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .init_array   00000004  0006288c  0006288c  0005288c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  00062890  00062890  00052890  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000499  00062894  00062894  00052894  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .RAM_D2       000015e8  00062d40  00062d40  00052d40  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 10 .RAM_D1       0007eb58  00064340  00064340  00054340  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 11 .SDRAM        02000000  000e2ea0  000e2ea0  000d2ea0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 12 .RAM_D3       00000201  020e2ea0  020e2ea0  020d2ea0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00019030  020e30a8  020e30a8  020d30a1  2**3
                  ALLOC
 14 .comment      0000007b  00000000  00000000  020d30a1  2**0
                  CONTENTS, READONLY
 15 .debug_aranges 00004478  00000000  00000000  020d311c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_info   000c79ba  00000000  00000000  020d7594  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_abbrev 00010f62  00000000  00000000  0219ef4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0005338f  00000000  00000000  021afeb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  000104e8  00000000  00000000  02203240  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    0018d753  00000000  00000000  02213728  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    000684a8  00000000  00000000  023a0e7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_ranges 000107b0  00000000  00000000  02409323  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_macro  000495e5  00000000  00000000  02419ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .ARM.attributes 0000002e  00000000  00000000  024630b8  2**0
                  CONTENTS, READONLY

Disassembly of section .init:

00008000 <_init>:
    8000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8002:	bf00      	nop
    8004:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8006:	bc08      	pop	{r3}
    8008:	469e      	mov	lr, r3
    800a:	4770      	bx	lr

Disassembly of section .text:

00008010 <exit>:
    8010:	b508      	push	{r3, lr}
    8012:	4b07      	ldr	r3, [pc, #28]	; (8030 <exit+0x20>)
    8014:	4604      	mov	r4, r0
    8016:	b113      	cbz	r3, 801e <exit+0xe>
    8018:	2100      	movs	r1, #0
    801a:	f3af 8000 	nop.w
    801e:	4b05      	ldr	r3, [pc, #20]	; (8034 <exit+0x24>)
    8020:	6818      	ldr	r0, [r3, #0]
    8022:	6a83      	ldr	r3, [r0, #40]	; 0x28
    8024:	b103      	cbz	r3, 8028 <exit+0x18>
    8026:	4798      	blx	r3
    8028:	4620      	mov	r0, r4
    802a:	f019 fd73 	bl	21b14 <_exit>
    802e:	bf00      	nop
    8030:	00000000 	.word	0x00000000
    8034:	00051f1c 	.word	0x00051f1c

00008038 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
    8038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* USER CODE BEGIN 1 */
  MPU_Conf();
    803a:	f011 f9c1 	bl	193c0 <MPU_Conf>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    803e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8042:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8046:	4c7e      	ldr	r4, [pc, #504]	; (8240 <main+0x208>)
    8048:	2500      	movs	r5, #0
    804a:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    804e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8052:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
    8056:	6963      	ldr	r3, [r4, #20]
    8058:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    805c:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    805e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8062:	f3bf 8f6f 	isb	sy

  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
    8066:	f011 f869 	bl	1913c <SCB_EnableDCache>

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
    806a:	f000 f991 	bl	8390 <HAL_Init>
  __ASM volatile ("dsb 0xF":::"memory");
    806e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8072:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_DisableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
    8076:	6963      	ldr	r3, [r4, #20]
    8078:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    807c:	6163      	str	r3, [r4, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    807e:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    8082:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    8086:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
    808a:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    808e:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
    8092:	6963      	ldr	r3, [r4, #20]
    8094:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    8098:	6163      	str	r3, [r4, #20]
    809a:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
    809e:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
                                            /* clean & invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80a2:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
    80a6:	f3c3 06c9 	ubfx	r6, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    80aa:	f3c3 334e 	ubfx	r3, r3, #13, #15
    80ae:	07b7      	lsls	r7, r6, #30
    80b0:	0158      	lsls	r0, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80b2:	ea00 050c 	and.w	r5, r0, ip
    80b6:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
    80b8:	4632      	mov	r2, r6
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80ba:	ea41 0305 	orr.w	r3, r1, r5
                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
    80be:	3a01      	subs	r2, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
    80c0:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
    80c4:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
      } while (ways-- != 0U);
    80c8:	1c53      	adds	r3, r2, #1
    80ca:	d1f6      	bne.n	80ba <main+0x82>
    80cc:	3820      	subs	r0, #32
    } while(sets-- != 0U);
    80ce:	f110 0f20 	cmn.w	r0, #32
    80d2:	d1ee      	bne.n	80b2 <main+0x7a>
    80d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    80d8:	f3bf 8f6f 	isb	sy
  /* Enable D-Cache---------------------------------------------------------*/
  SCB_DisableDCache();
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
    80dc:	f011 f85e 	bl	1919c <SystemClock_Config>


  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
    80e0:	f010 fdb4 	bl	18c4c <MX_GPIO_Init>
  MX_BDMA_Init();
    80e4:	f00f f90a 	bl	172fc <MX_BDMA_Init>
  MX_DMA_Init();
    80e8:	f00f fa1a 	bl	17520 <MX_DMA_Init>
  MX_FMC_Init();
    80ec:	f00f fdda 	bl	17ca4 <MX_FMC_Init>
  MX_ADC1_Init();
    80f0:	f00e fb52 	bl	16798 <MX_ADC1_Init>
  MX_I2C2_Init();
    80f4:	f010 fed6 	bl	18ea4 <MX_I2C2_Init>
  MX_SDMMC1_SD_Init();
    80f8:	f012 f894 	bl	1a224 <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
    80fc:	f00f fdb8 	bl	17c70 <MX_FATFS_Init>
  MX_SAI1_Init();
    8100:	f011 ff08 	bl	19f14 <MX_SAI1_Init>
  MX_RNG_Init();
    8104:	f011 fed8 	bl	19eb8 <MX_RNG_Init>
  MX_I2C4_Init();
    8108:	f010 fefa 	bl	18f00 <MX_I2C4_Init>
  MX_USB_HOST_Init();
    810c:	f01b fb1a 	bl	23744 <MX_USB_HOST_Init>
  MX_TIM3_Init();
    8110:	f019 fd06 	bl	21b20 <MX_TIM3_Init>
  MX_TIM4_Init();
    8114:	f019 fd82 	bl	21c1c <MX_TIM4_Init>
  __ASM volatile ("dsb 0xF":::"memory");
    8118:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    811c:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
    8120:	2500      	movs	r5, #0
    8122:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
    8126:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    812a:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
    812e:	6963      	ldr	r3, [r4, #20]
    8130:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    8134:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    8136:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    813a:	f3bf 8f6f 	isb	sy
  // otherwise turning on -o3 optimization causes unreliable behavior where it's not set up correctly and never reaches the USB interrupt for connection
  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
    813e:	f010 fffd 	bl	1913c <SCB_EnableDCache>


  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
    8142:	2104      	movs	r1, #4
    8144:	483f      	ldr	r0, [pc, #252]	; (8244 <main+0x20c>)
    8146:	f00a fadf 	bl	12708 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
    814a:	4629      	mov	r1, r5
    814c:	483e      	ldr	r0, [pc, #248]	; (8248 <main+0x210>)
    814e:	f00a fadb 	bl	12708 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
    8152:	2104      	movs	r1, #4
    8154:	483c      	ldr	r0, [pc, #240]	; (8248 <main+0x210>)
    8156:	f00a fad7 	bl	12708 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);
    815a:	2108      	movs	r1, #8
    815c:	483a      	ldr	r0, [pc, #232]	; (8248 <main+0x210>)
    815e:	f00a fad3 	bl	12708 <HAL_TIM_PWM_Start>

  //HAL_Delay(1);
  // Emulated EEPROM Init
  HAL_FLASH_Unlock();
    8162:	f003 fb1f 	bl	b7a4 <HAL_FLASH_Unlock>
  if( EE_Init() != EE_OK)
    8166:	f00f fa6f 	bl	17648 <EE_Init>
    816a:	4605      	mov	r5, r0
    816c:	b100      	cbz	r0, 8170 <main+0x138>
    816e:	e7fe      	b.n	816e <main+0x136>
  {
    Error_Handler();
  }
  if((EE_ReadVariable(VirtAddVarTab[0],  &VarDataTab)) != HAL_OK) // read what the preset was before last power-off
    8170:	4c36      	ldr	r4, [pc, #216]	; (824c <main+0x214>)
    8172:	4937      	ldr	r1, [pc, #220]	; (8250 <main+0x218>)
    8174:	8820      	ldrh	r0, [r4, #0]
    8176:	f00f fc3f 	bl	179f8 <EE_ReadVariable>
    817a:	2800      	cmp	r0, #0
    817c:	d13e      	bne.n	81fc <main+0x1c4>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
	{
		Error_Handler();
	}
  }
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    817e:	4b34      	ldr	r3, [pc, #208]	; (8250 <main+0x218>)
*/
/* helper function to initialize measuring unit (cycle counter) */
static void CycleCounterInit( void )
{
  /* Enable TRC */
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    8180:	4a34      	ldr	r2, [pc, #208]	; (8254 <main+0x21c>)
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    8182:	881b      	ldrh	r3, [r3, #0]
    8184:	4834      	ldr	r0, [pc, #208]	; (8258 <main+0x220>)
    8186:	2b12      	cmp	r3, #18

  /* Unlock DWT registers */
  if ((*(uint32_t*)0xE0001FB4) & 1)
    8188:	4934      	ldr	r1, [pc, #208]	; (825c <main+0x224>)
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
    818a:	bf28      	it	cs
    818c:	2300      	movcs	r3, #0
    818e:	7003      	strb	r3, [r0, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    8190:	68d3      	ldr	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
    8192:	6809      	ldr	r1, [r1, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    8194:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    8198:	60d3      	str	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
    819a:	07cb      	lsls	r3, r1, #31
    819c:	d502      	bpl.n	81a4 <main+0x16c>
    *(uint32_t*)0xE0001FB0 = 0xC5ACCE55;
    819e:	4b30      	ldr	r3, [pc, #192]	; (8260 <main+0x228>)
    81a0:	4a30      	ldr	r2, [pc, #192]	; (8264 <main+0x22c>)
    81a2:	601a      	str	r2, [r3, #0]

  /* clear the cycle counter */
  DWT->CYCCNT = 0;
    81a4:	4830      	ldr	r0, [pc, #192]	; (8268 <main+0x230>)
    81a6:	2500      	movs	r5, #0

  /* start the cycle counter */
  DWT->CTRL = 0x40000001;
    81a8:	4c30      	ldr	r4, [pc, #192]	; (826c <main+0x234>)
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81aa:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  DWT->CYCCNT = 0;
    81ae:	6045      	str	r5, [r0, #4]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81b0:	462a      	mov	r2, r5
  DWT->CTRL = 0x40000001;
    81b2:	6004      	str	r4, [r0, #0]

  for (int i = 0; i < 4; i++)
  {
	  cycleCountAverages[i][0] = 0.0f;
    81b4:	2400      	movs	r4, #0
    81b6:	4b2e      	ldr	r3, [pc, #184]	; (8270 <main+0x238>)
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81b8:	482e      	ldr	r0, [pc, #184]	; (8274 <main+0x23c>)
	  cycleCountAverages[i][0] = 0.0f;
    81ba:	601c      	str	r4, [r3, #0]
	  cycleCountAverages[i][1] = 0.0f;
    81bc:	605c      	str	r4, [r3, #4]
	  cycleCountAverages[i][2] = 0.0f;
    81be:	609c      	str	r4, [r3, #8]
	  cycleCountAverages[i][0] = 0.0f;
    81c0:	60dc      	str	r4, [r3, #12]
	  cycleCountAverages[i][1] = 0.0f;
    81c2:	611c      	str	r4, [r3, #16]
	  cycleCountAverages[i][2] = 0.0f;
    81c4:	615c      	str	r4, [r3, #20]
	  cycleCountAverages[i][0] = 0.0f;
    81c6:	619c      	str	r4, [r3, #24]
	  cycleCountAverages[i][1] = 0.0f;
    81c8:	61dc      	str	r4, [r3, #28]
	  cycleCountAverages[i][2] = 0.0f;
    81ca:	621c      	str	r4, [r3, #32]
	  cycleCountAverages[i][0] = 0.0f;
    81cc:	625c      	str	r4, [r3, #36]	; 0x24
	  cycleCountAverages[i][1] = 0.0f;
    81ce:	629c      	str	r4, [r3, #40]	; 0x28
	  cycleCountAverages[i][2] = 0.0f;
    81d0:	62dc      	str	r4, [r3, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
    81d2:	f004 f82f 	bl	c234 <HAL_GPIO_WritePin>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
    81d6:	eef1 3a10 	vmrs	r3, fpscr
  tempFPURegisterVal |= (1<<24); // set the FTZ (flush-to-zero) bit in the FPU control register  // this makes checking for denormals not necessary as they are automatically set to zero by the hardware
    81da:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    81de:	eee1 3a10 	vmsr	fpscr, r3
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
    81e2:	f240 72ff 	movw	r2, #2047	; 0x7ff
    81e6:	4629      	mov	r1, r5
    81e8:	4823      	ldr	r0, [pc, #140]	; (8278 <main+0x240>)
    81ea:	f001 fa9b 	bl	9724 <HAL_ADCEx_Calibration_Start>
  if (HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_values, NUM_ADC_CHANNELS) != HAL_OK)
    81ee:	2206      	movs	r2, #6
    81f0:	4922      	ldr	r1, [pc, #136]	; (827c <main+0x244>)
    81f2:	4821      	ldr	r0, [pc, #132]	; (8278 <main+0x240>)
    81f4:	f000 f936 	bl	8464 <HAL_ADC_Start_DMA>
    81f8:	b138      	cbz	r0, 820a <main+0x1d2>
    81fa:	e7fe      	b.n	81fa <main+0x1c2>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
    81fc:	4629      	mov	r1, r5
    81fe:	8820      	ldrh	r0, [r4, #0]
    8200:	f00f fc36 	bl	17a70 <EE_WriteVariable>
    8204:	2800      	cmp	r0, #0
    8206:	d0ba      	beq.n	817e <main+0x146>
    8208:	e7fe      	b.n	8208 <main+0x1d0>
    820a:	4c1d      	ldr	r4, [pc, #116]	; (8280 <main+0x248>)
  HAL_Delay(10);
    820c:	200a      	movs	r0, #10
    820e:	f000 f8f7 	bl	8400 <HAL_Delay>
  OLED_init(&hi2c4);
    8212:	4620      	mov	r0, r4
    8214:	f011 fa70 	bl	196f8 <OLED_init>
  SDRAM_Initialization_sequence();
    8218:	f011 f860 	bl	192dc <SDRAM_Initialization_sequence>
  audioInit(&hi2c2, &hsai_BlockA1, &hsai_BlockB1);
    821c:	4a19      	ldr	r2, [pc, #100]	; (8284 <main+0x24c>)
    821e:	491a      	ldr	r1, [pc, #104]	; (8288 <main+0x250>)
    8220:	481a      	ldr	r0, [pc, #104]	; (828c <main+0x254>)
    8222:	f00e ff91 	bl	17148 <audioInit>
  OLED_writePreset();
    8226:	f011 f9ed 	bl	19604 <OLED_writePreset>
    MX_USB_HOST_Process();
    822a:	f01b fac1 	bl	237b0 <MX_USB_HOST_Process>
    OLED_process(); // process what to write to the screen but don't actually draw
    822e:	f011 fdd1 	bl	19dd4 <OLED_process>
 	if (hi2c4.State == HAL_I2C_STATE_READY)
    8232:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    8236:	2b20      	cmp	r3, #32
    8238:	d1f7      	bne.n	822a <main+0x1f2>
	  OLED_draw();
    823a:	f011 fba5 	bl	19988 <OLED_draw>
    823e:	e7f4      	b.n	822a <main+0x1f2>
    8240:	e000ed00 	.word	0xe000ed00
    8244:	020fb2b8 	.word	0x020fb2b8
    8248:	020fb278 	.word	0x020fb278
    824c:	000628ac 	.word	0x000628ac
    8250:	020e3110 	.word	0x020e3110
    8254:	e000edf0 	.word	0xe000edf0
    8258:	020e3259 	.word	0x020e3259
    825c:	e0001fb4 	.word	0xe0001fb4
    8260:	e0001fb0 	.word	0xe0001fb0
    8264:	c5acce55 	.word	0xc5acce55
    8268:	e0001000 	.word	0xe0001000
    826c:	40000001 	.word	0x40000001
    8270:	020f8168 	.word	0x020f8168
    8274:	58020800 	.word	0x58020800
    8278:	020e3314 	.word	0x020e3314
    827c:	00063dc0 	.word	0x00063dc0
    8280:	020f7c4c 	.word	0x020f7c4c
    8284:	020f82b0 	.word	0x020f82b0
    8288:	020f8438 	.word	0x020f8438
    828c:	020f7c98 	.word	0x020f7c98

00008290 <__do_global_dtors_aux>:
    8290:	b510      	push	{r4, lr}
    8292:	4c05      	ldr	r4, [pc, #20]	; (82a8 <__do_global_dtors_aux+0x18>)
    8294:	7823      	ldrb	r3, [r4, #0]
    8296:	b933      	cbnz	r3, 82a6 <__do_global_dtors_aux+0x16>
    8298:	4b04      	ldr	r3, [pc, #16]	; (82ac <__do_global_dtors_aux+0x1c>)
    829a:	b113      	cbz	r3, 82a2 <__do_global_dtors_aux+0x12>
    829c:	4804      	ldr	r0, [pc, #16]	; (82b0 <__do_global_dtors_aux+0x20>)
    829e:	f3af 8000 	nop.w
    82a2:	2301      	movs	r3, #1
    82a4:	7023      	strb	r3, [r4, #0]
    82a6:	bd10      	pop	{r4, pc}
    82a8:	020e30a8 	.word	0x020e30a8
    82ac:	00000000 	.word	0x00000000
    82b0:	00052888 	.word	0x00052888

000082b4 <frame_dummy>:
    82b4:	b508      	push	{r3, lr}
    82b6:	4b03      	ldr	r3, [pc, #12]	; (82c4 <frame_dummy+0x10>)
    82b8:	b11b      	cbz	r3, 82c2 <frame_dummy+0xe>
    82ba:	4903      	ldr	r1, [pc, #12]	; (82c8 <frame_dummy+0x14>)
    82bc:	4803      	ldr	r0, [pc, #12]	; (82cc <frame_dummy+0x18>)
    82be:	f3af 8000 	nop.w
    82c2:	bd08      	pop	{r3, pc}
    82c4:	00000000 	.word	0x00000000
    82c8:	020e30ac 	.word	0x020e30ac
    82cc:	00052888 	.word	0x00052888

000082d0 <_mainCRTStartup>:
    82d0:	4b15      	ldr	r3, [pc, #84]	; (8328 <_mainCRTStartup+0x58>)
    82d2:	2b00      	cmp	r3, #0
    82d4:	bf08      	it	eq
    82d6:	4b13      	ldreq	r3, [pc, #76]	; (8324 <_mainCRTStartup+0x54>)
    82d8:	469d      	mov	sp, r3
    82da:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
    82de:	2100      	movs	r1, #0
    82e0:	468b      	mov	fp, r1
    82e2:	460f      	mov	r7, r1
    82e4:	4813      	ldr	r0, [pc, #76]	; (8334 <_mainCRTStartup+0x64>)
    82e6:	4a14      	ldr	r2, [pc, #80]	; (8338 <_mainCRTStartup+0x68>)
    82e8:	1a12      	subs	r2, r2, r0
    82ea:	f024 fbaa 	bl	2ca42 <memset>
    82ee:	4b0f      	ldr	r3, [pc, #60]	; (832c <_mainCRTStartup+0x5c>)
    82f0:	2b00      	cmp	r3, #0
    82f2:	d000      	beq.n	82f6 <_mainCRTStartup+0x26>
    82f4:	4798      	blx	r3
    82f6:	4b0e      	ldr	r3, [pc, #56]	; (8330 <_mainCRTStartup+0x60>)
    82f8:	2b00      	cmp	r3, #0
    82fa:	d000      	beq.n	82fe <_mainCRTStartup+0x2e>
    82fc:	4798      	blx	r3
    82fe:	2000      	movs	r0, #0
    8300:	2100      	movs	r1, #0
    8302:	0004      	movs	r4, r0
    8304:	000d      	movs	r5, r1
    8306:	480d      	ldr	r0, [pc, #52]	; (833c <_mainCRTStartup+0x6c>)
    8308:	2800      	cmp	r0, #0
    830a:	d002      	beq.n	8312 <_mainCRTStartup+0x42>
    830c:	480c      	ldr	r0, [pc, #48]	; (8340 <_mainCRTStartup+0x70>)
    830e:	f3af 8000 	nop.w
    8312:	f024 fb4d 	bl	2c9b0 <__libc_init_array>
    8316:	0020      	movs	r0, r4
    8318:	0029      	movs	r1, r5
    831a:	f7ff fe8d 	bl	8038 <main>
    831e:	f7ff fe77 	bl	8010 <exit>
    8322:	bf00      	nop
    8324:	00080000 	.word	0x00080000
	...
    8334:	020e30a1 	.word	0x020e30a1
    8338:	020fc0d8 	.word	0x020fc0d8
	...

00008344 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
    8344:	4b0f      	ldr	r3, [pc, #60]	; (8384 <HAL_InitTick+0x40>)
    8346:	781b      	ldrb	r3, [r3, #0]
    8348:	b90b      	cbnz	r3, 834e <HAL_InitTick+0xa>
  {
    return HAL_ERROR;
    834a:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
    834c:	4770      	bx	lr
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
    834e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8352:	490d      	ldr	r1, [pc, #52]	; (8388 <HAL_InitTick+0x44>)
    8354:	fbb2 f3f3 	udiv	r3, r2, r3
{
    8358:	b510      	push	{r4, lr}
    835a:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
    835c:	6808      	ldr	r0, [r1, #0]
    835e:	fbb0 f0f3 	udiv	r0, r0, r3
    8362:	f001 fbab 	bl	9abc <HAL_SYSTICK_Config>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
    8366:	2c0f      	cmp	r4, #15
    8368:	d800      	bhi.n	836c <HAL_InitTick+0x28>
    836a:	b108      	cbz	r0, 8370 <HAL_InitTick+0x2c>
    return HAL_ERROR;
    836c:	2001      	movs	r0, #1
}
    836e:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    8370:	2200      	movs	r2, #0
    8372:	4621      	mov	r1, r4
    8374:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8378:	f001 fb2c 	bl	99d4 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
    837c:	4b03      	ldr	r3, [pc, #12]	; (838c <HAL_InitTick+0x48>)
    837e:	2000      	movs	r0, #0
    8380:	601c      	str	r4, [r3, #0]
}
    8382:	bd10      	pop	{r4, pc}
    8384:	00062894 	.word	0x00062894
    8388:	00062b44 	.word	0x00062b44
    838c:	00062898 	.word	0x00062898

00008390 <HAL_Init>:
{
    8390:	b530      	push	{r4, r5, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    8392:	2003      	movs	r0, #3
{
    8394:	b083      	sub	sp, #12
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    8396:	f001 fb01 	bl	999c <HAL_NVIC_SetPriorityGrouping>
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    839a:	4c12      	ldr	r4, [pc, #72]	; (83e4 <HAL_Init+0x54>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    839c:	f006 fa1e 	bl	e7dc <HAL_RCC_GetSysClockFreq>
    83a0:	4a11      	ldr	r2, [pc, #68]	; (83e8 <HAL_Init+0x58>)
    83a2:	4912      	ldr	r1, [pc, #72]	; (83ec <HAL_Init+0x5c>)
    83a4:	6993      	ldr	r3, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83a6:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83a8:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemCoreClock = common_system_clock;
    83ac:	4d10      	ldr	r5, [pc, #64]	; (83f0 <HAL_Init+0x60>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83ae:	f002 020f 	and.w	r2, r2, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83b2:	5ccb      	ldrb	r3, [r1, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83b4:	5c8a      	ldrb	r2, [r1, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83b6:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83ba:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    83be:	fa20 f303 	lsr.w	r3, r0, r3
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
    83c2:	2000      	movs	r0, #0
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83c4:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
    83c8:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    83ca:	6022      	str	r2, [r4, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
    83cc:	f7ff ffba 	bl	8344 <HAL_InitTick>
    83d0:	b110      	cbz	r0, 83d8 <HAL_Init+0x48>
    return HAL_ERROR;
    83d2:	2001      	movs	r0, #1
}
    83d4:	b003      	add	sp, #12
    83d6:	bd30      	pop	{r4, r5, pc}
    83d8:	9001      	str	r0, [sp, #4]
  HAL_MspInit();
    83da:	f019 fb89 	bl	21af0 <HAL_MspInit>
  return HAL_OK;
    83de:	9801      	ldr	r0, [sp, #4]
}
    83e0:	b003      	add	sp, #12
    83e2:	bd30      	pop	{r4, r5, pc}
    83e4:	00062b48 	.word	0x00062b48
    83e8:	58024400 	.word	0x58024400
    83ec:	00031054 	.word	0x00031054
    83f0:	00062b44 	.word	0x00062b44

000083f4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
    83f4:	4b01      	ldr	r3, [pc, #4]	; (83fc <HAL_GetTick+0x8>)
    83f6:	6818      	ldr	r0, [r3, #0]
}
    83f8:	4770      	bx	lr
    83fa:	bf00      	nop
    83fc:	020e3264 	.word	0x020e3264

00008400 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
    8400:	b538      	push	{r3, r4, r5, lr}
    8402:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
    8404:	f7ff fff6 	bl	83f4 <HAL_GetTick>
    8408:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
    840a:	1c63      	adds	r3, r4, #1
    840c:	d002      	beq.n	8414 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
    840e:	4b04      	ldr	r3, [pc, #16]	; (8420 <HAL_Delay+0x20>)
    8410:	781b      	ldrb	r3, [r3, #0]
    8412:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
    8414:	f7ff ffee 	bl	83f4 <HAL_GetTick>
    8418:	1b40      	subs	r0, r0, r5
    841a:	42a0      	cmp	r0, r4
    841c:	d3fa      	bcc.n	8414 <HAL_Delay+0x14>
  {
  }
}
    841e:	bd38      	pop	{r3, r4, r5, pc}
    8420:	00062894 	.word	0x00062894

00008424 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
    8424:	4b01      	ldr	r3, [pc, #4]	; (842c <HAL_GetREVID+0x8>)
    8426:	6818      	ldr	r0, [r3, #0]
}
    8428:	0c00      	lsrs	r0, r0, #16
    842a:	4770      	bx	lr
    842c:	5c001000 	.word	0x5c001000

00008430 <HAL_SetFMCMemorySwappingConfig>:
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    8430:	f030 7380 	bics.w	r3, r0, #16777216	; 0x1000000
{
    8434:	b510      	push	{r4, lr}
    8436:	4604      	mov	r4, r0
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    8438:	d002      	beq.n	8440 <HAL_SetFMCMemorySwappingConfig+0x10>
    843a:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
    843e:	d106      	bne.n	844e <HAL_SetFMCMemorySwappingConfig+0x1e>
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
    8440:	4b06      	ldr	r3, [pc, #24]	; (845c <HAL_SetFMCMemorySwappingConfig+0x2c>)
    8442:	6818      	ldr	r0, [r3, #0]
    8444:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
    8448:	4320      	orrs	r0, r4
    844a:	6018      	str	r0, [r3, #0]
}
    844c:	bd10      	pop	{r4, pc}
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
    844e:	f44f 6181 	mov.w	r1, #1032	; 0x408
    8452:	4803      	ldr	r0, [pc, #12]	; (8460 <HAL_SetFMCMemorySwappingConfig+0x30>)
    8454:	f011 f834 	bl	194c0 <assert_failed>
    8458:	e7f2      	b.n	8440 <HAL_SetFMCMemorySwappingConfig+0x10>
    845a:	bf00      	nop
    845c:	52004000 	.word	0x52004000
    8460:	0002fea8 	.word	0x0002fea8

00008464 <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
    8464:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8468:	4b6a      	ldr	r3, [pc, #424]	; (8614 <HAL_ADC_Start_DMA+0x1b0>)
{
    846a:	460e      	mov	r6, r1
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    846c:	6801      	ldr	r1, [r0, #0]
{
    846e:	4604      	mov	r4, r0
    8470:	4617      	mov	r7, r2
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8472:	4299      	cmp	r1, r3
    8474:	d037      	beq.n	84e6 <HAL_ADC_Start_DMA+0x82>
    8476:	f503 7380 	add.w	r3, r3, #256	; 0x100
    847a:	4299      	cmp	r1, r3
    847c:	d033      	beq.n	84e6 <HAL_ADC_Start_DMA+0x82>
    847e:	4866      	ldr	r0, [pc, #408]	; (8618 <HAL_ADC_Start_DMA+0x1b4>)

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    8480:	4a64      	ldr	r2, [pc, #400]	; (8614 <HAL_ADC_Start_DMA+0x1b0>)
    8482:	4b66      	ldr	r3, [pc, #408]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    8484:	6885      	ldr	r5, [r0, #8]
    8486:	4291      	cmp	r1, r2
    8488:	bf18      	it	ne
    848a:	4299      	cmpne	r1, r3
    848c:	d002      	beq.n	8494 <HAL_ADC_Start_DMA+0x30>
    848e:	4b64      	ldr	r3, [pc, #400]	; (8620 <HAL_ADC_Start_DMA+0x1bc>)
    8490:	4299      	cmp	r1, r3
    8492:	d12a      	bne.n	84ea <HAL_ADC_Start_DMA+0x86>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    8494:	688b      	ldr	r3, [r1, #8]
    8496:	075a      	lsls	r2, r3, #29
    8498:	d430      	bmi.n	84fc <HAL_ADC_Start_DMA+0x98>

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* Process locked */
    __HAL_LOCK(hadc);
    849a:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    849e:	2b01      	cmp	r3, #1
    84a0:	d02c      	beq.n	84fc <HAL_ADC_Start_DMA+0x98>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    84a2:	f005 051f 	and.w	r5, r5, #31
    84a6:	2301      	movs	r3, #1

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    84a8:	2d09      	cmp	r5, #9
    __HAL_LOCK(hadc);
    84aa:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    84ae:	d905      	bls.n	84bc <HAL_ADC_Start_DMA+0x58>
        LL_ADC_REG_StartConversion(hadc->Instance);
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
    84b0:	2300      	movs	r3, #0
    84b2:	2001      	movs	r0, #1
    84b4:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    tmp_hal_status = HAL_BUSY;
  }

  /* Return function status */
  return tmp_hal_status;
}
    84b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    84bc:	f240 2021 	movw	r0, #545	; 0x221
    84c0:	40e8      	lsrs	r0, r5
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
    84c2:	07c3      	lsls	r3, r0, #31
    84c4:	d5f4      	bpl.n	84b0 <HAL_ADC_Start_DMA+0x4c>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    84c6:	688b      	ldr	r3, [r1, #8]
    84c8:	07d8      	lsls	r0, r3, #31
    84ca:	d41a      	bmi.n	8502 <HAL_ADC_Start_DMA+0x9e>
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    84cc:	688a      	ldr	r2, [r1, #8]
    84ce:	4b55      	ldr	r3, [pc, #340]	; (8624 <HAL_ADC_Start_DMA+0x1c0>)
    84d0:	421a      	tst	r2, r3
    84d2:	d05b      	beq.n	858c <HAL_ADC_Start_DMA+0x128>
        }

        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    84d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
    84d6:	f043 0310 	orr.w	r3, r3, #16
    84da:	6563      	str	r3, [r4, #84]	; 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    84dc:	6da3      	ldr	r3, [r4, #88]	; 0x58
    84de:	f043 0301 	orr.w	r3, r3, #1
    84e2:	65a3      	str	r3, [r4, #88]	; 0x58
    84e4:	e7e4      	b.n	84b0 <HAL_ADC_Start_DMA+0x4c>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    84e6:	4850      	ldr	r0, [pc, #320]	; (8628 <HAL_ADC_Start_DMA+0x1c4>)
    84e8:	e7ca      	b.n	8480 <HAL_ADC_Start_DMA+0x1c>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    84ea:	f240 71a7 	movw	r1, #1959	; 0x7a7
    84ee:	484f      	ldr	r0, [pc, #316]	; (862c <HAL_ADC_Start_DMA+0x1c8>)
    84f0:	f010 ffe6 	bl	194c0 <assert_failed>
    84f4:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    84f6:	688b      	ldr	r3, [r1, #8]
    84f8:	075a      	lsls	r2, r3, #29
    84fa:	d5ce      	bpl.n	849a <HAL_ADC_Start_DMA+0x36>
    tmp_hal_status = HAL_BUSY;
    84fc:	2002      	movs	r0, #2
}
    84fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8502:	4b46      	ldr	r3, [pc, #280]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
    8504:	1ac9      	subs	r1, r1, r3
    8506:	bf18      	it	ne
    8508:	2101      	movne	r1, #1
        ADC_STATE_CLR_SET(hadc->State,
    850a:	6d62      	ldr	r2, [r4, #84]	; 0x54
    850c:	4b48      	ldr	r3, [pc, #288]	; (8630 <HAL_ADC_Start_DMA+0x1cc>)
    850e:	4013      	ands	r3, r2
    8510:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    8514:	6563      	str	r3, [r4, #84]	; 0x54
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    8516:	b105      	cbz	r5, 851a <HAL_ADC_Start_DMA+0xb6>
    8518:	b119      	cbz	r1, 8522 <HAL_ADC_Start_DMA+0xbe>
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
    851a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    851c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    8520:	6563      	str	r3, [r4, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
    8522:	6d63      	ldr	r3, [r4, #84]	; 0x54
    8524:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
    8528:	d02e      	beq.n	8588 <HAL_ADC_Start_DMA+0x124>
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
    852a:	6da3      	ldr	r3, [r4, #88]	; 0x58
    852c:	f023 0306 	bic.w	r3, r3, #6
    8530:	65a3      	str	r3, [r4, #88]	; 0x58
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    8532:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    8534:	463b      	mov	r3, r7
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    8536:	483f      	ldr	r0, [pc, #252]	; (8634 <HAL_ADC_Start_DMA+0x1d0>)
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    8538:	4632      	mov	r2, r6
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    853a:	4f3f      	ldr	r7, [pc, #252]	; (8638 <HAL_ADC_Start_DMA+0x1d4>)
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
    853c:	251c      	movs	r5, #28
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
    853e:	63c8      	str	r0, [r1, #60]	; 0x3c
        __HAL_UNLOCK(hadc);
    8540:	2100      	movs	r1, #0
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    8542:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    8544:	4e3d      	ldr	r6, [pc, #244]	; (863c <HAL_ADC_Start_DMA+0x1d8>)
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    8546:	6407      	str	r7, [r0, #64]	; 0x40
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
    8548:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    854a:	64c6      	str	r6, [r0, #76]	; 0x4c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
    854c:	6820      	ldr	r0, [r4, #0]
    854e:	6005      	str	r5, [r0, #0]
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    8550:	6820      	ldr	r0, [r4, #0]
        __HAL_UNLOCK(hadc);
    8552:	f884 1050 	strb.w	r1, [r4, #80]	; 0x50
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    8556:	6841      	ldr	r1, [r0, #4]
    8558:	f041 0110 	orr.w	r1, r1, #16
    855c:	6041      	str	r1, [r0, #4]
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
    855e:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
    8560:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    8562:	68c1      	ldr	r1, [r0, #12]
    8564:	f021 0103 	bic.w	r1, r1, #3
    8568:	4329      	orrs	r1, r5
    856a:	60c1      	str	r1, [r0, #12]
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    856c:	6821      	ldr	r1, [r4, #0]
    856e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    8570:	3140      	adds	r1, #64	; 0x40
    8572:	f002 fab3 	bl	aadc <HAL_DMA_Start_IT>
        LL_ADC_REG_StartConversion(hadc->Instance);
    8576:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
    8578:	4b31      	ldr	r3, [pc, #196]	; (8640 <HAL_ADC_Start_DMA+0x1dc>)
    857a:	6891      	ldr	r1, [r2, #8]
    857c:	400b      	ands	r3, r1
    857e:	f043 0304 	orr.w	r3, r3, #4
    8582:	6093      	str	r3, [r2, #8]
}
    8584:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          ADC_CLEAR_ERRORCODE(hadc);
    8588:	65a3      	str	r3, [r4, #88]	; 0x58
    858a:	e7d2      	b.n	8532 <HAL_ADC_Start_DMA+0xce>
  MODIFY_REG(ADCx->CR,
    858c:	688a      	ldr	r2, [r1, #8]
    858e:	4b2c      	ldr	r3, [pc, #176]	; (8640 <HAL_ADC_Start_DMA+0x1dc>)
    8590:	4013      	ands	r3, r2
    8592:	f043 0301 	orr.w	r3, r3, #1
    8596:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
    8598:	f7ff ff2c 	bl	83f4 <HAL_GetTick>
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    859c:	6823      	ldr	r3, [r4, #0]
    859e:	4a1d      	ldr	r2, [pc, #116]	; (8614 <HAL_ADC_Start_DMA+0x1b0>)
    tickstart = HAL_GetTick();
    85a0:	4680      	mov	r8, r0
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    85a2:	4293      	cmp	r3, r2
    85a4:	d022      	beq.n	85ec <HAL_ADC_Start_DMA+0x188>
    85a6:	f502 7280 	add.w	r2, r2, #256	; 0x100
    85aa:	4293      	cmp	r3, r2
    85ac:	d01e      	beq.n	85ec <HAL_ADC_Start_DMA+0x188>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    85ae:	4a1a      	ldr	r2, [pc, #104]	; (8618 <HAL_ADC_Start_DMA+0x1b4>)
    85b0:	6892      	ldr	r2, [r2, #8]
  MODIFY_REG(ADCx->CR,
    85b2:	f8df 908c 	ldr.w	r9, [pc, #140]	; 8640 <HAL_ADC_Start_DMA+0x1dc>
    85b6:	e00c      	b.n	85d2 <HAL_ADC_Start_DMA+0x16e>
    85b8:	689a      	ldr	r2, [r3, #8]
    85ba:	ea02 0209 	and.w	r2, r2, r9
    85be:	f042 0201 	orr.w	r2, r2, #1
    85c2:	609a      	str	r2, [r3, #8]
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
    85c4:	f7ff ff16 	bl	83f4 <HAL_GetTick>
    85c8:	eba0 0008 	sub.w	r0, r0, r8
    85cc:	2802      	cmp	r0, #2
    85ce:	d881      	bhi.n	84d4 <HAL_ADC_Start_DMA+0x70>
    85d0:	6823      	ldr	r3, [r4, #0]
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
    85d2:	681a      	ldr	r2, [r3, #0]
    85d4:	07d2      	lsls	r2, r2, #31
    85d6:	d418      	bmi.n	860a <HAL_ADC_Start_DMA+0x1a6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    85d8:	689a      	ldr	r2, [r3, #8]
    85da:	07d1      	lsls	r1, r2, #31
    85dc:	d5ec      	bpl.n	85b8 <HAL_ADC_Start_DMA+0x154>
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
    85de:	f7ff ff09 	bl	83f4 <HAL_GetTick>
    85e2:	eba0 0008 	sub.w	r0, r0, r8
    85e6:	2802      	cmp	r0, #2
    85e8:	d9f2      	bls.n	85d0 <HAL_ADC_Start_DMA+0x16c>
    85ea:	e773      	b.n	84d4 <HAL_ADC_Start_DMA+0x70>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
    85ec:	490e      	ldr	r1, [pc, #56]	; (8628 <HAL_ADC_Start_DMA+0x1c4>)
    if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
    85ee:	4a0b      	ldr	r2, [pc, #44]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
    85f0:	6889      	ldr	r1, [r1, #8]
         || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
    85f2:	f011 0f1f 	tst.w	r1, #31
    85f6:	bf0c      	ite	eq
    85f8:	2101      	moveq	r1, #1
    85fa:	2100      	movne	r1, #0
    85fc:	4293      	cmp	r3, r2
    85fe:	bf18      	it	ne
    8600:	f041 0101 	orrne.w	r1, r1, #1
    8604:	2900      	cmp	r1, #0
    8606:	d1d4      	bne.n	85b2 <HAL_ADC_Start_DMA+0x14e>
    8608:	e77f      	b.n	850a <HAL_ADC_Start_DMA+0xa6>
    860a:	4904      	ldr	r1, [pc, #16]	; (861c <HAL_ADC_Start_DMA+0x1b8>)
    860c:	1a59      	subs	r1, r3, r1
    860e:	bf18      	it	ne
    8610:	2101      	movne	r1, #1
    8612:	e77a      	b.n	850a <HAL_ADC_Start_DMA+0xa6>
    8614:	40022000 	.word	0x40022000
    8618:	58026300 	.word	0x58026300
    861c:	40022100 	.word	0x40022100
    8620:	58026000 	.word	0x58026000
    8624:	8000003f 	.word	0x8000003f
    8628:	40022300 	.word	0x40022300
    862c:	0002fedc 	.word	0x0002fedc
    8630:	fffff0fe 	.word	0xfffff0fe
    8634:	00008655 	.word	0x00008655
    8638:	00008645 	.word	0x00008645
    863c:	000086bd 	.word	0x000086bd
    8640:	7fffffc0 	.word	0x7fffffc0

00008644 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
    8644:	b508      	push	{r3, lr}

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
    8646:	6b80      	ldr	r0, [r0, #56]	; 0x38
    8648:	f010 fe46 	bl	192d8 <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
    864c:	bd08      	pop	{r3, pc}
    864e:	bf00      	nop

00008650 <HAL_ADC_ErrorCallback>:
    8650:	4770      	bx	lr
    8652:	bf00      	nop

00008654 <ADC_DMAConvCplt>:
{
    8654:	b510      	push	{r4, lr}
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
    8656:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
    8658:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    865a:	f012 0f50 	tst.w	r2, #80	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
    865e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
    8660:	d11d      	bne.n	869e <ADC_DMAConvCplt+0x4a>
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
    8662:	6819      	ldr	r1, [r3, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
    8664:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    8668:	655a      	str	r2, [r3, #84]	; 0x54
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
    866a:	680a      	ldr	r2, [r1, #0]
    866c:	f012 0f08 	tst.w	r2, #8
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
    8670:	68ca      	ldr	r2, [r1, #12]
    8672:	d01b      	beq.n	86ac <ADC_DMAConvCplt+0x58>
    8674:	f412 6f40 	tst.w	r2, #3072	; 0xc00
    8678:	d10d      	bne.n	8696 <ADC_DMAConvCplt+0x42>
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
    867a:	68ca      	ldr	r2, [r1, #12]
    867c:	0494      	lsls	r4, r2, #18
    867e:	d40a      	bmi.n	8696 <ADC_DMAConvCplt+0x42>
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
    8680:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8682:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    8686:	655a      	str	r2, [r3, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
    8688:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    868a:	04d1      	lsls	r1, r2, #19
    868c:	d403      	bmi.n	8696 <ADC_DMAConvCplt+0x42>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
    868e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    8690:	f042 0201 	orr.w	r2, r2, #1
    8694:	655a      	str	r2, [r3, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
    8696:	4618      	mov	r0, r3
    8698:	f010 fe1c 	bl	192d4 <HAL_ADC_ConvCpltCallback>
}
    869c:	bd10      	pop	{r4, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
    869e:	06d2      	lsls	r2, r2, #27
    86a0:	d407      	bmi.n	86b2 <ADC_DMAConvCplt+0x5e>
      hadc->DMA_Handle->XferErrorCallback(hdma);
    86a2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
    86a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      hadc->DMA_Handle->XferErrorCallback(hdma);
    86a8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    86aa:	4718      	bx	r3
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
    86ac:	0790      	lsls	r0, r2, #30
    86ae:	d1f2      	bne.n	8696 <ADC_DMAConvCplt+0x42>
    86b0:	e7e6      	b.n	8680 <ADC_DMAConvCplt+0x2c>
      HAL_ADC_ErrorCallback(hadc);
    86b2:	4618      	mov	r0, r3
    86b4:	f7ff ffcc 	bl	8650 <HAL_ADC_ErrorCallback>
}
    86b8:	bd10      	pop	{r4, pc}
    86ba:	bf00      	nop

000086bc <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
    86bc:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
    86be:	6b83      	ldr	r3, [r0, #56]	; 0x38

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
    86c0:	6d5a      	ldr	r2, [r3, #84]	; 0x54

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
    86c2:	4618      	mov	r0, r3
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
    86c4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    86c8:	655a      	str	r2, [r3, #84]	; 0x54
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
    86ca:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    86cc:	f042 0204 	orr.w	r2, r2, #4
    86d0:	659a      	str	r2, [r3, #88]	; 0x58
  HAL_ADC_ErrorCallback(hadc);
    86d2:	f7ff ffbd 	bl	8650 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
    86d6:	bd08      	pop	{r3, pc}

000086d8 <HAL_ADC_ConfigChannel>:
{
    86d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    86da:	4605      	mov	r5, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86dc:	4ab3      	ldr	r2, [pc, #716]	; (89ac <HAL_ADC_ConfigChannel+0x2d4>)
    86de:	48b4      	ldr	r0, [pc, #720]	; (89b0 <HAL_ADC_ConfigChannel+0x2d8>)
{
    86e0:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86e2:	682b      	ldr	r3, [r5, #0]
  __IO uint32_t wait_loop_index = 0;
    86e4:	2600      	movs	r6, #0
{
    86e6:	460c      	mov	r4, r1
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86e8:	4283      	cmp	r3, r0
    86ea:	bf18      	it	ne
    86ec:	4293      	cmpne	r3, r2
  __IO uint32_t wait_loop_index = 0;
    86ee:	9601      	str	r6, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    86f0:	d003      	beq.n	86fa <HAL_ADC_ConfigChannel+0x22>
    86f2:	4ab0      	ldr	r2, [pc, #704]	; (89b4 <HAL_ADC_ConfigChannel+0x2dc>)
    86f4:	4293      	cmp	r3, r2
    86f6:	f040 8153 	bne.w	89a0 <HAL_ADC_ConfigChannel+0x2c8>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    86fa:	6862      	ldr	r2, [r4, #4]
    86fc:	f422 7340 	bic.w	r3, r2, #768	; 0x300
    8700:	f422 7180 	bic.w	r1, r2, #256	; 0x100
    8704:	1f98      	subs	r0, r3, #6
    8706:	bf18      	it	ne
    8708:	2001      	movne	r0, #1
    870a:	2918      	cmp	r1, #24
    870c:	f240 8119 	bls.w	8942 <HAL_ADC_ConfigChannel+0x26a>
    8710:	2301      	movs	r3, #1
    8712:	f422 7600 	bic.w	r6, r2, #512	; 0x200
    8716:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
    871a:	f5b6 7680 	subs.w	r6, r6, #256	; 0x100
    871e:	bf18      	it	ne
    8720:	2601      	movne	r6, #1
    8722:	2918      	cmp	r1, #24
    8724:	f240 8107 	bls.w	8936 <HAL_ADC_ConfigChannel+0x25e>
    8728:	2201      	movs	r2, #1
    872a:	4003      	ands	r3, r0
    872c:	421e      	tst	r6, r3
    872e:	d002      	beq.n	8736 <HAL_ADC_ConfigChannel+0x5e>
    8730:	2a00      	cmp	r2, #0
    8732:	f040 8404 	bne.w	8f3e <HAL_ADC_ConfigChannel+0x866>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
    8736:	68a3      	ldr	r3, [r4, #8]
    8738:	2b07      	cmp	r3, #7
    873a:	f200 8256 	bhi.w	8bea <HAL_ADC_ConfigChannel+0x512>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
    873e:	68e3      	ldr	r3, [r4, #12]
    8740:	f240 72ff 	movw	r2, #2047	; 0x7ff
    8744:	4293      	cmp	r3, r2
    8746:	d003      	beq.n	8750 <HAL_ADC_ConfigChannel+0x78>
    8748:	4a9b      	ldr	r2, [pc, #620]	; (89b8 <HAL_ADC_ConfigChannel+0x2e0>)
    874a:	4293      	cmp	r3, r2
    874c:	f040 8111 	bne.w	8972 <HAL_ADC_ConfigChannel+0x29a>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
    8750:	6923      	ldr	r3, [r4, #16]
    8752:	2b04      	cmp	r3, #4
    8754:	f200 8116 	bhi.w	8984 <HAL_ADC_ConfigChannel+0x2ac>
  if (hadc->Init.OversamplingMode == ENABLE)
    8758:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    875c:	6961      	ldr	r1, [r4, #20]
    875e:	2b01      	cmp	r3, #1
    8760:	682a      	ldr	r2, [r5, #0]
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
    8762:	4b96      	ldr	r3, [pc, #600]	; (89bc <HAL_ADC_ConfigChannel+0x2e4>)
    8764:	f000 8223 	beq.w	8bae <HAL_ADC_ConfigChannel+0x4d6>
    8768:	681b      	ldr	r3, [r3, #0]
    876a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
    876e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8772:	f040 810d 	bne.w	8990 <HAL_ADC_ConfigChannel+0x2b8>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
    8776:	68d2      	ldr	r2, [r2, #12]
    8778:	f64f 73ff 	movw	r3, #65535	; 0xffff
    877c:	0852      	lsrs	r2, r2, #1
    877e:	f002 020e 	and.w	r2, r2, #14
    8782:	40d3      	lsrs	r3, r2
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
    8784:	4299      	cmp	r1, r3
    8786:	f200 813f 	bhi.w	8a08 <HAL_ADC_ConfigChannel+0x330>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
    878a:	4b8b      	ldr	r3, [pc, #556]	; (89b8 <HAL_ADC_ConfigChannel+0x2e0>)
    878c:	68e2      	ldr	r2, [r4, #12]
    878e:	429a      	cmp	r2, r3
    8790:	f000 8152 	beq.w	8a38 <HAL_ADC_ConfigChannel+0x360>
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
    8794:	6821      	ldr	r1, [r4, #0]
    8796:	4b8a      	ldr	r3, [pc, #552]	; (89c0 <HAL_ADC_ConfigChannel+0x2e8>)
    8798:	4e8a      	ldr	r6, [pc, #552]	; (89c4 <HAL_ADC_ConfigChannel+0x2ec>)
    879a:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
    879e:	2901      	cmp	r1, #1
    87a0:	bf18      	it	ne
    87a2:	4299      	cmpne	r1, r3
    87a4:	4888      	ldr	r0, [pc, #544]	; (89c8 <HAL_ADC_ConfigChannel+0x2f0>)
    87a6:	bf14      	ite	ne
    87a8:	2301      	movne	r3, #1
    87aa:	2300      	moveq	r3, #0
    87ac:	42b1      	cmp	r1, r6
    87ae:	bf0c      	ite	eq
    87b0:	2300      	moveq	r3, #0
    87b2:	f003 0301 	andne.w	r3, r3, #1
    87b6:	4e85      	ldr	r6, [pc, #532]	; (89cc <HAL_ADC_ConfigChannel+0x2f4>)
    87b8:	4281      	cmp	r1, r0
    87ba:	bf0c      	ite	eq
    87bc:	2300      	moveq	r3, #0
    87be:	f003 0301 	andne.w	r3, r3, #1
    87c2:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    87c6:	42b1      	cmp	r1, r6
    87c8:	bf0c      	ite	eq
    87ca:	2300      	moveq	r3, #0
    87cc:	f003 0301 	andne.w	r3, r3, #1
    87d0:	3018      	adds	r0, #24
    87d2:	4e7f      	ldr	r6, [pc, #508]	; (89d0 <HAL_ADC_ConfigChannel+0x2f8>)
    87d4:	4281      	cmp	r1, r0
    87d6:	bf0c      	ite	eq
    87d8:	2300      	moveq	r3, #0
    87da:	f003 0301 	andne.w	r3, r3, #1
    87de:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    87e2:	42b1      	cmp	r1, r6
    87e4:	bf0c      	ite	eq
    87e6:	2300      	moveq	r3, #0
    87e8:	f003 0301 	andne.w	r3, r3, #1
    87ec:	3060      	adds	r0, #96	; 0x60
    87ee:	4e79      	ldr	r6, [pc, #484]	; (89d4 <HAL_ADC_ConfigChannel+0x2fc>)
    87f0:	4281      	cmp	r1, r0
    87f2:	bf0c      	ite	eq
    87f4:	2300      	moveq	r3, #0
    87f6:	f003 0301 	andne.w	r3, r3, #1
    87fa:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    87fe:	42b1      	cmp	r1, r6
    8800:	bf0c      	ite	eq
    8802:	2300      	moveq	r3, #0
    8804:	f003 0301 	andne.w	r3, r3, #1
    8808:	f500 70c0 	add.w	r0, r0, #384	; 0x180
    880c:	4e72      	ldr	r6, [pc, #456]	; (89d8 <HAL_ADC_ConfigChannel+0x300>)
    880e:	4281      	cmp	r1, r0
    8810:	bf0c      	ite	eq
    8812:	2300      	moveq	r3, #0
    8814:	f003 0301 	andne.w	r3, r3, #1
    8818:	f100 6008 	add.w	r0, r0, #142606336	; 0x8800000
    881c:	42b1      	cmp	r1, r6
    881e:	bf0c      	ite	eq
    8820:	2300      	moveq	r3, #0
    8822:	f003 0301 	andne.w	r3, r3, #1
    8826:	f500 60c0 	add.w	r0, r0, #1536	; 0x600
    882a:	f106 6606 	add.w	r6, r6, #140509184	; 0x8600000
    882e:	4281      	cmp	r1, r0
    8830:	bf0c      	ite	eq
    8832:	2300      	moveq	r3, #0
    8834:	f003 0301 	andne.w	r3, r3, #1
    8838:	4868      	ldr	r0, [pc, #416]	; (89dc <HAL_ADC_ConfigChannel+0x304>)
    883a:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
    883e:	42b1      	cmp	r1, r6
    8840:	bf0c      	ite	eq
    8842:	2300      	moveq	r3, #0
    8844:	f003 0301 	andne.w	r3, r3, #1
    8848:	4e65      	ldr	r6, [pc, #404]	; (89e0 <HAL_ADC_ConfigChannel+0x308>)
    884a:	4281      	cmp	r1, r0
    884c:	bf0c      	ite	eq
    884e:	2300      	moveq	r3, #0
    8850:	f003 0301 	andne.w	r3, r3, #1
    8854:	4863      	ldr	r0, [pc, #396]	; (89e4 <HAL_ADC_ConfigChannel+0x30c>)
    8856:	42b1      	cmp	r1, r6
    8858:	bf0c      	ite	eq
    885a:	2300      	moveq	r3, #0
    885c:	f003 0301 	andne.w	r3, r3, #1
    8860:	4e61      	ldr	r6, [pc, #388]	; (89e8 <HAL_ADC_ConfigChannel+0x310>)
    8862:	4281      	cmp	r1, r0
    8864:	bf0c      	ite	eq
    8866:	2300      	moveq	r3, #0
    8868:	f003 0301 	andne.w	r3, r3, #1
    886c:	485f      	ldr	r0, [pc, #380]	; (89ec <HAL_ADC_ConfigChannel+0x314>)
    886e:	4960      	ldr	r1, [pc, #384]	; (89f0 <HAL_ADC_ConfigChannel+0x318>)
    8870:	42b2      	cmp	r2, r6
    8872:	bf0c      	ite	eq
    8874:	2300      	moveq	r3, #0
    8876:	f003 0301 	andne.w	r3, r3, #1
    887a:	4282      	cmp	r2, r0
    887c:	bf0c      	ite	eq
    887e:	2300      	moveq	r3, #0
    8880:	f003 0301 	andne.w	r3, r3, #1
    8884:	428a      	cmp	r2, r1
    8886:	bf0c      	ite	eq
    8888:	2300      	moveq	r3, #0
    888a:	f003 0301 	andne.w	r3, r3, #1
    888e:	2b00      	cmp	r3, #0
    8890:	d166      	bne.n	8960 <HAL_ADC_ConfigChannel+0x288>
  __HAL_LOCK(hadc);
    8892:	f895 3050 	ldrb.w	r3, [r5, #80]	; 0x50
    8896:	2b01      	cmp	r3, #1
    8898:	f000 82a2 	beq.w	8de0 <HAL_ADC_ConfigChannel+0x708>
    889c:	2001      	movs	r0, #1
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
    889e:	682a      	ldr	r2, [r5, #0]
  __HAL_LOCK(hadc);
    88a0:	f885 0050 	strb.w	r0, [r5, #80]	; 0x50
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    88a4:	6893      	ldr	r3, [r2, #8]
    88a6:	075b      	lsls	r3, r3, #29
    88a8:	d451      	bmi.n	894e <HAL_ADC_ConfigChannel+0x276>
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
    88aa:	6823      	ldr	r3, [r4, #0]
    88ac:	f3c3 0113 	ubfx	r1, r3, #0, #20
    88b0:	2900      	cmp	r1, #0
    88b2:	f040 81a2 	bne.w	8bfa <HAL_ADC_ConfigChannel+0x522>
    88b6:	f3c3 6384 	ubfx	r3, r3, #26, #5
    88ba:	4098      	lsls	r0, r3
    88bc:	69d3      	ldr	r3, [r2, #28]
  MODIFY_REG(*preg,
    88be:	271f      	movs	r7, #31
    88c0:	4318      	orrs	r0, r3
    88c2:	61d0      	str	r0, [r2, #28]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
    88c4:	6862      	ldr	r2, [r4, #4]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
    88c6:	6829      	ldr	r1, [r5, #0]
    88c8:	0990      	lsrs	r0, r2, #6
  MODIFY_REG(*preg,
    88ca:	6823      	ldr	r3, [r4, #0]
    88cc:	403a      	ands	r2, r7
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
    88ce:	3130      	adds	r1, #48	; 0x30
    88d0:	f000 000c 	and.w	r0, r0, #12
  MODIFY_REG(*preg,
    88d4:	f3c3 6384 	ubfx	r3, r3, #26, #5
    88d8:	4097      	lsls	r7, r2
    88da:	5846      	ldr	r6, [r0, r1]
    88dc:	4093      	lsls	r3, r2
    88de:	ea26 0207 	bic.w	r2, r6, r7
    88e2:	4313      	orrs	r3, r2
    88e4:	5043      	str	r3, [r0, r1]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
    88e6:	682b      	ldr	r3, [r5, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    88e8:	689a      	ldr	r2, [r3, #8]
    88ea:	0757      	lsls	r7, r2, #29
    88ec:	f100 8183 	bmi.w	8bf6 <HAL_ADC_ConfigChannel+0x51e>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    88f0:	689e      	ldr	r6, [r3, #8]
    88f2:	f016 0608 	ands.w	r6, r6, #8
    88f6:	f000 80f1 	beq.w	8adc <HAL_ADC_ConfigChannel+0x404>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    88fa:	689a      	ldr	r2, [r3, #8]
    88fc:	07d6      	lsls	r6, r2, #31
    88fe:	d418      	bmi.n	8932 <HAL_ADC_ConfigChannel+0x25a>
  MODIFY_REG(ADCx->DIFSEL,
    8900:	68e1      	ldr	r1, [r4, #12]
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
    8902:	6826      	ldr	r6, [r4, #0]
    8904:	f001 0018 	and.w	r0, r1, #24
    8908:	4a3a      	ldr	r2, [pc, #232]	; (89f4 <HAL_ADC_ConfigChannel+0x31c>)
    890a:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    890e:	40c2      	lsrs	r2, r0
    8910:	f3c6 0013 	ubfx	r0, r6, #0, #20
    8914:	4032      	ands	r2, r6
    8916:	ea21 0100 	bic.w	r1, r1, r0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
    891a:	4827      	ldr	r0, [pc, #156]	; (89b8 <HAL_ADC_ConfigChannel+0x2e0>)
    891c:	430a      	orrs	r2, r1
    891e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    8922:	68e3      	ldr	r3, [r4, #12]
    8924:	4283      	cmp	r3, r0
    8926:	f000 821c 	beq.w	8d62 <HAL_ADC_ConfigChannel+0x68a>
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
    892a:	6822      	ldr	r2, [r4, #0]
    892c:	2a00      	cmp	r2, #0
    892e:	f2c0 81b6 	blt.w	8c9e <HAL_ADC_ConfigChannel+0x5c6>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8932:	2000      	movs	r0, #0
    8934:	e00f      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    8936:	4a30      	ldr	r2, [pc, #192]	; (89f8 <HAL_ADC_ConfigChannel+0x320>)
    8938:	40ca      	lsrs	r2, r1
    893a:	43d2      	mvns	r2, r2
    893c:	f002 0201 	and.w	r2, r2, #1
    8940:	e6f3      	b.n	872a <HAL_ADC_ConfigChannel+0x52>
    8942:	4b2e      	ldr	r3, [pc, #184]	; (89fc <HAL_ADC_ConfigChannel+0x324>)
    8944:	40cb      	lsrs	r3, r1
    8946:	43db      	mvns	r3, r3
    8948:	f003 0301 	and.w	r3, r3, #1
    894c:	e6e1      	b.n	8712 <HAL_ADC_ConfigChannel+0x3a>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    894e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    8950:	f043 0320 	orr.w	r3, r3, #32
    8954:	656b      	str	r3, [r5, #84]	; 0x54
  __HAL_UNLOCK(hadc);
    8956:	2300      	movs	r3, #0
    8958:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
}
    895c:	b003      	add	sp, #12
    895e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
    8960:	4b27      	ldr	r3, [pc, #156]	; (8a00 <HAL_ADC_ConfigChannel+0x328>)
    8962:	429a      	cmp	r2, r3
    8964:	d095      	beq.n	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8966:	f640 2174 	movw	r1, #2676	; 0xa74
    896a:	4826      	ldr	r0, [pc, #152]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    896c:	f010 fda8 	bl	194c0 <assert_failed>
    8970:	e78f      	b.n	8892 <HAL_ADC_ConfigChannel+0x1ba>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
    8972:	f640 2161 	movw	r1, #2657	; 0xa61
    8976:	4823      	ldr	r0, [pc, #140]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    8978:	f010 fda2 	bl	194c0 <assert_failed>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
    897c:	6923      	ldr	r3, [r4, #16]
    897e:	2b04      	cmp	r3, #4
    8980:	f67f aeea 	bls.w	8758 <HAL_ADC_ConfigChannel+0x80>
    8984:	f640 2162 	movw	r1, #2658	; 0xa62
    8988:	481e      	ldr	r0, [pc, #120]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    898a:	f010 fd99 	bl	194c0 <assert_failed>
    898e:	e6e3      	b.n	8758 <HAL_ADC_ConfigChannel+0x80>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
    8990:	68d3      	ldr	r3, [r2, #12]
    8992:	f003 031c 	and.w	r3, r3, #28
    8996:	2b1c      	cmp	r3, #28
    8998:	f47f aeed 	bne.w	8776 <HAL_ADC_ConfigChannel+0x9e>
    899c:	23ff      	movs	r3, #255	; 0xff
    899e:	e6f1      	b.n	8784 <HAL_ADC_ConfigChannel+0xac>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    89a0:	f640 215e 	movw	r1, #2654	; 0xa5e
    89a4:	4817      	ldr	r0, [pc, #92]	; (8a04 <HAL_ADC_ConfigChannel+0x32c>)
    89a6:	f010 fd8b 	bl	194c0 <assert_failed>
    89aa:	e6a6      	b.n	86fa <HAL_ADC_ConfigChannel+0x22>
    89ac:	40022100 	.word	0x40022100
    89b0:	40022000 	.word	0x40022000
    89b4:	58026000 	.word	0x58026000
    89b8:	47ff0000 	.word	0x47ff0000
    89bc:	5c001000 	.word	0x5c001000
    89c0:	04300002 	.word	0x04300002
    89c4:	08600004 	.word	0x08600004
    89c8:	0c900008 	.word	0x0c900008
    89cc:	10c00010 	.word	0x10c00010
    89d0:	19200040 	.word	0x19200040
    89d4:	21800100 	.word	0x21800100
    89d8:	2a000400 	.word	0x2a000400
    89dc:	36902000 	.word	0x36902000
    89e0:	3ac04000 	.word	0x3ac04000
    89e4:	3ef08000 	.word	0x3ef08000
    89e8:	43210000 	.word	0x43210000
    89ec:	47520000 	.word	0x47520000
    89f0:	4b840000 	.word	0x4b840000
    89f4:	000fffff 	.word	0x000fffff
    89f8:	01041001 	.word	0x01041001
    89fc:	01041000 	.word	0x01041000
    8a00:	4fb80000 	.word	0x4fb80000
    8a04:	0002fedc 	.word	0x0002fedc
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
    8a08:	f640 216a 	movw	r1, #2666	; 0xa6a
    8a0c:	48bd      	ldr	r0, [pc, #756]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8a0e:	f010 fd57 	bl	194c0 <assert_failed>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
    8a12:	6923      	ldr	r3, [r4, #16]
    8a14:	2b04      	cmp	r3, #4
    8a16:	f43f aeb8 	beq.w	878a <HAL_ADC_ConfigChannel+0xb2>
    8a1a:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
    8a1e:	2b01      	cmp	r3, #1
    8a20:	f47f aeb3 	bne.w	878a <HAL_ADC_ConfigChannel+0xb2>
    8a24:	f640 216f 	movw	r1, #2671	; 0xa6f
    8a28:	48b6      	ldr	r0, [pc, #728]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8a2a:	f010 fd49 	bl	194c0 <assert_failed>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
    8a2e:	4bb6      	ldr	r3, [pc, #728]	; (8d08 <HAL_ADC_ConfigChannel+0x630>)
    8a30:	68e2      	ldr	r2, [r4, #12]
    8a32:	429a      	cmp	r2, r3
    8a34:	f47f aeae 	bne.w	8794 <HAL_ADC_ConfigChannel+0xbc>
    if (hadc->Instance == ADC1)
    8a38:	682b      	ldr	r3, [r5, #0]
    8a3a:	4ab4      	ldr	r2, [pc, #720]	; (8d0c <HAL_ADC_ConfigChannel+0x634>)
    8a3c:	4293      	cmp	r3, r2
    8a3e:	f000 81d8 	beq.w	8df2 <HAL_ADC_ConfigChannel+0x71a>
    if (hadc->Instance == ADC2)
    8a42:	4ab3      	ldr	r2, [pc, #716]	; (8d10 <HAL_ADC_ConfigChannel+0x638>)
    8a44:	4293      	cmp	r3, r2
    8a46:	f000 80e7 	beq.w	8c18 <HAL_ADC_ConfigChannel+0x540>
    if (hadc->Instance == ADC3)
    8a4a:	4ab2      	ldr	r2, [pc, #712]	; (8d14 <HAL_ADC_ConfigChannel+0x63c>)
    8a4c:	4293      	cmp	r3, r2
    8a4e:	f47f af20 	bne.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
      assert_param(IS_ADC3_DIFF_CHANNEL(sConfig->Channel));
    8a52:	6822      	ldr	r2, [r4, #0]
    8a54:	4bb0      	ldr	r3, [pc, #704]	; (8d18 <HAL_ADC_ConfigChannel+0x640>)
    8a56:	48b1      	ldr	r0, [pc, #708]	; (8d1c <HAL_ADC_ConfigChannel+0x644>)
    8a58:	49b1      	ldr	r1, [pc, #708]	; (8d20 <HAL_ADC_ConfigChannel+0x648>)
    8a5a:	429a      	cmp	r2, r3
    8a5c:	bf18      	it	ne
    8a5e:	4282      	cmpne	r2, r0
    8a60:	48b0      	ldr	r0, [pc, #704]	; (8d24 <HAL_ADC_ConfigChannel+0x64c>)
    8a62:	bf14      	ite	ne
    8a64:	2301      	movne	r3, #1
    8a66:	2300      	moveq	r3, #0
    8a68:	428a      	cmp	r2, r1
    8a6a:	bf0c      	ite	eq
    8a6c:	2300      	moveq	r3, #0
    8a6e:	f003 0301 	andne.w	r3, r3, #1
    8a72:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
    8a76:	4282      	cmp	r2, r0
    8a78:	bf0c      	ite	eq
    8a7a:	2300      	moveq	r3, #0
    8a7c:	f003 0301 	andne.w	r3, r3, #1
    8a80:	3118      	adds	r1, #24
    8a82:	48a9      	ldr	r0, [pc, #676]	; (8d28 <HAL_ADC_ConfigChannel+0x650>)
    8a84:	428a      	cmp	r2, r1
    8a86:	bf0c      	ite	eq
    8a88:	2300      	moveq	r3, #0
    8a8a:	f003 0301 	andne.w	r3, r3, #1
    8a8e:	f101 51ca 	add.w	r1, r1, #423624704	; 0x19400000
    8a92:	4282      	cmp	r2, r0
    8a94:	bf0c      	ite	eq
    8a96:	2300      	moveq	r3, #0
    8a98:	f003 0301 	andne.w	r3, r3, #1
    8a9c:	f501 61fc 	add.w	r1, r1, #2016	; 0x7e0
    8aa0:	48a2      	ldr	r0, [pc, #648]	; (8d2c <HAL_ADC_ConfigChannel+0x654>)
    8aa2:	428a      	cmp	r2, r1
    8aa4:	bf0c      	ite	eq
    8aa6:	2300      	moveq	r3, #0
    8aa8:	f003 0301 	andne.w	r3, r3, #1
    8aac:	49a0      	ldr	r1, [pc, #640]	; (8d30 <HAL_ADC_ConfigChannel+0x658>)
    8aae:	4282      	cmp	r2, r0
    8ab0:	bf0c      	ite	eq
    8ab2:	2300      	moveq	r3, #0
    8ab4:	f003 0301 	andne.w	r3, r3, #1
    8ab8:	428a      	cmp	r2, r1
    8aba:	bf0c      	ite	eq
    8abc:	2300      	moveq	r3, #0
    8abe:	f003 0301 	andne.w	r3, r3, #1
    8ac2:	2b00      	cmp	r3, #0
    8ac4:	f43f aee5 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8ac8:	4b9a      	ldr	r3, [pc, #616]	; (8d34 <HAL_ADC_ConfigChannel+0x65c>)
    8aca:	429a      	cmp	r2, r3
    8acc:	f43f aee1 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8ad0:	f640 2184 	movw	r1, #2692	; 0xa84
    8ad4:	488b      	ldr	r0, [pc, #556]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8ad6:	f010 fcf3 	bl	194c0 <assert_failed>
    8ada:	e6da      	b.n	8892 <HAL_ADC_ConfigChannel+0x1ba>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
    8adc:	6821      	ldr	r1, [r4, #0]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8ade:	3314      	adds	r3, #20
  MODIFY_REG(*preg,
    8ae0:	2207      	movs	r2, #7
    8ae2:	68a7      	ldr	r7, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8ae4:	0dc8      	lsrs	r0, r1, #23
  MODIFY_REG(*preg,
    8ae6:	f3c1 5104 	ubfx	r1, r1, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8aea:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
    8aee:	fa02 fc01 	lsl.w	ip, r2, r1
    8af2:	fa07 f101 	lsl.w	r1, r7, r1
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8af6:	4f90      	ldr	r7, [pc, #576]	; (8d38 <HAL_ADC_ConfigChannel+0x660>)
    8af8:	58c2      	ldr	r2, [r0, r3]
    8afa:	ea22 020c 	bic.w	r2, r2, ip
    8afe:	430a      	orrs	r2, r1
    8b00:	50c2      	str	r2, [r0, r3]
    8b02:	683b      	ldr	r3, [r7, #0]
    8b04:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
    8b08:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8b0c:	f000 8120 	beq.w	8d50 <HAL_ADC_ConfigChannel+0x678>
    8b10:	682b      	ldr	r3, [r5, #0]
    8b12:	6962      	ldr	r2, [r4, #20]
    8b14:	68d9      	ldr	r1, [r3, #12]
    8b16:	f011 0f10 	tst.w	r1, #16
    8b1a:	68d9      	ldr	r1, [r3, #12]
    8b1c:	f040 81ce 	bne.w	8ebc <HAL_ADC_ConfigChannel+0x7e4>
    8b20:	f3c1 0182 	ubfx	r1, r1, #2, #3
    8b24:	0049      	lsls	r1, r1, #1
    8b26:	fa02 f101 	lsl.w	r1, r2, r1
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
    8b2a:	6920      	ldr	r0, [r4, #16]
    8b2c:	6822      	ldr	r2, [r4, #0]
    8b2e:	2804      	cmp	r0, #4
    8b30:	f000 81a8 	beq.w	8e84 <HAL_ADC_ConfigChannel+0x7ac>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
    8b34:	3360      	adds	r3, #96	; 0x60
  MODIFY_REG(*preg,
    8b36:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
    8b3a:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
    8b3e:	430a      	orrs	r2, r1
    8b40:	f007 4100 	and.w	r1, r7, #2147483648	; 0x80000000
    8b44:	430a      	orrs	r2, r1
    8b46:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
    8b4a:	7e63      	ldrb	r3, [r4, #25]
    8b4c:	2b01      	cmp	r3, #1
    8b4e:	d905      	bls.n	8b5c <HAL_ADC_ConfigChannel+0x484>
    8b50:	f640 21b2 	movw	r1, #2738	; 0xab2
    8b54:	486b      	ldr	r0, [pc, #428]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8b56:	f010 fcb3 	bl	194c0 <assert_failed>
    8b5a:	7e63      	ldrb	r3, [r4, #25]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
    8b5c:	682a      	ldr	r2, [r5, #0]
    8b5e:	2b01      	cmp	r3, #1
    8b60:	6921      	ldr	r1, [r4, #16]
   register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
    8b62:	f102 0260 	add.w	r2, r2, #96	; 0x60
    8b66:	bf14      	ite	ne
    8b68:	2000      	movne	r0, #0
    8b6a:	f04f 4000 	moveq.w	r0, #2147483648	; 0x80000000
   MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
    8b6e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    8b72:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    8b76:	4303      	orrs	r3, r0
    8b78:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
    8b7c:	7e23      	ldrb	r3, [r4, #24]
    8b7e:	2b01      	cmp	r3, #1
    8b80:	d905      	bls.n	8b8e <HAL_ADC_ConfigChannel+0x4b6>
    8b82:	f640 21b6 	movw	r1, #2742	; 0xab6
    8b86:	485f      	ldr	r0, [pc, #380]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8b88:	f010 fc9a 	bl	194c0 <assert_failed>
    8b8c:	7e23      	ldrb	r3, [r4, #24]
        LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
    8b8e:	2b01      	cmp	r3, #1
    8b90:	682a      	ldr	r2, [r5, #0]
    8b92:	6921      	ldr	r1, [r4, #16]
    8b94:	d104      	bne.n	8ba0 <HAL_ADC_ConfigChannel+0x4c8>
    8b96:	f001 011f 	and.w	r1, r1, #31
    8b9a:	f44f 6600 	mov.w	r6, #2048	; 0x800
    8b9e:	408e      	lsls	r6, r1
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
    8ba0:	6913      	ldr	r3, [r2, #16]
    8ba2:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    8ba6:	431e      	orrs	r6, r3
    8ba8:	6116      	str	r6, [r2, #16]
    8baa:	682b      	ldr	r3, [r5, #0]
    8bac:	e6a5      	b.n	88fa <HAL_ADC_ConfigChannel+0x222>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
    8bae:	681b      	ldr	r3, [r3, #0]
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
    8bb0:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    8bb2:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
    8bb6:	3001      	adds	r0, #1
    8bb8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
    8bbc:	fbb1 f1f0 	udiv	r1, r1, r0
    8bc0:	d123      	bne.n	8c0a <HAL_ADC_ConfigChannel+0x532>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
    8bc2:	68d2      	ldr	r2, [r2, #12]
    8bc4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    8bc8:	0852      	lsrs	r2, r2, #1
    8bca:	f002 020e 	and.w	r2, r2, #14
    8bce:	40d3      	lsrs	r3, r2
    8bd0:	4299      	cmp	r1, r3
    8bd2:	f200 8108 	bhi.w	8de6 <HAL_ADC_ConfigChannel+0x70e>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
    8bd6:	6923      	ldr	r3, [r4, #16]
    8bd8:	2b04      	cmp	r3, #4
    8bda:	f43f add6 	beq.w	878a <HAL_ADC_ConfigChannel+0xb2>
    8bde:	f640 216f 	movw	r1, #2671	; 0xa6f
    8be2:	4848      	ldr	r0, [pc, #288]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8be4:	f010 fc6c 	bl	194c0 <assert_failed>
    8be8:	e721      	b.n	8a2e <HAL_ADC_ConfigChannel+0x356>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
    8bea:	f44f 6126 	mov.w	r1, #2656	; 0xa60
    8bee:	4845      	ldr	r0, [pc, #276]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8bf0:	f010 fc66 	bl	194c0 <assert_failed>
    8bf4:	e5a3      	b.n	873e <HAL_ADC_ConfigChannel+0x66>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    8bf6:	689a      	ldr	r2, [r3, #8]
    8bf8:	e67f      	b.n	88fa <HAL_ADC_ConfigChannel+0x222>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    8bfa:	fa93 f3a3 	rbit	r3, r3
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
    8bfe:	fab3 f383 	clz	r3, r3
    8c02:	f003 031f 	and.w	r3, r3, #31
    8c06:	4098      	lsls	r0, r3
    8c08:	e658      	b.n	88bc <HAL_ADC_ConfigChannel+0x1e4>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
    8c0a:	68d3      	ldr	r3, [r2, #12]
    8c0c:	f003 031c 	and.w	r3, r3, #28
    8c10:	2b1c      	cmp	r3, #28
    8c12:	d1d6      	bne.n	8bc2 <HAL_ADC_ConfigChannel+0x4ea>
    8c14:	23ff      	movs	r3, #255	; 0xff
    8c16:	e7db      	b.n	8bd0 <HAL_ADC_ConfigChannel+0x4f8>
      assert_param(IS_ADC2_DIFF_CHANNEL(sConfig->Channel));
    8c18:	6822      	ldr	r2, [r4, #0]
    8c1a:	4b3f      	ldr	r3, [pc, #252]	; (8d18 <HAL_ADC_ConfigChannel+0x640>)
    8c1c:	493f      	ldr	r1, [pc, #252]	; (8d1c <HAL_ADC_ConfigChannel+0x644>)
    8c1e:	4840      	ldr	r0, [pc, #256]	; (8d20 <HAL_ADC_ConfigChannel+0x648>)
    8c20:	429a      	cmp	r2, r3
    8c22:	bf18      	it	ne
    8c24:	428a      	cmpne	r2, r1
    8c26:	493f      	ldr	r1, [pc, #252]	; (8d24 <HAL_ADC_ConfigChannel+0x64c>)
    8c28:	bf14      	ite	ne
    8c2a:	2301      	movne	r3, #1
    8c2c:	2300      	moveq	r3, #0
    8c2e:	4282      	cmp	r2, r0
    8c30:	bf0c      	ite	eq
    8c32:	2300      	moveq	r3, #0
    8c34:	f003 0301 	andne.w	r3, r3, #1
    8c38:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    8c3c:	428a      	cmp	r2, r1
    8c3e:	bf0c      	ite	eq
    8c40:	2300      	moveq	r3, #0
    8c42:	f003 0301 	andne.w	r3, r3, #1
    8c46:	3018      	adds	r0, #24
    8c48:	4937      	ldr	r1, [pc, #220]	; (8d28 <HAL_ADC_ConfigChannel+0x650>)
    8c4a:	4282      	cmp	r2, r0
    8c4c:	bf0c      	ite	eq
    8c4e:	2300      	moveq	r3, #0
    8c50:	f003 0301 	andne.w	r3, r3, #1
    8c54:	f100 50ca 	add.w	r0, r0, #423624704	; 0x19400000
    8c58:	428a      	cmp	r2, r1
    8c5a:	bf0c      	ite	eq
    8c5c:	2300      	moveq	r3, #0
    8c5e:	f003 0301 	andne.w	r3, r3, #1
    8c62:	f500 60fc 	add.w	r0, r0, #2016	; 0x7e0
    8c66:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
    8c6a:	4282      	cmp	r2, r0
    8c6c:	bf0c      	ite	eq
    8c6e:	2300      	moveq	r3, #0
    8c70:	f003 0301 	andne.w	r3, r3, #1
    8c74:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
    8c78:	428a      	cmp	r2, r1
    8c7a:	bf0c      	ite	eq
    8c7c:	2300      	moveq	r3, #0
    8c7e:	f003 0301 	andne.w	r3, r3, #1
    8c82:	2b00      	cmp	r3, #0
    8c84:	f43f ae05 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8c88:	4b2c      	ldr	r3, [pc, #176]	; (8d3c <HAL_ADC_ConfigChannel+0x664>)
    8c8a:	429a      	cmp	r2, r3
    8c8c:	f43f ae01 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8c90:	f640 217e 	movw	r1, #2686	; 0xa7e
    8c94:	481b      	ldr	r0, [pc, #108]	; (8d04 <HAL_ADC_ConfigChannel+0x62c>)
    8c96:	f010 fc13 	bl	194c0 <assert_failed>
    8c9a:	682b      	ldr	r3, [r5, #0]
    8c9c:	e6d5      	b.n	8a4a <HAL_ADC_ConfigChannel+0x372>
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8c9e:	6829      	ldr	r1, [r5, #0]
    8ca0:	4b1a      	ldr	r3, [pc, #104]	; (8d0c <HAL_ADC_ConfigChannel+0x634>)
    8ca2:	4299      	cmp	r1, r3
    8ca4:	f000 813d 	beq.w	8f22 <HAL_ADC_ConfigChannel+0x84a>
    8ca8:	f503 7380 	add.w	r3, r3, #256	; 0x100
    8cac:	4299      	cmp	r1, r3
    8cae:	f000 8138 	beq.w	8f22 <HAL_ADC_ConfigChannel+0x84a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8cb2:	4e18      	ldr	r6, [pc, #96]	; (8d14 <HAL_ADC_ConfigChannel+0x63c>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8cb4:	4c22      	ldr	r4, [pc, #136]	; (8d40 <HAL_ADC_ConfigChannel+0x668>)
    8cb6:	68a0      	ldr	r0, [r4, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8cb8:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8cba:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
    8cbe:	43db      	mvns	r3, r3
    8cc0:	f003 0301 	and.w	r3, r3, #1
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    8cc4:	2b00      	cmp	r3, #0
    8cc6:	f000 8141 	beq.w	8f4c <HAL_ADC_ConfigChannel+0x874>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
    8cca:	4b1e      	ldr	r3, [pc, #120]	; (8d44 <HAL_ADC_ConfigChannel+0x66c>)
    8ccc:	429a      	cmp	r2, r3
    8cce:	f000 8160 	beq.w	8f92 <HAL_ADC_ConfigChannel+0x8ba>
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
    8cd2:	4b1d      	ldr	r3, [pc, #116]	; (8d48 <HAL_ADC_ConfigChannel+0x670>)
    8cd4:	429a      	cmp	r2, r3
    8cd6:	f000 817e 	beq.w	8fd6 <HAL_ADC_ConfigChannel+0x8fe>
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
    8cda:	4b1c      	ldr	r3, [pc, #112]	; (8d4c <HAL_ADC_ConfigChannel+0x674>)
    8cdc:	429a      	cmp	r2, r3
    8cde:	f47f ae28 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_VREFINT_INSTANCE(hadc))
    8ce2:	0243      	lsls	r3, r0, #9
    8ce4:	f53f ae25 	bmi.w	8932 <HAL_ADC_ConfigChannel+0x25a>
    8ce8:	4b0a      	ldr	r3, [pc, #40]	; (8d14 <HAL_ADC_ConfigChannel+0x63c>)
    8cea:	4299      	cmp	r1, r3
    8cec:	f47f ae21 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
    8cf0:	68a2      	ldr	r2, [r4, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
    8cf2:	f446 0380 	orr.w	r3, r6, #4194304	; 0x400000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8cf6:	2000      	movs	r0, #0
    8cf8:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
    8cfc:	4313      	orrs	r3, r2
    8cfe:	60a3      	str	r3, [r4, #8]
    8d00:	e629      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
    8d02:	bf00      	nop
    8d04:	0002fedc 	.word	0x0002fedc
    8d08:	47ff0000 	.word	0x47ff0000
    8d0c:	40022000 	.word	0x40022000
    8d10:	40022100 	.word	0x40022100
    8d14:	58026000 	.word	0x58026000
    8d18:	04300002 	.word	0x04300002
    8d1c:	08600004 	.word	0x08600004
    8d20:	0c900008 	.word	0x0c900008
    8d24:	10c00010 	.word	0x10c00010
    8d28:	2a000400 	.word	0x2a000400
    8d2c:	36902000 	.word	0x36902000
    8d30:	3ac04000 	.word	0x3ac04000
    8d34:	3ef08000 	.word	0x3ef08000
    8d38:	5c001000 	.word	0x5c001000
    8d3c:	4b840000 	.word	0x4b840000
    8d40:	58026300 	.word	0x58026300
    8d44:	cb840000 	.word	0xcb840000
    8d48:	c7520000 	.word	0xc7520000
    8d4c:	cfb80000 	.word	0xcfb80000
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8d50:	682b      	ldr	r3, [r5, #0]
    8d52:	6962      	ldr	r2, [r4, #20]
    8d54:	68d9      	ldr	r1, [r3, #12]
    8d56:	f3c1 0182 	ubfx	r1, r1, #2, #3
    8d5a:	0049      	lsls	r1, r1, #1
    8d5c:	fa02 f101 	lsl.w	r1, r2, r1
    8d60:	e6e3      	b.n	8b2a <HAL_ADC_ConfigChannel+0x452>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8d62:	6822      	ldr	r2, [r4, #0]
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8d64:	6829      	ldr	r1, [r5, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8d66:	f3c2 0313 	ubfx	r3, r2, #0, #20
    8d6a:	2b00      	cmp	r3, #0
    8d6c:	f000 80ac 	beq.w	8ec8 <HAL_ADC_ConfigChannel+0x7f0>
    8d70:	fa92 f3a2 	rbit	r3, r2
    8d74:	fab3 f383 	clz	r3, r3
    8d78:	3301      	adds	r3, #1
    8d7a:	f003 031f 	and.w	r3, r3, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8d7e:	2b09      	cmp	r3, #9
    8d80:	f200 80ea 	bhi.w	8f58 <HAL_ADC_ConfigChannel+0x880>
    8d84:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8d88:	fab3 f383 	clz	r3, r3
    8d8c:	fa92 f0a2 	rbit	r0, r2
    8d90:	2601      	movs	r6, #1
    8d92:	fab0 f080 	clz	r0, r0
    8d96:	3301      	adds	r3, #1
    8d98:	4430      	add	r0, r6
    8d9a:	069b      	lsls	r3, r3, #26
    8d9c:	f000 001f 	and.w	r0, r0, #31
    8da0:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
    8da4:	fa06 f000 	lsl.w	r0, r6, r0
    8da8:	4303      	orrs	r3, r0
    8daa:	fa92 f2a2 	rbit	r2, r2
    8dae:	fab2 f282 	clz	r2, r2
    8db2:	4432      	add	r2, r6
    8db4:	f002 021f 	and.w	r2, r2, #31
    8db8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8dbc:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8dbe:	431a      	orrs	r2, r3
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8dc0:	3114      	adds	r1, #20
  MODIFY_REG(*preg,
    8dc2:	2707      	movs	r7, #7
    8dc4:	68a3      	ldr	r3, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8dc6:	0dd6      	lsrs	r6, r2, #23
  MODIFY_REG(*preg,
    8dc8:	f3c2 5204 	ubfx	r2, r2, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
    8dcc:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
    8dd0:	4097      	lsls	r7, r2
    8dd2:	4093      	lsls	r3, r2
    8dd4:	5870      	ldr	r0, [r6, r1]
    8dd6:	ea20 0207 	bic.w	r2, r0, r7
    8dda:	431a      	orrs	r2, r3
    8ddc:	5072      	str	r2, [r6, r1]
    8dde:	e5a4      	b.n	892a <HAL_ADC_ConfigChannel+0x252>
  __HAL_LOCK(hadc);
    8de0:	2002      	movs	r0, #2
}
    8de2:	b003      	add	sp, #12
    8de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
    8de6:	f640 2166 	movw	r1, #2662	; 0xa66
    8dea:	4883      	ldr	r0, [pc, #524]	; (8ff8 <HAL_ADC_ConfigChannel+0x920>)
    8dec:	f010 fb68 	bl	194c0 <assert_failed>
    8df0:	e60f      	b.n	8a12 <HAL_ADC_ConfigChannel+0x33a>
      assert_param(IS_ADC1_DIFF_CHANNEL(sConfig->Channel));
    8df2:	6822      	ldr	r2, [r4, #0]
    8df4:	4b81      	ldr	r3, [pc, #516]	; (8ffc <HAL_ADC_ConfigChannel+0x924>)
    8df6:	4882      	ldr	r0, [pc, #520]	; (9000 <HAL_ADC_ConfigChannel+0x928>)
    8df8:	4982      	ldr	r1, [pc, #520]	; (9004 <HAL_ADC_ConfigChannel+0x92c>)
    8dfa:	429a      	cmp	r2, r3
    8dfc:	bf18      	it	ne
    8dfe:	4282      	cmpne	r2, r0
    8e00:	4881      	ldr	r0, [pc, #516]	; (9008 <HAL_ADC_ConfigChannel+0x930>)
    8e02:	bf14      	ite	ne
    8e04:	2301      	movne	r3, #1
    8e06:	2300      	moveq	r3, #0
    8e08:	428a      	cmp	r2, r1
    8e0a:	bf0c      	ite	eq
    8e0c:	2300      	moveq	r3, #0
    8e0e:	f003 0301 	andne.w	r3, r3, #1
    8e12:	f101 6106 	add.w	r1, r1, #140509184	; 0x8600000
    8e16:	4282      	cmp	r2, r0
    8e18:	bf0c      	ite	eq
    8e1a:	2300      	moveq	r3, #0
    8e1c:	f003 0301 	andne.w	r3, r3, #1
    8e20:	3118      	adds	r1, #24
    8e22:	487a      	ldr	r0, [pc, #488]	; (900c <HAL_ADC_ConfigChannel+0x934>)
    8e24:	428a      	cmp	r2, r1
    8e26:	bf0c      	ite	eq
    8e28:	2300      	moveq	r3, #0
    8e2a:	f003 0301 	andne.w	r3, r3, #1
    8e2e:	f101 51ca 	add.w	r1, r1, #423624704	; 0x19400000
    8e32:	4282      	cmp	r2, r0
    8e34:	bf0c      	ite	eq
    8e36:	2300      	moveq	r3, #0
    8e38:	f003 0301 	andne.w	r3, r3, #1
    8e3c:	f501 61fc 	add.w	r1, r1, #2016	; 0x7e0
    8e40:	f100 6006 	add.w	r0, r0, #140509184	; 0x8600000
    8e44:	428a      	cmp	r2, r1
    8e46:	bf0c      	ite	eq
    8e48:	2300      	moveq	r3, #0
    8e4a:	f003 0301 	andne.w	r3, r3, #1
    8e4e:	4970      	ldr	r1, [pc, #448]	; (9010 <HAL_ADC_ConfigChannel+0x938>)
    8e50:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
    8e54:	4282      	cmp	r2, r0
    8e56:	bf0c      	ite	eq
    8e58:	2300      	moveq	r3, #0
    8e5a:	f003 0301 	andne.w	r3, r3, #1
    8e5e:	428a      	cmp	r2, r1
    8e60:	bf0c      	ite	eq
    8e62:	2300      	moveq	r3, #0
    8e64:	f003 0301 	andne.w	r3, r3, #1
    8e68:	2b00      	cmp	r3, #0
    8e6a:	f43f ad12 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8e6e:	4b69      	ldr	r3, [pc, #420]	; (9014 <HAL_ADC_ConfigChannel+0x93c>)
    8e70:	429a      	cmp	r2, r3
    8e72:	f43f ad0e 	beq.w	8892 <HAL_ADC_ConfigChannel+0x1ba>
    8e76:	f640 217a 	movw	r1, #2682	; 0xa7a
    8e7a:	485f      	ldr	r0, [pc, #380]	; (8ff8 <HAL_ADC_ConfigChannel+0x920>)
    8e7c:	f010 fb20 	bl	194c0 <assert_failed>
    8e80:	682b      	ldr	r3, [r5, #0]
    8e82:	e5de      	b.n	8a42 <HAL_ADC_ConfigChannel+0x36a>
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8e84:	6e19      	ldr	r1, [r3, #96]	; 0x60
    8e86:	0692      	lsls	r2, r2, #26
    8e88:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8e8c:	4291      	cmp	r1, r2
    8e8e:	d040      	beq.n	8f12 <HAL_ADC_ConfigChannel+0x83a>
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8e90:	6e59      	ldr	r1, [r3, #100]	; 0x64
    8e92:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8e96:	4291      	cmp	r1, r2
    8e98:	d033      	beq.n	8f02 <HAL_ADC_ConfigChannel+0x82a>
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8e9a:	6e99      	ldr	r1, [r3, #104]	; 0x68
    8e9c:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8ea0:	4291      	cmp	r1, r2
    8ea2:	d026      	beq.n	8ef2 <HAL_ADC_ConfigChannel+0x81a>
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
    8ea4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
    8ea6:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
    8eaa:	4291      	cmp	r1, r2
    8eac:	f47f ad25 	bne.w	88fa <HAL_ADC_ConfigChannel+0x222>
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
    8eb0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    8eb2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8eb6:	66da      	str	r2, [r3, #108]	; 0x6c
    8eb8:	682b      	ldr	r3, [r5, #0]
    8eba:	e51e      	b.n	88fa <HAL_ADC_ConfigChannel+0x222>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
    8ebc:	0849      	lsrs	r1, r1, #1
    8ebe:	f001 0108 	and.w	r1, r1, #8
    8ec2:	fa02 f101 	lsl.w	r1, r2, r1
    8ec6:	e630      	b.n	8b2a <HAL_ADC_ConfigChannel+0x452>
    8ec8:	2601      	movs	r6, #1
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8eca:	0e92      	lsrs	r2, r2, #26
    8ecc:	4432      	add	r2, r6
    8ece:	f002 001f 	and.w	r0, r2, #31
    8ed2:	0693      	lsls	r3, r2, #26
    8ed4:	4086      	lsls	r6, r0
    8ed6:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
    8eda:	2809      	cmp	r0, #9
    8edc:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    8ee0:	ea43 0306 	orr.w	r3, r3, r6
    8ee4:	f67f af6a 	bls.w	8dbc <HAL_ADC_ConfigChannel+0x6e4>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8ee8:	3a1e      	subs	r2, #30
    8eea:	0512      	lsls	r2, r2, #20
    8eec:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    8ef0:	e765      	b.n	8dbe <HAL_ADC_ConfigChannel+0x6e6>
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
    8ef2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    8ef4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8ef8:	669a      	str	r2, [r3, #104]	; 0x68
    8efa:	6822      	ldr	r2, [r4, #0]
    8efc:	682b      	ldr	r3, [r5, #0]
    8efe:	0692      	lsls	r2, r2, #26
    8f00:	e7d0      	b.n	8ea4 <HAL_ADC_ConfigChannel+0x7cc>
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
    8f02:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    8f04:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8f08:	665a      	str	r2, [r3, #100]	; 0x64
    8f0a:	6822      	ldr	r2, [r4, #0]
    8f0c:	682b      	ldr	r3, [r5, #0]
    8f0e:	0692      	lsls	r2, r2, #26
    8f10:	e7c3      	b.n	8e9a <HAL_ADC_ConfigChannel+0x7c2>
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
    8f12:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    8f14:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    8f18:	661a      	str	r2, [r3, #96]	; 0x60
    8f1a:	6822      	ldr	r2, [r4, #0]
    8f1c:	682b      	ldr	r3, [r5, #0]
    8f1e:	0692      	lsls	r2, r2, #26
    8f20:	e7b6      	b.n	8e90 <HAL_ADC_ConfigChannel+0x7b8>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8f22:	4b3d      	ldr	r3, [pc, #244]	; (9018 <HAL_ADC_ConfigChannel+0x940>)
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8f24:	4e3d      	ldr	r6, [pc, #244]	; (901c <HAL_ADC_ConfigChannel+0x944>)
    8f26:	4f3e      	ldr	r7, [pc, #248]	; (9020 <HAL_ADC_ConfigChannel+0x948>)
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
    8f28:	461c      	mov	r4, r3
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8f2a:	6898      	ldr	r0, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    8f2c:	68bf      	ldr	r7, [r7, #8]
    8f2e:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
    8f30:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
    8f34:	433b      	orrs	r3, r7
    8f36:	43db      	mvns	r3, r3
    8f38:	f003 0301 	and.w	r3, r3, #1
    8f3c:	e6c2      	b.n	8cc4 <HAL_ADC_ConfigChannel+0x5ec>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
    8f3e:	f640 215f 	movw	r1, #2655	; 0xa5f
    8f42:	482d      	ldr	r0, [pc, #180]	; (8ff8 <HAL_ADC_ConfigChannel+0x920>)
    8f44:	f010 fabc 	bl	194c0 <assert_failed>
    8f48:	f7ff bbf5 	b.w	8736 <HAL_ADC_ConfigChannel+0x5e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    8f4c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
          tmp_hal_status = HAL_ERROR;
    8f4e:	2001      	movs	r0, #1
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    8f50:	f043 0320 	orr.w	r3, r3, #32
    8f54:	656b      	str	r3, [r5, #84]	; 0x54
    8f56:	e4fe      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
    8f58:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
    8f5c:	fab3 f383 	clz	r3, r3
    8f60:	fa92 f0a2 	rbit	r0, r2
    8f64:	2601      	movs	r6, #1
    8f66:	fab0 f080 	clz	r0, r0
    8f6a:	3301      	adds	r3, #1
    8f6c:	4430      	add	r0, r6
    8f6e:	069b      	lsls	r3, r3, #26
    8f70:	f000 001f 	and.w	r0, r0, #31
    8f74:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
    8f78:	fa06 f000 	lsl.w	r0, r6, r0
    8f7c:	4303      	orrs	r3, r0
    8f7e:	fa92 f2a2 	rbit	r2, r2
    8f82:	fab2 f282 	clz	r2, r2
    8f86:	4432      	add	r2, r6
    8f88:	f002 021f 	and.w	r2, r2, #31
    8f8c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8f90:	e7aa      	b.n	8ee8 <HAL_ADC_ConfigChannel+0x810>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
    8f92:	0200      	lsls	r0, r0, #8
    8f94:	f53f accd 	bmi.w	8932 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
    8f98:	4b22      	ldr	r3, [pc, #136]	; (9024 <HAL_ADC_ConfigChannel+0x94c>)
    8f9a:	4299      	cmp	r1, r3
    8f9c:	f47f acc9 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    8fa0:	4b21      	ldr	r3, [pc, #132]	; (9028 <HAL_ADC_ConfigChannel+0x950>)
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
    8fa2:	f446 0200 	orr.w	r2, r6, #8388608	; 0x800000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
    8fa6:	68a1      	ldr	r1, [r4, #8]
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    8fa8:	681b      	ldr	r3, [r3, #0]
    8faa:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
    8fae:	481f      	ldr	r0, [pc, #124]	; (902c <HAL_ADC_ConfigChannel+0x954>)
    8fb0:	099b      	lsrs	r3, r3, #6
    8fb2:	430a      	orrs	r2, r1
    8fb4:	fba0 1303 	umull	r1, r3, r0, r3
    8fb8:	60a2      	str	r2, [r4, #8]
    8fba:	099b      	lsrs	r3, r3, #6
    8fbc:	005b      	lsls	r3, r3, #1
    8fbe:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
    8fc0:	9b01      	ldr	r3, [sp, #4]
    8fc2:	2b00      	cmp	r3, #0
    8fc4:	f43f acb5 	beq.w	8932 <HAL_ADC_ConfigChannel+0x25a>
                wait_loop_index--;
    8fc8:	9b01      	ldr	r3, [sp, #4]
    8fca:	3b01      	subs	r3, #1
    8fcc:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
    8fce:	9b01      	ldr	r3, [sp, #4]
    8fd0:	2b00      	cmp	r3, #0
    8fd2:	d1f9      	bne.n	8fc8 <HAL_ADC_ConfigChannel+0x8f0>
    8fd4:	e4ad      	b.n	8932 <HAL_ADC_ConfigChannel+0x25a>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
    8fd6:	01c2      	lsls	r2, r0, #7
    8fd8:	f53f acab 	bmi.w	8932 <HAL_ADC_ConfigChannel+0x25a>
    8fdc:	4b11      	ldr	r3, [pc, #68]	; (9024 <HAL_ADC_ConfigChannel+0x94c>)
    8fde:	4299      	cmp	r1, r3
    8fe0:	f47f aca7 	bne.w	8932 <HAL_ADC_ConfigChannel+0x25a>
    8fe4:	68a2      	ldr	r2, [r4, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
    8fe6:	f046 7380 	orr.w	r3, r6, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    8fea:	2000      	movs	r0, #0
    8fec:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
    8ff0:	4313      	orrs	r3, r2
    8ff2:	60a3      	str	r3, [r4, #8]
    8ff4:	e4af      	b.n	8956 <HAL_ADC_ConfigChannel+0x27e>
    8ff6:	bf00      	nop
    8ff8:	0002fedc 	.word	0x0002fedc
    8ffc:	04300002 	.word	0x04300002
    9000:	08600004 	.word	0x08600004
    9004:	0c900008 	.word	0x0c900008
    9008:	10c00010 	.word	0x10c00010
    900c:	2a000400 	.word	0x2a000400
    9010:	43210000 	.word	0x43210000
    9014:	4b840000 	.word	0x4b840000
    9018:	40022300 	.word	0x40022300
    901c:	40022100 	.word	0x40022100
    9020:	40022000 	.word	0x40022000
    9024:	58026000 	.word	0x58026000
    9028:	00062b44 	.word	0x00062b44
    902c:	053e2d63 	.word	0x053e2d63

00009030 <ADC_Disable>:
{
    9030:	b538      	push	{r3, r4, r5, lr}
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
    9032:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
    9034:	6899      	ldr	r1, [r3, #8]
    9036:	0789      	lsls	r1, r1, #30
    9038:	d502      	bpl.n	9040 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    903a:	689b      	ldr	r3, [r3, #8]
  return HAL_OK;
    903c:	2000      	movs	r0, #0
}
    903e:	bd38      	pop	{r3, r4, r5, pc}
    9040:	6899      	ldr	r1, [r3, #8]
    9042:	07ca      	lsls	r2, r1, #31
    9044:	d524      	bpl.n	9090 <ADC_Disable+0x60>
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
    9046:	6899      	ldr	r1, [r3, #8]
    9048:	4604      	mov	r4, r0
    904a:	f001 010d 	and.w	r1, r1, #13
    904e:	2901      	cmp	r1, #1
    9050:	d008      	beq.n	9064 <ADC_Disable+0x34>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9052:	6d63      	ldr	r3, [r4, #84]	; 0x54
        return HAL_ERROR;
    9054:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    9056:	f043 0310 	orr.w	r3, r3, #16
    905a:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    905c:	6da3      	ldr	r3, [r4, #88]	; 0x58
    905e:	4303      	orrs	r3, r0
    9060:	65a3      	str	r3, [r4, #88]	; 0x58
}
    9062:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
    9064:	6898      	ldr	r0, [r3, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
    9066:	2103      	movs	r1, #3
    9068:	4a0a      	ldr	r2, [pc, #40]	; (9094 <ADC_Disable+0x64>)
    906a:	4002      	ands	r2, r0
    906c:	f042 0202 	orr.w	r2, r2, #2
    9070:	609a      	str	r2, [r3, #8]
    9072:	6823      	ldr	r3, [r4, #0]
    9074:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
    9076:	f7ff f9bd 	bl	83f4 <HAL_GetTick>
    907a:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
    907c:	e004      	b.n	9088 <ADC_Disable+0x58>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
    907e:	f7ff f9b9 	bl	83f4 <HAL_GetTick>
    9082:	1b40      	subs	r0, r0, r5
    9084:	2802      	cmp	r0, #2
    9086:	d8e4      	bhi.n	9052 <ADC_Disable+0x22>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
    9088:	6823      	ldr	r3, [r4, #0]
    908a:	689b      	ldr	r3, [r3, #8]
    908c:	07db      	lsls	r3, r3, #31
    908e:	d4f6      	bmi.n	907e <ADC_Disable+0x4e>
  return HAL_OK;
    9090:	2000      	movs	r0, #0
}
    9092:	bd38      	pop	{r3, r4, r5, pc}
    9094:	7fffffc0 	.word	0x7fffffc0

00009098 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef* hadc)
{
    9098:	b538      	push	{r3, r4, r5, lr}
  uint32_t freq;
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    909a:	4a52      	ldr	r2, [pc, #328]	; (91e4 <ADC_ConfigureBoostMode+0x14c>)
{
    909c:	4605      	mov	r5, r0
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    909e:	6803      	ldr	r3, [r0, #0]
    90a0:	4293      	cmp	r3, r2
    90a2:	d027      	beq.n	90f4 <ADC_ConfigureBoostMode+0x5c>
    90a4:	f502 7280 	add.w	r2, r2, #256	; 0x100
    90a8:	4293      	cmp	r3, r2
    90aa:	d023      	beq.n	90f4 <ADC_ConfigureBoostMode+0x5c>
    90ac:	4b4e      	ldr	r3, [pc, #312]	; (91e8 <ADC_ConfigureBoostMode+0x150>)
    90ae:	689b      	ldr	r3, [r3, #8]
    90b0:	f413 3f40 	tst.w	r3, #196608	; 0x30000
    90b4:	bf14      	ite	ne
    90b6:	2301      	movne	r3, #1
    90b8:	2300      	moveq	r3, #0
    90ba:	b323      	cbz	r3, 9106 <ADC_ConfigureBoostMode+0x6e>
  {
    freq = HAL_RCC_GetHCLKFreq();
    90bc:	f005 fe2a 	bl	ed14 <HAL_RCC_GetHCLKFreq>
    switch(hadc->Init.ClockPrescaler)
    90c0:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCC_GetHCLKFreq();
    90c2:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
    90c4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    90c8:	d062      	beq.n	9190 <ADC_ConfigureBoostMode+0xf8>
    90ca:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
    90ce:	d072      	beq.n	91b6 <ADC_ConfigureBoostMode+0x11e>
    90d0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    90d4:	d05c      	beq.n	9190 <ADC_ConfigureBoostMode+0xf8>
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
    90d6:	f7ff f9a5 	bl	8424 <HAL_GetREVID>
    90da:	f241 0303 	movw	r3, #4099	; 0x1003
    90de:	4298      	cmp	r0, r3
    90e0:	d832      	bhi.n	9148 <ADC_ConfigureBoostMode+0xb0>
  {
    if(freq > 20000000UL)
    90e2:	4a42      	ldr	r2, [pc, #264]	; (91ec <ADC_ConfigureBoostMode+0x154>)
    90e4:	682b      	ldr	r3, [r5, #0]
    90e6:	4294      	cmp	r4, r2
    90e8:	d928      	bls.n	913c <ADC_ConfigureBoostMode+0xa4>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
    90ea:	689a      	ldr	r2, [r3, #8]
    90ec:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    90f0:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
    90f2:	bd38      	pop	{r3, r4, r5, pc}
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
    90f4:	4b3e      	ldr	r3, [pc, #248]	; (91f0 <ADC_ConfigureBoostMode+0x158>)
    90f6:	689b      	ldr	r3, [r3, #8]
    90f8:	f413 3f40 	tst.w	r3, #196608	; 0x30000
    90fc:	bf14      	ite	ne
    90fe:	2301      	movne	r3, #1
    9100:	2300      	moveq	r3, #0
    9102:	2b00      	cmp	r3, #0
    9104:	d1da      	bne.n	90bc <ADC_ConfigureBoostMode+0x24>
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    9106:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    910a:	f007 f8bb 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
    switch(hadc->Init.ClockPrescaler)
    910e:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
    9110:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
    9112:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
    9116:	d049      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    9118:	d93e      	bls.n	9198 <ADC_ConfigureBoostMode+0x100>
    911a:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
    911e:	d04e      	beq.n	91be <ADC_ConfigureBoostMode+0x126>
    9120:	d927      	bls.n	9172 <ADC_ConfigureBoostMode+0xda>
    9122:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
    9126:	d048      	beq.n	91ba <ADC_ConfigureBoostMode+0x122>
    9128:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
    912c:	d1d3      	bne.n	90d6 <ADC_ConfigureBoostMode+0x3e>
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
    912e:	f7ff f979 	bl	8424 <HAL_GetREVID>
    9132:	f241 0303 	movw	r3, #4099	; 0x1003
    9136:	4298      	cmp	r0, r3
    9138:	d805      	bhi.n	9146 <ADC_ConfigureBoostMode+0xae>
    913a:	682b      	ldr	r3, [r5, #0]
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
    913c:	689a      	ldr	r2, [r3, #8]
    913e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    9142:	609a      	str	r2, [r3, #8]
}
    9144:	bd38      	pop	{r3, r4, r5, pc}
        freq /= 256UL;
    9146:	0a24      	lsrs	r4, r4, #8
    freq /= 2U; /* divider by 2 for Rev.V */
    9148:	0864      	lsrs	r4, r4, #1
    if (freq <= 6250000UL)
    914a:	4a2a      	ldr	r2, [pc, #168]	; (91f4 <ADC_ConfigureBoostMode+0x15c>)
    914c:	682b      	ldr	r3, [r5, #0]
    914e:	4294      	cmp	r4, r2
    9150:	d90a      	bls.n	9168 <ADC_ConfigureBoostMode+0xd0>
    else if(freq <= 12500000UL)
    9152:	4a29      	ldr	r2, [pc, #164]	; (91f8 <ADC_ConfigureBoostMode+0x160>)
    9154:	4294      	cmp	r4, r2
    9156:	d914      	bls.n	9182 <ADC_ConfigureBoostMode+0xea>
    else if(freq <= 25000000UL)
    9158:	4a28      	ldr	r2, [pc, #160]	; (91fc <ADC_ConfigureBoostMode+0x164>)
    915a:	4294      	cmp	r4, r2
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
    915c:	689a      	ldr	r2, [r3, #8]
    else if(freq <= 25000000UL)
    915e:	d932      	bls.n	91c6 <ADC_ConfigureBoostMode+0x12e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    9160:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    9164:	609a      	str	r2, [r3, #8]
}
    9166:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
    9168:	689a      	ldr	r2, [r3, #8]
    916a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    916e:	609a      	str	r2, [r3, #8]
}
    9170:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
    9172:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
    9176:	d024      	beq.n	91c2 <ADC_ConfigureBoostMode+0x12a>
    9178:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
    917c:	d1ab      	bne.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 32UL;
    917e:	0944      	lsrs	r4, r0, #5
        break;
    9180:	e7a9      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
    9182:	689a      	ldr	r2, [r3, #8]
    9184:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    9188:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    918c:	609a      	str	r2, [r3, #8]
}
    918e:	bd38      	pop	{r3, r4, r5, pc}
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
    9190:	0c1b      	lsrs	r3, r3, #16
    9192:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
    9196:	e79e      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
    switch(hadc->Init.ClockPrescaler)
    9198:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
    919c:	d006      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    919e:	d818      	bhi.n	91d2 <ADC_ConfigureBoostMode+0x13a>
    91a0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    91a4:	d002      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    91a6:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
    91aa:	d194      	bne.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
    91ac:	0c9b      	lsrs	r3, r3, #18
    91ae:	005b      	lsls	r3, r3, #1
    91b0:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
    91b4:	e78f      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 4UL;
    91b6:	0884      	lsrs	r4, r0, #2
        break;
    91b8:	e78d      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 128UL;
    91ba:	09c4      	lsrs	r4, r0, #7
        break;
    91bc:	e78b      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 64UL;
    91be:	0984      	lsrs	r4, r0, #6
        break;
    91c0:	e789      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
        freq /= 16UL;
    91c2:	0904      	lsrs	r4, r0, #4
      break;
    91c4:	e787      	b.n	90d6 <ADC_ConfigureBoostMode+0x3e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
    91c6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    91ca:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    91ce:	609a      	str	r2, [r3, #8]
}
    91d0:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
    91d2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    91d6:	d0e9      	beq.n	91ac <ADC_ConfigureBoostMode+0x114>
    91d8:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
    91dc:	f47f af7b 	bne.w	90d6 <ADC_ConfigureBoostMode+0x3e>
    91e0:	e7e4      	b.n	91ac <ADC_ConfigureBoostMode+0x114>
    91e2:	bf00      	nop
    91e4:	40022000 	.word	0x40022000
    91e8:	58026300 	.word	0x58026300
    91ec:	01312d00 	.word	0x01312d00
    91f0:	40022300 	.word	0x40022300
    91f4:	005f5e10 	.word	0x005f5e10
    91f8:	00bebc20 	.word	0x00bebc20
    91fc:	017d7840 	.word	0x017d7840

00009200 <HAL_ADC_Init>:
{
    9200:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0UL;
    9202:	2300      	movs	r3, #0
{
    9204:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
    9206:	9301      	str	r3, [sp, #4]
  if (hadc == NULL)
    9208:	2800      	cmp	r0, #0
    920a:	f000 81ab 	beq.w	9564 <HAL_ADC_Init+0x364>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    920e:	6803      	ldr	r3, [r0, #0]
    9210:	4604      	mov	r4, r0
    9212:	499a      	ldr	r1, [pc, #616]	; (947c <HAL_ADC_Init+0x27c>)
    9214:	4a9a      	ldr	r2, [pc, #616]	; (9480 <HAL_ADC_Init+0x280>)
    9216:	428b      	cmp	r3, r1
    9218:	bf18      	it	ne
    921a:	4293      	cmpne	r3, r2
    921c:	d003      	beq.n	9226 <HAL_ADC_Init+0x26>
    921e:	4a99      	ldr	r2, [pc, #612]	; (9484 <HAL_ADC_Init+0x284>)
    9220:	4293      	cmp	r3, r2
    9222:	f040 81b0 	bne.w	9586 <HAL_ADC_Init+0x386>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    9226:	6862      	ldr	r2, [r4, #4]
    9228:	f422 2300 	bic.w	r3, r2, #524288	; 0x80000
    922c:	f422 3540 	bic.w	r5, r2, #196608	; 0x30000
    9230:	f422 1080 	bic.w	r0, r2, #1048576	; 0x100000
    9234:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
    9238:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    923c:	bf18      	it	ne
    923e:	2d00      	cmpne	r5, #0
    9240:	bf14      	ite	ne
    9242:	2301      	movne	r3, #1
    9244:	2300      	moveq	r3, #0
    9246:	f5b2 1fe0 	cmp.w	r2, #1835008	; 0x1c0000
    924a:	bf0c      	ite	eq
    924c:	2300      	moveq	r3, #0
    924e:	f003 0301 	andne.w	r3, r3, #1
    9252:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
    9256:	bf0c      	ite	eq
    9258:	2300      	moveq	r3, #0
    925a:	f003 0301 	andne.w	r3, r3, #1
    925e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    9262:	bf0c      	ite	eq
    9264:	2300      	moveq	r3, #0
    9266:	f003 0301 	andne.w	r3, r3, #1
    926a:	b12b      	cbz	r3, 9278 <HAL_ADC_Init+0x78>
    926c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
    9270:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    9274:	f040 81e0 	bne.w	9638 <HAL_ADC_Init+0x438>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    9278:	68a2      	ldr	r2, [r4, #8]
    927a:	2a10      	cmp	r2, #16
    927c:	f200 817d 	bhi.w	957a <HAL_ADC_Init+0x37a>
    9280:	4b81      	ldr	r3, [pc, #516]	; (9488 <HAL_ADC_Init+0x288>)
    9282:	40d3      	lsrs	r3, r2
    9284:	07de      	lsls	r6, r3, #31
    9286:	f140 8178 	bpl.w	957a <HAL_ADC_Init+0x37a>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    928a:	68e3      	ldr	r3, [r4, #12]
    928c:	2b01      	cmp	r3, #1
    928e:	f200 80e0 	bhi.w	9452 <HAL_ADC_Init+0x252>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9292:	7d63      	ldrb	r3, [r4, #21]
    9294:	2b01      	cmp	r3, #1
    9296:	f200 80cc 	bhi.w	9432 <HAL_ADC_Init+0x232>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    929a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    929c:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    92a0:	f040 80d1 	bne.w	9446 <HAL_ADC_Init+0x246>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    92a4:	6a62      	ldr	r2, [r4, #36]	; 0x24
    92a6:	f5b2 6fd0 	cmp.w	r2, #1664	; 0x680
    92aa:	bf18      	it	ne
    92ac:	f5b2 6fb8 	cmpne.w	r2, #1472	; 0x5c0
    92b0:	f022 0040 	bic.w	r0, r2, #64	; 0x40
    92b4:	f022 0180 	bic.w	r1, r2, #128	; 0x80
    92b8:	f422 7590 	bic.w	r5, r2, #288	; 0x120
    92bc:	bf14      	ite	ne
    92be:	2301      	movne	r3, #1
    92c0:	2300      	moveq	r3, #0
    92c2:	f5b0 6f84 	cmp.w	r0, #1056	; 0x420
    92c6:	bf0c      	ite	eq
    92c8:	2300      	moveq	r3, #0
    92ca:	f003 0301 	andne.w	r3, r3, #1
    92ce:	f422 7080 	bic.w	r0, r2, #256	; 0x100
    92d2:	f5b1 6f88 	cmp.w	r1, #1088	; 0x440
    92d6:	bf0c      	ite	eq
    92d8:	2300      	moveq	r3, #0
    92da:	f003 0301 	andne.w	r3, r3, #1
    92de:	f022 0160 	bic.w	r1, r2, #96	; 0x60
    92e2:	f5b5 6f90 	cmp.w	r5, #1152	; 0x480
    92e6:	bf0c      	ite	eq
    92e8:	2300      	moveq	r3, #0
    92ea:	f003 0301 	andne.w	r3, r3, #1
    92ee:	f5b0 6f9c 	cmp.w	r0, #1248	; 0x4e0
    92f2:	bf0c      	ite	eq
    92f4:	2300      	moveq	r3, #0
    92f6:	f003 0301 	andne.w	r3, r3, #1
    92fa:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    92fe:	bf0c      	ite	eq
    9300:	2300      	moveq	r3, #0
    9302:	f003 0301 	andne.w	r3, r3, #1
    9306:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    930a:	bf0c      	ite	eq
    930c:	2300      	moveq	r3, #0
    930e:	f003 0301 	andne.w	r3, r3, #1
    9312:	b11b      	cbz	r3, 931c <HAL_ADC_Init+0x11c>
    9314:	f432 6380 	bics.w	r3, r2, #1024	; 0x400
    9318:	f040 8194 	bne.w	9644 <HAL_ADC_Init+0x444>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
    931c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    931e:	2b03      	cmp	r3, #3
    9320:	f200 8165 	bhi.w	95ee <HAL_ADC_Init+0x3ee>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
    9324:	6923      	ldr	r3, [r4, #16]
    9326:	2b04      	cmp	r3, #4
    9328:	d006      	beq.n	9338 <HAL_ADC_Init+0x138>
    932a:	2b08      	cmp	r3, #8
    932c:	d004      	beq.n	9338 <HAL_ADC_Init+0x138>
    932e:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
    9332:	4856      	ldr	r0, [pc, #344]	; (948c <HAL_ADC_Init+0x28c>)
    9334:	f010 f8c4 	bl	194c0 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
    9338:	6b23      	ldr	r3, [r4, #48]	; 0x30
    933a:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
    933e:	f040 8092 	bne.w	9466 <HAL_ADC_Init+0x266>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    9342:	7d23      	ldrb	r3, [r4, #20]
    9344:	2b01      	cmp	r3, #1
    9346:	d86a      	bhi.n	941e <HAL_ADC_Init+0x21e>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    9348:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    934c:	2b01      	cmp	r3, #1
    934e:	d85d      	bhi.n	940c <HAL_ADC_Init+0x20c>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    9350:	68e3      	ldr	r3, [r4, #12]
    9352:	2b00      	cmp	r3, #0
    9354:	d141      	bne.n	93da <HAL_ADC_Init+0x1da>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
    9356:	7f23      	ldrb	r3, [r4, #28]
    9358:	2b01      	cmp	r3, #1
    935a:	d04e      	beq.n	93fa <HAL_ADC_Init+0x1fa>
  if (hadc->State == HAL_ADC_STATE_RESET)
    935c:	6d65      	ldr	r5, [r4, #84]	; 0x54
    935e:	2d00      	cmp	r5, #0
    9360:	f000 8104 	beq.w	956c <HAL_ADC_Init+0x36c>
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
    9364:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
    9366:	689a      	ldr	r2, [r3, #8]
    9368:	0095      	lsls	r5, r2, #2
    936a:	d504      	bpl.n	9376 <HAL_ADC_Init+0x176>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
    936c:	6899      	ldr	r1, [r3, #8]
    936e:	4a48      	ldr	r2, [pc, #288]	; (9490 <HAL_ADC_Init+0x290>)
    9370:	400a      	ands	r2, r1
    9372:	609a      	str	r2, [r3, #8]
    9374:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
    9376:	689a      	ldr	r2, [r3, #8]
    9378:	00d0      	lsls	r0, r2, #3
    937a:	d416      	bmi.n	93aa <HAL_ADC_Init+0x1aa>
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
    937c:	4a45      	ldr	r2, [pc, #276]	; (9494 <HAL_ADC_Init+0x294>)
  MODIFY_REG(ADCx->CR,
    937e:	6898      	ldr	r0, [r3, #8]
    9380:	6812      	ldr	r2, [r2, #0]
    9382:	4d45      	ldr	r5, [pc, #276]	; (9498 <HAL_ADC_Init+0x298>)
    9384:	0992      	lsrs	r2, r2, #6
    9386:	4945      	ldr	r1, [pc, #276]	; (949c <HAL_ADC_Init+0x29c>)
    9388:	fba5 5202 	umull	r5, r2, r5, r2
    938c:	4001      	ands	r1, r0
    938e:	0992      	lsrs	r2, r2, #6
    9390:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
    9394:	6099      	str	r1, [r3, #8]
    9396:	9201      	str	r2, [sp, #4]
    while (wait_loop_index != 0UL)
    9398:	9b01      	ldr	r3, [sp, #4]
    939a:	b12b      	cbz	r3, 93a8 <HAL_ADC_Init+0x1a8>
      wait_loop_index--;
    939c:	9b01      	ldr	r3, [sp, #4]
    939e:	3b01      	subs	r3, #1
    93a0:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
    93a2:	9b01      	ldr	r3, [sp, #4]
    93a4:	2b00      	cmp	r3, #0
    93a6:	d1f9      	bne.n	939c <HAL_ADC_Init+0x19c>
    93a8:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
    93aa:	689a      	ldr	r2, [r3, #8]
    93ac:	00d1      	lsls	r1, r2, #3
    93ae:	f100 80d7 	bmi.w	9560 <HAL_ADC_Init+0x360>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93b2:	6d62      	ldr	r2, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    93b4:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93b6:	f042 0210 	orr.w	r2, r2, #16
    93ba:	6562      	str	r2, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    93bc:	6da2      	ldr	r2, [r4, #88]	; 0x58
    93be:	432a      	orrs	r2, r5
    93c0:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    93c2:	689a      	ldr	r2, [r3, #8]
    93c4:	0752      	lsls	r2, r2, #29
    93c6:	d56b      	bpl.n	94a0 <HAL_ADC_Init+0x2a0>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
    93c8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93ca:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    93cc:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93ce:	f043 0310 	orr.w	r3, r3, #16
}
    93d2:	4628      	mov	r0, r5
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    93d4:	6563      	str	r3, [r4, #84]	; 0x54
}
    93d6:	b003      	add	sp, #12
    93d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    93da:	69a3      	ldr	r3, [r4, #24]
    93dc:	3b01      	subs	r3, #1
    93de:	2b0f      	cmp	r3, #15
    93e0:	f200 80ff 	bhi.w	95e2 <HAL_ADC_Init+0x3e2>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    93e4:	7f23      	ldrb	r3, [r4, #28]
    93e6:	2b01      	cmp	r3, #1
    93e8:	f200 80d3 	bhi.w	9592 <HAL_ADC_Init+0x392>
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    93ec:	2b01      	cmp	r3, #1
    93ee:	d1b5      	bne.n	935c <HAL_ADC_Init+0x15c>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    93f0:	6a23      	ldr	r3, [r4, #32]
    93f2:	3b01      	subs	r3, #1
    93f4:	2b07      	cmp	r3, #7
    93f6:	f200 810f 	bhi.w	9618 <HAL_ADC_Init+0x418>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
    93fa:	7d63      	ldrb	r3, [r4, #21]
    93fc:	2b01      	cmp	r3, #1
    93fe:	d1ad      	bne.n	935c <HAL_ADC_Init+0x15c>
    9400:	f240 11bf 	movw	r1, #447	; 0x1bf
    9404:	4821      	ldr	r0, [pc, #132]	; (948c <HAL_ADC_Init+0x28c>)
    9406:	f010 f85b 	bl	194c0 <assert_failed>
    940a:	e7a7      	b.n	935c <HAL_ADC_Init+0x15c>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    940c:	f240 11b1 	movw	r1, #433	; 0x1b1
    9410:	481e      	ldr	r0, [pc, #120]	; (948c <HAL_ADC_Init+0x28c>)
    9412:	f010 f855 	bl	194c0 <assert_failed>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    9416:	68e3      	ldr	r3, [r4, #12]
    9418:	2b00      	cmp	r3, #0
    941a:	d09c      	beq.n	9356 <HAL_ADC_Init+0x156>
    941c:	e7dd      	b.n	93da <HAL_ADC_Init+0x1da>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    941e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
    9422:	481a      	ldr	r0, [pc, #104]	; (948c <HAL_ADC_Init+0x28c>)
    9424:	f010 f84c 	bl	194c0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
    9428:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    942c:	2b01      	cmp	r3, #1
    942e:	d98f      	bls.n	9350 <HAL_ADC_Init+0x150>
    9430:	e7ec      	b.n	940c <HAL_ADC_Init+0x20c>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    9432:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
    9436:	4815      	ldr	r0, [pc, #84]	; (948c <HAL_ADC_Init+0x28c>)
    9438:	f010 f842 	bl	194c0 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    943c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    943e:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    9442:	f43f af2f 	beq.w	92a4 <HAL_ADC_Init+0xa4>
    9446:	f240 11ab 	movw	r1, #427	; 0x1ab
    944a:	4810      	ldr	r0, [pc, #64]	; (948c <HAL_ADC_Init+0x28c>)
    944c:	f010 f838 	bl	194c0 <assert_failed>
    9450:	e728      	b.n	92a4 <HAL_ADC_Init+0xa4>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    9452:	f240 11a9 	movw	r1, #425	; 0x1a9
    9456:	480d      	ldr	r0, [pc, #52]	; (948c <HAL_ADC_Init+0x28c>)
    9458:	f010 f832 	bl	194c0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    945c:	7d63      	ldrb	r3, [r4, #21]
    945e:	2b01      	cmp	r3, #1
    9460:	f67f af1b 	bls.w	929a <HAL_ADC_Init+0x9a>
    9464:	e7e5      	b.n	9432 <HAL_ADC_Init+0x232>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
    9466:	f240 11af 	movw	r1, #431	; 0x1af
    946a:	4808      	ldr	r0, [pc, #32]	; (948c <HAL_ADC_Init+0x28c>)
    946c:	f010 f828 	bl	194c0 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
    9470:	7d23      	ldrb	r3, [r4, #20]
    9472:	2b01      	cmp	r3, #1
    9474:	f67f af68 	bls.w	9348 <HAL_ADC_Init+0x148>
    9478:	e7d1      	b.n	941e <HAL_ADC_Init+0x21e>
    947a:	bf00      	nop
    947c:	40022000 	.word	0x40022000
    9480:	40022100 	.word	0x40022100
    9484:	58026000 	.word	0x58026000
    9488:	00011111 	.word	0x00011111
    948c:	0002fedc 	.word	0x0002fedc
    9490:	5fffffc0 	.word	0x5fffffc0
    9494:	00062b44 	.word	0x00062b44
    9498:	053e2d63 	.word	0x053e2d63
    949c:	6fffffc0 	.word	0x6fffffc0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
    94a0:	6d62      	ldr	r2, [r4, #84]	; 0x54
    94a2:	06d7      	lsls	r7, r2, #27
    94a4:	d491      	bmi.n	93ca <HAL_ADC_Init+0x1ca>
    ADC_STATE_CLR_SET(hadc->State,
    94a6:	6d62      	ldr	r2, [r4, #84]	; 0x54
    94a8:	f422 7281 	bic.w	r2, r2, #258	; 0x102
    94ac:	f042 0202 	orr.w	r2, r2, #2
    94b0:	6562      	str	r2, [r4, #84]	; 0x54
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    94b2:	689a      	ldr	r2, [r3, #8]
    94b4:	07d6      	lsls	r6, r2, #31
    94b6:	d413      	bmi.n	94e0 <HAL_ADC_Init+0x2e0>
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    94b8:	4a91      	ldr	r2, [pc, #580]	; (9700 <HAL_ADC_Init+0x500>)
    94ba:	4293      	cmp	r3, r2
    94bc:	f000 80b2 	beq.w	9624 <HAL_ADC_Init+0x424>
    94c0:	f502 7280 	add.w	r2, r2, #256	; 0x100
    94c4:	4293      	cmp	r3, r2
    94c6:	f000 80ad 	beq.w	9624 <HAL_ADC_Init+0x424>
    94ca:	4b8e      	ldr	r3, [pc, #568]	; (9704 <HAL_ADC_Init+0x504>)
    94cc:	689b      	ldr	r3, [r3, #8]
    94ce:	07d9      	lsls	r1, r3, #31
    94d0:	d406      	bmi.n	94e0 <HAL_ADC_Init+0x2e0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
    94d2:	4a8d      	ldr	r2, [pc, #564]	; (9708 <HAL_ADC_Init+0x508>)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
    94d4:	6893      	ldr	r3, [r2, #8]
    94d6:	6861      	ldr	r1, [r4, #4]
    94d8:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
    94dc:	430b      	orrs	r3, r1
    94de:	6093      	str	r3, [r2, #8]
    if((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
    94e0:	f7fe ffa0 	bl	8424 <HAL_GetREVID>
    94e4:	f241 0303 	movw	r3, #4099	; 0x1003
    94e8:	4298      	cmp	r0, r3
    94ea:	f240 8086 	bls.w	95fa <HAL_ADC_Init+0x3fa>
    94ee:	68a2      	ldr	r2, [r4, #8]
    94f0:	7d61      	ldrb	r1, [r4, #21]
    94f2:	7f20      	ldrb	r0, [r4, #28]
    94f4:	2a10      	cmp	r2, #16
    94f6:	ea4f 3141 	mov.w	r1, r1, lsl #13
    94fa:	6b26      	ldr	r6, [r4, #48]	; 0x30
    94fc:	ea4f 4300 	mov.w	r3, r0, lsl #16
    9500:	f000 80e0 	beq.w	96c4 <HAL_ADC_Init+0x4c4>
                  hadc->Init.Overrun                                                    |
    9504:	430a      	orrs	r2, r1
    9506:	4332      	orrs	r2, r6
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
    9508:	431a      	orrs	r2, r3
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    950a:	2801      	cmp	r0, #1
    950c:	d103      	bne.n	9516 <HAL_ADC_Init+0x316>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
    950e:	6a23      	ldr	r3, [r4, #32]
    9510:	3b01      	subs	r3, #1
    9512:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
    9516:	6a63      	ldr	r3, [r4, #36]	; 0x24
    9518:	b123      	cbz	r3, 9524 <HAL_ADC_Init+0x324>
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
    951a:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
    951e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    9520:	430b      	orrs	r3, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
    9522:	431a      	orrs	r2, r3
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
    9524:	6821      	ldr	r1, [r4, #0]
    9526:	4b79      	ldr	r3, [pc, #484]	; (970c <HAL_ADC_Init+0x50c>)
    9528:	68c8      	ldr	r0, [r1, #12]
    952a:	4003      	ands	r3, r0
    952c:	4313      	orrs	r3, r2
    952e:	60cb      	str	r3, [r1, #12]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
    9530:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    9532:	689a      	ldr	r2, [r3, #8]
    9534:	f012 0f04 	tst.w	r2, #4
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    9538:	689a      	ldr	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    953a:	d101      	bne.n	9540 <HAL_ADC_Init+0x340>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
    953c:	0712      	lsls	r2, r2, #28
    953e:	d532      	bpl.n	95a6 <HAL_ADC_Init+0x3a6>
    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
    9540:	68e2      	ldr	r2, [r4, #12]
    9542:	2a01      	cmp	r2, #1
    9544:	d060      	beq.n	9608 <HAL_ADC_Init+0x408>
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
    9546:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    9548:	f022 020f 	bic.w	r2, r2, #15
    954c:	631a      	str	r2, [r3, #48]	; 0x30
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
    954e:	6d63      	ldr	r3, [r4, #84]	; 0x54
}
    9550:	4628      	mov	r0, r5
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
    9552:	f023 0303 	bic.w	r3, r3, #3
    9556:	f043 0301 	orr.w	r3, r3, #1
    955a:	6563      	str	r3, [r4, #84]	; 0x54
}
    955c:	b003      	add	sp, #12
    955e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9560:	2500      	movs	r5, #0
    9562:	e72e      	b.n	93c2 <HAL_ADC_Init+0x1c2>
    return HAL_ERROR;
    9564:	2501      	movs	r5, #1
}
    9566:	4628      	mov	r0, r5
    9568:	b003      	add	sp, #12
    956a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
    956c:	4620      	mov	r0, r4
    956e:	f00d f9b7 	bl	168e0 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
    9572:	65a5      	str	r5, [r4, #88]	; 0x58
    hadc->Lock = HAL_UNLOCKED;
    9574:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    9578:	e6f4      	b.n	9364 <HAL_ADC_Init+0x164>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    957a:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
    957e:	4864      	ldr	r0, [pc, #400]	; (9710 <HAL_ADC_Init+0x510>)
    9580:	f00f ff9e 	bl	194c0 <assert_failed>
    9584:	e681      	b.n	928a <HAL_ADC_Init+0x8a>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9586:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
    958a:	4861      	ldr	r0, [pc, #388]	; (9710 <HAL_ADC_Init+0x510>)
    958c:	f00f ff98 	bl	194c0 <assert_failed>
    9590:	e649      	b.n	9226 <HAL_ADC_Init+0x26>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    9592:	f44f 71db 	mov.w	r1, #438	; 0x1b6
    9596:	485e      	ldr	r0, [pc, #376]	; (9710 <HAL_ADC_Init+0x510>)
    9598:	f00f ff92 	bl	194c0 <assert_failed>
    959c:	7f23      	ldrb	r3, [r4, #28]
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    959e:	2b01      	cmp	r3, #1
    95a0:	f47f aedc 	bne.w	935c <HAL_ADC_Init+0x15c>
    95a4:	e724      	b.n	93f0 <HAL_ADC_Init+0x1f0>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
    95a6:	68d9      	ldr	r1, [r3, #12]
    95a8:	4a5a      	ldr	r2, [pc, #360]	; (9714 <HAL_ADC_Init+0x514>)
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
    95aa:	7d20      	ldrb	r0, [r4, #20]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
    95ac:	400a      	ands	r2, r1
    95ae:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    95b0:	ea42 3280 	orr.w	r2, r2, r0, lsl #14
    95b4:	430a      	orrs	r2, r1
    95b6:	60da      	str	r2, [r3, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
    95b8:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
    95bc:	2b01      	cmp	r3, #1
    95be:	d047      	beq.n	9650 <HAL_ADC_Init+0x450>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
    95c0:	6822      	ldr	r2, [r4, #0]
    95c2:	6913      	ldr	r3, [r2, #16]
    95c4:	f023 0301 	bic.w	r3, r3, #1
    95c8:	6113      	str	r3, [r2, #16]
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
    95ca:	6822      	ldr	r2, [r4, #0]
      ADC_ConfigureBoostMode(hadc);
    95cc:	4620      	mov	r0, r4
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
    95ce:	6b61      	ldr	r1, [r4, #52]	; 0x34
    95d0:	6913      	ldr	r3, [r2, #16]
    95d2:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    95d6:	430b      	orrs	r3, r1
    95d8:	6113      	str	r3, [r2, #16]
      ADC_ConfigureBoostMode(hadc);
    95da:	f7ff fd5d 	bl	9098 <ADC_ConfigureBoostMode>
    95de:	6823      	ldr	r3, [r4, #0]
    95e0:	e7ae      	b.n	9540 <HAL_ADC_Init+0x340>
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    95e2:	f240 11b5 	movw	r1, #437	; 0x1b5
    95e6:	484a      	ldr	r0, [pc, #296]	; (9710 <HAL_ADC_Init+0x510>)
    95e8:	f00f ff6a 	bl	194c0 <assert_failed>
    95ec:	e6fa      	b.n	93e4 <HAL_ADC_Init+0x1e4>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
    95ee:	f240 11ad 	movw	r1, #429	; 0x1ad
    95f2:	4847      	ldr	r0, [pc, #284]	; (9710 <HAL_ADC_Init+0x510>)
    95f4:	f00f ff64 	bl	194c0 <assert_failed>
    95f8:	e694      	b.n	9324 <HAL_ADC_Init+0x124>
    95fa:	7d62      	ldrb	r2, [r4, #21]
    95fc:	7f20      	ldrb	r0, [r4, #28]
    95fe:	0351      	lsls	r1, r2, #13
    9600:	6b26      	ldr	r6, [r4, #48]	; 0x30
    9602:	68a2      	ldr	r2, [r4, #8]
    9604:	0403      	lsls	r3, r0, #16
    9606:	e77d      	b.n	9504 <HAL_ADC_Init+0x304>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    9608:	6b19      	ldr	r1, [r3, #48]	; 0x30
    960a:	69a2      	ldr	r2, [r4, #24]
    960c:	f021 010f 	bic.w	r1, r1, #15
    9610:	3a01      	subs	r2, #1
    9612:	430a      	orrs	r2, r1
    9614:	631a      	str	r2, [r3, #48]	; 0x30
    9616:	e79a      	b.n	954e <HAL_ADC_Init+0x34e>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    9618:	f44f 71dd 	mov.w	r1, #442	; 0x1ba
    961c:	483c      	ldr	r0, [pc, #240]	; (9710 <HAL_ADC_Init+0x510>)
    961e:	f00f ff4f 	bl	194c0 <assert_failed>
    9622:	e698      	b.n	9356 <HAL_ADC_Init+0x156>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    9624:	4a36      	ldr	r2, [pc, #216]	; (9700 <HAL_ADC_Init+0x500>)
    9626:	4b3c      	ldr	r3, [pc, #240]	; (9718 <HAL_ADC_Init+0x518>)
    9628:	6892      	ldr	r2, [r2, #8]
    962a:	689b      	ldr	r3, [r3, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    962c:	4313      	orrs	r3, r2
    962e:	07d8      	lsls	r0, r3, #31
    9630:	f53f af56 	bmi.w	94e0 <HAL_ADC_Init+0x2e0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
    9634:	4a39      	ldr	r2, [pc, #228]	; (971c <HAL_ADC_Init+0x51c>)
    9636:	e74d      	b.n	94d4 <HAL_ADC_Init+0x2d4>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    9638:	f240 11a7 	movw	r1, #423	; 0x1a7
    963c:	4834      	ldr	r0, [pc, #208]	; (9710 <HAL_ADC_Init+0x510>)
    963e:	f00f ff3f 	bl	194c0 <assert_failed>
    9642:	e619      	b.n	9278 <HAL_ADC_Init+0x78>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    9644:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
    9648:	4831      	ldr	r0, [pc, #196]	; (9710 <HAL_ADC_Init+0x510>)
    964a:	f00f ff39 	bl	194c0 <assert_failed>
    964e:	e665      	b.n	931c <HAL_ADC_Init+0x11c>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
    9650:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    9652:	3b01      	subs	r3, #1
    9654:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    9658:	d245      	bcs.n	96e6 <HAL_ADC_Init+0x4e6>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
    965a:	6c22      	ldr	r2, [r4, #64]	; 0x40
    965c:	f032 0160 	bics.w	r1, r2, #96	; 0x60
    9660:	bf14      	ite	ne
    9662:	2301      	movne	r3, #1
    9664:	2300      	moveq	r3, #0
    9666:	2980      	cmp	r1, #128	; 0x80
    9668:	bf0c      	ite	eq
    966a:	2300      	moveq	r3, #0
    966c:	f003 0301 	andne.w	r3, r3, #1
    9670:	b113      	cbz	r3, 9678 <HAL_ADC_Init+0x478>
    9672:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    9676:	d13c      	bne.n	96f2 <HAL_ADC_Init+0x4f2>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
    9678:	6c63      	ldr	r3, [r4, #68]	; 0x44
    967a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    967e:	d12c      	bne.n	96da <HAL_ADC_Init+0x4da>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
    9680:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    9682:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    9686:	2b01      	cmp	r3, #1
    9688:	d121      	bne.n	96ce <HAL_ADC_Init+0x4ce>
      if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
    968a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    968c:	6c66      	ldr	r6, [r4, #68]	; 0x44
    968e:	b10b      	cbz	r3, 9694 <HAL_ADC_Init+0x494>
            || (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
    9690:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9692:	b933      	cbnz	r3, 96a2 <HAL_ADC_Init+0x4a2>
          assert_param((hadc->Init.Oversampling.TriggeredMode == ADC_TRIGGEREDMODE_SINGLE_TRIGGER));
    9694:	b12e      	cbz	r6, 96a2 <HAL_ADC_Init+0x4a2>
    9696:	f240 218b 	movw	r1, #651	; 0x28b
    969a:	481d      	ldr	r0, [pc, #116]	; (9710 <HAL_ADC_Init+0x510>)
    969c:	f00f ff10 	bl	194c0 <assert_failed>
    96a0:	6c66      	ldr	r6, [r4, #68]	; 0x44
       MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
    96a2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    96a4:	6820      	ldr	r0, [r4, #0]
    96a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
    96a8:	6907      	ldr	r7, [r0, #16]
    96aa:	4313      	orrs	r3, r2
    96ac:	491c      	ldr	r1, [pc, #112]	; (9720 <HAL_ADC_Init+0x520>)
    96ae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    96b0:	4039      	ands	r1, r7
    96b2:	f043 0301 	orr.w	r3, r3, #1
    96b6:	3a01      	subs	r2, #1
    96b8:	430b      	orrs	r3, r1
    96ba:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    96be:	4333      	orrs	r3, r6
    96c0:	6103      	str	r3, [r0, #16]
    96c2:	e782      	b.n	95ca <HAL_ADC_Init+0x3ca>
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
    96c4:	f046 021c 	orr.w	r2, r6, #28
    96c8:	430a      	orrs	r2, r1
    96ca:	431a      	orrs	r2, r3
    96cc:	e71d      	b.n	950a <HAL_ADC_Init+0x30a>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
    96ce:	f240 2185 	movw	r1, #645	; 0x285
    96d2:	480f      	ldr	r0, [pc, #60]	; (9710 <HAL_ADC_Init+0x510>)
    96d4:	f00f fef4 	bl	194c0 <assert_failed>
    96d8:	e7d7      	b.n	968a <HAL_ADC_Init+0x48a>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
    96da:	f44f 7121 	mov.w	r1, #644	; 0x284
    96de:	480c      	ldr	r0, [pc, #48]	; (9710 <HAL_ADC_Init+0x510>)
    96e0:	f00f feee 	bl	194c0 <assert_failed>
    96e4:	e7cc      	b.n	9680 <HAL_ADC_Init+0x480>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
    96e6:	f240 2182 	movw	r1, #642	; 0x282
    96ea:	4809      	ldr	r0, [pc, #36]	; (9710 <HAL_ADC_Init+0x510>)
    96ec:	f00f fee8 	bl	194c0 <assert_failed>
    96f0:	e7b3      	b.n	965a <HAL_ADC_Init+0x45a>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
    96f2:	f240 2183 	movw	r1, #643	; 0x283
    96f6:	4806      	ldr	r0, [pc, #24]	; (9710 <HAL_ADC_Init+0x510>)
    96f8:	f00f fee2 	bl	194c0 <assert_failed>
    96fc:	e7bc      	b.n	9678 <HAL_ADC_Init+0x478>
    96fe:	bf00      	nop
    9700:	40022000 	.word	0x40022000
    9704:	58026000 	.word	0x58026000
    9708:	58026300 	.word	0x58026300
    970c:	fff0c003 	.word	0xfff0c003
    9710:	0002fedc 	.word	0x0002fedc
    9714:	ffffbffc 	.word	0xffffbffc
    9718:	40022100 	.word	0x40022100
    971c:	40022300 	.word	0x40022300
    9720:	fc00f81e 	.word	0xfc00f81e

00009724 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
    9724:	b5f0      	push	{r4, r5, r6, r7, lr}
    9726:	4604      	mov	r4, r0
    9728:	4616      	mov	r6, r2
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    972a:	4835      	ldr	r0, [pc, #212]	; (9800 <HAL_ADCEx_Calibration_Start+0xdc>)
{
    972c:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    972e:	6823      	ldr	r3, [r4, #0]
  __IO uint32_t wait_loop_index = 0UL;
    9730:	2700      	movs	r7, #0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9732:	4a34      	ldr	r2, [pc, #208]	; (9804 <HAL_ADCEx_Calibration_Start+0xe0>)
{
    9734:	460d      	mov	r5, r1
  __IO uint32_t wait_loop_index = 0UL;
    9736:	9701      	str	r7, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    9738:	4283      	cmp	r3, r0
    973a:	bf18      	it	ne
    973c:	4293      	cmpne	r3, r2
    973e:	d002      	beq.n	9746 <HAL_ADCEx_Calibration_Start+0x22>
    9740:	4a31      	ldr	r2, [pc, #196]	; (9808 <HAL_ADCEx_Calibration_Start+0xe4>)
    9742:	4293      	cmp	r3, r2
    9744:	d14b      	bne.n	97de <HAL_ADCEx_Calibration_Start+0xba>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
    9746:	f240 73ff 	movw	r3, #2047	; 0x7ff
    974a:	429e      	cmp	r6, r3
    974c:	d002      	beq.n	9754 <HAL_ADCEx_Calibration_Start+0x30>
    974e:	4b2f      	ldr	r3, [pc, #188]	; (980c <HAL_ADCEx_Calibration_Start+0xe8>)
    9750:	429e      	cmp	r6, r3
    9752:	d139      	bne.n	97c8 <HAL_ADCEx_Calibration_Start+0xa4>

  /* Process locked */
  __HAL_LOCK(hadc);
    9754:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    9758:	2b01      	cmp	r3, #1
    975a:	d03d      	beq.n	97d8 <HAL_ADCEx_Calibration_Start+0xb4>
    975c:	2301      	movs	r3, #1

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
    975e:	4620      	mov	r0, r4
  __HAL_LOCK(hadc);
    9760:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tmp_hal_status = ADC_Disable(hadc);
    9764:	f7ff fc64 	bl	9030 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
    9768:	bb28      	cbnz	r0, 97b6 <HAL_ADCEx_Calibration_Start+0x92>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
    976a:	6d61      	ldr	r1, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
    976c:	f405 3380 	and.w	r3, r5, #65536	; 0x10000
    9770:	4a27      	ldr	r2, [pc, #156]	; (9810 <HAL_ADCEx_Calibration_Start+0xec>)
    9772:	f006 4680 	and.w	r6, r6, #1073741824	; 0x40000000
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance , CalibrationMode, SingleDiff );
    9776:	6827      	ldr	r7, [r4, #0]
    9778:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    ADC_STATE_CLR_SET(hadc->State,
    977c:	400a      	ands	r2, r1
    977e:	4d25      	ldr	r5, [pc, #148]	; (9814 <HAL_ADCEx_Calibration_Start+0xf0>)
    9780:	4333      	orrs	r3, r6

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    9782:	4925      	ldr	r1, [pc, #148]	; (9818 <HAL_ADCEx_Calibration_Start+0xf4>)
    ADC_STATE_CLR_SET(hadc->State,
    9784:	f042 0202 	orr.w	r2, r2, #2
    9788:	6562      	str	r2, [r4, #84]	; 0x54
    978a:	68ba      	ldr	r2, [r7, #8]
    978c:	4015      	ands	r5, r2
    978e:	432b      	orrs	r3, r5
    9790:	60bb      	str	r3, [r7, #8]
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    9792:	6822      	ldr	r2, [r4, #0]
    9794:	e005      	b.n	97a2 <HAL_ADCEx_Calibration_Start+0x7e>
      wait_loop_index++;
    9796:	9b01      	ldr	r3, [sp, #4]
    9798:	3301      	adds	r3, #1
    979a:	9301      	str	r3, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
    979c:	9b01      	ldr	r3, [sp, #4]
    979e:	428b      	cmp	r3, r1
    97a0:	d822      	bhi.n	97e8 <HAL_ADCEx_Calibration_Start+0xc4>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
    97a2:	6893      	ldr	r3, [r2, #8]
    97a4:	2b00      	cmp	r3, #0
    97a6:	dbf6      	blt.n	9796 <HAL_ADCEx_Calibration_Start+0x72>
        return HAL_ERROR;
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
    97a8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    97aa:	f023 0303 	bic.w	r3, r3, #3
    97ae:	f043 0301 	orr.w	r3, r3, #1
    97b2:	6563      	str	r3, [r4, #84]	; 0x54
    97b4:	e003      	b.n	97be <HAL_ADCEx_Calibration_Start+0x9a>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    97b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
    97b8:	f043 0310 	orr.w	r3, r3, #16
    97bc:	6563      	str	r3, [r4, #84]	; 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
    97be:	2300      	movs	r3, #0
    97c0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
}
    97c4:	b003      	add	sp, #12
    97c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
    97c8:	218f      	movs	r1, #143	; 0x8f
    97ca:	4814      	ldr	r0, [pc, #80]	; (981c <HAL_ADCEx_Calibration_Start+0xf8>)
    97cc:	f00f fe78 	bl	194c0 <assert_failed>
  __HAL_LOCK(hadc);
    97d0:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    97d4:	2b01      	cmp	r3, #1
    97d6:	d1c1      	bne.n	975c <HAL_ADCEx_Calibration_Start+0x38>
    97d8:	2002      	movs	r0, #2
}
    97da:	b003      	add	sp, #12
    97dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    97de:	218e      	movs	r1, #142	; 0x8e
    97e0:	480e      	ldr	r0, [pc, #56]	; (981c <HAL_ADCEx_Calibration_Start+0xf8>)
    97e2:	f00f fe6d 	bl	194c0 <assert_failed>
    97e6:	e7ae      	b.n	9746 <HAL_ADCEx_Calibration_Start+0x22>
        ADC_STATE_CLR_SET(hadc->State,
    97e8:	6d63      	ldr	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hadc);
    97ea:	2200      	movs	r2, #0
        return HAL_ERROR;
    97ec:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
    97ee:	f023 0312 	bic.w	r3, r3, #18
        __HAL_UNLOCK(hadc);
    97f2:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        ADC_STATE_CLR_SET(hadc->State,
    97f6:	f043 0310 	orr.w	r3, r3, #16
    97fa:	6563      	str	r3, [r4, #84]	; 0x54
}
    97fc:	b003      	add	sp, #12
    97fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9800:	40022000 	.word	0x40022000
    9804:	40022100 	.word	0x40022100
    9808:	58026000 	.word	0x58026000
    980c:	47ff0000 	.word	0x47ff0000
    9810:	ffffeefd 	.word	0xffffeefd
    9814:	3ffeffc0 	.word	0x3ffeffc0
    9818:	25c3f7ff 	.word	0x25c3f7ff
    981c:	0002ff14 	.word	0x0002ff14

00009820 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
    9820:	b570      	push	{r4, r5, r6, lr}
  ADC_Common_TypeDef *tmpADC_Common;
  ADC_HandleTypeDef  tmphadcSlave;
  uint32_t tmphadcSlave_conversion_on_going;

  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9822:	4b58      	ldr	r3, [pc, #352]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
{
    9824:	4604      	mov	r4, r0
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    9826:	6802      	ldr	r2, [r0, #0]
{
    9828:	460d      	mov	r5, r1
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
    982a:	429a      	cmp	r2, r3
    982c:	d004      	beq.n	9838 <HAL_ADCEx_MultiModeConfigChannel+0x18>
    982e:	f640 01bd 	movw	r1, #2237	; 0x8bd
    9832:	4855      	ldr	r0, [pc, #340]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    9834:	f00f fe44 	bl	194c0 <assert_failed>
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
    9838:	682b      	ldr	r3, [r5, #0]
    983a:	2b09      	cmp	r3, #9
    983c:	d933      	bls.n	98a6 <HAL_ADCEx_MultiModeConfigChannel+0x86>
    983e:	f640 01be 	movw	r1, #2238	; 0x8be
    9842:	4851      	ldr	r0, [pc, #324]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    9844:	f00f fe3c 	bl	194c0 <assert_failed>
    9848:	682b      	ldr	r3, [r5, #0]
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
    984a:	b1cb      	cbz	r3, 9880 <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    984c:	686b      	ldr	r3, [r5, #4]
    984e:	f433 4200 	bics.w	r2, r3, #32768	; 0x8000
    9852:	d002      	beq.n	985a <HAL_ADCEx_MultiModeConfigChannel+0x3a>
    9854:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
    9858:	d15c      	bne.n	9914 <HAL_ADCEx_MultiModeConfigChannel+0xf4>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    985a:	68ab      	ldr	r3, [r5, #8]
    985c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    9860:	bf18      	it	ne
    9862:	f5b3 6fe0 	cmpne.w	r3, #1792	; 0x700
    9866:	bf14      	ite	ne
    9868:	2201      	movne	r2, #1
    986a:	2200      	moveq	r2, #0
    986c:	f433 7140 	bics.w	r1, r3, #768	; 0x300
    9870:	bf08      	it	eq
    9872:	2200      	moveq	r2, #0
    9874:	b122      	cbz	r2, 9880 <HAL_ADCEx_MultiModeConfigChannel+0x60>
    9876:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    987a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    987e:	d179      	bne.n	9974 <HAL_ADCEx_MultiModeConfigChannel+0x154>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
    9880:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    9884:	2b01      	cmp	r3, #1
    9886:	d04b      	beq.n	9920 <HAL_ADCEx_MultiModeConfigChannel+0x100>

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9888:	4a3e      	ldr	r2, [pc, #248]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
  __HAL_LOCK(hadc);
    988a:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    988c:	6823      	ldr	r3, [r4, #0]
  __HAL_LOCK(hadc);
    988e:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
    9892:	4293      	cmp	r3, r2
    9894:	d00d      	beq.n	98b2 <HAL_ADCEx_MultiModeConfigChannel+0x92>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    9896:	6d63      	ldr	r3, [r4, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
    9898:	2200      	movs	r2, #0
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    989a:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
    989e:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    98a2:	6563      	str	r3, [r4, #84]	; 0x54
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
    98a4:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
    98a6:	f240 22ef 	movw	r2, #751	; 0x2ef
    98aa:	40da      	lsrs	r2, r3
    98ac:	07d6      	lsls	r6, r2, #31
    98ae:	d4cc      	bmi.n	984a <HAL_ADCEx_MultiModeConfigChannel+0x2a>
    98b0:	e7c5      	b.n	983e <HAL_ADCEx_MultiModeConfigChannel+0x1e>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
    98b2:	4a36      	ldr	r2, [pc, #216]	; (998c <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
    98b4:	6891      	ldr	r1, [r2, #8]
    98b6:	0749      	lsls	r1, r1, #29
    98b8:	d509      	bpl.n	98ce <HAL_ADCEx_MultiModeConfigChannel+0xae>
    98ba:	689b      	ldr	r3, [r3, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    98bc:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
    98be:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    98c0:	f043 0320 	orr.w	r3, r3, #32
    98c4:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
    98c6:	2300      	movs	r3, #0
    98c8:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
    98cc:	bd70      	pop	{r4, r5, r6, pc}
    98ce:	6899      	ldr	r1, [r3, #8]
    98d0:	0748      	lsls	r0, r1, #29
    98d2:	d4f3      	bmi.n	98bc <HAL_ADCEx_MultiModeConfigChannel+0x9c>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
    98d4:	6829      	ldr	r1, [r5, #0]
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
    98d6:	482e      	ldr	r0, [pc, #184]	; (9990 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
    98d8:	b321      	cbz	r1, 9924 <HAL_ADCEx_MultiModeConfigChannel+0x104>
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
    98da:	6881      	ldr	r1, [r0, #8]
    98dc:	686e      	ldr	r6, [r5, #4]
    98de:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    98e2:	4331      	orrs	r1, r6
    98e4:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    98e6:	6821      	ldr	r1, [r4, #0]
    98e8:	4299      	cmp	r1, r3
    98ea:	d03a      	beq.n	9962 <HAL_ADCEx_MultiModeConfigChannel+0x142>
    98ec:	4291      	cmp	r1, r2
    98ee:	d038      	beq.n	9962 <HAL_ADCEx_MultiModeConfigChannel+0x142>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
    98f0:	4b28      	ldr	r3, [pc, #160]	; (9994 <HAL_ADCEx_MultiModeConfigChannel+0x174>)
    98f2:	689b      	ldr	r3, [r3, #8]
    98f4:	43db      	mvns	r3, r3
    98f6:	f003 0301 	and.w	r3, r3, #1
    98fa:	2b00      	cmp	r3, #0
    98fc:	d040      	beq.n	9980 <HAL_ADCEx_MultiModeConfigChannel+0x160>
        MODIFY_REG(tmpADC_Common->CCR,
    98fe:	4924      	ldr	r1, [pc, #144]	; (9990 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9900:	2000      	movs	r0, #0
        MODIFY_REG(tmpADC_Common->CCR,
    9902:	682b      	ldr	r3, [r5, #0]
    9904:	688e      	ldr	r6, [r1, #8]
    9906:	68ad      	ldr	r5, [r5, #8]
    9908:	4a23      	ldr	r2, [pc, #140]	; (9998 <HAL_ADCEx_MultiModeConfigChannel+0x178>)
    990a:	432b      	orrs	r3, r5
    990c:	4032      	ands	r2, r6
    990e:	4313      	orrs	r3, r2
    9910:	608b      	str	r3, [r1, #8]
    9912:	e7d8      	b.n	98c6 <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    9914:	f640 01c1 	movw	r1, #2241	; 0x8c1
    9918:	481b      	ldr	r0, [pc, #108]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    991a:	f00f fdd1 	bl	194c0 <assert_failed>
    991e:	e79c      	b.n	985a <HAL_ADCEx_MultiModeConfigChannel+0x3a>
  __HAL_LOCK(hadc);
    9920:	2002      	movs	r0, #2
}
    9922:	bd70      	pop	{r4, r5, r6, pc}
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
    9924:	6881      	ldr	r1, [r0, #8]
    9926:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
    992a:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
    992c:	6821      	ldr	r1, [r4, #0]
    992e:	4299      	cmp	r1, r3
    9930:	d00e      	beq.n	9950 <HAL_ADCEx_MultiModeConfigChannel+0x130>
    9932:	4291      	cmp	r1, r2
    9934:	d00c      	beq.n	9950 <HAL_ADCEx_MultiModeConfigChannel+0x130>
    9936:	4b17      	ldr	r3, [pc, #92]	; (9994 <HAL_ADCEx_MultiModeConfigChannel+0x174>)
    9938:	689b      	ldr	r3, [r3, #8]
    993a:	43db      	mvns	r3, r3
    993c:	f003 0301 	and.w	r3, r3, #1
    9940:	b1f3      	cbz	r3, 9980 <HAL_ADCEx_MultiModeConfigChannel+0x160>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
    9942:	4a13      	ldr	r2, [pc, #76]	; (9990 <HAL_ADCEx_MultiModeConfigChannel+0x170>)
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9944:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
    9946:	4b14      	ldr	r3, [pc, #80]	; (9998 <HAL_ADCEx_MultiModeConfigChannel+0x178>)
    9948:	6891      	ldr	r1, [r2, #8]
    994a:	400b      	ands	r3, r1
    994c:	6093      	str	r3, [r2, #8]
    994e:	e7ba      	b.n	98c6 <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    9950:	4a0c      	ldr	r2, [pc, #48]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
    9952:	4b0e      	ldr	r3, [pc, #56]	; (998c <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
    9954:	6892      	ldr	r2, [r2, #8]
    9956:	689b      	ldr	r3, [r3, #8]
    9958:	4313      	orrs	r3, r2
    995a:	43db      	mvns	r3, r3
    995c:	f003 0301 	and.w	r3, r3, #1
    9960:	e7ee      	b.n	9940 <HAL_ADCEx_MultiModeConfigChannel+0x120>
    9962:	4a08      	ldr	r2, [pc, #32]	; (9984 <HAL_ADCEx_MultiModeConfigChannel+0x164>)
    9964:	4b09      	ldr	r3, [pc, #36]	; (998c <HAL_ADCEx_MultiModeConfigChannel+0x16c>)
    9966:	6892      	ldr	r2, [r2, #8]
    9968:	689b      	ldr	r3, [r3, #8]
    996a:	4313      	orrs	r3, r2
    996c:	43db      	mvns	r3, r3
    996e:	f003 0301 	and.w	r3, r3, #1
    9972:	e7c2      	b.n	98fa <HAL_ADCEx_MultiModeConfigChannel+0xda>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    9974:	f640 01c2 	movw	r1, #2242	; 0x8c2
    9978:	4803      	ldr	r0, [pc, #12]	; (9988 <HAL_ADCEx_MultiModeConfigChannel+0x168>)
    997a:	f00f fda1 	bl	194c0 <assert_failed>
    997e:	e77f      	b.n	9880 <HAL_ADCEx_MultiModeConfigChannel+0x60>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    9980:	2000      	movs	r0, #0
    9982:	e7a0      	b.n	98c6 <HAL_ADCEx_MultiModeConfigChannel+0xa6>
    9984:	40022000 	.word	0x40022000
    9988:	0002ff14 	.word	0x0002ff14
    998c:	40022100 	.word	0x40022100
    9990:	40022300 	.word	0x40022300
    9994:	58026000 	.word	0x58026000
    9998:	fffff0e0 	.word	0xfffff0e0

0000999c <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
    999c:	1ec3      	subs	r3, r0, #3
    999e:	2b04      	cmp	r3, #4
{
    99a0:	b510      	push	{r4, lr}
    99a2:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
    99a4:	d903      	bls.n	99ae <HAL_NVIC_SetPriorityGrouping+0x12>
    99a6:	2192      	movs	r1, #146	; 0x92
    99a8:	4807      	ldr	r0, [pc, #28]	; (99c8 <HAL_NVIC_SetPriorityGrouping+0x2c>)
    99aa:	f00f fd89 	bl	194c0 <assert_failed>
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    99ae:	4907      	ldr	r1, [pc, #28]	; (99cc <HAL_NVIC_SetPriorityGrouping+0x30>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
    99b0:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
    99b4:	0224      	lsls	r4, r4, #8
    99b6:	4b06      	ldr	r3, [pc, #24]	; (99d0 <HAL_NVIC_SetPriorityGrouping+0x34>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
    99b8:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
    99ba:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
    99be:	4002      	ands	r2, r0
    99c0:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
    99c2:	431c      	orrs	r4, r3
  SCB->AIRCR =  reg_value;
    99c4:	60cc      	str	r4, [r1, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
    99c6:	bd10      	pop	{r4, pc}
    99c8:	0002ff50 	.word	0x0002ff50
    99cc:	e000ed00 	.word	0xe000ed00
    99d0:	05fa0000 	.word	0x05fa0000

000099d4 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    99d4:	2a0f      	cmp	r2, #15
{
    99d6:	b570      	push	{r4, r5, r6, lr}
    99d8:	4616      	mov	r6, r2
    99da:	4605      	mov	r5, r0
    99dc:	460c      	mov	r4, r1
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    99de:	d832      	bhi.n	9a46 <HAL_NVIC_SetPriority+0x72>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    99e0:	2c0f      	cmp	r4, #15
    99e2:	d82b      	bhi.n	9a3c <HAL_NVIC_SetPriority+0x68>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
    99e4:	4b1a      	ldr	r3, [pc, #104]	; (9a50 <HAL_NVIC_SetPriority+0x7c>)
    99e6:	68db      	ldr	r3, [r3, #12]
    99e8:	f3c3 2302 	ubfx	r3, r3, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
    99ec:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    99f0:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
    99f2:	2904      	cmp	r1, #4
    99f4:	bf28      	it	cs
    99f6:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    99f8:	2a06      	cmp	r2, #6
    99fa:	d917      	bls.n	9a2c <HAL_NVIC_SetPriority+0x58>
    99fc:	3b03      	subs	r3, #3
    99fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9a02:	409a      	lsls	r2, r3
    9a04:	ea26 0602 	bic.w	r6, r6, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
    9a08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
    9a0c:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
    9a0e:	fa02 f201 	lsl.w	r2, r2, r1
    9a12:	ea24 0202 	bic.w	r2, r4, r2
    9a16:	fa02 f203 	lsl.w	r2, r2, r3
    9a1a:	ea42 0206 	orr.w	r2, r2, r6
    9a1e:	ea4f 1202 	mov.w	r2, r2, lsl #4
    9a22:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
    9a24:	db05      	blt.n	9a32 <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9a26:	4b0b      	ldr	r3, [pc, #44]	; (9a54 <HAL_NVIC_SetPriority+0x80>)
    9a28:	555a      	strb	r2, [r3, r5]

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
    9a2a:	bd70      	pop	{r4, r5, r6, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
    9a2c:	2600      	movs	r6, #0
    9a2e:	4633      	mov	r3, r6
    9a30:	e7ea      	b.n	9a08 <HAL_NVIC_SetPriority+0x34>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9a32:	f005 050f 	and.w	r5, r5, #15
    9a36:	4b08      	ldr	r3, [pc, #32]	; (9a58 <HAL_NVIC_SetPriority+0x84>)
    9a38:	555a      	strb	r2, [r3, r5]
    9a3a:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    9a3c:	21ab      	movs	r1, #171	; 0xab
    9a3e:	4807      	ldr	r0, [pc, #28]	; (9a5c <HAL_NVIC_SetPriority+0x88>)
    9a40:	f00f fd3e 	bl	194c0 <assert_failed>
    9a44:	e7ce      	b.n	99e4 <HAL_NVIC_SetPriority+0x10>
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
    9a46:	21aa      	movs	r1, #170	; 0xaa
    9a48:	4804      	ldr	r0, [pc, #16]	; (9a5c <HAL_NVIC_SetPriority+0x88>)
    9a4a:	f00f fd39 	bl	194c0 <assert_failed>
    9a4e:	e7c7      	b.n	99e0 <HAL_NVIC_SetPriority+0xc>
    9a50:	e000ed00 	.word	0xe000ed00
    9a54:	e000e400 	.word	0xe000e400
    9a58:	e000ed14 	.word	0xe000ed14
    9a5c:	0002ff50 	.word	0x0002ff50

00009a60 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9a60:	2800      	cmp	r0, #0
    9a62:	db08      	blt.n	9a76 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9a64:	f000 011f 	and.w	r1, r0, #31
    9a68:	2301      	movs	r3, #1
    9a6a:	0940      	lsrs	r0, r0, #5
    9a6c:	4a04      	ldr	r2, [pc, #16]	; (9a80 <HAL_NVIC_EnableIRQ+0x20>)
    9a6e:	408b      	lsls	r3, r1
    9a70:	f842 3020 	str.w	r3, [r2, r0, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
    9a74:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9a76:	21be      	movs	r1, #190	; 0xbe
    9a78:	4802      	ldr	r0, [pc, #8]	; (9a84 <HAL_NVIC_EnableIRQ+0x24>)
    9a7a:	f00f bd21 	b.w	194c0 <assert_failed>
    9a7e:	bf00      	nop
    9a80:	e000e100 	.word	0xe000e100
    9a84:	0002ff50 	.word	0x0002ff50

00009a88 <HAL_NVIC_DisableIRQ>:
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9a88:	2800      	cmp	r0, #0
    9a8a:	db0e      	blt.n	9aaa <HAL_NVIC_DisableIRQ+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9a8c:	0943      	lsrs	r3, r0, #5
    9a8e:	2201      	movs	r2, #1
    9a90:	f000 001f 	and.w	r0, r0, #31
    9a94:	4907      	ldr	r1, [pc, #28]	; (9ab4 <HAL_NVIC_DisableIRQ+0x2c>)
    9a96:	3320      	adds	r3, #32
    9a98:	fa02 f000 	lsl.w	r0, r2, r0
    9a9c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    9aa0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9aa4:	f3bf 8f6f 	isb	sy

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
    9aa8:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    9aaa:	21ce      	movs	r1, #206	; 0xce
    9aac:	4802      	ldr	r0, [pc, #8]	; (9ab8 <HAL_NVIC_DisableIRQ+0x30>)
    9aae:	f00f bd07 	b.w	194c0 <assert_failed>
    9ab2:	bf00      	nop
    9ab4:	e000e100 	.word	0xe000e100
    9ab8:	0002ff50 	.word	0x0002ff50

00009abc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    9abc:	3801      	subs	r0, #1
    9abe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    9ac2:	d20d      	bcs.n	9ae0 <HAL_SYSTICK_Config+0x24>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9ac4:	4b07      	ldr	r3, [pc, #28]	; (9ae4 <HAL_SYSTICK_Config+0x28>)
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9ac6:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9ac8:	2107      	movs	r1, #7
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
    9aca:	b430      	push	{r4, r5}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9acc:	25f0      	movs	r5, #240	; 0xf0
    9ace:	4c06      	ldr	r4, [pc, #24]	; (9ae8 <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9ad0:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
    9ad2:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9ad4:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9ad8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9ada:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
    9adc:	bc30      	pop	{r4, r5}
    9ade:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
    9ae0:	2001      	movs	r0, #1
    9ae2:	4770      	bx	lr
    9ae4:	e000e010 	.word	0xe000e010
    9ae8:	e000ed00 	.word	0xe000ed00

00009aec <HAL_MPU_Disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    9aec:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9af0:	4a04      	ldr	r2, [pc, #16]	; (9b04 <HAL_MPU_Disable+0x18>)

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
    9af2:	2000      	movs	r0, #0
    9af4:	4904      	ldr	r1, [pc, #16]	; (9b08 <HAL_MPU_Disable+0x1c>)
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
    9af6:	6a53      	ldr	r3, [r2, #36]	; 0x24
    9af8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    9afc:	6253      	str	r3, [r2, #36]	; 0x24
  MPU->CTRL = 0;
    9afe:	6048      	str	r0, [r1, #4]
}
    9b00:	4770      	bx	lr
    9b02:	bf00      	nop
    9b04:	e000ed00 	.word	0xe000ed00
    9b08:	e000ed90 	.word	0xe000ed90

00009b0c <HAL_MPU_Enable>:
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9b0c:	4a06      	ldr	r2, [pc, #24]	; (9b28 <HAL_MPU_Enable+0x1c>)
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
    9b0e:	f040 0001 	orr.w	r0, r0, #1
    9b12:	4b06      	ldr	r3, [pc, #24]	; (9b2c <HAL_MPU_Enable+0x20>)
    9b14:	6058      	str	r0, [r3, #4]
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
    9b16:	6a53      	ldr	r3, [r2, #36]	; 0x24
    9b18:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    9b1c:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
    9b1e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9b22:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
    9b26:	4770      	bx	lr
    9b28:	e000ed00 	.word	0xe000ed00
    9b2c:	e000ed90 	.word	0xe000ed90

00009b30 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
    9b30:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9b32:	7843      	ldrb	r3, [r0, #1]
{
    9b34:	4604      	mov	r4, r0
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9b36:	2b0f      	cmp	r3, #15
    9b38:	d86f      	bhi.n	9c1a <HAL_MPU_ConfigRegion+0xea>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
    9b3a:	7823      	ldrb	r3, [r4, #0]
    9b3c:	2b01      	cmp	r3, #1
    9b3e:	d904      	bls.n	9b4a <HAL_MPU_ConfigRegion+0x1a>
    9b40:	f44f 7197 	mov.w	r1, #302	; 0x12e
    9b44:	4849      	ldr	r0, [pc, #292]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9b46:	f00f fcbb 	bl	194c0 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
    9b4a:	7862      	ldrb	r2, [r4, #1]
    9b4c:	4b48      	ldr	r3, [pc, #288]	; (9c70 <HAL_MPU_ConfigRegion+0x140>)
    9b4e:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
    9b50:	7822      	ldrb	r2, [r4, #0]
    9b52:	2a00      	cmp	r2, #0
    9b54:	d039      	beq.n	9bca <HAL_MPU_ConfigRegion+0x9a>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    9b56:	7b23      	ldrb	r3, [r4, #12]
    9b58:	2b01      	cmp	r3, #1
    9b5a:	d839      	bhi.n	9bd0 <HAL_MPU_ConfigRegion+0xa0>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9b5c:	7ae3      	ldrb	r3, [r4, #11]
    9b5e:	1f5a      	subs	r2, r3, #5
    9b60:	2a01      	cmp	r2, #1
    9b62:	d901      	bls.n	9b68 <HAL_MPU_ConfigRegion+0x38>
    9b64:	2b03      	cmp	r3, #3
    9b66:	d86d      	bhi.n	9c44 <HAL_MPU_ConfigRegion+0x114>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9b68:	7aa3      	ldrb	r3, [r4, #10]
    9b6a:	2b02      	cmp	r3, #2
    9b6c:	d861      	bhi.n	9c32 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9b6e:	7b63      	ldrb	r3, [r4, #13]
    9b70:	2b01      	cmp	r3, #1
    9b72:	d849      	bhi.n	9c08 <HAL_MPU_ConfigRegion+0xd8>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9b74:	7ba3      	ldrb	r3, [r4, #14]
    9b76:	2b01      	cmp	r3, #1
    9b78:	d83d      	bhi.n	9bf6 <HAL_MPU_ConfigRegion+0xc6>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9b7a:	7be3      	ldrb	r3, [r4, #15]
    9b7c:	2b01      	cmp	r3, #1
    9b7e:	d831      	bhi.n	9be4 <HAL_MPU_ConfigRegion+0xb4>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9b80:	7a63      	ldrb	r3, [r4, #9]
    9b82:	2bff      	cmp	r3, #255	; 0xff
    9b84:	d067      	beq.n	9c56 <HAL_MPU_ConfigRegion+0x126>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9b86:	7a23      	ldrb	r3, [r4, #8]
    9b88:	3b04      	subs	r3, #4
    9b8a:	2b1b      	cmp	r3, #27
    9b8c:	d84b      	bhi.n	9c26 <HAL_MPU_ConfigRegion+0xf6>

    MPU->RBAR = MPU_Init->BaseAddress;
    9b8e:	6863      	ldr	r3, [r4, #4]
    9b90:	4a37      	ldr	r2, [pc, #220]	; (9c70 <HAL_MPU_ConfigRegion+0x140>)
    9b92:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    9b94:	7ae3      	ldrb	r3, [r4, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9b96:	7b21      	ldrb	r1, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    9b98:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
    9b9a:	7825      	ldrb	r5, [r4, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
    9b9c:	7aa0      	ldrb	r0, [r4, #10]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9b9e:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
    9ba2:	7b61      	ldrb	r1, [r4, #13]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
    9ba4:	7ba6      	ldrb	r6, [r4, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9ba6:	432b      	orrs	r3, r5
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
    9ba8:	7be5      	ldrb	r5, [r4, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9baa:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
    9bae:	7a60      	ldrb	r0, [r4, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    9bb0:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
    9bb4:	7a21      	ldrb	r1, [r4, #8]
    9bb6:	ea43 4346 	orr.w	r3, r3, r6, lsl #17
    9bba:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
    9bbe:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    9bc2:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    9bc6:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
    9bc8:	bd70      	pop	{r4, r5, r6, pc}
    MPU->RBAR = 0x00;
    9bca:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
    9bcc:	611a      	str	r2, [r3, #16]
}
    9bce:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    9bd0:	f44f 719b 	mov.w	r1, #310	; 0x136
    9bd4:	4825      	ldr	r0, [pc, #148]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9bd6:	f00f fc73 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9bda:	7ae3      	ldrb	r3, [r4, #11]
    9bdc:	1f5a      	subs	r2, r3, #5
    9bde:	2a01      	cmp	r2, #1
    9be0:	d8c0      	bhi.n	9b64 <HAL_MPU_ConfigRegion+0x34>
    9be2:	e7c1      	b.n	9b68 <HAL_MPU_ConfigRegion+0x38>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9be4:	f240 113b 	movw	r1, #315	; 0x13b
    9be8:	4820      	ldr	r0, [pc, #128]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9bea:	f00f fc69 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9bee:	7a63      	ldrb	r3, [r4, #9]
    9bf0:	2bff      	cmp	r3, #255	; 0xff
    9bf2:	d1c8      	bne.n	9b86 <HAL_MPU_ConfigRegion+0x56>
    9bf4:	e02f      	b.n	9c56 <HAL_MPU_ConfigRegion+0x126>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9bf6:	f44f 719d 	mov.w	r1, #314	; 0x13a
    9bfa:	481c      	ldr	r0, [pc, #112]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9bfc:	f00f fc60 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    9c00:	7be3      	ldrb	r3, [r4, #15]
    9c02:	2b01      	cmp	r3, #1
    9c04:	d9bc      	bls.n	9b80 <HAL_MPU_ConfigRegion+0x50>
    9c06:	e7ed      	b.n	9be4 <HAL_MPU_ConfigRegion+0xb4>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9c08:	f240 1139 	movw	r1, #313	; 0x139
    9c0c:	4817      	ldr	r0, [pc, #92]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c0e:	f00f fc57 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    9c12:	7ba3      	ldrb	r3, [r4, #14]
    9c14:	2b01      	cmp	r3, #1
    9c16:	d9b0      	bls.n	9b7a <HAL_MPU_ConfigRegion+0x4a>
    9c18:	e7ed      	b.n	9bf6 <HAL_MPU_ConfigRegion+0xc6>
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    9c1a:	f240 112d 	movw	r1, #301	; 0x12d
    9c1e:	4813      	ldr	r0, [pc, #76]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c20:	f00f fc4e 	bl	194c0 <assert_failed>
    9c24:	e789      	b.n	9b3a <HAL_MPU_ConfigRegion+0xa>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9c26:	f240 113d 	movw	r1, #317	; 0x13d
    9c2a:	4810      	ldr	r0, [pc, #64]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c2c:	f00f fc48 	bl	194c0 <assert_failed>
    9c30:	e7ad      	b.n	9b8e <HAL_MPU_ConfigRegion+0x5e>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9c32:	f44f 719c 	mov.w	r1, #312	; 0x138
    9c36:	480d      	ldr	r0, [pc, #52]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c38:	f00f fc42 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    9c3c:	7b63      	ldrb	r3, [r4, #13]
    9c3e:	2b01      	cmp	r3, #1
    9c40:	d998      	bls.n	9b74 <HAL_MPU_ConfigRegion+0x44>
    9c42:	e7e1      	b.n	9c08 <HAL_MPU_ConfigRegion+0xd8>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    9c44:	f240 1137 	movw	r1, #311	; 0x137
    9c48:	4808      	ldr	r0, [pc, #32]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c4a:	f00f fc39 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    9c4e:	7aa3      	ldrb	r3, [r4, #10]
    9c50:	2b02      	cmp	r3, #2
    9c52:	d98c      	bls.n	9b6e <HAL_MPU_ConfigRegion+0x3e>
    9c54:	e7ed      	b.n	9c32 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    9c56:	f44f 719e 	mov.w	r1, #316	; 0x13c
    9c5a:	4804      	ldr	r0, [pc, #16]	; (9c6c <HAL_MPU_ConfigRegion+0x13c>)
    9c5c:	f00f fc30 	bl	194c0 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    9c60:	7a23      	ldrb	r3, [r4, #8]
    9c62:	3b04      	subs	r3, #4
    9c64:	2b1b      	cmp	r3, #27
    9c66:	d992      	bls.n	9b8e <HAL_MPU_ConfigRegion+0x5e>
    9c68:	e7dd      	b.n	9c26 <HAL_MPU_ConfigRegion+0xf6>
    9c6a:	bf00      	nop
    9c6c:	0002ff50 	.word	0x0002ff50
    9c70:	e000ed90 	.word	0xe000ed90

00009c74 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9c74:	4b35      	ldr	r3, [pc, #212]	; (9d4c <DMA_CalcBaseAndBitshift+0xd8>)
{
    9c76:	4601      	mov	r1, r0
    9c78:	b430      	push	{r4, r5}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9c7a:	4c35      	ldr	r4, [pc, #212]	; (9d50 <DMA_CalcBaseAndBitshift+0xdc>)
    9c7c:	6802      	ldr	r2, [r0, #0]
    9c7e:	4835      	ldr	r0, [pc, #212]	; (9d54 <DMA_CalcBaseAndBitshift+0xe0>)
    9c80:	42a2      	cmp	r2, r4
    9c82:	bf18      	it	ne
    9c84:	429a      	cmpne	r2, r3
    9c86:	4d34      	ldr	r5, [pc, #208]	; (9d58 <DMA_CalcBaseAndBitshift+0xe4>)
    9c88:	f104 0448 	add.w	r4, r4, #72	; 0x48
    9c8c:	bf0c      	ite	eq
    9c8e:	2301      	moveq	r3, #1
    9c90:	2300      	movne	r3, #0
    9c92:	4282      	cmp	r2, r0
    9c94:	bf08      	it	eq
    9c96:	f043 0301 	orreq.w	r3, r3, #1
    9c9a:	3048      	adds	r0, #72	; 0x48
    9c9c:	42aa      	cmp	r2, r5
    9c9e:	bf08      	it	eq
    9ca0:	f043 0301 	orreq.w	r3, r3, #1
    9ca4:	3548      	adds	r5, #72	; 0x48
    9ca6:	42a2      	cmp	r2, r4
    9ca8:	bf08      	it	eq
    9caa:	f043 0301 	orreq.w	r3, r3, #1
    9cae:	3448      	adds	r4, #72	; 0x48
    9cb0:	4282      	cmp	r2, r0
    9cb2:	bf08      	it	eq
    9cb4:	f043 0301 	orreq.w	r3, r3, #1
    9cb8:	f500 7062 	add.w	r0, r0, #904	; 0x388
    9cbc:	42aa      	cmp	r2, r5
    9cbe:	bf08      	it	eq
    9cc0:	f043 0301 	orreq.w	r3, r3, #1
    9cc4:	f505 7562 	add.w	r5, r5, #904	; 0x388
    9cc8:	42a2      	cmp	r2, r4
    9cca:	bf08      	it	eq
    9ccc:	f043 0301 	orreq.w	r3, r3, #1
    9cd0:	f504 7462 	add.w	r4, r4, #904	; 0x388
    9cd4:	4282      	cmp	r2, r0
    9cd6:	bf08      	it	eq
    9cd8:	f043 0301 	orreq.w	r3, r3, #1
    9cdc:	3048      	adds	r0, #72	; 0x48
    9cde:	42aa      	cmp	r2, r5
    9ce0:	bf08      	it	eq
    9ce2:	f043 0301 	orreq.w	r3, r3, #1
    9ce6:	3548      	adds	r5, #72	; 0x48
    9ce8:	42a2      	cmp	r2, r4
    9cea:	bf08      	it	eq
    9cec:	f043 0301 	orreq.w	r3, r3, #1
    9cf0:	3448      	adds	r4, #72	; 0x48
    9cf2:	4282      	cmp	r2, r0
    9cf4:	bf08      	it	eq
    9cf6:	f043 0301 	orreq.w	r3, r3, #1
    9cfa:	3048      	adds	r0, #72	; 0x48
    9cfc:	42aa      	cmp	r2, r5
    9cfe:	bf08      	it	eq
    9d00:	f043 0301 	orreq.w	r3, r3, #1
    9d04:	42a2      	cmp	r2, r4
    9d06:	bf08      	it	eq
    9d08:	f043 0301 	orreq.w	r3, r3, #1
    9d0c:	4282      	cmp	r2, r0
    9d0e:	bf08      	it	eq
    9d10:	f043 0301 	orreq.w	r3, r3, #1
    9d14:	b913      	cbnz	r3, 9d1c <DMA_CalcBaseAndBitshift+0xa8>
    9d16:	4b11      	ldr	r3, [pc, #68]	; (9d5c <DMA_CalcBaseAndBitshift+0xe8>)
    9d18:	429a      	cmp	r2, r3
    9d1a:	d112      	bne.n	9d42 <DMA_CalcBaseAndBitshift+0xce>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    9d1c:	b2d3      	uxtb	r3, r2
    9d1e:	4d10      	ldr	r5, [pc, #64]	; (9d60 <DMA_CalcBaseAndBitshift+0xec>)
    9d20:	4810      	ldr	r0, [pc, #64]	; (9d64 <DMA_CalcBaseAndBitshift+0xf0>)
    9d22:	3b10      	subs	r3, #16

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d24:	4c10      	ldr	r4, [pc, #64]	; (9d68 <DMA_CalcBaseAndBitshift+0xf4>)
    9d26:	4010      	ands	r0, r2
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    9d28:	fba5 5303 	umull	r5, r3, r5, r3
    9d2c:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d2e:	f003 0207 	and.w	r2, r3, #7

    if (stream_number > 3U)
    9d32:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d34:	5ca2      	ldrb	r2, [r4, r2]
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
    9d36:	bf88      	it	hi
    9d38:	3004      	addhi	r0, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    9d3a:	65ca      	str	r2, [r1, #92]	; 0x5c
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
    9d3c:	6588      	str	r0, [r1, #88]	; 0x58
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
  }

  return hdma->StreamBaseAddress;
}
    9d3e:	bc30      	pop	{r4, r5}
    9d40:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
    9d42:	f022 00ff 	bic.w	r0, r2, #255	; 0xff
    9d46:	6588      	str	r0, [r1, #88]	; 0x58
    9d48:	e7f9      	b.n	9d3e <DMA_CalcBaseAndBitshift+0xca>
    9d4a:	bf00      	nop
    9d4c:	40020010 	.word	0x40020010
    9d50:	40020028 	.word	0x40020028
    9d54:	40020040 	.word	0x40020040
    9d58:	40020058 	.word	0x40020058
    9d5c:	400204b8 	.word	0x400204b8
    9d60:	aaaaaaab 	.word	0xaaaaaaab
    9d64:	fffffc00 	.word	0xfffffc00
    9d68:	0002ffc4 	.word	0x0002ffc4

00009d6c <HAL_DMA_Init>:
{
    9d6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9d70:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
    9d72:	f7fe fb3f 	bl	83f4 <HAL_GetTick>
  if(hdma == NULL)
    9d76:	2d00      	cmp	r5, #0
    9d78:	f000 82ba 	beq.w	a2f0 <HAL_DMA_Init+0x584>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    9d7c:	682a      	ldr	r2, [r5, #0]
    9d7e:	4604      	mov	r4, r0
    9d80:	4b9e      	ldr	r3, [pc, #632]	; (9ffc <HAL_DMA_Init+0x290>)
    9d82:	489f      	ldr	r0, [pc, #636]	; (a000 <HAL_DMA_Init+0x294>)
    9d84:	499f      	ldr	r1, [pc, #636]	; (a004 <HAL_DMA_Init+0x298>)
    9d86:	429a      	cmp	r2, r3
    9d88:	bf18      	it	ne
    9d8a:	4282      	cmpne	r2, r0
    9d8c:	f100 0030 	add.w	r0, r0, #48	; 0x30
    9d90:	bf14      	ite	ne
    9d92:	2301      	movne	r3, #1
    9d94:	2300      	moveq	r3, #0
    9d96:	428a      	cmp	r2, r1
    9d98:	bf0c      	ite	eq
    9d9a:	2300      	moveq	r3, #0
    9d9c:	f003 0301 	andne.w	r3, r3, #1
    9da0:	3130      	adds	r1, #48	; 0x30
    9da2:	4282      	cmp	r2, r0
    9da4:	bf0c      	ite	eq
    9da6:	2300      	moveq	r3, #0
    9da8:	f003 0301 	andne.w	r3, r3, #1
    9dac:	3030      	adds	r0, #48	; 0x30
    9dae:	428a      	cmp	r2, r1
    9db0:	bf0c      	ite	eq
    9db2:	2300      	moveq	r3, #0
    9db4:	f003 0301 	andne.w	r3, r3, #1
    9db8:	3130      	adds	r1, #48	; 0x30
    9dba:	4282      	cmp	r2, r0
    9dbc:	bf0c      	ite	eq
    9dbe:	2300      	moveq	r3, #0
    9dc0:	f003 0301 	andne.w	r3, r3, #1
    9dc4:	3030      	adds	r0, #48	; 0x30
    9dc6:	428a      	cmp	r2, r1
    9dc8:	bf0c      	ite	eq
    9dca:	2300      	moveq	r3, #0
    9dcc:	f003 0301 	andne.w	r3, r3, #1
    9dd0:	f501 715c 	add.w	r1, r1, #880	; 0x370
    9dd4:	4282      	cmp	r2, r0
    9dd6:	bf0c      	ite	eq
    9dd8:	2300      	moveq	r3, #0
    9dda:	f003 0301 	andne.w	r3, r3, #1
    9dde:	f500 705c 	add.w	r0, r0, #880	; 0x370
    9de2:	428a      	cmp	r2, r1
    9de4:	bf0c      	ite	eq
    9de6:	2300      	moveq	r3, #0
    9de8:	f003 0301 	andne.w	r3, r3, #1
    9dec:	3130      	adds	r1, #48	; 0x30
    9dee:	4282      	cmp	r2, r0
    9df0:	bf0c      	ite	eq
    9df2:	2300      	moveq	r3, #0
    9df4:	f003 0301 	andne.w	r3, r3, #1
    9df8:	3030      	adds	r0, #48	; 0x30
    9dfa:	428a      	cmp	r2, r1
    9dfc:	bf0c      	ite	eq
    9dfe:	2300      	moveq	r3, #0
    9e00:	f003 0301 	andne.w	r3, r3, #1
    9e04:	3130      	adds	r1, #48	; 0x30
    9e06:	4282      	cmp	r2, r0
    9e08:	bf0c      	ite	eq
    9e0a:	2300      	moveq	r3, #0
    9e0c:	f003 0301 	andne.w	r3, r3, #1
    9e10:	3030      	adds	r0, #48	; 0x30
    9e12:	428a      	cmp	r2, r1
    9e14:	bf0c      	ite	eq
    9e16:	2300      	moveq	r3, #0
    9e18:	f003 0301 	andne.w	r3, r3, #1
    9e1c:	3130      	adds	r1, #48	; 0x30
    9e1e:	4282      	cmp	r2, r0
    9e20:	bf0c      	ite	eq
    9e22:	2300      	moveq	r3, #0
    9e24:	f003 0301 	andne.w	r3, r3, #1
    9e28:	3030      	adds	r0, #48	; 0x30
    9e2a:	428a      	cmp	r2, r1
    9e2c:	bf0c      	ite	eq
    9e2e:	2300      	moveq	r3, #0
    9e30:	f003 0301 	andne.w	r3, r3, #1
    9e34:	4974      	ldr	r1, [pc, #464]	; (a008 <HAL_DMA_Init+0x29c>)
    9e36:	4282      	cmp	r2, r0
    9e38:	bf0c      	ite	eq
    9e3a:	2300      	moveq	r3, #0
    9e3c:	f003 0301 	andne.w	r3, r3, #1
    9e40:	4872      	ldr	r0, [pc, #456]	; (a00c <HAL_DMA_Init+0x2a0>)
    9e42:	428a      	cmp	r2, r1
    9e44:	bf0c      	ite	eq
    9e46:	2300      	moveq	r3, #0
    9e48:	f003 0301 	andne.w	r3, r3, #1
    9e4c:	3128      	adds	r1, #40	; 0x28
    9e4e:	4282      	cmp	r2, r0
    9e50:	bf0c      	ite	eq
    9e52:	2300      	moveq	r3, #0
    9e54:	f003 0301 	andne.w	r3, r3, #1
    9e58:	3028      	adds	r0, #40	; 0x28
    9e5a:	428a      	cmp	r2, r1
    9e5c:	bf0c      	ite	eq
    9e5e:	2300      	moveq	r3, #0
    9e60:	f003 0301 	andne.w	r3, r3, #1
    9e64:	3128      	adds	r1, #40	; 0x28
    9e66:	4282      	cmp	r2, r0
    9e68:	bf0c      	ite	eq
    9e6a:	2300      	moveq	r3, #0
    9e6c:	f003 0301 	andne.w	r3, r3, #1
    9e70:	3028      	adds	r0, #40	; 0x28
    9e72:	428a      	cmp	r2, r1
    9e74:	bf0c      	ite	eq
    9e76:	2300      	moveq	r3, #0
    9e78:	f003 0301 	andne.w	r3, r3, #1
    9e7c:	3128      	adds	r1, #40	; 0x28
    9e7e:	4282      	cmp	r2, r0
    9e80:	bf0c      	ite	eq
    9e82:	2300      	moveq	r3, #0
    9e84:	f003 0301 	andne.w	r3, r3, #1
    9e88:	428a      	cmp	r2, r1
    9e8a:	bf0c      	ite	eq
    9e8c:	2300      	moveq	r3, #0
    9e8e:	f003 0301 	andne.w	r3, r3, #1
    9e92:	b11b      	cbz	r3, 9e9c <HAL_DMA_Init+0x130>
    9e94:	4b5e      	ldr	r3, [pc, #376]	; (a010 <HAL_DMA_Init+0x2a4>)
    9e96:	429a      	cmp	r2, r3
    9e98:	f040 836b 	bne.w	a572 <HAL_DMA_Init+0x806>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    9e9c:	68ab      	ldr	r3, [r5, #8]
    9e9e:	f033 0240 	bics.w	r2, r3, #64	; 0x40
    9ea2:	d002      	beq.n	9eaa <HAL_DMA_Init+0x13e>
    9ea4:	2b80      	cmp	r3, #128	; 0x80
    9ea6:	f040 8226 	bne.w	a2f6 <HAL_DMA_Init+0x58a>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    9eaa:	68eb      	ldr	r3, [r5, #12]
    9eac:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    9eb0:	f040 8114 	bne.w	a0dc <HAL_DMA_Init+0x370>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    9eb4:	692b      	ldr	r3, [r5, #16]
    9eb6:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
    9eba:	f040 8105 	bne.w	a0c8 <HAL_DMA_Init+0x35c>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    9ebe:	696b      	ldr	r3, [r5, #20]
    9ec0:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
    9ec4:	d003      	beq.n	9ece <HAL_DMA_Init+0x162>
    9ec6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    9eca:	f040 821e 	bne.w	a30a <HAL_DMA_Init+0x59e>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    9ece:	69ab      	ldr	r3, [r5, #24]
    9ed0:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
    9ed4:	d003      	beq.n	9ede <HAL_DMA_Init+0x172>
    9ed6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    9eda:	f040 8220 	bne.w	a31e <HAL_DMA_Init+0x5b2>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
    9ede:	69ea      	ldr	r2, [r5, #28]
    9ee0:	f032 0320 	bics.w	r3, r2, #32
    9ee4:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
    9ee8:	bf14      	ite	ne
    9eea:	2301      	movne	r3, #1
    9eec:	2300      	moveq	r3, #0
    9eee:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
    9ef2:	bf0c      	ite	eq
    9ef4:	2300      	moveq	r3, #0
    9ef6:	f003 0301 	andne.w	r3, r3, #1
    9efa:	b11b      	cbz	r3, 9f04 <HAL_DMA_Init+0x198>
    9efc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    9f00:	f040 8212 	bne.w	a328 <HAL_DMA_Init+0x5bc>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    9f04:	6a2b      	ldr	r3, [r5, #32]
    9f06:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
    9f0a:	f040 824e 	bne.w	a3aa <HAL_DMA_Init+0x63e>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    9f0e:	682a      	ldr	r2, [r5, #0]
    9f10:	4b3a      	ldr	r3, [pc, #232]	; (9ffc <HAL_DMA_Init+0x290>)
    9f12:	483b      	ldr	r0, [pc, #236]	; (a000 <HAL_DMA_Init+0x294>)
    9f14:	493b      	ldr	r1, [pc, #236]	; (a004 <HAL_DMA_Init+0x298>)
    9f16:	4282      	cmp	r2, r0
    9f18:	bf18      	it	ne
    9f1a:	429a      	cmpne	r2, r3
    9f1c:	f100 0030 	add.w	r0, r0, #48	; 0x30
    9f20:	bf0c      	ite	eq
    9f22:	2301      	moveq	r3, #1
    9f24:	2300      	movne	r3, #0
    9f26:	428a      	cmp	r2, r1
    9f28:	bf08      	it	eq
    9f2a:	f043 0301 	orreq.w	r3, r3, #1
    9f2e:	3130      	adds	r1, #48	; 0x30
    9f30:	4282      	cmp	r2, r0
    9f32:	bf08      	it	eq
    9f34:	f043 0301 	orreq.w	r3, r3, #1
    9f38:	3030      	adds	r0, #48	; 0x30
    9f3a:	428a      	cmp	r2, r1
    9f3c:	bf08      	it	eq
    9f3e:	f043 0301 	orreq.w	r3, r3, #1
    9f42:	3130      	adds	r1, #48	; 0x30
    9f44:	4282      	cmp	r2, r0
    9f46:	bf08      	it	eq
    9f48:	f043 0301 	orreq.w	r3, r3, #1
    9f4c:	3030      	adds	r0, #48	; 0x30
    9f4e:	428a      	cmp	r2, r1
    9f50:	bf08      	it	eq
    9f52:	f043 0301 	orreq.w	r3, r3, #1
    9f56:	f501 715c 	add.w	r1, r1, #880	; 0x370
    9f5a:	4282      	cmp	r2, r0
    9f5c:	bf08      	it	eq
    9f5e:	f043 0301 	orreq.w	r3, r3, #1
    9f62:	f500 705c 	add.w	r0, r0, #880	; 0x370
    9f66:	428a      	cmp	r2, r1
    9f68:	bf08      	it	eq
    9f6a:	f043 0301 	orreq.w	r3, r3, #1
    9f6e:	3130      	adds	r1, #48	; 0x30
    9f70:	4282      	cmp	r2, r0
    9f72:	bf08      	it	eq
    9f74:	f043 0301 	orreq.w	r3, r3, #1
    9f78:	3030      	adds	r0, #48	; 0x30
    9f7a:	428a      	cmp	r2, r1
    9f7c:	bf08      	it	eq
    9f7e:	f043 0301 	orreq.w	r3, r3, #1
    9f82:	3130      	adds	r1, #48	; 0x30
    9f84:	4282      	cmp	r2, r0
    9f86:	bf08      	it	eq
    9f88:	f043 0301 	orreq.w	r3, r3, #1
    9f8c:	3030      	adds	r0, #48	; 0x30
    9f8e:	428a      	cmp	r2, r1
    9f90:	bf08      	it	eq
    9f92:	f043 0301 	orreq.w	r3, r3, #1
    9f96:	3130      	adds	r1, #48	; 0x30
    9f98:	4282      	cmp	r2, r0
    9f9a:	bf08      	it	eq
    9f9c:	f043 0301 	orreq.w	r3, r3, #1
    9fa0:	428a      	cmp	r2, r1
    9fa2:	bf08      	it	eq
    9fa4:	f043 0301 	orreq.w	r3, r3, #1
    9fa8:	b91b      	cbnz	r3, 9fb2 <HAL_DMA_Init+0x246>
    9faa:	4b1a      	ldr	r3, [pc, #104]	; (a014 <HAL_DMA_Init+0x2a8>)
    9fac:	429a      	cmp	r2, r3
    9fae:	f040 8259 	bne.w	a464 <HAL_DMA_Init+0x6f8>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
    9fb2:	686b      	ldr	r3, [r5, #4]
    9fb4:	2b73      	cmp	r3, #115	; 0x73
    9fb6:	f200 809b 	bhi.w	a0f0 <HAL_DMA_Init+0x384>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    9fba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    9fbc:	f033 0204 	bics.w	r2, r3, #4
    9fc0:	f040 809f 	bne.w	a102 <HAL_DMA_Init+0x396>
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    9fc4:	b16b      	cbz	r3, 9fe2 <HAL_DMA_Init+0x276>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    9fc6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    9fc8:	2b03      	cmp	r3, #3
    9fca:	f200 81e9 	bhi.w	a3a0 <HAL_DMA_Init+0x634>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    9fce:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    9fd0:	f033 73c0 	bics.w	r3, r3, #25165824	; 0x1800000
    9fd4:	f040 822a 	bne.w	a42c <HAL_DMA_Init+0x6c0>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    9fd8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    9fda:	f433 03c0 	bics.w	r3, r3, #6291456	; 0x600000
    9fde:	f040 81a8 	bne.w	a332 <HAL_DMA_Init+0x5c6>
    __HAL_UNLOCK(hdma);
    9fe2:	2000      	movs	r0, #0
    __HAL_DMA_DISABLE(hdma);
    9fe4:	682a      	ldr	r2, [r5, #0]
    __HAL_UNLOCK(hdma);
    9fe6:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
    9fea:	2002      	movs	r0, #2
    9fec:	f885 0035 	strb.w	r0, [r5, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
    9ff0:	6813      	ldr	r3, [r2, #0]
    9ff2:	f023 0301 	bic.w	r3, r3, #1
    9ff6:	6013      	str	r3, [r2, #0]
    9ff8:	e014      	b.n	a024 <HAL_DMA_Init+0x2b8>
    9ffa:	bf00      	nop
    9ffc:	40020010 	.word	0x40020010
    a000:	40020028 	.word	0x40020028
    a004:	40020040 	.word	0x40020040
    a008:	58025408 	.word	0x58025408
    a00c:	5802541c 	.word	0x5802541c
    a010:	58025494 	.word	0x58025494
    a014:	400204b8 	.word	0x400204b8
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
    a018:	f7fe f9ec 	bl	83f4 <HAL_GetTick>
    a01c:	1b00      	subs	r0, r0, r4
    a01e:	2805      	cmp	r0, #5
    a020:	f200 815e 	bhi.w	a2e0 <HAL_DMA_Init+0x574>
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
    a024:	682b      	ldr	r3, [r5, #0]
    a026:	681a      	ldr	r2, [r3, #0]
    a028:	07d0      	lsls	r0, r2, #31
    a02a:	d4f5      	bmi.n	a018 <HAL_DMA_Init+0x2ac>
    registerValue |=  hdma->Init.Direction           |
    a02c:	e9d5 2002 	ldrd	r2, r0, [r5, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a030:	6929      	ldr	r1, [r5, #16]
    registerValue |=  hdma->Init.Direction           |
    a032:	4302      	orrs	r2, r0
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a034:	e9d5 4005 	ldrd	r4, r0, [r5, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a038:	430a      	orrs	r2, r1
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a03a:	69e9      	ldr	r1, [r5, #28]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    a03c:	4322      	orrs	r2, r4
            hdma->Init.Mode                | hdma->Init.Priority;
    a03e:	6a2c      	ldr	r4, [r5, #32]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a040:	4302      	orrs	r2, r0
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
    a042:	6818      	ldr	r0, [r3, #0]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    a044:	430a      	orrs	r2, r1
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    a046:	49bd      	ldr	r1, [pc, #756]	; (a33c <HAL_DMA_Init+0x5d0>)
    a048:	4001      	ands	r1, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a04a:	6a68      	ldr	r0, [r5, #36]	; 0x24
            hdma->Init.Mode                | hdma->Init.Priority;
    a04c:	4322      	orrs	r2, r4
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a04e:	2804      	cmp	r0, #4
    registerValue |=  hdma->Init.Direction           |
    a050:	ea42 0201 	orr.w	r2, r2, r1
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a054:	d103      	bne.n	a05e <HAL_DMA_Init+0x2f2>
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
    a056:	e9d5 100b 	ldrd	r1, r0, [r5, #44]	; 0x2c
    a05a:	4301      	orrs	r1, r0
    a05c:	430a      	orrs	r2, r1
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
    a05e:	48b8      	ldr	r0, [pc, #736]	; (a340 <HAL_DMA_Init+0x5d4>)
    a060:	49b8      	ldr	r1, [pc, #736]	; (a344 <HAL_DMA_Init+0x5d8>)
    a062:	6800      	ldr	r0, [r0, #0]
    a064:	4001      	ands	r1, r0
    a066:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    a06a:	d30a      	bcc.n	a082 <HAL_DMA_Init+0x316>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
    a06c:	6868      	ldr	r0, [r5, #4]
    a06e:	f1a0 0429 	sub.w	r4, r0, #41	; 0x29
    a072:	2c1f      	cmp	r4, #31
    a074:	f240 818c 	bls.w	a390 <HAL_DMA_Init+0x624>
    a078:	384f      	subs	r0, #79	; 0x4f
    a07a:	2803      	cmp	r0, #3
    a07c:	d801      	bhi.n	a082 <HAL_DMA_Init+0x316>
        registerValue |= DMA_SxCR_TRBUFF;
    a07e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
    a082:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
    a084:	6829      	ldr	r1, [r5, #0]
    registerValue |= hdma->Init.FIFOMode;
    a086:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
    a088:	694b      	ldr	r3, [r1, #20]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a08a:	2a04      	cmp	r2, #4
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    a08c:	f023 0307 	bic.w	r3, r3, #7
    registerValue |= hdma->Init.FIFOMode;
    a090:	ea43 0302 	orr.w	r3, r3, r2
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
    a094:	d144      	bne.n	a120 <HAL_DMA_Init+0x3b4>
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    a096:	e9d5 200a 	ldrd	r2, r0, [r5, #40]	; 0x28
      registerValue |= hdma->Init.FIFOThreshold;
    a09a:	4313      	orrs	r3, r2
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    a09c:	2800      	cmp	r0, #0
    a09e:	d03f      	beq.n	a120 <HAL_DMA_Init+0x3b4>
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
    a0a0:	69ac      	ldr	r4, [r5, #24]
    a0a2:	2c00      	cmp	r4, #0
    a0a4:	d036      	beq.n	a114 <HAL_DMA_Init+0x3a8>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
    a0a6:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
    a0aa:	f000 823e 	beq.w	a52a <HAL_DMA_Init+0x7be>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
    a0ae:	2a02      	cmp	r2, #2
    a0b0:	d903      	bls.n	a0ba <HAL_DMA_Init+0x34e>
    a0b2:	2a03      	cmp	r2, #3
    a0b4:	d134      	bne.n	a120 <HAL_DMA_Init+0x3b4>
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;

      case DMA_FIFO_THRESHOLD_FULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
    a0b6:	01c2      	lsls	r2, r0, #7
    a0b8:	d532      	bpl.n	a120 <HAL_DMA_Init+0x3b4>
          hdma->State = HAL_DMA_STATE_READY;
    a0ba:	2301      	movs	r3, #1
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a0bc:	2240      	movs	r2, #64	; 0x40
          return HAL_ERROR;
    a0be:	4618      	mov	r0, r3
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a0c0:	656a      	str	r2, [r5, #84]	; 0x54
          hdma->State = HAL_DMA_STATE_READY;
    a0c2:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
          return HAL_ERROR;
    a0c6:	e109      	b.n	a2dc <HAL_DMA_Init+0x570>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a0c8:	21e4      	movs	r1, #228	; 0xe4
    a0ca:	489f      	ldr	r0, [pc, #636]	; (a348 <HAL_DMA_Init+0x5dc>)
    a0cc:	f00f f9f8 	bl	194c0 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a0d0:	696b      	ldr	r3, [r5, #20]
    a0d2:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
    a0d6:	f47f aef6 	bne.w	9ec6 <HAL_DMA_Init+0x15a>
    a0da:	e6f8      	b.n	9ece <HAL_DMA_Init+0x162>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a0dc:	21e3      	movs	r1, #227	; 0xe3
    a0de:	489a      	ldr	r0, [pc, #616]	; (a348 <HAL_DMA_Init+0x5dc>)
    a0e0:	f00f f9ee 	bl	194c0 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    a0e4:	692b      	ldr	r3, [r5, #16]
    a0e6:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
    a0ea:	f43f aee8 	beq.w	9ebe <HAL_DMA_Init+0x152>
    a0ee:	e7eb      	b.n	a0c8 <HAL_DMA_Init+0x35c>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
    a0f0:	21ec      	movs	r1, #236	; 0xec
    a0f2:	4895      	ldr	r0, [pc, #596]	; (a348 <HAL_DMA_Init+0x5dc>)
    a0f4:	f00f f9e4 	bl	194c0 <assert_failed>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    a0f8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a0fa:	f033 0204 	bics.w	r2, r3, #4
    a0fe:	f43f af61 	beq.w	9fc4 <HAL_DMA_Init+0x258>
    a102:	21ed      	movs	r1, #237	; 0xed
    a104:	4890      	ldr	r0, [pc, #576]	; (a348 <HAL_DMA_Init+0x5dc>)
    a106:	f00f f9db 	bl	194c0 <assert_failed>
    a10a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    a10c:	2b00      	cmp	r3, #0
    a10e:	f43f af68 	beq.w	9fe2 <HAL_DMA_Init+0x276>
    a112:	e758      	b.n	9fc6 <HAL_DMA_Init+0x25a>
    switch (hdma->Init.FIFOThreshold)
    a114:	2a01      	cmp	r2, #1
    a116:	f000 8203 	beq.w	a520 <HAL_DMA_Init+0x7b4>
    a11a:	d3cc      	bcc.n	a0b6 <HAL_DMA_Init+0x34a>
    a11c:	2a02      	cmp	r2, #2
    a11e:	d0ca      	beq.n	a0b6 <HAL_DMA_Init+0x34a>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
    a120:	614b      	str	r3, [r1, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a122:	4628      	mov	r0, r5
    a124:	f7ff fda6 	bl	9c74 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    a128:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    a12a:	233f      	movs	r3, #63	; 0x3f
    a12c:	f002 021f 	and.w	r2, r2, #31
    a130:	4093      	lsls	r3, r2
    a132:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    a134:	682a      	ldr	r2, [r5, #0]
    a136:	4b85      	ldr	r3, [pc, #532]	; (a34c <HAL_DMA_Init+0x5e0>)
    a138:	4885      	ldr	r0, [pc, #532]	; (a350 <HAL_DMA_Init+0x5e4>)
    a13a:	4986      	ldr	r1, [pc, #536]	; (a354 <HAL_DMA_Init+0x5e8>)
    a13c:	4282      	cmp	r2, r0
    a13e:	bf18      	it	ne
    a140:	429a      	cmpne	r2, r3
    a142:	4e85      	ldr	r6, [pc, #532]	; (a358 <HAL_DMA_Init+0x5ec>)
    a144:	4c85      	ldr	r4, [pc, #532]	; (a35c <HAL_DMA_Init+0x5f0>)
    a146:	f100 0060 	add.w	r0, r0, #96	; 0x60
    a14a:	bf0c      	ite	eq
    a14c:	2301      	moveq	r3, #1
    a14e:	2300      	movne	r3, #0
    a150:	f8df e21c 	ldr.w	lr, [pc, #540]	; a370 <HAL_DMA_Init+0x604>
    a154:	428a      	cmp	r2, r1
    a156:	bf08      	it	eq
    a158:	f043 0301 	orreq.w	r3, r3, #1
    a15c:	3160      	adds	r1, #96	; 0x60
    a15e:	f8df c214 	ldr.w	ip, [pc, #532]	; a374 <HAL_DMA_Init+0x608>
    a162:	42b2      	cmp	r2, r6
    a164:	bf08      	it	eq
    a166:	f043 0301 	orreq.w	r3, r3, #1
    a16a:	4f7d      	ldr	r7, [pc, #500]	; (a360 <HAL_DMA_Init+0x5f4>)
    a16c:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
    a170:	f8df 8204 	ldr.w	r8, [pc, #516]	; a378 <HAL_DMA_Init+0x60c>
    a174:	42a2      	cmp	r2, r4
    a176:	bf08      	it	eq
    a178:	f043 0301 	orreq.w	r3, r3, #1
    a17c:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    a180:	f8df a1f8 	ldr.w	sl, [pc, #504]	; a37c <HAL_DMA_Init+0x610>
    a184:	4282      	cmp	r2, r0
    a186:	bf08      	it	eq
    a188:	f043 0301 	orreq.w	r3, r3, #1
    a18c:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
    a190:	f8df 91ec 	ldr.w	r9, [pc, #492]	; a380 <HAL_DMA_Init+0x614>
    a194:	428a      	cmp	r2, r1
    a196:	bf08      	it	eq
    a198:	f043 0301 	orreq.w	r3, r3, #1
    a19c:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
    a1a0:	4572      	cmp	r2, lr
    a1a2:	bf08      	it	eq
    a1a4:	f043 0301 	orreq.w	r3, r3, #1
    a1a8:	f8df e1d8 	ldr.w	lr, [pc, #472]	; a384 <HAL_DMA_Init+0x618>
    a1ac:	4562      	cmp	r2, ip
    a1ae:	bf08      	it	eq
    a1b0:	f043 0301 	orreq.w	r3, r3, #1
    a1b4:	eba2 0e0e 	sub.w	lr, r2, lr
    a1b8:	f8df c1cc 	ldr.w	ip, [pc, #460]	; a388 <HAL_DMA_Init+0x61c>
    a1bc:	42ba      	cmp	r2, r7
    a1be:	bf08      	it	eq
    a1c0:	f043 0301 	orreq.w	r3, r3, #1
    a1c4:	fabe fe8e 	clz	lr, lr
    a1c8:	eba2 070c 	sub.w	r7, r2, ip
    a1cc:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a1d0:	42b2      	cmp	r2, r6
    a1d2:	bf08      	it	eq
    a1d4:	f043 0301 	orreq.w	r3, r3, #1
    a1d8:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
    a1dc:	eba2 060a 	sub.w	r6, r2, sl
    a1e0:	fab7 f787 	clz	r7, r7
    a1e4:	42a2      	cmp	r2, r4
    a1e6:	bf08      	it	eq
    a1e8:	f043 0301 	orreq.w	r3, r3, #1
    a1ec:	f10a 0a28 	add.w	sl, sl, #40	; 0x28
    a1f0:	eba2 040c 	sub.w	r4, r2, ip
    a1f4:	097f      	lsrs	r7, r7, #5
    a1f6:	4282      	cmp	r2, r0
    a1f8:	bf08      	it	eq
    a1fa:	f043 0301 	orreq.w	r3, r3, #1
    a1fe:	fab6 f686 	clz	r6, r6
    a202:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a206:	fab4 f484 	clz	r4, r4
    a20a:	428a      	cmp	r2, r1
    a20c:	bf08      	it	eq
    a20e:	f043 0301 	orreq.w	r3, r3, #1
    a212:	0976      	lsrs	r6, r6, #5
    a214:	eba2 000a 	sub.w	r0, r2, sl
    a218:	eba2 010c 	sub.w	r1, r2, ip
    a21c:	4542      	cmp	r2, r8
    a21e:	bf08      	it	eq
    a220:	f043 0301 	orreq.w	r3, r3, #1
    a224:	0964      	lsrs	r4, r4, #5
    a226:	fab0 f080 	clz	r0, r0
    a22a:	f10c 0c14 	add.w	ip, ip, #20
    a22e:	454a      	cmp	r2, r9
    a230:	bf08      	it	eq
    a232:	f043 0301 	orreq.w	r3, r3, #1
    a236:	fab1 f181 	clz	r1, r1
    a23a:	0940      	lsrs	r0, r0, #5
    a23c:	eba2 0c0c 	sub.w	ip, r2, ip
    a240:	ea4e 0303 	orr.w	r3, lr, r3
    a244:	0949      	lsrs	r1, r1, #5
    a246:	f8df 8144 	ldr.w	r8, [pc, #324]	; a38c <HAL_DMA_Init+0x620>
    a24a:	fabc fc8c 	clz	ip, ip
    a24e:	433b      	orrs	r3, r7
    a250:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    a254:	eba2 0808 	sub.w	r8, r2, r8
    a258:	4333      	orrs	r3, r6
    a25a:	fab8 f888 	clz	r8, r8
    a25e:	4323      	orrs	r3, r4
    a260:	ea4f 1858 	mov.w	r8, r8, lsr #5
    a264:	4303      	orrs	r3, r0
    a266:	430b      	orrs	r3, r1
    a268:	ea5c 0303 	orrs.w	r3, ip, r3
    a26c:	d102      	bne.n	a274 <HAL_DMA_Init+0x508>
    a26e:	f1b8 0f00 	cmp.w	r8, #0
    a272:	d02e      	beq.n	a2d2 <HAL_DMA_Init+0x566>
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a274:	ea47 070e 	orr.w	r7, r7, lr
    a278:	b2d3      	uxtb	r3, r2
    a27a:	433e      	orrs	r6, r7
    a27c:	4334      	orrs	r4, r6
    a27e:	4320      	orrs	r0, r4
    a280:	4301      	orrs	r1, r0
    a282:	ea5c 0101 	orrs.w	r1, ip, r1
    a286:	d103      	bne.n	a290 <HAL_DMA_Init+0x524>
    a288:	f1b8 0f00 	cmp.w	r8, #0
    a28c:	f000 80d3 	beq.w	a436 <HAL_DMA_Init+0x6ca>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a290:	4834      	ldr	r0, [pc, #208]	; (a364 <HAL_DMA_Init+0x5f8>)
    a292:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a294:	4a34      	ldr	r2, [pc, #208]	; (a368 <HAL_DMA_Init+0x5fc>)
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a296:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a298:	fba0 0303 	umull	r0, r3, r0, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a29c:	4833      	ldr	r0, [pc, #204]	; (a36c <HAL_DMA_Init+0x600>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a29e:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a2a0:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a2a2:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a2a4:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a2a8:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a2aa:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a2ae:	662a      	str	r2, [r5, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a2b0:	66ab      	str	r3, [r5, #104]	; 0x68
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
    a2b2:	68ab      	ldr	r3, [r5, #8]
    a2b4:	2b80      	cmp	r3, #128	; 0x80
    a2b6:	d07d      	beq.n	a3b4 <HAL_DMA_Init+0x648>
    a2b8:	792b      	ldrb	r3, [r5, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
    a2ba:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    a2bc:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	; 0x64
    a2c0:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
    a2c2:	6868      	ldr	r0, [r5, #4]
    a2c4:	1e41      	subs	r1, r0, #1
    a2c6:	2907      	cmp	r1, #7
    a2c8:	d978      	bls.n	a3bc <HAL_DMA_Init+0x650>
      hdma->DMAmuxRequestGen = 0U;
    a2ca:	2300      	movs	r3, #0
      hdma->DMAmuxRequestGenStatus = 0U;
    a2cc:	e9c5 331b 	strd	r3, r3, [r5, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
    a2d0:	676b      	str	r3, [r5, #116]	; 0x74
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a2d2:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
    a2d4:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a2d6:	6568      	str	r0, [r5, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
    a2d8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
    a2dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    a2e0:	2220      	movs	r2, #32
        hdma->State = HAL_DMA_STATE_ERROR;
    a2e2:	2303      	movs	r3, #3
        return HAL_ERROR;
    a2e4:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    a2e6:	656a      	str	r2, [r5, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
    a2e8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
    a2ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return HAL_ERROR;
    a2f0:	2001      	movs	r0, #1
}
    a2f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    a2f6:	21e2      	movs	r1, #226	; 0xe2
    a2f8:	4813      	ldr	r0, [pc, #76]	; (a348 <HAL_DMA_Init+0x5dc>)
    a2fa:	f00f f8e1 	bl	194c0 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    a2fe:	68eb      	ldr	r3, [r5, #12]
    a300:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    a304:	f43f add6 	beq.w	9eb4 <HAL_DMA_Init+0x148>
    a308:	e6e8      	b.n	a0dc <HAL_DMA_Init+0x370>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    a30a:	21e5      	movs	r1, #229	; 0xe5
    a30c:	480e      	ldr	r0, [pc, #56]	; (a348 <HAL_DMA_Init+0x5dc>)
    a30e:	f00f f8d7 	bl	194c0 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    a312:	69ab      	ldr	r3, [r5, #24]
    a314:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
    a318:	f47f addd 	bne.w	9ed6 <HAL_DMA_Init+0x16a>
    a31c:	e5df      	b.n	9ede <HAL_DMA_Init+0x172>
    a31e:	21e6      	movs	r1, #230	; 0xe6
    a320:	4809      	ldr	r0, [pc, #36]	; (a348 <HAL_DMA_Init+0x5dc>)
    a322:	f00f f8cd 	bl	194c0 <assert_failed>
    a326:	e5da      	b.n	9ede <HAL_DMA_Init+0x172>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
    a328:	21e7      	movs	r1, #231	; 0xe7
    a32a:	4807      	ldr	r0, [pc, #28]	; (a348 <HAL_DMA_Init+0x5dc>)
    a32c:	f00f f8c8 	bl	194c0 <assert_failed>
    a330:	e5e8      	b.n	9f04 <HAL_DMA_Init+0x198>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    a332:	21f4      	movs	r1, #244	; 0xf4
    a334:	4804      	ldr	r0, [pc, #16]	; (a348 <HAL_DMA_Init+0x5dc>)
    a336:	f00f f8c3 	bl	194c0 <assert_failed>
    a33a:	e652      	b.n	9fe2 <HAL_DMA_Init+0x276>
    a33c:	fe10803f 	.word	0xfe10803f
    a340:	5c001000 	.word	0x5c001000
    a344:	ffff0000 	.word	0xffff0000
    a348:	0002ff8c 	.word	0x0002ff8c
    a34c:	40020010 	.word	0x40020010
    a350:	40020028 	.word	0x40020028
    a354:	40020040 	.word	0x40020040
    a358:	40020058 	.word	0x40020058
    a35c:	40020070 	.word	0x40020070
    a360:	40020428 	.word	0x40020428
    a364:	cccccccd 	.word	0xcccccccd
    a368:	16009600 	.word	0x16009600
    a36c:	58025880 	.word	0x58025880
    a370:	400200b8 	.word	0x400200b8
    a374:	40020410 	.word	0x40020410
    a378:	400204a0 	.word	0x400204a0
    a37c:	58025430 	.word	0x58025430
    a380:	400204b8 	.word	0x400204b8
    a384:	58025408 	.word	0x58025408
    a388:	5802541c 	.word	0x5802541c
    a38c:	58025494 	.word	0x58025494
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
    a390:	497a      	ldr	r1, [pc, #488]	; (a57c <HAL_DMA_Init+0x810>)
    a392:	40e1      	lsrs	r1, r4
    a394:	07c9      	lsls	r1, r1, #31
    a396:	f57f ae6f 	bpl.w	a078 <HAL_DMA_Init+0x30c>
        registerValue |= DMA_SxCR_TRBUFF;
    a39a:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    a39e:	e670      	b.n	a082 <HAL_DMA_Init+0x316>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    a3a0:	21f2      	movs	r1, #242	; 0xf2
    a3a2:	4877      	ldr	r0, [pc, #476]	; (a580 <HAL_DMA_Init+0x814>)
    a3a4:	f00f f88c 	bl	194c0 <assert_failed>
    a3a8:	e611      	b.n	9fce <HAL_DMA_Init+0x262>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    a3aa:	21e8      	movs	r1, #232	; 0xe8
    a3ac:	4874      	ldr	r0, [pc, #464]	; (a580 <HAL_DMA_Init+0x814>)
    a3ae:	f00f f887 	bl	194c0 <assert_failed>
    a3b2:	e5ac      	b.n	9f0e <HAL_DMA_Init+0x1a2>
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
    a3b4:	2100      	movs	r1, #0
    a3b6:	460b      	mov	r3, r1
    a3b8:	6069      	str	r1, [r5, #4]
    a3ba:	e77e      	b.n	a2ba <HAL_DMA_Init+0x54e>
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a3bc:	682a      	ldr	r2, [r5, #0]
    a3be:	4b71      	ldr	r3, [pc, #452]	; (a584 <HAL_DMA_Init+0x818>)
    a3c0:	4e71      	ldr	r6, [pc, #452]	; (a588 <HAL_DMA_Init+0x81c>)
    a3c2:	4c72      	ldr	r4, [pc, #456]	; (a58c <HAL_DMA_Init+0x820>)
    a3c4:	42b2      	cmp	r2, r6
    a3c6:	bf18      	it	ne
    a3c8:	429a      	cmpne	r2, r3
    a3ca:	f106 0628 	add.w	r6, r6, #40	; 0x28
    a3ce:	bf0c      	ite	eq
    a3d0:	2301      	moveq	r3, #1
    a3d2:	2300      	movne	r3, #0
    a3d4:	42a2      	cmp	r2, r4
    a3d6:	bf08      	it	eq
    a3d8:	f043 0301 	orreq.w	r3, r3, #1
    a3dc:	3428      	adds	r4, #40	; 0x28
    a3de:	42b2      	cmp	r2, r6
    a3e0:	bf08      	it	eq
    a3e2:	f043 0301 	orreq.w	r3, r3, #1
    a3e6:	3628      	adds	r6, #40	; 0x28
    a3e8:	42a2      	cmp	r2, r4
    a3ea:	bf08      	it	eq
    a3ec:	f043 0301 	orreq.w	r3, r3, #1
    a3f0:	3428      	adds	r4, #40	; 0x28
    a3f2:	42b2      	cmp	r2, r6
    a3f4:	bf08      	it	eq
    a3f6:	f043 0301 	orreq.w	r3, r3, #1
    a3fa:	42a2      	cmp	r2, r4
    a3fc:	bf08      	it	eq
    a3fe:	f043 0301 	orreq.w	r3, r3, #1
    a402:	b91b      	cbnz	r3, a40c <HAL_DMA_Init+0x6a0>
    a404:	4b62      	ldr	r3, [pc, #392]	; (a590 <HAL_DMA_Init+0x824>)
    a406:	429a      	cmp	r2, r3
    a408:	f040 809e 	bne.w	a548 <HAL_DMA_Init+0x7dc>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a40c:	4b61      	ldr	r3, [pc, #388]	; (a594 <HAL_DMA_Init+0x828>)

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    a40e:	4c62      	ldr	r4, [pc, #392]	; (a598 <HAL_DMA_Init+0x82c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a410:	4403      	add	r3, r0
    a412:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a414:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a416:	2000      	movs	r0, #0
    a418:	672c      	str	r4, [r5, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a41a:	fa02 f101 	lsl.w	r1, r2, r1
    a41e:	66eb      	str	r3, [r5, #108]	; 0x6c
    a420:	6769      	str	r1, [r5, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a422:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    a424:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	; 0x70
    a428:	605a      	str	r2, [r3, #4]
    a42a:	e752      	b.n	a2d2 <HAL_DMA_Init+0x566>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    a42c:	21f3      	movs	r1, #243	; 0xf3
    a42e:	4854      	ldr	r0, [pc, #336]	; (a580 <HAL_DMA_Init+0x814>)
    a430:	f00f f846 	bl	194c0 <assert_failed>
    a434:	e5d0      	b.n	9fd8 <HAL_DMA_Init+0x26c>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a436:	4959      	ldr	r1, [pc, #356]	; (a59c <HAL_DMA_Init+0x830>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a438:	3b10      	subs	r3, #16
    a43a:	4859      	ldr	r0, [pc, #356]	; (a5a0 <HAL_DMA_Init+0x834>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a43c:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a43e:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a442:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a444:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a448:	d800      	bhi.n	a44c <HAL_DMA_Init+0x6e0>
      stream_number += 8U;
    a44a:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a44c:	4a55      	ldr	r2, [pc, #340]	; (a5a4 <HAL_DMA_Init+0x838>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a44e:	f003 041f 	and.w	r4, r3, #31
    a452:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a454:	4854      	ldr	r0, [pc, #336]	; (a5a8 <HAL_DMA_Init+0x83c>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a456:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a458:	40a1      	lsls	r1, r4
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a45a:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a45c:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a45e:	66a9      	str	r1, [r5, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a460:	662a      	str	r2, [r5, #96]	; 0x60
    a462:	e726      	b.n	a2b2 <HAL_DMA_Init+0x546>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    a464:	4b47      	ldr	r3, [pc, #284]	; (a584 <HAL_DMA_Init+0x818>)
    a466:	429a      	cmp	r2, r3
    a468:	d01e      	beq.n	a4a8 <HAL_DMA_Init+0x73c>
    a46a:	3314      	adds	r3, #20
    a46c:	429a      	cmp	r2, r3
    a46e:	d01b      	beq.n	a4a8 <HAL_DMA_Init+0x73c>
    a470:	4b46      	ldr	r3, [pc, #280]	; (a58c <HAL_DMA_Init+0x820>)
    a472:	494e      	ldr	r1, [pc, #312]	; (a5ac <HAL_DMA_Init+0x840>)
    a474:	4c4e      	ldr	r4, [pc, #312]	; (a5b0 <HAL_DMA_Init+0x844>)
    a476:	428a      	cmp	r2, r1
    a478:	bf18      	it	ne
    a47a:	429a      	cmpne	r2, r3
    a47c:	484d      	ldr	r0, [pc, #308]	; (a5b4 <HAL_DMA_Init+0x848>)
    a47e:	f101 013c 	add.w	r1, r1, #60	; 0x3c
    a482:	bf0c      	ite	eq
    a484:	2301      	moveq	r3, #1
    a486:	2300      	movne	r3, #0
    a488:	42a2      	cmp	r2, r4
    a48a:	bf08      	it	eq
    a48c:	f043 0301 	orreq.w	r3, r3, #1
    a490:	4282      	cmp	r2, r0
    a492:	bf08      	it	eq
    a494:	f043 0301 	orreq.w	r3, r3, #1
    a498:	428a      	cmp	r2, r1
    a49a:	bf08      	it	eq
    a49c:	f043 0301 	orreq.w	r3, r3, #1
    a4a0:	b913      	cbnz	r3, a4a8 <HAL_DMA_Init+0x73c>
    a4a2:	4b3b      	ldr	r3, [pc, #236]	; (a590 <HAL_DMA_Init+0x824>)
    a4a4:	429a      	cmp	r2, r3
    a4a6:	d15d      	bne.n	a564 <HAL_DMA_Init+0x7f8>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    a4a8:	686b      	ldr	r3, [r5, #4]
    a4aa:	2b11      	cmp	r3, #17
    a4ac:	d853      	bhi.n	a556 <HAL_DMA_Init+0x7ea>
    hdma->State = HAL_DMA_STATE_BUSY;
    a4ae:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);
    a4b0:	2100      	movs	r1, #0
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a4b2:	4f41      	ldr	r7, [pc, #260]	; (a5b8 <HAL_DMA_Init+0x84c>)
    hdma->State = HAL_DMA_STATE_BUSY;
    a4b4:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4b8:	68ab      	ldr	r3, [r5, #8]
    __HAL_UNLOCK(hdma);
    a4ba:	f885 1034 	strb.w	r1, [r5, #52]	; 0x34
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4be:	2b40      	cmp	r3, #64	; 0x40
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
    a4c0:	6811      	ldr	r1, [r2, #0]
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
    a4c2:	ea07 0701 	and.w	r7, r7, r1
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4c6:	d044      	beq.n	a552 <HAL_DMA_Init+0x7e6>
    a4c8:	2b80      	cmp	r3, #128	; 0x80
    a4ca:	bf14      	ite	ne
    a4cc:	2100      	movne	r1, #0
    a4ce:	f44f 4180 	moveq.w	r1, #16384	; 0x4000
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
    a4d2:	692b      	ldr	r3, [r5, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a4d4:	4628      	mov	r0, r5
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
    a4d6:	68ec      	ldr	r4, [r5, #12]
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
    a4d8:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
    a4da:	696e      	ldr	r6, [r5, #20]
    a4dc:	ea43 03d4 	orr.w	r3, r3, r4, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
    a4e0:	69ac      	ldr	r4, [r5, #24]
    a4e2:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
    a4e6:	69ee      	ldr	r6, [r5, #28]
    a4e8:	ea43 03d4 	orr.w	r3, r3, r4, lsr #3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
    a4ec:	6a2c      	ldr	r4, [r5, #32]
    a4ee:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a4f2:	4e32      	ldr	r6, [pc, #200]	; (a5bc <HAL_DMA_Init+0x850>)
    a4f4:	ea43 1314 	orr.w	r3, r3, r4, lsr #4
    a4f8:	4c31      	ldr	r4, [pc, #196]	; (a5c0 <HAL_DMA_Init+0x854>)
    a4fa:	433b      	orrs	r3, r7
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a4fc:	430b      	orrs	r3, r1
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
    a4fe:	6013      	str	r3, [r2, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
    a500:	682b      	ldr	r3, [r5, #0]
    a502:	441e      	add	r6, r3
    a504:	fba4 2306 	umull	r2, r3, r4, r6
    a508:	091b      	lsrs	r3, r3, #4
    a50a:	009b      	lsls	r3, r3, #2
    a50c:	65eb      	str	r3, [r5, #92]	; 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    a50e:	f7ff fbb1 	bl	9c74 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    a512:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    a514:	2301      	movs	r3, #1
    a516:	f002 021f 	and.w	r2, r2, #31
    a51a:	4093      	lsls	r3, r2
    a51c:	6043      	str	r3, [r0, #4]
    a51e:	e609      	b.n	a134 <HAL_DMA_Init+0x3c8>
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
    a520:	f1b0 7fc0 	cmp.w	r0, #25165824	; 0x1800000
    a524:	f47f adfc 	bne.w	a120 <HAL_DMA_Init+0x3b4>
    a528:	e5c7      	b.n	a0ba <HAL_DMA_Init+0x34e>
    switch (hdma->Init.FIFOThreshold)
    a52a:	2a03      	cmp	r2, #3
    a52c:	f63f adf8 	bhi.w	a120 <HAL_DMA_Init+0x3b4>
    a530:	a401      	add	r4, pc, #4	; (adr r4, a538 <HAL_DMA_Init+0x7cc>)
    a532:	f854 f022 	ldr.w	pc, [r4, r2, lsl #2]
    a536:	bf00      	nop
    a538:	0000a0bb 	.word	0x0000a0bb
    a53c:	0000a0b7 	.word	0x0000a0b7
    a540:	0000a0bb 	.word	0x0000a0bb
    a544:	0000a521 	.word	0x0000a521
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    a548:	4b1e      	ldr	r3, [pc, #120]	; (a5c4 <HAL_DMA_Init+0x858>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    a54a:	4c1f      	ldr	r4, [pc, #124]	; (a5c8 <HAL_DMA_Init+0x85c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    a54c:	4403      	add	r3, r0
    a54e:	009b      	lsls	r3, r3, #2
    a550:	e760      	b.n	a414 <HAL_DMA_Init+0x6a8>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
    a552:	2110      	movs	r1, #16
    a554:	e7bd      	b.n	a4d2 <HAL_DMA_Init+0x766>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    a556:	f44f 71b3 	mov.w	r1, #358	; 0x166
    a55a:	4809      	ldr	r0, [pc, #36]	; (a580 <HAL_DMA_Init+0x814>)
    a55c:	f00e ffb0 	bl	194c0 <assert_failed>
    a560:	682a      	ldr	r2, [r5, #0]
    a562:	e7a4      	b.n	a4ae <HAL_DMA_Init+0x742>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a564:	2240      	movs	r2, #64	; 0x40
    hdma->State     = HAL_DMA_STATE_ERROR;
    a566:	2303      	movs	r3, #3
    return HAL_ERROR;
    a568:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    a56a:	656a      	str	r2, [r5, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
    a56c:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    return HAL_ERROR;
    a570:	e6b4      	b.n	a2dc <HAL_DMA_Init+0x570>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    a572:	21e1      	movs	r1, #225	; 0xe1
    a574:	4802      	ldr	r0, [pc, #8]	; (a580 <HAL_DMA_Init+0x814>)
    a576:	f00e ffa3 	bl	194c0 <assert_failed>
    a57a:	e48f      	b.n	9e9c <HAL_DMA_Init+0x130>
    a57c:	c3c0003f 	.word	0xc3c0003f
    a580:	0002ff8c 	.word	0x0002ff8c
    a584:	58025408 	.word	0x58025408
    a588:	5802541c 	.word	0x5802541c
    a58c:	58025430 	.word	0x58025430
    a590:	58025494 	.word	0x58025494
    a594:	1600963f 	.word	0x1600963f
    a598:	58025940 	.word	0x58025940
    a59c:	bffdfbf0 	.word	0xbffdfbf0
    a5a0:	aaaaaaab 	.word	0xaaaaaaab
    a5a4:	10008200 	.word	0x10008200
    a5a8:	40020880 	.word	0x40020880
    a5ac:	58025444 	.word	0x58025444
    a5b0:	58025458 	.word	0x58025458
    a5b4:	5802546c 	.word	0x5802546c
    a5b8:	fffe000f 	.word	0xfffe000f
    a5bc:	a7fdabf8 	.word	0xa7fdabf8
    a5c0:	cccccccd 	.word	0xcccccccd
    a5c4:	1000823f 	.word	0x1000823f
    a5c8:	40020940 	.word	0x40020940

0000a5cc <HAL_DMA_DeInit>:
  if(hdma == NULL)
    a5cc:	2800      	cmp	r0, #0
    a5ce:	f000 821c 	beq.w	aa0a <HAL_DMA_DeInit+0x43e>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a5d2:	49a7      	ldr	r1, [pc, #668]	; (a870 <HAL_DMA_DeInit+0x2a4>)
{
    a5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_DMA_DISABLE(hdma);
    a5d8:	6802      	ldr	r2, [r0, #0]
    a5da:	4604      	mov	r4, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a5dc:	4da5      	ldr	r5, [pc, #660]	; (a874 <HAL_DMA_DeInit+0x2a8>)
  __HAL_DMA_DISABLE(hdma);
    a5de:	6813      	ldr	r3, [r2, #0]
    a5e0:	f023 0301 	bic.w	r3, r3, #1
    a5e4:	6013      	str	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a5e6:	4ba4      	ldr	r3, [pc, #656]	; (a878 <HAL_DMA_DeInit+0x2ac>)
    a5e8:	6802      	ldr	r2, [r0, #0]
    a5ea:	48a4      	ldr	r0, [pc, #656]	; (a87c <HAL_DMA_DeInit+0x2b0>)
    a5ec:	4282      	cmp	r2, r0
    a5ee:	bf18      	it	ne
    a5f0:	429a      	cmpne	r2, r3
    a5f2:	f100 0048 	add.w	r0, r0, #72	; 0x48
    a5f6:	bf0c      	ite	eq
    a5f8:	2301      	moveq	r3, #1
    a5fa:	2300      	movne	r3, #0
    a5fc:	428a      	cmp	r2, r1
    a5fe:	bf08      	it	eq
    a600:	f043 0301 	orreq.w	r3, r3, #1
    a604:	3148      	adds	r1, #72	; 0x48
    a606:	42aa      	cmp	r2, r5
    a608:	bf08      	it	eq
    a60a:	f043 0301 	orreq.w	r3, r3, #1
    a60e:	3548      	adds	r5, #72	; 0x48
    a610:	4282      	cmp	r2, r0
    a612:	bf08      	it	eq
    a614:	f043 0301 	orreq.w	r3, r3, #1
    a618:	3048      	adds	r0, #72	; 0x48
    a61a:	428a      	cmp	r2, r1
    a61c:	bf08      	it	eq
    a61e:	f043 0301 	orreq.w	r3, r3, #1
    a622:	f501 7162 	add.w	r1, r1, #904	; 0x388
    a626:	42aa      	cmp	r2, r5
    a628:	bf08      	it	eq
    a62a:	f043 0301 	orreq.w	r3, r3, #1
    a62e:	f505 7562 	add.w	r5, r5, #904	; 0x388
    a632:	4282      	cmp	r2, r0
    a634:	bf08      	it	eq
    a636:	f043 0301 	orreq.w	r3, r3, #1
    a63a:	f500 7062 	add.w	r0, r0, #904	; 0x388
    a63e:	428a      	cmp	r2, r1
    a640:	bf08      	it	eq
    a642:	f043 0301 	orreq.w	r3, r3, #1
    a646:	3148      	adds	r1, #72	; 0x48
    a648:	42aa      	cmp	r2, r5
    a64a:	bf08      	it	eq
    a64c:	f043 0301 	orreq.w	r3, r3, #1
    a650:	3548      	adds	r5, #72	; 0x48
    a652:	4282      	cmp	r2, r0
    a654:	bf08      	it	eq
    a656:	f043 0301 	orreq.w	r3, r3, #1
    a65a:	3048      	adds	r0, #72	; 0x48
    a65c:	428a      	cmp	r2, r1
    a65e:	bf08      	it	eq
    a660:	f043 0301 	orreq.w	r3, r3, #1
    a664:	3148      	adds	r1, #72	; 0x48
    a666:	42aa      	cmp	r2, r5
    a668:	bf08      	it	eq
    a66a:	f043 0301 	orreq.w	r3, r3, #1
    a66e:	4282      	cmp	r2, r0
    a670:	bf08      	it	eq
    a672:	f043 0301 	orreq.w	r3, r3, #1
    a676:	428a      	cmp	r2, r1
    a678:	bf08      	it	eq
    a67a:	f043 0301 	orreq.w	r3, r3, #1
    a67e:	b91b      	cbnz	r3, a688 <HAL_DMA_DeInit+0xbc>
    a680:	4b7f      	ldr	r3, [pc, #508]	; (a880 <HAL_DMA_DeInit+0x2b4>)
    a682:	429a      	cmp	r2, r3
    a684:	f040 81c3 	bne.w	aa0e <HAL_DMA_DeInit+0x442>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
    a688:	2100      	movs	r1, #0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    a68a:	2521      	movs	r5, #33	; 0x21
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a68c:	4b7a      	ldr	r3, [pc, #488]	; (a878 <HAL_DMA_DeInit+0x2ac>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
    a68e:	6011      	str	r1, [r2, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
    a690:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a692:	487a      	ldr	r0, [pc, #488]	; (a87c <HAL_DMA_DeInit+0x2b0>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
    a694:	6051      	str	r1, [r2, #4]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
    a696:	6822      	ldr	r2, [r4, #0]
    a698:	6091      	str	r1, [r2, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
    a69a:	6822      	ldr	r2, [r4, #0]
    a69c:	60d1      	str	r1, [r2, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
    a69e:	6822      	ldr	r2, [r4, #0]
    a6a0:	6111      	str	r1, [r2, #16]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    a6a2:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a6a4:	4972      	ldr	r1, [pc, #456]	; (a870 <HAL_DMA_DeInit+0x2a4>)
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
    a6a6:	6155      	str	r5, [r2, #20]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    a6a8:	6822      	ldr	r2, [r4, #0]
    a6aa:	4d72      	ldr	r5, [pc, #456]	; (a874 <HAL_DMA_DeInit+0x2a8>)
    a6ac:	4282      	cmp	r2, r0
    a6ae:	bf18      	it	ne
    a6b0:	429a      	cmpne	r2, r3
    a6b2:	f100 0048 	add.w	r0, r0, #72	; 0x48
    a6b6:	bf0c      	ite	eq
    a6b8:	2301      	moveq	r3, #1
    a6ba:	2300      	movne	r3, #0
    a6bc:	428a      	cmp	r2, r1
    a6be:	bf08      	it	eq
    a6c0:	f043 0301 	orreq.w	r3, r3, #1
    a6c4:	3148      	adds	r1, #72	; 0x48
    a6c6:	42aa      	cmp	r2, r5
    a6c8:	bf08      	it	eq
    a6ca:	f043 0301 	orreq.w	r3, r3, #1
    a6ce:	3548      	adds	r5, #72	; 0x48
    a6d0:	4282      	cmp	r2, r0
    a6d2:	bf08      	it	eq
    a6d4:	f043 0301 	orreq.w	r3, r3, #1
    a6d8:	3048      	adds	r0, #72	; 0x48
    a6da:	428a      	cmp	r2, r1
    a6dc:	bf08      	it	eq
    a6de:	f043 0301 	orreq.w	r3, r3, #1
    a6e2:	f501 7162 	add.w	r1, r1, #904	; 0x388
    a6e6:	42aa      	cmp	r2, r5
    a6e8:	bf08      	it	eq
    a6ea:	f043 0301 	orreq.w	r3, r3, #1
    a6ee:	f505 7562 	add.w	r5, r5, #904	; 0x388
    a6f2:	4282      	cmp	r2, r0
    a6f4:	bf08      	it	eq
    a6f6:	f043 0301 	orreq.w	r3, r3, #1
    a6fa:	f500 7062 	add.w	r0, r0, #904	; 0x388
    a6fe:	428a      	cmp	r2, r1
    a700:	bf08      	it	eq
    a702:	f043 0301 	orreq.w	r3, r3, #1
    a706:	3148      	adds	r1, #72	; 0x48
    a708:	42aa      	cmp	r2, r5
    a70a:	bf08      	it	eq
    a70c:	f043 0301 	orreq.w	r3, r3, #1
    a710:	3548      	adds	r5, #72	; 0x48
    a712:	4282      	cmp	r2, r0
    a714:	bf08      	it	eq
    a716:	f043 0301 	orreq.w	r3, r3, #1
    a71a:	3048      	adds	r0, #72	; 0x48
    a71c:	428a      	cmp	r2, r1
    a71e:	bf08      	it	eq
    a720:	f043 0301 	orreq.w	r3, r3, #1
    a724:	3148      	adds	r1, #72	; 0x48
    a726:	42aa      	cmp	r2, r5
    a728:	bf08      	it	eq
    a72a:	f043 0301 	orreq.w	r3, r3, #1
    a72e:	4282      	cmp	r2, r0
    a730:	bf08      	it	eq
    a732:	f043 0301 	orreq.w	r3, r3, #1
    a736:	428a      	cmp	r2, r1
    a738:	bf08      	it	eq
    a73a:	f043 0301 	orreq.w	r3, r3, #1
    a73e:	b91b      	cbnz	r3, a748 <HAL_DMA_DeInit+0x17c>
    a740:	4b4f      	ldr	r3, [pc, #316]	; (a880 <HAL_DMA_DeInit+0x2b4>)
    a742:	429a      	cmp	r2, r3
    a744:	f040 819d 	bne.w	aa82 <HAL_DMA_DeInit+0x4b6>
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a748:	b2d3      	uxtb	r3, r2
    a74a:	4d4e      	ldr	r5, [pc, #312]	; (a884 <HAL_DMA_DeInit+0x2b8>)
    a74c:	494e      	ldr	r1, [pc, #312]	; (a888 <HAL_DMA_DeInit+0x2bc>)
    a74e:	3b10      	subs	r3, #16
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a750:	484e      	ldr	r0, [pc, #312]	; (a88c <HAL_DMA_DeInit+0x2c0>)
    a752:	4011      	ands	r1, r2
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a754:	fba5 5303 	umull	r5, r3, r5, r3
    a758:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a75a:	f003 0207 	and.w	r2, r3, #7
    if (stream_number > 3U)
    a75e:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a760:	5c82      	ldrb	r2, [r0, r2]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
    a762:	bf88      	it	hi
    a764:	3104      	addhi	r1, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
    a766:	65e2      	str	r2, [r4, #92]	; 0x5c
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
    a768:	65a1      	str	r1, [r4, #88]	; 0x58
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    a76a:	f002 021f 	and.w	r2, r2, #31
    a76e:	233f      	movs	r3, #63	; 0x3f
    a770:	fa03 f202 	lsl.w	r2, r3, r2
    a774:	608a      	str	r2, [r1, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    a776:	6822      	ldr	r2, [r4, #0]
    a778:	4b3f      	ldr	r3, [pc, #252]	; (a878 <HAL_DMA_DeInit+0x2ac>)
    a77a:	4840      	ldr	r0, [pc, #256]	; (a87c <HAL_DMA_DeInit+0x2b0>)
    a77c:	493c      	ldr	r1, [pc, #240]	; (a870 <HAL_DMA_DeInit+0x2a4>)
    a77e:	4282      	cmp	r2, r0
    a780:	bf18      	it	ne
    a782:	429a      	cmpne	r2, r3
    a784:	4e3b      	ldr	r6, [pc, #236]	; (a874 <HAL_DMA_DeInit+0x2a8>)
    a786:	4d42      	ldr	r5, [pc, #264]	; (a890 <HAL_DMA_DeInit+0x2c4>)
    a788:	f100 0060 	add.w	r0, r0, #96	; 0x60
    a78c:	bf0c      	ite	eq
    a78e:	2301      	moveq	r3, #1
    a790:	2300      	movne	r3, #0
    a792:	f8df e104 	ldr.w	lr, [pc, #260]	; a898 <HAL_DMA_DeInit+0x2cc>
    a796:	428a      	cmp	r2, r1
    a798:	bf08      	it	eq
    a79a:	f043 0301 	orreq.w	r3, r3, #1
    a79e:	3160      	adds	r1, #96	; 0x60
    a7a0:	f8df c0f8 	ldr.w	ip, [pc, #248]	; a89c <HAL_DMA_DeInit+0x2d0>
    a7a4:	42b2      	cmp	r2, r6
    a7a6:	bf08      	it	eq
    a7a8:	f043 0301 	orreq.w	r3, r3, #1
    a7ac:	4f39      	ldr	r7, [pc, #228]	; (a894 <HAL_DMA_DeInit+0x2c8>)
    a7ae:	f506 767a 	add.w	r6, r6, #1000	; 0x3e8
    a7b2:	f8df 80ec 	ldr.w	r8, [pc, #236]	; a8a0 <HAL_DMA_DeInit+0x2d4>
    a7b6:	42aa      	cmp	r2, r5
    a7b8:	bf08      	it	eq
    a7ba:	f043 0301 	orreq.w	r3, r3, #1
    a7be:	f505 757a 	add.w	r5, r5, #1000	; 0x3e8
    a7c2:	f8df a0e0 	ldr.w	sl, [pc, #224]	; a8a4 <HAL_DMA_DeInit+0x2d8>
    a7c6:	4282      	cmp	r2, r0
    a7c8:	bf08      	it	eq
    a7ca:	f043 0301 	orreq.w	r3, r3, #1
    a7ce:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
    a7d2:	f8df 90ac 	ldr.w	r9, [pc, #172]	; a880 <HAL_DMA_DeInit+0x2b4>
    a7d6:	428a      	cmp	r2, r1
    a7d8:	bf08      	it	eq
    a7da:	f043 0301 	orreq.w	r3, r3, #1
    a7de:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
    a7e2:	4572      	cmp	r2, lr
    a7e4:	bf08      	it	eq
    a7e6:	f043 0301 	orreq.w	r3, r3, #1
    a7ea:	f8df e0bc 	ldr.w	lr, [pc, #188]	; a8a8 <HAL_DMA_DeInit+0x2dc>
    a7ee:	4562      	cmp	r2, ip
    a7f0:	bf08      	it	eq
    a7f2:	f043 0301 	orreq.w	r3, r3, #1
    a7f6:	eba2 0e0e 	sub.w	lr, r2, lr
    a7fa:	f8df c0b0 	ldr.w	ip, [pc, #176]	; a8ac <HAL_DMA_DeInit+0x2e0>
    a7fe:	42ba      	cmp	r2, r7
    a800:	bf08      	it	eq
    a802:	f043 0301 	orreq.w	r3, r3, #1
    a806:	fabe fe8e 	clz	lr, lr
    a80a:	eba2 070c 	sub.w	r7, r2, ip
    a80e:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a812:	42b2      	cmp	r2, r6
    a814:	bf08      	it	eq
    a816:	f043 0301 	orreq.w	r3, r3, #1
    a81a:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
    a81e:	eba2 060a 	sub.w	r6, r2, sl
    a822:	fab7 f787 	clz	r7, r7
    a826:	42aa      	cmp	r2, r5
    a828:	bf08      	it	eq
    a82a:	f043 0301 	orreq.w	r3, r3, #1
    a82e:	f10a 0a28 	add.w	sl, sl, #40	; 0x28
    a832:	eba2 050c 	sub.w	r5, r2, ip
    a836:	097f      	lsrs	r7, r7, #5
    a838:	4282      	cmp	r2, r0
    a83a:	bf08      	it	eq
    a83c:	f043 0301 	orreq.w	r3, r3, #1
    a840:	fab6 f686 	clz	r6, r6
    a844:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    a848:	fab5 f585 	clz	r5, r5
    a84c:	428a      	cmp	r2, r1
    a84e:	bf08      	it	eq
    a850:	f043 0301 	orreq.w	r3, r3, #1
    a854:	0976      	lsrs	r6, r6, #5
    a856:	eba2 000a 	sub.w	r0, r2, sl
    a85a:	eba2 010c 	sub.w	r1, r2, ip
    a85e:	4542      	cmp	r2, r8
    a860:	bf08      	it	eq
    a862:	f043 0301 	orreq.w	r3, r3, #1
    a866:	096d      	lsrs	r5, r5, #5
    a868:	fab0 f080 	clz	r0, r0
    a86c:	e020      	b.n	a8b0 <HAL_DMA_DeInit+0x2e4>
    a86e:	bf00      	nop
    a870:	40020040 	.word	0x40020040
    a874:	40020058 	.word	0x40020058
    a878:	40020010 	.word	0x40020010
    a87c:	40020028 	.word	0x40020028
    a880:	400204b8 	.word	0x400204b8
    a884:	aaaaaaab 	.word	0xaaaaaaab
    a888:	fffffc00 	.word	0xfffffc00
    a88c:	0002ffc4 	.word	0x0002ffc4
    a890:	40020070 	.word	0x40020070
    a894:	40020428 	.word	0x40020428
    a898:	400200b8 	.word	0x400200b8
    a89c:	40020410 	.word	0x40020410
    a8a0:	400204a0 	.word	0x400204a0
    a8a4:	58025430 	.word	0x58025430
    a8a8:	58025408 	.word	0x58025408
    a8ac:	5802541c 	.word	0x5802541c
    a8b0:	f10c 0c14 	add.w	ip, ip, #20
    a8b4:	454a      	cmp	r2, r9
    a8b6:	bf08      	it	eq
    a8b8:	f043 0301 	orreq.w	r3, r3, #1
    a8bc:	fab1 f181 	clz	r1, r1
    a8c0:	0940      	lsrs	r0, r0, #5
    a8c2:	eba2 0c0c 	sub.w	ip, r2, ip
    a8c6:	ea4e 0303 	orr.w	r3, lr, r3
    a8ca:	0949      	lsrs	r1, r1, #5
    a8cc:	f8df 81e4 	ldr.w	r8, [pc, #484]	; aab4 <HAL_DMA_DeInit+0x4e8>
    a8d0:	fabc fc8c 	clz	ip, ip
    a8d4:	433b      	orrs	r3, r7
    a8d6:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
    a8da:	eba2 0808 	sub.w	r8, r2, r8
    a8de:	4333      	orrs	r3, r6
    a8e0:	fab8 f888 	clz	r8, r8
    a8e4:	432b      	orrs	r3, r5
    a8e6:	ea4f 1858 	mov.w	r8, r8, lsr #5
    a8ea:	4303      	orrs	r3, r0
    a8ec:	430b      	orrs	r3, r1
    a8ee:	ea5c 0303 	orrs.w	r3, ip, r3
    a8f2:	d102      	bne.n	a8fa <HAL_DMA_DeInit+0x32e>
    a8f4:	f1b8 0f00 	cmp.w	r8, #0
    a8f8:	d02b      	beq.n	a952 <HAL_DMA_DeInit+0x386>
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a8fa:	ea47 070e 	orr.w	r7, r7, lr
    a8fe:	b2d3      	uxtb	r3, r2
    a900:	433e      	orrs	r6, r7
    a902:	4335      	orrs	r5, r6
    a904:	4328      	orrs	r0, r5
    a906:	4301      	orrs	r1, r0
    a908:	ea5c 0101 	orrs.w	r1, ip, r1
    a90c:	d102      	bne.n	a914 <HAL_DMA_DeInit+0x348>
    a90e:	f1b8 0f00 	cmp.w	r8, #0
    a912:	d063      	beq.n	a9dc <HAL_DMA_DeInit+0x410>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a914:	4861      	ldr	r0, [pc, #388]	; (aa9c <HAL_DMA_DeInit+0x4d0>)
    a916:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a918:	4a61      	ldr	r2, [pc, #388]	; (aaa0 <HAL_DMA_DeInit+0x4d4>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a91a:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a91c:	fba0 0303 	umull	r0, r3, r0, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a920:	4860      	ldr	r0, [pc, #384]	; (aaa4 <HAL_DMA_DeInit+0x4d8>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
    a922:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    a924:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a926:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a928:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a92c:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a92e:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
    a932:	6622      	str	r2, [r4, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a934:	66a3      	str	r3, [r4, #104]	; 0x68
    if(hdma->DMAmuxChannel != 0U)
    a936:	b122      	cbz	r2, a942 <HAL_DMA_DeInit+0x376>
      hdma->DMAmuxChannel->CCR = 0U;
    a938:	2300      	movs	r3, #0
    a93a:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    a93c:	e9d4 3219 	ldrd	r3, r2, [r4, #100]	; 0x64
    a940:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
    a942:	6860      	ldr	r0, [r4, #4]
    a944:	1e41      	subs	r1, r0, #1
    a946:	2907      	cmp	r1, #7
    a948:	d912      	bls.n	a970 <HAL_DMA_DeInit+0x3a4>
    hdma->DMAmuxRequestGen = 0U;
    a94a:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
    a94c:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatusMask = 0U;
    a950:	6763      	str	r3, [r4, #116]	; 0x74
  hdma->XferCpltCallback       = NULL;
    a952:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    a954:	6563      	str	r3, [r4, #84]	; 0x54
  return HAL_OK;
    a956:	4618      	mov	r0, r3
  hdma->State = HAL_DMA_STATE_RESET;
    a958:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
    a95c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->XferHalfCpltCallback   = NULL;
    a960:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
    a964:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
  hdma->XferAbortCallback      = NULL;
    a968:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
}
    a96c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
    a970:	6822      	ldr	r2, [r4, #0]
    a972:	4b4d      	ldr	r3, [pc, #308]	; (aaa8 <HAL_DMA_DeInit+0x4dc>)
    a974:	4e4d      	ldr	r6, [pc, #308]	; (aaac <HAL_DMA_DeInit+0x4e0>)
    a976:	4d4e      	ldr	r5, [pc, #312]	; (aab0 <HAL_DMA_DeInit+0x4e4>)
    a978:	42b2      	cmp	r2, r6
    a97a:	bf18      	it	ne
    a97c:	429a      	cmpne	r2, r3
    a97e:	f106 0628 	add.w	r6, r6, #40	; 0x28
    a982:	bf0c      	ite	eq
    a984:	2301      	moveq	r3, #1
    a986:	2300      	movne	r3, #0
    a988:	42aa      	cmp	r2, r5
    a98a:	bf08      	it	eq
    a98c:	f043 0301 	orreq.w	r3, r3, #1
    a990:	3528      	adds	r5, #40	; 0x28
    a992:	42b2      	cmp	r2, r6
    a994:	bf08      	it	eq
    a996:	f043 0301 	orreq.w	r3, r3, #1
    a99a:	3628      	adds	r6, #40	; 0x28
    a99c:	42aa      	cmp	r2, r5
    a99e:	bf08      	it	eq
    a9a0:	f043 0301 	orreq.w	r3, r3, #1
    a9a4:	3528      	adds	r5, #40	; 0x28
    a9a6:	42b2      	cmp	r2, r6
    a9a8:	bf08      	it	eq
    a9aa:	f043 0301 	orreq.w	r3, r3, #1
    a9ae:	42aa      	cmp	r2, r5
    a9b0:	bf08      	it	eq
    a9b2:	f043 0301 	orreq.w	r3, r3, #1
    a9b6:	b913      	cbnz	r3, a9be <HAL_DMA_DeInit+0x3f2>
    a9b8:	4b3e      	ldr	r3, [pc, #248]	; (aab4 <HAL_DMA_DeInit+0x4e8>)
    a9ba:	429a      	cmp	r2, r3
    a9bc:	d169      	bne.n	aa92 <HAL_DMA_DeInit+0x4c6>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a9be:	4a3e      	ldr	r2, [pc, #248]	; (aab8 <HAL_DMA_DeInit+0x4ec>)
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    a9c0:	4d3e      	ldr	r5, [pc, #248]	; (aabc <HAL_DMA_DeInit+0x4f0>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
    a9c2:	4402      	add	r2, r0
    a9c4:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a9c6:	2301      	movs	r3, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a9c8:	2000      	movs	r0, #0
    a9ca:	6725      	str	r5, [r4, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
    a9cc:	fa03 f101 	lsl.w	r1, r3, r1
    a9d0:	6761      	str	r1, [r4, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
    a9d2:	6010      	str	r0, [r2, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    a9d4:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
    a9d8:	605a      	str	r2, [r3, #4]
    a9da:	e7b6      	b.n	a94a <HAL_DMA_DeInit+0x37e>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9dc:	4938      	ldr	r1, [pc, #224]	; (aac0 <HAL_DMA_DeInit+0x4f4>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a9de:	3b10      	subs	r3, #16
    a9e0:	4838      	ldr	r0, [pc, #224]	; (aac4 <HAL_DMA_DeInit+0x4f8>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9e2:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a9e4:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9e8:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
    a9ea:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
    a9ee:	d800      	bhi.n	a9f2 <HAL_DMA_DeInit+0x426>
      stream_number += 8U;
    a9f0:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a9f2:	4a35      	ldr	r2, [pc, #212]	; (aac8 <HAL_DMA_DeInit+0x4fc>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a9f4:	f003 051f 	and.w	r5, r3, #31
    a9f8:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    a9fa:	4834      	ldr	r0, [pc, #208]	; (aacc <HAL_DMA_DeInit+0x500>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    a9fc:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    a9fe:	40a9      	lsls	r1, r5
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    aa00:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    aa02:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
    aa04:	66a1      	str	r1, [r4, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    aa06:	6622      	str	r2, [r4, #96]	; 0x60
    aa08:	e795      	b.n	a936 <HAL_DMA_DeInit+0x36a>
    return HAL_ERROR;
    aa0a:	2001      	movs	r0, #1
}
    aa0c:	4770      	bx	lr
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    aa0e:	4b26      	ldr	r3, [pc, #152]	; (aaa8 <HAL_DMA_DeInit+0x4dc>)
    aa10:	4926      	ldr	r1, [pc, #152]	; (aaac <HAL_DMA_DeInit+0x4e0>)
    aa12:	4827      	ldr	r0, [pc, #156]	; (aab0 <HAL_DMA_DeInit+0x4e4>)
    aa14:	428a      	cmp	r2, r1
    aa16:	bf18      	it	ne
    aa18:	429a      	cmpne	r2, r3
    aa1a:	f101 0128 	add.w	r1, r1, #40	; 0x28
    aa1e:	4d2c      	ldr	r5, [pc, #176]	; (aad0 <HAL_DMA_DeInit+0x504>)
    aa20:	bf0c      	ite	eq
    aa22:	2301      	moveq	r3, #1
    aa24:	2300      	movne	r3, #0
    aa26:	4282      	cmp	r2, r0
    aa28:	bf08      	it	eq
    aa2a:	f043 0301 	orreq.w	r3, r3, #1
    aa2e:	303c      	adds	r0, #60	; 0x3c
    aa30:	428a      	cmp	r2, r1
    aa32:	bf08      	it	eq
    aa34:	f043 0301 	orreq.w	r3, r3, #1
    aa38:	313c      	adds	r1, #60	; 0x3c
    aa3a:	42aa      	cmp	r2, r5
    aa3c:	bf08      	it	eq
    aa3e:	f043 0301 	orreq.w	r3, r3, #1
    aa42:	4282      	cmp	r2, r0
    aa44:	bf08      	it	eq
    aa46:	f043 0301 	orreq.w	r3, r3, #1
    aa4a:	428a      	cmp	r2, r1
    aa4c:	bf08      	it	eq
    aa4e:	f043 0301 	orreq.w	r3, r3, #1
    aa52:	b913      	cbnz	r3, aa5a <HAL_DMA_DeInit+0x48e>
    aa54:	4b17      	ldr	r3, [pc, #92]	; (aab4 <HAL_DMA_DeInit+0x4e8>)
    aa56:	429a      	cmp	r2, r3
    aa58:	d118      	bne.n	aa8c <HAL_DMA_DeInit+0x4c0>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
    aa5a:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    aa5c:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
    aa5e:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
    aa60:	6822      	ldr	r2, [r4, #0]
    aa62:	6053      	str	r3, [r2, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
    aa64:	6822      	ldr	r2, [r4, #0]
    aa66:	6093      	str	r3, [r2, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
    aa68:	6822      	ldr	r2, [r4, #0]
    aa6a:	60d3      	str	r3, [r2, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
    aa6c:	6822      	ldr	r2, [r4, #0]
    aa6e:	6113      	str	r3, [r2, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
    aa70:	f7ff f900 	bl	9c74 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    aa74:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    aa76:	2301      	movs	r3, #1
    aa78:	f002 021f 	and.w	r2, r2, #31
    aa7c:	4093      	lsls	r3, r2
    aa7e:	6043      	str	r3, [r0, #4]
    aa80:	e679      	b.n	a776 <HAL_DMA_DeInit+0x1aa>
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
    aa82:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
    aa86:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    aa88:	65a1      	str	r1, [r4, #88]	; 0x58
    aa8a:	e66e      	b.n	a76a <HAL_DMA_DeInit+0x19e>
    return HAL_ERROR;
    aa8c:	2001      	movs	r0, #1
}
    aa8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa92:	4a10      	ldr	r2, [pc, #64]	; (aad4 <HAL_DMA_DeInit+0x508>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    aa94:	4d10      	ldr	r5, [pc, #64]	; (aad8 <HAL_DMA_DeInit+0x50c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
    aa96:	4402      	add	r2, r0
    aa98:	0092      	lsls	r2, r2, #2
    aa9a:	e794      	b.n	a9c6 <HAL_DMA_DeInit+0x3fa>
    aa9c:	cccccccd 	.word	0xcccccccd
    aaa0:	16009600 	.word	0x16009600
    aaa4:	58025880 	.word	0x58025880
    aaa8:	58025408 	.word	0x58025408
    aaac:	5802541c 	.word	0x5802541c
    aab0:	58025430 	.word	0x58025430
    aab4:	58025494 	.word	0x58025494
    aab8:	1600963f 	.word	0x1600963f
    aabc:	58025940 	.word	0x58025940
    aac0:	bffdfbf0 	.word	0xbffdfbf0
    aac4:	aaaaaaab 	.word	0xaaaaaaab
    aac8:	10008200 	.word	0x10008200
    aacc:	40020880 	.word	0x40020880
    aad0:	58025458 	.word	0x58025458
    aad4:	1000823f 	.word	0x1000823f
    aad8:	40020940 	.word	0x40020940

0000aadc <HAL_DMA_Start_IT>:
{
    aadc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aade:	461d      	mov	r5, r3
    aae0:	460e      	mov	r6, r1
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    aae2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
{
    aae6:	4604      	mov	r4, r0
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    aae8:	1e69      	subs	r1, r5, #1
{
    aaea:	4617      	mov	r7, r2
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    aaec:	4299      	cmp	r1, r3
    aaee:	d813      	bhi.n	ab18 <HAL_DMA_Start_IT+0x3c>
  if(hdma == NULL)
    aaf0:	b1cc      	cbz	r4, ab26 <HAL_DMA_Start_IT+0x4a>
  __HAL_LOCK(hdma);
    aaf2:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    aaf6:	2b01      	cmp	r3, #1
    aaf8:	f000 826f 	beq.w	afda <HAL_DMA_Start_IT+0x4fe>
    aafc:	2001      	movs	r0, #1
  if(HAL_DMA_STATE_READY == hdma->State)
    aafe:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    ab02:	4283      	cmp	r3, r0
  __HAL_LOCK(hdma);
    ab04:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
    ab08:	d012      	beq.n	ab30 <HAL_DMA_Start_IT+0x54>
    __HAL_UNLOCK(hdma);
    ab0a:	2200      	movs	r2, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    ab0c:	f44f 6300 	mov.w	r3, #2048	; 0x800
    __HAL_UNLOCK(hdma);
    ab10:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    ab14:	6563      	str	r3, [r4, #84]	; 0x54
}
    ab16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    ab18:	f240 21a7 	movw	r1, #679	; 0x2a7
    ab1c:	4803      	ldr	r0, [pc, #12]	; (ab2c <HAL_DMA_Start_IT+0x50>)
    ab1e:	f00e fccf 	bl	194c0 <assert_failed>
  if(hdma == NULL)
    ab22:	2c00      	cmp	r4, #0
    ab24:	d1e5      	bne.n	aaf2 <HAL_DMA_Start_IT+0x16>
    return HAL_ERROR;
    ab26:	2001      	movs	r0, #1
}
    ab28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ab2a:	bf00      	nop
    ab2c:	0002ff8c 	.word	0x0002ff8c
    hdma->State = HAL_DMA_STATE_BUSY;
    ab30:	2002      	movs	r0, #2
    __HAL_DMA_DISABLE(hdma);
    ab32:	6822      	ldr	r2, [r4, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
    ab34:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    ab38:	2000      	movs	r0, #0
    ab3a:	6560      	str	r0, [r4, #84]	; 0x54
    __HAL_DMA_DISABLE(hdma);
    ab3c:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ab3e:	489e      	ldr	r0, [pc, #632]	; (adb8 <HAL_DMA_Start_IT+0x2dc>)
    __HAL_DMA_DISABLE(hdma);
    ab40:	f023 0301 	bic.w	r3, r3, #1
    ab44:	6013      	str	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ab46:	4a9d      	ldr	r2, [pc, #628]	; (adbc <HAL_DMA_Start_IT+0x2e0>)
    ab48:	6821      	ldr	r1, [r4, #0]
    ab4a:	4b9d      	ldr	r3, [pc, #628]	; (adc0 <HAL_DMA_Start_IT+0x2e4>)
    ab4c:	4291      	cmp	r1, r2
    ab4e:	bf18      	it	ne
    ab50:	4281      	cmpne	r1, r0
    ab52:	f102 0230 	add.w	r2, r2, #48	; 0x30
    ab56:	bf0c      	ite	eq
    ab58:	2001      	moveq	r0, #1
    ab5a:	2000      	movne	r0, #0
    ab5c:	4299      	cmp	r1, r3
    ab5e:	bf08      	it	eq
    ab60:	f040 0001 	orreq.w	r0, r0, #1
    ab64:	3330      	adds	r3, #48	; 0x30
    ab66:	4291      	cmp	r1, r2
    ab68:	bf08      	it	eq
    ab6a:	f040 0001 	orreq.w	r0, r0, #1
    ab6e:	3230      	adds	r2, #48	; 0x30
    ab70:	4299      	cmp	r1, r3
    ab72:	bf08      	it	eq
    ab74:	f040 0001 	orreq.w	r0, r0, #1
    ab78:	3330      	adds	r3, #48	; 0x30
    ab7a:	4291      	cmp	r1, r2
    ab7c:	bf08      	it	eq
    ab7e:	f040 0001 	orreq.w	r0, r0, #1
    ab82:	3230      	adds	r2, #48	; 0x30
    ab84:	4299      	cmp	r1, r3
    ab86:	bf08      	it	eq
    ab88:	f040 0001 	orreq.w	r0, r0, #1
    ab8c:	f503 735c 	add.w	r3, r3, #880	; 0x370
    ab90:	4291      	cmp	r1, r2
    ab92:	bf08      	it	eq
    ab94:	f040 0001 	orreq.w	r0, r0, #1
    ab98:	f502 725c 	add.w	r2, r2, #880	; 0x370
    ab9c:	4299      	cmp	r1, r3
    ab9e:	bf08      	it	eq
    aba0:	f040 0001 	orreq.w	r0, r0, #1
    aba4:	3330      	adds	r3, #48	; 0x30
    aba6:	4291      	cmp	r1, r2
    aba8:	bf08      	it	eq
    abaa:	f040 0001 	orreq.w	r0, r0, #1
    abae:	3230      	adds	r2, #48	; 0x30
    abb0:	4299      	cmp	r1, r3
    abb2:	bf08      	it	eq
    abb4:	f040 0001 	orreq.w	r0, r0, #1
    abb8:	3330      	adds	r3, #48	; 0x30
    abba:	4291      	cmp	r1, r2
    abbc:	bf08      	it	eq
    abbe:	f040 0001 	orreq.w	r0, r0, #1
    abc2:	3230      	adds	r2, #48	; 0x30
    abc4:	4299      	cmp	r1, r3
    abc6:	bf08      	it	eq
    abc8:	f040 0001 	orreq.w	r0, r0, #1
    abcc:	3330      	adds	r3, #48	; 0x30
    abce:	4291      	cmp	r1, r2
    abd0:	bf08      	it	eq
    abd2:	f040 0001 	orreq.w	r0, r0, #1
    abd6:	3230      	adds	r2, #48	; 0x30
    abd8:	4299      	cmp	r1, r3
    abda:	bf08      	it	eq
    abdc:	f040 0001 	orreq.w	r0, r0, #1
    abe0:	4b78      	ldr	r3, [pc, #480]	; (adc4 <HAL_DMA_Start_IT+0x2e8>)
    abe2:	4291      	cmp	r1, r2
    abe4:	bf08      	it	eq
    abe6:	f040 0001 	orreq.w	r0, r0, #1
    abea:	4a77      	ldr	r2, [pc, #476]	; (adc8 <HAL_DMA_Start_IT+0x2ec>)
    abec:	4299      	cmp	r1, r3
    abee:	bf08      	it	eq
    abf0:	f040 0001 	orreq.w	r0, r0, #1
    abf4:	3328      	adds	r3, #40	; 0x28
    abf6:	4291      	cmp	r1, r2
    abf8:	bf08      	it	eq
    abfa:	f040 0001 	orreq.w	r0, r0, #1
    abfe:	3228      	adds	r2, #40	; 0x28
    ac00:	4299      	cmp	r1, r3
    ac02:	bf08      	it	eq
    ac04:	f040 0001 	orreq.w	r0, r0, #1
    ac08:	3328      	adds	r3, #40	; 0x28
    ac0a:	4291      	cmp	r1, r2
    ac0c:	bf08      	it	eq
    ac0e:	f040 0001 	orreq.w	r0, r0, #1
    ac12:	3228      	adds	r2, #40	; 0x28
    ac14:	4299      	cmp	r1, r3
    ac16:	bf08      	it	eq
    ac18:	f040 0001 	orreq.w	r0, r0, #1
    ac1c:	3328      	adds	r3, #40	; 0x28
    ac1e:	4291      	cmp	r1, r2
    ac20:	bf08      	it	eq
    ac22:	f040 0001 	orreq.w	r0, r0, #1
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
    ac26:	6da2      	ldr	r2, [r4, #88]	; 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ac28:	4299      	cmp	r1, r3
    ac2a:	bf08      	it	eq
    ac2c:	f040 0001 	orreq.w	r0, r0, #1
    ac30:	b910      	cbnz	r0, ac38 <HAL_DMA_Start_IT+0x15c>
    ac32:	3314      	adds	r3, #20
    ac34:	4299      	cmp	r1, r3
    ac36:	d108      	bne.n	ac4a <HAL_DMA_Start_IT+0x16e>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    ac38:	e9d4 3119 	ldrd	r3, r1, [r4, #100]	; 0x64
    ac3c:	6059      	str	r1, [r3, #4]
    if(hdma->DMAmuxRequestGen != 0U)
    ac3e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    ac40:	b113      	cbz	r3, ac48 <HAL_DMA_Start_IT+0x16c>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    ac42:	e9d4 311c 	ldrd	r3, r1, [r4, #112]	; 0x70
    ac46:	6059      	str	r1, [r3, #4]
    ac48:	6821      	ldr	r1, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    ac4a:	4b5b      	ldr	r3, [pc, #364]	; (adb8 <HAL_DMA_Start_IT+0x2dc>)
    ac4c:	f8df c16c 	ldr.w	ip, [pc, #364]	; adbc <HAL_DMA_Start_IT+0x2e0>
    ac50:	485b      	ldr	r0, [pc, #364]	; (adc0 <HAL_DMA_Start_IT+0x2e4>)
    ac52:	4561      	cmp	r1, ip
    ac54:	bf18      	it	ne
    ac56:	4299      	cmpne	r1, r3
    ac58:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    ac5c:	bf0c      	ite	eq
    ac5e:	2301      	moveq	r3, #1
    ac60:	2300      	movne	r3, #0
    ac62:	4281      	cmp	r1, r0
    ac64:	bf08      	it	eq
    ac66:	f043 0301 	orreq.w	r3, r3, #1
    ac6a:	3030      	adds	r0, #48	; 0x30
    ac6c:	4561      	cmp	r1, ip
    ac6e:	bf08      	it	eq
    ac70:	f043 0301 	orreq.w	r3, r3, #1
    ac74:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    ac78:	4281      	cmp	r1, r0
    ac7a:	bf08      	it	eq
    ac7c:	f043 0301 	orreq.w	r3, r3, #1
    ac80:	3030      	adds	r0, #48	; 0x30
    ac82:	4561      	cmp	r1, ip
    ac84:	bf08      	it	eq
    ac86:	f043 0301 	orreq.w	r3, r3, #1
    ac8a:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    ac8e:	4281      	cmp	r1, r0
    ac90:	bf08      	it	eq
    ac92:	f043 0301 	orreq.w	r3, r3, #1
    ac96:	f500 705c 	add.w	r0, r0, #880	; 0x370
    ac9a:	4561      	cmp	r1, ip
    ac9c:	bf08      	it	eq
    ac9e:	f043 0301 	orreq.w	r3, r3, #1
    aca2:	f50c 7c5c 	add.w	ip, ip, #880	; 0x370
    aca6:	4281      	cmp	r1, r0
    aca8:	bf08      	it	eq
    acaa:	f043 0301 	orreq.w	r3, r3, #1
    acae:	3030      	adds	r0, #48	; 0x30
    acb0:	4561      	cmp	r1, ip
    acb2:	bf08      	it	eq
    acb4:	f043 0301 	orreq.w	r3, r3, #1
    acb8:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    acbc:	4281      	cmp	r1, r0
    acbe:	bf08      	it	eq
    acc0:	f043 0301 	orreq.w	r3, r3, #1
    acc4:	3030      	adds	r0, #48	; 0x30
    acc6:	4561      	cmp	r1, ip
    acc8:	bf08      	it	eq
    acca:	f043 0301 	orreq.w	r3, r3, #1
    acce:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    acd2:	4281      	cmp	r1, r0
    acd4:	bf08      	it	eq
    acd6:	f043 0301 	orreq.w	r3, r3, #1
    acda:	3030      	adds	r0, #48	; 0x30
    acdc:	4561      	cmp	r1, ip
    acde:	bf08      	it	eq
    ace0:	f043 0301 	orreq.w	r3, r3, #1
    ace4:	4281      	cmp	r1, r0
    ace6:	bf08      	it	eq
    ace8:	f043 0301 	orreq.w	r3, r3, #1
    acec:	b91b      	cbnz	r3, acf6 <HAL_DMA_Start_IT+0x21a>
    acee:	4b37      	ldr	r3, [pc, #220]	; (adcc <HAL_DMA_Start_IT+0x2f0>)
    acf0:	4299      	cmp	r1, r3
    acf2:	f040 8174 	bne.w	afde <HAL_DMA_Start_IT+0x502>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
    acf6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    acf8:	233f      	movs	r3, #63	; 0x3f
    acfa:	f001 011f 	and.w	r1, r1, #31
    acfe:	408b      	lsls	r3, r1
    ad00:	6093      	str	r3, [r2, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
    ad02:	6822      	ldr	r2, [r4, #0]
    ad04:	6813      	ldr	r3, [r2, #0]
    ad06:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    ad0a:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
    ad0c:	6823      	ldr	r3, [r4, #0]
    ad0e:	605d      	str	r5, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    ad10:	68a3      	ldr	r3, [r4, #8]
    ad12:	2b40      	cmp	r3, #64	; 0x40
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
    ad14:	6823      	ldr	r3, [r4, #0]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    ad16:	f000 815b 	beq.w	afd0 <HAL_DMA_Start_IT+0x4f4>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
    ad1a:	609e      	str	r6, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
    ad1c:	6823      	ldr	r3, [r4, #0]
    ad1e:	60df      	str	r7, [r3, #12]
    ad20:	6821      	ldr	r1, [r4, #0]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    ad22:	4b25      	ldr	r3, [pc, #148]	; (adb8 <HAL_DMA_Start_IT+0x2dc>)
    ad24:	4825      	ldr	r0, [pc, #148]	; (adbc <HAL_DMA_Start_IT+0x2e0>)
    ad26:	4a26      	ldr	r2, [pc, #152]	; (adc0 <HAL_DMA_Start_IT+0x2e4>)
    ad28:	4281      	cmp	r1, r0
    ad2a:	bf18      	it	ne
    ad2c:	4299      	cmpne	r1, r3
    ad2e:	4d28      	ldr	r5, [pc, #160]	; (add0 <HAL_DMA_Start_IT+0x2f4>)
    ad30:	f100 0048 	add.w	r0, r0, #72	; 0x48
    ad34:	bf0c      	ite	eq
    ad36:	2301      	moveq	r3, #1
    ad38:	2300      	movne	r3, #0
    ad3a:	4291      	cmp	r1, r2
    ad3c:	bf08      	it	eq
    ad3e:	f043 0301 	orreq.w	r3, r3, #1
    ad42:	3248      	adds	r2, #72	; 0x48
    ad44:	42a9      	cmp	r1, r5
    ad46:	bf08      	it	eq
    ad48:	f043 0301 	orreq.w	r3, r3, #1
    ad4c:	3548      	adds	r5, #72	; 0x48
    ad4e:	4281      	cmp	r1, r0
    ad50:	bf08      	it	eq
    ad52:	f043 0301 	orreq.w	r3, r3, #1
    ad56:	3048      	adds	r0, #72	; 0x48
    ad58:	4291      	cmp	r1, r2
    ad5a:	bf08      	it	eq
    ad5c:	f043 0301 	orreq.w	r3, r3, #1
    ad60:	f502 7262 	add.w	r2, r2, #904	; 0x388
    ad64:	42a9      	cmp	r1, r5
    ad66:	bf08      	it	eq
    ad68:	f043 0301 	orreq.w	r3, r3, #1
    ad6c:	f505 7562 	add.w	r5, r5, #904	; 0x388
    ad70:	4281      	cmp	r1, r0
    ad72:	bf08      	it	eq
    ad74:	f043 0301 	orreq.w	r3, r3, #1
    ad78:	f500 7062 	add.w	r0, r0, #904	; 0x388
    ad7c:	4291      	cmp	r1, r2
    ad7e:	bf08      	it	eq
    ad80:	f043 0301 	orreq.w	r3, r3, #1
    ad84:	3248      	adds	r2, #72	; 0x48
    ad86:	42a9      	cmp	r1, r5
    ad88:	bf08      	it	eq
    ad8a:	f043 0301 	orreq.w	r3, r3, #1
    ad8e:	3548      	adds	r5, #72	; 0x48
    ad90:	4281      	cmp	r1, r0
    ad92:	bf08      	it	eq
    ad94:	f043 0301 	orreq.w	r3, r3, #1
    ad98:	3048      	adds	r0, #72	; 0x48
    ad9a:	4291      	cmp	r1, r2
    ad9c:	bf08      	it	eq
    ad9e:	f043 0301 	orreq.w	r3, r3, #1
    ada2:	3248      	adds	r2, #72	; 0x48
    ada4:	42a9      	cmp	r1, r5
    ada6:	bf08      	it	eq
    ada8:	f043 0301 	orreq.w	r3, r3, #1
    adac:	4281      	cmp	r1, r0
    adae:	bf08      	it	eq
    adb0:	f043 0301 	orreq.w	r3, r3, #1
    adb4:	e00e      	b.n	add4 <HAL_DMA_Start_IT+0x2f8>
    adb6:	bf00      	nop
    adb8:	40020010 	.word	0x40020010
    adbc:	40020028 	.word	0x40020028
    adc0:	40020040 	.word	0x40020040
    adc4:	58025408 	.word	0x58025408
    adc8:	5802541c 	.word	0x5802541c
    adcc:	400204b8 	.word	0x400204b8
    add0:	40020058 	.word	0x40020058
    add4:	4291      	cmp	r1, r2
    add6:	bf08      	it	eq
    add8:	f043 0301 	orreq.w	r3, r3, #1
    addc:	b91b      	cbnz	r3, ade6 <HAL_DMA_Start_IT+0x30a>
    adde:	4b9a      	ldr	r3, [pc, #616]	; (b048 <HAL_DMA_Start_IT+0x56c>)
    ade0:	4299      	cmp	r1, r3
    ade2:	f040 8145 	bne.w	b070 <HAL_DMA_Start_IT+0x594>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
    ade6:	680b      	ldr	r3, [r1, #0]
    ade8:	f023 031e 	bic.w	r3, r3, #30
    adec:	f043 0316 	orr.w	r3, r3, #22
    adf0:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
    adf2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    adf4:	b123      	cbz	r3, ae00 <HAL_DMA_Start_IT+0x324>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
    adf6:	6822      	ldr	r2, [r4, #0]
    adf8:	6813      	ldr	r3, [r2, #0]
    adfa:	f043 0308 	orr.w	r3, r3, #8
    adfe:	6013      	str	r3, [r2, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    ae00:	6821      	ldr	r1, [r4, #0]
    ae02:	4b92      	ldr	r3, [pc, #584]	; (b04c <HAL_DMA_Start_IT+0x570>)
    ae04:	4a92      	ldr	r2, [pc, #584]	; (b050 <HAL_DMA_Start_IT+0x574>)
    ae06:	4d93      	ldr	r5, [pc, #588]	; (b054 <HAL_DMA_Start_IT+0x578>)
    ae08:	4291      	cmp	r1, r2
    ae0a:	bf18      	it	ne
    ae0c:	4299      	cmpne	r1, r3
    ae0e:	4892      	ldr	r0, [pc, #584]	; (b058 <HAL_DMA_Start_IT+0x57c>)
    ae10:	f102 0248 	add.w	r2, r2, #72	; 0x48
    ae14:	bf0c      	ite	eq
    ae16:	2301      	moveq	r3, #1
    ae18:	2300      	movne	r3, #0
    ae1a:	42a9      	cmp	r1, r5
    ae1c:	bf08      	it	eq
    ae1e:	f043 0301 	orreq.w	r3, r3, #1
    ae22:	3548      	adds	r5, #72	; 0x48
    ae24:	4281      	cmp	r1, r0
    ae26:	bf08      	it	eq
    ae28:	f043 0301 	orreq.w	r3, r3, #1
    ae2c:	3048      	adds	r0, #72	; 0x48
    ae2e:	4291      	cmp	r1, r2
    ae30:	bf08      	it	eq
    ae32:	f043 0301 	orreq.w	r3, r3, #1
    ae36:	3248      	adds	r2, #72	; 0x48
    ae38:	42a9      	cmp	r1, r5
    ae3a:	bf08      	it	eq
    ae3c:	f043 0301 	orreq.w	r3, r3, #1
    ae40:	f505 7562 	add.w	r5, r5, #904	; 0x388
    ae44:	4281      	cmp	r1, r0
    ae46:	bf08      	it	eq
    ae48:	f043 0301 	orreq.w	r3, r3, #1
    ae4c:	f500 7062 	add.w	r0, r0, #904	; 0x388
    ae50:	4291      	cmp	r1, r2
    ae52:	bf08      	it	eq
    ae54:	f043 0301 	orreq.w	r3, r3, #1
    ae58:	f502 7262 	add.w	r2, r2, #904	; 0x388
    ae5c:	42a9      	cmp	r1, r5
    ae5e:	bf08      	it	eq
    ae60:	f043 0301 	orreq.w	r3, r3, #1
    ae64:	3548      	adds	r5, #72	; 0x48
    ae66:	4281      	cmp	r1, r0
    ae68:	bf08      	it	eq
    ae6a:	f043 0301 	orreq.w	r3, r3, #1
    ae6e:	3048      	adds	r0, #72	; 0x48
    ae70:	4291      	cmp	r1, r2
    ae72:	bf08      	it	eq
    ae74:	f043 0301 	orreq.w	r3, r3, #1
    ae78:	3248      	adds	r2, #72	; 0x48
    ae7a:	42a9      	cmp	r1, r5
    ae7c:	bf08      	it	eq
    ae7e:	f043 0301 	orreq.w	r3, r3, #1
    ae82:	3548      	adds	r5, #72	; 0x48
    ae84:	4281      	cmp	r1, r0
    ae86:	bf08      	it	eq
    ae88:	f043 0301 	orreq.w	r3, r3, #1
    ae8c:	3048      	adds	r0, #72	; 0x48
    ae8e:	4291      	cmp	r1, r2
    ae90:	bf08      	it	eq
    ae92:	f043 0301 	orreq.w	r3, r3, #1
    ae96:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
    ae9a:	42a9      	cmp	r1, r5
    ae9c:	bf08      	it	eq
    ae9e:	f043 0301 	orreq.w	r3, r3, #1
    aea2:	f502 429f 	add.w	r2, r2, #20352	; 0x4f80
    aea6:	4d6d      	ldr	r5, [pc, #436]	; (b05c <HAL_DMA_Start_IT+0x580>)
    aea8:	4281      	cmp	r1, r0
    aeaa:	bf08      	it	eq
    aeac:	f043 0301 	orreq.w	r3, r3, #1
    aeb0:	486b      	ldr	r0, [pc, #428]	; (b060 <HAL_DMA_Start_IT+0x584>)
    aeb2:	4291      	cmp	r1, r2
    aeb4:	bf08      	it	eq
    aeb6:	f043 0301 	orreq.w	r3, r3, #1
    aeba:	323c      	adds	r2, #60	; 0x3c
    aebc:	42a9      	cmp	r1, r5
    aebe:	bf08      	it	eq
    aec0:	f043 0301 	orreq.w	r3, r3, #1
    aec4:	353c      	adds	r5, #60	; 0x3c
    aec6:	4281      	cmp	r1, r0
    aec8:	bf08      	it	eq
    aeca:	f043 0301 	orreq.w	r3, r3, #1
    aece:	303c      	adds	r0, #60	; 0x3c
    aed0:	4291      	cmp	r1, r2
    aed2:	bf08      	it	eq
    aed4:	f043 0301 	orreq.w	r3, r3, #1
    aed8:	323c      	adds	r2, #60	; 0x3c
    aeda:	42a9      	cmp	r1, r5
    aedc:	bf08      	it	eq
    aede:	f043 0301 	orreq.w	r3, r3, #1
    aee2:	4281      	cmp	r1, r0
    aee4:	bf08      	it	eq
    aee6:	f043 0301 	orreq.w	r3, r3, #1
    aeea:	4291      	cmp	r1, r2
    aeec:	bf08      	it	eq
    aeee:	f043 0301 	orreq.w	r3, r3, #1
    aef2:	b913      	cbnz	r3, aefa <HAL_DMA_Start_IT+0x41e>
    aef4:	4b5b      	ldr	r3, [pc, #364]	; (b064 <HAL_DMA_Start_IT+0x588>)
    aef6:	4299      	cmp	r1, r3
    aef8:	d10e      	bne.n	af18 <HAL_DMA_Start_IT+0x43c>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
    aefa:	6e23      	ldr	r3, [r4, #96]	; 0x60
    aefc:	681a      	ldr	r2, [r3, #0]
    aefe:	03d2      	lsls	r2, r2, #15
    af00:	d503      	bpl.n	af0a <HAL_DMA_Start_IT+0x42e>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
    af02:	681a      	ldr	r2, [r3, #0]
    af04:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    af08:	601a      	str	r2, [r3, #0]
      if(hdma->DMAmuxRequestGen != 0U)
    af0a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    af0c:	b11b      	cbz	r3, af16 <HAL_DMA_Start_IT+0x43a>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
    af0e:	681a      	ldr	r2, [r3, #0]
    af10:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    af14:	601a      	str	r2, [r3, #0]
    af16:	6821      	ldr	r1, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
    af18:	4b4c      	ldr	r3, [pc, #304]	; (b04c <HAL_DMA_Start_IT+0x570>)
    af1a:	484d      	ldr	r0, [pc, #308]	; (b050 <HAL_DMA_Start_IT+0x574>)
    af1c:	4a4d      	ldr	r2, [pc, #308]	; (b054 <HAL_DMA_Start_IT+0x578>)
    af1e:	4281      	cmp	r1, r0
    af20:	bf18      	it	ne
    af22:	4299      	cmpne	r1, r3
    af24:	4d4c      	ldr	r5, [pc, #304]	; (b058 <HAL_DMA_Start_IT+0x57c>)
    af26:	4c50      	ldr	r4, [pc, #320]	; (b068 <HAL_DMA_Start_IT+0x58c>)
    af28:	f100 0060 	add.w	r0, r0, #96	; 0x60
    af2c:	bf0c      	ite	eq
    af2e:	2301      	moveq	r3, #1
    af30:	2300      	movne	r3, #0
    af32:	4291      	cmp	r1, r2
    af34:	bf08      	it	eq
    af36:	f043 0301 	orreq.w	r3, r3, #1
    af3a:	3260      	adds	r2, #96	; 0x60
    af3c:	42a9      	cmp	r1, r5
    af3e:	bf08      	it	eq
    af40:	f043 0301 	orreq.w	r3, r3, #1
    af44:	3560      	adds	r5, #96	; 0x60
    af46:	42a1      	cmp	r1, r4
    af48:	bf08      	it	eq
    af4a:	f043 0301 	orreq.w	r3, r3, #1
    af4e:	f504 7468 	add.w	r4, r4, #928	; 0x3a0
    af52:	4281      	cmp	r1, r0
    af54:	bf08      	it	eq
    af56:	f043 0301 	orreq.w	r3, r3, #1
    af5a:	f500 7068 	add.w	r0, r0, #928	; 0x3a0
    af5e:	4291      	cmp	r1, r2
    af60:	bf08      	it	eq
    af62:	f043 0301 	orreq.w	r3, r3, #1
    af66:	f502 7268 	add.w	r2, r2, #928	; 0x3a0
    af6a:	42a9      	cmp	r1, r5
    af6c:	bf08      	it	eq
    af6e:	f043 0301 	orreq.w	r3, r3, #1
    af72:	f505 7568 	add.w	r5, r5, #928	; 0x3a0
    af76:	42a1      	cmp	r1, r4
    af78:	bf08      	it	eq
    af7a:	f043 0301 	orreq.w	r3, r3, #1
    af7e:	3460      	adds	r4, #96	; 0x60
    af80:	4281      	cmp	r1, r0
    af82:	bf08      	it	eq
    af84:	f043 0301 	orreq.w	r3, r3, #1
    af88:	3060      	adds	r0, #96	; 0x60
    af8a:	4291      	cmp	r1, r2
    af8c:	bf08      	it	eq
    af8e:	f043 0301 	orreq.w	r3, r3, #1
    af92:	3260      	adds	r2, #96	; 0x60
    af94:	42a9      	cmp	r1, r5
    af96:	bf08      	it	eq
    af98:	f043 0301 	orreq.w	r3, r3, #1
    af9c:	42a1      	cmp	r1, r4
    af9e:	bf08      	it	eq
    afa0:	f043 0301 	orreq.w	r3, r3, #1
    afa4:	4281      	cmp	r1, r0
    afa6:	bf08      	it	eq
    afa8:	f043 0301 	orreq.w	r3, r3, #1
    afac:	4291      	cmp	r1, r2
    afae:	bf08      	it	eq
    afb0:	f043 0301 	orreq.w	r3, r3, #1
    afb4:	b933      	cbnz	r3, afc4 <HAL_DMA_Start_IT+0x4e8>
    afb6:	3030      	adds	r0, #48	; 0x30
    afb8:	1a08      	subs	r0, r1, r0
    afba:	fab0 f080 	clz	r0, r0
    afbe:	0940      	lsrs	r0, r0, #5
    afc0:	2800      	cmp	r0, #0
    afc2:	d03c      	beq.n	b03e <HAL_DMA_Start_IT+0x562>
    afc4:	680b      	ldr	r3, [r1, #0]
  HAL_StatusTypeDef status = HAL_OK;
    afc6:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
    afc8:	f043 0301 	orr.w	r3, r3, #1
    afcc:	600b      	str	r3, [r1, #0]
}
    afce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
    afd0:	609f      	str	r7, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
    afd2:	6823      	ldr	r3, [r4, #0]
    afd4:	60de      	str	r6, [r3, #12]
    afd6:	6821      	ldr	r1, [r4, #0]
    afd8:	e6a3      	b.n	ad22 <HAL_DMA_Start_IT+0x246>
  __HAL_LOCK(hdma);
    afda:	2002      	movs	r0, #2
}
    afdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
    afde:	4b23      	ldr	r3, [pc, #140]	; (b06c <HAL_DMA_Start_IT+0x590>)
    afe0:	f8df c078 	ldr.w	ip, [pc, #120]	; b05c <HAL_DMA_Start_IT+0x580>
    afe4:	481e      	ldr	r0, [pc, #120]	; (b060 <HAL_DMA_Start_IT+0x584>)
    afe6:	4561      	cmp	r1, ip
    afe8:	bf18      	it	ne
    afea:	4299      	cmpne	r1, r3
    afec:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    aff0:	bf0c      	ite	eq
    aff2:	2301      	moveq	r3, #1
    aff4:	2300      	movne	r3, #0
    aff6:	4281      	cmp	r1, r0
    aff8:	bf08      	it	eq
    affa:	f043 0301 	orreq.w	r3, r3, #1
    affe:	3028      	adds	r0, #40	; 0x28
    b000:	4561      	cmp	r1, ip
    b002:	bf08      	it	eq
    b004:	f043 0301 	orreq.w	r3, r3, #1
    b008:	f10c 0c28 	add.w	ip, ip, #40	; 0x28
    b00c:	4281      	cmp	r1, r0
    b00e:	bf08      	it	eq
    b010:	f043 0301 	orreq.w	r3, r3, #1
    b014:	3028      	adds	r0, #40	; 0x28
    b016:	4561      	cmp	r1, ip
    b018:	bf08      	it	eq
    b01a:	f043 0301 	orreq.w	r3, r3, #1
    b01e:	4281      	cmp	r1, r0
    b020:	bf08      	it	eq
    b022:	f043 0301 	orreq.w	r3, r3, #1
    b026:	b91b      	cbnz	r3, b030 <HAL_DMA_Start_IT+0x554>
    b028:	4b0e      	ldr	r3, [pc, #56]	; (b064 <HAL_DMA_Start_IT+0x588>)
    b02a:	4299      	cmp	r1, r3
    b02c:	f47f ae79 	bne.w	ad22 <HAL_DMA_Start_IT+0x246>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
    b030:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    b032:	2301      	movs	r3, #1
    b034:	f001 011f 	and.w	r1, r1, #31
    b038:	408b      	lsls	r3, r1
    b03a:	6053      	str	r3, [r2, #4]
    b03c:	e666      	b.n	ad0c <HAL_DMA_Start_IT+0x230>
    __HAL_DMA_ENABLE(hdma);
    b03e:	680b      	ldr	r3, [r1, #0]
    b040:	f043 0301 	orr.w	r3, r3, #1
    b044:	600b      	str	r3, [r1, #0]
}
    b046:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b048:	400204b8 	.word	0x400204b8
    b04c:	40020010 	.word	0x40020010
    b050:	40020028 	.word	0x40020028
    b054:	40020040 	.word	0x40020040
    b058:	40020058 	.word	0x40020058
    b05c:	5802541c 	.word	0x5802541c
    b060:	58025430 	.word	0x58025430
    b064:	58025494 	.word	0x58025494
    b068:	40020070 	.word	0x40020070
    b06c:	58025408 	.word	0x58025408
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
    b070:	680b      	ldr	r3, [r1, #0]
    b072:	f023 030e 	bic.w	r3, r3, #14
    b076:	f043 030a 	orr.w	r3, r3, #10
    b07a:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
    b07c:	6c23      	ldr	r3, [r4, #64]	; 0x40
    b07e:	2b00      	cmp	r3, #0
    b080:	f43f aebe 	beq.w	ae00 <HAL_DMA_Start_IT+0x324>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
    b084:	6822      	ldr	r2, [r4, #0]
    b086:	6813      	ldr	r3, [r2, #0]
    b088:	f043 0304 	orr.w	r3, r3, #4
    b08c:	6013      	str	r3, [r2, #0]
    b08e:	e6b7      	b.n	ae00 <HAL_DMA_Start_IT+0x324>

0000b090 <HAL_DMA_Abort_IT>:
  if(hdma == NULL)
    b090:	2800      	cmp	r0, #0
    b092:	d06a      	beq.n	b16a <HAL_DMA_Abort_IT+0xda>
{
    b094:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if(hdma->State != HAL_DMA_STATE_BUSY)
    b098:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    b09c:	4603      	mov	r3, r0
    b09e:	2a02      	cmp	r2, #2
    b0a0:	d004      	beq.n	b0ac <HAL_DMA_Abort_IT+0x1c>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
    b0a2:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
    b0a4:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
    b0a6:	655a      	str	r2, [r3, #84]	; 0x54
}
    b0a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b0ac:	6802      	ldr	r2, [r0, #0]
    b0ae:	4986      	ldr	r1, [pc, #536]	; (b2c8 <HAL_DMA_Abort_IT+0x238>)
    b0b0:	428a      	cmp	r2, r1
    b0b2:	d050      	beq.n	b156 <HAL_DMA_Abort_IT+0xc6>
    b0b4:	4885      	ldr	r0, [pc, #532]	; (b2cc <HAL_DMA_Abort_IT+0x23c>)
    b0b6:	4282      	cmp	r2, r0
    b0b8:	d04d      	beq.n	b156 <HAL_DMA_Abort_IT+0xc6>
    b0ba:	f8df 8228 	ldr.w	r8, [pc, #552]	; b2e4 <HAL_DMA_Abort_IT+0x254>
    b0be:	f8df 9220 	ldr.w	r9, [pc, #544]	; b2e0 <HAL_DMA_Abort_IT+0x250>
    b0c2:	f8df e230 	ldr.w	lr, [pc, #560]	; b2f4 <HAL_DMA_Abort_IT+0x264>
    b0c6:	454a      	cmp	r2, r9
    b0c8:	bf18      	it	ne
    b0ca:	4542      	cmpne	r2, r8
    b0cc:	f8df c228 	ldr.w	ip, [pc, #552]	; b2f8 <HAL_DMA_Abort_IT+0x268>
    b0d0:	4f7f      	ldr	r7, [pc, #508]	; (b2d0 <HAL_DMA_Abort_IT+0x240>)
    b0d2:	bf0c      	ite	eq
    b0d4:	f04f 0a01 	moveq.w	sl, #1
    b0d8:	f04f 0a00 	movne.w	sl, #0
    b0dc:	4c7d      	ldr	r4, [pc, #500]	; (b2d4 <HAL_DMA_Abort_IT+0x244>)
    b0de:	4572      	cmp	r2, lr
    b0e0:	bf08      	it	eq
    b0e2:	f04a 0a01 	orreq.w	sl, sl, #1
    b0e6:	f8df b214 	ldr.w	fp, [pc, #532]	; b2fc <HAL_DMA_Abort_IT+0x26c>
    b0ea:	4e7b      	ldr	r6, [pc, #492]	; (b2d8 <HAL_DMA_Abort_IT+0x248>)
    b0ec:	4562      	cmp	r2, ip
    b0ee:	bf08      	it	eq
    b0f0:	f04a 0a01 	orreq.w	sl, sl, #1
    b0f4:	4d79      	ldr	r5, [pc, #484]	; (b2dc <HAL_DMA_Abort_IT+0x24c>)
    b0f6:	42ba      	cmp	r2, r7
    b0f8:	bf08      	it	eq
    b0fa:	f04a 0a01 	orreq.w	sl, sl, #1
    b0fe:	42a2      	cmp	r2, r4
    b100:	bf08      	it	eq
    b102:	f04a 0a01 	orreq.w	sl, sl, #1
    b106:	f504 7456 	add.w	r4, r4, #856	; 0x358
    b10a:	42a2      	cmp	r2, r4
    b10c:	bf08      	it	eq
    b10e:	f04a 0a01 	orreq.w	sl, sl, #1
    b112:	3418      	adds	r4, #24
    b114:	42a2      	cmp	r2, r4
    b116:	bf08      	it	eq
    b118:	f04a 0a01 	orreq.w	sl, sl, #1
    b11c:	3418      	adds	r4, #24
    b11e:	42a2      	cmp	r2, r4
    b120:	bf08      	it	eq
    b122:	f04a 0a01 	orreq.w	sl, sl, #1
    b126:	3460      	adds	r4, #96	; 0x60
    b128:	455a      	cmp	r2, fp
    b12a:	bf08      	it	eq
    b12c:	f04a 0a01 	orreq.w	sl, sl, #1
    b130:	42b2      	cmp	r2, r6
    b132:	bf08      	it	eq
    b134:	f04a 0a01 	orreq.w	sl, sl, #1
    b138:	42aa      	cmp	r2, r5
    b13a:	bf08      	it	eq
    b13c:	f04a 0a01 	orreq.w	sl, sl, #1
    b140:	42a2      	cmp	r2, r4
    b142:	bf08      	it	eq
    b144:	f04a 0a01 	orreq.w	sl, sl, #1
    b148:	f1ba 0f00 	cmp.w	sl, #0
    b14c:	d103      	bne.n	b156 <HAL_DMA_Abort_IT+0xc6>
    b14e:	f8df a1b0 	ldr.w	sl, [pc, #432]	; b300 <HAL_DMA_Abort_IT+0x270>
    b152:	4552      	cmp	r2, sl
    b154:	d10b      	bne.n	b16e <HAL_DMA_Abort_IT+0xde>
      hdma->State = HAL_DMA_STATE_ABORT;
    b156:	2104      	movs	r1, #4
  return HAL_OK;
    b158:	2000      	movs	r0, #0
      hdma->State = HAL_DMA_STATE_ABORT;
    b15a:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
    b15e:	6813      	ldr	r3, [r2, #0]
    b160:	f023 0301 	bic.w	r3, r3, #1
    b164:	6013      	str	r3, [r2, #0]
}
    b166:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_ERROR;
    b16a:	2001      	movs	r0, #1
}
    b16c:	4770      	bx	lr
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b16e:	6814      	ldr	r4, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b170:	4856      	ldr	r0, [pc, #344]	; (b2cc <HAL_DMA_Abort_IT+0x23c>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b172:	f024 040e 	bic.w	r4, r4, #14
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b176:	4d5a      	ldr	r5, [pc, #360]	; (b2e0 <HAL_DMA_Abort_IT+0x250>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
    b178:	6014      	str	r4, [r2, #0]
      __HAL_DMA_DISABLE(hdma);
    b17a:	681a      	ldr	r2, [r3, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b17c:	4c59      	ldr	r4, [pc, #356]	; (b2e4 <HAL_DMA_Abort_IT+0x254>)
      __HAL_DMA_DISABLE(hdma);
    b17e:	6811      	ldr	r1, [r2, #0]
    b180:	f021 0101 	bic.w	r1, r1, #1
    b184:	6011      	str	r1, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
    b186:	4a50      	ldr	r2, [pc, #320]	; (b2c8 <HAL_DMA_Abort_IT+0x238>)
    b188:	6819      	ldr	r1, [r3, #0]
    b18a:	4281      	cmp	r1, r0
    b18c:	bf18      	it	ne
    b18e:	4291      	cmpne	r1, r2
    b190:	f100 0048 	add.w	r0, r0, #72	; 0x48
    b194:	bf0c      	ite	eq
    b196:	2201      	moveq	r2, #1
    b198:	2200      	movne	r2, #0
    b19a:	42a9      	cmp	r1, r5
    b19c:	bf08      	it	eq
    b19e:	f042 0201 	orreq.w	r2, r2, #1
    b1a2:	3548      	adds	r5, #72	; 0x48
    b1a4:	42a1      	cmp	r1, r4
    b1a6:	bf08      	it	eq
    b1a8:	f042 0201 	orreq.w	r2, r2, #1
    b1ac:	3448      	adds	r4, #72	; 0x48
    b1ae:	4281      	cmp	r1, r0
    b1b0:	bf08      	it	eq
    b1b2:	f042 0201 	orreq.w	r2, r2, #1
    b1b6:	3048      	adds	r0, #72	; 0x48
    b1b8:	42a9      	cmp	r1, r5
    b1ba:	bf08      	it	eq
    b1bc:	f042 0201 	orreq.w	r2, r2, #1
    b1c0:	f505 7562 	add.w	r5, r5, #904	; 0x388
    b1c4:	42a1      	cmp	r1, r4
    b1c6:	bf08      	it	eq
    b1c8:	f042 0201 	orreq.w	r2, r2, #1
    b1cc:	f504 7462 	add.w	r4, r4, #904	; 0x388
    b1d0:	4281      	cmp	r1, r0
    b1d2:	bf08      	it	eq
    b1d4:	f042 0201 	orreq.w	r2, r2, #1
    b1d8:	f500 7062 	add.w	r0, r0, #904	; 0x388
    b1dc:	42a9      	cmp	r1, r5
    b1de:	bf08      	it	eq
    b1e0:	f042 0201 	orreq.w	r2, r2, #1
    b1e4:	3548      	adds	r5, #72	; 0x48
    b1e6:	42a1      	cmp	r1, r4
    b1e8:	bf08      	it	eq
    b1ea:	f042 0201 	orreq.w	r2, r2, #1
    b1ee:	3448      	adds	r4, #72	; 0x48
    b1f0:	4281      	cmp	r1, r0
    b1f2:	bf08      	it	eq
    b1f4:	f042 0201 	orreq.w	r2, r2, #1
    b1f8:	3048      	adds	r0, #72	; 0x48
    b1fa:	42a9      	cmp	r1, r5
    b1fc:	bf08      	it	eq
    b1fe:	f042 0201 	orreq.w	r2, r2, #1
    b202:	3548      	adds	r5, #72	; 0x48
    b204:	42a1      	cmp	r1, r4
    b206:	bf08      	it	eq
    b208:	f042 0201 	orreq.w	r2, r2, #1
    b20c:	3448      	adds	r4, #72	; 0x48
    b20e:	4281      	cmp	r1, r0
    b210:	bf08      	it	eq
    b212:	f042 0201 	orreq.w	r2, r2, #1
    b216:	f100 50c0 	add.w	r0, r0, #402653184	; 0x18000000
    b21a:	42a9      	cmp	r1, r5
    b21c:	bf08      	it	eq
    b21e:	f042 0201 	orreq.w	r2, r2, #1
    b222:	f500 409f 	add.w	r0, r0, #20352	; 0x4f80
    b226:	4d30      	ldr	r5, [pc, #192]	; (b2e8 <HAL_DMA_Abort_IT+0x258>)
    b228:	42a1      	cmp	r1, r4
    b22a:	bf08      	it	eq
    b22c:	f042 0201 	orreq.w	r2, r2, #1
    b230:	4c2e      	ldr	r4, [pc, #184]	; (b2ec <HAL_DMA_Abort_IT+0x25c>)
    b232:	4281      	cmp	r1, r0
    b234:	bf08      	it	eq
    b236:	f042 0201 	orreq.w	r2, r2, #1
    b23a:	303c      	adds	r0, #60	; 0x3c
    b23c:	42a9      	cmp	r1, r5
    b23e:	bf08      	it	eq
    b240:	f042 0201 	orreq.w	r2, r2, #1
    b244:	353c      	adds	r5, #60	; 0x3c
    b246:	42a1      	cmp	r1, r4
    b248:	bf08      	it	eq
    b24a:	f042 0201 	orreq.w	r2, r2, #1
    b24e:	343c      	adds	r4, #60	; 0x3c
    b250:	4281      	cmp	r1, r0
    b252:	bf08      	it	eq
    b254:	f042 0201 	orreq.w	r2, r2, #1
    b258:	303c      	adds	r0, #60	; 0x3c
    b25a:	42a9      	cmp	r1, r5
    b25c:	bf08      	it	eq
    b25e:	f042 0201 	orreq.w	r2, r2, #1
    b262:	42a1      	cmp	r1, r4
    b264:	bf08      	it	eq
    b266:	f042 0201 	orreq.w	r2, r2, #1
    b26a:	4281      	cmp	r1, r0
    b26c:	bf08      	it	eq
    b26e:	f042 0201 	orreq.w	r2, r2, #1
    b272:	b912      	cbnz	r2, b27a <HAL_DMA_Abort_IT+0x1ea>
    b274:	4a1e      	ldr	r2, [pc, #120]	; (b2f0 <HAL_DMA_Abort_IT+0x260>)
    b276:	4291      	cmp	r1, r2
    b278:	d117      	bne.n	b2aa <HAL_DMA_Abort_IT+0x21a>
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
    b27a:	6e18      	ldr	r0, [r3, #96]	; 0x60
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    b27c:	2201      	movs	r2, #1
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
    b27e:	6801      	ldr	r1, [r0, #0]
    b280:	f421 7180 	bic.w	r1, r1, #256	; 0x100
    b284:	6001      	str	r1, [r0, #0]
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
    b286:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	; 0x58
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
    b28a:	f001 011f 	and.w	r1, r1, #31
    b28e:	408a      	lsls	r2, r1
    b290:	6042      	str	r2, [r0, #4]
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
    b292:	e9d3 2119 	ldrd	r2, r1, [r3, #100]	; 0x64
    b296:	6051      	str	r1, [r2, #4]
        if(hdma->DMAmuxRequestGen != 0U)
    b298:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    b29a:	b132      	cbz	r2, b2aa <HAL_DMA_Abort_IT+0x21a>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
    b29c:	6811      	ldr	r1, [r2, #0]
    b29e:	f421 7180 	bic.w	r1, r1, #256	; 0x100
    b2a2:	6011      	str	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
    b2a4:	e9d3 211c 	ldrd	r2, r1, [r3, #112]	; 0x70
    b2a8:	6051      	str	r1, [r2, #4]
      __HAL_UNLOCK(hdma);
    b2aa:	2400      	movs	r4, #0
      hdma->State = HAL_DMA_STATE_READY;
    b2ac:	2101      	movs	r1, #1
      if(hdma->XferAbortCallback != NULL)
    b2ae:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      __HAL_UNLOCK(hdma);
    b2b0:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
    b2b4:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      if(hdma->XferAbortCallback != NULL)
    b2b8:	b11a      	cbz	r2, b2c2 <HAL_DMA_Abort_IT+0x232>
    b2ba:	4618      	mov	r0, r3
        hdma->XferAbortCallback(hdma);
    b2bc:	4790      	blx	r2
  return HAL_OK;
    b2be:	4620      	mov	r0, r4
    b2c0:	e6f2      	b.n	b0a8 <HAL_DMA_Abort_IT+0x18>
    b2c2:	4610      	mov	r0, r2
    b2c4:	e6f0      	b.n	b0a8 <HAL_DMA_Abort_IT+0x18>
    b2c6:	bf00      	nop
    b2c8:	40020010 	.word	0x40020010
    b2cc:	40020028 	.word	0x40020028
    b2d0:	400200a0 	.word	0x400200a0
    b2d4:	400200b8 	.word	0x400200b8
    b2d8:	40020470 	.word	0x40020470
    b2dc:	40020488 	.word	0x40020488
    b2e0:	40020040 	.word	0x40020040
    b2e4:	40020058 	.word	0x40020058
    b2e8:	5802541c 	.word	0x5802541c
    b2ec:	58025430 	.word	0x58025430
    b2f0:	58025494 	.word	0x58025494
    b2f4:	40020070 	.word	0x40020070
    b2f8:	40020088 	.word	0x40020088
    b2fc:	40020458 	.word	0x40020458
    b300:	400204b8 	.word	0x400204b8

0000b304 <HAL_DMA_GetState>:
  return hdma->State;
    b304:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
    b308:	4770      	bx	lr
    b30a:	bf00      	nop

0000b30c <HAL_DMA_GetError>:
  return hdma->ErrorCode;
    b30c:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
    b30e:	4770      	bx	lr

0000b310 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
    b310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b312:	4605      	mov	r5, r0
  uint32_t syncSignalID = 0;
  uint32_t syncPolarity = 0;

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    b314:	4baa      	ldr	r3, [pc, #680]	; (b5c0 <HAL_DMAEx_ConfigMuxSync+0x2b0>)
    b316:	48ab      	ldr	r0, [pc, #684]	; (b5c4 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
{
    b318:	460c      	mov	r4, r1
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    b31a:	682a      	ldr	r2, [r5, #0]
    b31c:	49aa      	ldr	r1, [pc, #680]	; (b5c8 <HAL_DMAEx_ConfigMuxSync+0x2b8>)
    b31e:	429a      	cmp	r2, r3
    b320:	bf18      	it	ne
    b322:	4282      	cmpne	r2, r0
    b324:	f100 0030 	add.w	r0, r0, #48	; 0x30
    b328:	bf14      	ite	ne
    b32a:	2301      	movne	r3, #1
    b32c:	2300      	moveq	r3, #0
    b32e:	428a      	cmp	r2, r1
    b330:	bf0c      	ite	eq
    b332:	2300      	moveq	r3, #0
    b334:	f003 0301 	andne.w	r3, r3, #1
    b338:	3130      	adds	r1, #48	; 0x30
    b33a:	4282      	cmp	r2, r0
    b33c:	bf0c      	ite	eq
    b33e:	2300      	moveq	r3, #0
    b340:	f003 0301 	andne.w	r3, r3, #1
    b344:	3030      	adds	r0, #48	; 0x30
    b346:	428a      	cmp	r2, r1
    b348:	bf0c      	ite	eq
    b34a:	2300      	moveq	r3, #0
    b34c:	f003 0301 	andne.w	r3, r3, #1
    b350:	3130      	adds	r1, #48	; 0x30
    b352:	4282      	cmp	r2, r0
    b354:	bf0c      	ite	eq
    b356:	2300      	moveq	r3, #0
    b358:	f003 0301 	andne.w	r3, r3, #1
    b35c:	3030      	adds	r0, #48	; 0x30
    b35e:	428a      	cmp	r2, r1
    b360:	bf0c      	ite	eq
    b362:	2300      	moveq	r3, #0
    b364:	f003 0301 	andne.w	r3, r3, #1
    b368:	f501 715c 	add.w	r1, r1, #880	; 0x370
    b36c:	4282      	cmp	r2, r0
    b36e:	bf0c      	ite	eq
    b370:	2300      	moveq	r3, #0
    b372:	f003 0301 	andne.w	r3, r3, #1
    b376:	f500 705c 	add.w	r0, r0, #880	; 0x370
    b37a:	428a      	cmp	r2, r1
    b37c:	bf0c      	ite	eq
    b37e:	2300      	moveq	r3, #0
    b380:	f003 0301 	andne.w	r3, r3, #1
    b384:	3130      	adds	r1, #48	; 0x30
    b386:	4282      	cmp	r2, r0
    b388:	bf0c      	ite	eq
    b38a:	2300      	moveq	r3, #0
    b38c:	f003 0301 	andne.w	r3, r3, #1
    b390:	3030      	adds	r0, #48	; 0x30
    b392:	428a      	cmp	r2, r1
    b394:	bf0c      	ite	eq
    b396:	2300      	moveq	r3, #0
    b398:	f003 0301 	andne.w	r3, r3, #1
    b39c:	3130      	adds	r1, #48	; 0x30
    b39e:	4282      	cmp	r2, r0
    b3a0:	bf0c      	ite	eq
    b3a2:	2300      	moveq	r3, #0
    b3a4:	f003 0301 	andne.w	r3, r3, #1
    b3a8:	3030      	adds	r0, #48	; 0x30
    b3aa:	428a      	cmp	r2, r1
    b3ac:	bf0c      	ite	eq
    b3ae:	2300      	moveq	r3, #0
    b3b0:	f003 0301 	andne.w	r3, r3, #1
    b3b4:	3130      	adds	r1, #48	; 0x30
    b3b6:	4282      	cmp	r2, r0
    b3b8:	bf0c      	ite	eq
    b3ba:	2300      	moveq	r3, #0
    b3bc:	f003 0301 	andne.w	r3, r3, #1
    b3c0:	3030      	adds	r0, #48	; 0x30
    b3c2:	428a      	cmp	r2, r1
    b3c4:	bf0c      	ite	eq
    b3c6:	2300      	moveq	r3, #0
    b3c8:	f003 0301 	andne.w	r3, r3, #1
    b3cc:	497f      	ldr	r1, [pc, #508]	; (b5cc <HAL_DMAEx_ConfigMuxSync+0x2bc>)
    b3ce:	4282      	cmp	r2, r0
    b3d0:	bf0c      	ite	eq
    b3d2:	2300      	moveq	r3, #0
    b3d4:	f003 0301 	andne.w	r3, r3, #1
    b3d8:	487d      	ldr	r0, [pc, #500]	; (b5d0 <HAL_DMAEx_ConfigMuxSync+0x2c0>)
    b3da:	428a      	cmp	r2, r1
    b3dc:	bf0c      	ite	eq
    b3de:	2300      	moveq	r3, #0
    b3e0:	f003 0301 	andne.w	r3, r3, #1
    b3e4:	3128      	adds	r1, #40	; 0x28
    b3e6:	4282      	cmp	r2, r0
    b3e8:	bf0c      	ite	eq
    b3ea:	2300      	moveq	r3, #0
    b3ec:	f003 0301 	andne.w	r3, r3, #1
    b3f0:	3028      	adds	r0, #40	; 0x28
    b3f2:	428a      	cmp	r2, r1
    b3f4:	bf0c      	ite	eq
    b3f6:	2300      	moveq	r3, #0
    b3f8:	f003 0301 	andne.w	r3, r3, #1
    b3fc:	3128      	adds	r1, #40	; 0x28
    b3fe:	4282      	cmp	r2, r0
    b400:	bf0c      	ite	eq
    b402:	2300      	moveq	r3, #0
    b404:	f003 0301 	andne.w	r3, r3, #1
    b408:	3028      	adds	r0, #40	; 0x28
    b40a:	428a      	cmp	r2, r1
    b40c:	bf0c      	ite	eq
    b40e:	2300      	moveq	r3, #0
    b410:	f003 0301 	andne.w	r3, r3, #1
    b414:	3128      	adds	r1, #40	; 0x28
    b416:	4282      	cmp	r2, r0
    b418:	bf0c      	ite	eq
    b41a:	2300      	moveq	r3, #0
    b41c:	f003 0301 	andne.w	r3, r3, #1
    b420:	428a      	cmp	r2, r1
    b422:	bf0c      	ite	eq
    b424:	2300      	moveq	r3, #0
    b426:	f003 0301 	andne.w	r3, r3, #1
    b42a:	b11b      	cbz	r3, b434 <HAL_DMAEx_ConfigMuxSync+0x124>
    b42c:	4b69      	ldr	r3, [pc, #420]	; (b5d4 <HAL_DMAEx_ConfigMuxSync+0x2c4>)
    b42e:	429a      	cmp	r2, r3
    b430:	f040 80c0 	bne.w	b5b4 <HAL_DMAEx_ConfigMuxSync+0x2a4>
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
    b434:	7a23      	ldrb	r3, [r4, #8]
    b436:	2b01      	cmp	r3, #1
    b438:	d904      	bls.n	b444 <HAL_DMAEx_ConfigMuxSync+0x134>
    b43a:	f44f 71ca 	mov.w	r1, #404	; 0x194
    b43e:	4866      	ldr	r0, [pc, #408]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b440:	f00e f83e 	bl	194c0 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
    b444:	7a63      	ldrb	r3, [r4, #9]
    b446:	2b01      	cmp	r3, #1
    b448:	d904      	bls.n	b454 <HAL_DMAEx_ConfigMuxSync+0x144>
    b44a:	f240 1195 	movw	r1, #405	; 0x195
    b44e:	4862      	ldr	r0, [pc, #392]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b450:	f00e f836 	bl	194c0 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
    b454:	68e3      	ldr	r3, [r4, #12]
    b456:	3b01      	subs	r3, #1
    b458:	2b1f      	cmp	r3, #31
    b45a:	f200 808d 	bhi.w	b578 <HAL_DMAEx_ConfigMuxSync+0x268>

  if(pSyncConfig->SyncEnable == ENABLE)
    b45e:	7a23      	ldrb	r3, [r4, #8]
    b460:	2b01      	cmp	r3, #1
    b462:	d02f      	beq.n	b4c4 <HAL_DMAEx_ConfigMuxSync+0x1b4>
  uint32_t syncPolarity = 0;
    b464:	2200      	movs	r2, #0
  uint32_t syncSignalID = 0;
    b466:	4611      	mov	r1, r2
    syncSignalID = pSyncConfig->SyncSignalID;
    syncPolarity = pSyncConfig->SyncPolarity;
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
    b468:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
    b46c:	b2db      	uxtb	r3, r3
    b46e:	2b01      	cmp	r3, #1
    b470:	d004      	beq.n	b47c <HAL_DMAEx_ConfigMuxSync+0x16c>
    return HAL_OK;
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    b472:	f44f 6300 	mov.w	r3, #2048	; 0x800

    /* Return error status */
    return HAL_ERROR;
    b476:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
    b478:	656b      	str	r3, [r5, #84]	; 0x54
  }
}
    b47a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hdma);
    b47c:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
    b480:	2801      	cmp	r0, #1
    b482:	f000 8086 	beq.w	b592 <HAL_DMAEx_ConfigMuxSync+0x282>
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    b486:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    __HAL_UNLOCK(hdma);
    b488:	2600      	movs	r6, #0
    __HAL_LOCK(hdma);
    b48a:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    b48e:	683b      	ldr	r3, [r7, #0]
    return HAL_OK;
    b490:	4630      	mov	r0, r6
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
    b492:	f423 3381 	bic.w	r3, r3, #66048	; 0x10200
    b496:	603b      	str	r3, [r7, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
    b498:	68e7      	ldr	r7, [r4, #12]
    b49a:	7a23      	ldrb	r3, [r4, #8]
    b49c:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
    b4a0:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    b4a2:	041b      	lsls	r3, r3, #16
    b4a4:	f894 e009 	ldrb.w	lr, [r4, #9]
    b4a8:	683c      	ldr	r4, [r7, #0]
    b4aa:	ea43 43cc 	orr.w	r3, r3, ip, lsl #19
    b4ae:	b2e4      	uxtb	r4, r4
    b4b0:	ea43 234e 	orr.w	r3, r3, lr, lsl #9
    b4b4:	4323      	orrs	r3, r4
    b4b6:	4313      	orrs	r3, r2
    b4b8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    b4bc:	603b      	str	r3, [r7, #0]
    __HAL_UNLOCK(hdma);
    b4be:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
}
    b4c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
    b4c4:	6863      	ldr	r3, [r4, #4]
    b4c6:	f433 23c0 	bics.w	r3, r3, #393216	; 0x60000
    b4ca:	d164      	bne.n	b596 <HAL_DMAEx_ConfigMuxSync+0x286>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
    b4cc:	682a      	ldr	r2, [r5, #0]
    b4ce:	4b3c      	ldr	r3, [pc, #240]	; (b5c0 <HAL_DMAEx_ConfigMuxSync+0x2b0>)
    b4d0:	493c      	ldr	r1, [pc, #240]	; (b5c4 <HAL_DMAEx_ConfigMuxSync+0x2b4>)
    b4d2:	483d      	ldr	r0, [pc, #244]	; (b5c8 <HAL_DMAEx_ConfigMuxSync+0x2b8>)
    b4d4:	428a      	cmp	r2, r1
    b4d6:	bf18      	it	ne
    b4d8:	429a      	cmpne	r2, r3
    b4da:	f101 0130 	add.w	r1, r1, #48	; 0x30
    b4de:	bf0c      	ite	eq
    b4e0:	2301      	moveq	r3, #1
    b4e2:	2300      	movne	r3, #0
    b4e4:	4282      	cmp	r2, r0
    b4e6:	bf08      	it	eq
    b4e8:	f043 0301 	orreq.w	r3, r3, #1
    b4ec:	3030      	adds	r0, #48	; 0x30
    b4ee:	428a      	cmp	r2, r1
    b4f0:	bf08      	it	eq
    b4f2:	f043 0301 	orreq.w	r3, r3, #1
    b4f6:	3130      	adds	r1, #48	; 0x30
    b4f8:	4282      	cmp	r2, r0
    b4fa:	bf08      	it	eq
    b4fc:	f043 0301 	orreq.w	r3, r3, #1
    b500:	3030      	adds	r0, #48	; 0x30
    b502:	428a      	cmp	r2, r1
    b504:	bf08      	it	eq
    b506:	f043 0301 	orreq.w	r3, r3, #1
    b50a:	3130      	adds	r1, #48	; 0x30
    b50c:	4282      	cmp	r2, r0
    b50e:	bf08      	it	eq
    b510:	f043 0301 	orreq.w	r3, r3, #1
    b514:	f500 705c 	add.w	r0, r0, #880	; 0x370
    b518:	428a      	cmp	r2, r1
    b51a:	bf08      	it	eq
    b51c:	f043 0301 	orreq.w	r3, r3, #1
    b520:	f501 715c 	add.w	r1, r1, #880	; 0x370
    b524:	4282      	cmp	r2, r0
    b526:	bf08      	it	eq
    b528:	f043 0301 	orreq.w	r3, r3, #1
    b52c:	3030      	adds	r0, #48	; 0x30
    b52e:	428a      	cmp	r2, r1
    b530:	bf08      	it	eq
    b532:	f043 0301 	orreq.w	r3, r3, #1
    b536:	3130      	adds	r1, #48	; 0x30
    b538:	4282      	cmp	r2, r0
    b53a:	bf08      	it	eq
    b53c:	f043 0301 	orreq.w	r3, r3, #1
    b540:	3030      	adds	r0, #48	; 0x30
    b542:	428a      	cmp	r2, r1
    b544:	bf08      	it	eq
    b546:	f043 0301 	orreq.w	r3, r3, #1
    b54a:	3130      	adds	r1, #48	; 0x30
    b54c:	4282      	cmp	r2, r0
    b54e:	bf08      	it	eq
    b550:	f043 0301 	orreq.w	r3, r3, #1
    b554:	3030      	adds	r0, #48	; 0x30
    b556:	428a      	cmp	r2, r1
    b558:	bf08      	it	eq
    b55a:	f043 0301 	orreq.w	r3, r3, #1
    b55e:	6821      	ldr	r1, [r4, #0]
    b560:	4282      	cmp	r2, r0
    b562:	bf08      	it	eq
    b564:	f043 0301 	orreq.w	r3, r3, #1
    b568:	b913      	cbnz	r3, b570 <HAL_DMAEx_ConfigMuxSync+0x260>
    b56a:	4b1c      	ldr	r3, [pc, #112]	; (b5dc <HAL_DMAEx_ConfigMuxSync+0x2cc>)
    b56c:	429a      	cmp	r2, r3
    b56e:	d118      	bne.n	b5a2 <HAL_DMAEx_ConfigMuxSync+0x292>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    b570:	2907      	cmp	r1, #7
    b572:	d807      	bhi.n	b584 <HAL_DMAEx_ConfigMuxSync+0x274>
    syncPolarity = pSyncConfig->SyncPolarity;
    b574:	6862      	ldr	r2, [r4, #4]
    b576:	e777      	b.n	b468 <HAL_DMAEx_ConfigMuxSync+0x158>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
    b578:	f44f 71cb 	mov.w	r1, #406	; 0x196
    b57c:	4816      	ldr	r0, [pc, #88]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b57e:	f00d ff9f 	bl	194c0 <assert_failed>
    b582:	e76c      	b.n	b45e <HAL_DMAEx_ConfigMuxSync+0x14e>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    b584:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    b588:	4813      	ldr	r0, [pc, #76]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b58a:	f00d ff99 	bl	194c0 <assert_failed>
    b58e:	6821      	ldr	r1, [r4, #0]
    b590:	e7f0      	b.n	b574 <HAL_DMAEx_ConfigMuxSync+0x264>
    __HAL_LOCK(hdma);
    b592:	2002      	movs	r0, #2
}
    b594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
    b596:	f44f 71cd 	mov.w	r1, #410	; 0x19a
    b59a:	480f      	ldr	r0, [pc, #60]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b59c:	f00d ff90 	bl	194c0 <assert_failed>
    b5a0:	e794      	b.n	b4cc <HAL_DMAEx_ConfigMuxSync+0x1bc>
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    b5a2:	290f      	cmp	r1, #15
    b5a4:	d9e6      	bls.n	b574 <HAL_DMAEx_ConfigMuxSync+0x264>
    b5a6:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
    b5aa:	480b      	ldr	r0, [pc, #44]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b5ac:	f00d ff88 	bl	194c0 <assert_failed>
    b5b0:	6821      	ldr	r1, [r4, #0]
    b5b2:	e7df      	b.n	b574 <HAL_DMAEx_ConfigMuxSync+0x264>
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
    b5b4:	f240 1193 	movw	r1, #403	; 0x193
    b5b8:	4807      	ldr	r0, [pc, #28]	; (b5d8 <HAL_DMAEx_ConfigMuxSync+0x2c8>)
    b5ba:	f00d ff81 	bl	194c0 <assert_failed>
    b5be:	e739      	b.n	b434 <HAL_DMAEx_ConfigMuxSync+0x124>
    b5c0:	40020010 	.word	0x40020010
    b5c4:	40020028 	.word	0x40020028
    b5c8:	40020040 	.word	0x40020040
    b5cc:	58025408 	.word	0x58025408
    b5d0:	5802541c 	.word	0x5802541c
    b5d4:	58025494 	.word	0x58025494
    b5d8:	0002ffcc 	.word	0x0002ffcc
    b5dc:	400204b8 	.word	0x400204b8

0000b5e0 <FLASH_WaitForLastOperation.constprop.3>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
    b5e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b5e2:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
    b5e4:	f7fc ff06 	bl	83f4 <HAL_GetTick>
    b5e8:	4606      	mov	r6, r0

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b5ea:	1e6b      	subs	r3, r5, #1
    b5ec:	2b01      	cmp	r3, #1
    b5ee:	d80e      	bhi.n	b60e <FLASH_WaitForLastOperation.constprop.3+0x2e>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
    b5f0:	2d01      	cmp	r5, #1
    b5f2:	d111      	bne.n	b618 <FLASH_WaitForLastOperation.constprop.3+0x38>
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b5f4:	4c2b      	ldr	r4, [pc, #172]	; (b6a4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b5f6:	f24c 3550 	movw	r5, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b5fa:	6923      	ldr	r3, [r4, #16]
    b5fc:	075b      	lsls	r3, r3, #29
    b5fe:	d53a      	bpl.n	b676 <FLASH_WaitForLastOperation.constprop.3+0x96>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b600:	f7fc fef8 	bl	83f4 <HAL_GetTick>
    b604:	1b80      	subs	r0, r0, r6
    b606:	42a8      	cmp	r0, r5
    b608:	d9f7      	bls.n	b5fa <FLASH_WaitForLastOperation.constprop.3+0x1a>
      {
        return HAL_TIMEOUT;
    b60a:	2003      	movs	r0, #3
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }

  return HAL_OK;
}
    b60c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b60e:	f240 3192 	movw	r1, #914	; 0x392
    b612:	4825      	ldr	r0, [pc, #148]	; (b6a8 <FLASH_WaitForLastOperation.constprop.3+0xc8>)
    b614:	f00d ff54 	bl	194c0 <assert_failed>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b618:	4c22      	ldr	r4, [pc, #136]	; (b6a4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b61a:	f24c 3750 	movw	r7, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b61e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    b622:	075a      	lsls	r2, r3, #29
    b624:	d508      	bpl.n	b638 <FLASH_WaitForLastOperation.constprop.3+0x58>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b626:	f7fc fee5 	bl	83f4 <HAL_GetTick>
    b62a:	1b80      	subs	r0, r0, r6
    b62c:	42b8      	cmp	r0, r7
    b62e:	d8ec      	bhi.n	b60a <FLASH_WaitForLastOperation.constprop.3+0x2a>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b630:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    b634:	075a      	lsls	r2, r3, #29
    b636:	d4f6      	bmi.n	b626 <FLASH_WaitForLastOperation.constprop.3+0x46>
  if (Bank == FLASH_BANK_1)
    b638:	2d01      	cmp	r5, #1
    b63a:	d01c      	beq.n	b676 <FLASH_WaitForLastOperation.constprop.3+0x96>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b63c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b640:	481a      	ldr	r0, [pc, #104]	; (b6ac <FLASH_WaitForLastOperation.constprop.3+0xcc>)
    b642:	4018      	ands	r0, r3
    b644:	d00b      	beq.n	b65e <FLASH_WaitForLastOperation.constprop.3+0x7e>
    pFlash.ErrorCode |= errorflag;
    b646:	491a      	ldr	r1, [pc, #104]	; (b6b0 <FLASH_WaitForLastOperation.constprop.3+0xd0>)
    return HAL_ERROR;
    b648:	2001      	movs	r0, #1
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b64a:	4d1a      	ldr	r5, [pc, #104]	; (b6b4 <FLASH_WaitForLastOperation.constprop.3+0xd4>)
    pFlash.ErrorCode |= errorflag;
    b64c:	698a      	ldr	r2, [r1, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b64e:	402b      	ands	r3, r5
    pFlash.ErrorCode |= errorflag;
    b650:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    b654:	431a      	orrs	r2, r3
    b656:	618a      	str	r2, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b658:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
    b65c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
    b65e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    b662:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    b666:	d004      	beq.n	b672 <FLASH_WaitForLastOperation.constprop.3+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    b668:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b66c:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
    b670:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
    b672:	4618      	mov	r0, r3
}
    b674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b676:	4a0b      	ldr	r2, [pc, #44]	; (b6a4 <FLASH_WaitForLastOperation.constprop.3+0xc4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b678:	480c      	ldr	r0, [pc, #48]	; (b6ac <FLASH_WaitForLastOperation.constprop.3+0xcc>)
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b67a:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b67c:	4018      	ands	r0, r3
    b67e:	d107      	bne.n	b690 <FLASH_WaitForLastOperation.constprop.3+0xb0>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
    b680:	6913      	ldr	r3, [r2, #16]
    b682:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    b686:	d0f4      	beq.n	b672 <FLASH_WaitForLastOperation.constprop.3+0x92>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
    b688:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b68c:	6153      	str	r3, [r2, #20]
}
    b68e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pFlash.ErrorCode |= errorflag;
    b690:	4c07      	ldr	r4, [pc, #28]	; (b6b0 <FLASH_WaitForLastOperation.constprop.3+0xd0>)
    return HAL_ERROR;
    b692:	2001      	movs	r0, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b694:	4907      	ldr	r1, [pc, #28]	; (b6b4 <FLASH_WaitForLastOperation.constprop.3+0xd4>)
    b696:	400b      	ands	r3, r1
    pFlash.ErrorCode |= errorflag;
    b698:	69a1      	ldr	r1, [r4, #24]
    b69a:	4319      	orrs	r1, r3
    b69c:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b69e:	6153      	str	r3, [r2, #20]
}
    b6a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b6a2:	bf00      	nop
    b6a4:	52002000 	.word	0x52002000
    b6a8:	00030008 	.word	0x00030008
    b6ac:	15ee0000 	.word	0x15ee0000
    b6b0:	020e3268 	.word	0x020e3268
    b6b4:	17ee0000 	.word	0x17ee0000

0000b6b8 <HAL_FLASH_Program>:
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    b6b8:	2801      	cmp	r0, #1
{
    b6ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b6be:	460c      	mov	r4, r1
    b6c0:	4616      	mov	r6, r2
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    b6c2:	d003      	beq.n	b6cc <HAL_FLASH_Program+0x14>
    b6c4:	219b      	movs	r1, #155	; 0x9b
    b6c6:	4834      	ldr	r0, [pc, #208]	; (b798 <HAL_FLASH_Program+0xe0>)
    b6c8:	f00d fefa 	bl	194c0 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    b6cc:	f104 4778 	add.w	r7, r4, #4160749568	; 0xf8000000
    b6d0:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
    b6d4:	d24f      	bcs.n	b776 <HAL_FLASH_Program+0xbe>
  __HAL_LOCK(&pFlash);
    b6d6:	4d31      	ldr	r5, [pc, #196]	; (b79c <HAL_FLASH_Program+0xe4>)
    b6d8:	7d2b      	ldrb	r3, [r5, #20]
    b6da:	2b01      	cmp	r3, #1
    b6dc:	d053      	beq.n	b786 <HAL_FLASH_Program+0xce>
    b6de:	f04f 0801 	mov.w	r8, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    b6e2:	f5b7 1f80 	cmp.w	r7, #1048576	; 0x100000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b6e6:	f04f 0300 	mov.w	r3, #0
  __HAL_LOCK(&pFlash);
    b6ea:	f885 8014 	strb.w	r8, [r5, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    b6ee:	d336      	bcc.n	b75e <HAL_FLASH_Program+0xa6>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b6f0:	2002      	movs	r0, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b6f2:	61ab      	str	r3, [r5, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b6f4:	f7ff ff74 	bl	b5e0 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
    b6f8:	bb68      	cbnz	r0, b756 <HAL_FLASH_Program+0x9e>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
    b6fa:	4a29      	ldr	r2, [pc, #164]	; (b7a0 <HAL_FLASH_Program+0xe8>)
    bank = FLASH_BANK_2;
    b6fc:	f04f 0802 	mov.w	r8, #2
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
    b700:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    b704:	ea43 0308 	orr.w	r3, r3, r8
    b708:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    b70c:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    b710:	f3bf 8f4f 	dsb	sy
        *dest_addr = *src_addr;
    b714:	6833      	ldr	r3, [r6, #0]
    b716:	6023      	str	r3, [r4, #0]
    b718:	6873      	ldr	r3, [r6, #4]
    b71a:	6063      	str	r3, [r4, #4]
    b71c:	68b3      	ldr	r3, [r6, #8]
    b71e:	60a3      	str	r3, [r4, #8]
    b720:	68f3      	ldr	r3, [r6, #12]
    b722:	60e3      	str	r3, [r4, #12]
    b724:	6933      	ldr	r3, [r6, #16]
    b726:	6123      	str	r3, [r4, #16]
    b728:	6973      	ldr	r3, [r6, #20]
    b72a:	6163      	str	r3, [r4, #20]
    b72c:	69b3      	ldr	r3, [r6, #24]
    b72e:	61a3      	str	r3, [r4, #24]
    b730:	69f3      	ldr	r3, [r6, #28]
    b732:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("isb 0xF":::"memory");
    b734:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    b738:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b73c:	4640      	mov	r0, r8
    b73e:	f7ff ff4f 	bl	b5e0 <FLASH_WaitForLastOperation.constprop.3>
      if(bank == FLASH_BANK_1)
    b742:	f1b8 0f01 	cmp.w	r8, #1
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    b746:	4a16      	ldr	r2, [pc, #88]	; (b7a0 <HAL_FLASH_Program+0xe8>)
      if(bank == FLASH_BANK_1)
    b748:	d020      	beq.n	b78c <HAL_FLASH_Program+0xd4>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
    b74a:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    b74e:	f023 0302 	bic.w	r3, r3, #2
    b752:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  __HAL_UNLOCK(&pFlash);
    b756:	2300      	movs	r3, #0
    b758:	752b      	strb	r3, [r5, #20]
}
    b75a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b75e:	4640      	mov	r0, r8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b760:	61ab      	str	r3, [r5, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
    b762:	f7ff ff3d 	bl	b5e0 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
    b766:	2800      	cmp	r0, #0
    b768:	d1f5      	bne.n	b756 <HAL_FLASH_Program+0x9e>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
    b76a:	4a0d      	ldr	r2, [pc, #52]	; (b7a0 <HAL_FLASH_Program+0xe8>)
    b76c:	68d3      	ldr	r3, [r2, #12]
    b76e:	f043 0302 	orr.w	r3, r3, #2
    b772:	60d3      	str	r3, [r2, #12]
    b774:	e7ca      	b.n	b70c <HAL_FLASH_Program+0x54>
  __HAL_LOCK(&pFlash);
    b776:	4d09      	ldr	r5, [pc, #36]	; (b79c <HAL_FLASH_Program+0xe4>)
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    b778:	219c      	movs	r1, #156	; 0x9c
    b77a:	4807      	ldr	r0, [pc, #28]	; (b798 <HAL_FLASH_Program+0xe0>)
    b77c:	f00d fea0 	bl	194c0 <assert_failed>
  __HAL_LOCK(&pFlash);
    b780:	7d2b      	ldrb	r3, [r5, #20]
    b782:	2b01      	cmp	r3, #1
    b784:	d1ab      	bne.n	b6de <HAL_FLASH_Program+0x26>
    b786:	2002      	movs	r0, #2
}
    b788:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    b78c:	68d3      	ldr	r3, [r2, #12]
    b78e:	f023 0302 	bic.w	r3, r3, #2
    b792:	60d3      	str	r3, [r2, #12]
    b794:	e7df      	b.n	b756 <HAL_FLASH_Program+0x9e>
    b796:	bf00      	nop
    b798:	00030008 	.word	0x00030008
    b79c:	020e3268 	.word	0x020e3268
    b7a0:	52002000 	.word	0x52002000

0000b7a4 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
    b7a4:	4b0f      	ldr	r3, [pc, #60]	; (b7e4 <HAL_FLASH_Unlock+0x40>)
    b7a6:	68da      	ldr	r2, [r3, #12]
    b7a8:	07d2      	lsls	r2, r2, #31
    b7aa:	d506      	bpl.n	b7ba <HAL_FLASH_Unlock+0x16>
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    b7ac:	490e      	ldr	r1, [pc, #56]	; (b7e8 <HAL_FLASH_Unlock+0x44>)
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    b7ae:	4a0f      	ldr	r2, [pc, #60]	; (b7ec <HAL_FLASH_Unlock+0x48>)
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
    b7b0:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
    b7b2:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
    b7b4:	68db      	ldr	r3, [r3, #12]
    b7b6:	07db      	lsls	r3, r3, #31
    b7b8:	d411      	bmi.n	b7de <HAL_FLASH_Unlock+0x3a>
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
    b7ba:	4b0a      	ldr	r3, [pc, #40]	; (b7e4 <HAL_FLASH_Unlock+0x40>)
    b7bc:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    b7c0:	f010 0001 	ands.w	r0, r0, #1
    b7c4:	d00a      	beq.n	b7dc <HAL_FLASH_Unlock+0x38>
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    b7c6:	4908      	ldr	r1, [pc, #32]	; (b7e8 <HAL_FLASH_Unlock+0x44>)
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    b7c8:	4a08      	ldr	r2, [pc, #32]	; (b7ec <HAL_FLASH_Unlock+0x48>)
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    b7ca:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    b7ce:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
    b7d2:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
      return HAL_ERROR;
    b7d6:	f000 0001 	and.w	r0, r0, #1
    b7da:	4770      	bx	lr
    b7dc:	4770      	bx	lr
    b7de:	2001      	movs	r0, #1
}
    b7e0:	4770      	bx	lr
    b7e2:	bf00      	nop
    b7e4:	52002000 	.word	0x52002000
    b7e8:	45670123 	.word	0x45670123
    b7ec:	cdef89ab 	.word	0xcdef89ab

0000b7f0 <FLASH_WaitForLastOperation>:
{
    b7f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b7f4:	460d      	mov	r5, r1
    b7f6:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
    b7f8:	f7fc fdfc 	bl	83f4 <HAL_GetTick>
    b7fc:	4680      	mov	r8, r0
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b7fe:	1e6b      	subs	r3, r5, #1
    b800:	2b01      	cmp	r3, #1
    b802:	d857      	bhi.n	b8b4 <FLASH_WaitForLastOperation+0xc4>
    bsyflag = FLASH_FLAG_QW_BANK2;
    b804:	2d01      	cmp	r5, #1
    b806:	4c36      	ldr	r4, [pc, #216]	; (b8e0 <FLASH_WaitForLastOperation+0xf0>)
    b808:	bf08      	it	eq
    b80a:	2404      	moveq	r4, #4
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b80c:	4f35      	ldr	r7, [pc, #212]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
    b80e:	2c04      	cmp	r4, #4
    b810:	d02d      	beq.n	b86e <FLASH_WaitForLastOperation+0x7e>
    b812:	1c70      	adds	r0, r6, #1
    b814:	d11b      	bne.n	b84e <FLASH_WaitForLastOperation+0x5e>
    b816:	4a33      	ldr	r2, [pc, #204]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
    b818:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
    b81c:	ea24 0303 	bic.w	r3, r4, r3
    b820:	0759      	lsls	r1, r3, #29
    b822:	d5f9      	bpl.n	b818 <FLASH_WaitForLastOperation+0x28>
  if (Bank == FLASH_BANK_1)
    b824:	2d01      	cmp	r5, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b826:	4a2f      	ldr	r2, [pc, #188]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b828:	482f      	ldr	r0, [pc, #188]	; (b8e8 <FLASH_WaitForLastOperation+0xf8>)
  if (Bank == FLASH_BANK_1)
    b82a:	d02a      	beq.n	b882 <FLASH_WaitForLastOperation+0x92>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b82c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b830:	4018      	ands	r0, r3
    b832:	d031      	beq.n	b898 <FLASH_WaitForLastOperation+0xa8>
    pFlash.ErrorCode |= errorflag;
    b834:	4c2d      	ldr	r4, [pc, #180]	; (b8ec <FLASH_WaitForLastOperation+0xfc>)
    return HAL_ERROR;
    b836:	2001      	movs	r0, #1
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b838:	4d2d      	ldr	r5, [pc, #180]	; (b8f0 <FLASH_WaitForLastOperation+0x100>)
    pFlash.ErrorCode |= errorflag;
    b83a:	69a1      	ldr	r1, [r4, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
    b83c:	402b      	ands	r3, r5
    pFlash.ErrorCode |= errorflag;
    b83e:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    b842:	4319      	orrs	r1, r3
    b844:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b846:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
    b84a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b84e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
    b852:	ea24 0303 	bic.w	r3, r4, r3
    b856:	075b      	lsls	r3, r3, #29
    b858:	d4e4      	bmi.n	b824 <FLASH_WaitForLastOperation+0x34>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
    b85a:	f7fc fdcb 	bl	83f4 <HAL_GetTick>
    b85e:	eba0 0008 	sub.w	r0, r0, r8
    b862:	42b0      	cmp	r0, r6
    b864:	d801      	bhi.n	b86a <FLASH_WaitForLastOperation+0x7a>
    b866:	2e00      	cmp	r6, #0
    b868:	d1d1      	bne.n	b80e <FLASH_WaitForLastOperation+0x1e>
        return HAL_TIMEOUT;
    b86a:	2003      	movs	r0, #3
    b86c:	e7ed      	b.n	b84a <FLASH_WaitForLastOperation+0x5a>
    b86e:	1c70      	adds	r0, r6, #1
    b870:	d127      	bne.n	b8c2 <FLASH_WaitForLastOperation+0xd2>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b872:	4a1c      	ldr	r2, [pc, #112]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
    b874:	6913      	ldr	r3, [r2, #16]
    b876:	0759      	lsls	r1, r3, #29
    b878:	d4fc      	bmi.n	b874 <FLASH_WaitForLastOperation+0x84>
  if (Bank == FLASH_BANK_1)
    b87a:	2d01      	cmp	r5, #1
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b87c:	4a19      	ldr	r2, [pc, #100]	; (b8e4 <FLASH_WaitForLastOperation+0xf4>)
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b87e:	481a      	ldr	r0, [pc, #104]	; (b8e8 <FLASH_WaitForLastOperation+0xf8>)
  if (Bank == FLASH_BANK_1)
    b880:	d1d4      	bne.n	b82c <FLASH_WaitForLastOperation+0x3c>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b882:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
    b884:	4018      	ands	r0, r3
    b886:	d120      	bne.n	b8ca <FLASH_WaitForLastOperation+0xda>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
    b888:	6915      	ldr	r5, [r2, #16]
    b88a:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
    b88e:	d00e      	beq.n	b8ae <FLASH_WaitForLastOperation+0xbe>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
    b890:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b894:	6153      	str	r3, [r2, #20]
    b896:	e7d8      	b.n	b84a <FLASH_WaitForLastOperation+0x5a>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
    b898:	f8d2 5110 	ldr.w	r5, [r2, #272]	; 0x110
    b89c:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
    b8a0:	d005      	beq.n	b8ae <FLASH_WaitForLastOperation+0xbe>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    b8a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    b8a6:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
    b8aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return HAL_OK;
    b8ae:	4628      	mov	r0, r5
}
    b8b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
    b8b4:	f240 3192 	movw	r1, #914	; 0x392
    b8b8:	480e      	ldr	r0, [pc, #56]	; (b8f4 <FLASH_WaitForLastOperation+0x104>)
    b8ba:	f00d fe01 	bl	194c0 <assert_failed>
    bsyflag = FLASH_FLAG_QW_BANK2;
    b8be:	4c08      	ldr	r4, [pc, #32]	; (b8e0 <FLASH_WaitForLastOperation+0xf0>)
    b8c0:	e7a4      	b.n	b80c <FLASH_WaitForLastOperation+0x1c>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
    b8c2:	693b      	ldr	r3, [r7, #16]
    b8c4:	075b      	lsls	r3, r3, #29
    b8c6:	d4c8      	bmi.n	b85a <FLASH_WaitForLastOperation+0x6a>
    b8c8:	e7ac      	b.n	b824 <FLASH_WaitForLastOperation+0x34>
    pFlash.ErrorCode |= errorflag;
    b8ca:	4c08      	ldr	r4, [pc, #32]	; (b8ec <FLASH_WaitForLastOperation+0xfc>)
    return HAL_ERROR;
    b8cc:	4628      	mov	r0, r5
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
    b8ce:	4908      	ldr	r1, [pc, #32]	; (b8f0 <FLASH_WaitForLastOperation+0x100>)
    b8d0:	400b      	ands	r3, r1
    pFlash.ErrorCode |= errorflag;
    b8d2:	69a1      	ldr	r1, [r4, #24]
    b8d4:	4319      	orrs	r1, r3
    b8d6:	61a1      	str	r1, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
    b8d8:	6153      	str	r3, [r2, #20]
}
    b8da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b8de:	bf00      	nop
    b8e0:	80000004 	.word	0x80000004
    b8e4:	52002000 	.word	0x52002000
    b8e8:	15ee0000 	.word	0x15ee0000
    b8ec:	020e3268 	.word	0x020e3268
    b8f0:	17ee0000 	.word	0x17ee0000
    b8f4:	00030008 	.word	0x00030008

0000b8f8 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
    b8f8:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    b8fa:	f030 0330 	bics.w	r3, r0, #48	; 0x30
{
    b8fe:	4605      	mov	r5, r0
    b900:	460c      	mov	r4, r1
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    b902:	d004      	beq.n	b90e <FLASH_MassErase+0x16>
    b904:	f44f 7144 	mov.w	r1, #784	; 0x310
    b908:	4826      	ldr	r0, [pc, #152]	; (b9a4 <FLASH_MassErase+0xac>)
    b90a:	f00d fdd9 	bl	194c0 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));
    b90e:	1e63      	subs	r3, r4, #1
    b910:	2b02      	cmp	r3, #2
    b912:	d826      	bhi.n	b962 <FLASH_MassErase+0x6a>

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
    b914:	f004 0303 	and.w	r3, r4, #3
    b918:	2b03      	cmp	r3, #3
    b91a:	d02b      	beq.n	b974 <FLASH_MassErase+0x7c>
    FLASH->OPTCR |= FLASH_OPTCR_MER;
  }
  else
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
    b91c:	07e2      	lsls	r2, r4, #31
    b91e:	d50b      	bpl.n	b938 <FLASH_MassErase+0x40>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
    b920:	4b21      	ldr	r3, [pc, #132]	; (b9a8 <FLASH_MassErase+0xb0>)
    b922:	68da      	ldr	r2, [r3, #12]
    b924:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b928:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
    b92a:	68da      	ldr	r2, [r3, #12]
    b92c:	432a      	orrs	r2, r5
    b92e:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
    b930:	68da      	ldr	r2, [r3, #12]
    b932:	f042 0288 	orr.w	r2, r2, #136	; 0x88
    b936:	60da      	str	r2, [r3, #12]
    }
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
    b938:	07a3      	lsls	r3, r4, #30
    b93a:	d511      	bpl.n	b960 <FLASH_MassErase+0x68>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
    b93c:	4b1a      	ldr	r3, [pc, #104]	; (b9a8 <FLASH_MassErase+0xb0>)
    b93e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b942:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b946:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
    b94a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b94e:	4315      	orrs	r5, r2
    b950:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    b954:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b958:	f042 0288 	orr.w	r2, r2, #136	; 0x88
    b95c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    }
  }
}
    b960:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FLASH_BANK(Banks));
    b962:	f44f 7145 	mov.w	r1, #788	; 0x314
    b966:	480f      	ldr	r0, [pc, #60]	; (b9a4 <FLASH_MassErase+0xac>)
    b968:	f00d fdaa 	bl	194c0 <assert_failed>
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
    b96c:	f004 0303 	and.w	r3, r4, #3
    b970:	2b03      	cmp	r3, #3
    b972:	d1d3      	bne.n	b91c <FLASH_MassErase+0x24>
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
    b974:	4b0c      	ldr	r3, [pc, #48]	; (b9a8 <FLASH_MassErase+0xb0>)
    b976:	68da      	ldr	r2, [r3, #12]
    b978:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b97c:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
    b97e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b982:	f022 0230 	bic.w	r2, r2, #48	; 0x30
    b986:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    FLASH->CR1 |= VoltageRange;
    b98a:	68da      	ldr	r2, [r3, #12]
    b98c:	432a      	orrs	r2, r5
    b98e:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
    b990:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    b994:	4315      	orrs	r5, r2
    b996:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
    FLASH->OPTCR |= FLASH_OPTCR_MER;
    b99a:	699a      	ldr	r2, [r3, #24]
    b99c:	f042 0210 	orr.w	r2, r2, #16
    b9a0:	619a      	str	r2, [r3, #24]
}
    b9a2:	bd38      	pop	{r3, r4, r5, pc}
    b9a4:	00030044 	.word	0x00030044
    b9a8:	52002000 	.word	0x52002000

0000b9ac <HAL_FLASHEx_Erase>:
{
    b9ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    b9b0:	6803      	ldr	r3, [r0, #0]
{
    b9b2:	b083      	sub	sp, #12
    b9b4:	4604      	mov	r4, r0
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    b9b6:	2b01      	cmp	r3, #1
{
    b9b8:	9101      	str	r1, [sp, #4]
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    b9ba:	d903      	bls.n	b9c4 <HAL_FLASHEx_Erase+0x18>
    b9bc:	21ac      	movs	r1, #172	; 0xac
    b9be:	487d      	ldr	r0, [pc, #500]	; (bbb4 <HAL_FLASHEx_Erase+0x208>)
    b9c0:	f00d fd7e 	bl	194c0 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    b9c4:	6863      	ldr	r3, [r4, #4]
    b9c6:	3b01      	subs	r3, #1
    b9c8:	2b02      	cmp	r3, #2
    b9ca:	f200 80a1 	bhi.w	bb10 <HAL_FLASHEx_Erase+0x164>
  __HAL_LOCK(&pFlash);
    b9ce:	f8df 81ec 	ldr.w	r8, [pc, #492]	; bbbc <HAL_FLASHEx_Erase+0x210>
    b9d2:	f898 3014 	ldrb.w	r3, [r8, #20]
    b9d6:	2b01      	cmp	r3, #1
    b9d8:	f000 80a5 	beq.w	bb26 <HAL_FLASHEx_Erase+0x17a>
    b9dc:	2501      	movs	r5, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b9de:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
    b9e0:	f888 5014 	strb.w	r5, [r8, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    b9e4:	f8c8 3018 	str.w	r3, [r8, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    b9e8:	6862      	ldr	r2, [r4, #4]
    b9ea:	07d0      	lsls	r0, r2, #31
    b9ec:	f100 80a0 	bmi.w	bb30 <HAL_FLASHEx_Erase+0x184>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    b9f0:	0793      	lsls	r3, r2, #30
    b9f2:	d50d      	bpl.n	ba10 <HAL_FLASHEx_Erase+0x64>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    b9f4:	2102      	movs	r1, #2
    b9f6:	f24c 3050 	movw	r0, #50000	; 0xc350
    b9fa:	f7ff fef9 	bl	b7f0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
    b9fe:	b138      	cbz	r0, ba10 <HAL_FLASHEx_Erase+0x64>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    ba00:	2301      	movs	r3, #1
  __HAL_UNLOCK(&pFlash);
    ba02:	2200      	movs	r2, #0
}
    ba04:	4618      	mov	r0, r3
  __HAL_UNLOCK(&pFlash);
    ba06:	f888 2014 	strb.w	r2, [r8, #20]
}
    ba0a:	b003      	add	sp, #12
    ba0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
    ba10:	6825      	ldr	r5, [r4, #0]
    ba12:	2d01      	cmp	r5, #1
    ba14:	f000 80a2 	beq.w	bb5c <HAL_FLASHEx_Erase+0x1b0>
      *SectorError = 0xFFFFFFFFU;
    ba18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ba1c:	9a01      	ldr	r2, [sp, #4]
    ba1e:	6013      	str	r3, [r2, #0]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
    ba20:	e9d4 6302 	ldrd	r6, r3, [r4, #8]
    ba24:	4433      	add	r3, r6
    ba26:	42b3      	cmp	r3, r6
    ba28:	f240 8096 	bls.w	bb58 <HAL_FLASHEx_Erase+0x1ac>
    ba2c:	0237      	lsls	r7, r6, #8
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
  assert_param(IS_FLASH_SECTOR(Sector));
    ba2e:	f8df 9184 	ldr.w	r9, [pc, #388]	; bbb4 <HAL_FLASHEx_Erase+0x208>

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    ba32:	4d61      	ldr	r5, [pc, #388]	; (bbb8 <HAL_FLASHEx_Erase+0x20c>)
    ba34:	e03d      	b.n	bab2 <HAL_FLASHEx_Erase+0x106>
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));
    ba36:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    ba3a:	2901      	cmp	r1, #1
    ba3c:	d904      	bls.n	ba48 <HAL_FLASHEx_Erase+0x9c>
    ba3e:	f240 3157 	movw	r1, #855	; 0x357
    ba42:	4648      	mov	r0, r9
    ba44:	f00d fd3c 	bl	194c0 <assert_failed>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
    ba48:	f03b 0330 	bics.w	r3, fp, #48	; 0x30
    ba4c:	d004      	beq.n	ba58 <HAL_FLASHEx_Erase+0xac>
    ba4e:	f240 3159 	movw	r1, #857	; 0x359
    ba52:	4648      	mov	r0, r9
    ba54:	f00d fd34 	bl	194c0 <assert_failed>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
    ba58:	f01a 0f01 	tst.w	sl, #1
    ba5c:	d00a      	beq.n	ba74 <HAL_FLASHEx_Erase+0xc8>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    ba5e:	68e9      	ldr	r1, [r5, #12]
    ba60:	f421 61e6 	bic.w	r1, r1, #1840	; 0x730
    ba64:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
    ba66:	68e9      	ldr	r1, [r5, #12]
    ba68:	f041 0184 	orr.w	r1, r1, #132	; 0x84
    ba6c:	ea41 010b 	orr.w	r1, r1, fp
    ba70:	4339      	orrs	r1, r7
    ba72:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
    ba74:	f01a 0f02 	tst.w	sl, #2
    ba78:	d00e      	beq.n	ba98 <HAL_FLASHEx_Erase+0xec>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
    ba7a:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    ba7e:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
    ba82:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
    ba86:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
    ba8a:	f043 0384 	orr.w	r3, r3, #132	; 0x84
    ba8e:	ea43 030b 	orr.w	r3, r3, fp
    ba92:	433b      	orrs	r3, r7
    ba94:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    ba98:	6863      	ldr	r3, [r4, #4]
    ba9a:	07da      	lsls	r2, r3, #31
    ba9c:	d415      	bmi.n	baca <HAL_FLASHEx_Erase+0x11e>
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    ba9e:	0798      	lsls	r0, r3, #30
    baa0:	d427      	bmi.n	baf2 <HAL_FLASHEx_Erase+0x146>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
    baa2:	68e3      	ldr	r3, [r4, #12]
    baa4:	3601      	adds	r6, #1
    baa6:	68a2      	ldr	r2, [r4, #8]
    baa8:	f507 7780 	add.w	r7, r7, #256	; 0x100
    baac:	4413      	add	r3, r2
    baae:	42b3      	cmp	r3, r6
    bab0:	d952      	bls.n	bb58 <HAL_FLASHEx_Erase+0x1ac>
  assert_param(IS_FLASH_SECTOR(Sector));
    bab2:	2e07      	cmp	r6, #7
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
    bab4:	f8d4 a004 	ldr.w	sl, [r4, #4]
    bab8:	f8d4 b010 	ldr.w	fp, [r4, #16]
  assert_param(IS_FLASH_SECTOR(Sector));
    babc:	d9bb      	bls.n	ba36 <HAL_FLASHEx_Erase+0x8a>
    babe:	f240 3156 	movw	r1, #854	; 0x356
    bac2:	4648      	mov	r0, r9
    bac4:	f00d fcfc 	bl	194c0 <assert_failed>
    bac8:	e7b5      	b.n	ba36 <HAL_FLASHEx_Erase+0x8a>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
    baca:	2101      	movs	r1, #1
    bacc:	f24c 3050 	movw	r0, #50000	; 0xc350
    bad0:	f7ff fe8e 	bl	b7f0 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bad4:	68ea      	ldr	r2, [r5, #12]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
    bad6:	4603      	mov	r3, r0
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bad8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    badc:	f022 0204 	bic.w	r2, r2, #4
    bae0:	60ea      	str	r2, [r5, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    bae2:	6862      	ldr	r2, [r4, #4]
    bae4:	0791      	lsls	r1, r2, #30
    bae6:	d404      	bmi.n	baf2 <HAL_FLASHEx_Erase+0x146>
        if(status != HAL_OK)
    bae8:	2b00      	cmp	r3, #0
    baea:	d0da      	beq.n	baa2 <HAL_FLASHEx_Erase+0xf6>
          *SectorError = sector_index;
    baec:	9a01      	ldr	r2, [sp, #4]
    baee:	6016      	str	r6, [r2, #0]
          break;
    baf0:	e787      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
    baf2:	2102      	movs	r1, #2
    baf4:	f24c 3050 	movw	r0, #50000	; 0xc350
    baf8:	f7ff fe7a 	bl	b7f0 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bafc:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
    bb00:	4603      	mov	r3, r0
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
    bb02:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    bb06:	f022 0204 	bic.w	r2, r2, #4
    bb0a:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
    bb0e:	e7eb      	b.n	bae8 <HAL_FLASHEx_Erase+0x13c>
  __HAL_LOCK(&pFlash);
    bb10:	f8df 80a8 	ldr.w	r8, [pc, #168]	; bbbc <HAL_FLASHEx_Erase+0x210>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
    bb14:	21ad      	movs	r1, #173	; 0xad
    bb16:	4827      	ldr	r0, [pc, #156]	; (bbb4 <HAL_FLASHEx_Erase+0x208>)
    bb18:	f00d fcd2 	bl	194c0 <assert_failed>
  __HAL_LOCK(&pFlash);
    bb1c:	f898 3014 	ldrb.w	r3, [r8, #20]
    bb20:	2b01      	cmp	r3, #1
    bb22:	f47f af5b 	bne.w	b9dc <HAL_FLASHEx_Erase+0x30>
    bb26:	2302      	movs	r3, #2
}
    bb28:	4618      	mov	r0, r3
    bb2a:	b003      	add	sp, #12
    bb2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
    bb30:	4629      	mov	r1, r5
    bb32:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb36:	f7ff fe5b 	bl	b7f0 <FLASH_WaitForLastOperation>
    bb3a:	b158      	cbz	r0, bb54 <HAL_FLASHEx_Erase+0x1a8>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    bb3c:	6863      	ldr	r3, [r4, #4]
    bb3e:	079a      	lsls	r2, r3, #30
    bb40:	f57f af5e 	bpl.w	ba00 <HAL_FLASHEx_Erase+0x54>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    bb44:	2102      	movs	r1, #2
    bb46:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb4a:	9501      	str	r5, [sp, #4]
    bb4c:	f7ff fe50 	bl	b7f0 <FLASH_WaitForLastOperation>
    bb50:	9b01      	ldr	r3, [sp, #4]
    bb52:	e756      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
    bb54:	6862      	ldr	r2, [r4, #4]
    bb56:	e74b      	b.n	b9f0 <HAL_FLASHEx_Erase+0x44>
    bb58:	2300      	movs	r3, #0
    bb5a:	e752      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
    bb5c:	6861      	ldr	r1, [r4, #4]
    bb5e:	6920      	ldr	r0, [r4, #16]
    bb60:	f7ff feca 	bl	b8f8 <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
    bb64:	6862      	ldr	r2, [r4, #4]
    bb66:	f012 0301 	ands.w	r3, r2, #1
    bb6a:	d114      	bne.n	bb96 <HAL_FLASHEx_Erase+0x1ea>
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
    bb6c:	0791      	lsls	r1, r2, #30
    bb6e:	f57f af48 	bpl.w	ba02 <HAL_FLASHEx_Erase+0x56>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
    bb72:	2102      	movs	r1, #2
    bb74:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb78:	9301      	str	r3, [sp, #4]
    bb7a:	f7ff fe39 	bl	b7f0 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
    bb7e:	490e      	ldr	r1, [pc, #56]	; (bbb8 <HAL_FLASHEx_Erase+0x20c>)
          status = HAL_ERROR;
    bb80:	2800      	cmp	r0, #0
    bb82:	9b01      	ldr	r3, [sp, #4]
        FLASH->CR2 &= (~FLASH_CR_BER);
    bb84:	f8d1 210c 	ldr.w	r2, [r1, #268]	; 0x10c
          status = HAL_ERROR;
    bb88:	bf18      	it	ne
    bb8a:	2301      	movne	r3, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
    bb8c:	f022 0208 	bic.w	r2, r2, #8
    bb90:	f8c1 210c 	str.w	r2, [r1, #268]	; 0x10c
    bb94:	e735      	b.n	ba02 <HAL_FLASHEx_Erase+0x56>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
    bb96:	4629      	mov	r1, r5
    bb98:	f24c 3050 	movw	r0, #50000	; 0xc350
    bb9c:	f7ff fe28 	bl	b7f0 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
    bba0:	4905      	ldr	r1, [pc, #20]	; (bbb8 <HAL_FLASHEx_Erase+0x20c>)
          status = HAL_ERROR;
    bba2:	1c03      	adds	r3, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
    bba4:	68ca      	ldr	r2, [r1, #12]
          status = HAL_ERROR;
    bba6:	bf18      	it	ne
    bba8:	2301      	movne	r3, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
    bbaa:	f022 0208 	bic.w	r2, r2, #8
    bbae:	60ca      	str	r2, [r1, #12]
    bbb0:	6862      	ldr	r2, [r4, #4]
    bbb2:	e7db      	b.n	bb6c <HAL_FLASHEx_Erase+0x1c0>
    bbb4:	00030044 	.word	0x00030044
    bbb8:	52002000 	.word	0x52002000
    bbbc:	020e3268 	.word	0x020e3268

0000bbc0 <HAL_GPIO_Init>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bbc0:	4abf      	ldr	r2, [pc, #764]	; (bec0 <HAL_GPIO_Init+0x300>)
    bbc2:	4bc0      	ldr	r3, [pc, #768]	; (bec4 <HAL_GPIO_Init+0x304>)
    bbc4:	4290      	cmp	r0, r2
    bbc6:	bf18      	it	ne
    bbc8:	4298      	cmpne	r0, r3
{
    bbca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bbce:	4607      	mov	r7, r0
    bbd0:	b089      	sub	sp, #36	; 0x24
    bbd2:	4689      	mov	r9, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bbd4:	bf14      	ite	ne
    bbd6:	f04f 0b01 	movne.w	fp, #1
    bbda:	f04f 0b00 	moveq.w	fp, #0
    bbde:	d027      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbe0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbe4:	4298      	cmp	r0, r3
    bbe6:	d023      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbe8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbec:	4298      	cmp	r0, r3
    bbee:	d01f      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbf0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbf4:	4298      	cmp	r0, r3
    bbf6:	d01b      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bbf8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bbfc:	4298      	cmp	r0, r3
    bbfe:	d017      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc00:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bc04:	4298      	cmp	r0, r3
    bc06:	d013      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc08:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bc0c:	4298      	cmp	r0, r3
    bc0e:	d00f      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc10:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
    bc14:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    bc18:	4290      	cmp	r0, r2
    bc1a:	bf18      	it	ne
    bc1c:	4298      	cmpne	r0, r3
    bc1e:	d007      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc20:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bc24:	4298      	cmp	r0, r3
    bc26:	d003      	beq.n	bc30 <HAL_GPIO_Init+0x70>
    bc28:	21bb      	movs	r1, #187	; 0xbb
    bc2a:	48a7      	ldr	r0, [pc, #668]	; (bec8 <HAL_GPIO_Init+0x308>)
    bc2c:	f00d fc48 	bl	194c0 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    bc30:	f8d9 2000 	ldr.w	r2, [r9]
    bc34:	b293      	uxth	r3, r2
    bc36:	2b00      	cmp	r3, #0
    bc38:	f000 8168 	beq.w	bf0c <HAL_GPIO_Init+0x34c>
    bc3c:	4ba3      	ldr	r3, [pc, #652]	; (becc <HAL_GPIO_Init+0x30c>)
    bc3e:	4013      	ands	r3, r2
    bc40:	2b00      	cmp	r3, #0
    bc42:	f040 8163 	bne.w	bf0c <HAL_GPIO_Init+0x34c>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    bc46:	f8d9 2004 	ldr.w	r2, [r9, #4]
    bc4a:	4ba1      	ldr	r3, [pc, #644]	; (bed0 <HAL_GPIO_Init+0x310>)
    bc4c:	4ca1      	ldr	r4, [pc, #644]	; (bed4 <HAL_GPIO_Init+0x314>)
    bc4e:	f1a2 0011 	sub.w	r0, r2, #17
    bc52:	429a      	cmp	r2, r3
    bc54:	bf18      	it	ne
    bc56:	2a03      	cmpne	r2, #3
    bc58:	f422 1100 	bic.w	r1, r2, #2097152	; 0x200000
    bc5c:	bf8c      	ite	hi
    bc5e:	2301      	movhi	r3, #1
    bc60:	2300      	movls	r3, #0
    bc62:	42a2      	cmp	r2, r4
    bc64:	bf0c      	ite	eq
    bc66:	2300      	moveq	r3, #0
    bc68:	f003 0301 	andne.w	r3, r3, #1
    bc6c:	4a9a      	ldr	r2, [pc, #616]	; (bed8 <HAL_GPIO_Init+0x318>)
    bc6e:	2801      	cmp	r0, #1
    bc70:	bf94      	ite	ls
    bc72:	2300      	movls	r3, #0
    bc74:	f003 0301 	andhi.w	r3, r3, #1
    bc78:	4291      	cmp	r1, r2
    bc7a:	bf0c      	ite	eq
    bc7c:	2300      	moveq	r3, #0
    bc7e:	f003 0301 	andne.w	r3, r3, #1
    bc82:	b11b      	cbz	r3, bc8c <HAL_GPIO_Init+0xcc>
    bc84:	4b95      	ldr	r3, [pc, #596]	; (bedc <HAL_GPIO_Init+0x31c>)
    bc86:	4299      	cmp	r1, r3
    bc88:	f040 8193 	bne.w	bfb2 <HAL_GPIO_Init+0x3f2>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    bc8c:	f8d9 3008 	ldr.w	r3, [r9, #8]
    bc90:	2b02      	cmp	r3, #2
    bc92:	f200 8170 	bhi.w	bf76 <HAL_GPIO_Init+0x3b6>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
    bc96:	f8d9 1000 	ldr.w	r1, [r9]
    bc9a:	2900      	cmp	r1, #0
    bc9c:	f000 810d 	beq.w	beba <HAL_GPIO_Init+0x2fa>

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bca0:	4b8f      	ldr	r3, [pc, #572]	; (bee0 <HAL_GPIO_Init+0x320>)
    bca2:	f04f 0800 	mov.w	r8, #0
    bca6:	4a8f      	ldr	r2, [pc, #572]	; (bee4 <HAL_GPIO_Init+0x324>)
    bca8:	488f      	ldr	r0, [pc, #572]	; (bee8 <HAL_GPIO_Init+0x328>)
    bcaa:	429f      	cmp	r7, r3
    bcac:	bf18      	it	ne
    bcae:	4297      	cmpne	r7, r2
    bcb0:	4d8e      	ldr	r5, [pc, #568]	; (beec <HAL_GPIO_Init+0x32c>)
    bcb2:	f5a2 52c0 	sub.w	r2, r2, #6144	; 0x1800
    bcb6:	4c8e      	ldr	r4, [pc, #568]	; (bef0 <HAL_GPIO_Init+0x330>)
    bcb8:	bf14      	ite	ne
    bcba:	2301      	movne	r3, #1
    bcbc:	2300      	moveq	r3, #0
    bcbe:	42af      	cmp	r7, r5
    bcc0:	bf0c      	ite	eq
    bcc2:	2300      	moveq	r3, #0
    bcc4:	f003 0301 	andne.w	r3, r3, #1
    bcc8:	4287      	cmp	r7, r0
    bcca:	bf18      	it	ne
    bccc:	4297      	cmpne	r7, r2
    bcce:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
    bcd2:	bf14      	ite	ne
    bcd4:	2201      	movne	r2, #1
    bcd6:	2200      	moveq	r2, #0
    bcd8:	9305      	str	r3, [sp, #20]
    bcda:	4b86      	ldr	r3, [pc, #536]	; (bef4 <HAL_GPIO_Init+0x334>)
    bcdc:	9200      	str	r2, [sp, #0]
    bcde:	42a7      	cmp	r7, r4
    bce0:	bf18      	it	ne
    bce2:	429f      	cmpne	r7, r3
    bce4:	4a84      	ldr	r2, [pc, #528]	; (bef8 <HAL_GPIO_Init+0x338>)
    bce6:	bf14      	ite	ne
    bce8:	2301      	movne	r3, #1
    bcea:	2300      	moveq	r3, #0
    bcec:	4287      	cmp	r7, r0
    bcee:	bf18      	it	ne
    bcf0:	4297      	cmpne	r7, r2
    bcf2:	9301      	str	r3, [sp, #4]
    bcf4:	bf14      	ite	ne
    bcf6:	2201      	movne	r2, #1
    bcf8:	2200      	moveq	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bcfa:	4b80      	ldr	r3, [pc, #512]	; (befc <HAL_GPIO_Init+0x33c>)
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bcfc:	9204      	str	r2, [sp, #16]
    bcfe:	4a80      	ldr	r2, [pc, #512]	; (bf00 <HAL_GPIO_Init+0x340>)
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
    bd00:	2401      	movs	r4, #1
    bd02:	fa04 f408 	lsl.w	r4, r4, r8
    if (iocurrent != 0x00U)
    bd06:	ea14 0a01 	ands.w	sl, r4, r1
    bd0a:	f000 80d0 	beq.w	beae <HAL_GPIO_Init+0x2ee>
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    bd0e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    bd12:	ea4f 0648 	mov.w	r6, r8, lsl #1
    bd16:	2503      	movs	r5, #3
    bd18:	f021 0110 	bic.w	r1, r1, #16
    bd1c:	40b5      	lsls	r5, r6
    bd1e:	3901      	subs	r1, #1
    bd20:	43ed      	mvns	r5, r5
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    bd22:	2901      	cmp	r1, #1
    bd24:	d814      	bhi.n	bd50 <HAL_GPIO_Init+0x190>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    bd26:	f8d9 100c 	ldr.w	r1, [r9, #12]
    bd2a:	2903      	cmp	r1, #3
    bd2c:	f200 80f3 	bhi.w	bf16 <HAL_GPIO_Init+0x356>
        temp = GPIOx->OSPEEDR;
    bd30:	68b8      	ldr	r0, [r7, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
    bd32:	40b1      	lsls	r1, r6
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    bd34:	4028      	ands	r0, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
    bd36:	4301      	orrs	r1, r0
        GPIOx->OSPEEDR = temp;
    bd38:	60b9      	str	r1, [r7, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    bd3a:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = GPIOx->OTYPER;
    bd3e:	6878      	ldr	r0, [r7, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    bd40:	f3c1 1100 	ubfx	r1, r1, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
    bd44:	ea20 0004 	bic.w	r0, r0, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    bd48:	fa01 f408 	lsl.w	r4, r1, r8
    bd4c:	4304      	orrs	r4, r0
        GPIOx->OTYPER = temp;
    bd4e:	607c      	str	r4, [r7, #4]
      temp = GPIOx->PUPDR;
    bd50:	68f8      	ldr	r0, [r7, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
    bd52:	f8d9 1008 	ldr.w	r1, [r9, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    bd56:	4028      	ands	r0, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
    bd58:	40b1      	lsls	r1, r6
    bd5a:	4301      	orrs	r1, r0
      GPIOx->PUPDR = temp;
    bd5c:	60f9      	str	r1, [r7, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    bd5e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    bd62:	f021 0010 	bic.w	r0, r1, #16
    bd66:	2802      	cmp	r0, #2
    bd68:	d120      	bne.n	bdac <HAL_GPIO_Init+0x1ec>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bd6a:	f1bb 0f00 	cmp.w	fp, #0
    bd6e:	d003      	beq.n	bd78 <HAL_GPIO_Init+0x1b8>
    bd70:	9900      	ldr	r1, [sp, #0]
    bd72:	2900      	cmp	r1, #0
    bd74:	f040 80da 	bne.w	bf2c <HAL_GPIO_Init+0x36c>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    bd78:	f8d9 e010 	ldr.w	lr, [r9, #16]
    bd7c:	f1be 0f0f 	cmp.w	lr, #15
    bd80:	f200 80ee 	bhi.w	bf60 <HAL_GPIO_Init+0x3a0>
        temp = GPIOx->AFR[position >> 3U];
    bd84:	ea4f 00d8 	mov.w	r0, r8, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    bd88:	f008 0107 	and.w	r1, r8, #7
    bd8c:	f04f 0c0f 	mov.w	ip, #15
    bd90:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    bd94:	0089      	lsls	r1, r1, #2
        temp = GPIOx->AFR[position >> 3U];
    bd96:	6a04      	ldr	r4, [r0, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    bd98:	fa0c fc01 	lsl.w	ip, ip, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    bd9c:	fa0e f101 	lsl.w	r1, lr, r1
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
    bda0:	ea24 040c 	bic.w	r4, r4, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    bda4:	4321      	orrs	r1, r4
        GPIOx->AFR[position >> 3U] = temp;
    bda6:	6201      	str	r1, [r0, #32]
    bda8:	f8d9 1004 	ldr.w	r1, [r9, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    bdac:	f001 0103 	and.w	r1, r1, #3
      temp = GPIOx->MODER;
    bdb0:	6838      	ldr	r0, [r7, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    bdb2:	fa01 f606 	lsl.w	r6, r1, r6
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
    bdb6:	4005      	ands	r5, r0
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    bdb8:	4335      	orrs	r5, r6
      GPIOx->MODER = temp;
    bdba:	603d      	str	r5, [r7, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
    bdbc:	f8d9 1004 	ldr.w	r1, [r9, #4]
    bdc0:	00cc      	lsls	r4, r1, #3
    bdc2:	d572      	bpl.n	beaa <HAL_GPIO_Init+0x2ea>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdc4:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
    bdc8:	f028 0503 	bic.w	r5, r8, #3

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bdcc:	f008 0103 	and.w	r1, r8, #3
    bdd0:	200f      	movs	r0, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdd2:	f044 0402 	orr.w	r4, r4, #2
    bdd6:	4415      	add	r5, r2
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bdd8:	0089      	lsls	r1, r1, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdda:	f8c3 40f4 	str.w	r4, [r3, #244]	; 0xf4
    bdde:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bde2:	fa00 f601 	lsl.w	r6, r0, r1
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bde6:	f004 0402 	and.w	r4, r4, #2
    bdea:	9407      	str	r4, [sp, #28]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    bdec:	4c34      	ldr	r4, [pc, #208]	; (bec0 <HAL_GPIO_Init+0x300>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
    bdee:	9807      	ldr	r0, [sp, #28]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    bdf0:	42a7      	cmp	r7, r4
        temp = SYSCFG->EXTICR[position >> 2U];
    bdf2:	68a8      	ldr	r0, [r5, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    bdf4:	ea20 0006 	bic.w	r0, r0, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
    bdf8:	d027      	beq.n	be4a <HAL_GPIO_Init+0x28a>
    bdfa:	f1bb 0f00 	cmp.w	fp, #0
    bdfe:	f000 80bf 	beq.w	bf80 <HAL_GPIO_Init+0x3c0>
    be02:	4c39      	ldr	r4, [pc, #228]	; (bee8 <HAL_GPIO_Init+0x328>)
    be04:	42a7      	cmp	r7, r4
    be06:	f000 80a6 	beq.w	bf56 <HAL_GPIO_Init+0x396>
    be0a:	9c00      	ldr	r4, [sp, #0]
    be0c:	2c00      	cmp	r4, #0
    be0e:	f000 80c1 	beq.w	bf94 <HAL_GPIO_Init+0x3d4>
    be12:	4c37      	ldr	r4, [pc, #220]	; (bef0 <HAL_GPIO_Init+0x330>)
    be14:	42a7      	cmp	r7, r4
    be16:	f000 80c2 	beq.w	bf9e <HAL_GPIO_Init+0x3de>
    be1a:	9c01      	ldr	r4, [sp, #4]
    be1c:	2c00      	cmp	r4, #0
    be1e:	f000 80b4 	beq.w	bf8a <HAL_GPIO_Init+0x3ca>
    be22:	4c38      	ldr	r4, [pc, #224]	; (bf04 <HAL_GPIO_Init+0x344>)
    be24:	42a7      	cmp	r7, r4
    be26:	f000 80bf 	beq.w	bfa8 <HAL_GPIO_Init+0x3e8>
    be2a:	9c04      	ldr	r4, [sp, #16]
    be2c:	2c00      	cmp	r4, #0
    be2e:	f000 80c5 	beq.w	bfbc <HAL_GPIO_Init+0x3fc>
    be32:	4c2b      	ldr	r4, [pc, #172]	; (bee0 <HAL_GPIO_Init+0x320>)
    be34:	42a7      	cmp	r7, r4
    be36:	f000 80c6 	beq.w	bfc6 <HAL_GPIO_Init+0x406>
    be3a:	4c2a      	ldr	r4, [pc, #168]	; (bee4 <HAL_GPIO_Init+0x324>)
    be3c:	42a7      	cmp	r7, r4
    be3e:	bf0c      	ite	eq
    be40:	2409      	moveq	r4, #9
    be42:	240a      	movne	r4, #10
    be44:	fa04 f101 	lsl.w	r1, r4, r1
    be48:	4308      	orrs	r0, r1
        SYSCFG->EXTICR[position >> 2U] = temp;
    be4a:	60a8      	str	r0, [r5, #8]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
        temp &= ~(iocurrent);
    be4c:	ea6f 050a 	mvn.w	r5, sl
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    be50:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->IMR1;
    be54:	492c      	ldr	r1, [pc, #176]	; (bf08 <HAL_GPIO_Init+0x348>)
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    be56:	03c0      	lsls	r0, r0, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
    be58:	4c2b      	ldr	r4, [pc, #172]	; (bf08 <HAL_GPIO_Init+0x348>)
        temp = EXTI_CurrentCPU->IMR1;
    be5a:	6809      	ldr	r1, [r1, #0]
        temp &= ~(iocurrent);
    be5c:	bf54      	ite	pl
    be5e:	4029      	andpl	r1, r5
          temp |= iocurrent;
    be60:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->IMR1 = temp;
    be64:	6021      	str	r1, [r4, #0]

        temp = EXTI_CurrentCPU->EMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    be66:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->EMR1;
    be6a:	6861      	ldr	r1, [r4, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    be6c:	0386      	lsls	r6, r0, #14
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
    be6e:	4c26      	ldr	r4, [pc, #152]	; (bf08 <HAL_GPIO_Init+0x348>)

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
    be70:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    be74:	bf54      	ite	pl
    be76:	4029      	andpl	r1, r5
          temp |= iocurrent;
    be78:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->EMR1 = temp;
    be7c:	6061      	str	r1, [r4, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
    be7e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    be82:	f8d9 4004 	ldr.w	r4, [r9, #4]
        temp = EXTI->RTSR1;
    be86:	6800      	ldr	r0, [r0, #0]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    be88:	02e4      	lsls	r4, r4, #11
        temp &= ~(iocurrent);
    be8a:	bf54      	ite	pl
    be8c:	4028      	andpl	r0, r5
          temp |= iocurrent;
    be8e:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI->RTSR1 = temp;
    be92:	6008      	str	r0, [r1, #0]

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    be94:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI->FTSR1;
    be98:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    be9a:	0280      	lsls	r0, r0, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
    be9c:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
    bea0:	bf54      	ite	pl
    bea2:	4029      	andpl	r1, r5
          temp |= iocurrent;
    bea4:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI->FTSR1 = temp;
    bea8:	6041      	str	r1, [r0, #4]
    beaa:	f8d9 1000 	ldr.w	r1, [r9]
      }
    }

    position++;
    beae:	f108 0801 	add.w	r8, r8, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
    beb2:	fa31 f008 	lsrs.w	r0, r1, r8
    beb6:	f47f af23 	bne.w	bd00 <HAL_GPIO_Init+0x140>
  }
}
    beba:	b009      	add	sp, #36	; 0x24
    bebc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bec0:	58020000 	.word	0x58020000
    bec4:	58020400 	.word	0x58020400
    bec8:	00030084 	.word	0x00030084
    becc:	ffff0000 	.word	0xffff0000
    bed0:	11210000 	.word	0x11210000
    bed4:	11220000 	.word	0x11220000
    bed8:	11110000 	.word	0x11110000
    bedc:	11120000 	.word	0x11120000
    bee0:	58022000 	.word	0x58022000
    bee4:	58022400 	.word	0x58022400
    bee8:	58020800 	.word	0x58020800
    beec:	58022800 	.word	0x58022800
    bef0:	58021000 	.word	0x58021000
    bef4:	58021400 	.word	0x58021400
    bef8:	58021c00 	.word	0x58021c00
    befc:	58024400 	.word	0x58024400
    bf00:	58000400 	.word	0x58000400
    bf04:	58021800 	.word	0x58021800
    bf08:	58000080 	.word	0x58000080
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    bf0c:	21bc      	movs	r1, #188	; 0xbc
    bf0e:	4830      	ldr	r0, [pc, #192]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf10:	f00d fad6 	bl	194c0 <assert_failed>
    bf14:	e697      	b.n	bc46 <HAL_GPIO_Init+0x86>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    bf16:	21ce      	movs	r1, #206	; 0xce
    bf18:	482d      	ldr	r0, [pc, #180]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf1a:	e9cd 3202 	strd	r3, r2, [sp, #8]
    bf1e:	f00d facf 	bl	194c0 <assert_failed>
    bf22:	f8d9 100c 	ldr.w	r1, [r9, #12]
    bf26:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    bf2a:	e701      	b.n	bd30 <HAL_GPIO_Init+0x170>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    bf2c:	9901      	ldr	r1, [sp, #4]
    bf2e:	2900      	cmp	r1, #0
    bf30:	f43f af22 	beq.w	bd78 <HAL_GPIO_Init+0x1b8>
    bf34:	9904      	ldr	r1, [sp, #16]
    bf36:	2900      	cmp	r1, #0
    bf38:	f43f af1e 	beq.w	bd78 <HAL_GPIO_Init+0x1b8>
    bf3c:	9905      	ldr	r1, [sp, #20]
    bf3e:	2900      	cmp	r1, #0
    bf40:	f43f af1a 	beq.w	bd78 <HAL_GPIO_Init+0x1b8>
    bf44:	21e6      	movs	r1, #230	; 0xe6
    bf46:	4822      	ldr	r0, [pc, #136]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf48:	e9cd 3202 	strd	r3, r2, [sp, #8]
    bf4c:	f00d fab8 	bl	194c0 <assert_failed>
    bf50:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    bf54:	e710      	b.n	bd78 <HAL_GPIO_Init+0x1b8>
    bf56:	2402      	movs	r4, #2
    bf58:	fa04 f101 	lsl.w	r1, r4, r1
    bf5c:	4308      	orrs	r0, r1
    bf5e:	e774      	b.n	be4a <HAL_GPIO_Init+0x28a>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    bf60:	21e7      	movs	r1, #231	; 0xe7
    bf62:	481b      	ldr	r0, [pc, #108]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf64:	e9cd 3202 	strd	r3, r2, [sp, #8]
    bf68:	f00d faaa 	bl	194c0 <assert_failed>
    bf6c:	f8d9 e010 	ldr.w	lr, [r9, #16]
    bf70:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    bf74:	e706      	b.n	bd84 <HAL_GPIO_Init+0x1c4>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    bf76:	21be      	movs	r1, #190	; 0xbe
    bf78:	4815      	ldr	r0, [pc, #84]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bf7a:	f00d faa1 	bl	194c0 <assert_failed>
    bf7e:	e68a      	b.n	bc96 <HAL_GPIO_Init+0xd6>
    bf80:	2401      	movs	r4, #1
    bf82:	fa04 f101 	lsl.w	r1, r4, r1
    bf86:	4308      	orrs	r0, r1
    bf88:	e75f      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bf8a:	2405      	movs	r4, #5
    bf8c:	fa04 f101 	lsl.w	r1, r4, r1
    bf90:	4308      	orrs	r0, r1
    bf92:	e75a      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bf94:	2403      	movs	r4, #3
    bf96:	fa04 f101 	lsl.w	r1, r4, r1
    bf9a:	4308      	orrs	r0, r1
    bf9c:	e755      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bf9e:	2404      	movs	r4, #4
    bfa0:	fa04 f101 	lsl.w	r1, r4, r1
    bfa4:	4308      	orrs	r0, r1
    bfa6:	e750      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bfa8:	2406      	movs	r4, #6
    bfaa:	fa04 f101 	lsl.w	r1, r4, r1
    bfae:	4308      	orrs	r0, r1
    bfb0:	e74b      	b.n	be4a <HAL_GPIO_Init+0x28a>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    bfb2:	21bd      	movs	r1, #189	; 0xbd
    bfb4:	4806      	ldr	r0, [pc, #24]	; (bfd0 <HAL_GPIO_Init+0x410>)
    bfb6:	f00d fa83 	bl	194c0 <assert_failed>
    bfba:	e667      	b.n	bc8c <HAL_GPIO_Init+0xcc>
    bfbc:	2407      	movs	r4, #7
    bfbe:	fa04 f101 	lsl.w	r1, r4, r1
    bfc2:	4308      	orrs	r0, r1
    bfc4:	e741      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bfc6:	2408      	movs	r4, #8
    bfc8:	fa04 f101 	lsl.w	r1, r4, r1
    bfcc:	4308      	orrs	r0, r1
    bfce:	e73c      	b.n	be4a <HAL_GPIO_Init+0x28a>
    bfd0:	00030084 	.word	0x00030084

0000bfd4 <HAL_GPIO_DeInit>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bfd4:	4a80      	ldr	r2, [pc, #512]	; (c1d8 <HAL_GPIO_DeInit+0x204>)
    bfd6:	4b81      	ldr	r3, [pc, #516]	; (c1dc <HAL_GPIO_DeInit+0x208>)
    bfd8:	4290      	cmp	r0, r2
    bfda:	bf18      	it	ne
    bfdc:	4298      	cmpne	r0, r3
{
    bfde:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bfe2:	4604      	mov	r4, r0
    bfe4:	b083      	sub	sp, #12
    bfe6:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    bfe8:	bf14      	ite	ne
    bfea:	f04f 0801 	movne.w	r8, #1
    bfee:	f04f 0800 	moveq.w	r8, #0
    bff2:	d028      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    bff4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    bff8:	4298      	cmp	r0, r3
    bffa:	d024      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    bffc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c000:	4298      	cmp	r0, r3
    c002:	d020      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c004:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c008:	4298      	cmp	r0, r3
    c00a:	d01c      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c00c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c010:	4298      	cmp	r0, r3
    c012:	d018      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c014:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c018:	4298      	cmp	r0, r3
    c01a:	d014      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c01c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c020:	4298      	cmp	r0, r3
    c022:	d010      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c024:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
    c028:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    c02c:	4290      	cmp	r0, r2
    c02e:	bf18      	it	ne
    c030:	4298      	cmpne	r0, r3
    c032:	d008      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c034:	f503 6380 	add.w	r3, r3, #1024	; 0x400
    c038:	4298      	cmp	r0, r3
    c03a:	d004      	beq.n	c046 <HAL_GPIO_DeInit+0x72>
    c03c:	f240 113f 	movw	r1, #319	; 0x13f
    c040:	4867      	ldr	r0, [pc, #412]	; (c1e0 <HAL_GPIO_DeInit+0x20c>)
    c042:	f00d fa3d 	bl	194c0 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c046:	b2ab      	uxth	r3, r5
    c048:	2b00      	cmp	r3, #0
    c04a:	d046      	beq.n	c0da <HAL_GPIO_DeInit+0x106>
    c04c:	4b65      	ldr	r3, [pc, #404]	; (c1e4 <HAL_GPIO_DeInit+0x210>)
    c04e:	402b      	ands	r3, r5
    c050:	2b00      	cmp	r3, #0
    c052:	d142      	bne.n	c0da <HAL_GPIO_DeInit+0x106>
{
    c054:	2300      	movs	r3, #0
    c056:	f8df b1a8 	ldr.w	fp, [pc, #424]	; c200 <HAL_GPIO_DeInit+0x22c>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c05a:	f8df a17c 	ldr.w	sl, [pc, #380]	; c1d8 <HAL_GPIO_DeInit+0x204>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    c05e:	f8df 91a4 	ldr.w	r9, [pc, #420]	; c204 <HAL_GPIO_DeInit+0x230>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c062:	f8cd 8004 	str.w	r8, [sp, #4]
    iocurrent = GPIO_Pin & (1UL << position) ;
    c066:	f04f 0801 	mov.w	r8, #1
    c06a:	fa08 f003 	lsl.w	r0, r8, r3
    if (iocurrent != 0x00U)
    c06e:	ea10 0105 	ands.w	r1, r0, r5
    c072:	f000 8081 	beq.w	c178 <HAL_GPIO_DeInit+0x1a4>
    c076:	f023 0703 	bic.w	r7, r3, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    c07a:	f003 0203 	and.w	r2, r3, #3
    c07e:	f04f 0c0f 	mov.w	ip, #15
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c082:	4554      	cmp	r4, sl
    c084:	445f      	add	r7, fp
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    c086:	ea4f 0282 	mov.w	r2, r2, lsl #2
      tmp = SYSCFG->EXTICR[position >> 2U];
    c08a:	f8d7 e008 	ldr.w	lr, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
    c08e:	fa0c fc02 	lsl.w	ip, ip, r2
    c092:	ea0c 0e0e 	and.w	lr, ip, lr
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c096:	d02a      	beq.n	c0ee <HAL_GPIO_DeInit+0x11a>
    c098:	9e01      	ldr	r6, [sp, #4]
    c09a:	b1de      	cbz	r6, c0d4 <HAL_GPIO_DeInit+0x100>
    c09c:	4e52      	ldr	r6, [pc, #328]	; (c1e8 <HAL_GPIO_DeInit+0x214>)
    c09e:	42b4      	cmp	r4, r6
    c0a0:	d077      	beq.n	c192 <HAL_GPIO_DeInit+0x1be>
    c0a2:	4e52      	ldr	r6, [pc, #328]	; (c1ec <HAL_GPIO_DeInit+0x218>)
    c0a4:	42b4      	cmp	r4, r6
    c0a6:	d079      	beq.n	c19c <HAL_GPIO_DeInit+0x1c8>
    c0a8:	4e51      	ldr	r6, [pc, #324]	; (c1f0 <HAL_GPIO_DeInit+0x21c>)
    c0aa:	42b4      	cmp	r4, r6
    c0ac:	d06c      	beq.n	c188 <HAL_GPIO_DeInit+0x1b4>
    c0ae:	4e51      	ldr	r6, [pc, #324]	; (c1f4 <HAL_GPIO_DeInit+0x220>)
    c0b0:	42b4      	cmp	r4, r6
    c0b2:	d07d      	beq.n	c1b0 <HAL_GPIO_DeInit+0x1dc>
    c0b4:	4e50      	ldr	r6, [pc, #320]	; (c1f8 <HAL_GPIO_DeInit+0x224>)
    c0b6:	42b4      	cmp	r4, r6
    c0b8:	d07f      	beq.n	c1ba <HAL_GPIO_DeInit+0x1e6>
    c0ba:	4e50      	ldr	r6, [pc, #320]	; (c1fc <HAL_GPIO_DeInit+0x228>)
    c0bc:	42b4      	cmp	r4, r6
    c0be:	d072      	beq.n	c1a6 <HAL_GPIO_DeInit+0x1d2>
    c0c0:	f8df 8144 	ldr.w	r8, [pc, #324]	; c208 <HAL_GPIO_DeInit+0x234>
    c0c4:	4544      	cmp	r4, r8
    c0c6:	d07d      	beq.n	c1c4 <HAL_GPIO_DeInit+0x1f0>
    c0c8:	f8df 8140 	ldr.w	r8, [pc, #320]	; c20c <HAL_GPIO_DeInit+0x238>
    c0cc:	4544      	cmp	r4, r8
    c0ce:	d07e      	beq.n	c1ce <HAL_GPIO_DeInit+0x1fa>
    c0d0:	f04f 080a 	mov.w	r8, #10
    c0d4:	fa08 f202 	lsl.w	r2, r8, r2
    c0d8:	e00a      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c0da:	f44f 71a0 	mov.w	r1, #320	; 0x140
    c0de:	4840      	ldr	r0, [pc, #256]	; (c1e0 <HAL_GPIO_DeInit+0x20c>)
    c0e0:	f00d f9ee 	bl	194c0 <assert_failed>
  while ((GPIO_Pin >> position) != 0x00U)
    c0e4:	2d00      	cmp	r5, #0
    c0e6:	d1b5      	bne.n	c054 <HAL_GPIO_DeInit+0x80>
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    }

    position++;
  }
}
    c0e8:	b003      	add	sp, #12
    c0ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c0ee:	2200      	movs	r2, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
    c0f0:	4596      	cmp	lr, r2
    c0f2:	d11d      	bne.n	c130 <HAL_GPIO_DeInit+0x15c>
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    c0f4:	f8d9 e000 	ldr.w	lr, [r9]
    c0f8:	43c9      	mvns	r1, r1
        EXTI->RTSR1 &= ~(iocurrent);
    c0fa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
    c0fe:	ea0e 0e01 	and.w	lr, lr, r1
    c102:	f8c9 e000 	str.w	lr, [r9]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
    c106:	f8d9 e004 	ldr.w	lr, [r9, #4]
    c10a:	ea01 0e0e 	and.w	lr, r1, lr
    c10e:	f8c9 e004 	str.w	lr, [r9, #4]
        EXTI->RTSR1 &= ~(iocurrent);
    c112:	f8d2 e000 	ldr.w	lr, [r2]
    c116:	ea01 0e0e 	and.w	lr, r1, lr
    c11a:	f8c2 e000 	str.w	lr, [r2]
        EXTI->FTSR1 &= ~(iocurrent);
    c11e:	f8d2 e004 	ldr.w	lr, [r2, #4]
    c122:	ea01 010e 	and.w	r1, r1, lr
    c126:	6051      	str	r1, [r2, #4]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
    c128:	68ba      	ldr	r2, [r7, #8]
    c12a:	ea22 020c 	bic.w	r2, r2, ip
    c12e:	60ba      	str	r2, [r7, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c130:	2103      	movs	r1, #3
    c132:	005a      	lsls	r2, r3, #1
    c134:	f8d4 e000 	ldr.w	lr, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c138:	f04f 0c0f 	mov.w	ip, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c13c:	fa01 f202 	lsl.w	r2, r1, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c140:	fa23 f701 	lsr.w	r7, r3, r1
    c144:	f003 0107 	and.w	r1, r3, #7
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c148:	ea4e 0e02 	orr.w	lr, lr, r2
    c14c:	eb04 0787 	add.w	r7, r4, r7, lsl #2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c150:	0089      	lsls	r1, r1, #2
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    c152:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
    c154:	f8c4 e000 	str.w	lr, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
    c158:	fa0c fc01 	lsl.w	ip, ip, r1
    c15c:	6a39      	ldr	r1, [r7, #32]
    c15e:	ea21 010c 	bic.w	r1, r1, ip
    c162:	6239      	str	r1, [r7, #32]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    c164:	68e1      	ldr	r1, [r4, #12]
    c166:	4011      	ands	r1, r2
    c168:	60e1      	str	r1, [r4, #12]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
    c16a:	6861      	ldr	r1, [r4, #4]
    c16c:	ea21 0000 	bic.w	r0, r1, r0
    c170:	6060      	str	r0, [r4, #4]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    c172:	68a1      	ldr	r1, [r4, #8]
    c174:	400a      	ands	r2, r1
    c176:	60a2      	str	r2, [r4, #8]
    position++;
    c178:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00U)
    c17a:	fa35 f203 	lsrs.w	r2, r5, r3
    c17e:	f47f af72 	bne.w	c066 <HAL_GPIO_DeInit+0x92>
}
    c182:	b003      	add	sp, #12
    c184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c188:	f04f 0804 	mov.w	r8, #4
    c18c:	fa08 f202 	lsl.w	r2, r8, r2
    c190:	e7ae      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c192:	f04f 0802 	mov.w	r8, #2
    c196:	fa08 f202 	lsl.w	r2, r8, r2
    c19a:	e7a9      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c19c:	f04f 0803 	mov.w	r8, #3
    c1a0:	fa08 f202 	lsl.w	r2, r8, r2
    c1a4:	e7a4      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1a6:	f04f 0807 	mov.w	r8, #7
    c1aa:	fa08 f202 	lsl.w	r2, r8, r2
    c1ae:	e79f      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1b0:	f04f 0805 	mov.w	r8, #5
    c1b4:	fa08 f202 	lsl.w	r2, r8, r2
    c1b8:	e79a      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1ba:	f04f 0806 	mov.w	r8, #6
    c1be:	fa08 f202 	lsl.w	r2, r8, r2
    c1c2:	e795      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1c4:	f04f 0808 	mov.w	r8, #8
    c1c8:	fa08 f202 	lsl.w	r2, r8, r2
    c1cc:	e790      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1ce:	f04f 0809 	mov.w	r8, #9
    c1d2:	fa08 f202 	lsl.w	r2, r8, r2
    c1d6:	e78b      	b.n	c0f0 <HAL_GPIO_DeInit+0x11c>
    c1d8:	58020000 	.word	0x58020000
    c1dc:	58020400 	.word	0x58020400
    c1e0:	00030084 	.word	0x00030084
    c1e4:	ffff0000 	.word	0xffff0000
    c1e8:	58020800 	.word	0x58020800
    c1ec:	58020c00 	.word	0x58020c00
    c1f0:	58021000 	.word	0x58021000
    c1f4:	58021400 	.word	0x58021400
    c1f8:	58021800 	.word	0x58021800
    c1fc:	58021c00 	.word	0x58021c00
    c200:	58000400 	.word	0x58000400
    c204:	58000080 	.word	0x58000080
    c208:	58022000 	.word	0x58022000
    c20c:	58022400 	.word	0x58022400

0000c210 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
    c210:	b538      	push	{r3, r4, r5, lr}
    c212:	4605      	mov	r5, r0
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c214:	460c      	mov	r4, r1
    c216:	b129      	cbz	r1, c224 <HAL_GPIO_ReadPin+0x14>

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
    c218:	692b      	ldr	r3, [r5, #16]
    c21a:	421c      	tst	r4, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
    c21c:	bf14      	ite	ne
    c21e:	2001      	movne	r0, #1
    c220:	2000      	moveq	r0, #0
    c222:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c224:	f240 118d 	movw	r1, #397	; 0x18d
    c228:	4801      	ldr	r0, [pc, #4]	; (c230 <HAL_GPIO_ReadPin+0x20>)
    c22a:	f00d f949 	bl	194c0 <assert_failed>
    c22e:	e7f3      	b.n	c218 <HAL_GPIO_ReadPin+0x8>
    c230:	00030084 	.word	0x00030084

0000c234 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
    c234:	b570      	push	{r4, r5, r6, lr}
    c236:	4606      	mov	r6, r0
    c238:	4615      	mov	r5, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c23a:	460c      	mov	r4, r1
    c23c:	b161      	cbz	r1, c258 <HAL_GPIO_WritePin+0x24>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
    c23e:	2d01      	cmp	r5, #1
    c240:	d803      	bhi.n	c24a <HAL_GPIO_WritePin+0x16>

  if (PinState != GPIO_PIN_RESET)
    c242:	b905      	cbnz	r5, c246 <HAL_GPIO_WritePin+0x12>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    c244:	0424      	lsls	r4, r4, #16
    c246:	61b4      	str	r4, [r6, #24]
  }
}
    c248:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN_ACTION(PinState));
    c24a:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
    c24e:	4805      	ldr	r0, [pc, #20]	; (c264 <HAL_GPIO_WritePin+0x30>)
    c250:	f00d f936 	bl	194c0 <assert_failed>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    c254:	61b4      	str	r4, [r6, #24]
}
    c256:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
    c258:	f240 11ad 	movw	r1, #429	; 0x1ad
    c25c:	4801      	ldr	r0, [pc, #4]	; (c264 <HAL_GPIO_WritePin+0x30>)
    c25e:	f00d f92f 	bl	194c0 <assert_failed>
    c262:	e7ec      	b.n	c23e <HAL_GPIO_WritePin+0xa>
    c264:	00030084 	.word	0x00030084

0000c268 <HAL_HCD_HC_Init>:
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps)
{
    c268:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
    c26c:	f890 42b8 	ldrb.w	r4, [r0, #696]	; 0x2b8
{
    c270:	b085      	sub	sp, #20
  __HAL_LOCK(hhcd);
    c272:	2c01      	cmp	r4, #1
{
    c274:	f89d c038 	ldrb.w	ip, [sp, #56]	; 0x38
    c278:	f89d e03c 	ldrb.w	lr, [sp, #60]	; 0x3c
    c27c:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
  __HAL_LOCK(hhcd);
    c280:	d029      	beq.n	c2d6 <HAL_HCD_HC_Init+0x6e>
    c282:	4605      	mov	r5, r0
  hhcd->hc[ch_num].do_ping = 0U;
    c284:	eb01 0481 	add.w	r4, r1, r1, lsl #2
  __HAL_LOCK(hhcd);
    c288:	f04f 0801 	mov.w	r8, #1
  hhcd->hc[ch_num].max_packet = mps;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;

  if ((epnum & 0x80U) == 0x80U)
    c28c:	09d0      	lsrs	r0, r2, #7
  hhcd->hc[ch_num].do_ping = 0U;
    c28e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
    c292:	f002 0a7f 	and.w	sl, r2, #127	; 0x7f
  __HAL_LOCK(hhcd);
    c296:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8
  hhcd->hc[ch_num].do_ping = 0U;
    c29a:	f04f 0800 	mov.w	r8, #0
  hhcd->hc[ch_num].dev_addr = dev_address;
    c29e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hhcd->hc[ch_num].max_packet = mps;
    c2a2:	f8a4 9040 	strh.w	r9, [r4, #64]	; 0x40
  hhcd->hc[ch_num].ch_num = ch_num;
    c2a6:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  hhcd->hc[ch_num].ep_type = ep_type;
    c2aa:	f884 e03f 	strb.w	lr, [r4, #63]	; 0x3f
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
  }

  hhcd->hc[ch_num].speed = speed;
    c2ae:	f884 c03c 	strb.w	ip, [r4, #60]	; 0x3c
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
    c2b2:	f884 a03a 	strb.w	sl, [r4, #58]	; 0x3a
    c2b6:	f884 003b 	strb.w	r0, [r4, #59]	; 0x3b
  hhcd->hc[ch_num].do_ping = 0U;
    c2ba:	f884 803d 	strb.w	r8, [r4, #61]	; 0x3d

  status =  USB_HC_Init(hhcd->Instance,
    c2be:	6828      	ldr	r0, [r5, #0]
    c2c0:	f8cd c000 	str.w	ip, [sp]
    c2c4:	e9cd e901 	strd	lr, r9, [sp, #4]
    c2c8:	f008 fb74 	bl	149b4 <USB_HC_Init>
                        epnum,
                        dev_address,
                        speed,
                        ep_type,
                        mps);
  __HAL_UNLOCK(hhcd);
    c2cc:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8

  return status;
}
    c2d0:	b005      	add	sp, #20
    c2d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(hhcd);
    c2d6:	2002      	movs	r0, #2
}
    c2d8:	b005      	add	sp, #20
    c2da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c2de:	bf00      	nop

0000c2e0 <HAL_HCD_HC_Halt>:
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  HAL_StatusTypeDef status = HAL_OK;

  __HAL_LOCK(hhcd);
    c2e0:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    c2e4:	2b01      	cmp	r3, #1
    c2e6:	d00b      	beq.n	c300 <HAL_HCD_HC_Halt+0x20>
    c2e8:	2301      	movs	r3, #1
{
    c2ea:	b510      	push	{r4, lr}
    c2ec:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
    c2ee:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    c2f0:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
    c2f4:	f008 fcb4 	bl	14c60 <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
    c2f8:	2000      	movs	r0, #0
    c2fa:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return status;
}
    c2fe:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
    c300:	2002      	movs	r0, #2
}
    c302:	4770      	bx	lr

0000c304 <HAL_HCD_Init>:
  if (hhcd == NULL)
    c304:	2800      	cmp	r0, #0
    c306:	d057      	beq.n	c3b8 <HAL_HCD_Init+0xb4>
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    c308:	4b2c      	ldr	r3, [pc, #176]	; (c3bc <HAL_HCD_Init+0xb8>)
{
    c30a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    c30e:	6804      	ldr	r4, [r0, #0]
{
    c310:	b08a      	sub	sp, #40	; 0x28
    c312:	4607      	mov	r7, r0
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    c314:	429c      	cmp	r4, r3
    c316:	d008      	beq.n	c32a <HAL_HCD_Init+0x26>
    c318:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
    c31c:	429c      	cmp	r4, r3
    c31e:	d004      	beq.n	c32a <HAL_HCD_Init+0x26>
    c320:	217a      	movs	r1, #122	; 0x7a
    c322:	4827      	ldr	r0, [pc, #156]	; (c3c0 <HAL_HCD_Init+0xbc>)
    c324:	f00d f8cc 	bl	194c0 <assert_failed>
    c328:	683c      	ldr	r4, [r7, #0]
  if (hhcd->State == HAL_HCD_STATE_RESET)
    c32a:	f897 32b9 	ldrb.w	r3, [r7, #697]	; 0x2b9
    c32e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c332:	2b00      	cmp	r3, #0
    c334:	d039      	beq.n	c3aa <HAL_HCD_Init+0xa6>
    c336:	4620      	mov	r0, r4
  hhcd->State = HAL_HCD_STATE_BUSY;
    c338:	2303      	movs	r3, #3
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c33a:	466d      	mov	r5, sp
    c33c:	f107 0804 	add.w	r8, r7, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
    c340:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
  if ((USBx->CID & (0x1U << 8)) == 0U)
    c344:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c346:	463c      	mov	r4, r7
  if ((USBx->CID & (0x1U << 8)) == 0U)
    c348:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hhcd->Init.dma_enable = 0U;
    c34c:	bf08      	it	eq
    c34e:	613b      	streq	r3, [r7, #16]
  __HAL_HCD_DISABLE(hhcd);
    c350:	f008 fa2a 	bl	147a8 <USB_DisableGlobalInt>
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c354:	f854 6b10 	ldr.w	r6, [r4], #16
    c358:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c35a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c35c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    c35e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c360:	e894 0003 	ldmia.w	r4, {r0, r1}
    c364:	e885 0003 	stmia.w	r5, {r0, r1}
    c368:	4630      	mov	r0, r6
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
    c36a:	463e      	mov	r6, r7
    c36c:	466d      	mov	r5, sp
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
    c36e:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    c372:	f008 f9a7 	bl	146c4 <USB_CoreInit>
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
    c376:	2101      	movs	r1, #1
    c378:	6838      	ldr	r0, [r7, #0]
    c37a:	f008 fa1d 	bl	147b8 <USB_SetCurrentMode>
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
    c37e:	f856 cb10 	ldr.w	ip, [r6], #16
    c382:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    c384:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c386:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    c388:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    c38a:	e894 0003 	ldmia.w	r4, {r0, r1}
    c38e:	e885 0003 	stmia.w	r5, {r0, r1}
    c392:	4660      	mov	r0, ip
    c394:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
    c398:	f008 fa26 	bl	147e8 <USB_HostInit>
  hhcd->State = HAL_HCD_STATE_READY;
    c39c:	2301      	movs	r3, #1
  return HAL_OK;
    c39e:	2000      	movs	r0, #0
  hhcd->State = HAL_HCD_STATE_READY;
    c3a0:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
}
    c3a4:	b00a      	add	sp, #40	; 0x28
    c3a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_HCD_MspInit(hhcd);
    c3aa:	4638      	mov	r0, r7
    hhcd->Lock = HAL_UNLOCKED;
    c3ac:	f887 22b8 	strb.w	r2, [r7, #696]	; 0x2b8
    HAL_HCD_MspInit(hhcd);
    c3b0:	f017 fb84 	bl	23abc <HAL_HCD_MspInit>
    c3b4:	6838      	ldr	r0, [r7, #0]
    c3b6:	e7bf      	b.n	c338 <HAL_HCD_Init+0x34>
    return HAL_ERROR;
    c3b8:	2001      	movs	r0, #1
}
    c3ba:	4770      	bx	lr
    c3bc:	40080000 	.word	0x40080000
    c3c0:	000300c0 	.word	0x000300c0

0000c3c4 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
    c3c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    c3c6:	460c      	mov	r4, r1
  hhcd->hc[ch_num].ep_is_in = direction;
    c3c8:	0089      	lsls	r1, r1, #2
{
    c3ca:	f89d c014 	ldrb.w	ip, [sp, #20]
  hhcd->hc[ch_num].ep_is_in = direction;
    c3ce:	190d      	adds	r5, r1, r4
{
    c3d0:	9f06      	ldr	r7, [sp, #24]
    c3d2:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
    c3d6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
{
    c3da:	f89d e020 	ldrb.w	lr, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
    c3de:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
  hhcd->hc[ch_num].ep_type  = ep_type;
    c3e2:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f

  if (token == 0U)
    c3e6:	f1bc 0f00 	cmp.w	ip, #0
    c3ea:	d137      	bne.n	c45c <HAL_HCD_HC_SubmitRequest+0x98>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    hhcd->hc[ch_num].do_ping = do_ping;
    c3ec:	f885 e03d 	strb.w	lr, [r5, #61]	; 0x3d
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    c3f0:	f04f 0e03 	mov.w	lr, #3
    c3f4:	190d      	adds	r5, r1, r4
    c3f6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
    c3fa:	f885 e042 	strb.w	lr, [r5, #66]	; 0x42
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
  }

  /* Manage Data Toggle */
  switch (ep_type)
    c3fe:	2b03      	cmp	r3, #3
    c400:	d815      	bhi.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
    c402:	e8df f003 	tbb	[pc, r3]
    c406:	3902      	.short	0x3902
    c408:	2e2e      	.short	0x2e2e
  {
    case EP_TYPE_CTRL:
      if ((token == 1U) && (direction == 0U)) /*send data */
    c40a:	f1bc 0f01 	cmp.w	ip, #1
    c40e:	d10e      	bne.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
    c410:	b96a      	cbnz	r2, c42e <HAL_HCD_HC_SubmitRequest+0x6a>
      {
        if (length == 0U)
        {
          /* For Status OUT stage, Length==0, Status Out PID = 1 */
          hhcd->hc[ch_num].toggle_out = 1U;
    c412:	190b      	adds	r3, r1, r4
        if (length == 0U)
    c414:	2e00      	cmp	r6, #0
    c416:	d13e      	bne.n	c496 <HAL_HCD_HC_SubmitRequest+0xd2>
          hhcd->hc[ch_num].toggle_out = 1U;
    c418:	2201      	movs	r2, #1
    c41a:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c41e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
        }
        else
        {
          /* Put the PID 1 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c422:	190b      	adds	r3, r1, r4
    c424:	2202      	movs	r2, #2
    c426:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c42a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    default:
      break;
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
    c42e:	190b      	adds	r3, r1, r4
  hhcd->hc[ch_num].urb_state = URB_IDLE;
  hhcd->hc[ch_num].xfer_count = 0U;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].state = HC_IDLE;

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c430:	2128      	movs	r1, #40	; 0x28
  hhcd->hc[ch_num].urb_state = URB_IDLE;
    c432:	2200      	movs	r2, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
    c434:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c438:	fb01 0104 	mla	r1, r1, r4, r0
  hhcd->hc[ch_num].xfer_buff = pbuff;
    c43c:	645f      	str	r7, [r3, #68]	; 0x44
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c43e:	3138      	adds	r1, #56	; 0x38
  hhcd->hc[ch_num].xfer_len  = length;
    c440:	649e      	str	r6, [r3, #72]	; 0x48
  hhcd->hc[ch_num].ch_num = ch_num;
    c442:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39
  hhcd->hc[ch_num].urb_state = URB_IDLE;
    c446:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  hhcd->hc[ch_num].xfer_count = 0U;
    c44a:	64da      	str	r2, [r3, #76]	; 0x4c
  hhcd->hc[ch_num].state = HC_IDLE;
    c44c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c450:	7c02      	ldrb	r2, [r0, #16]
    c452:	6800      	ldr	r0, [r0, #0]
}
    c454:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
    c458:	f008 bb48 	b.w	14aec <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c45c:	f04f 0e02 	mov.w	lr, #2
    c460:	e7c8      	b.n	c3f4 <HAL_HCD_HC_SubmitRequest+0x30>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    c462:	190b      	adds	r3, r1, r4
    c464:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
      if (direction == 0U)
    c468:	b96a      	cbnz	r2, c486 <HAL_HCD_HC_SubmitRequest+0xc2>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    c46a:	f893 5051 	ldrb.w	r5, [r3, #81]	; 0x51
    c46e:	b13d      	cbz	r5, c480 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c470:	2202      	movs	r2, #2
    c472:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    c476:	e7da      	b.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    c478:	190b      	adds	r3, r1, r4
    c47a:	2200      	movs	r2, #0
    c47c:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c480:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      break;
    c484:	e7d3      	b.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_in == 0U)
    c486:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
    c48a:	2a00      	cmp	r2, #0
    c48c:	d0f8      	beq.n	c480 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    c48e:	2202      	movs	r2, #2
    c490:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    c494:	e7cb      	b.n	c42e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_out == 0U)
    c496:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    c49a:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
    c49e:	2a00      	cmp	r2, #0
    c4a0:	d0ee      	beq.n	c480 <HAL_HCD_HC_SubmitRequest+0xbc>
    c4a2:	e7be      	b.n	c422 <HAL_HCD_HC_SubmitRequest+0x5e>

0000c4a4 <HAL_HCD_Start>:
  * @brief  Start the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
{
    c4a4:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hhcd);
    c4a6:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    c4aa:	2b01      	cmp	r3, #1
    c4ac:	d00e      	beq.n	c4cc <HAL_HCD_Start+0x28>
    c4ae:	4604      	mov	r4, r0
    c4b0:	2501      	movs	r5, #1
  __HAL_HCD_ENABLE(hhcd);
    c4b2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    c4b4:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
  __HAL_HCD_ENABLE(hhcd);
    c4b8:	f008 f96e 	bl	14798 <USB_EnableGlobalInt>
  (void)USB_DriveVbus(hhcd->Instance, 1U);
    c4bc:	4629      	mov	r1, r5
    c4be:	6820      	ldr	r0, [r4, #0]
    c4c0:	f008 fa42 	bl	14948 <USB_DriveVbus>
  __HAL_UNLOCK(hhcd);
    c4c4:	2000      	movs	r0, #0
    c4c6:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return HAL_OK;
}
    c4ca:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hhcd);
    c4cc:	2002      	movs	r0, #2
}
    c4ce:	bd38      	pop	{r3, r4, r5, pc}

0000c4d0 <HAL_HCD_Stop>:
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
{
  __HAL_LOCK(hhcd);
    c4d0:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
    c4d4:	2b01      	cmp	r3, #1
    c4d6:	d00b      	beq.n	c4f0 <HAL_HCD_Stop+0x20>
    c4d8:	2301      	movs	r3, #1
{
    c4da:	b510      	push	{r4, lr}
    c4dc:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
    c4de:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
    c4e0:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_StopHost(hhcd->Instance);
    c4e4:	f008 fc14 	bl	14d10 <USB_StopHost>
  __HAL_UNLOCK(hhcd);
    c4e8:	2000      	movs	r0, #0
    c4ea:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return HAL_OK;
}
    c4ee:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
    c4f0:	2002      	movs	r0, #2
}
    c4f2:	4770      	bx	lr

0000c4f4 <HAL_HCD_ResetPort>:
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
{
  return (USB_ResetPort(hhcd->Instance));
    c4f4:	6800      	ldr	r0, [r0, #0]
    c4f6:	f008 ba07 	b.w	14908 <USB_ResetPort>
    c4fa:	bf00      	nop

0000c4fc <HAL_HCD_HC_GetURBState>:
  *            URB_ERROR/
  *            URB_STALL
  */
HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
  return hhcd->hc[chnum].urb_state;
    c4fc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    c500:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
    c504:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
    c508:	4770      	bx	lr
    c50a:	bf00      	nop

0000c50c <HAL_HCD_HC_GetXferCount>:
  *         This parameter can be a value from 1 to 15
  * @retval last transfer size in byte
  */
uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
  return hhcd->hc[chnum].xfer_count;
    c50c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    c510:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
    c514:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
    c516:	4770      	bx	lr

0000c518 <HAL_HCD_GetCurrentFrame>:
  * @param  hhcd HCD handle
  * @retval Current Host frame number
  */
uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
{
  return (USB_GetCurrentFrame(hhcd->Instance));
    c518:	6800      	ldr	r0, [r0, #0]
    c51a:	f008 ba45 	b.w	149a8 <USB_GetCurrentFrame>
    c51e:	bf00      	nop

0000c520 <HAL_HCD_GetCurrentSpeed>:
  * @param  hhcd HCD handle
  * @retval Enumeration speed
  */
uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
{
  return (USB_GetHostSpeed(hhcd->Instance));
    c520:	6800      	ldr	r0, [r0, #0]
    c522:	f008 ba35 	b.w	14990 <USB_GetHostSpeed>
    c526:	bf00      	nop

0000c528 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
    c528:	b570      	push	{r4, r5, r6, lr}
    c52a:	4604      	mov	r4, r0
    c52c:	460d      	mov	r5, r1
    c52e:	4616      	mov	r6, r2
    c530:	1c6b      	adds	r3, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    c532:	6822      	ldr	r2, [r4, #0]
    c534:	d12e      	bne.n	c594 <I2C_WaitOnTXISFlagUntilTimeout+0x6c>
    c536:	6993      	ldr	r3, [r2, #24]
    c538:	0798      	lsls	r0, r3, #30
    c53a:	d42e      	bmi.n	c59a <I2C_WaitOnTXISFlagUntilTimeout+0x72>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    c53c:	6993      	ldr	r3, [r2, #24]
    c53e:	06d9      	lsls	r1, r3, #27
    c540:	d5f9      	bpl.n	c536 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c542:	6993      	ldr	r3, [r2, #24]
    c544:	069d      	lsls	r5, r3, #26
    c546:	d5fc      	bpl.n	c542 <I2C_WaitOnTXISFlagUntilTimeout+0x1a>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c548:	2310      	movs	r3, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c54a:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c54c:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c54e:	6823      	ldr	r3, [r4, #0]
    c550:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    c552:	6823      	ldr	r3, [r4, #0]
    c554:	699a      	ldr	r2, [r3, #24]
    c556:	0791      	lsls	r1, r2, #30
    c558:	d502      	bpl.n	c560 <I2C_WaitOnTXISFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
    c55a:	2200      	movs	r2, #0
    c55c:	629a      	str	r2, [r3, #40]	; 0x28
    c55e:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    c560:	699a      	ldr	r2, [r3, #24]
    c562:	07d2      	lsls	r2, r2, #31
    c564:	d404      	bmi.n	c570 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    c566:	699a      	ldr	r2, [r3, #24]
    c568:	f042 0201 	orr.w	r2, r2, #1
    c56c:	619a      	str	r2, [r3, #24]
    c56e:	6823      	ldr	r3, [r4, #0]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
    c570:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c572:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
    c574:	4e1b      	ldr	r6, [pc, #108]	; (c5e4 <I2C_WaitOnTXISFlagUntilTimeout+0xbc>)
    hi2c->State = HAL_I2C_STATE_READY;
    c576:	2520      	movs	r5, #32
      return HAL_ERROR;
    c578:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
    c57a:	4032      	ands	r2, r6
    c57c:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c57e:	6c63      	ldr	r3, [r4, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    c580:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c584:	f043 0304 	orr.w	r3, r3, #4
    c588:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    c58a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c58e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
    c592:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
    c594:	6993      	ldr	r3, [r2, #24]
    c596:	079b      	lsls	r3, r3, #30
    c598:	d501      	bpl.n	c59e <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  return HAL_OK;
    c59a:	2000      	movs	r0, #0
}
    c59c:	bd70      	pop	{r4, r5, r6, pc}
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    c59e:	6993      	ldr	r3, [r2, #24]
    c5a0:	06db      	lsls	r3, r3, #27
    c5a2:	d407      	bmi.n	c5b4 <I2C_WaitOnTXISFlagUntilTimeout+0x8c>
    c5a4:	e00a      	b.n	c5bc <I2C_WaitOnTXISFlagUntilTimeout+0x94>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c5a6:	f7fb ff25 	bl	83f4 <HAL_GetTick>
    c5aa:	1b80      	subs	r0, r0, r6
    c5ac:	4285      	cmp	r5, r0
    c5ae:	d30c      	bcc.n	c5ca <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
    c5b0:	b15d      	cbz	r5, c5ca <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
    c5b2:	6822      	ldr	r2, [r4, #0]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c5b4:	6993      	ldr	r3, [r2, #24]
    c5b6:	0698      	lsls	r0, r3, #26
    c5b8:	d5f5      	bpl.n	c5a6 <I2C_WaitOnTXISFlagUntilTimeout+0x7e>
    c5ba:	e7c5      	b.n	c548 <I2C_WaitOnTXISFlagUntilTimeout+0x20>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c5bc:	f7fb ff1a 	bl	83f4 <HAL_GetTick>
    c5c0:	1b80      	subs	r0, r0, r6
    c5c2:	42a8      	cmp	r0, r5
    c5c4:	d801      	bhi.n	c5ca <I2C_WaitOnTXISFlagUntilTimeout+0xa2>
    c5c6:	2d00      	cmp	r5, #0
    c5c8:	d1b2      	bne.n	c530 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c5ca:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c5cc:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c5ce:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
    c5d0:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c5d2:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    c5d4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c5d8:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c5da:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c5de:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    c5e2:	bd70      	pop	{r4, r5, r6, pc}
    c5e4:	fe00e800 	.word	0xfe00e800

0000c5e8 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
    c5e8:	b570      	push	{r4, r5, r6, lr}
    c5ea:	4604      	mov	r4, r0
    c5ec:	460d      	mov	r5, r1
    c5ee:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c5f0:	6822      	ldr	r2, [r4, #0]
    c5f2:	6993      	ldr	r3, [r2, #24]
    c5f4:	069b      	lsls	r3, r3, #26
    c5f6:	d44d      	bmi.n	c694 <I2C_WaitOnSTOPFlagUntilTimeout+0xac>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
    c5f8:	6993      	ldr	r3, [r2, #24]
    c5fa:	06d9      	lsls	r1, r3, #27
    c5fc:	d52a      	bpl.n	c654 <I2C_WaitOnSTOPFlagUntilTimeout+0x6c>
    c5fe:	1c6b      	adds	r3, r5, #1
    c600:	d13c      	bne.n	c67c <I2C_WaitOnSTOPFlagUntilTimeout+0x94>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c602:	6993      	ldr	r3, [r2, #24]
    c604:	069d      	lsls	r5, r3, #26
    c606:	d5fc      	bpl.n	c602 <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c608:	2310      	movs	r3, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c60a:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    c60c:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    c60e:	6823      	ldr	r3, [r4, #0]
    c610:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    c612:	6823      	ldr	r3, [r4, #0]
    c614:	699a      	ldr	r2, [r3, #24]
    c616:	0791      	lsls	r1, r2, #30
    c618:	d502      	bpl.n	c620 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
    c61a:	2200      	movs	r2, #0
    c61c:	629a      	str	r2, [r3, #40]	; 0x28
    c61e:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    c620:	699a      	ldr	r2, [r3, #24]
    c622:	07d2      	lsls	r2, r2, #31
    c624:	d404      	bmi.n	c630 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    c626:	699a      	ldr	r2, [r3, #24]
    c628:	f042 0201 	orr.w	r2, r2, #1
    c62c:	619a      	str	r2, [r3, #24]
    c62e:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
    c630:	685a      	ldr	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c632:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
    c634:	4e18      	ldr	r6, [pc, #96]	; (c698 <I2C_WaitOnSTOPFlagUntilTimeout+0xb0>)
    hi2c->State = HAL_I2C_STATE_READY;
    c636:	2520      	movs	r5, #32
      return HAL_ERROR;
    c638:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
    c63a:	4032      	ands	r2, r6
    c63c:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c63e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
    c640:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    c644:	f043 0304 	orr.w	r3, r3, #4
    c648:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
    c64a:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
    c64e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
    c652:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c654:	f7fb fece 	bl	83f4 <HAL_GetTick>
    c658:	1b80      	subs	r0, r0, r6
    c65a:	42a8      	cmp	r0, r5
    c65c:	d801      	bhi.n	c662 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    c65e:	2d00      	cmp	r5, #0
    c660:	d1c6      	bne.n	c5f0 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c662:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c664:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c666:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
    c668:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c66a:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    c66c:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    c670:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    c672:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    c676:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    c67a:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
    c67c:	6993      	ldr	r3, [r2, #24]
    c67e:	0698      	lsls	r0, r3, #26
    c680:	d4c2      	bmi.n	c608 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c682:	f7fb feb7 	bl	83f4 <HAL_GetTick>
    c686:	1b80      	subs	r0, r0, r6
    c688:	4285      	cmp	r5, r0
    c68a:	d3ea      	bcc.n	c662 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    c68c:	2d00      	cmp	r5, #0
    c68e:	d0e8      	beq.n	c662 <I2C_WaitOnSTOPFlagUntilTimeout+0x7a>
    c690:	6822      	ldr	r2, [r4, #0]
    c692:	e7b4      	b.n	c5fe <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
    c694:	2000      	movs	r0, #0
}
    c696:	bd70      	pop	{r4, r5, r6, pc}
    c698:	fe00e800 	.word	0xfe00e800

0000c69c <HAL_I2C_Init>:
  if (hi2c == NULL)
    c69c:	2800      	cmp	r0, #0
    c69e:	f000 80d2 	beq.w	c846 <HAL_I2C_Init+0x1aa>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c6a2:	496f      	ldr	r1, [pc, #444]	; (c860 <HAL_I2C_Init+0x1c4>)
{
    c6a4:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c6a6:	4b6f      	ldr	r3, [pc, #444]	; (c864 <HAL_I2C_Init+0x1c8>)
    c6a8:	4604      	mov	r4, r0
    c6aa:	6802      	ldr	r2, [r0, #0]
    c6ac:	486e      	ldr	r0, [pc, #440]	; (c868 <HAL_I2C_Init+0x1cc>)
    c6ae:	429a      	cmp	r2, r3
    c6b0:	bf18      	it	ne
    c6b2:	4282      	cmpne	r2, r0
    c6b4:	bf14      	ite	ne
    c6b6:	2301      	movne	r3, #1
    c6b8:	2300      	moveq	r3, #0
    c6ba:	428a      	cmp	r2, r1
    c6bc:	bf0c      	ite	eq
    c6be:	2300      	moveq	r3, #0
    c6c0:	f003 0301 	andne.w	r3, r3, #1
    c6c4:	b11b      	cbz	r3, c6ce <HAL_I2C_Init+0x32>
    c6c6:	4b69      	ldr	r3, [pc, #420]	; (c86c <HAL_I2C_Init+0x1d0>)
    c6c8:	429a      	cmp	r2, r3
    c6ca:	f040 80be 	bne.w	c84a <HAL_I2C_Init+0x1ae>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    c6ce:	68a3      	ldr	r3, [r4, #8]
    c6d0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    c6d4:	d271      	bcs.n	c7ba <HAL_I2C_Init+0x11e>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    c6d6:	68e3      	ldr	r3, [r4, #12]
    c6d8:	3b01      	subs	r3, #1
    c6da:	2b01      	cmp	r3, #1
    c6dc:	d85e      	bhi.n	c79c <HAL_I2C_Init+0x100>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    c6de:	6923      	ldr	r3, [r4, #16]
    c6e0:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    c6e4:	d17c      	bne.n	c7e0 <HAL_I2C_Init+0x144>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    c6e6:	6963      	ldr	r3, [r4, #20]
    c6e8:	2bff      	cmp	r3, #255	; 0xff
    c6ea:	d870      	bhi.n	c7ce <HAL_I2C_Init+0x132>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    c6ec:	69a3      	ldr	r3, [r4, #24]
    c6ee:	2b07      	cmp	r3, #7
    c6f0:	f200 809e 	bhi.w	c830 <HAL_I2C_Init+0x194>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    c6f4:	69e3      	ldr	r3, [r4, #28]
    c6f6:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
    c6fa:	f040 808e 	bne.w	c81a <HAL_I2C_Init+0x17e>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    c6fe:	6a23      	ldr	r3, [r4, #32]
    c700:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
    c704:	d17c      	bne.n	c800 <HAL_I2C_Init+0x164>
  if (hi2c->State == HAL_I2C_STATE_RESET)
    c706:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    c70a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c70e:	2b00      	cmp	r3, #0
    c710:	d070      	beq.n	c7f4 <HAL_I2C_Init+0x158>
  __HAL_I2C_DISABLE(hi2c);
    c712:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
    c714:	2324      	movs	r3, #36	; 0x24
    c716:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
    c71a:	6813      	ldr	r3, [r2, #0]
    c71c:	f023 0301 	bic.w	r3, r3, #1
    c720:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
    c722:	e9d4 2300 	ldrd	r2, r3, [r4]
    c726:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    c72a:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
    c72c:	6822      	ldr	r2, [r4, #0]
    c72e:	6893      	ldr	r3, [r2, #8]
    c730:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    c734:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    c736:	68e3      	ldr	r3, [r4, #12]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    c738:	6822      	ldr	r2, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
    c73a:	2b01      	cmp	r3, #1
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    c73c:	68a3      	ldr	r3, [r4, #8]
    c73e:	bf0c      	ite	eq
    c740:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
    c744:	f443 4304 	orrne.w	r3, r3, #33792	; 0x8400
    c748:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    c74a:	68e3      	ldr	r3, [r4, #12]
    c74c:	6825      	ldr	r5, [r4, #0]
    c74e:	2b02      	cmp	r3, #2
    c750:	d02e      	beq.n	c7b0 <HAL_I2C_Init+0x114>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c752:	6868      	ldr	r0, [r5, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    c754:	2200      	movs	r2, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c756:	4b46      	ldr	r3, [pc, #280]	; (c870 <HAL_I2C_Init+0x1d4>)
  hi2c->State = HAL_I2C_STATE_READY;
    c758:	2120      	movs	r1, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c75a:	4303      	orrs	r3, r0
  return HAL_OK;
    c75c:	4610      	mov	r0, r2
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
    c75e:	606b      	str	r3, [r5, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
    c760:	6825      	ldr	r5, [r4, #0]
    c762:	68eb      	ldr	r3, [r5, #12]
    c764:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    c768:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
    c76a:	e9d4 3504 	ldrd	r3, r5, [r4, #16]
    c76e:	432b      	orrs	r3, r5
    c770:	69a5      	ldr	r5, [r4, #24]
    c772:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    c776:	6825      	ldr	r5, [r4, #0]
    c778:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
    c77a:	e9d4 3507 	ldrd	r3, r5, [r4, #28]
    c77e:	432b      	orrs	r3, r5
    c780:	6825      	ldr	r5, [r4, #0]
    c782:	602b      	str	r3, [r5, #0]
  __HAL_I2C_ENABLE(hi2c);
    c784:	6825      	ldr	r5, [r4, #0]
    c786:	682b      	ldr	r3, [r5, #0]
    c788:	f043 0301 	orr.w	r3, r3, #1
    c78c:	602b      	str	r3, [r5, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    c78e:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
    c790:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
    c794:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
    c796:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    c79a:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    c79c:	f240 11e3 	movw	r1, #483	; 0x1e3
    c7a0:	4834      	ldr	r0, [pc, #208]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7a2:	f00c fe8d 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    c7a6:	6923      	ldr	r3, [r4, #16]
    c7a8:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    c7ac:	d09b      	beq.n	c6e6 <HAL_I2C_Init+0x4a>
    c7ae:	e017      	b.n	c7e0 <HAL_I2C_Init+0x144>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
    c7b0:	f44f 6300 	mov.w	r3, #2048	; 0x800
    c7b4:	606b      	str	r3, [r5, #4]
    c7b6:	6825      	ldr	r5, [r4, #0]
    c7b8:	e7cb      	b.n	c752 <HAL_I2C_Init+0xb6>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    c7ba:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
    c7be:	482d      	ldr	r0, [pc, #180]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7c0:	f00c fe7e 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    c7c4:	68e3      	ldr	r3, [r4, #12]
    c7c6:	3b01      	subs	r3, #1
    c7c8:	2b01      	cmp	r3, #1
    c7ca:	d988      	bls.n	c6de <HAL_I2C_Init+0x42>
    c7cc:	e7e6      	b.n	c79c <HAL_I2C_Init+0x100>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    c7ce:	f240 11e5 	movw	r1, #485	; 0x1e5
    c7d2:	4828      	ldr	r0, [pc, #160]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7d4:	f00c fe74 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    c7d8:	69a3      	ldr	r3, [r4, #24]
    c7da:	2b07      	cmp	r3, #7
    c7dc:	d98a      	bls.n	c6f4 <HAL_I2C_Init+0x58>
    c7de:	e027      	b.n	c830 <HAL_I2C_Init+0x194>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    c7e0:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
    c7e4:	4823      	ldr	r0, [pc, #140]	; (c874 <HAL_I2C_Init+0x1d8>)
    c7e6:	f00c fe6b 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    c7ea:	6963      	ldr	r3, [r4, #20]
    c7ec:	2bff      	cmp	r3, #255	; 0xff
    c7ee:	f67f af7d 	bls.w	c6ec <HAL_I2C_Init+0x50>
    c7f2:	e7ec      	b.n	c7ce <HAL_I2C_Init+0x132>
    hi2c->Lock = HAL_UNLOCKED;
    c7f4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
    c7f8:	4620      	mov	r0, r4
    c7fa:	f00c fbaf 	bl	18f5c <HAL_I2C_MspInit>
    c7fe:	e788      	b.n	c712 <HAL_I2C_Init+0x76>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    c800:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
    c804:	481b      	ldr	r0, [pc, #108]	; (c874 <HAL_I2C_Init+0x1d8>)
    c806:	f00c fe5b 	bl	194c0 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
    c80a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    c80e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c812:	2b00      	cmp	r3, #0
    c814:	f47f af7d 	bne.w	c712 <HAL_I2C_Init+0x76>
    c818:	e7ec      	b.n	c7f4 <HAL_I2C_Init+0x158>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    c81a:	f240 11e7 	movw	r1, #487	; 0x1e7
    c81e:	4815      	ldr	r0, [pc, #84]	; (c874 <HAL_I2C_Init+0x1d8>)
    c820:	f00c fe4e 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    c824:	6a23      	ldr	r3, [r4, #32]
    c826:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
    c82a:	f43f af6c 	beq.w	c706 <HAL_I2C_Init+0x6a>
    c82e:	e7e7      	b.n	c800 <HAL_I2C_Init+0x164>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    c830:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
    c834:	480f      	ldr	r0, [pc, #60]	; (c874 <HAL_I2C_Init+0x1d8>)
    c836:	f00c fe43 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    c83a:	69e3      	ldr	r3, [r4, #28]
    c83c:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
    c840:	f43f af5d 	beq.w	c6fe <HAL_I2C_Init+0x62>
    c844:	e7e9      	b.n	c81a <HAL_I2C_Init+0x17e>
    return HAL_ERROR;
    c846:	2001      	movs	r0, #1
}
    c848:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c84a:	f240 11e1 	movw	r1, #481	; 0x1e1
    c84e:	4809      	ldr	r0, [pc, #36]	; (c874 <HAL_I2C_Init+0x1d8>)
    c850:	f00c fe36 	bl	194c0 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    c854:	68a3      	ldr	r3, [r4, #8]
    c856:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    c85a:	f4ff af3c 	bcc.w	c6d6 <HAL_I2C_Init+0x3a>
    c85e:	e7ac      	b.n	c7ba <HAL_I2C_Init+0x11e>
    c860:	40005c00 	.word	0x40005c00
    c864:	40005400 	.word	0x40005400
    c868:	40005800 	.word	0x40005800
    c86c:	58001c00 	.word	0x58001c00
    c870:	02008000 	.word	0x02008000
    c874:	000300f8 	.word	0x000300f8

0000c878 <HAL_I2C_Master_Transmit>:
{
    c878:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
    c87c:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
    c880:	9e08      	ldr	r6, [sp, #32]
  if (hi2c->State == HAL_I2C_STATE_READY)
    c882:	2c20      	cmp	r4, #32
    c884:	f040 80a1 	bne.w	c9ca <HAL_I2C_Master_Transmit+0x152>
    __HAL_LOCK(hi2c);
    c888:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
    c88c:	2c01      	cmp	r4, #1
    c88e:	f000 809c 	beq.w	c9ca <HAL_I2C_Master_Transmit+0x152>
    c892:	4698      	mov	r8, r3
    c894:	2301      	movs	r3, #1
    c896:	4691      	mov	r9, r2
    c898:	460f      	mov	r7, r1
    c89a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    c89e:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
    c8a0:	f7fb fda8 	bl	83f4 <HAL_GetTick>
    c8a4:	4605      	mov	r5, r0
    c8a6:	e005      	b.n	c8b4 <HAL_I2C_Master_Transmit+0x3c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c8a8:	f7fb fda4 	bl	83f4 <HAL_GetTick>
    c8ac:	1b40      	subs	r0, r0, r5
    c8ae:	2819      	cmp	r0, #25
    c8b0:	f200 80a6 	bhi.w	ca00 <HAL_I2C_Master_Transmit+0x188>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    c8b4:	6823      	ldr	r3, [r4, #0]
    c8b6:	6998      	ldr	r0, [r3, #24]
    c8b8:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
    c8bc:	d1f4      	bne.n	c8a8 <HAL_I2C_Master_Transmit+0x30>
    c8be:	4a78      	ldr	r2, [pc, #480]	; (caa0 <HAL_I2C_Master_Transmit+0x228>)
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
    c8c0:	f04f 0c21 	mov.w	ip, #33	; 0x21
    c8c4:	4977      	ldr	r1, [pc, #476]	; (caa4 <HAL_I2C_Master_Transmit+0x22c>)
    c8c6:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    c8ca:	4293      	cmp	r3, r2
    c8cc:	bf18      	it	ne
    c8ce:	428b      	cmpne	r3, r1
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    c8d0:	f04f 0110 	mov.w	r1, #16
    c8d4:	f8df c1dc 	ldr.w	ip, [pc, #476]	; cab4 <HAL_I2C_Master_Transmit+0x23c>
    c8d8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    c8dc:	bf14      	ite	ne
    c8de:	2201      	movne	r2, #1
    c8e0:	2200      	moveq	r2, #0
    c8e2:	4971      	ldr	r1, [pc, #452]	; (caa8 <HAL_I2C_Master_Transmit+0x230>)
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    c8e4:	6460      	str	r0, [r4, #68]	; 0x44
    c8e6:	428b      	cmp	r3, r1
    c8e8:	bf0c      	ite	eq
    c8ea:	2200      	moveq	r2, #0
    c8ec:	f002 0201 	andne.w	r2, r2, #1
    hi2c->XferCount = Size;
    c8f0:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c8f4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    c8f6:	4563      	cmp	r3, ip
    c8f8:	bf0c      	ite	eq
    c8fa:	2200      	moveq	r2, #0
    c8fc:	f002 0201 	andne.w	r2, r2, #1
    hi2c->pBuffPtr  = pData;
    c900:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c904:	29ff      	cmp	r1, #255	; 0xff
    hi2c->XferISR   = NULL;
    c906:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c908:	d862      	bhi.n	c9d0 <HAL_I2C_Master_Transmit+0x158>
      hi2c->XferSize = hi2c->XferCount;
    c90a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    c90c:	b289      	uxth	r1, r1
    c90e:	8521      	strh	r1, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    c910:	fa5f f881 	uxtb.w	r8, r1
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c914:	2a00      	cmp	r2, #0
    c916:	f040 80b5 	bne.w	ca84 <HAL_I2C_Master_Transmit+0x20c>
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    c91a:	f3c7 0709 	ubfx	r7, r7, #0, #10
    c91e:	4a63      	ldr	r2, [pc, #396]	; (caac <HAL_I2C_Master_Transmit+0x234>)
    c920:	6859      	ldr	r1, [r3, #4]
    c922:	433a      	orrs	r2, r7
    c924:	4862      	ldr	r0, [pc, #392]	; (cab0 <HAL_I2C_Master_Transmit+0x238>)
    c926:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
    c92a:	4001      	ands	r1, r0
    c92c:	430a      	orrs	r2, r1
    c92e:	605a      	str	r2, [r3, #4]
    c930:	f8df 8194 	ldr.w	r8, [pc, #404]	; cac8 <HAL_I2C_Master_Transmit+0x250>
    c934:	f8df 916c 	ldr.w	r9, [pc, #364]	; caa4 <HAL_I2C_Master_Transmit+0x22c>
    c938:	ea47 0808 	orr.w	r8, r7, r8
    while (hi2c->XferCount > 0U)
    c93c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    c93e:	462a      	mov	r2, r5
    c940:	4631      	mov	r1, r6
    c942:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
    c944:	b29b      	uxth	r3, r3
    c946:	2b00      	cmp	r3, #0
    c948:	d07b      	beq.n	ca42 <HAL_I2C_Master_Transmit+0x1ca>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    c94a:	f7ff fded 	bl	c528 <I2C_WaitOnTXISFlagUntilTimeout>
    c94e:	2800      	cmp	r0, #0
    c950:	d174      	bne.n	ca3c <HAL_I2C_Master_Transmit+0x1c4>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    c952:	6a62      	ldr	r2, [r4, #36]	; 0x24
    c954:	6823      	ldr	r3, [r4, #0]
    c956:	7812      	ldrb	r2, [r2, #0]
    c958:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    c95a:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    c95c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
    c95e:	3901      	subs	r1, #1
      hi2c->pBuffPtr++;
    c960:	6a62      	ldr	r2, [r4, #36]	; 0x24
      hi2c->XferSize--;
    c962:	3b01      	subs	r3, #1
      hi2c->XferCount--;
    c964:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
    c966:	3201      	adds	r2, #1
      hi2c->XferSize--;
    c968:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
    c96a:	8561      	strh	r1, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    c96c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    c96e:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    c970:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
    c972:	6262      	str	r2, [r4, #36]	; 0x24
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    c974:	2b00      	cmp	r3, #0
    c976:	d1e1      	bne.n	c93c <HAL_I2C_Master_Transmit+0xc4>
    c978:	2900      	cmp	r1, #0
    c97a:	d0df      	beq.n	c93c <HAL_I2C_Master_Transmit+0xc4>
    c97c:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    c97e:	6822      	ldr	r2, [r4, #0]
    c980:	d134      	bne.n	c9ec <HAL_I2C_Master_Transmit+0x174>
    c982:	6993      	ldr	r3, [r2, #24]
    c984:	0619      	lsls	r1, r3, #24
    c986:	d5fc      	bpl.n	c982 <HAL_I2C_Master_Transmit+0x10a>
    c988:	4b4a      	ldr	r3, [pc, #296]	; (cab4 <HAL_I2C_Master_Transmit+0x23c>)
    c98a:	4947      	ldr	r1, [pc, #284]	; (caa8 <HAL_I2C_Master_Transmit+0x230>)
    c98c:	454a      	cmp	r2, r9
    c98e:	bf18      	it	ne
    c990:	429a      	cmpne	r2, r3
    c992:	4843      	ldr	r0, [pc, #268]	; (caa0 <HAL_I2C_Master_Transmit+0x228>)
    c994:	bf14      	ite	ne
    c996:	2301      	movne	r3, #1
    c998:	2300      	moveq	r3, #0
    c99a:	428a      	cmp	r2, r1
    c99c:	bf0c      	ite	eq
    c99e:	2300      	moveq	r3, #0
    c9a0:	f003 0301 	andne.w	r3, r3, #1
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
    c9a4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    c9a6:	4282      	cmp	r2, r0
    c9a8:	bf0c      	ite	eq
    c9aa:	2300      	moveq	r3, #0
    c9ac:	f003 0301 	andne.w	r3, r3, #1
    c9b0:	29ff      	cmp	r1, #255	; 0xff
    c9b2:	d933      	bls.n	ca1c <HAL_I2C_Master_Transmit+0x1a4>
          hi2c->XferSize = MAX_NBYTE_SIZE;
    c9b4:	21ff      	movs	r1, #255	; 0xff
    c9b6:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c9b8:	2b00      	cmp	r3, #0
    c9ba:	d155      	bne.n	ca68 <HAL_I2C_Master_Transmit+0x1f0>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    c9bc:	6853      	ldr	r3, [r2, #4]
    c9be:	493e      	ldr	r1, [pc, #248]	; (cab8 <HAL_I2C_Master_Transmit+0x240>)
    c9c0:	400b      	ands	r3, r1
    c9c2:	ea43 0308 	orr.w	r3, r3, r8
    c9c6:	6053      	str	r3, [r2, #4]
    c9c8:	e7b8      	b.n	c93c <HAL_I2C_Master_Transmit+0xc4>
    return HAL_BUSY;
    c9ca:	2002      	movs	r0, #2
}
    c9cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
    c9d0:	21ff      	movs	r1, #255	; 0xff
    c9d2:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    c9d4:	2a00      	cmp	r2, #0
    c9d6:	d15c      	bne.n	ca92 <HAL_I2C_Master_Transmit+0x21a>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    c9d8:	685a      	ldr	r2, [r3, #4]
    c9da:	f3c7 0709 	ubfx	r7, r7, #0, #10
    c9de:	4937      	ldr	r1, [pc, #220]	; (cabc <HAL_I2C_Master_Transmit+0x244>)
    c9e0:	4833      	ldr	r0, [pc, #204]	; (cab0 <HAL_I2C_Master_Transmit+0x238>)
    c9e2:	4339      	orrs	r1, r7
    c9e4:	4002      	ands	r2, r0
    c9e6:	430a      	orrs	r2, r1
    c9e8:	605a      	str	r2, [r3, #4]
    c9ea:	e7a1      	b.n	c930 <HAL_I2C_Master_Transmit+0xb8>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
    c9ec:	6993      	ldr	r3, [r2, #24]
    c9ee:	061b      	lsls	r3, r3, #24
    c9f0:	d4ca      	bmi.n	c988 <HAL_I2C_Master_Transmit+0x110>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    c9f2:	f7fb fcff 	bl	83f4 <HAL_GetTick>
    c9f6:	1b40      	subs	r0, r0, r5
    c9f8:	4286      	cmp	r6, r0
    c9fa:	d301      	bcc.n	ca00 <HAL_I2C_Master_Transmit+0x188>
    c9fc:	2e00      	cmp	r6, #0
    c9fe:	d1bd      	bne.n	c97c <HAL_I2C_Master_Transmit+0x104>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    ca00:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    ca02:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
    ca04:	2200      	movs	r2, #0
          return HAL_ERROR;
    ca06:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    ca08:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
    ca0a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
    ca0e:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
    ca10:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
    ca14:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
    ca18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          hi2c->XferSize = hi2c->XferCount;
    ca1c:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    ca1e:	b289      	uxth	r1, r1
    ca20:	8521      	strh	r1, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
    ca22:	fa5f fa81 	uxtb.w	sl, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ca26:	bb33      	cbnz	r3, ca76 <HAL_I2C_Master_Transmit+0x1fe>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    ca28:	6851      	ldr	r1, [r2, #4]
    ca2a:	ea47 430a 	orr.w	r3, r7, sl, lsl #16
    ca2e:	4822      	ldr	r0, [pc, #136]	; (cab8 <HAL_I2C_Master_Transmit+0x240>)
    ca30:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    ca34:	4001      	ands	r1, r0
    ca36:	430b      	orrs	r3, r1
    ca38:	6053      	str	r3, [r2, #4]
    ca3a:	e77f      	b.n	c93c <HAL_I2C_Master_Transmit+0xc4>
        return HAL_ERROR;
    ca3c:	2001      	movs	r0, #1
}
    ca3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    ca42:	f7ff fdd1 	bl	c5e8 <I2C_WaitOnSTOPFlagUntilTimeout>
    ca46:	2800      	cmp	r0, #0
    ca48:	d1f8      	bne.n	ca3c <HAL_I2C_Master_Transmit+0x1c4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    ca4a:	6823      	ldr	r3, [r4, #0]
    ca4c:	2220      	movs	r2, #32
    I2C_RESET_CR2(hi2c);
    ca4e:	4d1c      	ldr	r5, [pc, #112]	; (cac0 <HAL_I2C_Master_Transmit+0x248>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    ca50:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
    ca52:	6821      	ldr	r1, [r4, #0]
    ca54:	684b      	ldr	r3, [r1, #4]
    ca56:	402b      	ands	r3, r5
    ca58:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
    ca5a:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    ca5e:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
    ca62:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
    ca66:	e7b1      	b.n	c9cc <HAL_I2C_Master_Transmit+0x154>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ca68:	f641 1131 	movw	r1, #6449	; 0x1931
    ca6c:	4815      	ldr	r0, [pc, #84]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca6e:	f00c fd27 	bl	194c0 <assert_failed>
    ca72:	6822      	ldr	r2, [r4, #0]
    ca74:	e7a2      	b.n	c9bc <HAL_I2C_Master_Transmit+0x144>
    ca76:	f641 1131 	movw	r1, #6449	; 0x1931
    ca7a:	4812      	ldr	r0, [pc, #72]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca7c:	f00c fd20 	bl	194c0 <assert_failed>
    ca80:	6822      	ldr	r2, [r4, #0]
    ca82:	e7d1      	b.n	ca28 <HAL_I2C_Master_Transmit+0x1b0>
    ca84:	f641 1131 	movw	r1, #6449	; 0x1931
    ca88:	480e      	ldr	r0, [pc, #56]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca8a:	f00c fd19 	bl	194c0 <assert_failed>
    ca8e:	6823      	ldr	r3, [r4, #0]
    ca90:	e743      	b.n	c91a <HAL_I2C_Master_Transmit+0xa2>
    ca92:	f641 1131 	movw	r1, #6449	; 0x1931
    ca96:	480b      	ldr	r0, [pc, #44]	; (cac4 <HAL_I2C_Master_Transmit+0x24c>)
    ca98:	f00c fd12 	bl	194c0 <assert_failed>
    ca9c:	6823      	ldr	r3, [r4, #0]
    ca9e:	e79b      	b.n	c9d8 <HAL_I2C_Master_Transmit+0x160>
    caa0:	40005c00 	.word	0x40005c00
    caa4:	40005400 	.word	0x40005400
    caa8:	40005800 	.word	0x40005800
    caac:	82002000 	.word	0x82002000
    cab0:	fc009800 	.word	0xfc009800
    cab4:	58001c00 	.word	0x58001c00
    cab8:	fc009c00 	.word	0xfc009c00
    cabc:	81ff2000 	.word	0x81ff2000
    cac0:	fe00e800 	.word	0xfe00e800
    cac4:	000300f8 	.word	0x000300f8
    cac8:	01ff0000 	.word	0x01ff0000

0000cacc <HAL_I2C_Master_Transmit_DMA>:
{
    cacc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
    cad0:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
    cad4:	2c20      	cmp	r4, #32
    cad6:	d148      	bne.n	cb6a <HAL_I2C_Master_Transmit_DMA+0x9e>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
    cad8:	6807      	ldr	r7, [r0, #0]
    cada:	69bd      	ldr	r5, [r7, #24]
    cadc:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
    cae0:	d143      	bne.n	cb6a <HAL_I2C_Master_Transmit_DMA+0x9e>
    __HAL_LOCK(hi2c);
    cae2:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
    cae6:	2c01      	cmp	r4, #1
    cae8:	d03f      	beq.n	cb6a <HAL_I2C_Master_Transmit_DMA+0x9e>
    caea:	4604      	mov	r4, r0
    caec:	460e      	mov	r6, r1
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
    caee:	f04f 0c21 	mov.w	ip, #33	; 0x21
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
    caf2:	2110      	movs	r1, #16
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    caf4:	4868      	ldr	r0, [pc, #416]	; (cc98 <HAL_I2C_Master_Transmit_DMA+0x1cc>)
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
    caf6:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
    cafa:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    __HAL_LOCK(hi2c);
    cafe:	2101      	movs	r1, #1
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    cb00:	6465      	str	r5, [r4, #68]	; 0x44
    hi2c->XferCount   = Size;
    cb02:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    cb04:	62e0      	str	r0, [r4, #44]	; 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    cb06:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    cb08:	f8df 81c0 	ldr.w	r8, [pc, #448]	; cccc <HAL_I2C_Master_Transmit_DMA+0x200>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    cb0c:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr    = pData;
    cb0e:	6262      	str	r2, [r4, #36]	; 0x24
    __HAL_LOCK(hi2c);
    cb10:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->XferISR     = I2C_Master_ISR_DMA;
    cb14:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    cb18:	d92b      	bls.n	cb72 <HAL_I2C_Master_Transmit_DMA+0xa6>
    cb1a:	23ff      	movs	r3, #255	; 0xff
      xfermode = I2C_RELOAD_MODE;
    cb1c:	f04f 7980 	mov.w	r9, #16777216	; 0x1000000
    cb20:	8523      	strh	r3, [r4, #40]	; 0x28
      if (hi2c->hdmatx != NULL)
    cb22:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb24:	2b00      	cmp	r3, #0
    cb26:	d058      	beq.n	cbda <HAL_I2C_Master_Transmit_DMA+0x10e>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    cb28:	4d5c      	ldr	r5, [pc, #368]	; (cc9c <HAL_I2C_Master_Transmit_DMA+0x1d0>)
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
    cb2a:	2700      	movs	r7, #0
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    cb2c:	485c      	ldr	r0, [pc, #368]	; (cca0 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    cb2e:	4611      	mov	r1, r2
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
    cb30:	63dd      	str	r5, [r3, #60]	; 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
    cb32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb34:	64d8      	str	r0, [r3, #76]	; 0x4c
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
    cb36:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb38:	641f      	str	r7, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
    cb3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb3c:	651f      	str	r7, [r3, #80]	; 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
    cb3e:	6822      	ldr	r2, [r4, #0]
    cb40:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    cb42:	3228      	adds	r2, #40	; 0x28
    cb44:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    cb46:	f7fd ffc9 	bl	aadc <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
    cb4a:	4605      	mov	r5, r0
    cb4c:	2800      	cmp	r0, #0
    cb4e:	d05b      	beq.n	cc08 <HAL_I2C_Master_Transmit_DMA+0x13c>
        hi2c->State     = HAL_I2C_STATE_READY;
    cb50:	2320      	movs	r3, #32
        __HAL_UNLOCK(hi2c);
    cb52:	f884 7040 	strb.w	r7, [r4, #64]	; 0x40
        return HAL_ERROR;
    cb56:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
    cb58:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
    cb5c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
    cb60:	6c63      	ldr	r3, [r4, #68]	; 0x44
    cb62:	f043 0310 	orr.w	r3, r3, #16
    cb66:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
    cb68:	e000      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
    return HAL_BUSY;
    cb6a:	2502      	movs	r5, #2
}
    cb6c:	4628      	mov	r0, r5
    cb6e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hi2c->XferSize = hi2c->XferCount;
    cb72:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    cb74:	b29b      	uxth	r3, r3
    cb76:	8523      	strh	r3, [r4, #40]	; 0x28
    if (hi2c->XferSize > 0U)
    cb78:	2b00      	cmp	r3, #0
    cb7a:	d13b      	bne.n	cbf4 <HAL_I2C_Master_Transmit_DMA+0x128>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cb7c:	4b49      	ldr	r3, [pc, #292]	; (cca4 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
    cb7e:	4a4a      	ldr	r2, [pc, #296]	; (cca8 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
    cb80:	494a      	ldr	r1, [pc, #296]	; (ccac <HAL_I2C_Master_Transmit_DMA+0x1e0>)
    cb82:	429f      	cmp	r7, r3
    cb84:	bf18      	it	ne
    cb86:	4297      	cmpne	r7, r2
      hi2c->XferISR = I2C_Master_ISR_IT;
    cb88:	4a49      	ldr	r2, [pc, #292]	; (ccb0 <HAL_I2C_Master_Transmit_DMA+0x1e4>)
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cb8a:	bf14      	ite	ne
    cb8c:	2301      	movne	r3, #1
    cb8e:	2300      	moveq	r3, #0
      hi2c->XferISR = I2C_Master_ISR_IT;
    cb90:	6362      	str	r2, [r4, #52]	; 0x34
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cb92:	428f      	cmp	r7, r1
    cb94:	bf0c      	ite	eq
    cb96:	2300      	moveq	r3, #0
    cb98:	f003 0301 	andne.w	r3, r3, #1
    cb9c:	b113      	cbz	r3, cba4 <HAL_I2C_Master_Transmit_DMA+0xd8>
    cb9e:	4b45      	ldr	r3, [pc, #276]	; (ccb4 <HAL_I2C_Master_Transmit_DMA+0x1e8>)
    cba0:	429f      	cmp	r7, r3
    cba2:	d12a      	bne.n	cbfa <HAL_I2C_Master_Transmit_DMA+0x12e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cba4:	f3c6 0109 	ubfx	r1, r6, #0, #10
    cba8:	4b43      	ldr	r3, [pc, #268]	; (ccb8 <HAL_I2C_Master_Transmit_DMA+0x1ec>)
    cbaa:	687a      	ldr	r2, [r7, #4]
      __HAL_UNLOCK(hi2c);
    cbac:	2000      	movs	r0, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cbae:	430b      	orrs	r3, r1
    cbb0:	4942      	ldr	r1, [pc, #264]	; (ccbc <HAL_I2C_Master_Transmit_DMA+0x1f0>)
    cbb2:	400a      	ands	r2, r1
    cbb4:	4313      	orrs	r3, r2
    cbb6:	607b      	str	r3, [r7, #4]
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cbb8:	6b63      	ldr	r3, [r4, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
    cbba:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cbbe:	4543      	cmp	r3, r8
    cbc0:	d004      	beq.n	cbcc <HAL_I2C_Master_Transmit_DMA+0x100>
    cbc2:	4a3f      	ldr	r2, [pc, #252]	; (ccc0 <HAL_I2C_Master_Transmit_DMA+0x1f4>)
    cbc4:	4293      	cmp	r3, r2
    cbc6:	d001      	beq.n	cbcc <HAL_I2C_Master_Transmit_DMA+0x100>
    cbc8:	21f2      	movs	r1, #242	; 0xf2
    cbca:	e000      	b.n	cbce <HAL_I2C_Master_Transmit_DMA+0x102>
    cbcc:	2100      	movs	r1, #0
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    cbce:	6822      	ldr	r2, [r4, #0]
    return HAL_OK;
    cbd0:	2500      	movs	r5, #0
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    cbd2:	6813      	ldr	r3, [r2, #0]
    cbd4:	430b      	orrs	r3, r1
    cbd6:	6013      	str	r3, [r2, #0]
    cbd8:	e7c8      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
        hi2c->State     = HAL_I2C_STATE_READY;
    cbda:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
    cbdc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
    cbe0:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
    cbe2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
    cbe6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
    cbea:	6c63      	ldr	r3, [r4, #68]	; 0x44
    cbec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    cbf0:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
    cbf2:	e7bb      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
      xfermode = I2C_AUTOEND_MODE;
    cbf4:	f04f 7900 	mov.w	r9, #33554432	; 0x2000000
    cbf8:	e793      	b.n	cb22 <HAL_I2C_Master_Transmit_DMA+0x56>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cbfa:	f641 1131 	movw	r1, #6449	; 0x1931
    cbfe:	4831      	ldr	r0, [pc, #196]	; (ccc4 <HAL_I2C_Master_Transmit_DMA+0x1f8>)
    cc00:	f00c fc5e 	bl	194c0 <assert_failed>
    cc04:	6827      	ldr	r7, [r4, #0]
    cc06:	e7cd      	b.n	cba4 <HAL_I2C_Master_Transmit_DMA+0xd8>
    cc08:	4b26      	ldr	r3, [pc, #152]	; (cca4 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
    cc0a:	6822      	ldr	r2, [r4, #0]
    cc0c:	4826      	ldr	r0, [pc, #152]	; (cca8 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
    cc0e:	4927      	ldr	r1, [pc, #156]	; (ccac <HAL_I2C_Master_Transmit_DMA+0x1e0>)
    cc10:	429a      	cmp	r2, r3
    cc12:	bf18      	it	ne
    cc14:	4282      	cmpne	r2, r0
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
    cc16:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cc1a:	bf14      	ite	ne
    cc1c:	2301      	movne	r3, #1
    cc1e:	2300      	moveq	r3, #0
    cc20:	428a      	cmp	r2, r1
    cc22:	bf0c      	ite	eq
    cc24:	2300      	moveq	r3, #0
    cc26:	f003 0301 	andne.w	r3, r3, #1
    cc2a:	b113      	cbz	r3, cc32 <HAL_I2C_Master_Transmit_DMA+0x166>
    cc2c:	4b21      	ldr	r3, [pc, #132]	; (ccb4 <HAL_I2C_Master_Transmit_DMA+0x1e8>)
    cc2e:	429a      	cmp	r2, r3
    cc30:	d12a      	bne.n	cc88 <HAL_I2C_Master_Transmit_DMA+0x1bc>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cc32:	f3c6 0109 	ubfx	r1, r6, #0, #10
    cc36:	4b24      	ldr	r3, [pc, #144]	; (ccc8 <HAL_I2C_Master_Transmit_DMA+0x1fc>)
    cc38:	6856      	ldr	r6, [r2, #4]
        __HAL_UNLOCK(hi2c);
    cc3a:	2000      	movs	r0, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cc3c:	430b      	orrs	r3, r1
    cc3e:	491f      	ldr	r1, [pc, #124]	; (ccbc <HAL_I2C_Master_Transmit_DMA+0x1f0>)
    cc40:	400e      	ands	r6, r1
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc42:	491f      	ldr	r1, [pc, #124]	; (ccc0 <HAL_I2C_Master_Transmit_DMA+0x1f4>)
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    cc44:	4333      	orrs	r3, r6
    cc46:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
    cc4a:	ea43 0309 	orr.w	r3, r3, r9
    cc4e:	6053      	str	r3, [r2, #4]
        hi2c->XferCount -= hi2c->XferSize;
    cc50:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    cc52:	8d26      	ldrh	r6, [r4, #40]	; 0x28
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc54:	6b63      	ldr	r3, [r4, #52]	; 0x34
        hi2c->XferCount -= hi2c->XferSize;
    cc56:	1b92      	subs	r2, r2, r6
        __HAL_UNLOCK(hi2c);
    cc58:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc5c:	428b      	cmp	r3, r1
        hi2c->XferCount -= hi2c->XferSize;
    cc5e:	b292      	uxth	r2, r2
    cc60:	8562      	strh	r2, [r4, #42]	; 0x2a
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc62:	d00f      	beq.n	cc84 <HAL_I2C_Master_Transmit_DMA+0x1b8>
    cc64:	eba3 0308 	sub.w	r3, r3, r8
    cc68:	fab3 f383 	clz	r3, r3
    cc6c:	095b      	lsrs	r3, r3, #5
    cc6e:	b94b      	cbnz	r3, cc84 <HAL_I2C_Master_Transmit_DMA+0x1b8>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    cc70:	6821      	ldr	r1, [r4, #0]
    cc72:	680a      	ldr	r2, [r1, #0]
    cc74:	4313      	orrs	r3, r2
    cc76:	600b      	str	r3, [r1, #0]
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
    cc78:	6822      	ldr	r2, [r4, #0]
    cc7a:	6813      	ldr	r3, [r2, #0]
    cc7c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    cc80:	6013      	str	r3, [r2, #0]
    cc82:	e773      	b.n	cb6c <HAL_I2C_Master_Transmit_DMA+0xa0>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    cc84:	2390      	movs	r3, #144	; 0x90
    cc86:	e7f3      	b.n	cc70 <HAL_I2C_Master_Transmit_DMA+0x1a4>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    cc88:	f641 1131 	movw	r1, #6449	; 0x1931
    cc8c:	480d      	ldr	r0, [pc, #52]	; (ccc4 <HAL_I2C_Master_Transmit_DMA+0x1f8>)
    cc8e:	f00c fc17 	bl	194c0 <assert_failed>
    cc92:	6822      	ldr	r2, [r4, #0]
    cc94:	e7cd      	b.n	cc32 <HAL_I2C_Master_Transmit_DMA+0x166>
    cc96:	bf00      	nop
    cc98:	ffff0000 	.word	0xffff0000
    cc9c:	0000d4c1 	.word	0x0000d4c1
    cca0:	0000dd45 	.word	0x0000dd45
    cca4:	40005400 	.word	0x40005400
    cca8:	40005800 	.word	0x40005800
    ccac:	40005c00 	.word	0x40005c00
    ccb0:	0000d7cd 	.word	0x0000d7cd
    ccb4:	58001c00 	.word	0x58001c00
    ccb8:	82002000 	.word	0x82002000
    ccbc:	fc009800 	.word	0xfc009800
    ccc0:	0000d2f5 	.word	0x0000d2f5
    ccc4:	000300f8 	.word	0x000300f8
    ccc8:	80002000 	.word	0x80002000
    cccc:	0000daa1 	.word	0x0000daa1

0000ccd0 <HAL_I2C_MasterTxCpltCallback>:
    ccd0:	4770      	bx	lr
    ccd2:	bf00      	nop

0000ccd4 <HAL_I2C_MasterRxCpltCallback>:
    ccd4:	4770      	bx	lr
    ccd6:	bf00      	nop

0000ccd8 <HAL_I2C_SlaveTxCpltCallback>:
    ccd8:	4770      	bx	lr
    ccda:	bf00      	nop

0000ccdc <HAL_I2C_SlaveRxCpltCallback>:
    ccdc:	4770      	bx	lr
    ccde:	bf00      	nop

0000cce0 <I2C_ITSlaveSeqCplt>:
{
    cce0:	b538      	push	{r3, r4, r5, lr}
    cce2:	4603      	mov	r3, r0
  hi2c->Mode = HAL_I2C_MODE_NONE;
    cce4:	2000      	movs	r0, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    cce6:	681a      	ldr	r2, [r3, #0]
    cce8:	6811      	ldr	r1, [r2, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
    ccea:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
    ccee:	0448      	lsls	r0, r1, #17
    ccf0:	d50c      	bpl.n	cd0c <I2C_ITSlaveSeqCplt+0x2c>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    ccf2:	6811      	ldr	r1, [r2, #0]
    ccf4:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
    ccf8:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
    ccfa:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    ccfe:	2a29      	cmp	r2, #41	; 0x29
    cd00:	d00e      	beq.n	cd20 <I2C_ITSlaveSeqCplt+0x40>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
    cd02:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    cd06:	2a2a      	cmp	r2, #42	; 0x2a
    cd08:	d024      	beq.n	cd54 <I2C_ITSlaveSeqCplt+0x74>
}
    cd0a:	bd38      	pop	{r3, r4, r5, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
    cd0c:	0409      	lsls	r1, r1, #16
    cd0e:	d5f4      	bpl.n	ccfa <I2C_ITSlaveSeqCplt+0x1a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    cd10:	6811      	ldr	r1, [r2, #0]
    cd12:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
    cd16:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
    cd18:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    cd1c:	2a29      	cmp	r2, #41	; 0x29
    cd1e:	d1f0      	bne.n	cd02 <I2C_ITSlaveSeqCplt+0x22>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd20:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    cd22:	2221      	movs	r2, #33	; 0x21
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd24:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
    cd26:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd28:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    cd2c:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    cd2e:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd30:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd34:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd36:	f001 0128 	and.w	r1, r1, #40	; 0x28
    cd3a:	2928      	cmp	r1, #40	; 0x28
    cd3c:	bf14      	ite	ne
    cd3e:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
    cd42:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd46:	400a      	ands	r2, r1
    cd48:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
    cd4a:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    cd4e:	f7ff ffc3 	bl	ccd8 <HAL_I2C_SlaveTxCpltCallback>
}
    cd52:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd54:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    cd56:	2222      	movs	r2, #34	; 0x22
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd58:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
    cd5a:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    cd5c:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    cd60:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    cd62:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd64:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd68:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cd6a:	f001 0128 	and.w	r1, r1, #40	; 0x28
    cd6e:	2928      	cmp	r1, #40	; 0x28
    cd70:	bf14      	ite	ne
    cd72:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    cd76:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cd7a:	400a      	ands	r2, r1
    cd7c:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
    cd7e:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    cd82:	f7ff ffab 	bl	ccdc <HAL_I2C_SlaveRxCpltCallback>
}
    cd86:	bd38      	pop	{r3, r4, r5, pc}

0000cd88 <HAL_I2C_AddrCallback>:
}
    cd88:	4770      	bx	lr
    cd8a:	bf00      	nop

0000cd8c <I2C_ITAddrCplt.isra.9.part.10>:
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
    cd8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    transferdirection = I2C_GET_DIR(hi2c);
    cd8e:	6804      	ldr	r4, [r0, #0]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    cd90:	68c3      	ldr	r3, [r0, #12]
    transferdirection = I2C_GET_DIR(hi2c);
    cd92:	69a1      	ldr	r1, [r4, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    cd94:	69a2      	ldr	r2, [r4, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    cd96:	2b02      	cmp	r3, #2
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
    cd98:	68a6      	ldr	r6, [r4, #8]
    transferdirection = I2C_GET_DIR(hi2c);
    cd9a:	f3c1 4100 	ubfx	r1, r1, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    cd9e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
    cda2:	68e7      	ldr	r7, [r4, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
    cda4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    cda8:	d10d      	bne.n	cdc6 <I2C_ITAddrCplt.isra.9.part.10+0x3a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
    cdaa:	f3c6 0609 	ubfx	r6, r6, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
    cdae:	ea82 13d6 	eor.w	r3, r2, r6, lsr #7
    cdb2:	f013 0306 	ands.w	r3, r3, #6
    cdb6:	d110      	bne.n	cdda <I2C_ITAddrCplt.isra.9.part.10+0x4e>
        hi2c->AddrEventCount++;
    cdb8:	6c82      	ldr	r2, [r0, #72]	; 0x48
    cdba:	3201      	adds	r2, #1
    cdbc:	6482      	str	r2, [r0, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
    cdbe:	6c82      	ldr	r2, [r0, #72]	; 0x48
    cdc0:	2a02      	cmp	r2, #2
    cdc2:	d016      	beq.n	cdf2 <I2C_ITAddrCplt.isra.9.part.10+0x66>
}
    cdc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cdc6:	6823      	ldr	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
    cdc8:	2600      	movs	r6, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cdca:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
    cdce:	6023      	str	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
    cdd0:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdd4:	f7ff ffd8 	bl	cd88 <HAL_I2C_AddrCallback>
}
    cdd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cdda:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
    cddc:	2600      	movs	r6, #0
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdde:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cde2:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
    cde6:	6023      	str	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
    cde8:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdec:	f7ff ffcc 	bl	cd88 <HAL_I2C_AddrCallback>
}
    cdf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    cdf2:	2708      	movs	r7, #8
          hi2c->AddrEventCount = 0U;
    cdf4:	6483      	str	r3, [r0, #72]	; 0x48
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdf6:	4632      	mov	r2, r6
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    cdf8:	61e7      	str	r7, [r4, #28]
          __HAL_UNLOCK(hi2c);
    cdfa:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
    cdfe:	f7ff ffc3 	bl	cd88 <HAL_I2C_AddrCallback>
}
    ce02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000ce04 <HAL_I2C_ListenCpltCallback>:
    ce04:	4770      	bx	lr
    ce06:	bf00      	nop

0000ce08 <HAL_I2C_MemTxCpltCallback>:
    ce08:	4770      	bx	lr
    ce0a:	bf00      	nop

0000ce0c <HAL_I2C_MemRxCpltCallback>:
    ce0c:	4770      	bx	lr
    ce0e:	bf00      	nop

0000ce10 <HAL_I2C_ErrorCallback>:
    ce10:	4770      	bx	lr
    ce12:	bf00      	nop

0000ce14 <HAL_I2C_AbortCpltCallback>:
    ce14:	4770      	bx	lr
    ce16:	bf00      	nop

0000ce18 <I2C_DMAAbort>:
{
    ce18:	b508      	push	{r3, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    ce1a:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
    ce1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    ce1e:	b10a      	cbz	r2, ce24 <I2C_DMAAbort+0xc>
    hi2c->hdmatx->XferAbortCallback = NULL;
    ce20:	2100      	movs	r1, #0
    ce22:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->hdmarx != NULL)
    ce24:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    ce26:	b10a      	cbz	r2, ce2c <I2C_DMAAbort+0x14>
    hi2c->hdmarx->XferAbortCallback = NULL;
    ce28:	2100      	movs	r1, #0
    ce2a:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    ce2c:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
    ce30:	2a60      	cmp	r2, #96	; 0x60
    ce32:	d007      	beq.n	ce44 <I2C_DMAAbort+0x2c>
    hi2c->PreviousState = I2C_STATE_NONE;
    ce34:	2200      	movs	r2, #0
    HAL_I2C_ErrorCallback(hi2c);
    ce36:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_NONE;
    ce38:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    ce3a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    ce3e:	f7ff ffe7 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    ce42:	bd08      	pop	{r3, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
    ce44:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
    ce46:	2120      	movs	r1, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    ce48:	4618      	mov	r0, r3
    hi2c->State = HAL_I2C_STATE_READY;
    ce4a:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    ce4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    ce52:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    ce54:	f7ff ffde 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    ce58:	bd08      	pop	{r3, pc}
    ce5a:	bf00      	nop

0000ce5c <I2C_ITError>:
{
    ce5c:	b570      	push	{r4, r5, r6, lr}
    ce5e:	4604      	mov	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    ce60:	2200      	movs	r2, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    ce62:	484c      	ldr	r0, [pc, #304]	; (cf94 <I2C_ITError+0x138>)
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    ce64:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    ce68:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    ce6c:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    ce6e:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    ce70:	8562      	strh	r2, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    ce72:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    ce74:	2b02      	cmp	r3, #2
    ce76:	6820      	ldr	r0, [r4, #0]
  hi2c->ErrorCode |= ErrorCode;
    ce78:	ea41 0102 	orr.w	r1, r1, r2
    ce7c:	6461      	str	r1, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    ce7e:	d830      	bhi.n	cee2 <I2C_ITError+0x86>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce80:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    ce84:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce86:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce8a:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ce8c:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce8e:	4031      	ands	r1, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ce90:	4d41      	ldr	r5, [pc, #260]	; (cf98 <I2C_ITError+0x13c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce92:	42b2      	cmp	r2, r6
    ce94:	bf14      	ite	ne
    ce96:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
    ce9a:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ce9e:	42b1      	cmp	r1, r6
    cea0:	bf18      	it	ne
    cea2:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cea6:	4013      	ands	r3, r2
    cea8:	6003      	str	r3, [r0, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    ceaa:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    ceae:	6365      	str	r5, [r4, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ceb0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    ceb2:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ceb4:	b118      	cbz	r0, cebe <I2C_ITError+0x62>
    ceb6:	2b11      	cmp	r3, #17
    ceb8:	d025      	beq.n	cf06 <I2C_ITError+0xaa>
    ceba:	2b21      	cmp	r3, #33	; 0x21
    cebc:	d023      	beq.n	cf06 <I2C_ITError+0xaa>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    cebe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cec0:	b118      	cbz	r0, ceca <I2C_ITError+0x6e>
    cec2:	2b12      	cmp	r3, #18
    cec4:	d037      	beq.n	cf36 <I2C_ITError+0xda>
    cec6:	2b22      	cmp	r3, #34	; 0x22
    cec8:	d035      	beq.n	cf36 <I2C_ITError+0xda>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    ceca:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    cece:	2b60      	cmp	r3, #96	; 0x60
    ced0:	d054      	beq.n	cf7c <I2C_ITError+0x120>
    hi2c->PreviousState = I2C_STATE_NONE;
    ced2:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    ced4:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
    ced6:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    ced8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    cedc:	f7ff ff98 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    cee0:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cee2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cee6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    ceea:	6803      	ldr	r3, [r0, #0]
    ceec:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    cef0:	6003      	str	r3, [r0, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    cef2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    cef6:	2b60      	cmp	r3, #96	; 0x60
    cef8:	d002      	beq.n	cf00 <I2C_ITError+0xa4>
      hi2c->State         = HAL_I2C_STATE_READY;
    cefa:	2320      	movs	r3, #32
    cefc:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    cf00:	2300      	movs	r3, #0
    cf02:	6363      	str	r3, [r4, #52]	; 0x34
    cf04:	e7d4      	b.n	ceb0 <I2C_ITError+0x54>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    cf06:	6823      	ldr	r3, [r4, #0]
    cf08:	681a      	ldr	r2, [r3, #0]
    cf0a:	0451      	lsls	r1, r2, #17
    cf0c:	d430      	bmi.n	cf70 <I2C_ITError+0x114>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    cf0e:	f7fe f9f9 	bl	b304 <HAL_DMA_GetState>
    cf12:	2801      	cmp	r0, #1
    cf14:	d0d9      	beq.n	ceca <I2C_ITError+0x6e>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    cf16:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    cf18:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    cf1a:	4920      	ldr	r1, [pc, #128]	; (cf9c <I2C_ITError+0x140>)
    cf1c:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    cf1e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    cf22:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    cf24:	f7fe f8b4 	bl	b090 <HAL_DMA_Abort_IT>
    cf28:	2800      	cmp	r0, #0
    cf2a:	d0d9      	beq.n	cee0 <I2C_ITError+0x84>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    cf2c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
    cf2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    cf32:	6d03      	ldr	r3, [r0, #80]	; 0x50
    cf34:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    cf36:	6823      	ldr	r3, [r4, #0]
    cf38:	681a      	ldr	r2, [r3, #0]
    cf3a:	0412      	lsls	r2, r2, #16
    cf3c:	d504      	bpl.n	cf48 <I2C_ITError+0xec>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    cf3e:	681a      	ldr	r2, [r3, #0]
    cf40:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    cf44:	601a      	str	r2, [r3, #0]
    cf46:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    cf48:	f7fe f9dc 	bl	b304 <HAL_DMA_GetState>
    cf4c:	2801      	cmp	r0, #1
    cf4e:	d0bc      	beq.n	ceca <I2C_ITError+0x6e>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    cf50:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    cf52:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    cf54:	4911      	ldr	r1, [pc, #68]	; (cf9c <I2C_ITError+0x140>)
    cf56:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    cf58:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    cf5c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cf5e:	f7fe f897 	bl	b090 <HAL_DMA_Abort_IT>
    cf62:	2800      	cmp	r0, #0
    cf64:	d0bc      	beq.n	cee0 <I2C_ITError+0x84>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    cf66:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
    cf68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    cf6c:	6d03      	ldr	r3, [r0, #80]	; 0x50
    cf6e:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    cf70:	681a      	ldr	r2, [r3, #0]
    cf72:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    cf76:	601a      	str	r2, [r3, #0]
    cf78:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    cf7a:	e7c8      	b.n	cf0e <I2C_ITError+0xb2>
    hi2c->PreviousState = I2C_STATE_NONE;
    cf7c:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    cf7e:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    cf80:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    cf82:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    cf86:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    cf8a:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    cf8c:	f7ff ff42 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    cf90:	bd70      	pop	{r4, r5, r6, pc}
    cf92:	bf00      	nop
    cf94:	ffff0000 	.word	0xffff0000
    cf98:	0000d14d 	.word	0x0000d14d
    cf9c:	0000ce19 	.word	0x0000ce19

0000cfa0 <I2C_ITSlaveCplt>:
{
    cfa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cfa2:	4604      	mov	r4, r0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    cfa4:	6802      	ldr	r2, [r0, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    cfa6:	2620      	movs	r6, #32
{
    cfa8:	460d      	mov	r5, r1
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
    cfaa:	6810      	ldr	r0, [r2, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    cfac:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    cfb0:	61d6      	str	r6, [r2, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    cfb2:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cfb6:	6821      	ldr	r1, [r4, #0]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    cfb8:	2b21      	cmp	r3, #33	; 0x21
    cfba:	d165      	bne.n	d088 <I2C_ITSlaveCplt+0xe8>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    cfbc:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    cfc0:	680a      	ldr	r2, [r1, #0]
    cfc2:	f022 02fa 	bic.w	r2, r2, #250	; 0xfa
    cfc6:	600a      	str	r2, [r1, #0]
    cfc8:	6821      	ldr	r1, [r4, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
    cfca:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    cfcc:	684a      	ldr	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
    cfce:	4e5d      	ldr	r6, [pc, #372]	; (d144 <I2C_ITSlaveCplt+0x1a4>)
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    cfd0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    cfd4:	604a      	str	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
    cfd6:	6822      	ldr	r2, [r4, #0]
    cfd8:	6853      	ldr	r3, [r2, #4]
    cfda:	4033      	ands	r3, r6
    cfdc:	6053      	str	r3, [r2, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    cfde:	6823      	ldr	r3, [r4, #0]
    cfe0:	699a      	ldr	r2, [r3, #24]
    cfe2:	0792      	lsls	r2, r2, #30
    cfe4:	d502      	bpl.n	cfec <I2C_ITSlaveCplt+0x4c>
    hi2c->Instance->TXDR = 0x00U;
    cfe6:	2200      	movs	r2, #0
    cfe8:	629a      	str	r2, [r3, #40]	; 0x28
    cfea:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    cfec:	699a      	ldr	r2, [r3, #24]
    cfee:	07d7      	lsls	r7, r2, #31
    cff0:	d403      	bmi.n	cffa <I2C_ITSlaveCplt+0x5a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    cff2:	699a      	ldr	r2, [r3, #24]
    cff4:	f042 0201 	orr.w	r2, r2, #1
    cff8:	619a      	str	r2, [r3, #24]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
    cffa:	0446      	lsls	r6, r0, #17
    cffc:	d539      	bpl.n	d072 <I2C_ITSlaveCplt+0xd2>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    cffe:	6822      	ldr	r2, [r4, #0]
    d000:	6813      	ldr	r3, [r2, #0]
    d002:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    d006:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmatx != NULL)
    d008:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d00a:	b11b      	cbz	r3, d014 <I2C_ITSlaveCplt+0x74>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
    d00c:	681a      	ldr	r2, [r3, #0]
    d00e:	6853      	ldr	r3, [r2, #4]
    d010:	b29b      	uxth	r3, r3
    d012:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
    d014:	0769      	lsls	r1, r5, #29
    d016:	d50b      	bpl.n	d030 <I2C_ITSlaveCplt+0x90>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d018:	6822      	ldr	r2, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
    d01a:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d01e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d020:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d022:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d024:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d026:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d028:	3301      	adds	r3, #1
    d02a:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d02c:	2a00      	cmp	r2, #0
    d02e:	d144      	bne.n	d0ba <I2C_ITSlaveCplt+0x11a>
  if (hi2c->XferCount != 0U)
    d030:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d032:	b29b      	uxth	r3, r3
    d034:	b11b      	cbz	r3, d03e <I2C_ITSlaveCplt+0x9e>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d036:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d038:	f043 0304 	orr.w	r3, r3, #4
    d03c:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d03e:	2700      	movs	r7, #0
    d040:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    d044:	6c66      	ldr	r6, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
    d046:	6367      	str	r7, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
    d048:	2e00      	cmp	r6, #0
    d04a:	d13d      	bne.n	d0c8 <I2C_ITSlaveCplt+0x128>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d04c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d04e:	4d3e      	ldr	r5, [pc, #248]	; (d148 <I2C_ITSlaveCplt+0x1a8>)
    d050:	42ab      	cmp	r3, r5
    d052:	d124      	bne.n	d09e <I2C_ITSlaveCplt+0xfe>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d054:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    d058:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
    d05a:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d05e:	2b22      	cmp	r3, #34	; 0x22
    hi2c->State = HAL_I2C_STATE_READY;
    d060:	f04f 0320 	mov.w	r3, #32
    d064:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    d068:	6326      	str	r6, [r4, #48]	; 0x30
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d06a:	d066      	beq.n	d13a <I2C_ITSlaveCplt+0x19a>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
    d06c:	f7ff fe34 	bl	ccd8 <HAL_I2C_SlaveTxCpltCallback>
}
    d070:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
    d072:	0400      	lsls	r0, r0, #16
    d074:	d5ce      	bpl.n	d014 <I2C_ITSlaveCplt+0x74>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    d076:	6822      	ldr	r2, [r4, #0]
    d078:	6813      	ldr	r3, [r2, #0]
    d07a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    d07e:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmarx != NULL)
    d080:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    d082:	2b00      	cmp	r3, #0
    d084:	d1c2      	bne.n	d00c <I2C_ITSlaveCplt+0x6c>
    d086:	e7c5      	b.n	d014 <I2C_ITSlaveCplt+0x74>
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
    d088:	2b22      	cmp	r3, #34	; 0x22
    d08a:	d19f      	bne.n	cfcc <I2C_ITSlaveCplt+0x2c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d08c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d090:	680a      	ldr	r2, [r1, #0]
    d092:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
    d096:	600a      	str	r2, [r1, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    d098:	6323      	str	r3, [r4, #48]	; 0x30
    d09a:	6821      	ldr	r1, [r4, #0]
    d09c:	e796      	b.n	cfcc <I2C_ITSlaveCplt+0x2c>
    I2C_ITSlaveSeqCplt(hi2c);
    d09e:	4620      	mov	r0, r4
    d0a0:	f7ff fe1e 	bl	cce0 <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
    d0a4:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d0a6:	62e5      	str	r5, [r4, #44]	; 0x2c
    HAL_I2C_ListenCpltCallback(hi2c);
    d0a8:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    d0aa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    d0ae:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    d0b2:	6326      	str	r6, [r4, #48]	; 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
    d0b4:	f7ff fea6 	bl	ce04 <HAL_I2C_ListenCpltCallback>
}
    d0b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->XferCount--;
    d0ba:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d0bc:	3a01      	subs	r2, #1
      hi2c->XferCount--;
    d0be:	3b01      	subs	r3, #1
      hi2c->XferSize--;
    d0c0:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d0c2:	b29b      	uxth	r3, r3
    d0c4:	8563      	strh	r3, [r4, #42]	; 0x2a
    d0c6:	e7b3      	b.n	d030 <I2C_ITSlaveCplt+0x90>
    I2C_ITError(hi2c, hi2c->ErrorCode);
    d0c8:	6c61      	ldr	r1, [r4, #68]	; 0x44
    d0ca:	4620      	mov	r0, r4
    d0cc:	f7ff fec6 	bl	ce5c <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
    d0d0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d0d4:	2b28      	cmp	r3, #40	; 0x28
    d0d6:	d1cb      	bne.n	d070 <I2C_ITSlaveCplt+0xd0>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d0d8:	4b1b      	ldr	r3, [pc, #108]	; (d148 <I2C_ITSlaveCplt+0x1a8>)
  hi2c->State = HAL_I2C_STATE_READY;
    d0da:	2220      	movs	r2, #32
  hi2c->XferISR = NULL;
    d0dc:	6367      	str	r7, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d0de:	62e3      	str	r3, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
    d0e0:	6327      	str	r7, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    d0e2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d0e6:	076a      	lsls	r2, r5, #29
    d0e8:	6823      	ldr	r3, [r4, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d0ea:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d0ee:	d512      	bpl.n	d116 <I2C_ITSlaveCplt+0x176>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d0f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    d0f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d0f4:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d0f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d0f8:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d0fa:	3301      	adds	r3, #1
    d0fc:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d0fe:	b1fa      	cbz	r2, d140 <I2C_ITSlaveCplt+0x1a0>
      hi2c->XferCount--;
    d100:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d102:	3a01      	subs	r2, #1
    d104:	6823      	ldr	r3, [r4, #0]
      hi2c->XferCount--;
    d106:	3901      	subs	r1, #1
      hi2c->XferSize--;
    d108:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d10a:	b28a      	uxth	r2, r1
    d10c:	8562      	strh	r2, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d10e:	6c62      	ldr	r2, [r4, #68]	; 0x44
    d110:	f042 0204 	orr.w	r2, r2, #4
    d114:	6462      	str	r2, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d116:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d11a:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d11c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    d120:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d122:	681a      	ldr	r2, [r3, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    d124:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d126:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
    d12a:	601a      	str	r2, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d12c:	6823      	ldr	r3, [r4, #0]
    d12e:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d130:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    d134:	f7ff fe66 	bl	ce04 <HAL_I2C_ListenCpltCallback>
}
    d138:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_I2C_SlaveRxCpltCallback(hi2c);
    d13a:	f7ff fdcf 	bl	ccdc <HAL_I2C_SlaveRxCpltCallback>
}
    d13e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d140:	6823      	ldr	r3, [r4, #0]
    d142:	e7e8      	b.n	d116 <I2C_ITSlaveCplt+0x176>
    d144:	fe00e800 	.word	0xfe00e800
    d148:	ffff0000 	.word	0xffff0000

0000d14c <I2C_Slave_ISR_IT>:
{
    d14c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
    d14e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
    d152:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
    d154:	2b01      	cmp	r3, #1
    d156:	d07f      	beq.n	d258 <I2C_Slave_ISR_IT+0x10c>
    d158:	4616      	mov	r6, r2
    d15a:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d15c:	068a      	lsls	r2, r1, #26
    d15e:	4604      	mov	r4, r0
    d160:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
    d162:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d166:	d501      	bpl.n	d16c <I2C_Slave_ISR_IT+0x20>
    d168:	06b3      	lsls	r3, r6, #26
    d16a:	d462      	bmi.n	d232 <I2C_Slave_ISR_IT+0xe6>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d16c:	06ea      	lsls	r2, r5, #27
    d16e:	d51b      	bpl.n	d1a8 <I2C_Slave_ISR_IT+0x5c>
    d170:	06f3      	lsls	r3, r6, #27
    d172:	d519      	bpl.n	d1a8 <I2C_Slave_ISR_IT+0x5c>
    if (hi2c->XferCount == 0U)
    d174:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d176:	6822      	ldr	r2, [r4, #0]
    d178:	b29b      	uxth	r3, r3
    d17a:	2b00      	cmp	r3, #0
    d17c:	d15e      	bne.n	d23c <I2C_Slave_ISR_IT+0xf0>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
    d17e:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    d182:	2928      	cmp	r1, #40	; 0x28
    d184:	d102      	bne.n	d18c <I2C_Slave_ISR_IT+0x40>
    d186:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    d18a:	d07a      	beq.n	d282 <I2C_Slave_ISR_IT+0x136>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d18c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d190:	2b29      	cmp	r3, #41	; 0x29
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d192:	f04f 0310 	mov.w	r3, #16
    d196:	61d3      	str	r3, [r2, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d198:	d102      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d19a:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    d19e:	d161      	bne.n	d264 <I2C_Slave_ISR_IT+0x118>
  __HAL_UNLOCK(hi2c);
    d1a0:	2000      	movs	r0, #0
    d1a2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d1a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d1a8:	076a      	lsls	r2, r5, #29
    d1aa:	d40e      	bmi.n	d1ca <I2C_Slave_ISR_IT+0x7e>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
    d1ac:	0728      	lsls	r0, r5, #28
    d1ae:	d52a      	bpl.n	d206 <I2C_Slave_ISR_IT+0xba>
    d1b0:	0731      	lsls	r1, r6, #28
    d1b2:	d528      	bpl.n	d206 <I2C_Slave_ISR_IT+0xba>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
    d1b4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d1b8:	f003 0328 	and.w	r3, r3, #40	; 0x28
    d1bc:	2b28      	cmp	r3, #40	; 0x28
    d1be:	f000 8090 	beq.w	d2e2 <I2C_Slave_ISR_IT+0x196>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d1c2:	6823      	ldr	r3, [r4, #0]
    d1c4:	2208      	movs	r2, #8
    d1c6:	61da      	str	r2, [r3, #28]
    d1c8:	e7ea      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d1ca:	0773      	lsls	r3, r6, #29
    d1cc:	d5ee      	bpl.n	d1ac <I2C_Slave_ISR_IT+0x60>
    if (hi2c->XferCount > 0U)
    d1ce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d1d0:	b29b      	uxth	r3, r3
    d1d2:	b16b      	cbz	r3, d1f0 <I2C_Slave_ISR_IT+0xa4>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d1d4:	6822      	ldr	r2, [r4, #0]
    d1d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d1d8:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d1da:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
    d1dc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
    d1de:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
    d1e0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d1e2:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
    d1e4:	3101      	adds	r1, #1
      hi2c->XferCount--;
    d1e6:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
    d1e8:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
    d1ea:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
    d1ec:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d1ee:	8522      	strh	r2, [r4, #40]	; 0x28
    if ((hi2c->XferCount == 0U) && \
    d1f0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d1f2:	b29b      	uxth	r3, r3
    d1f4:	2b00      	cmp	r3, #0
    d1f6:	d1d3      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d1f8:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    d1fc:	d0d0      	beq.n	d1a0 <I2C_Slave_ISR_IT+0x54>
        I2C_ITSlaveSeqCplt(hi2c);
    d1fe:	4620      	mov	r0, r4
    d200:	f7ff fd6e 	bl	cce0 <I2C_ITSlaveSeqCplt>
    d204:	e7cc      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
    d206:	07aa      	lsls	r2, r5, #30
    d208:	d5ca      	bpl.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d20a:	07b3      	lsls	r3, r6, #30
    d20c:	d5c8      	bpl.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    if (hi2c->XferCount > 0U)
    d20e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d210:	b29b      	uxth	r3, r3
    d212:	b31b      	cbz	r3, d25c <I2C_Slave_ISR_IT+0x110>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    d214:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d216:	6823      	ldr	r3, [r4, #0]
    d218:	7812      	ldrb	r2, [r2, #0]
    d21a:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
    d21c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
    d21e:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
    d220:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d222:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
    d224:	3101      	adds	r1, #1
      hi2c->XferCount--;
    d226:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
    d228:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
    d22a:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
    d22c:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d22e:	8522      	strh	r2, [r4, #40]	; 0x28
    d230:	e7b6      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
    d232:	f7ff feb5 	bl	cfa0 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d236:	06ea      	lsls	r2, r5, #27
    d238:	d5b6      	bpl.n	d1a8 <I2C_Slave_ISR_IT+0x5c>
    d23a:	e799      	b.n	d170 <I2C_Slave_ISR_IT+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d23c:	2310      	movs	r3, #16
    d23e:	61d3      	str	r3, [r2, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d240:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d242:	f043 0304 	orr.w	r3, r3, #4
    d246:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    d248:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
    d24c:	d1a8      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
        I2C_ITError(hi2c, hi2c->ErrorCode);
    d24e:	6c61      	ldr	r1, [r4, #68]	; 0x44
    d250:	4620      	mov	r0, r4
    d252:	f7ff fe03 	bl	ce5c <I2C_ITError>
    d256:	e7a3      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
  __HAL_LOCK(hi2c);
    d258:	2002      	movs	r0, #2
}
    d25a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
    d25c:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
    d260:	d19e      	bne.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d262:	e7cc      	b.n	d1fe <I2C_Slave_ISR_IT+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d264:	6823      	ldr	r3, [r4, #0]
    d266:	699a      	ldr	r2, [r3, #24]
    d268:	0790      	lsls	r0, r2, #30
    d26a:	d502      	bpl.n	d272 <I2C_Slave_ISR_IT+0x126>
    hi2c->Instance->TXDR = 0x00U;
    d26c:	2200      	movs	r2, #0
    d26e:	629a      	str	r2, [r3, #40]	; 0x28
    d270:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d272:	699a      	ldr	r2, [r3, #24]
    d274:	07d1      	lsls	r1, r2, #31
    d276:	d4c2      	bmi.n	d1fe <I2C_Slave_ISR_IT+0xb2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d278:	699a      	ldr	r2, [r3, #24]
    d27a:	f042 0201 	orr.w	r2, r2, #1
    d27e:	619a      	str	r2, [r3, #24]
    d280:	e7bd      	b.n	d1fe <I2C_Slave_ISR_IT+0xb2>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d282:	481b      	ldr	r0, [pc, #108]	; (d2f0 <I2C_Slave_ISR_IT+0x1a4>)
  hi2c->State = HAL_I2C_STATE_READY;
    d284:	2120      	movs	r1, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d286:	076d      	lsls	r5, r5, #29
  hi2c->XferISR = NULL;
    d288:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d28a:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
    d28c:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    d28e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d292:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d296:	d512      	bpl.n	d2be <I2C_Slave_ISR_IT+0x172>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d298:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d29a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d29c:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d29e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d2a0:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d2a2:	3301      	adds	r3, #1
    d2a4:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d2a6:	b301      	cbz	r1, d2ea <I2C_Slave_ISR_IT+0x19e>
      hi2c->XferCount--;
    d2a8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d2aa:	3901      	subs	r1, #1
    d2ac:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
    d2ae:	3b01      	subs	r3, #1
      hi2c->XferSize--;
    d2b0:	8521      	strh	r1, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d2b2:	b29b      	uxth	r3, r3
    d2b4:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d2b6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d2b8:	f043 0304 	orr.w	r3, r3, #4
    d2bc:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d2be:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d2c2:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d2c4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    d2c8:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d2ca:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    d2cc:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d2ce:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    d2d2:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d2d4:	6823      	ldr	r3, [r4, #0]
    d2d6:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d2d8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    d2dc:	f7ff fd92 	bl	ce04 <HAL_I2C_ListenCpltCallback>
    d2e0:	e75e      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d2e2:	4620      	mov	r0, r4
    d2e4:	f7ff fd52 	bl	cd8c <I2C_ITAddrCplt.isra.9.part.10>
    d2e8:	e75a      	b.n	d1a0 <I2C_Slave_ISR_IT+0x54>
    d2ea:	6822      	ldr	r2, [r4, #0]
    d2ec:	e7e7      	b.n	d2be <I2C_Slave_ISR_IT+0x172>
    d2ee:	bf00      	nop
    d2f0:	ffff0000 	.word	0xffff0000

0000d2f4 <I2C_Slave_ISR_DMA>:
{
    d2f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
    d2f6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
    d2fa:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
    d2fc:	2b01      	cmp	r3, #1
    d2fe:	f000 80b0 	beq.w	d462 <I2C_Slave_ISR_DMA+0x16e>
    d302:	4615      	mov	r5, r2
    d304:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d306:	068a      	lsls	r2, r1, #26
    d308:	4604      	mov	r4, r0
    d30a:	460e      	mov	r6, r1
  __HAL_LOCK(hi2c);
    d30c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d310:	d502      	bpl.n	d318 <I2C_Slave_ISR_DMA+0x24>
    d312:	06ab      	lsls	r3, r5, #26
    d314:	f100 8081 	bmi.w	d41a <I2C_Slave_ISR_DMA+0x126>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d318:	06f1      	lsls	r1, r6, #27
    d31a:	d56d      	bpl.n	d3f8 <I2C_Slave_ISR_DMA+0x104>
    d31c:	06ea      	lsls	r2, r5, #27
    d31e:	d56b      	bpl.n	d3f8 <I2C_Slave_ISR_DMA+0x104>
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
    d320:	0bab      	lsrs	r3, r5, #14
    d322:	6822      	ldr	r2, [r4, #0]
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
    d324:	0bed      	lsrs	r5, r5, #15
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
    d326:	f003 0001 	and.w	r0, r3, #1
    d32a:	432b      	orrs	r3, r5
    d32c:	07db      	lsls	r3, r3, #31
    d32e:	d579      	bpl.n	d424 <I2C_Slave_ISR_DMA+0x130>
    d330:	e9d4 130e 	ldrd	r1, r3, [r4, #56]	; 0x38
      if (hi2c->hdmarx != NULL)
    d334:	b1bb      	cbz	r3, d366 <I2C_Slave_ISR_DMA+0x72>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
    d336:	07ed      	lsls	r5, r5, #31
    d338:	d515      	bpl.n	d366 <I2C_Slave_ISR_DMA+0x72>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
    d33a:	f8df e180 	ldr.w	lr, [pc, #384]	; d4bc <I2C_Slave_ISR_DMA+0x1c8>
    d33e:	681d      	ldr	r5, [r3, #0]
    d340:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d344:	686b      	ldr	r3, [r5, #4]
    d346:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d34a:	fab3 f383 	clz	r3, r3
    d34e:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d352:	095b      	lsrs	r3, r3, #5
    d354:	f50e 7e5c 	add.w	lr, lr, #880	; 0x370
    d358:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d35c:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    d360:	2b00      	cmp	r3, #0
    d362:	f040 809a 	bne.w	d49a <I2C_Slave_ISR_DMA+0x1a6>
      if (hi2c->hdmatx != NULL)
    d366:	2900      	cmp	r1, #0
    d368:	d07f      	beq.n	d46a <I2C_Slave_ISR_DMA+0x176>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
    d36a:	2800      	cmp	r0, #0
    d36c:	d07d      	beq.n	d46a <I2C_Slave_ISR_DMA+0x176>
    d36e:	2000      	movs	r0, #0
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
    d370:	6809      	ldr	r1, [r1, #0]
    d372:	684b      	ldr	r3, [r1, #4]
    d374:	fab3 f383 	clz	r3, r3
    d378:	095b      	lsrs	r3, r3, #5
    d37a:	2b00      	cmp	r3, #0
    d37c:	d073      	beq.n	d466 <I2C_Slave_ISR_DMA+0x172>
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
    d37e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d382:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    d386:	b2db      	uxtb	r3, r3
    d388:	d14f      	bne.n	d42a <I2C_Slave_ISR_DMA+0x136>
    d38a:	2b28      	cmp	r3, #40	; 0x28
    d38c:	d14d      	bne.n	d42a <I2C_Slave_ISR_DMA+0x136>
  hi2c->PreviousState = I2C_STATE_NONE;
    d38e:	2300      	movs	r3, #0
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d390:	4849      	ldr	r0, [pc, #292]	; (d4b8 <I2C_Slave_ISR_DMA+0x1c4>)
  hi2c->State = HAL_I2C_STATE_READY;
    d392:	2120      	movs	r1, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d394:	0775      	lsls	r5, r6, #29
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    d396:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferISR = NULL;
    d398:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->PreviousState = I2C_STATE_NONE;
    d39a:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
    d39c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d3a0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
    d3a4:	d513      	bpl.n	d3ce <I2C_Slave_ISR_DMA+0xda>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d3a6:	6a52      	ldr	r2, [r2, #36]	; 0x24
    d3a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d3aa:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
    d3ac:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d3ae:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
    d3b0:	3301      	adds	r3, #1
    d3b2:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
    d3b4:	2a00      	cmp	r2, #0
    d3b6:	d07c      	beq.n	d4b2 <I2C_Slave_ISR_DMA+0x1be>
      hi2c->XferCount--;
    d3b8:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
    d3ba:	1e53      	subs	r3, r2, #1
    d3bc:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
    d3be:	3901      	subs	r1, #1
      hi2c->XferSize--;
    d3c0:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
    d3c2:	b28b      	uxth	r3, r1
    d3c4:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d3c6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d3c8:	f043 0304 	orr.w	r3, r3, #4
    d3cc:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d3ce:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d3d2:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d3d4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
    d3d8:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d3da:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
    d3dc:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d3de:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    d3e2:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d3e4:	6823      	ldr	r3, [r4, #0]
    d3e6:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d3e8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
    d3ec:	f7ff fd0a 	bl	ce04 <HAL_I2C_ListenCpltCallback>
  __HAL_UNLOCK(hi2c);
    d3f0:	2000      	movs	r0, #0
    d3f2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d3f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
    d3f8:	0732      	lsls	r2, r6, #28
    d3fa:	d5f9      	bpl.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
    d3fc:	072b      	lsls	r3, r5, #28
    d3fe:	d5f7      	bpl.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
    d400:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d404:	f003 0328 	and.w	r3, r3, #40	; 0x28
    d408:	2b28      	cmp	r3, #40	; 0x28
    d40a:	d04e      	beq.n	d4aa <I2C_Slave_ISR_DMA+0x1b6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d40c:	6823      	ldr	r3, [r4, #0]
    d40e:	2208      	movs	r2, #8
  __HAL_UNLOCK(hi2c);
    d410:	2000      	movs	r0, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
    d412:	61da      	str	r2, [r3, #28]
  __HAL_UNLOCK(hi2c);
    d414:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    d418:	e7ed      	b.n	d3f6 <I2C_Slave_ISR_DMA+0x102>
    I2C_ITSlaveCplt(hi2c, ITFlags);
    d41a:	f7ff fdc1 	bl	cfa0 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d41e:	06f1      	lsls	r1, r6, #27
    d420:	d5ea      	bpl.n	d3f8 <I2C_Slave_ISR_DMA+0x104>
    d422:	e77b      	b.n	d31c <I2C_Slave_ISR_DMA+0x28>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d424:	2310      	movs	r3, #16
    d426:	61d3      	str	r3, [r2, #28]
    d428:	e7e2      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d42a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d42e:	2b29      	cmp	r3, #41	; 0x29
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d430:	f04f 0310 	mov.w	r3, #16
    d434:	61d3      	str	r3, [r2, #28]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
    d436:	d1db      	bne.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
    d438:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
    d43c:	d0d8      	beq.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d43e:	6823      	ldr	r3, [r4, #0]
    d440:	699a      	ldr	r2, [r3, #24]
    d442:	0790      	lsls	r0, r2, #30
    d444:	d502      	bpl.n	d44c <I2C_Slave_ISR_DMA+0x158>
    hi2c->Instance->TXDR = 0x00U;
    d446:	2200      	movs	r2, #0
    d448:	629a      	str	r2, [r3, #40]	; 0x28
    d44a:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d44c:	699a      	ldr	r2, [r3, #24]
    d44e:	07d1      	lsls	r1, r2, #31
    d450:	d403      	bmi.n	d45a <I2C_Slave_ISR_DMA+0x166>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d452:	699a      	ldr	r2, [r3, #24]
    d454:	f042 0201 	orr.w	r2, r2, #1
    d458:	619a      	str	r2, [r3, #24]
          I2C_ITSlaveSeqCplt(hi2c);
    d45a:	4620      	mov	r0, r4
    d45c:	f7ff fc40 	bl	cce0 <I2C_ITSlaveSeqCplt>
    d460:	e7c6      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
  __HAL_LOCK(hi2c);
    d462:	2002      	movs	r0, #2
}
    d464:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (treatdmanack == 1U)
    d466:	2800      	cmp	r0, #0
    d468:	d189      	bne.n	d37e <I2C_Slave_ISR_DMA+0x8a>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d46a:	2310      	movs	r3, #16
    d46c:	61d3      	str	r3, [r2, #28]
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    d46e:	f037 7280 	bics.w	r2, r7, #16777216	; 0x1000000
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d472:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d474:	f043 0304 	orr.w	r3, r3, #4
    d478:	6463      	str	r3, [r4, #68]	; 0x44
        tmpstate = hi2c->State;
    d47a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d47e:	b2db      	uxtb	r3, r3
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
    d480:	d1b6      	bne.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
    d482:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    d486:	2b21      	cmp	r3, #33	; 0x21
    d488:	d001      	beq.n	d48e <I2C_Slave_ISR_DMA+0x19a>
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
    d48a:	2b22      	cmp	r3, #34	; 0x22
    d48c:	d100      	bne.n	d490 <I2C_Slave_ISR_DMA+0x19c>
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
    d48e:	6323      	str	r3, [r4, #48]	; 0x30
          I2C_ITError(hi2c, hi2c->ErrorCode);
    d490:	6c61      	ldr	r1, [r4, #68]	; 0x44
    d492:	4620      	mov	r0, r4
    d494:	f7ff fce2 	bl	ce5c <I2C_ITError>
    d498:	e7aa      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
      if (hi2c->hdmatx != NULL)
    d49a:	2900      	cmp	r1, #0
    d49c:	f43f af6f 	beq.w	d37e <I2C_Slave_ISR_DMA+0x8a>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
    d4a0:	2800      	cmp	r0, #0
    d4a2:	f43f af6c 	beq.w	d37e <I2C_Slave_ISR_DMA+0x8a>
            treatdmanack = 1U;
    d4a6:	2001      	movs	r0, #1
    d4a8:	e762      	b.n	d370 <I2C_Slave_ISR_DMA+0x7c>
    d4aa:	4620      	mov	r0, r4
    d4ac:	f7ff fc6e 	bl	cd8c <I2C_ITAddrCplt.isra.9.part.10>
    d4b0:	e79e      	b.n	d3f0 <I2C_Slave_ISR_DMA+0xfc>
    d4b2:	6822      	ldr	r2, [r4, #0]
    d4b4:	e78b      	b.n	d3ce <I2C_Slave_ISR_DMA+0xda>
    d4b6:	bf00      	nop
    d4b8:	ffff0000 	.word	0xffff0000
    d4bc:	40020028 	.word	0x40020028

0000d4c0 <I2C_DMAMasterTransmitCplt>:
{
    d4c0:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    d4c2:	6b84      	ldr	r4, [r0, #56]	; 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    d4c4:	6822      	ldr	r2, [r4, #0]
    d4c6:	6813      	ldr	r3, [r2, #0]
    d4c8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    d4cc:	6013      	str	r3, [r2, #0]
  if (hi2c->XferCount == 0U)
    d4ce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d4d0:	b29b      	uxth	r3, r3
    d4d2:	b963      	cbnz	r3, d4ee <I2C_DMAMasterTransmitCplt+0x2e>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d4d4:	6b63      	ldr	r3, [r4, #52]	; 0x34
    d4d6:	4a1e      	ldr	r2, [pc, #120]	; (d550 <I2C_DMAMasterTransmitCplt+0x90>)
    d4d8:	4293      	cmp	r3, r2
    d4da:	d02b      	beq.n	d534 <I2C_DMAMasterTransmitCplt+0x74>
    d4dc:	4a1d      	ldr	r2, [pc, #116]	; (d554 <I2C_DMAMasterTransmitCplt+0x94>)
    d4de:	4293      	cmp	r3, r2
    d4e0:	d028      	beq.n	d534 <I2C_DMAMasterTransmitCplt+0x74>
      tmpisr |= I2C_IT_STOPI;
    d4e2:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d4e4:	6822      	ldr	r2, [r4, #0]
    d4e6:	6813      	ldr	r3, [r2, #0]
    d4e8:	430b      	orrs	r3, r1
    d4ea:	6013      	str	r3, [r2, #0]
}
    d4ec:	bd10      	pop	{r4, pc}
    hi2c->pBuffPtr += hi2c->XferSize;
    d4ee:	6a61      	ldr	r1, [r4, #36]	; 0x24
    d4f0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4f2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr += hi2c->XferSize;
    d4f4:	4411      	add	r1, r2
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4f6:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr += hi2c->XferSize;
    d4f8:	6261      	str	r1, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d4fa:	d818      	bhi.n	d52e <I2C_DMAMasterTransmitCplt+0x6e>
      hi2c->XferSize = hi2c->XferCount;
    d4fc:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    d4fe:	b280      	uxth	r0, r0
    d500:	4603      	mov	r3, r0
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
    d502:	6822      	ldr	r2, [r4, #0]
    d504:	8520      	strh	r0, [r4, #40]	; 0x28
    d506:	3228      	adds	r2, #40	; 0x28
    d508:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    d50a:	f7fd fae7 	bl	aadc <HAL_DMA_Start_IT>
    d50e:	b9c8      	cbnz	r0, d544 <I2C_DMAMasterTransmitCplt+0x84>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d510:	6b63      	ldr	r3, [r4, #52]	; 0x34
    d512:	4a10      	ldr	r2, [pc, #64]	; (d554 <I2C_DMAMasterTransmitCplt+0x94>)
    d514:	4293      	cmp	r3, r2
    d516:	d00f      	beq.n	d538 <I2C_DMAMasterTransmitCplt+0x78>
    d518:	4a0d      	ldr	r2, [pc, #52]	; (d550 <I2C_DMAMasterTransmitCplt+0x90>)
    d51a:	1a9b      	subs	r3, r3, r2
    d51c:	fab3 f383 	clz	r3, r3
    d520:	095b      	lsrs	r3, r3, #5
    d522:	b94b      	cbnz	r3, d538 <I2C_DMAMasterTransmitCplt+0x78>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d524:	6821      	ldr	r1, [r4, #0]
    d526:	680a      	ldr	r2, [r1, #0]
    d528:	4313      	orrs	r3, r2
    d52a:	600b      	str	r3, [r1, #0]
}
    d52c:	bd10      	pop	{r4, pc}
    d52e:	23ff      	movs	r3, #255	; 0xff
      hi2c->XferSize = MAX_NBYTE_SIZE;
    d530:	4618      	mov	r0, r3
    d532:	e7e6      	b.n	d502 <I2C_DMAMasterTransmitCplt+0x42>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    d534:	2160      	movs	r1, #96	; 0x60
    d536:	e7d5      	b.n	d4e4 <I2C_DMAMasterTransmitCplt+0x24>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d538:	6821      	ldr	r1, [r4, #0]
      tmpisr |= I2C_IT_TCI;
    d53a:	2340      	movs	r3, #64	; 0x40
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    d53c:	680a      	ldr	r2, [r1, #0]
    d53e:	4313      	orrs	r3, r2
    d540:	600b      	str	r3, [r1, #0]
    d542:	e7f3      	b.n	d52c <I2C_DMAMasterTransmitCplt+0x6c>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
    d544:	4620      	mov	r0, r4
    d546:	2110      	movs	r1, #16
}
    d548:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
    d54c:	f7ff bc86 	b.w	ce5c <I2C_ITError>
    d550:	0000d2f5 	.word	0x0000d2f5
    d554:	0000daa1 	.word	0x0000daa1

0000d558 <I2C_ITMasterCplt>:
{
    d558:	b570      	push	{r4, r5, r6, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d55a:	2220      	movs	r2, #32
    d55c:	6803      	ldr	r3, [r0, #0]
{
    d55e:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
    d560:	61da      	str	r2, [r3, #28]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d562:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    d566:	2b21      	cmp	r3, #33	; 0x21
    d568:	f000 80a8 	beq.w	d6bc <I2C_ITMasterCplt+0x164>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d56c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    d570:	2b22      	cmp	r3, #34	; 0x22
    d572:	f000 808d 	beq.w	d690 <I2C_ITMasterCplt+0x138>
  I2C_RESET_CR2(hi2c);
    d576:	6822      	ldr	r2, [r4, #0]
  hi2c->XferISR       = NULL;
    d578:	2500      	movs	r5, #0
  I2C_RESET_CR2(hi2c);
    d57a:	4890      	ldr	r0, [pc, #576]	; (d7bc <I2C_ITMasterCplt+0x264>)
    d57c:	6853      	ldr	r3, [r2, #4]
    d57e:	4003      	ands	r3, r0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d580:	488f      	ldr	r0, [pc, #572]	; (d7c0 <I2C_ITMasterCplt+0x268>)
  I2C_RESET_CR2(hi2c);
    d582:	6053      	str	r3, [r2, #4]
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
    d584:	06cb      	lsls	r3, r1, #27
  hi2c->XferISR       = NULL;
    d586:	6365      	str	r5, [r4, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d588:	62e0      	str	r0, [r4, #44]	; 0x2c
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
    d58a:	d506      	bpl.n	d59a <I2C_ITMasterCplt+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d58c:	6823      	ldr	r3, [r4, #0]
    d58e:	2210      	movs	r2, #16
    d590:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d592:	6c63      	ldr	r3, [r4, #68]	; 0x44
    d594:	f043 0304 	orr.w	r3, r3, #4
    d598:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
    d59a:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d59e:	6823      	ldr	r3, [r4, #0]
    d5a0:	2a60      	cmp	r2, #96	; 0x60
    d5a2:	f000 8086 	beq.w	d6b2 <I2C_ITMasterCplt+0x15a>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d5a6:	699a      	ldr	r2, [r3, #24]
    d5a8:	0795      	lsls	r5, r2, #30
    d5aa:	d502      	bpl.n	d5b2 <I2C_ITMasterCplt+0x5a>
    hi2c->Instance->TXDR = 0x00U;
    d5ac:	2200      	movs	r2, #0
    d5ae:	629a      	str	r2, [r3, #40]	; 0x28
    d5b0:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d5b2:	699a      	ldr	r2, [r3, #24]
    d5b4:	07d0      	lsls	r0, r2, #31
    d5b6:	d403      	bmi.n	d5c0 <I2C_ITMasterCplt+0x68>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d5b8:	699a      	ldr	r2, [r3, #24]
    d5ba:	f042 0201 	orr.w	r2, r2, #1
    d5be:	619a      	str	r2, [r3, #24]
  tmperror = hi2c->ErrorCode;
    d5c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
    d5c2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d5c6:	2a60      	cmp	r2, #96	; 0x60
    d5c8:	d00d      	beq.n	d5e6 <I2C_ITMasterCplt+0x8e>
    d5ca:	3300      	adds	r3, #0
    d5cc:	bf18      	it	ne
    d5ce:	2301      	movne	r3, #1
    d5d0:	b94b      	cbnz	r3, d5e6 <I2C_ITMasterCplt+0x8e>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d5d2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d5d6:	2a21      	cmp	r2, #33	; 0x21
    d5d8:	f000 80ce 	beq.w	d778 <I2C_ITMasterCplt+0x220>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    d5dc:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    d5e0:	2a22      	cmp	r2, #34	; 0x22
    d5e2:	d07c      	beq.n	d6de <I2C_ITMasterCplt+0x186>
}
    d5e4:	bd70      	pop	{r4, r5, r6, pc}
    I2C_ITError(hi2c, hi2c->ErrorCode);
    d5e6:	6c62      	ldr	r2, [r4, #68]	; 0x44
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    d5e8:	2100      	movs	r1, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    d5ea:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d5ee:	4874      	ldr	r0, [pc, #464]	; (d7c0 <I2C_ITMasterCplt+0x268>)
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    d5f0:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    d5f4:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    d5f6:	62e0      	str	r0, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    d5f8:	8561      	strh	r1, [r4, #42]	; 0x2a
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    d5fa:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
    d5fc:	6c60      	ldr	r0, [r4, #68]	; 0x44
    d5fe:	6821      	ldr	r1, [r4, #0]
    d600:	ea42 0200 	orr.w	r2, r2, r0
    d604:	6462      	str	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    d606:	d831      	bhi.n	d66c <I2C_ITMasterCplt+0x114>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d608:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d60c:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d60e:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d612:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d614:	680b      	ldr	r3, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d616:	4030      	ands	r0, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    d618:	4d6a      	ldr	r5, [pc, #424]	; (d7c4 <I2C_ITMasterCplt+0x26c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d61a:	42b2      	cmp	r2, r6
    d61c:	bf14      	ite	ne
    d61e:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
    d622:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d626:	42b0      	cmp	r0, r6
    d628:	bf18      	it	ne
    d62a:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d62e:	4013      	ands	r3, r2
    d630:	600b      	str	r3, [r1, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    d632:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    d636:	6365      	str	r5, [r4, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    d638:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    d63a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    d63c:	b118      	cbz	r0, d646 <I2C_ITMasterCplt+0xee>
    d63e:	2b11      	cmp	r3, #17
    d640:	d05d      	beq.n	d6fe <I2C_ITMasterCplt+0x1a6>
    d642:	2b21      	cmp	r3, #33	; 0x21
    d644:	d05b      	beq.n	d6fe <I2C_ITMasterCplt+0x1a6>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    d646:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    d648:	b118      	cbz	r0, d652 <I2C_ITMasterCplt+0xfa>
    d64a:	2b12      	cmp	r3, #18
    d64c:	d075      	beq.n	d73a <I2C_ITMasterCplt+0x1e2>
    d64e:	2b22      	cmp	r3, #34	; 0x22
    d650:	d073      	beq.n	d73a <I2C_ITMasterCplt+0x1e2>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    d652:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d656:	2b60      	cmp	r3, #96	; 0x60
    d658:	f000 809e 	beq.w	d798 <I2C_ITMasterCplt+0x240>
    hi2c->PreviousState = I2C_STATE_NONE;
    d65c:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    d65e:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
    d660:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    d662:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    d666:	f7ff fbd3 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    d66a:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d66c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d670:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d674:	680b      	ldr	r3, [r1, #0]
    d676:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    d67a:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    d67c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    d680:	2b60      	cmp	r3, #96	; 0x60
    d682:	d002      	beq.n	d68a <I2C_ITMasterCplt+0x132>
      hi2c->State         = HAL_I2C_STATE_READY;
    d684:	2320      	movs	r3, #32
    d686:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d68a:	2300      	movs	r3, #0
    d68c:	6363      	str	r3, [r4, #52]	; 0x34
    d68e:	e7d3      	b.n	d638 <I2C_ITMasterCplt+0xe0>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d690:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d694:	2512      	movs	r5, #18
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d696:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d698:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d69c:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d69e:	2a28      	cmp	r2, #40	; 0x28
    d6a0:	bf14      	ite	ne
    d6a2:	f06f 02f4 	mvnne.w	r2, #244	; 0xf4
    d6a6:	f06f 0244 	mvneq.w	r2, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6aa:	4013      	ands	r3, r2
    d6ac:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d6ae:	6325      	str	r5, [r4, #48]	; 0x30
    d6b0:	e761      	b.n	d576 <I2C_ITMasterCplt+0x1e>
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
    d6b2:	074e      	lsls	r6, r1, #29
    d6b4:	f57f af77 	bpl.w	d5a6 <I2C_ITMasterCplt+0x4e>
    tmp = (uint8_t)hi2c->Instance->RXDR;
    d6b8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    d6ba:	e774      	b.n	d5a6 <I2C_ITMasterCplt+0x4e>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d6bc:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d6c0:	2511      	movs	r5, #17
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6c2:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d6c4:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6c8:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d6ca:	2a28      	cmp	r2, #40	; 0x28
    d6cc:	bf14      	ite	ne
    d6ce:	f06f 02f2 	mvnne.w	r2, #242	; 0xf2
    d6d2:	f06f 0242 	mvneq.w	r2, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d6d6:	4013      	ands	r3, r2
    d6d8:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d6da:	6325      	str	r5, [r4, #48]	; 0x30
    d6dc:	e74b      	b.n	d576 <I2C_ITMasterCplt+0x1e>
    hi2c->State = HAL_I2C_STATE_READY;
    d6de:	2220      	movs	r2, #32
      HAL_I2C_MemRxCpltCallback(hi2c);
    d6e0:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
    d6e2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
    d6e6:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    d6ea:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d6ec:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
    d6f0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d6f4:	2a40      	cmp	r2, #64	; 0x40
    d6f6:	d05d      	beq.n	d7b4 <I2C_ITMasterCplt+0x25c>
      HAL_I2C_MasterRxCpltCallback(hi2c);
    d6f8:	f7ff faec 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
}
    d6fc:	bd70      	pop	{r4, r5, r6, pc}
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    d6fe:	6823      	ldr	r3, [r4, #0]
    d700:	681a      	ldr	r2, [r3, #0]
    d702:	0451      	lsls	r1, r2, #17
    d704:	d504      	bpl.n	d710 <I2C_ITMasterCplt+0x1b8>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    d706:	681a      	ldr	r2, [r3, #0]
    d708:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    d70c:	601a      	str	r2, [r3, #0]
    d70e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    d710:	f7fd fdf8 	bl	b304 <HAL_DMA_GetState>
    d714:	2801      	cmp	r0, #1
    d716:	d09c      	beq.n	d652 <I2C_ITMasterCplt+0xfa>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    d718:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    d71a:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    d71c:	492a      	ldr	r1, [pc, #168]	; (d7c8 <I2C_ITMasterCplt+0x270>)
    d71e:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    d720:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    d724:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    d726:	f7fd fcb3 	bl	b090 <HAL_DMA_Abort_IT>
    d72a:	2800      	cmp	r0, #0
    d72c:	f43f af5a 	beq.w	d5e4 <I2C_ITMasterCplt+0x8c>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    d730:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
    d732:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    d736:	6d03      	ldr	r3, [r0, #80]	; 0x50
    d738:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    d73a:	6823      	ldr	r3, [r4, #0]
    d73c:	681a      	ldr	r2, [r3, #0]
    d73e:	0412      	lsls	r2, r2, #16
    d740:	d504      	bpl.n	d74c <I2C_ITMasterCplt+0x1f4>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    d742:	681a      	ldr	r2, [r3, #0]
    d744:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    d748:	601a      	str	r2, [r3, #0]
    d74a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    d74c:	f7fd fdda 	bl	b304 <HAL_DMA_GetState>
    d750:	2801      	cmp	r0, #1
    d752:	f43f af7e 	beq.w	d652 <I2C_ITMasterCplt+0xfa>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    d756:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    d758:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    d75a:	491b      	ldr	r1, [pc, #108]	; (d7c8 <I2C_ITMasterCplt+0x270>)
    d75c:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    d75e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    d762:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    d764:	f7fd fc94 	bl	b090 <HAL_DMA_Abort_IT>
    d768:	2800      	cmp	r0, #0
    d76a:	f43f af3b 	beq.w	d5e4 <I2C_ITMasterCplt+0x8c>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    d76e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
    d770:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    d774:	6d03      	ldr	r3, [r0, #80]	; 0x50
    d776:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
    d778:	2220      	movs	r2, #32
      HAL_I2C_MemTxCpltCallback(hi2c);
    d77a:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
    d77c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
    d780:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
    d784:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d786:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
    d78a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
    d78e:	2a40      	cmp	r2, #64	; 0x40
    d790:	d00d      	beq.n	d7ae <I2C_ITMasterCplt+0x256>
      HAL_I2C_MasterTxCpltCallback(hi2c);
    d792:	f7ff fa9d 	bl	ccd0 <HAL_I2C_MasterTxCpltCallback>
}
    d796:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
    d798:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    d79a:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    d79c:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
    d79e:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    d7a2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    d7a6:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    d7a8:	f7ff fb34 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    d7ac:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemTxCpltCallback(hi2c);
    d7ae:	f7ff fb2b 	bl	ce08 <HAL_I2C_MemTxCpltCallback>
}
    d7b2:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemRxCpltCallback(hi2c);
    d7b4:	f7ff fb2a 	bl	ce0c <HAL_I2C_MemRxCpltCallback>
}
    d7b8:	bd70      	pop	{r4, r5, r6, pc}
    d7ba:	bf00      	nop
    d7bc:	fe00e800 	.word	0xfe00e800
    d7c0:	ffff0000 	.word	0xffff0000
    d7c4:	0000d14d 	.word	0x0000d14d
    d7c8:	0000ce19 	.word	0x0000ce19

0000d7cc <I2C_Master_ISR_IT>:
  __HAL_LOCK(hi2c);
    d7cc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    d7d0:	2b01      	cmp	r3, #1
    d7d2:	f000 80d8 	beq.w	d986 <I2C_Master_ISR_IT+0x1ba>
    d7d6:	2301      	movs	r3, #1
{
    d7d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d7dc:	06cf      	lsls	r7, r1, #27
{
    d7de:	b082      	sub	sp, #8
    d7e0:	4604      	mov	r4, r0
    d7e2:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
    d7e4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    d7e8:	d51e      	bpl.n	d828 <I2C_Master_ISR_IT+0x5c>
    d7ea:	06d6      	lsls	r6, r2, #27
    d7ec:	d51c      	bpl.n	d828 <I2C_Master_ISR_IT+0x5c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    d7ee:	6803      	ldr	r3, [r0, #0]
    d7f0:	2110      	movs	r1, #16
    d7f2:	61d9      	str	r1, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d7f4:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d7f6:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    d7f8:	f041 0104 	orr.w	r1, r1, #4
    d7fc:	6441      	str	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    d7fe:	6999      	ldr	r1, [r3, #24]
    d800:	0788      	lsls	r0, r1, #30
    d802:	d502      	bpl.n	d80a <I2C_Master_ISR_IT+0x3e>
    hi2c->Instance->TXDR = 0x00U;
    d804:	2100      	movs	r1, #0
    d806:	6299      	str	r1, [r3, #40]	; 0x28
    d808:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    d80a:	6999      	ldr	r1, [r3, #24]
    d80c:	07c9      	lsls	r1, r1, #31
    d80e:	f140 8087 	bpl.w	d920 <I2C_Master_ISR_IT+0x154>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    d812:	06a9      	lsls	r1, r5, #26
    d814:	d502      	bpl.n	d81c <I2C_Master_ISR_IT+0x50>
    d816:	0693      	lsls	r3, r2, #26
    d818:	f100 80b7 	bmi.w	d98a <I2C_Master_ISR_IT+0x1be>
  __HAL_UNLOCK(hi2c);
    d81c:	2000      	movs	r0, #0
    d81e:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d822:	b002      	add	sp, #8
    d824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d828:	076f      	lsls	r7, r5, #29
    d82a:	d408      	bmi.n	d83e <I2C_Master_ISR_IT+0x72>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
    d82c:	07a8      	lsls	r0, r5, #30
    d82e:	d519      	bpl.n	d864 <I2C_Master_ISR_IT+0x98>
    d830:	0791      	lsls	r1, r2, #30
    d832:	d517      	bpl.n	d864 <I2C_Master_ISR_IT+0x98>
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
    d834:	6a61      	ldr	r1, [r4, #36]	; 0x24
    d836:	6823      	ldr	r3, [r4, #0]
    d838:	7809      	ldrb	r1, [r1, #0]
    d83a:	6299      	str	r1, [r3, #40]	; 0x28
    d83c:	e007      	b.n	d84e <I2C_Master_ISR_IT+0x82>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
    d83e:	0756      	lsls	r6, r2, #29
    d840:	d5f4      	bpl.n	d82c <I2C_Master_ISR_IT+0x60>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d842:	6821      	ldr	r1, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
    d844:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
    d848:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d84a:	6a49      	ldr	r1, [r1, #36]	; 0x24
    d84c:	7019      	strb	r1, [r3, #0]
    hi2c->XferCount--;
    d84e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr++;
    d850:	6a60      	ldr	r0, [r4, #36]	; 0x24
    hi2c->XferSize--;
    d852:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
    d854:	3b01      	subs	r3, #1
    hi2c->pBuffPtr++;
    d856:	3001      	adds	r0, #1
    hi2c->XferCount--;
    d858:	b29b      	uxth	r3, r3
    hi2c->XferSize--;
    d85a:	3901      	subs	r1, #1
    hi2c->pBuffPtr++;
    d85c:	6260      	str	r0, [r4, #36]	; 0x24
    hi2c->XferCount--;
    d85e:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferSize--;
    d860:	8521      	strh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
    d862:	e7d6      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    d864:	062b      	lsls	r3, r5, #24
    d866:	d416      	bmi.n	d896 <I2C_Master_ISR_IT+0xca>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    d868:	066e      	lsls	r6, r5, #25
    d86a:	d5d2      	bpl.n	d812 <I2C_Master_ISR_IT+0x46>
    d86c:	0650      	lsls	r0, r2, #25
    d86e:	d5d0      	bpl.n	d812 <I2C_Master_ISR_IT+0x46>
    if (hi2c->XferCount == 0U)
    d870:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d872:	b29b      	uxth	r3, r3
    d874:	2b00      	cmp	r3, #0
    d876:	d17f      	bne.n	d978 <I2C_Master_ISR_IT+0x1ac>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    d878:	6821      	ldr	r1, [r4, #0]
    d87a:	684b      	ldr	r3, [r1, #4]
    d87c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    d880:	d1c7      	bne.n	d812 <I2C_Master_ISR_IT+0x46>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
    d882:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    d884:	f510 3f80 	cmn.w	r0, #65536	; 0x10000
    d888:	f040 80a2 	bne.w	d9d0 <I2C_Master_ISR_IT+0x204>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
    d88c:	684b      	ldr	r3, [r1, #4]
    d88e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    d892:	604b      	str	r3, [r1, #4]
    d894:	e7bd      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    d896:	0657      	lsls	r7, r2, #25
    d898:	d5bb      	bpl.n	d812 <I2C_Master_ISR_IT+0x46>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
    d89a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    d89c:	6821      	ldr	r1, [r4, #0]
    d89e:	b29b      	uxth	r3, r3
    d8a0:	2b00      	cmp	r3, #0
    d8a2:	d042      	beq.n	d92a <I2C_Master_ISR_IT+0x15e>
    d8a4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    d8a6:	2b00      	cmp	r3, #0
    d8a8:	d13f      	bne.n	d92a <I2C_Master_ISR_IT+0x15e>
    d8aa:	4b76      	ldr	r3, [pc, #472]	; (da84 <I2C_Master_ISR_IT+0x2b8>)
    d8ac:	4e76      	ldr	r6, [pc, #472]	; (da88 <I2C_Master_ISR_IT+0x2bc>)
    d8ae:	4877      	ldr	r0, [pc, #476]	; (da8c <I2C_Master_ISR_IT+0x2c0>)
    d8b0:	4299      	cmp	r1, r3
    d8b2:	bf18      	it	ne
    d8b4:	42b1      	cmpne	r1, r6
    d8b6:	4f76      	ldr	r7, [pc, #472]	; (da90 <I2C_Master_ISR_IT+0x2c4>)
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    d8b8:	684e      	ldr	r6, [r1, #4]
    d8ba:	bf14      	ite	ne
    d8bc:	2301      	movne	r3, #1
    d8be:	2300      	moveq	r3, #0
    d8c0:	f3c6 0609 	ubfx	r6, r6, #0, #10
    d8c4:	4281      	cmp	r1, r0
    d8c6:	bf0c      	ite	eq
    d8c8:	2300      	moveq	r3, #0
    d8ca:	f003 0301 	andne.w	r3, r3, #1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    d8ce:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    d8d0:	42b9      	cmp	r1, r7
    d8d2:	bf0c      	ite	eq
    d8d4:	2300      	moveq	r3, #0
    d8d6:	f003 0301 	andne.w	r3, r3, #1
    d8da:	28ff      	cmp	r0, #255	; 0xff
    d8dc:	f200 8099 	bhi.w	da12 <I2C_Master_ISR_IT+0x246>
        hi2c->XferSize = hi2c->XferCount;
    d8e0:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d8e2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
    d8e4:	b280      	uxth	r0, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d8e6:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
    d8ea:	8520      	strh	r0, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
    d8ec:	b2c7      	uxtb	r7, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    d8ee:	f000 809b 	beq.w	da28 <I2C_Master_ISR_IT+0x25c>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
    d8f2:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    d8f6:	2b00      	cmp	r3, #0
    d8f8:	f040 80a1 	bne.w	da3e <I2C_Master_ISR_IT+0x272>
  assert_param(IS_TRANSFER_MODE(Mode));
    d8fc:	f038 7380 	bics.w	r3, r8, #16777216	; 0x1000000
    d900:	d003      	beq.n	d90a <I2C_Master_ISR_IT+0x13e>
    d902:	f1b8 7f00 	cmp.w	r8, #33554432	; 0x2000000
    d906:	f040 80a2 	bne.w	da4e <I2C_Master_ISR_IT+0x282>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    d90a:	6823      	ldr	r3, [r4, #0]
    d90c:	4961      	ldr	r1, [pc, #388]	; (da94 <I2C_Master_ISR_IT+0x2c8>)
    d90e:	6858      	ldr	r0, [r3, #4]
    d910:	4008      	ands	r0, r1
    d912:	ea40 0008 	orr.w	r0, r0, r8
    d916:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    d91a:	4306      	orrs	r6, r0
    d91c:	605e      	str	r6, [r3, #4]
    d91e:	e778      	b.n	d812 <I2C_Master_ISR_IT+0x46>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    d920:	6999      	ldr	r1, [r3, #24]
    d922:	f041 0101 	orr.w	r1, r1, #1
    d926:	6199      	str	r1, [r3, #24]
    d928:	e773      	b.n	d812 <I2C_Master_ISR_IT+0x46>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    d92a:	684b      	ldr	r3, [r1, #4]
    d92c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    d930:	d122      	bne.n	d978 <I2C_Master_ISR_IT+0x1ac>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d932:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    d936:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d938:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    d93c:	9201      	str	r2, [sp, #4]
    d93e:	2821      	cmp	r0, #33	; 0x21
    d940:	d02d      	beq.n	d99e <I2C_Master_ISR_IT+0x1d2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d942:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    d944:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d948:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    d94a:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d94c:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d94e:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d952:	f8d1 c000 	ldr.w	ip, [r1]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d956:	f007 0728 	and.w	r7, r7, #40	; 0x28
    d95a:	2f28      	cmp	r7, #40	; 0x28
    d95c:	bf14      	ite	ne
    d95e:	f06f 06f4 	mvnne.w	r6, #244	; 0xf4
    d962:	f06f 0644 	mvneq.w	r6, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d966:	ea06 060c 	and.w	r6, r6, ip
    d96a:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    d96c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    d970:	f7ff f9b0 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    d974:	9a01      	ldr	r2, [sp, #4]
    d976:	e74c      	b.n	d812 <I2C_Master_ISR_IT+0x46>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
    d978:	2140      	movs	r1, #64	; 0x40
    d97a:	4620      	mov	r0, r4
    d97c:	9201      	str	r2, [sp, #4]
    d97e:	f7ff fa6d 	bl	ce5c <I2C_ITError>
    d982:	9a01      	ldr	r2, [sp, #4]
    d984:	e745      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  __HAL_LOCK(hi2c);
    d986:	2002      	movs	r0, #2
}
    d988:	4770      	bx	lr
    I2C_ITMasterCplt(hi2c, tmpITFlags);
    d98a:	4620      	mov	r0, r4
    d98c:	4629      	mov	r1, r5
    d98e:	f7ff fde3 	bl	d558 <I2C_ITMasterCplt>
  __HAL_UNLOCK(hi2c);
    d992:	2000      	movs	r0, #0
    d994:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    d998:	b002      	add	sp, #8
    d99a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d99e:	2611      	movs	r6, #17
    hi2c->State         = HAL_I2C_STATE_READY;
    d9a0:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d9a4:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
    d9a6:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    d9a8:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9aa:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d9ae:	680f      	ldr	r7, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9b0:	f006 0628 	and.w	r6, r6, #40	; 0x28
    d9b4:	2e28      	cmp	r6, #40	; 0x28
    d9b6:	bf14      	ite	ne
    d9b8:	f06f 06f2 	mvnne.w	r6, #242	; 0xf2
    d9bc:	f06f 0642 	mvneq.w	r6, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d9c0:	403e      	ands	r6, r7
    d9c2:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    d9c4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
    d9c8:	f7ff f982 	bl	ccd0 <HAL_I2C_MasterTxCpltCallback>
    d9cc:	9a01      	ldr	r2, [sp, #4]
    d9ce:	e720      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    d9d0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    d9d4:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    d9d6:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
    d9da:	9201      	str	r2, [sp, #4]
    d9dc:	2821      	cmp	r0, #33	; 0x21
    d9de:	d0de      	beq.n	d99e <I2C_Master_ISR_IT+0x1d2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d9e0:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    d9e2:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    d9e6:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    d9e8:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    d9ea:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9ec:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    d9f0:	680e      	ldr	r6, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    d9f2:	f007 0728 	and.w	r7, r7, #40	; 0x28
    d9f6:	2f28      	cmp	r7, #40	; 0x28
    d9f8:	bf14      	ite	ne
    d9fa:	f06f 07f4 	mvnne.w	r7, #244	; 0xf4
    d9fe:	f06f 0744 	mvneq.w	r7, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    da02:	403e      	ands	r6, r7
    da04:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
    da06:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    da0a:	f7ff f963 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    da0e:	9a01      	ldr	r2, [sp, #4]
    da10:	e6ff      	b.n	d812 <I2C_Master_ISR_IT+0x46>
        hi2c->XferSize = MAX_NBYTE_SIZE;
    da12:	20ff      	movs	r0, #255	; 0xff
    da14:	8520      	strh	r0, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da16:	bb13      	cbnz	r3, da5e <I2C_Master_ISR_IT+0x292>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    da18:	684b      	ldr	r3, [r1, #4]
    da1a:	4f1e      	ldr	r7, [pc, #120]	; (da94 <I2C_Master_ISR_IT+0x2c8>)
    da1c:	481e      	ldr	r0, [pc, #120]	; (da98 <I2C_Master_ISR_IT+0x2cc>)
    da1e:	403b      	ands	r3, r7
    da20:	4330      	orrs	r0, r6
    da22:	4303      	orrs	r3, r0
    da24:	604b      	str	r3, [r1, #4]
    da26:	e6f4      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da28:	bb13      	cbnz	r3, da70 <I2C_Master_ISR_IT+0x2a4>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    da2a:	ea46 4307 	orr.w	r3, r6, r7, lsl #16
    da2e:	6848      	ldr	r0, [r1, #4]
    da30:	4e18      	ldr	r6, [pc, #96]	; (da94 <I2C_Master_ISR_IT+0x2c8>)
    da32:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    da36:	4030      	ands	r0, r6
    da38:	4303      	orrs	r3, r0
    da3a:	604b      	str	r3, [r1, #4]
    da3c:	e6e9      	b.n	d812 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da3e:	f641 1131 	movw	r1, #6449	; 0x1931
    da42:	4816      	ldr	r0, [pc, #88]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da44:	9201      	str	r2, [sp, #4]
    da46:	f00b fd3b 	bl	194c0 <assert_failed>
    da4a:	9a01      	ldr	r2, [sp, #4]
    da4c:	e756      	b.n	d8fc <I2C_Master_ISR_IT+0x130>
  assert_param(IS_TRANSFER_MODE(Mode));
    da4e:	f641 1132 	movw	r1, #6450	; 0x1932
    da52:	4812      	ldr	r0, [pc, #72]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da54:	9201      	str	r2, [sp, #4]
    da56:	f00b fd33 	bl	194c0 <assert_failed>
    da5a:	9a01      	ldr	r2, [sp, #4]
    da5c:	e755      	b.n	d90a <I2C_Master_ISR_IT+0x13e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    da5e:	f641 1131 	movw	r1, #6449	; 0x1931
    da62:	480e      	ldr	r0, [pc, #56]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da64:	9201      	str	r2, [sp, #4]
    da66:	f00b fd2b 	bl	194c0 <assert_failed>
    da6a:	6821      	ldr	r1, [r4, #0]
    da6c:	9a01      	ldr	r2, [sp, #4]
    da6e:	e7d3      	b.n	da18 <I2C_Master_ISR_IT+0x24c>
    da70:	f641 1131 	movw	r1, #6449	; 0x1931
    da74:	4809      	ldr	r0, [pc, #36]	; (da9c <I2C_Master_ISR_IT+0x2d0>)
    da76:	9201      	str	r2, [sp, #4]
    da78:	f00b fd22 	bl	194c0 <assert_failed>
    da7c:	6821      	ldr	r1, [r4, #0]
    da7e:	9a01      	ldr	r2, [sp, #4]
    da80:	e7d3      	b.n	da2a <I2C_Master_ISR_IT+0x25e>
    da82:	bf00      	nop
    da84:	40005400 	.word	0x40005400
    da88:	40005800 	.word	0x40005800
    da8c:	40005c00 	.word	0x40005c00
    da90:	58001c00 	.word	0x58001c00
    da94:	fc009c00 	.word	0xfc009c00
    da98:	01ff0000 	.word	0x01ff0000
    da9c:	000300f8 	.word	0x000300f8

0000daa0 <I2C_Master_ISR_DMA>:
  __HAL_LOCK(hi2c);
    daa0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    daa4:	2b01      	cmp	r3, #1
    daa6:	f000 80a8 	beq.w	dbfa <I2C_Master_ISR_DMA+0x15a>
    daaa:	2301      	movs	r3, #1
{
    daac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dab0:	06cd      	lsls	r5, r1, #27
    dab2:	4604      	mov	r4, r0
  __HAL_LOCK(hi2c);
    dab4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
    dab8:	d529      	bpl.n	db0e <I2C_Master_ISR_DMA+0x6e>
    daba:	06d0      	lsls	r0, r2, #27
    dabc:	d527      	bpl.n	db0e <I2C_Master_ISR_DMA+0x6e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dabe:	6823      	ldr	r3, [r4, #0]
    dac0:	2210      	movs	r2, #16
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dac2:	4998      	ldr	r1, [pc, #608]	; (dd24 <I2C_Master_ISR_DMA+0x284>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
    dac4:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    dac6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dac8:	6b62      	ldr	r2, [r4, #52]	; 0x34
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    daca:	f043 0304 	orr.w	r3, r3, #4
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dace:	428a      	cmp	r2, r1
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    dad0:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dad2:	f000 8090 	beq.w	dbf6 <I2C_Master_ISR_DMA+0x156>
    dad6:	4b94      	ldr	r3, [pc, #592]	; (dd28 <I2C_Master_ISR_DMA+0x288>)
    dad8:	429a      	cmp	r2, r3
    dada:	f000 808c 	beq.w	dbf6 <I2C_Master_ISR_DMA+0x156>
      tmpisr |= I2C_IT_STOPI;
    dade:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
    dae0:	6822      	ldr	r2, [r4, #0]
    dae2:	6813      	ldr	r3, [r2, #0]
    dae4:	430b      	orrs	r3, r1
    dae6:	6013      	str	r3, [r2, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
    dae8:	6823      	ldr	r3, [r4, #0]
    daea:	699a      	ldr	r2, [r3, #24]
    daec:	0791      	lsls	r1, r2, #30
    daee:	d502      	bpl.n	daf6 <I2C_Master_ISR_DMA+0x56>
    hi2c->Instance->TXDR = 0x00U;
    daf0:	2200      	movs	r2, #0
    daf2:	629a      	str	r2, [r3, #40]	; 0x28
    daf4:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
    daf6:	699a      	ldr	r2, [r3, #24]
    daf8:	07d2      	lsls	r2, r2, #31
    dafa:	d403      	bmi.n	db04 <I2C_Master_ISR_DMA+0x64>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
    dafc:	699a      	ldr	r2, [r3, #24]
    dafe:	f042 0201 	orr.w	r2, r2, #1
    db02:	619a      	str	r2, [r3, #24]
  __HAL_UNLOCK(hi2c);
    db04:	2000      	movs	r0, #0
    db06:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
    db0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    db0e:	060f      	lsls	r7, r1, #24
    db10:	d553      	bpl.n	dbba <I2C_Master_ISR_DMA+0x11a>
    db12:	0656      	lsls	r6, r2, #25
    db14:	d567      	bpl.n	dbe6 <I2C_Master_ISR_DMA+0x146>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
    db16:	6822      	ldr	r2, [r4, #0]
    db18:	6813      	ldr	r3, [r2, #0]
    db1a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    db1e:	6013      	str	r3, [r2, #0]
    if (hi2c->XferCount != 0U)
    db20:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    db22:	6822      	ldr	r2, [r4, #0]
    if (hi2c->XferCount != 0U)
    db24:	b29b      	uxth	r3, r3
    db26:	2b00      	cmp	r3, #0
    db28:	d069      	beq.n	dbfe <I2C_Master_ISR_DMA+0x15e>
    db2a:	4980      	ldr	r1, [pc, #512]	; (dd2c <I2C_Master_ISR_DMA+0x28c>)
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    db2c:	4610      	mov	r0, r2
    db2e:	4e80      	ldr	r6, [pc, #512]	; (dd30 <I2C_Master_ISR_DMA+0x290>)
    db30:	6855      	ldr	r5, [r2, #4]
    db32:	42b2      	cmp	r2, r6
    db34:	bf18      	it	ne
    db36:	428a      	cmpne	r2, r1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    db38:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
    db3a:	f3c5 0609 	ubfx	r6, r5, #0, #10
    db3e:	bf14      	ite	ne
    db40:	2101      	movne	r1, #1
    db42:	2100      	moveq	r1, #0
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
    db44:	2bff      	cmp	r3, #255	; 0xff
    db46:	f200 8082 	bhi.w	dc4e <I2C_Master_ISR_DMA+0x1ae>
        hi2c->XferSize = hi2c->XferCount;
    db4a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    db4c:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
    db4e:	b29b      	uxth	r3, r3
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    db50:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
    db54:	8523      	strh	r3, [r4, #40]	; 0x28
    db56:	b2db      	uxtb	r3, r3
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
    db58:	f000 80c6 	beq.w	dce8 <I2C_Master_ISR_DMA+0x248>
          xfermode = hi2c->XferOptions;
    db5c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    db5e:	041d      	lsls	r5, r3, #16
    db60:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    db64:	2900      	cmp	r1, #0
    db66:	f040 80ca 	bne.w	dcfe <I2C_Master_ISR_DMA+0x25e>
    db6a:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    db6e:	bf18      	it	ne
    db70:	f1b8 0f00 	cmpne.w	r8, #0
    db74:	bf14      	ite	ne
    db76:	f04f 0801 	movne.w	r8, #1
    db7a:	f04f 0800 	moveq.w	r8, #0
  assert_param(IS_TRANSFER_MODE(Mode));
    db7e:	f1b8 0f00 	cmp.w	r8, #0
    db82:	f040 80b5 	bne.w	dcf0 <I2C_Master_ISR_DMA+0x250>
    db86:	6822      	ldr	r2, [r4, #0]
    db88:	4610      	mov	r0, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
    db8a:	6843      	ldr	r3, [r0, #4]
    db8c:	433d      	orrs	r5, r7
    db8e:	4a69      	ldr	r2, [pc, #420]	; (dd34 <I2C_Master_ISR_DMA+0x294>)
    db90:	4335      	orrs	r5, r6
    db92:	4013      	ands	r3, r2
    db94:	431d      	orrs	r5, r3
    db96:	6045      	str	r5, [r0, #4]
      hi2c->XferCount -= hi2c->XferSize;
    db98:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    db9a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    db9c:	1a9b      	subs	r3, r3, r2
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
    db9e:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
    dba0:	b29b      	uxth	r3, r3
    dba2:	8563      	strh	r3, [r4, #42]	; 0x2a
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
    dba4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dba8:	2b22      	cmp	r3, #34	; 0x22
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
    dbaa:	6813      	ldr	r3, [r2, #0]
    dbac:	bf0c      	ite	eq
    dbae:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
    dbb2:	f443 4380 	orrne.w	r3, r3, #16384	; 0x4000
    dbb6:	6013      	str	r3, [r2, #0]
    dbb8:	e7a4      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
    dbba:	064d      	lsls	r5, r1, #25
    dbbc:	d513      	bpl.n	dbe6 <I2C_Master_ISR_DMA+0x146>
    dbbe:	0650      	lsls	r0, r2, #25
    dbc0:	d511      	bpl.n	dbe6 <I2C_Master_ISR_DMA+0x146>
    if (hi2c->XferCount == 0U)
    dbc2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    dbc4:	b29b      	uxth	r3, r3
    dbc6:	2b00      	cmp	r3, #0
    dbc8:	d13c      	bne.n	dc44 <I2C_Master_ISR_DMA+0x1a4>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    dbca:	6822      	ldr	r2, [r4, #0]
    dbcc:	6853      	ldr	r3, [r2, #4]
    dbce:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    dbd2:	d197      	bne.n	db04 <I2C_Master_ISR_DMA+0x64>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
    dbd4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    dbd6:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
    dbda:	d166      	bne.n	dcaa <I2C_Master_ISR_DMA+0x20a>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
    dbdc:	6853      	ldr	r3, [r2, #4]
    dbde:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    dbe2:	6053      	str	r3, [r2, #4]
    dbe4:	e78e      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
    dbe6:	068b      	lsls	r3, r1, #26
    dbe8:	d58c      	bpl.n	db04 <I2C_Master_ISR_DMA+0x64>
    dbea:	0692      	lsls	r2, r2, #26
    dbec:	d58a      	bpl.n	db04 <I2C_Master_ISR_DMA+0x64>
    I2C_ITMasterCplt(hi2c, ITFlags);
    dbee:	4620      	mov	r0, r4
    dbf0:	f7ff fcb2 	bl	d558 <I2C_ITMasterCplt>
    dbf4:	e786      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
    dbf6:	2160      	movs	r1, #96	; 0x60
    dbf8:	e772      	b.n	dae0 <I2C_Master_ISR_DMA+0x40>
  __HAL_LOCK(hi2c);
    dbfa:	2002      	movs	r0, #2
}
    dbfc:	4770      	bx	lr
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
    dbfe:	6853      	ldr	r3, [r2, #4]
    dc00:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
    dc04:	d11e      	bne.n	dc44 <I2C_Master_ISR_DMA+0x1a4>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    dc06:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    dc0a:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    dc0c:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    dc10:	2921      	cmp	r1, #33	; 0x21
    dc12:	d032      	beq.n	dc7a <I2C_Master_ISR_DMA+0x1da>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dc14:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    dc16:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    dc1a:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dc1c:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dc1e:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc20:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc24:	6816      	ldr	r6, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc26:	f005 0528 	and.w	r5, r5, #40	; 0x28
    dc2a:	2d28      	cmp	r5, #40	; 0x28
    dc2c:	bf14      	ite	ne
    dc2e:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    dc32:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc36:	4031      	ands	r1, r6
    dc38:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    dc3a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dc3e:	f7ff f849 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    dc42:	e75f      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
    dc44:	2140      	movs	r1, #64	; 0x40
    dc46:	4620      	mov	r0, r4
    dc48:	f7ff f908 	bl	ce5c <I2C_ITError>
    dc4c:	e75a      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
        hi2c->XferSize = MAX_NBYTE_SIZE;
    dc4e:	23ff      	movs	r3, #255	; 0xff
    dc50:	f44f 057f 	mov.w	r5, #16711680	; 0xff0000
        xfermode = I2C_RELOAD_MODE;
    dc54:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
        hi2c->XferSize = MAX_NBYTE_SIZE;
    dc58:	8523      	strh	r3, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    dc5a:	2900      	cmp	r1, #0
    dc5c:	d095      	beq.n	db8a <I2C_Master_ISR_DMA+0xea>
    dc5e:	4b36      	ldr	r3, [pc, #216]	; (dd38 <I2C_Master_ISR_DMA+0x298>)
    dc60:	429a      	cmp	r2, r3
    dc62:	d091      	beq.n	db88 <I2C_Master_ISR_DMA+0xe8>
    dc64:	4b35      	ldr	r3, [pc, #212]	; (dd3c <I2C_Master_ISR_DMA+0x29c>)
    dc66:	429a      	cmp	r2, r3
    dc68:	d08e      	beq.n	db88 <I2C_Master_ISR_DMA+0xe8>
    dc6a:	f04f 0800 	mov.w	r8, #0
    dc6e:	f641 1131 	movw	r1, #6449	; 0x1931
    dc72:	4833      	ldr	r0, [pc, #204]	; (dd40 <I2C_Master_ISR_DMA+0x2a0>)
    dc74:	f00b fc24 	bl	194c0 <assert_failed>
    dc78:	e781      	b.n	db7e <I2C_Master_ISR_DMA+0xde>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    dc7a:	2111      	movs	r1, #17
    hi2c->State         = HAL_I2C_STATE_READY;
    dc7c:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    dc80:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
    dc82:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
    dc84:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc86:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc8a:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dc8c:	f001 0128 	and.w	r1, r1, #40	; 0x28
    dc90:	2928      	cmp	r1, #40	; 0x28
    dc92:	bf14      	ite	ne
    dc94:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
    dc98:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dc9c:	4029      	ands	r1, r5
    dc9e:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    dca0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
    dca4:	f7ff f814 	bl	ccd0 <HAL_I2C_MasterTxCpltCallback>
    dca8:	e72c      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
  hi2c->Mode = HAL_I2C_MODE_NONE;
    dcaa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
    dcae:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
    dcb0:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
    dcb4:	2921      	cmp	r1, #33	; 0x21
    dcb6:	d0e0      	beq.n	dc7a <I2C_Master_ISR_DMA+0x1da>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dcb8:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
    dcba:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
    dcbe:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dcc0:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
    dcc2:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dcc4:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dcc8:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dcca:	f001 0128 	and.w	r1, r1, #40	; 0x28
    dcce:	2928      	cmp	r1, #40	; 0x28
    dcd0:	bf14      	ite	ne
    dcd2:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
    dcd6:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dcda:	4029      	ands	r1, r5
    dcdc:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
    dcde:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
    dce2:	f7fe fff7 	bl	ccd4 <HAL_I2C_MasterRxCpltCallback>
    dce6:	e70d      	b.n	db04 <I2C_Master_ISR_DMA+0x64>
          xfermode = I2C_AUTOEND_MODE;
    dce8:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
    dcec:	041d      	lsls	r5, r3, #16
    dcee:	e7b4      	b.n	dc5a <I2C_Master_ISR_DMA+0x1ba>
  assert_param(IS_TRANSFER_MODE(Mode));
    dcf0:	4813      	ldr	r0, [pc, #76]	; (dd40 <I2C_Master_ISR_DMA+0x2a0>)
    dcf2:	f641 1132 	movw	r1, #6450	; 0x1932
    dcf6:	f00b fbe3 	bl	194c0 <assert_failed>
    dcfa:	6820      	ldr	r0, [r4, #0]
    dcfc:	e745      	b.n	db8a <I2C_Master_ISR_DMA+0xea>
    dcfe:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
    dd02:	bf18      	it	ne
    dd04:	f1b8 0f00 	cmpne.w	r8, #0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    dd08:	4b0b      	ldr	r3, [pc, #44]	; (dd38 <I2C_Master_ISR_DMA+0x298>)
    dd0a:	bf14      	ite	ne
    dd0c:	f04f 0801 	movne.w	r8, #1
    dd10:	f04f 0800 	moveq.w	r8, #0
    dd14:	429a      	cmp	r2, r3
    dd16:	f43f af32 	beq.w	db7e <I2C_Master_ISR_DMA+0xde>
    dd1a:	4b08      	ldr	r3, [pc, #32]	; (dd3c <I2C_Master_ISR_DMA+0x29c>)
    dd1c:	429a      	cmp	r2, r3
    dd1e:	d1a6      	bne.n	dc6e <I2C_Master_ISR_DMA+0x1ce>
    dd20:	e72d      	b.n	db7e <I2C_Master_ISR_DMA+0xde>
    dd22:	bf00      	nop
    dd24:	0000d2f5 	.word	0x0000d2f5
    dd28:	0000daa1 	.word	0x0000daa1
    dd2c:	40005800 	.word	0x40005800
    dd30:	40005400 	.word	0x40005400
    dd34:	fc009c00 	.word	0xfc009c00
    dd38:	58001c00 	.word	0x58001c00
    dd3c:	40005c00 	.word	0x40005c00
    dd40:	000300f8 	.word	0x000300f8

0000dd44 <I2C_DMAError>:
{
    dd44:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
    dd46:	6b85      	ldr	r5, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
    dd48:	6bac      	ldr	r4, [r5, #56]	; 0x38
    dd4a:	b124      	cbz	r4, dd56 <I2C_DMAError+0x12>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
    dd4c:	6822      	ldr	r2, [r4, #0]
    dd4e:	6854      	ldr	r4, [r2, #4]
    dd50:	fab4 f484 	clz	r4, r4
    dd54:	0964      	lsrs	r4, r4, #5
  if (hi2c->hdmarx != NULL)
    dd56:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    dd58:	2b00      	cmp	r3, #0
    dd5a:	d049      	beq.n	ddf0 <I2C_DMAError+0xac>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
    dd5c:	681a      	ldr	r2, [r3, #0]
    dd5e:	6853      	ldr	r3, [r2, #4]
    dd60:	fab3 f383 	clz	r3, r3
    dd64:	095b      	lsrs	r3, r3, #5
    dd66:	2b00      	cmp	r3, #0
    dd68:	d042      	beq.n	ddf0 <I2C_DMAError+0xac>
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
    dd6a:	f7fd facf 	bl	b30c <HAL_DMA_GetError>
    dd6e:	2802      	cmp	r0, #2
    dd70:	d03d      	beq.n	ddee <I2C_DMAError+0xaa>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    dd72:	6829      	ldr	r1, [r5, #0]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    dd74:	2200      	movs	r2, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    dd76:	4852      	ldr	r0, [pc, #328]	; (dec0 <I2C_DMAError+0x17c>)
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
    dd78:	684b      	ldr	r3, [r1, #4]
    dd7a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    dd7e:	604b      	str	r3, [r1, #4]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
    dd80:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
    dd84:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    dd88:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
    dd8a:	62e8      	str	r0, [r5, #44]	; 0x2c
  hi2c->XferCount     = 0U;
    dd8c:	856a      	strh	r2, [r5, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
    dd8e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    dd90:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
    dd92:	f042 0210 	orr.w	r2, r2, #16
    dd96:	646a      	str	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
    dd98:	d931      	bls.n	ddfe <I2C_DMAError+0xba>
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dd9a:	682a      	ldr	r2, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dd9c:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    dda0:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    dda4:	6813      	ldr	r3, [r2, #0]
    dda6:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
    ddaa:	6013      	str	r3, [r2, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
    ddac:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    ddb0:	2b60      	cmp	r3, #96	; 0x60
    ddb2:	d002      	beq.n	ddba <I2C_DMAError+0x76>
      hi2c->State         = HAL_I2C_STATE_READY;
    ddb4:	2320      	movs	r3, #32
    ddb6:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
    hi2c->XferISR       = NULL;
    ddba:	2300      	movs	r3, #0
    ddbc:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ddbe:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
    ddc0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
    ddc2:	b118      	cbz	r0, ddcc <I2C_DMAError+0x88>
    ddc4:	2b11      	cmp	r3, #17
    ddc6:	d034      	beq.n	de32 <I2C_DMAError+0xee>
    ddc8:	2b21      	cmp	r3, #33	; 0x21
    ddca:	d032      	beq.n	de32 <I2C_DMAError+0xee>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
    ddcc:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    ddce:	b118      	cbz	r0, ddd8 <I2C_DMAError+0x94>
    ddd0:	2b12      	cmp	r3, #18
    ddd2:	d046      	beq.n	de62 <I2C_DMAError+0x11e>
    ddd4:	2b22      	cmp	r3, #34	; 0x22
    ddd6:	d044      	beq.n	de62 <I2C_DMAError+0x11e>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
    ddd8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    dddc:	2b60      	cmp	r3, #96	; 0x60
    ddde:	d063      	beq.n	dea8 <I2C_DMAError+0x164>
    hi2c->PreviousState = I2C_STATE_NONE;
    dde0:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
    dde2:	4628      	mov	r0, r5
    hi2c->PreviousState = I2C_STATE_NONE;
    dde4:	632b      	str	r3, [r5, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
    dde6:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
    ddea:	f7ff f811 	bl	ce10 <HAL_I2C_ErrorCallback>
}
    ddee:	bd70      	pop	{r4, r5, r6, pc}
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
    ddf0:	f7fd fa8c 	bl	b30c <HAL_DMA_GetError>
    ddf4:	2802      	cmp	r0, #2
    ddf6:	d0fa      	beq.n	ddee <I2C_DMAError+0xaa>
    ddf8:	07e0      	lsls	r0, r4, #31
    ddfa:	d4ba      	bmi.n	dd72 <I2C_DMAError+0x2e>
}
    ddfc:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    ddfe:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    de02:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de04:	f895 1041 	ldrb.w	r1, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de08:	4033      	ands	r3, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de0a:	6828      	ldr	r0, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de0c:	4031      	ands	r1, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    de0e:	4c2d      	ldr	r4, [pc, #180]	; (dec4 <I2C_DMAError+0x180>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de10:	42b3      	cmp	r3, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de12:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de14:	bf14      	ite	ne
    de16:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
    de1a:	f06f 0246 	mvneq.w	r2, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
    de1e:	42b1      	cmp	r1, r6
    de20:	bf18      	it	ne
    de22:	f06f 02f6 	mvnne.w	r2, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
    de26:	4013      	ands	r3, r2
    de28:	6003      	str	r3, [r0, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
    de2a:	f885 6041 	strb.w	r6, [r5, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
    de2e:	636c      	str	r4, [r5, #52]	; 0x34
    de30:	e7c5      	b.n	ddbe <I2C_DMAError+0x7a>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
    de32:	682b      	ldr	r3, [r5, #0]
    de34:	681a      	ldr	r2, [r3, #0]
    de36:	0451      	lsls	r1, r2, #17
    de38:	d430      	bmi.n	de9c <I2C_DMAError+0x158>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
    de3a:	f7fd fa63 	bl	b304 <HAL_DMA_GetState>
    de3e:	2801      	cmp	r0, #1
    de40:	d0ca      	beq.n	ddd8 <I2C_DMAError+0x94>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    de42:	6baa      	ldr	r2, [r5, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
    de44:	2300      	movs	r3, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
    de46:	4920      	ldr	r1, [pc, #128]	; (dec8 <I2C_DMAError+0x184>)
    de48:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    de4a:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
    de4e:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    de50:	f7fd f91e 	bl	b090 <HAL_DMA_Abort_IT>
    de54:	2800      	cmp	r0, #0
    de56:	d0ca      	beq.n	ddee <I2C_DMAError+0xaa>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    de58:	6ba8      	ldr	r0, [r5, #56]	; 0x38
}
    de5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
    de5e:	6d03      	ldr	r3, [r0, #80]	; 0x50
    de60:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
    de62:	682b      	ldr	r3, [r5, #0]
    de64:	681a      	ldr	r2, [r3, #0]
    de66:	0412      	lsls	r2, r2, #16
    de68:	d504      	bpl.n	de74 <I2C_DMAError+0x130>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
    de6a:	681a      	ldr	r2, [r3, #0]
    de6c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    de70:	601a      	str	r2, [r3, #0]
    de72:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
    de74:	f7fd fa46 	bl	b304 <HAL_DMA_GetState>
    de78:	2801      	cmp	r0, #1
    de7a:	d0ad      	beq.n	ddd8 <I2C_DMAError+0x94>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    de7c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
    de7e:	2300      	movs	r3, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
    de80:	4911      	ldr	r1, [pc, #68]	; (dec8 <I2C_DMAError+0x184>)
    de82:	6511      	str	r1, [r2, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
    de84:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
    de88:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    de8a:	f7fd f901 	bl	b090 <HAL_DMA_Abort_IT>
    de8e:	2800      	cmp	r0, #0
    de90:	d0ad      	beq.n	ddee <I2C_DMAError+0xaa>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    de92:	6be8      	ldr	r0, [r5, #60]	; 0x3c
}
    de94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
    de98:	6d03      	ldr	r3, [r0, #80]	; 0x50
    de9a:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
    de9c:	681a      	ldr	r2, [r3, #0]
    de9e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    dea2:	601a      	str	r2, [r3, #0]
    dea4:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    dea6:	e7c8      	b.n	de3a <I2C_DMAError+0xf6>
    hi2c->PreviousState = I2C_STATE_NONE;
    dea8:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
    deaa:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
    deac:	4628      	mov	r0, r5
    hi2c->State = HAL_I2C_STATE_READY;
    deae:	f885 2041 	strb.w	r2, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    deb2:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    deb6:	632b      	str	r3, [r5, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
    deb8:	f7fe ffac 	bl	ce14 <HAL_I2C_AbortCpltCallback>
}
    debc:	bd70      	pop	{r4, r5, r6, pc}
    debe:	bf00      	nop
    dec0:	ffff0000 	.word	0xffff0000
    dec4:	0000d14d 	.word	0x0000d14d
    dec8:	0000ce19 	.word	0x0000ce19

0000decc <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
    decc:	b570      	push	{r4, r5, r6, lr}
    dece:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ded0:	4b25      	ldr	r3, [pc, #148]	; (df68 <HAL_I2CEx_ConfigAnalogFilter+0x9c>)
    ded2:	4826      	ldr	r0, [pc, #152]	; (df6c <HAL_I2CEx_ConfigAnalogFilter+0xa0>)
{
    ded4:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    ded6:	6822      	ldr	r2, [r4, #0]
    ded8:	4925      	ldr	r1, [pc, #148]	; (df70 <HAL_I2CEx_ConfigAnalogFilter+0xa4>)
    deda:	429a      	cmp	r2, r3
    dedc:	bf18      	it	ne
    dede:	4282      	cmpne	r2, r0
    dee0:	bf14      	ite	ne
    dee2:	2301      	movne	r3, #1
    dee4:	2300      	moveq	r3, #0
    dee6:	428a      	cmp	r2, r1
    dee8:	bf0c      	ite	eq
    deea:	2300      	moveq	r3, #0
    deec:	f003 0301 	andne.w	r3, r3, #1
    def0:	b113      	cbz	r3, def8 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
    def2:	4b20      	ldr	r3, [pc, #128]	; (df74 <HAL_I2CEx_ConfigAnalogFilter+0xa8>)
    def4:	429a      	cmp	r2, r3
    def6:	d132      	bne.n	df5e <HAL_I2CEx_ConfigAnalogFilter+0x92>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
    def8:	f435 5380 	bics.w	r3, r5, #4096	; 0x1000
    defc:	d12a      	bne.n	df54 <HAL_I2CEx_ConfigAnalogFilter+0x88>

  if (hi2c->State == HAL_I2C_STATE_READY)
    defe:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    df02:	b2db      	uxtb	r3, r3
    df04:	2b20      	cmp	r3, #32
    df06:	d123      	bne.n	df50 <HAL_I2CEx_ConfigAnalogFilter+0x84>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    df08:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
    df0c:	2a01      	cmp	r2, #1
    df0e:	d01f      	beq.n	df50 <HAL_I2CEx_ConfigAnalogFilter+0x84>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    df10:	6826      	ldr	r6, [r4, #0]
    __HAL_LOCK(hi2c);
    df12:	2101      	movs	r1, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
    df14:	2224      	movs	r2, #36	; 0x24
    __HAL_LOCK(hi2c);
    df16:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    df1a:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
    df1c:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
    df20:	6832      	ldr	r2, [r6, #0]

    return HAL_OK;
    df22:	4608      	mov	r0, r1
    __HAL_I2C_DISABLE(hi2c);
    df24:	f022 0201 	bic.w	r2, r2, #1
    df28:	6032      	str	r2, [r6, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
    df2a:	6826      	ldr	r6, [r4, #0]
    df2c:	6832      	ldr	r2, [r6, #0]
    df2e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    df32:	6032      	str	r2, [r6, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
    df34:	6826      	ldr	r6, [r4, #0]
    df36:	6832      	ldr	r2, [r6, #0]
    df38:	4315      	orrs	r5, r2
    df3a:	6035      	str	r5, [r6, #0]
    __HAL_I2C_ENABLE(hi2c);
    df3c:	6825      	ldr	r5, [r4, #0]
    df3e:	682a      	ldr	r2, [r5, #0]
    df40:	f042 0201 	orr.w	r2, r2, #1
    df44:	602a      	str	r2, [r5, #0]
    hi2c->State = HAL_I2C_STATE_READY;
    df46:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    df4a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
    df4e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
    df50:	2002      	movs	r0, #2
}
    df52:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
    df54:	2165      	movs	r1, #101	; 0x65
    df56:	4808      	ldr	r0, [pc, #32]	; (df78 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
    df58:	f00b fab2 	bl	194c0 <assert_failed>
    df5c:	e7cf      	b.n	defe <HAL_I2CEx_ConfigAnalogFilter+0x32>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    df5e:	2164      	movs	r1, #100	; 0x64
    df60:	4805      	ldr	r0, [pc, #20]	; (df78 <HAL_I2CEx_ConfigAnalogFilter+0xac>)
    df62:	f00b faad 	bl	194c0 <assert_failed>
    df66:	e7c7      	b.n	def8 <HAL_I2CEx_ConfigAnalogFilter+0x2c>
    df68:	40005400 	.word	0x40005400
    df6c:	40005800 	.word	0x40005800
    df70:	40005c00 	.word	0x40005c00
    df74:	58001c00 	.word	0x58001c00
    df78:	00030130 	.word	0x00030130

0000df7c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
    df7c:	b570      	push	{r4, r5, r6, lr}
    df7e:	4604      	mov	r4, r0
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    df80:	4b24      	ldr	r3, [pc, #144]	; (e014 <HAL_I2CEx_ConfigDigitalFilter+0x98>)
    df82:	4825      	ldr	r0, [pc, #148]	; (e018 <HAL_I2CEx_ConfigDigitalFilter+0x9c>)
{
    df84:	460d      	mov	r5, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    df86:	6822      	ldr	r2, [r4, #0]
    df88:	4924      	ldr	r1, [pc, #144]	; (e01c <HAL_I2CEx_ConfigDigitalFilter+0xa0>)
    df8a:	429a      	cmp	r2, r3
    df8c:	bf18      	it	ne
    df8e:	4282      	cmpne	r2, r0
    df90:	bf14      	ite	ne
    df92:	2301      	movne	r3, #1
    df94:	2300      	moveq	r3, #0
    df96:	428a      	cmp	r2, r1
    df98:	bf0c      	ite	eq
    df9a:	2300      	moveq	r3, #0
    df9c:	f003 0301 	andne.w	r3, r3, #1
    dfa0:	b113      	cbz	r3, dfa8 <HAL_I2CEx_ConfigDigitalFilter+0x2c>
    dfa2:	4b1f      	ldr	r3, [pc, #124]	; (e020 <HAL_I2CEx_ConfigDigitalFilter+0xa4>)
    dfa4:	429a      	cmp	r2, r3
    dfa6:	d12f      	bne.n	e008 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
    dfa8:	2d0f      	cmp	r5, #15
    dfaa:	d828      	bhi.n	dffe <HAL_I2CEx_ConfigDigitalFilter+0x82>

  if (hi2c->State == HAL_I2C_STATE_READY)
    dfac:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    dfb0:	b2db      	uxtb	r3, r3
    dfb2:	2b20      	cmp	r3, #32
    dfb4:	d121      	bne.n	dffa <HAL_I2CEx_ConfigDigitalFilter+0x7e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
    dfb6:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
    dfba:	2a01      	cmp	r2, #1
    dfbc:	d01d      	beq.n	dffa <HAL_I2CEx_ConfigDigitalFilter+0x7e>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
    dfbe:	6821      	ldr	r1, [r4, #0]
    __HAL_LOCK(hi2c);
    dfc0:	2001      	movs	r0, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
    dfc2:	2224      	movs	r2, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
    dfc4:	2600      	movs	r6, #0
    __HAL_LOCK(hi2c);
    dfc6:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_BUSY;
    dfca:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41

    return HAL_OK;
    dfce:	4630      	mov	r0, r6
    __HAL_I2C_DISABLE(hi2c);
    dfd0:	680a      	ldr	r2, [r1, #0]
    dfd2:	f022 0201 	bic.w	r2, r2, #1
    dfd6:	600a      	str	r2, [r1, #0]
    tmpreg = hi2c->Instance->CR1;
    dfd8:	6822      	ldr	r2, [r4, #0]
    dfda:	6811      	ldr	r1, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
    dfdc:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
    tmpreg |= DigitalFilter << 8U;
    dfe0:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
    hi2c->Instance->CR1 = tmpreg;
    dfe4:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
    dfe6:	6821      	ldr	r1, [r4, #0]
    dfe8:	680a      	ldr	r2, [r1, #0]
    dfea:	f042 0201 	orr.w	r2, r2, #1
    dfee:	600a      	str	r2, [r1, #0]
    hi2c->State = HAL_I2C_STATE_READY;
    dff0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
    dff4:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
    dff8:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
    dffa:	2002      	movs	r0, #2
}
    dffc:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
    dffe:	2193      	movs	r1, #147	; 0x93
    e000:	4808      	ldr	r0, [pc, #32]	; (e024 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
    e002:	f00b fa5d 	bl	194c0 <assert_failed>
    e006:	e7d1      	b.n	dfac <HAL_I2CEx_ConfigDigitalFilter+0x30>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    e008:	2192      	movs	r1, #146	; 0x92
    e00a:	4806      	ldr	r0, [pc, #24]	; (e024 <HAL_I2CEx_ConfigDigitalFilter+0xa8>)
    e00c:	f00b fa58 	bl	194c0 <assert_failed>
    e010:	e7ca      	b.n	dfa8 <HAL_I2CEx_ConfigDigitalFilter+0x2c>
    e012:	bf00      	nop
    e014:	40005400 	.word	0x40005400
    e018:	40005800 	.word	0x40005800
    e01c:	40005c00 	.word	0x40005c00
    e020:	58001c00 	.word	0x58001c00
    e024:	00030130 	.word	0x00030130

0000e028 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
    e028:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
    e02a:	1e43      	subs	r3, r0, #1
{
    e02c:	4604      	mov	r4, r0
  assert_param (IS_PWR_SUPPLY (SupplySource));
    e02e:	2b01      	cmp	r3, #1
    e030:	d904      	bls.n	e03c <HAL_PWREx_ConfigSupply+0x14>
    e032:	f44f 719d 	mov.w	r1, #314	; 0x13a
    e036:	4812      	ldr	r0, [pc, #72]	; (e080 <HAL_PWREx_ConfigSupply+0x58>)
    e038:	f00b fa42 	bl	194c0 <assert_failed>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
    e03c:	4b11      	ldr	r3, [pc, #68]	; (e084 <HAL_PWREx_ConfigSupply+0x5c>)
    e03e:	68da      	ldr	r2, [r3, #12]
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
    e040:	68d8      	ldr	r0, [r3, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
    e042:	0752      	lsls	r2, r2, #29
    e044:	d405      	bmi.n	e052 <HAL_PWREx_ConfigSupply+0x2a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
    e046:	f000 0007 	and.w	r0, r0, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
    e04a:	1b00      	subs	r0, r0, r4
    e04c:	bf18      	it	ne
    e04e:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
    e050:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
    e052:	f020 0007 	bic.w	r0, r0, #7
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    e056:	461d      	mov	r5, r3
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
    e058:	4320      	orrs	r0, r4
    e05a:	60d8      	str	r0, [r3, #12]
  tickstart = HAL_GetTick ();
    e05c:	f7fa f9ca 	bl	83f4 <HAL_GetTick>
    e060:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    e062:	e005      	b.n	e070 <HAL_PWREx_ConfigSupply+0x48>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
    e064:	f7fa f9c6 	bl	83f4 <HAL_GetTick>
    e068:	1b00      	subs	r0, r0, r4
    e06a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
    e06e:	d804      	bhi.n	e07a <HAL_PWREx_ConfigSupply+0x52>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
    e070:	686b      	ldr	r3, [r5, #4]
    e072:	049b      	lsls	r3, r3, #18
    e074:	d5f6      	bpl.n	e064 <HAL_PWREx_ConfigSupply+0x3c>
  return HAL_OK;
    e076:	2000      	movs	r0, #0
}
    e078:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
    e07a:	2001      	movs	r0, #1
}
    e07c:	bd38      	pop	{r3, r4, r5, pc}
    e07e:	bf00      	nop
    e080:	0003016c 	.word	0x0003016c
    e084:	58024800 	.word	0x58024800

0000e088 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
    e088:	4a02      	ldr	r2, [pc, #8]	; (e094 <HAL_PWREx_EnableUSBVoltageDetector+0xc>)
    e08a:	68d3      	ldr	r3, [r2, #12]
    e08c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    e090:	60d3      	str	r3, [r2, #12]
}
    e092:	4770      	bx	lr
    e094:	58024800 	.word	0x58024800

0000e098 <HAL_PWREx_DisableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
    e098:	4a02      	ldr	r2, [pc, #8]	; (e0a4 <HAL_PWREx_DisableUSBVoltageDetector+0xc>)
    e09a:	68d3      	ldr	r3, [r2, #12]
    e09c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    e0a0:	60d3      	str	r3, [r2, #12]
}
    e0a2:	4770      	bx	lr
    e0a4:	58024800 	.word	0x58024800

0000e0a8 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
    e0a8:	2800      	cmp	r0, #0
    e0aa:	f000 823c 	beq.w	e526 <HAL_RCC_OscConfig+0x47e>
{
    e0ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    e0b0:	6803      	ldr	r3, [r0, #0]
    e0b2:	4604      	mov	r4, r0
    e0b4:	2b00      	cmp	r3, #0
    e0b6:	f000 80a6 	beq.w	e206 <HAL_RCC_OscConfig+0x15e>
    e0ba:	0698      	lsls	r0, r3, #26
    e0bc:	f000 821e 	beq.w	e4fc <HAL_RCC_OscConfig+0x454>
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
    e0c0:	07d9      	lsls	r1, r3, #31
    e0c2:	d536      	bpl.n	e132 <HAL_RCC_OscConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    e0c4:	6863      	ldr	r3, [r4, #4]
    e0c6:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
    e0ca:	d003      	beq.n	e0d4 <HAL_RCC_OscConfig+0x2c>
    e0cc:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
    e0d0:	f040 81e8 	bne.w	e4a4 <HAL_RCC_OscConfig+0x3fc>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e0d4:	4aa7      	ldr	r2, [pc, #668]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e0d6:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    e0d8:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e0da:	f003 0338 	and.w	r3, r3, #56	; 0x38
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
    e0de:	2b10      	cmp	r3, #16
    e0e0:	f000 81f2 	beq.w	e4c8 <HAL_RCC_OscConfig+0x420>
    e0e4:	2b18      	cmp	r3, #24
    e0e6:	f000 81ea 	beq.w	e4be <HAL_RCC_OscConfig+0x416>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    e0ea:	6863      	ldr	r3, [r4, #4]
    e0ec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    e0f0:	f000 81f5 	beq.w	e4de <HAL_RCC_OscConfig+0x436>
    e0f4:	2b00      	cmp	r3, #0
    e0f6:	f040 8267 	bne.w	e5c8 <HAL_RCC_OscConfig+0x520>
    e0fa:	4b9e      	ldr	r3, [pc, #632]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e0fc:	681a      	ldr	r2, [r3, #0]
    e0fe:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    e102:	601a      	str	r2, [r3, #0]
    e104:	681a      	ldr	r2, [r3, #0]
    e106:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
    e10a:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
    e10c:	6863      	ldr	r3, [r4, #4]
    e10e:	2b00      	cmp	r3, #0
    e110:	f000 81fb 	beq.w	e50a <HAL_RCC_OscConfig+0x462>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
    e114:	f7fa f96e 	bl	83f4 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    e118:	4d96      	ldr	r5, [pc, #600]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
        tickstart = HAL_GetTick();
    e11a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    e11c:	e005      	b.n	e12a <HAL_RCC_OscConfig+0x82>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    e11e:	f7fa f969 	bl	83f4 <HAL_GetTick>
    e122:	1b80      	subs	r0, r0, r6
    e124:	2864      	cmp	r0, #100	; 0x64
    e126:	f200 81e7 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    e12a:	682b      	ldr	r3, [r5, #0]
    e12c:	039b      	lsls	r3, r3, #14
    e12e:	d5f6      	bpl.n	e11e <HAL_RCC_OscConfig+0x76>
    e130:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
    e132:	0798      	lsls	r0, r3, #30
    e134:	d52b      	bpl.n	e18e <HAL_RCC_OscConfig+0xe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    e136:	68e2      	ldr	r2, [r4, #12]
    e138:	2a19      	cmp	r2, #25
    e13a:	f200 8288 	bhi.w	e64e <HAL_RCC_OscConfig+0x5a6>
    e13e:	4b8e      	ldr	r3, [pc, #568]	; (e378 <HAL_RCC_OscConfig+0x2d0>)
    e140:	40d3      	lsrs	r3, r2
    e142:	07d9      	lsls	r1, r3, #31
    e144:	f140 8283 	bpl.w	e64e <HAL_RCC_OscConfig+0x5a6>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    e148:	6923      	ldr	r3, [r4, #16]
    e14a:	2b7f      	cmp	r3, #127	; 0x7f
    e14c:	f200 81a4 	bhi.w	e498 <HAL_RCC_OscConfig+0x3f0>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e150:	4a88      	ldr	r2, [pc, #544]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e152:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    e154:	6a92      	ldr	r2, [r2, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    e156:	f013 0338 	ands.w	r3, r3, #56	; 0x38
    e15a:	f040 8173 	bne.w	e444 <HAL_RCC_OscConfig+0x39c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
    e15e:	4b85      	ldr	r3, [pc, #532]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e160:	681b      	ldr	r3, [r3, #0]
    e162:	075b      	lsls	r3, r3, #29
    e164:	d503      	bpl.n	e16e <HAL_RCC_OscConfig+0xc6>
    e166:	68e3      	ldr	r3, [r4, #12]
    e168:	2b00      	cmp	r3, #0
    e16a:	f000 81b6 	beq.w	e4da <HAL_RCC_OscConfig+0x432>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e16e:	f7fa f959 	bl	8424 <HAL_GetREVID>
    e172:	f241 0303 	movw	r3, #4099	; 0x1003
    e176:	4a7f      	ldr	r2, [pc, #508]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e178:	4298      	cmp	r0, r3
    e17a:	6921      	ldr	r1, [r4, #16]
    e17c:	6853      	ldr	r3, [r2, #4]
    e17e:	f200 825b 	bhi.w	e638 <HAL_RCC_OscConfig+0x590>
    e182:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    e186:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    e18a:	6053      	str	r3, [r2, #4]
    e18c:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
    e18e:	06d9      	lsls	r1, r3, #27
    e190:	d539      	bpl.n	e206 <HAL_RCC_OscConfig+0x15e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    e192:	69e3      	ldr	r3, [r4, #28]
    e194:	f033 0380 	bics.w	r3, r3, #128	; 0x80
    e198:	f040 81fd 	bne.w	e596 <HAL_RCC_OscConfig+0x4ee>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    e19c:	6a23      	ldr	r3, [r4, #32]
    e19e:	2b3f      	cmp	r3, #63	; 0x3f
    e1a0:	f200 81f3 	bhi.w	e58a <HAL_RCC_OscConfig+0x4e2>

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e1a4:	4a73      	ldr	r2, [pc, #460]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e1a6:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
    e1a8:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
    e1aa:	f003 0338 	and.w	r3, r3, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
    e1ae:	2b08      	cmp	r3, #8
    e1b0:	f000 81c0 	beq.w	e534 <HAL_RCC_OscConfig+0x48c>
    e1b4:	2b18      	cmp	r3, #24
    e1b6:	f000 81b8 	beq.w	e52a <HAL_RCC_OscConfig+0x482>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
    e1ba:	69e3      	ldr	r3, [r4, #28]
    e1bc:	2b00      	cmp	r3, #0
    e1be:	f000 8211 	beq.w	e5e4 <HAL_RCC_OscConfig+0x53c>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
    e1c2:	4b6c      	ldr	r3, [pc, #432]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e1c4:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    e1c6:	461d      	mov	r5, r3
        __HAL_RCC_CSI_ENABLE();
    e1c8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    e1cc:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e1ce:	f7fa f911 	bl	83f4 <HAL_GetTick>
    e1d2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    e1d4:	e005      	b.n	e1e2 <HAL_RCC_OscConfig+0x13a>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    e1d6:	f7fa f90d 	bl	83f4 <HAL_GetTick>
    e1da:	1b80      	subs	r0, r0, r6
    e1dc:	2802      	cmp	r0, #2
    e1de:	f200 818b 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    e1e2:	682b      	ldr	r3, [r5, #0]
    e1e4:	05db      	lsls	r3, r3, #23
    e1e6:	d5f6      	bpl.n	e1d6 <HAL_RCC_OscConfig+0x12e>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e1e8:	f7fa f91c 	bl	8424 <HAL_GetREVID>
    e1ec:	f241 0303 	movw	r3, #4099	; 0x1003
    e1f0:	4298      	cmp	r0, r3
    e1f2:	f200 82b5 	bhi.w	e760 <HAL_RCC_OscConfig+0x6b8>
    e1f6:	686b      	ldr	r3, [r5, #4]
    e1f8:	6a22      	ldr	r2, [r4, #32]
    e1fa:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
    e1fe:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
    e202:	606b      	str	r3, [r5, #4]
    e204:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
    e206:	071d      	lsls	r5, r3, #28
    e208:	d51a      	bpl.n	e240 <HAL_RCC_OscConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    e20a:	6963      	ldr	r3, [r4, #20]
    e20c:	2b01      	cmp	r3, #1
    e20e:	f200 814f 	bhi.w	e4b0 <HAL_RCC_OscConfig+0x408>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
    e212:	2b00      	cmp	r3, #0
    e214:	f000 81a6 	beq.w	e564 <HAL_RCC_OscConfig+0x4bc>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
    e218:	4b56      	ldr	r3, [pc, #344]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e21a:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    e21c:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
    e21e:	f042 0201 	orr.w	r2, r2, #1
    e222:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
    e224:	f7fa f8e6 	bl	83f4 <HAL_GetTick>
    e228:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    e22a:	e005      	b.n	e238 <HAL_RCC_OscConfig+0x190>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    e22c:	f7fa f8e2 	bl	83f4 <HAL_GetTick>
    e230:	1b80      	subs	r0, r0, r6
    e232:	2802      	cmp	r0, #2
    e234:	f200 8160 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
    e238:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    e23a:	0798      	lsls	r0, r3, #30
    e23c:	d5f6      	bpl.n	e22c <HAL_RCC_OscConfig+0x184>
    e23e:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
    e240:	069a      	lsls	r2, r3, #26
    e242:	d51a      	bpl.n	e27a <HAL_RCC_OscConfig+0x1d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    e244:	69a3      	ldr	r3, [r4, #24]
    e246:	2b01      	cmp	r3, #1
    e248:	f200 814f 	bhi.w	e4ea <HAL_RCC_OscConfig+0x442>

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
    e24c:	2b00      	cmp	r3, #0
    e24e:	f000 81a8 	beq.w	e5a2 <HAL_RCC_OscConfig+0x4fa>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
    e252:	4b48      	ldr	r3, [pc, #288]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e254:	681a      	ldr	r2, [r3, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    e256:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_ENABLE();
    e258:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    e25c:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
    e25e:	f7fa f8c9 	bl	83f4 <HAL_GetTick>
    e262:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    e264:	e005      	b.n	e272 <HAL_RCC_OscConfig+0x1ca>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    e266:	f7fa f8c5 	bl	83f4 <HAL_GetTick>
    e26a:	1b80      	subs	r0, r0, r6
    e26c:	2802      	cmp	r0, #2
    e26e:	f200 8143 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
    e272:	682b      	ldr	r3, [r5, #0]
    e274:	049f      	lsls	r7, r3, #18
    e276:	d5f6      	bpl.n	e266 <HAL_RCC_OscConfig+0x1be>
    e278:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
    e27a:	0759      	lsls	r1, r3, #29
    e27c:	d53c      	bpl.n	e2f8 <HAL_RCC_OscConfig+0x250>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    e27e:	68a3      	ldr	r3, [r4, #8]
    e280:	2b01      	cmp	r3, #1
    e282:	d902      	bls.n	e28a <HAL_RCC_OscConfig+0x1e2>
    e284:	2b05      	cmp	r3, #5
    e286:	f040 81f8 	bne.w	e67a <HAL_RCC_OscConfig+0x5d2>

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
    e28a:	4b3c      	ldr	r3, [pc, #240]	; (e37c <HAL_RCC_OscConfig+0x2d4>)
    e28c:	681a      	ldr	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    e28e:	461d      	mov	r5, r3
    PWR->CR1 |= PWR_CR1_DBP;
    e290:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    e294:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    e296:	f7fa f8ad 	bl	83f4 <HAL_GetTick>
    e29a:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    e29c:	e005      	b.n	e2aa <HAL_RCC_OscConfig+0x202>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
    e29e:	f7fa f8a9 	bl	83f4 <HAL_GetTick>
    e2a2:	1b80      	subs	r0, r0, r6
    e2a4:	2864      	cmp	r0, #100	; 0x64
    e2a6:	f200 8127 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    e2aa:	682b      	ldr	r3, [r5, #0]
    e2ac:	05da      	lsls	r2, r3, #23
    e2ae:	d5f6      	bpl.n	e29e <HAL_RCC_OscConfig+0x1f6>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    e2b0:	68a3      	ldr	r3, [r4, #8]
    e2b2:	2b01      	cmp	r3, #1
    e2b4:	f000 821d 	beq.w	e6f2 <HAL_RCC_OscConfig+0x64a>
    e2b8:	2b00      	cmp	r3, #0
    e2ba:	f040 8244 	bne.w	e746 <HAL_RCC_OscConfig+0x69e>
    e2be:	4b2d      	ldr	r3, [pc, #180]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e2c0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e2c2:	f022 0201 	bic.w	r2, r2, #1
    e2c6:	671a      	str	r2, [r3, #112]	; 0x70
    e2c8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e2ca:	f022 0204 	bic.w	r2, r2, #4
    e2ce:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    e2d0:	68a3      	ldr	r3, [r4, #8]
    e2d2:	2b00      	cmp	r3, #0
    e2d4:	f000 8213 	beq.w	e6fe <HAL_RCC_OscConfig+0x656>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
    e2d8:	f7fa f88c 	bl	83f4 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    e2dc:	4d25      	ldr	r5, [pc, #148]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
      tickstart = HAL_GetTick();
    e2de:	4607      	mov	r7, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e2e0:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    e2e4:	e005      	b.n	e2f2 <HAL_RCC_OscConfig+0x24a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e2e6:	f7fa f885 	bl	83f4 <HAL_GetTick>
    e2ea:	1bc0      	subs	r0, r0, r7
    e2ec:	42b0      	cmp	r0, r6
    e2ee:	f200 8103 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    e2f2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    e2f4:	079b      	lsls	r3, r3, #30
    e2f6:	d5f6      	bpl.n	e2e6 <HAL_RCC_OscConfig+0x23e>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    e2f8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    e2fa:	2802      	cmp	r0, #2
    e2fc:	f200 81b6 	bhi.w	e66c <HAL_RCC_OscConfig+0x5c4>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
    e300:	2800      	cmp	r0, #0
    e302:	f000 809d 	beq.w	e440 <HAL_RCC_OscConfig+0x398>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
    e306:	4a1b      	ldr	r2, [pc, #108]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e308:	6913      	ldr	r3, [r2, #16]
    e30a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    e30e:	2b18      	cmp	r3, #24
    e310:	f000 81c1 	beq.w	e696 <HAL_RCC_OscConfig+0x5ee>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
    e314:	2802      	cmp	r0, #2
    e316:	f040 8203 	bne.w	e720 <HAL_RCC_OscConfig+0x678>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    e31a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e31c:	2b03      	cmp	r3, #3
    e31e:	f200 8253 	bhi.w	e7c8 <HAL_RCC_OscConfig+0x720>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    e322:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e324:	3b01      	subs	r3, #1
    e326:	2b3e      	cmp	r3, #62	; 0x3e
    e328:	f200 8230 	bhi.w	e78c <HAL_RCC_OscConfig+0x6e4>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    e32c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e32e:	3b04      	subs	r3, #4
    e330:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    e334:	f200 8224 	bhi.w	e780 <HAL_RCC_OscConfig+0x6d8>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    e338:	6b63      	ldr	r3, [r4, #52]	; 0x34
    e33a:	3b01      	subs	r3, #1
    e33c:	2b7f      	cmp	r3, #127	; 0x7f
    e33e:	f200 823d 	bhi.w	e7bc <HAL_RCC_OscConfig+0x714>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    e342:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    e344:	3b01      	subs	r3, #1
    e346:	2b7f      	cmp	r3, #127	; 0x7f
    e348:	f200 8232 	bhi.w	e7b0 <HAL_RCC_OscConfig+0x708>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    e34c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    e34e:	3b01      	subs	r3, #1
    e350:	2b7f      	cmp	r3, #127	; 0x7f
    e352:	f200 8227 	bhi.w	e7a4 <HAL_RCC_OscConfig+0x6fc>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    e356:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    e358:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    e35c:	f080 821c 	bcs.w	e798 <HAL_RCC_OscConfig+0x6f0>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
    e360:	4b04      	ldr	r3, [pc, #16]	; (e374 <HAL_RCC_OscConfig+0x2cc>)
    e362:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e364:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
    e366:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    e36a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e36c:	f7fa f842 	bl	83f4 <HAL_GetTick>
    e370:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e372:	e00b      	b.n	e38c <HAL_RCC_OscConfig+0x2e4>
    e374:	58024400 	.word	0x58024400
    e378:	02020203 	.word	0x02020203
    e37c:	58024800 	.word	0x58024800
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    e380:	f7fa f838 	bl	83f4 <HAL_GetTick>
    e384:	1b80      	subs	r0, r0, r6
    e386:	2802      	cmp	r0, #2
    e388:	f200 80b6 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e38c:	682b      	ldr	r3, [r5, #0]
    e38e:	0199      	lsls	r1, r3, #6
    e390:	d4f6      	bmi.n	e380 <HAL_RCC_OscConfig+0x2d8>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    e392:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    e394:	4bb1      	ldr	r3, [pc, #708]	; (e65c <HAL_RCC_OscConfig+0x5b4>)
    e396:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e398:	4013      	ands	r3, r2
    e39a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    e39c:	49b0      	ldr	r1, [pc, #704]	; (e660 <HAL_RCC_OscConfig+0x5b8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    e39e:	4303      	orrs	r3, r0

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    e3a0:	4eb0      	ldr	r6, [pc, #704]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    e3a2:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
    e3a6:	62ab      	str	r3, [r5, #40]	; 0x28
    e3a8:	6b27      	ldr	r7, [r4, #48]	; 0x30
    e3aa:	e9d4 320d 	ldrd	r3, r2, [r4, #52]	; 0x34
    e3ae:	3f01      	subs	r7, #1
    e3b0:	1e50      	subs	r0, r2, #1
    e3b2:	3b01      	subs	r3, #1
    e3b4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    e3b6:	f3c7 0708 	ubfx	r7, r7, #0, #9
    e3ba:	025b      	lsls	r3, r3, #9
    e3bc:	0400      	lsls	r0, r0, #16
    e3be:	3a01      	subs	r2, #1
    e3c0:	b29b      	uxth	r3, r3
    e3c2:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    e3c6:	0612      	lsls	r2, r2, #24
    e3c8:	4303      	orrs	r3, r0
    e3ca:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    e3ce:	433b      	orrs	r3, r7
    e3d0:	4313      	orrs	r3, r2
    e3d2:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
    e3d4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e3d6:	f023 0301 	bic.w	r3, r3, #1
    e3da:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
    e3dc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    e3de:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    e3e0:	4011      	ands	r1, r2
    e3e2:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    e3e6:	6369      	str	r1, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
    e3e8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e3ea:	6c22      	ldr	r2, [r4, #64]	; 0x40
    e3ec:	f023 030c 	bic.w	r3, r3, #12
    e3f0:	4313      	orrs	r3, r2
    e3f2:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
    e3f4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e3f6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    e3f8:	f023 0302 	bic.w	r3, r3, #2
    e3fc:	4313      	orrs	r3, r2
    e3fe:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
    e400:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e402:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    e406:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    e408:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e40a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    e40e:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
    e410:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e412:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    e416:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
    e418:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e41a:	f043 0301 	orr.w	r3, r3, #1
    e41e:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
    e420:	682b      	ldr	r3, [r5, #0]
    e422:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    e426:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
    e428:	f7f9 ffe4 	bl	83f4 <HAL_GetTick>
    e42c:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    e42e:	e004      	b.n	e43a <HAL_RCC_OscConfig+0x392>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    e430:	f7f9 ffe0 	bl	83f4 <HAL_GetTick>
    e434:	1b00      	subs	r0, r0, r4
    e436:	2802      	cmp	r0, #2
    e438:	d85e      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    e43a:	6833      	ldr	r3, [r6, #0]
    e43c:	019a      	lsls	r2, r3, #6
    e43e:	d5f7      	bpl.n	e430 <HAL_RCC_OscConfig+0x388>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
    e440:	2000      	movs	r0, #0
}
    e442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    e444:	2b18      	cmp	r3, #24
    e446:	f000 80fe 	beq.w	e646 <HAL_RCC_OscConfig+0x59e>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
    e44a:	68e2      	ldr	r2, [r4, #12]
    e44c:	2a00      	cmp	r2, #0
    e44e:	f000 80de 	beq.w	e60e <HAL_RCC_OscConfig+0x566>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    e452:	4984      	ldr	r1, [pc, #528]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e454:	680b      	ldr	r3, [r1, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    e456:	460d      	mov	r5, r1
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    e458:	f023 0319 	bic.w	r3, r3, #25
    e45c:	4313      	orrs	r3, r2
    e45e:	600b      	str	r3, [r1, #0]
        tickstart = HAL_GetTick();
    e460:	f7f9 ffc8 	bl	83f4 <HAL_GetTick>
    e464:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    e466:	e004      	b.n	e472 <HAL_RCC_OscConfig+0x3ca>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    e468:	f7f9 ffc4 	bl	83f4 <HAL_GetTick>
    e46c:	1b80      	subs	r0, r0, r6
    e46e:	2802      	cmp	r0, #2
    e470:	d842      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    e472:	682b      	ldr	r3, [r5, #0]
    e474:	075f      	lsls	r7, r3, #29
    e476:	d5f7      	bpl.n	e468 <HAL_RCC_OscConfig+0x3c0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e478:	f7f9 ffd4 	bl	8424 <HAL_GetREVID>
    e47c:	f241 0303 	movw	r3, #4099	; 0x1003
    e480:	6922      	ldr	r2, [r4, #16]
    e482:	4298      	cmp	r0, r3
    e484:	686b      	ldr	r3, [r5, #4]
    e486:	f200 8174 	bhi.w	e772 <HAL_RCC_OscConfig+0x6ca>
    e48a:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    e48e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    e492:	606b      	str	r3, [r5, #4]
    e494:	6823      	ldr	r3, [r4, #0]
    e496:	e67a      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    e498:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
    e49c:	4872      	ldr	r0, [pc, #456]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e49e:	f00b f80f 	bl	194c0 <assert_failed>
    e4a2:	e655      	b.n	e150 <HAL_RCC_OscConfig+0xa8>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    e4a4:	f240 11a3 	movw	r1, #419	; 0x1a3
    e4a8:	486f      	ldr	r0, [pc, #444]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e4aa:	f00b f809 	bl	194c0 <assert_failed>
    e4ae:	e611      	b.n	e0d4 <HAL_RCC_OscConfig+0x2c>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    e4b0:	f44f 7117 	mov.w	r1, #604	; 0x25c
    e4b4:	486c      	ldr	r0, [pc, #432]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e4b6:	f00b f803 	bl	194c0 <assert_failed>
    e4ba:	6963      	ldr	r3, [r4, #20]
    e4bc:	e6a9      	b.n	e212 <HAL_RCC_OscConfig+0x16a>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
    e4be:	f002 0203 	and.w	r2, r2, #3
    e4c2:	2a02      	cmp	r2, #2
    e4c4:	f47f ae11 	bne.w	e0ea <HAL_RCC_OscConfig+0x42>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
    e4c8:	4b66      	ldr	r3, [pc, #408]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e4ca:	681b      	ldr	r3, [r3, #0]
    e4cc:	039a      	lsls	r2, r3, #14
    e4ce:	f57f ae2f 	bpl.w	e130 <HAL_RCC_OscConfig+0x88>
    e4d2:	6863      	ldr	r3, [r4, #4]
    e4d4:	2b00      	cmp	r3, #0
    e4d6:	f47f ae2b 	bne.w	e130 <HAL_RCC_OscConfig+0x88>
        return HAL_ERROR;
    e4da:	2001      	movs	r0, #1
}
    e4dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    e4de:	4a61      	ldr	r2, [pc, #388]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e4e0:	6813      	ldr	r3, [r2, #0]
    e4e2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    e4e6:	6013      	str	r3, [r2, #0]
    e4e8:	e610      	b.n	e10c <HAL_RCC_OscConfig+0x64>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    e4ea:	f240 2187 	movw	r1, #647	; 0x287
    e4ee:	485e      	ldr	r0, [pc, #376]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e4f0:	f00a ffe6 	bl	194c0 <assert_failed>
    e4f4:	69a3      	ldr	r3, [r4, #24]
    e4f6:	e6a9      	b.n	e24c <HAL_RCC_OscConfig+0x1a4>
            return HAL_TIMEOUT;
    e4f8:	2003      	movs	r0, #3
}
    e4fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    e4fc:	f44f 71cf 	mov.w	r1, #414	; 0x19e
    e500:	4859      	ldr	r0, [pc, #356]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e502:	f00a ffdd 	bl	194c0 <assert_failed>
    e506:	6823      	ldr	r3, [r4, #0]
    e508:	e5da      	b.n	e0c0 <HAL_RCC_OscConfig+0x18>
        tickstart = HAL_GetTick();
    e50a:	f7f9 ff73 	bl	83f4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    e50e:	4d55      	ldr	r5, [pc, #340]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
        tickstart = HAL_GetTick();
    e510:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    e512:	e004      	b.n	e51e <HAL_RCC_OscConfig+0x476>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    e514:	f7f9 ff6e 	bl	83f4 <HAL_GetTick>
    e518:	1b80      	subs	r0, r0, r6
    e51a:	2864      	cmp	r0, #100	; 0x64
    e51c:	d8ec      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
    e51e:	682b      	ldr	r3, [r5, #0]
    e520:	039f      	lsls	r7, r3, #14
    e522:	d4f7      	bmi.n	e514 <HAL_RCC_OscConfig+0x46c>
    e524:	e604      	b.n	e130 <HAL_RCC_OscConfig+0x88>
    return HAL_ERROR;
    e526:	2001      	movs	r0, #1
}
    e528:	4770      	bx	lr
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
    e52a:	f002 0203 	and.w	r2, r2, #3
    e52e:	2a01      	cmp	r2, #1
    e530:	f47f ae43 	bne.w	e1ba <HAL_RCC_OscConfig+0x112>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
    e534:	4b4b      	ldr	r3, [pc, #300]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e536:	681b      	ldr	r3, [r3, #0]
    e538:	05da      	lsls	r2, r3, #23
    e53a:	d502      	bpl.n	e542 <HAL_RCC_OscConfig+0x49a>
    e53c:	69e3      	ldr	r3, [r4, #28]
    e53e:	2b80      	cmp	r3, #128	; 0x80
    e540:	d1cb      	bne.n	e4da <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e542:	f7f9 ff6f 	bl	8424 <HAL_GetREVID>
    e546:	f241 0303 	movw	r3, #4099	; 0x1003
    e54a:	4a46      	ldr	r2, [pc, #280]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e54c:	4298      	cmp	r0, r3
    e54e:	6a21      	ldr	r1, [r4, #32]
    e550:	f200 8099 	bhi.w	e686 <HAL_RCC_OscConfig+0x5de>
    e554:	6853      	ldr	r3, [r2, #4]
    e556:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
    e55a:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
    e55e:	6053      	str	r3, [r2, #4]
    e560:	6823      	ldr	r3, [r4, #0]
    e562:	e650      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
      __HAL_RCC_LSI_DISABLE();
    e564:	4b3f      	ldr	r3, [pc, #252]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e566:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    e568:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
    e56a:	f022 0201 	bic.w	r2, r2, #1
    e56e:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
    e570:	f7f9 ff40 	bl	83f4 <HAL_GetTick>
    e574:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    e576:	e004      	b.n	e582 <HAL_RCC_OscConfig+0x4da>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    e578:	f7f9 ff3c 	bl	83f4 <HAL_GetTick>
    e57c:	1b80      	subs	r0, r0, r6
    e57e:	2802      	cmp	r0, #2
    e580:	d8ba      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
    e582:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    e584:	0799      	lsls	r1, r3, #30
    e586:	d4f7      	bmi.n	e578 <HAL_RCC_OscConfig+0x4d0>
    e588:	e659      	b.n	e23e <HAL_RCC_OscConfig+0x196>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    e58a:	f240 211b 	movw	r1, #539	; 0x21b
    e58e:	4836      	ldr	r0, [pc, #216]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e590:	f00a ff96 	bl	194c0 <assert_failed>
    e594:	e606      	b.n	e1a4 <HAL_RCC_OscConfig+0xfc>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    e596:	f240 211a 	movw	r1, #538	; 0x21a
    e59a:	4833      	ldr	r0, [pc, #204]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e59c:	f00a ff90 	bl	194c0 <assert_failed>
    e5a0:	e5fc      	b.n	e19c <HAL_RCC_OscConfig+0xf4>
      __HAL_RCC_HSI48_DISABLE();
    e5a2:	4b30      	ldr	r3, [pc, #192]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e5a4:	681a      	ldr	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    e5a6:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_DISABLE();
    e5a8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    e5ac:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
    e5ae:	f7f9 ff21 	bl	83f4 <HAL_GetTick>
    e5b2:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    e5b4:	e004      	b.n	e5c0 <HAL_RCC_OscConfig+0x518>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    e5b6:	f7f9 ff1d 	bl	83f4 <HAL_GetTick>
    e5ba:	1b80      	subs	r0, r0, r6
    e5bc:	2802      	cmp	r0, #2
    e5be:	d89b      	bhi.n	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
    e5c0:	682b      	ldr	r3, [r5, #0]
    e5c2:	0498      	lsls	r0, r3, #18
    e5c4:	d4f7      	bmi.n	e5b6 <HAL_RCC_OscConfig+0x50e>
    e5c6:	e657      	b.n	e278 <HAL_RCC_OscConfig+0x1d0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    e5c8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
    e5cc:	4b25      	ldr	r3, [pc, #148]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e5ce:	681a      	ldr	r2, [r3, #0]
    e5d0:	f47f ad95 	bne.w	e0fe <HAL_RCC_OscConfig+0x56>
    e5d4:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
    e5d8:	601a      	str	r2, [r3, #0]
    e5da:	681a      	ldr	r2, [r3, #0]
    e5dc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    e5e0:	601a      	str	r2, [r3, #0]
    e5e2:	e593      	b.n	e10c <HAL_RCC_OscConfig+0x64>
        __HAL_RCC_CSI_DISABLE();
    e5e4:	4b1f      	ldr	r3, [pc, #124]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e5e6:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    e5e8:	461d      	mov	r5, r3
        __HAL_RCC_CSI_DISABLE();
    e5ea:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    e5ee:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e5f0:	f7f9 ff00 	bl	83f4 <HAL_GetTick>
    e5f4:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    e5f6:	e005      	b.n	e604 <HAL_RCC_OscConfig+0x55c>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    e5f8:	f7f9 fefc 	bl	83f4 <HAL_GetTick>
    e5fc:	1b80      	subs	r0, r0, r6
    e5fe:	2802      	cmp	r0, #2
    e600:	f63f af7a 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    e604:	682b      	ldr	r3, [r5, #0]
    e606:	05df      	lsls	r7, r3, #23
    e608:	d4f6      	bmi.n	e5f8 <HAL_RCC_OscConfig+0x550>
    e60a:	6823      	ldr	r3, [r4, #0]
    e60c:	e5fb      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
        __HAL_RCC_HSI_DISABLE();
    e60e:	4b15      	ldr	r3, [pc, #84]	; (e664 <HAL_RCC_OscConfig+0x5bc>)
    e610:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    e612:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
    e614:	f022 0201 	bic.w	r2, r2, #1
    e618:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
    e61a:	f7f9 feeb 	bl	83f4 <HAL_GetTick>
    e61e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    e620:	e005      	b.n	e62e <HAL_RCC_OscConfig+0x586>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    e622:	f7f9 fee7 	bl	83f4 <HAL_GetTick>
    e626:	1b80      	subs	r0, r0, r6
    e628:	2802      	cmp	r0, #2
    e62a:	f63f af65 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    e62e:	682b      	ldr	r3, [r5, #0]
    e630:	0758      	lsls	r0, r3, #29
    e632:	d4f6      	bmi.n	e622 <HAL_RCC_OscConfig+0x57a>
    e634:	6823      	ldr	r3, [r4, #0]
    e636:	e5aa      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e638:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    e63c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    e640:	6053      	str	r3, [r2, #4]
    e642:	6823      	ldr	r3, [r4, #0]
    e644:	e5a3      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
    e646:	0792      	lsls	r2, r2, #30
    e648:	f47f aeff 	bne.w	e44a <HAL_RCC_OscConfig+0x3a2>
    e64c:	e587      	b.n	e15e <HAL_RCC_OscConfig+0xb6>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    e64e:	f240 11d7 	movw	r1, #471	; 0x1d7
    e652:	4805      	ldr	r0, [pc, #20]	; (e668 <HAL_RCC_OscConfig+0x5c0>)
    e654:	f00a ff34 	bl	194c0 <assert_failed>
    e658:	e576      	b.n	e148 <HAL_RCC_OscConfig+0xa0>
    e65a:	bf00      	nop
    e65c:	fffffc0c 	.word	0xfffffc0c
    e660:	ffff0007 	.word	0xffff0007
    e664:	58024400 	.word	0x58024400
    e668:	000301a8 	.word	0x000301a8
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    e66c:	4859      	ldr	r0, [pc, #356]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e66e:	f240 21e3 	movw	r1, #739	; 0x2e3
    e672:	f00a ff25 	bl	194c0 <assert_failed>
    e676:	6a60      	ldr	r0, [r4, #36]	; 0x24
    e678:	e642      	b.n	e300 <HAL_RCC_OscConfig+0x258>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    e67a:	f240 21b1 	movw	r1, #689	; 0x2b1
    e67e:	4855      	ldr	r0, [pc, #340]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e680:	f00a ff1e 	bl	194c0 <assert_failed>
    e684:	e601      	b.n	e28a <HAL_RCC_OscConfig+0x1e2>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e686:	68d3      	ldr	r3, [r2, #12]
    e688:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
    e68c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    e690:	60d3      	str	r3, [r2, #12]
    e692:	6823      	ldr	r3, [r4, #0]
    e694:	e5b7      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    e696:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
    e698:	6a91      	ldr	r1, [r2, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
    e69a:	6b15      	ldr	r5, [r2, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    e69c:	f43f aed1 	beq.w	e442 <HAL_RCC_OscConfig+0x39a>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    e6a0:	f001 0303 	and.w	r3, r1, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    e6a4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e6a6:	4293      	cmp	r3, r2
    e6a8:	f47f af17 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    e6ac:	f3c1 1105 	ubfx	r1, r1, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    e6b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e6b2:	4299      	cmp	r1, r3
    e6b4:	f47f af11 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    e6b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e6ba:	f3c5 0208 	ubfx	r2, r5, #0, #9
    e6be:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    e6c0:	429a      	cmp	r2, r3
    e6c2:	f47f af0a 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    e6c6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    e6c8:	f3c5 2246 	ubfx	r2, r5, #9, #7
    e6cc:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    e6ce:	429a      	cmp	r2, r3
    e6d0:	f47f af03 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
    e6d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    e6d6:	f3c5 4206 	ubfx	r2, r5, #16, #7
    e6da:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    e6dc:	429a      	cmp	r2, r3
    e6de:	f47f aefc 	bne.w	e4da <HAL_RCC_OscConfig+0x432>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
    e6e2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    e6e4:	f3c5 6506 	ubfx	r5, r5, #24, #7
    e6e8:	3801      	subs	r0, #1
    return HAL_ERROR;
    e6ea:	1a28      	subs	r0, r5, r0
    e6ec:	bf18      	it	ne
    e6ee:	2001      	movne	r0, #1
    e6f0:	e6a7      	b.n	e442 <HAL_RCC_OscConfig+0x39a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    e6f2:	4a39      	ldr	r2, [pc, #228]	; (e7d8 <HAL_RCC_OscConfig+0x730>)
    e6f4:	6f13      	ldr	r3, [r2, #112]	; 0x70
    e6f6:	f043 0301 	orr.w	r3, r3, #1
    e6fa:	6713      	str	r3, [r2, #112]	; 0x70
    e6fc:	e5e8      	b.n	e2d0 <HAL_RCC_OscConfig+0x228>
      tickstart = HAL_GetTick();
    e6fe:	f7f9 fe79 	bl	83f4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    e702:	4d35      	ldr	r5, [pc, #212]	; (e7d8 <HAL_RCC_OscConfig+0x730>)
      tickstart = HAL_GetTick();
    e704:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e706:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    e70a:	e005      	b.n	e718 <HAL_RCC_OscConfig+0x670>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
    e70c:	f7f9 fe72 	bl	83f4 <HAL_GetTick>
    e710:	1bc0      	subs	r0, r0, r7
    e712:	42b0      	cmp	r0, r6
    e714:	f63f aef0 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
    e718:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    e71a:	0798      	lsls	r0, r3, #30
    e71c:	d4f6      	bmi.n	e70c <HAL_RCC_OscConfig+0x664>
    e71e:	e5eb      	b.n	e2f8 <HAL_RCC_OscConfig+0x250>
        __HAL_RCC_PLL_DISABLE();
    e720:	6813      	ldr	r3, [r2, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e722:	4614      	mov	r4, r2
        __HAL_RCC_PLL_DISABLE();
    e724:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    e728:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
    e72a:	f7f9 fe63 	bl	83f4 <HAL_GetTick>
    e72e:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e730:	e005      	b.n	e73e <HAL_RCC_OscConfig+0x696>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    e732:	f7f9 fe5f 	bl	83f4 <HAL_GetTick>
    e736:	1b40      	subs	r0, r0, r5
    e738:	2802      	cmp	r0, #2
    e73a:	f63f aedd 	bhi.w	e4f8 <HAL_RCC_OscConfig+0x450>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
    e73e:	6823      	ldr	r3, [r4, #0]
    e740:	019b      	lsls	r3, r3, #6
    e742:	d4f6      	bmi.n	e732 <HAL_RCC_OscConfig+0x68a>
    e744:	e67c      	b.n	e440 <HAL_RCC_OscConfig+0x398>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    e746:	2b05      	cmp	r3, #5
    e748:	4b23      	ldr	r3, [pc, #140]	; (e7d8 <HAL_RCC_OscConfig+0x730>)
    e74a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e74c:	f47f adb9 	bne.w	e2c2 <HAL_RCC_OscConfig+0x21a>
    e750:	f042 0204 	orr.w	r2, r2, #4
    e754:	671a      	str	r2, [r3, #112]	; 0x70
    e756:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    e758:	f042 0201 	orr.w	r2, r2, #1
    e75c:	671a      	str	r2, [r3, #112]	; 0x70
    e75e:	e5b7      	b.n	e2d0 <HAL_RCC_OscConfig+0x228>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    e760:	68eb      	ldr	r3, [r5, #12]
    e762:	6a22      	ldr	r2, [r4, #32]
    e764:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
    e768:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    e76c:	60eb      	str	r3, [r5, #12]
    e76e:	6823      	ldr	r3, [r4, #0]
    e770:	e549      	b.n	e206 <HAL_RCC_OscConfig+0x15e>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    e772:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    e776:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    e77a:	606b      	str	r3, [r5, #4]
    e77c:	6823      	ldr	r3, [r4, #0]
    e77e:	e506      	b.n	e18e <HAL_RCC_OscConfig+0xe6>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    e780:	f240 21ee 	movw	r1, #750	; 0x2ee
    e784:	4813      	ldr	r0, [pc, #76]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e786:	f00a fe9b 	bl	194c0 <assert_failed>
    e78a:	e5d5      	b.n	e338 <HAL_RCC_OscConfig+0x290>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    e78c:	f240 21ed 	movw	r1, #749	; 0x2ed
    e790:	4810      	ldr	r0, [pc, #64]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e792:	f00a fe95 	bl	194c0 <assert_failed>
    e796:	e5c9      	b.n	e32c <HAL_RCC_OscConfig+0x284>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    e798:	f240 21f2 	movw	r1, #754	; 0x2f2
    e79c:	480d      	ldr	r0, [pc, #52]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e79e:	f00a fe8f 	bl	194c0 <assert_failed>
    e7a2:	e5dd      	b.n	e360 <HAL_RCC_OscConfig+0x2b8>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    e7a4:	f240 21f1 	movw	r1, #753	; 0x2f1
    e7a8:	480a      	ldr	r0, [pc, #40]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7aa:	f00a fe89 	bl	194c0 <assert_failed>
    e7ae:	e5d2      	b.n	e356 <HAL_RCC_OscConfig+0x2ae>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    e7b0:	f44f 713c 	mov.w	r1, #752	; 0x2f0
    e7b4:	4807      	ldr	r0, [pc, #28]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7b6:	f00a fe83 	bl	194c0 <assert_failed>
    e7ba:	e5c7      	b.n	e34c <HAL_RCC_OscConfig+0x2a4>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    e7bc:	f240 21ef 	movw	r1, #751	; 0x2ef
    e7c0:	4804      	ldr	r0, [pc, #16]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7c2:	f00a fe7d 	bl	194c0 <assert_failed>
    e7c6:	e5bc      	b.n	e342 <HAL_RCC_OscConfig+0x29a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    e7c8:	f44f 713b 	mov.w	r1, #748	; 0x2ec
    e7cc:	4801      	ldr	r0, [pc, #4]	; (e7d4 <HAL_RCC_OscConfig+0x72c>)
    e7ce:	f00a fe77 	bl	194c0 <assert_failed>
    e7d2:	e5a6      	b.n	e322 <HAL_RCC_OscConfig+0x27a>
    e7d4:	000301a8 	.word	0x000301a8
    e7d8:	58024400 	.word	0x58024400

0000e7dc <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
    e7dc:	4a3e      	ldr	r2, [pc, #248]	; (e8d8 <HAL_RCC_GetSysClockFreq+0xfc>)
    e7de:	6913      	ldr	r3, [r2, #16]
    e7e0:	f003 0338 	and.w	r3, r3, #56	; 0x38
    e7e4:	2b10      	cmp	r3, #16
    e7e6:	d04f      	beq.n	e888 <HAL_RCC_GetSysClockFreq+0xac>
    e7e8:	2b18      	cmp	r3, #24
    e7ea:	d00b      	beq.n	e804 <HAL_RCC_GetSysClockFreq+0x28>
    e7ec:	b10b      	cbz	r3, e7f2 <HAL_RCC_GetSysClockFreq+0x16>
      }

    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
    e7ee:	483b      	ldr	r0, [pc, #236]	; (e8dc <HAL_RCC_GetSysClockFreq+0x100>)
    e7f0:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    e7f2:	6813      	ldr	r3, [r2, #0]
    e7f4:	0699      	lsls	r1, r3, #26
    e7f6:	d549      	bpl.n	e88c <HAL_RCC_GetSysClockFreq+0xb0>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e7f8:	6813      	ldr	r3, [r2, #0]
    e7fa:	4839      	ldr	r0, [pc, #228]	; (e8e0 <HAL_RCC_GetSysClockFreq+0x104>)
    e7fc:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    e800:	40d8      	lsrs	r0, r3
    e802:	4770      	bx	lr
{
    e804:	b410      	push	{r4}
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    e806:	6a91      	ldr	r1, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    e808:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    e80a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    e80c:	f3c0 1005 	ubfx	r0, r0, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e810:	6b54      	ldr	r4, [r2, #52]	; 0x34

    if (pllm != 0U)
    e812:	b3b0      	cbz	r0, e882 <HAL_RCC_GetSysClockFreq+0xa6>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e814:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    e818:	f003 0301 	and.w	r3, r3, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    e81c:	f001 0103 	and.w	r1, r1, #3
    e820:	ee07 0a90 	vmov	s15, r0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e824:	fb03 f304 	mul.w	r3, r3, r4
    {
      switch (pllsource)
    e828:	2901      	cmp	r1, #1
    e82a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    e82e:	ee07 3a10 	vmov	s14, r3
    e832:	eeba 7ae9 	vcvt.f32.s32	s14, s14, #13
      switch (pllsource)
    e836:	d002      	beq.n	e83e <HAL_RCC_GetSysClockFreq+0x62>
    e838:	d32d      	bcc.n	e896 <HAL_RCC_GetSysClockFreq+0xba>
    e83a:	2902      	cmp	r1, #2
    e83c:	d028      	beq.n	e890 <HAL_RCC_GetSysClockFreq+0xb4>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e83e:	eddf 5a29 	vldr	s11, [pc, #164]	; e8e4 <HAL_RCC_GetSysClockFreq+0x108>
    e842:	eec5 6aa7 	vdiv.f32	s13, s11, s15
    e846:	6b13      	ldr	r3, [r2, #48]	; 0x30
    e848:	f3c3 0308 	ubfx	r3, r3, #0, #9
    e84c:	ee07 3a90 	vmov	s15, r3
    e850:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    e854:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    e858:	ee77 7a86 	vadd.f32	s15, s15, s12
    e85c:	ee37 7a87 	vadd.f32	s14, s15, s14
    e860:	ee27 7a26 	vmul.f32	s14, s14, s13
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
    e864:	4b1c      	ldr	r3, [pc, #112]	; (e8d8 <HAL_RCC_GetSysClockFreq+0xfc>)
    e866:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    e868:	f3c3 2346 	ubfx	r3, r3, #9, #7
    e86c:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    e86e:	ee07 3a90 	vmov	s15, r3
    e872:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    e876:	eec7 7a26 	vdiv.f32	s15, s14, s13
    e87a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    e87e:	ee17 0a90 	vmov	r0, s15
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
    e882:	f85d 4b04 	ldr.w	r4, [sp], #4
    e886:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
    e888:	4817      	ldr	r0, [pc, #92]	; (e8e8 <HAL_RCC_GetSysClockFreq+0x10c>)
    e88a:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
    e88c:	4814      	ldr	r0, [pc, #80]	; (e8e0 <HAL_RCC_GetSysClockFreq+0x104>)
}
    e88e:	4770      	bx	lr
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e890:	eddf 5a16 	vldr	s11, [pc, #88]	; e8ec <HAL_RCC_GetSysClockFreq+0x110>
    e894:	e7d5      	b.n	e842 <HAL_RCC_GetSysClockFreq+0x66>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    e896:	6813      	ldr	r3, [r2, #0]
    e898:	069b      	lsls	r3, r3, #26
    e89a:	d51a      	bpl.n	e8d2 <HAL_RCC_GetSysClockFreq+0xf6>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e89c:	6810      	ldr	r0, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e89e:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e8a2:	490f      	ldr	r1, [pc, #60]	; (e8e0 <HAL_RCC_GetSysClockFreq+0x104>)
    e8a4:	f3c0 00c1 	ubfx	r0, r0, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e8a8:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    e8aa:	40c1      	lsrs	r1, r0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e8ac:	f3c3 0308 	ubfx	r3, r3, #0, #9
    e8b0:	ee06 1a90 	vmov	s13, r1
    e8b4:	eef8 5ae6 	vcvt.f32.s32	s11, s13
    e8b8:	ee06 3a90 	vmov	s13, r3
    e8bc:	eeb8 6ae6 	vcvt.f32.s32	s12, s13
    e8c0:	eec5 6aa7 	vdiv.f32	s13, s11, s15
    e8c4:	ee76 7a05 	vadd.f32	s15, s12, s10
    e8c8:	ee37 7a87 	vadd.f32	s14, s15, s14
    e8cc:	ee26 7a87 	vmul.f32	s14, s13, s14
    e8d0:	e7c8      	b.n	e864 <HAL_RCC_GetSysClockFreq+0x88>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    e8d2:	eddf 5a07 	vldr	s11, [pc, #28]	; e8f0 <HAL_RCC_GetSysClockFreq+0x114>
    e8d6:	e7b4      	b.n	e842 <HAL_RCC_GetSysClockFreq+0x66>
    e8d8:	58024400 	.word	0x58024400
    e8dc:	003d0900 	.word	0x003d0900
    e8e0:	03d09000 	.word	0x03d09000
    e8e4:	4a742400 	.word	0x4a742400
    e8e8:	017d7840 	.word	0x017d7840
    e8ec:	4bbebc20 	.word	0x4bbebc20
    e8f0:	4c742400 	.word	0x4c742400

0000e8f4 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
    e8f4:	2800      	cmp	r0, #0
    e8f6:	f000 81bd 	beq.w	ec74 <HAL_RCC_ClockConfig+0x380>
{
    e8fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    e8fe:	6803      	ldr	r3, [r0, #0]
    e900:	4604      	mov	r4, r0
    e902:	460d      	mov	r5, r1
    e904:	3b01      	subs	r3, #1
    e906:	2b3e      	cmp	r3, #62	; 0x3e
    e908:	f200 81a1 	bhi.w	ec4e <HAL_RCC_ClockConfig+0x35a>
  assert_param(IS_FLASH_LATENCY(FLatency));
    e90c:	2d0f      	cmp	r5, #15
    e90e:	f200 818e 	bhi.w	ec2e <HAL_RCC_ClockConfig+0x33a>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
    e912:	4a5e      	ldr	r2, [pc, #376]	; (ea8c <HAL_RCC_ClockConfig+0x198>)
    e914:	6813      	ldr	r3, [r2, #0]
    e916:	f003 030f 	and.w	r3, r3, #15
    e91a:	42ab      	cmp	r3, r5
    e91c:	f0c0 81ac 	bcc.w	ec78 <HAL_RCC_ClockConfig+0x384>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
    e920:	6823      	ldr	r3, [r4, #0]
    e922:	075e      	lsls	r6, r3, #29
    e924:	d512      	bpl.n	e94c <HAL_RCC_ClockConfig+0x58>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    e926:	4a5a      	ldr	r2, [pc, #360]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e928:	6921      	ldr	r1, [r4, #16]
    e92a:	6992      	ldr	r2, [r2, #24]
    e92c:	f002 0270 	and.w	r2, r2, #112	; 0x70
    e930:	4291      	cmp	r1, r2
    e932:	d90b      	bls.n	e94c <HAL_RCC_ClockConfig+0x58>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    e934:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    e938:	2b40      	cmp	r3, #64	; 0x40
    e93a:	f040 81c0 	bne.w	ecbe <HAL_RCC_ClockConfig+0x3ca>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    e93e:	4a54      	ldr	r2, [pc, #336]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e940:	6993      	ldr	r3, [r2, #24]
    e942:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    e946:	4319      	orrs	r1, r3
    e948:	6191      	str	r1, [r2, #24]
    e94a:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    e94c:	0718      	lsls	r0, r3, #28
    e94e:	d512      	bpl.n	e976 <HAL_RCC_ClockConfig+0x82>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    e950:	4a4f      	ldr	r2, [pc, #316]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e952:	6961      	ldr	r1, [r4, #20]
    e954:	69d2      	ldr	r2, [r2, #28]
    e956:	f002 0270 	and.w	r2, r2, #112	; 0x70
    e95a:	4291      	cmp	r1, r2
    e95c:	d90b      	bls.n	e976 <HAL_RCC_ClockConfig+0x82>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    e95e:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    e962:	2b40      	cmp	r3, #64	; 0x40
    e964:	f040 81b2 	bne.w	eccc <HAL_RCC_ClockConfig+0x3d8>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    e968:	4a49      	ldr	r2, [pc, #292]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e96a:	69d3      	ldr	r3, [r2, #28]
    e96c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    e970:	4319      	orrs	r1, r3
    e972:	61d1      	str	r1, [r2, #28]
    e974:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    e976:	06d9      	lsls	r1, r3, #27
    e978:	d513      	bpl.n	e9a2 <HAL_RCC_ClockConfig+0xae>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    e97a:	4a45      	ldr	r2, [pc, #276]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e97c:	69a1      	ldr	r1, [r4, #24]
    e97e:	69d2      	ldr	r2, [r2, #28]
    e980:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    e984:	4291      	cmp	r1, r2
    e986:	d90c      	bls.n	e9a2 <HAL_RCC_ClockConfig+0xae>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    e988:	f421 7340 	bic.w	r3, r1, #768	; 0x300
    e98c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    e990:	f040 81a3 	bne.w	ecda <HAL_RCC_ClockConfig+0x3e6>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    e994:	4a3e      	ldr	r2, [pc, #248]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e996:	69d3      	ldr	r3, [r2, #28]
    e998:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    e99c:	4319      	orrs	r1, r3
    e99e:	61d1      	str	r1, [r2, #28]
    e9a0:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
    e9a2:	069a      	lsls	r2, r3, #26
    e9a4:	d512      	bpl.n	e9cc <HAL_RCC_ClockConfig+0xd8>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    e9a6:	4a3a      	ldr	r2, [pc, #232]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9a8:	69e1      	ldr	r1, [r4, #28]
    e9aa:	6a12      	ldr	r2, [r2, #32]
    e9ac:	f002 0270 	and.w	r2, r2, #112	; 0x70
    e9b0:	4291      	cmp	r1, r2
    e9b2:	d90b      	bls.n	e9cc <HAL_RCC_ClockConfig+0xd8>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    e9b4:	f021 0330 	bic.w	r3, r1, #48	; 0x30
    e9b8:	2b40      	cmp	r3, #64	; 0x40
    e9ba:	f040 8179 	bne.w	ecb0 <HAL_RCC_ClockConfig+0x3bc>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    e9be:	4a34      	ldr	r2, [pc, #208]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9c0:	6a13      	ldr	r3, [r2, #32]
    e9c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    e9c6:	4319      	orrs	r1, r3
    e9c8:	6211      	str	r1, [r2, #32]
    e9ca:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    e9cc:	079f      	lsls	r7, r3, #30
    e9ce:	d512      	bpl.n	e9f6 <HAL_RCC_ClockConfig+0x102>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
    e9d0:	4a2f      	ldr	r2, [pc, #188]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9d2:	68e1      	ldr	r1, [r4, #12]
    e9d4:	6992      	ldr	r2, [r2, #24]
    e9d6:	f002 020f 	and.w	r2, r2, #15
    e9da:	4291      	cmp	r1, r2
    e9dc:	d90b      	bls.n	e9f6 <HAL_RCC_ClockConfig+0x102>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    e9de:	f1a1 0308 	sub.w	r3, r1, #8
    e9e2:	2b07      	cmp	r3, #7
    e9e4:	f200 8180 	bhi.w	ece8 <HAL_RCC_ClockConfig+0x3f4>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    e9e8:	4a29      	ldr	r2, [pc, #164]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    e9ea:	6993      	ldr	r3, [r2, #24]
    e9ec:	f023 030f 	bic.w	r3, r3, #15
    e9f0:	4319      	orrs	r1, r3
    e9f2:	6191      	str	r1, [r2, #24]
    e9f4:	6823      	ldr	r3, [r4, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    e9f6:	07de      	lsls	r6, r3, #31
    e9f8:	d55a      	bpl.n	eab0 <HAL_RCC_ClockConfig+0x1bc>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    e9fa:	68a2      	ldr	r2, [r4, #8]
    e9fc:	f432 6300 	bics.w	r3, r2, #2048	; 0x800
    ea00:	f422 7000 	bic.w	r0, r2, #512	; 0x200
    ea04:	f422 6180 	bic.w	r1, r2, #1024	; 0x400
    ea08:	bf14      	ite	ne
    ea0a:	2301      	movne	r3, #1
    ea0c:	2300      	moveq	r3, #0
    ea0e:	f5b0 6f10 	cmp.w	r0, #2304	; 0x900
    ea12:	bf0c      	ite	eq
    ea14:	2300      	moveq	r3, #0
    ea16:	f003 0301 	andne.w	r3, r3, #1
    ea1a:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
    ea1e:	bf0c      	ite	eq
    ea20:	2300      	moveq	r3, #0
    ea22:	f003 0301 	andne.w	r3, r3, #1
    ea26:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
    ea2a:	bf0c      	ite	eq
    ea2c:	2300      	moveq	r3, #0
    ea2e:	f003 0301 	andne.w	r3, r3, #1
    ea32:	b12b      	cbz	r3, ea40 <HAL_RCC_ClockConfig+0x14c>
    ea34:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    ea38:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
    ea3c:	f040 812e 	bne.w	ec9c <HAL_RCC_ClockConfig+0x3a8>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    ea40:	6863      	ldr	r3, [r4, #4]
    ea42:	2b03      	cmp	r3, #3
    ea44:	f200 8110 	bhi.w	ec68 <HAL_RCC_ClockConfig+0x374>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
    ea48:	4a11      	ldr	r2, [pc, #68]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
    ea4a:	68a1      	ldr	r1, [r4, #8]
    ea4c:	6993      	ldr	r3, [r2, #24]
    ea4e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
    ea52:	430b      	orrs	r3, r1
    ea54:	6193      	str	r3, [r2, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    ea56:	6863      	ldr	r3, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ea58:	6812      	ldr	r2, [r2, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    ea5a:	2b02      	cmp	r3, #2
    ea5c:	f000 8100 	beq.w	ec60 <HAL_RCC_ClockConfig+0x36c>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    ea60:	2b03      	cmp	r3, #3
    ea62:	f000 8117 	beq.w	ec94 <HAL_RCC_ClockConfig+0x3a0>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
    ea66:	2b01      	cmp	r3, #1
    ea68:	f000 811e 	beq.w	eca8 <HAL_RCC_ClockConfig+0x3b4>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    ea6c:	0757      	lsls	r7, r2, #29
    ea6e:	f140 80eb 	bpl.w	ec48 <HAL_RCC_ClockConfig+0x354>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    ea72:	4907      	ldr	r1, [pc, #28]	; (ea90 <HAL_RCC_ClockConfig+0x19c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    ea74:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    ea78:	690a      	ldr	r2, [r1, #16]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    ea7a:	460e      	mov	r6, r1
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    ea7c:	f022 0207 	bic.w	r2, r2, #7
    ea80:	4313      	orrs	r3, r2
    ea82:	610b      	str	r3, [r1, #16]
      tickstart = HAL_GetTick();
    ea84:	f7f9 fcb6 	bl	83f4 <HAL_GetTick>
    ea88:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    ea8a:	e009      	b.n	eaa0 <HAL_RCC_ClockConfig+0x1ac>
    ea8c:	52002000 	.word	0x52002000
    ea90:	58024400 	.word	0x58024400
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    ea94:	f7f9 fcae 	bl	83f4 <HAL_GetTick>
    ea98:	1bc0      	subs	r0, r0, r7
    ea9a:	4540      	cmp	r0, r8
    ea9c:	f200 80f8 	bhi.w	ec90 <HAL_RCC_ClockConfig+0x39c>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    eaa0:	6933      	ldr	r3, [r6, #16]
    eaa2:	6862      	ldr	r2, [r4, #4]
    eaa4:	f003 0338 	and.w	r3, r3, #56	; 0x38
    eaa8:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
    eaac:	d1f2      	bne.n	ea94 <HAL_RCC_ClockConfig+0x1a0>
    eaae:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    eab0:	079e      	lsls	r6, r3, #30
    eab2:	d517      	bpl.n	eae4 <HAL_RCC_ClockConfig+0x1f0>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
    eab4:	4b90      	ldr	r3, [pc, #576]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eab6:	68e2      	ldr	r2, [r4, #12]
    eab8:	699b      	ldr	r3, [r3, #24]
    eaba:	f003 030f 	and.w	r3, r3, #15
    eabe:	429a      	cmp	r2, r3
    eac0:	d210      	bcs.n	eae4 <HAL_RCC_ClockConfig+0x1f0>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    eac2:	f1a2 0308 	sub.w	r3, r2, #8
    eac6:	2b06      	cmp	r3, #6
    eac8:	d906      	bls.n	ead8 <HAL_RCC_ClockConfig+0x1e4>
    eaca:	b12a      	cbz	r2, ead8 <HAL_RCC_ClockConfig+0x1e4>
    eacc:	f240 4136 	movw	r1, #1078	; 0x436
    ead0:	488a      	ldr	r0, [pc, #552]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ead2:	f00a fcf5 	bl	194c0 <assert_failed>
    ead6:	68e2      	ldr	r2, [r4, #12]
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    ead8:	4987      	ldr	r1, [pc, #540]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eada:	698b      	ldr	r3, [r1, #24]
    eadc:	f023 030f 	bic.w	r3, r3, #15
    eae0:	431a      	orrs	r2, r3
    eae2:	618a      	str	r2, [r1, #24]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
    eae4:	4a86      	ldr	r2, [pc, #536]	; (ed00 <HAL_RCC_ClockConfig+0x40c>)
    eae6:	6813      	ldr	r3, [r2, #0]
    eae8:	f003 030f 	and.w	r3, r3, #15
    eaec:	42ab      	cmp	r3, r5
    eaee:	d90a      	bls.n	eb06 <HAL_RCC_ClockConfig+0x212>
    __HAL_FLASH_SET_LATENCY(FLatency);
    eaf0:	6813      	ldr	r3, [r2, #0]
    eaf2:	f023 030f 	bic.w	r3, r3, #15
    eaf6:	432b      	orrs	r3, r5
    eaf8:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    eafa:	6813      	ldr	r3, [r2, #0]
    eafc:	f003 030f 	and.w	r3, r3, #15
    eb00:	42ab      	cmp	r3, r5
    eb02:	f040 80a1 	bne.w	ec48 <HAL_RCC_ClockConfig+0x354>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
    eb06:	6823      	ldr	r3, [r4, #0]
    eb08:	0758      	lsls	r0, r3, #29
    eb0a:	d51a      	bpl.n	eb42 <HAL_RCC_ClockConfig+0x24e>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    eb0c:	4a7a      	ldr	r2, [pc, #488]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb0e:	6921      	ldr	r1, [r4, #16]
    eb10:	6992      	ldr	r2, [r2, #24]
    eb12:	f002 0270 	and.w	r2, r2, #112	; 0x70
    eb16:	4291      	cmp	r1, r2
    eb18:	d213      	bcs.n	eb42 <HAL_RCC_ClockConfig+0x24e>
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    eb1a:	2950      	cmp	r1, #80	; 0x50
    eb1c:	bf18      	it	ne
    eb1e:	2960      	cmpne	r1, #96	; 0x60
    eb20:	d008      	beq.n	eb34 <HAL_RCC_ClockConfig+0x240>
    eb22:	f031 0340 	bics.w	r3, r1, #64	; 0x40
    eb26:	d005      	beq.n	eb34 <HAL_RCC_ClockConfig+0x240>
    eb28:	f240 4157 	movw	r1, #1111	; 0x457
    eb2c:	4873      	ldr	r0, [pc, #460]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eb2e:	f00a fcc7 	bl	194c0 <assert_failed>
    eb32:	6921      	ldr	r1, [r4, #16]
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    eb34:	4a70      	ldr	r2, [pc, #448]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb36:	6993      	ldr	r3, [r2, #24]
    eb38:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    eb3c:	4319      	orrs	r1, r3
    eb3e:	6191      	str	r1, [r2, #24]
    eb40:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    eb42:	0719      	lsls	r1, r3, #28
    eb44:	d51a      	bpl.n	eb7c <HAL_RCC_ClockConfig+0x288>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    eb46:	4a6c      	ldr	r2, [pc, #432]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb48:	6961      	ldr	r1, [r4, #20]
    eb4a:	69d2      	ldr	r2, [r2, #28]
    eb4c:	f002 0270 	and.w	r2, r2, #112	; 0x70
    eb50:	4291      	cmp	r1, r2
    eb52:	d213      	bcs.n	eb7c <HAL_RCC_ClockConfig+0x288>
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    eb54:	2950      	cmp	r1, #80	; 0x50
    eb56:	bf18      	it	ne
    eb58:	2960      	cmpne	r1, #96	; 0x60
    eb5a:	d008      	beq.n	eb6e <HAL_RCC_ClockConfig+0x27a>
    eb5c:	f031 0340 	bics.w	r3, r1, #64	; 0x40
    eb60:	d005      	beq.n	eb6e <HAL_RCC_ClockConfig+0x27a>
    eb62:	f240 4169 	movw	r1, #1129	; 0x469
    eb66:	4865      	ldr	r0, [pc, #404]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eb68:	f00a fcaa 	bl	194c0 <assert_failed>
    eb6c:	6961      	ldr	r1, [r4, #20]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    eb6e:	4a62      	ldr	r2, [pc, #392]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb70:	69d3      	ldr	r3, [r2, #28]
    eb72:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    eb76:	4319      	orrs	r1, r3
    eb78:	61d1      	str	r1, [r2, #28]
    eb7a:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    eb7c:	06da      	lsls	r2, r3, #27
    eb7e:	d51c      	bpl.n	ebba <HAL_RCC_ClockConfig+0x2c6>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    eb80:	4a5d      	ldr	r2, [pc, #372]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    eb82:	69a1      	ldr	r1, [r4, #24]
    eb84:	69d2      	ldr	r2, [r2, #28]
    eb86:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    eb8a:	4291      	cmp	r1, r2
    eb8c:	d215      	bcs.n	ebba <HAL_RCC_ClockConfig+0x2c6>
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    eb8e:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    eb92:	bf18      	it	ne
    eb94:	f5b1 6fa0 	cmpne.w	r1, #1280	; 0x500
    eb98:	d008      	beq.n	ebac <HAL_RCC_ClockConfig+0x2b8>
    eb9a:	f431 6380 	bics.w	r3, r1, #1024	; 0x400
    eb9e:	d005      	beq.n	ebac <HAL_RCC_ClockConfig+0x2b8>
    eba0:	f240 417b 	movw	r1, #1147	; 0x47b
    eba4:	4855      	ldr	r0, [pc, #340]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eba6:	f00a fc8b 	bl	194c0 <assert_failed>
    ebaa:	69a1      	ldr	r1, [r4, #24]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    ebac:	4a52      	ldr	r2, [pc, #328]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebae:	69d3      	ldr	r3, [r2, #28]
    ebb0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    ebb4:	4319      	orrs	r1, r3
    ebb6:	61d1      	str	r1, [r2, #28]
    ebb8:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
    ebba:	069b      	lsls	r3, r3, #26
    ebbc:	d519      	bpl.n	ebf2 <HAL_RCC_ClockConfig+0x2fe>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    ebbe:	4b4e      	ldr	r3, [pc, #312]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebc0:	69e2      	ldr	r2, [r4, #28]
    ebc2:	6a1b      	ldr	r3, [r3, #32]
    ebc4:	f003 0370 	and.w	r3, r3, #112	; 0x70
    ebc8:	429a      	cmp	r2, r3
    ebca:	d212      	bcs.n	ebf2 <HAL_RCC_ClockConfig+0x2fe>
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    ebcc:	2a50      	cmp	r2, #80	; 0x50
    ebce:	bf18      	it	ne
    ebd0:	2a60      	cmpne	r2, #96	; 0x60
    ebd2:	d008      	beq.n	ebe6 <HAL_RCC_ClockConfig+0x2f2>
    ebd4:	f032 0340 	bics.w	r3, r2, #64	; 0x40
    ebd8:	d005      	beq.n	ebe6 <HAL_RCC_ClockConfig+0x2f2>
    ebda:	f240 418d 	movw	r1, #1165	; 0x48d
    ebde:	4847      	ldr	r0, [pc, #284]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ebe0:	f00a fc6e 	bl	194c0 <assert_failed>
    ebe4:	69e2      	ldr	r2, [r4, #28]
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    ebe6:	4944      	ldr	r1, [pc, #272]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebe8:	6a0b      	ldr	r3, [r1, #32]
    ebea:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    ebee:	431a      	orrs	r2, r3
    ebf0:	620a      	str	r2, [r1, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ebf2:	f7ff fdf3 	bl	e7dc <HAL_RCC_GetSysClockFreq>
    ebf6:	4a40      	ldr	r2, [pc, #256]	; (ecf8 <HAL_RCC_ClockConfig+0x404>)
    ebf8:	4942      	ldr	r1, [pc, #264]	; (ed04 <HAL_RCC_ClockConfig+0x410>)
    ebfa:	6993      	ldr	r3, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ebfc:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ebfe:	f3c3 2303 	ubfx	r3, r3, #8, #4
  halstatus = HAL_InitTick (uwTickPrio);
    ec02:	4d41      	ldr	r5, [pc, #260]	; (ed08 <HAL_RCC_ClockConfig+0x414>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec04:	f002 020f 	and.w	r2, r2, #15
    ec08:	4c40      	ldr	r4, [pc, #256]	; (ed0c <HAL_RCC_ClockConfig+0x418>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ec0a:	5ccb      	ldrb	r3, [r1, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec0c:	5c8a      	ldrb	r2, [r1, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ec0e:	f003 031f 	and.w	r3, r3, #31
  SystemCoreClock = common_system_clock;
    ec12:	493f      	ldr	r1, [pc, #252]	; (ed10 <HAL_RCC_ClockConfig+0x41c>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec14:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
    ec18:	fa20 f303 	lsr.w	r3, r0, r3
  halstatus = HAL_InitTick (uwTickPrio);
    ec1c:	6828      	ldr	r0, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec1e:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
    ec22:	600b      	str	r3, [r1, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ec24:	6022      	str	r2, [r4, #0]
}
    ec26:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
    ec2a:	f7f9 bb8b 	b.w	8344 <HAL_InitTick>
  assert_param(IS_FLASH_LATENCY(FLatency));
    ec2e:	f44f 7160 	mov.w	r1, #896	; 0x380
    ec32:	4832      	ldr	r0, [pc, #200]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ec34:	f00a fc44 	bl	194c0 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
    ec38:	4b31      	ldr	r3, [pc, #196]	; (ed00 <HAL_RCC_ClockConfig+0x40c>)
    ec3a:	681a      	ldr	r2, [r3, #0]
    __HAL_FLASH_SET_LATENCY(FLatency);
    ec3c:	6819      	ldr	r1, [r3, #0]
    ec3e:	f021 010f 	bic.w	r1, r1, #15
    ec42:	430d      	orrs	r5, r1
    ec44:	601d      	str	r5, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    ec46:	681b      	ldr	r3, [r3, #0]
    return HAL_ERROR;
    ec48:	2001      	movs	r0, #1
}
    ec4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    ec4e:	f240 317f 	movw	r1, #895	; 0x37f
    ec52:	482a      	ldr	r0, [pc, #168]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ec54:	f00a fc34 	bl	194c0 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
    ec58:	2d0f      	cmp	r5, #15
    ec5a:	f67f ae5a 	bls.w	e912 <HAL_RCC_ClockConfig+0x1e>
    ec5e:	e7e6      	b.n	ec2e <HAL_RCC_ClockConfig+0x33a>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
    ec60:	0390      	lsls	r0, r2, #14
    ec62:	f53f af06 	bmi.w	ea72 <HAL_RCC_ClockConfig+0x17e>
    ec66:	e7ef      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    ec68:	f240 31f5 	movw	r1, #1013	; 0x3f5
    ec6c:	4823      	ldr	r0, [pc, #140]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ec6e:	f00a fc27 	bl	194c0 <assert_failed>
    ec72:	e6e9      	b.n	ea48 <HAL_RCC_ClockConfig+0x154>
    return HAL_ERROR;
    ec74:	2001      	movs	r0, #1
}
    ec76:	4770      	bx	lr
    __HAL_FLASH_SET_LATENCY(FLatency);
    ec78:	6813      	ldr	r3, [r2, #0]
    ec7a:	f023 030f 	bic.w	r3, r3, #15
    ec7e:	432b      	orrs	r3, r5
    ec80:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
    ec82:	6813      	ldr	r3, [r2, #0]
    ec84:	f003 030f 	and.w	r3, r3, #15
    ec88:	42ab      	cmp	r3, r5
    ec8a:	f43f ae49 	beq.w	e920 <HAL_RCC_ClockConfig+0x2c>
    ec8e:	e7db      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
            return HAL_TIMEOUT;
    ec90:	2003      	movs	r0, #3
    ec92:	e7da      	b.n	ec4a <HAL_RCC_ClockConfig+0x356>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
    ec94:	0191      	lsls	r1, r2, #6
    ec96:	f53f aeec 	bmi.w	ea72 <HAL_RCC_ClockConfig+0x17e>
    ec9a:	e7d5      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    ec9c:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
    eca0:	4816      	ldr	r0, [pc, #88]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    eca2:	f00a fc0d 	bl	194c0 <assert_failed>
    eca6:	e6cb      	b.n	ea40 <HAL_RCC_ClockConfig+0x14c>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    eca8:	05d2      	lsls	r2, r2, #23
    ecaa:	f53f aee2 	bmi.w	ea72 <HAL_RCC_ClockConfig+0x17e>
    ecae:	e7cb      	b.n	ec48 <HAL_RCC_ClockConfig+0x354>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    ecb0:	f240 31d1 	movw	r1, #977	; 0x3d1
    ecb4:	4811      	ldr	r0, [pc, #68]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecb6:	f00a fc03 	bl	194c0 <assert_failed>
    ecba:	69e1      	ldr	r1, [r4, #28]
    ecbc:	e67f      	b.n	e9be <HAL_RCC_ClockConfig+0xca>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    ecbe:	f44f 7167 	mov.w	r1, #924	; 0x39c
    ecc2:	480e      	ldr	r0, [pc, #56]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecc4:	f00a fbfc 	bl	194c0 <assert_failed>
    ecc8:	6921      	ldr	r1, [r4, #16]
    ecca:	e638      	b.n	e93e <HAL_RCC_ClockConfig+0x4a>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    eccc:	f240 31ae 	movw	r1, #942	; 0x3ae
    ecd0:	480a      	ldr	r0, [pc, #40]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecd2:	f00a fbf5 	bl	194c0 <assert_failed>
    ecd6:	6961      	ldr	r1, [r4, #20]
    ecd8:	e646      	b.n	e968 <HAL_RCC_ClockConfig+0x74>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    ecda:	f240 31bf 	movw	r1, #959	; 0x3bf
    ecde:	4807      	ldr	r0, [pc, #28]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ece0:	f00a fbee 	bl	194c0 <assert_failed>
    ece4:	69a1      	ldr	r1, [r4, #24]
    ece6:	e655      	b.n	e994 <HAL_RCC_ClockConfig+0xa0>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    ece8:	f44f 7179 	mov.w	r1, #996	; 0x3e4
    ecec:	4803      	ldr	r0, [pc, #12]	; (ecfc <HAL_RCC_ClockConfig+0x408>)
    ecee:	f00a fbe7 	bl	194c0 <assert_failed>
    ecf2:	68e1      	ldr	r1, [r4, #12]
    ecf4:	e678      	b.n	e9e8 <HAL_RCC_ClockConfig+0xf4>
    ecf6:	bf00      	nop
    ecf8:	58024400 	.word	0x58024400
    ecfc:	000301a8 	.word	0x000301a8
    ed00:	52002000 	.word	0x52002000
    ed04:	00031054 	.word	0x00031054
    ed08:	00062898 	.word	0x00062898
    ed0c:	00062b48 	.word	0x00062b48
    ed10:	00062b44 	.word	0x00062b44

0000ed14 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
    ed14:	4a49      	ldr	r2, [pc, #292]	; (ee3c <HAL_RCC_GetHCLKFreq+0x128>)
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
    ed16:	b430      	push	{r4, r5}
  switch (RCC->CFGR & RCC_CFGR_SWS)
    ed18:	6913      	ldr	r3, [r2, #16]
    ed1a:	f003 0338 	and.w	r3, r3, #56	; 0x38
    ed1e:	2b10      	cmp	r3, #16
    ed20:	d064      	beq.n	edec <HAL_RCC_GetHCLKFreq+0xd8>
    ed22:	2b18      	cmp	r3, #24
    ed24:	d022      	beq.n	ed6c <HAL_RCC_GetHCLKFreq+0x58>
    ed26:	b1bb      	cbz	r3, ed58 <HAL_RCC_GetHCLKFreq+0x44>
    sysclockfreq = CSI_VALUE;
    ed28:	4b45      	ldr	r3, [pc, #276]	; (ee40 <HAL_RCC_GetHCLKFreq+0x12c>)
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed2a:	4944      	ldr	r1, [pc, #272]	; (ee3c <HAL_RCC_GetHCLKFreq+0x128>)
    ed2c:	4845      	ldr	r0, [pc, #276]	; (ee44 <HAL_RCC_GetHCLKFreq+0x130>)
    ed2e:	698a      	ldr	r2, [r1, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed30:	6989      	ldr	r1, [r1, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed32:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed36:	4c44      	ldr	r4, [pc, #272]	; (ee48 <HAL_RCC_GetHCLKFreq+0x134>)
    ed38:	f001 010f 	and.w	r1, r1, #15
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
    ed3c:	4d43      	ldr	r5, [pc, #268]	; (ee4c <HAL_RCC_GetHCLKFreq+0x138>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed3e:	5c82      	ldrb	r2, [r0, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed40:	5c40      	ldrb	r0, [r0, r1]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed42:	f002 021f 	and.w	r2, r2, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed46:	f000 001f 	and.w	r0, r0, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
    ed4a:	40d3      	lsrs	r3, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed4c:	fa23 f000 	lsr.w	r0, r3, r0
  SystemCoreClock = common_system_clock;
    ed50:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
    ed52:	6020      	str	r0, [r4, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
    ed54:	bc30      	pop	{r4, r5}
    ed56:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    ed58:	6813      	ldr	r3, [r2, #0]
    ed5a:	0699      	lsls	r1, r3, #26
    ed5c:	d548      	bpl.n	edf0 <HAL_RCC_GetHCLKFreq+0xdc>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ed5e:	6813      	ldr	r3, [r2, #0]
    ed60:	4a3b      	ldr	r2, [pc, #236]	; (ee50 <HAL_RCC_GetHCLKFreq+0x13c>)
    ed62:	f3c3 03c1 	ubfx	r3, r3, #3, #2
    ed66:	fa22 f303 	lsr.w	r3, r2, r3
    ed6a:	e7de      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    ed6c:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    ed6e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    ed70:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    ed72:	f3c3 1305 	ubfx	r3, r3, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed76:	6b54      	ldr	r4, [r2, #52]	; 0x34
    if (pllm != 0U)
    ed78:	2b00      	cmp	r3, #0
    ed7a:	d0d6      	beq.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed7c:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    ed80:	f001 0101 	and.w	r1, r1, #1
    ed84:	ee07 3a90 	vmov	s15, r3
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    ed88:	f000 0003 	and.w	r0, r0, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed8c:	fb01 f304 	mul.w	r3, r1, r4
    ed90:	eef8 6ae7 	vcvt.f32.s32	s13, s15
      switch (pllsource)
    ed94:	2801      	cmp	r0, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
    ed96:	ee07 3a90 	vmov	s15, r3
    ed9a:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
      switch (pllsource)
    ed9e:	d002      	beq.n	eda6 <HAL_RCC_GetHCLKFreq+0x92>
    eda0:	d32b      	bcc.n	edfa <HAL_RCC_GetHCLKFreq+0xe6>
    eda2:	2802      	cmp	r0, #2
    eda4:	d026      	beq.n	edf4 <HAL_RCC_GetHCLKFreq+0xe0>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    eda6:	ed9f 7a2b 	vldr	s14, [pc, #172]	; ee54 <HAL_RCC_GetHCLKFreq+0x140>
    edaa:	ee87 6a26 	vdiv.f32	s12, s14, s13
    edae:	6b13      	ldr	r3, [r2, #48]	; 0x30
    edb0:	f3c3 0308 	ubfx	r3, r3, #0, #9
    edb4:	ee07 3a10 	vmov	s14, r3
    edb8:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    edbc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    edc0:	ee37 7a25 	vadd.f32	s14, s14, s11
    edc4:	ee77 7a27 	vadd.f32	s15, s14, s15
    edc8:	ee67 7a86 	vmul.f32	s15, s15, s12
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
    edcc:	4b1b      	ldr	r3, [pc, #108]	; (ee3c <HAL_RCC_GetHCLKFreq+0x128>)
    edce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    edd0:	f3c3 2346 	ubfx	r3, r3, #9, #7
    edd4:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    edd6:	ee07 3a10 	vmov	s14, r3
    edda:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    edde:	eec7 6a87 	vdiv.f32	s13, s15, s14
    ede2:	eefc 7ae6 	vcvt.u32.f32	s15, s13
    ede6:	ee17 3a90 	vmov	r3, s15
    edea:	e79e      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
    sysclockfreq = HSE_VALUE;
    edec:	4b1a      	ldr	r3, [pc, #104]	; (ee58 <HAL_RCC_GetHCLKFreq+0x144>)
    edee:	e79c      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
        sysclockfreq = (uint32_t) HSI_VALUE;
    edf0:	4b17      	ldr	r3, [pc, #92]	; (ee50 <HAL_RCC_GetHCLKFreq+0x13c>)
    edf2:	e79a      	b.n	ed2a <HAL_RCC_GetHCLKFreq+0x16>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    edf4:	ed9f 7a19 	vldr	s14, [pc, #100]	; ee5c <HAL_RCC_GetHCLKFreq+0x148>
    edf8:	e7d7      	b.n	edaa <HAL_RCC_GetHCLKFreq+0x96>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    edfa:	6813      	ldr	r3, [r2, #0]
    edfc:	069b      	lsls	r3, r3, #26
    edfe:	d51a      	bpl.n	ee36 <HAL_RCC_GetHCLKFreq+0x122>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ee00:	6810      	ldr	r0, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee02:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ee06:	4912      	ldr	r1, [pc, #72]	; (ee50 <HAL_RCC_GetHCLKFreq+0x13c>)
    ee08:	f3c0 00c1 	ubfx	r0, r0, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee0c:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ee0e:	40c1      	lsrs	r1, r0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee10:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ee14:	ee07 1a10 	vmov	s14, r1
    ee18:	eef8 5ac7 	vcvt.f32.s32	s11, s14
    ee1c:	ee07 3a10 	vmov	s14, r3
    ee20:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
    ee24:	ee85 7aa6 	vdiv.f32	s14, s11, s13
    ee28:	ee76 6a05 	vadd.f32	s13, s12, s10
    ee2c:	ee76 7aa7 	vadd.f32	s15, s13, s15
    ee30:	ee67 7a27 	vmul.f32	s15, s14, s15
    ee34:	e7ca      	b.n	edcc <HAL_RCC_GetHCLKFreq+0xb8>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    ee36:	ed9f 7a0a 	vldr	s14, [pc, #40]	; ee60 <HAL_RCC_GetHCLKFreq+0x14c>
    ee3a:	e7b6      	b.n	edaa <HAL_RCC_GetHCLKFreq+0x96>
    ee3c:	58024400 	.word	0x58024400
    ee40:	003d0900 	.word	0x003d0900
    ee44:	00031054 	.word	0x00031054
    ee48:	00062b48 	.word	0x00062b48
    ee4c:	00062b44 	.word	0x00062b44
    ee50:	03d09000 	.word	0x03d09000
    ee54:	4a742400 	.word	0x4a742400
    ee58:	017d7840 	.word	0x017d7840
    ee5c:	4bbebc20 	.word	0x4bbebc20
    ee60:	4c742400 	.word	0x4c742400

0000ee64 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
    ee64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    ee66:	6803      	ldr	r3, [r0, #0]
{
    ee68:	4604      	mov	r4, r0
    ee6a:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    ee6c:	3b01      	subs	r3, #1
    ee6e:	2b3e      	cmp	r3, #62	; 0x3e
    ee70:	f200 809a 	bhi.w	efa8 <RCCEx_PLL2_Config+0x144>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
    ee74:	6863      	ldr	r3, [r4, #4]
    ee76:	3b04      	subs	r3, #4
    ee78:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    ee7c:	f200 809f 	bhi.w	efbe <RCCEx_PLL2_Config+0x15a>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
    ee80:	68a3      	ldr	r3, [r4, #8]
    ee82:	3b01      	subs	r3, #1
    ee84:	2b7f      	cmp	r3, #127	; 0x7f
    ee86:	f200 80a4 	bhi.w	efd2 <RCCEx_PLL2_Config+0x16e>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
    ee8a:	6923      	ldr	r3, [r4, #16]
    ee8c:	3b01      	subs	r3, #1
    ee8e:	2b7f      	cmp	r3, #127	; 0x7f
    ee90:	f200 80a9 	bhi.w	efe6 <RCCEx_PLL2_Config+0x182>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
    ee94:	68e3      	ldr	r3, [r4, #12]
    ee96:	3b01      	subs	r3, #1
    ee98:	2b7f      	cmp	r3, #127	; 0x7f
    ee9a:	f200 80ae 	bhi.w	effa <RCCEx_PLL2_Config+0x196>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
    ee9e:	6963      	ldr	r3, [r4, #20]
    eea0:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
    eea4:	f040 80b3 	bne.w	f00e <RCCEx_PLL2_Config+0x1aa>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
    eea8:	69a3      	ldr	r3, [r4, #24]
    eeaa:	f033 0320 	bics.w	r3, r3, #32
    eeae:	f040 80b8 	bne.w	f022 <RCCEx_PLL2_Config+0x1be>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
    eeb2:	69e3      	ldr	r3, [r4, #28]
    eeb4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    eeb8:	d270      	bcs.n	ef9c <RCCEx_PLL2_Config+0x138>

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
    eeba:	4a5f      	ldr	r2, [pc, #380]	; (f038 <RCCEx_PLL2_Config+0x1d4>)
    eebc:	6a93      	ldr	r3, [r2, #40]	; 0x28
    eebe:	f003 0303 	and.w	r3, r3, #3
    eec2:	2b03      	cmp	r3, #3
    eec4:	d066      	beq.n	ef94 <RCCEx_PLL2_Config+0x130>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
    eec6:	6813      	ldr	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    eec8:	4615      	mov	r5, r2
    __HAL_RCC_PLL2_DISABLE();
    eeca:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
    eece:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
    eed0:	f7f9 fa90 	bl	83f4 <HAL_GetTick>
    eed4:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    eed6:	e004      	b.n	eee2 <RCCEx_PLL2_Config+0x7e>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    eed8:	f7f9 fa8c 	bl	83f4 <HAL_GetTick>
    eedc:	1bc0      	subs	r0, r0, r7
    eede:	2802      	cmp	r0, #2
    eee0:	d85a      	bhi.n	ef98 <RCCEx_PLL2_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
    eee2:	682b      	ldr	r3, [r5, #0]
    eee4:	011a      	lsls	r2, r3, #4
    eee6:	d4f7      	bmi.n	eed8 <RCCEx_PLL2_Config+0x74>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    eee8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    eeea:	6822      	ldr	r2, [r4, #0]
    eeec:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    eef0:	4952      	ldr	r1, [pc, #328]	; (f03c <RCCEx_PLL2_Config+0x1d8>)
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
    eef2:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    eef6:	62ab      	str	r3, [r5, #40]	; 0x28
    eef8:	6867      	ldr	r7, [r4, #4]
    eefa:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    eefe:	3f01      	subs	r7, #1
    ef00:	1e50      	subs	r0, r2, #1
    ef02:	3b01      	subs	r3, #1
    ef04:	6922      	ldr	r2, [r4, #16]
    ef06:	f3c7 0708 	ubfx	r7, r7, #0, #9
    ef0a:	025b      	lsls	r3, r3, #9
    ef0c:	0400      	lsls	r0, r0, #16
    ef0e:	3a01      	subs	r2, #1
    ef10:	b29b      	uxth	r3, r3
    ef12:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    ef16:	0612      	lsls	r2, r2, #24
    ef18:	4303      	orrs	r3, r0
    ef1a:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    ef1e:	433b      	orrs	r3, r7
    ef20:	4313      	orrs	r3, r2
    ef22:	63ab      	str	r3, [r5, #56]	; 0x38
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
    ef24:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef26:	6962      	ldr	r2, [r4, #20]
    ef28:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    ef2c:	4313      	orrs	r3, r2
    ef2e:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
    ef30:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef32:	69a2      	ldr	r2, [r4, #24]
    ef34:	f023 0320 	bic.w	r3, r3, #32
    ef38:	4313      	orrs	r3, r2
    ef3a:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_DISABLE();
    ef3c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef3e:	f023 0310 	bic.w	r3, r3, #16
    ef42:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
    ef44:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    ef46:	69e3      	ldr	r3, [r4, #28]
    ef48:	4011      	ands	r1, r2
    ef4a:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    ef4e:	63e9      	str	r1, [r5, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
    ef50:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    ef52:	f043 0310 	orr.w	r3, r3, #16
    ef56:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
    ef58:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
    ef5a:	2e00      	cmp	r6, #0
    ef5c:	d067      	beq.n	f02e <RCCEx_PLL2_Config+0x1ca>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
    ef5e:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
    ef60:	bf0c      	ite	eq
    ef62:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
    ef66:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
    ef6a:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
    ef6c:	4b32      	ldr	r3, [pc, #200]	; (f038 <RCCEx_PLL2_Config+0x1d4>)
    ef6e:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    ef70:	461c      	mov	r4, r3
    __HAL_RCC_PLL2_ENABLE();
    ef72:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    ef76:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    ef78:	f7f9 fa3c 	bl	83f4 <HAL_GetTick>
    ef7c:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    ef7e:	e004      	b.n	ef8a <RCCEx_PLL2_Config+0x126>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    ef80:	f7f9 fa38 	bl	83f4 <HAL_GetTick>
    ef84:	1b40      	subs	r0, r0, r5
    ef86:	2802      	cmp	r0, #2
    ef88:	d806      	bhi.n	ef98 <RCCEx_PLL2_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
    ef8a:	6823      	ldr	r3, [r4, #0]
    ef8c:	011b      	lsls	r3, r3, #4
    ef8e:	d5f7      	bpl.n	ef80 <RCCEx_PLL2_Config+0x11c>
    }

  }


  return status;
    ef90:	2000      	movs	r0, #0
}
    ef92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
    ef94:	2001      	movs	r0, #1
}
    ef96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
    ef98:	2003      	movs	r0, #3
}
    ef9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
    ef9c:	f640 4186 	movw	r1, #3206	; 0xc86
    efa0:	4827      	ldr	r0, [pc, #156]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efa2:	f00a fa8d 	bl	194c0 <assert_failed>
    efa6:	e788      	b.n	eeba <RCCEx_PLL2_Config+0x56>
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
    efa8:	f640 417f 	movw	r1, #3199	; 0xc7f
    efac:	4824      	ldr	r0, [pc, #144]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efae:	f00a fa87 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
    efb2:	6863      	ldr	r3, [r4, #4]
    efb4:	3b04      	subs	r3, #4
    efb6:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    efba:	f67f af61 	bls.w	ee80 <RCCEx_PLL2_Config+0x1c>
    efbe:	f44f 6148 	mov.w	r1, #3200	; 0xc80
    efc2:	481f      	ldr	r0, [pc, #124]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efc4:	f00a fa7c 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
    efc8:	68a3      	ldr	r3, [r4, #8]
    efca:	3b01      	subs	r3, #1
    efcc:	2b7f      	cmp	r3, #127	; 0x7f
    efce:	f67f af5c 	bls.w	ee8a <RCCEx_PLL2_Config+0x26>
    efd2:	f640 4181 	movw	r1, #3201	; 0xc81
    efd6:	481a      	ldr	r0, [pc, #104]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efd8:	f00a fa72 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
    efdc:	6923      	ldr	r3, [r4, #16]
    efde:	3b01      	subs	r3, #1
    efe0:	2b7f      	cmp	r3, #127	; 0x7f
    efe2:	f67f af57 	bls.w	ee94 <RCCEx_PLL2_Config+0x30>
    efe6:	f640 4182 	movw	r1, #3202	; 0xc82
    efea:	4815      	ldr	r0, [pc, #84]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    efec:	f00a fa68 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
    eff0:	68e3      	ldr	r3, [r4, #12]
    eff2:	3b01      	subs	r3, #1
    eff4:	2b7f      	cmp	r3, #127	; 0x7f
    eff6:	f67f af52 	bls.w	ee9e <RCCEx_PLL2_Config+0x3a>
    effa:	f640 4183 	movw	r1, #3203	; 0xc83
    effe:	4810      	ldr	r0, [pc, #64]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    f000:	f00a fa5e 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
    f004:	6963      	ldr	r3, [r4, #20]
    f006:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
    f00a:	f43f af4d 	beq.w	eea8 <RCCEx_PLL2_Config+0x44>
    f00e:	f640 4184 	movw	r1, #3204	; 0xc84
    f012:	480b      	ldr	r0, [pc, #44]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    f014:	f00a fa54 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
    f018:	69a3      	ldr	r3, [r4, #24]
    f01a:	f033 0320 	bics.w	r3, r3, #32
    f01e:	f43f af48 	beq.w	eeb2 <RCCEx_PLL2_Config+0x4e>
    f022:	f640 4185 	movw	r1, #3205	; 0xc85
    f026:	4806      	ldr	r0, [pc, #24]	; (f040 <RCCEx_PLL2_Config+0x1dc>)
    f028:	f00a fa4a 	bl	194c0 <assert_failed>
    f02c:	e741      	b.n	eeb2 <RCCEx_PLL2_Config+0x4e>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
    f02e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    f032:	62eb      	str	r3, [r5, #44]	; 0x2c
    f034:	e79a      	b.n	ef6c <RCCEx_PLL2_Config+0x108>
    f036:	bf00      	nop
    f038:	58024400 	.word	0x58024400
    f03c:	ffff0007 	.word	0xffff0007
    f040:	000301e0 	.word	0x000301e0

0000f044 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
    f044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    f046:	6803      	ldr	r3, [r0, #0]
{
    f048:	4604      	mov	r4, r0
    f04a:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    f04c:	3b01      	subs	r3, #1
    f04e:	2b3e      	cmp	r3, #62	; 0x3e
    f050:	f200 809a 	bhi.w	f188 <RCCEx_PLL3_Config+0x144>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
    f054:	6863      	ldr	r3, [r4, #4]
    f056:	3b04      	subs	r3, #4
    f058:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    f05c:	f200 809f 	bhi.w	f19e <RCCEx_PLL3_Config+0x15a>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
    f060:	68a3      	ldr	r3, [r4, #8]
    f062:	3b01      	subs	r3, #1
    f064:	2b7f      	cmp	r3, #127	; 0x7f
    f066:	f200 80a4 	bhi.w	f1b2 <RCCEx_PLL3_Config+0x16e>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
    f06a:	6923      	ldr	r3, [r4, #16]
    f06c:	3b01      	subs	r3, #1
    f06e:	2b7f      	cmp	r3, #127	; 0x7f
    f070:	f200 80a9 	bhi.w	f1c6 <RCCEx_PLL3_Config+0x182>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
    f074:	68e3      	ldr	r3, [r4, #12]
    f076:	3b01      	subs	r3, #1
    f078:	2b7f      	cmp	r3, #127	; 0x7f
    f07a:	f200 80ae 	bhi.w	f1da <RCCEx_PLL3_Config+0x196>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
    f07e:	6963      	ldr	r3, [r4, #20]
    f080:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    f084:	f040 80b3 	bne.w	f1ee <RCCEx_PLL3_Config+0x1aa>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
    f088:	69a3      	ldr	r3, [r4, #24]
    f08a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    f08e:	f040 80b8 	bne.w	f202 <RCCEx_PLL3_Config+0x1be>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
    f092:	69e3      	ldr	r3, [r4, #28]
    f094:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    f098:	d270      	bcs.n	f17c <RCCEx_PLL3_Config+0x138>

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
    f09a:	4a5f      	ldr	r2, [pc, #380]	; (f218 <RCCEx_PLL3_Config+0x1d4>)
    f09c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    f09e:	f003 0303 	and.w	r3, r3, #3
    f0a2:	2b03      	cmp	r3, #3
    f0a4:	d066      	beq.n	f174 <RCCEx_PLL3_Config+0x130>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
    f0a6:	6813      	ldr	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    f0a8:	4615      	mov	r5, r2
    __HAL_RCC_PLL3_DISABLE();
    f0aa:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    f0ae:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
    f0b0:	f7f9 f9a0 	bl	83f4 <HAL_GetTick>
    f0b4:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    f0b6:	e004      	b.n	f0c2 <RCCEx_PLL3_Config+0x7e>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
    f0b8:	f7f9 f99c 	bl	83f4 <HAL_GetTick>
    f0bc:	1bc0      	subs	r0, r0, r7
    f0be:	2802      	cmp	r0, #2
    f0c0:	d85a      	bhi.n	f178 <RCCEx_PLL3_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
    f0c2:	682b      	ldr	r3, [r5, #0]
    f0c4:	009a      	lsls	r2, r3, #2
    f0c6:	d4f7      	bmi.n	f0b8 <RCCEx_PLL3_Config+0x74>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    f0c8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    f0ca:	6822      	ldr	r2, [r4, #0]
    f0cc:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    f0d0:	4952      	ldr	r1, [pc, #328]	; (f21c <RCCEx_PLL3_Config+0x1d8>)
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
    f0d2:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    f0d6:	62ab      	str	r3, [r5, #40]	; 0x28
    f0d8:	6867      	ldr	r7, [r4, #4]
    f0da:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    f0de:	3f01      	subs	r7, #1
    f0e0:	1e50      	subs	r0, r2, #1
    f0e2:	3b01      	subs	r3, #1
    f0e4:	6922      	ldr	r2, [r4, #16]
    f0e6:	f3c7 0708 	ubfx	r7, r7, #0, #9
    f0ea:	025b      	lsls	r3, r3, #9
    f0ec:	0400      	lsls	r0, r0, #16
    f0ee:	3a01      	subs	r2, #1
    f0f0:	b29b      	uxth	r3, r3
    f0f2:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
    f0f6:	0612      	lsls	r2, r2, #24
    f0f8:	4303      	orrs	r3, r0
    f0fa:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
    f0fe:	433b      	orrs	r3, r7
    f100:	4313      	orrs	r3, r2
    f102:	642b      	str	r3, [r5, #64]	; 0x40
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
    f104:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f106:	6962      	ldr	r2, [r4, #20]
    f108:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
    f10c:	4313      	orrs	r3, r2
    f10e:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
    f110:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f112:	69a2      	ldr	r2, [r4, #24]
    f114:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    f118:	4313      	orrs	r3, r2
    f11a:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_DISABLE();
    f11c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f11e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    f122:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
    f124:	6c6a      	ldr	r2, [r5, #68]	; 0x44
    f126:	69e3      	ldr	r3, [r4, #28]
    f128:	4011      	ands	r1, r2
    f12a:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    f12e:	6469      	str	r1, [r5, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
    f130:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    f132:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    f136:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
    f138:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
    f13a:	2e00      	cmp	r6, #0
    f13c:	d067      	beq.n	f20e <RCCEx_PLL3_Config+0x1ca>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
    f13e:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
    f140:	bf0c      	ite	eq
    f142:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
    f146:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
    f14a:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
    f14c:	4b32      	ldr	r3, [pc, #200]	; (f218 <RCCEx_PLL3_Config+0x1d4>)
    f14e:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
    f150:	461c      	mov	r4, r3
    __HAL_RCC_PLL3_ENABLE();
    f152:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    f156:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    f158:	f7f9 f94c 	bl	83f4 <HAL_GetTick>
    f15c:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
    f15e:	e004      	b.n	f16a <RCCEx_PLL3_Config+0x126>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
    f160:	f7f9 f948 	bl	83f4 <HAL_GetTick>
    f164:	1b40      	subs	r0, r0, r5
    f166:	2802      	cmp	r0, #2
    f168:	d806      	bhi.n	f178 <RCCEx_PLL3_Config+0x134>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
    f16a:	6823      	ldr	r3, [r4, #0]
    f16c:	009b      	lsls	r3, r3, #2
    f16e:	d5f7      	bpl.n	f160 <RCCEx_PLL3_Config+0x11c>
    }

  }


  return status;
    f170:	2000      	movs	r0, #0
}
    f172:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
    f174:	2001      	movs	r0, #1
}
    f176:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
    f178:	2003      	movs	r0, #3
}
    f17a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
    f17c:	f640 41ee 	movw	r1, #3310	; 0xcee
    f180:	4827      	ldr	r0, [pc, #156]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f182:	f00a f99d 	bl	194c0 <assert_failed>
    f186:	e788      	b.n	f09a <RCCEx_PLL3_Config+0x56>
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
    f188:	f640 41e7 	movw	r1, #3303	; 0xce7
    f18c:	4824      	ldr	r0, [pc, #144]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f18e:	f00a f997 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
    f192:	6863      	ldr	r3, [r4, #4]
    f194:	3b04      	subs	r3, #4
    f196:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
    f19a:	f67f af61 	bls.w	f060 <RCCEx_PLL3_Config+0x1c>
    f19e:	f640 41e8 	movw	r1, #3304	; 0xce8
    f1a2:	481f      	ldr	r0, [pc, #124]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1a4:	f00a f98c 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
    f1a8:	68a3      	ldr	r3, [r4, #8]
    f1aa:	3b01      	subs	r3, #1
    f1ac:	2b7f      	cmp	r3, #127	; 0x7f
    f1ae:	f67f af5c 	bls.w	f06a <RCCEx_PLL3_Config+0x26>
    f1b2:	f640 41e9 	movw	r1, #3305	; 0xce9
    f1b6:	481a      	ldr	r0, [pc, #104]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1b8:	f00a f982 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
    f1bc:	6923      	ldr	r3, [r4, #16]
    f1be:	3b01      	subs	r3, #1
    f1c0:	2b7f      	cmp	r3, #127	; 0x7f
    f1c2:	f67f af57 	bls.w	f074 <RCCEx_PLL3_Config+0x30>
    f1c6:	f640 41ea 	movw	r1, #3306	; 0xcea
    f1ca:	4815      	ldr	r0, [pc, #84]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1cc:	f00a f978 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
    f1d0:	68e3      	ldr	r3, [r4, #12]
    f1d2:	3b01      	subs	r3, #1
    f1d4:	2b7f      	cmp	r3, #127	; 0x7f
    f1d6:	f67f af52 	bls.w	f07e <RCCEx_PLL3_Config+0x3a>
    f1da:	f640 41eb 	movw	r1, #3307	; 0xceb
    f1de:	4810      	ldr	r0, [pc, #64]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1e0:	f00a f96e 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
    f1e4:	6963      	ldr	r3, [r4, #20]
    f1e6:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
    f1ea:	f43f af4d 	beq.w	f088 <RCCEx_PLL3_Config+0x44>
    f1ee:	f640 41ec 	movw	r1, #3308	; 0xcec
    f1f2:	480b      	ldr	r0, [pc, #44]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f1f4:	f00a f964 	bl	194c0 <assert_failed>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
    f1f8:	69a3      	ldr	r3, [r4, #24]
    f1fa:	f433 7300 	bics.w	r3, r3, #512	; 0x200
    f1fe:	f43f af48 	beq.w	f092 <RCCEx_PLL3_Config+0x4e>
    f202:	f640 41ed 	movw	r1, #3309	; 0xced
    f206:	4806      	ldr	r0, [pc, #24]	; (f220 <RCCEx_PLL3_Config+0x1dc>)
    f208:	f00a f95a 	bl	194c0 <assert_failed>
    f20c:	e741      	b.n	f092 <RCCEx_PLL3_Config+0x4e>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
    f20e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
    f212:	62eb      	str	r3, [r5, #44]	; 0x2c
    f214:	e79a      	b.n	f14c <RCCEx_PLL3_Config+0x108>
    f216:	bf00      	nop
    f218:	58024400 	.word	0x58024400
    f21c:	ffff0007 	.word	0xffff0007
    f220:	000301e0 	.word	0x000301e0

0000f224 <HAL_RCCEx_PeriphCLKConfig>:
{
    f224:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
    f228:	6803      	ldr	r3, [r0, #0]
{
    f22a:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
    f22c:	f013 6600 	ands.w	r6, r3, #134217728	; 0x8000000
    f230:	d016      	beq.n	f260 <HAL_RCCEx_PeriphCLKConfig+0x3c>
    switch(PeriphClkInit->SpdifrxClockSelection)
    f232:	6e42      	ldr	r2, [r0, #100]	; 0x64
    f234:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
    f238:	f000 8527 	beq.w	fc8a <HAL_RCCEx_PeriphCLKConfig+0xa66>
    f23c:	f240 861b 	bls.w	fe76 <HAL_RCCEx_PeriphCLKConfig+0xc52>
    f240:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    f244:	f000 855b 	beq.w	fcfe <HAL_RCCEx_PeriphCLKConfig+0xada>
    f248:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
    f24c:	f040 8639 	bne.w	fec2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
    f250:	49b7      	ldr	r1, [pc, #732]	; (f530 <HAL_RCCEx_PeriphCLKConfig+0x30c>)
    f252:	2600      	movs	r6, #0
    f254:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    f256:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    f25a:	431a      	orrs	r2, r3
    f25c:	650a      	str	r2, [r1, #80]	; 0x50
    f25e:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
    f260:	05dd      	lsls	r5, r3, #23
    f262:	d50a      	bpl.n	f27a <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
    f264:	6d62      	ldr	r2, [r4, #84]	; 0x54
    f266:	2a04      	cmp	r2, #4
    f268:	d806      	bhi.n	f278 <HAL_RCCEx_PeriphCLKConfig+0x54>
    f26a:	e8df f012 	tbh	[pc, r2, lsl #1]
    f26e:	04ac      	.short	0x04ac
    f270:	04c404be 	.word	0x04c404be
    f274:	04880488 	.word	0x04880488
      ret = HAL_ERROR;
    f278:	2601      	movs	r6, #1
    f27a:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
    f27c:	0598      	lsls	r0, r3, #22
    f27e:	d515      	bpl.n	f2ac <HAL_RCCEx_PeriphCLKConfig+0x88>
    switch(PeriphClkInit->Sai23ClockSelection)
    f280:	6da2      	ldr	r2, [r4, #88]	; 0x58
    f282:	2a80      	cmp	r2, #128	; 0x80
    f284:	f000 850c 	beq.w	fca0 <HAL_RCCEx_PeriphCLKConfig+0xa7c>
    f288:	f200 85ea 	bhi.w	fe60 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
    f28c:	2a00      	cmp	r2, #0
    f28e:	f000 853c 	beq.w	fd0a <HAL_RCCEx_PeriphCLKConfig+0xae6>
    f292:	2a40      	cmp	r2, #64	; 0x40
    f294:	f040 85eb 	bne.w	fe6e <HAL_RCCEx_PeriphCLKConfig+0xc4a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f298:	2100      	movs	r1, #0
    f29a:	1d20      	adds	r0, r4, #4
    f29c:	f7ff fde2 	bl	ee64 <RCCEx_PLL2_Config>
    f2a0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f2a2:	2d00      	cmp	r5, #0
    f2a4:	f000 8505 	beq.w	fcb2 <HAL_RCCEx_PeriphCLKConfig+0xa8e>
    f2a8:	6823      	ldr	r3, [r4, #0]
    f2aa:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
    f2ac:	0559      	lsls	r1, r3, #21
    f2ae:	d518      	bpl.n	f2e2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
    switch(PeriphClkInit->Sai4AClockSelection)
    f2b0:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
    f2b4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
    f2b8:	f000 8505 	beq.w	fcc6 <HAL_RCCEx_PeriphCLKConfig+0xaa2>
    f2bc:	f200 85c4 	bhi.w	fe48 <HAL_RCCEx_PeriphCLKConfig+0xc24>
    f2c0:	2a00      	cmp	r2, #0
    f2c2:	f000 8530 	beq.w	fd26 <HAL_RCCEx_PeriphCLKConfig+0xb02>
    f2c6:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    f2ca:	f040 85c5 	bne.w	fe58 <HAL_RCCEx_PeriphCLKConfig+0xc34>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f2ce:	2100      	movs	r1, #0
    f2d0:	1d20      	adds	r0, r4, #4
    f2d2:	f7ff fdc7 	bl	ee64 <RCCEx_PLL2_Config>
    f2d6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f2d8:	2d00      	cmp	r5, #0
    f2da:	f000 84fd 	beq.w	fcd8 <HAL_RCCEx_PeriphCLKConfig+0xab4>
    f2de:	6823      	ldr	r3, [r4, #0]
    f2e0:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
    f2e2:	051a      	lsls	r2, r3, #20
    f2e4:	d518      	bpl.n	f318 <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->Sai4BClockSelection)
    f2e6:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
    f2ea:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
    f2ee:	f000 84fe 	beq.w	fcee <HAL_RCCEx_PeriphCLKConfig+0xaca>
    f2f2:	f200 85d5 	bhi.w	fea0 <HAL_RCCEx_PeriphCLKConfig+0xc7c>
    f2f6:	2a00      	cmp	r2, #0
    f2f8:	f000 84b4 	beq.w	fc64 <HAL_RCCEx_PeriphCLKConfig+0xa40>
    f2fc:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
    f300:	f040 85d6 	bne.w	feb0 <HAL_RCCEx_PeriphCLKConfig+0xc8c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f304:	2100      	movs	r1, #0
    f306:	1d20      	adds	r0, r4, #4
    f308:	f7ff fdac 	bl	ee64 <RCCEx_PLL2_Config>
    f30c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f30e:	2d00      	cmp	r5, #0
    f310:	f000 84b0 	beq.w	fc74 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    f314:	6823      	ldr	r3, [r4, #0]
    f316:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
    f318:	019f      	lsls	r7, r3, #6
    f31a:	d50d      	bpl.n	f338 <HAL_RCCEx_PeriphCLKConfig+0x114>
    switch(PeriphClkInit->QspiClockSelection)
    f31c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    f31e:	2a10      	cmp	r2, #16
    f320:	f000 83f6 	beq.w	fb10 <HAL_RCCEx_PeriphCLKConfig+0x8ec>
    f324:	f240 85c8 	bls.w	feb8 <HAL_RCCEx_PeriphCLKConfig+0xc94>
    f328:	2a20      	cmp	r2, #32
    f32a:	f000 83fa 	beq.w	fb22 <HAL_RCCEx_PeriphCLKConfig+0x8fe>
    f32e:	2a30      	cmp	r2, #48	; 0x30
    f330:	f000 83f3 	beq.w	fb1a <HAL_RCCEx_PeriphCLKConfig+0x8f6>
      ret = HAL_ERROR;
    f334:	2601      	movs	r6, #1
    f336:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
    f338:	04d8      	lsls	r0, r3, #19
    f33a:	d517      	bpl.n	f36c <HAL_RCCEx_PeriphCLKConfig+0x148>
    switch(PeriphClkInit->Spi123ClockSelection)
    f33c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    f33e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    f342:	f000 8477 	beq.w	fc34 <HAL_RCCEx_PeriphCLKConfig+0xa10>
    f346:	f200 859f 	bhi.w	fe88 <HAL_RCCEx_PeriphCLKConfig+0xc64>
    f34a:	2a00      	cmp	r2, #0
    f34c:	f000 84e4 	beq.w	fd18 <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    f350:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    f354:	f040 85a0 	bne.w	fe98 <HAL_RCCEx_PeriphCLKConfig+0xc74>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f358:	2100      	movs	r1, #0
    f35a:	1d20      	adds	r0, r4, #4
    f35c:	f7ff fd82 	bl	ee64 <RCCEx_PLL2_Config>
    f360:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f362:	2d00      	cmp	r5, #0
    f364:	f000 846f 	beq.w	fc46 <HAL_RCCEx_PeriphCLKConfig+0xa22>
    f368:	6823      	ldr	r3, [r4, #0]
    f36a:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
    f36c:	0499      	lsls	r1, r3, #18
    f36e:	d51b      	bpl.n	f3a8 <HAL_RCCEx_PeriphCLKConfig+0x184>
    switch(PeriphClkInit->Spi45ClockSelection)
    f370:	6e22      	ldr	r2, [r4, #96]	; 0x60
    f372:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
    f376:	f000 83e5 	beq.w	fb44 <HAL_RCCEx_PeriphCLKConfig+0x920>
    f37a:	f200 8527 	bhi.w	fdcc <HAL_RCCEx_PeriphCLKConfig+0xba8>
    f37e:	b142      	cbz	r2, f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
    f380:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    f384:	f040 852e 	bne.w	fde4 <HAL_RCCEx_PeriphCLKConfig+0xbc0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    f388:	2101      	movs	r1, #1
    f38a:	1d20      	adds	r0, r4, #4
    f38c:	f7ff fd6a 	bl	ee64 <RCCEx_PLL2_Config>
    f390:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f392:	2d00      	cmp	r5, #0
    f394:	f040 833b 	bne.w	fa0e <HAL_RCCEx_PeriphCLKConfig+0x7ea>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
    f398:	4a65      	ldr	r2, [pc, #404]	; (f530 <HAL_RCCEx_PeriphCLKConfig+0x30c>)
    f39a:	6e21      	ldr	r1, [r4, #96]	; 0x60
    f39c:	6d13      	ldr	r3, [r2, #80]	; 0x50
    f39e:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
    f3a2:	430b      	orrs	r3, r1
    f3a4:	6513      	str	r3, [r2, #80]	; 0x50
    f3a6:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
    f3a8:	045a      	lsls	r2, r3, #17
    f3aa:	d51d      	bpl.n	f3e8 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    switch(PeriphClkInit->Spi6ClockSelection)
    f3ac:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
    f3b0:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f3b4:	f000 83d0 	beq.w	fb58 <HAL_RCCEx_PeriphCLKConfig+0x934>
    f3b8:	f200 8527 	bhi.w	fe0a <HAL_RCCEx_PeriphCLKConfig+0xbe6>
    f3bc:	b142      	cbz	r2, f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    f3be:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    f3c2:	f040 852e 	bne.w	fe22 <HAL_RCCEx_PeriphCLKConfig+0xbfe>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    f3c6:	2101      	movs	r1, #1
    f3c8:	1d20      	adds	r0, r4, #4
    f3ca:	f7ff fd4b 	bl	ee64 <RCCEx_PLL2_Config>
    f3ce:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f3d0:	2d00      	cmp	r5, #0
    f3d2:	f040 8319 	bne.w	fa08 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
    f3d6:	4a56      	ldr	r2, [pc, #344]	; (f530 <HAL_RCCEx_PeriphCLKConfig+0x30c>)
    f3d8:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
    f3dc:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f3de:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    f3e2:	430b      	orrs	r3, r1
    f3e4:	6593      	str	r3, [r2, #88]	; 0x58
    f3e6:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
    f3e8:	041f      	lsls	r7, r3, #16
    f3ea:	d50d      	bpl.n	f408 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    switch(PeriphClkInit->FdcanClockSelection)
    f3ec:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    f3ee:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    f3f2:	f000 83bb 	beq.w	fb6c <HAL_RCCEx_PeriphCLKConfig+0x948>
    f3f6:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f3fa:	f000 8298 	beq.w	f92e <HAL_RCCEx_PeriphCLKConfig+0x70a>
    f3fe:	2a00      	cmp	r2, #0
    f400:	f000 829a 	beq.w	f938 <HAL_RCCEx_PeriphCLKConfig+0x714>
      ret = HAL_ERROR;
    f404:	2601      	movs	r6, #1
    f406:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
    f408:	01d8      	lsls	r0, r3, #7
    f40a:	d50a      	bpl.n	f422 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    switch(PeriphClkInit->FmcClockSelection)
    f40c:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f40e:	2a03      	cmp	r2, #3
    f410:	d805      	bhi.n	f41e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
    f412:	e8df f012 	tbh	[pc, r2, lsl #1]
    f416:	0270      	.short	0x0270
    f418:	026b033c 	.word	0x026b033c
    f41c:	0270      	.short	0x0270
      ret = HAL_ERROR;
    f41e:	2601      	movs	r6, #1
    f420:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
    f422:	0259      	lsls	r1, r3, #9
    f424:	f140 80c9 	bpl.w	f5ba <HAL_RCCEx_PeriphCLKConfig+0x396>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    f428:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    f42c:	4f41      	ldr	r7, [pc, #260]	; (f534 <HAL_RCCEx_PeriphCLKConfig+0x310>)
    f42e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f432:	bf18      	it	ne
    f434:	f5b2 7f00 	cmpne.w	r2, #512	; 0x200
    f438:	f422 4ca0 	bic.w	ip, r2, #20480	; 0x5000
    f43c:	f422 4010 	bic.w	r0, r2, #36864	; 0x9000
    f440:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
    f444:	bf14      	ite	ne
    f446:	2301      	movne	r3, #1
    f448:	2300      	moveq	r3, #0
    f44a:	f422 3e88 	bic.w	lr, r2, #69632	; 0x11000
    f44e:	f5bc 5f0c 	cmp.w	ip, #8960	; 0x2300
    f452:	bf0c      	ite	eq
    f454:	2300      	moveq	r3, #0
    f456:	f003 0301 	andne.w	r3, r3, #1
    f45a:	f8df c0e4 	ldr.w	ip, [pc, #228]	; f540 <HAL_RCCEx_PeriphCLKConfig+0x31c>
    f45e:	f5b0 4f86 	cmp.w	r0, #17152	; 0x4300
    f462:	bf0c      	ite	eq
    f464:	2300      	moveq	r3, #0
    f466:	f003 0301 	andne.w	r3, r3, #1
    f46a:	4833      	ldr	r0, [pc, #204]	; (f538 <HAL_RCCEx_PeriphCLKConfig+0x314>)
    f46c:	f5b1 4f03 	cmp.w	r1, #33536	; 0x8300
    f470:	bf0c      	ite	eq
    f472:	2300      	moveq	r3, #0
    f474:	f003 0301 	andne.w	r3, r3, #1
    f478:	f5be 4f63 	cmp.w	lr, #58112	; 0xe300
    f47c:	bf0c      	ite	eq
    f47e:	2300      	moveq	r3, #0
    f480:	f003 0301 	andne.w	r3, r3, #1
    f484:	f422 3e04 	bic.w	lr, r2, #135168	; 0x21000
    f488:	42b9      	cmp	r1, r7
    f48a:	bf0c      	ite	eq
    f48c:	2300      	moveq	r3, #0
    f48e:	f003 0301 	andne.w	r3, r3, #1
    f492:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
    f496:	4281      	cmp	r1, r0
    f498:	bf0c      	ite	eq
    f49a:	2300      	moveq	r3, #0
    f49c:	f003 0301 	andne.w	r3, r3, #1
    f4a0:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
    f4a4:	4561      	cmp	r1, ip
    f4a6:	bf0c      	ite	eq
    f4a8:	2300      	moveq	r3, #0
    f4aa:	f003 0301 	andne.w	r3, r3, #1
    f4ae:	f50c 4c40 	add.w	ip, ip, #49152	; 0xc000
    f4b2:	45be      	cmp	lr, r7
    f4b4:	bf0c      	ite	eq
    f4b6:	2300      	moveq	r3, #0
    f4b8:	f003 0301 	andne.w	r3, r3, #1
    f4bc:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
    f4c0:	4281      	cmp	r1, r0
    f4c2:	bf0c      	ite	eq
    f4c4:	2300      	moveq	r3, #0
    f4c6:	f003 0301 	andne.w	r3, r3, #1
    f4ca:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
    f4ce:	4561      	cmp	r1, ip
    f4d0:	bf0c      	ite	eq
    f4d2:	2300      	moveq	r3, #0
    f4d4:	f003 0301 	andne.w	r3, r3, #1
    f4d8:	f50c 4c40 	add.w	ip, ip, #49152	; 0xc000
    f4dc:	42b9      	cmp	r1, r7
    f4de:	bf0c      	ite	eq
    f4e0:	2300      	moveq	r3, #0
    f4e2:	f003 0301 	andne.w	r3, r3, #1
    f4e6:	f507 4740 	add.w	r7, r7, #49152	; 0xc000
    f4ea:	4281      	cmp	r1, r0
    f4ec:	bf0c      	ite	eq
    f4ee:	2300      	moveq	r3, #0
    f4f0:	f003 0301 	andne.w	r3, r3, #1
    f4f4:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
    f4f8:	4561      	cmp	r1, ip
    f4fa:	bf0c      	ite	eq
    f4fc:	2300      	moveq	r3, #0
    f4fe:	f003 0301 	andne.w	r3, r3, #1
    f502:	42b9      	cmp	r1, r7
    f504:	bf0c      	ite	eq
    f506:	2300      	moveq	r3, #0
    f508:	f003 0301 	andne.w	r3, r3, #1
    f50c:	4281      	cmp	r1, r0
    f50e:	bf0c      	ite	eq
    f510:	2300      	moveq	r3, #0
    f512:	f003 0301 	andne.w	r3, r3, #1
    f516:	2b00      	cmp	r3, #0
    f518:	f040 81b7 	bne.w	f88a <HAL_RCCEx_PeriphCLKConfig+0x666>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
    f51c:	4b07      	ldr	r3, [pc, #28]	; (f53c <HAL_RCCEx_PeriphCLKConfig+0x318>)
    f51e:	681a      	ldr	r2, [r3, #0]
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    f520:	461f      	mov	r7, r3
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
    f522:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    f526:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
    f528:	f7f8 ff64 	bl	83f4 <HAL_GetTick>
    f52c:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    f52e:	e010      	b.n	f552 <HAL_RCCEx_PeriphCLKConfig+0x32e>
    f530:	58024400 	.word	0x58024400
    f534:	00010300 	.word	0x00010300
    f538:	00014300 	.word	0x00014300
    f53c:	58024800 	.word	0x58024800
    f540:	00018300 	.word	0x00018300
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
    f544:	f7f8 ff56 	bl	83f4 <HAL_GetTick>
    f548:	eba0 0008 	sub.w	r0, r0, r8
    f54c:	2864      	cmp	r0, #100	; 0x64
    f54e:	f200 8245 	bhi.w	f9dc <HAL_RCCEx_PeriphCLKConfig+0x7b8>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
    f552:	683b      	ldr	r3, [r7, #0]
    f554:	05da      	lsls	r2, r3, #23
    f556:	d5f5      	bpl.n	f544 <HAL_RCCEx_PeriphCLKConfig+0x320>
    if(ret == HAL_OK)
    f558:	2d00      	cmp	r5, #0
    f55a:	f040 84c0 	bne.w	fede <HAL_RCCEx_PeriphCLKConfig+0xcba>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
    f55e:	4b3e      	ldr	r3, [pc, #248]	; (f658 <HAL_RCCEx_PeriphCLKConfig+0x434>)
    f560:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    f564:	6f19      	ldr	r1, [r3, #112]	; 0x70
    f566:	4051      	eors	r1, r2
    f568:	f411 7f40 	tst.w	r1, #768	; 0x300
    f56c:	d00d      	beq.n	f58a <HAL_RCCEx_PeriphCLKConfig+0x366>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
    f56e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
    f570:	6f19      	ldr	r1, [r3, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
    f572:	f422 7240 	bic.w	r2, r2, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
    f576:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
    f57a:	6719      	str	r1, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
    f57c:	6f19      	ldr	r1, [r3, #112]	; 0x70
    f57e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    f582:	6719      	str	r1, [r3, #112]	; 0x70
        RCC->BDCR = tmpreg;
    f584:	671a      	str	r2, [r3, #112]	; 0x70
    f586:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
    f58a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f58e:	f000 83f9 	beq.w	fd84 <HAL_RCCEx_PeriphCLKConfig+0xb60>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
    f592:	f402 7340 	and.w	r3, r2, #768	; 0x300
    f596:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    f59a:	f000 8495 	beq.w	fec8 <HAL_RCCEx_PeriphCLKConfig+0xca4>
    f59e:	4a2e      	ldr	r2, [pc, #184]	; (f658 <HAL_RCCEx_PeriphCLKConfig+0x434>)
    f5a0:	6913      	ldr	r3, [r2, #16]
    f5a2:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    f5a6:	6113      	str	r3, [r2, #16]
    f5a8:	4a2b      	ldr	r2, [pc, #172]	; (f658 <HAL_RCCEx_PeriphCLKConfig+0x434>)
    f5aa:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
    f5ae:	6f11      	ldr	r1, [r2, #112]	; 0x70
    f5b0:	f3c3 030b 	ubfx	r3, r3, #0, #12
    f5b4:	430b      	orrs	r3, r1
    f5b6:	6713      	str	r3, [r2, #112]	; 0x70
    f5b8:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
    f5ba:	07df      	lsls	r7, r3, #31
    f5bc:	d52f      	bpl.n	f61e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
    switch(PeriphClkInit->Usart16ClockSelection)
    f5be:	6fa2      	ldr	r2, [r4, #120]	; 0x78
    f5c0:	2a28      	cmp	r2, #40	; 0x28
    f5c2:	d82a      	bhi.n	f61a <HAL_RCCEx_PeriphCLKConfig+0x3f6>
    f5c4:	e8df f012 	tbh	[pc, r2, lsl #1]
    f5c8:	002901a8 	.word	0x002901a8
    f5cc:	00290029 	.word	0x00290029
    f5d0:	00290029 	.word	0x00290029
    f5d4:	00290029 	.word	0x00290029
    f5d8:	0029028a 	.word	0x0029028a
    f5dc:	00290029 	.word	0x00290029
    f5e0:	00290029 	.word	0x00290029
    f5e4:	00290029 	.word	0x00290029
    f5e8:	002901a2 	.word	0x002901a2
    f5ec:	00290029 	.word	0x00290029
    f5f0:	00290029 	.word	0x00290029
    f5f4:	00290029 	.word	0x00290029
    f5f8:	002901a8 	.word	0x002901a8
    f5fc:	00290029 	.word	0x00290029
    f600:	00290029 	.word	0x00290029
    f604:	00290029 	.word	0x00290029
    f608:	002901a8 	.word	0x002901a8
    f60c:	00290029 	.word	0x00290029
    f610:	00290029 	.word	0x00290029
    f614:	00290029 	.word	0x00290029
    f618:	01a8      	.short	0x01a8
      ret = HAL_ERROR;
    f61a:	2601      	movs	r6, #1
    f61c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
    f61e:	0798      	lsls	r0, r3, #30
    f620:	d50c      	bpl.n	f63c <HAL_RCCEx_PeriphCLKConfig+0x418>
    switch(PeriphClkInit->Usart234578ClockSelection)
    f622:	6f62      	ldr	r2, [r4, #116]	; 0x74
    f624:	2a05      	cmp	r2, #5
    f626:	d807      	bhi.n	f638 <HAL_RCCEx_PeriphCLKConfig+0x414>
    f628:	e8df f012 	tbh	[pc, r2, lsl #1]
    f62c:	021f0154 	.word	0x021f0154
    f630:	0154014e 	.word	0x0154014e
    f634:	01540154 	.word	0x01540154
      ret = HAL_ERROR;
    f638:	2601      	movs	r6, #1
    f63a:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
    f63c:	0759      	lsls	r1, r3, #29
    f63e:	d50f      	bpl.n	f660 <HAL_RCCEx_PeriphCLKConfig+0x43c>
    switch(PeriphClkInit->Lpuart1ClockSelection)
    f640:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
    f644:	2a05      	cmp	r2, #5
    f646:	d809      	bhi.n	f65c <HAL_RCCEx_PeriphCLKConfig+0x438>
    f648:	e8df f012 	tbh	[pc, r2, lsl #1]
    f64c:	02180131 	.word	0x02180131
    f650:	0131012b 	.word	0x0131012b
    f654:	01310131 	.word	0x01310131
    f658:	58024400 	.word	0x58024400
      ret = HAL_ERROR;
    f65c:	2601      	movs	r6, #1
    f65e:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
    f660:	069a      	lsls	r2, r3, #26
    f662:	d51d      	bpl.n	f6a0 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    switch(PeriphClkInit->Lptim1ClockSelection)
    f664:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
    f668:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f66c:	f000 82a1 	beq.w	fbb2 <HAL_RCCEx_PeriphCLKConfig+0x98e>
    f670:	f200 83bc 	bhi.w	fdec <HAL_RCCEx_PeriphCLKConfig+0xbc8>
    f674:	b142      	cbz	r2, f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
    f676:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    f67a:	f040 83c3 	bne.w	fe04 <HAL_RCCEx_PeriphCLKConfig+0xbe0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f67e:	2100      	movs	r1, #0
    f680:	1d20      	adds	r0, r4, #4
    f682:	f7ff fbef 	bl	ee64 <RCCEx_PLL2_Config>
    f686:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f688:	2d00      	cmp	r5, #0
    f68a:	f040 81c9 	bne.w	fa20 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
    f68e:	4ab9      	ldr	r2, [pc, #740]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f690:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    f694:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f696:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    f69a:	430b      	orrs	r3, r1
    f69c:	6553      	str	r3, [r2, #84]	; 0x54
    f69e:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
    f6a0:	065f      	lsls	r7, r3, #25
    f6a2:	d51d      	bpl.n	f6e0 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    switch(PeriphClkInit->Lptim2ClockSelection)
    f6a4:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
    f6a8:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
    f6ac:	f000 8277 	beq.w	fb9e <HAL_RCCEx_PeriphCLKConfig+0x97a>
    f6b0:	f200 83bb 	bhi.w	fe2a <HAL_RCCEx_PeriphCLKConfig+0xc06>
    f6b4:	b142      	cbz	r2, f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    f6b6:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    f6ba:	f040 83c2 	bne.w	fe42 <HAL_RCCEx_PeriphCLKConfig+0xc1e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f6be:	2100      	movs	r1, #0
    f6c0:	1d20      	adds	r0, r4, #4
    f6c2:	f7ff fbcf 	bl	ee64 <RCCEx_PLL2_Config>
    f6c6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f6c8:	2d00      	cmp	r5, #0
    f6ca:	f040 81a6 	bne.w	fa1a <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
    f6ce:	4aa9      	ldr	r2, [pc, #676]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f6d0:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
    f6d4:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f6d6:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
    f6da:	430b      	orrs	r3, r1
    f6dc:	6593      	str	r3, [r2, #88]	; 0x58
    f6de:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
    f6e0:	0618      	lsls	r0, r3, #24
    f6e2:	d51d      	bpl.n	f720 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    switch(PeriphClkInit->Lptim345ClockSelection)
    f6e4:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    f6e8:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    f6ec:	f000 824d 	beq.w	fb8a <HAL_RCCEx_PeriphCLKConfig+0x966>
    f6f0:	f200 835d 	bhi.w	fdae <HAL_RCCEx_PeriphCLKConfig+0xb8a>
    f6f4:	b142      	cbz	r2, f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    f6f6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    f6fa:	f040 8364 	bne.w	fdc6 <HAL_RCCEx_PeriphCLKConfig+0xba2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    f6fe:	2100      	movs	r1, #0
    f700:	1d20      	adds	r0, r4, #4
    f702:	f7ff fbaf 	bl	ee64 <RCCEx_PLL2_Config>
    f706:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f708:	2d00      	cmp	r5, #0
    f70a:	f040 8183 	bne.w	fa14 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
    f70e:	4a99      	ldr	r2, [pc, #612]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f710:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
    f714:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f716:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
    f71a:	430b      	orrs	r3, r1
    f71c:	6593      	str	r3, [r2, #88]	; 0x58
    f71e:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
    f720:	0719      	lsls	r1, r3, #28
    f722:	d510      	bpl.n	f746 <HAL_RCCEx_PeriphCLKConfig+0x522>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
    f724:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    f728:	f432 5340 	bics.w	r3, r2, #12288	; 0x3000
    f72c:	f040 831a 	bne.w	fd64 <HAL_RCCEx_PeriphCLKConfig+0xb40>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
    f730:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    f734:	f000 8266 	beq.w	fc04 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
    f738:	498e      	ldr	r1, [pc, #568]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f73a:	6d4b      	ldr	r3, [r1, #84]	; 0x54
    f73c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
    f740:	4313      	orrs	r3, r2
    f742:	654b      	str	r3, [r1, #84]	; 0x54
    f744:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
    f746:	06da      	lsls	r2, r3, #27
    f748:	d516      	bpl.n	f778 <HAL_RCCEx_PeriphCLKConfig+0x554>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    f74a:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    f74e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    f752:	bf18      	it	ne
    f754:	f5b2 5f40 	cmpne.w	r2, #12288	; 0x3000
    f758:	d003      	beq.n	f762 <HAL_RCCEx_PeriphCLKConfig+0x53e>
    f75a:	f432 7380 	bics.w	r3, r2, #256	; 0x100
    f75e:	f040 8309 	bne.w	fd74 <HAL_RCCEx_PeriphCLKConfig+0xb50>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
    f762:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f766:	f000 8259 	beq.w	fc1c <HAL_RCCEx_PeriphCLKConfig+0x9f8>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
    f76a:	4982      	ldr	r1, [pc, #520]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f76c:	6d8b      	ldr	r3, [r1, #88]	; 0x58
    f76e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    f772:	4313      	orrs	r3, r2
    f774:	658b      	str	r3, [r1, #88]	; 0x58
    f776:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
    f778:	031f      	lsls	r7, r3, #12
    f77a:	d50e      	bpl.n	f79a <HAL_RCCEx_PeriphCLKConfig+0x576>
    switch(PeriphClkInit->AdcClockSelection)
    f77c:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
    f780:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    f784:	f000 80e3 	beq.w	f94e <HAL_RCCEx_PeriphCLKConfig+0x72a>
    f788:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
    f78c:	f000 80e5 	beq.w	f95a <HAL_RCCEx_PeriphCLKConfig+0x736>
    f790:	2900      	cmp	r1, #0
    f792:	f000 82d6 	beq.w	fd42 <HAL_RCCEx_PeriphCLKConfig+0xb1e>
      ret = HAL_ERROR;
    f796:	2601      	movs	r6, #1
    f798:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
    f79a:	0358      	lsls	r0, r3, #13
    f79c:	d50f      	bpl.n	f7be <HAL_RCCEx_PeriphCLKConfig+0x59a>
    switch(PeriphClkInit->UsbClockSelection)
    f79e:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
    f7a2:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    f7a6:	f000 80eb 	beq.w	f980 <HAL_RCCEx_PeriphCLKConfig+0x75c>
    f7aa:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
    f7ae:	f000 80ed 	beq.w	f98c <HAL_RCCEx_PeriphCLKConfig+0x768>
    f7b2:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
    f7b6:	f000 82cc 	beq.w	fd52 <HAL_RCCEx_PeriphCLKConfig+0xb2e>
      ret = HAL_ERROR;
    f7ba:	2601      	movs	r6, #1
    f7bc:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
    f7be:	03d9      	lsls	r1, r3, #15
    f7c0:	d515      	bpl.n	f7ee <HAL_RCCEx_PeriphCLKConfig+0x5ca>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
    f7c2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    f7c4:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
    f7c8:	f040 8171 	bne.w	faae <HAL_RCCEx_PeriphCLKConfig+0x88a>
    switch(PeriphClkInit->SdmmcClockSelection)
    f7cc:	2b00      	cmp	r3, #0
    f7ce:	f000 813b 	beq.w	fa48 <HAL_RCCEx_PeriphCLKConfig+0x824>
    f7d2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    f7d6:	f040 8129 	bne.w	fa2c <HAL_RCCEx_PeriphCLKConfig+0x808>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    f7da:	2102      	movs	r1, #2
    f7dc:	1d20      	adds	r0, r4, #4
    f7de:	f7ff fb41 	bl	ee64 <RCCEx_PLL2_Config>
    f7e2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f7e4:	2d00      	cmp	r5, #0
    f7e6:	f000 8137 	beq.w	fa58 <HAL_RCCEx_PeriphCLKConfig+0x834>
    f7ea:	6823      	ldr	r3, [r4, #0]
    f7ec:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
    f7ee:	009a      	lsls	r2, r3, #2
    f7f0:	f100 80e9 	bmi.w	f9c6 <HAL_RCCEx_PeriphCLKConfig+0x7a2>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
    f7f4:	039f      	lsls	r7, r3, #14
    f7f6:	d437      	bmi.n	f868 <HAL_RCCEx_PeriphCLKConfig+0x644>
    f7f8:	3600      	adds	r6, #0
    f7fa:	bf18      	it	ne
    f7fc:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
    f7fe:	02d8      	lsls	r0, r3, #11
    f800:	d50b      	bpl.n	f81a <HAL_RCCEx_PeriphCLKConfig+0x5f6>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
    f802:	6f22      	ldr	r2, [r4, #112]	; 0x70
    f804:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
    f808:	f040 814a 	bne.w	faa0 <HAL_RCCEx_PeriphCLKConfig+0x87c>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
    f80c:	4959      	ldr	r1, [pc, #356]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f80e:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    f810:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    f814:	4313      	orrs	r3, r2
    f816:	650b      	str	r3, [r1, #80]	; 0x50
    f818:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
    f81a:	0299      	lsls	r1, r3, #10
    f81c:	d50b      	bpl.n	f836 <HAL_RCCEx_PeriphCLKConfig+0x612>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
    f81e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    f820:	f032 7380 	bics.w	r3, r2, #16777216	; 0x1000000
    f824:	f040 814d 	bne.w	fac2 <HAL_RCCEx_PeriphCLKConfig+0x89e>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
    f828:	4952      	ldr	r1, [pc, #328]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f82a:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    f82c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    f830:	4313      	orrs	r3, r2
    f832:	650b      	str	r3, [r1, #80]	; 0x50
    f834:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
    f836:	005a      	lsls	r2, r3, #1
    f838:	d510      	bpl.n	f85c <HAL_RCCEx_PeriphCLKConfig+0x638>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    f83a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
    f83e:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
    f842:	f040 8145 	bne.w	fad0 <HAL_RCCEx_PeriphCLKConfig+0x8ac>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
    f846:	4b4b      	ldr	r3, [pc, #300]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f848:	691a      	ldr	r2, [r3, #16]
    f84a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    f84e:	611a      	str	r2, [r3, #16]
    f850:	691a      	ldr	r2, [r3, #16]
    f852:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
    f856:	430a      	orrs	r2, r1
    f858:	611a      	str	r2, [r3, #16]
    f85a:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
    f85c:	2b00      	cmp	r3, #0
    f85e:	f2c0 80a1 	blt.w	f9a4 <HAL_RCCEx_PeriphCLKConfig+0x780>
}
    f862:	4630      	mov	r0, r6
    f864:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->RngClockSelection)
    f868:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    f86a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    f86e:	f000 80e1 	beq.w	fa34 <HAL_RCCEx_PeriphCLKConfig+0x810>
    f872:	f240 813c 	bls.w	faee <HAL_RCCEx_PeriphCLKConfig+0x8ca>
    f876:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    f87a:	f000 80e0 	beq.w	fa3e <HAL_RCCEx_PeriphCLKConfig+0x81a>
    f87e:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
    f882:	f000 80dc 	beq.w	fa3e <HAL_RCCEx_PeriphCLKConfig+0x81a>
    f886:	2601      	movs	r6, #1
    f888:	e7b9      	b.n	f7fe <HAL_RCCEx_PeriphCLKConfig+0x5da>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    f88a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    f88e:	4b3a      	ldr	r3, [pc, #232]	; (f978 <HAL_RCCEx_PeriphCLKConfig+0x754>)
    f890:	429a      	cmp	r2, r3
    f892:	f43f ae43 	beq.w	f51c <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    f896:	f44f 715a 	mov.w	r1, #872	; 0x368
    f89a:	4838      	ldr	r0, [pc, #224]	; (f97c <HAL_RCCEx_PeriphCLKConfig+0x758>)
    f89c:	f009 fe10 	bl	194c0 <assert_failed>
    f8a0:	e63c      	b.n	f51c <HAL_RCCEx_PeriphCLKConfig+0x2f8>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f8a2:	2101      	movs	r1, #1
    f8a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f8a8:	f7ff fbcc 	bl	f044 <RCCEx_PLL3_Config>
    f8ac:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f8ae:	2d00      	cmp	r5, #0
    f8b0:	f040 809e 	bne.w	f9f0 <HAL_RCCEx_PeriphCLKConfig+0x7cc>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
    f8b4:	4a2f      	ldr	r2, [pc, #188]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f8b6:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
    f8ba:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f8bc:	f023 0307 	bic.w	r3, r3, #7
    f8c0:	430b      	orrs	r3, r1
    f8c2:	6593      	str	r3, [r2, #88]	; 0x58
    f8c4:	6823      	ldr	r3, [r4, #0]
    f8c6:	e6cb      	b.n	f660 <HAL_RCCEx_PeriphCLKConfig+0x43c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f8c8:	2101      	movs	r1, #1
    f8ca:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f8ce:	f7ff fbb9 	bl	f044 <RCCEx_PLL3_Config>
    f8d2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f8d4:	2d00      	cmp	r5, #0
    f8d6:	f040 808e 	bne.w	f9f6 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
    f8da:	4a26      	ldr	r2, [pc, #152]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f8dc:	6f61      	ldr	r1, [r4, #116]	; 0x74
    f8de:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f8e0:	f023 0307 	bic.w	r3, r3, #7
    f8e4:	430b      	orrs	r3, r1
    f8e6:	6553      	str	r3, [r2, #84]	; 0x54
    f8e8:	6823      	ldr	r3, [r4, #0]
    f8ea:	e6a7      	b.n	f63c <HAL_RCCEx_PeriphCLKConfig+0x418>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    f8ec:	2102      	movs	r1, #2
    f8ee:	1d20      	adds	r0, r4, #4
    f8f0:	f7ff fab8 	bl	ee64 <RCCEx_PLL2_Config>
    f8f4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f8f6:	2d00      	cmp	r5, #0
    f8f8:	d177      	bne.n	f9ea <HAL_RCCEx_PeriphCLKConfig+0x7c6>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
    f8fa:	4a1e      	ldr	r2, [pc, #120]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f8fc:	6c61      	ldr	r1, [r4, #68]	; 0x44
    f8fe:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    f900:	f023 0303 	bic.w	r3, r3, #3
    f904:	430b      	orrs	r3, r1
    f906:	64d3      	str	r3, [r2, #76]	; 0x4c
    f908:	6823      	ldr	r3, [r4, #0]
    f90a:	e58a      	b.n	f422 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f90c:	2101      	movs	r1, #1
    f90e:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f912:	f7ff fb97 	bl	f044 <RCCEx_PLL3_Config>
    f916:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f918:	2d00      	cmp	r5, #0
    f91a:	d163      	bne.n	f9e4 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
    f91c:	4a15      	ldr	r2, [pc, #84]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f91e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
    f920:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f922:	f023 0338 	bic.w	r3, r3, #56	; 0x38
    f926:	430b      	orrs	r3, r1
    f928:	6553      	str	r3, [r2, #84]	; 0x54
    f92a:	6823      	ldr	r3, [r4, #0]
    f92c:	e677      	b.n	f61e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    f92e:	2101      	movs	r1, #1
    f930:	1d20      	adds	r0, r4, #4
    f932:	f7ff fa97 	bl	ee64 <RCCEx_PLL2_Config>
    f936:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f938:	2d00      	cmp	r5, #0
    f93a:	d174      	bne.n	fa26 <HAL_RCCEx_PeriphCLKConfig+0x802>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
    f93c:	4a0d      	ldr	r2, [pc, #52]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f93e:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    f940:	6d13      	ldr	r3, [r2, #80]	; 0x50
    f942:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    f946:	430b      	orrs	r3, r1
    f948:	6513      	str	r3, [r2, #80]	; 0x50
    f94a:	6823      	ldr	r3, [r4, #0]
    f94c:	e55c      	b.n	f408 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    f94e:	2102      	movs	r1, #2
    f950:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f954:	f7ff fb76 	bl	f044 <RCCEx_PLL3_Config>
    f958:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f95a:	2d00      	cmp	r5, #0
    f95c:	d151      	bne.n	fa02 <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
    f95e:	4a05      	ldr	r2, [pc, #20]	; (f974 <HAL_RCCEx_PeriphCLKConfig+0x750>)
    f960:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
    f964:	6d93      	ldr	r3, [r2, #88]	; 0x58
    f966:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    f96a:	430b      	orrs	r3, r1
    f96c:	6593      	str	r3, [r2, #88]	; 0x58
    f96e:	6823      	ldr	r3, [r4, #0]
    f970:	e713      	b.n	f79a <HAL_RCCEx_PeriphCLKConfig+0x576>
    f972:	bf00      	nop
    f974:	58024400 	.word	0x58024400
    f978:	0003e300 	.word	0x0003e300
    f97c:	000301e0 	.word	0x000301e0
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    f980:	2101      	movs	r1, #1
    f982:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f986:	f7ff fb5d 	bl	f044 <RCCEx_PLL3_Config>
    f98a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    f98c:	2d00      	cmp	r5, #0
    f98e:	d135      	bne.n	f9fc <HAL_RCCEx_PeriphCLKConfig+0x7d8>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
    f990:	4ab2      	ldr	r2, [pc, #712]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    f992:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
    f996:	6d53      	ldr	r3, [r2, #84]	; 0x54
    f998:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    f99c:	430b      	orrs	r3, r1
    f99e:	6553      	str	r3, [r2, #84]	; 0x54
    f9a0:	6823      	ldr	r3, [r4, #0]
    f9a2:	e70c      	b.n	f7be <HAL_RCCEx_PeriphCLKConfig+0x59a>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
    f9a4:	6d22      	ldr	r2, [r4, #80]	; 0x50
    f9a6:	f032 5380 	bics.w	r3, r2, #268435456	; 0x10000000
    f9aa:	d003      	beq.n	f9b4 <HAL_RCCEx_PeriphCLKConfig+0x790>
    f9ac:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    f9b0:	f040 81c0 	bne.w	fd34 <HAL_RCCEx_PeriphCLKConfig+0xb10>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
    f9b4:	49a9      	ldr	r1, [pc, #676]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
}
    f9b6:	4630      	mov	r0, r6
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
    f9b8:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
    f9ba:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    f9be:	4313      	orrs	r3, r2
    f9c0:	64cb      	str	r3, [r1, #76]	; 0x4c
}
    f9c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
    f9c6:	2102      	movs	r1, #2
    f9c8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    f9cc:	f7ff fb3a 	bl	f044 <RCCEx_PLL3_Config>
    f9d0:	6823      	ldr	r3, [r4, #0]
    f9d2:	2800      	cmp	r0, #0
    f9d4:	f43f af0e 	beq.w	f7f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>
      status=HAL_ERROR;
    f9d8:	2601      	movs	r6, #1
    f9da:	e70b      	b.n	f7f4 <HAL_RCCEx_PeriphCLKConfig+0x5d0>
            ret = HAL_TIMEOUT;
    f9dc:	2603      	movs	r6, #3
    f9de:	6823      	ldr	r3, [r4, #0]
    f9e0:	4635      	mov	r5, r6
    f9e2:	e5ea      	b.n	f5ba <HAL_RCCEx_PeriphCLKConfig+0x396>
    f9e4:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9e6:	462e      	mov	r6, r5
    f9e8:	e619      	b.n	f61e <HAL_RCCEx_PeriphCLKConfig+0x3fa>
    f9ea:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9ec:	462e      	mov	r6, r5
    f9ee:	e518      	b.n	f422 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    f9f0:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9f2:	462e      	mov	r6, r5
    f9f4:	e634      	b.n	f660 <HAL_RCCEx_PeriphCLKConfig+0x43c>
    f9f6:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9f8:	462e      	mov	r6, r5
    f9fa:	e61f      	b.n	f63c <HAL_RCCEx_PeriphCLKConfig+0x418>
    f9fc:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    f9fe:	462e      	mov	r6, r5
    fa00:	e6dd      	b.n	f7be <HAL_RCCEx_PeriphCLKConfig+0x59a>
    fa02:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa04:	462e      	mov	r6, r5
    fa06:	e6c8      	b.n	f79a <HAL_RCCEx_PeriphCLKConfig+0x576>
    fa08:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa0a:	462e      	mov	r6, r5
    fa0c:	e4ec      	b.n	f3e8 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    fa0e:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa10:	462e      	mov	r6, r5
    fa12:	e4c9      	b.n	f3a8 <HAL_RCCEx_PeriphCLKConfig+0x184>
    fa14:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa16:	462e      	mov	r6, r5
    fa18:	e682      	b.n	f720 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    fa1a:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa1c:	462e      	mov	r6, r5
    fa1e:	e65f      	b.n	f6e0 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    fa20:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa22:	462e      	mov	r6, r5
    fa24:	e63c      	b.n	f6a0 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    fa26:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fa28:	462e      	mov	r6, r5
    fa2a:	e4ed      	b.n	f408 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
      ret = HAL_ERROR;
    fa2c:	2601      	movs	r6, #1
    fa2e:	6823      	ldr	r3, [r4, #0]
    fa30:	4635      	mov	r5, r6
    fa32:	e6dc      	b.n	f7ee <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fa34:	4a89      	ldr	r2, [pc, #548]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa36:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fa38:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fa3c:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fa3e:	2d00      	cmp	r5, #0
    fa40:	d05a      	beq.n	faf8 <HAL_RCCEx_PeriphCLKConfig+0x8d4>
    fa42:	6823      	ldr	r3, [r4, #0]
    fa44:	2601      	movs	r6, #1
    fa46:	e6da      	b.n	f7fe <HAL_RCCEx_PeriphCLKConfig+0x5da>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fa48:	4a84      	ldr	r2, [pc, #528]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa4a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fa4c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fa50:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fa52:	2d00      	cmp	r5, #0
    fa54:	f47f aec9 	bne.w	f7ea <HAL_RCCEx_PeriphCLKConfig+0x5c6>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
    fa58:	4a80      	ldr	r2, [pc, #512]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa5a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
    fa5c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    fa5e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    fa62:	430b      	orrs	r3, r1
    fa64:	64d3      	str	r3, [r2, #76]	; 0x4c
    fa66:	6823      	ldr	r3, [r4, #0]
    fa68:	e6c1      	b.n	f7ee <HAL_RCCEx_PeriphCLKConfig+0x5ca>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    fa6a:	2101      	movs	r1, #1
    fa6c:	1d20      	adds	r0, r4, #4
    fa6e:	f7ff f9f9 	bl	ee64 <RCCEx_PLL2_Config>
    fa72:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fa74:	2d00      	cmp	r5, #0
    fa76:	f43f af30 	beq.w	f8da <HAL_RCCEx_PeriphCLKConfig+0x6b6>
    fa7a:	e7bc      	b.n	f9f6 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    fa7c:	2101      	movs	r1, #1
    fa7e:	1d20      	adds	r0, r4, #4
    fa80:	f7ff f9f0 	bl	ee64 <RCCEx_PLL2_Config>
    fa84:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fa86:	2d00      	cmp	r5, #0
    fa88:	f43f af14 	beq.w	f8b4 <HAL_RCCEx_PeriphCLKConfig+0x690>
    fa8c:	e7b0      	b.n	f9f0 <HAL_RCCEx_PeriphCLKConfig+0x7cc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fa8e:	4a73      	ldr	r2, [pc, #460]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fa90:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fa92:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fa96:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fa98:	2d00      	cmp	r5, #0
    fa9a:	f43f af2e 	beq.w	f8fa <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    fa9e:	e7a4      	b.n	f9ea <HAL_RCCEx_PeriphCLKConfig+0x7c6>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
    faa0:	f240 51bd 	movw	r1, #1469	; 0x5bd
    faa4:	486e      	ldr	r0, [pc, #440]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    faa6:	f009 fd0b 	bl	194c0 <assert_failed>
    faaa:	6f22      	ldr	r2, [r4, #112]	; 0x70
    faac:	e6ae      	b.n	f80c <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
    faae:	f240 515e 	movw	r1, #1374	; 0x55e
    fab2:	486b      	ldr	r0, [pc, #428]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    fab4:	f009 fd04 	bl	194c0 <assert_failed>
    fab8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    switch(PeriphClkInit->SdmmcClockSelection)
    faba:	2b00      	cmp	r3, #0
    fabc:	f47f ae89 	bne.w	f7d2 <HAL_RCCEx_PeriphCLKConfig+0x5ae>
    fac0:	e7c2      	b.n	fa48 <HAL_RCCEx_PeriphCLKConfig+0x824>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
    fac2:	f240 51d1 	movw	r1, #1489	; 0x5d1
    fac6:	4866      	ldr	r0, [pc, #408]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    fac8:	f009 fcfa 	bl	194c0 <assert_failed>
    facc:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    face:	e6ab      	b.n	f828 <HAL_RCCEx_PeriphCLKConfig+0x604>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    fad0:	f240 51e7 	movw	r1, #1511	; 0x5e7
    fad4:	4862      	ldr	r0, [pc, #392]	; (fc60 <HAL_RCCEx_PeriphCLKConfig+0xa3c>)
    fad6:	f009 fcf3 	bl	194c0 <assert_failed>
    fada:	e6b4      	b.n	f846 <HAL_RCCEx_PeriphCLKConfig+0x622>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
    fadc:	2101      	movs	r1, #1
    fade:	1d20      	adds	r0, r4, #4
    fae0:	f7ff f9c0 	bl	ee64 <RCCEx_PLL2_Config>
    fae4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fae6:	2d00      	cmp	r5, #0
    fae8:	f43f af18 	beq.w	f91c <HAL_RCCEx_PeriphCLKConfig+0x6f8>
    faec:	e77a      	b.n	f9e4 <HAL_RCCEx_PeriphCLKConfig+0x7c0>
    switch(PeriphClkInit->RngClockSelection)
    faee:	2a00      	cmp	r2, #0
    faf0:	f47f aec9 	bne.w	f886 <HAL_RCCEx_PeriphCLKConfig+0x662>
    if(ret == HAL_OK)
    faf4:	2d00      	cmp	r5, #0
    faf6:	d1a4      	bne.n	fa42 <HAL_RCCEx_PeriphCLKConfig+0x81e>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
    faf8:	4a58      	ldr	r2, [pc, #352]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fafa:	3600      	adds	r6, #0
    fafc:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
    fafe:	6d53      	ldr	r3, [r2, #84]	; 0x54
    fb00:	bf18      	it	ne
    fb02:	2601      	movne	r6, #1
    fb04:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    fb08:	430b      	orrs	r3, r1
    fb0a:	6553      	str	r3, [r2, #84]	; 0x54
    fb0c:	6823      	ldr	r3, [r4, #0]
    fb0e:	e676      	b.n	f7fe <HAL_RCCEx_PeriphCLKConfig+0x5da>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fb10:	4a52      	ldr	r2, [pc, #328]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fb12:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fb14:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fb18:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fb1a:	b14d      	cbz	r5, fb30 <HAL_RCCEx_PeriphCLKConfig+0x90c>
    fb1c:	6823      	ldr	r3, [r4, #0]
    fb1e:	462e      	mov	r6, r5
    fb20:	e40a      	b.n	f338 <HAL_RCCEx_PeriphCLKConfig+0x114>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    fb22:	2102      	movs	r1, #2
    fb24:	1d20      	adds	r0, r4, #4
    fb26:	f7ff f99d 	bl	ee64 <RCCEx_PLL2_Config>
    fb2a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb2c:	2d00      	cmp	r5, #0
    fb2e:	d1f5      	bne.n	fb1c <HAL_RCCEx_PeriphCLKConfig+0x8f8>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
    fb30:	4a4a      	ldr	r2, [pc, #296]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fb32:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    fb34:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    fb36:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    fb3a:	430b      	orrs	r3, r1
    fb3c:	64d3      	str	r3, [r2, #76]	; 0x4c
    fb3e:	6823      	ldr	r3, [r4, #0]
    fb40:	f7ff bbfa 	b.w	f338 <HAL_RCCEx_PeriphCLKConfig+0x114>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    fb44:	2101      	movs	r1, #1
    fb46:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fb4a:	f7ff fa7b 	bl	f044 <RCCEx_PLL3_Config>
    fb4e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb50:	2d00      	cmp	r5, #0
    fb52:	f43f ac21 	beq.w	f398 <HAL_RCCEx_PeriphCLKConfig+0x174>
    fb56:	e75a      	b.n	fa0e <HAL_RCCEx_PeriphCLKConfig+0x7ea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
    fb58:	2101      	movs	r1, #1
    fb5a:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fb5e:	f7ff fa71 	bl	f044 <RCCEx_PLL3_Config>
    fb62:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb64:	2d00      	cmp	r5, #0
    fb66:	f43f ac36 	beq.w	f3d6 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    fb6a:	e74d      	b.n	fa08 <HAL_RCCEx_PeriphCLKConfig+0x7e4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fb6c:	4a3b      	ldr	r2, [pc, #236]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fb6e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fb70:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fb74:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fb76:	2d00      	cmp	r5, #0
    fb78:	f43f aee0 	beq.w	f93c <HAL_RCCEx_PeriphCLKConfig+0x718>
    fb7c:	e753      	b.n	fa26 <HAL_RCCEx_PeriphCLKConfig+0x802>
    switch(PeriphClkInit->Sai1ClockSelection)
    fb7e:	4635      	mov	r5, r6
    if(ret == HAL_OK)
    fb80:	b34d      	cbz	r5, fbd6 <HAL_RCCEx_PeriphCLKConfig+0x9b2>
    fb82:	6823      	ldr	r3, [r4, #0]
    fb84:	462e      	mov	r6, r5
    fb86:	f7ff bb79 	b.w	f27c <HAL_RCCEx_PeriphCLKConfig+0x58>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fb8a:	2102      	movs	r1, #2
    fb8c:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fb90:	f7ff fa58 	bl	f044 <RCCEx_PLL3_Config>
    fb94:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fb96:	2d00      	cmp	r5, #0
    fb98:	f43f adb9 	beq.w	f70e <HAL_RCCEx_PeriphCLKConfig+0x4ea>
    fb9c:	e73a      	b.n	fa14 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fb9e:	2102      	movs	r1, #2
    fba0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fba4:	f7ff fa4e 	bl	f044 <RCCEx_PLL3_Config>
    fba8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fbaa:	2d00      	cmp	r5, #0
    fbac:	f43f ad8f 	beq.w	f6ce <HAL_RCCEx_PeriphCLKConfig+0x4aa>
    fbb0:	e733      	b.n	fa1a <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fbb2:	2102      	movs	r1, #2
    fbb4:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fbb8:	f7ff fa44 	bl	f044 <RCCEx_PLL3_Config>
    fbbc:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fbbe:	2d00      	cmp	r5, #0
    fbc0:	f43f ad65 	beq.w	f68e <HAL_RCCEx_PeriphCLKConfig+0x46a>
    fbc4:	e72c      	b.n	fa20 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fbc6:	4a25      	ldr	r2, [pc, #148]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
      break;
    fbc8:	4635      	mov	r5, r6
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fbca:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fbcc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fbd0:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fbd2:	2d00      	cmp	r5, #0
    fbd4:	d1d5      	bne.n	fb82 <HAL_RCCEx_PeriphCLKConfig+0x95e>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
    fbd6:	4a21      	ldr	r2, [pc, #132]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fbd8:	6d61      	ldr	r1, [r4, #84]	; 0x54
    fbda:	6d13      	ldr	r3, [r2, #80]	; 0x50
    fbdc:	f023 0307 	bic.w	r3, r3, #7
    fbe0:	430b      	orrs	r3, r1
    fbe2:	6513      	str	r3, [r2, #80]	; 0x50
    fbe4:	6823      	ldr	r3, [r4, #0]
    fbe6:	f7ff bb49 	b.w	f27c <HAL_RCCEx_PeriphCLKConfig+0x58>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    fbea:	2100      	movs	r1, #0
    fbec:	1d20      	adds	r0, r4, #4
    fbee:	f7ff f939 	bl	ee64 <RCCEx_PLL2_Config>
    fbf2:	4605      	mov	r5, r0
      break;
    fbf4:	e7c4      	b.n	fb80 <HAL_RCCEx_PeriphCLKConfig+0x95c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fbf6:	2100      	movs	r1, #0
    fbf8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fbfc:	f7ff fa22 	bl	f044 <RCCEx_PLL3_Config>
    fc00:	4605      	mov	r5, r0
      break;
    fc02:	e7bd      	b.n	fb80 <HAL_RCCEx_PeriphCLKConfig+0x95c>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
    fc04:	2102      	movs	r1, #2
    fc06:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fc0a:	f7ff fa1b 	bl	f044 <RCCEx_PLL3_Config>
    fc0e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    fc12:	2800      	cmp	r0, #0
    fc14:	f43f ad90 	beq.w	f738 <HAL_RCCEx_PeriphCLKConfig+0x514>
          status = HAL_ERROR;
    fc18:	2601      	movs	r6, #1
    fc1a:	e58d      	b.n	f738 <HAL_RCCEx_PeriphCLKConfig+0x514>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
    fc1c:	2102      	movs	r1, #2
    fc1e:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fc22:	f7ff fa0f 	bl	f044 <RCCEx_PLL3_Config>
    fc26:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    fc2a:	2800      	cmp	r0, #0
    fc2c:	f43f ad9d 	beq.w	f76a <HAL_RCCEx_PeriphCLKConfig+0x546>
        status = HAL_ERROR;
    fc30:	2601      	movs	r6, #1
    fc32:	e59a      	b.n	f76a <HAL_RCCEx_PeriphCLKConfig+0x546>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fc34:	2100      	movs	r1, #0
    fc36:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fc3a:	f7ff fa03 	bl	f044 <RCCEx_PLL3_Config>
    fc3e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fc40:	2d00      	cmp	r5, #0
    fc42:	f47f ab91 	bne.w	f368 <HAL_RCCEx_PeriphCLKConfig+0x144>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
    fc46:	4a05      	ldr	r2, [pc, #20]	; (fc5c <HAL_RCCEx_PeriphCLKConfig+0xa38>)
    fc48:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    fc4a:	6d13      	ldr	r3, [r2, #80]	; 0x50
    fc4c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
    fc50:	430b      	orrs	r3, r1
    fc52:	6513      	str	r3, [r2, #80]	; 0x50
    fc54:	6823      	ldr	r3, [r4, #0]
    fc56:	f7ff bb89 	b.w	f36c <HAL_RCCEx_PeriphCLKConfig+0x148>
    fc5a:	bf00      	nop
    fc5c:	58024400 	.word	0x58024400
    fc60:	000301e0 	.word	0x000301e0
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fc64:	4aa0      	ldr	r2, [pc, #640]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fc66:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fc68:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fc6c:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fc6e:	2d00      	cmp	r5, #0
    fc70:	f47f ab50 	bne.w	f314 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
    fc74:	4a9c      	ldr	r2, [pc, #624]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fc76:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
    fc7a:	6d93      	ldr	r3, [r2, #88]	; 0x58
    fc7c:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    fc80:	430b      	orrs	r3, r1
    fc82:	6593      	str	r3, [r2, #88]	; 0x58
    fc84:	6823      	ldr	r3, [r4, #0]
    fc86:	f7ff bb47 	b.w	f318 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
    fc8a:	2102      	movs	r1, #2
    fc8c:	3004      	adds	r0, #4
    fc8e:	f7ff f8e9 	bl	ee64 <RCCEx_PLL2_Config>
    fc92:	4606      	mov	r6, r0
    if(ret == HAL_OK)
    fc94:	2e00      	cmp	r6, #0
    fc96:	f47f aae2 	bne.w	f25e <HAL_RCCEx_PeriphCLKConfig+0x3a>
    fc9a:	6e62      	ldr	r2, [r4, #100]	; 0x64
    fc9c:	f7ff bad8 	b.w	f250 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fca0:	2100      	movs	r1, #0
    fca2:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fca6:	f7ff f9cd 	bl	f044 <RCCEx_PLL3_Config>
    fcaa:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fcac:	2d00      	cmp	r5, #0
    fcae:	f47f aafb 	bne.w	f2a8 <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
    fcb2:	4a8d      	ldr	r2, [pc, #564]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fcb4:	6da1      	ldr	r1, [r4, #88]	; 0x58
    fcb6:	6d13      	ldr	r3, [r2, #80]	; 0x50
    fcb8:	f423 73e0 	bic.w	r3, r3, #448	; 0x1c0
    fcbc:	430b      	orrs	r3, r1
    fcbe:	6513      	str	r3, [r2, #80]	; 0x50
    fcc0:	6823      	ldr	r3, [r4, #0]
    fcc2:	f7ff baf3 	b.w	f2ac <HAL_RCCEx_PeriphCLKConfig+0x88>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
    fcc6:	2100      	movs	r1, #0
    fcc8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fccc:	f7ff f9ba 	bl	f044 <RCCEx_PLL3_Config>
    fcd0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fcd2:	2d00      	cmp	r5, #0
    fcd4:	f47f ab03 	bne.w	f2de <HAL_RCCEx_PeriphCLKConfig+0xba>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
    fcd8:	4a83      	ldr	r2, [pc, #524]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fcda:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
    fcde:	6d93      	ldr	r3, [r2, #88]	; 0x58
    fce0:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
    fce4:	430b      	orrs	r3, r1
    fce6:	6593      	str	r3, [r2, #88]	; 0x58
    fce8:	6823      	ldr	r3, [r4, #0]
    fcea:	f7ff bafa 	b.w	f2e2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
    fcee:	2100      	movs	r1, #0
    fcf0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    fcf4:	f7ff f9a6 	bl	f044 <RCCEx_PLL3_Config>
    fcf8:	4605      	mov	r5, r0
      break;
    fcfa:	f7ff bb08 	b.w	f30e <HAL_RCCEx_PeriphCLKConfig+0xea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
    fcfe:	2102      	movs	r1, #2
    fd00:	3024      	adds	r0, #36	; 0x24
    fd02:	f7ff f99f 	bl	f044 <RCCEx_PLL3_Config>
    fd06:	4606      	mov	r6, r0
      break;
    fd08:	e7c4      	b.n	fc94 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd0a:	4a77      	ldr	r2, [pc, #476]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd0c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd0e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd12:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
    fd14:	f7ff bac5 	b.w	f2a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd18:	4a73      	ldr	r2, [pc, #460]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd1a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd1c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd20:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
    fd22:	f7ff bb1e 	b.w	f362 <HAL_RCCEx_PeriphCLKConfig+0x13e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd26:	4a70      	ldr	r2, [pc, #448]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd28:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd2a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd2e:	62d3      	str	r3, [r2, #44]	; 0x2c
      break;
    fd30:	f7ff bad2 	b.w	f2d8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
    fd34:	f240 51f1 	movw	r1, #1521	; 0x5f1
    fd38:	486c      	ldr	r0, [pc, #432]	; (feec <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
    fd3a:	f009 fbc1 	bl	194c0 <assert_failed>
    fd3e:	6d22      	ldr	r2, [r4, #80]	; 0x50
    fd40:	e638      	b.n	f9b4 <HAL_RCCEx_PeriphCLKConfig+0x790>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
    fd42:	1d20      	adds	r0, r4, #4
    fd44:	f7ff f88e 	bl	ee64 <RCCEx_PLL2_Config>
    fd48:	4605      	mov	r5, r0
    if(ret == HAL_OK)
    fd4a:	2d00      	cmp	r5, #0
    fd4c:	f43f ae07 	beq.w	f95e <HAL_RCCEx_PeriphCLKConfig+0x73a>
    fd50:	e657      	b.n	fa02 <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fd52:	4a65      	ldr	r2, [pc, #404]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fd54:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fd56:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fd5a:	62d3      	str	r3, [r2, #44]	; 0x2c
    if(ret == HAL_OK)
    fd5c:	2d00      	cmp	r5, #0
    fd5e:	f43f ae17 	beq.w	f990 <HAL_RCCEx_PeriphCLKConfig+0x76c>
    fd62:	e64b      	b.n	f9fc <HAL_RCCEx_PeriphCLKConfig+0x7d8>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
    fd64:	f240 41e6 	movw	r1, #1254	; 0x4e6
    fd68:	4860      	ldr	r0, [pc, #384]	; (feec <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
    fd6a:	f009 fba9 	bl	194c0 <assert_failed>
    fd6e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    fd72:	e4dd      	b.n	f730 <HAL_RCCEx_PeriphCLKConfig+0x50c>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    fd74:	f44f 619f 	mov.w	r1, #1272	; 0x4f8
    fd78:	485c      	ldr	r0, [pc, #368]	; (feec <HAL_RCCEx_PeriphCLKConfig+0xcc8>)
    fd7a:	f009 fba1 	bl	194c0 <assert_failed>
    fd7e:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
    fd82:	e4ee      	b.n	f762 <HAL_RCCEx_PeriphCLKConfig+0x53e>
        tickstart = HAL_GetTick();
    fd84:	f7f8 fb36 	bl	83f4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    fd88:	4f57      	ldr	r7, [pc, #348]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
        tickstart = HAL_GetTick();
    fd8a:	4681      	mov	r9, r0
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
    fd8c:	f241 3888 	movw	r8, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    fd90:	e006      	b.n	fda0 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
    fd92:	f7f8 fb2f 	bl	83f4 <HAL_GetTick>
    fd96:	eba0 0009 	sub.w	r0, r0, r9
    fd9a:	4540      	cmp	r0, r8
    fd9c:	f63f ae1e 	bhi.w	f9dc <HAL_RCCEx_PeriphCLKConfig+0x7b8>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
    fda0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    fda2:	079b      	lsls	r3, r3, #30
    fda4:	d5f5      	bpl.n	fd92 <HAL_RCCEx_PeriphCLKConfig+0xb6e>
    fda6:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
    fdaa:	f7ff bbf2 	b.w	f592 <HAL_RCCEx_PeriphCLKConfig+0x36e>
    switch(PeriphClkInit->Lptim345ClockSelection)
    fdae:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    fdb2:	f43f aca9 	beq.w	f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    fdb6:	f5b2 4f20 	cmp.w	r2, #40960	; 0xa000
    fdba:	f43f aca5 	beq.w	f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    fdbe:	f5b2 4fc0 	cmp.w	r2, #24576	; 0x6000
    fdc2:	f43f aca1 	beq.w	f708 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
      ret = HAL_ERROR;
    fdc6:	2601      	movs	r6, #1
    fdc8:	4635      	mov	r5, r6
    fdca:	e4a9      	b.n	f720 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
    switch(PeriphClkInit->Spi45ClockSelection)
    fdcc:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
    fdd0:	f43f aadf 	beq.w	f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
    fdd4:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
    fdd8:	f43f aadb 	beq.w	f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
    fddc:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
    fde0:	f43f aad7 	beq.w	f392 <HAL_RCCEx_PeriphCLKConfig+0x16e>
      ret = HAL_ERROR;
    fde4:	2601      	movs	r6, #1
    fde6:	4635      	mov	r5, r6
    fde8:	f7ff bade 	b.w	f3a8 <HAL_RCCEx_PeriphCLKConfig+0x184>
    switch(PeriphClkInit->Lptim1ClockSelection)
    fdec:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
    fdf0:	f43f ac4a 	beq.w	f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
    fdf4:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
    fdf8:	f43f ac46 	beq.w	f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
    fdfc:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
    fe00:	f43f ac42 	beq.w	f688 <HAL_RCCEx_PeriphCLKConfig+0x464>
      ret = HAL_ERROR;
    fe04:	2601      	movs	r6, #1
    fe06:	4635      	mov	r5, r6
    fe08:	e44a      	b.n	f6a0 <HAL_RCCEx_PeriphCLKConfig+0x47c>
    switch(PeriphClkInit->Spi6ClockSelection)
    fe0a:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
    fe0e:	f43f aadf 	beq.w	f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    fe12:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
    fe16:	f43f aadb 	beq.w	f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    fe1a:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
    fe1e:	f43f aad7 	beq.w	f3d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
      ret = HAL_ERROR;
    fe22:	2601      	movs	r6, #1
    fe24:	4635      	mov	r5, r6
    fe26:	f7ff badf 	b.w	f3e8 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    switch(PeriphClkInit->Lptim2ClockSelection)
    fe2a:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    fe2e:	f43f ac4b 	beq.w	f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    fe32:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
    fe36:	f43f ac47 	beq.w	f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    fe3a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
    fe3e:	f43f ac43 	beq.w	f6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
      ret = HAL_ERROR;
    fe42:	2601      	movs	r6, #1
    fe44:	4635      	mov	r5, r6
    fe46:	e44b      	b.n	f6e0 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
    switch(PeriphClkInit->Sai4AClockSelection)
    fe48:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
    fe4c:	f43f aa44 	beq.w	f2d8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
    fe50:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    fe54:	f43f aa40 	beq.w	f2d8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      ret = HAL_ERROR;
    fe58:	2601      	movs	r6, #1
    fe5a:	4635      	mov	r5, r6
    fe5c:	f7ff ba41 	b.w	f2e2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
    switch(PeriphClkInit->Sai23ClockSelection)
    fe60:	2ac0      	cmp	r2, #192	; 0xc0
    fe62:	f43f aa1e 	beq.w	f2a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    fe66:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    fe6a:	f43f aa1a 	beq.w	f2a2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      ret = HAL_ERROR;
    fe6e:	2601      	movs	r6, #1
    fe70:	4635      	mov	r5, r6
    fe72:	f7ff ba1b 	b.w	f2ac <HAL_RCCEx_PeriphCLKConfig+0x88>
    switch(PeriphClkInit->SpdifrxClockSelection)
    fe76:	bb22      	cbnz	r2, fec2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
    fe78:	4a1b      	ldr	r2, [pc, #108]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    fe7a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    fe7c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    fe80:	62d3      	str	r3, [r2, #44]	; 0x2c
    fe82:	6e42      	ldr	r2, [r0, #100]	; 0x64
    fe84:	f7ff b9e4 	b.w	f250 <HAL_RCCEx_PeriphCLKConfig+0x2c>
    switch(PeriphClkInit->Spi123ClockSelection)
    fe88:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
    fe8c:	f43f aa69 	beq.w	f362 <HAL_RCCEx_PeriphCLKConfig+0x13e>
    fe90:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    fe94:	f43f aa65 	beq.w	f362 <HAL_RCCEx_PeriphCLKConfig+0x13e>
      ret = HAL_ERROR;
    fe98:	2601      	movs	r6, #1
    fe9a:	4635      	mov	r5, r6
    fe9c:	f7ff ba66 	b.w	f36c <HAL_RCCEx_PeriphCLKConfig+0x148>
    switch(PeriphClkInit->Sai4BClockSelection)
    fea0:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
    fea4:	f43f aa33 	beq.w	f30e <HAL_RCCEx_PeriphCLKConfig+0xea>
    fea8:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
    feac:	f43f aa2f 	beq.w	f30e <HAL_RCCEx_PeriphCLKConfig+0xea>
      ret = HAL_ERROR;
    feb0:	2601      	movs	r6, #1
    feb2:	4635      	mov	r5, r6
    feb4:	f7ff ba30 	b.w	f318 <HAL_RCCEx_PeriphCLKConfig+0xf4>
    switch(PeriphClkInit->QspiClockSelection)
    feb8:	2a00      	cmp	r2, #0
    feba:	f43f ae2e 	beq.w	fb1a <HAL_RCCEx_PeriphCLKConfig+0x8f6>
    febe:	f7ff ba39 	b.w	f334 <HAL_RCCEx_PeriphCLKConfig+0x110>
      ret = HAL_ERROR;
    fec2:	2601      	movs	r6, #1
    fec4:	f7ff b9cc 	b.w	f260 <HAL_RCCEx_PeriphCLKConfig+0x3c>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
    fec8:	4807      	ldr	r0, [pc, #28]	; (fee8 <HAL_RCCEx_PeriphCLKConfig+0xcc4>)
    feca:	4b09      	ldr	r3, [pc, #36]	; (fef0 <HAL_RCCEx_PeriphCLKConfig+0xccc>)
    fecc:	6901      	ldr	r1, [r0, #16]
    fece:	ea03 1312 	and.w	r3, r3, r2, lsr #4
    fed2:	f421 527c 	bic.w	r2, r1, #16128	; 0x3f00
    fed6:	4313      	orrs	r3, r2
    fed8:	6103      	str	r3, [r0, #16]
    feda:	f7ff bb65 	b.w	f5a8 <HAL_RCCEx_PeriphCLKConfig+0x384>
    fede:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
    fee0:	462e      	mov	r6, r5
    fee2:	f7ff bb6a 	b.w	f5ba <HAL_RCCEx_PeriphCLKConfig+0x396>
    fee6:	bf00      	nop
    fee8:	58024400 	.word	0x58024400
    feec:	000301e0 	.word	0x000301e0
    fef0:	00ffffcf 	.word	0x00ffffcf

0000fef4 <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    fef4:	4a46      	ldr	r2, [pc, #280]	; (10010 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>)
{
    fef6:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    fef8:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
    fefa:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
    fefc:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
    fefe:	f3c3 3305 	ubfx	r3, r3, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
    ff02:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
  if (pll2m != 0U)
    ff04:	2b00      	cmp	r3, #0
    ff06:	d059      	beq.n	ffbc <HAL_RCCEx_GetPLL2ClockFreq+0xc8>
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
    ff08:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
    ff0c:	f3c1 1100 	ubfx	r1, r1, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    ff10:	f004 0403 	and.w	r4, r4, #3
    ff14:	ee07 3a90 	vmov	s15, r3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
    ff18:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
    ff1c:	2c01      	cmp	r4, #1
    ff1e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ff22:	ee06 1a90 	vmov	s13, r1
    ff26:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    ff2a:	d002      	beq.n	ff32 <HAL_RCCEx_GetPLL2ClockFreq+0x3e>
    ff2c:	d34e      	bcc.n	ffcc <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
    ff2e:	2c02      	cmp	r4, #2
    ff30:	d049      	beq.n	ffc6 <HAL_RCCEx_GetPLL2ClockFreq+0xd2>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ff32:	ed9f 7a38 	vldr	s14, [pc, #224]	; 10014 <HAL_RCCEx_GetPLL2ClockFreq+0x120>
    ff36:	ee87 6a27 	vdiv.f32	s12, s14, s15
    ff3a:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff3c:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ff40:	ee07 3a10 	vmov	s14, r3
    ff44:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    ff48:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    ff4c:	ee37 7a25 	vadd.f32	s14, s14, s11
    ff50:	ee77 7a26 	vadd.f32	s15, s14, s13
    ff54:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
    ff58:	4a2d      	ldr	r2, [pc, #180]	; (10010 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>)
    ff5a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    ff5e:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff60:	f3c3 2346 	ubfx	r3, r3, #9, #7
    ff64:	ee06 3a90 	vmov	s13, r3
    ff68:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
    ff6c:	bc30      	pop	{r4, r5}
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
    ff6e:	ee76 6a86 	vadd.f32	s13, s13, s12
    ff72:	ee87 7aa6 	vdiv.f32	s14, s15, s13
    ff76:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    ff7a:	ed80 7a00 	vstr	s14, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
    ff7e:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff80:	f3c3 4306 	ubfx	r3, r3, #16, #7
    ff84:	ee06 3a90 	vmov	s13, r3
    ff88:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    ff8c:	ee76 6a86 	vadd.f32	s13, s13, s12
    ff90:	ee87 7aa6 	vdiv.f32	s14, s15, s13
    ff94:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    ff98:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
    ff9c:	6b93      	ldr	r3, [r2, #56]	; 0x38
    ff9e:	f3c3 6306 	ubfx	r3, r3, #24, #7
    ffa2:	ee07 3a10 	vmov	s14, r3
    ffa6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    ffaa:	ee37 7a06 	vadd.f32	s14, s14, s12
    ffae:	eec7 6a87 	vdiv.f32	s13, s15, s14
    ffb2:	eefc 6ae6 	vcvt.u32.f32	s13, s13
    ffb6:	edc0 6a02 	vstr	s13, [r0, #8]
}
    ffba:	4770      	bx	lr
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    ffbc:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
    ffc0:	6083      	str	r3, [r0, #8]
}
    ffc2:	bc30      	pop	{r4, r5}
    ffc4:	4770      	bx	lr
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffc6:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10018 <HAL_RCCEx_GetPLL2ClockFreq+0x124>
    ffca:	e7b4      	b.n	ff36 <HAL_RCCEx_GetPLL2ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
    ffcc:	6813      	ldr	r3, [r2, #0]
    ffce:	069b      	lsls	r3, r3, #26
    ffd0:	d51a      	bpl.n	10008 <HAL_RCCEx_GetPLL2ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ffd2:	6814      	ldr	r4, [r2, #0]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffd4:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ffd8:	4910      	ldr	r1, [pc, #64]	; (1001c <HAL_RCCEx_GetPLL2ClockFreq+0x128>)
    ffda:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffde:	6b93      	ldr	r3, [r2, #56]	; 0x38
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
    ffe0:	40e1      	lsrs	r1, r4
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
    ffe2:	f3c3 0308 	ubfx	r3, r3, #0, #9
    ffe6:	ee07 1a10 	vmov	s14, r1
    ffea:	eef8 5ac7 	vcvt.f32.s32	s11, s14
    ffee:	ee07 3a10 	vmov	s14, r3
    fff2:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
    fff6:	ee85 7aa7 	vdiv.f32	s14, s11, s15
    fffa:	ee76 7a05 	vadd.f32	s15, s12, s10
    fffe:	ee77 7aa6 	vadd.f32	s15, s15, s13
   10002:	ee67 7a27 	vmul.f32	s15, s14, s15
   10006:	e7a7      	b.n	ff58 <HAL_RCCEx_GetPLL2ClockFreq+0x64>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
   10008:	ed9f 7a05 	vldr	s14, [pc, #20]	; 10020 <HAL_RCCEx_GetPLL2ClockFreq+0x12c>
   1000c:	e793      	b.n	ff36 <HAL_RCCEx_GetPLL2ClockFreq+0x42>
   1000e:	bf00      	nop
   10010:	58024400 	.word	0x58024400
   10014:	4a742400 	.word	0x4a742400
   10018:	4bbebc20 	.word	0x4bbebc20
   1001c:	03d09000 	.word	0x03d09000
   10020:	4c742400 	.word	0x4c742400

00010024 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10024:	4a46      	ldr	r2, [pc, #280]	; (10140 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>)
{
   10026:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10028:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
   1002a:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
   1002c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
   1002e:	f3c3 5305 	ubfx	r3, r3, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   10032:	6c55      	ldr	r5, [r2, #68]	; 0x44
  if (pll3m != 0U)
   10034:	2b00      	cmp	r3, #0
   10036:	d059      	beq.n	100ec <HAL_RCCEx_GetPLL3ClockFreq+0xc8>
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   10038:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
   1003c:	f3c1 2100 	ubfx	r1, r1, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10040:	f004 0403 	and.w	r4, r4, #3
   10044:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
   10048:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   1004c:	2c01      	cmp	r4, #1
   1004e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10052:	ee06 1a90 	vmov	s13, r1
   10056:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   1005a:	d002      	beq.n	10062 <HAL_RCCEx_GetPLL3ClockFreq+0x3e>
   1005c:	d34e      	bcc.n	100fc <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
   1005e:	2c02      	cmp	r4, #2
   10060:	d049      	beq.n	100f6 <HAL_RCCEx_GetPLL3ClockFreq+0xd2>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10062:	ed9f 7a38 	vldr	s14, [pc, #224]	; 10144 <HAL_RCCEx_GetPLL3ClockFreq+0x120>
   10066:	ee87 6a27 	vdiv.f32	s12, s14, s15
   1006a:	6c13      	ldr	r3, [r2, #64]	; 0x40
   1006c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10070:	ee07 3a10 	vmov	s14, r3
   10074:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   10078:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1007c:	ee37 7a25 	vadd.f32	s14, s14, s11
   10080:	ee77 7a26 	vadd.f32	s15, s14, s13
   10084:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
   10088:	4a2d      	ldr	r2, [pc, #180]	; (10140 <HAL_RCCEx_GetPLL3ClockFreq+0x11c>)
   1008a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   1008e:	6c13      	ldr	r3, [r2, #64]	; 0x40
   10090:	f3c3 2346 	ubfx	r3, r3, #9, #7
   10094:	ee06 3a90 	vmov	s13, r3
   10098:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   1009c:	bc30      	pop	{r4, r5}
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
   1009e:	ee76 6a86 	vadd.f32	s13, s13, s12
   100a2:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   100a6:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   100aa:	ed80 7a00 	vstr	s14, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
   100ae:	6c13      	ldr	r3, [r2, #64]	; 0x40
   100b0:	f3c3 4306 	ubfx	r3, r3, #16, #7
   100b4:	ee06 3a90 	vmov	s13, r3
   100b8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   100bc:	ee76 6a86 	vadd.f32	s13, s13, s12
   100c0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   100c4:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   100c8:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
   100cc:	6c13      	ldr	r3, [r2, #64]	; 0x40
   100ce:	f3c3 6306 	ubfx	r3, r3, #24, #7
   100d2:	ee07 3a10 	vmov	s14, r3
   100d6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   100da:	ee37 7a06 	vadd.f32	s14, s14, s12
   100de:	eec7 6a87 	vdiv.f32	s13, s15, s14
   100e2:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   100e6:	edc0 6a02 	vstr	s13, [r0, #8]
}
   100ea:	4770      	bx	lr
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
   100ec:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
   100f0:	6083      	str	r3, [r0, #8]
}
   100f2:	bc30      	pop	{r4, r5}
   100f4:	4770      	bx	lr
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   100f6:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10148 <HAL_RCCEx_GetPLL3ClockFreq+0x124>
   100fa:	e7b4      	b.n	10066 <HAL_RCCEx_GetPLL3ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   100fc:	6813      	ldr	r3, [r2, #0]
   100fe:	069b      	lsls	r3, r3, #26
   10100:	d51a      	bpl.n	10138 <HAL_RCCEx_GetPLL3ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10102:	6814      	ldr	r4, [r2, #0]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10104:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10108:	4910      	ldr	r1, [pc, #64]	; (1014c <HAL_RCCEx_GetPLL3ClockFreq+0x128>)
   1010a:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   1010e:	6c13      	ldr	r3, [r2, #64]	; 0x40
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10110:	40e1      	lsrs	r1, r4
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10112:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10116:	ee07 1a10 	vmov	s14, r1
   1011a:	eef8 5ac7 	vcvt.f32.s32	s11, s14
   1011e:	ee07 3a10 	vmov	s14, r3
   10122:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
   10126:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   1012a:	ee76 7a05 	vadd.f32	s15, s12, s10
   1012e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   10132:	ee67 7a27 	vmul.f32	s15, s14, s15
   10136:	e7a7      	b.n	10088 <HAL_RCCEx_GetPLL3ClockFreq+0x64>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
   10138:	ed9f 7a05 	vldr	s14, [pc, #20]	; 10150 <HAL_RCCEx_GetPLL3ClockFreq+0x12c>
   1013c:	e793      	b.n	10066 <HAL_RCCEx_GetPLL3ClockFreq+0x42>
   1013e:	bf00      	nop
   10140:	58024400 	.word	0x58024400
   10144:	4a742400 	.word	0x4a742400
   10148:	4bbebc20 	.word	0x4bbebc20
   1014c:	03d09000 	.word	0x03d09000
   10150:	4c742400 	.word	0x4c742400

00010154 <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10154:	4a46      	ldr	r2, [pc, #280]	; (10270 <HAL_RCCEx_GetPLL1ClockFreq+0x11c>)
{
   10156:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10158:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
   1015a:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
   1015c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
   1015e:	f3c3 1305 	ubfx	r3, r3, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   10162:	6b55      	ldr	r5, [r2, #52]	; 0x34
  if (pll1m != 0U)
   10164:	2b00      	cmp	r3, #0
   10166:	d059      	beq.n	1021c <HAL_RCCEx_GetPLL1ClockFreq+0xc8>
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   10168:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
   1016c:	f001 0101 	and.w	r1, r1, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   10170:	f004 0403 	and.w	r4, r4, #3
   10174:	ee07 3a90 	vmov	s15, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   10178:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
   1017c:	2c01      	cmp	r4, #1
   1017e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10182:	ee06 1a90 	vmov	s13, r1
   10186:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
   1018a:	d002      	beq.n	10192 <HAL_RCCEx_GetPLL1ClockFreq+0x3e>
   1018c:	d34e      	bcc.n	1022c <HAL_RCCEx_GetPLL1ClockFreq+0xd8>
   1018e:	2c02      	cmp	r4, #2
   10190:	d049      	beq.n	10226 <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10192:	ed9f 7a38 	vldr	s14, [pc, #224]	; 10274 <HAL_RCCEx_GetPLL1ClockFreq+0x120>
   10196:	ee87 6a27 	vdiv.f32	s12, s14, s15
   1019a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1019c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   101a0:	ee07 3a10 	vmov	s14, r3
   101a4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   101a8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   101ac:	ee37 7a25 	vadd.f32	s14, s14, s11
   101b0:	ee77 7a26 	vadd.f32	s15, s14, s13
   101b4:	ee67 7a86 	vmul.f32	s15, s15, s12
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
   101b8:	4a2d      	ldr	r2, [pc, #180]	; (10270 <HAL_RCCEx_GetPLL1ClockFreq+0x11c>)
   101ba:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   101be:	6b13      	ldr	r3, [r2, #48]	; 0x30
   101c0:	f3c3 2346 	ubfx	r3, r3, #9, #7
   101c4:	ee06 3a90 	vmov	s13, r3
   101c8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
   101cc:	bc30      	pop	{r4, r5}
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
   101ce:	ee76 6a86 	vadd.f32	s13, s13, s12
   101d2:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   101d6:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   101da:	ed80 7a00 	vstr	s14, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
   101de:	6b13      	ldr	r3, [r2, #48]	; 0x30
   101e0:	f3c3 4306 	ubfx	r3, r3, #16, #7
   101e4:	ee06 3a90 	vmov	s13, r3
   101e8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   101ec:	ee76 6a86 	vadd.f32	s13, s13, s12
   101f0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   101f4:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   101f8:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
   101fc:	6b13      	ldr	r3, [r2, #48]	; 0x30
   101fe:	f3c3 6306 	ubfx	r3, r3, #24, #7
   10202:	ee07 3a10 	vmov	s14, r3
   10206:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   1020a:	ee37 7a06 	vadd.f32	s14, s14, s12
   1020e:	eec7 6a87 	vdiv.f32	s13, s15, s14
   10212:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   10216:	edc0 6a02 	vstr	s13, [r0, #8]
}
   1021a:	4770      	bx	lr
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
   1021c:	e9c0 3300 	strd	r3, r3, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
   10220:	6083      	str	r3, [r0, #8]
}
   10222:	bc30      	pop	{r4, r5}
   10224:	4770      	bx	lr
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10226:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10278 <HAL_RCCEx_GetPLL1ClockFreq+0x124>
   1022a:	e7b4      	b.n	10196 <HAL_RCCEx_GetPLL1ClockFreq+0x42>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   1022c:	6813      	ldr	r3, [r2, #0]
   1022e:	069b      	lsls	r3, r3, #26
   10230:	d51a      	bpl.n	10268 <HAL_RCCEx_GetPLL1ClockFreq+0x114>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10232:	6814      	ldr	r4, [r2, #0]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10234:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10238:	4910      	ldr	r1, [pc, #64]	; (1027c <HAL_RCCEx_GetPLL1ClockFreq+0x128>)
   1023a:	f3c4 04c1 	ubfx	r4, r4, #3, #2
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   1023e:	6b13      	ldr	r3, [r2, #48]	; 0x30
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   10240:	40e1      	lsrs	r1, r4
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10242:	f3c3 0308 	ubfx	r3, r3, #0, #9
   10246:	ee07 1a10 	vmov	s14, r1
   1024a:	eef8 5ac7 	vcvt.f32.s32	s11, s14
   1024e:	ee07 3a10 	vmov	s14, r3
   10252:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
   10256:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   1025a:	ee76 7a05 	vadd.f32	s15, s12, s10
   1025e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   10262:	ee67 7a27 	vmul.f32	s15, s14, s15
   10266:	e7a7      	b.n	101b8 <HAL_RCCEx_GetPLL1ClockFreq+0x64>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   10268:	ed9f 7a05 	vldr	s14, [pc, #20]	; 10280 <HAL_RCCEx_GetPLL1ClockFreq+0x12c>
   1026c:	e793      	b.n	10196 <HAL_RCCEx_GetPLL1ClockFreq+0x42>
   1026e:	bf00      	nop
   10270:	58024400 	.word	0x58024400
   10274:	4a742400 	.word	0x4a742400
   10278:	4bbebc20 	.word	0x4bbebc20
   1027c:	03d09000 	.word	0x03d09000
   10280:	4c742400 	.word	0x4c742400

00010284 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
   10284:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
{
   10288:	b500      	push	{lr}
   1028a:	b085      	sub	sp, #20
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
   1028c:	d02d      	beq.n	102ea <HAL_RCCEx_GetPeriphCLKFreq+0x66>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
   1028e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   10292:	d018      	beq.n	102c6 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
   10294:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   10298:	d04e      	beq.n	10338 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
   1029a:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
   1029e:	d037      	beq.n	10310 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
   102a0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   102a4:	f000 808b 	beq.w	103be <HAL_RCCEx_GetPeriphCLKFreq+0x13a>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
   102a8:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
   102ac:	f000 80ac 	beq.w	10408 <HAL_RCCEx_GetPeriphCLKFreq+0x184>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
   102b0:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
   102b4:	f000 80b6 	beq.w	10424 <HAL_RCCEx_GetPeriphCLKFreq+0x1a0>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
   102b8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
   102bc:	d062      	beq.n	10384 <HAL_RCCEx_GetPeriphCLKFreq+0x100>
          frequency = 0;
   102be:	2000      	movs	r0, #0
}
   102c0:	b005      	add	sp, #20
   102c2:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
   102c6:	4a70      	ldr	r2, [pc, #448]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   102c8:	6d13      	ldr	r3, [r2, #80]	; 0x50
   102ca:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
      switch (saiclocksource)
   102ce:	2b80      	cmp	r3, #128	; 0x80
   102d0:	d043      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   102d2:	d86a      	bhi.n	103aa <HAL_RCCEx_GetPeriphCLKFreq+0x126>
   102d4:	2b00      	cmp	r3, #0
   102d6:	d039      	beq.n	1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   102d8:	2b40      	cmp	r3, #64	; 0x40
   102da:	d1f0      	bne.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   102dc:	a801      	add	r0, sp, #4
   102de:	f7ff fe09 	bl	fef4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
   102e2:	9801      	ldr	r0, [sp, #4]
}
   102e4:	b005      	add	sp, #20
   102e6:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
   102ea:	4b67      	ldr	r3, [pc, #412]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   102ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   102ee:	f003 0307 	and.w	r3, r3, #7
      switch (saiclocksource)
   102f2:	2b04      	cmp	r3, #4
   102f4:	d8e3      	bhi.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   102f6:	a201      	add	r2, pc, #4	; (adr r2, 102fc <HAL_RCCEx_GetPeriphCLKFreq+0x78>)
   102f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   102fc:	0001034d 	.word	0x0001034d
   10300:	000102dd 	.word	0x000102dd
   10304:	0001035b 	.word	0x0001035b
   10308:	00010331 	.word	0x00010331
   1030c:	00010369 	.word	0x00010369
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
   10310:	4a5d      	ldr	r2, [pc, #372]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10312:	6d93      	ldr	r3, [r2, #88]	; 0x58
   10314:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
      switch (saiclocksource)
   10318:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   1031c:	d01d      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   1031e:	d85c      	bhi.n	103da <HAL_RCCEx_GetPeriphCLKFreq+0x156>
   10320:	b1a3      	cbz	r3, 1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   10322:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   10326:	d0d9      	beq.n	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
   10328:	e7c9      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   1032a:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
   1032e:	d15b      	bne.n	103e8 <HAL_RCCEx_GetPeriphCLKFreq+0x164>
          frequency = EXTERNAL_CLOCK_VALUE;
   10330:	4856      	ldr	r0, [pc, #344]	; (1048c <HAL_RCCEx_GetPeriphCLKFreq+0x208>)
}
   10332:	b005      	add	sp, #20
   10334:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
   10338:	4a53      	ldr	r2, [pc, #332]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   1033a:	6d93      	ldr	r3, [r2, #88]	; 0x58
   1033c:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
      switch (saiclocksource)
   10340:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   10344:	d009      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   10346:	d8f0      	bhi.n	1032a <HAL_RCCEx_GetPeriphCLKFreq+0xa6>
   10348:	2b00      	cmp	r3, #0
   1034a:	d151      	bne.n	103f0 <HAL_RCCEx_GetPeriphCLKFreq+0x16c>
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
   1034c:	a801      	add	r0, sp, #4
   1034e:	f7ff ff01 	bl	10154 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
   10352:	9802      	ldr	r0, [sp, #8]
}
   10354:	b005      	add	sp, #20
   10356:	f85d fb04 	ldr.w	pc, [sp], #4
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   1035a:	a801      	add	r0, sp, #4
   1035c:	f7ff fe62 	bl	10024 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
   10360:	9801      	ldr	r0, [sp, #4]
}
   10362:	b005      	add	sp, #20
   10364:	f85d fb04 	ldr.w	pc, [sp], #4
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
   10368:	4b47      	ldr	r3, [pc, #284]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   1036a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
   1036c:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
   10370:	d019      	beq.n	103a6 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
   10372:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   10376:	d062      	beq.n	1043e <HAL_RCCEx_GetPeriphCLKFreq+0x1ba>
            frequency = HSE_VALUE;
   10378:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   1037c:	4844      	ldr	r0, [pc, #272]	; (10490 <HAL_RCCEx_GetPeriphCLKFreq+0x20c>)
   1037e:	bf18      	it	ne
   10380:	2000      	movne	r0, #0
   10382:	e79d      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
   10384:	4b40      	ldr	r3, [pc, #256]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10386:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   10388:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
      switch (srcclk)
   1038c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   10390:	d068      	beq.n	10464 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
   10392:	d95b      	bls.n	1044c <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>
   10394:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
   10398:	d051      	beq.n	1043e <HAL_RCCEx_GetPeriphCLKFreq+0x1ba>
   1039a:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
   1039e:	d05f      	beq.n	10460 <HAL_RCCEx_GetPeriphCLKFreq+0x1dc>
   103a0:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   103a4:	d18b      	bne.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
            frequency = HSI_VALUE;
   103a6:	483b      	ldr	r0, [pc, #236]	; (10494 <HAL_RCCEx_GetPeriphCLKFreq+0x210>)
   103a8:	e78a      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (saiclocksource)
   103aa:	2bc0      	cmp	r3, #192	; 0xc0
   103ac:	d0c0      	beq.n	10330 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
   103ae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   103b2:	d184      	bne.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
   103b4:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
   103b6:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
   103ba:	d1da      	bne.n	10372 <HAL_RCCEx_GetPeriphCLKFreq+0xee>
   103bc:	e7f3      	b.n	103a6 <HAL_RCCEx_GetPeriphCLKFreq+0x122>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
   103be:	4a32      	ldr	r2, [pc, #200]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   103c0:	6d13      	ldr	r3, [r2, #80]	; 0x50
   103c2:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
      switch (srcclk)
   103c6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   103ca:	d0c6      	beq.n	1035a <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
   103cc:	d815      	bhi.n	103fa <HAL_RCCEx_GetPeriphCLKFreq+0x176>
   103ce:	2b00      	cmp	r3, #0
   103d0:	d0bc      	beq.n	1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   103d2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   103d6:	d081      	beq.n	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
   103d8:	e771      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   103da:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
   103de:	d0a7      	beq.n	10330 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
   103e0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
   103e4:	d0e6      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   103e6:	e76a      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
   103e8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   103ec:	d0e2      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   103ee:	e766      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   103f0:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
   103f4:	f43f af72 	beq.w	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
   103f8:	e761      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (srcclk)
   103fa:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
   103fe:	d097      	beq.n	10330 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
   10400:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   10404:	d0d6      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   10406:	e75a      	b.n	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
   10408:	4a1f      	ldr	r2, [pc, #124]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   1040a:	6d93      	ldr	r3, [r2, #88]	; 0x58
   1040c:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
      switch (srcclk)
   10410:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   10414:	d015      	beq.n	10442 <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
   10416:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   1041a:	d0cb      	beq.n	103b4 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
   1041c:	2b00      	cmp	r3, #0
   1041e:	f47f af4e 	bne.w	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
   10422:	e75b      	b.n	102dc <HAL_RCCEx_GetPeriphCLKFreq+0x58>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
   10424:	4b18      	ldr	r3, [pc, #96]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10426:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
      switch (srcclk)
   10428:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   1042c:	d08e      	beq.n	1034c <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
   1042e:	2b00      	cmp	r3, #0
   10430:	f43f af45 	beq.w	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   10434:	a801      	add	r0, sp, #4
   10436:	f7ff fd5d 	bl	fef4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
   1043a:	9803      	ldr	r0, [sp, #12]
          break;
   1043c:	e740      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
            frequency = CSI_VALUE;
   1043e:	4816      	ldr	r0, [pc, #88]	; (10498 <HAL_RCCEx_GetPeriphCLKFreq+0x214>)
   10440:	e73e      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   10442:	a801      	add	r0, sp, #4
   10444:	f7ff fdee 	bl	10024 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
   10448:	9803      	ldr	r0, [sp, #12]
          break;
   1044a:	e739      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (srcclk)
   1044c:	b17b      	cbz	r3, 1046e <HAL_RCCEx_GetPeriphCLKFreq+0x1ea>
   1044e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   10452:	f47f af34 	bne.w	102be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   10456:	a801      	add	r0, sp, #4
   10458:	f7ff fd4c 	bl	fef4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
   1045c:	9802      	ldr	r0, [sp, #8]
          break;
   1045e:	e72f      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          frequency = HSE_VALUE;
   10460:	480b      	ldr	r0, [pc, #44]	; (10490 <HAL_RCCEx_GetPeriphCLKFreq+0x20c>)
          break;
   10462:	e72d      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   10464:	a801      	add	r0, sp, #4
   10466:	f7ff fddd 	bl	10024 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
   1046a:	9802      	ldr	r0, [sp, #8]
          break;
   1046c:	e728      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
   1046e:	f7fe fc51 	bl	ed14 <HAL_RCC_GetHCLKFreq>
   10472:	4b05      	ldr	r3, [pc, #20]	; (10488 <HAL_RCCEx_GetPeriphCLKFreq+0x204>)
   10474:	4a09      	ldr	r2, [pc, #36]	; (1049c <HAL_RCCEx_GetPeriphCLKFreq+0x218>)
   10476:	6a1b      	ldr	r3, [r3, #32]
   10478:	f3c3 1302 	ubfx	r3, r3, #4, #3
   1047c:	5cd3      	ldrb	r3, [r2, r3]
   1047e:	f003 031f 	and.w	r3, r3, #31
   10482:	40d8      	lsrs	r0, r3
          break;
   10484:	e71c      	b.n	102c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
   10486:	bf00      	nop
   10488:	58024400 	.word	0x58024400
   1048c:	00bb8000 	.word	0x00bb8000
   10490:	017d7840 	.word	0x017d7840
   10494:	03d09000 	.word	0x03d09000
   10498:	003d0900 	.word	0x003d0900
   1049c:	00031054 	.word	0x00031054

000104a0 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
   104a0:	2800      	cmp	r0, #0
   104a2:	d049      	beq.n	10538 <HAL_RNG_Init+0x98>
{
   104a4:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_RNG_ALL_INSTANCE(hrng->Instance));
   104a6:	4b28      	ldr	r3, [pc, #160]	; (10548 <HAL_RNG_Init+0xa8>)
   104a8:	4604      	mov	r4, r0
   104aa:	6802      	ldr	r2, [r0, #0]
   104ac:	429a      	cmp	r2, r3
   104ae:	d003      	beq.n	104b8 <HAL_RNG_Init+0x18>
   104b0:	21b1      	movs	r1, #177	; 0xb1
   104b2:	4826      	ldr	r0, [pc, #152]	; (1054c <HAL_RNG_Init+0xac>)
   104b4:	f009 f804 	bl	194c0 <assert_failed>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
   104b8:	6863      	ldr	r3, [r4, #4]
   104ba:	f033 0320 	bics.w	r3, r3, #32
   104be:	d131      	bne.n	10524 <HAL_RNG_Init+0x84>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
   104c0:	7a63      	ldrb	r3, [r4, #9]
   104c2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   104c6:	b343      	cbz	r3, 1051a <HAL_RNG_Init+0x7a>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
   104c8:	2302      	movs	r3, #2
      return HAL_ERROR;
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
   104ca:	e9d4 2100 	ldrd	r2, r1, [r4]
  hrng->State = HAL_RNG_STATE_BUSY;
   104ce:	7263      	strb	r3, [r4, #9]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
   104d0:	6813      	ldr	r3, [r2, #0]
   104d2:	f023 0320 	bic.w	r3, r3, #32
   104d6:	430b      	orrs	r3, r1
   104d8:	6013      	str	r3, [r2, #0]
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
   104da:	6822      	ldr	r2, [r4, #0]
   104dc:	6813      	ldr	r3, [r2, #0]
   104de:	f043 0304 	orr.w	r3, r3, #4
   104e2:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
   104e4:	6823      	ldr	r3, [r4, #0]
   104e6:	685b      	ldr	r3, [r3, #4]
   104e8:	065b      	lsls	r3, r3, #25
   104ea:	d503      	bpl.n	104f4 <HAL_RNG_Init+0x54>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
   104ec:	2304      	movs	r3, #4
    return HAL_ERROR;
   104ee:	2001      	movs	r0, #1
    hrng->State = HAL_RNG_STATE_ERROR;
   104f0:	7263      	strb	r3, [r4, #9]
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
   104f2:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
   104f4:	f7f7 ff7e 	bl	83f4 <HAL_GetTick>
   104f8:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
   104fa:	e004      	b.n	10506 <HAL_RNG_Init+0x66>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
   104fc:	f7f7 ff7a 	bl	83f4 <HAL_GetTick>
   10500:	1b40      	subs	r0, r0, r5
   10502:	2802      	cmp	r0, #2
   10504:	d81a      	bhi.n	1053c <HAL_RNG_Init+0x9c>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
   10506:	6823      	ldr	r3, [r4, #0]
   10508:	685b      	ldr	r3, [r3, #4]
   1050a:	f013 0304 	ands.w	r3, r3, #4
   1050e:	d1f5      	bne.n	104fc <HAL_RNG_Init+0x5c>
  hrng->State = HAL_RNG_STATE_READY;
   10510:	2201      	movs	r2, #1
  return HAL_OK;
   10512:	4618      	mov	r0, r3
  hrng->State = HAL_RNG_STATE_READY;
   10514:	7262      	strb	r2, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
   10516:	60e3      	str	r3, [r4, #12]
}
   10518:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
   1051a:	7222      	strb	r2, [r4, #8]
    HAL_RNG_MspInit(hrng);
   1051c:	4620      	mov	r0, r4
   1051e:	f009 fcdf 	bl	19ee0 <HAL_RNG_MspInit>
   10522:	e7d1      	b.n	104c8 <HAL_RNG_Init+0x28>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
   10524:	21b2      	movs	r1, #178	; 0xb2
   10526:	4809      	ldr	r0, [pc, #36]	; (1054c <HAL_RNG_Init+0xac>)
   10528:	f008 ffca 	bl	194c0 <assert_failed>
  if (hrng->State == HAL_RNG_STATE_RESET)
   1052c:	7a63      	ldrb	r3, [r4, #9]
   1052e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   10532:	2b00      	cmp	r3, #0
   10534:	d1c8      	bne.n	104c8 <HAL_RNG_Init+0x28>
   10536:	e7f0      	b.n	1051a <HAL_RNG_Init+0x7a>
    return HAL_ERROR;
   10538:	2001      	movs	r0, #1
}
   1053a:	4770      	bx	lr
      hrng->State = HAL_RNG_STATE_ERROR;
   1053c:	2204      	movs	r2, #4
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   1053e:	2302      	movs	r3, #2
      return HAL_ERROR;
   10540:	2001      	movs	r0, #1
      hrng->State = HAL_RNG_STATE_ERROR;
   10542:	7262      	strb	r2, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   10544:	60e3      	str	r3, [r4, #12]
}
   10546:	bd38      	pop	{r3, r4, r5, pc}
   10548:	48021800 	.word	0x48021800
   1054c:	0003021c 	.word	0x0003021c

00010550 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
   10550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
   10552:	7a03      	ldrb	r3, [r0, #8]
   10554:	2b01      	cmp	r3, #1
   10556:	d00b      	beq.n	10570 <HAL_RNG_GenerateRandomNumber+0x20>
   10558:	4604      	mov	r4, r0
   1055a:	2001      	movs	r0, #1
   1055c:	460e      	mov	r6, r1

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
   1055e:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng);
   10560:	7220      	strb	r0, [r4, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
   10562:	4283      	cmp	r3, r0
   10564:	d006      	beq.n	10574 <HAL_RNG_GenerateRandomNumber+0x24>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
   10566:	2304      	movs	r3, #4
   10568:	60e3      	str	r3, [r4, #12]
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
   1056a:	2300      	movs	r3, #0
   1056c:	7223      	strb	r3, [r4, #8]

  return status;
}
   1056e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrng);
   10570:	2002      	movs	r0, #2
}
   10572:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
   10574:	2302      	movs	r3, #2
   10576:	7263      	strb	r3, [r4, #9]
    tickstart = HAL_GetTick();
   10578:	f7f7 ff3c 	bl	83f4 <HAL_GetTick>
   1057c:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
   1057e:	e004      	b.n	1058a <HAL_RNG_GenerateRandomNumber+0x3a>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
   10580:	f7f7 ff38 	bl	83f4 <HAL_GetTick>
   10584:	1bc0      	subs	r0, r0, r7
   10586:	2802      	cmp	r0, #2
   10588:	d80b      	bhi.n	105a2 <HAL_RNG_GenerateRandomNumber+0x52>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
   1058a:	6822      	ldr	r2, [r4, #0]
   1058c:	6855      	ldr	r5, [r2, #4]
   1058e:	f015 0501 	ands.w	r5, r5, #1
   10592:	d0f5      	beq.n	10580 <HAL_RNG_GenerateRandomNumber+0x30>
    hrng->RandomNumber = hrng->Instance->DR;
   10594:	6893      	ldr	r3, [r2, #8]
    hrng->State = HAL_RNG_STATE_READY;
   10596:	2201      	movs	r2, #1
  HAL_StatusTypeDef status = HAL_OK;
   10598:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
   1059a:	6123      	str	r3, [r4, #16]
    *random32bit = hrng->RandomNumber;
   1059c:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
   1059e:	7262      	strb	r2, [r4, #9]
   105a0:	e7e3      	b.n	1056a <HAL_RNG_GenerateRandomNumber+0x1a>
        hrng->State = HAL_RNG_STATE_READY;
   105a2:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   105a4:	2302      	movs	r3, #2
        __HAL_UNLOCK(hrng);
   105a6:	7225      	strb	r5, [r4, #8]
        hrng->State = HAL_RNG_STATE_READY;
   105a8:	7260      	strb	r0, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
   105aa:	60e3      	str	r3, [r4, #12]
}
   105ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   105ae:	bf00      	nop

000105b0 <HAL_SAI_InitProtocol>:
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
  HAL_StatusTypeDef status;

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   105b0:	2904      	cmp	r1, #4
{
   105b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   105b4:	460d      	mov	r5, r1
   105b6:	4604      	mov	r4, r0
   105b8:	4617      	mov	r7, r2
   105ba:	461e      	mov	r6, r3
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   105bc:	d87c      	bhi.n	106b8 <HAL_SAI_InitProtocol+0x108>
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   105be:	2f03      	cmp	r7, #3
   105c0:	d874      	bhi.n	106ac <HAL_SAI_InitProtocol+0xfc>

  switch (protocol)
   105c2:	2d04      	cmp	r5, #4
   105c4:	d828      	bhi.n	10618 <HAL_SAI_InitProtocol+0x68>
   105c6:	e8df f005 	tbb	[pc, r5]
   105ca:	4c4c      	.short	0x4c4c
   105cc:	294c      	.short	0x294c
   105ce:	29          	.byte	0x29
   105cf:	00          	.byte	0x00

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
   105d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   105d2:	3b01      	subs	r3, #1
   105d4:	2b02      	cmp	r3, #2
   105d6:	d904      	bls.n	105e2 <HAL_SAI_InitProtocol+0x32>
   105d8:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   105dc:	4839      	ldr	r0, [pc, #228]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   105de:	f008 ff6f 	bl	194c0 <assert_failed>
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
   105e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   105e4:	b113      	cbz	r3, 105ec <HAL_SAI_InitProtocol+0x3c>
   105e6:	f433 7340 	bics.w	r3, r3, #768	; 0x300
   105ea:	d004      	beq.n	105f6 <HAL_SAI_InitProtocol+0x46>
   105ec:	f240 11af 	movw	r1, #431	; 0x1af
   105f0:	4834      	ldr	r0, [pc, #208]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   105f2:	f008 ff65 	bl	194c0 <assert_failed>
    /* Check that SAI sub-block is SAI1 or SAI4 sub-block A, in master RX mode with free protocol */
#if defined(SAI4)
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
   105f6:	6823      	ldr	r3, [r4, #0]
   105f8:	4a33      	ldr	r2, [pc, #204]	; (106c8 <HAL_SAI_InitProtocol+0x118>)
   105fa:	4293      	cmp	r3, r2
   105fc:	d005      	beq.n	1060a <HAL_SAI_InitProtocol+0x5a>
   105fe:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
   10602:	f5a2 3282 	sub.w	r2, r2, #66560	; 0x10400
   10606:	4293      	cmp	r3, r2
   10608:	d106      	bne.n	10618 <HAL_SAI_InitProtocol+0x68>
   1060a:	6862      	ldr	r2, [r4, #4]
   1060c:	2a01      	cmp	r2, #1
   1060e:	d103      	bne.n	10618 <HAL_SAI_InitProtocol+0x68>
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
   10610:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10612:	2a00      	cmp	r2, #0
   10614:	f000 816d 	beq.w	108f2 <HAL_SAI_InitProtocol+0x342>
  hsai->SlotInit.SlotNumber      = nbslot;

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
  {
    return HAL_ERROR;
   10618:	2001      	movs	r0, #1
}
   1061a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef status = HAL_OK;

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1061c:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1061e:	2300      	movs	r3, #0
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
   10620:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   10624:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10628:	f032 0202 	bics.w	r2, r2, #2
  hsai->SlotInit.FirstBitOffset  = 0;
  hsai->SlotInit.SlotNumber      = nbslot;
   1062c:	6726      	str	r6, [r4, #112]	; 0x70
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1062e:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10630:	bf0c      	ite	eq
   10632:	2201      	moveq	r2, #1
   10634:	461a      	movne	r2, r3
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;

  if (protocol == SAI_PCM_SHORT)
  {
      hsai->FrameInit.ActiveFrameLength = 1;
   10636:	2d04      	cmp	r5, #4
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   10638:	64e3      	str	r3, [r4, #76]	; 0x4c
   1063a:	6522      	str	r2, [r4, #80]	; 0x50
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1063c:	f64f 72ff 	movw	r2, #65535	; 0xffff
      hsai->FrameInit.ActiveFrameLength = 1;
   10640:	bf14      	ite	ne
   10642:	250d      	movne	r5, #13
   10644:	2501      	moveq	r5, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
   10646:	65e3      	str	r3, [r4, #92]	; 0x5c
   10648:	65a5      	str	r5, [r4, #88]	; 0x58
  hsai->SlotInit.FirstBitOffset  = 0;
   1064a:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1064c:	6762      	str	r2, [r4, #116]	; 0x74
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   1064e:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
  {
    /* SAI_PCM_LONG */
      hsai->FrameInit.ActiveFrameLength = 13;
  }

  switch (datasize)
   10652:	2f03      	cmp	r7, #3
   10654:	d8e0      	bhi.n	10618 <HAL_SAI_InitProtocol+0x68>
   10656:	e8df f017 	tbh	[pc, r7, lsl #1]
   1065a:	0173      	.short	0x0173
   1065c:	017a016d 	.word	0x017a016d
   10660:	0039      	.short	0x0039
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10662:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   10664:	2300      	movs	r3, #0
  hsai->SlotInit.SlotNumber      = nbslot;
   10666:	6726      	str	r6, [r4, #112]	; 0x70
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10668:	f032 0202 	bics.w	r2, r2, #2
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1066c:	6463      	str	r3, [r4, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1066e:	64e3      	str	r3, [r4, #76]	; 0x4c
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   10670:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10674:	bf08      	it	eq
   10676:	4619      	moveq	r1, r3
  hsai->SlotInit.FirstBitOffset  = 0;
   10678:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1067a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1067e:	bf18      	it	ne
   10680:	2101      	movne	r1, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   10682:	65e2      	str	r2, [r4, #92]	; 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   10684:	6763      	str	r3, [r4, #116]	; 0x74
  if ((nbslot & 0x1U) != 0U)
   10686:	f016 0301 	ands.w	r3, r6, #1
   1068a:	6521      	str	r1, [r4, #80]	; 0x50
   1068c:	d1c4      	bne.n	10618 <HAL_SAI_InitProtocol+0x68>
  if (protocol == SAI_I2S_STANDARD)
   1068e:	2d00      	cmp	r5, #0
   10690:	f000 8164 	beq.w	1095c <HAL_SAI_InitProtocol+0x3ac>
   10694:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   10698:	e9c4 2318 	strd	r2, r3, [r4, #96]	; 0x60
  switch (datasize)
   1069c:	2f03      	cmp	r7, #3
   1069e:	d8bb      	bhi.n	10618 <HAL_SAI_InitProtocol+0x68>
   106a0:	e8df f017 	tbh	[pc, r7, lsl #1]
   106a4:	02490259 	.word	0x02490259
   106a8:	022e0238 	.word	0x022e0238
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   106ac:	f44f 71a9 	mov.w	r1, #338	; 0x152
   106b0:	4804      	ldr	r0, [pc, #16]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   106b2:	f008 ff05 	bl	194c0 <assert_failed>
   106b6:	e784      	b.n	105c2 <HAL_SAI_InitProtocol+0x12>
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   106b8:	f240 1151 	movw	r1, #337	; 0x151
   106bc:	4801      	ldr	r0, [pc, #4]	; (106c4 <HAL_SAI_InitProtocol+0x114>)
   106be:	f008 feff 	bl	194c0 <assert_failed>
   106c2:	e77c      	b.n	105be <HAL_SAI_InitProtocol+0xe>
   106c4:	00030254 	.word	0x00030254
   106c8:	40015804 	.word	0x40015804
      hsai->FrameInit.FrameLength = 32U * nbslot;
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
      break;
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
      hsai->FrameInit.FrameLength = 32U * nbslot;
   106cc:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_32;
   106ce:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   106d0:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   106d2:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_32;
   106d4:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   106d6:	66e2      	str	r2, [r4, #108]	; 0x6c
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
   106d8:	6822      	ldr	r2, [r4, #0]
   106da:	4ba7      	ldr	r3, [pc, #668]	; (10978 <HAL_SAI_InitProtocol+0x3c8>)
   106dc:	49a7      	ldr	r1, [pc, #668]	; (1097c <HAL_SAI_InitProtocol+0x3cc>)
   106de:	48a8      	ldr	r0, [pc, #672]	; (10980 <HAL_SAI_InitProtocol+0x3d0>)
   106e0:	429a      	cmp	r2, r3
   106e2:	bf18      	it	ne
   106e4:	428a      	cmpne	r2, r1
   106e6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
   106ea:	4da6      	ldr	r5, [pc, #664]	; (10984 <HAL_SAI_InitProtocol+0x3d4>)
   106ec:	bf14      	ite	ne
   106ee:	2301      	movne	r3, #1
   106f0:	2300      	moveq	r3, #0
   106f2:	4282      	cmp	r2, r0
   106f4:	bf0c      	ite	eq
   106f6:	2300      	moveq	r3, #0
   106f8:	f003 0301 	andne.w	r3, r3, #1
   106fc:	f500 6084 	add.w	r0, r0, #1056	; 0x420
   10700:	428a      	cmp	r2, r1
   10702:	bf0c      	ite	eq
   10704:	2300      	moveq	r3, #0
   10706:	f003 0301 	andne.w	r3, r3, #1
   1070a:	499f      	ldr	r1, [pc, #636]	; (10988 <HAL_SAI_InitProtocol+0x3d8>)
   1070c:	42aa      	cmp	r2, r5
   1070e:	bf0c      	ite	eq
   10710:	2300      	moveq	r3, #0
   10712:	f003 0301 	andne.w	r3, r3, #1
   10716:	4282      	cmp	r2, r0
   10718:	bf0c      	ite	eq
   1071a:	2300      	moveq	r3, #0
   1071c:	f003 0301 	andne.w	r3, r3, #1
   10720:	428a      	cmp	r2, r1
   10722:	bf0c      	ite	eq
   10724:	2300      	moveq	r3, #0
   10726:	f003 0301 	andne.w	r3, r3, #1
   1072a:	b11b      	cbz	r3, 10734 <HAL_SAI_InitProtocol+0x184>
   1072c:	4b97      	ldr	r3, [pc, #604]	; (1098c <HAL_SAI_InitProtocol+0x3dc>)
   1072e:	429a      	cmp	r2, r3
   10730:	f040 835d 	bne.w	10dee <HAL_SAI_InitProtocol+0x83e>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
   10734:	6a22      	ldr	r2, [r4, #32]
   10736:	f64b 3680 	movw	r6, #48000	; 0xbb80
   1073a:	4b95      	ldr	r3, [pc, #596]	; (10990 <HAL_SAI_InitProtocol+0x3e0>)
   1073c:	f64a 4544 	movw	r5, #44100	; 0xac44
   10740:	4994      	ldr	r1, [pc, #592]	; (10994 <HAL_SAI_InitProtocol+0x3e4>)
   10742:	f245 6022 	movw	r0, #22050	; 0x5622
   10746:	429a      	cmp	r2, r3
   10748:	bf18      	it	ne
   1074a:	428a      	cmpne	r2, r1
   1074c:	f642 3111 	movw	r1, #11025	; 0x2b11
   10750:	bf14      	ite	ne
   10752:	2301      	movne	r3, #1
   10754:	2300      	moveq	r3, #0
   10756:	42b2      	cmp	r2, r6
   10758:	bf0c      	ite	eq
   1075a:	2300      	moveq	r3, #0
   1075c:	f003 0301 	andne.w	r3, r3, #1
   10760:	42aa      	cmp	r2, r5
   10762:	bf0c      	ite	eq
   10764:	2300      	moveq	r3, #0
   10766:	f003 0301 	andne.w	r3, r3, #1
   1076a:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
   1076e:	bf0c      	ite	eq
   10770:	2300      	moveq	r3, #0
   10772:	f003 0301 	andne.w	r3, r3, #1
   10776:	4282      	cmp	r2, r0
   10778:	bf0c      	ite	eq
   1077a:	2300      	moveq	r3, #0
   1077c:	f003 0301 	andne.w	r3, r3, #1
   10780:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
   10784:	bf0c      	ite	eq
   10786:	2300      	moveq	r3, #0
   10788:	f003 0301 	andne.w	r3, r3, #1
   1078c:	428a      	cmp	r2, r1
   1078e:	bf0c      	ite	eq
   10790:	2300      	moveq	r3, #0
   10792:	f003 0301 	andne.w	r3, r3, #1
   10796:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
   1079a:	bf0c      	ite	eq
   1079c:	2300      	moveq	r3, #0
   1079e:	f003 0301 	andne.w	r3, r3, #1
   107a2:	b113      	cbz	r3, 107aa <HAL_SAI_InitProtocol+0x1fa>
   107a4:	2a00      	cmp	r2, #0
   107a6:	f040 8333 	bne.w	10e10 <HAL_SAI_InitProtocol+0x860>
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
   107aa:	6c63      	ldr	r3, [r4, #68]	; 0x44
   107ac:	f033 0204 	bics.w	r2, r3, #4
   107b0:	d006      	beq.n	107c0 <HAL_SAI_InitProtocol+0x210>
   107b2:	2b08      	cmp	r3, #8
   107b4:	d004      	beq.n	107c0 <HAL_SAI_InitProtocol+0x210>
   107b6:	f240 1185 	movw	r1, #389	; 0x185
   107ba:	4877      	ldr	r0, [pc, #476]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   107bc:	f008 fe80 	bl	194c0 <assert_failed>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
   107c0:	6863      	ldr	r3, [r4, #4]
   107c2:	2b03      	cmp	r3, #3
   107c4:	f200 8166 	bhi.w	10a94 <HAL_SAI_InitProtocol+0x4e4>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
   107c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   107ca:	f023 0220 	bic.w	r2, r3, #32
   107ce:	2a80      	cmp	r2, #128	; 0x80
   107d0:	d004      	beq.n	107dc <HAL_SAI_InitProtocol+0x22c>
   107d2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
   107d6:	2b40      	cmp	r3, #64	; 0x40
   107d8:	f040 82e7 	bne.w	10daa <HAL_SAI_InitProtocol+0x7fa>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
   107dc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   107de:	f433 7380 	bics.w	r3, r3, #256	; 0x100
   107e2:	f040 8151 	bne.w	10a88 <HAL_SAI_InitProtocol+0x4d8>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
   107e6:	6d23      	ldr	r3, [r4, #80]	; 0x50
   107e8:	2b01      	cmp	r3, #1
   107ea:	d904      	bls.n	107f6 <HAL_SAI_InitProtocol+0x246>
   107ec:	f240 1189 	movw	r1, #393	; 0x189
   107f0:	4869      	ldr	r0, [pc, #420]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   107f2:	f008 fe65 	bl	194c0 <assert_failed>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
   107f6:	68a3      	ldr	r3, [r4, #8]
   107f8:	2b05      	cmp	r3, #5
   107fa:	f200 813f 	bhi.w	10a7c <HAL_SAI_InitProtocol+0x4cc>
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   107fe:	f7f7 fe11 	bl	8424 <HAL_GetREVID>
   10802:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
   10806:	d304      	bcc.n	10812 <HAL_SAI_InitProtocol+0x262>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
   10808:	6923      	ldr	r3, [r4, #16]
   1080a:	f033 6300 	bics.w	r3, r3, #134217728	; 0x8000000
   1080e:	f040 8294 	bne.w	10d3a <HAL_SAI_InitProtocol+0x78a>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
   10812:	6963      	ldr	r3, [r4, #20]
   10814:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
   10818:	f040 812a 	bne.w	10a70 <HAL_SAI_InitProtocol+0x4c0>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
   1081c:	69a3      	ldr	r3, [r4, #24]
   1081e:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
   10822:	f040 8167 	bne.w	10af4 <HAL_SAI_InitProtocol+0x544>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
   10826:	69e3      	ldr	r3, [r4, #28]
   10828:	2b04      	cmp	r3, #4
   1082a:	f200 815d 	bhi.w	10ae8 <HAL_SAI_InitProtocol+0x538>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
   1082e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   10830:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   10834:	f040 8152 	bne.w	10adc <HAL_SAI_InitProtocol+0x52c>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
   10838:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1083a:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
   1083e:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
   10842:	f5b1 4f20 	cmp.w	r1, #40960	; 0xa000
   10846:	bf18      	it	ne
   10848:	2a00      	cmpne	r2, #0
   1084a:	d003      	beq.n	10854 <HAL_SAI_InitProtocol+0x2a4>
   1084c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
   10850:	f040 82a3 	bne.w	10d9a <HAL_SAI_InitProtocol+0x7ea>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
   10854:	6b63      	ldr	r3, [r4, #52]	; 0x34
   10856:	f033 0310 	bics.w	r3, r3, #16
   1085a:	f040 8139 	bne.w	10ad0 <HAL_SAI_InitProtocol+0x520>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
   1085e:	68e3      	ldr	r3, [r4, #12]
   10860:	2b02      	cmp	r3, #2
   10862:	f200 812f 	bhi.w	10ac4 <HAL_SAI_InitProtocol+0x514>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
   10866:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   10868:	f033 6380 	bics.w	r3, r3, #67108864	; 0x4000000
   1086c:	f040 8124 	bne.w	10ab8 <HAL_SAI_InitProtocol+0x508>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
   10870:	6d63      	ldr	r3, [r4, #84]	; 0x54
   10872:	3b08      	subs	r3, #8
   10874:	2bf8      	cmp	r3, #248	; 0xf8
   10876:	f200 8119 	bhi.w	10aac <HAL_SAI_InitProtocol+0x4fc>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
   1087a:	6da3      	ldr	r3, [r4, #88]	; 0x58
   1087c:	3b01      	subs	r3, #1
   1087e:	2b7f      	cmp	r3, #127	; 0x7f
   10880:	f200 810e 	bhi.w	10aa0 <HAL_SAI_InitProtocol+0x4f0>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
   10884:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   10886:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
   1088a:	f040 80eb 	bne.w	10a64 <HAL_SAI_InitProtocol+0x4b4>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
   1088e:	6e23      	ldr	r3, [r4, #96]	; 0x60
   10890:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   10894:	f040 80e0 	bne.w	10a58 <HAL_SAI_InitProtocol+0x4a8>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
   10898:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1089a:	f433 2380 	bics.w	r3, r3, #262144	; 0x40000
   1089e:	f040 80d5 	bne.w	10a4c <HAL_SAI_InitProtocol+0x49c>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
   108a2:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   108a4:	2b18      	cmp	r3, #24
   108a6:	f200 80cb 	bhi.w	10a40 <HAL_SAI_InitProtocol+0x490>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
   108aa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   108ac:	f033 0240 	bics.w	r2, r3, #64	; 0x40
   108b0:	d006      	beq.n	108c0 <HAL_SAI_InitProtocol+0x310>
   108b2:	2b80      	cmp	r3, #128	; 0x80
   108b4:	d004      	beq.n	108c0 <HAL_SAI_InitProtocol+0x310>
   108b6:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
   108ba:	4837      	ldr	r0, [pc, #220]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   108bc:	f008 fe00 	bl	194c0 <assert_failed>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
   108c0:	6f23      	ldr	r3, [r4, #112]	; 0x70
   108c2:	3b01      	subs	r3, #1
   108c4:	2b0f      	cmp	r3, #15
   108c6:	f200 80b5 	bhi.w	10a34 <HAL_SAI_InitProtocol+0x484>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
   108ca:	6f63      	ldr	r3, [r4, #116]	; 0x74
   108cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   108d0:	f080 80aa 	bcs.w	10a28 <HAL_SAI_InitProtocol+0x478>
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
   108d4:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   108d8:	2b01      	cmp	r3, #1
   108da:	d906      	bls.n	108ea <HAL_SAI_InitProtocol+0x33a>
   108dc:	f240 11ab 	movw	r1, #427	; 0x1ab
   108e0:	482d      	ldr	r0, [pc, #180]	; (10998 <HAL_SAI_InitProtocol+0x3e8>)
   108e2:	f008 fded 	bl	194c0 <assert_failed>
   108e6:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
  if (hsai->Init.PdmInit.Activation == ENABLE)
   108ea:	2b01      	cmp	r3, #1
   108ec:	f43f ae70 	beq.w	105d0 <HAL_SAI_InitProtocol+0x20>
   108f0:	6823      	ldr	r3, [r4, #0]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
   108f2:	4a21      	ldr	r2, [pc, #132]	; (10978 <HAL_SAI_InitProtocol+0x3c8>)
   108f4:	4293      	cmp	r3, r2
   108f6:	d053      	beq.n	109a0 <HAL_SAI_InitProtocol+0x3f0>
   108f8:	3220      	adds	r2, #32
   108fa:	4293      	cmp	r3, r2
   108fc:	d050      	beq.n	109a0 <HAL_SAI_InitProtocol+0x3f0>
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
   108fe:	f502 7278 	add.w	r2, r2, #992	; 0x3e0
   10902:	4293      	cmp	r3, r2
   10904:	f000 8136 	beq.w	10b74 <HAL_SAI_InitProtocol+0x5c4>
   10908:	3220      	adds	r2, #32
   1090a:	4293      	cmp	r3, r2
   1090c:	f000 8132 	beq.w	10b74 <HAL_SAI_InitProtocol+0x5c4>
  else if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
   10910:	f502 7278 	add.w	r2, r2, #992	; 0x3e0
   10914:	4293      	cmp	r3, r2
   10916:	f000 8246 	beq.w	10da6 <HAL_SAI_InitProtocol+0x7f6>
   1091a:	3220      	adds	r2, #32
   1091c:	4293      	cmp	r3, r2
   1091e:	f000 8242 	beq.w	10da6 <HAL_SAI_InitProtocol+0x7f6>
  else if ((hsai->Instance == SAI4_Block_A) || (hsai->Instance == SAI4_Block_B))
   10922:	4a19      	ldr	r2, [pc, #100]	; (10988 <HAL_SAI_InitProtocol+0x3d8>)
   10924:	4293      	cmp	r3, r2
   10926:	d003      	beq.n	10930 <HAL_SAI_InitProtocol+0x380>
   10928:	3220      	adds	r2, #32
   1092a:	4293      	cmp	r3, r2
   1092c:	f47f ae74 	bne.w	10618 <HAL_SAI_InitProtocol+0x68>
    SaiBaseAddress = SAI4;
   10930:	4d1a      	ldr	r5, [pc, #104]	; (1099c <HAL_SAI_InitProtocol+0x3ec>)
   10932:	e036      	b.n	109a2 <HAL_SAI_InitProtocol+0x3f2>
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10934:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   10936:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10938:	64a2      	str	r2, [r4, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
   1093a:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1093c:	66e2      	str	r2, [r4, #108]	; 0x6c
   1093e:	e6cb      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 16U * nbslot;
   10940:	0136      	lsls	r6, r6, #4
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10942:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   10944:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 16U * nbslot;
   10946:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10948:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   1094a:	66e2      	str	r2, [r4, #108]	; 0x6c
   1094c:	e6c4      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 32U * nbslot;
   1094e:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10950:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10952:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
   10954:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10956:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10958:	66e2      	str	r2, [r4, #108]	; 0x6c
   1095a:	e6bd      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
   1095c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   10960:	e9c4 5318 	strd	r5, r3, [r4, #96]	; 0x60
  switch (datasize)
   10964:	2f03      	cmp	r7, #3
   10966:	f63f ae57 	bhi.w	10618 <HAL_SAI_InitProtocol+0x68>
   1096a:	e8df f017 	tbh	[pc, r7, lsl #1]
   1096e:	00f4      	.short	0x00f4
   10970:	00d300e4 	.word	0x00d300e4
   10974:	00c9      	.short	0x00c9
   10976:	bf00      	nop
   10978:	40015804 	.word	0x40015804
   1097c:	40015824 	.word	0x40015824
   10980:	40015c04 	.word	0x40015c04
   10984:	40016004 	.word	0x40016004
   10988:	58005404 	.word	0x58005404
   1098c:	58005424 	.word	0x58005424
   10990:	0002ee00 	.word	0x0002ee00
   10994:	00017700 	.word	0x00017700
   10998:	00030254 	.word	0x00030254
   1099c:	58005400 	.word	0x58005400
    SaiBaseAddress = SAI1;
   109a0:	4d75      	ldr	r5, [pc, #468]	; (10b78 <HAL_SAI_InitProtocol+0x5c8>)
  if (hsai->State == HAL_SAI_STATE_RESET)
   109a2:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
   109a6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   109aa:	2a00      	cmp	r2, #0
   109ac:	f000 81be 	beq.w	10d2c <HAL_SAI_InitProtocol+0x77c>
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   109b0:	4a72      	ldr	r2, [pc, #456]	; (10b7c <HAL_SAI_InitProtocol+0x5cc>)
   109b2:	4873      	ldr	r0, [pc, #460]	; (10b80 <HAL_SAI_InitProtocol+0x5d0>)
   109b4:	6812      	ldr	r2, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
   109b6:	6819      	ldr	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   109b8:	fba0 0202 	umull	r0, r2, r0, r2
  __HAL_SAI_DISABLE(hsai);
   109bc:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   109c0:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
   109c2:	6019      	str	r1, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
   109c4:	0093      	lsls	r3, r2, #2
   109c6:	b33a      	cbz	r2, 10a18 <HAL_SAI_InitProtocol+0x468>
      status = HAL_TIMEOUT;
      break;
    }
    count--;
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109c8:	6821      	ldr	r1, [r4, #0]
    count--;
   109ca:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109cc:	680a      	ldr	r2, [r1, #0]
   109ce:	03d7      	lsls	r7, r2, #15
   109d0:	d504      	bpl.n	109dc <HAL_SAI_InitProtocol+0x42c>
    if (count == 0U)
   109d2:	b30b      	cbz	r3, 10a18 <HAL_SAI_InitProtocol+0x468>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109d4:	680a      	ldr	r2, [r1, #0]
    count--;
   109d6:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   109d8:	03d2      	lsls	r2, r2, #15
   109da:	d4fa      	bmi.n	109d2 <HAL_SAI_InitProtocol+0x422>
  switch (hsai->Init.SynchroExt)
   109dc:	68e3      	ldr	r3, [r4, #12]
  hsai->State = HAL_SAI_STATE_BUSY;
   109de:	2202      	movs	r2, #2
  switch (hsai->Init.SynchroExt)
   109e0:	2b01      	cmp	r3, #1
  hsai->State = HAL_SAI_STATE_BUSY;
   109e2:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
  switch (hsai->Init.SynchroExt)
   109e6:	f000 80c0 	beq.w	10b6a <HAL_SAI_InitProtocol+0x5ba>
   109ea:	4293      	cmp	r3, r2
   109ec:	bf15      	itete	ne
   109ee:	4610      	movne	r0, r2
   109f0:	2123      	moveq	r1, #35	; 0x23
   109f2:	2103      	movne	r1, #3
   109f4:	2022      	moveq	r0, #34	; 0x22
   109f6:	bf0b      	itete	eq
   109f8:	2621      	moveq	r6, #33	; 0x21
   109fa:	2601      	movne	r6, #1
   109fc:	2220      	moveq	r2, #32
   109fe:	2200      	movne	r2, #0
  switch (hsai->Init.Synchro)
   10a00:	68a3      	ldr	r3, [r4, #8]
   10a02:	3b01      	subs	r3, #1
   10a04:	2b04      	cmp	r3, #4
   10a06:	f200 818b 	bhi.w	10d20 <HAL_SAI_InitProtocol+0x770>
   10a0a:	e8df f013 	tbh	[pc, r3, lsl #1]
   10a0e:	0186      	.short	0x0186
   10a10:	018b00c0 	.word	0x018b00c0
   10a14:	01da00bf 	.word	0x01da00bf
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10a18:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    return HAL_ERROR;
   10a1c:	2001      	movs	r0, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10a1e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10a22:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
   10a26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
   10a28:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
   10a2c:	4855      	ldr	r0, [pc, #340]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a2e:	f008 fd47 	bl	194c0 <assert_failed>
   10a32:	e74f      	b.n	108d4 <HAL_SAI_InitProtocol+0x324>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
   10a34:	f240 11a7 	movw	r1, #423	; 0x1a7
   10a38:	4852      	ldr	r0, [pc, #328]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a3a:	f008 fd41 	bl	194c0 <assert_failed>
   10a3e:	e744      	b.n	108ca <HAL_SAI_InitProtocol+0x31a>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
   10a40:	f240 11a5 	movw	r1, #421	; 0x1a5
   10a44:	484f      	ldr	r0, [pc, #316]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a46:	f008 fd3b 	bl	194c0 <assert_failed>
   10a4a:	e72e      	b.n	108aa <HAL_SAI_InitProtocol+0x2fa>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
   10a4c:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
   10a50:	484c      	ldr	r0, [pc, #304]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a52:	f008 fd35 	bl	194c0 <assert_failed>
   10a56:	e724      	b.n	108a2 <HAL_SAI_InitProtocol+0x2f2>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
   10a58:	f240 11a1 	movw	r1, #417	; 0x1a1
   10a5c:	4849      	ldr	r0, [pc, #292]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a5e:	f008 fd2f 	bl	194c0 <assert_failed>
   10a62:	e719      	b.n	10898 <HAL_SAI_InitProtocol+0x2e8>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
   10a64:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
   10a68:	4846      	ldr	r0, [pc, #280]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a6a:	f008 fd29 	bl	194c0 <assert_failed>
   10a6e:	e70e      	b.n	1088e <HAL_SAI_InitProtocol+0x2de>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
   10a70:	f44f 71ca 	mov.w	r1, #404	; 0x194
   10a74:	4843      	ldr	r0, [pc, #268]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a76:	f008 fd23 	bl	194c0 <assert_failed>
   10a7a:	e6cf      	b.n	1081c <HAL_SAI_InitProtocol+0x26c>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
   10a7c:	f44f 71c5 	mov.w	r1, #394	; 0x18a
   10a80:	4840      	ldr	r0, [pc, #256]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a82:	f008 fd1d 	bl	194c0 <assert_failed>
   10a86:	e6ba      	b.n	107fe <HAL_SAI_InitProtocol+0x24e>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
   10a88:	f44f 71c4 	mov.w	r1, #392	; 0x188
   10a8c:	483d      	ldr	r0, [pc, #244]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a8e:	f008 fd17 	bl	194c0 <assert_failed>
   10a92:	e6a8      	b.n	107e6 <HAL_SAI_InitProtocol+0x236>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
   10a94:	f44f 71c3 	mov.w	r1, #390	; 0x186
   10a98:	483a      	ldr	r0, [pc, #232]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10a9a:	f008 fd11 	bl	194c0 <assert_failed>
   10a9e:	e693      	b.n	107c8 <HAL_SAI_InitProtocol+0x218>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
   10aa0:	f240 119f 	movw	r1, #415	; 0x19f
   10aa4:	4837      	ldr	r0, [pc, #220]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10aa6:	f008 fd0b 	bl	194c0 <assert_failed>
   10aaa:	e6eb      	b.n	10884 <HAL_SAI_InitProtocol+0x2d4>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
   10aac:	f44f 71cf 	mov.w	r1, #414	; 0x19e
   10ab0:	4834      	ldr	r0, [pc, #208]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10ab2:	f008 fd05 	bl	194c0 <assert_failed>
   10ab6:	e6e0      	b.n	1087a <HAL_SAI_InitProtocol+0x2ca>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
   10ab8:	f240 119b 	movw	r1, #411	; 0x19b
   10abc:	4831      	ldr	r0, [pc, #196]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10abe:	f008 fcff 	bl	194c0 <assert_failed>
   10ac2:	e6d5      	b.n	10870 <HAL_SAI_InitProtocol+0x2c0>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
   10ac4:	f44f 71cd 	mov.w	r1, #410	; 0x19a
   10ac8:	482e      	ldr	r0, [pc, #184]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10aca:	f008 fcf9 	bl	194c0 <assert_failed>
   10ace:	e6ca      	b.n	10866 <HAL_SAI_InitProtocol+0x2b6>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
   10ad0:	f240 1199 	movw	r1, #409	; 0x199
   10ad4:	482b      	ldr	r0, [pc, #172]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10ad6:	f008 fcf3 	bl	194c0 <assert_failed>
   10ada:	e6c0      	b.n	1085e <HAL_SAI_InitProtocol+0x2ae>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
   10adc:	f240 1197 	movw	r1, #407	; 0x197
   10ae0:	4828      	ldr	r0, [pc, #160]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10ae2:	f008 fced 	bl	194c0 <assert_failed>
   10ae6:	e6a7      	b.n	10838 <HAL_SAI_InitProtocol+0x288>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
   10ae8:	f44f 71cb 	mov.w	r1, #406	; 0x196
   10aec:	4825      	ldr	r0, [pc, #148]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10aee:	f008 fce7 	bl	194c0 <assert_failed>
   10af2:	e69c      	b.n	1082e <HAL_SAI_InitProtocol+0x27e>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
   10af4:	f240 1195 	movw	r1, #405	; 0x195
   10af8:	4822      	ldr	r0, [pc, #136]	; (10b84 <HAL_SAI_InitProtocol+0x5d4>)
   10afa:	f008 fce1 	bl	194c0 <assert_failed>
   10afe:	e692      	b.n	10826 <HAL_SAI_InitProtocol+0x276>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b00:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_32;
   10b02:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b04:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b06:	01b3      	lsls	r3, r6, #6
      hsai->Init.DataSize = SAI_DATASIZE_32;
   10b08:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b0a:	0176      	lsls	r6, r6, #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b0c:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b0e:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
   10b12:	e5e1      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b14:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10b16:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b18:	2280      	movs	r2, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b1a:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b1c:	ea4f 1386 	mov.w	r3, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_24;
   10b20:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b22:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b26:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b28:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b2c:	f47f add4 	bne.w	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->SlotInit.FirstBitOffset = 8;
   10b30:	2308      	movs	r3, #8
   10b32:	66a3      	str	r3, [r4, #104]	; 0x68
   10b34:	e5d0      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b36:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b38:	2380      	movs	r3, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b3a:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
   10b3c:	ea4f 1286 	mov.w	r2, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b40:	64a3      	str	r3, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b42:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   10b46:	66e3      	str	r3, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
   10b48:	e9c4 2615 	strd	r2, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
   10b4c:	f47f adc4 	bne.w	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->SlotInit.FirstBitOffset = 16;
   10b50:	2310      	movs	r3, #16
   10b52:	66a3      	str	r3, [r4, #104]	; 0x68
   10b54:	e5c0      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
   10b56:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b58:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   10b5a:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
   10b5c:	0173      	lsls	r3, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
   10b5e:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
   10b60:	0136      	lsls	r6, r6, #4
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   10b62:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
   10b64:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
   10b68:	e5b6      	b.n	106d8 <HAL_SAI_InitProtocol+0x128>
  switch (hsai->Init.SynchroExt)
   10b6a:	2113      	movs	r1, #19
   10b6c:	2012      	movs	r0, #18
   10b6e:	2611      	movs	r6, #17
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
   10b70:	2210      	movs	r2, #16
   10b72:	e745      	b.n	10a00 <HAL_SAI_InitProtocol+0x450>
    SaiBaseAddress = SAI2;
   10b74:	4d04      	ldr	r5, [pc, #16]	; (10b88 <HAL_SAI_InitProtocol+0x5d8>)
   10b76:	e714      	b.n	109a2 <HAL_SAI_InitProtocol+0x3f2>
   10b78:	40015800 	.word	0x40015800
   10b7c:	00062b44 	.word	0x00062b44
   10b80:	95cbec1b 	.word	0x95cbec1b
   10b84:	00030254 	.word	0x00030254
   10b88:	40015c00 	.word	0x40015c00
      tmpregisterGCR |= SAI_GCR_SYNCIN_1;
   10b8c:	4602      	mov	r2, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
   10b8e:	f44f 6600 	mov.w	r6, #2048	; 0x800
  SaiBaseAddress->GCR = tmpregisterGCR;
   10b92:	602a      	str	r2, [r5, #0]
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
   10b94:	6a23      	ldr	r3, [r4, #32]
   10b96:	2b00      	cmp	r3, #0
   10b98:	d045      	beq.n	10c26 <HAL_SAI_InitProtocol+0x676>
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
   10b9a:	6823      	ldr	r3, [r4, #0]
   10b9c:	4a9f      	ldr	r2, [pc, #636]	; (10e1c <HAL_SAI_InitProtocol+0x86c>)
   10b9e:	4293      	cmp	r3, r2
   10ba0:	f000 811f 	beq.w	10de2 <HAL_SAI_InitProtocol+0x832>
   10ba4:	489e      	ldr	r0, [pc, #632]	; (10e20 <HAL_SAI_InitProtocol+0x870>)
   10ba6:	1a18      	subs	r0, r3, r0
   10ba8:	fab0 f080 	clz	r0, r0
   10bac:	0940      	lsrs	r0, r0, #5
   10bae:	2800      	cmp	r0, #0
   10bb0:	f040 8117 	bne.w	10de2 <HAL_SAI_InitProtocol+0x832>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
   10bb4:	4a9b      	ldr	r2, [pc, #620]	; (10e24 <HAL_SAI_InitProtocol+0x874>)
   10bb6:	4293      	cmp	r3, r2
   10bb8:	f000 810d 	beq.w	10dd6 <HAL_SAI_InitProtocol+0x826>
   10bbc:	3220      	adds	r2, #32
   10bbe:	4293      	cmp	r3, r2
   10bc0:	f000 8109 	beq.w	10dd6 <HAL_SAI_InitProtocol+0x826>
    if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
   10bc4:	4a98      	ldr	r2, [pc, #608]	; (10e28 <HAL_SAI_InitProtocol+0x878>)
   10bc6:	4293      	cmp	r3, r2
   10bc8:	f000 80ff 	beq.w	10dca <HAL_SAI_InitProtocol+0x81a>
   10bcc:	3220      	adds	r2, #32
   10bce:	4293      	cmp	r3, r2
   10bd0:	f000 80fb 	beq.w	10dca <HAL_SAI_InitProtocol+0x81a>
    if (hsai->Instance == SAI4_Block_A)
   10bd4:	4a95      	ldr	r2, [pc, #596]	; (10e2c <HAL_SAI_InitProtocol+0x87c>)
   10bd6:	4293      	cmp	r3, r2
   10bd8:	f000 8114 	beq.w	10e04 <HAL_SAI_InitProtocol+0x854>
    if (hsai->Instance == SAI4_Block_B)
   10bdc:	4a94      	ldr	r2, [pc, #592]	; (10e30 <HAL_SAI_InitProtocol+0x880>)
   10bde:	4293      	cmp	r3, r2
   10be0:	f000 810b 	beq.w	10dfa <HAL_SAI_InitProtocol+0x84a>
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
   10be4:	69a2      	ldr	r2, [r4, #24]
   10be6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   10bea:	6a23      	ldr	r3, [r4, #32]
   10bec:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
   10bf0:	ea4f 0040 	mov.w	r0, r0, lsl #1
   10bf4:	f000 80df 	beq.w	10db6 <HAL_SAI_InitProtocol+0x806>
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
   10bf8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
   10bfa:	021b      	lsls	r3, r3, #8
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
   10bfc:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
   10c00:	bf14      	ite	ne
   10c02:	2201      	movne	r2, #1
   10c04:	2202      	moveq	r2, #2
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
   10c06:	fb02 f303 	mul.w	r3, r2, r3
   10c0a:	fbb0 f3f3 	udiv	r3, r0, r3
    hsai->Init.Mckdiv = tmpval / 10U;
   10c0e:	4a89      	ldr	r2, [pc, #548]	; (10e34 <HAL_SAI_InitProtocol+0x884>)
   10c10:	fba2 1203 	umull	r1, r2, r2, r3
   10c14:	08d2      	lsrs	r2, r2, #3
    if ((tmpval % 10U) > 8U)
   10c16:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   10c1a:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
   10c1e:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv += 1U;
   10c20:	bf08      	it	eq
   10c22:	3201      	addeq	r2, #1
   10c24:	6262      	str	r2, [r4, #36]	; 0x24
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10c26:	6863      	ldr	r3, [r4, #4]
   10c28:	6d22      	ldr	r2, [r4, #80]	; 0x50
   10c2a:	f033 0702 	bics.w	r7, r3, #2
   10c2e:	f040 80ae 	bne.w	10d8e <HAL_SAI_InitProtocol+0x7de>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
   10c32:	2a01      	cmp	r2, #1
   10c34:	bf18      	it	ne
   10c36:	f44f 7700 	movne.w	r7, #512	; 0x200
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   10c3a:	f7f7 fbf3 	bl	8424 <HAL_GetREVID>
   10c3e:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   10c42:	6822      	ldr	r2, [r4, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
   10c44:	f0c0 8092 	bcc.w	10d6c <HAL_SAI_InitProtocol+0x7bc>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   10c48:	6811      	ldr	r1, [r2, #0]
   10c4a:	4b7b      	ldr	r3, [pc, #492]	; (10e38 <HAL_SAI_InitProtocol+0x888>)
   10c4c:	400b      	ands	r3, r1
   10c4e:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c50:	6863      	ldr	r3, [r4, #4]
   10c52:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
   10c54:	e9d4 1211 	ldrd	r1, r2, [r4, #68]	; 0x44
   10c58:	430b      	orrs	r3, r1
   10c5a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   10c5c:	4313      	orrs	r3, r2
   10c5e:	6962      	ldr	r2, [r4, #20]
   10c60:	4303      	orrs	r3, r0
   10c62:	69a0      	ldr	r0, [r4, #24]
   10c64:	430b      	orrs	r3, r1
   10c66:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   10c68:	4313      	orrs	r3, r2
   10c6a:	6922      	ldr	r2, [r4, #16]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c6c:	4303      	orrs	r3, r0
   10c6e:	6820      	ldr	r0, [r4, #0]
   10c70:	430b      	orrs	r3, r1
   10c72:	6801      	ldr	r1, [r0, #0]
   10c74:	4313      	orrs	r3, r2
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
   10c76:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c78:	430b      	orrs	r3, r1
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
   10c7a:	f24f 0120 	movw	r1, #61472	; 0xf020
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10c7e:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
   10c82:	4333      	orrs	r3, r6
   10c84:	433b      	orrs	r3, r7
   10c86:	6003      	str	r3, [r0, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   10c88:	6826      	ldr	r6, [r4, #0]
   10c8a:	4b6c      	ldr	r3, [pc, #432]	; (10e3c <HAL_SAI_InitProtocol+0x88c>)
   10c8c:	6872      	ldr	r2, [r6, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   10c8e:	486c      	ldr	r0, [pc, #432]	; (10e40 <HAL_SAI_InitProtocol+0x890>)
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   10c90:	4013      	ands	r3, r2
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   10c92:	4a62      	ldr	r2, [pc, #392]	; (10e1c <HAL_SAI_InitProtocol+0x86c>)
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   10c94:	6073      	str	r3, [r6, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
   10c96:	69e3      	ldr	r3, [r4, #28]
   10c98:	e9d4 760c 	ldrd	r7, r6, [r4, #48]	; 0x30
   10c9c:	433b      	orrs	r3, r7
   10c9e:	6827      	ldr	r7, [r4, #0]
   10ca0:	4333      	orrs	r3, r6
   10ca2:	687e      	ldr	r6, [r7, #4]
   10ca4:	4333      	orrs	r3, r6
   10ca6:	607b      	str	r3, [r7, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
   10ca8:	6823      	ldr	r3, [r4, #0]
   10caa:	689e      	ldr	r6, [r3, #8]
   10cac:	4030      	ands	r0, r6
   10cae:	6098      	str	r0, [r3, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   10cb0:	6e63      	ldr	r3, [r4, #100]	; 0x64
   10cb2:	6827      	ldr	r7, [r4, #0]
   10cb4:	e9d4 6017 	ldrd	r6, r0, [r4, #92]	; 0x5c
   10cb8:	4333      	orrs	r3, r6
   10cba:	6d66      	ldr	r6, [r4, #84]	; 0x54
   10cbc:	4303      	orrs	r3, r0
   10cbe:	68b8      	ldr	r0, [r7, #8]
   10cc0:	3e01      	subs	r6, #1
   10cc2:	4303      	orrs	r3, r0
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
   10cc4:	6da0      	ldr	r0, [r4, #88]	; 0x58
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   10cc6:	4333      	orrs	r3, r6
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
   10cc8:	3801      	subs	r0, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
   10cca:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   10cce:	60bb      	str	r3, [r7, #8]
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
   10cd0:	6820      	ldr	r0, [r4, #0]
   10cd2:	68c3      	ldr	r3, [r0, #12]
   10cd4:	400b      	ands	r3, r1
   10cd6:	60c3      	str	r3, [r0, #12]
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10cd8:	6820      	ldr	r0, [r4, #0]
   10cda:	e9d4 361a 	ldrd	r3, r6, [r4, #104]	; 0x68
   10cde:	68c1      	ldr	r1, [r0, #12]
   10ce0:	4333      	orrs	r3, r6
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   10ce2:	6f66      	ldr	r6, [r4, #116]	; 0x74
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10ce4:	430b      	orrs	r3, r1
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   10ce6:	6f21      	ldr	r1, [r4, #112]	; 0x70
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10ce8:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
   10cec:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
   10cee:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   10cf2:	60c3      	str	r3, [r0, #12]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
   10cf4:	6823      	ldr	r3, [r4, #0]
   10cf6:	4293      	cmp	r3, r2
   10cf8:	d025      	beq.n	10d46 <HAL_SAI_InitProtocol+0x796>
   10cfa:	f102 52c0 	add.w	r2, r2, #402653184	; 0x18000000
   10cfe:	f5a2 3282 	sub.w	r2, r2, #66560	; 0x10400
   10d02:	4293      	cmp	r3, r2
   10d04:	d01f      	beq.n	10d46 <HAL_SAI_InitProtocol+0x796>
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10d06:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
   10d08:	2201      	movs	r2, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10d0a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  return HAL_OK;
   10d0e:	4618      	mov	r0, r3
  __HAL_UNLOCK(hsai);
   10d10:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
  hsai->State = HAL_SAI_STATE_READY;
   10d14:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
}
   10d18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      syncen_bits = SAI_xCR1_SYNCEN_0;
   10d1a:	f44f 6680 	mov.w	r6, #1024	; 0x400
   10d1e:	e738      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
      syncen_bits = 0;
   10d20:	2600      	movs	r6, #0
   10d22:	e736      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
   10d24:	4632      	mov	r2, r6
      syncen_bits = SAI_xCR1_SYNCEN_1;
   10d26:	f44f 6600 	mov.w	r6, #2048	; 0x800
   10d2a:	e732      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
    hsai->Lock = HAL_UNLOCKED;
   10d2c:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
    HAL_SAI_MspInit(hsai);
   10d30:	4620      	mov	r0, r4
   10d32:	f009 f92d 	bl	19f90 <HAL_SAI_MspInit>
   10d36:	6823      	ldr	r3, [r4, #0]
   10d38:	e63a      	b.n	109b0 <HAL_SAI_InitProtocol+0x400>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
   10d3a:	f240 118f 	movw	r1, #399	; 0x18f
   10d3e:	4841      	ldr	r0, [pc, #260]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10d40:	f008 fbbe 	bl	194c0 <assert_failed>
   10d44:	e565      	b.n	10812 <HAL_SAI_InitProtocol+0x262>
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
   10d46:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   10d48:	f023 0301 	bic.w	r3, r3, #1
   10d4c:	646b      	str	r3, [r5, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
   10d4e:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   10d52:	2b01      	cmp	r3, #1
   10d54:	d1d7      	bne.n	10d06 <HAL_SAI_InitProtocol+0x756>
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
   10d56:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
   10d5a:	3a01      	subs	r2, #1
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
   10d5c:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
   10d60:	646b      	str	r3, [r5, #68]	; 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
   10d62:	6c6b      	ldr	r3, [r5, #68]	; 0x44
   10d64:	f043 0301 	orr.w	r3, r3, #1
   10d68:	646b      	str	r3, [r5, #68]	; 0x44
   10d6a:	e7cc      	b.n	10d06 <HAL_SAI_InitProtocol+0x756>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
   10d6c:	6811      	ldr	r1, [r2, #0]
   10d6e:	4b36      	ldr	r3, [pc, #216]	; (10e48 <HAL_SAI_InitProtocol+0x898>)
   10d70:	400b      	ands	r3, r1
   10d72:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
   10d74:	6863      	ldr	r3, [r4, #4]
   10d76:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
   10d78:	e9d4 2011 	ldrd	r2, r0, [r4, #68]	; 0x44
   10d7c:	4313      	orrs	r3, r2
   10d7e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   10d80:	4303      	orrs	r3, r0
   10d82:	6960      	ldr	r0, [r4, #20]
   10d84:	430b      	orrs	r3, r1
   10d86:	69a1      	ldr	r1, [r4, #24]
   10d88:	4313      	orrs	r3, r2
   10d8a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   10d8c:	e76e      	b.n	10c6c <HAL_SAI_InitProtocol+0x6bc>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
   10d8e:	2a01      	cmp	r2, #1
   10d90:	bf14      	ite	ne
   10d92:	2700      	movne	r7, #0
   10d94:	f44f 7700 	moveq.w	r7, #512	; 0x200
   10d98:	e74f      	b.n	10c3a <HAL_SAI_InitProtocol+0x68a>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
   10d9a:	f44f 71cc 	mov.w	r1, #408	; 0x198
   10d9e:	4829      	ldr	r0, [pc, #164]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10da0:	f008 fb8e 	bl	194c0 <assert_failed>
   10da4:	e556      	b.n	10854 <HAL_SAI_InitProtocol+0x2a4>
    SaiBaseAddress = SAI3;
   10da6:	4d29      	ldr	r5, [pc, #164]	; (10e4c <HAL_SAI_InitProtocol+0x89c>)
   10da8:	e5fb      	b.n	109a2 <HAL_SAI_InitProtocol+0x3f2>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
   10daa:	f240 1187 	movw	r1, #391	; 0x187
   10dae:	4825      	ldr	r0, [pc, #148]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10db0:	f008 fb86 	bl	194c0 <assert_failed>
   10db4:	e512      	b.n	107dc <HAL_SAI_InitProtocol+0x22c>
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * hsai->FrameInit.FrameLength);
   10db6:	6d62      	ldr	r2, [r4, #84]	; 0x54
   10db8:	fb02 f303 	mul.w	r3, r2, r3
   10dbc:	fbb0 f3f3 	udiv	r3, r0, r3
   10dc0:	e725      	b.n	10c0e <HAL_SAI_InitProtocol+0x65e>
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
   10dc2:	460a      	mov	r2, r1
      syncen_bits = SAI_xCR1_SYNCEN_1;
   10dc4:	f44f 6600 	mov.w	r6, #2048	; 0x800
   10dc8:	e6e3      	b.n	10b92 <HAL_SAI_InitProtocol+0x5e2>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI3);
   10dca:	f44f 7000 	mov.w	r0, #512	; 0x200
   10dce:	f7ff fa59 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10dd2:	6823      	ldr	r3, [r4, #0]
   10dd4:	e6fe      	b.n	10bd4 <HAL_SAI_InitProtocol+0x624>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
   10dd6:	f44f 7000 	mov.w	r0, #512	; 0x200
   10dda:	f7ff fa53 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10dde:	6823      	ldr	r3, [r4, #0]
   10de0:	e6f0      	b.n	10bc4 <HAL_SAI_InitProtocol+0x614>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
   10de2:	f44f 7080 	mov.w	r0, #256	; 0x100
   10de6:	f7ff fa4d 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10dea:	6823      	ldr	r3, [r4, #0]
   10dec:	e6e2      	b.n	10bb4 <HAL_SAI_InitProtocol+0x604>
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
   10dee:	f240 1181 	movw	r1, #385	; 0x181
   10df2:	4814      	ldr	r0, [pc, #80]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10df4:	f008 fb64 	bl	194c0 <assert_failed>
   10df8:	e49c      	b.n	10734 <HAL_SAI_InitProtocol+0x184>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4B);
   10dfa:	f44f 6000 	mov.w	r0, #2048	; 0x800
   10dfe:	f7ff fa41 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10e02:	e6ef      	b.n	10be4 <HAL_SAI_InitProtocol+0x634>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4A);
   10e04:	f44f 6080 	mov.w	r0, #1024	; 0x400
   10e08:	f7ff fa3c 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   10e0c:	6823      	ldr	r3, [r4, #0]
   10e0e:	e6e5      	b.n	10bdc <HAL_SAI_InitProtocol+0x62c>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
   10e10:	f44f 71c2 	mov.w	r1, #388	; 0x184
   10e14:	480b      	ldr	r0, [pc, #44]	; (10e44 <HAL_SAI_InitProtocol+0x894>)
   10e16:	f008 fb53 	bl	194c0 <assert_failed>
   10e1a:	e4c6      	b.n	107aa <HAL_SAI_InitProtocol+0x1fa>
   10e1c:	40015804 	.word	0x40015804
   10e20:	40015824 	.word	0x40015824
   10e24:	40015c04 	.word	0x40015c04
   10e28:	40016004 	.word	0x40016004
   10e2c:	58005404 	.word	0x58005404
   10e30:	58005424 	.word	0x58005424
   10e34:	cccccccd 	.word	0xcccccccd
   10e38:	f005c010 	.word	0xf005c010
   10e3c:	ffff1ff0 	.word	0xffff1ff0
   10e40:	fff88000 	.word	0xfff88000
   10e44:	00030254 	.word	0x00030254
   10e48:	f805c010 	.word	0xf805c010
   10e4c:	40016000 	.word	0x40016000

00010e50 <HAL_SAI_Transmit_DMA>:
{
   10e50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10e54:	460f      	mov	r7, r1
   10e56:	4604      	mov	r4, r0
   10e58:	4690      	mov	r8, r2
  uint32_t tickstart = HAL_GetTick();
   10e5a:	f7f7 facb 	bl	83f4 <HAL_GetTick>
  if ((pData == NULL) || (Size == 0U))
   10e5e:	2f00      	cmp	r7, #0
   10e60:	d064      	beq.n	10f2c <HAL_SAI_Transmit_DMA+0xdc>
   10e62:	fab8 f588 	clz	r5, r8
   10e66:	096d      	lsrs	r5, r5, #5
   10e68:	2d00      	cmp	r5, #0
   10e6a:	d15f      	bne.n	10f2c <HAL_SAI_Transmit_DMA+0xdc>
  if (hsai->State == HAL_SAI_STATE_READY)
   10e6c:	f894 6091 	ldrb.w	r6, [r4, #145]	; 0x91
   10e70:	b2f6      	uxtb	r6, r6
   10e72:	2e01      	cmp	r6, #1
   10e74:	d156      	bne.n	10f24 <HAL_SAI_Transmit_DMA+0xd4>
    __HAL_LOCK(hsai);
   10e76:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
   10e7a:	2b01      	cmp	r3, #1
   10e7c:	d052      	beq.n	10f24 <HAL_SAI_Transmit_DMA+0xd4>
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   10e7e:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_TX;
   10e82:	2112      	movs	r1, #18
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   10e84:	4a37      	ldr	r2, [pc, #220]	; (10f64 <HAL_SAI_Transmit_DMA+0x114>)
   10e86:	4681      	mov	r9, r0
    hsai->pBuffPtr = pData;
   10e88:	67a7      	str	r7, [r4, #120]	; 0x78
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10e8a:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->XferSize = Size;
   10e8e:	f8a4 807c 	strh.w	r8, [r4, #124]	; 0x7c
    hsai->State = HAL_SAI_STATE_BUSY_TX;
   10e92:	f884 1091 	strb.w	r1, [r4, #145]	; 0x91
    __HAL_LOCK(hsai);
   10e96:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->XferCount = Size;
   10e9a:	f8a4 807e 	strh.w	r8, [r4, #126]	; 0x7e
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   10e9e:	4932      	ldr	r1, [pc, #200]	; (10f68 <HAL_SAI_Transmit_DMA+0x118>)
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   10ea0:	641a      	str	r2, [r3, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   10ea2:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   10ea6:	4a31      	ldr	r2, [pc, #196]	; (10f6c <HAL_SAI_Transmit_DMA+0x11c>)
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   10ea8:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   10eaa:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   10eae:	64da      	str	r2, [r3, #76]	; 0x4c
    hsai->hdmatx->XferAbortCallback = NULL;
   10eb0:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
   10eb4:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
   10eb6:	6822      	ldr	r2, [r4, #0]
   10eb8:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   10ebc:	321c      	adds	r2, #28
   10ebe:	6fa1      	ldr	r1, [r4, #120]	; 0x78
   10ec0:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
   10ec4:	f7f9 fe0a 	bl	aadc <HAL_DMA_Start_IT>
   10ec8:	4607      	mov	r7, r0
   10eca:	2800      	cmp	r0, #0
   10ecc:	d132      	bne.n	10f34 <HAL_SAI_Transmit_DMA+0xe4>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   10ece:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10ed0:	6863      	ldr	r3, [r4, #4]
   10ed2:	2a08      	cmp	r2, #8
   10ed4:	d03c      	beq.n	10f50 <HAL_SAI_Transmit_DMA+0x100>
   10ed6:	2005      	movs	r0, #5
   10ed8:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10eda:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10edc:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
   10ede:	2b01      	cmp	r3, #1
   10ee0:	bf88      	it	hi
   10ee2:	4602      	movhi	r2, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10ee4:	690b      	ldr	r3, [r1, #16]
   10ee6:	4313      	orrs	r3, r2
   10ee8:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   10eea:	6822      	ldr	r2, [r4, #0]
   10eec:	6813      	ldr	r3, [r2, #0]
   10eee:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   10ef2:	6013      	str	r3, [r2, #0]
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
   10ef4:	e006      	b.n	10f04 <HAL_SAI_Transmit_DMA+0xb4>
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
   10ef6:	f7f7 fa7d 	bl	83f4 <HAL_GetTick>
   10efa:	eba0 0009 	sub.w	r0, r0, r9
   10efe:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   10f02:	d81b      	bhi.n	10f3c <HAL_SAI_Transmit_DMA+0xec>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
   10f04:	6822      	ldr	r2, [r4, #0]
   10f06:	6955      	ldr	r5, [r2, #20]
   10f08:	f415 25e0 	ands.w	r5, r5, #458752	; 0x70000
   10f0c:	d0f3      	beq.n	10ef6 <HAL_SAI_Transmit_DMA+0xa6>
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
   10f0e:	6813      	ldr	r3, [r2, #0]
   10f10:	03db      	lsls	r3, r3, #15
   10f12:	d403      	bmi.n	10f1c <HAL_SAI_Transmit_DMA+0xcc>
      __HAL_SAI_ENABLE(hsai);
   10f14:	6813      	ldr	r3, [r2, #0]
   10f16:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   10f1a:	6013      	str	r3, [r2, #0]
    __HAL_UNLOCK(hsai);
   10f1c:	2300      	movs	r3, #0
   10f1e:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    return HAL_OK;
   10f22:	e000      	b.n	10f26 <HAL_SAI_Transmit_DMA+0xd6>
    return HAL_BUSY;
   10f24:	2702      	movs	r7, #2
}
   10f26:	4638      	mov	r0, r7
   10f28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return  HAL_ERROR;
   10f2c:	2701      	movs	r7, #1
}
   10f2e:	4638      	mov	r0, r7
   10f30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      __HAL_UNLOCK(hsai);
   10f34:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
   10f38:	4637      	mov	r7, r6
   10f3a:	e7f4      	b.n	10f26 <HAL_SAI_Transmit_DMA+0xd6>
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10f3c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
   10f40:	2703      	movs	r7, #3
        __HAL_UNLOCK(hsai);
   10f42:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   10f46:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10f4a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
   10f4e:	e7ea      	b.n	10f26 <HAL_SAI_Transmit_DMA+0xd6>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   10f50:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   10f54:	2a01      	cmp	r2, #1
   10f56:	bf0b      	itete	eq
   10f58:	2015      	moveq	r0, #21
   10f5a:	2005      	movne	r0, #5
   10f5c:	2271      	moveq	r2, #113	; 0x71
   10f5e:	2261      	movne	r2, #97	; 0x61
   10f60:	e7bb      	b.n	10eda <HAL_SAI_Transmit_DMA+0x8a>
   10f62:	bf00      	nop
   10f64:	000110b5 	.word	0x000110b5
   10f68:	00011051 	.word	0x00011051
   10f6c:	00011131 	.word	0x00011131

00010f70 <HAL_SAI_Receive_DMA>:
  if ((pData == NULL) || (Size == 0U))
   10f70:	2900      	cmp	r1, #0
   10f72:	d057      	beq.n	11024 <HAL_SAI_Receive_DMA+0xb4>
{
   10f74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((pData == NULL) || (Size == 0U))
   10f76:	fab2 f582 	clz	r5, r2
   10f7a:	096d      	lsrs	r5, r5, #5
   10f7c:	2d00      	cmp	r5, #0
   10f7e:	d14f      	bne.n	11020 <HAL_SAI_Receive_DMA+0xb0>
  if (hsai->State == HAL_SAI_STATE_READY)
   10f80:	f890 6091 	ldrb.w	r6, [r0, #145]	; 0x91
   10f84:	b2f6      	uxtb	r6, r6
   10f86:	2e01      	cmp	r6, #1
   10f88:	d148      	bne.n	1101c <HAL_SAI_Receive_DMA+0xac>
    __HAL_LOCK(hsai);
   10f8a:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
   10f8e:	2b01      	cmp	r3, #1
   10f90:	d044      	beq.n	1101c <HAL_SAI_Receive_DMA+0xac>
   10f92:	4604      	mov	r4, r0
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   10f94:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    hsai->State = HAL_SAI_STATE_BUSY_RX;
   10f98:	2722      	movs	r7, #34	; 0x22
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   10f9a:	482a      	ldr	r0, [pc, #168]	; (11044 <HAL_SAI_Receive_DMA+0xd4>)
    hsai->pBuffPtr = pData;
   10f9c:	67a1      	str	r1, [r4, #120]	; 0x78
    hsai->XferSize = Size;
   10f9e:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   10fa2:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->XferCount = Size;
   10fa6:	f8a4 207e 	strh.w	r2, [r4, #126]	; 0x7e
    __HAL_LOCK(hsai);
   10faa:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->State = HAL_SAI_STATE_BUSY_RX;
   10fae:	f884 7091 	strb.w	r7, [r4, #145]	; 0x91
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   10fb2:	4925      	ldr	r1, [pc, #148]	; (11048 <HAL_SAI_Receive_DMA+0xd8>)
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   10fb4:	6418      	str	r0, [r3, #64]	; 0x40
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   10fb6:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   10fba:	4a24      	ldr	r2, [pc, #144]	; (1104c <HAL_SAI_Receive_DMA+0xdc>)
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   10fbc:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   10fbe:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   10fc2:	64da      	str	r2, [r3, #76]	; 0x4c
    hsai->hdmarx->XferAbortCallback = NULL;
   10fc4:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   10fc8:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
   10fca:	6821      	ldr	r1, [r4, #0]
   10fcc:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
   10fd0:	311c      	adds	r1, #28
   10fd2:	6fa2      	ldr	r2, [r4, #120]	; 0x78
   10fd4:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
   10fd8:	f7f9 fd80 	bl	aadc <HAL_DMA_Start_IT>
   10fdc:	bb20      	cbnz	r0, 11028 <HAL_SAI_Receive_DMA+0xb8>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   10fde:	6c62      	ldr	r2, [r4, #68]	; 0x44
   10fe0:	6863      	ldr	r3, [r4, #4]
   10fe2:	2a08      	cmp	r2, #8
   10fe4:	d024      	beq.n	11030 <HAL_SAI_Receive_DMA+0xc0>
   10fe6:	2505      	movs	r5, #5
   10fe8:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10fea:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   10fec:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
   10fee:	2b01      	cmp	r3, #1
   10ff0:	bf88      	it	hi
   10ff2:	462a      	movhi	r2, r5
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   10ff4:	690b      	ldr	r3, [r1, #16]
   10ff6:	4313      	orrs	r3, r2
   10ff8:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   10ffa:	6822      	ldr	r2, [r4, #0]
   10ffc:	6813      	ldr	r3, [r2, #0]
   10ffe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11002:	6013      	str	r3, [r2, #0]
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
   11004:	6823      	ldr	r3, [r4, #0]
   11006:	681a      	ldr	r2, [r3, #0]
   11008:	03d2      	lsls	r2, r2, #15
   1100a:	d403      	bmi.n	11014 <HAL_SAI_Receive_DMA+0xa4>
      __HAL_SAI_ENABLE(hsai);
   1100c:	681a      	ldr	r2, [r3, #0]
   1100e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   11012:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
   11014:	2300      	movs	r3, #0
   11016:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
}
   1101a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
   1101c:	2002      	movs	r0, #2
}
   1101e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
   11020:	2001      	movs	r0, #1
}
   11022:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
   11024:	2001      	movs	r0, #1
}
   11026:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
   11028:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
   1102c:	4630      	mov	r0, r6
}
   1102e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11030:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   11034:	2a01      	cmp	r2, #1
   11036:	bf0b      	itete	eq
   11038:	2515      	moveq	r5, #21
   1103a:	2505      	movne	r5, #5
   1103c:	2271      	moveq	r2, #113	; 0x71
   1103e:	2261      	movne	r2, #97	; 0x61
   11040:	e7d3      	b.n	10fea <HAL_SAI_Receive_DMA+0x7a>
   11042:	bf00      	nop
   11044:	00011125 	.word	0x00011125
   11048:	000110c1 	.word	0x000110c1
   1104c:	00011131 	.word	0x00011131

00011050 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
   11050:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
   11052:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   11054:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
   11056:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1105a:	d01a      	beq.n	11092 <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;
   1105c:	2300      	movs	r3, #0

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   1105e:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
   11060:	f8a0 307e 	strh.w	r3, [r0, #126]	; 0x7e
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   11064:	6813      	ldr	r3, [r2, #0]
   11066:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1106a:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1106c:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1106e:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11070:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   11072:	d011      	beq.n	11098 <SAI_DMATxCplt+0x48>
   11074:	f06f 0261 	mvn.w	r2, #97	; 0x61
   11078:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1107c:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   1107e:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
   11080:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   11082:	42a3      	cmp	r3, r4
   11084:	bf88      	it	hi
   11086:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   11088:	690b      	ldr	r3, [r1, #16]
   1108a:	4013      	ands	r3, r2
   1108c:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
   1108e:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
   11092:	f006 f927 	bl	172e4 <HAL_SAI_TxCpltCallback>
#endif
}
   11096:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11098:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1109c:	2a01      	cmp	r2, #1
   1109e:	bf0b      	itete	eq
   110a0:	f06f 0271 	mvneq.w	r2, #113	; 0x71
   110a4:	f06f 0261 	mvnne.w	r2, #97	; 0x61
   110a8:	f06f 0515 	mvneq.w	r5, #21
   110ac:	f06f 0505 	mvnne.w	r5, #5
   110b0:	e7e4      	b.n	1107c <SAI_DMATxCplt+0x2c>
   110b2:	bf00      	nop

000110b4 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
   110b4:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
   110b6:	6b80      	ldr	r0, [r0, #56]	; 0x38
   110b8:	f006 f916 	bl	172e8 <HAL_SAI_TxHalfCpltCallback>
#endif
}
   110bc:	bd08      	pop	{r3, pc}
   110be:	bf00      	nop

000110c0 <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
   110c0:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
   110c2:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   110c4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
   110c6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   110ca:	d01a      	beq.n	11102 <SAI_DMARxCplt+0x42>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   110cc:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
   110ce:	2100      	movs	r1, #0
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   110d0:	6813      	ldr	r3, [r2, #0]
   110d2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   110d6:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   110d8:	6c43      	ldr	r3, [r0, #68]	; 0x44
    hsai->XferCount = 0;
   110da:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   110de:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   110e0:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   110e2:	d011      	beq.n	11108 <SAI_DMARxCplt+0x48>
   110e4:	f06f 0261 	mvn.w	r2, #97	; 0x61
   110e8:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   110ec:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   110ee:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
   110f0:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   110f2:	42a3      	cmp	r3, r4
   110f4:	bf88      	it	hi
   110f6:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   110f8:	690b      	ldr	r3, [r1, #16]
   110fa:	4013      	ands	r3, r2
   110fc:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
   110fe:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
   11102:	f006 f8f3 	bl	172ec <HAL_SAI_RxCpltCallback>
#endif
}
   11106:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   11108:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
   1110c:	2a01      	cmp	r2, #1
   1110e:	bf0b      	itete	eq
   11110:	f06f 0271 	mvneq.w	r2, #113	; 0x71
   11114:	f06f 0261 	mvnne.w	r2, #97	; 0x61
   11118:	f06f 0515 	mvneq.w	r5, #21
   1111c:	f06f 0505 	mvnne.w	r5, #5
   11120:	e7e4      	b.n	110ec <SAI_DMARxCplt+0x2c>
   11122:	bf00      	nop

00011124 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
   11124:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
   11126:	6b80      	ldr	r0, [r0, #56]	; 0x38
   11128:	f006 f8e4 	bl	172f4 <HAL_SAI_RxHalfCpltCallback>
#endif
}
   1112c:	bd08      	pop	{r3, pc}
   1112e:	bf00      	nop

00011130 <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
   11130:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   11132:	6b84      	ldr	r4, [r0, #56]	; 0x38

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
   11134:	f7fa f8ea 	bl	b30c <HAL_DMA_GetError>
   11138:	2802      	cmp	r0, #2
   1113a:	d02a      	beq.n	11192 <SAI_DMAError+0x62>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   1113c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   11140:	6821      	ldr	r1, [r4, #0]
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   11142:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11146:	4a17      	ldr	r2, [pc, #92]	; (111a4 <SAI_DMAError+0x74>)
   11148:	4d17      	ldr	r5, [pc, #92]	; (111a8 <SAI_DMAError+0x78>)
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
   1114a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   1114e:	680b      	ldr	r3, [r1, #0]
   11150:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   11154:	600b      	str	r3, [r1, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11156:	6812      	ldr	r2, [r2, #0]
  __HAL_SAI_DISABLE(hsai);
   11158:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   1115a:	fba5 3202 	umull	r3, r2, r5, r2
  __HAL_SAI_DISABLE(hsai);
   1115e:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
   11160:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
   11162:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    if (count == 0U)
   11166:	0093      	lsls	r3, r2, #2
  __HAL_SAI_DISABLE(hsai);
   11168:	6001      	str	r1, [r0, #0]
    if (count == 0U)
   1116a:	b19a      	cbz	r2, 11194 <SAI_DMAError+0x64>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   1116c:	6821      	ldr	r1, [r4, #0]
    count--;
   1116e:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11170:	680a      	ldr	r2, [r1, #0]
   11172:	03d0      	lsls	r0, r2, #15
   11174:	d504      	bpl.n	11180 <SAI_DMAError+0x50>
    if (count == 0U)
   11176:	b16b      	cbz	r3, 11194 <SAI_DMAError+0x64>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   11178:	680a      	ldr	r2, [r1, #0]
    count--;
   1117a:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
   1117c:	03d2      	lsls	r2, r2, #15
   1117e:	d4fa      	bmi.n	11176 <SAI_DMAError+0x46>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
   11180:	2201      	movs	r2, #1

    /* Initialize XferCount */
    hsai->XferCount = 0U;
   11182:	2300      	movs	r3, #0

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
   11184:	4620      	mov	r0, r4
    hsai->State = HAL_SAI_STATE_READY;
   11186:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
    hsai->XferCount = 0U;
   1118a:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    HAL_SAI_ErrorCallback(hsai);
   1118e:	f006 f8a5 	bl	172dc <HAL_SAI_ErrorCallback>
#endif
  }
}
   11192:	bd38      	pop	{r3, r4, r5, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   11194:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   11198:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1119c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
   111a0:	e7ee      	b.n	11180 <SAI_DMAError+0x50>
   111a2:	bf00      	nop
   111a4:	00062b44 	.word	0x00062b44
   111a8:	95cbec1b 	.word	0x95cbec1b

000111ac <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
   111ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   111b0:	4605      	mov	r5, r0
   111b2:	b087      	sub	sp, #28
   111b4:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
   111b6:	f7f7 f91d 	bl	83f4 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
   111ba:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
   111bc:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
   111be:	6828      	ldr	r0, [r5, #0]
   111c0:	f002 fd82 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   111c4:	4604      	mov	r4, r0
   111c6:	b118      	cbz	r0, 111d0 <SD_FindSCR+0x24>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
   111c8:	4620      	mov	r0, r4
   111ca:	b007      	add	sp, #28
   111cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
   111d0:	6ca9      	ldr	r1, [r5, #72]	; 0x48
   111d2:	6828      	ldr	r0, [r5, #0]
   111d4:	0409      	lsls	r1, r1, #16
   111d6:	f002 ffe1 	bl	1419c <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
   111da:	4604      	mov	r4, r0
   111dc:	2800      	cmp	r0, #0
   111de:	d1f3      	bne.n	111c8 <SD_FindSCR+0x1c>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   111e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 8U;
   111e4:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
   111e6:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   111e8:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   111ea:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   111ec:	2202      	movs	r2, #2
  config.DataLength    = 8U;
   111ee:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   111f0:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
   111f2:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   111f4:	4669      	mov	r1, sp
   111f6:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   111f8:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   111fa:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   111fc:	f002 fd06 	bl	13c0c <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
   11200:	6828      	ldr	r0, [r5, #0]
   11202:	f003 f887 	bl	14314 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   11206:	4604      	mov	r4, r0
   11208:	2800      	cmp	r0, #0
   1120a:	d1dd      	bne.n	111c8 <SD_FindSCR+0x1c>
  uint32_t index = 0U;
   1120c:	4681      	mov	r9, r0
  uint32_t tempscr[2U] = {0UL, 0UL};
   1120e:	4683      	mov	fp, r0
   11210:	4682      	mov	sl, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   11212:	f240 582a 	movw	r8, #1322	; 0x52a
   11216:	e004      	b.n	11222 <SD_FindSCR+0x76>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11218:	f7f7 f8ec 	bl	83f4 <HAL_GetTick>
   1121c:	1b80      	subs	r0, r0, r6
   1121e:	3001      	adds	r0, #1
   11220:	d025      	beq.n	1126e <SD_FindSCR+0xc2>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   11222:	6828      	ldr	r0, [r5, #0]
   11224:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11226:	ea13 0f08 	tst.w	r3, r8
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
   1122a:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
   1122c:	d10e      	bne.n	1124c <SD_FindSCR+0xa0>
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
   1122e:	031b      	lsls	r3, r3, #12
   11230:	d4f2      	bmi.n	11218 <SD_FindSCR+0x6c>
   11232:	f1b9 0f00 	cmp.w	r9, #0
   11236:	d1ef      	bne.n	11218 <SD_FindSCR+0x6c>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
   11238:	f002 fcc2 	bl	13bc0 <SDMMC_ReadFIFO>
   1123c:	4682      	mov	sl, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
   1123e:	6828      	ldr	r0, [r5, #0]
      index++;
   11240:	f04f 0901 	mov.w	r9, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
   11244:	f002 fcbc 	bl	13bc0 <SDMMC_ReadFIFO>
   11248:	4683      	mov	fp, r0
   1124a:	e7e5      	b.n	11218 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   1124c:	0719      	lsls	r1, r3, #28
   1124e:	d411      	bmi.n	11274 <SD_FindSCR+0xc8>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   11250:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11252:	079a      	lsls	r2, r3, #30
   11254:	d411      	bmi.n	1127a <SD_FindSCR+0xce>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   11256:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11258:	069b      	lsls	r3, r3, #26
   1125a:	d411      	bmi.n	11280 <SD_FindSCR+0xd4>
   1125c:	fa9b f28b 	rev.w	r2, fp
   11260:	fa9a f38a 	rev.w	r3, sl
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11264:	4908      	ldr	r1, [pc, #32]	; (11288 <SD_FindSCR+0xdc>)
   11266:	6381      	str	r1, [r0, #56]	; 0x38
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
   11268:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
   1126c:	e7ac      	b.n	111c8 <SD_FindSCR+0x1c>
      return HAL_SD_ERROR_TIMEOUT;
   1126e:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   11272:	e7a9      	b.n	111c8 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
   11274:	2408      	movs	r4, #8
   11276:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
   11278:	e7a6      	b.n	111c8 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
   1127a:	2402      	movs	r4, #2
   1127c:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
   1127e:	e7a3      	b.n	111c8 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
   11280:	2420      	movs	r4, #32
   11282:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
   11284:	e7a0      	b.n	111c8 <SD_FindSCR+0x1c>
   11286:	bf00      	nop
   11288:	18000f3a 	.word	0x18000f3a

0001128c <HAL_SD_ReadBlocks>:
{
   1128c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11290:	460d      	mov	r5, r1
   11292:	b086      	sub	sp, #24
   11294:	4604      	mov	r4, r0
   11296:	4690      	mov	r8, r2
   11298:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
   1129a:	f7f7 f8ab 	bl	83f4 <HAL_GetTick>
  if(NULL == pData)
   1129e:	2d00      	cmp	r5, #0
   112a0:	d070      	beq.n	11384 <HAL_SD_ReadBlocks+0xf8>
   112a2:	4607      	mov	r7, r0
  if(hsd->State == HAL_SD_STATE_READY)
   112a4:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
   112a8:	b2c0      	uxtb	r0, r0
   112aa:	2801      	cmp	r0, #1
   112ac:	d007      	beq.n	112be <HAL_SD_ReadBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   112ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   112b0:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   112b2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   112b6:	63a3      	str	r3, [r4, #56]	; 0x38
}
   112b8:	b006      	add	sp, #24
   112ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   112be:	eb08 0306 	add.w	r3, r8, r6
   112c2:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   112c4:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   112c6:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   112c8:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   112ca:	d863      	bhi.n	11394 <HAL_SD_ReadBlocks+0x108>
    hsd->Instance->DCTRL = 0U;
   112cc:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
   112ce:	2203      	movs	r2, #3
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   112d0:	f04f 0902 	mov.w	r9, #2
    hsd->State = HAL_SD_STATE_BUSY;
   112d4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   112d8:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
   112da:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   112dc:	0271      	lsls	r1, r6, #9
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   112de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   112e0:	9101      	str	r1, [sp, #4]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   112e2:	4669      	mov	r1, sp
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   112e4:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   112e6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   112ea:	6820      	ldr	r0, [r4, #0]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   112ec:	9300      	str	r3, [sp, #0]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   112ee:	f04f 0300 	mov.w	r3, #0
      add *= 512U;
   112f2:	bf18      	it	ne
   112f4:	ea4f 2848 	movne.w	r8, r8, lsl #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   112f8:	9202      	str	r2, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
   112fa:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   112fc:	e9cd 9303 	strd	r9, r3, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   11300:	f002 fc84 	bl	13c0c <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11304:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
   11306:	2e01      	cmp	r6, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11308:	68d3      	ldr	r3, [r2, #12]
   1130a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1130e:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
   11310:	d953      	bls.n	113ba <HAL_SD_ReadBlocks+0x12e>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
   11312:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
   11316:	4641      	mov	r1, r8
   11318:	6820      	ldr	r0, [r4, #0]
   1131a:	f002 fd5d 	bl	13dd8 <SDMMC_CmdReadMultiBlock>
   1131e:	4603      	mov	r3, r0
   11320:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
   11322:	2b00      	cmp	r3, #0
   11324:	d13d      	bne.n	113a2 <HAL_SD_ReadBlocks+0x116>
    dataremaining = config.DataLength;
   11326:	f8dd 9004 	ldr.w	r9, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1132a:	e006      	b.n	1133a <HAL_SD_ReadBlocks+0xae>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
   1132c:	f7f7 f862 	bl	83f4 <HAL_GetTick>
   11330:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   11332:	1bc0      	subs	r0, r0, r7
   11334:	4298      	cmp	r0, r3
   11336:	d274      	bcs.n	11422 <HAL_SD_ReadBlocks+0x196>
   11338:	6820      	ldr	r0, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   1133a:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1133c:	f413 7f95 	tst.w	r3, #298	; 0x12a
   11340:	d143      	bne.n	113ca <HAL_SD_ReadBlocks+0x13e>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= 32U))
   11342:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11344:	0419      	lsls	r1, r3, #16
   11346:	d5f1      	bpl.n	1132c <HAL_SD_ReadBlocks+0xa0>
   11348:	f1b9 0f1f 	cmp.w	r9, #31
   1134c:	d9ee      	bls.n	1132c <HAL_SD_ReadBlocks+0xa0>
   1134e:	f105 0a04 	add.w	sl, r5, #4
   11352:	f105 0824 	add.w	r8, r5, #36	; 0x24
   11356:	e000      	b.n	1135a <HAL_SD_ReadBlocks+0xce>
   11358:	6820      	ldr	r0, [r4, #0]
          data = SDMMC_ReadFIFO(hsd->Instance);
   1135a:	f002 fc31 	bl	13bc0 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
   1135e:	f80a 0c04 	strb.w	r0, [sl, #-4]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
   11362:	0a02      	lsrs	r2, r0, #8
   11364:	f10a 0a04 	add.w	sl, sl, #4
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
   11368:	0c03      	lsrs	r3, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
   1136a:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
   1136c:	f80a 2c07 	strb.w	r2, [sl, #-7]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
   11370:	f80a 3c06 	strb.w	r3, [sl, #-6]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
   11374:	f80a 0c05 	strb.w	r0, [sl, #-5]
        for(count = 0U; count < 8U; count++)
   11378:	45c2      	cmp	sl, r8
   1137a:	d1ed      	bne.n	11358 <HAL_SD_ReadBlocks+0xcc>
   1137c:	3520      	adds	r5, #32
        dataremaining -= 32U;
   1137e:	f1a9 0920 	sub.w	r9, r9, #32
   11382:	e7d3      	b.n	1132c <HAL_SD_ReadBlocks+0xa0>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11384:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   11386:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11388:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   1138c:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1138e:	b006      	add	sp, #24
   11390:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
   11394:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11396:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   1139a:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1139c:	b006      	add	sp, #24
   1139e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   113a2:	4a39      	ldr	r2, [pc, #228]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   113a4:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
   113a6:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   113a8:	6382      	str	r2, [r0, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
   113aa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          return HAL_ERROR;
   113ac:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
   113ae:	4313      	orrs	r3, r2
   113b0:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
   113b2:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
   113b6:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
   113b8:	e77e      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
   113ba:	2301      	movs	r3, #1
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
   113bc:	4641      	mov	r1, r8
   113be:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
   113c0:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
   113c2:	f002 fcc5 	bl	13d50 <SDMMC_CmdReadSingleBlock>
   113c6:	4603      	mov	r3, r0
   113c8:	e7aa      	b.n	11320 <HAL_SD_ReadBlocks+0x94>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
   113ca:	68c3      	ldr	r3, [r0, #12]
   113cc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   113d0:	60c3      	str	r3, [r0, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
   113d2:	6823      	ldr	r3, [r4, #0]
   113d4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   113d6:	05d2      	lsls	r2, r2, #23
   113d8:	d50b      	bpl.n	113f2 <HAL_SD_ReadBlocks+0x166>
   113da:	2e01      	cmp	r6, #1
   113dc:	d909      	bls.n	113f2 <HAL_SD_ReadBlocks+0x166>
      if(hsd->SdCard.CardType != CARD_SECURED)
   113de:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   113e0:	2a03      	cmp	r2, #3
   113e2:	d006      	beq.n	113f2 <HAL_SD_ReadBlocks+0x166>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
   113e4:	4618      	mov	r0, r3
   113e6:	f002 fdc3 	bl	13f70 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
   113ea:	4603      	mov	r3, r0
   113ec:	2800      	cmp	r0, #0
   113ee:	d145      	bne.n	1147c <HAL_SD_ReadBlocks+0x1f0>
   113f0:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   113f2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   113f4:	f012 0208 	ands.w	r2, r2, #8
   113f8:	d121      	bne.n	1143e <HAL_SD_ReadBlocks+0x1b2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   113fa:	6b59      	ldr	r1, [r3, #52]	; 0x34
   113fc:	f011 0102 	ands.w	r1, r1, #2
   11400:	d12a      	bne.n	11458 <HAL_SD_ReadBlocks+0x1cc>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   11402:	6b58      	ldr	r0, [r3, #52]	; 0x34
   11404:	f010 0020 	ands.w	r0, r0, #32
   11408:	d032      	beq.n	11470 <HAL_SD_ReadBlocks+0x1e4>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1140a:	481f      	ldr	r0, [pc, #124]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   1140c:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1140e:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11410:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
   11412:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11414:	f043 0320 	orr.w	r3, r3, #32
   11418:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1141a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   1141e:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   11420:	e74a      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11422:	6823      	ldr	r3, [r4, #0]
        hsd->State= HAL_SD_STATE_READY;
   11424:	2101      	movs	r1, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11426:	4d18      	ldr	r5, [pc, #96]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
        hsd->Context = SD_CONTEXT_NONE;
   11428:	2200      	movs	r2, #0
        return HAL_TIMEOUT;
   1142a:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1142c:	639d      	str	r5, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
   1142e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11430:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   11434:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
   11436:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
   1143a:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
   1143c:	e73c      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1143e:	4812      	ldr	r0, [pc, #72]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   11440:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
   11442:	2100      	movs	r1, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11444:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11446:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
   11448:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1144a:	f043 0308 	orr.w	r3, r3, #8
   1144e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   11450:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   11454:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   11456:	e72f      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11458:	480b      	ldr	r0, [pc, #44]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
      hsd->State = HAL_SD_STATE_READY;
   1145a:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1145c:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   1145e:	4608      	mov	r0, r1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
   11460:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11462:	f043 0302 	orr.w	r3, r3, #2
   11466:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   11468:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   1146c:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
   1146e:	e723      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11470:	4906      	ldr	r1, [pc, #24]	; (1148c <HAL_SD_ReadBlocks+0x200>)
    hsd->State = HAL_SD_STATE_READY;
   11472:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11474:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11476:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
   1147a:	e71d      	b.n	112b8 <HAL_SD_ReadBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1147c:	6822      	ldr	r2, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
   1147e:	2101      	movs	r1, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11480:	4801      	ldr	r0, [pc, #4]	; (11488 <HAL_SD_ReadBlocks+0x1fc>)
          hsd->Context = SD_CONTEXT_NONE;
   11482:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11484:	6390      	str	r0, [r2, #56]	; 0x38
   11486:	e790      	b.n	113aa <HAL_SD_ReadBlocks+0x11e>
   11488:	1fe00fff 	.word	0x1fe00fff
   1148c:	18000f3a 	.word	0x18000f3a

00011490 <HAL_SD_WriteBlocks>:
{
   11490:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11494:	460d      	mov	r5, r1
   11496:	b089      	sub	sp, #36	; 0x24
   11498:	4604      	mov	r4, r0
   1149a:	4616      	mov	r6, r2
   1149c:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
   1149e:	f7f6 ffa9 	bl	83f4 <HAL_GetTick>
  if(NULL == pData)
   114a2:	2d00      	cmp	r5, #0
   114a4:	d05d      	beq.n	11562 <HAL_SD_WriteBlocks+0xd2>
   114a6:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
   114a8:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
   114ac:	b2c0      	uxtb	r0, r0
   114ae:	2801      	cmp	r0, #1
   114b0:	d007      	beq.n	114c2 <HAL_SD_WriteBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   114b2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   114b4:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
   114b6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   114ba:	63a3      	str	r3, [r4, #56]	; 0x38
}
   114bc:	b009      	add	sp, #36	; 0x24
   114be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   114c2:	19f3      	adds	r3, r6, r7
   114c4:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   114c6:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   114c8:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
   114ca:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
   114cc:	d851      	bhi.n	11572 <HAL_SD_WriteBlocks+0xe2>
    hsd->Instance->DCTRL = 0U;
   114ce:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
   114d0:	2203      	movs	r2, #3
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
   114d2:	0278      	lsls	r0, r7, #9
    hsd->State = HAL_SD_STATE_BUSY;
   114d4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   114d8:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
   114da:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   114dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   114e0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
   114e2:	9102      	str	r1, [sp, #8]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   114e4:	a902      	add	r1, sp, #8
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
   114e6:	2b01      	cmp	r3, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
   114e8:	f04f 0300 	mov.w	r3, #0
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
   114ec:	e9cd 0203 	strd	r0, r2, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   114f0:	6820      	ldr	r0, [r4, #0]
      add *= 512U;
   114f2:	bf18      	it	ne
   114f4:	0276      	lslne	r6, r6, #9
    config.DPSM          = SDMMC_DPSM_DISABLE;
   114f6:	9307      	str	r3, [sp, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   114f8:	e9cd 3305 	strd	r3, r3, [sp, #20]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
   114fc:	f002 fb86 	bl	13c0c <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11500:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
   11502:	2f01      	cmp	r7, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
   11504:	68d3      	ldr	r3, [r2, #12]
   11506:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1150a:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
   1150c:	d944      	bls.n	11598 <HAL_SD_WriteBlocks+0x108>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
   1150e:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
   11510:	4631      	mov	r1, r6
   11512:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
   11514:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
   11516:	f002 fce7 	bl	13ee8 <SDMMC_CmdWriteMultiBlock>
   1151a:	4603      	mov	r3, r0
   1151c:	6820      	ldr	r0, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
   1151e:	bb7b      	cbnz	r3, 11580 <HAL_SD_WriteBlocks+0xf0>
    dataremaining = config.DataLength;
   11520:	9e03      	ldr	r6, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11522:	e007      	b.n	11534 <HAL_SD_WriteBlocks+0xa4>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
   11524:	f7f6 ff66 	bl	83f4 <HAL_GetTick>
   11528:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1152a:	eba0 0008 	sub.w	r0, r0, r8
   1152e:	4298      	cmp	r0, r3
   11530:	d266      	bcs.n	11600 <HAL_SD_WriteBlocks+0x170>
   11532:	6820      	ldr	r0, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11534:	6b43      	ldr	r3, [r0, #52]	; 0x34
   11536:	f413 7f8d 	tst.w	r3, #282	; 0x11a
   1153a:	d135      	bne.n	115a8 <HAL_SD_WriteBlocks+0x118>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= 32U))
   1153c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1153e:	0459      	lsls	r1, r3, #17
   11540:	d5f0      	bpl.n	11524 <HAL_SD_WriteBlocks+0x94>
   11542:	2e1f      	cmp	r6, #31
   11544:	d9ee      	bls.n	11524 <HAL_SD_WriteBlocks+0x94>
   11546:	f105 0920 	add.w	r9, r5, #32
   1154a:	e000      	b.n	1154e <HAL_SD_WriteBlocks+0xbe>
   1154c:	6820      	ldr	r0, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
   1154e:	f855 3b04 	ldr.w	r3, [r5], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
   11552:	a901      	add	r1, sp, #4
          data |= ((uint32_t)(*tempbuff) << 24U);
   11554:	9301      	str	r3, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
   11556:	f002 fb37 	bl	13bc8 <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
   1155a:	454d      	cmp	r5, r9
   1155c:	d1f6      	bne.n	1154c <HAL_SD_WriteBlocks+0xbc>
        dataremaining -= 32U;
   1155e:	3e20      	subs	r6, #32
   11560:	e7e0      	b.n	11524 <HAL_SD_WriteBlocks+0x94>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11562:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
   11564:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11566:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   1156a:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1156c:	b009      	add	sp, #36	; 0x24
   1156e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
   11572:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11574:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   11578:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1157a:	b009      	add	sp, #36	; 0x24
   1157c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11580:	4a38      	ldr	r2, [pc, #224]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   11582:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
   11584:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11586:	6382      	str	r2, [r0, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
   11588:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          return HAL_ERROR;
   1158a:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
   1158c:	4313      	orrs	r3, r2
   1158e:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
   11590:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
   11594:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
   11596:	e791      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
   11598:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
   1159a:	4631      	mov	r1, r6
   1159c:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
   1159e:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
   115a0:	f002 fc5e 	bl	13e60 <SDMMC_CmdWriteSingleBlock>
   115a4:	4603      	mov	r3, r0
   115a6:	e7b9      	b.n	1151c <HAL_SD_WriteBlocks+0x8c>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
   115a8:	68c3      	ldr	r3, [r0, #12]
   115aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   115ae:	60c3      	str	r3, [r0, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
   115b0:	6823      	ldr	r3, [r4, #0]
   115b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   115b4:	05d2      	lsls	r2, r2, #23
   115b6:	d50b      	bpl.n	115d0 <HAL_SD_WriteBlocks+0x140>
   115b8:	2f01      	cmp	r7, #1
   115ba:	d909      	bls.n	115d0 <HAL_SD_WriteBlocks+0x140>
      if(hsd->SdCard.CardType != CARD_SECURED)
   115bc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   115be:	2a03      	cmp	r2, #3
   115c0:	d006      	beq.n	115d0 <HAL_SD_WriteBlocks+0x140>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
   115c2:	4618      	mov	r0, r3
   115c4:	f002 fcd4 	bl	13f70 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
   115c8:	4603      	mov	r3, r0
   115ca:	2800      	cmp	r0, #0
   115cc:	d143      	bne.n	11656 <HAL_SD_WriteBlocks+0x1c6>
   115ce:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   115d0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   115d2:	f012 0208 	ands.w	r2, r2, #8
   115d6:	d11f      	bne.n	11618 <HAL_SD_WriteBlocks+0x188>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   115d8:	6b59      	ldr	r1, [r3, #52]	; 0x34
   115da:	f011 0102 	ands.w	r1, r1, #2
   115de:	d128      	bne.n	11632 <HAL_SD_WriteBlocks+0x1a2>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
   115e0:	6b58      	ldr	r0, [r3, #52]	; 0x34
   115e2:	f010 0010 	ands.w	r0, r0, #16
   115e6:	d030      	beq.n	1164a <HAL_SD_WriteBlocks+0x1ba>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   115e8:	481e      	ldr	r0, [pc, #120]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   115ea:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   115ec:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   115ee:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
   115f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   115f2:	f043 0310 	orr.w	r3, r3, #16
   115f6:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   115f8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   115fc:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   115fe:	e75d      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11600:	6821      	ldr	r1, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
   11602:	2201      	movs	r2, #1
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11604:	4d17      	ldr	r5, [pc, #92]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
        hsd->Context = SD_CONTEXT_NONE;
   11606:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
   11608:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1160a:	638d      	str	r5, [r1, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
   1160c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   1160e:	63a1      	str	r1, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
   11610:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
   11614:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
   11616:	e751      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11618:	4812      	ldr	r0, [pc, #72]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   1161a:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
   1161c:	2100      	movs	r1, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1161e:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11620:	4610      	mov	r0, r2
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
   11622:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11624:	f043 0308 	orr.w	r3, r3, #8
   11628:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   1162a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   1162e:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
   11630:	e744      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11632:	480c      	ldr	r0, [pc, #48]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
      hsd->State = HAL_SD_STATE_READY;
   11634:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11636:	6398      	str	r0, [r3, #56]	; 0x38
      return HAL_ERROR;
   11638:	4608      	mov	r0, r1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
   1163a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1163c:	f043 0302 	orr.w	r3, r3, #2
   11640:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
   11642:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
   11646:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
   11648:	e738      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   1164a:	4907      	ldr	r1, [pc, #28]	; (11668 <HAL_SD_WriteBlocks+0x1d8>)
    hsd->State = HAL_SD_STATE_READY;
   1164c:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   1164e:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11650:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
   11654:	e732      	b.n	114bc <HAL_SD_WriteBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11656:	6822      	ldr	r2, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
   11658:	2101      	movs	r1, #1
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1165a:	4802      	ldr	r0, [pc, #8]	; (11664 <HAL_SD_WriteBlocks+0x1d4>)
          hsd->Context = SD_CONTEXT_NONE;
   1165c:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1165e:	6390      	str	r0, [r2, #56]	; 0x38
   11660:	e792      	b.n	11588 <HAL_SD_WriteBlocks+0xf8>
   11662:	bf00      	nop
   11664:	1fe00fff 	.word	0x1fe00fff
   11668:	18000f3a 	.word	0x18000f3a

0001166c <HAL_SD_DriveTransceiver_1_8V_Callback>:
}
   1166c:	4770      	bx	lr
   1166e:	bf00      	nop

00011670 <HAL_SD_GetCardCSD>:
{
   11670:	4603      	mov	r3, r0
  pCSD->Reserved2 = 0U; /*!< Reserved */
   11672:	2000      	movs	r0, #0
{
   11674:	b430      	push	{r4, r5}
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
   11676:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   11678:	0f92      	lsrs	r2, r2, #30
   1167a:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
   1167c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   1167e:	f3c2 6283 	ubfx	r2, r2, #26, #4
   11682:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
   11684:	f893 2063 	ldrb.w	r2, [r3, #99]	; 0x63
   11688:	f002 0203 	and.w	r2, r2, #3
   1168c:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
   1168e:	f893 2062 	ldrb.w	r2, [r3, #98]	; 0x62
   11692:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
   11694:	f893 2061 	ldrb.w	r2, [r3, #97]	; 0x61
   11698:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
   1169a:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   1169e:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
   116a0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116a2:	0d12      	lsrs	r2, r2, #20
   116a4:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
   116a6:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
   116aa:	f002 020f 	and.w	r2, r2, #15
   116ae:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
   116b0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116b2:	f3c2 32c0 	ubfx	r2, r2, #15, #1
   116b6:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
   116b8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116ba:	f3c2 3280 	ubfx	r2, r2, #14, #1
   116be:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
   116c0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116c2:	f3c2 3240 	ubfx	r2, r2, #13, #1
   116c6:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
   116c8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
   116ca:	f3c2 3200 	ubfx	r2, r2, #12, #1
   116ce:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
   116d0:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
   116d2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   116d4:	2a00      	cmp	r2, #0
   116d6:	f040 8086 	bne.w	117e6 <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   116da:	6e5d      	ldr	r5, [r3, #100]	; 0x64
   116dc:	f640 72fc 	movw	r2, #4092	; 0xffc
   116e0:	6e98      	ldr	r0, [r3, #104]	; 0x68
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   116e2:	2401      	movs	r4, #1
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   116e4:	ea02 0285 	and.w	r2, r2, r5, lsl #2
    hsd->SdCard.LogBlockSize = 512U;
   116e8:	f44f 7500 	mov.w	r5, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
   116ec:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
   116f0:	610a      	str	r2, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
   116f2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   116f4:	f3c2 62c2 	ubfx	r2, r2, #27, #3
   116f8:	750a      	strb	r2, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
   116fa:	f893 206b 	ldrb.w	r2, [r3, #107]	; 0x6b
   116fe:	f002 0207 	and.w	r2, r2, #7
   11702:	754a      	strb	r2, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
   11704:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   11706:	f3c2 5242 	ubfx	r2, r2, #21, #3
   1170a:	758a      	strb	r2, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
   1170c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   1170e:	f3c2 4282 	ubfx	r2, r2, #18, #3
   11712:	75ca      	strb	r2, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
   11714:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   11716:	f3c2 32c2 	ubfx	r2, r2, #15, #3
   1171a:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
   1171c:	690a      	ldr	r2, [r1, #16]
   1171e:	4422      	add	r2, r4
   11720:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
   11722:	7e08      	ldrb	r0, [r1, #24]
   11724:	f000 0007 	and.w	r0, r0, #7
   11728:	3002      	adds	r0, #2
   1172a:	4082      	lsls	r2, r0
   1172c:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   1172e:	7a08      	ldrb	r0, [r1, #8]
    hsd->SdCard.LogBlockSize = 512U;
   11730:	659d      	str	r5, [r3, #88]	; 0x58
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   11732:	f000 000f 	and.w	r0, r0, #15
   11736:	fa04 f000 	lsl.w	r0, r4, r0
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
   1173a:	0a44      	lsrs	r4, r0, #9
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
   1173c:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
   1173e:	fb02 f204 	mul.w	r2, r2, r4
   11742:	655a      	str	r2, [r3, #84]	; 0x54
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   11744:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  pCSD->Reserved3 = 0;
   11746:	2500      	movs	r5, #0
  pCSD->Reserved4 = 1;
   11748:	2401      	movs	r4, #1
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   1174a:	f3c2 3280 	ubfx	r2, r2, #14, #1
  return HAL_OK;
   1174e:	4628      	mov	r0, r5
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
   11750:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
   11752:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   11754:	f3c2 12c6 	ubfx	r2, r2, #7, #7
   11758:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
   1175a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   1175c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   11760:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
   11762:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   11764:	0fd2      	lsrs	r2, r2, #31
   11766:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
   11768:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   1176a:	f3c2 7241 	ubfx	r2, r2, #29, #2
   1176e:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
   11770:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   11772:	f3c2 6282 	ubfx	r2, r2, #26, #3
   11776:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
   11778:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   1177a:	f3c2 5283 	ubfx	r2, r2, #22, #4
   1177e:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
   11780:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   11782:	f3c2 5240 	ubfx	r2, r2, #21, #1
   11786:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->Reserved3 = 0;
   1178a:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
   1178e:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
   11792:	4022      	ands	r2, r4
   11794:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
   11798:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   1179a:	f3c2 32c0 	ubfx	r2, r2, #15, #1
   1179e:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
   117a2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117a4:	f3c2 3280 	ubfx	r2, r2, #14, #1
   117a8:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
   117ac:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117ae:	f3c2 3240 	ubfx	r2, r2, #13, #1
   117b2:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
   117b6:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117b8:	f3c2 3200 	ubfx	r2, r2, #12, #1
   117bc:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
   117c0:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117c2:	f3c2 2281 	ubfx	r2, r2, #10, #2
   117c6:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
   117ca:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   117cc:	f3c2 2201 	ubfx	r2, r2, #8, #2
   117d0:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
   117d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   117d6:	f3c3 0346 	ubfx	r3, r3, #1, #7
   117da:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
   117de:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
}
   117e2:	bc30      	pop	{r4, r5}
   117e4:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
   117e6:	2a01      	cmp	r2, #1
   117e8:	d00c      	beq.n	11804 <HAL_SD_GetCardCSD+0x194>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   117ea:	681a      	ldr	r2, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
   117ec:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   117ee:	4c0e      	ldr	r4, [pc, #56]	; (11828 <HAL_SD_GetCardCSD+0x1b8>)
    return HAL_ERROR;
   117f0:	4608      	mov	r0, r1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   117f2:	6394      	str	r4, [r2, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   117f4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   117f6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   117fa:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   117fc:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
}
   11800:	bc30      	pop	{r4, r5}
   11802:	4770      	bx	lr
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
   11804:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    hsd->SdCard.BlockSize = 512U;
   11806:	f44f 7000 	mov.w	r0, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
   1180a:	f8b3 406a 	ldrh.w	r4, [r3, #106]	; 0x6a
   1180e:	0412      	lsls	r2, r2, #16
   11810:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
   11814:	4322      	orrs	r2, r4
   11816:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   11818:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
   1181a:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   1181c:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
   1181e:	6598      	str	r0, [r3, #88]	; 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
   11820:	0292      	lsls	r2, r2, #10
   11822:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
   11824:	655a      	str	r2, [r3, #84]	; 0x54
   11826:	e78d      	b.n	11744 <HAL_SD_GetCardCSD+0xd4>
   11828:	1fe00fff 	.word	0x1fe00fff

0001182c <HAL_SD_InitCard>:
{
   1182c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11830:	6982      	ldr	r2, [r0, #24]
{
   11832:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
   11834:	2300      	movs	r3, #0
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
   11836:	21fa      	movs	r1, #250	; 0xfa
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11838:	2a02      	cmp	r2, #2
{
   1183a:	4604      	mov	r4, r0
   1183c:	6805      	ldr	r5, [r0, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
   1183e:	910b      	str	r1, [sp, #44]	; 0x2c
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
   11840:	e9cd 3307 	strd	r3, r3, [sp, #28]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
   11844:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11848:	d104      	bne.n	11854 <HAL_SD_InitCard+0x28>
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
   1184a:	682b      	ldr	r3, [r5, #0]
   1184c:	f043 0310 	orr.w	r3, r3, #16
   11850:	602b      	str	r3, [r5, #0]
   11852:	6805      	ldr	r5, [r0, #0]
  (void)SDMMC_Init(hsd->Instance, Init);
   11854:	aa0a      	add	r2, sp, #40	; 0x28
   11856:	ab07      	add	r3, sp, #28
   11858:	ca07      	ldmia	r2, {r0, r1, r2}
   1185a:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   1185e:	4628      	mov	r0, r5
   11860:	cb0e      	ldmia	r3, {r1, r2, r3}
   11862:	f002 f94d 	bl	13b00 <SDMMC_Init>
  (void)SDMMC_PowerState_ON(hsd->Instance);
   11866:	6820      	ldr	r0, [r4, #0]
   11868:	f002 f9b4 	bl	13bd4 <SDMMC_PowerState_ON>
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC)/(2U*SDMMC_INIT_CLK_DIV);
   1186c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
   11870:	f7fe fd08 	bl	10284 <HAL_RCCEx_GetPeriphCLKFreq>
   11874:	4ba3      	ldr	r3, [pc, #652]	; (11b04 <HAL_SD_InitCard+0x2d8>)
   11876:	fba3 3000 	umull	r3, r0, r3, r0
  if(sdmmc_clk != 0U)
   1187a:	0940      	lsrs	r0, r0, #5
   1187c:	d019      	beq.n	118b2 <HAL_SD_InitCard+0x86>
    HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
   1187e:	4ba2      	ldr	r3, [pc, #648]	; (11b08 <HAL_SD_InitCard+0x2dc>)
   11880:	fbb3 f0f0 	udiv	r0, r3, r0
   11884:	3001      	adds	r0, #1
   11886:	f7f6 fdbb 	bl	8400 <HAL_Delay>
  __IO uint32_t count = 0U;
   1188a:	2300      	movs	r3, #0
   1188c:	9306      	str	r3, [sp, #24]
  uint32_t tickstart = HAL_GetTick();
   1188e:	f7f6 fdb1 	bl	83f4 <HAL_GetTick>
   11892:	4680      	mov	r8, r0
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
   11894:	6820      	ldr	r0, [r4, #0]
   11896:	f002 fc13 	bl	140c0 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
   1189a:	4605      	mov	r5, r0
   1189c:	b168      	cbz	r0, 118ba <HAL_SD_InitCard+0x8e>
    hsd->State = HAL_SD_STATE_READY;
   1189e:	2601      	movs	r6, #1
   118a0:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
   118a4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   118a6:	431d      	orrs	r5, r3
   118a8:	63a5      	str	r5, [r4, #56]	; 0x38
}
   118aa:	4630      	mov	r0, r6
   118ac:	b018      	add	sp, #96	; 0x60
   118ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_Delay(2U);
   118b2:	2002      	movs	r0, #2
   118b4:	f7f6 fda4 	bl	8400 <HAL_Delay>
   118b8:	e7e7      	b.n	1188a <HAL_SD_InitCard+0x5e>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
   118ba:	6820      	ldr	r0, [r4, #0]
   118bc:	f002 fc2e 	bl	1411c <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
   118c0:	2800      	cmp	r0, #0
   118c2:	d179      	bne.n	119b8 <HAL_SD_InitCard+0x18c>
    hsd->SdCard.CardVersion = CARD_V2_X;
   118c4:	2301      	movs	r3, #1
   118c6:	6423      	str	r3, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
   118c8:	2100      	movs	r1, #0
   118ca:	6820      	ldr	r0, [r4, #0]
   118cc:	f002 fc66 	bl	1419c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   118d0:	bb08      	cbnz	r0, 11916 <HAL_SD_InitCard+0xea>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   118d2:	9b06      	ldr	r3, [sp, #24]
   118d4:	f64f 76fe 	movw	r6, #65534	; 0xfffe
   118d8:	42b3      	cmp	r3, r6
   118da:	f200 8109 	bhi.w	11af0 <HAL_SD_InitCard+0x2c4>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   118de:	4f8b      	ldr	r7, [pc, #556]	; (11b0c <HAL_SD_InitCard+0x2e0>)
   118e0:	e00c      	b.n	118fc <HAL_SD_InitCard+0xd0>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   118e2:	4601      	mov	r1, r0
   118e4:	6820      	ldr	r0, [r4, #0]
   118e6:	f002 f981 	bl	13bec <SDMMC_GetResponse>
    count++;
   118ea:	9b06      	ldr	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   118ec:	1e02      	subs	r2, r0, #0
    count++;
   118ee:	f103 0301 	add.w	r3, r3, #1
   118f2:	9306      	str	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
   118f4:	9b06      	ldr	r3, [sp, #24]
   118f6:	db11      	blt.n	1191c <HAL_SD_InitCard+0xf0>
   118f8:	42b3      	cmp	r3, r6
   118fa:	d80f      	bhi.n	1191c <HAL_SD_InitCard+0xf0>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
   118fc:	2100      	movs	r1, #0
   118fe:	6820      	ldr	r0, [r4, #0]
   11900:	f002 fc4c 	bl	1419c <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   11904:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
   11906:	4605      	mov	r5, r0
   11908:	2800      	cmp	r0, #0
   1190a:	d1c8      	bne.n	1189e <HAL_SD_InitCard+0x72>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
   1190c:	6820      	ldr	r0, [r4, #0]
   1190e:	f002 fc89 	bl	14224 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   11912:	2800      	cmp	r0, #0
   11914:	d0e5      	beq.n	118e2 <HAL_SD_InitCard+0xb6>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   11916:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   1191a:	e7c0      	b.n	1189e <HAL_SD_InitCard+0x72>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
   1191c:	9906      	ldr	r1, [sp, #24]
   1191e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   11922:	4299      	cmp	r1, r3
   11924:	f200 809d 	bhi.w	11a62 <HAL_SD_InitCard+0x236>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
   11928:	0057      	lsls	r7, r2, #1
   1192a:	6820      	ldr	r0, [r4, #0]
   1192c:	d504      	bpl.n	11938 <HAL_SD_InitCard+0x10c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   1192e:	69a3      	ldr	r3, [r4, #24]
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
   11930:	2101      	movs	r1, #1
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11932:	2b02      	cmp	r3, #2
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
   11934:	63e1      	str	r1, [r4, #60]	; 0x3c
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
   11936:	d051      	beq.n	119dc <HAL_SD_InitCard+0x1b0>
  uint16_t sd_rca = 1U;
   11938:	2301      	movs	r3, #1
   1193a:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
   1193e:	f002 f951 	bl	13be4 <SDMMC_GetPowerState>
   11942:	2800      	cmp	r0, #0
   11944:	d044      	beq.n	119d0 <HAL_SD_InitCard+0x1a4>
  if(hsd->SdCard.CardType != CARD_SECURED)
   11946:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   11948:	6823      	ldr	r3, [r4, #0]
   1194a:	2a03      	cmp	r2, #3
   1194c:	d125      	bne.n	1199a <HAL_SD_InitCard+0x16e>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   1194e:	4618      	mov	r0, r3
   11950:	2104      	movs	r1, #4
   11952:	f002 f94b 	bl	13bec <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   11956:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   11958:	0d03      	lsrs	r3, r0, #20
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   1195a:	4620      	mov	r0, r4
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
   1195c:	6463      	str	r3, [r4, #68]	; 0x44
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
   1195e:	f7ff fe87 	bl	11670 <HAL_SD_GetCardCSD>
   11962:	4606      	mov	r6, r0
   11964:	2800      	cmp	r0, #0
   11966:	d136      	bne.n	119d6 <HAL_SD_InitCard+0x1aa>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
   11968:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1196a:	4603      	mov	r3, r0
   1196c:	6820      	ldr	r0, [r4, #0]
   1196e:	0412      	lsls	r2, r2, #16
   11970:	f002 fb62 	bl	14038 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
   11974:	b9b0      	cbnz	r0, 119a4 <HAL_SD_InitCard+0x178>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   11976:	f44f 7100 	mov.w	r1, #512	; 0x200
   1197a:	6820      	ldr	r0, [r4, #0]
   1197c:	f002 f9a4 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11980:	2800      	cmp	r0, #0
   11982:	d092      	beq.n	118aa <HAL_SD_InitCard+0x7e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11984:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
   11986:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11988:	4961      	ldr	r1, [pc, #388]	; (11b10 <HAL_SD_InitCard+0x2e4>)
    return HAL_ERROR;
   1198a:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   1198c:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   1198e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11990:	4318      	orrs	r0, r3
   11992:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11994:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_ERROR;
   11998:	e787      	b.n	118aa <HAL_SD_InitCard+0x7e>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
   1199a:	4618      	mov	r0, r3
   1199c:	f002 fcfe 	bl	1439c <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
   119a0:	2800      	cmp	r0, #0
   119a2:	d061      	beq.n	11a68 <HAL_SD_InitCard+0x23c>
    hsd->State = HAL_SD_STATE_READY;
   119a4:	2601      	movs	r6, #1
   119a6:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
   119aa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   119ac:	4308      	orrs	r0, r1
   119ae:	63a0      	str	r0, [r4, #56]	; 0x38
}
   119b0:	4630      	mov	r0, r6
   119b2:	b018      	add	sp, #96	; 0x60
   119b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->SdCard.CardVersion = CARD_V1_X;
   119b8:	6425      	str	r5, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
   119ba:	6820      	ldr	r0, [r4, #0]
   119bc:	f002 fb80 	bl	140c0 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
   119c0:	4605      	mov	r5, r0
   119c2:	2800      	cmp	r0, #0
   119c4:	f47f af6b 	bne.w	1189e <HAL_SD_InitCard+0x72>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
   119c8:	6c23      	ldr	r3, [r4, #64]	; 0x40
   119ca:	2b01      	cmp	r3, #1
   119cc:	d181      	bne.n	118d2 <HAL_SD_InitCard+0xa6>
   119ce:	e77b      	b.n	118c8 <HAL_SD_InitCard+0x9c>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
   119d0:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   119d4:	e7e6      	b.n	119a4 <HAL_SD_InitCard+0x178>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   119d6:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
   119da:	e7e3      	b.n	119a4 <HAL_SD_InitCard+0x178>
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
   119dc:	01d6      	lsls	r6, r2, #7
   119de:	d5ab      	bpl.n	11938 <HAL_SD_InitCard+0x10c>
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
   119e0:	f44f 7300 	mov.w	r3, #512	; 0x200
   119e4:	65e3      	str	r3, [r4, #92]	; 0x5c
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
   119e6:	6803      	ldr	r3, [r0, #0]
   119e8:	f043 0308 	orr.w	r3, r3, #8
   119ec:	6003      	str	r3, [r0, #0]
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
   119ee:	6820      	ldr	r0, [r4, #0]
   119f0:	f002 fe24 	bl	1463c <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
   119f4:	4605      	mov	r5, r0
   119f6:	b130      	cbz	r0, 11a06 <HAL_SD_InitCard+0x1da>
   119f8:	e751      	b.n	1189e <HAL_SD_InitCard+0x72>
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   119fa:	f7f6 fcfb 	bl	83f4 <HAL_GetTick>
   119fe:	eba0 0008 	sub.w	r0, r0, r8
   11a02:	3001      	adds	r0, #1
   11a04:	d079      	beq.n	11afa <HAL_SD_InitCard+0x2ce>
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
   11a06:	6823      	ldr	r3, [r4, #0]
   11a08:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11a0a:	0155      	lsls	r5, r2, #5
   11a0c:	d5f5      	bpl.n	119fa <HAL_SD_InitCard+0x1ce>
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
   11a0e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   11a12:	639a      	str	r2, [r3, #56]	; 0x38
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
   11a14:	6823      	ldr	r3, [r4, #0]
   11a16:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   11a18:	02d8      	lsls	r0, r3, #11
   11a1a:	f57f af7c 	bpl.w	11916 <HAL_SD_InitCard+0xea>
          HAL_SD_DriveTransceiver_1_8V_Callback(SET);
   11a1e:	2001      	movs	r0, #1
   11a20:	f7ff fe24 	bl	1166c <HAL_SD_DriveTransceiver_1_8V_Callback>
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
   11a24:	6822      	ldr	r2, [r4, #0]
   11a26:	6813      	ldr	r3, [r2, #0]
   11a28:	f043 0304 	orr.w	r3, r3, #4
   11a2c:	6013      	str	r3, [r2, #0]
   11a2e:	e005      	b.n	11a3c <HAL_SD_InitCard+0x210>
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11a30:	f7f6 fce0 	bl	83f4 <HAL_GetTick>
   11a34:	eba0 0008 	sub.w	r0, r0, r8
   11a38:	3001      	adds	r0, #1
   11a3a:	d05e      	beq.n	11afa <HAL_SD_InitCard+0x2ce>
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
   11a3c:	6823      	ldr	r3, [r4, #0]
   11a3e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11a40:	0191      	lsls	r1, r2, #6
   11a42:	d5f5      	bpl.n	11a30 <HAL_SD_InitCard+0x204>
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
   11a44:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   11a48:	639a      	str	r2, [r3, #56]	; 0x38
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
   11a4a:	6823      	ldr	r3, [r4, #0]
   11a4c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11a4e:	02d2      	lsls	r2, r2, #11
   11a50:	d407      	bmi.n	11a62 <HAL_SD_InitCard+0x236>
          hsd->Instance->POWER = 0x13U;
   11a52:	2113      	movs	r1, #19
          hsd->Instance->ICR = 0xFFFFFFFFU;
   11a54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          hsd->Instance->POWER = 0x13U;
   11a58:	6019      	str	r1, [r3, #0]
          hsd->Instance->ICR = 0xFFFFFFFFU;
   11a5a:	6823      	ldr	r3, [r4, #0]
   11a5c:	639a      	str	r2, [r3, #56]	; 0x38
   11a5e:	6820      	ldr	r0, [r4, #0]
   11a60:	e76a      	b.n	11938 <HAL_SD_InitCard+0x10c>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
   11a62:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
   11a66:	e71a      	b.n	1189e <HAL_SD_InitCard+0x72>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11a68:	4601      	mov	r1, r0
   11a6a:	6820      	ldr	r0, [r4, #0]
   11a6c:	f002 f8be 	bl	13bec <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11a70:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11a72:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11a74:	6820      	ldr	r0, [r4, #0]
   11a76:	f002 f8b9 	bl	13bec <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11a7a:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11a7c:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11a7e:	6820      	ldr	r0, [r4, #0]
   11a80:	f002 f8b4 	bl	13bec <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11a84:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11a86:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11a88:	6820      	ldr	r0, [r4, #0]
   11a8a:	f002 f8af 	bl	13bec <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
   11a8e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11a90:	67e0      	str	r0, [r4, #124]	; 0x7c
  if(hsd->SdCard.CardType != CARD_SECURED)
   11a92:	2b03      	cmp	r3, #3
   11a94:	d034      	beq.n	11b00 <HAL_SD_InitCard+0x2d4>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
   11a96:	f10d 0116 	add.w	r1, sp, #22
   11a9a:	6820      	ldr	r0, [r4, #0]
   11a9c:	f002 fcf2 	bl	14484 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
   11aa0:	2800      	cmp	r0, #0
   11aa2:	f47f af7f 	bne.w	119a4 <HAL_SD_InitCard+0x178>
  if(hsd->SdCard.CardType != CARD_SECURED)
   11aa6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   11aa8:	6823      	ldr	r3, [r4, #0]
   11aaa:	2a03      	cmp	r2, #3
   11aac:	f43f af4f 	beq.w	1194e <HAL_SD_InitCard+0x122>
    hsd->SdCard.RelCardAdd = sd_rca;
   11ab0:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11ab4:	4618      	mov	r0, r3
    hsd->SdCard.RelCardAdd = sd_rca;
   11ab6:	64a1      	str	r1, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11ab8:	0409      	lsls	r1, r1, #16
   11aba:	f002 fca9 	bl	14410 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
   11abe:	2800      	cmp	r0, #0
   11ac0:	f47f af70 	bne.w	119a4 <HAL_SD_InitCard+0x178>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11ac4:	4601      	mov	r1, r0
   11ac6:	6820      	ldr	r0, [r4, #0]
   11ac8:	f002 f890 	bl	13bec <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11acc:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11ace:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11ad0:	6820      	ldr	r0, [r4, #0]
   11ad2:	f002 f88b 	bl	13bec <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11ad6:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
   11ad8:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11ada:	6820      	ldr	r0, [r4, #0]
   11adc:	f002 f886 	bl	13bec <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11ae0:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
   11ae2:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
   11ae4:	6820      	ldr	r0, [r4, #0]
   11ae6:	f002 f881 	bl	13bec <SDMMC_GetResponse>
   11aea:	6823      	ldr	r3, [r4, #0]
   11aec:	66e0      	str	r0, [r4, #108]	; 0x6c
   11aee:	e72e      	b.n	1194e <HAL_SD_InitCard+0x122>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
   11af0:	9b06      	ldr	r3, [sp, #24]
   11af2:	42b3      	cmp	r3, r6
   11af4:	d8b5      	bhi.n	11a62 <HAL_SD_InitCard+0x236>
   11af6:	6820      	ldr	r0, [r4, #0]
   11af8:	e71e      	b.n	11938 <HAL_SD_InitCard+0x10c>
            return HAL_SD_ERROR_TIMEOUT;
   11afa:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   11afe:	e6ce      	b.n	1189e <HAL_SD_InitCard+0x72>
   11b00:	6823      	ldr	r3, [r4, #0]
   11b02:	e724      	b.n	1194e <HAL_SD_InitCard+0x122>
   11b04:	10624dd3 	.word	0x10624dd3
   11b08:	00012110 	.word	0x00012110
   11b0c:	c1100000 	.word	0xc1100000
   11b10:	1fe00fff 	.word	0x1fe00fff

00011b14 <HAL_SD_GetCardStatus>:
{
   11b14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11b18:	4604      	mov	r4, r0
   11b1a:	b097      	sub	sp, #92	; 0x5c
   11b1c:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
   11b1e:	f7f6 fc69 	bl	83f4 <HAL_GetTick>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11b22:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
   11b24:	4680      	mov	r8, r0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11b26:	6820      	ldr	r0, [r4, #0]
   11b28:	f002 f860 	bl	13bec <SDMMC_GetResponse>
   11b2c:	0187      	lsls	r7, r0, #6
   11b2e:	d422      	bmi.n	11b76 <HAL_SD_GetCardStatus+0x62>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
   11b30:	2140      	movs	r1, #64	; 0x40
   11b32:	6820      	ldr	r0, [r4, #0]
   11b34:	f002 f8c8 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11b38:	b308      	cbz	r0, 11b7e <HAL_SD_GetCardStatus+0x6a>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
   11b3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11b3c:	63a3      	str	r3, [r4, #56]	; 0x38
   11b3e:	6823      	ldr	r3, [r4, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b40:	495b      	ldr	r1, [pc, #364]	; (11cb0 <HAL_SD_GetCardStatus+0x19c>)
    hsd->State = HAL_SD_STATE_READY;
   11b42:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b44:	6399      	str	r1, [r3, #56]	; 0x38
    status = HAL_ERROR;
   11b46:	4616      	mov	r6, r2
    hsd->ErrorCode |= errorstate;
   11b48:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11b4a:	4318      	orrs	r0, r3
   11b4c:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11b4e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   11b52:	f44f 7100 	mov.w	r1, #512	; 0x200
   11b56:	6820      	ldr	r0, [r4, #0]
   11b58:	f002 f8b6 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11b5c:	b138      	cbz	r0, 11b6e <HAL_SD_GetCardStatus+0x5a>
    hsd->State = HAL_SD_STATE_READY;
   11b5e:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b60:	6822      	ldr	r2, [r4, #0]
   11b62:	4953      	ldr	r1, [pc, #332]	; (11cb0 <HAL_SD_GetCardStatus+0x19c>)
    status = HAL_ERROR;
   11b64:	461e      	mov	r6, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11b66:	6391      	str	r1, [r2, #56]	; 0x38
    hsd->ErrorCode = errorstate;
   11b68:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
   11b6a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
   11b6e:	4630      	mov	r0, r6
   11b70:	b017      	add	sp, #92	; 0x5c
   11b72:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11b76:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
   11b78:	f44f 6000 	mov.w	r0, #2048	; 0x800
   11b7c:	e7e0      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11b7e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11b80:	6820      	ldr	r0, [r4, #0]
   11b82:	0409      	lsls	r1, r1, #16
   11b84:	f002 fb0a 	bl	1419c <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
   11b88:	2800      	cmp	r0, #0
   11b8a:	d1d6      	bne.n	11b3a <HAL_SD_GetCardStatus+0x26>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   11b8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 64U;
   11b90:	2340      	movs	r3, #64	; 0x40
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
   11b92:	2160      	movs	r1, #96	; 0x60
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
   11b94:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
   11b96:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   11b98:	2202      	movs	r2, #2
  config.DataLength    = 64U;
   11b9a:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   11b9c:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
   11b9e:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   11ba0:	4669      	mov	r1, sp
   11ba2:	6820      	ldr	r0, [r4, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
   11ba4:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
   11ba6:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
   11ba8:	f002 f830 	bl	13c0c <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
   11bac:	6820      	ldr	r0, [r4, #0]
   11bae:	f002 fd01 	bl	145b4 <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
   11bb2:	2800      	cmp	r0, #0
   11bb4:	d1c1      	bne.n	11b3a <HAL_SD_GetCardStatus+0x26>
  uint32_t *pData = pSDstatus;
   11bb6:	af06      	add	r7, sp, #24
   11bb8:	e005      	b.n	11bc6 <HAL_SD_GetCardStatus+0xb2>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11bba:	f7f6 fc1b 	bl	83f4 <HAL_GetTick>
   11bbe:	eba0 0008 	sub.w	r0, r0, r8
   11bc2:	3001      	adds	r0, #1
   11bc4:	d013      	beq.n	11bee <HAL_SD_GetCardStatus+0xda>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11bc6:	6823      	ldr	r3, [r4, #0]
   11bc8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11bca:	f412 7f95 	tst.w	r2, #298	; 0x12a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
   11bce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
   11bd0:	d110      	bne.n	11bf4 <HAL_SD_GetCardStatus+0xe0>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
   11bd2:	0416      	lsls	r6, r2, #16
   11bd4:	d5f1      	bpl.n	11bba <HAL_SD_GetCardStatus+0xa6>
   11bd6:	f107 0620 	add.w	r6, r7, #32
   11bda:	e000      	b.n	11bde <HAL_SD_GetCardStatus+0xca>
   11bdc:	6823      	ldr	r3, [r4, #0]
        *pData = SDMMC_ReadFIFO(hsd->Instance);
   11bde:	4618      	mov	r0, r3
   11be0:	f001 ffee 	bl	13bc0 <SDMMC_ReadFIFO>
   11be4:	f847 0b04 	str.w	r0, [r7], #4
      for(count = 0U; count < 8U; count++)
   11be8:	42b7      	cmp	r7, r6
   11bea:	d1f7      	bne.n	11bdc <HAL_SD_GetCardStatus+0xc8>
   11bec:	e7e5      	b.n	11bba <HAL_SD_GetCardStatus+0xa6>
      return HAL_SD_ERROR_TIMEOUT;
   11bee:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
   11bf2:	e7a4      	b.n	11b3e <HAL_SD_GetCardStatus+0x2a>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
   11bf4:	0710      	lsls	r0, r2, #28
   11bf6:	d455      	bmi.n	11ca4 <HAL_SD_GetCardStatus+0x190>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
   11bf8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11bfa:	0791      	lsls	r1, r2, #30
   11bfc:	d454      	bmi.n	11ca8 <HAL_SD_GetCardStatus+0x194>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
   11bfe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11c00:	0692      	lsls	r2, r2, #26
   11c02:	d50b      	bpl.n	11c1c <HAL_SD_GetCardStatus+0x108>
   11c04:	e052      	b.n	11cac <HAL_SD_GetCardStatus+0x198>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
   11c06:	f001 ffdb 	bl	13bc0 <SDMMC_ReadFIFO>
   11c0a:	f847 0b04 	str.w	r0, [r7], #4
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
   11c0e:	f7f6 fbf1 	bl	83f4 <HAL_GetTick>
   11c12:	eba0 0008 	sub.w	r0, r0, r8
   11c16:	3001      	adds	r0, #1
   11c18:	d0e9      	beq.n	11bee <HAL_SD_GetCardStatus+0xda>
   11c1a:	6823      	ldr	r3, [r4, #0]
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
   11c1c:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    *pData = SDMMC_ReadFIFO(hsd->Instance);
   11c1e:	4618      	mov	r0, r3
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
   11c20:	f416 5680 	ands.w	r6, r6, #4096	; 0x1000
   11c24:	d1ef      	bne.n	11c06 <HAL_SD_GetCardStatus+0xf2>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   11c26:	9f06      	ldr	r7, [sp, #24]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   11c28:	9808      	ldr	r0, [sp, #32]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c2a:	0a39      	lsrs	r1, r7, #8
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   11c2c:	f3c7 1e81 	ubfx	lr, r7, #6, #2
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c30:	ea4f 4810 	mov.w	r8, r0, lsr #16
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
   11c34:	f3c7 1c40 	ubfx	ip, r7, #5, #1
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c38:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c3c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c3e:	ea41 6117 	orr.w	r1, r1, r7, lsr #24
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c42:	f028 07ff 	bic.w	r7, r8, #255	; 0xff
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11c46:	f8df 806c 	ldr.w	r8, [pc, #108]	; 11cb4 <HAL_SD_GetCardStatus+0x1a0>
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c4a:	fa5f f982 	uxtb.w	r9, r2
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c4e:	b289      	uxth	r1, r1
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
   11c50:	f8c3 8038 	str.w	r8, [r3, #56]	; 0x38
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   11c54:	fa5f f880 	uxtb.w	r8, r0
   11c58:	9b07      	ldr	r3, [sp, #28]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c5a:	ea47 0709 	orr.w	r7, r7, r9
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
   11c5e:	f885 e000 	strb.w	lr, [r5]
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
   11c62:	f885 c001 	strb.w	ip, [r5, #1]
   11c66:	fa93 fe83 	rev.w	lr, r3
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
   11c6a:	8069      	strh	r1, [r5, #2]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
   11c6c:	f3c0 5303 	ubfx	r3, r0, #20, #4
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
   11c70:	f3c0 2107 	ubfx	r1, r0, #8, #8
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
   11c74:	f8c5 e004 	str.w	lr, [r5, #4]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
   11c78:	f3c2 2c85 	ubfx	ip, r2, #10, #6
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
   11c7c:	f885 8008 	strb.w	r8, [r5, #8]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
   11c80:	f3c2 2001 	ubfx	r0, r2, #8, #2
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
   11c84:	7269      	strb	r1, [r5, #9]
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
   11c86:	72ab      	strb	r3, [r5, #10]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
   11c88:	f3c2 1103 	ubfx	r1, r2, #4, #4
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
   11c8c:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
   11c90:	f002 020f 	and.w	r2, r2, #15
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
   11c94:	81af      	strh	r7, [r5, #12]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
   11c96:	f885 c00e 	strb.w	ip, [r5, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
   11c9a:	73e8      	strb	r0, [r5, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
   11c9c:	7429      	strb	r1, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
   11c9e:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
   11ca0:	74ab      	strb	r3, [r5, #18]
   11ca2:	e756      	b.n	11b52 <HAL_SD_GetCardStatus+0x3e>
    return HAL_SD_ERROR_DATA_TIMEOUT;
   11ca4:	2008      	movs	r0, #8
   11ca6:	e74b      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_DATA_CRC_FAIL;
   11ca8:	2002      	movs	r0, #2
   11caa:	e749      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_RX_OVERRUN;
   11cac:	2020      	movs	r0, #32
   11cae:	e747      	b.n	11b40 <HAL_SD_GetCardStatus+0x2c>
   11cb0:	1fe00fff 	.word	0x1fe00fff
   11cb4:	18000f3a 	.word	0x18000f3a

00011cb8 <HAL_SD_GetCardInfo>:
{
   11cb8:	4603      	mov	r3, r0
}
   11cba:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
   11cbc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   11cbe:	600a      	str	r2, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
   11cc0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   11cc2:	604a      	str	r2, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
   11cc4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   11cc6:	608a      	str	r2, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
   11cc8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   11cca:	60ca      	str	r2, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
   11ccc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   11cce:	610a      	str	r2, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
   11cd0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   11cd2:	614a      	str	r2, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
   11cd4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   11cd6:	618a      	str	r2, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
   11cd8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   11cda:	61cb      	str	r3, [r1, #28]
}
   11cdc:	4770      	bx	lr
   11cde:	bf00      	nop

00011ce0 <HAL_SD_ConfigWideBusOperation>:
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   11ce0:	f431 4380 	bics.w	r3, r1, #16384	; 0x4000
{
   11ce4:	b570      	push	{r4, r5, r6, lr}
   11ce6:	460d      	mov	r5, r1
   11ce8:	b08a      	sub	sp, #40	; 0x28
   11cea:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   11cec:	d002      	beq.n	11cf4 <HAL_SD_ConfigWideBusOperation+0x14>
   11cee:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   11cf2:	d152      	bne.n	11d9a <HAL_SD_ConfigWideBusOperation+0xba>
  hsd->State = HAL_SD_STATE_BUSY;
   11cf4:	2103      	movs	r1, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
   11cf6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   11cf8:	6823      	ldr	r3, [r4, #0]
   11cfa:	428a      	cmp	r2, r1
  hsd->State = HAL_SD_STATE_BUSY;
   11cfc:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
   11d00:	d025      	beq.n	11d4e <HAL_SD_ConfigWideBusOperation+0x6e>
    if(WideMode == SDMMC_BUS_WIDE_8B)
   11d02:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   11d06:	d022      	beq.n	11d4e <HAL_SD_ConfigWideBusOperation+0x6e>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
   11d08:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
   11d0c:	d06b      	beq.n	11de6 <HAL_SD_ConfigWideBusOperation+0x106>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
   11d0e:	2d00      	cmp	r5, #0
   11d10:	d049      	beq.n	11da6 <HAL_SD_ConfigWideBusOperation+0xc6>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
   11d12:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d14:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
   11d18:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
   11d1a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d1c:	b9f2      	cbnz	r2, 11d5c <HAL_SD_ConfigWideBusOperation+0x7c>
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   11d1e:	6962      	ldr	r2, [r4, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   11d20:	6921      	ldr	r1, [r4, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   11d22:	2a03      	cmp	r2, #3
    Init.BusWide             = WideMode;
   11d24:	9506      	str	r5, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
   11d26:	9107      	str	r1, [sp, #28]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
   11d28:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
   11d2c:	e9cd 6004 	strd	r6, r0, [sp, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
   11d30:	d92a      	bls.n	11d88 <HAL_SD_ConfigWideBusOperation+0xa8>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
   11d32:	9208      	str	r2, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
   11d34:	aa0a      	add	r2, sp, #40	; 0x28
   11d36:	ae04      	add	r6, sp, #16
  HAL_StatusTypeDef status = HAL_OK;
   11d38:	2500      	movs	r5, #0
    (void)SDMMC_Init(hsd->Instance, Init);
   11d3a:	e912 0007 	ldmdb	r2, {r0, r1, r2}
   11d3e:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   11d42:	4618      	mov	r0, r3
   11d44:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
   11d48:	f001 feda 	bl	13b00 <SDMMC_Init>
   11d4c:	e009      	b.n	11d62 <HAL_SD_ConfigWideBusOperation+0x82>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
   11d4e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d50:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   11d54:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
   11d56:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11d58:	2a00      	cmp	r2, #0
   11d5a:	d0e0      	beq.n	11d1e <HAL_SD_ConfigWideBusOperation+0x3e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d5c:	4a36      	ldr	r2, [pc, #216]	; (11e38 <HAL_SD_ConfigWideBusOperation+0x158>)
    status = HAL_ERROR;
   11d5e:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d60:	639a      	str	r2, [r3, #56]	; 0x38
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
   11d62:	f44f 7100 	mov.w	r1, #512	; 0x200
   11d66:	6820      	ldr	r0, [r4, #0]
   11d68:	f001 ffae 	bl	13cc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
   11d6c:	b130      	cbz	r0, 11d7c <HAL_SD_ConfigWideBusOperation+0x9c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d6e:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
   11d70:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
   11d72:	4a31      	ldr	r2, [pc, #196]	; (11e38 <HAL_SD_ConfigWideBusOperation+0x158>)
   11d74:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
   11d76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11d78:	4318      	orrs	r0, r3
   11d7a:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
   11d7c:	2301      	movs	r3, #1
}
   11d7e:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
   11d80:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
   11d84:	b00a      	add	sp, #40	; 0x28
   11d86:	bd70      	pop	{r4, r5, r6, pc}
    else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
   11d88:	6de1      	ldr	r1, [r4, #92]	; 0x5c
   11d8a:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   11d8e:	d0d0      	beq.n	11d32 <HAL_SD_ConfigWideBusOperation+0x52>
    else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
   11d90:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   11d94:	d034      	beq.n	11e00 <HAL_SD_ConfigWideBusOperation+0x120>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
   11d96:	2204      	movs	r2, #4
   11d98:	e7cb      	b.n	11d32 <HAL_SD_ConfigWideBusOperation+0x52>
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
   11d9a:	f640 1149 	movw	r1, #2377	; 0x949
   11d9e:	4827      	ldr	r0, [pc, #156]	; (11e3c <HAL_SD_ConfigWideBusOperation+0x15c>)
   11da0:	f007 fb8e 	bl	194c0 <assert_failed>
   11da4:	e7a6      	b.n	11cf4 <HAL_SD_ConfigWideBusOperation+0x14>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11da6:	4629      	mov	r1, r5
   11da8:	4618      	mov	r0, r3
  uint32_t scr[2U] = {0UL, 0UL};
   11daa:	e9cd 5504 	strd	r5, r5, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11dae:	f001 ff1d 	bl	13bec <SDMMC_GetResponse>
   11db2:	0181      	lsls	r1, r0, #6
   11db4:	d420      	bmi.n	11df8 <HAL_SD_ConfigWideBusOperation+0x118>
  errorstate = SD_FindSCR(hsd, scr);
   11db6:	a904      	add	r1, sp, #16
   11db8:	4620      	mov	r0, r4
   11dba:	f7ff f9f7 	bl	111ac <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   11dbe:	b968      	cbnz	r0, 11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
   11dc0:	9a05      	ldr	r2, [sp, #20]
   11dc2:	6823      	ldr	r3, [r4, #0]
   11dc4:	03d2      	lsls	r2, r2, #15
   11dc6:	d534      	bpl.n	11e32 <HAL_SD_ConfigWideBusOperation+0x152>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11dc8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11dca:	4618      	mov	r0, r3
   11dcc:	0409      	lsls	r1, r1, #16
   11dce:	f002 f9e5 	bl	1419c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   11dd2:	b918      	cbnz	r0, 11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
   11dd4:	4629      	mov	r1, r5
   11dd6:	6820      	ldr	r0, [r4, #0]
   11dd8:	f002 fa58 	bl	1428c <SDMMC_CmdBusWidth>
   11ddc:	6823      	ldr	r3, [r4, #0]
      hsd->ErrorCode |= errorstate;
   11dde:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   11de0:	4310      	orrs	r0, r2
   11de2:	63a0      	str	r0, [r4, #56]	; 0x38
   11de4:	e7b7      	b.n	11d56 <HAL_SD_ConfigWideBusOperation+0x76>
  uint32_t scr[2U] = {0UL, 0UL};
   11de6:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11de8:	4618      	mov	r0, r3
   11dea:	4611      	mov	r1, r2
  uint32_t scr[2U] = {0UL, 0UL};
   11dec:	e9cd 2204 	strd	r2, r2, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
   11df0:	f001 fefc 	bl	13bec <SDMMC_GetResponse>
   11df4:	0186      	lsls	r6, r0, #6
   11df6:	d506      	bpl.n	11e06 <HAL_SD_ConfigWideBusOperation+0x126>
   11df8:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
   11dfa:	f44f 6000 	mov.w	r0, #2048	; 0x800
   11dfe:	e7ee      	b.n	11dde <HAL_SD_ConfigWideBusOperation+0xfe>
      Init.ClockDiv = SDMMC_HSpeed_CLK_DIV;
   11e00:	2202      	movs	r2, #2
   11e02:	9208      	str	r2, [sp, #32]
   11e04:	e796      	b.n	11d34 <HAL_SD_ConfigWideBusOperation+0x54>
  errorstate = SD_FindSCR(hsd, scr);
   11e06:	a904      	add	r1, sp, #16
   11e08:	4620      	mov	r0, r4
   11e0a:	f7ff f9cf 	bl	111ac <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
   11e0e:	2800      	cmp	r0, #0
   11e10:	d1e4      	bne.n	11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
   11e12:	9a05      	ldr	r2, [sp, #20]
   11e14:	6823      	ldr	r3, [r4, #0]
   11e16:	0350      	lsls	r0, r2, #13
   11e18:	d50b      	bpl.n	11e32 <HAL_SD_ConfigWideBusOperation+0x152>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11e1a:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11e1c:	4618      	mov	r0, r3
   11e1e:	0409      	lsls	r1, r1, #16
   11e20:	f002 f9bc 	bl	1419c <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
   11e24:	2800      	cmp	r0, #0
   11e26:	d1d9      	bne.n	11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
   11e28:	2102      	movs	r1, #2
   11e2a:	6820      	ldr	r0, [r4, #0]
   11e2c:	f002 fa2e 	bl	1428c <SDMMC_CmdBusWidth>
   11e30:	e7d4      	b.n	11ddc <HAL_SD_ConfigWideBusOperation+0xfc>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
   11e32:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
   11e36:	e7d2      	b.n	11dde <HAL_SD_ConfigWideBusOperation+0xfe>
   11e38:	1fe00fff 	.word	0x1fe00fff
   11e3c:	0003028c 	.word	0x0003028c

00011e40 <HAL_SD_Init>:
{
   11e40:	b5f0      	push	{r4, r5, r6, r7, lr}
   11e42:	b087      	sub	sp, #28
  if(hsd == NULL)
   11e44:	2800      	cmp	r0, #0
   11e46:	d038      	beq.n	11eba <HAL_SD_Init+0x7a>
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));
   11e48:	6803      	ldr	r3, [r0, #0]
   11e4a:	4604      	mov	r4, r0
   11e4c:	4a5c      	ldr	r2, [pc, #368]	; (11fc0 <HAL_SD_Init+0x180>)
   11e4e:	4293      	cmp	r3, r2
   11e50:	d007      	beq.n	11e62 <HAL_SD_Init+0x22>
   11e52:	4a5c      	ldr	r2, [pc, #368]	; (11fc4 <HAL_SD_Init+0x184>)
   11e54:	4293      	cmp	r3, r2
   11e56:	d004      	beq.n	11e62 <HAL_SD_Init+0x22>
   11e58:	f240 115b 	movw	r1, #347	; 0x15b
   11e5c:	485a      	ldr	r0, [pc, #360]	; (11fc8 <HAL_SD_Init+0x188>)
   11e5e:	f007 fb2f 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
   11e62:	6863      	ldr	r3, [r4, #4]
   11e64:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
   11e68:	d17a      	bne.n	11f60 <HAL_SD_Init+0x120>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   11e6a:	68a3      	ldr	r3, [r4, #8]
   11e6c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   11e70:	d16c      	bne.n	11f4c <HAL_SD_Init+0x10c>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   11e72:	68e3      	ldr	r3, [r4, #12]
   11e74:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
   11e78:	d003      	beq.n	11e82 <HAL_SD_Init+0x42>
   11e7a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11e7e:	f040 8084 	bne.w	11f8a <HAL_SD_Init+0x14a>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   11e82:	6923      	ldr	r3, [r4, #16]
   11e84:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   11e88:	d175      	bne.n	11f76 <HAL_SD_Init+0x136>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   11e8a:	6963      	ldr	r3, [r4, #20]
   11e8c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   11e90:	d250      	bcs.n	11f34 <HAL_SD_Init+0xf4>
  if(hsd->State == HAL_SD_STATE_RESET)
   11e92:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   11e96:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   11e9a:	b93b      	cbnz	r3, 11eac <HAL_SD_Init+0x6c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
   11e9c:	69a3      	ldr	r3, [r4, #24]
    hsd->Lock = HAL_UNLOCKED;
   11e9e:	7722      	strb	r2, [r4, #28]
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
   11ea0:	b90b      	cbnz	r3, 11ea6 <HAL_SD_Init+0x66>
      hsd->Init.TranceiverPresent = SDMMC_TRANSCEIVER_PRESENT;
   11ea2:	2302      	movs	r3, #2
   11ea4:	61a3      	str	r3, [r4, #24]
    HAL_SD_MspInit(hsd);
   11ea6:	4620      	mov	r0, r4
   11ea8:	f008 f9d2 	bl	1a250 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
   11eac:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
   11eae:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
   11eb0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
   11eb4:	f7ff fcba 	bl	1182c <HAL_SD_InitCard>
   11eb8:	b118      	cbz	r0, 11ec2 <HAL_SD_Init+0x82>
    return HAL_ERROR;
   11eba:	2501      	movs	r5, #1
}
   11ebc:	4628      	mov	r0, r5
   11ebe:	b007      	add	sp, #28
   11ec0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
   11ec2:	a901      	add	r1, sp, #4
   11ec4:	4620      	mov	r0, r4
   11ec6:	f7ff fe25 	bl	11b14 <HAL_SD_GetCardStatus>
   11eca:	2800      	cmp	r0, #0
   11ecc:	d1f5      	bne.n	11eba <HAL_SD_Init+0x7a>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11ece:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  speedgrade = CardStatus.UhsSpeedGrade;
   11ed0:	f89d 2014 	ldrb.w	r2, [sp, #20]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11ed4:	2901      	cmp	r1, #1
  unitsize = CardStatus.UhsAllocationUnitSize;
   11ed6:	f89d 3015 	ldrb.w	r3, [sp, #21]
  speedgrade = CardStatus.UhsSpeedGrade;
   11eda:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
   11edc:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11ede:	d05f      	beq.n	11fa0 <HAL_SD_Init+0x160>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
   11ee0:	65e0      	str	r0, [r4, #92]	; 0x5c
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
   11ee2:	68e1      	ldr	r1, [r4, #12]
   11ee4:	4620      	mov	r0, r4
   11ee6:	f7ff fefb 	bl	11ce0 <HAL_SD_ConfigWideBusOperation>
   11eea:	4605      	mov	r5, r0
   11eec:	2800      	cmp	r0, #0
   11eee:	d1e4      	bne.n	11eba <HAL_SD_Init+0x7a>
  tickstart = HAL_GetTick();
   11ef0:	f7f6 fa80 	bl	83f4 <HAL_GetTick>
   11ef4:	4607      	mov	r7, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
   11ef6:	e007      	b.n	11f08 <HAL_SD_Init+0xc8>
    hsd->ErrorCode |= errorstate;
   11ef8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11efa:	431e      	orrs	r6, r3
   11efc:	63a6      	str	r6, [r4, #56]	; 0x38
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
   11efe:	f7f6 fa79 	bl	83f4 <HAL_GetTick>
   11f02:	1bc0      	subs	r0, r0, r7
   11f04:	3001      	adds	r0, #1
   11f06:	d053      	beq.n	11fb0 <HAL_SD_Init+0x170>
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11f08:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   11f0a:	6820      	ldr	r0, [r4, #0]
   11f0c:	0409      	lsls	r1, r1, #16
   11f0e:	f002 fb0d 	bl	1452c <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
   11f12:	4606      	mov	r6, r0
   11f14:	2800      	cmp	r0, #0
   11f16:	d1ef      	bne.n	11ef8 <HAL_SD_Init+0xb8>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11f18:	4601      	mov	r1, r0
   11f1a:	6820      	ldr	r0, [r4, #0]
   11f1c:	f001 fe66 	bl	13bec <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
   11f20:	f3c0 2043 	ubfx	r0, r0, #9, #4
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
   11f24:	2804      	cmp	r0, #4
   11f26:	d1ea      	bne.n	11efe <HAL_SD_Init+0xbe>
  hsd->State = HAL_SD_STATE_READY;
   11f28:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
   11f2a:	63a6      	str	r6, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
   11f2c:	6326      	str	r6, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
   11f2e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
   11f32:	e7c3      	b.n	11ebc <HAL_SD_Init+0x7c>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   11f34:	f44f 71b0 	mov.w	r1, #352	; 0x160
   11f38:	4823      	ldr	r0, [pc, #140]	; (11fc8 <HAL_SD_Init+0x188>)
   11f3a:	f007 fac1 	bl	194c0 <assert_failed>
  if(hsd->State == HAL_SD_STATE_RESET)
   11f3e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
   11f42:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   11f46:	2b00      	cmp	r3, #0
   11f48:	d1b0      	bne.n	11eac <HAL_SD_Init+0x6c>
   11f4a:	e7a7      	b.n	11e9c <HAL_SD_Init+0x5c>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   11f4c:	f240 115d 	movw	r1, #349	; 0x15d
   11f50:	481d      	ldr	r0, [pc, #116]	; (11fc8 <HAL_SD_Init+0x188>)
   11f52:	f007 fab5 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   11f56:	68e3      	ldr	r3, [r4, #12]
   11f58:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
   11f5c:	d18d      	bne.n	11e7a <HAL_SD_Init+0x3a>
   11f5e:	e790      	b.n	11e82 <HAL_SD_Init+0x42>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
   11f60:	f44f 71ae 	mov.w	r1, #348	; 0x15c
   11f64:	4818      	ldr	r0, [pc, #96]	; (11fc8 <HAL_SD_Init+0x188>)
   11f66:	f007 faab 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
   11f6a:	68a3      	ldr	r3, [r4, #8]
   11f6c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   11f70:	f43f af7f 	beq.w	11e72 <HAL_SD_Init+0x32>
   11f74:	e7ea      	b.n	11f4c <HAL_SD_Init+0x10c>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   11f76:	f240 115f 	movw	r1, #351	; 0x15f
   11f7a:	4813      	ldr	r0, [pc, #76]	; (11fc8 <HAL_SD_Init+0x188>)
   11f7c:	f007 faa0 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
   11f80:	6963      	ldr	r3, [r4, #20]
   11f82:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   11f86:	d384      	bcc.n	11e92 <HAL_SD_Init+0x52>
   11f88:	e7d4      	b.n	11f34 <HAL_SD_Init+0xf4>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
   11f8a:	f44f 71af 	mov.w	r1, #350	; 0x15e
   11f8e:	480e      	ldr	r0, [pc, #56]	; (11fc8 <HAL_SD_Init+0x188>)
   11f90:	f007 fa96 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
   11f94:	6923      	ldr	r3, [r4, #16]
   11f96:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
   11f9a:	f43f af76 	beq.w	11e8a <HAL_SD_Init+0x4a>
   11f9e:	e7ea      	b.n	11f76 <HAL_SD_Init+0x136>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
   11fa0:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
   11fa2:	bf14      	ite	ne
   11fa4:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
   11fa8:	f44f 7380 	moveq.w	r3, #256	; 0x100
   11fac:	65e3      	str	r3, [r4, #92]	; 0x5c
   11fae:	e798      	b.n	11ee2 <HAL_SD_Init+0xa2>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
   11fb0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
      hsd->State= HAL_SD_STATE_READY;
   11fb4:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
   11fb6:	2503      	movs	r5, #3
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
   11fb8:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
   11fba:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
   11fbe:	e77d      	b.n	11ebc <HAL_SD_Init+0x7c>
   11fc0:	52007000 	.word	0x52007000
   11fc4:	48022400 	.word	0x48022400
   11fc8:	0003028c 	.word	0x0003028c

00011fcc <HAL_SD_GetCardState>:
{
   11fcc:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11fce:	6c81      	ldr	r1, [r0, #72]	; 0x48
{
   11fd0:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
   11fd2:	6800      	ldr	r0, [r0, #0]
   11fd4:	0409      	lsls	r1, r1, #16
   11fd6:	f002 faa9 	bl	1452c <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
   11fda:	4601      	mov	r1, r0
   11fdc:	b120      	cbz	r0, 11fe8 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
   11fde:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11fe0:	2000      	movs	r0, #0
   11fe2:	4319      	orrs	r1, r3
   11fe4:	63a1      	str	r1, [r4, #56]	; 0x38
}
   11fe6:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
   11fe8:	6820      	ldr	r0, [r4, #0]
   11fea:	f001 fdff 	bl	13bec <SDMMC_GetResponse>
   11fee:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
   11ff2:	bd10      	pop	{r4, pc}

00011ff4 <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
   11ff4:	b310      	cbz	r0, 1203c <HAL_SDRAM_Init+0x48>
{
   11ff6:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
   11ff8:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   11ffc:	4604      	mov	r4, r0
   11ffe:	460d      	mov	r5, r1
   12000:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   12004:	b1ab      	cbz	r3, 12032 <HAL_SDRAM_Init+0x3e>
    HAL_SDRAM_MspInit(hsdram);
#endif
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
   12006:	2302      	movs	r3, #2

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   12008:	1d21      	adds	r1, r4, #4
   1200a:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
   1200c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
   12010:	f001 fb3a 	bl	13688 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
   12014:	4629      	mov	r1, r5
   12016:	e9d4 0200 	ldrd	r0, r2, [r4]
   1201a:	f001 fbf9 	bl	13810 <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
   1201e:	4a08      	ldr	r2, [pc, #32]	; (12040 <HAL_SDRAM_Init+0x4c>)
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
   12020:	2101      	movs	r1, #1

  return HAL_OK;
   12022:	2000      	movs	r0, #0
  __FMC_ENABLE();
   12024:	6813      	ldr	r3, [r2, #0]
   12026:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1202a:	6013      	str	r3, [r2, #0]
  hsdram->State = HAL_SDRAM_STATE_READY;
   1202c:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
}
   12030:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
   12032:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
   12036:	f005 fe6b 	bl	17d10 <HAL_SDRAM_MspInit>
   1203a:	e7e4      	b.n	12006 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
   1203c:	2001      	movs	r0, #1
}
   1203e:	4770      	bx	lr
   12040:	52004000 	.word	0x52004000

00012044 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  HAL_SDRAM_StateTypeDef state = hsdram->State;
   12044:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   12048:	b2db      	uxtb	r3, r3
  
  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
   1204a:	2b02      	cmp	r3, #2
   1204c:	d015      	beq.n	1207a <HAL_SDRAM_SendCommand+0x36>
{
   1204e:	b570      	push	{r4, r5, r6, lr}
  {
    return HAL_BUSY;
  }
  else if((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
   12050:	f003 04fb 	and.w	r4, r3, #251	; 0xfb
   12054:	2c01      	cmp	r4, #1
   12056:	d001      	beq.n	1205c <HAL_SDRAM_SendCommand+0x18>
      hsdram->State = HAL_SDRAM_STATE_READY;
    }
  }
  else
  {
    return HAL_ERROR;
   12058:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
   1205a:	bd70      	pop	{r4, r5, r6, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   1205c:	2302      	movs	r3, #2
   1205e:	4605      	mov	r5, r0
   12060:	460e      	mov	r6, r1
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   12062:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   12064:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
   12068:	f001 fc7a 	bl	13960 <FMC_SDRAM_SendCommand>
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
   1206c:	6833      	ldr	r3, [r6, #0]
   1206e:	2b02      	cmp	r3, #2
   12070:	d005      	beq.n	1207e <HAL_SDRAM_SendCommand+0x3a>
      hsdram->State = HAL_SDRAM_STATE_READY;
   12072:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  return HAL_OK;
   12076:	2000      	movs	r0, #0
}
   12078:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
   1207a:	4618      	mov	r0, r3
}
   1207c:	4770      	bx	lr
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   1207e:	2305      	movs	r3, #5
  return HAL_OK;
   12080:	2000      	movs	r0, #0
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
   12082:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
}
   12086:	bd70      	pop	{r4, r5, r6, pc}

00012088 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
   12088:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
   1208a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   1208e:	b2db      	uxtb	r3, r3
   12090:	2b02      	cmp	r3, #2
   12092:	d006      	beq.n	120a2 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
   12094:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
   12098:	b2ed      	uxtb	r5, r5
   1209a:	2d01      	cmp	r5, #1
   1209c:	d003      	beq.n	120a6 <HAL_SDRAM_ProgramRefreshRate+0x1e>
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  else
  {
    return HAL_ERROR;
   1209e:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
   120a0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
   120a2:	4618      	mov	r0, r3
}
   120a4:	bd38      	pop	{r3, r4, r5, pc}
   120a6:	4604      	mov	r4, r0
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   120a8:	2302      	movs	r3, #2
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
   120aa:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
   120ac:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
   120b0:	f001 fca0 	bl	139f4 <FMC_SDRAM_ProgramRefreshRate>
    hsdram->State = HAL_SDRAM_STATE_READY;
   120b4:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
  return HAL_OK;
   120b8:	2000      	movs	r0, #0
}
   120ba:	bd38      	pop	{r3, r4, r5, pc}

000120bc <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
   120bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
   120c0:	6a02      	ldr	r2, [r0, #32]
{
   120c2:	460f      	mov	r7, r1
   120c4:	4604      	mov	r4, r0
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   120c6:	4b3b      	ldr	r3, [pc, #236]	; (121b4 <TIM_OC1_SetConfig+0xf8>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   120c8:	f022 0201 	bic.w	r2, r2, #1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   120cc:	493a      	ldr	r1, [pc, #232]	; (121b8 <TIM_OC1_SetConfig+0xfc>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   120ce:	6202      	str	r2, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   120d0:	428c      	cmp	r4, r1
  tmpccer = TIMx->CCER;
   120d2:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
   120d4:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
   120d8:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC1P;
   120da:	f025 0502 	bic.w	r5, r5, #2
  tmpccer |= OC_Config->OCPolarity;
   120de:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
   120e0:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= OC_Config->OCMode;
   120e4:	683e      	ldr	r6, [r7, #0]
  tmpccer |= OC_Config->OCPolarity;
   120e6:	ea45 0502 	orr.w	r5, r5, r2
  tmpccmrx |= OC_Config->OCMode;
   120ea:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   120ee:	d03a      	beq.n	12166 <TIM_OC1_SetConfig+0xaa>
   120f0:	4b32      	ldr	r3, [pc, #200]	; (121bc <TIM_OC1_SetConfig+0x100>)
   120f2:	429c      	cmp	r4, r3
   120f4:	d037      	beq.n	12166 <TIM_OC1_SetConfig+0xaa>
   120f6:	4a32      	ldr	r2, [pc, #200]	; (121c0 <TIM_OC1_SetConfig+0x104>)
   120f8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   120fc:	429c      	cmp	r4, r3
   120fe:	bf18      	it	ne
   12100:	4294      	cmpne	r4, r2
   12102:	d003      	beq.n	1210c <TIM_OC1_SetConfig+0x50>
   12104:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12108:	429c      	cmp	r4, r3
   1210a:	d144      	bne.n	12196 <TIM_OC1_SetConfig+0xda>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   1210c:	68fb      	ldr	r3, [r7, #12]
   1210e:	f025 0508 	bic.w	r5, r5, #8
   12112:	f033 0208 	bics.w	r2, r3, #8
   12116:	d02c      	beq.n	12172 <TIM_OC1_SetConfig+0xb6>
   12118:	f641 0106 	movw	r1, #6150	; 0x1806
   1211c:	4829      	ldr	r0, [pc, #164]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   1211e:	f007 f9cf 	bl	194c0 <assert_failed>

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
   12122:	68fb      	ldr	r3, [r7, #12]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12124:	4a26      	ldr	r2, [pc, #152]	; (121c0 <TIM_OC1_SetConfig+0x104>)
    tmpccer |= OC_Config->OCNPolarity;
   12126:	431d      	orrs	r5, r3
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12128:	4b27      	ldr	r3, [pc, #156]	; (121c8 <TIM_OC1_SetConfig+0x10c>)
   1212a:	429c      	cmp	r4, r3
   1212c:	bf18      	it	ne
   1212e:	4294      	cmpne	r4, r2
    tmpccer &= ~TIM_CCER_CC1NE;
   12130:	f025 0504 	bic.w	r5, r5, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12134:	d020      	beq.n	12178 <TIM_OC1_SetConfig+0xbc>
   12136:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   1213a:	429c      	cmp	r4, r3
   1213c:	d12b      	bne.n	12196 <TIM_OC1_SetConfig+0xda>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   1213e:	69bb      	ldr	r3, [r7, #24]
   12140:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12144:	d01c      	beq.n	12180 <TIM_OC1_SetConfig+0xc4>
   12146:	f641 0113 	movw	r1, #6163	; 0x1813
   1214a:	481e      	ldr	r0, [pc, #120]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   1214c:	f007 f9b8 	bl	194c0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12150:	697b      	ldr	r3, [r7, #20]
   12152:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12156:	d017      	beq.n	12188 <TIM_OC1_SetConfig+0xcc>
   12158:	f641 0114 	movw	r1, #6164	; 0x1814
   1215c:	4819      	ldr	r0, [pc, #100]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   1215e:	f007 f9af 	bl	194c0 <assert_failed>
   12162:	697b      	ldr	r3, [r7, #20]
   12164:	e010      	b.n	12188 <TIM_OC1_SetConfig+0xcc>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12166:	68fb      	ldr	r3, [r7, #12]
   12168:	f025 0508 	bic.w	r5, r5, #8
   1216c:	f033 0208 	bics.w	r2, r3, #8
   12170:	d119      	bne.n	121a6 <TIM_OC1_SetConfig+0xea>
    tmpccer |= OC_Config->OCNPolarity;
   12172:	431d      	orrs	r5, r3
    tmpccer &= ~TIM_CCER_CC1NE;
   12174:	f025 0504 	bic.w	r5, r5, #4
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12178:	69bb      	ldr	r3, [r7, #24]
   1217a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1217e:	d1e2      	bne.n	12146 <TIM_OC1_SetConfig+0x8a>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12180:	697b      	ldr	r3, [r7, #20]
   12182:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12186:	d1e7      	bne.n	12158 <TIM_OC1_SetConfig+0x9c>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
   12188:	f428 7840 	bic.w	r8, r8, #768	; 0x300
   1218c:	69ba      	ldr	r2, [r7, #24]
   1218e:	ea48 0802 	orr.w	r8, r8, r2
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
   12192:	ea48 0803 	orr.w	r8, r8, r3
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
   12196:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
   1219a:	61a6      	str	r6, [r4, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
   1219c:	687b      	ldr	r3, [r7, #4]
   1219e:	6363      	str	r3, [r4, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
   121a0:	6225      	str	r5, [r4, #32]
}
   121a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   121a6:	f641 0106 	movw	r1, #6150	; 0x1806
   121aa:	4806      	ldr	r0, [pc, #24]	; (121c4 <TIM_OC1_SetConfig+0x108>)
   121ac:	f007 f988 	bl	194c0 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
   121b0:	68fb      	ldr	r3, [r7, #12]
   121b2:	e7de      	b.n	12172 <TIM_OC1_SetConfig+0xb6>
   121b4:	fffeff8c 	.word	0xfffeff8c
   121b8:	40010000 	.word	0x40010000
   121bc:	40010400 	.word	0x40010400
   121c0:	40014000 	.word	0x40014000
   121c4:	000302c4 	.word	0x000302c4
   121c8:	40014400 	.word	0x40014400

000121cc <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
   121cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
   121d0:	6a03      	ldr	r3, [r0, #32]
{
   121d2:	460f      	mov	r7, r1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   121d4:	4931      	ldr	r1, [pc, #196]	; (1229c <TIM_OC3_SetConfig+0xd0>)
{
   121d6:	4604      	mov	r4, r0
  TIMx->CCER &= ~TIM_CCER_CC3E;
   121d8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   121dc:	4288      	cmp	r0, r1
  TIMx->CCER &= ~TIM_CCER_CC3E;
   121de:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
   121e0:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
   121e2:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
   121e6:	69c6      	ldr	r6, [r0, #28]
  tmpccer &= ~TIM_CCER_CC3P;
   121e8:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
   121ec:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
   121ee:	f026 0673 	bic.w	r6, r6, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
   121f2:	683b      	ldr	r3, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
   121f4:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccmrx |= OC_Config->OCMode;
   121f8:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   121fc:	d023      	beq.n	12246 <TIM_OC3_SetConfig+0x7a>
   121fe:	4b28      	ldr	r3, [pc, #160]	; (122a0 <TIM_OC3_SetConfig+0xd4>)
   12200:	4298      	cmp	r0, r3
   12202:	d020      	beq.n	12246 <TIM_OC3_SetConfig+0x7a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12204:	4a27      	ldr	r2, [pc, #156]	; (122a4 <TIM_OC3_SetConfig+0xd8>)
   12206:	4b28      	ldr	r3, [pc, #160]	; (122a8 <TIM_OC3_SetConfig+0xdc>)
   12208:	4298      	cmp	r0, r3
   1220a:	bf18      	it	ne
   1220c:	4290      	cmpne	r0, r2
   1220e:	d003      	beq.n	12218 <TIM_OC3_SetConfig+0x4c>
   12210:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12214:	4298      	cmp	r0, r3
   12216:	d10e      	bne.n	12236 <TIM_OC3_SetConfig+0x6a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12218:	69bb      	ldr	r3, [r7, #24]
   1221a:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   1221e:	d120      	bne.n	12262 <TIM_OC3_SetConfig+0x96>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12220:	697b      	ldr	r3, [r7, #20]
   12222:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12226:	d125      	bne.n	12274 <TIM_OC3_SetConfig+0xa8>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
   12228:	f428 5840 	bic.w	r8, r8, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   1222c:	69ba      	ldr	r2, [r7, #24]
   1222e:	ea48 1802 	orr.w	r8, r8, r2, lsl #4
   12232:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
   12236:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
   1223a:	61e6      	str	r6, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
   1223c:	687b      	ldr	r3, [r7, #4]
   1223e:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
   12240:	6225      	str	r5, [r4, #32]
}
   12242:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12246:	68fb      	ldr	r3, [r7, #12]
   12248:	f033 0208 	bics.w	r2, r3, #8
   1224c:	d119      	bne.n	12282 <TIM_OC3_SetConfig+0xb6>
    tmpccer &= ~TIM_CCER_CC3NP;
   1224e:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
   12252:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
   12256:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   1225a:	69bb      	ldr	r3, [r7, #24]
   1225c:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12260:	d0de      	beq.n	12220 <TIM_OC3_SetConfig+0x54>
   12262:	f641 01a9 	movw	r1, #6313	; 0x18a9
   12266:	4811      	ldr	r0, [pc, #68]	; (122ac <TIM_OC3_SetConfig+0xe0>)
   12268:	f007 f92a 	bl	194c0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1226c:	697b      	ldr	r3, [r7, #20]
   1226e:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12272:	d0d9      	beq.n	12228 <TIM_OC3_SetConfig+0x5c>
   12274:	f641 01aa 	movw	r1, #6314	; 0x18aa
   12278:	480c      	ldr	r0, [pc, #48]	; (122ac <TIM_OC3_SetConfig+0xe0>)
   1227a:	f007 f921 	bl	194c0 <assert_failed>
   1227e:	697b      	ldr	r3, [r7, #20]
   12280:	e7d2      	b.n	12228 <TIM_OC3_SetConfig+0x5c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12282:	f641 019c 	movw	r1, #6300	; 0x189c
   12286:	4809      	ldr	r0, [pc, #36]	; (122ac <TIM_OC3_SetConfig+0xe0>)
   12288:	f007 f91a 	bl	194c0 <assert_failed>
    tmpccer &= ~TIM_CCER_CC3NP;
   1228c:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
   12290:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
   12292:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
   12296:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
   1229a:	e7de      	b.n	1225a <TIM_OC3_SetConfig+0x8e>
   1229c:	40010000 	.word	0x40010000
   122a0:	40010400 	.word	0x40010400
   122a4:	40014000 	.word	0x40014000
   122a8:	40014400 	.word	0x40014400
   122ac:	000302c4 	.word	0x000302c4

000122b0 <HAL_TIM_Base_Init>:
  if (htim == NULL)
   122b0:	2800      	cmp	r0, #0
   122b2:	f000 80dd 	beq.w	12470 <HAL_TIM_Base_Init+0x1c0>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   122b6:	4b80      	ldr	r3, [pc, #512]	; (124b8 <HAL_TIM_Base_Init+0x208>)
   122b8:	4980      	ldr	r1, [pc, #512]	; (124bc <HAL_TIM_Base_Init+0x20c>)
{
   122ba:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   122bc:	6802      	ldr	r2, [r0, #0]
   122be:	4604      	mov	r4, r0
   122c0:	487f      	ldr	r0, [pc, #508]	; (124c0 <HAL_TIM_Base_Init+0x210>)
   122c2:	429a      	cmp	r2, r3
   122c4:	bf18      	it	ne
   122c6:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   122ca:	4d7e      	ldr	r5, [pc, #504]	; (124c4 <HAL_TIM_Base_Init+0x214>)
   122cc:	bf14      	ite	ne
   122ce:	2301      	movne	r3, #1
   122d0:	2300      	moveq	r3, #0
   122d2:	4282      	cmp	r2, r0
   122d4:	bf0c      	ite	eq
   122d6:	2300      	moveq	r3, #0
   122d8:	f003 0301 	andne.w	r3, r3, #1
   122dc:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   122e0:	428a      	cmp	r2, r1
   122e2:	bf0c      	ite	eq
   122e4:	2300      	moveq	r3, #0
   122e6:	f003 0301 	andne.w	r3, r3, #1
   122ea:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
   122ee:	42aa      	cmp	r2, r5
   122f0:	bf0c      	ite	eq
   122f2:	2300      	moveq	r3, #0
   122f4:	f003 0301 	andne.w	r3, r3, #1
   122f8:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
   122fc:	4282      	cmp	r2, r0
   122fe:	bf0c      	ite	eq
   12300:	2300      	moveq	r3, #0
   12302:	f003 0301 	andne.w	r3, r3, #1
   12306:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1230a:	428a      	cmp	r2, r1
   1230c:	bf0c      	ite	eq
   1230e:	2300      	moveq	r3, #0
   12310:	f003 0301 	andne.w	r3, r3, #1
   12314:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12318:	42aa      	cmp	r2, r5
   1231a:	bf0c      	ite	eq
   1231c:	2300      	moveq	r3, #0
   1231e:	f003 0301 	andne.w	r3, r3, #1
   12322:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
   12326:	4282      	cmp	r2, r0
   12328:	bf0c      	ite	eq
   1232a:	2300      	moveq	r3, #0
   1232c:	f003 0301 	andne.w	r3, r3, #1
   12330:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
   12334:	428a      	cmp	r2, r1
   12336:	bf0c      	ite	eq
   12338:	2300      	moveq	r3, #0
   1233a:	f003 0301 	andne.w	r3, r3, #1
   1233e:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
   12342:	42aa      	cmp	r2, r5
   12344:	bf0c      	ite	eq
   12346:	2300      	moveq	r3, #0
   12348:	f003 0301 	andne.w	r3, r3, #1
   1234c:	4282      	cmp	r2, r0
   1234e:	bf0c      	ite	eq
   12350:	2300      	moveq	r3, #0
   12352:	f003 0301 	andne.w	r3, r3, #1
   12356:	428a      	cmp	r2, r1
   12358:	bf0c      	ite	eq
   1235a:	2300      	moveq	r3, #0
   1235c:	f003 0301 	andne.w	r3, r3, #1
   12360:	b11b      	cbz	r3, 1236a <HAL_TIM_Base_Init+0xba>
   12362:	4b59      	ldr	r3, [pc, #356]	; (124c8 <HAL_TIM_Base_Init+0x218>)
   12364:	429a      	cmp	r2, r3
   12366:	f040 80a0 	bne.w	124aa <HAL_TIM_Base_Init+0x1fa>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1236a:	68a3      	ldr	r3, [r4, #8]
   1236c:	f023 0140 	bic.w	r1, r3, #64	; 0x40
   12370:	f023 0210 	bic.w	r2, r3, #16
   12374:	2920      	cmp	r1, #32
   12376:	bf18      	it	ne
   12378:	2a00      	cmpne	r2, #0
   1237a:	d002      	beq.n	12382 <HAL_TIM_Base_Init+0xd2>
   1237c:	2b40      	cmp	r3, #64	; 0x40
   1237e:	f040 8083 	bne.w	12488 <HAL_TIM_Base_Init+0x1d8>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   12382:	6923      	ldr	r3, [r4, #16]
   12384:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   12388:	d002      	beq.n	12390 <HAL_TIM_Base_Init+0xe0>
   1238a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1238e:	d171      	bne.n	12474 <HAL_TIM_Base_Init+0x1c4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   12390:	69a3      	ldr	r3, [r4, #24]
   12392:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   12396:	d15f      	bne.n	12458 <HAL_TIM_Base_Init+0x1a8>
  if (htim->State == HAL_TIM_STATE_RESET)
   12398:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   1239c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   123a0:	2b00      	cmp	r3, #0
   123a2:	d053      	beq.n	1244c <HAL_TIM_Base_Init+0x19c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
   123a4:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
   123a6:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   123a8:	4943      	ldr	r1, [pc, #268]	; (124b8 <HAL_TIM_Base_Init+0x208>)
   123aa:	4d48      	ldr	r5, [pc, #288]	; (124cc <HAL_TIM_Base_Init+0x21c>)
   123ac:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   123b0:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
   123b4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   123b8:	eba2 0505 	sub.w	r5, r2, r5
  tmpcr1 = TIMx->CR1;
   123bc:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   123be:	fab1 f181 	clz	r1, r1
   123c2:	fab5 f585 	clz	r5, r5
   123c6:	ea4f 1151 	mov.w	r1, r1, lsr #5
   123ca:	ea4f 1555 	mov.w	r5, r5, lsr #5
   123ce:	d018      	beq.n	12402 <HAL_TIM_Base_Init+0x152>
   123d0:	b9b9      	cbnz	r1, 12402 <HAL_TIM_Base_Init+0x152>
   123d2:	483b      	ldr	r0, [pc, #236]	; (124c0 <HAL_TIM_Base_Init+0x210>)
   123d4:	4282      	cmp	r2, r0
   123d6:	d014      	beq.n	12402 <HAL_TIM_Base_Init+0x152>
   123d8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   123dc:	4282      	cmp	r2, r0
   123de:	d010      	beq.n	12402 <HAL_TIM_Base_Init+0x152>
   123e0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   123e4:	4282      	cmp	r2, r0
   123e6:	d055      	beq.n	12494 <HAL_TIM_Base_Init+0x1e4>
   123e8:	2d00      	cmp	r5, #0
   123ea:	d153      	bne.n	12494 <HAL_TIM_Base_Init+0x1e4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   123ec:	4e38      	ldr	r6, [pc, #224]	; (124d0 <HAL_TIM_Base_Init+0x220>)
   123ee:	4839      	ldr	r0, [pc, #228]	; (124d4 <HAL_TIM_Base_Init+0x224>)
   123f0:	4282      	cmp	r2, r0
   123f2:	bf18      	it	ne
   123f4:	42b2      	cmpne	r2, r6
   123f6:	d008      	beq.n	1240a <HAL_TIM_Base_Init+0x15a>
   123f8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   123fc:	4282      	cmp	r2, r0
   123fe:	d108      	bne.n	12412 <HAL_TIM_Base_Init+0x162>
   12400:	e003      	b.n	1240a <HAL_TIM_Base_Init+0x15a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   12402:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   12406:	68a0      	ldr	r0, [r4, #8]
   12408:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
   1240a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
   1240e:	6920      	ldr	r0, [r4, #16]
   12410:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   12412:	69a0      	ldr	r0, [r4, #24]
   12414:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   12418:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
   1241a:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
   1241c:	68e3      	ldr	r3, [r4, #12]
   1241e:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
   12420:	6863      	ldr	r3, [r4, #4]
   12422:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   12424:	b951      	cbnz	r1, 1243c <HAL_TIM_Base_Init+0x18c>
   12426:	b94d      	cbnz	r5, 1243c <HAL_TIM_Base_Init+0x18c>
   12428:	4929      	ldr	r1, [pc, #164]	; (124d0 <HAL_TIM_Base_Init+0x220>)
   1242a:	4b2a      	ldr	r3, [pc, #168]	; (124d4 <HAL_TIM_Base_Init+0x224>)
   1242c:	429a      	cmp	r2, r3
   1242e:	bf18      	it	ne
   12430:	428a      	cmpne	r2, r1
   12432:	d003      	beq.n	1243c <HAL_TIM_Base_Init+0x18c>
   12434:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12438:	429a      	cmp	r2, r3
   1243a:	d101      	bne.n	12440 <HAL_TIM_Base_Init+0x190>
    TIMx->RCR = Structure->RepetitionCounter;
   1243c:	6963      	ldr	r3, [r4, #20]
   1243e:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
   12440:	2301      	movs	r3, #1
  return HAL_OK;
   12442:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
   12444:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
   12446:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
   1244a:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
   1244c:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
   12450:	4620      	mov	r0, r4
   12452:	f00f fca5 	bl	21da0 <HAL_TIM_Base_MspInit>
   12456:	e7a5      	b.n	123a4 <HAL_TIM_Base_Init+0xf4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   12458:	f44f 718c 	mov.w	r1, #280	; 0x118
   1245c:	481e      	ldr	r0, [pc, #120]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   1245e:	f007 f82f 	bl	194c0 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
   12462:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   12466:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1246a:	2b00      	cmp	r3, #0
   1246c:	d19a      	bne.n	123a4 <HAL_TIM_Base_Init+0xf4>
   1246e:	e7ed      	b.n	1244c <HAL_TIM_Base_Init+0x19c>
    return HAL_ERROR;
   12470:	2001      	movs	r0, #1
}
   12472:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   12474:	f240 1117 	movw	r1, #279	; 0x117
   12478:	4817      	ldr	r0, [pc, #92]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   1247a:	f007 f821 	bl	194c0 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1247e:	69a3      	ldr	r3, [r4, #24]
   12480:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   12484:	d088      	beq.n	12398 <HAL_TIM_Base_Init+0xe8>
   12486:	e7e7      	b.n	12458 <HAL_TIM_Base_Init+0x1a8>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   12488:	f44f 718b 	mov.w	r1, #278	; 0x116
   1248c:	4812      	ldr	r0, [pc, #72]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   1248e:	f007 f817 	bl	194c0 <assert_failed>
   12492:	e776      	b.n	12382 <HAL_TIM_Base_Init+0xd2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   12494:	480b      	ldr	r0, [pc, #44]	; (124c4 <HAL_TIM_Base_Init+0x214>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   12496:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   1249a:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   1249c:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
   1249e:	ea43 0306 	orr.w	r3, r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   124a2:	d0b2      	beq.n	1240a <HAL_TIM_Base_Init+0x15a>
   124a4:	2d00      	cmp	r5, #0
   124a6:	d1b0      	bne.n	1240a <HAL_TIM_Base_Init+0x15a>
   124a8:	e7a0      	b.n	123ec <HAL_TIM_Base_Init+0x13c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   124aa:	f240 1115 	movw	r1, #277	; 0x115
   124ae:	480a      	ldr	r0, [pc, #40]	; (124d8 <HAL_TIM_Base_Init+0x228>)
   124b0:	f007 f806 	bl	194c0 <assert_failed>
   124b4:	e759      	b.n	1236a <HAL_TIM_Base_Init+0xba>
   124b6:	bf00      	nop
   124b8:	40010000 	.word	0x40010000
   124bc:	40000800 	.word	0x40000800
   124c0:	40000400 	.word	0x40000400
   124c4:	40000c00 	.word	0x40000c00
   124c8:	40014800 	.word	0x40014800
   124cc:	40010400 	.word	0x40010400
   124d0:	40014000 	.word	0x40014000
   124d4:	40014400 	.word	0x40014400
   124d8:	000302c4 	.word	0x000302c4

000124dc <HAL_TIM_PWM_Init>:
  if (htim == NULL)
   124dc:	2800      	cmp	r0, #0
   124de:	f000 80dd 	beq.w	1269c <HAL_TIM_PWM_Init+0x1c0>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   124e2:	4b80      	ldr	r3, [pc, #512]	; (126e4 <HAL_TIM_PWM_Init+0x208>)
   124e4:	4980      	ldr	r1, [pc, #512]	; (126e8 <HAL_TIM_PWM_Init+0x20c>)
{
   124e6:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   124e8:	6802      	ldr	r2, [r0, #0]
   124ea:	4604      	mov	r4, r0
   124ec:	487f      	ldr	r0, [pc, #508]	; (126ec <HAL_TIM_PWM_Init+0x210>)
   124ee:	429a      	cmp	r2, r3
   124f0:	bf18      	it	ne
   124f2:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   124f6:	4d7e      	ldr	r5, [pc, #504]	; (126f0 <HAL_TIM_PWM_Init+0x214>)
   124f8:	bf14      	ite	ne
   124fa:	2301      	movne	r3, #1
   124fc:	2300      	moveq	r3, #0
   124fe:	4282      	cmp	r2, r0
   12500:	bf0c      	ite	eq
   12502:	2300      	moveq	r3, #0
   12504:	f003 0301 	andne.w	r3, r3, #1
   12508:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   1250c:	428a      	cmp	r2, r1
   1250e:	bf0c      	ite	eq
   12510:	2300      	moveq	r3, #0
   12512:	f003 0301 	andne.w	r3, r3, #1
   12516:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
   1251a:	42aa      	cmp	r2, r5
   1251c:	bf0c      	ite	eq
   1251e:	2300      	moveq	r3, #0
   12520:	f003 0301 	andne.w	r3, r3, #1
   12524:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
   12528:	4282      	cmp	r2, r0
   1252a:	bf0c      	ite	eq
   1252c:	2300      	moveq	r3, #0
   1252e:	f003 0301 	andne.w	r3, r3, #1
   12532:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12536:	428a      	cmp	r2, r1
   12538:	bf0c      	ite	eq
   1253a:	2300      	moveq	r3, #0
   1253c:	f003 0301 	andne.w	r3, r3, #1
   12540:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12544:	42aa      	cmp	r2, r5
   12546:	bf0c      	ite	eq
   12548:	2300      	moveq	r3, #0
   1254a:	f003 0301 	andne.w	r3, r3, #1
   1254e:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
   12552:	4282      	cmp	r2, r0
   12554:	bf0c      	ite	eq
   12556:	2300      	moveq	r3, #0
   12558:	f003 0301 	andne.w	r3, r3, #1
   1255c:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
   12560:	428a      	cmp	r2, r1
   12562:	bf0c      	ite	eq
   12564:	2300      	moveq	r3, #0
   12566:	f003 0301 	andne.w	r3, r3, #1
   1256a:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
   1256e:	42aa      	cmp	r2, r5
   12570:	bf0c      	ite	eq
   12572:	2300      	moveq	r3, #0
   12574:	f003 0301 	andne.w	r3, r3, #1
   12578:	4282      	cmp	r2, r0
   1257a:	bf0c      	ite	eq
   1257c:	2300      	moveq	r3, #0
   1257e:	f003 0301 	andne.w	r3, r3, #1
   12582:	428a      	cmp	r2, r1
   12584:	bf0c      	ite	eq
   12586:	2300      	moveq	r3, #0
   12588:	f003 0301 	andne.w	r3, r3, #1
   1258c:	b11b      	cbz	r3, 12596 <HAL_TIM_PWM_Init+0xba>
   1258e:	4b59      	ldr	r3, [pc, #356]	; (126f4 <HAL_TIM_PWM_Init+0x218>)
   12590:	429a      	cmp	r2, r3
   12592:	f040 80a0 	bne.w	126d6 <HAL_TIM_PWM_Init+0x1fa>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   12596:	68a3      	ldr	r3, [r4, #8]
   12598:	f023 0140 	bic.w	r1, r3, #64	; 0x40
   1259c:	f023 0210 	bic.w	r2, r3, #16
   125a0:	2920      	cmp	r1, #32
   125a2:	bf18      	it	ne
   125a4:	2a00      	cmpne	r2, #0
   125a6:	d002      	beq.n	125ae <HAL_TIM_PWM_Init+0xd2>
   125a8:	2b40      	cmp	r3, #64	; 0x40
   125aa:	f040 8083 	bne.w	126b4 <HAL_TIM_PWM_Init+0x1d8>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   125ae:	6923      	ldr	r3, [r4, #16]
   125b0:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   125b4:	d002      	beq.n	125bc <HAL_TIM_PWM_Init+0xe0>
   125b6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   125ba:	d171      	bne.n	126a0 <HAL_TIM_PWM_Init+0x1c4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   125bc:	69a3      	ldr	r3, [r4, #24]
   125be:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   125c2:	d15f      	bne.n	12684 <HAL_TIM_PWM_Init+0x1a8>
  if (htim->State == HAL_TIM_STATE_RESET)
   125c4:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   125c8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   125cc:	2b00      	cmp	r3, #0
   125ce:	d053      	beq.n	12678 <HAL_TIM_PWM_Init+0x19c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
   125d0:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
   125d2:	2302      	movs	r3, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   125d4:	4943      	ldr	r1, [pc, #268]	; (126e4 <HAL_TIM_PWM_Init+0x208>)
   125d6:	4d48      	ldr	r5, [pc, #288]	; (126f8 <HAL_TIM_PWM_Init+0x21c>)
   125d8:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   125dc:	eba2 0101 	sub.w	r1, r2, r1
  htim->State = HAL_TIM_STATE_BUSY;
   125e0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   125e4:	eba2 0505 	sub.w	r5, r2, r5
  tmpcr1 = TIMx->CR1;
   125e8:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   125ea:	fab1 f181 	clz	r1, r1
   125ee:	fab5 f585 	clz	r5, r5
   125f2:	ea4f 1151 	mov.w	r1, r1, lsr #5
   125f6:	ea4f 1555 	mov.w	r5, r5, lsr #5
   125fa:	d018      	beq.n	1262e <HAL_TIM_PWM_Init+0x152>
   125fc:	b9b9      	cbnz	r1, 1262e <HAL_TIM_PWM_Init+0x152>
   125fe:	483b      	ldr	r0, [pc, #236]	; (126ec <HAL_TIM_PWM_Init+0x210>)
   12600:	4282      	cmp	r2, r0
   12602:	d014      	beq.n	1262e <HAL_TIM_PWM_Init+0x152>
   12604:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   12608:	4282      	cmp	r2, r0
   1260a:	d010      	beq.n	1262e <HAL_TIM_PWM_Init+0x152>
   1260c:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   12610:	4282      	cmp	r2, r0
   12612:	d055      	beq.n	126c0 <HAL_TIM_PWM_Init+0x1e4>
   12614:	2d00      	cmp	r5, #0
   12616:	d153      	bne.n	126c0 <HAL_TIM_PWM_Init+0x1e4>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   12618:	4e38      	ldr	r6, [pc, #224]	; (126fc <HAL_TIM_PWM_Init+0x220>)
   1261a:	4839      	ldr	r0, [pc, #228]	; (12700 <HAL_TIM_PWM_Init+0x224>)
   1261c:	4282      	cmp	r2, r0
   1261e:	bf18      	it	ne
   12620:	42b2      	cmpne	r2, r6
   12622:	d008      	beq.n	12636 <HAL_TIM_PWM_Init+0x15a>
   12624:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   12628:	4282      	cmp	r2, r0
   1262a:	d108      	bne.n	1263e <HAL_TIM_PWM_Init+0x162>
   1262c:	e003      	b.n	12636 <HAL_TIM_PWM_Init+0x15a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   1262e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   12632:	68a0      	ldr	r0, [r4, #8]
   12634:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
   12636:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
   1263a:	6920      	ldr	r0, [r4, #16]
   1263c:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   1263e:	69a0      	ldr	r0, [r4, #24]
   12640:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   12644:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
   12646:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
   12648:	68e3      	ldr	r3, [r4, #12]
   1264a:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
   1264c:	6863      	ldr	r3, [r4, #4]
   1264e:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   12650:	b951      	cbnz	r1, 12668 <HAL_TIM_PWM_Init+0x18c>
   12652:	b94d      	cbnz	r5, 12668 <HAL_TIM_PWM_Init+0x18c>
   12654:	4929      	ldr	r1, [pc, #164]	; (126fc <HAL_TIM_PWM_Init+0x220>)
   12656:	4b2a      	ldr	r3, [pc, #168]	; (12700 <HAL_TIM_PWM_Init+0x224>)
   12658:	429a      	cmp	r2, r3
   1265a:	bf18      	it	ne
   1265c:	428a      	cmpne	r2, r1
   1265e:	d003      	beq.n	12668 <HAL_TIM_PWM_Init+0x18c>
   12660:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12664:	429a      	cmp	r2, r3
   12666:	d101      	bne.n	1266c <HAL_TIM_PWM_Init+0x190>
    TIMx->RCR = Structure->RepetitionCounter;
   12668:	6963      	ldr	r3, [r4, #20]
   1266a:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
   1266c:	2301      	movs	r3, #1
  return HAL_OK;
   1266e:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
   12670:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
   12672:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
   12676:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
   12678:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
   1267c:	4620      	mov	r0, r4
   1267e:	f00f fb75 	bl	21d6c <HAL_TIM_PWM_MspInit>
   12682:	e7a5      	b.n	125d0 <HAL_TIM_PWM_Init+0xf4>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   12684:	f240 41a5 	movw	r1, #1189	; 0x4a5
   12688:	481e      	ldr	r0, [pc, #120]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   1268a:	f006 ff19 	bl	194c0 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
   1268e:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   12692:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   12696:	2b00      	cmp	r3, #0
   12698:	d19a      	bne.n	125d0 <HAL_TIM_PWM_Init+0xf4>
   1269a:	e7ed      	b.n	12678 <HAL_TIM_PWM_Init+0x19c>
    return HAL_ERROR;
   1269c:	2001      	movs	r0, #1
}
   1269e:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   126a0:	f240 41a4 	movw	r1, #1188	; 0x4a4
   126a4:	4817      	ldr	r0, [pc, #92]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   126a6:	f006 ff0b 	bl	194c0 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   126aa:	69a3      	ldr	r3, [r4, #24]
   126ac:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   126b0:	d088      	beq.n	125c4 <HAL_TIM_PWM_Init+0xe8>
   126b2:	e7e7      	b.n	12684 <HAL_TIM_PWM_Init+0x1a8>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   126b4:	f240 41a3 	movw	r1, #1187	; 0x4a3
   126b8:	4812      	ldr	r0, [pc, #72]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   126ba:	f006 ff01 	bl	194c0 <assert_failed>
   126be:	e776      	b.n	125ae <HAL_TIM_PWM_Init+0xd2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   126c0:	480b      	ldr	r0, [pc, #44]	; (126f0 <HAL_TIM_PWM_Init+0x214>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   126c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
   126c6:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   126c8:	4282      	cmp	r2, r0
    tmpcr1 |= Structure->CounterMode;
   126ca:	ea43 0306 	orr.w	r3, r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   126ce:	d0b2      	beq.n	12636 <HAL_TIM_PWM_Init+0x15a>
   126d0:	2d00      	cmp	r5, #0
   126d2:	d1b0      	bne.n	12636 <HAL_TIM_PWM_Init+0x15a>
   126d4:	e7a0      	b.n	12618 <HAL_TIM_PWM_Init+0x13c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
   126d6:	f240 41a2 	movw	r1, #1186	; 0x4a2
   126da:	480a      	ldr	r0, [pc, #40]	; (12704 <HAL_TIM_PWM_Init+0x228>)
   126dc:	f006 fef0 	bl	194c0 <assert_failed>
   126e0:	e759      	b.n	12596 <HAL_TIM_PWM_Init+0xba>
   126e2:	bf00      	nop
   126e4:	40010000 	.word	0x40010000
   126e8:	40000800 	.word	0x40000800
   126ec:	40000400 	.word	0x40000400
   126f0:	40000c00 	.word	0x40000c00
   126f4:	40014800 	.word	0x40014800
   126f8:	40010400 	.word	0x40010400
   126fc:	40014000 	.word	0x40014000
   12700:	40014400 	.word	0x40014400
   12704:	000302c4 	.word	0x000302c4

00012708 <HAL_TIM_PWM_Start>:
{
   12708:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1270a:	4b66      	ldr	r3, [pc, #408]	; (128a4 <HAL_TIM_PWM_Start+0x19c>)
{
   1270c:	4606      	mov	r6, r0
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1270e:	6804      	ldr	r4, [r0, #0]
{
   12710:	460d      	mov	r5, r1
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   12712:	429c      	cmp	r4, r3
   12714:	f000 8093 	beq.w	1283e <HAL_TIM_PWM_Start+0x136>
   12718:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   1271c:	f000 8089 	beq.w	12832 <HAL_TIM_PWM_Start+0x12a>
   12720:	4b61      	ldr	r3, [pc, #388]	; (128a8 <HAL_TIM_PWM_Start+0x1a0>)
   12722:	429c      	cmp	r4, r3
   12724:	f000 8085 	beq.w	12832 <HAL_TIM_PWM_Start+0x12a>
   12728:	4b60      	ldr	r3, [pc, #384]	; (128ac <HAL_TIM_PWM_Start+0x1a4>)
   1272a:	429c      	cmp	r4, r3
   1272c:	f000 8081 	beq.w	12832 <HAL_TIM_PWM_Start+0x12a>
   12730:	4b5f      	ldr	r3, [pc, #380]	; (128b0 <HAL_TIM_PWM_Start+0x1a8>)
   12732:	429c      	cmp	r4, r3
   12734:	d07d      	beq.n	12832 <HAL_TIM_PWM_Start+0x12a>
   12736:	4b5f      	ldr	r3, [pc, #380]	; (128b4 <HAL_TIM_PWM_Start+0x1ac>)
   12738:	429c      	cmp	r4, r3
   1273a:	f000 8092 	beq.w	12862 <HAL_TIM_PWM_Start+0x15a>
   1273e:	4b5e      	ldr	r3, [pc, #376]	; (128b8 <HAL_TIM_PWM_Start+0x1b0>)
   12740:	429c      	cmp	r4, r3
   12742:	f000 8096 	beq.w	12872 <HAL_TIM_PWM_Start+0x16a>
   12746:	4b5d      	ldr	r3, [pc, #372]	; (128bc <HAL_TIM_PWM_Start+0x1b4>)
   12748:	429c      	cmp	r4, r3
   1274a:	f040 8097 	bne.w	1287c <HAL_TIM_PWM_Start+0x174>
   1274e:	b1d5      	cbz	r5, 12786 <HAL_TIM_PWM_Start+0x7e>
   12750:	f240 511c 	movw	r1, #1308	; 0x51c
   12754:	485a      	ldr	r0, [pc, #360]	; (128c0 <HAL_TIM_PWM_Start+0x1b8>)
   12756:	f006 feb3 	bl	194c0 <assert_failed>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1275a:	6834      	ldr	r4, [r6, #0]
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   1275c:	4b51      	ldr	r3, [pc, #324]	; (128a4 <HAL_TIM_PWM_Start+0x19c>)
   1275e:	429c      	cmp	r4, r3
   12760:	d02d      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12762:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   12766:	d02a      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12768:	f5a3 437c 	sub.w	r3, r3, #64512	; 0xfc00
   1276c:	429c      	cmp	r4, r3
   1276e:	d026      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12770:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12774:	429c      	cmp	r4, r3
   12776:	d022      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12778:	4b4d      	ldr	r3, [pc, #308]	; (128b0 <HAL_TIM_PWM_Start+0x1a8>)
   1277a:	429c      	cmp	r4, r3
   1277c:	d01f      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   1277e:	f503 4378 	add.w	r3, r3, #63488	; 0xf800
   12782:	429c      	cmp	r4, r3
   12784:	d01b      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12786:	4b4c      	ldr	r3, [pc, #304]	; (128b8 <HAL_TIM_PWM_Start+0x1b0>)
   12788:	429c      	cmp	r4, r3
   1278a:	d018      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   1278c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12790:	429c      	cmp	r4, r3
   12792:	d014      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   12794:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12798:	429c      	cmp	r4, r3
   1279a:	d010      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   1279c:	f503 3390 	add.w	r3, r3, #73728	; 0x12000
   127a0:	429c      	cmp	r4, r3
   127a2:	d00c      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   127a4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   127a8:	429c      	cmp	r4, r3
   127aa:	d008      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   127ac:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   127b0:	429c      	cmp	r4, r3
   127b2:	d004      	beq.n	127be <HAL_TIM_PWM_Start+0xb6>
   127b4:	f641 3154 	movw	r1, #6996	; 0x1b54
   127b8:	4841      	ldr	r0, [pc, #260]	; (128c0 <HAL_TIM_PWM_Start+0x1b8>)
   127ba:	f006 fe81 	bl	194c0 <assert_failed>
  assert_param(IS_TIM_CHANNELS(Channel));
   127be:	2d14      	cmp	r5, #20
   127c0:	d943      	bls.n	1284a <HAL_TIM_PWM_Start+0x142>
   127c2:	2d3c      	cmp	r5, #60	; 0x3c
   127c4:	d147      	bne.n	12856 <HAL_TIM_PWM_Start+0x14e>

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   127c6:	2301      	movs	r3, #1
   127c8:	f005 051f 	and.w	r5, r5, #31

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
   127cc:	6a21      	ldr	r1, [r4, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   127ce:	fa03 f505 	lsl.w	r5, r3, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127d2:	4a34      	ldr	r2, [pc, #208]	; (128a4 <HAL_TIM_PWM_Start+0x19c>)
   127d4:	4f37      	ldr	r7, [pc, #220]	; (128b4 <HAL_TIM_PWM_Start+0x1ac>)
  TIMx->CCER &= ~tmp;
   127d6:	ea21 0105 	bic.w	r1, r1, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127da:	483a      	ldr	r0, [pc, #232]	; (128c4 <HAL_TIM_PWM_Start+0x1bc>)
  TIMx->CCER &= ~tmp;
   127dc:	6221      	str	r1, [r4, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   127de:	6a23      	ldr	r3, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127e0:	4939      	ldr	r1, [pc, #228]	; (128c8 <HAL_TIM_PWM_Start+0x1c0>)
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   127e2:	431d      	orrs	r5, r3
   127e4:	6225      	str	r5, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   127e6:	6833      	ldr	r3, [r6, #0]
   127e8:	42bb      	cmp	r3, r7
   127ea:	bf18      	it	ne
   127ec:	4293      	cmpne	r3, r2
   127ee:	bf0c      	ite	eq
   127f0:	2201      	moveq	r2, #1
   127f2:	2200      	movne	r2, #0
   127f4:	4283      	cmp	r3, r0
   127f6:	bf08      	it	eq
   127f8:	f042 0201 	orreq.w	r2, r2, #1
   127fc:	428b      	cmp	r3, r1
   127fe:	bf08      	it	eq
   12800:	f042 0201 	orreq.w	r2, r2, #1
   12804:	b912      	cbnz	r2, 1280c <HAL_TIM_PWM_Start+0x104>
   12806:	4a31      	ldr	r2, [pc, #196]	; (128cc <HAL_TIM_PWM_Start+0x1c4>)
   12808:	4293      	cmp	r3, r2
   1280a:	d104      	bne.n	12816 <HAL_TIM_PWM_Start+0x10e>
    __HAL_TIM_MOE_ENABLE(htim);
   1280c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   1280e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   12812:	645a      	str	r2, [r3, #68]	; 0x44
   12814:	6833      	ldr	r3, [r6, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   12816:	6899      	ldr	r1, [r3, #8]
   12818:	4a2d      	ldr	r2, [pc, #180]	; (128d0 <HAL_TIM_PWM_Start+0x1c8>)
   1281a:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1281c:	2a06      	cmp	r2, #6
   1281e:	d006      	beq.n	1282e <HAL_TIM_PWM_Start+0x126>
   12820:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
   12824:	d003      	beq.n	1282e <HAL_TIM_PWM_Start+0x126>
    __HAL_TIM_ENABLE(htim);
   12826:	681a      	ldr	r2, [r3, #0]
   12828:	f042 0201 	orr.w	r2, r2, #1
   1282c:	601a      	str	r2, [r3, #0]
}
   1282e:	2000      	movs	r0, #0
   12830:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   12832:	f035 030c 	bics.w	r3, r5, #12
   12836:	d18b      	bne.n	12750 <HAL_TIM_PWM_Start+0x48>
  assert_param(IS_TIM_CHANNELS(Channel));
   12838:	2d14      	cmp	r5, #20
   1283a:	d8c2      	bhi.n	127c2 <HAL_TIM_PWM_Start+0xba>
   1283c:	e005      	b.n	1284a <HAL_TIM_PWM_Start+0x142>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1283e:	2914      	cmp	r1, #20
   12840:	d886      	bhi.n	12750 <HAL_TIM_PWM_Start+0x48>
   12842:	4b24      	ldr	r3, [pc, #144]	; (128d4 <HAL_TIM_PWM_Start+0x1cc>)
   12844:	40cb      	lsrs	r3, r1
   12846:	07d9      	lsls	r1, r3, #31
   12848:	d582      	bpl.n	12750 <HAL_TIM_PWM_Start+0x48>
  assert_param(IS_TIM_CHANNELS(Channel));
   1284a:	4b22      	ldr	r3, [pc, #136]	; (128d4 <HAL_TIM_PWM_Start+0x1cc>)
   1284c:	40eb      	lsrs	r3, r5
   1284e:	07db      	lsls	r3, r3, #31
   12850:	d4b9      	bmi.n	127c6 <HAL_TIM_PWM_Start+0xbe>
   12852:	2d3c      	cmp	r5, #60	; 0x3c
   12854:	d0b7      	beq.n	127c6 <HAL_TIM_PWM_Start+0xbe>
   12856:	f641 3155 	movw	r1, #6997	; 0x1b55
   1285a:	4819      	ldr	r0, [pc, #100]	; (128c0 <HAL_TIM_PWM_Start+0x1b8>)
   1285c:	f006 fe30 	bl	194c0 <assert_failed>
   12860:	e7b1      	b.n	127c6 <HAL_TIM_PWM_Start+0xbe>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   12862:	2914      	cmp	r1, #20
   12864:	f63f af74 	bhi.w	12750 <HAL_TIM_PWM_Start+0x48>
   12868:	4b1a      	ldr	r3, [pc, #104]	; (128d4 <HAL_TIM_PWM_Start+0x1cc>)
   1286a:	40cb      	lsrs	r3, r1
   1286c:	07da      	lsls	r2, r3, #31
   1286e:	d4a6      	bmi.n	127be <HAL_TIM_PWM_Start+0xb6>
   12870:	e76e      	b.n	12750 <HAL_TIM_PWM_Start+0x48>
   12872:	f035 0304 	bics.w	r3, r5, #4
   12876:	f47f af6b 	bne.w	12750 <HAL_TIM_PWM_Start+0x48>
   1287a:	e784      	b.n	12786 <HAL_TIM_PWM_Start+0x7e>
   1287c:	4b16      	ldr	r3, [pc, #88]	; (128d8 <HAL_TIM_PWM_Start+0x1d0>)
   1287e:	429c      	cmp	r4, r3
   12880:	f43f af65 	beq.w	1274e <HAL_TIM_PWM_Start+0x46>
   12884:	4b0f      	ldr	r3, [pc, #60]	; (128c4 <HAL_TIM_PWM_Start+0x1bc>)
   12886:	429c      	cmp	r4, r3
   12888:	d0f3      	beq.n	12872 <HAL_TIM_PWM_Start+0x16a>
   1288a:	4b0f      	ldr	r3, [pc, #60]	; (128c8 <HAL_TIM_PWM_Start+0x1c0>)
   1288c:	429c      	cmp	r4, r3
   1288e:	f43f af5e 	beq.w	1274e <HAL_TIM_PWM_Start+0x46>
   12892:	4b0e      	ldr	r3, [pc, #56]	; (128cc <HAL_TIM_PWM_Start+0x1c4>)
   12894:	429c      	cmp	r4, r3
   12896:	f47f af5b 	bne.w	12750 <HAL_TIM_PWM_Start+0x48>
   1289a:	2900      	cmp	r1, #0
   1289c:	f47f af58 	bne.w	12750 <HAL_TIM_PWM_Start+0x48>
   128a0:	461c      	mov	r4, r3
   128a2:	e769      	b.n	12778 <HAL_TIM_PWM_Start+0x70>
   128a4:	40010000 	.word	0x40010000
   128a8:	40000400 	.word	0x40000400
   128ac:	40000800 	.word	0x40000800
   128b0:	40000c00 	.word	0x40000c00
   128b4:	40010400 	.word	0x40010400
   128b8:	40001800 	.word	0x40001800
   128bc:	40001c00 	.word	0x40001c00
   128c0:	000302c4 	.word	0x000302c4
   128c4:	40014000 	.word	0x40014000
   128c8:	40014400 	.word	0x40014400
   128cc:	40014800 	.word	0x40014800
   128d0:	00010007 	.word	0x00010007
   128d4:	00111111 	.word	0x00111111
   128d8:	40002000 	.word	0x40002000

000128dc <HAL_TIM_ConfigClockSource>:
{
   128dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
   128de:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
   128e2:	2b01      	cmp	r3, #1
   128e4:	f000 8186 	beq.w	12bf4 <HAL_TIM_ConfigClockSource+0x318>
   128e8:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
   128ea:	2302      	movs	r3, #2
   128ec:	460d      	mov	r5, r1
   128ee:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
   128f0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
   128f4:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   128f8:	680b      	ldr	r3, [r1, #0]
   128fa:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   128fe:	bf18      	it	ne
   12900:	f5b3 5f00 	cmpne.w	r3, #8192	; 0x2000
   12904:	bf14      	ite	ne
   12906:	2201      	movne	r2, #1
   12908:	2200      	moveq	r2, #0
   1290a:	f033 0330 	bics.w	r3, r3, #48	; 0x30
   1290e:	bf08      	it	eq
   12910:	2200      	moveq	r2, #0
   12912:	b112      	cbz	r2, 1291a <HAL_TIM_ConfigClockSource+0x3e>
   12914:	2b40      	cmp	r3, #64	; 0x40
   12916:	f040 8262 	bne.w	12dde <HAL_TIM_ConfigClockSource+0x502>
  tmpsmcr = htim->Instance->SMCR;
   1291a:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   1291c:	4bb6      	ldr	r3, [pc, #728]	; (12bf8 <HAL_TIM_ConfigClockSource+0x31c>)
  tmpsmcr = htim->Instance->SMCR;
   1291e:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   12920:	400b      	ands	r3, r1
  htim->Instance->SMCR = tmpsmcr;
   12922:	6093      	str	r3, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
   12924:	682b      	ldr	r3, [r5, #0]
   12926:	2b70      	cmp	r3, #112	; 0x70
   12928:	f000 8178 	beq.w	12c1c <HAL_TIM_ConfigClockSource+0x340>
   1292c:	d85c      	bhi.n	129e8 <HAL_TIM_ConfigClockSource+0x10c>
   1292e:	2b30      	cmp	r3, #48	; 0x30
   12930:	f000 820f 	beq.w	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12934:	f240 8206 	bls.w	12d44 <HAL_TIM_ConfigClockSource+0x468>
   12938:	2b50      	cmp	r3, #80	; 0x50
   1293a:	f000 81b4 	beq.w	12ca6 <HAL_TIM_ConfigClockSource+0x3ca>
   1293e:	2b60      	cmp	r3, #96	; 0x60
   12940:	f000 80c3 	beq.w	12aca <HAL_TIM_ConfigClockSource+0x1ee>
   12944:	2b40      	cmp	r3, #64	; 0x40
   12946:	f040 80b8 	bne.w	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   1294a:	6822      	ldr	r2, [r4, #0]
   1294c:	4bab      	ldr	r3, [pc, #684]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   1294e:	48ac      	ldr	r0, [pc, #688]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12950:	429a      	cmp	r2, r3
   12952:	bf18      	it	ne
   12954:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12958:	49aa      	ldr	r1, [pc, #680]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   1295a:	bf14      	ite	ne
   1295c:	2301      	movne	r3, #1
   1295e:	2300      	moveq	r3, #0
   12960:	4282      	cmp	r2, r0
   12962:	bf0c      	ite	eq
   12964:	2300      	moveq	r3, #0
   12966:	f003 0301 	andne.w	r3, r3, #1
   1296a:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   1296e:	428a      	cmp	r2, r1
   12970:	bf0c      	ite	eq
   12972:	2300      	moveq	r3, #0
   12974:	f003 0301 	andne.w	r3, r3, #1
   12978:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   1297c:	4282      	cmp	r2, r0
   1297e:	bf0c      	ite	eq
   12980:	2300      	moveq	r3, #0
   12982:	f003 0301 	andne.w	r3, r3, #1
   12986:	428a      	cmp	r2, r1
   12988:	bf0c      	ite	eq
   1298a:	2300      	moveq	r3, #0
   1298c:	f003 0301 	andne.w	r3, r3, #1
   12990:	b11b      	cbz	r3, 1299a <HAL_TIM_ConfigClockSource+0xbe>
   12992:	4b9d      	ldr	r3, [pc, #628]	; (12c08 <HAL_TIM_ConfigClockSource+0x32c>)
   12994:	429a      	cmp	r2, r3
   12996:	f040 825a 	bne.w	12e4e <HAL_TIM_ConfigClockSource+0x572>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   1299a:	686b      	ldr	r3, [r5, #4]
   1299c:	2b0a      	cmp	r3, #10
   1299e:	bf18      	it	ne
   129a0:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   129a4:	d003      	beq.n	129ae <HAL_TIM_ConfigClockSource+0xd2>
   129a6:	f033 0302 	bics.w	r3, r3, #2
   129aa:	f040 821e 	bne.w	12dea <HAL_TIM_ConfigClockSource+0x50e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   129ae:	68ee      	ldr	r6, [r5, #12]
   129b0:	2e0f      	cmp	r6, #15
   129b2:	f200 826e 	bhi.w	12e92 <HAL_TIM_ConfigClockSource+0x5b6>
      TIM_TI1_ConfigInputStage(htim->Instance,
   129b6:	6823      	ldr	r3, [r4, #0]
   129b8:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
   129ba:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
   129bc:	6a1d      	ldr	r5, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   129be:	f022 020a 	bic.w	r2, r2, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
   129c2:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
   129c6:	4310      	orrs	r0, r2
  tmpsmcr &= ~TIM_SMCR_TS;
   129c8:	4a90      	ldr	r2, [pc, #576]	; (12c0c <HAL_TIM_ConfigClockSource+0x330>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   129ca:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
   129cc:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
   129ce:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
   129d2:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
   129d6:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
   129d8:	6218      	str	r0, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   129da:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   129dc:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   129de:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   129e0:	f042 0247 	orr.w	r2, r2, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
   129e4:	609a      	str	r2, [r3, #8]
   129e6:	e068      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
   129e8:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
   129ec:	f000 81b1 	beq.w	12d52 <HAL_TIM_ConfigClockSource+0x476>
   129f0:	f200 81de 	bhi.w	12db0 <HAL_TIM_ConfigClockSource+0x4d4>
   129f4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   129f8:	f000 80b7 	beq.w	12b6a <HAL_TIM_ConfigClockSource+0x28e>
   129fc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   12a00:	f000 81a7 	beq.w	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12a04:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   12a08:	d157      	bne.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
   12a0a:	6822      	ldr	r2, [r4, #0]
   12a0c:	4b7b      	ldr	r3, [pc, #492]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   12a0e:	487c      	ldr	r0, [pc, #496]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12a10:	429a      	cmp	r2, r3
   12a12:	bf18      	it	ne
   12a14:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12a18:	497a      	ldr	r1, [pc, #488]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   12a1a:	4d7d      	ldr	r5, [pc, #500]	; (12c10 <HAL_TIM_ConfigClockSource+0x334>)
   12a1c:	bf14      	ite	ne
   12a1e:	2301      	movne	r3, #1
   12a20:	2300      	moveq	r3, #0
   12a22:	4282      	cmp	r2, r0
   12a24:	bf0c      	ite	eq
   12a26:	2300      	moveq	r3, #0
   12a28:	f003 0301 	andne.w	r3, r3, #1
   12a2c:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   12a30:	428a      	cmp	r2, r1
   12a32:	bf0c      	ite	eq
   12a34:	2300      	moveq	r3, #0
   12a36:	f003 0301 	andne.w	r3, r3, #1
   12a3a:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
   12a3e:	42aa      	cmp	r2, r5
   12a40:	bf0c      	ite	eq
   12a42:	2300      	moveq	r3, #0
   12a44:	f003 0301 	andne.w	r3, r3, #1
   12a48:	f505 4578 	add.w	r5, r5, #63488	; 0xf800
   12a4c:	4282      	cmp	r2, r0
   12a4e:	bf0c      	ite	eq
   12a50:	2300      	moveq	r3, #0
   12a52:	f003 0301 	andne.w	r3, r3, #1
   12a56:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12a5a:	428a      	cmp	r2, r1
   12a5c:	bf0c      	ite	eq
   12a5e:	2300      	moveq	r3, #0
   12a60:	f003 0301 	andne.w	r3, r3, #1
   12a64:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12a68:	42aa      	cmp	r2, r5
   12a6a:	bf0c      	ite	eq
   12a6c:	2300      	moveq	r3, #0
   12a6e:	f003 0301 	andne.w	r3, r3, #1
   12a72:	f5a5 4564 	sub.w	r5, r5, #58368	; 0xe400
   12a76:	4282      	cmp	r2, r0
   12a78:	bf0c      	ite	eq
   12a7a:	2300      	moveq	r3, #0
   12a7c:	f003 0301 	andne.w	r3, r3, #1
   12a80:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
   12a84:	428a      	cmp	r2, r1
   12a86:	bf0c      	ite	eq
   12a88:	2300      	moveq	r3, #0
   12a8a:	f003 0301 	andne.w	r3, r3, #1
   12a8e:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
   12a92:	42aa      	cmp	r2, r5
   12a94:	bf0c      	ite	eq
   12a96:	2300      	moveq	r3, #0
   12a98:	f003 0301 	andne.w	r3, r3, #1
   12a9c:	4282      	cmp	r2, r0
   12a9e:	bf0c      	ite	eq
   12aa0:	2300      	moveq	r3, #0
   12aa2:	f003 0301 	andne.w	r3, r3, #1
   12aa6:	428a      	cmp	r2, r1
   12aa8:	bf0c      	ite	eq
   12aaa:	2300      	moveq	r3, #0
   12aac:	f003 0301 	andne.w	r3, r3, #1
   12ab0:	b11b      	cbz	r3, 12aba <HAL_TIM_ConfigClockSource+0x1de>
   12ab2:	4b58      	ldr	r3, [pc, #352]	; (12c14 <HAL_TIM_ConfigClockSource+0x338>)
   12ab4:	429a      	cmp	r2, r3
   12ab6:	f040 81ff 	bne.w	12eb8 <HAL_TIM_ConfigClockSource+0x5dc>
  __HAL_UNLOCK(htim);
   12aba:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   12abc:	2201      	movs	r2, #1
  return HAL_OK;
   12abe:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   12ac0:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   12ac4:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   12ac8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12aca:	6822      	ldr	r2, [r4, #0]
   12acc:	4b4b      	ldr	r3, [pc, #300]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   12ace:	484c      	ldr	r0, [pc, #304]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12ad0:	429a      	cmp	r2, r3
   12ad2:	bf18      	it	ne
   12ad4:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12ad8:	494a      	ldr	r1, [pc, #296]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   12ada:	bf14      	ite	ne
   12adc:	2301      	movne	r3, #1
   12ade:	2300      	moveq	r3, #0
   12ae0:	4282      	cmp	r2, r0
   12ae2:	bf0c      	ite	eq
   12ae4:	2300      	moveq	r3, #0
   12ae6:	f003 0301 	andne.w	r3, r3, #1
   12aea:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12aee:	428a      	cmp	r2, r1
   12af0:	bf0c      	ite	eq
   12af2:	2300      	moveq	r3, #0
   12af4:	f003 0301 	andne.w	r3, r3, #1
   12af8:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   12afc:	4282      	cmp	r2, r0
   12afe:	bf0c      	ite	eq
   12b00:	2300      	moveq	r3, #0
   12b02:	f003 0301 	andne.w	r3, r3, #1
   12b06:	428a      	cmp	r2, r1
   12b08:	bf0c      	ite	eq
   12b0a:	2300      	moveq	r3, #0
   12b0c:	f003 0301 	andne.w	r3, r3, #1
   12b10:	b11b      	cbz	r3, 12b1a <HAL_TIM_ConfigClockSource+0x23e>
   12b12:	4b3d      	ldr	r3, [pc, #244]	; (12c08 <HAL_TIM_ConfigClockSource+0x32c>)
   12b14:	429a      	cmp	r2, r3
   12b16:	f040 8194 	bne.w	12e42 <HAL_TIM_ConfigClockSource+0x566>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12b1a:	686b      	ldr	r3, [r5, #4]
   12b1c:	2b0a      	cmp	r3, #10
   12b1e:	bf18      	it	ne
   12b20:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12b24:	d003      	beq.n	12b2e <HAL_TIM_ConfigClockSource+0x252>
   12b26:	f033 0302 	bics.w	r3, r3, #2
   12b2a:	f040 8164 	bne.w	12df6 <HAL_TIM_ConfigClockSource+0x51a>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12b2e:	68ee      	ldr	r6, [r5, #12]
   12b30:	2e0f      	cmp	r6, #15
   12b32:	f200 81a7 	bhi.w	12e84 <HAL_TIM_ConfigClockSource+0x5a8>
      TIM_TI2_ConfigInputStage(htim->Instance,
   12b36:	6823      	ldr	r3, [r4, #0]
   12b38:	686f      	ldr	r7, [r5, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12b3a:	6a1d      	ldr	r5, [r3, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
   12b3c:	4a33      	ldr	r2, [pc, #204]	; (12c0c <HAL_TIM_ConfigClockSource+0x330>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12b3e:	f025 0510 	bic.w	r5, r5, #16
   12b42:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
   12b44:	6998      	ldr	r0, [r3, #24]
  tmpccer = TIMx->CCER;
   12b46:	6a19      	ldr	r1, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
   12b48:	f420 4070 	bic.w	r0, r0, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   12b4c:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
   12b50:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
   12b54:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
   12b58:	6198      	str	r0, [r3, #24]
  TIMx->CCER = tmpccer;
   12b5a:	6219      	str	r1, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   12b5c:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   12b5e:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   12b60:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12b62:	f042 0267 	orr.w	r2, r2, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
   12b66:	609a      	str	r2, [r3, #8]
   12b68:	e7a7      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   12b6a:	6822      	ldr	r2, [r4, #0]
   12b6c:	4b23      	ldr	r3, [pc, #140]	; (12bfc <HAL_TIM_ConfigClockSource+0x320>)
   12b6e:	4924      	ldr	r1, [pc, #144]	; (12c00 <HAL_TIM_ConfigClockSource+0x324>)
   12b70:	429a      	cmp	r2, r3
   12b72:	bf18      	it	ne
   12b74:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12b78:	4822      	ldr	r0, [pc, #136]	; (12c04 <HAL_TIM_ConfigClockSource+0x328>)
   12b7a:	bf14      	ite	ne
   12b7c:	2301      	movne	r3, #1
   12b7e:	2300      	moveq	r3, #0
   12b80:	428a      	cmp	r2, r1
   12b82:	bf0c      	ite	eq
   12b84:	2300      	moveq	r3, #0
   12b86:	f003 0301 	andne.w	r3, r3, #1
   12b8a:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12b8e:	4282      	cmp	r2, r0
   12b90:	bf0c      	ite	eq
   12b92:	2300      	moveq	r3, #0
   12b94:	f003 0301 	andne.w	r3, r3, #1
   12b98:	428a      	cmp	r2, r1
   12b9a:	bf0c      	ite	eq
   12b9c:	2300      	moveq	r3, #0
   12b9e:	f003 0301 	andne.w	r3, r3, #1
   12ba2:	b11b      	cbz	r3, 12bac <HAL_TIM_ConfigClockSource+0x2d0>
   12ba4:	4b1c      	ldr	r3, [pc, #112]	; (12c18 <HAL_TIM_ConfigClockSource+0x33c>)
   12ba6:	429a      	cmp	r2, r3
   12ba8:	f040 810d 	bne.w	12dc6 <HAL_TIM_ConfigClockSource+0x4ea>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12bac:	68ab      	ldr	r3, [r5, #8]
   12bae:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
   12bb2:	f040 8175 	bne.w	12ea0 <HAL_TIM_ConfigClockSource+0x5c4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12bb6:	686b      	ldr	r3, [r5, #4]
   12bb8:	2b0a      	cmp	r3, #10
   12bba:	bf18      	it	ne
   12bbc:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12bc0:	d003      	beq.n	12bca <HAL_TIM_ConfigClockSource+0x2ee>
   12bc2:	f033 0302 	bics.w	r3, r3, #2
   12bc6:	f040 8122 	bne.w	12e0e <HAL_TIM_ConfigClockSource+0x532>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12bca:	68e9      	ldr	r1, [r5, #12]
   12bcc:	290f      	cmp	r1, #15
   12bce:	f200 8144 	bhi.w	12e5a <HAL_TIM_ConfigClockSource+0x57e>
      TIM_ETR_SetConfig(htim->Instance,
   12bd2:	6820      	ldr	r0, [r4, #0]
   12bd4:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
   12bd6:	6882      	ldr	r2, [r0, #8]
   12bd8:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   12bda:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   12bde:	432b      	orrs	r3, r5
   12be0:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   12be2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
   12be6:	6083      	str	r3, [r0, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
   12be8:	6822      	ldr	r2, [r4, #0]
   12bea:	6893      	ldr	r3, [r2, #8]
   12bec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   12bf0:	6093      	str	r3, [r2, #8]
      break;
   12bf2:	e762      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  __HAL_LOCK(htim);
   12bf4:	2002      	movs	r0, #2
}
   12bf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12bf8:	ffce0088 	.word	0xffce0088
   12bfc:	40010000 	.word	0x40010000
   12c00:	40000400 	.word	0x40000400
   12c04:	40000800 	.word	0x40000800
   12c08:	40014000 	.word	0x40014000
   12c0c:	ffcfff8f 	.word	0xffcfff8f
   12c10:	40000c00 	.word	0x40000c00
   12c14:	40014800 	.word	0x40014800
   12c18:	40010400 	.word	0x40010400
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   12c1c:	6822      	ldr	r2, [r4, #0]
   12c1e:	4ba9      	ldr	r3, [pc, #676]	; (12ec4 <HAL_TIM_ConfigClockSource+0x5e8>)
   12c20:	49a9      	ldr	r1, [pc, #676]	; (12ec8 <HAL_TIM_ConfigClockSource+0x5ec>)
   12c22:	429a      	cmp	r2, r3
   12c24:	bf18      	it	ne
   12c26:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12c2a:	48a8      	ldr	r0, [pc, #672]	; (12ecc <HAL_TIM_ConfigClockSource+0x5f0>)
   12c2c:	bf14      	ite	ne
   12c2e:	2301      	movne	r3, #1
   12c30:	2300      	moveq	r3, #0
   12c32:	428a      	cmp	r2, r1
   12c34:	bf0c      	ite	eq
   12c36:	2300      	moveq	r3, #0
   12c38:	f003 0301 	andne.w	r3, r3, #1
   12c3c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   12c40:	4282      	cmp	r2, r0
   12c42:	bf0c      	ite	eq
   12c44:	2300      	moveq	r3, #0
   12c46:	f003 0301 	andne.w	r3, r3, #1
   12c4a:	428a      	cmp	r2, r1
   12c4c:	bf0c      	ite	eq
   12c4e:	2300      	moveq	r3, #0
   12c50:	f003 0301 	andne.w	r3, r3, #1
   12c54:	b11b      	cbz	r3, 12c5e <HAL_TIM_ConfigClockSource+0x382>
   12c56:	4b9e      	ldr	r3, [pc, #632]	; (12ed0 <HAL_TIM_ConfigClockSource+0x5f4>)
   12c58:	429a      	cmp	r2, r3
   12c5a:	f040 80ba 	bne.w	12dd2 <HAL_TIM_ConfigClockSource+0x4f6>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12c5e:	68ab      	ldr	r3, [r5, #8]
   12c60:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
   12c64:	f040 8122 	bne.w	12eac <HAL_TIM_ConfigClockSource+0x5d0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12c68:	686b      	ldr	r3, [r5, #4]
   12c6a:	2b0a      	cmp	r3, #10
   12c6c:	bf18      	it	ne
   12c6e:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12c72:	d003      	beq.n	12c7c <HAL_TIM_ConfigClockSource+0x3a0>
   12c74:	f033 0302 	bics.w	r3, r3, #2
   12c78:	f040 80c3 	bne.w	12e02 <HAL_TIM_ConfigClockSource+0x526>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12c7c:	68e9      	ldr	r1, [r5, #12]
   12c7e:	290f      	cmp	r1, #15
   12c80:	f200 80f9 	bhi.w	12e76 <HAL_TIM_ConfigClockSource+0x59a>
      TIM_ETR_SetConfig(htim->Instance,
   12c84:	6820      	ldr	r0, [r4, #0]
   12c86:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
   12c88:	6882      	ldr	r2, [r0, #8]
   12c8a:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   12c8c:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
   12c90:	432b      	orrs	r3, r5
   12c92:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   12c94:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
   12c98:	6083      	str	r3, [r0, #8]
      tmpsmcr = htim->Instance->SMCR;
   12c9a:	6822      	ldr	r2, [r4, #0]
   12c9c:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   12c9e:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
   12ca2:	6093      	str	r3, [r2, #8]
      break;
   12ca4:	e709      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12ca6:	6822      	ldr	r2, [r4, #0]
   12ca8:	4b86      	ldr	r3, [pc, #536]	; (12ec4 <HAL_TIM_ConfigClockSource+0x5e8>)
   12caa:	4887      	ldr	r0, [pc, #540]	; (12ec8 <HAL_TIM_ConfigClockSource+0x5ec>)
   12cac:	429a      	cmp	r2, r3
   12cae:	bf18      	it	ne
   12cb0:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   12cb4:	4985      	ldr	r1, [pc, #532]	; (12ecc <HAL_TIM_ConfigClockSource+0x5f0>)
   12cb6:	bf14      	ite	ne
   12cb8:	2301      	movne	r3, #1
   12cba:	2300      	moveq	r3, #0
   12cbc:	4282      	cmp	r2, r0
   12cbe:	bf0c      	ite	eq
   12cc0:	2300      	moveq	r3, #0
   12cc2:	f003 0301 	andne.w	r3, r3, #1
   12cc6:	f500 6000 	add.w	r0, r0, #2048	; 0x800
   12cca:	428a      	cmp	r2, r1
   12ccc:	bf0c      	ite	eq
   12cce:	2300      	moveq	r3, #0
   12cd0:	f003 0301 	andne.w	r3, r3, #1
   12cd4:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   12cd8:	4282      	cmp	r2, r0
   12cda:	bf0c      	ite	eq
   12cdc:	2300      	moveq	r3, #0
   12cde:	f003 0301 	andne.w	r3, r3, #1
   12ce2:	428a      	cmp	r2, r1
   12ce4:	bf0c      	ite	eq
   12ce6:	2300      	moveq	r3, #0
   12ce8:	f003 0301 	andne.w	r3, r3, #1
   12cec:	b11b      	cbz	r3, 12cf6 <HAL_TIM_ConfigClockSource+0x41a>
   12cee:	4b79      	ldr	r3, [pc, #484]	; (12ed4 <HAL_TIM_ConfigClockSource+0x5f8>)
   12cf0:	429a      	cmp	r2, r3
   12cf2:	f040 8098 	bne.w	12e26 <HAL_TIM_ConfigClockSource+0x54a>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12cf6:	686b      	ldr	r3, [r5, #4]
   12cf8:	2b0a      	cmp	r3, #10
   12cfa:	bf18      	it	ne
   12cfc:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
   12d00:	d003      	beq.n	12d0a <HAL_TIM_ConfigClockSource+0x42e>
   12d02:	f033 0302 	bics.w	r3, r3, #2
   12d06:	f040 8088 	bne.w	12e1a <HAL_TIM_ConfigClockSource+0x53e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12d0a:	68ee      	ldr	r6, [r5, #12]
   12d0c:	2e0f      	cmp	r6, #15
   12d0e:	f200 80ab 	bhi.w	12e68 <HAL_TIM_ConfigClockSource+0x58c>
      TIM_TI1_ConfigInputStage(htim->Instance,
   12d12:	6823      	ldr	r3, [r4, #0]
   12d14:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
   12d16:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
   12d18:	6a1d      	ldr	r5, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   12d1a:	f022 020a 	bic.w	r2, r2, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
   12d1e:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
   12d22:	4310      	orrs	r0, r2
  tmpsmcr &= ~TIM_SMCR_TS;
   12d24:	4a6c      	ldr	r2, [pc, #432]	; (12ed8 <HAL_TIM_ConfigClockSource+0x5fc>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
   12d26:	621d      	str	r5, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
   12d28:	6999      	ldr	r1, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
   12d2a:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
   12d2e:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
   12d32:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
   12d34:	6218      	str	r0, [r3, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   12d36:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = TIMx->SMCR;
   12d38:	6899      	ldr	r1, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
   12d3a:	400a      	ands	r2, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12d3c:	f042 0257 	orr.w	r2, r2, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
   12d40:	609a      	str	r2, [r3, #8]
   12d42:	e6ba      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
   12d44:	2b10      	cmp	r3, #16
   12d46:	d004      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12d48:	2b20      	cmp	r3, #32
   12d4a:	d002      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12d4c:	2b00      	cmp	r3, #0
   12d4e:	f47f aeb4 	bne.w	12aba <HAL_TIM_ConfigClockSource+0x1de>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   12d52:	6821      	ldr	r1, [r4, #0]
   12d54:	4a5b      	ldr	r2, [pc, #364]	; (12ec4 <HAL_TIM_ConfigClockSource+0x5e8>)
   12d56:	4e5c      	ldr	r6, [pc, #368]	; (12ec8 <HAL_TIM_ConfigClockSource+0x5ec>)
   12d58:	4291      	cmp	r1, r2
   12d5a:	bf18      	it	ne
   12d5c:	f1b1 4f80 	cmpne.w	r1, #1073741824	; 0x40000000
   12d60:	485a      	ldr	r0, [pc, #360]	; (12ecc <HAL_TIM_ConfigClockSource+0x5f0>)
   12d62:	bf14      	ite	ne
   12d64:	2201      	movne	r2, #1
   12d66:	2200      	moveq	r2, #0
   12d68:	42b1      	cmp	r1, r6
   12d6a:	bf0c      	ite	eq
   12d6c:	2200      	moveq	r2, #0
   12d6e:	f002 0201 	andne.w	r2, r2, #1
   12d72:	f506 6600 	add.w	r6, r6, #2048	; 0x800
   12d76:	4281      	cmp	r1, r0
   12d78:	bf0c      	ite	eq
   12d7a:	2200      	moveq	r2, #0
   12d7c:	f002 0201 	andne.w	r2, r2, #1
   12d80:	f500 407c 	add.w	r0, r0, #64512	; 0xfc00
   12d84:	42b1      	cmp	r1, r6
   12d86:	bf0c      	ite	eq
   12d88:	2200      	moveq	r2, #0
   12d8a:	f002 0201 	andne.w	r2, r2, #1
   12d8e:	4281      	cmp	r1, r0
   12d90:	bf0c      	ite	eq
   12d92:	2200      	moveq	r2, #0
   12d94:	f002 0201 	andne.w	r2, r2, #1
   12d98:	b112      	cbz	r2, 12da0 <HAL_TIM_ConfigClockSource+0x4c4>
   12d9a:	4a4e      	ldr	r2, [pc, #312]	; (12ed4 <HAL_TIM_ConfigClockSource+0x5f8>)
   12d9c:	4291      	cmp	r1, r2
   12d9e:	d148      	bne.n	12e32 <HAL_TIM_ConfigClockSource+0x556>
  tmpsmcr = TIMx->SMCR;
   12da0:	6888      	ldr	r0, [r1, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12da2:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
   12da6:	4a4c      	ldr	r2, [pc, #304]	; (12ed8 <HAL_TIM_ConfigClockSource+0x5fc>)
   12da8:	4002      	ands	r2, r0
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   12daa:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
   12dac:	608b      	str	r3, [r1, #8]
   12dae:	e684      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
  switch (sClockSourceConfig->ClockSource)
   12db0:	4a4a      	ldr	r2, [pc, #296]	; (12edc <HAL_TIM_ConfigClockSource+0x600>)
   12db2:	4293      	cmp	r3, r2
   12db4:	d0cd      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12db6:	3210      	adds	r2, #16
   12db8:	4293      	cmp	r3, r2
   12dba:	d0ca      	beq.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
   12dbc:	3a20      	subs	r2, #32
   12dbe:	4293      	cmp	r3, r2
   12dc0:	f47f ae7b 	bne.w	12aba <HAL_TIM_ConfigClockSource+0x1de>
   12dc4:	e7c5      	b.n	12d52 <HAL_TIM_ConfigClockSource+0x476>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   12dc6:	f241 21ab 	movw	r1, #4779	; 0x12ab
   12dca:	4845      	ldr	r0, [pc, #276]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12dcc:	f006 fb78 	bl	194c0 <assert_failed>
   12dd0:	e6ec      	b.n	12bac <HAL_TIM_ConfigClockSource+0x2d0>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   12dd2:	f241 2193 	movw	r1, #4755	; 0x1293
   12dd6:	4842      	ldr	r0, [pc, #264]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12dd8:	f006 fb72 	bl	194c0 <assert_failed>
   12ddc:	e73f      	b.n	12c5e <HAL_TIM_ConfigClockSource+0x382>
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   12dde:	f44f 5194 	mov.w	r1, #4736	; 0x1280
   12de2:	483f      	ldr	r0, [pc, #252]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12de4:	f006 fb6c 	bl	194c0 <assert_failed>
   12de8:	e597      	b.n	1291a <HAL_TIM_ConfigClockSource+0x3e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12dea:	f241 21e2 	movw	r1, #4834	; 0x12e2
   12dee:	483c      	ldr	r0, [pc, #240]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12df0:	f006 fb66 	bl	194c0 <assert_failed>
   12df4:	e5db      	b.n	129ae <HAL_TIM_ConfigClockSource+0xd2>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12df6:	f241 21d2 	movw	r1, #4818	; 0x12d2
   12dfa:	4839      	ldr	r0, [pc, #228]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12dfc:	f006 fb60 	bl	194c0 <assert_failed>
   12e00:	e695      	b.n	12b2e <HAL_TIM_ConfigClockSource+0x252>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12e02:	f241 2197 	movw	r1, #4759	; 0x1297
   12e06:	4836      	ldr	r0, [pc, #216]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e08:	f006 fb5a 	bl	194c0 <assert_failed>
   12e0c:	e736      	b.n	12c7c <HAL_TIM_ConfigClockSource+0x3a0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12e0e:	f241 21af 	movw	r1, #4783	; 0x12af
   12e12:	4833      	ldr	r0, [pc, #204]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e14:	f006 fb54 	bl	194c0 <assert_failed>
   12e18:	e6d7      	b.n	12bca <HAL_TIM_ConfigClockSource+0x2ee>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   12e1a:	f241 21c2 	movw	r1, #4802	; 0x12c2
   12e1e:	4830      	ldr	r0, [pc, #192]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e20:	f006 fb4e 	bl	194c0 <assert_failed>
   12e24:	e771      	b.n	12d0a <HAL_TIM_ConfigClockSource+0x42e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12e26:	f241 21bf 	movw	r1, #4799	; 0x12bf
   12e2a:	482d      	ldr	r0, [pc, #180]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e2c:	f006 fb48 	bl	194c0 <assert_failed>
   12e30:	e761      	b.n	12cf6 <HAL_TIM_ConfigClockSource+0x41a>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   12e32:	f241 21f7 	movw	r1, #4855	; 0x12f7
   12e36:	482a      	ldr	r0, [pc, #168]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e38:	f006 fb42 	bl	194c0 <assert_failed>
   12e3c:	682b      	ldr	r3, [r5, #0]
   12e3e:	6821      	ldr	r1, [r4, #0]
   12e40:	e7ae      	b.n	12da0 <HAL_TIM_ConfigClockSource+0x4c4>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12e42:	f241 21cf 	movw	r1, #4815	; 0x12cf
   12e46:	4826      	ldr	r0, [pc, #152]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e48:	f006 fb3a 	bl	194c0 <assert_failed>
   12e4c:	e665      	b.n	12b1a <HAL_TIM_ConfigClockSource+0x23e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   12e4e:	f241 21df 	movw	r1, #4831	; 0x12df
   12e52:	4823      	ldr	r0, [pc, #140]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e54:	f006 fb34 	bl	194c0 <assert_failed>
   12e58:	e59f      	b.n	1299a <HAL_TIM_ConfigClockSource+0xbe>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e5a:	f241 21b0 	movw	r1, #4784	; 0x12b0
   12e5e:	4820      	ldr	r0, [pc, #128]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e60:	f006 fb2e 	bl	194c0 <assert_failed>
   12e64:	68e9      	ldr	r1, [r5, #12]
   12e66:	e6b4      	b.n	12bd2 <HAL_TIM_ConfigClockSource+0x2f6>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e68:	f241 21c3 	movw	r1, #4803	; 0x12c3
   12e6c:	481c      	ldr	r0, [pc, #112]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e6e:	f006 fb27 	bl	194c0 <assert_failed>
   12e72:	68ee      	ldr	r6, [r5, #12]
   12e74:	e74d      	b.n	12d12 <HAL_TIM_ConfigClockSource+0x436>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e76:	f241 2198 	movw	r1, #4760	; 0x1298
   12e7a:	4819      	ldr	r0, [pc, #100]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e7c:	f006 fb20 	bl	194c0 <assert_failed>
   12e80:	68e9      	ldr	r1, [r5, #12]
   12e82:	e6ff      	b.n	12c84 <HAL_TIM_ConfigClockSource+0x3a8>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e84:	f241 21d3 	movw	r1, #4819	; 0x12d3
   12e88:	4815      	ldr	r0, [pc, #84]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e8a:	f006 fb19 	bl	194c0 <assert_failed>
   12e8e:	68ee      	ldr	r6, [r5, #12]
   12e90:	e651      	b.n	12b36 <HAL_TIM_ConfigClockSource+0x25a>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   12e92:	f241 21e3 	movw	r1, #4835	; 0x12e3
   12e96:	4812      	ldr	r0, [pc, #72]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12e98:	f006 fb12 	bl	194c0 <assert_failed>
   12e9c:	68ee      	ldr	r6, [r5, #12]
   12e9e:	e58a      	b.n	129b6 <HAL_TIM_ConfigClockSource+0xda>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12ea0:	f241 21ae 	movw	r1, #4782	; 0x12ae
   12ea4:	480e      	ldr	r0, [pc, #56]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12ea6:	f006 fb0b 	bl	194c0 <assert_failed>
   12eaa:	e684      	b.n	12bb6 <HAL_TIM_ConfigClockSource+0x2da>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   12eac:	f241 2196 	movw	r1, #4758	; 0x1296
   12eb0:	480b      	ldr	r0, [pc, #44]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12eb2:	f006 fb05 	bl	194c0 <assert_failed>
   12eb6:	e6d7      	b.n	12c68 <HAL_TIM_ConfigClockSource+0x38c>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
   12eb8:	f241 218c 	movw	r1, #4748	; 0x128c
   12ebc:	4808      	ldr	r0, [pc, #32]	; (12ee0 <HAL_TIM_ConfigClockSource+0x604>)
   12ebe:	f006 faff 	bl	194c0 <assert_failed>
   12ec2:	e5fa      	b.n	12aba <HAL_TIM_ConfigClockSource+0x1de>
   12ec4:	40010000 	.word	0x40010000
   12ec8:	40000400 	.word	0x40000400
   12ecc:	40000800 	.word	0x40000800
   12ed0:	40010400 	.word	0x40010400
   12ed4:	40014000 	.word	0x40014000
   12ed8:	ffcfff8f 	.word	0xffcfff8f
   12edc:	00100030 	.word	0x00100030
   12ee0:	000302c4 	.word	0x000302c4

00012ee4 <TIM_OC2_SetConfig>:
{
   12ee4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12ee8:	6a02      	ldr	r2, [r0, #32]
{
   12eea:	460e      	mov	r6, r1
   12eec:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   12eee:	4b31      	ldr	r3, [pc, #196]	; (12fb4 <TIM_OC2_SetConfig+0xd0>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12ef0:	f022 0210 	bic.w	r2, r2, #16
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   12ef4:	4930      	ldr	r1, [pc, #192]	; (12fb8 <TIM_OC2_SetConfig+0xd4>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
   12ef6:	6202      	str	r2, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   12ef8:	428c      	cmp	r4, r1
  tmpccer = TIMx->CCER;
   12efa:	6a05      	ldr	r5, [r0, #32]
  tmpcr2 =  TIMx->CR2;
   12efc:	6847      	ldr	r7, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
   12efe:	6982      	ldr	r2, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
   12f00:	f025 0520 	bic.w	r5, r5, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
   12f04:	68b0      	ldr	r0, [r6, #8]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
   12f06:	ea03 0302 	and.w	r3, r3, r2
  tmpccmrx |= (OC_Config->OCMode << 8U);
   12f0a:	6832      	ldr	r2, [r6, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
   12f0c:	ea45 1500 	orr.w	r5, r5, r0, lsl #4
  tmpccmrx |= (OC_Config->OCMode << 8U);
   12f10:	ea43 2802 	orr.w	r8, r3, r2, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   12f14:	d023      	beq.n	12f5e <TIM_OC2_SetConfig+0x7a>
   12f16:	4b29      	ldr	r3, [pc, #164]	; (12fbc <TIM_OC2_SetConfig+0xd8>)
   12f18:	429c      	cmp	r4, r3
   12f1a:	d020      	beq.n	12f5e <TIM_OC2_SetConfig+0x7a>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   12f1c:	4a28      	ldr	r2, [pc, #160]	; (12fc0 <TIM_OC2_SetConfig+0xdc>)
   12f1e:	4b29      	ldr	r3, [pc, #164]	; (12fc4 <TIM_OC2_SetConfig+0xe0>)
   12f20:	429c      	cmp	r4, r3
   12f22:	bf18      	it	ne
   12f24:	4294      	cmpne	r4, r2
   12f26:	d003      	beq.n	12f30 <TIM_OC2_SetConfig+0x4c>
   12f28:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   12f2c:	429c      	cmp	r4, r3
   12f2e:	d10e      	bne.n	12f4e <TIM_OC2_SetConfig+0x6a>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12f30:	69b3      	ldr	r3, [r6, #24]
   12f32:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12f36:	d120      	bne.n	12f7a <TIM_OC2_SetConfig+0x96>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12f38:	6971      	ldr	r1, [r6, #20]
   12f3a:	f431 7380 	bics.w	r3, r1, #256	; 0x100
   12f3e:	d125      	bne.n	12f8c <TIM_OC2_SetConfig+0xa8>
    tmpcr2 &= ~TIM_CR2_OIS2N;
   12f40:	f427 6240 	bic.w	r2, r7, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   12f44:	69b3      	ldr	r3, [r6, #24]
   12f46:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
   12f4a:	ea42 0781 	orr.w	r7, r2, r1, lsl #2
  TIMx->CR2 = tmpcr2;
   12f4e:	6067      	str	r7, [r4, #4]
  TIMx->CCMR1 = tmpccmrx;
   12f50:	f8c4 8018 	str.w	r8, [r4, #24]
  TIMx->CCR2 = OC_Config->Pulse;
   12f54:	6873      	ldr	r3, [r6, #4]
   12f56:	63a3      	str	r3, [r4, #56]	; 0x38
  TIMx->CCER = tmpccer;
   12f58:	6225      	str	r5, [r4, #32]
}
   12f5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12f5e:	68f3      	ldr	r3, [r6, #12]
   12f60:	f033 0208 	bics.w	r2, r3, #8
   12f64:	d119      	bne.n	12f9a <TIM_OC2_SetConfig+0xb6>
    tmpccer &= ~TIM_CCER_CC2NP;
   12f66:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
   12f6a:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
   12f6e:	f025 0540 	bic.w	r5, r5, #64	; 0x40
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   12f72:	69b3      	ldr	r3, [r6, #24]
   12f74:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   12f78:	d0de      	beq.n	12f38 <TIM_OC2_SetConfig+0x54>
   12f7a:	f641 015f 	movw	r1, #6239	; 0x185f
   12f7e:	4812      	ldr	r0, [pc, #72]	; (12fc8 <TIM_OC2_SetConfig+0xe4>)
   12f80:	f006 fa9e 	bl	194c0 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   12f84:	6971      	ldr	r1, [r6, #20]
   12f86:	f431 7380 	bics.w	r3, r1, #256	; 0x100
   12f8a:	d0d9      	beq.n	12f40 <TIM_OC2_SetConfig+0x5c>
   12f8c:	f44f 51c3 	mov.w	r1, #6240	; 0x1860
   12f90:	480d      	ldr	r0, [pc, #52]	; (12fc8 <TIM_OC2_SetConfig+0xe4>)
   12f92:	f006 fa95 	bl	194c0 <assert_failed>
   12f96:	6971      	ldr	r1, [r6, #20]
   12f98:	e7d2      	b.n	12f40 <TIM_OC2_SetConfig+0x5c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   12f9a:	f641 0151 	movw	r1, #6225	; 0x1851
   12f9e:	480a      	ldr	r0, [pc, #40]	; (12fc8 <TIM_OC2_SetConfig+0xe4>)
   12fa0:	f006 fa8e 	bl	194c0 <assert_failed>
    tmpccer &= ~TIM_CCER_CC2NP;
   12fa4:	f025 0580 	bic.w	r5, r5, #128	; 0x80
   12fa8:	68f3      	ldr	r3, [r6, #12]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
   12faa:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
   12fae:	f025 0540 	bic.w	r5, r5, #64	; 0x40
   12fb2:	e7de      	b.n	12f72 <TIM_OC2_SetConfig+0x8e>
   12fb4:	feff8cff 	.word	0xfeff8cff
   12fb8:	40010000 	.word	0x40010000
   12fbc:	40010400 	.word	0x40010400
   12fc0:	40014000 	.word	0x40014000
   12fc4:	40014400 	.word	0x40014400
   12fc8:	000302c4 	.word	0x000302c4

00012fcc <HAL_TIM_PWM_ConfigChannel>:
  assert_param(IS_TIM_CHANNELS(Channel));
   12fcc:	2a14      	cmp	r2, #20
{
   12fce:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12fd2:	4616      	mov	r6, r2
   12fd4:	4604      	mov	r4, r0
   12fd6:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
   12fd8:	f240 80a2 	bls.w	13120 <HAL_TIM_PWM_ConfigChannel+0x154>
   12fdc:	2a3c      	cmp	r2, #60	; 0x3c
   12fde:	f040 80a4 	bne.w	1312a <HAL_TIM_PWM_ConfigChannel+0x15e>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   12fe2:	682b      	ldr	r3, [r5, #0]
   12fe4:	4a9b      	ldr	r2, [pc, #620]	; (13254 <HAL_TIM_PWM_ConfigChannel+0x288>)
   12fe6:	f023 0110 	bic.w	r1, r3, #16
   12fea:	4291      	cmp	r1, r2
   12fec:	d004      	beq.n	12ff8 <HAL_TIM_PWM_ConfigChannel+0x2c>
   12fee:	4a9a      	ldr	r2, [pc, #616]	; (13258 <HAL_TIM_PWM_ConfigChannel+0x28c>)
   12ff0:	401a      	ands	r2, r3
   12ff2:	2a60      	cmp	r2, #96	; 0x60
   12ff4:	f040 8235 	bne.w	13462 <HAL_TIM_PWM_ConfigChannel+0x496>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   12ff8:	68ab      	ldr	r3, [r5, #8]
   12ffa:	f033 0302 	bics.w	r3, r3, #2
   12ffe:	f040 809a 	bne.w	13136 <HAL_TIM_PWM_ConfigChannel+0x16a>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   13002:	692b      	ldr	r3, [r5, #16]
   13004:	f033 0304 	bics.w	r3, r3, #4
   13008:	f040 809f 	bne.w	1314a <HAL_TIM_PWM_ConfigChannel+0x17e>
  __HAL_LOCK(htim);
   1300c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   13010:	2b01      	cmp	r3, #1
   13012:	f000 80a4 	beq.w	1315e <HAL_TIM_PWM_ConfigChannel+0x192>
   13016:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
   13018:	2302      	movs	r3, #2
  __HAL_LOCK(htim);
   1301a:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
   1301e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  switch (Channel)
   13022:	2e14      	cmp	r6, #20
   13024:	d873      	bhi.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
   13026:	e8df f016 	tbh	[pc, r6, lsl #1]
   1302a:	0015      	.short	0x0015
   1302c:	00720072 	.word	0x00720072
   13030:	009d0072 	.word	0x009d0072
   13034:	00720072 	.word	0x00720072
   13038:	00e00072 	.word	0x00e00072
   1303c:	00720072 	.word	0x00720072
   13040:	01290072 	.word	0x01290072
   13044:	00720072 	.word	0x00720072
   13048:	018e0072 	.word	0x018e0072
   1304c:	00720072 	.word	0x00720072
   13050:	01d50072 	.word	0x01d50072
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   13054:	6820      	ldr	r0, [r4, #0]
   13056:	4b81      	ldr	r3, [pc, #516]	; (1325c <HAL_TIM_PWM_ConfigChannel+0x290>)
   13058:	4a81      	ldr	r2, [pc, #516]	; (13260 <HAL_TIM_PWM_ConfigChannel+0x294>)
   1305a:	4298      	cmp	r0, r3
   1305c:	bf18      	it	ne
   1305e:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   13062:	4980      	ldr	r1, [pc, #512]	; (13264 <HAL_TIM_PWM_ConfigChannel+0x298>)
   13064:	bf14      	ite	ne
   13066:	2301      	movne	r3, #1
   13068:	2300      	moveq	r3, #0
   1306a:	4290      	cmp	r0, r2
   1306c:	bf0c      	ite	eq
   1306e:	2300      	moveq	r3, #0
   13070:	f003 0301 	andne.w	r3, r3, #1
   13074:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   13078:	4288      	cmp	r0, r1
   1307a:	bf0c      	ite	eq
   1307c:	2300      	moveq	r3, #0
   1307e:	f003 0301 	andne.w	r3, r3, #1
   13082:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   13086:	4290      	cmp	r0, r2
   13088:	bf0c      	ite	eq
   1308a:	2300      	moveq	r3, #0
   1308c:	f003 0301 	andne.w	r3, r3, #1
   13090:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
   13094:	4288      	cmp	r0, r1
   13096:	bf0c      	ite	eq
   13098:	2300      	moveq	r3, #0
   1309a:	f003 0301 	andne.w	r3, r3, #1
   1309e:	f5a1 4168 	sub.w	r1, r1, #59392	; 0xe800
   130a2:	4290      	cmp	r0, r2
   130a4:	bf0c      	ite	eq
   130a6:	2300      	moveq	r3, #0
   130a8:	f003 0301 	andne.w	r3, r3, #1
   130ac:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   130b0:	4288      	cmp	r0, r1
   130b2:	bf0c      	ite	eq
   130b4:	2300      	moveq	r3, #0
   130b6:	f003 0301 	andne.w	r3, r3, #1
   130ba:	f501 3192 	add.w	r1, r1, #74752	; 0x12400
   130be:	4290      	cmp	r0, r2
   130c0:	bf0c      	ite	eq
   130c2:	2300      	moveq	r3, #0
   130c4:	f003 0301 	andne.w	r3, r3, #1
   130c8:	f502 3292 	add.w	r2, r2, #74752	; 0x12400
   130cc:	4288      	cmp	r0, r1
   130ce:	bf0c      	ite	eq
   130d0:	2300      	moveq	r3, #0
   130d2:	f003 0301 	andne.w	r3, r3, #1
   130d6:	4290      	cmp	r0, r2
   130d8:	bf0c      	ite	eq
   130da:	2300      	moveq	r3, #0
   130dc:	f003 0301 	andne.w	r3, r3, #1
   130e0:	b11b      	cbz	r3, 130ea <HAL_TIM_PWM_ConfigChannel+0x11e>
   130e2:	4b61      	ldr	r3, [pc, #388]	; (13268 <HAL_TIM_PWM_ConfigChannel+0x29c>)
   130e4:	4298      	cmp	r0, r3
   130e6:	f040 81ec 	bne.w	134c2 <HAL_TIM_PWM_ConfigChannel+0x4f6>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
   130ea:	4629      	mov	r1, r5
   130ec:	f7fe ffe6 	bl	120bc <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   130f0:	6822      	ldr	r2, [r4, #0]
   130f2:	6993      	ldr	r3, [r2, #24]
   130f4:	f043 0308 	orr.w	r3, r3, #8
   130f8:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   130fa:	6822      	ldr	r2, [r4, #0]
   130fc:	6993      	ldr	r3, [r2, #24]
   130fe:	f023 0304 	bic.w	r3, r3, #4
   13102:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
   13104:	6822      	ldr	r2, [r4, #0]
   13106:	6929      	ldr	r1, [r5, #16]
   13108:	6993      	ldr	r3, [r2, #24]
   1310a:	430b      	orrs	r3, r1
   1310c:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
   1310e:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   13110:	2201      	movs	r2, #1
  return HAL_OK;
   13112:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   13114:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   13118:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   1311c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_TIM_CHANNELS(Channel));
   13120:	4b52      	ldr	r3, [pc, #328]	; (1326c <HAL_TIM_PWM_ConfigChannel+0x2a0>)
   13122:	40d3      	lsrs	r3, r2
   13124:	07db      	lsls	r3, r3, #31
   13126:	f53f af5c 	bmi.w	12fe2 <HAL_TIM_PWM_ConfigChannel+0x16>
   1312a:	f640 611c 	movw	r1, #3612	; 0xe1c
   1312e:	4850      	ldr	r0, [pc, #320]	; (13270 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
   13130:	f006 f9c6 	bl	194c0 <assert_failed>
   13134:	e755      	b.n	12fe2 <HAL_TIM_PWM_ConfigChannel+0x16>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   13136:	f640 611e 	movw	r1, #3614	; 0xe1e
   1313a:	484d      	ldr	r0, [pc, #308]	; (13270 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
   1313c:	f006 f9c0 	bl	194c0 <assert_failed>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   13140:	692b      	ldr	r3, [r5, #16]
   13142:	f033 0304 	bics.w	r3, r3, #4
   13146:	f43f af61 	beq.w	1300c <HAL_TIM_PWM_ConfigChannel+0x40>
   1314a:	f640 611f 	movw	r1, #3615	; 0xe1f
   1314e:	4848      	ldr	r0, [pc, #288]	; (13270 <HAL_TIM_PWM_ConfigChannel+0x2a4>)
   13150:	f006 f9b6 	bl	194c0 <assert_failed>
  __HAL_LOCK(htim);
   13154:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   13158:	2b01      	cmp	r3, #1
   1315a:	f47f af5c 	bne.w	13016 <HAL_TIM_PWM_ConfigChannel+0x4a>
   1315e:	2002      	movs	r0, #2
}
   13160:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   13164:	6820      	ldr	r0, [r4, #0]
   13166:	4b3d      	ldr	r3, [pc, #244]	; (1325c <HAL_TIM_PWM_ConfigChannel+0x290>)
   13168:	4a3d      	ldr	r2, [pc, #244]	; (13260 <HAL_TIM_PWM_ConfigChannel+0x294>)
   1316a:	4298      	cmp	r0, r3
   1316c:	bf18      	it	ne
   1316e:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   13172:	493c      	ldr	r1, [pc, #240]	; (13264 <HAL_TIM_PWM_ConfigChannel+0x298>)
   13174:	bf14      	ite	ne
   13176:	2301      	movne	r3, #1
   13178:	2300      	moveq	r3, #0
   1317a:	4290      	cmp	r0, r2
   1317c:	bf0c      	ite	eq
   1317e:	2300      	moveq	r3, #0
   13180:	f003 0301 	andne.w	r3, r3, #1
   13184:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   13188:	4288      	cmp	r0, r1
   1318a:	bf0c      	ite	eq
   1318c:	2300      	moveq	r3, #0
   1318e:	f003 0301 	andne.w	r3, r3, #1
   13192:	f501 417c 	add.w	r1, r1, #64512	; 0xfc00
   13196:	4290      	cmp	r0, r2
   13198:	bf0c      	ite	eq
   1319a:	2300      	moveq	r3, #0
   1319c:	f003 0301 	andne.w	r3, r3, #1
   131a0:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
   131a4:	4288      	cmp	r0, r1
   131a6:	bf0c      	ite	eq
   131a8:	2300      	moveq	r3, #0
   131aa:	f003 0301 	andne.w	r3, r3, #1
   131ae:	4290      	cmp	r0, r2
   131b0:	bf0c      	ite	eq
   131b2:	2300      	moveq	r3, #0
   131b4:	f003 0301 	andne.w	r3, r3, #1
   131b8:	b11b      	cbz	r3, 131c2 <HAL_TIM_PWM_ConfigChannel+0x1f6>
   131ba:	4b2e      	ldr	r3, [pc, #184]	; (13274 <HAL_TIM_PWM_ConfigChannel+0x2a8>)
   131bc:	4298      	cmp	r0, r3
   131be:	f040 8179 	bne.w	134b4 <HAL_TIM_PWM_ConfigChannel+0x4e8>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
   131c2:	4629      	mov	r1, r5
   131c4:	f7ff fe8e 	bl	12ee4 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   131c8:	6822      	ldr	r2, [r4, #0]
   131ca:	6993      	ldr	r3, [r2, #24]
   131cc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   131d0:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   131d2:	6822      	ldr	r2, [r4, #0]
   131d4:	6993      	ldr	r3, [r2, #24]
   131d6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   131da:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   131dc:	6822      	ldr	r2, [r4, #0]
   131de:	6929      	ldr	r1, [r5, #16]
   131e0:	6993      	ldr	r3, [r2, #24]
   131e2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   131e6:	6193      	str	r3, [r2, #24]
      break;
   131e8:	e791      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   131ea:	6820      	ldr	r0, [r4, #0]
   131ec:	4b1b      	ldr	r3, [pc, #108]	; (1325c <HAL_TIM_PWM_ConfigChannel+0x290>)
   131ee:	4a1c      	ldr	r2, [pc, #112]	; (13260 <HAL_TIM_PWM_ConfigChannel+0x294>)
   131f0:	4298      	cmp	r0, r3
   131f2:	bf18      	it	ne
   131f4:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
   131f8:	491a      	ldr	r1, [pc, #104]	; (13264 <HAL_TIM_PWM_ConfigChannel+0x298>)
   131fa:	bf14      	ite	ne
   131fc:	2301      	movne	r3, #1
   131fe:	2300      	moveq	r3, #0
   13200:	4290      	cmp	r0, r2
   13202:	bf0c      	ite	eq
   13204:	2300      	moveq	r3, #0
   13206:	f003 0301 	andne.w	r3, r3, #1
   1320a:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   1320e:	4288      	cmp	r0, r1
   13210:	bf0c      	ite	eq
   13212:	2300      	moveq	r3, #0
   13214:	f003 0301 	andne.w	r3, r3, #1
   13218:	4290      	cmp	r0, r2
   1321a:	bf0c      	ite	eq
   1321c:	2300      	moveq	r3, #0
   1321e:	f003 0301 	andne.w	r3, r3, #1
   13222:	b11b      	cbz	r3, 1322c <HAL_TIM_PWM_ConfigChannel+0x260>
   13224:	4b14      	ldr	r3, [pc, #80]	; (13278 <HAL_TIM_PWM_ConfigChannel+0x2ac>)
   13226:	4298      	cmp	r0, r3
   13228:	f040 813d 	bne.w	134a6 <HAL_TIM_PWM_ConfigChannel+0x4da>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
   1322c:	4629      	mov	r1, r5
   1322e:	f7fe ffcd 	bl	121cc <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   13232:	6822      	ldr	r2, [r4, #0]
   13234:	69d3      	ldr	r3, [r2, #28]
   13236:	f043 0308 	orr.w	r3, r3, #8
   1323a:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   1323c:	6822      	ldr	r2, [r4, #0]
   1323e:	69d3      	ldr	r3, [r2, #28]
   13240:	f023 0304 	bic.w	r3, r3, #4
   13244:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
   13246:	6822      	ldr	r2, [r4, #0]
   13248:	6929      	ldr	r1, [r5, #16]
   1324a:	69d3      	ldr	r3, [r2, #28]
   1324c:	430b      	orrs	r3, r1
   1324e:	61d3      	str	r3, [r2, #28]
      break;
   13250:	e75d      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
   13252:	bf00      	nop
   13254:	00010040 	.word	0x00010040
   13258:	fffeffef 	.word	0xfffeffef
   1325c:	40010000 	.word	0x40010000
   13260:	40000400 	.word	0x40000400
   13264:	40000800 	.word	0x40000800
   13268:	40014800 	.word	0x40014800
   1326c:	00111111 	.word	0x00111111
   13270:	000302c4 	.word	0x000302c4
   13274:	40014000 	.word	0x40014000
   13278:	40010400 	.word	0x40010400
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   1327c:	6826      	ldr	r6, [r4, #0]
   1327e:	4b94      	ldr	r3, [pc, #592]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
   13280:	4a94      	ldr	r2, [pc, #592]	; (134d4 <HAL_TIM_PWM_ConfigChannel+0x508>)
   13282:	429e      	cmp	r6, r3
   13284:	bf18      	it	ne
   13286:	f1b6 4f80 	cmpne.w	r6, #1073741824	; 0x40000000
   1328a:	4993      	ldr	r1, [pc, #588]	; (134d8 <HAL_TIM_PWM_ConfigChannel+0x50c>)
   1328c:	bf14      	ite	ne
   1328e:	2301      	movne	r3, #1
   13290:	2300      	moveq	r3, #0
   13292:	4296      	cmp	r6, r2
   13294:	bf0c      	ite	eq
   13296:	2300      	moveq	r3, #0
   13298:	f003 0301 	andne.w	r3, r3, #1
   1329c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
   132a0:	428e      	cmp	r6, r1
   132a2:	bf0c      	ite	eq
   132a4:	2300      	moveq	r3, #0
   132a6:	f003 0301 	andne.w	r3, r3, #1
   132aa:	4296      	cmp	r6, r2
   132ac:	bf0c      	ite	eq
   132ae:	2300      	moveq	r3, #0
   132b0:	f003 0301 	andne.w	r3, r3, #1
   132b4:	b11b      	cbz	r3, 132be <HAL_TIM_PWM_ConfigChannel+0x2f2>
   132b6:	4b89      	ldr	r3, [pc, #548]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   132b8:	429e      	cmp	r6, r3
   132ba:	f040 80ed 	bne.w	13498 <HAL_TIM_PWM_ConfigChannel+0x4cc>
  TIMx->CCER &= ~TIM_CCER_CC4E;
   132be:	6a33      	ldr	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   132c0:	4983      	ldr	r1, [pc, #524]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
   132c2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   132c6:	428e      	cmp	r6, r1
  TIMx->CCER &= ~TIM_CCER_CC4E;
   132c8:	6233      	str	r3, [r6, #32]
  tmpccer = TIMx->CCER;
   132ca:	6a33      	ldr	r3, [r6, #32]
  tmpcr2 =  TIMx->CR2;
   132cc:	f8d6 9004 	ldr.w	r9, [r6, #4]
  tmpccmrx = TIMx->CCMR2;
   132d0:	69f7      	ldr	r7, [r6, #28]
  tmpccer &= ~TIM_CCER_CC4P;
   132d2:	f423 5800 	bic.w	r8, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
   132d6:	68aa      	ldr	r2, [r5, #8]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
   132d8:	f427 47e6 	bic.w	r7, r7, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
   132dc:	682b      	ldr	r3, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
   132de:	ea48 3802 	orr.w	r8, r8, r2, lsl #12
  tmpccmrx |= (OC_Config->OCMode << 8U);
   132e2:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   132e6:	d00d      	beq.n	13304 <HAL_TIM_PWM_ConfigChannel+0x338>
   132e8:	4b7c      	ldr	r3, [pc, #496]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   132ea:	429e      	cmp	r6, r3
   132ec:	d00a      	beq.n	13304 <HAL_TIM_PWM_ConfigChannel+0x338>
   132ee:	4a7c      	ldr	r2, [pc, #496]	; (134e0 <HAL_TIM_PWM_ConfigChannel+0x514>)
   132f0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   132f4:	429e      	cmp	r6, r3
   132f6:	bf18      	it	ne
   132f8:	4296      	cmpne	r6, r2
   132fa:	d003      	beq.n	13304 <HAL_TIM_PWM_ConfigChannel+0x338>
   132fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   13300:	429e      	cmp	r6, r3
   13302:	d108      	bne.n	13316 <HAL_TIM_PWM_ConfigChannel+0x34a>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   13304:	696b      	ldr	r3, [r5, #20]
   13306:	f433 7280 	bics.w	r2, r3, #256	; 0x100
   1330a:	f040 80be 	bne.w	1348a <HAL_TIM_PWM_ConfigChannel+0x4be>
    tmpcr2 &= ~TIM_CR2_OIS4;
   1330e:	f429 4980 	bic.w	r9, r9, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
   13312:	ea49 1983 	orr.w	r9, r9, r3, lsl #6
  TIMx->CR2 = tmpcr2;
   13316:	f8c6 9004 	str.w	r9, [r6, #4]
  TIMx->CCMR2 = tmpccmrx;
   1331a:	61f7      	str	r7, [r6, #28]
  TIMx->CCR4 = OC_Config->Pulse;
   1331c:	686b      	ldr	r3, [r5, #4]
   1331e:	6433      	str	r3, [r6, #64]	; 0x40
  TIMx->CCER = tmpccer;
   13320:	f8c6 8020 	str.w	r8, [r6, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   13324:	6822      	ldr	r2, [r4, #0]
   13326:	69d3      	ldr	r3, [r2, #28]
   13328:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   1332c:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   1332e:	6822      	ldr	r2, [r4, #0]
   13330:	69d3      	ldr	r3, [r2, #28]
   13332:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   13336:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   13338:	6822      	ldr	r2, [r4, #0]
   1333a:	6929      	ldr	r1, [r5, #16]
   1333c:	69d3      	ldr	r3, [r2, #28]
   1333e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   13342:	61d3      	str	r3, [r2, #28]
      break;
   13344:	e6e3      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   13346:	6823      	ldr	r3, [r4, #0]
   13348:	4a61      	ldr	r2, [pc, #388]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
   1334a:	4293      	cmp	r3, r2
   1334c:	d004      	beq.n	13358 <HAL_TIM_PWM_ConfigChannel+0x38c>
   1334e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   13352:	4293      	cmp	r3, r2
   13354:	f040 8092 	bne.w	1347c <HAL_TIM_PWM_ConfigChannel+0x4b0>
  TIMx->CCER &= ~TIM_CCER_CC5E;
   13358:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1335a:	4f5d      	ldr	r7, [pc, #372]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC5E;
   1335c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13360:	42bb      	cmp	r3, r7
  TIMx->CCER &= ~TIM_CCER_CC5E;
   13362:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
   13364:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
   13366:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
   1336a:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= ~TIM_CCER_CC5P;
   1336c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
   13370:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
   13372:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
   13376:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
   13378:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  tmpccmrx |= OC_Config->OCMode;
   1337c:	ea41 0100 	orr.w	r1, r1, r0
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   13380:	d00d      	beq.n	1339e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   13382:	4856      	ldr	r0, [pc, #344]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   13384:	4283      	cmp	r3, r0
   13386:	d00a      	beq.n	1339e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   13388:	4e55      	ldr	r6, [pc, #340]	; (134e0 <HAL_TIM_PWM_ConfigChannel+0x514>)
   1338a:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
   1338e:	4283      	cmp	r3, r0
   13390:	bf18      	it	ne
   13392:	42b3      	cmpne	r3, r6
   13394:	d003      	beq.n	1339e <HAL_TIM_PWM_ConfigChannel+0x3d2>
   13396:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   1339a:	4283      	cmp	r3, r0
   1339c:	d104      	bne.n	133a8 <HAL_TIM_PWM_ConfigChannel+0x3dc>
    tmpcr2 &= ~TIM_CR2_OIS5;
   1339e:	f42c 3c80 	bic.w	ip, ip, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
   133a2:	6968      	ldr	r0, [r5, #20]
   133a4:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
  TIMx->CR2 = tmpcr2;
   133a8:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
   133ac:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
   133ae:	6869      	ldr	r1, [r5, #4]
   133b0:	6599      	str	r1, [r3, #88]	; 0x58
  TIMx->CCER = tmpccer;
   133b2:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   133b4:	6822      	ldr	r2, [r4, #0]
   133b6:	6d53      	ldr	r3, [r2, #84]	; 0x54
   133b8:	f043 0308 	orr.w	r3, r3, #8
   133bc:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   133be:	6822      	ldr	r2, [r4, #0]
   133c0:	6d53      	ldr	r3, [r2, #84]	; 0x54
   133c2:	f023 0304 	bic.w	r3, r3, #4
   133c6:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
   133c8:	6822      	ldr	r2, [r4, #0]
   133ca:	6929      	ldr	r1, [r5, #16]
   133cc:	6d53      	ldr	r3, [r2, #84]	; 0x54
   133ce:	430b      	orrs	r3, r1
   133d0:	6553      	str	r3, [r2, #84]	; 0x54
      break;
   133d2:	e69c      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   133d4:	6823      	ldr	r3, [r4, #0]
   133d6:	4a3e      	ldr	r2, [pc, #248]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
   133d8:	4293      	cmp	r3, r2
   133da:	d003      	beq.n	133e4 <HAL_TIM_PWM_ConfigChannel+0x418>
   133dc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   133e0:	4293      	cmp	r3, r2
   133e2:	d144      	bne.n	1346e <HAL_TIM_PWM_ConfigChannel+0x4a2>
  TIMx->CCER &= ~TIM_CCER_CC6E;
   133e4:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   133e6:	4f3a      	ldr	r7, [pc, #232]	; (134d0 <HAL_TIM_PWM_ConfigChannel+0x504>)
  TIMx->CCER &= ~TIM_CCER_CC6E;
   133e8:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   133ec:	42bb      	cmp	r3, r7
  TIMx->CCER &= ~TIM_CCER_CC6E;
   133ee:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
   133f0:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
   133f2:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
   133f6:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   133f8:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
   133fc:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
   133fe:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
   13402:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
   13404:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  tmpccmrx |= (OC_Config->OCMode << 8U);
   13408:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
   1340c:	d00d      	beq.n	1342a <HAL_TIM_PWM_ConfigChannel+0x45e>
   1340e:	4833      	ldr	r0, [pc, #204]	; (134dc <HAL_TIM_PWM_ConfigChannel+0x510>)
   13410:	4283      	cmp	r3, r0
   13412:	d00a      	beq.n	1342a <HAL_TIM_PWM_ConfigChannel+0x45e>
   13414:	4e32      	ldr	r6, [pc, #200]	; (134e0 <HAL_TIM_PWM_ConfigChannel+0x514>)
   13416:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
   1341a:	4283      	cmp	r3, r0
   1341c:	bf18      	it	ne
   1341e:	42b3      	cmpne	r3, r6
   13420:	d003      	beq.n	1342a <HAL_TIM_PWM_ConfigChannel+0x45e>
   13422:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   13426:	4283      	cmp	r3, r0
   13428:	d104      	bne.n	13434 <HAL_TIM_PWM_ConfigChannel+0x468>
    tmpcr2 &= ~TIM_CR2_OIS6;
   1342a:	f42c 3c00 	bic.w	ip, ip, #131072	; 0x20000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
   1342e:	6968      	ldr	r0, [r5, #20]
   13430:	ea4c 2c80 	orr.w	ip, ip, r0, lsl #10
  TIMx->CR2 = tmpcr2;
   13434:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
   13438:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
   1343a:	6869      	ldr	r1, [r5, #4]
   1343c:	65d9      	str	r1, [r3, #92]	; 0x5c
  TIMx->CCER = tmpccer;
   1343e:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   13440:	6822      	ldr	r2, [r4, #0]
   13442:	6d53      	ldr	r3, [r2, #84]	; 0x54
   13444:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   13448:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   1344a:	6822      	ldr	r2, [r4, #0]
   1344c:	6d53      	ldr	r3, [r2, #84]	; 0x54
   1344e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   13452:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
   13454:	6822      	ldr	r2, [r4, #0]
   13456:	6929      	ldr	r1, [r5, #16]
   13458:	6d53      	ldr	r3, [r2, #84]	; 0x54
   1345a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   1345e:	6553      	str	r3, [r2, #84]	; 0x54
      break;
   13460:	e655      	b.n	1310e <HAL_TIM_PWM_ConfigChannel+0x142>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   13462:	f640 611d 	movw	r1, #3613	; 0xe1d
   13466:	481f      	ldr	r0, [pc, #124]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13468:	f006 f82a 	bl	194c0 <assert_failed>
   1346c:	e5c4      	b.n	12ff8 <HAL_TIM_PWM_ConfigChannel+0x2c>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   1346e:	f44f 6168 	mov.w	r1, #3712	; 0xe80
   13472:	481c      	ldr	r0, [pc, #112]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13474:	f006 f824 	bl	194c0 <assert_failed>
   13478:	6823      	ldr	r3, [r4, #0]
   1347a:	e7b3      	b.n	133e4 <HAL_TIM_PWM_ConfigChannel+0x418>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   1347c:	f640 616f 	movw	r1, #3695	; 0xe6f
   13480:	4818      	ldr	r0, [pc, #96]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13482:	f006 f81d 	bl	194c0 <assert_failed>
   13486:	6823      	ldr	r3, [r4, #0]
   13488:	e766      	b.n	13358 <HAL_TIM_PWM_ConfigChannel+0x38c>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   1348a:	f641 01e8 	movw	r1, #6376	; 0x18e8
   1348e:	4815      	ldr	r0, [pc, #84]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   13490:	f006 f816 	bl	194c0 <assert_failed>
   13494:	696b      	ldr	r3, [r5, #20]
   13496:	e73a      	b.n	1330e <HAL_TIM_PWM_ConfigChannel+0x342>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   13498:	f640 615e 	movw	r1, #3678	; 0xe5e
   1349c:	4811      	ldr	r0, [pc, #68]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   1349e:	f006 f80f 	bl	194c0 <assert_failed>
   134a2:	6826      	ldr	r6, [r4, #0]
   134a4:	e70b      	b.n	132be <HAL_TIM_PWM_ConfigChannel+0x2f2>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   134a6:	480f      	ldr	r0, [pc, #60]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   134a8:	f640 614d 	movw	r1, #3661	; 0xe4d
   134ac:	f006 f808 	bl	194c0 <assert_failed>
   134b0:	6820      	ldr	r0, [r4, #0]
   134b2:	e6bb      	b.n	1322c <HAL_TIM_PWM_ConfigChannel+0x260>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   134b4:	480b      	ldr	r0, [pc, #44]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   134b6:	f640 613c 	movw	r1, #3644	; 0xe3c
   134ba:	f006 f801 	bl	194c0 <assert_failed>
   134be:	6820      	ldr	r0, [r4, #0]
   134c0:	e67f      	b.n	131c2 <HAL_TIM_PWM_ConfigChannel+0x1f6>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   134c2:	4808      	ldr	r0, [pc, #32]	; (134e4 <HAL_TIM_PWM_ConfigChannel+0x518>)
   134c4:	f640 612b 	movw	r1, #3627	; 0xe2b
   134c8:	f005 fffa 	bl	194c0 <assert_failed>
   134cc:	6820      	ldr	r0, [r4, #0]
   134ce:	e60c      	b.n	130ea <HAL_TIM_PWM_ConfigChannel+0x11e>
   134d0:	40010000 	.word	0x40010000
   134d4:	40000400 	.word	0x40000400
   134d8:	40000800 	.word	0x40000800
   134dc:	40010400 	.word	0x40010400
   134e0:	40014000 	.word	0x40014000
   134e4:	000302c4 	.word	0x000302c4

000134e8 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
   134e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   134ea:	4b60      	ldr	r3, [pc, #384]	; (1366c <HAL_TIMEx_MasterConfigSynchronization+0x184>)
{
   134ec:	4604      	mov	r4, r0
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   134ee:	6802      	ldr	r2, [r0, #0]
{
   134f0:	460d      	mov	r5, r1
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   134f2:	4e5f      	ldr	r6, [pc, #380]	; (13670 <HAL_TIMEx_MasterConfigSynchronization+0x188>)
   134f4:	429a      	cmp	r2, r3
   134f6:	bf18      	it	ne
   134f8:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
   134fc:	485d      	ldr	r0, [pc, #372]	; (13674 <HAL_TIMEx_MasterConfigSynchronization+0x18c>)
   134fe:	495e      	ldr	r1, [pc, #376]	; (13678 <HAL_TIMEx_MasterConfigSynchronization+0x190>)
   13500:	bf14      	ite	ne
   13502:	2301      	movne	r3, #1
   13504:	2300      	moveq	r3, #0
   13506:	42b2      	cmp	r2, r6
   13508:	bf0c      	ite	eq
   1350a:	2300      	moveq	r3, #0
   1350c:	f003 0301 	andne.w	r3, r3, #1
   13510:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
   13514:	4282      	cmp	r2, r0
   13516:	bf0c      	ite	eq
   13518:	2300      	moveq	r3, #0
   1351a:	f003 0301 	andne.w	r3, r3, #1
   1351e:	f500 6040 	add.w	r0, r0, #3072	; 0xc00
   13522:	428a      	cmp	r2, r1
   13524:	bf0c      	ite	eq
   13526:	2300      	moveq	r3, #0
   13528:	f003 0301 	andne.w	r3, r3, #1
   1352c:	f501 4178 	add.w	r1, r1, #63488	; 0xf800
   13530:	42b2      	cmp	r2, r6
   13532:	bf0c      	ite	eq
   13534:	2300      	moveq	r3, #0
   13536:	f003 0301 	andne.w	r3, r3, #1
   1353a:	4282      	cmp	r2, r0
   1353c:	bf0c      	ite	eq
   1353e:	2300      	moveq	r3, #0
   13540:	f003 0301 	andne.w	r3, r3, #1
   13544:	428a      	cmp	r2, r1
   13546:	bf0c      	ite	eq
   13548:	2300      	moveq	r3, #0
   1354a:	f003 0301 	andne.w	r3, r3, #1
   1354e:	b113      	cbz	r3, 13556 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
   13550:	4b4a      	ldr	r3, [pc, #296]	; (1367c <HAL_TIMEx_MasterConfigSynchronization+0x194>)
   13552:	429a      	cmp	r2, r3
   13554:	d175      	bne.n	13642 <HAL_TIMEx_MasterConfigSynchronization+0x15a>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   13556:	682b      	ldr	r3, [r5, #0]
   13558:	f023 0330 	bic.w	r3, r3, #48	; 0x30
   1355c:	2b40      	cmp	r3, #64	; 0x40
   1355e:	d001      	beq.n	13564 <HAL_TIMEx_MasterConfigSynchronization+0x7c>
   13560:	2b00      	cmp	r3, #0
   13562:	d174      	bne.n	1364e <HAL_TIMEx_MasterConfigSynchronization+0x166>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   13564:	68ab      	ldr	r3, [r5, #8]
   13566:	f033 0380 	bics.w	r3, r3, #128	; 0x80
   1356a:	d15f      	bne.n	1362c <HAL_TIMEx_MasterConfigSynchronization+0x144>

  /* Check input state */
  __HAL_LOCK(htim);
   1356c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   13570:	2b01      	cmp	r3, #1
   13572:	d064      	beq.n	1363e <HAL_TIMEx_MasterConfigSynchronization+0x156>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
   13574:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(htim);
   13576:	2001      	movs	r0, #1

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   13578:	4b3c      	ldr	r3, [pc, #240]	; (1366c <HAL_TIMEx_MasterConfigSynchronization+0x184>)
  htim->State = HAL_TIM_STATE_BUSY;
   1357a:	2102      	movs	r1, #2
  __HAL_LOCK(htim);
   1357c:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   13580:	429a      	cmp	r2, r3
  htim->State = HAL_TIM_STATE_BUSY;
   13582:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
   13586:	6857      	ldr	r7, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
   13588:	6896      	ldr	r6, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   1358a:	d037      	beq.n	135fc <HAL_TIMEx_MasterConfigSynchronization+0x114>
   1358c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   13590:	429a      	cmp	r2, r3
   13592:	d033      	beq.n	135fc <HAL_TIMEx_MasterConfigSynchronization+0x114>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   13594:	6829      	ldr	r1, [r5, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
   13596:	f027 0770 	bic.w	r7, r7, #112	; 0x70

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1359a:	4b34      	ldr	r3, [pc, #208]	; (1366c <HAL_TIMEx_MasterConfigSynchronization+0x184>)
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   1359c:	430f      	orrs	r7, r1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   1359e:	4934      	ldr	r1, [pc, #208]	; (13670 <HAL_TIMEx_MasterConfigSynchronization+0x188>)
   135a0:	4835      	ldr	r0, [pc, #212]	; (13678 <HAL_TIMEx_MasterConfigSynchronization+0x190>)
  htim->Instance->CR2 = tmpcr2;
   135a2:	6057      	str	r7, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   135a4:	6822      	ldr	r2, [r4, #0]
   135a6:	4f33      	ldr	r7, [pc, #204]	; (13674 <HAL_TIMEx_MasterConfigSynchronization+0x18c>)
   135a8:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
   135ac:	bf18      	it	ne
   135ae:	429a      	cmpne	r2, r3
   135b0:	bf0c      	ite	eq
   135b2:	2301      	moveq	r3, #1
   135b4:	2300      	movne	r3, #0
   135b6:	428a      	cmp	r2, r1
   135b8:	bf08      	it	eq
   135ba:	f043 0301 	orreq.w	r3, r3, #1
   135be:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
   135c2:	42ba      	cmp	r2, r7
   135c4:	bf08      	it	eq
   135c6:	f043 0301 	orreq.w	r3, r3, #1
   135ca:	4282      	cmp	r2, r0
   135cc:	bf08      	it	eq
   135ce:	f043 0301 	orreq.w	r3, r3, #1
   135d2:	428a      	cmp	r2, r1
   135d4:	bf08      	it	eq
   135d6:	f043 0301 	orreq.w	r3, r3, #1
   135da:	b913      	cbnz	r3, 135e2 <HAL_TIMEx_MasterConfigSynchronization+0xfa>
   135dc:	4b28      	ldr	r3, [pc, #160]	; (13680 <HAL_TIMEx_MasterConfigSynchronization+0x198>)
   135de:	429a      	cmp	r2, r3
   135e0:	d104      	bne.n	135ec <HAL_TIMEx_MasterConfigSynchronization+0x104>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
   135e2:	68ab      	ldr	r3, [r5, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
   135e4:	f026 0680 	bic.w	r6, r6, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
   135e8:	431e      	orrs	r6, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
   135ea:	6096      	str	r6, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
   135ec:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
   135ee:	2201      	movs	r2, #1

  return HAL_OK;
   135f0:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
   135f2:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
   135f6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
   135fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   135fc:	6868      	ldr	r0, [r5, #4]
   135fe:	f420 1340 	bic.w	r3, r0, #3145728	; 0x300000
   13602:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   13606:	bf18      	it	ne
   13608:	2b00      	cmpne	r3, #0
   1360a:	bf14      	ite	ne
   1360c:	2101      	movne	r1, #1
   1360e:	2100      	moveq	r1, #0
   13610:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   13614:	bf0c      	ite	eq
   13616:	2100      	moveq	r1, #0
   13618:	f001 0101 	andne.w	r1, r1, #1
   1361c:	b111      	cbz	r1, 13624 <HAL_TIMEx_MasterConfigSynchronization+0x13c>
   1361e:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   13622:	d11a      	bne.n	1365a <HAL_TIMEx_MasterConfigSynchronization+0x172>
    tmpcr2 &= ~TIM_CR2_MMS2;
   13624:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
   13628:	4307      	orrs	r7, r0
   1362a:	e7b3      	b.n	13594 <HAL_TIMEx_MasterConfigSynchronization+0xac>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1362c:	f240 6175 	movw	r1, #1653	; 0x675
   13630:	4814      	ldr	r0, [pc, #80]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   13632:	f005 ff45 	bl	194c0 <assert_failed>
  __HAL_LOCK(htim);
   13636:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1363a:	2b01      	cmp	r3, #1
   1363c:	d19a      	bne.n	13574 <HAL_TIMEx_MasterConfigSynchronization+0x8c>
   1363e:	2002      	movs	r0, #2
}
   13640:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   13642:	f240 6173 	movw	r1, #1651	; 0x673
   13646:	480f      	ldr	r0, [pc, #60]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   13648:	f005 ff3a 	bl	194c0 <assert_failed>
   1364c:	e783      	b.n	13556 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1364e:	f240 6174 	movw	r1, #1652	; 0x674
   13652:	480c      	ldr	r0, [pc, #48]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   13654:	f005 ff34 	bl	194c0 <assert_failed>
   13658:	e784      	b.n	13564 <HAL_TIMEx_MasterConfigSynchronization+0x7c>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   1365a:	480a      	ldr	r0, [pc, #40]	; (13684 <HAL_TIMEx_MasterConfigSynchronization+0x19c>)
   1365c:	f240 6187 	movw	r1, #1671	; 0x687
   13660:	f005 ff2e 	bl	194c0 <assert_failed>
   13664:	6868      	ldr	r0, [r5, #4]
   13666:	6822      	ldr	r2, [r4, #0]
   13668:	e7dc      	b.n	13624 <HAL_TIMEx_MasterConfigSynchronization+0x13c>
   1366a:	bf00      	nop
   1366c:	40010000 	.word	0x40010000
   13670:	40000400 	.word	0x40000400
   13674:	40000800 	.word	0x40000800
   13678:	40000c00 	.word	0x40000c00
   1367c:	40014000 	.word	0x40014000
   13680:	40001800 	.word	0x40001800
   13684:	000302fc 	.word	0x000302fc

00013688 <FMC_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13688:	4b5e      	ldr	r3, [pc, #376]	; (13804 <FMC_SDRAM_Init+0x17c>)
   1368a:	4298      	cmp	r0, r3
{
   1368c:	b570      	push	{r4, r5, r6, lr}
   1368e:	4605      	mov	r5, r0
   13690:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13692:	d004      	beq.n	1369e <FMC_SDRAM_Init+0x16>
   13694:	f240 311a 	movw	r1, #794	; 0x31a
   13698:	485b      	ldr	r0, [pc, #364]	; (13808 <FMC_SDRAM_Init+0x180>)
   1369a:	f005 ff11 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
   1369e:	6823      	ldr	r3, [r4, #0]
   136a0:	2b01      	cmp	r3, #1
   136a2:	d904      	bls.n	136ae <FMC_SDRAM_Init+0x26>
   136a4:	f240 311b 	movw	r1, #795	; 0x31b
   136a8:	4857      	ldr	r0, [pc, #348]	; (13808 <FMC_SDRAM_Init+0x180>)
   136aa:	f005 ff09 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
   136ae:	6863      	ldr	r3, [r4, #4]
   136b0:	2b03      	cmp	r3, #3
   136b2:	f200 80a1 	bhi.w	137f8 <FMC_SDRAM_Init+0x170>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
   136b6:	68a3      	ldr	r3, [r4, #8]
   136b8:	f033 0204 	bics.w	r2, r3, #4
   136bc:	d002      	beq.n	136c4 <FMC_SDRAM_Init+0x3c>
   136be:	2b08      	cmp	r3, #8
   136c0:	f040 8094 	bne.w	137ec <FMC_SDRAM_Init+0x164>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
   136c4:	68e3      	ldr	r3, [r4, #12]
   136c6:	f033 0210 	bics.w	r2, r3, #16
   136ca:	d001      	beq.n	136d0 <FMC_SDRAM_Init+0x48>
   136cc:	2b20      	cmp	r3, #32
   136ce:	d17d      	bne.n	137cc <FMC_SDRAM_Init+0x144>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
   136d0:	6923      	ldr	r3, [r4, #16]
   136d2:	f033 0340 	bics.w	r3, r3, #64	; 0x40
   136d6:	f040 8083 	bne.w	137e0 <FMC_SDRAM_Init+0x158>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
   136da:	6963      	ldr	r3, [r4, #20]
   136dc:	f423 7280 	bic.w	r2, r3, #256	; 0x100
   136e0:	2a80      	cmp	r2, #128	; 0x80
   136e2:	d002      	beq.n	136ea <FMC_SDRAM_Init+0x62>
   136e4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   136e8:	d161      	bne.n	137ae <FMC_SDRAM_Init+0x126>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
   136ea:	69a3      	ldr	r3, [r4, #24]
   136ec:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   136f0:	d166      	bne.n	137c0 <FMC_SDRAM_Init+0x138>
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
   136f2:	69e3      	ldr	r3, [r4, #28]
   136f4:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
   136f8:	d002      	beq.n	13700 <FMC_SDRAM_Init+0x78>
   136fa:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
   136fe:	d147      	bne.n	13790 <FMC_SDRAM_Init+0x108>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
   13700:	6a23      	ldr	r3, [r4, #32]
   13702:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   13706:	d14c      	bne.n	137a2 <FMC_SDRAM_Init+0x11a>
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
   13708:	6a62      	ldr	r2, [r4, #36]	; 0x24
   1370a:	f432 5300 	bics.w	r3, r2, #8192	; 0x2000
   1370e:	d002      	beq.n	13716 <FMC_SDRAM_Init+0x8e>
   13710:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
   13714:	d11c      	bne.n	13750 <FMC_SDRAM_Init+0xc8>

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
   13716:	6821      	ldr	r1, [r4, #0]
   13718:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
   1371c:	b319      	cbz	r1, 13766 <FMC_SDRAM_Init+0xde>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   1371e:	6829      	ldr	r1, [r5, #0]
   13720:	4303      	orrs	r3, r0
               FMC_SDCRx_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   13722:	483a      	ldr	r0, [pc, #232]	; (1380c <FMC_SDRAM_Init+0x184>)
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   13724:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
   13728:	430b      	orrs	r3, r1
   1372a:	4313      	orrs	r3, r2
   1372c:	602b      	str	r3, [r5, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   1372e:	68e2      	ldr	r2, [r4, #12]
   13730:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   13734:	430b      	orrs	r3, r1
   13736:	6921      	ldr	r1, [r4, #16]
   13738:	4313      	orrs	r3, r2
   1373a:	e9d4 6205 	ldrd	r6, r2, [r4, #20]
   1373e:	430b      	orrs	r3, r1
   13740:	6869      	ldr	r1, [r5, #4]
   13742:	4333      	orrs	r3, r6
   13744:	4008      	ands	r0, r1
   13746:	4313      	orrs	r3, r2
   13748:	4303      	orrs	r3, r0
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
   1374a:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
   1374c:	606b      	str	r3, [r5, #4]
}
   1374e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
   13750:	f44f 7149 	mov.w	r1, #804	; 0x324
   13754:	482c      	ldr	r0, [pc, #176]	; (13808 <FMC_SDRAM_Init+0x180>)
   13756:	f005 feb3 	bl	194c0 <assert_failed>
  if (Init->SDBank == FMC_SDRAM_BANK1)
   1375a:	6821      	ldr	r1, [r4, #0]
   1375c:	6a62      	ldr	r2, [r4, #36]	; 0x24
   1375e:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
   13762:	2900      	cmp	r1, #0
   13764:	d1db      	bne.n	1371e <FMC_SDRAM_Init+0x96>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   13766:	4303      	orrs	r3, r0
   13768:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
   1376c:	430b      	orrs	r3, r1
   1376e:	68e1      	ldr	r1, [r4, #12]
   13770:	4303      	orrs	r3, r0
   13772:	6920      	ldr	r0, [r4, #16]
   13774:	430b      	orrs	r3, r1
   13776:	e9d4 1405 	ldrd	r1, r4, [r4, #20]
   1377a:	4303      	orrs	r3, r0
   1377c:	6828      	ldr	r0, [r5, #0]
   1377e:	430b      	orrs	r3, r1
   13780:	4922      	ldr	r1, [pc, #136]	; (1380c <FMC_SDRAM_Init+0x184>)
   13782:	4323      	orrs	r3, r4
   13784:	4001      	ands	r1, r0
}
   13786:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
   13788:	430b      	orrs	r3, r1
   1378a:	4313      	orrs	r3, r2
   1378c:	602b      	str	r3, [r5, #0]
}
   1378e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
   13790:	f240 3122 	movw	r1, #802	; 0x322
   13794:	481c      	ldr	r0, [pc, #112]	; (13808 <FMC_SDRAM_Init+0x180>)
   13796:	f005 fe93 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
   1379a:	6a23      	ldr	r3, [r4, #32]
   1379c:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
   137a0:	d0b2      	beq.n	13708 <FMC_SDRAM_Init+0x80>
   137a2:	f240 3123 	movw	r1, #803	; 0x323
   137a6:	4818      	ldr	r0, [pc, #96]	; (13808 <FMC_SDRAM_Init+0x180>)
   137a8:	f005 fe8a 	bl	194c0 <assert_failed>
   137ac:	e7ac      	b.n	13708 <FMC_SDRAM_Init+0x80>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
   137ae:	f44f 7148 	mov.w	r1, #800	; 0x320
   137b2:	4815      	ldr	r0, [pc, #84]	; (13808 <FMC_SDRAM_Init+0x180>)
   137b4:	f005 fe84 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
   137b8:	69a3      	ldr	r3, [r4, #24]
   137ba:	f433 7300 	bics.w	r3, r3, #512	; 0x200
   137be:	d098      	beq.n	136f2 <FMC_SDRAM_Init+0x6a>
   137c0:	f240 3121 	movw	r1, #801	; 0x321
   137c4:	4810      	ldr	r0, [pc, #64]	; (13808 <FMC_SDRAM_Init+0x180>)
   137c6:	f005 fe7b 	bl	194c0 <assert_failed>
   137ca:	e792      	b.n	136f2 <FMC_SDRAM_Init+0x6a>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
   137cc:	f240 311e 	movw	r1, #798	; 0x31e
   137d0:	480d      	ldr	r0, [pc, #52]	; (13808 <FMC_SDRAM_Init+0x180>)
   137d2:	f005 fe75 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
   137d6:	6923      	ldr	r3, [r4, #16]
   137d8:	f033 0340 	bics.w	r3, r3, #64	; 0x40
   137dc:	f43f af7d 	beq.w	136da <FMC_SDRAM_Init+0x52>
   137e0:	f240 311f 	movw	r1, #799	; 0x31f
   137e4:	4808      	ldr	r0, [pc, #32]	; (13808 <FMC_SDRAM_Init+0x180>)
   137e6:	f005 fe6b 	bl	194c0 <assert_failed>
   137ea:	e776      	b.n	136da <FMC_SDRAM_Init+0x52>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
   137ec:	f240 311d 	movw	r1, #797	; 0x31d
   137f0:	4805      	ldr	r0, [pc, #20]	; (13808 <FMC_SDRAM_Init+0x180>)
   137f2:	f005 fe65 	bl	194c0 <assert_failed>
   137f6:	e765      	b.n	136c4 <FMC_SDRAM_Init+0x3c>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
   137f8:	f44f 7147 	mov.w	r1, #796	; 0x31c
   137fc:	4802      	ldr	r0, [pc, #8]	; (13808 <FMC_SDRAM_Init+0x180>)
   137fe:	f005 fe5f 	bl	194c0 <assert_failed>
   13802:	e758      	b.n	136b6 <FMC_SDRAM_Init+0x2e>
   13804:	52004140 	.word	0x52004140
   13808:	00030338 	.word	0x00030338
   1380c:	ffff8000 	.word	0xffff8000

00013810 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
   13810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13812:	4b50      	ldr	r3, [pc, #320]	; (13954 <FMC_SDRAM_Timing_Init+0x144>)
{
   13814:	4605      	mov	r5, r0
   13816:	460c      	mov	r4, r1
   13818:	4616      	mov	r6, r2
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   1381a:	4298      	cmp	r0, r3
   1381c:	d004      	beq.n	13828 <FMC_SDRAM_Timing_Init+0x18>
   1381e:	f44f 7156 	mov.w	r1, #856	; 0x358
   13822:	484d      	ldr	r0, [pc, #308]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13824:	f005 fe4c 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
   13828:	6823      	ldr	r3, [r4, #0]
   1382a:	3b01      	subs	r3, #1
   1382c:	2b0f      	cmp	r3, #15
   1382e:	f200 808a 	bhi.w	13946 <FMC_SDRAM_Timing_Init+0x136>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
   13832:	6863      	ldr	r3, [r4, #4]
   13834:	3b01      	subs	r3, #1
   13836:	2b0f      	cmp	r3, #15
   13838:	d87f      	bhi.n	1393a <FMC_SDRAM_Timing_Init+0x12a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
   1383a:	68a3      	ldr	r3, [r4, #8]
   1383c:	3b01      	subs	r3, #1
   1383e:	2b0f      	cmp	r3, #15
   13840:	d875      	bhi.n	1392e <FMC_SDRAM_Timing_Init+0x11e>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
   13842:	68e3      	ldr	r3, [r4, #12]
   13844:	3b01      	subs	r3, #1
   13846:	2b0f      	cmp	r3, #15
   13848:	d86b      	bhi.n	13922 <FMC_SDRAM_Timing_Init+0x112>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
   1384a:	6923      	ldr	r3, [r4, #16]
   1384c:	3b01      	subs	r3, #1
   1384e:	2b0f      	cmp	r3, #15
   13850:	d861      	bhi.n	13916 <FMC_SDRAM_Timing_Init+0x106>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
   13852:	6963      	ldr	r3, [r4, #20]
   13854:	3b01      	subs	r3, #1
   13856:	2b0f      	cmp	r3, #15
   13858:	d857      	bhi.n	1390a <FMC_SDRAM_Timing_Init+0xfa>
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
   1385a:	69a3      	ldr	r3, [r4, #24]
   1385c:	3b01      	subs	r3, #1
   1385e:	2b0f      	cmp	r3, #15
   13860:	d84d      	bhi.n	138fe <FMC_SDRAM_Timing_Init+0xee>
  assert_param(IS_FMC_SDRAM_BANK(Bank));
   13862:	2e01      	cmp	r6, #1
   13864:	d821      	bhi.n	138aa <FMC_SDRAM_Timing_Init+0x9a>
   13866:	68e3      	ldr	r3, [r4, #12]
   13868:	6961      	ldr	r1, [r4, #20]
   1386a:	3b01      	subs	r3, #1
   1386c:	3901      	subs	r1, #1
   1386e:	031b      	lsls	r3, r3, #12
   13870:	0509      	lsls	r1, r1, #20

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
   13872:	bb2e      	cbnz	r6, 138c0 <FMC_SDRAM_Timing_Init+0xb0>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   13874:	6822      	ldr	r2, [r4, #0]
   13876:	430b      	orrs	r3, r1
   13878:	6860      	ldr	r0, [r4, #4]
   1387a:	3a01      	subs	r2, #1
   1387c:	68a1      	ldr	r1, [r4, #8]
   1387e:	1e47      	subs	r7, r0, #1
   13880:	6920      	ldr	r0, [r4, #16]
   13882:	4313      	orrs	r3, r2
   13884:	1e4e      	subs	r6, r1, #1
   13886:	3801      	subs	r0, #1
   13888:	69a1      	ldr	r1, [r4, #24]
   1388a:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
   1388e:	68aa      	ldr	r2, [r5, #8]
   13890:	3901      	subs	r1, #1
   13892:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
   13896:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   1389a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
}
   1389e:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   138a0:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   138a4:	4313      	orrs	r3, r2
   138a6:	60ab      	str	r3, [r5, #8]
}
   138a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_SDRAM_BANK(Bank));
   138aa:	f44f 7158 	mov.w	r1, #864	; 0x360
   138ae:	482a      	ldr	r0, [pc, #168]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   138b0:	f005 fe06 	bl	194c0 <assert_failed>
   138b4:	68e3      	ldr	r3, [r4, #12]
   138b6:	6961      	ldr	r1, [r4, #20]
   138b8:	3b01      	subs	r3, #1
   138ba:	3901      	subs	r1, #1
   138bc:	031b      	lsls	r3, r3, #12
   138be:	0509      	lsls	r1, r1, #20
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
   138c0:	68a8      	ldr	r0, [r5, #8]
   138c2:	430b      	orrs	r3, r1
   138c4:	4a25      	ldr	r2, [pc, #148]	; (1395c <FMC_SDRAM_Timing_Init+0x14c>)
   138c6:	4002      	ands	r2, r0
   138c8:	4313      	orrs	r3, r2
   138ca:	60ab      	str	r3, [r5, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
   138cc:	6820      	ldr	r0, [r4, #0]
   138ce:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   138d2:	1e46      	subs	r6, r0, #1
   138d4:	1e5a      	subs	r2, r3, #1
   138d6:	1e4b      	subs	r3, r1, #1
   138d8:	6921      	ldr	r1, [r4, #16]
   138da:	0212      	lsls	r2, r2, #8
   138dc:	1e48      	subs	r0, r1, #1
   138de:	69a1      	ldr	r1, [r4, #24]
   138e0:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
   138e4:	68ea      	ldr	r2, [r5, #12]
   138e6:	3901      	subs	r1, #1
   138e8:	4333      	orrs	r3, r6
   138ea:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
   138ee:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
}
   138f2:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
   138f4:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   138f8:	4313      	orrs	r3, r2
   138fa:	60eb      	str	r3, [r5, #12]
}
   138fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
   138fe:	f240 315f 	movw	r1, #863	; 0x35f
   13902:	4815      	ldr	r0, [pc, #84]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13904:	f005 fddc 	bl	194c0 <assert_failed>
   13908:	e7ab      	b.n	13862 <FMC_SDRAM_Timing_Init+0x52>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
   1390a:	f240 315e 	movw	r1, #862	; 0x35e
   1390e:	4812      	ldr	r0, [pc, #72]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13910:	f005 fdd6 	bl	194c0 <assert_failed>
   13914:	e7a1      	b.n	1385a <FMC_SDRAM_Timing_Init+0x4a>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
   13916:	f240 315d 	movw	r1, #861	; 0x35d
   1391a:	480f      	ldr	r0, [pc, #60]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   1391c:	f005 fdd0 	bl	194c0 <assert_failed>
   13920:	e797      	b.n	13852 <FMC_SDRAM_Timing_Init+0x42>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
   13922:	f44f 7157 	mov.w	r1, #860	; 0x35c
   13926:	480c      	ldr	r0, [pc, #48]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13928:	f005 fdca 	bl	194c0 <assert_failed>
   1392c:	e78d      	b.n	1384a <FMC_SDRAM_Timing_Init+0x3a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
   1392e:	f240 315b 	movw	r1, #859	; 0x35b
   13932:	4809      	ldr	r0, [pc, #36]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13934:	f005 fdc4 	bl	194c0 <assert_failed>
   13938:	e783      	b.n	13842 <FMC_SDRAM_Timing_Init+0x32>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
   1393a:	f240 315a 	movw	r1, #858	; 0x35a
   1393e:	4806      	ldr	r0, [pc, #24]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   13940:	f005 fdbe 	bl	194c0 <assert_failed>
   13944:	e779      	b.n	1383a <FMC_SDRAM_Timing_Init+0x2a>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
   13946:	f240 3159 	movw	r1, #857	; 0x359
   1394a:	4803      	ldr	r0, [pc, #12]	; (13958 <FMC_SDRAM_Timing_Init+0x148>)
   1394c:	f005 fdb8 	bl	194c0 <assert_failed>
   13950:	e76f      	b.n	13832 <FMC_SDRAM_Timing_Init+0x22>
   13952:	bf00      	nop
   13954:	52004140 	.word	0x52004140
   13958:	00030338 	.word	0x00030338
   1395c:	ff0f0fff 	.word	0xff0f0fff

00013960 <FMC_SDRAM_SendCommand>:
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   13960:	4b22      	ldr	r3, [pc, #136]	; (139ec <FMC_SDRAM_SendCommand+0x8c>)
   13962:	4298      	cmp	r0, r3
{
   13964:	b570      	push	{r4, r5, r6, lr}
   13966:	4605      	mov	r5, r0
   13968:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   1396a:	d004      	beq.n	13976 <FMC_SDRAM_SendCommand+0x16>
   1396c:	f240 31d9 	movw	r1, #985	; 0x3d9
   13970:	481f      	ldr	r0, [pc, #124]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   13972:	f005 fda5 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
   13976:	6823      	ldr	r3, [r4, #0]
   13978:	2b06      	cmp	r3, #6
   1397a:	d831      	bhi.n	139e0 <FMC_SDRAM_SendCommand+0x80>
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
   1397c:	6863      	ldr	r3, [r4, #4]
   1397e:	f023 0210 	bic.w	r2, r3, #16
   13982:	2a08      	cmp	r2, #8
   13984:	d001      	beq.n	1398a <FMC_SDRAM_SendCommand+0x2a>
   13986:	2b10      	cmp	r3, #16
   13988:	d11b      	bne.n	139c2 <FMC_SDRAM_SendCommand+0x62>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
   1398a:	68a3      	ldr	r3, [r4, #8]
   1398c:	3b01      	subs	r3, #1
   1398e:	2b0e      	cmp	r3, #14
   13990:	d820      	bhi.n	139d4 <FMC_SDRAM_SendCommand+0x74>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));
   13992:	68e1      	ldr	r1, [r4, #12]
   13994:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
   13998:	d305      	bcc.n	139a6 <FMC_SDRAM_SendCommand+0x46>
   1399a:	f240 31dd 	movw	r1, #989	; 0x3dd
   1399e:	4814      	ldr	r0, [pc, #80]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139a0:	f005 fd8e 	bl	194c0 <assert_failed>
   139a4:	68e1      	ldr	r1, [r4, #12]

  /* Set command register */
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
   139a6:	6823      	ldr	r3, [r4, #0]
                          (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos)   |
                          ((Command->ModeRegisterDefinition)   << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
   139a8:	2000      	movs	r0, #0
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
   139aa:	e9d4 6201 	ldrd	r6, r2, [r4, #4]
   139ae:	692c      	ldr	r4, [r5, #16]
   139b0:	4333      	orrs	r3, r6
   139b2:	3a01      	subs	r2, #1
   139b4:	4323      	orrs	r3, r4
   139b6:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
   139ba:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
   139be:	612b      	str	r3, [r5, #16]
}
   139c0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
   139c2:	f240 31db 	movw	r1, #987	; 0x3db
   139c6:	480a      	ldr	r0, [pc, #40]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139c8:	f005 fd7a 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
   139cc:	68a3      	ldr	r3, [r4, #8]
   139ce:	3b01      	subs	r3, #1
   139d0:	2b0e      	cmp	r3, #14
   139d2:	d9de      	bls.n	13992 <FMC_SDRAM_SendCommand+0x32>
   139d4:	f44f 7177 	mov.w	r1, #988	; 0x3dc
   139d8:	4805      	ldr	r0, [pc, #20]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139da:	f005 fd71 	bl	194c0 <assert_failed>
   139de:	e7d8      	b.n	13992 <FMC_SDRAM_SendCommand+0x32>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
   139e0:	f240 31da 	movw	r1, #986	; 0x3da
   139e4:	4802      	ldr	r0, [pc, #8]	; (139f0 <FMC_SDRAM_SendCommand+0x90>)
   139e6:	f005 fd6b 	bl	194c0 <assert_failed>
   139ea:	e7c7      	b.n	1397c <FMC_SDRAM_SendCommand+0x1c>
   139ec:	52004140 	.word	0x52004140
   139f0:	00030338 	.word	0x00030338

000139f4 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
   139f4:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   139f6:	4b0d      	ldr	r3, [pc, #52]	; (13a2c <FMC_SDRAM_ProgramRefreshRate+0x38>)
{
   139f8:	4604      	mov	r4, r0
   139fa:	460d      	mov	r5, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
   139fc:	4298      	cmp	r0, r3
   139fe:	d004      	beq.n	13a0a <FMC_SDRAM_ProgramRefreshRate+0x16>
   13a00:	f240 31f2 	movw	r1, #1010	; 0x3f2
   13a04:	480a      	ldr	r0, [pc, #40]	; (13a30 <FMC_SDRAM_ProgramRefreshRate+0x3c>)
   13a06:	f005 fd5b 	bl	194c0 <assert_failed>
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
   13a0a:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
   13a0e:	d304      	bcc.n	13a1a <FMC_SDRAM_ProgramRefreshRate+0x26>
   13a10:	f240 31f3 	movw	r1, #1011	; 0x3f3
   13a14:	4806      	ldr	r0, [pc, #24]	; (13a30 <FMC_SDRAM_ProgramRefreshRate+0x3c>)
   13a16:	f005 fd53 	bl	194c0 <assert_failed>

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
   13a1a:	6963      	ldr	r3, [r4, #20]

  return HAL_OK;
}
   13a1c:	2000      	movs	r0, #0
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
   13a1e:	4905      	ldr	r1, [pc, #20]	; (13a34 <FMC_SDRAM_ProgramRefreshRate+0x40>)
   13a20:	4019      	ands	r1, r3
   13a22:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
   13a26:	6161      	str	r1, [r4, #20]
}
   13a28:	bd38      	pop	{r3, r4, r5, pc}
   13a2a:	bf00      	nop
   13a2c:	52004140 	.word	0x52004140
   13a30:	00030338 	.word	0x00030338
   13a34:	ffffc001 	.word	0xffffc001

00013a38 <SDMMC_GetCmdResp1.part.2>:
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
   13a38:	4b30      	ldr	r3, [pc, #192]	; (13afc <SDMMC_GetCmdResp1.part.2+0xc4>)
  return (*(__IO uint32_t *) tmp);
   13a3a:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
   13a3c:	4013      	ands	r3, r2
   13a3e:	b34b      	cbz	r3, 13a94 <SDMMC_GetCmdResp1.part.2+0x5c>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
   13a40:	2a00      	cmp	r2, #0
   13a42:	db29      	blt.n	13a98 <SDMMC_GetCmdResp1.part.2+0x60>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
   13a44:	0051      	lsls	r1, r2, #1
   13a46:	d42d      	bmi.n	13aa4 <SDMMC_GetCmdResp1.part.2+0x6c>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
   13a48:	0093      	lsls	r3, r2, #2
   13a4a:	d42d      	bmi.n	13aa8 <SDMMC_GetCmdResp1.part.2+0x70>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
   13a4c:	00d1      	lsls	r1, r2, #3
   13a4e:	d426      	bmi.n	13a9e <SDMMC_GetCmdResp1.part.2+0x66>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
   13a50:	0113      	lsls	r3, r2, #4
   13a52:	d42e      	bmi.n	13ab2 <SDMMC_GetCmdResp1.part.2+0x7a>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
   13a54:	0151      	lsls	r1, r2, #5
   13a56:	d42f      	bmi.n	13ab8 <SDMMC_GetCmdResp1.part.2+0x80>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
   13a58:	01d3      	lsls	r3, r2, #7
   13a5a:	d427      	bmi.n	13aac <SDMMC_GetCmdResp1.part.2+0x74>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
   13a5c:	0211      	lsls	r1, r2, #8
   13a5e:	d42e      	bmi.n	13abe <SDMMC_GetCmdResp1.part.2+0x86>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
   13a60:	0253      	lsls	r3, r2, #9
   13a62:	d42f      	bmi.n	13ac4 <SDMMC_GetCmdResp1.part.2+0x8c>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
   13a64:	0291      	lsls	r1, r2, #10
   13a66:	d430      	bmi.n	13aca <SDMMC_GetCmdResp1.part.2+0x92>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
   13a68:	02d3      	lsls	r3, r2, #11
   13a6a:	d431      	bmi.n	13ad0 <SDMMC_GetCmdResp1.part.2+0x98>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
   13a6c:	0351      	lsls	r1, r2, #13
   13a6e:	d432      	bmi.n	13ad6 <SDMMC_GetCmdResp1.part.2+0x9e>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
   13a70:	0393      	lsls	r3, r2, #14
   13a72:	d433      	bmi.n	13adc <SDMMC_GetCmdResp1.part.2+0xa4>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
   13a74:	03d1      	lsls	r1, r2, #15
   13a76:	d434      	bmi.n	13ae2 <SDMMC_GetCmdResp1.part.2+0xaa>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
   13a78:	0413      	lsls	r3, r2, #16
   13a7a:	d435      	bmi.n	13ae8 <SDMMC_GetCmdResp1.part.2+0xb0>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
   13a7c:	0451      	lsls	r1, r2, #17
   13a7e:	d436      	bmi.n	13aee <SDMMC_GetCmdResp1.part.2+0xb6>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
   13a80:	0493      	lsls	r3, r2, #18
   13a82:	d437      	bmi.n	13af4 <SDMMC_GetCmdResp1.part.2+0xbc>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
   13a84:	f012 0f08 	tst.w	r2, #8
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
   13a88:	bf14      	ite	ne
   13a8a:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
   13a8e:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   13a92:	4770      	bx	lr
    return SDMMC_ERROR_NONE;
   13a94:	4618      	mov	r0, r3
   13a96:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
   13a98:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
   13a9c:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
   13a9e:	f44f 7080 	mov.w	r0, #256	; 0x100
   13aa2:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
   13aa4:	2040      	movs	r0, #64	; 0x40
   13aa6:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
   13aa8:	2080      	movs	r0, #128	; 0x80
   13aaa:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
   13aac:	f44f 6000 	mov.w	r0, #2048	; 0x800
   13ab0:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
   13ab2:	f44f 7000 	mov.w	r0, #512	; 0x200
   13ab6:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
   13ab8:	f44f 6080 	mov.w	r0, #1024	; 0x400
   13abc:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
   13abe:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   13ac2:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
   13ac4:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   13ac8:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
   13aca:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   13ace:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
   13ad0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   13ad4:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
   13ad6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   13ada:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
   13adc:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   13ae0:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
   13ae2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   13ae6:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
   13ae8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   13aec:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
   13aee:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   13af2:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
   13af4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
}
   13af8:	4770      	bx	lr
   13afa:	bf00      	nop
   13afc:	fdffe008 	.word	0xfdffe008

00013b00 <SDMMC_Init>:
{
   13b00:	b084      	sub	sp, #16
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b02:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 13bbc <SDMMC_Init+0xbc>
{
   13b06:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13b0a:	4605      	mov	r5, r0
   13b0c:	a809      	add	r0, sp, #36	; 0x24
   13b0e:	460c      	mov	r4, r1
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b10:	4565      	cmp	r5, ip
   13b12:	e9dd 760c 	ldrd	r7, r6, [sp, #48]	; 0x30
{
   13b16:	e880 000e 	stmia.w	r0, {r1, r2, r3}
   13b1a:	e9dd 980a 	ldrd	r9, r8, [sp, #40]	; 0x28
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b1e:	d002      	beq.n	13b26 <SDMMC_Init+0x26>
   13b20:	4b23      	ldr	r3, [pc, #140]	; (13bb0 <SDMMC_Init+0xb0>)
   13b22:	429d      	cmp	r5, r3
   13b24:	d125      	bne.n	13b72 <SDMMC_Init+0x72>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
   13b26:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
   13b2a:	d129      	bne.n	13b80 <SDMMC_Init+0x80>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
   13b2c:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
   13b30:	d12d      	bne.n	13b8e <SDMMC_Init+0x8e>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
   13b32:	f438 4380 	bics.w	r3, r8, #16384	; 0x4000
   13b36:	d002      	beq.n	13b3e <SDMMC_Init+0x3e>
   13b38:	f5b8 4f00 	cmp.w	r8, #32768	; 0x8000
   13b3c:	d12c      	bne.n	13b98 <SDMMC_Init+0x98>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
   13b3e:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
   13b42:	d130      	bne.n	13ba6 <SDMMC_Init+0xa6>
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
   13b44:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   13b48:	d303      	bcc.n	13b52 <SDMMC_Init+0x52>
   13b4a:	21d7      	movs	r1, #215	; 0xd7
   13b4c:	4819      	ldr	r0, [pc, #100]	; (13bb4 <SDMMC_Init+0xb4>)
   13b4e:	f005 fcb7 	bl	194c0 <assert_failed>
  tmpreg |= (Init.ClockEdge           |\
   13b52:	ea44 0309 	orr.w	r3, r4, r9
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   13b56:	6869      	ldr	r1, [r5, #4]
   13b58:	4a17      	ldr	r2, [pc, #92]	; (13bb8 <SDMMC_Init+0xb8>)
}
   13b5a:	2000      	movs	r0, #0
             Init.ClockPowerSave      |\
   13b5c:	ea43 0308 	orr.w	r3, r3, r8
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   13b60:	400a      	ands	r2, r1
             Init.BusWide             |\
   13b62:	433b      	orrs	r3, r7
             Init.HardwareFlowControl |\
   13b64:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
   13b66:	4313      	orrs	r3, r2
   13b68:	606b      	str	r3, [r5, #4]
}
   13b6a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13b6e:	b004      	add	sp, #16
   13b70:	4770      	bx	lr
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
   13b72:	21d2      	movs	r1, #210	; 0xd2
   13b74:	480f      	ldr	r0, [pc, #60]	; (13bb4 <SDMMC_Init+0xb4>)
   13b76:	f005 fca3 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
   13b7a:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
   13b7e:	d0d5      	beq.n	13b2c <SDMMC_Init+0x2c>
   13b80:	21d3      	movs	r1, #211	; 0xd3
   13b82:	480c      	ldr	r0, [pc, #48]	; (13bb4 <SDMMC_Init+0xb4>)
   13b84:	f005 fc9c 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
   13b88:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
   13b8c:	d0d1      	beq.n	13b32 <SDMMC_Init+0x32>
   13b8e:	21d4      	movs	r1, #212	; 0xd4
   13b90:	4808      	ldr	r0, [pc, #32]	; (13bb4 <SDMMC_Init+0xb4>)
   13b92:	f005 fc95 	bl	194c0 <assert_failed>
   13b96:	e7cc      	b.n	13b32 <SDMMC_Init+0x32>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
   13b98:	21d5      	movs	r1, #213	; 0xd5
   13b9a:	4806      	ldr	r0, [pc, #24]	; (13bb4 <SDMMC_Init+0xb4>)
   13b9c:	f005 fc90 	bl	194c0 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
   13ba0:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
   13ba4:	d0ce      	beq.n	13b44 <SDMMC_Init+0x44>
   13ba6:	21d6      	movs	r1, #214	; 0xd6
   13ba8:	4802      	ldr	r0, [pc, #8]	; (13bb4 <SDMMC_Init+0xb4>)
   13baa:	f005 fc89 	bl	194c0 <assert_failed>
   13bae:	e7c9      	b.n	13b44 <SDMMC_Init+0x44>
   13bb0:	48022400 	.word	0x48022400
   13bb4:	00030370 	.word	0x00030370
   13bb8:	ffc02c00 	.word	0xffc02c00
   13bbc:	52007000 	.word	0x52007000

00013bc0 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
   13bc0:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
   13bc4:	4770      	bx	lr
   13bc6:	bf00      	nop

00013bc8 <SDMMC_WriteFIFO>:
{
   13bc8:	4603      	mov	r3, r0
  SDMMCx->FIFO = *pWriteData;
   13bca:	680a      	ldr	r2, [r1, #0]
}
   13bcc:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
   13bce:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
   13bd2:	4770      	bx	lr

00013bd4 <SDMMC_PowerState_ON>:
{
   13bd4:	4602      	mov	r2, r0
}
   13bd6:	2000      	movs	r0, #0
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
   13bd8:	6813      	ldr	r3, [r2, #0]
   13bda:	f043 0303 	orr.w	r3, r3, #3
   13bde:	6013      	str	r3, [r2, #0]
}
   13be0:	4770      	bx	lr
   13be2:	bf00      	nop

00013be4 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
   13be4:	6800      	ldr	r0, [r0, #0]
}
   13be6:	f000 0003 	and.w	r0, r0, #3
   13bea:	4770      	bx	lr

00013bec <SDMMC_GetResponse>:
{
   13bec:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_SDMMC_RESP(Response));
   13bee:	f031 030c 	bics.w	r3, r1, #12
{
   13bf2:	460d      	mov	r5, r1
   13bf4:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_RESP(Response));
   13bf6:	d004      	beq.n	13c02 <SDMMC_GetResponse+0x16>
   13bf8:	f44f 71cc 	mov.w	r1, #408	; 0x198
   13bfc:	4802      	ldr	r0, [pc, #8]	; (13c08 <SDMMC_GetResponse+0x1c>)
   13bfe:	f005 fc5f 	bl	194c0 <assert_failed>
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
   13c02:	3414      	adds	r4, #20
  return (*(__IO uint32_t *) tmp);
   13c04:	5960      	ldr	r0, [r4, r5]
}
   13c06:	bd38      	pop	{r3, r4, r5, pc}
   13c08:	00030370 	.word	0x00030370

00013c0c <SDMMC_ConfigData>:
{
   13c0c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   13c0e:	684b      	ldr	r3, [r1, #4]
{
   13c10:	460c      	mov	r4, r1
   13c12:	4605      	mov	r5, r0
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   13c14:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   13c18:	d23b      	bcs.n	13c92 <SDMMC_ConfigData+0x86>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
   13c1a:	68a2      	ldr	r2, [r4, #8]
   13c1c:	f032 0130 	bics.w	r1, r2, #48	; 0x30
   13c20:	bf14      	ite	ne
   13c22:	2301      	movne	r3, #1
   13c24:	2300      	moveq	r3, #0
   13c26:	2940      	cmp	r1, #64	; 0x40
   13c28:	bf0c      	ite	eq
   13c2a:	2300      	moveq	r3, #0
   13c2c:	f003 0301 	andne.w	r3, r3, #1
   13c30:	2ae0      	cmp	r2, #224	; 0xe0
   13c32:	bf0c      	ite	eq
   13c34:	2300      	moveq	r3, #0
   13c36:	f003 0301 	andne.w	r3, r3, #1
   13c3a:	2980      	cmp	r1, #128	; 0x80
   13c3c:	bf0c      	ite	eq
   13c3e:	2300      	moveq	r3, #0
   13c40:	f003 0301 	andne.w	r3, r3, #1
   13c44:	b11b      	cbz	r3, 13c4e <SDMMC_ConfigData+0x42>
   13c46:	f022 0210 	bic.w	r2, r2, #16
   13c4a:	2ac0      	cmp	r2, #192	; 0xc0
   13c4c:	d133      	bne.n	13cb6 <SDMMC_ConfigData+0xaa>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
   13c4e:	68e3      	ldr	r3, [r4, #12]
   13c50:	f033 0302 	bics.w	r3, r3, #2
   13c54:	d129      	bne.n	13caa <SDMMC_ConfigData+0x9e>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
   13c56:	6923      	ldr	r3, [r4, #16]
   13c58:	f033 0308 	bics.w	r3, r3, #8
   13c5c:	d11f      	bne.n	13c9e <SDMMC_ConfigData+0x92>
  assert_param(IS_SDMMC_DPSM(Data->DPSM));
   13c5e:	6963      	ldr	r3, [r4, #20]
   13c60:	2b01      	cmp	r3, #1
   13c62:	d904      	bls.n	13c6e <SDMMC_ConfigData+0x62>
   13c64:	f240 11b1 	movw	r1, #433	; 0x1b1
   13c68:	4816      	ldr	r0, [pc, #88]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13c6a:	f005 fc29 	bl	194c0 <assert_failed>
  SDMMCx->DTIMER = Data->DataTimeOut;
   13c6e:	6823      	ldr	r3, [r4, #0]
}
   13c70:	2000      	movs	r0, #0
  SDMMCx->DTIMER = Data->DataTimeOut;
   13c72:	626b      	str	r3, [r5, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
   13c74:	6863      	ldr	r3, [r4, #4]
   13c76:	62ab      	str	r3, [r5, #40]	; 0x28
                       Data->TransferDir   |\
   13c78:	6926      	ldr	r6, [r4, #16]
                       Data->TransferMode  |\
   13c7a:	6961      	ldr	r1, [r4, #20]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
   13c7c:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   13c80:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   13c82:	6aea      	ldr	r2, [r5, #44]	; 0x2c
                       Data->TransferDir   |\
   13c84:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   13c86:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
                       Data->TransferMode  |\
   13c8a:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   13c8c:	4313      	orrs	r3, r2
   13c8e:	62eb      	str	r3, [r5, #44]	; 0x2c
}
   13c90:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
   13c92:	f240 11ad 	movw	r1, #429	; 0x1ad
   13c96:	480b      	ldr	r0, [pc, #44]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13c98:	f005 fc12 	bl	194c0 <assert_failed>
   13c9c:	e7bd      	b.n	13c1a <SDMMC_ConfigData+0xe>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
   13c9e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
   13ca2:	4808      	ldr	r0, [pc, #32]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13ca4:	f005 fc0c 	bl	194c0 <assert_failed>
   13ca8:	e7d9      	b.n	13c5e <SDMMC_ConfigData+0x52>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
   13caa:	f240 11af 	movw	r1, #431	; 0x1af
   13cae:	4805      	ldr	r0, [pc, #20]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13cb0:	f005 fc06 	bl	194c0 <assert_failed>
   13cb4:	e7cf      	b.n	13c56 <SDMMC_ConfigData+0x4a>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
   13cb6:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   13cba:	4802      	ldr	r0, [pc, #8]	; (13cc4 <SDMMC_ConfigData+0xb8>)
   13cbc:	f005 fc00 	bl	194c0 <assert_failed>
   13cc0:	e7c5      	b.n	13c4e <SDMMC_ConfigData+0x42>
   13cc2:	bf00      	nop
   13cc4:	00030370 	.word	0x00030370

00013cc8 <SDMMC_CmdBlockLength>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cc8:	4a1c      	ldr	r2, [pc, #112]	; (13d3c <SDMMC_CmdBlockLength+0x74>)
   13cca:	4b1d      	ldr	r3, [pc, #116]	; (13d40 <SDMMC_CmdBlockLength+0x78>)
{
   13ccc:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cce:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13cd0:	f241 1410 	movw	r4, #4368	; 0x1110
  SDMMCx->ARG = Command->Argument;
   13cd4:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cd6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13cda:	68c1      	ldr	r1, [r0, #12]
   13cdc:	4d19      	ldr	r5, [pc, #100]	; (13d44 <SDMMC_CmdBlockLength+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13cde:	f241 3388 	movw	r3, #5000	; 0x1388
   13ce2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13ce4:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13ce6:	4918      	ldr	r1, [pc, #96]	; (13d48 <SDMMC_CmdBlockLength+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13ce8:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13cec:	432c      	orrs	r4, r5
   13cee:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13cf0:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13cf4:	d312      	bcc.n	13d1c <SDMMC_CmdBlockLength+0x54>
    sta_reg = SDMMCx->STA;
   13cf6:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13cf8:	420a      	tst	r2, r1
   13cfa:	d0f9      	beq.n	13cf0 <SDMMC_CmdBlockLength+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13cfc:	0494      	lsls	r4, r2, #18
   13cfe:	d4f7      	bmi.n	13cf0 <SDMMC_CmdBlockLength+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13d00:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d02:	075a      	lsls	r2, r3, #29
   13d04:	d40e      	bmi.n	13d24 <SDMMC_CmdBlockLength+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13d06:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d08:	07db      	lsls	r3, r3, #31
   13d0a:	d40f      	bmi.n	13d2c <SDMMC_CmdBlockLength+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13d0c:	4b0f      	ldr	r3, [pc, #60]	; (13d4c <SDMMC_CmdBlockLength+0x84>)
   13d0e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13d10:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13d12:	b2db      	uxtb	r3, r3
   13d14:	2b10      	cmp	r3, #16
   13d16:	d00d      	beq.n	13d34 <SDMMC_CmdBlockLength+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13d18:	2001      	movs	r0, #1
  return errorstate;
   13d1a:	e001      	b.n	13d20 <SDMMC_CmdBlockLength+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13d1c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13d20:	bc30      	pop	{r4, r5}
   13d22:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13d24:	2304      	movs	r3, #4
   13d26:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13d28:	4618      	mov	r0, r3
   13d2a:	e7f9      	b.n	13d20 <SDMMC_CmdBlockLength+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13d2c:	2301      	movs	r3, #1
   13d2e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13d30:	4618      	mov	r0, r3
   13d32:	e7f5      	b.n	13d20 <SDMMC_CmdBlockLength+0x58>
}
   13d34:	bc30      	pop	{r4, r5}
   13d36:	f7ff be7f 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13d3a:	bf00      	nop
   13d3c:	00062b44 	.word	0x00062b44
   13d40:	10624dd3 	.word	0x10624dd3
   13d44:	fffee0c0 	.word	0xfffee0c0
   13d48:	00200045 	.word	0x00200045
   13d4c:	002000c5 	.word	0x002000c5

00013d50 <SDMMC_CmdReadSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d50:	4a1c      	ldr	r2, [pc, #112]	; (13dc4 <SDMMC_CmdReadSingleBlock+0x74>)
   13d52:	4b1d      	ldr	r3, [pc, #116]	; (13dc8 <SDMMC_CmdReadSingleBlock+0x78>)
{
   13d54:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d56:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d58:	f241 1411 	movw	r4, #4369	; 0x1111
  SDMMCx->ARG = Command->Argument;
   13d5c:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d5e:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d62:	68c1      	ldr	r1, [r0, #12]
   13d64:	4d19      	ldr	r5, [pc, #100]	; (13dcc <SDMMC_CmdReadSingleBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d66:	f241 3388 	movw	r3, #5000	; 0x1388
   13d6a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d6c:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13d6e:	4918      	ldr	r1, [pc, #96]	; (13dd0 <SDMMC_CmdReadSingleBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13d70:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13d74:	432c      	orrs	r4, r5
   13d76:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13d78:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13d7c:	d312      	bcc.n	13da4 <SDMMC_CmdReadSingleBlock+0x54>
    sta_reg = SDMMCx->STA;
   13d7e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13d80:	420a      	tst	r2, r1
   13d82:	d0f9      	beq.n	13d78 <SDMMC_CmdReadSingleBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13d84:	0494      	lsls	r4, r2, #18
   13d86:	d4f7      	bmi.n	13d78 <SDMMC_CmdReadSingleBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13d88:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d8a:	075a      	lsls	r2, r3, #29
   13d8c:	d40e      	bmi.n	13dac <SDMMC_CmdReadSingleBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13d8e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13d90:	07db      	lsls	r3, r3, #31
   13d92:	d40f      	bmi.n	13db4 <SDMMC_CmdReadSingleBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13d94:	4b0f      	ldr	r3, [pc, #60]	; (13dd4 <SDMMC_CmdReadSingleBlock+0x84>)
   13d96:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13d98:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13d9a:	b2db      	uxtb	r3, r3
   13d9c:	2b11      	cmp	r3, #17
   13d9e:	d00d      	beq.n	13dbc <SDMMC_CmdReadSingleBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13da0:	2001      	movs	r0, #1
  return errorstate;
   13da2:	e001      	b.n	13da8 <SDMMC_CmdReadSingleBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13da4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13da8:	bc30      	pop	{r4, r5}
   13daa:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13dac:	2304      	movs	r3, #4
   13dae:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13db0:	4618      	mov	r0, r3
   13db2:	e7f9      	b.n	13da8 <SDMMC_CmdReadSingleBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13db4:	2301      	movs	r3, #1
   13db6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13db8:	4618      	mov	r0, r3
   13dba:	e7f5      	b.n	13da8 <SDMMC_CmdReadSingleBlock+0x58>
}
   13dbc:	bc30      	pop	{r4, r5}
   13dbe:	f7ff be3b 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13dc2:	bf00      	nop
   13dc4:	00062b44 	.word	0x00062b44
   13dc8:	10624dd3 	.word	0x10624dd3
   13dcc:	fffee0c0 	.word	0xfffee0c0
   13dd0:	00200045 	.word	0x00200045
   13dd4:	002000c5 	.word	0x002000c5

00013dd8 <SDMMC_CmdReadMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13dd8:	4a1c      	ldr	r2, [pc, #112]	; (13e4c <SDMMC_CmdReadMultiBlock+0x74>)
   13dda:	4b1d      	ldr	r3, [pc, #116]	; (13e50 <SDMMC_CmdReadMultiBlock+0x78>)
{
   13ddc:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13dde:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13de0:	f241 1412 	movw	r4, #4370	; 0x1112
  SDMMCx->ARG = Command->Argument;
   13de4:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13de6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13dea:	68c1      	ldr	r1, [r0, #12]
   13dec:	4d19      	ldr	r5, [pc, #100]	; (13e54 <SDMMC_CmdReadMultiBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13dee:	f241 3388 	movw	r3, #5000	; 0x1388
   13df2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13df4:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13df6:	4918      	ldr	r1, [pc, #96]	; (13e58 <SDMMC_CmdReadMultiBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13df8:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13dfc:	432c      	orrs	r4, r5
   13dfe:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13e00:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13e04:	d312      	bcc.n	13e2c <SDMMC_CmdReadMultiBlock+0x54>
    sta_reg = SDMMCx->STA;
   13e06:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13e08:	420a      	tst	r2, r1
   13e0a:	d0f9      	beq.n	13e00 <SDMMC_CmdReadMultiBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13e0c:	0494      	lsls	r4, r2, #18
   13e0e:	d4f7      	bmi.n	13e00 <SDMMC_CmdReadMultiBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13e10:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13e12:	075a      	lsls	r2, r3, #29
   13e14:	d40e      	bmi.n	13e34 <SDMMC_CmdReadMultiBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13e16:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13e18:	07db      	lsls	r3, r3, #31
   13e1a:	d40f      	bmi.n	13e3c <SDMMC_CmdReadMultiBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13e1c:	4b0f      	ldr	r3, [pc, #60]	; (13e5c <SDMMC_CmdReadMultiBlock+0x84>)
   13e1e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13e20:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13e22:	b2db      	uxtb	r3, r3
   13e24:	2b12      	cmp	r3, #18
   13e26:	d00d      	beq.n	13e44 <SDMMC_CmdReadMultiBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13e28:	2001      	movs	r0, #1
  return errorstate;
   13e2a:	e001      	b.n	13e30 <SDMMC_CmdReadMultiBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13e2c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13e30:	bc30      	pop	{r4, r5}
   13e32:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13e34:	2304      	movs	r3, #4
   13e36:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13e38:	4618      	mov	r0, r3
   13e3a:	e7f9      	b.n	13e30 <SDMMC_CmdReadMultiBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13e3c:	2301      	movs	r3, #1
   13e3e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13e40:	4618      	mov	r0, r3
   13e42:	e7f5      	b.n	13e30 <SDMMC_CmdReadMultiBlock+0x58>
}
   13e44:	bc30      	pop	{r4, r5}
   13e46:	f7ff bdf7 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13e4a:	bf00      	nop
   13e4c:	00062b44 	.word	0x00062b44
   13e50:	10624dd3 	.word	0x10624dd3
   13e54:	fffee0c0 	.word	0xfffee0c0
   13e58:	00200045 	.word	0x00200045
   13e5c:	002000c5 	.word	0x002000c5

00013e60 <SDMMC_CmdWriteSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e60:	4a1c      	ldr	r2, [pc, #112]	; (13ed4 <SDMMC_CmdWriteSingleBlock+0x74>)
   13e62:	4b1d      	ldr	r3, [pc, #116]	; (13ed8 <SDMMC_CmdWriteSingleBlock+0x78>)
{
   13e64:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e66:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e68:	f241 1418 	movw	r4, #4376	; 0x1118
  SDMMCx->ARG = Command->Argument;
   13e6c:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e6e:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e72:	68c1      	ldr	r1, [r0, #12]
   13e74:	4d19      	ldr	r5, [pc, #100]	; (13edc <SDMMC_CmdWriteSingleBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e76:	f241 3388 	movw	r3, #5000	; 0x1388
   13e7a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e7c:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13e7e:	4918      	ldr	r1, [pc, #96]	; (13ee0 <SDMMC_CmdWriteSingleBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13e80:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13e84:	432c      	orrs	r4, r5
   13e86:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13e88:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13e8c:	d312      	bcc.n	13eb4 <SDMMC_CmdWriteSingleBlock+0x54>
    sta_reg = SDMMCx->STA;
   13e8e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13e90:	420a      	tst	r2, r1
   13e92:	d0f9      	beq.n	13e88 <SDMMC_CmdWriteSingleBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13e94:	0494      	lsls	r4, r2, #18
   13e96:	d4f7      	bmi.n	13e88 <SDMMC_CmdWriteSingleBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13e98:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13e9a:	075a      	lsls	r2, r3, #29
   13e9c:	d40e      	bmi.n	13ebc <SDMMC_CmdWriteSingleBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13e9e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13ea0:	07db      	lsls	r3, r3, #31
   13ea2:	d40f      	bmi.n	13ec4 <SDMMC_CmdWriteSingleBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13ea4:	4b0f      	ldr	r3, [pc, #60]	; (13ee4 <SDMMC_CmdWriteSingleBlock+0x84>)
   13ea6:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13ea8:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13eaa:	b2db      	uxtb	r3, r3
   13eac:	2b18      	cmp	r3, #24
   13eae:	d00d      	beq.n	13ecc <SDMMC_CmdWriteSingleBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13eb0:	2001      	movs	r0, #1
  return errorstate;
   13eb2:	e001      	b.n	13eb8 <SDMMC_CmdWriteSingleBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13eb4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13eb8:	bc30      	pop	{r4, r5}
   13eba:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13ebc:	2304      	movs	r3, #4
   13ebe:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13ec0:	4618      	mov	r0, r3
   13ec2:	e7f9      	b.n	13eb8 <SDMMC_CmdWriteSingleBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13ec4:	2301      	movs	r3, #1
   13ec6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13ec8:	4618      	mov	r0, r3
   13eca:	e7f5      	b.n	13eb8 <SDMMC_CmdWriteSingleBlock+0x58>
}
   13ecc:	bc30      	pop	{r4, r5}
   13ece:	f7ff bdb3 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13ed2:	bf00      	nop
   13ed4:	00062b44 	.word	0x00062b44
   13ed8:	10624dd3 	.word	0x10624dd3
   13edc:	fffee0c0 	.word	0xfffee0c0
   13ee0:	00200045 	.word	0x00200045
   13ee4:	002000c5 	.word	0x002000c5

00013ee8 <SDMMC_CmdWriteMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13ee8:	4a1c      	ldr	r2, [pc, #112]	; (13f5c <SDMMC_CmdWriteMultiBlock+0x74>)
   13eea:	4b1d      	ldr	r3, [pc, #116]	; (13f60 <SDMMC_CmdWriteMultiBlock+0x78>)
{
   13eec:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13eee:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13ef0:	f241 1419 	movw	r4, #4377	; 0x1119
  SDMMCx->ARG = Command->Argument;
   13ef4:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13ef6:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13efa:	68c1      	ldr	r1, [r0, #12]
   13efc:	4d19      	ldr	r5, [pc, #100]	; (13f64 <SDMMC_CmdWriteMultiBlock+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13efe:	f241 3388 	movw	r3, #5000	; 0x1388
   13f02:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f04:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13f06:	4918      	ldr	r1, [pc, #96]	; (13f68 <SDMMC_CmdWriteMultiBlock+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f08:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f0c:	432c      	orrs	r4, r5
   13f0e:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13f10:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   13f14:	d312      	bcc.n	13f3c <SDMMC_CmdWriteMultiBlock+0x54>
    sta_reg = SDMMCx->STA;
   13f16:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13f18:	420a      	tst	r2, r1
   13f1a:	d0f9      	beq.n	13f10 <SDMMC_CmdWriteMultiBlock+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13f1c:	0494      	lsls	r4, r2, #18
   13f1e:	d4f7      	bmi.n	13f10 <SDMMC_CmdWriteMultiBlock+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13f20:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13f22:	075a      	lsls	r2, r3, #29
   13f24:	d40e      	bmi.n	13f44 <SDMMC_CmdWriteMultiBlock+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13f26:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13f28:	07db      	lsls	r3, r3, #31
   13f2a:	d40f      	bmi.n	13f4c <SDMMC_CmdWriteMultiBlock+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13f2c:	4b0f      	ldr	r3, [pc, #60]	; (13f6c <SDMMC_CmdWriteMultiBlock+0x84>)
   13f2e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13f30:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13f32:	b2db      	uxtb	r3, r3
   13f34:	2b19      	cmp	r3, #25
   13f36:	d00d      	beq.n	13f54 <SDMMC_CmdWriteMultiBlock+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13f38:	2001      	movs	r0, #1
  return errorstate;
   13f3a:	e001      	b.n	13f40 <SDMMC_CmdWriteMultiBlock+0x58>
      return SDMMC_ERROR_TIMEOUT;
   13f3c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   13f40:	bc30      	pop	{r4, r5}
   13f42:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13f44:	2304      	movs	r3, #4
   13f46:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   13f48:	4618      	mov	r0, r3
   13f4a:	e7f9      	b.n	13f40 <SDMMC_CmdWriteMultiBlock+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13f4c:	2301      	movs	r3, #1
   13f4e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13f50:	4618      	mov	r0, r3
   13f52:	e7f5      	b.n	13f40 <SDMMC_CmdWriteMultiBlock+0x58>
}
   13f54:	bc30      	pop	{r4, r5}
   13f56:	f7ff bd6f 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   13f5a:	bf00      	nop
   13f5c:	00062b44 	.word	0x00062b44
   13f60:	10624dd3 	.word	0x10624dd3
   13f64:	fffee0c0 	.word	0xfffee0c0
   13f68:	00200045 	.word	0x00200045
   13f6c:	002000c5 	.word	0x002000c5

00013f70 <SDMMC_CmdStopTransfer>:
{
   13f70:	b570      	push	{r4, r5, r6, lr}
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   13f72:	68c3      	ldr	r3, [r0, #12]
  SDMMCx->ARG = Command->Argument;
   13f74:	2600      	movs	r6, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f76:	4a2a      	ldr	r2, [pc, #168]	; (14020 <SDMMC_CmdStopTransfer+0xb0>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f78:	f241 140c 	movw	r4, #4364	; 0x110c
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   13f7c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f80:	4d28      	ldr	r5, [pc, #160]	; (14024 <SDMMC_CmdStopTransfer+0xb4>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f82:	6812      	ldr	r2, [r2, #0]
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
   13f84:	60c3      	str	r3, [r0, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   13f86:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f88:	4b27      	ldr	r3, [pc, #156]	; (14028 <SDMMC_CmdStopTransfer+0xb8>)
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   13f8a:	f021 0140 	bic.w	r1, r1, #64	; 0x40
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f8e:	fba3 3202 	umull	r3, r2, r3, r2
   13f92:	4b26      	ldr	r3, [pc, #152]	; (1402c <SDMMC_CmdStopTransfer+0xbc>)
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
   13f94:	60c1      	str	r1, [r0, #12]
  SDMMCx->ARG = Command->Argument;
   13f96:	6086      	str	r6, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f98:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13f9a:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   13f9c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13fa0:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13fa2:	4923      	ldr	r1, [pc, #140]	; (14030 <SDMMC_CmdStopTransfer+0xc0>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   13fa4:	432c      	orrs	r4, r5
   13fa6:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   13fa8:	b1c3      	cbz	r3, 13fdc <SDMMC_CmdStopTransfer+0x6c>
    sta_reg = SDMMCx->STA;
   13faa:	6b42      	ldr	r2, [r0, #52]	; 0x34
   13fac:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   13fae:	420a      	tst	r2, r1
   13fb0:	d0fa      	beq.n	13fa8 <SDMMC_CmdStopTransfer+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   13fb2:	0492      	lsls	r2, r2, #18
   13fb4:	d4f8      	bmi.n	13fa8 <SDMMC_CmdStopTransfer+0x38>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   13fb6:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13fb8:	075b      	lsls	r3, r3, #29
   13fba:	d417      	bmi.n	13fec <SDMMC_CmdStopTransfer+0x7c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   13fbc:	6b44      	ldr	r4, [r0, #52]	; 0x34
   13fbe:	f014 0401 	ands.w	r4, r4, #1
   13fc2:	d11a      	bne.n	13ffa <SDMMC_CmdStopTransfer+0x8a>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   13fc4:	4b1b      	ldr	r3, [pc, #108]	; (14034 <SDMMC_CmdStopTransfer+0xc4>)
   13fc6:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   13fc8:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   13fca:	b2db      	uxtb	r3, r3
   13fcc:	2b0c      	cmp	r3, #12
   13fce:	d01b      	beq.n	14008 <SDMMC_CmdStopTransfer+0x98>
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13fd0:	68c3      	ldr	r3, [r0, #12]
    return SDMMC_ERROR_CMD_CRC_FAIL;
   13fd2:	2401      	movs	r4, #1
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13fd4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13fd8:	60c3      	str	r3, [r0, #12]
   13fda:	e005      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
   13fdc:	68c3      	ldr	r3, [r0, #12]
      return SDMMC_ERROR_TIMEOUT;
   13fde:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13fe2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13fe6:	60c3      	str	r3, [r0, #12]
}
   13fe8:	4620      	mov	r0, r4
   13fea:	bd70      	pop	{r4, r5, r6, pc}
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   13fec:	2404      	movs	r4, #4
   13fee:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13ff0:	68c3      	ldr	r3, [r0, #12]
   13ff2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13ff6:	60c3      	str	r3, [r0, #12]
   13ff8:	e7f6      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   13ffa:	2401      	movs	r4, #1
   13ffc:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   13ffe:	68c3      	ldr	r3, [r0, #12]
   14000:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   14004:	60c3      	str	r3, [r0, #12]
   14006:	e7ef      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
   14008:	4605      	mov	r5, r0
   1400a:	f7ff fd15 	bl	13a38 <SDMMC_GetCmdResp1.part.2>
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
   1400e:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
   14012:	bf18      	it	ne
   14014:	4604      	movne	r4, r0
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
   14016:	68eb      	ldr	r3, [r5, #12]
   14018:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1401c:	60eb      	str	r3, [r5, #12]
   1401e:	e7e3      	b.n	13fe8 <SDMMC_CmdStopTransfer+0x78>
   14020:	00062b44 	.word	0x00062b44
   14024:	fffee0c0 	.word	0xfffee0c0
   14028:	10624dd3 	.word	0x10624dd3
   1402c:	05f5e100 	.word	0x05f5e100
   14030:	00200045 	.word	0x00200045
   14034:	002000c5 	.word	0x002000c5

00014038 <SDMMC_CmdSelDesel>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14038:	4b1c      	ldr	r3, [pc, #112]	; (140ac <SDMMC_CmdSelDesel+0x74>)
   1403a:	491d      	ldr	r1, [pc, #116]	; (140b0 <SDMMC_CmdSelDesel+0x78>)
{
   1403c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1403e:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14040:	f241 1407 	movw	r4, #4359	; 0x1107
  SDMMCx->ARG = Command->Argument;
   14044:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14046:	4d1b      	ldr	r5, [pc, #108]	; (140b4 <SDMMC_CmdSelDesel+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14048:	fba1 3203 	umull	r3, r2, r1, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1404c:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1404e:	f241 3388 	movw	r3, #5000	; 0x1388
   14052:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14054:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14056:	4918      	ldr	r1, [pc, #96]	; (140b8 <SDMMC_CmdSelDesel+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14058:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1405c:	432c      	orrs	r4, r5
   1405e:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   14060:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14064:	d312      	bcc.n	1408c <SDMMC_CmdSelDesel+0x54>
    sta_reg = SDMMCx->STA;
   14066:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14068:	420a      	tst	r2, r1
   1406a:	d0f9      	beq.n	14060 <SDMMC_CmdSelDesel+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1406c:	0494      	lsls	r4, r2, #18
   1406e:	d4f7      	bmi.n	14060 <SDMMC_CmdSelDesel+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   14070:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14072:	075a      	lsls	r2, r3, #29
   14074:	d40e      	bmi.n	14094 <SDMMC_CmdSelDesel+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14076:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14078:	07db      	lsls	r3, r3, #31
   1407a:	d40f      	bmi.n	1409c <SDMMC_CmdSelDesel+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   1407c:	4b0f      	ldr	r3, [pc, #60]	; (140bc <SDMMC_CmdSelDesel+0x84>)
   1407e:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   14080:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14082:	b2db      	uxtb	r3, r3
   14084:	2b07      	cmp	r3, #7
   14086:	d00d      	beq.n	140a4 <SDMMC_CmdSelDesel+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14088:	2001      	movs	r0, #1
  return errorstate;
   1408a:	e001      	b.n	14090 <SDMMC_CmdSelDesel+0x58>
      return SDMMC_ERROR_TIMEOUT;
   1408c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14090:	bc30      	pop	{r4, r5}
   14092:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14094:	2304      	movs	r3, #4
   14096:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   14098:	4618      	mov	r0, r3
   1409a:	e7f9      	b.n	14090 <SDMMC_CmdSelDesel+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1409c:	2301      	movs	r3, #1
   1409e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   140a0:	4618      	mov	r0, r3
   140a2:	e7f5      	b.n	14090 <SDMMC_CmdSelDesel+0x58>
}
   140a4:	bc30      	pop	{r4, r5}
   140a6:	f7ff bcc7 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   140aa:	bf00      	nop
   140ac:	00062b44 	.word	0x00062b44
   140b0:	10624dd3 	.word	0x10624dd3
   140b4:	fffee0c0 	.word	0xfffee0c0
   140b8:	00200045 	.word	0x00200045
   140bc:	002000c5 	.word	0x002000c5

000140c0 <SDMMC_CmdGoIdleState>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140c0:	4b12      	ldr	r3, [pc, #72]	; (1410c <SDMMC_CmdGoIdleState+0x4c>)
{
   140c2:	4602      	mov	r2, r0
  SDMMCx->ARG = Command->Argument;
   140c4:	2100      	movs	r1, #0
{
   140c6:	b410      	push	{r4}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140c8:	4c11      	ldr	r4, [pc, #68]	; (14110 <SDMMC_CmdGoIdleState+0x50>)
   140ca:	6818      	ldr	r0, [r3, #0]
   140cc:	f241 3388 	movw	r3, #5000	; 0x1388
  SDMMCx->ARG = Command->Argument;
   140d0:	6091      	str	r1, [r2, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140d2:	fba4 4000 	umull	r4, r0, r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   140d6:	490f      	ldr	r1, [pc, #60]	; (14114 <SDMMC_CmdGoIdleState+0x54>)
   140d8:	68d4      	ldr	r4, [r2, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140da:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   140dc:	4021      	ands	r1, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   140de:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   140e2:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
   140e6:	60d1      	str	r1, [r2, #12]
   140e8:	e002      	b.n	140f0 <SDMMC_CmdGoIdleState+0x30>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
   140ea:	6b51      	ldr	r1, [r2, #52]	; 0x34
   140ec:	0609      	lsls	r1, r1, #24
   140ee:	d407      	bmi.n	14100 <SDMMC_CmdGoIdleState+0x40>
    if (count-- == 0U)
   140f0:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   140f4:	d2f9      	bcs.n	140ea <SDMMC_CmdGoIdleState+0x2a>
      return SDMMC_ERROR_TIMEOUT;
   140f6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   140fa:	f85d 4b04 	ldr.w	r4, [sp], #4
   140fe:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14100:	4b05      	ldr	r3, [pc, #20]	; (14118 <SDMMC_CmdGoIdleState+0x58>)
  return SDMMC_ERROR_NONE;
   14102:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14104:	6393      	str	r3, [r2, #56]	; 0x38
}
   14106:	f85d 4b04 	ldr.w	r4, [sp], #4
   1410a:	4770      	bx	lr
   1410c:	00062b44 	.word	0x00062b44
   14110:	10624dd3 	.word	0x10624dd3
   14114:	fffee0c0 	.word	0xfffee0c0
   14118:	002000c5 	.word	0x002000c5

0001411c <SDMMC_CmdOperCond>:
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1411c:	4a1c      	ldr	r2, [pc, #112]	; (14190 <SDMMC_CmdOperCond+0x74>)
{
   1411e:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14120:	4b1c      	ldr	r3, [pc, #112]	; (14194 <SDMMC_CmdOperCond+0x78>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14122:	f241 1008 	movw	r0, #4360	; 0x1108
{
   14126:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   14128:	f44f 74d5 	mov.w	r4, #426	; 0x1aa
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1412c:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
   1412e:	608c      	str	r4, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14130:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14134:	68cd      	ldr	r5, [r1, #12]
   14136:	4c18      	ldr	r4, [pc, #96]	; (14198 <SDMMC_CmdOperCond+0x7c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14138:	f241 3388 	movw	r3, #5000	; 0x1388
   1413c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1413e:	402c      	ands	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14140:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14144:	4320      	orrs	r0, r4
   14146:	60c8      	str	r0, [r1, #12]

  do
  {
    if (count-- == 0U)
   14148:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1414c:	d313      	bcc.n	14176 <SDMMC_CmdOperCond+0x5a>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
   1414e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14150:	f012 0f45 	tst.w	r2, #69	; 0x45
   14154:	d0f8      	beq.n	14148 <SDMMC_CmdOperCond+0x2c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   14156:	0492      	lsls	r2, r2, #18
   14158:	d4f6      	bmi.n	14148 <SDMMC_CmdOperCond+0x2c>

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1415a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   1415c:	075b      	lsls	r3, r3, #29
   1415e:	d40e      	bmi.n	1417e <SDMMC_CmdOperCond+0x62>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14160:	6b48      	ldr	r0, [r1, #52]	; 0x34
   14162:	f010 0001 	ands.w	r0, r0, #1
   14166:	d10d      	bne.n	14184 <SDMMC_CmdOperCond+0x68>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
   14168:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   1416a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
   1416e:	d00c      	beq.n	1418a <SDMMC_CmdOperCond+0x6e>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
   14170:	2340      	movs	r3, #64	; 0x40
   14172:	638b      	str	r3, [r1, #56]	; 0x38
   14174:	e001      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
      return SDMMC_ERROR_TIMEOUT;
   14176:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1417a:	bc30      	pop	{r4, r5}
   1417c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   1417e:	2004      	movs	r0, #4
   14180:	6388      	str	r0, [r1, #56]	; 0x38
   14182:	e7fa      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   14184:	2001      	movs	r0, #1
   14186:	6388      	str	r0, [r1, #56]	; 0x38
   14188:	e7f7      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
  }

  return SDMMC_ERROR_NONE;
   1418a:	4618      	mov	r0, r3
  return errorstate;
   1418c:	e7f5      	b.n	1417a <SDMMC_CmdOperCond+0x5e>
   1418e:	bf00      	nop
   14190:	00062b44 	.word	0x00062b44
   14194:	10624dd3 	.word	0x10624dd3
   14198:	fffee0c0 	.word	0xfffee0c0

0001419c <SDMMC_CmdAppCommand>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1419c:	4a1c      	ldr	r2, [pc, #112]	; (14210 <SDMMC_CmdAppCommand+0x74>)
   1419e:	4b1d      	ldr	r3, [pc, #116]	; (14214 <SDMMC_CmdAppCommand+0x78>)
{
   141a0:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141a2:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141a4:	f241 1437 	movw	r4, #4407	; 0x1137
  SDMMCx->ARG = Command->Argument;
   141a8:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141aa:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141ae:	68c1      	ldr	r1, [r0, #12]
   141b0:	4d19      	ldr	r5, [pc, #100]	; (14218 <SDMMC_CmdAppCommand+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141b2:	f241 3388 	movw	r3, #5000	; 0x1388
   141b6:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141b8:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   141ba:	4918      	ldr	r1, [pc, #96]	; (1421c <SDMMC_CmdAppCommand+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   141bc:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   141c0:	432c      	orrs	r4, r5
   141c2:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   141c4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   141c8:	d312      	bcc.n	141f0 <SDMMC_CmdAppCommand+0x54>
    sta_reg = SDMMCx->STA;
   141ca:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   141cc:	420a      	tst	r2, r1
   141ce:	d0f9      	beq.n	141c4 <SDMMC_CmdAppCommand+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   141d0:	0494      	lsls	r4, r2, #18
   141d2:	d4f7      	bmi.n	141c4 <SDMMC_CmdAppCommand+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   141d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   141d6:	075a      	lsls	r2, r3, #29
   141d8:	d40e      	bmi.n	141f8 <SDMMC_CmdAppCommand+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   141da:	6b43      	ldr	r3, [r0, #52]	; 0x34
   141dc:	07db      	lsls	r3, r3, #31
   141de:	d40f      	bmi.n	14200 <SDMMC_CmdAppCommand+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   141e0:	4b0f      	ldr	r3, [pc, #60]	; (14220 <SDMMC_CmdAppCommand+0x84>)
   141e2:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   141e4:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   141e6:	b2db      	uxtb	r3, r3
   141e8:	2b37      	cmp	r3, #55	; 0x37
   141ea:	d00d      	beq.n	14208 <SDMMC_CmdAppCommand+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   141ec:	2001      	movs	r0, #1
  return errorstate;
   141ee:	e001      	b.n	141f4 <SDMMC_CmdAppCommand+0x58>
      return SDMMC_ERROR_TIMEOUT;
   141f0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   141f4:	bc30      	pop	{r4, r5}
   141f6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   141f8:	2304      	movs	r3, #4
   141fa:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   141fc:	4618      	mov	r0, r3
   141fe:	e7f9      	b.n	141f4 <SDMMC_CmdAppCommand+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   14200:	2301      	movs	r3, #1
   14202:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14204:	4618      	mov	r0, r3
   14206:	e7f5      	b.n	141f4 <SDMMC_CmdAppCommand+0x58>
}
   14208:	bc30      	pop	{r4, r5}
   1420a:	f7ff bc15 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   1420e:	bf00      	nop
   14210:	00062b44 	.word	0x00062b44
   14214:	10624dd3 	.word	0x10624dd3
   14218:	fffee0c0 	.word	0xfffee0c0
   1421c:	00200045 	.word	0x00200045
   14220:	002000c5 	.word	0x002000c5

00014224 <SDMMC_CmdAppOperCommand>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14224:	4a15      	ldr	r2, [pc, #84]	; (1427c <SDMMC_CmdAppOperCommand+0x58>)
   14226:	4b16      	ldr	r3, [pc, #88]	; (14280 <SDMMC_CmdAppOperCommand+0x5c>)
{
   14228:	b430      	push	{r4, r5}
   1422a:	4604      	mov	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1422c:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1422e:	f241 1029 	movw	r0, #4393	; 0x1129
  SDMMCx->ARG = Command->Argument;
   14232:	60a1      	str	r1, [r4, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14234:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14238:	68e5      	ldr	r5, [r4, #12]
   1423a:	4912      	ldr	r1, [pc, #72]	; (14284 <SDMMC_CmdAppOperCommand+0x60>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1423c:	f241 3388 	movw	r3, #5000	; 0x1388
   14240:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14242:	4029      	ands	r1, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14244:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14248:	4308      	orrs	r0, r1
   1424a:	60e0      	str	r0, [r4, #12]
    if (count-- == 0U)
   1424c:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14250:	d30d      	bcc.n	1426e <SDMMC_CmdAppOperCommand+0x4a>
    sta_reg = SDMMCx->STA;
   14252:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14254:	f012 0f45 	tst.w	r2, #69	; 0x45
   14258:	d0f8      	beq.n	1424c <SDMMC_CmdAppOperCommand+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   1425a:	0492      	lsls	r2, r2, #18
   1425c:	d4f6      	bmi.n	1424c <SDMMC_CmdAppOperCommand+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1425e:	6b60      	ldr	r0, [r4, #52]	; 0x34
   14260:	f010 0004 	ands.w	r0, r0, #4
   14264:	d107      	bne.n	14276 <SDMMC_CmdAppOperCommand+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14266:	4b08      	ldr	r3, [pc, #32]	; (14288 <SDMMC_CmdAppOperCommand+0x64>)
   14268:	63a3      	str	r3, [r4, #56]	; 0x38
}
   1426a:	bc30      	pop	{r4, r5}
   1426c:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
   1426e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14272:	bc30      	pop	{r4, r5}
   14274:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14276:	2004      	movs	r0, #4
   14278:	63a0      	str	r0, [r4, #56]	; 0x38
   1427a:	e7fa      	b.n	14272 <SDMMC_CmdAppOperCommand+0x4e>
   1427c:	00062b44 	.word	0x00062b44
   14280:	10624dd3 	.word	0x10624dd3
   14284:	fffee0c0 	.word	0xfffee0c0
   14288:	002000c5 	.word	0x002000c5

0001428c <SDMMC_CmdBusWidth>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1428c:	4a1c      	ldr	r2, [pc, #112]	; (14300 <SDMMC_CmdBusWidth+0x74>)
   1428e:	4b1d      	ldr	r3, [pc, #116]	; (14304 <SDMMC_CmdBusWidth+0x78>)
{
   14290:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14292:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14294:	f241 1406 	movw	r4, #4358	; 0x1106
  SDMMCx->ARG = Command->Argument;
   14298:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1429a:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1429e:	68c1      	ldr	r1, [r0, #12]
   142a0:	4d19      	ldr	r5, [pc, #100]	; (14308 <SDMMC_CmdBusWidth+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   142a2:	f241 3388 	movw	r3, #5000	; 0x1388
   142a6:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   142a8:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   142aa:	4918      	ldr	r1, [pc, #96]	; (1430c <SDMMC_CmdBusWidth+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   142ac:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   142b0:	432c      	orrs	r4, r5
   142b2:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   142b4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   142b8:	d312      	bcc.n	142e0 <SDMMC_CmdBusWidth+0x54>
    sta_reg = SDMMCx->STA;
   142ba:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   142bc:	420a      	tst	r2, r1
   142be:	d0f9      	beq.n	142b4 <SDMMC_CmdBusWidth+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   142c0:	0494      	lsls	r4, r2, #18
   142c2:	d4f7      	bmi.n	142b4 <SDMMC_CmdBusWidth+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   142c4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   142c6:	075a      	lsls	r2, r3, #29
   142c8:	d40e      	bmi.n	142e8 <SDMMC_CmdBusWidth+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   142ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
   142cc:	07db      	lsls	r3, r3, #31
   142ce:	d40f      	bmi.n	142f0 <SDMMC_CmdBusWidth+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   142d0:	4b0f      	ldr	r3, [pc, #60]	; (14310 <SDMMC_CmdBusWidth+0x84>)
   142d2:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   142d4:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   142d6:	b2db      	uxtb	r3, r3
   142d8:	2b06      	cmp	r3, #6
   142da:	d00d      	beq.n	142f8 <SDMMC_CmdBusWidth+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   142dc:	2001      	movs	r0, #1
  return errorstate;
   142de:	e001      	b.n	142e4 <SDMMC_CmdBusWidth+0x58>
      return SDMMC_ERROR_TIMEOUT;
   142e0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   142e4:	bc30      	pop	{r4, r5}
   142e6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   142e8:	2304      	movs	r3, #4
   142ea:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   142ec:	4618      	mov	r0, r3
   142ee:	e7f9      	b.n	142e4 <SDMMC_CmdBusWidth+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   142f0:	2301      	movs	r3, #1
   142f2:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   142f4:	4618      	mov	r0, r3
   142f6:	e7f5      	b.n	142e4 <SDMMC_CmdBusWidth+0x58>
}
   142f8:	bc30      	pop	{r4, r5}
   142fa:	f7ff bb9d 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   142fe:	bf00      	nop
   14300:	00062b44 	.word	0x00062b44
   14304:	10624dd3 	.word	0x10624dd3
   14308:	fffee0c0 	.word	0xfffee0c0
   1430c:	00200045 	.word	0x00200045
   14310:	002000c5 	.word	0x002000c5

00014314 <SDMMC_CmdSendSCR>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14314:	4a1c      	ldr	r2, [pc, #112]	; (14388 <SDMMC_CmdSendSCR+0x74>)
  SDMMCx->ARG = Command->Argument;
   14316:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14318:	4b1c      	ldr	r3, [pc, #112]	; (1438c <SDMMC_CmdSendSCR+0x78>)
{
   1431a:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1431c:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1431e:	f241 1433 	movw	r4, #4403	; 0x1133
  SDMMCx->ARG = Command->Argument;
   14322:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14324:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14328:	68c1      	ldr	r1, [r0, #12]
   1432a:	4d19      	ldr	r5, [pc, #100]	; (14390 <SDMMC_CmdSendSCR+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1432c:	f241 3388 	movw	r3, #5000	; 0x1388
   14330:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14332:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14334:	4917      	ldr	r1, [pc, #92]	; (14394 <SDMMC_CmdSendSCR+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14336:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1433a:	432c      	orrs	r4, r5
   1433c:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   1433e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14342:	d312      	bcc.n	1436a <SDMMC_CmdSendSCR+0x56>
    sta_reg = SDMMCx->STA;
   14344:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14346:	420a      	tst	r2, r1
   14348:	d0f9      	beq.n	1433e <SDMMC_CmdSendSCR+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1434a:	0494      	lsls	r4, r2, #18
   1434c:	d4f7      	bmi.n	1433e <SDMMC_CmdSendSCR+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1434e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14350:	075a      	lsls	r2, r3, #29
   14352:	d40e      	bmi.n	14372 <SDMMC_CmdSendSCR+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14354:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14356:	07db      	lsls	r3, r3, #31
   14358:	d40f      	bmi.n	1437a <SDMMC_CmdSendSCR+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   1435a:	4b0f      	ldr	r3, [pc, #60]	; (14398 <SDMMC_CmdSendSCR+0x84>)
   1435c:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   1435e:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14360:	b2db      	uxtb	r3, r3
   14362:	2b33      	cmp	r3, #51	; 0x33
   14364:	d00d      	beq.n	14382 <SDMMC_CmdSendSCR+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14366:	2001      	movs	r0, #1
  return errorstate;
   14368:	e001      	b.n	1436e <SDMMC_CmdSendSCR+0x5a>
      return SDMMC_ERROR_TIMEOUT;
   1436a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1436e:	bc30      	pop	{r4, r5}
   14370:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14372:	2304      	movs	r3, #4
   14374:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   14376:	4618      	mov	r0, r3
   14378:	e7f9      	b.n	1436e <SDMMC_CmdSendSCR+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1437a:	2301      	movs	r3, #1
   1437c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1437e:	4618      	mov	r0, r3
   14380:	e7f5      	b.n	1436e <SDMMC_CmdSendSCR+0x5a>
}
   14382:	bc30      	pop	{r4, r5}
   14384:	f7ff bb58 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   14388:	00062b44 	.word	0x00062b44
   1438c:	10624dd3 	.word	0x10624dd3
   14390:	fffee0c0 	.word	0xfffee0c0
   14394:	00200045 	.word	0x00200045
   14398:	002000c5 	.word	0x002000c5

0001439c <SDMMC_CmdSendCID>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1439c:	4a18      	ldr	r2, [pc, #96]	; (14400 <SDMMC_CmdSendCID+0x64>)
{
   1439e:	4601      	mov	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143a0:	4b18      	ldr	r3, [pc, #96]	; (14404 <SDMMC_CmdSendCID+0x68>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143a2:	f241 3002 	movw	r0, #4866	; 0x1302
{
   143a6:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
   143a8:	2400      	movs	r4, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143aa:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
   143ac:	608c      	str	r4, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143ae:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143b2:	68cd      	ldr	r5, [r1, #12]
   143b4:	4c14      	ldr	r4, [pc, #80]	; (14408 <SDMMC_CmdSendCID+0x6c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143b6:	f241 3388 	movw	r3, #5000	; 0x1388
   143ba:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143bc:	402c      	ands	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   143be:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   143c2:	4320      	orrs	r0, r4
   143c4:	60c8      	str	r0, [r1, #12]
    if (count-- == 0U)
   143c6:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   143ca:	d30f      	bcc.n	143ec <SDMMC_CmdSendCID+0x50>
    sta_reg = SDMMCx->STA;
   143cc:	6b4a      	ldr	r2, [r1, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   143ce:	f012 0f45 	tst.w	r2, #69	; 0x45
   143d2:	d0f8      	beq.n	143c6 <SDMMC_CmdSendCID+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   143d4:	0492      	lsls	r2, r2, #18
   143d6:	d4f6      	bmi.n	143c6 <SDMMC_CmdSendCID+0x2a>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   143d8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   143da:	075b      	lsls	r3, r3, #29
   143dc:	d40a      	bmi.n	143f4 <SDMMC_CmdSendCID+0x58>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   143de:	6b48      	ldr	r0, [r1, #52]	; 0x34
   143e0:	f010 0001 	ands.w	r0, r0, #1
   143e4:	d109      	bne.n	143fa <SDMMC_CmdSendCID+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   143e6:	4b09      	ldr	r3, [pc, #36]	; (1440c <SDMMC_CmdSendCID+0x70>)
   143e8:	638b      	str	r3, [r1, #56]	; 0x38
   143ea:	e001      	b.n	143f0 <SDMMC_CmdSendCID+0x54>
      return SDMMC_ERROR_TIMEOUT;
   143ec:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   143f0:	bc30      	pop	{r4, r5}
   143f2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   143f4:	2004      	movs	r0, #4
   143f6:	6388      	str	r0, [r1, #56]	; 0x38
   143f8:	e7fa      	b.n	143f0 <SDMMC_CmdSendCID+0x54>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   143fa:	2001      	movs	r0, #1
   143fc:	6388      	str	r0, [r1, #56]	; 0x38
   143fe:	e7f7      	b.n	143f0 <SDMMC_CmdSendCID+0x54>
   14400:	00062b44 	.word	0x00062b44
   14404:	10624dd3 	.word	0x10624dd3
   14408:	fffee0c0 	.word	0xfffee0c0
   1440c:	002000c5 	.word	0x002000c5

00014410 <SDMMC_CmdSendCSD>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14410:	4a18      	ldr	r2, [pc, #96]	; (14474 <SDMMC_CmdSendCSD+0x64>)
   14412:	4b19      	ldr	r3, [pc, #100]	; (14478 <SDMMC_CmdSendCSD+0x68>)
{
   14414:	b430      	push	{r4, r5}
   14416:	4604      	mov	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14418:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1441a:	f241 3009 	movw	r0, #4873	; 0x1309
  SDMMCx->ARG = Command->Argument;
   1441e:	60a1      	str	r1, [r4, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14420:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14424:	68e5      	ldr	r5, [r4, #12]
   14426:	4915      	ldr	r1, [pc, #84]	; (1447c <SDMMC_CmdSendCSD+0x6c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14428:	f241 3388 	movw	r3, #5000	; 0x1388
   1442c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1442e:	4029      	ands	r1, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14430:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14434:	4308      	orrs	r0, r1
   14436:	60e0      	str	r0, [r4, #12]
    if (count-- == 0U)
   14438:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1443c:	d30f      	bcc.n	1445e <SDMMC_CmdSendCSD+0x4e>
    sta_reg = SDMMCx->STA;
   1443e:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   14440:	f012 0f45 	tst.w	r2, #69	; 0x45
   14444:	d0f8      	beq.n	14438 <SDMMC_CmdSendCSD+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   14446:	0492      	lsls	r2, r2, #18
   14448:	d4f6      	bmi.n	14438 <SDMMC_CmdSendCSD+0x28>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   1444a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1444c:	075b      	lsls	r3, r3, #29
   1444e:	d40a      	bmi.n	14466 <SDMMC_CmdSendCSD+0x56>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   14450:	6b60      	ldr	r0, [r4, #52]	; 0x34
   14452:	f010 0001 	ands.w	r0, r0, #1
   14456:	d109      	bne.n	1446c <SDMMC_CmdSendCSD+0x5c>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14458:	4b09      	ldr	r3, [pc, #36]	; (14480 <SDMMC_CmdSendCSD+0x70>)
   1445a:	63a3      	str	r3, [r4, #56]	; 0x38
   1445c:	e001      	b.n	14462 <SDMMC_CmdSendCSD+0x52>
      return SDMMC_ERROR_TIMEOUT;
   1445e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14462:	bc30      	pop	{r4, r5}
   14464:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14466:	2004      	movs	r0, #4
   14468:	63a0      	str	r0, [r4, #56]	; 0x38
   1446a:	e7fa      	b.n	14462 <SDMMC_CmdSendCSD+0x52>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1446c:	2001      	movs	r0, #1
   1446e:	63a0      	str	r0, [r4, #56]	; 0x38
   14470:	e7f7      	b.n	14462 <SDMMC_CmdSendCSD+0x52>
   14472:	bf00      	nop
   14474:	00062b44 	.word	0x00062b44
   14478:	10624dd3 	.word	0x10624dd3
   1447c:	fffee0c0 	.word	0xfffee0c0
   14480:	002000c5 	.word	0x002000c5

00014484 <SDMMC_CmdSetRelAdd>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14484:	4b25      	ldr	r3, [pc, #148]	; (1451c <SDMMC_CmdSetRelAdd+0x98>)
   14486:	4a26      	ldr	r2, [pc, #152]	; (14520 <SDMMC_CmdSetRelAdd+0x9c>)
{
   14488:	b470      	push	{r4, r5, r6}
  SDMMCx->ARG = Command->Argument;
   1448a:	2400      	movs	r4, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1448c:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1448e:	4d25      	ldr	r5, [pc, #148]	; (14524 <SDMMC_CmdSetRelAdd+0xa0>)
  SDMMCx->ARG = Command->Argument;
   14490:	6084      	str	r4, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14492:	f241 1403 	movw	r4, #4355	; 0x1103
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   14496:	fba2 2303 	umull	r2, r3, r2, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1449a:	68c6      	ldr	r6, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   1449c:	0a5a      	lsrs	r2, r3, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1449e:	4035      	ands	r5, r6
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   144a0:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   144a4:	432c      	orrs	r4, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
   144a6:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   144aa:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   144ac:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   144b0:	d311      	bcc.n	144d6 <SDMMC_CmdSetRelAdd+0x52>
    sta_reg = SDMMCx->STA;
   144b2:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   144b4:	f012 0f45 	tst.w	r2, #69	; 0x45
   144b8:	d0f8      	beq.n	144ac <SDMMC_CmdSetRelAdd+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
   144ba:	0496      	lsls	r6, r2, #18
   144bc:	d4f6      	bmi.n	144ac <SDMMC_CmdSetRelAdd+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   144be:	6b43      	ldr	r3, [r0, #52]	; 0x34
   144c0:	075d      	lsls	r5, r3, #29
   144c2:	d40c      	bmi.n	144de <SDMMC_CmdSetRelAdd+0x5a>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   144c4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   144c6:	07dc      	lsls	r4, r3, #31
   144c8:	d40d      	bmi.n	144e6 <SDMMC_CmdSetRelAdd+0x62>
  return (uint8_t)(SDMMCx->RESPCMD);
   144ca:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   144cc:	b2db      	uxtb	r3, r3
   144ce:	2b03      	cmp	r3, #3
   144d0:	d00d      	beq.n	144ee <SDMMC_CmdSetRelAdd+0x6a>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   144d2:	2001      	movs	r0, #1
   144d4:	e001      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
      return SDMMC_ERROR_TIMEOUT;
   144d6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   144da:	bc70      	pop	{r4, r5, r6}
   144dc:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   144de:	2304      	movs	r3, #4
   144e0:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   144e2:	4618      	mov	r0, r3
   144e4:	e7f9      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   144e6:	2301      	movs	r3, #1
   144e8:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   144ea:	4618      	mov	r0, r3
   144ec:	e7f5      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   144ee:	4b0e      	ldr	r3, [pc, #56]	; (14528 <SDMMC_CmdSetRelAdd+0xa4>)
   144f0:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
   144f2:	6943      	ldr	r3, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
   144f4:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
   144f8:	d009      	beq.n	1450e <SDMMC_CmdSetRelAdd+0x8a>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
   144fa:	045a      	lsls	r2, r3, #17
   144fc:	d40a      	bmi.n	14514 <SDMMC_CmdSetRelAdd+0x90>
    return SDMMC_ERROR_COM_CRC_FAILED;
   144fe:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   14502:	bf0c      	ite	eq
   14504:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   14508:	f44f 5080 	movne.w	r0, #4096	; 0x1000
   1450c:	e7e5      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
    *pRCA = (uint16_t) (response_r1 >> 16);
   1450e:	0c1b      	lsrs	r3, r3, #16
   14510:	800b      	strh	r3, [r1, #0]
   14512:	e7e2      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
    return SDMMC_ERROR_ILLEGAL_CMD;
   14514:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   14518:	e7df      	b.n	144da <SDMMC_CmdSetRelAdd+0x56>
   1451a:	bf00      	nop
   1451c:	00062b44 	.word	0x00062b44
   14520:	10624dd3 	.word	0x10624dd3
   14524:	fffee0c0 	.word	0xfffee0c0
   14528:	002000c5 	.word	0x002000c5

0001452c <SDMMC_CmdSendStatus>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1452c:	4a1c      	ldr	r2, [pc, #112]	; (145a0 <SDMMC_CmdSendStatus+0x74>)
   1452e:	4b1d      	ldr	r3, [pc, #116]	; (145a4 <SDMMC_CmdSendStatus+0x78>)
{
   14530:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14532:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14534:	f241 140d 	movw	r4, #4365	; 0x110d
  SDMMCx->ARG = Command->Argument;
   14538:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1453a:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1453e:	68c1      	ldr	r1, [r0, #12]
   14540:	4d19      	ldr	r5, [pc, #100]	; (145a8 <SDMMC_CmdSendStatus+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14542:	f241 3388 	movw	r3, #5000	; 0x1388
   14546:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14548:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1454a:	4918      	ldr	r1, [pc, #96]	; (145ac <SDMMC_CmdSendStatus+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1454c:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14550:	432c      	orrs	r4, r5
   14552:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   14554:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   14558:	d312      	bcc.n	14580 <SDMMC_CmdSendStatus+0x54>
    sta_reg = SDMMCx->STA;
   1455a:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   1455c:	420a      	tst	r2, r1
   1455e:	d0f9      	beq.n	14554 <SDMMC_CmdSendStatus+0x28>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14560:	0494      	lsls	r4, r2, #18
   14562:	d4f7      	bmi.n	14554 <SDMMC_CmdSendStatus+0x28>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   14564:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14566:	075a      	lsls	r2, r3, #29
   14568:	d40e      	bmi.n	14588 <SDMMC_CmdSendStatus+0x5c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   1456a:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1456c:	07db      	lsls	r3, r3, #31
   1456e:	d40f      	bmi.n	14590 <SDMMC_CmdSendStatus+0x64>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14570:	4b0f      	ldr	r3, [pc, #60]	; (145b0 <SDMMC_CmdSendStatus+0x84>)
   14572:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   14574:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14576:	b2db      	uxtb	r3, r3
   14578:	2b0d      	cmp	r3, #13
   1457a:	d00d      	beq.n	14598 <SDMMC_CmdSendStatus+0x6c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1457c:	2001      	movs	r0, #1
  return errorstate;
   1457e:	e001      	b.n	14584 <SDMMC_CmdSendStatus+0x58>
      return SDMMC_ERROR_TIMEOUT;
   14580:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14584:	bc30      	pop	{r4, r5}
   14586:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14588:	2304      	movs	r3, #4
   1458a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   1458c:	4618      	mov	r0, r3
   1458e:	e7f9      	b.n	14584 <SDMMC_CmdSendStatus+0x58>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   14590:	2301      	movs	r3, #1
   14592:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14594:	4618      	mov	r0, r3
   14596:	e7f5      	b.n	14584 <SDMMC_CmdSendStatus+0x58>
}
   14598:	bc30      	pop	{r4, r5}
   1459a:	f7ff ba4d 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   1459e:	bf00      	nop
   145a0:	00062b44 	.word	0x00062b44
   145a4:	10624dd3 	.word	0x10624dd3
   145a8:	fffee0c0 	.word	0xfffee0c0
   145ac:	00200045 	.word	0x00200045
   145b0:	002000c5 	.word	0x002000c5

000145b4 <SDMMC_CmdStatusRegister>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145b4:	4a1c      	ldr	r2, [pc, #112]	; (14628 <SDMMC_CmdStatusRegister+0x74>)
  SDMMCx->ARG = Command->Argument;
   145b6:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145b8:	4b1c      	ldr	r3, [pc, #112]	; (1462c <SDMMC_CmdStatusRegister+0x78>)
{
   145ba:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145bc:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145be:	f241 140d 	movw	r4, #4365	; 0x110d
  SDMMCx->ARG = Command->Argument;
   145c2:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145c4:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145c8:	68c1      	ldr	r1, [r0, #12]
   145ca:	4d19      	ldr	r5, [pc, #100]	; (14630 <SDMMC_CmdStatusRegister+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145cc:	f241 3388 	movw	r3, #5000	; 0x1388
   145d0:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145d2:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   145d4:	4917      	ldr	r1, [pc, #92]	; (14634 <SDMMC_CmdStatusRegister+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   145d6:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   145da:	432c      	orrs	r4, r5
   145dc:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   145de:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   145e2:	d312      	bcc.n	1460a <SDMMC_CmdStatusRegister+0x56>
    sta_reg = SDMMCx->STA;
   145e4:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   145e6:	420a      	tst	r2, r1
   145e8:	d0f9      	beq.n	145de <SDMMC_CmdStatusRegister+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   145ea:	0494      	lsls	r4, r2, #18
   145ec:	d4f7      	bmi.n	145de <SDMMC_CmdStatusRegister+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   145ee:	6b43      	ldr	r3, [r0, #52]	; 0x34
   145f0:	075a      	lsls	r2, r3, #29
   145f2:	d40e      	bmi.n	14612 <SDMMC_CmdStatusRegister+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   145f4:	6b43      	ldr	r3, [r0, #52]	; 0x34
   145f6:	07db      	lsls	r3, r3, #31
   145f8:	d40f      	bmi.n	1461a <SDMMC_CmdStatusRegister+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   145fa:	4b0f      	ldr	r3, [pc, #60]	; (14638 <SDMMC_CmdStatusRegister+0x84>)
   145fc:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   145fe:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14600:	b2db      	uxtb	r3, r3
   14602:	2b0d      	cmp	r3, #13
   14604:	d00d      	beq.n	14622 <SDMMC_CmdStatusRegister+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   14606:	2001      	movs	r0, #1
  return errorstate;
   14608:	e001      	b.n	1460e <SDMMC_CmdStatusRegister+0x5a>
      return SDMMC_ERROR_TIMEOUT;
   1460a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   1460e:	bc30      	pop	{r4, r5}
   14610:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   14612:	2304      	movs	r3, #4
   14614:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   14616:	4618      	mov	r0, r3
   14618:	e7f9      	b.n	1460e <SDMMC_CmdStatusRegister+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   1461a:	2301      	movs	r3, #1
   1461c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1461e:	4618      	mov	r0, r3
   14620:	e7f5      	b.n	1460e <SDMMC_CmdStatusRegister+0x5a>
}
   14622:	bc30      	pop	{r4, r5}
   14624:	f7ff ba08 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   14628:	00062b44 	.word	0x00062b44
   1462c:	10624dd3 	.word	0x10624dd3
   14630:	fffee0c0 	.word	0xfffee0c0
   14634:	00200045 	.word	0x00200045
   14638:	002000c5 	.word	0x002000c5

0001463c <SDMMC_CmdVoltageSwitch>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1463c:	4a1c      	ldr	r2, [pc, #112]	; (146b0 <SDMMC_CmdVoltageSwitch+0x74>)
  SDMMCx->ARG = Command->Argument;
   1463e:	2100      	movs	r1, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14640:	4b1c      	ldr	r3, [pc, #112]	; (146b4 <SDMMC_CmdVoltageSwitch+0x78>)
{
   14642:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14644:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14646:	f241 140b 	movw	r4, #4363	; 0x110b
  SDMMCx->ARG = Command->Argument;
   1464a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1464c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14650:	68c1      	ldr	r1, [r0, #12]
   14652:	4d19      	ldr	r5, [pc, #100]	; (146b8 <SDMMC_CmdVoltageSwitch+0x7c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   14654:	f241 3388 	movw	r3, #5000	; 0x1388
   14658:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   1465a:	400d      	ands	r5, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   1465c:	4917      	ldr	r1, [pc, #92]	; (146bc <SDMMC_CmdVoltageSwitch+0x80>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
   1465e:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
   14662:	432c      	orrs	r4, r5
   14664:	60c4      	str	r4, [r0, #12]
    if (count-- == 0U)
   14666:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   1466a:	d312      	bcc.n	14692 <SDMMC_CmdVoltageSwitch+0x56>
    sta_reg = SDMMCx->STA;
   1466c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
   1466e:	420a      	tst	r2, r1
   14670:	d0f9      	beq.n	14666 <SDMMC_CmdVoltageSwitch+0x2a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
   14672:	0494      	lsls	r4, r2, #18
   14674:	d4f7      	bmi.n	14666 <SDMMC_CmdVoltageSwitch+0x2a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
   14676:	6b43      	ldr	r3, [r0, #52]	; 0x34
   14678:	075a      	lsls	r2, r3, #29
   1467a:	d40e      	bmi.n	1469a <SDMMC_CmdVoltageSwitch+0x5e>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
   1467c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   1467e:	07db      	lsls	r3, r3, #31
   14680:	d40f      	bmi.n	146a2 <SDMMC_CmdVoltageSwitch+0x66>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
   14682:	4b0f      	ldr	r3, [pc, #60]	; (146c0 <SDMMC_CmdVoltageSwitch+0x84>)
   14684:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
   14686:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
   14688:	b2db      	uxtb	r3, r3
   1468a:	2b0b      	cmp	r3, #11
   1468c:	d00d      	beq.n	146aa <SDMMC_CmdVoltageSwitch+0x6e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
   1468e:	2001      	movs	r0, #1
  return errorstate;
   14690:	e001      	b.n	14696 <SDMMC_CmdVoltageSwitch+0x5a>
      return SDMMC_ERROR_TIMEOUT;
   14692:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
   14696:	bc30      	pop	{r4, r5}
   14698:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
   1469a:	2304      	movs	r3, #4
   1469c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
   1469e:	4618      	mov	r0, r3
   146a0:	e7f9      	b.n	14696 <SDMMC_CmdVoltageSwitch+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
   146a2:	2301      	movs	r3, #1
   146a4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
   146a6:	4618      	mov	r0, r3
   146a8:	e7f5      	b.n	14696 <SDMMC_CmdVoltageSwitch+0x5a>
}
   146aa:	bc30      	pop	{r4, r5}
   146ac:	f7ff b9c4 	b.w	13a38 <SDMMC_GetCmdResp1.part.2>
   146b0:	00062b44 	.word	0x00062b44
   146b4:	10624dd3 	.word	0x10624dd3
   146b8:	fffee0c0 	.word	0xfffee0c0
   146bc:	00200045 	.word	0x00200045
   146c0:	002000c5 	.word	0x002000c5

000146c4 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   146c4:	b084      	sub	sp, #16
   146c6:	b430      	push	{r4, r5}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   146c8:	9d08      	ldr	r5, [sp, #32]
{
   146ca:	ac03      	add	r4, sp, #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   146cc:	2d01      	cmp	r5, #1
{
   146ce:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   146d2:	d131      	bne.n	14738 <USB_CoreInit+0x74>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   146d4:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   146d6:	4b2e      	ldr	r3, [pc, #184]	; (14790 <USB_CoreInit+0xcc>)
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   146d8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
   146dc:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   146de:	6382      	str	r2, [r0, #56]	; 0x38
    if (cfg.use_external_vbus == 1U)
   146e0:	2901      	cmp	r1, #1
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   146e2:	68c2      	ldr	r2, [r0, #12]
   146e4:	ea03 0302 	and.w	r3, r3, r2
   146e8:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   146ea:	68c3      	ldr	r3, [r0, #12]
   146ec:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
   146f0:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
   146f2:	d044      	beq.n	1477e <USB_CoreInit+0xba>
{
   146f4:	4b27      	ldr	r3, [pc, #156]	; (14794 <USB_CoreInit+0xd0>)
   146f6:	e001      	b.n	146fc <USB_CoreInit+0x38>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
   146f8:	3b01      	subs	r3, #1
   146fa:	d045      	beq.n	14788 <USB_CoreInit+0xc4>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   146fc:	6902      	ldr	r2, [r0, #16]
   146fe:	2a00      	cmp	r2, #0
   14700:	dafa      	bge.n	146f8 <USB_CoreInit+0x34>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   14702:	6903      	ldr	r3, [r0, #16]
   14704:	4a23      	ldr	r2, [pc, #140]	; (14794 <USB_CoreInit+0xd0>)
   14706:	f043 0301 	orr.w	r3, r3, #1
   1470a:	6103      	str	r3, [r0, #16]
   1470c:	e001      	b.n	14712 <USB_CoreInit+0x4e>

  do
  {
    if (++count > 200000U)
   1470e:	3a01      	subs	r2, #1
   14710:	d03a      	beq.n	14788 <USB_CoreInit+0xc4>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   14712:	6903      	ldr	r3, [r0, #16]
   14714:	f013 0301 	ands.w	r3, r3, #1
   14718:	d1f9      	bne.n	1470e <USB_CoreInit+0x4a>
  if (cfg.dma_enable == 1U)
   1471a:	9a06      	ldr	r2, [sp, #24]
   1471c:	2a01      	cmp	r2, #1
   1471e:	d107      	bne.n	14730 <USB_CoreInit+0x6c>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
   14720:	6882      	ldr	r2, [r0, #8]
   14722:	f042 0206 	orr.w	r2, r2, #6
   14726:	6082      	str	r2, [r0, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   14728:	6882      	ldr	r2, [r0, #8]
   1472a:	f042 0220 	orr.w	r2, r2, #32
   1472e:	6082      	str	r2, [r0, #8]
}
   14730:	4618      	mov	r0, r3
   14732:	bc30      	pop	{r4, r5}
   14734:	b004      	add	sp, #16
   14736:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   14738:	68c2      	ldr	r2, [r0, #12]
   1473a:	4b16      	ldr	r3, [pc, #88]	; (14794 <USB_CoreInit+0xd0>)
   1473c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   14740:	60c2      	str	r2, [r0, #12]
   14742:	e001      	b.n	14748 <USB_CoreInit+0x84>
    if (++count > 200000U)
   14744:	3b01      	subs	r3, #1
   14746:	d021      	beq.n	1478c <USB_CoreInit+0xc8>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   14748:	6902      	ldr	r2, [r0, #16]
   1474a:	2a00      	cmp	r2, #0
   1474c:	dafa      	bge.n	14744 <USB_CoreInit+0x80>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   1474e:	6903      	ldr	r3, [r0, #16]
   14750:	4a10      	ldr	r2, [pc, #64]	; (14794 <USB_CoreInit+0xd0>)
   14752:	f043 0301 	orr.w	r3, r3, #1
   14756:	6103      	str	r3, [r0, #16]
   14758:	e001      	b.n	1475e <USB_CoreInit+0x9a>
    if (++count > 200000U)
   1475a:	3a01      	subs	r2, #1
   1475c:	d016      	beq.n	1478c <USB_CoreInit+0xc8>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   1475e:	6903      	ldr	r3, [r0, #16]
   14760:	f013 0301 	ands.w	r3, r3, #1
   14764:	d1f9      	bne.n	1475a <USB_CoreInit+0x96>
    if (cfg.battery_charging_enable == 0U)
   14766:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14768:	b922      	cbnz	r2, 14774 <USB_CoreInit+0xb0>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
   1476a:	6b82      	ldr	r2, [r0, #56]	; 0x38
   1476c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   14770:	6382      	str	r2, [r0, #56]	; 0x38
   14772:	e7d2      	b.n	1471a <USB_CoreInit+0x56>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   14774:	6b82      	ldr	r2, [r0, #56]	; 0x38
   14776:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
   1477a:	6382      	str	r2, [r0, #56]	; 0x38
   1477c:	e7cd      	b.n	1471a <USB_CoreInit+0x56>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   1477e:	68c3      	ldr	r3, [r0, #12]
   14780:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   14784:	60c3      	str	r3, [r0, #12]
   14786:	e7b5      	b.n	146f4 <USB_CoreInit+0x30>
      return HAL_TIMEOUT;
   14788:	2303      	movs	r3, #3
   1478a:	e7c6      	b.n	1471a <USB_CoreInit+0x56>
   1478c:	2303      	movs	r3, #3
   1478e:	e7ea      	b.n	14766 <USB_CoreInit+0xa2>
   14790:	ffbdffbf 	.word	0xffbdffbf
   14794:	00030d40 	.word	0x00030d40

00014798 <USB_EnableGlobalInt>:
{
   14798:	4602      	mov	r2, r0
}
   1479a:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   1479c:	6893      	ldr	r3, [r2, #8]
   1479e:	f043 0301 	orr.w	r3, r3, #1
   147a2:	6093      	str	r3, [r2, #8]
}
   147a4:	4770      	bx	lr
   147a6:	bf00      	nop

000147a8 <USB_DisableGlobalInt>:
{
   147a8:	4602      	mov	r2, r0
}
   147aa:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   147ac:	6893      	ldr	r3, [r2, #8]
   147ae:	f023 0301 	bic.w	r3, r3, #1
   147b2:	6093      	str	r3, [r2, #8]
}
   147b4:	4770      	bx	lr
   147b6:	bf00      	nop

000147b8 <USB_SetCurrentMode>:
{
   147b8:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   147ba:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
   147bc:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   147be:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
   147c2:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
   147c4:	d00b      	beq.n	147de <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
   147c6:	b941      	cbnz	r1, 147da <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
   147c8:	68c3      	ldr	r3, [r0, #12]
   147ca:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   147ce:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
   147d0:	2032      	movs	r0, #50	; 0x32
   147d2:	f7f3 fe15 	bl	8400 <HAL_Delay>
  return HAL_OK;
   147d6:	2000      	movs	r0, #0
}
   147d8:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
   147da:	2001      	movs	r0, #1
}
   147dc:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
   147de:	68c3      	ldr	r3, [r0, #12]
   147e0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   147e4:	60c3      	str	r3, [r0, #12]
   147e6:	e7f3      	b.n	147d0 <USB_SetCurrentMode+0x18>

000147e8 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
   147e8:	b084      	sub	sp, #16
   147ea:	b530      	push	{r4, r5, lr}
   147ec:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
   147ee:	2500      	movs	r5, #0
{
   147f0:	b083      	sub	sp, #12
  USBx_PCGCCTL = 0U;
   147f2:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   147f6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
{
   147f8:	a807      	add	r0, sp, #28
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   147fa:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
   147fe:	63a5      	str	r5, [r4, #56]	; 0x38

  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
   14800:	6ba5      	ldr	r5, [r4, #56]	; 0x38
   14802:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
   14806:	63a5      	str	r5, [r4, #56]	; 0x38


  if ((USBx->CID & (0x1U << 8)) != 0U)
   14808:	6be5      	ldr	r5, [r4, #60]	; 0x3c
{
   1480a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if ((USBx->CID & (0x1U << 8)) != 0U)
   1480e:	05eb      	lsls	r3, r5, #23
   14810:	9908      	ldr	r1, [sp, #32]
   14812:	d565      	bpl.n	148e0 <USB_HostInit+0xf8>
  {
    if (cfg.speed == USB_OTG_SPEED_FULL)
   14814:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14816:	2b03      	cmp	r3, #3
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   14818:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    if (cfg.speed == USB_OTG_SPEED_FULL)
   1481c:	d063      	beq.n	148e6 <USB_HostInit+0xfe>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   1481e:	f023 0304 	bic.w	r3, r3, #4
   14822:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14826:	f44f 6284 	mov.w	r2, #1056	; 0x420
   1482a:	4b31      	ldr	r3, [pc, #196]	; (148f0 <USB_HostInit+0x108>)
   1482c:	6122      	str	r2, [r4, #16]
   1482e:	e001      	b.n	14834 <USB_HostInit+0x4c>
    if (++count > 200000U)
   14830:	3b01      	subs	r3, #1
   14832:	d002      	beq.n	1483a <USB_HostInit+0x52>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   14834:	6922      	ldr	r2, [r4, #16]
   14836:	0695      	lsls	r5, r2, #26
   14838:	d4fa      	bmi.n	14830 <USB_HostInit+0x48>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   1483a:	2210      	movs	r2, #16
   1483c:	4b2c      	ldr	r3, [pc, #176]	; (148f0 <USB_HostInit+0x108>)
   1483e:	6122      	str	r2, [r4, #16]
   14840:	e001      	b.n	14846 <USB_HostInit+0x5e>
    if (++count > 200000U)
   14842:	3b01      	subs	r3, #1
   14844:	d002      	beq.n	1484c <USB_HostInit+0x64>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   14846:	6922      	ldr	r2, [r4, #16]
   14848:	06d0      	lsls	r0, r2, #27
   1484a:	d4fa      	bmi.n	14842 <USB_HostInit+0x5a>
  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
  (void)USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
   1484c:	b159      	cbz	r1, 14866 <USB_HostInit+0x7e>
   1484e:	2200      	movs	r2, #0
   14850:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   14854:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    USBx_HC(i)->HCINTMSK = 0U;
   14858:	4610      	mov	r0, r2
  for (i = 0U; i < cfg.Host_channels; i++)
   1485a:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   1485c:	609d      	str	r5, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
   1485e:	60d8      	str	r0, [r3, #12]
   14860:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.Host_channels; i++)
   14862:	428a      	cmp	r2, r1
   14864:	d1f9      	bne.n	1485a <USB_HostInit+0x72>
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
   14866:	2300      	movs	r3, #0
   14868:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
   1486a:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
   1486e:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   14870:	9b01      	ldr	r3, [sp, #4]
   14872:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   14876:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   14878:	9b01      	ldr	r3, [sp, #4]
   1487a:	04da      	lsls	r2, r3, #19
   1487c:	d404      	bmi.n	14888 <USB_HostInit+0xa0>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   1487e:	9b01      	ldr	r3, [sp, #4]
   14880:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   14884:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(200U);
   14888:	20c8      	movs	r0, #200	; 0xc8
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   1488a:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(200U);
   1488c:	f7f3 fdb8 	bl	8400 <HAL_Delay>
  USBx->GINTSTS = 0xFFFFFFFFU;
   14890:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTMSK = 0U;
   14894:	2200      	movs	r2, #0
   14896:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xFFFFFFFFU;
   14898:	6163      	str	r3, [r4, #20]
  if ((USBx->CID & (0x1U << 8)) != 0U)
   1489a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1489c:	05db      	lsls	r3, r3, #23
   1489e:	d517      	bpl.n	148d0 <USB_HostInit+0xe8>
    USBx->GRXFSIZ  = 0x200U;
   148a0:	f44f 7100 	mov.w	r1, #512	; 0x200
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   148a4:	4a13      	ldr	r2, [pc, #76]	; (148f4 <USB_HostInit+0x10c>)
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   148a6:	4b14      	ldr	r3, [pc, #80]	; (148f8 <USB_HostInit+0x110>)
    USBx->GRXFSIZ  = 0x200U;
   148a8:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   148aa:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   148ac:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  if (cfg.dma_enable == 0U)
   148b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   148b2:	b91b      	cbnz	r3, 148bc <USB_HostInit+0xd4>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
   148b4:	69a3      	ldr	r3, [r4, #24]
   148b6:	f043 0310 	orr.w	r3, r3, #16
   148ba:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   148bc:	69a2      	ldr	r2, [r4, #24]
}
   148be:	2000      	movs	r0, #0
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   148c0:	4b0e      	ldr	r3, [pc, #56]	; (148fc <USB_HostInit+0x114>)
   148c2:	4313      	orrs	r3, r2
   148c4:	61a3      	str	r3, [r4, #24]
}
   148c6:	b003      	add	sp, #12
   148c8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   148cc:	b004      	add	sp, #16
   148ce:	4770      	bx	lr
    USBx->GRXFSIZ  = 0x80U;
   148d0:	2180      	movs	r1, #128	; 0x80
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   148d2:	4a0b      	ldr	r2, [pc, #44]	; (14900 <USB_HostInit+0x118>)
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   148d4:	4b0b      	ldr	r3, [pc, #44]	; (14904 <USB_HostInit+0x11c>)
    USBx->GRXFSIZ  = 0x80U;
   148d6:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   148d8:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   148da:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
   148de:	e7e7      	b.n	148b0 <USB_HostInit+0xc8>
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   148e0:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
   148e4:	e79b      	b.n	1481e <USB_HostInit+0x36>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   148e6:	f043 0304 	orr.w	r3, r3, #4
   148ea:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
   148ee:	e79a      	b.n	14826 <USB_HostInit+0x3e>
   148f0:	00030d40 	.word	0x00030d40
   148f4:	01000200 	.word	0x01000200
   148f8:	00e00300 	.word	0x00e00300
   148fc:	a3200008 	.word	0xa3200008
   14900:	00600080 	.word	0x00600080
   14904:	004000e0 	.word	0x004000e0

00014908 <USB_ResetPort>:
{
   14908:	b530      	push	{r4, r5, lr}
   1490a:	4604      	mov	r4, r0
   1490c:	b083      	sub	sp, #12
  __IO uint32_t hprt0 = 0U;
   1490e:	2500      	movs	r5, #0
  HAL_Delay(100U);                                 /* See Note #1 */
   14910:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
   14912:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
   14914:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
   14918:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   1491a:	9b01      	ldr	r3, [sp, #4]
   1491c:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   14920:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
   14922:	9b01      	ldr	r3, [sp, #4]
   14924:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   14928:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
   1492c:	f7f3 fd68 	bl	8400 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   14930:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
   14932:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   14934:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   14938:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
   1493c:	f7f3 fd60 	bl	8400 <HAL_Delay>
}
   14940:	4628      	mov	r0, r5
   14942:	b003      	add	sp, #12
   14944:	bd30      	pop	{r4, r5, pc}
   14946:	bf00      	nop

00014948 <USB_DriveVbus>:
{
   14948:	b082      	sub	sp, #8
  __IO uint32_t hprt0 = 0U;
   1494a:	2300      	movs	r3, #0
   1494c:	9301      	str	r3, [sp, #4]
  hprt0 = USBx_HPRT0;
   1494e:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
   14952:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   14954:	9b01      	ldr	r3, [sp, #4]
   14956:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
   1495a:	9301      	str	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   1495c:	9b01      	ldr	r3, [sp, #4]
   1495e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   14962:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   14964:	d101      	bne.n	1496a <USB_DriveVbus+0x22>
   14966:	2901      	cmp	r1, #1
   14968:	d00a      	beq.n	14980 <USB_DriveVbus+0x38>
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   1496a:	04db      	lsls	r3, r3, #19
   1496c:	d505      	bpl.n	1497a <USB_DriveVbus+0x32>
   1496e:	b921      	cbnz	r1, 1497a <USB_DriveVbus+0x32>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
   14970:	9b01      	ldr	r3, [sp, #4]
   14972:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   14976:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  return HAL_OK;
}
   1497a:	2000      	movs	r0, #0
   1497c:	b002      	add	sp, #8
   1497e:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   14980:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   14984:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
   14988:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   1498a:	9b01      	ldr	r3, [sp, #4]
}
   1498c:	b002      	add	sp, #8
   1498e:	4770      	bx	lr

00014990 <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
   14990:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
   14992:	2300      	movs	r3, #0
   14994:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
   14996:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
   1499a:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
   1499c:	9801      	ldr	r0, [sp, #4]
}
   1499e:	f3c0 4041 	ubfx	r0, r0, #17, #2
   149a2:	b002      	add	sp, #8
   149a4:	4770      	bx	lr
   149a6:	bf00      	nop

000149a8 <USB_GetCurrentFrame>:
*/
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   149a8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
   149ac:	6880      	ldr	r0, [r0, #8]
}
   149ae:	b280      	uxth	r0, r0
   149b0:	4770      	bx	lr
   149b2:	bf00      	nop

000149b4 <USB_HC_Init>:
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
   149b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   149b8:	4606      	mov	r6, r0
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t HCcharEpDir, HCcharLowSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   149ba:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   149be:	2001      	movs	r0, #1
{
   149c0:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   149c4:	eb06 1541 	add.w	r5, r6, r1, lsl #5
   149c8:	f001 010f 	and.w	r1, r1, #15
   149cc:	f506 6980 	add.w	r9, r6, #1024	; 0x400
{
   149d0:	f89d e01c 	ldrb.w	lr, [sp, #28]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   149d4:	f505 68a0 	add.w	r8, r5, #1280	; 0x500
   149d8:	fa00 f101 	lsl.w	r1, r0, r1
   149dc:	f8c8 7008 	str.w	r7, [r8, #8]
   149e0:	b250      	sxtb	r0, r2
{
   149e2:	f8bd c024 	ldrh.w	ip, [sp, #36]	; 0x24

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
   149e6:	2c03      	cmp	r4, #3
   149e8:	d85b      	bhi.n	14aa2 <USB_HC_Init+0xee>
   149ea:	e8df f004 	tbb	[pc, r4]
   149ee:	3d4a      	.short	0x3d4a
   149f0:	024a      	.short	0x024a
        }
      }
      break;

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   149f2:	f240 679d 	movw	r7, #1693	; 0x69d
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
   149f6:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   149f8:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   149fc:	db63      	blt.n	14ac6 <USB_HC_Init+0x112>
      ret = HAL_ERROR;
      break;
  }

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   149fe:	f8d9 7018 	ldr.w	r7, [r9, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14a02:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14a04:	4339      	orrs	r1, r7
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
  }
  else
  {
    HCcharEpDir = 0U;
   14a06:	4607      	mov	r7, r0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14a08:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14a0c:	69b1      	ldr	r1, [r6, #24]
   14a0e:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   14a12:	61b1      	str	r1, [r6, #24]
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   14a14:	0599      	lsls	r1, r3, #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   14a16:	f3cc 030a 	ubfx	r3, ip, #0, #11
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   14a1a:	02d2      	lsls	r2, r2, #11
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   14a1c:	f1be 0f02 	cmp.w	lr, #2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   14a20:	f001 51fe 	and.w	r1, r1, #532676608	; 0x1fc00000
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   14a24:	ea4f 4684 	mov.w	r6, r4, lsl #18
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   14a28:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   14a2c:	bf18      	it	ne
   14a2e:	f04f 0c00 	movne.w	ip, #0
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   14a32:	ea43 0301 	orr.w	r3, r3, r1
   14a36:	f406 2140 	and.w	r1, r6, #786432	; 0xc0000
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   14a3a:	bf08      	it	eq
   14a3c:	f44f 3c00 	moveq.w	ip, #131072	; 0x20000

  if (ep_type == EP_TYPE_INTR)
   14a40:	2c03      	cmp	r4, #3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   14a42:	ea43 0302 	orr.w	r3, r3, r2
   14a46:	ea43 0301 	orr.w	r3, r3, r1
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   14a4a:	ea43 0307 	orr.w	r3, r3, r7
   14a4e:	ea43 030c 	orr.w	r3, r3, ip
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   14a52:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  if (ep_type == EP_TYPE_INTR)
   14a56:	d105      	bne.n	14a64 <USB_HC_Init+0xb0>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   14a58:	f8d5 3500 	ldr.w	r3, [r5, #1280]	; 0x500
   14a5c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   14a60:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  }

  return ret;
}
   14a64:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a68:	f240 2725 	movw	r7, #549	; 0x225
      if ((epnum & 0x80U) == 0x80U)
   14a6c:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a6e:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   14a72:	dac4      	bge.n	149fe <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
   14a74:	f8d8 000c 	ldr.w	r0, [r8, #12]
   14a78:	f440 70c0 	orr.w	r0, r0, #384	; 0x180
   14a7c:	f8c8 000c 	str.w	r0, [r8, #12]
   14a80:	e027      	b.n	14ad2 <USB_HC_Init+0x11e>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a82:	f240 479d 	movw	r7, #1181	; 0x49d
      if ((epnum & 0x80U) == 0x80U)
   14a86:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   14a88:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
   14a8c:	db1b      	blt.n	14ac6 <USB_HC_Init+0x112>
        if ((USBx->CID & (0x1U << 8)) != 0U)
   14a8e:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
   14a90:	05c0      	lsls	r0, r0, #23
   14a92:	d5b4      	bpl.n	149fe <USB_HC_Init+0x4a>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   14a94:	f8d8 000c 	ldr.w	r0, [r8, #12]
   14a98:	f040 0060 	orr.w	r0, r0, #96	; 0x60
   14a9c:	f8c8 000c 	str.w	r0, [r8, #12]
   14aa0:	e7ad      	b.n	149fe <USB_HC_Init+0x4a>
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14aa2:	f8d9 7018 	ldr.w	r7, [r9, #24]
      ret = HAL_ERROR;
   14aa6:	2800      	cmp	r0, #0
   14aa8:	f04f 0001 	mov.w	r0, #1
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14aac:	ea41 0107 	orr.w	r1, r1, r7
      ret = HAL_ERROR;
   14ab0:	bfac      	ite	ge
   14ab2:	2700      	movge	r7, #0
   14ab4:	f44f 4700 	movlt.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ab8:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14abc:	69b1      	ldr	r1, [r6, #24]
   14abe:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   14ac2:	61b1      	str	r1, [r6, #24]
   14ac4:	e7a6      	b.n	14a14 <USB_HC_Init+0x60>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   14ac6:	f8d8 000c 	ldr.w	r0, [r8, #12]
   14aca:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   14ace:	f8c8 000c 	str.w	r0, [r8, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ad2:	f8d9 7018 	ldr.w	r7, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14ad6:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ad8:	4339      	orrs	r1, r7
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
   14ada:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   14ade:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   14ae2:	69b1      	ldr	r1, [r6, #24]
   14ae4:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
   14ae8:	61b1      	str	r1, [r6, #24]
   14aea:	e793      	b.n	14a14 <USB_HC_Init+0x60>

00014aec <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
   14aec:	b4f0      	push	{r4, r5, r6, r7}
   14aee:	784b      	ldrb	r3, [r1, #1]
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
   14af0:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
   14af2:	eb00 1343 	add.w	r3, r0, r3, lsl #5
   14af6:	05e4      	lsls	r4, r4, #23
   14af8:	f503 67a0 	add.w	r7, r3, #1280	; 0x500
   14afc:	d50a      	bpl.n	14b14 <USB_HC_StartXfer+0x28>
   14afe:	790c      	ldrb	r4, [r1, #4]
   14b00:	b944      	cbnz	r4, 14b14 <USB_HC_StartXfer+0x28>
  {
    if ((dma == 0U) && (hc->do_ping == 1U))
   14b02:	2a00      	cmp	r2, #0
   14b04:	d05f      	beq.n	14bc6 <USB_HC_StartXfer+0xda>
    {
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
    else if (dma == 1U)
   14b06:	2a01      	cmp	r2, #1
   14b08:	d104      	bne.n	14b14 <USB_HC_StartXfer+0x28>
    {
      USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   14b0a:	68fd      	ldr	r5, [r7, #12]
   14b0c:	f025 0560 	bic.w	r5, r5, #96	; 0x60
   14b10:	60fd      	str	r5, [r7, #12]
      hc->do_ping = 0U;
   14b12:	714c      	strb	r4, [r1, #5]
      /* ... */
    }
  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
   14b14:	690d      	ldr	r5, [r1, #16]
   14b16:	2d00      	cmp	r5, #0
   14b18:	d149      	bne.n	14bae <USB_HC_StartXfer+0xc2>
   14b1a:	f44f 2600 	mov.w	r6, #524288	; 0x80000
   14b1e:	f04f 0c01 	mov.w	ip, #1
  }
  else
  {
    num_packets = 1U;
  }
  if (hc->ep_is_in != 0U)
   14b22:	78cc      	ldrb	r4, [r1, #3]
   14b24:	b11c      	cbz	r4, 14b2e <USB_HC_StartXfer+0x42>
  {
    hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   14b26:	890d      	ldrh	r5, [r1, #8]
   14b28:	fb0c f505 	mul.w	r5, ip, r5
   14b2c:	610d      	str	r5, [r1, #16]
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   14b2e:	7a8c      	ldrb	r4, [r1, #10]
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   14b30:	f3c5 0512 	ubfx	r5, r5, #0, #19
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   14b34:	0764      	lsls	r4, r4, #29
   14b36:	f004 44c0 	and.w	r4, r4, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   14b3a:	4334      	orrs	r4, r6
   14b3c:	432c      	orrs	r4, r5
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   14b3e:	613c      	str	r4, [r7, #16]

  if (dma != 0U)
   14b40:	b10a      	cbz	r2, 14b46 <USB_HC_StartXfer+0x5a>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   14b42:	68cc      	ldr	r4, [r1, #12]
   14b44:	617c      	str	r4, [r7, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
   14b46:	f500 6680 	add.w	r6, r0, #1024	; 0x400
   14b4a:	68b4      	ldr	r4, [r6, #8]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   14b4c:	f8d3 7500 	ldr.w	r7, [r3, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   14b50:	43e4      	mvns	r4, r4

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   14b52:	4d41      	ldr	r5, [pc, #260]	; (14c58 <USB_HC_StartXfer+0x16c>)
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   14b54:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   14b58:	0764      	lsls	r4, r4, #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   14b5a:	f8c3 7500 	str.w	r7, [r3, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   14b5e:	f004 5400 	and.w	r4, r4, #536870912	; 0x20000000
   14b62:	f8d3 7500 	ldr.w	r7, [r3, #1280]	; 0x500
   14b66:	433c      	orrs	r4, r7
   14b68:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   14b6c:	f8d3 4500 	ldr.w	r4, [r3, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
   14b70:	78cf      	ldrb	r7, [r1, #3]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
   14b72:	602c      	str	r4, [r5, #0]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   14b74:	682c      	ldr	r4, [r5, #0]
   14b76:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000
   14b7a:	602c      	str	r4, [r5, #0]
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
   14b7c:	682c      	ldr	r4, [r5, #0]
  if (hc->ep_is_in != 0U)
   14b7e:	2f00      	cmp	r7, #0
   14b80:	d031      	beq.n	14be6 <USB_HC_StartXfer+0xfa>
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
   14b82:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
   14b86:	602c      	str	r4, [r5, #0]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
   14b88:	682c      	ldr	r4, [r5, #0]
   14b8a:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
   14b8e:	602c      	str	r4, [r5, #0]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
   14b90:	682c      	ldr	r4, [r5, #0]
   14b92:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500

  if (dma == 0U) /* Slave mode */
   14b96:	bb1a      	cbnz	r2, 14be0 <USB_HC_StartXfer+0xf4>
  {
    if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
   14b98:	78cb      	ldrb	r3, [r1, #3]
   14b9a:	bb0b      	cbnz	r3, 14be0 <USB_HC_StartXfer+0xf4>
   14b9c:	690b      	ldr	r3, [r1, #16]
   14b9e:	b1fb      	cbz	r3, 14be0 <USB_HC_StartXfer+0xf4>
    {
      switch (hc->ep_type)
   14ba0:	79ca      	ldrb	r2, [r1, #7]
   14ba2:	2a03      	cmp	r2, #3
   14ba4:	d831      	bhi.n	14c0a <USB_HC_StartXfer+0x11e>
   14ba6:	e8df f002 	tbb	[pc, r2]
   14baa:	2944      	.short	0x2944
   14bac:	2944      	.short	0x2944
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
   14bae:	890e      	ldrh	r6, [r1, #8]
   14bb0:	1e6c      	subs	r4, r5, #1
   14bb2:	4434      	add	r4, r6
   14bb4:	fbb4 f4f6 	udiv	r4, r4, r6
    if (num_packets > max_hc_pkt_count)
   14bb8:	fa1f fc84 	uxth.w	ip, r4
   14bbc:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
   14bc0:	d815      	bhi.n	14bee <USB_HC_StartXfer+0x102>
   14bc2:	04e6      	lsls	r6, r4, #19
   14bc4:	e7ad      	b.n	14b22 <USB_HC_StartXfer+0x36>
    if ((dma == 0U) && (hc->do_ping == 1U))
   14bc6:	794c      	ldrb	r4, [r1, #5]
   14bc8:	2c01      	cmp	r4, #1
   14bca:	d1a3      	bne.n	14b14 <USB_HC_StartXfer+0x28>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   14bcc:	4a23      	ldr	r2, [pc, #140]	; (14c5c <USB_HC_StartXfer+0x170>)
   14bce:	613a      	str	r2, [r7, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
   14bd0:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   14bd4:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
   14bd8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
   14bdc:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   14be0:	2000      	movs	r0, #0
   14be2:	bcf0      	pop	{r4, r5, r6, r7}
   14be4:	4770      	bx	lr
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
   14be6:	f424 4400 	bic.w	r4, r4, #32768	; 0x8000
   14bea:	602c      	str	r4, [r5, #0]
   14bec:	e7cc      	b.n	14b88 <USB_HC_StartXfer+0x9c>
      hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   14bee:	0235      	lsls	r5, r6, #8
   14bf0:	f44f 7c80 	mov.w	ip, #256	; 0x100
   14bf4:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
   14bf8:	610d      	str	r5, [r1, #16]
   14bfa:	e792      	b.n	14b22 <USB_HC_StartXfer+0x36>
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   14bfc:	6934      	ldr	r4, [r6, #16]
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   14bfe:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   14c00:	b2a4      	uxth	r4, r4
   14c02:	f3c2 028f 	ubfx	r2, r2, #2, #16
   14c06:	4294      	cmp	r4, r2
   14c08:	d320      	bcc.n	14c4c <USB_HC_StartXfer+0x160>
    count32b = ((uint32_t)len + 3U) / 4U;
   14c0a:	b29b      	uxth	r3, r3
      (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
   14c0c:	68ca      	ldr	r2, [r1, #12]
   14c0e:	7849      	ldrb	r1, [r1, #1]
    count32b = ((uint32_t)len + 3U) / 4U;
   14c10:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
   14c12:	089b      	lsrs	r3, r3, #2
   14c14:	d0e4      	beq.n	14be0 <USB_HC_StartXfer+0xf4>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   14c16:	eb00 3001 	add.w	r0, r0, r1, lsl #12
   14c1a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   14c1e:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
   14c22:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
   14c26:	4293      	cmp	r3, r2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   14c28:	6001      	str	r1, [r0, #0]
    for (i = 0U; i < count32b; i++)
   14c2a:	d1fa      	bne.n	14c22 <USB_HC_StartXfer+0x136>
}
   14c2c:	2000      	movs	r0, #0
   14c2e:	bcf0      	pop	{r4, r5, r6, r7}
   14c30:	4770      	bx	lr
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   14c32:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   14c34:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   14c36:	b2a4      	uxth	r4, r4
   14c38:	f3c2 028f 	ubfx	r2, r2, #2, #16
   14c3c:	4294      	cmp	r4, r2
   14c3e:	d2e4      	bcs.n	14c0a <USB_HC_StartXfer+0x11e>
            USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   14c40:	6983      	ldr	r3, [r0, #24]
   14c42:	f043 0320 	orr.w	r3, r3, #32
   14c46:	6183      	str	r3, [r0, #24]
   14c48:	690b      	ldr	r3, [r1, #16]
   14c4a:	e7de      	b.n	14c0a <USB_HC_StartXfer+0x11e>
            USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
   14c4c:	6983      	ldr	r3, [r0, #24]
   14c4e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   14c52:	6183      	str	r3, [r0, #24]
   14c54:	690b      	ldr	r3, [r1, #16]
   14c56:	e7d8      	b.n	14c0a <USB_HC_StartXfer+0x11e>
   14c58:	020e30c4 	.word	0x020e30c4
   14c5c:	80080000 	.word	0x80080000

00014c60 <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
   14c60:	eb00 1141 	add.w	r1, r0, r1, lsl #5
   14c64:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   14c68:	f501 62a0 	add.w	r2, r1, #1280	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   14c6c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   14c70:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   14c74:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   14c78:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   14c7c:	d11f      	bne.n	14cbe <USB_HC_Halt+0x5e>
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
   14c7e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   14c80:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   14c84:	d13c      	bne.n	14d00 <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14c86:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14c8a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14c8e:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   14c92:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   14c96:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14c9a:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
   14c9e:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14ca2:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14ca6:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
   14caa:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
   14cae:	e001      	b.n	14cb4 <USB_HC_Halt+0x54>
        if (++count > 1000U)
   14cb0:	3b01      	subs	r3, #1
   14cb2:	d02b      	beq.n	14d0c <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   14cb4:	6811      	ldr	r1, [r2, #0]
   14cb6:	2900      	cmp	r1, #0
   14cb8:	dbfa      	blt.n	14cb0 <USB_HC_Halt+0x50>
}
   14cba:	2000      	movs	r0, #0
   14cbc:	4770      	bx	lr
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
   14cbe:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
   14cc2:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   14cc6:	d11b      	bne.n	14d00 <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14cc8:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14ccc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   14cd0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   14cd4:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   14cd8:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14cdc:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
   14ce0:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   14ce4:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
   14ce8:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
   14cec:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
   14cf0:	e001      	b.n	14cf6 <USB_HC_Halt+0x96>
        if (++count > 1000U)
   14cf2:	3b01      	subs	r3, #1
   14cf4:	d00a      	beq.n	14d0c <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   14cf6:	6811      	ldr	r1, [r2, #0]
   14cf8:	2900      	cmp	r1, #0
   14cfa:	dbfa      	blt.n	14cf2 <USB_HC_Halt+0x92>
}
   14cfc:	2000      	movs	r0, #0
   14cfe:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   14d00:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
   14d04:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   14d08:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
   14d0c:	2000      	movs	r0, #0
   14d0e:	4770      	bx	lr

00014d10 <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
   14d10:	b410      	push	{r4}
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   14d12:	6882      	ldr	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14d14:	f44f 6184 	mov.w	r1, #1056	; 0x420
{
   14d18:	4604      	mov	r4, r0
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14d1a:	4b5b      	ldr	r3, [pc, #364]	; (14e88 <USB_StopHost+0x178>)
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   14d1c:	f022 0201 	bic.w	r2, r2, #1
   14d20:	6082      	str	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   14d22:	6101      	str	r1, [r0, #16]
   14d24:	e001      	b.n	14d2a <USB_StopHost+0x1a>
    if (++count > 200000U)
   14d26:	3b01      	subs	r3, #1
   14d28:	d002      	beq.n	14d30 <USB_StopHost+0x20>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   14d2a:	6922      	ldr	r2, [r4, #16]
   14d2c:	0691      	lsls	r1, r2, #26
   14d2e:	d4fa      	bmi.n	14d26 <USB_StopHost+0x16>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   14d30:	2210      	movs	r2, #16
   14d32:	4b55      	ldr	r3, [pc, #340]	; (14e88 <USB_StopHost+0x178>)
   14d34:	6122      	str	r2, [r4, #16]
   14d36:	e001      	b.n	14d3c <USB_StopHost+0x2c>
    if (++count > 200000U)
   14d38:	3b01      	subs	r3, #1
   14d3a:	d002      	beq.n	14d42 <USB_StopHost+0x32>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   14d3c:	6922      	ldr	r2, [r4, #16]
   14d3e:	06d2      	lsls	r2, r2, #27
   14d40:	d4fa      	bmi.n	14d38 <USB_StopHost+0x28>
  (void)USB_FlushRxFifo(USBx);

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
   14d42:	f8d4 2500 	ldr.w	r2, [r4, #1280]	; 0x500
   14d46:	f504 61a0 	add.w	r1, r4, #1280	; 0x500
   14d4a:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
  uint32_t count = 0U;
   14d4e:	2300      	movs	r3, #0
   14d50:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d54:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d58:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    value = USBx_HC(i)->HCCHAR;
   14d5c:	f8d4 2520 	ldr.w	r2, [r4, #1312]	; 0x520
   14d60:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d64:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d68:	f8c4 2520 	str.w	r2, [r4, #1312]	; 0x520
    value = USBx_HC(i)->HCCHAR;
   14d6c:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
   14d70:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d74:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d78:	f8c4 2540 	str.w	r2, [r4, #1344]	; 0x540
    value = USBx_HC(i)->HCCHAR;
   14d7c:	f8d4 2560 	ldr.w	r2, [r4, #1376]	; 0x560
   14d80:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d84:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d88:	f8c4 2560 	str.w	r2, [r4, #1376]	; 0x560
    value = USBx_HC(i)->HCCHAR;
   14d8c:	f8d4 2580 	ldr.w	r2, [r4, #1408]	; 0x580
   14d90:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14d94:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14d98:	f8c4 2580 	str.w	r2, [r4, #1408]	; 0x580
    value = USBx_HC(i)->HCCHAR;
   14d9c:	f8d4 25a0 	ldr.w	r2, [r4, #1440]	; 0x5a0
   14da0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14da4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14da8:	f8c4 25a0 	str.w	r2, [r4, #1440]	; 0x5a0
    value = USBx_HC(i)->HCCHAR;
   14dac:	f8d4 25c0 	ldr.w	r2, [r4, #1472]	; 0x5c0
   14db0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14db4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14db8:	f8c4 25c0 	str.w	r2, [r4, #1472]	; 0x5c0
    value = USBx_HC(i)->HCCHAR;
   14dbc:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
   14dc0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14dc4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14dc8:	f8c4 25e0 	str.w	r2, [r4, #1504]	; 0x5e0
    value = USBx_HC(i)->HCCHAR;
   14dcc:	f8d4 2600 	ldr.w	r2, [r4, #1536]	; 0x600
   14dd0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14dd4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14dd8:	f8c4 2600 	str.w	r2, [r4, #1536]	; 0x600
    value = USBx_HC(i)->HCCHAR;
   14ddc:	f8d4 2620 	ldr.w	r2, [r4, #1568]	; 0x620
   14de0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14de4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14de8:	f8c4 2620 	str.w	r2, [r4, #1568]	; 0x620
    value = USBx_HC(i)->HCCHAR;
   14dec:	f8d4 2640 	ldr.w	r2, [r4, #1600]	; 0x640
   14df0:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14df4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14df8:	f8c4 2640 	str.w	r2, [r4, #1600]	; 0x640
    value = USBx_HC(i)->HCCHAR;
   14dfc:	f8d4 2660 	ldr.w	r2, [r4, #1632]	; 0x660
   14e00:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e04:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e08:	f8c4 2660 	str.w	r2, [r4, #1632]	; 0x660
    value = USBx_HC(i)->HCCHAR;
   14e0c:	f8d4 2680 	ldr.w	r2, [r4, #1664]	; 0x680
   14e10:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e14:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e18:	f8c4 2680 	str.w	r2, [r4, #1664]	; 0x680
    value = USBx_HC(i)->HCCHAR;
   14e1c:	f8d4 26a0 	ldr.w	r2, [r4, #1696]	; 0x6a0
   14e20:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e24:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e28:	f8c4 26a0 	str.w	r2, [r4, #1696]	; 0x6a0
    value = USBx_HC(i)->HCCHAR;
   14e2c:	f8d4 26c0 	ldr.w	r2, [r4, #1728]	; 0x6c0
   14e30:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e34:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e38:	f8c4 26c0 	str.w	r2, [r4, #1728]	; 0x6c0
    value = USBx_HC(i)->HCCHAR;
   14e3c:	f8d4 26e0 	ldr.w	r2, [r4, #1760]	; 0x6e0
   14e40:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e44:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
   14e48:	f8c4 26e0 	str.w	r2, [r4, #1760]	; 0x6e0
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
   14e4c:	680a      	ldr	r2, [r1, #0]
   14e4e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
   14e52:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
   14e56:	600a      	str	r2, [r1, #0]
   14e58:	e002      	b.n	14e60 <USB_StopHost+0x150>
      if (++count > 1000U)
      {
        break;
      }
    }
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   14e5a:	680a      	ldr	r2, [r1, #0]
   14e5c:	2a00      	cmp	r2, #0
   14e5e:	da03      	bge.n	14e68 <USB_StopHost+0x158>
      if (++count > 1000U)
   14e60:	3301      	adds	r3, #1
   14e62:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   14e66:	d9f8      	bls.n	14e5a <USB_StopHost+0x14a>
   14e68:	3120      	adds	r1, #32
  for (i = 0U; i <= 15U; i++)
   14e6a:	4281      	cmp	r1, r0
   14e6c:	d1ee      	bne.n	14e4c <USB_StopHost+0x13c>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
   14e6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTSTS = 0xFFFFFFFFU;

  (void)USB_EnableGlobalInt(USBx);

  return HAL_OK;
}
   14e72:	2000      	movs	r0, #0
  USBx_HOST->HAINT = 0xFFFFFFFFU;
   14e74:	f8c4 3414 	str.w	r3, [r4, #1044]	; 0x414
  USBx->GINTSTS = 0xFFFFFFFFU;
   14e78:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   14e7a:	68a3      	ldr	r3, [r4, #8]
   14e7c:	f043 0301 	orr.w	r3, r3, #1
   14e80:	60a3      	str	r3, [r4, #8]
}
   14e82:	f85d 4b04 	ldr.w	r4, [sp], #4
   14e86:	4770      	bx	lr
   14e88:	00030d40 	.word	0x00030d40

00014e8c <USBH_Init>:
USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
                              void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                              uint8_t id), uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
   14e8c:	b3a0      	cbz	r0, 14ef8 <USBH_Init+0x6c>
{
   14e8e:	b570      	push	{r4, r5, r6, lr}
   14e90:	4604      	mov	r4, r0

  /* Set DRiver ID */
  phost->id = id;

  /* Unlink class*/
  phost->pActiveClass = NULL;
   14e92:	2500      	movs	r5, #0
  phost->id = id;
   14e94:	f880 253c 	strb.w	r2, [r0, #1340]	; 0x53c
   14e98:	460e      	mov	r6, r1
   14e9a:	223c      	movs	r2, #60	; 0x3c
   14e9c:	4629      	mov	r1, r5
   14e9e:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
  phost->pActiveClass = NULL;
   14ea2:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
  phost->ClassNumber = 0U;
   14ea6:	f8c4 54f0 	str.w	r5, [r4, #1264]	; 0x4f0
   14eaa:	f017 fdca 	bl	2ca42 <memset>
   14eae:	4629      	mov	r1, r5
   14eb0:	f44f 7200 	mov.w	r2, #512	; 0x200
   14eb4:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   14eb8:	f017 fdc3 	bl	2ca42 <memset>
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
  phost->EnumState = ENUM_IDLE;
  phost->RequestState = CMD_SEND;
   14ebc:	2301      	movs	r3, #1
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14ebe:	2140      	movs	r1, #64	; 0x40
  phost->Control.errorcount = 0U;

  phost->device.address = USBH_ADDRESS_DEFAULT;
   14ec0:	f44f 7280 	mov.w	r2, #256	; 0x100
  phost->gState = HOST_IDLE;
   14ec4:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
   14ec6:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
   14ec8:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
   14ecc:	7665      	strb	r5, [r4, #25]
  phost->device.is_connected = 0U;
   14ece:	f884 5320 	strb.w	r5, [r4, #800]	; 0x320
  phost->device.PortEnabled = 0U;
   14ed2:	f884 5323 	strb.w	r5, [r4, #803]	; 0x323
  phost->device.is_disconnected = 0U;
   14ed6:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
  phost->RequestState = CMD_SEND;
   14eda:	70a3      	strb	r3, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
   14edc:	f884 5322 	strb.w	r5, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
   14ee0:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14ee2:	71a1      	strb	r1, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
   14ee4:	f8c4 231c 	str.w	r2, [r4, #796]	; 0x31c
  if (pUsrFunc != NULL)
   14ee8:	b10e      	cbz	r6, 14eee <USBH_Init+0x62>
    phost->pUser = pUsrFunc;
   14eea:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
  USBH_LL_Init(phost);
   14eee:	4620      	mov	r0, r4
   14ef0:	f00e fe28 	bl	23b44 <USBH_LL_Init>
  return USBH_OK;
   14ef4:	2000      	movs	r0, #0
}
   14ef6:	bd70      	pop	{r4, r5, r6, pc}
    return USBH_FAIL;
   14ef8:	2002      	movs	r0, #2
}
   14efa:	4770      	bx	lr

00014efc <USBH_DeInit>:
{
   14efc:	b538      	push	{r3, r4, r5, lr}
   14efe:	4604      	mov	r4, r0
   14f00:	223c      	movs	r2, #60	; 0x3c
   14f02:	2100      	movs	r1, #0
   14f04:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
   14f08:	f017 fd9b 	bl	2ca42 <memset>
   14f0c:	f44f 7200 	mov.w	r2, #512	; 0x200
   14f10:	2100      	movs	r1, #0
   14f12:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   14f16:	f017 fd94 	bl	2ca42 <memset>
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14f1a:	2540      	movs	r5, #64	; 0x40
  phost->gState = HOST_IDLE;
   14f1c:	2300      	movs	r3, #0
  phost->RequestState = CMD_SEND;
   14f1e:	2201      	movs	r2, #1
  phost->device.address = USBH_ADDRESS_DEFAULT;
   14f20:	f44f 7080 	mov.w	r0, #256	; 0x100
  if (phost->pData != NULL)
   14f24:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
  phost->gState = HOST_IDLE;
   14f28:	7023      	strb	r3, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   14f2a:	71a5      	strb	r5, [r4, #6]
  phost->Timer = 0U;
   14f2c:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
  phost->device.address = USBH_ADDRESS_DEFAULT;
   14f30:	f8c4 031c 	str.w	r0, [r4, #796]	; 0x31c
  phost->device.is_connected = 0U;
   14f34:	f884 3320 	strb.w	r3, [r4, #800]	; 0x320
  phost->EnumState = ENUM_IDLE;
   14f38:	7063      	strb	r3, [r4, #1]
  phost->device.is_disconnected = 0U;
   14f3a:	f884 3321 	strb.w	r3, [r4, #801]	; 0x321
  phost->Control.errorcount = 0U;
   14f3e:	7663      	strb	r3, [r4, #25]
  phost->device.PortEnabled = 0U;
   14f40:	f884 3323 	strb.w	r3, [r4, #803]	; 0x323
  phost->RequestState = CMD_SEND;
   14f44:	70a2      	strb	r2, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
   14f46:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
   14f4a:	7622      	strb	r2, [r4, #24]
  if (phost->pData != NULL)
   14f4c:	b111      	cbz	r1, 14f54 <USBH_DeInit+0x58>
    USBH_LL_Stop(phost);
   14f4e:	4620      	mov	r0, r4
   14f50:	f00e fe32 	bl	23bb8 <USBH_LL_Stop>
}
   14f54:	2000      	movs	r0, #0
   14f56:	bd38      	pop	{r3, r4, r5, pc}

00014f58 <USBH_RegisterClass>:
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
   14f58:	b149      	cbz	r1, 14f6e <USBH_RegisterClass+0x16>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
   14f5a:	f8d0 34f0 	ldr.w	r3, [r0, #1264]	; 0x4f0
   14f5e:	b933      	cbnz	r3, 14f6e <USBH_RegisterClass+0x16>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
   14f60:	2201      	movs	r2, #1
   14f62:	f8c0 14e8 	str.w	r1, [r0, #1256]	; 0x4e8
   14f66:	f8c0 24f0 	str.w	r2, [r0, #1264]	; 0x4f0
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
   14f6a:	4618      	mov	r0, r3
   14f6c:	4770      	bx	lr
    status = USBH_FAIL;
   14f6e:	2302      	movs	r3, #2
}
   14f70:	4618      	mov	r0, r3
   14f72:	4770      	bx	lr

00014f74 <USBH_SelectInterface>:
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
   14f74:	f890 333c 	ldrb.w	r3, [r0, #828]	; 0x33c
   14f78:	428b      	cmp	r3, r1
   14f7a:	d903      	bls.n	14f84 <USBH_SelectInterface+0x10>
  {
    phost->device.current_interface = interface;
   14f7c:	f880 1324 	strb.w	r1, [r0, #804]	; 0x324
  USBH_StatusTypeDef status = USBH_OK;
   14f80:	2000      	movs	r0, #0
   14f82:	4770      	bx	lr
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
   14f84:	2002      	movs	r0, #2
  }

  return status;
}
   14f86:	4770      	bx	lr

00014f88 <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
   14f88:	b430      	push	{r4, r5}
   14f8a:	f1a1 04ff 	sub.w	r4, r1, #255	; 0xff
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   14f8e:	f890 5347 	ldrb.w	r5, [r0, #839]	; 0x347
   14f92:	fab4 f484 	clz	r4, r4
   14f96:	428d      	cmp	r5, r1
   14f98:	ea4f 1454 	mov.w	r4, r4, lsr #5
   14f9c:	d03c      	beq.n	15018 <USBH_FindInterface+0x90>
   14f9e:	2c00      	cmp	r4, #0
   14fa0:	d13a      	bne.n	15018 <USBH_FindInterface+0x90>
   14fa2:	f890 5371 	ldrb.w	r5, [r0, #881]	; 0x371
   14fa6:	428d      	cmp	r5, r1
   14fa8:	d044      	beq.n	15034 <USBH_FindInterface+0xac>
   14faa:	2c00      	cmp	r4, #0
   14fac:	d142      	bne.n	15034 <USBH_FindInterface+0xac>
   14fae:	f890 539b 	ldrb.w	r5, [r0, #923]	; 0x39b
   14fb2:	428d      	cmp	r5, r1
   14fb4:	d04c      	beq.n	15050 <USBH_FindInterface+0xc8>
   14fb6:	2c00      	cmp	r4, #0
   14fb8:	d14a      	bne.n	15050 <USBH_FindInterface+0xc8>
   14fba:	f890 53c5 	ldrb.w	r5, [r0, #965]	; 0x3c5
   14fbe:	428d      	cmp	r5, r1
   14fc0:	d054      	beq.n	1506c <USBH_FindInterface+0xe4>
   14fc2:	2c00      	cmp	r4, #0
   14fc4:	d152      	bne.n	1506c <USBH_FindInterface+0xe4>
   14fc6:	f890 53ef 	ldrb.w	r5, [r0, #1007]	; 0x3ef
   14fca:	428d      	cmp	r5, r1
   14fcc:	d05c      	beq.n	15088 <USBH_FindInterface+0x100>
   14fce:	2c00      	cmp	r4, #0
   14fd0:	d15a      	bne.n	15088 <USBH_FindInterface+0x100>
   14fd2:	f890 5419 	ldrb.w	r5, [r0, #1049]	; 0x419
   14fd6:	428d      	cmp	r5, r1
   14fd8:	d064      	beq.n	150a4 <USBH_FindInterface+0x11c>
   14fda:	2c00      	cmp	r4, #0
   14fdc:	d162      	bne.n	150a4 <USBH_FindInterface+0x11c>
   14fde:	f890 5443 	ldrb.w	r5, [r0, #1091]	; 0x443
   14fe2:	428d      	cmp	r5, r1
   14fe4:	d06c      	beq.n	150c0 <USBH_FindInterface+0x138>
   14fe6:	2c00      	cmp	r4, #0
   14fe8:	d16a      	bne.n	150c0 <USBH_FindInterface+0x138>
   14fea:	f890 546d 	ldrb.w	r5, [r0, #1133]	; 0x46d
   14fee:	428d      	cmp	r5, r1
   14ff0:	d074      	beq.n	150dc <USBH_FindInterface+0x154>
   14ff2:	2c00      	cmp	r4, #0
   14ff4:	d172      	bne.n	150dc <USBH_FindInterface+0x154>
   14ff6:	f890 5497 	ldrb.w	r5, [r0, #1175]	; 0x497
   14ffa:	428d      	cmp	r5, r1
   14ffc:	d07c      	beq.n	150f8 <USBH_FindInterface+0x170>
   14ffe:	2c00      	cmp	r4, #0
   15000:	d17a      	bne.n	150f8 <USBH_FindInterface+0x170>
   15002:	f890 54c1 	ldrb.w	r5, [r0, #1217]	; 0x4c1
   15006:	428d      	cmp	r5, r1
   15008:	f000 8086 	beq.w	15118 <USBH_FindInterface+0x190>
   1500c:	2c00      	cmp	r4, #0
   1500e:	f040 8083 	bne.w	15118 <USBH_FindInterface+0x190>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
   15012:	20ff      	movs	r0, #255	; 0xff
}
   15014:	bc30      	pop	{r4, r5}
   15016:	4770      	bx	lr
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15018:	f890 5348 	ldrb.w	r5, [r0, #840]	; 0x348
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1501c:	4295      	cmp	r5, r2
   1501e:	d001      	beq.n	15024 <USBH_FindInterface+0x9c>
   15020:	2aff      	cmp	r2, #255	; 0xff
   15022:	d1be      	bne.n	14fa2 <USBH_FindInterface+0x1a>
   15024:	f890 5349 	ldrb.w	r5, [r0, #841]	; 0x349
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15028:	429d      	cmp	r5, r3
   1502a:	d001      	beq.n	15030 <USBH_FindInterface+0xa8>
   1502c:	2bff      	cmp	r3, #255	; 0xff
   1502e:	d1b8      	bne.n	14fa2 <USBH_FindInterface+0x1a>
  uint8_t if_ix = 0U;
   15030:	2000      	movs	r0, #0
   15032:	e7ef      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15034:	f890 5372 	ldrb.w	r5, [r0, #882]	; 0x372
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   15038:	4295      	cmp	r5, r2
   1503a:	d001      	beq.n	15040 <USBH_FindInterface+0xb8>
   1503c:	2aff      	cmp	r2, #255	; 0xff
   1503e:	d1b6      	bne.n	14fae <USBH_FindInterface+0x26>
   15040:	f890 5373 	ldrb.w	r5, [r0, #883]	; 0x373
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15044:	429d      	cmp	r5, r3
   15046:	d001      	beq.n	1504c <USBH_FindInterface+0xc4>
   15048:	2bff      	cmp	r3, #255	; 0xff
   1504a:	d1b0      	bne.n	14fae <USBH_FindInterface+0x26>
    if_ix++;
   1504c:	2001      	movs	r0, #1
   1504e:	e7e1      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15050:	f890 539c 	ldrb.w	r5, [r0, #924]	; 0x39c
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   15054:	4295      	cmp	r5, r2
   15056:	d001      	beq.n	1505c <USBH_FindInterface+0xd4>
   15058:	2aff      	cmp	r2, #255	; 0xff
   1505a:	d1ae      	bne.n	14fba <USBH_FindInterface+0x32>
   1505c:	f890 539d 	ldrb.w	r5, [r0, #925]	; 0x39d
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15060:	429d      	cmp	r5, r3
   15062:	d001      	beq.n	15068 <USBH_FindInterface+0xe0>
   15064:	2bff      	cmp	r3, #255	; 0xff
   15066:	d1a8      	bne.n	14fba <USBH_FindInterface+0x32>
    if_ix++;
   15068:	2002      	movs	r0, #2
   1506a:	e7d3      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   1506c:	f890 53c6 	ldrb.w	r5, [r0, #966]	; 0x3c6
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   15070:	4295      	cmp	r5, r2
   15072:	d001      	beq.n	15078 <USBH_FindInterface+0xf0>
   15074:	2aff      	cmp	r2, #255	; 0xff
   15076:	d1a6      	bne.n	14fc6 <USBH_FindInterface+0x3e>
   15078:	f890 53c7 	ldrb.w	r5, [r0, #967]	; 0x3c7
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1507c:	429d      	cmp	r5, r3
   1507e:	d001      	beq.n	15084 <USBH_FindInterface+0xfc>
   15080:	2bff      	cmp	r3, #255	; 0xff
   15082:	d1a0      	bne.n	14fc6 <USBH_FindInterface+0x3e>
    if_ix++;
   15084:	2003      	movs	r0, #3
   15086:	e7c5      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15088:	f890 53f0 	ldrb.w	r5, [r0, #1008]	; 0x3f0
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1508c:	4295      	cmp	r5, r2
   1508e:	d001      	beq.n	15094 <USBH_FindInterface+0x10c>
   15090:	2aff      	cmp	r2, #255	; 0xff
   15092:	d19e      	bne.n	14fd2 <USBH_FindInterface+0x4a>
   15094:	f890 53f1 	ldrb.w	r5, [r0, #1009]	; 0x3f1
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   15098:	429d      	cmp	r5, r3
   1509a:	d001      	beq.n	150a0 <USBH_FindInterface+0x118>
   1509c:	2bff      	cmp	r3, #255	; 0xff
   1509e:	d198      	bne.n	14fd2 <USBH_FindInterface+0x4a>
    if_ix++;
   150a0:	2004      	movs	r0, #4
   150a2:	e7b7      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150a4:	f890 541a 	ldrb.w	r5, [r0, #1050]	; 0x41a
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150a8:	4295      	cmp	r5, r2
   150aa:	d001      	beq.n	150b0 <USBH_FindInterface+0x128>
   150ac:	2aff      	cmp	r2, #255	; 0xff
   150ae:	d196      	bne.n	14fde <USBH_FindInterface+0x56>
   150b0:	f890 541b 	ldrb.w	r5, [r0, #1051]	; 0x41b
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   150b4:	429d      	cmp	r5, r3
   150b6:	d001      	beq.n	150bc <USBH_FindInterface+0x134>
   150b8:	2bff      	cmp	r3, #255	; 0xff
   150ba:	d190      	bne.n	14fde <USBH_FindInterface+0x56>
    if_ix++;
   150bc:	2005      	movs	r0, #5
   150be:	e7a9      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150c0:	f890 5444 	ldrb.w	r5, [r0, #1092]	; 0x444
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150c4:	4295      	cmp	r5, r2
   150c6:	d001      	beq.n	150cc <USBH_FindInterface+0x144>
   150c8:	2aff      	cmp	r2, #255	; 0xff
   150ca:	d18e      	bne.n	14fea <USBH_FindInterface+0x62>
   150cc:	f890 5445 	ldrb.w	r5, [r0, #1093]	; 0x445
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   150d0:	429d      	cmp	r5, r3
   150d2:	d001      	beq.n	150d8 <USBH_FindInterface+0x150>
   150d4:	2bff      	cmp	r3, #255	; 0xff
   150d6:	d188      	bne.n	14fea <USBH_FindInterface+0x62>
    if_ix++;
   150d8:	2006      	movs	r0, #6
   150da:	e79b      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150dc:	f890 546e 	ldrb.w	r5, [r0, #1134]	; 0x46e
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150e0:	4295      	cmp	r5, r2
   150e2:	d001      	beq.n	150e8 <USBH_FindInterface+0x160>
   150e4:	2aff      	cmp	r2, #255	; 0xff
   150e6:	d186      	bne.n	14ff6 <USBH_FindInterface+0x6e>
   150e8:	f890 546f 	ldrb.w	r5, [r0, #1135]	; 0x46f
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   150ec:	429d      	cmp	r5, r3
   150ee:	d001      	beq.n	150f4 <USBH_FindInterface+0x16c>
   150f0:	2bff      	cmp	r3, #255	; 0xff
   150f2:	d180      	bne.n	14ff6 <USBH_FindInterface+0x6e>
    if_ix++;
   150f4:	2007      	movs	r0, #7
   150f6:	e78d      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   150f8:	f890 5498 	ldrb.w	r5, [r0, #1176]	; 0x498
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   150fc:	4295      	cmp	r5, r2
   150fe:	d002      	beq.n	15106 <USBH_FindInterface+0x17e>
   15100:	2aff      	cmp	r2, #255	; 0xff
   15102:	f47f af7e 	bne.w	15002 <USBH_FindInterface+0x7a>
   15106:	f890 5499 	ldrb.w	r5, [r0, #1177]	; 0x499
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1510a:	429d      	cmp	r5, r3
   1510c:	d002      	beq.n	15114 <USBH_FindInterface+0x18c>
   1510e:	2bff      	cmp	r3, #255	; 0xff
   15110:	f47f af77 	bne.w	15002 <USBH_FindInterface+0x7a>
    if_ix++;
   15114:	2008      	movs	r0, #8
   15116:	e77d      	b.n	15014 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
   15118:	f890 14c2 	ldrb.w	r1, [r0, #1218]	; 0x4c2
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
   1511c:	4291      	cmp	r1, r2
   1511e:	d002      	beq.n	15126 <USBH_FindInterface+0x19e>
   15120:	2aff      	cmp	r2, #255	; 0xff
   15122:	f47f af76 	bne.w	15012 <USBH_FindInterface+0x8a>
   15126:	f890 24c3 	ldrb.w	r2, [r0, #1219]	; 0x4c3
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
   1512a:	429a      	cmp	r2, r3
   1512c:	d002      	beq.n	15134 <USBH_FindInterface+0x1ac>
   1512e:	2bff      	cmp	r3, #255	; 0xff
   15130:	f47f af6f 	bne.w	15012 <USBH_FindInterface+0x8a>
    if_ix++;
   15134:	2009      	movs	r0, #9
   15136:	e76d      	b.n	15014 <USBH_FindInterface+0x8c>

00015138 <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
{
   15138:	b510      	push	{r4, lr}
   1513a:	4604      	mov	r4, r0
  /* Start the low level driver  */
  USBH_LL_Start(phost);
   1513c:	f00e fd2e 	bl	23b9c <USBH_LL_Start>

  /* Activate VBUS on the port */
  USBH_LL_DriverVBUS(phost, OTRUE);
   15140:	2101      	movs	r1, #1
   15142:	4620      	mov	r0, r4
   15144:	f00e fdae 	bl	23ca4 <USBH_LL_DriverVBUS>

  return USBH_OK;
}
   15148:	2000      	movs	r0, #0
   1514a:	bd10      	pop	{r4, pc}

0001514c <USBH_Stop>:
  *         Stop the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Stop(USBH_HandleTypeDef *phost)
{
   1514c:	b510      	push	{r4, lr}
   1514e:	4604      	mov	r4, r0
  /* DeActivate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 0);
   15150:	2100      	movs	r1, #0
   15152:	f00e fda7 	bl	23ca4 <USBH_LL_DriverVBUS>

  /* Stop and cleanup the low level driver  */
  USBH_LL_Stop(phost);
   15156:	4620      	mov	r0, r4
   15158:	f00e fd2e 	bl	23bb8 <USBH_LL_Stop>

  /* Free Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
   1515c:	7921      	ldrb	r1, [r4, #4]
   1515e:	4620      	mov	r0, r4
   15160:	f001 fa24 	bl	165ac <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
   15164:	7961      	ldrb	r1, [r4, #5]
   15166:	4620      	mov	r0, r4
   15168:	f001 fa20 	bl	165ac <USBH_FreePipe>

  return USBH_OK;
}
   1516c:	2000      	movs	r0, #0
   1516e:	bd10      	pop	{r4, pc}

00015170 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
{
   15170:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
   15172:	2302      	movs	r3, #2
{
   15174:	b087      	sub	sp, #28
   15176:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
   15178:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
   1517c:	f890 3321 	ldrb.w	r3, [r0, #801]	; 0x321
   15180:	2b01      	cmp	r3, #1
   15182:	d101      	bne.n	15188 <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
   15184:	2303      	movs	r3, #3
   15186:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
   15188:	7823      	ldrb	r3, [r4, #0]
   1518a:	2b0b      	cmp	r3, #11
   1518c:	d84f      	bhi.n	1522e <USBH_Process+0xbe>
   1518e:	e8df f013 	tbh	[pc, r3, lsl #1]
   15192:	0059      	.short	0x0059
   15194:	0082006b 	.word	0x0082006b
   15198:	004e00b8 	.word	0x004e00b8
   1519c:	00f700ee 	.word	0x00f700ee
   151a0:	011f010c 	.word	0x011f010c
   151a4:	000c0117 	.word	0x000c0117
   151a8:	0051      	.short	0x0051
#endif
      break;

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
   151aa:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
   151ae:	2b00      	cmp	r3, #0
   151b0:	d03d      	beq.n	1522e <USBH_Process+0xbe>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
   151b2:	2300      	movs	r3, #0

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
        {
          for (int j = 0; j < 10; j++)
          {
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
   151b4:	f8d4 14e8 	ldr.w	r1, [r4, #1256]	; 0x4e8
   151b8:	f894 2347 	ldrb.w	r2, [r4, #839]	; 0x347
        phost->pActiveClass = NULL;
   151bc:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
   151c0:	790b      	ldrb	r3, [r1, #4]
   151c2:	429a      	cmp	r2, r3
   151c4:	d024      	beq.n	15210 <USBH_Process+0xa0>
   151c6:	f894 2371 	ldrb.w	r2, [r4, #881]	; 0x371
   151ca:	429a      	cmp	r2, r3
   151cc:	d020      	beq.n	15210 <USBH_Process+0xa0>
   151ce:	f894 239b 	ldrb.w	r2, [r4, #923]	; 0x39b
   151d2:	429a      	cmp	r2, r3
   151d4:	d01c      	beq.n	15210 <USBH_Process+0xa0>
   151d6:	f894 23c5 	ldrb.w	r2, [r4, #965]	; 0x3c5
   151da:	429a      	cmp	r2, r3
   151dc:	d018      	beq.n	15210 <USBH_Process+0xa0>
   151de:	f894 23ef 	ldrb.w	r2, [r4, #1007]	; 0x3ef
   151e2:	429a      	cmp	r2, r3
   151e4:	d014      	beq.n	15210 <USBH_Process+0xa0>
   151e6:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
   151ea:	429a      	cmp	r2, r3
   151ec:	d010      	beq.n	15210 <USBH_Process+0xa0>
   151ee:	f894 2443 	ldrb.w	r2, [r4, #1091]	; 0x443
   151f2:	429a      	cmp	r2, r3
   151f4:	d00c      	beq.n	15210 <USBH_Process+0xa0>
   151f6:	f894 246d 	ldrb.w	r2, [r4, #1133]	; 0x46d
   151fa:	429a      	cmp	r2, r3
   151fc:	d008      	beq.n	15210 <USBH_Process+0xa0>
   151fe:	f894 2497 	ldrb.w	r2, [r4, #1175]	; 0x497
   15202:	429a      	cmp	r2, r3
   15204:	d004      	beq.n	15210 <USBH_Process+0xa0>
   15206:	f894 24c1 	ldrb.w	r2, [r4, #1217]	; 0x4c1
   1520a:	429a      	cmp	r2, r3
   1520c:	f040 80c8 	bne.w	153a0 <USBH_Process+0x230>
			  {
				phost->pActiveClass = phost->pClass[idx];
   15210:	f8c4 14ec 	str.w	r1, [r4, #1260]	; 0x4ec
          }
        }

        if (phost->pActiveClass != NULL)
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
   15214:	4620      	mov	r0, r4
   15216:	688b      	ldr	r3, [r1, #8]
   15218:	4798      	blx	r3
   1521a:	2800      	cmp	r0, #0
   1521c:	f040 80c0 	bne.w	153a0 <USBH_Process+0x230>
          {
            phost->gState = HOST_CLASS_REQUEST;
   15220:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
   15222:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15226:	4620      	mov	r0, r4
   15228:	2103      	movs	r1, #3
            phost->gState = HOST_CLASS_REQUEST;
   1522a:	7022      	strb	r2, [r4, #0]
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
   1522c:	4798      	blx	r3
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
   1522e:	2000      	movs	r0, #0
   15230:	b007      	add	sp, #28
   15232:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pActiveClass != NULL)
   15234:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
   15238:	2b00      	cmp	r3, #0
   1523a:	d0f8      	beq.n	1522e <USBH_Process+0xbe>
        phost->pActiveClass->BgndProcess(phost);
   1523c:	695b      	ldr	r3, [r3, #20]
   1523e:	4620      	mov	r0, r4
   15240:	4798      	blx	r3
   15242:	e7f4      	b.n	1522e <USBH_Process+0xbe>
      if (phost->device.is_connected)
   15244:	f894 3320 	ldrb.w	r3, [r4, #800]	; 0x320
   15248:	2b00      	cmp	r3, #0
   1524a:	d0f0      	beq.n	1522e <USBH_Process+0xbe>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
   1524c:	2301      	movs	r3, #1
        USBH_Delay(200U);
   1524e:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
   15250:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
   15252:	f00e fd4b 	bl	23cec <USBH_Delay>
        USBH_LL_ResetPort(phost);
   15256:	4620      	mov	r0, r4
   15258:	f00e fcca 	bl	23bf0 <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
   1525c:	2300      	movs	r3, #0
   1525e:	f884 331c 	strb.w	r3, [r4, #796]	; 0x31c
        phost->Timeout = 0U;
   15262:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
   15266:	e7e2      	b.n	1522e <USBH_Process+0xbe>
      if (phost->device.PortEnabled == 1U)
   15268:	f894 3323 	ldrb.w	r3, [r4, #803]	; 0x323
   1526c:	2b01      	cmp	r3, #1
   1526e:	f000 8145 	beq.w	154fc <USBH_Process+0x38c>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
   15272:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
   15276:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   1527a:	f240 80b7 	bls.w	153ec <USBH_Process+0x27c>
          phost->device.RstCnt++;
   1527e:	f894 331f 	ldrb.w	r3, [r4, #799]	; 0x31f
   15282:	3301      	adds	r3, #1
   15284:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
   15286:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
   15288:	f884 331f 	strb.w	r3, [r4, #799]	; 0x31f
          if (phost->device.RstCnt > 3U)
   1528c:	f200 8088 	bhi.w	153a0 <USBH_Process+0x230>
            phost->gState = HOST_IDLE;
   15290:	2300      	movs	r3, #0
   15292:	7023      	strb	r3, [r4, #0]
   15294:	e7cb      	b.n	1522e <USBH_Process+0xbe>
      if (phost->pUser != NULL)
   15296:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   1529a:	b113      	cbz	r3, 152a2 <USBH_Process+0x132>
        phost->pUser(phost, HOST_USER_CONNECTION);
   1529c:	2104      	movs	r1, #4
   1529e:	4620      	mov	r0, r4
   152a0:	4798      	blx	r3
      USBH_Delay(100U);
   152a2:	2064      	movs	r0, #100	; 0x64
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   152a4:	2500      	movs	r5, #0
      USBH_Delay(100U);
   152a6:	f00e fd21 	bl	23cec <USBH_Delay>
      phost->device.speed = USBH_LL_GetSpeed(phost);
   152aa:	4620      	mov	r0, r4
   152ac:	f00e fc92 	bl	23bd4 <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
   152b0:	2305      	movs	r3, #5
      phost->device.speed = USBH_LL_GetSpeed(phost);
   152b2:	f884 031d 	strb.w	r0, [r4, #797]	; 0x31d
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   152b6:	4629      	mov	r1, r5
      phost->gState = HOST_ENUMERATION;
   152b8:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   152ba:	4620      	mov	r0, r4
   152bc:	f001 f92c 	bl	16518 <USBH_AllocPipe>
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   152c0:	2180      	movs	r1, #128	; 0x80
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
   152c2:	7160      	strb	r0, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   152c4:	4620      	mov	r0, r4
   152c6:	f001 f927 	bl	16518 <USBH_AllocPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   152ca:	79a7      	ldrb	r7, [r4, #6]
   152cc:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
   152d0:	4601      	mov	r1, r0
   152d2:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   152d6:	2280      	movs	r2, #128	; 0x80
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
   152d8:	7120      	strb	r0, [r4, #4]
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
   152da:	4620      	mov	r0, r4
   152dc:	9702      	str	r7, [sp, #8]
   152de:	e9cd 6500 	strd	r6, r5, [sp]
   152e2:	f001 f903 	bl	164ec <USBH_OpenPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
   152e6:	79a7      	ldrb	r7, [r4, #6]
   152e8:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
   152ec:	462a      	mov	r2, r5
   152ee:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   152f2:	4620      	mov	r0, r4
   152f4:	7961      	ldrb	r1, [r4, #5]
   152f6:	9501      	str	r5, [sp, #4]
   152f8:	9702      	str	r7, [sp, #8]
   152fa:	9600      	str	r6, [sp, #0]
   152fc:	f001 f8f6 	bl	164ec <USBH_OpenPipe>
      break;
   15300:	e795      	b.n	1522e <USBH_Process+0xbe>
      phost->device.is_disconnected = 0U;
   15302:	2500      	movs	r5, #0
   15304:	223c      	movs	r2, #60	; 0x3c
   15306:	f204 40f4 	addw	r0, r4, #1268	; 0x4f4
   1530a:	4629      	mov	r1, r5
   1530c:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
   15310:	f017 fb97 	bl	2ca42 <memset>
   15314:	4629      	mov	r1, r5
   15316:	f44f 7200 	mov.w	r2, #512	; 0x200
   1531a:	f504 708e 	add.w	r0, r4, #284	; 0x11c
   1531e:	f017 fb90 	bl	2ca42 <memset>
  phost->RequestState = CMD_SEND;
   15322:	2301      	movs	r3, #1
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   15324:	2040      	movs	r0, #64	; 0x40
  phost->device.address = USBH_ADDRESS_DEFAULT;
   15326:	f44f 7180 	mov.w	r1, #256	; 0x100
      if (phost->pActiveClass != NULL)
   1532a:	f8d4 24ec 	ldr.w	r2, [r4, #1260]	; 0x4ec
  phost->gState = HOST_IDLE;
   1532e:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
   15330:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
   15332:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
   15336:	7665      	strb	r5, [r4, #25]
  phost->RequestState = CMD_SEND;
   15338:	70a3      	strb	r3, [r4, #2]
  phost->Control.state = CTRL_SETUP;
   1533a:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
   1533c:	71a0      	strb	r0, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
   1533e:	f8c4 131c 	str.w	r1, [r4, #796]	; 0x31c
      if (phost->pActiveClass != NULL)
   15342:	b122      	cbz	r2, 1534e <USBH_Process+0x1de>
        phost->pActiveClass->DeInit(phost);
   15344:	68d3      	ldr	r3, [r2, #12]
   15346:	4620      	mov	r0, r4
   15348:	4798      	blx	r3
        phost->pActiveClass = NULL;
   1534a:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
      if (phost->pUser != NULL)
   1534e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15352:	b113      	cbz	r3, 1535a <USBH_Process+0x1ea>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
   15354:	2105      	movs	r1, #5
   15356:	4620      	mov	r0, r4
   15358:	4798      	blx	r3
      if (phost->device.is_ReEnumerated == 1U)
   1535a:	f894 5322 	ldrb.w	r5, [r4, #802]	; 0x322
   1535e:	b2ed      	uxtb	r5, r5
   15360:	2d01      	cmp	r5, #1
   15362:	f000 80c0 	beq.w	154e6 <USBH_Process+0x376>
        USBH_LL_Start(phost);
   15366:	4620      	mov	r0, r4
   15368:	f00e fc18 	bl	23b9c <USBH_LL_Start>
  return USBH_OK;
   1536c:	e75f      	b.n	1522e <USBH_Process+0xbe>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
   1536e:	7863      	ldrb	r3, [r4, #1]
   15370:	2b07      	cmp	r3, #7
   15372:	d84d      	bhi.n	15410 <USBH_Process+0x2a0>
   15374:	e8df f003 	tbb	[pc, r3]
   15378:	a58b9b41 	.word	0xa58b9b41
   1537c:	5f656d75 	.word	0x5f656d75
      if (phost->pActiveClass != NULL)
   15380:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
   15384:	b163      	cbz	r3, 153a0 <USBH_Process+0x230>
        status = phost->pActiveClass->Requests(phost);
   15386:	691b      	ldr	r3, [r3, #16]
   15388:	4620      	mov	r0, r4
   1538a:	4798      	blx	r3
   1538c:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
   15390:	f89d 3017 	ldrb.w	r3, [sp, #23]
   15394:	b33b      	cbz	r3, 153e6 <USBH_Process+0x276>
        else if (status == USBH_FAIL)
   15396:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1539a:	2b02      	cmp	r3, #2
   1539c:	f47f af47 	bne.w	1522e <USBH_Process+0xbe>
        phost->gState = HOST_ABORT_STATE;
   153a0:	230d      	movs	r3, #13
}
   153a2:	2000      	movs	r0, #0
        phost->gState = HOST_ABORT_STATE;
   153a4:	7023      	strb	r3, [r4, #0]
}
   153a6:	b007      	add	sp, #28
   153a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pUser != NULL)
   153aa:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   153ae:	2b00      	cmp	r3, #0
   153b0:	f43f af3d 	beq.w	1522e <USBH_Process+0xbe>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
   153b4:	2101      	movs	r1, #1
   153b6:	4620      	mov	r0, r4
   153b8:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
   153ba:	2308      	movs	r3, #8
   153bc:	7023      	strb	r3, [r4, #0]
   153be:	e736      	b.n	1522e <USBH_Process+0xbe>
      if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
   153c0:	f894 333f 	ldrb.w	r3, [r4, #831]	; 0x33f
   153c4:	069b      	lsls	r3, r3, #26
   153c6:	f100 8086 	bmi.w	154d6 <USBH_Process+0x366>
        phost->gState = HOST_CHECK_CLASS;
   153ca:	230a      	movs	r3, #10
   153cc:	7023      	strb	r3, [r4, #0]
   153ce:	e72e      	b.n	1522e <USBH_Process+0xbe>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
   153d0:	f894 133d 	ldrb.w	r1, [r4, #829]	; 0x33d
   153d4:	4620      	mov	r0, r4
   153d6:	f000 fd8b 	bl	15ef0 <USBH_SetCfg>
   153da:	2800      	cmp	r0, #0
   153dc:	f47f af27 	bne.w	1522e <USBH_Process+0xbe>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
   153e0:	2309      	movs	r3, #9
   153e2:	7023      	strb	r3, [r4, #0]
   153e4:	e723      	b.n	1522e <USBH_Process+0xbe>
          phost->gState = HOST_CLASS;
   153e6:	230b      	movs	r3, #11
   153e8:	7023      	strb	r3, [r4, #0]
   153ea:	e720      	b.n	1522e <USBH_Process+0xbe>
          phost->Timeout += 10U;
   153ec:	330a      	adds	r3, #10
          USBH_Delay(10U);
   153ee:	200a      	movs	r0, #10
          phost->Timeout += 10U;
   153f0:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
          USBH_Delay(10U);
   153f4:	f00e fc7a 	bl	23cec <USBH_Delay>
   153f8:	e719      	b.n	1522e <USBH_Process+0xbe>
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
   153fa:	2108      	movs	r1, #8
   153fc:	4620      	mov	r0, r4
   153fe:	f000 f91f 	bl	15640 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
   15402:	4605      	mov	r5, r0
   15404:	2800      	cmp	r0, #0
   15406:	f000 80c1 	beq.w	1558c <USBH_Process+0x41c>
        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
      }
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   1540a:	2803      	cmp	r0, #3
   1540c:	f000 80aa 	beq.w	15564 <USBH_Process+0x3f4>
  USBH_StatusTypeDef Status = USBH_BUSY;
   15410:	2301      	movs	r3, #1
      status = USBH_HandleEnum(phost);
   15412:	f88d 3017 	strb.w	r3, [sp, #23]
      if (status == USBH_OK)
   15416:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1541a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1541e:	2b00      	cmp	r3, #0
   15420:	f47f af05 	bne.w	1522e <USBH_Process+0xbe>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
   15424:	f894 3337 	ldrb.w	r3, [r4, #823]	; 0x337
        phost->device.current_interface = 0U;
   15428:	f884 2324 	strb.w	r2, [r4, #804]	; 0x324
        if (phost->device.DevDesc.bNumConfigurations == 1U)
   1542c:	2b01      	cmp	r3, #1
   1542e:	d0c4      	beq.n	153ba <USBH_Process+0x24a>
          phost->gState = HOST_INPUT;
   15430:	2307      	movs	r3, #7
   15432:	7023      	strb	r3, [r4, #0]
   15434:	e6fb      	b.n	1522e <USBH_Process+0xbe>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
   15436:	f894 1336 	ldrb.w	r1, [r4, #822]	; 0x336
   1543a:	2900      	cmp	r1, #0
   1543c:	d174      	bne.n	15528 <USBH_Process+0x3b8>
        }
      }
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
   1543e:	460b      	mov	r3, r1
   15440:	e7e7      	b.n	15412 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iProduct != 0U)
   15442:	f894 1335 	ldrb.w	r1, [r4, #821]	; 0x335
   15446:	2900      	cmp	r1, #0
   15448:	d17f      	bne.n	1554a <USBH_Process+0x3da>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   1544a:	2207      	movs	r2, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
   1544c:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   1544e:	7062      	strb	r2, [r4, #1]
   15450:	e7df      	b.n	15412 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iManufacturer != 0U)
   15452:	f894 1334 	ldrb.w	r1, [r4, #820]	; 0x334
   15456:	2900      	cmp	r1, #0
   15458:	d15a      	bne.n	15510 <USBH_Process+0x3a0>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   1545a:	2206      	movs	r2, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
   1545c:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   1545e:	7062      	strb	r2, [r4, #1]
   15460:	e7d7      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
   15462:	f8b4 133a 	ldrh.w	r1, [r4, #826]	; 0x33a
   15466:	4620      	mov	r0, r4
   15468:	f000 f9f8 	bl	1585c <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
   1546c:	2800      	cmp	r0, #0
   1546e:	d04b      	beq.n	15508 <USBH_Process+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   15470:	2803      	cmp	r0, #3
   15472:	d1cd      	bne.n	15410 <USBH_Process+0x2a0>
        phost->device.EnumCnt++;
   15474:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
   15478:	3301      	adds	r3, #1
   1547a:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
   1547c:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
   1547e:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
   15482:	f240 80a6 	bls.w	155d2 <USBH_Process+0x462>
          phost->gState = HOST_ABORT_STATE;
   15486:	220d      	movs	r2, #13
  USBH_StatusTypeDef Status = USBH_BUSY;
   15488:	2301      	movs	r3, #1
          phost->gState = HOST_ABORT_STATE;
   1548a:	7022      	strb	r2, [r4, #0]
   1548c:	e7c1      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
   1548e:	2101      	movs	r1, #1
   15490:	4620      	mov	r0, r4
   15492:	f000 fc47 	bl	15d24 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
   15496:	4606      	mov	r6, r0
   15498:	2800      	cmp	r0, #0
   1549a:	f000 80a7 	beq.w	155ec <USBH_Process+0x47c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
   1549e:	2803      	cmp	r0, #3
   154a0:	d1b6      	bne.n	15410 <USBH_Process+0x2a0>
        phost->gState = HOST_ABORT_STATE;
   154a2:	210d      	movs	r1, #13
        phost->EnumState = ENUM_IDLE;
   154a4:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   154a6:	2301      	movs	r3, #1
        phost->gState = HOST_ABORT_STATE;
   154a8:	7021      	strb	r1, [r4, #0]
        phost->EnumState = ENUM_IDLE;
   154aa:	7062      	strb	r2, [r4, #1]
   154ac:	e7b1      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
   154ae:	2112      	movs	r1, #18
   154b0:	4620      	mov	r0, r4
   154b2:	f000 f8c5 	bl	15640 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
   154b6:	2800      	cmp	r0, #0
   154b8:	d1da      	bne.n	15470 <USBH_Process+0x300>
        phost->EnumState = ENUM_SET_ADDR;
   154ba:	2202      	movs	r2, #2
  USBH_StatusTypeDef Status = USBH_BUSY;
   154bc:	2301      	movs	r3, #1
        phost->EnumState = ENUM_SET_ADDR;
   154be:	7062      	strb	r2, [r4, #1]
   154c0:	e7a7      	b.n	15412 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
   154c2:	2109      	movs	r1, #9
   154c4:	4620      	mov	r0, r4
   154c6:	f000 f9c9 	bl	1585c <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
   154ca:	2800      	cmp	r0, #0
   154cc:	d1d0      	bne.n	15470 <USBH_Process+0x300>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   154ce:	2204      	movs	r2, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
   154d0:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   154d2:	7062      	strb	r2, [r4, #1]
   154d4:	e79d      	b.n	15412 <USBH_Process+0x2a2>
        if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
   154d6:	2101      	movs	r1, #1
   154d8:	4620      	mov	r0, r4
   154da:	f000 fdef 	bl	160bc <USBH_SetFeature>
   154de:	2800      	cmp	r0, #0
   154e0:	f47f aea5 	bne.w	1522e <USBH_Process+0xbe>
   154e4:	e771      	b.n	153ca <USBH_Process+0x25a>
        phost->device.is_ReEnumerated = 0U;
   154e6:	2300      	movs	r3, #0
  USBH_LL_Start(phost);
   154e8:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
   154ea:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  USBH_LL_Start(phost);
   154ee:	f00e fb55 	bl	23b9c <USBH_LL_Start>
  USBH_LL_DriverVBUS(phost, OTRUE);
   154f2:	4629      	mov	r1, r5
   154f4:	4620      	mov	r0, r4
   154f6:	f00e fbd5 	bl	23ca4 <USBH_LL_DriverVBUS>
   154fa:	e698      	b.n	1522e <USBH_Process+0xbe>
        phost->device.RstCnt = 0U;
   154fc:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
   154fe:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
   15500:	f884 231f 	strb.w	r2, [r4, #799]	; 0x31f
        phost->gState = HOST_DEV_ATTACHED;
   15504:	7023      	strb	r3, [r4, #0]
   15506:	e692      	b.n	1522e <USBH_Process+0xbe>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   15508:	2205      	movs	r2, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
   1550a:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   1550c:	7062      	strb	r2, [r4, #1]
   1550e:	e780      	b.n	15412 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
   15510:	23ff      	movs	r3, #255	; 0xff
   15512:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   15516:	4620      	mov	r0, r4
   15518:	f000 faf6 	bl	15b08 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
   1551c:	2800      	cmp	r0, #0
   1551e:	d09c      	beq.n	1545a <USBH_Process+0x2ea>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   15520:	2803      	cmp	r0, #3
   15522:	f47f af75 	bne.w	15410 <USBH_Process+0x2a0>
   15526:	e798      	b.n	1545a <USBH_Process+0x2ea>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
   15528:	23ff      	movs	r3, #255	; 0xff
   1552a:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   1552e:	4620      	mov	r0, r4
   15530:	f000 faea 	bl	15b08 <USBH_Get_StringDesc>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   15534:	f1a0 0303 	sub.w	r3, r0, #3
   15538:	fab3 f383 	clz	r3, r3
   1553c:	095b      	lsrs	r3, r3, #5
   1553e:	2800      	cmp	r0, #0
   15540:	bf08      	it	eq
   15542:	2301      	moveq	r3, #1
  USBH_StatusTypeDef Status = USBH_BUSY;
   15544:	f083 0301 	eor.w	r3, r3, #1
   15548:	e763      	b.n	15412 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
   1554a:	23ff      	movs	r3, #255	; 0xff
   1554c:	f504 728e 	add.w	r2, r4, #284	; 0x11c
   15550:	4620      	mov	r0, r4
   15552:	f000 fad9 	bl	15b08 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
   15556:	2800      	cmp	r0, #0
   15558:	f43f af77 	beq.w	1544a <USBH_Process+0x2da>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
   1555c:	2803      	cmp	r0, #3
   1555e:	f47f af57 	bne.w	15410 <USBH_Process+0x2a0>
   15562:	e772      	b.n	1544a <USBH_Process+0x2da>
        phost->device.EnumCnt++;
   15564:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
   15568:	3301      	adds	r3, #1
   1556a:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
   1556c:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
   1556e:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
   15572:	d888      	bhi.n	15486 <USBH_Process+0x316>
          USBH_FreePipe(phost, phost->Control.pipe_out);
   15574:	7961      	ldrb	r1, [r4, #5]
   15576:	4620      	mov	r0, r4
   15578:	f001 f818 	bl	165ac <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
   1557c:	7921      	ldrb	r1, [r4, #4]
   1557e:	4620      	mov	r0, r4
   15580:	f001 f814 	bl	165ac <USBH_FreePipe>
          phost->gState = HOST_IDLE;
   15584:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   15586:	2301      	movs	r3, #1
          phost->gState = HOST_IDLE;
   15588:	7022      	strb	r2, [r4, #0]
   1558a:	e742      	b.n	15412 <USBH_Process+0x2a2>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   1558c:	f894 732d 	ldrb.w	r7, [r4, #813]	; 0x32d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   15590:	2601      	movs	r6, #1
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   15592:	f894 c31d 	ldrb.w	ip, [r4, #797]	; 0x31d
   15596:	2280      	movs	r2, #128	; 0x80
   15598:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   1559c:	4620      	mov	r0, r4
   1559e:	7921      	ldrb	r1, [r4, #4]
   155a0:	9501      	str	r5, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   155a2:	71a7      	strb	r7, [r4, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   155a4:	9702      	str	r7, [sp, #8]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   155a6:	7066      	strb	r6, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
   155a8:	f8cd c000 	str.w	ip, [sp]
   155ac:	f000 ff9e 	bl	164ec <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
   155b0:	f894 c006 	ldrb.w	ip, [r4, #6]
   155b4:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   155b8:	462a      	mov	r2, r5
   155ba:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   155be:	4620      	mov	r0, r4
   155c0:	7961      	ldrb	r1, [r4, #5]
   155c2:	9501      	str	r5, [sp, #4]
   155c4:	f8cd c008 	str.w	ip, [sp, #8]
   155c8:	9700      	str	r7, [sp, #0]
   155ca:	f000 ff8f 	bl	164ec <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
   155ce:	4633      	mov	r3, r6
   155d0:	e71f      	b.n	15412 <USBH_Process+0x2a2>
          USBH_FreePipe(phost, phost->Control.pipe_out);
   155d2:	7961      	ldrb	r1, [r4, #5]
   155d4:	4620      	mov	r0, r4
   155d6:	f000 ffe9 	bl	165ac <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
   155da:	7921      	ldrb	r1, [r4, #4]
   155dc:	4620      	mov	r0, r4
   155de:	f000 ffe5 	bl	165ac <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
   155e2:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
   155e4:	2301      	movs	r3, #1
          phost->EnumState = ENUM_IDLE;
   155e6:	7062      	strb	r2, [r4, #1]
          phost->gState = HOST_IDLE;
   155e8:	7022      	strb	r2, [r4, #0]
   155ea:	e712      	b.n	15412 <USBH_Process+0x2a2>
        USBH_Delay(2U);
   155ec:	2002      	movs	r0, #2
        phost->device.address = USBH_DEVICE_ADDRESS;
   155ee:	2501      	movs	r5, #1
        USBH_Delay(2U);
   155f0:	f00e fb7c 	bl	23cec <USBH_Delay>
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   155f4:	79a7      	ldrb	r7, [r4, #6]
        phost->EnumState = ENUM_GET_CFG_DESC;
   155f6:	2003      	movs	r0, #3
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   155f8:	7921      	ldrb	r1, [r4, #4]
   155fa:	9601      	str	r6, [sp, #4]
   155fc:	462b      	mov	r3, r5
        phost->EnumState = ENUM_GET_CFG_DESC;
   155fe:	7060      	strb	r0, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   15600:	2280      	movs	r2, #128	; 0x80
        phost->device.address = USBH_DEVICE_ADDRESS;
   15602:	f884 531c 	strb.w	r5, [r4, #796]	; 0x31c
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
   15606:	4620      	mov	r0, r4
   15608:	9702      	str	r7, [sp, #8]
   1560a:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   1560e:	9700      	str	r7, [sp, #0]
   15610:	f000 ff6c 	bl	164ec <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
   15614:	f894 c006 	ldrb.w	ip, [r4, #6]
   15618:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
   1561c:	4632      	mov	r2, r6
   1561e:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
   15622:	4620      	mov	r0, r4
   15624:	7961      	ldrb	r1, [r4, #5]
   15626:	9601      	str	r6, [sp, #4]
   15628:	f8cd c008 	str.w	ip, [sp, #8]
   1562c:	9700      	str	r7, [sp, #0]
   1562e:	f000 ff5d 	bl	164ec <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
   15632:	462b      	mov	r3, r5
   15634:	e6ed      	b.n	15412 <USBH_Process+0x2a2>
   15636:	bf00      	nop

00015638 <USBH_LL_SetTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
  phost->Timer = time;
   15638:	f8c0 1534 	str.w	r1, [r0, #1332]	; 0x534
}
   1563c:	4770      	bx	lr
   1563e:	bf00      	nop

00015640 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
{
   15640:	b570      	push	{r4, r5, r6, lr}
   15642:	4604      	mov	r4, r0
                                      uint8_t  req_type,
                                      uint16_t value_idx,
                                      uint8_t *buff,
                                      uint16_t length)
{
  if (phost->RequestState == CMD_SEND)
   15644:	7880      	ldrb	r0, [r0, #2]
{
   15646:	b082      	sub	sp, #8
  if (phost->RequestState == CMD_SEND)
   15648:	2801      	cmp	r0, #1
   1564a:	d011      	beq.n	15670 <USBH_Get_DevDesc+0x30>
                               uint16_t length)
{
  USBH_StatusTypeDef status;
  status = USBH_BUSY;

  switch (phost->RequestState)
   1564c:	2802      	cmp	r0, #2
   1564e:	d002      	beq.n	15656 <USBH_Get_DevDesc+0x16>
  status = USBH_BUSY;
   15650:	2001      	movs	r0, #1
}
   15652:	b002      	add	sp, #8
   15654:	bd70      	pop	{r4, r5, r6, pc}
{
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
   15656:	7e23      	ldrb	r3, [r4, #24]
   15658:	460d      	mov	r5, r1
   1565a:	3b01      	subs	r3, #1
   1565c:	2b0a      	cmp	r3, #10
   1565e:	d8f7      	bhi.n	15650 <USBH_Get_DevDesc+0x10>
   15660:	e8df f003 	tbb	[pc, r3]
   15664:	5548392f 	.word	0x5548392f
   15668:	8c7f6f60 	.word	0x8c7f6f60
   1566c:	ac9d      	.short	0xac9d
   1566e:	14          	.byte	0x14
   1566f:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15670:	4e79      	ldr	r6, [pc, #484]	; (15858 <USBH_Get_DevDesc+0x218>)
    phost->Control.setup.b.wValue.w = value_idx;
   15672:	2500      	movs	r5, #0
                                   USB_DESC_DEVICE, phost->device.Data,
   15674:	f504 728e 	add.w	r2, r4, #284	; 0x11c
      phost->RequestState = CMD_WAIT;
   15678:	2302      	movs	r3, #2
    phost->Control.setup.b.wLength.w = length;
   1567a:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
   1567c:	81a1      	strh	r1, [r4, #12]
      phost->Control.state = CTRL_SETUP;
   1567e:	7620      	strb	r0, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15680:	6126      	str	r6, [r4, #16]
    phost->Control.setup.b.wValue.w = value_idx;
   15682:	82a5      	strh	r5, [r4, #20]
      phost->Control.buff = buff;
   15684:	60a2      	str	r2, [r4, #8]
      phost->RequestState = CMD_WAIT;
   15686:	70a3      	strb	r3, [r4, #2]
}
   15688:	b002      	add	sp, #8
   1568a:	bd70      	pop	{r4, r5, r6, pc}
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   1568c:	7e63      	ldrb	r3, [r4, #25]
   1568e:	3301      	adds	r3, #1
   15690:	b2db      	uxtb	r3, r3
   15692:	2b02      	cmp	r3, #2
   15694:	7663      	strb	r3, [r4, #25]
   15696:	f240 80d7 	bls.w	15848 <USBH_Get_DevDesc+0x208>
        phost->RequestState = CMD_SEND;
      }
      else
      {
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
        phost->Control.errorcount = 0U;
   1569a:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   1569c:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   156a0:	2106      	movs	r1, #6
   156a2:	4620      	mov	r0, r4
   156a4:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");

        /* Free control pipes */
        USBH_FreePipe(phost, phost->Control.pipe_out);
   156a6:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   156a8:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   156aa:	4620      	mov	r0, r4
   156ac:	f000 ff7e 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   156b0:	7921      	ldrb	r1, [r4, #4]
   156b2:	4620      	mov	r0, r4
   156b4:	f000 ff7a 	bl	165ac <USBH_FreePipe>

        phost->gState = HOST_IDLE;
   156b8:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   156ba:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   156bc:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   156be:	70a3      	strb	r3, [r4, #2]
   156c0:	e7c7      	b.n	15652 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   156c2:	7962      	ldrb	r2, [r4, #5]
   156c4:	f104 0110 	add.w	r1, r4, #16
   156c8:	4620      	mov	r0, r4
   156ca:	f000 fec3 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   156ce:	2302      	movs	r3, #2
   156d0:	2001      	movs	r0, #1
   156d2:	7623      	strb	r3, [r4, #24]
   156d4:	e7bd      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   156d6:	7961      	ldrb	r1, [r4, #5]
   156d8:	4620      	mov	r0, r4
   156da:	f00e fadf 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   156de:	2801      	cmp	r0, #1
   156e0:	f000 80a7 	beq.w	15832 <USBH_Get_DevDesc+0x1f2>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   156e4:	2804      	cmp	r0, #4
   156e6:	d001      	beq.n	156ec <USBH_Get_DevDesc+0xac>
   156e8:	2802      	cmp	r0, #2
   156ea:	d1b1      	bne.n	15650 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
   156ec:	230b      	movs	r3, #11
   156ee:	2001      	movs	r0, #1
   156f0:	7623      	strb	r3, [r4, #24]
   156f2:	e7ae      	b.n	15652 <USBH_Get_DevDesc+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   156f4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   156f8:	4620      	mov	r0, r4
   156fa:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   156fc:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   156fe:	68a1      	ldr	r1, [r4, #8]
   15700:	89a2      	ldrh	r2, [r4, #12]
   15702:	f000 fecf 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15706:	2304      	movs	r3, #4
   15708:	2001      	movs	r0, #1
   1570a:	7623      	strb	r3, [r4, #24]
   1570c:	e7a1      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1570e:	7921      	ldrb	r1, [r4, #4]
   15710:	4620      	mov	r0, r4
   15712:	f00e fac3 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15716:	2801      	cmp	r0, #1
   15718:	d058      	beq.n	157cc <USBH_Get_DevDesc+0x18c>
      if (URB_Status == USBH_URB_STALL)
   1571a:	2805      	cmp	r0, #5
   1571c:	d039      	beq.n	15792 <USBH_Get_DevDesc+0x152>
        if (URB_Status == USBH_URB_ERROR)
   1571e:	2804      	cmp	r0, #4
   15720:	d196      	bne.n	15650 <USBH_Get_DevDesc+0x10>
   15722:	e7e3      	b.n	156ec <USBH_Get_DevDesc+0xac>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15724:	2501      	movs	r5, #1
   15726:	7963      	ldrb	r3, [r4, #5]
   15728:	89a2      	ldrh	r2, [r4, #12]
   1572a:	4620      	mov	r0, r4
   1572c:	68a1      	ldr	r1, [r4, #8]
   1572e:	9500      	str	r5, [sp, #0]
   15730:	f000 fea0 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15734:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15738:	2306      	movs	r3, #6
   1573a:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   1573c:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   1573e:	7623      	strb	r3, [r4, #24]
   15740:	e787      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15742:	7961      	ldrb	r1, [r4, #5]
   15744:	4620      	mov	r0, r4
   15746:	f00e faa9 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1574a:	2801      	cmp	r0, #1
   1574c:	d06d      	beq.n	1582a <USBH_Get_DevDesc+0x1ea>
      else if (URB_Status == USBH_URB_STALL)
   1574e:	2805      	cmp	r0, #5
   15750:	d01f      	beq.n	15792 <USBH_Get_DevDesc+0x152>
      else if (URB_Status == USBH_URB_NOTREADY)
   15752:	2802      	cmp	r0, #2
   15754:	d074      	beq.n	15840 <USBH_Get_DevDesc+0x200>
        if (URB_Status == USBH_URB_ERROR)
   15756:	2804      	cmp	r0, #4
   15758:	f47f af7a 	bne.w	15650 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
   1575c:	230b      	movs	r3, #11
   1575e:	7623      	strb	r3, [r4, #24]
   15760:	e7ab      	b.n	156ba <USBH_Get_DevDesc+0x7a>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   15762:	2200      	movs	r2, #0
   15764:	7923      	ldrb	r3, [r4, #4]
   15766:	4620      	mov	r0, r4
   15768:	4611      	mov	r1, r2
   1576a:	f000 fe9b 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1576e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15772:	2308      	movs	r3, #8
   15774:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   15776:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15778:	7623      	strb	r3, [r4, #24]
   1577a:	e76a      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1577c:	7921      	ldrb	r1, [r4, #4]
   1577e:	4620      	mov	r0, r4
   15780:	f00e fa8c 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15784:	2801      	cmp	r0, #1
   15786:	d025      	beq.n	157d4 <USBH_Get_DevDesc+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   15788:	2804      	cmp	r0, #4
   1578a:	d0af      	beq.n	156ec <USBH_Get_DevDesc+0xac>
        if (URB_Status == USBH_URB_STALL)
   1578c:	2805      	cmp	r0, #5
   1578e:	f47f af5f 	bne.w	15650 <USBH_Get_DevDesc+0x10>
        phost->RequestState = CMD_SEND;
   15792:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   15794:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   15796:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   15798:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   1579a:	7623      	strb	r3, [r4, #24]
   1579c:	e759      	b.n	15652 <USBH_Get_DevDesc+0x12>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1579e:	2200      	movs	r2, #0
   157a0:	2501      	movs	r5, #1
   157a2:	7963      	ldrb	r3, [r4, #5]
   157a4:	4620      	mov	r0, r4
   157a6:	4611      	mov	r1, r2
   157a8:	9500      	str	r5, [sp, #0]
   157aa:	f000 fe63 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   157ae:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   157b2:	230a      	movs	r3, #10
   157b4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   157b6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   157b8:	7623      	strb	r3, [r4, #24]
   157ba:	e74a      	b.n	15652 <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   157bc:	7961      	ldrb	r1, [r4, #5]
   157be:	4620      	mov	r0, r4
   157c0:	f00e fa6c 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   157c4:	2801      	cmp	r0, #1
   157c6:	d005      	beq.n	157d4 <USBH_Get_DevDesc+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   157c8:	2802      	cmp	r0, #2
   157ca:	d1a8      	bne.n	1571e <USBH_Get_DevDesc+0xde>
            phost->Control.state = CTRL_STATUS_OUT;
   157cc:	2309      	movs	r3, #9
   157ce:	2001      	movs	r0, #1
   157d0:	7623      	strb	r3, [r4, #24]
   157d2:	e73e      	b.n	15652 <USBH_Get_DevDesc+0x12>
        phost->RequestState = CMD_SEND;
   157d4:	2201      	movs	r2, #1
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
   157d6:	f894 311c 	ldrb.w	r3, [r4, #284]	; 0x11c
        phost->Control.state = CTRL_IDLE;
   157da:	2000      	movs	r0, #0
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
   157dc:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
   157e0:	70a2      	strb	r2, [r4, #2]
  if (length > 8U)
   157e2:	2d08      	cmp	r5, #8
  dev_desc->bcdUSB             = LE16(buf +  2);
   157e4:	f8b4 211e 	ldrh.w	r2, [r4, #286]	; 0x11e
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
   157e8:	f884 3326 	strb.w	r3, [r4, #806]	; 0x326
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
   157ec:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
        phost->Control.state = CTRL_IDLE;
   157f0:	7620      	strb	r0, [r4, #24]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
   157f2:	f884 1327 	strb.w	r1, [r4, #807]	; 0x327
  dev_desc->bcdUSB             = LE16(buf +  2);
   157f6:	f8a4 2328 	strh.w	r2, [r4, #808]	; 0x328
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
   157fa:	f8c4 332a 	str.w	r3, [r4, #810]	; 0x32a
  if (length > 8U)
   157fe:	f67f af28 	bls.w	15652 <USBH_Get_DevDesc+0x12>
    dev_desc->idVendor           = LE16(buf +  8);
   15802:	f8b4 5124 	ldrh.w	r5, [r4, #292]	; 0x124
    dev_desc->idProduct          = LE16(buf + 10);
   15806:	f8b4 1126 	ldrh.w	r1, [r4, #294]	; 0x126
    dev_desc->bcdDevice          = LE16(buf + 12);
   1580a:	f8b4 2128 	ldrh.w	r2, [r4, #296]	; 0x128
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
   1580e:	f8d4 312a 	ldr.w	r3, [r4, #298]	; 0x12a
    dev_desc->idVendor           = LE16(buf +  8);
   15812:	f8a4 532e 	strh.w	r5, [r4, #814]	; 0x32e
    dev_desc->idProduct          = LE16(buf + 10);
   15816:	f8a4 1330 	strh.w	r1, [r4, #816]	; 0x330
    dev_desc->bcdDevice          = LE16(buf + 12);
   1581a:	f8a4 2332 	strh.w	r2, [r4, #818]	; 0x332
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
   1581e:	f8c4 3334 	str.w	r3, [r4, #820]	; 0x334
}
   15822:	b002      	add	sp, #8
   15824:	bd70      	pop	{r4, r5, r6, pc}
          if (direction == USB_D2H)
   15826:	2a00      	cmp	r2, #0
   15828:	dbd0      	blt.n	157cc <USBH_Get_DevDesc+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   1582a:	2307      	movs	r3, #7
   1582c:	2001      	movs	r0, #1
   1582e:	7623      	strb	r3, [r4, #24]
   15830:	e70f      	b.n	15652 <USBH_Get_DevDesc+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   15832:	8ae3      	ldrh	r3, [r4, #22]
   15834:	f994 2010 	ldrsb.w	r2, [r4, #16]
   15838:	2b00      	cmp	r3, #0
   1583a:	d0f4      	beq.n	15826 <USBH_Get_DevDesc+0x1e6>
          if (direction == USB_D2H)
   1583c:	2a00      	cmp	r2, #0
   1583e:	db08      	blt.n	15852 <USBH_Get_DevDesc+0x212>
            phost->Control.state = CTRL_DATA_OUT;
   15840:	2305      	movs	r3, #5
   15842:	2001      	movs	r0, #1
   15844:	7623      	strb	r3, [r4, #24]
   15846:	e704      	b.n	15652 <USBH_Get_DevDesc+0x12>
        phost->Control.state = CTRL_SETUP;
   15848:	2301      	movs	r3, #1
   1584a:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   1584c:	4618      	mov	r0, r3
   1584e:	70a3      	strb	r3, [r4, #2]
   15850:	e6ff      	b.n	15652 <USBH_Get_DevDesc+0x12>
            phost->Control.state = CTRL_DATA_IN;
   15852:	2303      	movs	r3, #3
   15854:	7623      	strb	r3, [r4, #24]
   15856:	e6fc      	b.n	15652 <USBH_Get_DevDesc+0x12>
   15858:	01000680 	.word	0x01000680

0001585c <USBH_Get_CfgDesc>:
{
   1585c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (phost->RequestState == CMD_SEND)
   15860:	7883      	ldrb	r3, [r0, #2]
{
   15862:	b083      	sub	sp, #12
   15864:	4605      	mov	r5, r0
  uint8_t *pData = phost->device.CfgDesc_Raw;;
   15866:	f100 041c 	add.w	r4, r0, #28
  if (phost->RequestState == CMD_SEND)
   1586a:	2b01      	cmp	r3, #1
   1586c:	d012      	beq.n	15894 <USBH_Get_CfgDesc+0x38>
  switch (phost->RequestState)
   1586e:	2b02      	cmp	r3, #2
   15870:	d003      	beq.n	1587a <USBH_Get_CfgDesc+0x1e>
  status = USBH_BUSY;
   15872:	2001      	movs	r0, #1
}
   15874:	b003      	add	sp, #12
   15876:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  switch (phost->Control.state)
   1587a:	7e03      	ldrb	r3, [r0, #24]
   1587c:	460e      	mov	r6, r1
   1587e:	3b01      	subs	r3, #1
   15880:	2b0a      	cmp	r3, #10
   15882:	d8f6      	bhi.n	15872 <USBH_Get_CfgDesc+0x16>
   15884:	e8df f003 	tbb	[pc, r3]
   15888:	5145372e 	.word	0x5145372e
   1588c:	867a695b 	.word	0x867a695b
   15890:	a496      	.short	0xa496
   15892:	14          	.byte	0x14
   15893:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = length;
   15894:	82c1      	strh	r1, [r0, #22]
    phost->Control.setup.b.wValue.w = value_idx;
   15896:	2600      	movs	r6, #0
      phost->Control.buff = buff;
   15898:	6084      	str	r4, [r0, #8]
      phost->RequestState = CMD_WAIT;
   1589a:	2202      	movs	r2, #2
      phost->Control.length = length;
   1589c:	8181      	strh	r1, [r0, #12]
      status = USBH_BUSY;
   1589e:	4618      	mov	r0, r3
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   158a0:	4f98      	ldr	r7, [pc, #608]	; (15b04 <USBH_Get_CfgDesc+0x2a8>)
      phost->Control.state = CTRL_SETUP;
   158a2:	762b      	strb	r3, [r5, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   158a4:	612f      	str	r7, [r5, #16]
    phost->Control.setup.b.wValue.w = value_idx;
   158a6:	82ae      	strh	r6, [r5, #20]
      phost->RequestState = CMD_WAIT;
   158a8:	70aa      	strb	r2, [r5, #2]
}
   158aa:	b003      	add	sp, #12
   158ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   158b0:	7e43      	ldrb	r3, [r0, #25]
   158b2:	3301      	adds	r3, #1
   158b4:	b2db      	uxtb	r3, r3
   158b6:	2b02      	cmp	r3, #2
   158b8:	7643      	strb	r3, [r0, #25]
   158ba:	f240 811b 	bls.w	15af4 <USBH_Get_CfgDesc+0x298>
        phost->Control.errorcount = 0U;
   158be:	2400      	movs	r4, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   158c0:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
   158c4:	2106      	movs	r1, #6
   158c6:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   158c8:	7969      	ldrb	r1, [r5, #5]
        phost->Control.errorcount = 0U;
   158ca:	766c      	strb	r4, [r5, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   158cc:	4628      	mov	r0, r5
   158ce:	f000 fe6d 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   158d2:	7929      	ldrb	r1, [r5, #4]
   158d4:	4628      	mov	r0, r5
   158d6:	f000 fe69 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   158da:	702c      	strb	r4, [r5, #0]
        phost->RequestState = CMD_SEND;
   158dc:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   158de:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   158e0:	70ab      	strb	r3, [r5, #2]
   158e2:	e7c7      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   158e4:	7942      	ldrb	r2, [r0, #5]
   158e6:	f100 0110 	add.w	r1, r0, #16
   158ea:	f000 fdb3 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   158ee:	2302      	movs	r3, #2
   158f0:	2001      	movs	r0, #1
   158f2:	762b      	strb	r3, [r5, #24]
   158f4:	e7be      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   158f6:	7941      	ldrb	r1, [r0, #5]
   158f8:	f00e f9d0 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   158fc:	2801      	cmp	r0, #1
   158fe:	f000 80ee 	beq.w	15ade <USBH_Get_CfgDesc+0x282>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15902:	2804      	cmp	r0, #4
   15904:	d001      	beq.n	1590a <USBH_Get_CfgDesc+0xae>
   15906:	2802      	cmp	r0, #2
   15908:	d1b3      	bne.n	15872 <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
   1590a:	230b      	movs	r3, #11
   1590c:	2001      	movs	r0, #1
   1590e:	762b      	strb	r3, [r5, #24]
   15910:	e7b0      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      phost->Control.timer = (uint16_t)phost->Timer;
   15912:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15916:	7903      	ldrb	r3, [r0, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15918:	81c2      	strh	r2, [r0, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   1591a:	6881      	ldr	r1, [r0, #8]
   1591c:	8982      	ldrh	r2, [r0, #12]
   1591e:	f000 fdc1 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15922:	2304      	movs	r3, #4
   15924:	2001      	movs	r0, #1
   15926:	762b      	strb	r3, [r5, #24]
   15928:	e7a4      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1592a:	7901      	ldrb	r1, [r0, #4]
   1592c:	f00e f9b6 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15930:	2801      	cmp	r0, #1
   15932:	d054      	beq.n	159de <USBH_Get_CfgDesc+0x182>
      if (URB_Status == USBH_URB_STALL)
   15934:	2805      	cmp	r0, #5
   15936:	d037      	beq.n	159a8 <USBH_Get_CfgDesc+0x14c>
        if (URB_Status == USBH_URB_ERROR)
   15938:	2804      	cmp	r0, #4
   1593a:	d19a      	bne.n	15872 <USBH_Get_CfgDesc+0x16>
   1593c:	e7e5      	b.n	1590a <USBH_Get_CfgDesc+0xae>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1593e:	2401      	movs	r4, #1
   15940:	7943      	ldrb	r3, [r0, #5]
   15942:	8982      	ldrh	r2, [r0, #12]
   15944:	6881      	ldr	r1, [r0, #8]
   15946:	9400      	str	r4, [sp, #0]
   15948:	f000 fd94 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1594c:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15950:	2306      	movs	r3, #6
   15952:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
   15954:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15956:	762b      	strb	r3, [r5, #24]
   15958:	e78c      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1595a:	7941      	ldrb	r1, [r0, #5]
   1595c:	f00e f99e 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15960:	2801      	cmp	r0, #1
   15962:	f000 80b8 	beq.w	15ad6 <USBH_Get_CfgDesc+0x27a>
      else if (URB_Status == USBH_URB_STALL)
   15966:	2805      	cmp	r0, #5
   15968:	d01e      	beq.n	159a8 <USBH_Get_CfgDesc+0x14c>
      else if (URB_Status == USBH_URB_NOTREADY)
   1596a:	2802      	cmp	r0, #2
   1596c:	f000 80be 	beq.w	15aec <USBH_Get_CfgDesc+0x290>
        if (URB_Status == USBH_URB_ERROR)
   15970:	2804      	cmp	r0, #4
   15972:	f47f af7e 	bne.w	15872 <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
   15976:	230b      	movs	r3, #11
   15978:	762b      	strb	r3, [r5, #24]
   1597a:	e7af      	b.n	158dc <USBH_Get_CfgDesc+0x80>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   1597c:	2200      	movs	r2, #0
   1597e:	7903      	ldrb	r3, [r0, #4]
   15980:	4611      	mov	r1, r2
   15982:	f000 fd8f 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15986:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   1598a:	2308      	movs	r3, #8
   1598c:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   1598e:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15990:	762b      	strb	r3, [r5, #24]
   15992:	e76f      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15994:	7901      	ldrb	r1, [r0, #4]
   15996:	f00e f981 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1599a:	2801      	cmp	r0, #1
   1599c:	d023      	beq.n	159e6 <USBH_Get_CfgDesc+0x18a>
      else if (URB_Status == USBH_URB_ERROR)
   1599e:	2804      	cmp	r0, #4
   159a0:	d0b3      	beq.n	1590a <USBH_Get_CfgDesc+0xae>
        if (URB_Status == USBH_URB_STALL)
   159a2:	2805      	cmp	r0, #5
   159a4:	f47f af65 	bne.w	15872 <USBH_Get_CfgDesc+0x16>
        phost->RequestState = CMD_SEND;
   159a8:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   159aa:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   159ac:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   159ae:	70aa      	strb	r2, [r5, #2]
        phost->Control.state = CTRL_IDLE;
   159b0:	762b      	strb	r3, [r5, #24]
   159b2:	e75f      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   159b4:	2200      	movs	r2, #0
   159b6:	2401      	movs	r4, #1
   159b8:	7943      	ldrb	r3, [r0, #5]
   159ba:	4611      	mov	r1, r2
   159bc:	9400      	str	r4, [sp, #0]
   159be:	f000 fd59 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   159c2:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   159c6:	230a      	movs	r3, #10
   159c8:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
   159ca:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   159cc:	762b      	strb	r3, [r5, #24]
   159ce:	e751      	b.n	15874 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   159d0:	7941      	ldrb	r1, [r0, #5]
   159d2:	f00e f963 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   159d6:	2801      	cmp	r0, #1
   159d8:	d005      	beq.n	159e6 <USBH_Get_CfgDesc+0x18a>
      else if (URB_Status == USBH_URB_NOTREADY)
   159da:	2802      	cmp	r0, #2
   159dc:	d1ac      	bne.n	15938 <USBH_Get_CfgDesc+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   159de:	2309      	movs	r3, #9
   159e0:	2001      	movs	r0, #1
   159e2:	762b      	strb	r3, [r5, #24]
   159e4:	e746      	b.n	15874 <USBH_Get_CfgDesc+0x18>
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
   159e6:	7f2a      	ldrb	r2, [r5, #28]
        phost->RequestState = CMD_SEND;
   159e8:	2101      	movs	r1, #1
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
   159ea:	7f6b      	ldrb	r3, [r5, #29]
        phost->Control.state = CTRL_IDLE;
   159ec:	2700      	movs	r7, #0
  cfg_desc->wTotalLength        = LE16(buf + 2);
   159ee:	8be8      	ldrh	r0, [r5, #30]
  if (length > USB_CONFIGURATION_DESC_SIZE)
   159f0:	2e09      	cmp	r6, #9
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
   159f2:	f885 2338 	strb.w	r2, [r5, #824]	; 0x338
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
   159f6:	f885 3339 	strb.w	r3, [r5, #825]	; 0x339
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
   159fa:	6a2a      	ldr	r2, [r5, #32]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
   159fc:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
        phost->RequestState = CMD_SEND;
   15a00:	70a9      	strb	r1, [r5, #2]
        phost->Control.state = CTRL_IDLE;
   15a02:	762f      	strb	r7, [r5, #24]
  cfg_desc->wTotalLength        = LE16(buf + 2);
   15a04:	f8a5 033a 	strh.w	r0, [r5, #826]	; 0x33a
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
   15a08:	f8c5 233c 	str.w	r2, [r5, #828]	; 0x33c
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
   15a0c:	f885 3340 	strb.w	r3, [r5, #832]	; 0x340
  if (length > USB_CONFIGURATION_DESC_SIZE)
   15a10:	d913      	bls.n	15a3a <USBH_Get_CfgDesc+0x1de>
   15a12:	46ac      	mov	ip, r5
    ptr = USB_LEN_CFG_DESC;
   15a14:	2209      	movs	r2, #9
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15a16:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
   15a1a:	b2fe      	uxtb	r6, r7
   15a1c:	2e09      	cmp	r6, #9
   15a1e:	bf8c      	ite	hi
   15a20:	2600      	movhi	r6, #0
   15a22:	2601      	movls	r6, #1
   15a24:	e007      	b.n	15a36 <USBH_Get_CfgDesc+0x1da>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
   15a26:	b146      	cbz	r6, 15a3a <USBH_Get_CfgDesc+0x1de>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a28:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
   15a2a:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a2c:	4413      	add	r3, r2
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
   15a2e:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a30:	b29a      	uxth	r2, r3
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
   15a32:	2904      	cmp	r1, #4
   15a34:	d005      	beq.n	15a42 <USBH_Get_CfgDesc+0x1e6>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
   15a36:	4290      	cmp	r0, r2
   15a38:	d8f5      	bhi.n	15a26 <USBH_Get_CfgDesc+0x1ca>
        status = USBH_NOT_SUPPORTED;
   15a3a:	2000      	movs	r0, #0
}
   15a3c:	b003      	add	sp, #12
   15a3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
   15a42:	7823      	ldrb	r3, [r4, #0]
        ep_ix = 0U;
   15a44:	2100      	movs	r1, #0
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15a46:	fb0e f907 	mul.w	r9, lr, r7
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
   15a4a:	f88c 3342 	strb.w	r3, [ip, #834]	; 0x342
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
   15a4e:	7863      	ldrb	r3, [r4, #1]
   15a50:	f88c 3343 	strb.w	r3, [ip, #835]	; 0x343
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
   15a54:	78a3      	ldrb	r3, [r4, #2]
   15a56:	f88c 3344 	strb.w	r3, [ip, #836]	; 0x344
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
   15a5a:	78e3      	ldrb	r3, [r4, #3]
   15a5c:	f88c 3345 	strb.w	r3, [ip, #837]	; 0x345
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
   15a60:	f894 8004 	ldrb.w	r8, [r4, #4]
   15a64:	f88c 8346 	strb.w	r8, [ip, #838]	; 0x346
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
   15a68:	7963      	ldrb	r3, [r4, #5]
   15a6a:	f88c 3347 	strb.w	r3, [ip, #839]	; 0x347
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
   15a6e:	79a3      	ldrb	r3, [r4, #6]
   15a70:	f88c 3348 	strb.w	r3, [ip, #840]	; 0x348
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
   15a74:	79e3      	ldrb	r3, [r4, #7]
   15a76:	f88c 3349 	strb.w	r3, [ip, #841]	; 0x349
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
   15a7a:	7a23      	ldrb	r3, [r4, #8]
   15a7c:	f88c 334a 	strb.w	r3, [ip, #842]	; 0x34a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
   15a80:	4290      	cmp	r0, r2
   15a82:	d922      	bls.n	15aca <USBH_Get_CfgDesc+0x26e>
   15a84:	4541      	cmp	r1, r8
   15a86:	d220      	bcs.n	15aca <USBH_Get_CfgDesc+0x26e>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a88:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
   15a8a:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a8c:	4413      	add	r3, r2
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
   15a8e:	7866      	ldrb	r6, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
   15a90:	b29a      	uxth	r2, r3
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
   15a92:	2e05      	cmp	r6, #5
   15a94:	d1f4      	bne.n	15a80 <USBH_Get_CfgDesc+0x224>
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15a96:	3101      	adds	r1, #1
   15a98:	7826      	ldrb	r6, [r4, #0]
   15a9a:	eb09 03c1 	add.w	r3, r9, r1, lsl #3
            ep_ix++;
   15a9e:	b2c9      	uxtb	r1, r1
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
   15aa0:	442b      	add	r3, r5
   15aa2:	f883 6344 	strb.w	r6, [r3, #836]	; 0x344
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
   15aa6:	7866      	ldrb	r6, [r4, #1]
   15aa8:	f883 6345 	strb.w	r6, [r3, #837]	; 0x345
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
   15aac:	78a6      	ldrb	r6, [r4, #2]
   15aae:	f883 6346 	strb.w	r6, [r3, #838]	; 0x346
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
   15ab2:	78e6      	ldrb	r6, [r4, #3]
   15ab4:	f883 6347 	strb.w	r6, [r3, #839]	; 0x347
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
   15ab8:	88a6      	ldrh	r6, [r4, #4]
   15aba:	f8a3 6348 	strh.w	r6, [r3, #840]	; 0x348
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
   15abe:	79a6      	ldrb	r6, [r4, #6]
   15ac0:	f883 634a 	strb.w	r6, [r3, #842]	; 0x34a
   15ac4:	f89c 8346 	ldrb.w	r8, [ip, #838]	; 0x346
   15ac8:	e7da      	b.n	15a80 <USBH_Get_CfgDesc+0x224>
   15aca:	3701      	adds	r7, #1
   15acc:	f10c 0c2a 	add.w	ip, ip, #42	; 0x2a
   15ad0:	e7a3      	b.n	15a1a <USBH_Get_CfgDesc+0x1be>
          if (direction == USB_D2H)
   15ad2:	2b00      	cmp	r3, #0
   15ad4:	db83      	blt.n	159de <USBH_Get_CfgDesc+0x182>
            phost->Control.state = CTRL_STATUS_IN;
   15ad6:	2307      	movs	r3, #7
   15ad8:	2001      	movs	r0, #1
   15ada:	762b      	strb	r3, [r5, #24]
   15adc:	e6ca      	b.n	15874 <USBH_Get_CfgDesc+0x18>
        if (phost->Control.setup.b.wLength.w != 0U)
   15ade:	8aea      	ldrh	r2, [r5, #22]
   15ae0:	f995 3010 	ldrsb.w	r3, [r5, #16]
   15ae4:	2a00      	cmp	r2, #0
   15ae6:	d0f4      	beq.n	15ad2 <USBH_Get_CfgDesc+0x276>
          if (direction == USB_D2H)
   15ae8:	2b00      	cmp	r3, #0
   15aea:	db08      	blt.n	15afe <USBH_Get_CfgDesc+0x2a2>
            phost->Control.state = CTRL_DATA_OUT;
   15aec:	2305      	movs	r3, #5
   15aee:	2001      	movs	r0, #1
   15af0:	762b      	strb	r3, [r5, #24]
   15af2:	e6bf      	b.n	15874 <USBH_Get_CfgDesc+0x18>
        phost->Control.state = CTRL_SETUP;
   15af4:	2301      	movs	r3, #1
   15af6:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
   15af8:	4618      	mov	r0, r3
   15afa:	70ab      	strb	r3, [r5, #2]
   15afc:	e6ba      	b.n	15874 <USBH_Get_CfgDesc+0x18>
            phost->Control.state = CTRL_DATA_IN;
   15afe:	2303      	movs	r3, #3
   15b00:	762b      	strb	r3, [r5, #24]
   15b02:	e6b7      	b.n	15874 <USBH_Get_CfgDesc+0x18>
   15b04:	02000680 	.word	0x02000680

00015b08 <USBH_Get_StringDesc>:
{
   15b08:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (phost->RequestState == CMD_SEND)
   15b0a:	7885      	ldrb	r5, [r0, #2]
{
   15b0c:	b085      	sub	sp, #20
   15b0e:	4604      	mov	r4, r0
                                   phost->device.Data, length)) == USBH_OK)
   15b10:	f500 768e 	add.w	r6, r0, #284	; 0x11c
  if (phost->RequestState == CMD_SEND)
   15b14:	2d01      	cmp	r5, #1
   15b16:	d010      	beq.n	15b3a <USBH_Get_StringDesc+0x32>
  switch (phost->RequestState)
   15b18:	2d02      	cmp	r5, #2
   15b1a:	d002      	beq.n	15b22 <USBH_Get_StringDesc+0x1a>
  status = USBH_BUSY;
   15b1c:	2001      	movs	r0, #1
}
   15b1e:	b005      	add	sp, #20
   15b20:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (phost->Control.state)
   15b22:	7e01      	ldrb	r1, [r0, #24]
   15b24:	3901      	subs	r1, #1
   15b26:	290a      	cmp	r1, #10
   15b28:	d8f8      	bhi.n	15b1c <USBH_Get_StringDesc+0x14>
   15b2a:	e8df f001 	tbb	[pc, r1]
   15b2e:	3e34      	.short	0x3e34
   15b30:	74655a4d 	.word	0x74655a4d
   15b34:	b5a69184 	.word	0xb5a69184
   15b38:	19          	.byte	0x19
   15b39:	00          	.byte	0x00
  if ((status = USBH_GetDescriptor(phost,
   15b3a:	f441 7140 	orr.w	r1, r1, #768	; 0x300
    phost->Control.setup.b.wLength.w = length;
   15b3e:	82c3      	strh	r3, [r0, #22]
      phost->Control.buff = buff;
   15b40:	6086      	str	r6, [r0, #8]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15b42:	f44f 6cd0 	mov.w	ip, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
   15b46:	8241      	strh	r1, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
   15b48:	f240 4709 	movw	r7, #1033	; 0x409
      phost->Control.length = length;
   15b4c:	8183      	strh	r3, [r0, #12]
      phost->RequestState = CMD_WAIT;
   15b4e:	2202      	movs	r2, #2
      status = USBH_BUSY;
   15b50:	4628      	mov	r0, r5
      phost->Control.state = CTRL_SETUP;
   15b52:	7625      	strb	r5, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   15b54:	f8a4 c010 	strh.w	ip, [r4, #16]
      phost->Control.setup.b.wIndex.w = 0x0409U;
   15b58:	82a7      	strh	r7, [r4, #20]
      phost->RequestState = CMD_WAIT;
   15b5a:	70a2      	strb	r2, [r4, #2]
}
   15b5c:	b005      	add	sp, #20
   15b5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   15b60:	7e63      	ldrb	r3, [r4, #25]
   15b62:	3301      	adds	r3, #1
   15b64:	b2db      	uxtb	r3, r3
   15b66:	2b02      	cmp	r3, #2
   15b68:	7663      	strb	r3, [r4, #25]
   15b6a:	f240 80d3 	bls.w	15d14 <USBH_Get_StringDesc+0x20c>
        phost->Control.errorcount = 0U;
   15b6e:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   15b70:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15b74:	2106      	movs	r1, #6
   15b76:	4620      	mov	r0, r4
   15b78:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15b7a:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   15b7c:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15b7e:	4620      	mov	r0, r4
   15b80:	f000 fd14 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   15b84:	7921      	ldrb	r1, [r4, #4]
   15b86:	4620      	mov	r0, r4
   15b88:	f000 fd10 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   15b8c:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   15b8e:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   15b90:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   15b92:	70a3      	strb	r3, [r4, #2]
   15b94:	e7c3      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   15b96:	7962      	ldrb	r2, [r4, #5]
   15b98:	f104 0110 	add.w	r1, r4, #16
   15b9c:	4620      	mov	r0, r4
   15b9e:	f000 fc59 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   15ba2:	2302      	movs	r3, #2
   15ba4:	2001      	movs	r0, #1
   15ba6:	7623      	strb	r3, [r4, #24]
   15ba8:	e7b9      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15baa:	7961      	ldrb	r1, [r4, #5]
   15bac:	4620      	mov	r0, r4
   15bae:	f00e f875 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15bb2:	2801      	cmp	r0, #1
   15bb4:	f000 80a3 	beq.w	15cfe <USBH_Get_StringDesc+0x1f6>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15bb8:	2804      	cmp	r0, #4
   15bba:	d001      	beq.n	15bc0 <USBH_Get_StringDesc+0xb8>
   15bbc:	2802      	cmp	r0, #2
   15bbe:	d1ad      	bne.n	15b1c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
   15bc0:	230b      	movs	r3, #11
   15bc2:	2001      	movs	r0, #1
   15bc4:	7623      	strb	r3, [r4, #24]
   15bc6:	e7aa      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      phost->Control.timer = (uint16_t)phost->Timer;
   15bc8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15bcc:	4620      	mov	r0, r4
   15bce:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15bd0:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15bd2:	68a1      	ldr	r1, [r4, #8]
   15bd4:	89a2      	ldrh	r2, [r4, #12]
   15bd6:	f000 fc65 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15bda:	2304      	movs	r3, #4
   15bdc:	2001      	movs	r0, #1
   15bde:	7623      	strb	r3, [r4, #24]
   15be0:	e79d      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15be2:	7921      	ldrb	r1, [r4, #4]
   15be4:	4620      	mov	r0, r4
   15be6:	f00e f859 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15bea:	2801      	cmp	r0, #1
   15bec:	d060      	beq.n	15cb0 <USBH_Get_StringDesc+0x1a8>
      if (URB_Status == USBH_URB_STALL)
   15bee:	2805      	cmp	r0, #5
   15bf0:	d03d      	beq.n	15c6e <USBH_Get_StringDesc+0x166>
        if (URB_Status == USBH_URB_ERROR)
   15bf2:	2804      	cmp	r0, #4
   15bf4:	d192      	bne.n	15b1c <USBH_Get_StringDesc+0x14>
   15bf6:	e7e3      	b.n	15bc0 <USBH_Get_StringDesc+0xb8>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15bf8:	2501      	movs	r5, #1
   15bfa:	7963      	ldrb	r3, [r4, #5]
   15bfc:	89a2      	ldrh	r2, [r4, #12]
   15bfe:	4620      	mov	r0, r4
   15c00:	68a1      	ldr	r1, [r4, #8]
   15c02:	9500      	str	r5, [sp, #0]
   15c04:	f000 fc36 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15c08:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15c0c:	2306      	movs	r3, #6
   15c0e:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15c10:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15c12:	7623      	strb	r3, [r4, #24]
   15c14:	e783      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15c16:	7961      	ldrb	r1, [r4, #5]
   15c18:	4620      	mov	r0, r4
   15c1a:	f00e f83f 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15c1e:	2801      	cmp	r0, #1
   15c20:	d069      	beq.n	15cf6 <USBH_Get_StringDesc+0x1ee>
      else if (URB_Status == USBH_URB_STALL)
   15c22:	2805      	cmp	r0, #5
   15c24:	d023      	beq.n	15c6e <USBH_Get_StringDesc+0x166>
      else if (URB_Status == USBH_URB_NOTREADY)
   15c26:	2802      	cmp	r0, #2
   15c28:	d070      	beq.n	15d0c <USBH_Get_StringDesc+0x204>
        if (URB_Status == USBH_URB_ERROR)
   15c2a:	2804      	cmp	r0, #4
   15c2c:	f47f af76 	bne.w	15b1c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
   15c30:	230b      	movs	r3, #11
   15c32:	7623      	strb	r3, [r4, #24]
   15c34:	e7ab      	b.n	15b8e <USBH_Get_StringDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   15c36:	2200      	movs	r2, #0
   15c38:	7923      	ldrb	r3, [r4, #4]
   15c3a:	4620      	mov	r0, r4
   15c3c:	4611      	mov	r1, r2
   15c3e:	f000 fc31 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15c42:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15c46:	2308      	movs	r3, #8
   15c48:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   15c4a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15c4c:	7623      	strb	r3, [r4, #24]
   15c4e:	e766      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15c50:	7921      	ldrb	r1, [r4, #4]
   15c52:	4620      	mov	r0, r4
   15c54:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15c58:	f00e f820 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15c5c:	2801      	cmp	r0, #1
   15c5e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   15c62:	d029      	beq.n	15cb8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_ERROR)
   15c64:	2804      	cmp	r0, #4
   15c66:	d0ab      	beq.n	15bc0 <USBH_Get_StringDesc+0xb8>
        if (URB_Status == USBH_URB_STALL)
   15c68:	2805      	cmp	r0, #5
   15c6a:	f47f af57 	bne.w	15b1c <USBH_Get_StringDesc+0x14>
        phost->RequestState = CMD_SEND;
   15c6e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   15c70:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
   15c72:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   15c74:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   15c76:	7623      	strb	r3, [r4, #24]
   15c78:	e751      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   15c7a:	2200      	movs	r2, #0
   15c7c:	2501      	movs	r5, #1
   15c7e:	7963      	ldrb	r3, [r4, #5]
   15c80:	4620      	mov	r0, r4
   15c82:	4611      	mov	r1, r2
   15c84:	9500      	str	r5, [sp, #0]
   15c86:	f000 fbf5 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15c8a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15c8e:	230a      	movs	r3, #10
   15c90:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15c92:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15c94:	7623      	strb	r3, [r4, #24]
   15c96:	e742      	b.n	15b1e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15c98:	7961      	ldrb	r1, [r4, #5]
   15c9a:	4620      	mov	r0, r4
   15c9c:	e9cd 2302 	strd	r2, r3, [sp, #8]
   15ca0:	f00d fffc 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15ca4:	2801      	cmp	r0, #1
   15ca6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   15caa:	d005      	beq.n	15cb8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_NOTREADY)
   15cac:	2802      	cmp	r0, #2
   15cae:	d1a0      	bne.n	15bf2 <USBH_Get_StringDesc+0xea>
            phost->Control.state = CTRL_STATUS_OUT;
   15cb0:	2309      	movs	r3, #9
   15cb2:	2001      	movs	r0, #1
   15cb4:	7623      	strb	r3, [r4, #24]
   15cb6:	e732      	b.n	15b1e <USBH_Get_StringDesc+0x16>
  if (psrc[1] == USB_DESC_TYPE_STRING)
   15cb8:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
   15cbc:	2501      	movs	r5, #1
        phost->Control.state = CTRL_IDLE;
   15cbe:	2000      	movs	r0, #0
  if (psrc[1] == USB_DESC_TYPE_STRING)
   15cc0:	2903      	cmp	r1, #3
        phost->RequestState = CMD_SEND;
   15cc2:	70a5      	strb	r5, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   15cc4:	7620      	strb	r0, [r4, #24]
  if (psrc[1] == USB_DESC_TYPE_STRING)
   15cc6:	f47f af2a 	bne.w	15b1e <USBH_Get_StringDesc+0x16>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
   15cca:	f894 111c 	ldrb.w	r1, [r4, #284]	; 0x11c
   15cce:	3902      	subs	r1, #2
   15cd0:	428b      	cmp	r3, r1
   15cd2:	bf28      	it	cs
   15cd4:	460b      	movcs	r3, r1
   15cd6:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
   15cd8:	b13b      	cbz	r3, 15cea <USBH_Get_StringDesc+0x1e2>
      *pdest =  psrc[idx];
   15cda:	1833      	adds	r3, r6, r0
    for (idx = 0U; idx < strlength; idx += 2U)
   15cdc:	3002      	adds	r0, #2
   15cde:	b280      	uxth	r0, r0
      *pdest =  psrc[idx];
   15ce0:	789b      	ldrb	r3, [r3, #2]
    for (idx = 0U; idx < strlength; idx += 2U)
   15ce2:	4281      	cmp	r1, r0
      *pdest =  psrc[idx];
   15ce4:	f802 3b01 	strb.w	r3, [r2], #1
    for (idx = 0U; idx < strlength; idx += 2U)
   15ce8:	d8f7      	bhi.n	15cda <USBH_Get_StringDesc+0x1d2>
    *pdest = 0U; /* mark end of string */
   15cea:	2000      	movs	r0, #0
   15cec:	7010      	strb	r0, [r2, #0]
}
   15cee:	b005      	add	sp, #20
   15cf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (direction == USB_D2H)
   15cf2:	2a00      	cmp	r2, #0
   15cf4:	dbdc      	blt.n	15cb0 <USBH_Get_StringDesc+0x1a8>
            phost->Control.state = CTRL_STATUS_IN;
   15cf6:	2307      	movs	r3, #7
   15cf8:	2001      	movs	r0, #1
   15cfa:	7623      	strb	r3, [r4, #24]
   15cfc:	e70f      	b.n	15b1e <USBH_Get_StringDesc+0x16>
        if (phost->Control.setup.b.wLength.w != 0U)
   15cfe:	8ae3      	ldrh	r3, [r4, #22]
   15d00:	f994 2010 	ldrsb.w	r2, [r4, #16]
   15d04:	2b00      	cmp	r3, #0
   15d06:	d0f4      	beq.n	15cf2 <USBH_Get_StringDesc+0x1ea>
          if (direction == USB_D2H)
   15d08:	2a00      	cmp	r2, #0
   15d0a:	db08      	blt.n	15d1e <USBH_Get_StringDesc+0x216>
            phost->Control.state = CTRL_DATA_OUT;
   15d0c:	2305      	movs	r3, #5
   15d0e:	2001      	movs	r0, #1
   15d10:	7623      	strb	r3, [r4, #24]
   15d12:	e704      	b.n	15b1e <USBH_Get_StringDesc+0x16>
        phost->Control.state = CTRL_SETUP;
   15d14:	2301      	movs	r3, #1
   15d16:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   15d18:	4618      	mov	r0, r3
   15d1a:	70a3      	strb	r3, [r4, #2]
   15d1c:	e6ff      	b.n	15b1e <USBH_Get_StringDesc+0x16>
            phost->Control.state = CTRL_DATA_IN;
   15d1e:	2303      	movs	r3, #3
   15d20:	7623      	strb	r3, [r4, #24]
   15d22:	e6fc      	b.n	15b1e <USBH_Get_StringDesc+0x16>

00015d24 <USBH_SetAddress>:
{
   15d24:	b530      	push	{r4, r5, lr}
   15d26:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   15d28:	7880      	ldrb	r0, [r0, #2]
{
   15d2a:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   15d2c:	2801      	cmp	r0, #1
   15d2e:	d011      	beq.n	15d54 <USBH_SetAddress+0x30>
  switch (phost->RequestState)
   15d30:	2802      	cmp	r0, #2
   15d32:	d002      	beq.n	15d3a <USBH_SetAddress+0x16>
  status = USBH_BUSY;
   15d34:	2001      	movs	r0, #1
}
   15d36:	b003      	add	sp, #12
   15d38:	bd30      	pop	{r4, r5, pc}
   15d3a:	461c      	mov	r4, r3
  switch (phost->Control.state)
   15d3c:	7e1b      	ldrb	r3, [r3, #24]
   15d3e:	3b01      	subs	r3, #1
   15d40:	2b0a      	cmp	r3, #10
   15d42:	d8f7      	bhi.n	15d34 <USBH_SetAddress+0x10>
   15d44:	e8df f003 	tbb	[pc, r3]
   15d48:	5447382e 	.word	0x5447382e
   15d4c:	8b7e6e5f 	.word	0x8b7e6e5f
   15d50:	ac9d      	.short	0xac9d
   15d52:	13          	.byte	0x13
   15d53:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   15d54:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
   15d56:	f44f 65a0 	mov.w	r5, #1280	; 0x500
      phost->RequestState = CMD_WAIT;
   15d5a:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
   15d5c:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   15d5e:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
   15d60:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   15d62:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   15d64:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   15d66:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   15d68:	709c      	strb	r4, [r3, #2]
}
   15d6a:	b003      	add	sp, #12
   15d6c:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   15d6e:	7e63      	ldrb	r3, [r4, #25]
   15d70:	3301      	adds	r3, #1
   15d72:	b2db      	uxtb	r3, r3
   15d74:	2b02      	cmp	r3, #2
   15d76:	7663      	strb	r3, [r4, #25]
   15d78:	f240 80b1 	bls.w	15ede <USBH_SetAddress+0x1ba>
        phost->Control.errorcount = 0U;
   15d7c:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   15d7e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15d82:	2106      	movs	r1, #6
   15d84:	4620      	mov	r0, r4
   15d86:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15d88:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   15d8a:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15d8c:	4620      	mov	r0, r4
   15d8e:	f000 fc0d 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   15d92:	7921      	ldrb	r1, [r4, #4]
   15d94:	4620      	mov	r0, r4
   15d96:	f000 fc09 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   15d9a:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   15d9c:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   15d9e:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   15da0:	70a3      	strb	r3, [r4, #2]
   15da2:	e7c8      	b.n	15d36 <USBH_SetAddress+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   15da4:	7962      	ldrb	r2, [r4, #5]
   15da6:	f104 0110 	add.w	r1, r4, #16
   15daa:	4620      	mov	r0, r4
   15dac:	f000 fb52 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   15db0:	2302      	movs	r3, #2
   15db2:	2001      	movs	r0, #1
   15db4:	7623      	strb	r3, [r4, #24]
   15db6:	e7be      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15db8:	7961      	ldrb	r1, [r4, #5]
   15dba:	4620      	mov	r0, r4
   15dbc:	f00d ff6e 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15dc0:	2801      	cmp	r0, #1
   15dc2:	f000 8081 	beq.w	15ec8 <USBH_SetAddress+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15dc6:	2804      	cmp	r0, #4
   15dc8:	d001      	beq.n	15dce <USBH_SetAddress+0xaa>
   15dca:	2802      	cmp	r0, #2
   15dcc:	d1b2      	bne.n	15d34 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
   15dce:	230b      	movs	r3, #11
   15dd0:	2001      	movs	r0, #1
   15dd2:	7623      	strb	r3, [r4, #24]
   15dd4:	e7af      	b.n	15d36 <USBH_SetAddress+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   15dd6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15dda:	4620      	mov	r0, r4
   15ddc:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15dde:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15de0:	68a1      	ldr	r1, [r4, #8]
   15de2:	89a2      	ldrh	r2, [r4, #12]
   15de4:	f000 fb5e 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15de8:	2304      	movs	r3, #4
   15dea:	2001      	movs	r0, #1
   15dec:	7623      	strb	r3, [r4, #24]
   15dee:	e7a2      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15df0:	7921      	ldrb	r1, [r4, #4]
   15df2:	4620      	mov	r0, r4
   15df4:	f00d ff52 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15df8:	2801      	cmp	r0, #1
   15dfa:	d059      	beq.n	15eb0 <USBH_SetAddress+0x18c>
      if (URB_Status == USBH_URB_STALL)
   15dfc:	2805      	cmp	r0, #5
   15dfe:	d039      	beq.n	15e74 <USBH_SetAddress+0x150>
        if (URB_Status == USBH_URB_ERROR)
   15e00:	2804      	cmp	r0, #4
   15e02:	d197      	bne.n	15d34 <USBH_SetAddress+0x10>
   15e04:	e7e3      	b.n	15dce <USBH_SetAddress+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15e06:	2501      	movs	r5, #1
   15e08:	7963      	ldrb	r3, [r4, #5]
   15e0a:	89a2      	ldrh	r2, [r4, #12]
   15e0c:	4620      	mov	r0, r4
   15e0e:	68a1      	ldr	r1, [r4, #8]
   15e10:	9500      	str	r5, [sp, #0]
   15e12:	f000 fb2f 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15e16:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15e1a:	2306      	movs	r3, #6
   15e1c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15e1e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15e20:	7623      	strb	r3, [r4, #24]
   15e22:	e788      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15e24:	7961      	ldrb	r1, [r4, #5]
   15e26:	4620      	mov	r0, r4
   15e28:	f00d ff38 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15e2c:	2801      	cmp	r0, #1
   15e2e:	d047      	beq.n	15ec0 <USBH_SetAddress+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   15e30:	2805      	cmp	r0, #5
   15e32:	d01f      	beq.n	15e74 <USBH_SetAddress+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   15e34:	2802      	cmp	r0, #2
   15e36:	d04e      	beq.n	15ed6 <USBH_SetAddress+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   15e38:	2804      	cmp	r0, #4
   15e3a:	f47f af7b 	bne.w	15d34 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
   15e3e:	230b      	movs	r3, #11
   15e40:	7623      	strb	r3, [r4, #24]
   15e42:	e7ab      	b.n	15d9c <USBH_SetAddress+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   15e44:	2200      	movs	r2, #0
   15e46:	7923      	ldrb	r3, [r4, #4]
   15e48:	4620      	mov	r0, r4
   15e4a:	4611      	mov	r1, r2
   15e4c:	f000 fb2a 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15e50:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15e54:	2308      	movs	r3, #8
   15e56:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   15e58:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   15e5a:	7623      	strb	r3, [r4, #24]
   15e5c:	e76b      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15e5e:	7921      	ldrb	r1, [r4, #4]
   15e60:	4620      	mov	r0, r4
   15e62:	f00d ff1b 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15e66:	2801      	cmp	r0, #1
   15e68:	d026      	beq.n	15eb8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   15e6a:	2804      	cmp	r0, #4
   15e6c:	d0af      	beq.n	15dce <USBH_SetAddress+0xaa>
        if (URB_Status == USBH_URB_STALL)
   15e6e:	2805      	cmp	r0, #5
   15e70:	f47f af60 	bne.w	15d34 <USBH_SetAddress+0x10>
        status = USBH_NOT_SUPPORTED;
   15e74:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   15e76:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   15e78:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   15e7a:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   15e7c:	7623      	strb	r3, [r4, #24]
}
   15e7e:	b003      	add	sp, #12
   15e80:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   15e82:	2200      	movs	r2, #0
   15e84:	2501      	movs	r5, #1
   15e86:	7963      	ldrb	r3, [r4, #5]
   15e88:	4620      	mov	r0, r4
   15e8a:	4611      	mov	r1, r2
   15e8c:	9500      	str	r5, [sp, #0]
   15e8e:	f000 faf1 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15e92:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15e96:	230a      	movs	r3, #10
   15e98:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15e9a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   15e9c:	7623      	strb	r3, [r4, #24]
   15e9e:	e74a      	b.n	15d36 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15ea0:	7961      	ldrb	r1, [r4, #5]
   15ea2:	4620      	mov	r0, r4
   15ea4:	f00d fefa 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15ea8:	2801      	cmp	r0, #1
   15eaa:	d005      	beq.n	15eb8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   15eac:	2802      	cmp	r0, #2
   15eae:	d1a7      	bne.n	15e00 <USBH_SetAddress+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   15eb0:	2309      	movs	r3, #9
   15eb2:	2001      	movs	r0, #1
   15eb4:	7623      	strb	r3, [r4, #24]
   15eb6:	e73e      	b.n	15d36 <USBH_SetAddress+0x12>
        status = USBH_OK;
   15eb8:	2000      	movs	r0, #0
   15eba:	e7dc      	b.n	15e76 <USBH_SetAddress+0x152>
          if (direction == USB_D2H)
   15ebc:	2a00      	cmp	r2, #0
   15ebe:	dbf7      	blt.n	15eb0 <USBH_SetAddress+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   15ec0:	2307      	movs	r3, #7
   15ec2:	2001      	movs	r0, #1
   15ec4:	7623      	strb	r3, [r4, #24]
   15ec6:	e736      	b.n	15d36 <USBH_SetAddress+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   15ec8:	8ae3      	ldrh	r3, [r4, #22]
   15eca:	f994 2010 	ldrsb.w	r2, [r4, #16]
   15ece:	2b00      	cmp	r3, #0
   15ed0:	d0f4      	beq.n	15ebc <USBH_SetAddress+0x198>
          if (direction == USB_D2H)
   15ed2:	2a00      	cmp	r2, #0
   15ed4:	db08      	blt.n	15ee8 <USBH_SetAddress+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   15ed6:	2305      	movs	r3, #5
   15ed8:	2001      	movs	r0, #1
   15eda:	7623      	strb	r3, [r4, #24]
   15edc:	e72b      	b.n	15d36 <USBH_SetAddress+0x12>
        phost->Control.state = CTRL_SETUP;
   15ede:	2301      	movs	r3, #1
   15ee0:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   15ee2:	4618      	mov	r0, r3
   15ee4:	70a3      	strb	r3, [r4, #2]
   15ee6:	e726      	b.n	15d36 <USBH_SetAddress+0x12>
            phost->Control.state = CTRL_DATA_IN;
   15ee8:	2303      	movs	r3, #3
   15eea:	7623      	strb	r3, [r4, #24]
   15eec:	e723      	b.n	15d36 <USBH_SetAddress+0x12>
   15eee:	bf00      	nop

00015ef0 <USBH_SetCfg>:
{
   15ef0:	b530      	push	{r4, r5, lr}
   15ef2:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   15ef4:	7880      	ldrb	r0, [r0, #2]
{
   15ef6:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   15ef8:	2801      	cmp	r0, #1
   15efa:	d011      	beq.n	15f20 <USBH_SetCfg+0x30>
  switch (phost->RequestState)
   15efc:	2802      	cmp	r0, #2
   15efe:	d002      	beq.n	15f06 <USBH_SetCfg+0x16>
  status = USBH_BUSY;
   15f00:	2001      	movs	r0, #1
}
   15f02:	b003      	add	sp, #12
   15f04:	bd30      	pop	{r4, r5, pc}
   15f06:	461c      	mov	r4, r3
  switch (phost->Control.state)
   15f08:	7e1b      	ldrb	r3, [r3, #24]
   15f0a:	3b01      	subs	r3, #1
   15f0c:	2b0a      	cmp	r3, #10
   15f0e:	d8f7      	bhi.n	15f00 <USBH_SetCfg+0x10>
   15f10:	e8df f003 	tbb	[pc, r3]
   15f14:	5447382e 	.word	0x5447382e
   15f18:	8b7e6e5f 	.word	0x8b7e6e5f
   15f1c:	ac9d      	.short	0xac9d
   15f1e:	13          	.byte	0x13
   15f1f:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   15f20:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   15f22:	f44f 6510 	mov.w	r5, #2304	; 0x900
      phost->RequestState = CMD_WAIT;
   15f26:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = cfg_idx;
   15f28:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   15f2a:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   15f2c:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   15f2e:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   15f30:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   15f32:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   15f34:	709c      	strb	r4, [r3, #2]
}
   15f36:	b003      	add	sp, #12
   15f38:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   15f3a:	7e63      	ldrb	r3, [r4, #25]
   15f3c:	3301      	adds	r3, #1
   15f3e:	b2db      	uxtb	r3, r3
   15f40:	2b02      	cmp	r3, #2
   15f42:	7663      	strb	r3, [r4, #25]
   15f44:	f240 80b1 	bls.w	160aa <USBH_SetCfg+0x1ba>
        phost->Control.errorcount = 0U;
   15f48:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   15f4a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   15f4e:	2106      	movs	r1, #6
   15f50:	4620      	mov	r0, r4
   15f52:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15f54:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   15f56:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   15f58:	4620      	mov	r0, r4
   15f5a:	f000 fb27 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   15f5e:	7921      	ldrb	r1, [r4, #4]
   15f60:	4620      	mov	r0, r4
   15f62:	f000 fb23 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   15f66:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   15f68:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   15f6a:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   15f6c:	70a3      	strb	r3, [r4, #2]
   15f6e:	e7c8      	b.n	15f02 <USBH_SetCfg+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   15f70:	7962      	ldrb	r2, [r4, #5]
   15f72:	f104 0110 	add.w	r1, r4, #16
   15f76:	4620      	mov	r0, r4
   15f78:	f000 fa6c 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   15f7c:	2302      	movs	r3, #2
   15f7e:	2001      	movs	r0, #1
   15f80:	7623      	strb	r3, [r4, #24]
   15f82:	e7be      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15f84:	7961      	ldrb	r1, [r4, #5]
   15f86:	4620      	mov	r0, r4
   15f88:	f00d fe88 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15f8c:	2801      	cmp	r0, #1
   15f8e:	f000 8081 	beq.w	16094 <USBH_SetCfg+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   15f92:	2804      	cmp	r0, #4
   15f94:	d001      	beq.n	15f9a <USBH_SetCfg+0xaa>
   15f96:	2802      	cmp	r0, #2
   15f98:	d1b2      	bne.n	15f00 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
   15f9a:	230b      	movs	r3, #11
   15f9c:	2001      	movs	r0, #1
   15f9e:	7623      	strb	r3, [r4, #24]
   15fa0:	e7af      	b.n	15f02 <USBH_SetCfg+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   15fa2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15fa6:	4620      	mov	r0, r4
   15fa8:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   15faa:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   15fac:	68a1      	ldr	r1, [r4, #8]
   15fae:	89a2      	ldrh	r2, [r4, #12]
   15fb0:	f000 fa78 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   15fb4:	2304      	movs	r3, #4
   15fb6:	2001      	movs	r0, #1
   15fb8:	7623      	strb	r3, [r4, #24]
   15fba:	e7a2      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   15fbc:	7921      	ldrb	r1, [r4, #4]
   15fbe:	4620      	mov	r0, r4
   15fc0:	f00d fe6c 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15fc4:	2801      	cmp	r0, #1
   15fc6:	d059      	beq.n	1607c <USBH_SetCfg+0x18c>
      if (URB_Status == USBH_URB_STALL)
   15fc8:	2805      	cmp	r0, #5
   15fca:	d039      	beq.n	16040 <USBH_SetCfg+0x150>
        if (URB_Status == USBH_URB_ERROR)
   15fcc:	2804      	cmp	r0, #4
   15fce:	d197      	bne.n	15f00 <USBH_SetCfg+0x10>
   15fd0:	e7e3      	b.n	15f9a <USBH_SetCfg+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   15fd2:	2501      	movs	r5, #1
   15fd4:	7963      	ldrb	r3, [r4, #5]
   15fd6:	89a2      	ldrh	r2, [r4, #12]
   15fd8:	4620      	mov	r0, r4
   15fda:	68a1      	ldr	r1, [r4, #8]
   15fdc:	9500      	str	r5, [sp, #0]
   15fde:	f000 fa49 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   15fe2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15fe6:	2306      	movs	r3, #6
   15fe8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   15fea:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   15fec:	7623      	strb	r3, [r4, #24]
   15fee:	e788      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   15ff0:	7961      	ldrb	r1, [r4, #5]
   15ff2:	4620      	mov	r0, r4
   15ff4:	f00d fe52 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   15ff8:	2801      	cmp	r0, #1
   15ffa:	d047      	beq.n	1608c <USBH_SetCfg+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   15ffc:	2805      	cmp	r0, #5
   15ffe:	d01f      	beq.n	16040 <USBH_SetCfg+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   16000:	2802      	cmp	r0, #2
   16002:	d04e      	beq.n	160a2 <USBH_SetCfg+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   16004:	2804      	cmp	r0, #4
   16006:	f47f af7b 	bne.w	15f00 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
   1600a:	230b      	movs	r3, #11
   1600c:	7623      	strb	r3, [r4, #24]
   1600e:	e7ab      	b.n	15f68 <USBH_SetCfg+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   16010:	2200      	movs	r2, #0
   16012:	7923      	ldrb	r3, [r4, #4]
   16014:	4620      	mov	r0, r4
   16016:	4611      	mov	r1, r2
   16018:	f000 fa44 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1601c:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   16020:	2308      	movs	r3, #8
   16022:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   16024:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   16026:	7623      	strb	r3, [r4, #24]
   16028:	e76b      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   1602a:	7921      	ldrb	r1, [r4, #4]
   1602c:	4620      	mov	r0, r4
   1602e:	f00d fe35 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16032:	2801      	cmp	r0, #1
   16034:	d026      	beq.n	16084 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   16036:	2804      	cmp	r0, #4
   16038:	d0af      	beq.n	15f9a <USBH_SetCfg+0xaa>
        if (URB_Status == USBH_URB_STALL)
   1603a:	2805      	cmp	r0, #5
   1603c:	f47f af60 	bne.w	15f00 <USBH_SetCfg+0x10>
        status = USBH_NOT_SUPPORTED;
   16040:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   16042:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   16044:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   16046:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   16048:	7623      	strb	r3, [r4, #24]
}
   1604a:	b003      	add	sp, #12
   1604c:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1604e:	2200      	movs	r2, #0
   16050:	2501      	movs	r5, #1
   16052:	7963      	ldrb	r3, [r4, #5]
   16054:	4620      	mov	r0, r4
   16056:	4611      	mov	r1, r2
   16058:	9500      	str	r5, [sp, #0]
   1605a:	f000 fa0b 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1605e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16062:	230a      	movs	r3, #10
   16064:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16066:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16068:	7623      	strb	r3, [r4, #24]
   1606a:	e74a      	b.n	15f02 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1606c:	7961      	ldrb	r1, [r4, #5]
   1606e:	4620      	mov	r0, r4
   16070:	f00d fe14 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16074:	2801      	cmp	r0, #1
   16076:	d005      	beq.n	16084 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   16078:	2802      	cmp	r0, #2
   1607a:	d1a7      	bne.n	15fcc <USBH_SetCfg+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   1607c:	2309      	movs	r3, #9
   1607e:	2001      	movs	r0, #1
   16080:	7623      	strb	r3, [r4, #24]
   16082:	e73e      	b.n	15f02 <USBH_SetCfg+0x12>
        status = USBH_OK;
   16084:	2000      	movs	r0, #0
   16086:	e7dc      	b.n	16042 <USBH_SetCfg+0x152>
          if (direction == USB_D2H)
   16088:	2a00      	cmp	r2, #0
   1608a:	dbf7      	blt.n	1607c <USBH_SetCfg+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   1608c:	2307      	movs	r3, #7
   1608e:	2001      	movs	r0, #1
   16090:	7623      	strb	r3, [r4, #24]
   16092:	e736      	b.n	15f02 <USBH_SetCfg+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   16094:	8ae3      	ldrh	r3, [r4, #22]
   16096:	f994 2010 	ldrsb.w	r2, [r4, #16]
   1609a:	2b00      	cmp	r3, #0
   1609c:	d0f4      	beq.n	16088 <USBH_SetCfg+0x198>
          if (direction == USB_D2H)
   1609e:	2a00      	cmp	r2, #0
   160a0:	db08      	blt.n	160b4 <USBH_SetCfg+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   160a2:	2305      	movs	r3, #5
   160a4:	2001      	movs	r0, #1
   160a6:	7623      	strb	r3, [r4, #24]
   160a8:	e72b      	b.n	15f02 <USBH_SetCfg+0x12>
        phost->Control.state = CTRL_SETUP;
   160aa:	2301      	movs	r3, #1
   160ac:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   160ae:	4618      	mov	r0, r3
   160b0:	70a3      	strb	r3, [r4, #2]
   160b2:	e726      	b.n	15f02 <USBH_SetCfg+0x12>
            phost->Control.state = CTRL_DATA_IN;
   160b4:	2303      	movs	r3, #3
   160b6:	7623      	strb	r3, [r4, #24]
   160b8:	e723      	b.n	15f02 <USBH_SetCfg+0x12>
   160ba:	bf00      	nop

000160bc <USBH_SetFeature>:
{
   160bc:	b530      	push	{r4, r5, lr}
   160be:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   160c0:	7880      	ldrb	r0, [r0, #2]
{
   160c2:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   160c4:	2801      	cmp	r0, #1
   160c6:	d011      	beq.n	160ec <USBH_SetFeature+0x30>
  switch (phost->RequestState)
   160c8:	2802      	cmp	r0, #2
   160ca:	d002      	beq.n	160d2 <USBH_SetFeature+0x16>
  status = USBH_BUSY;
   160cc:	2001      	movs	r0, #1
}
   160ce:	b003      	add	sp, #12
   160d0:	bd30      	pop	{r4, r5, pc}
   160d2:	461c      	mov	r4, r3
  switch (phost->Control.state)
   160d4:	7e1b      	ldrb	r3, [r3, #24]
   160d6:	3b01      	subs	r3, #1
   160d8:	2b0a      	cmp	r3, #10
   160da:	d8f7      	bhi.n	160cc <USBH_SetFeature+0x10>
   160dc:	e8df f003 	tbb	[pc, r3]
   160e0:	5447382e 	.word	0x5447382e
   160e4:	8b7e6e5f 	.word	0x8b7e6e5f
   160e8:	ac9d      	.short	0xac9d
   160ea:	13          	.byte	0x13
   160eb:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
   160ec:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   160ee:	f44f 7540 	mov.w	r5, #768	; 0x300
      phost->RequestState = CMD_WAIT;
   160f2:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = wValue;
   160f4:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
   160f6:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
   160f8:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
   160fa:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
   160fc:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   160fe:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   16100:	709c      	strb	r4, [r3, #2]
}
   16102:	b003      	add	sp, #12
   16104:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   16106:	7e63      	ldrb	r3, [r4, #25]
   16108:	3301      	adds	r3, #1
   1610a:	b2db      	uxtb	r3, r3
   1610c:	2b02      	cmp	r3, #2
   1610e:	7663      	strb	r3, [r4, #25]
   16110:	f240 80b1 	bls.w	16276 <USBH_SetFeature+0x1ba>
        phost->Control.errorcount = 0U;
   16114:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   16116:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   1611a:	2106      	movs	r1, #6
   1611c:	4620      	mov	r0, r4
   1611e:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   16120:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   16122:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   16124:	4620      	mov	r0, r4
   16126:	f000 fa41 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   1612a:	7921      	ldrb	r1, [r4, #4]
   1612c:	4620      	mov	r0, r4
   1612e:	f000 fa3d 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   16132:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   16134:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   16136:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   16138:	70a3      	strb	r3, [r4, #2]
   1613a:	e7c8      	b.n	160ce <USBH_SetFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   1613c:	7962      	ldrb	r2, [r4, #5]
   1613e:	f104 0110 	add.w	r1, r4, #16
   16142:	4620      	mov	r0, r4
   16144:	f000 f986 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   16148:	2302      	movs	r3, #2
   1614a:	2001      	movs	r0, #1
   1614c:	7623      	strb	r3, [r4, #24]
   1614e:	e7be      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16150:	7961      	ldrb	r1, [r4, #5]
   16152:	4620      	mov	r0, r4
   16154:	f00d fda2 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16158:	2801      	cmp	r0, #1
   1615a:	f000 8081 	beq.w	16260 <USBH_SetFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   1615e:	2804      	cmp	r0, #4
   16160:	d001      	beq.n	16166 <USBH_SetFeature+0xaa>
   16162:	2802      	cmp	r0, #2
   16164:	d1b2      	bne.n	160cc <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   16166:	230b      	movs	r3, #11
   16168:	2001      	movs	r0, #1
   1616a:	7623      	strb	r3, [r4, #24]
   1616c:	e7af      	b.n	160ce <USBH_SetFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   1616e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16172:	4620      	mov	r0, r4
   16174:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   16176:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16178:	68a1      	ldr	r1, [r4, #8]
   1617a:	89a2      	ldrh	r2, [r4, #12]
   1617c:	f000 f992 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   16180:	2304      	movs	r3, #4
   16182:	2001      	movs	r0, #1
   16184:	7623      	strb	r3, [r4, #24]
   16186:	e7a2      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   16188:	7921      	ldrb	r1, [r4, #4]
   1618a:	4620      	mov	r0, r4
   1618c:	f00d fd86 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16190:	2801      	cmp	r0, #1
   16192:	d059      	beq.n	16248 <USBH_SetFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
   16194:	2805      	cmp	r0, #5
   16196:	d039      	beq.n	1620c <USBH_SetFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
   16198:	2804      	cmp	r0, #4
   1619a:	d197      	bne.n	160cc <USBH_SetFeature+0x10>
   1619c:	e7e3      	b.n	16166 <USBH_SetFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1619e:	2501      	movs	r5, #1
   161a0:	7963      	ldrb	r3, [r4, #5]
   161a2:	89a2      	ldrh	r2, [r4, #12]
   161a4:	4620      	mov	r0, r4
   161a6:	68a1      	ldr	r1, [r4, #8]
   161a8:	9500      	str	r5, [sp, #0]
   161aa:	f000 f963 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   161ae:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   161b2:	2306      	movs	r3, #6
   161b4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   161b6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   161b8:	7623      	strb	r3, [r4, #24]
   161ba:	e788      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   161bc:	7961      	ldrb	r1, [r4, #5]
   161be:	4620      	mov	r0, r4
   161c0:	f00d fd6c 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   161c4:	2801      	cmp	r0, #1
   161c6:	d047      	beq.n	16258 <USBH_SetFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   161c8:	2805      	cmp	r0, #5
   161ca:	d01f      	beq.n	1620c <USBH_SetFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   161cc:	2802      	cmp	r0, #2
   161ce:	d04e      	beq.n	1626e <USBH_SetFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   161d0:	2804      	cmp	r0, #4
   161d2:	f47f af7b 	bne.w	160cc <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   161d6:	230b      	movs	r3, #11
   161d8:	7623      	strb	r3, [r4, #24]
   161da:	e7ab      	b.n	16134 <USBH_SetFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   161dc:	2200      	movs	r2, #0
   161de:	7923      	ldrb	r3, [r4, #4]
   161e0:	4620      	mov	r0, r4
   161e2:	4611      	mov	r1, r2
   161e4:	f000 f95e 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   161e8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   161ec:	2308      	movs	r3, #8
   161ee:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   161f0:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   161f2:	7623      	strb	r3, [r4, #24]
   161f4:	e76b      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   161f6:	7921      	ldrb	r1, [r4, #4]
   161f8:	4620      	mov	r0, r4
   161fa:	f00d fd4f 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   161fe:	2801      	cmp	r0, #1
   16200:	d026      	beq.n	16250 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   16202:	2804      	cmp	r0, #4
   16204:	d0af      	beq.n	16166 <USBH_SetFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
   16206:	2805      	cmp	r0, #5
   16208:	f47f af60 	bne.w	160cc <USBH_SetFeature+0x10>
        status = USBH_NOT_SUPPORTED;
   1620c:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   1620e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   16210:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   16212:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   16214:	7623      	strb	r3, [r4, #24]
}
   16216:	b003      	add	sp, #12
   16218:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   1621a:	2200      	movs	r2, #0
   1621c:	2501      	movs	r5, #1
   1621e:	7963      	ldrb	r3, [r4, #5]
   16220:	4620      	mov	r0, r4
   16222:	4611      	mov	r1, r2
   16224:	9500      	str	r5, [sp, #0]
   16226:	f000 f925 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1622a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   1622e:	230a      	movs	r3, #10
   16230:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16232:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16234:	7623      	strb	r3, [r4, #24]
   16236:	e74a      	b.n	160ce <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16238:	7961      	ldrb	r1, [r4, #5]
   1623a:	4620      	mov	r0, r4
   1623c:	f00d fd2e 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16240:	2801      	cmp	r0, #1
   16242:	d005      	beq.n	16250 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   16244:	2802      	cmp	r0, #2
   16246:	d1a7      	bne.n	16198 <USBH_SetFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   16248:	2309      	movs	r3, #9
   1624a:	2001      	movs	r0, #1
   1624c:	7623      	strb	r3, [r4, #24]
   1624e:	e73e      	b.n	160ce <USBH_SetFeature+0x12>
        status = USBH_OK;
   16250:	2000      	movs	r0, #0
   16252:	e7dc      	b.n	1620e <USBH_SetFeature+0x152>
          if (direction == USB_D2H)
   16254:	2a00      	cmp	r2, #0
   16256:	dbf7      	blt.n	16248 <USBH_SetFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   16258:	2307      	movs	r3, #7
   1625a:	2001      	movs	r0, #1
   1625c:	7623      	strb	r3, [r4, #24]
   1625e:	e736      	b.n	160ce <USBH_SetFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   16260:	8ae3      	ldrh	r3, [r4, #22]
   16262:	f994 2010 	ldrsb.w	r2, [r4, #16]
   16266:	2b00      	cmp	r3, #0
   16268:	d0f4      	beq.n	16254 <USBH_SetFeature+0x198>
          if (direction == USB_D2H)
   1626a:	2a00      	cmp	r2, #0
   1626c:	db08      	blt.n	16280 <USBH_SetFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   1626e:	2305      	movs	r3, #5
   16270:	2001      	movs	r0, #1
   16272:	7623      	strb	r3, [r4, #24]
   16274:	e72b      	b.n	160ce <USBH_SetFeature+0x12>
        phost->Control.state = CTRL_SETUP;
   16276:	2301      	movs	r3, #1
   16278:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   1627a:	4618      	mov	r0, r3
   1627c:	70a3      	strb	r3, [r4, #2]
   1627e:	e726      	b.n	160ce <USBH_SetFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
   16280:	2303      	movs	r3, #3
   16282:	7623      	strb	r3, [r4, #24]
   16284:	e723      	b.n	160ce <USBH_SetFeature+0x12>
   16286:	bf00      	nop

00016288 <USBH_ClrFeature>:
{
   16288:	b530      	push	{r4, r5, lr}
   1628a:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
   1628c:	7880      	ldrb	r0, [r0, #2]
{
   1628e:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
   16290:	2801      	cmp	r0, #1
   16292:	d011      	beq.n	162b8 <USBH_ClrFeature+0x30>
  switch (phost->RequestState)
   16294:	2802      	cmp	r0, #2
   16296:	d002      	beq.n	1629e <USBH_ClrFeature+0x16>
  status = USBH_BUSY;
   16298:	2001      	movs	r0, #1
}
   1629a:	b003      	add	sp, #12
   1629c:	bd30      	pop	{r4, r5, pc}
   1629e:	461c      	mov	r4, r3
  switch (phost->Control.state)
   162a0:	7e1b      	ldrb	r3, [r3, #24]
   162a2:	3b01      	subs	r3, #1
   162a4:	2b0a      	cmp	r3, #10
   162a6:	d8f7      	bhi.n	16298 <USBH_ClrFeature+0x10>
   162a8:	e8df f003 	tbb	[pc, r3]
   162ac:	5447382e 	.word	0x5447382e
   162b0:	8b7e6e5f 	.word	0x8b7e6e5f
   162b4:	ac9d      	.short	0xac9d
   162b6:	13          	.byte	0x13
   162b7:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = 0U;
   162b8:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
   162ba:	f44f 7581 	mov.w	r5, #258	; 0x102
      phost->RequestState = CMD_WAIT;
   162be:	2402      	movs	r4, #2
    phost->Control.setup.b.wIndex.w = ep_num;
   162c0:	8299      	strh	r1, [r3, #20]
      phost->Control.state = CTRL_SETUP;
   162c2:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
   162c4:	611d      	str	r5, [r3, #16]
    phost->Control.setup.b.wLength.w = 0U;
   162c6:	82da      	strh	r2, [r3, #22]
      phost->Control.buff = buff;
   162c8:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
   162ca:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
   162cc:	709c      	strb	r4, [r3, #2]
}
   162ce:	b003      	add	sp, #12
   162d0:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   162d2:	7e63      	ldrb	r3, [r4, #25]
   162d4:	3301      	adds	r3, #1
   162d6:	b2db      	uxtb	r3, r3
   162d8:	2b02      	cmp	r3, #2
   162da:	7663      	strb	r3, [r4, #25]
   162dc:	f240 80b1 	bls.w	16442 <USBH_ClrFeature+0x1ba>
        phost->Control.errorcount = 0U;
   162e0:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
   162e2:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
   162e6:	2106      	movs	r1, #6
   162e8:	4620      	mov	r0, r4
   162ea:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
   162ec:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
   162ee:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
   162f0:	4620      	mov	r0, r4
   162f2:	f000 f95b 	bl	165ac <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
   162f6:	7921      	ldrb	r1, [r4, #4]
   162f8:	4620      	mov	r0, r4
   162fa:	f000 f957 	bl	165ac <USBH_FreePipe>
        phost->gState = HOST_IDLE;
   162fe:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
   16300:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
   16302:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
   16304:	70a3      	strb	r3, [r4, #2]
   16306:	e7c8      	b.n	1629a <USBH_ClrFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
   16308:	7962      	ldrb	r2, [r4, #5]
   1630a:	f104 0110 	add.w	r1, r4, #16
   1630e:	4620      	mov	r0, r4
   16310:	f000 f8a0 	bl	16454 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
   16314:	2302      	movs	r3, #2
   16316:	2001      	movs	r0, #1
   16318:	7623      	strb	r3, [r4, #24]
   1631a:	e7be      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   1631c:	7961      	ldrb	r1, [r4, #5]
   1631e:	4620      	mov	r0, r4
   16320:	f00d fcbc 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16324:	2801      	cmp	r0, #1
   16326:	f000 8081 	beq.w	1642c <USBH_ClrFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
   1632a:	2804      	cmp	r0, #4
   1632c:	d001      	beq.n	16332 <USBH_ClrFeature+0xaa>
   1632e:	2802      	cmp	r0, #2
   16330:	d1b2      	bne.n	16298 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   16332:	230b      	movs	r3, #11
   16334:	2001      	movs	r0, #1
   16336:	7623      	strb	r3, [r4, #24]
   16338:	e7af      	b.n	1629a <USBH_ClrFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
   1633a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   1633e:	4620      	mov	r0, r4
   16340:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
   16342:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
   16344:	68a1      	ldr	r1, [r4, #8]
   16346:	89a2      	ldrh	r2, [r4, #12]
   16348:	f000 f8ac 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
   1634c:	2304      	movs	r3, #4
   1634e:	2001      	movs	r0, #1
   16350:	7623      	strb	r3, [r4, #24]
   16352:	e7a2      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   16354:	7921      	ldrb	r1, [r4, #4]
   16356:	4620      	mov	r0, r4
   16358:	f00d fca0 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1635c:	2801      	cmp	r0, #1
   1635e:	d059      	beq.n	16414 <USBH_ClrFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
   16360:	2805      	cmp	r0, #5
   16362:	d039      	beq.n	163d8 <USBH_ClrFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
   16364:	2804      	cmp	r0, #4
   16366:	d197      	bne.n	16298 <USBH_ClrFeature+0x10>
   16368:	e7e3      	b.n	16332 <USBH_ClrFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
   1636a:	2501      	movs	r5, #1
   1636c:	7963      	ldrb	r3, [r4, #5]
   1636e:	89a2      	ldrh	r2, [r4, #12]
   16370:	4620      	mov	r0, r4
   16372:	68a1      	ldr	r1, [r4, #8]
   16374:	9500      	str	r5, [sp, #0]
   16376:	f000 f87d 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   1637a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   1637e:	2306      	movs	r3, #6
   16380:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   16382:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
   16384:	7623      	strb	r3, [r4, #24]
   16386:	e788      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16388:	7961      	ldrb	r1, [r4, #5]
   1638a:	4620      	mov	r0, r4
   1638c:	f00d fc86 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   16390:	2801      	cmp	r0, #1
   16392:	d047      	beq.n	16424 <USBH_ClrFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
   16394:	2805      	cmp	r0, #5
   16396:	d01f      	beq.n	163d8 <USBH_ClrFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
   16398:	2802      	cmp	r0, #2
   1639a:	d04e      	beq.n	1643a <USBH_ClrFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
   1639c:	2804      	cmp	r0, #4
   1639e:	f47f af7b 	bne.w	16298 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
   163a2:	230b      	movs	r3, #11
   163a4:	7623      	strb	r3, [r4, #24]
   163a6:	e7ab      	b.n	16300 <USBH_ClrFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
   163a8:	2200      	movs	r2, #0
   163aa:	7923      	ldrb	r3, [r4, #4]
   163ac:	4620      	mov	r0, r4
   163ae:	4611      	mov	r1, r2
   163b0:	f000 f878 	bl	164a4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
   163b4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   163b8:	2308      	movs	r3, #8
   163ba:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
   163bc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
   163be:	7623      	strb	r3, [r4, #24]
   163c0:	e76b      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
   163c2:	7921      	ldrb	r1, [r4, #4]
   163c4:	4620      	mov	r0, r4
   163c6:	f00d fc69 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   163ca:	2801      	cmp	r0, #1
   163cc:	d026      	beq.n	1641c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
   163ce:	2804      	cmp	r0, #4
   163d0:	d0af      	beq.n	16332 <USBH_ClrFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
   163d2:	2805      	cmp	r0, #5
   163d4:	f47f af60 	bne.w	16298 <USBH_ClrFeature+0x10>
        status = USBH_NOT_SUPPORTED;
   163d8:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
   163da:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
   163dc:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
   163de:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
   163e0:	7623      	strb	r3, [r4, #24]
}
   163e2:	b003      	add	sp, #12
   163e4:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
   163e6:	2200      	movs	r2, #0
   163e8:	2501      	movs	r5, #1
   163ea:	7963      	ldrb	r3, [r4, #5]
   163ec:	4620      	mov	r0, r4
   163ee:	4611      	mov	r1, r2
   163f0:	9500      	str	r5, [sp, #0]
   163f2:	f000 f83f 	bl	16474 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
   163f6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   163fa:	230a      	movs	r3, #10
   163fc:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
   163fe:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
   16400:	7623      	strb	r3, [r4, #24]
   16402:	e74a      	b.n	1629a <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
   16404:	7961      	ldrb	r1, [r4, #5]
   16406:	4620      	mov	r0, r4
   16408:	f00d fc48 	bl	23c9c <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
   1640c:	2801      	cmp	r0, #1
   1640e:	d005      	beq.n	1641c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
   16410:	2802      	cmp	r0, #2
   16412:	d1a7      	bne.n	16364 <USBH_ClrFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
   16414:	2309      	movs	r3, #9
   16416:	2001      	movs	r0, #1
   16418:	7623      	strb	r3, [r4, #24]
   1641a:	e73e      	b.n	1629a <USBH_ClrFeature+0x12>
        status = USBH_OK;
   1641c:	2000      	movs	r0, #0
   1641e:	e7dc      	b.n	163da <USBH_ClrFeature+0x152>
          if (direction == USB_D2H)
   16420:	2a00      	cmp	r2, #0
   16422:	dbf7      	blt.n	16414 <USBH_ClrFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
   16424:	2307      	movs	r3, #7
   16426:	2001      	movs	r0, #1
   16428:	7623      	strb	r3, [r4, #24]
   1642a:	e736      	b.n	1629a <USBH_ClrFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
   1642c:	8ae3      	ldrh	r3, [r4, #22]
   1642e:	f994 2010 	ldrsb.w	r2, [r4, #16]
   16432:	2b00      	cmp	r3, #0
   16434:	d0f4      	beq.n	16420 <USBH_ClrFeature+0x198>
          if (direction == USB_D2H)
   16436:	2a00      	cmp	r2, #0
   16438:	db08      	blt.n	1644c <USBH_ClrFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
   1643a:	2305      	movs	r3, #5
   1643c:	2001      	movs	r0, #1
   1643e:	7623      	strb	r3, [r4, #24]
   16440:	e72b      	b.n	1629a <USBH_ClrFeature+0x12>
        phost->Control.state = CTRL_SETUP;
   16442:	2301      	movs	r3, #1
   16444:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
   16446:	4618      	mov	r0, r3
   16448:	70a3      	strb	r3, [r4, #2]
   1644a:	e726      	b.n	1629a <USBH_ClrFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
   1644c:	2303      	movs	r3, #3
   1644e:	7623      	strb	r3, [r4, #24]
   16450:	e723      	b.n	1629a <USBH_ClrFeature+0x12>
   16452:	bf00      	nop

00016454 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
   16454:	b530      	push	{r4, r5, lr}

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   16456:	2400      	movs	r4, #0
{
   16458:	b085      	sub	sp, #20
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   1645a:	2508      	movs	r5, #8
   1645c:	9101      	str	r1, [sp, #4]
   1645e:	4623      	mov	r3, r4
   16460:	4611      	mov	r1, r2
   16462:	9403      	str	r4, [sp, #12]
   16464:	9400      	str	r4, [sp, #0]
   16466:	4622      	mov	r2, r4
   16468:	9502      	str	r5, [sp, #8]
   1646a:	f00d fbfb 	bl	23c64 <USBH_LL_SubmitURB>
                    USBH_PID_SETUP,       /* Type setup       */
                    buff,                 /* data buffer      */
                    USBH_SETUP_PKT_SIZE,  /* data length      */
                    0U);
  return USBH_OK;
}
   1646e:	4620      	mov	r0, r4
   16470:	b005      	add	sp, #20
   16472:	bd30      	pop	{r4, r5, pc}

00016474 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
   16474:	b570      	push	{r4, r5, r6, lr}
  if (phost->device.speed != USBH_SPEED_HIGH)
   16476:	f890 631d 	ldrb.w	r6, [r0, #797]	; 0x31d
{
   1647a:	b084      	sub	sp, #16
   1647c:	461d      	mov	r5, r3
  {
    do_ping = 0U;
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   1647e:	2300      	movs	r3, #0
  if (phost->device.speed != USBH_SPEED_HIGH)
   16480:	2e00      	cmp	r6, #0
{
   16482:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   16486:	f04f 0601 	mov.w	r6, #1
   1648a:	9202      	str	r2, [sp, #8]
    do_ping = 0U;
   1648c:	bf18      	it	ne
   1648e:	461c      	movne	r4, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   16490:	461a      	mov	r2, r3
   16492:	e9cd 6100 	strd	r6, r1, [sp]
   16496:	9403      	str	r4, [sp, #12]
   16498:	4629      	mov	r1, r5
   1649a:	f00d fbe3 	bl	23c64 <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
   1649e:	2000      	movs	r0, #0
   164a0:	b004      	add	sp, #16
   164a2:	bd70      	pop	{r4, r5, r6, pc}

000164a4 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
   164a4:	b570      	push	{r4, r5, r6, lr}
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   164a6:	2400      	movs	r4, #0
{
   164a8:	b084      	sub	sp, #16
   164aa:	461e      	mov	r6, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   164ac:	2501      	movs	r5, #1
   164ae:	4623      	mov	r3, r4
   164b0:	9403      	str	r4, [sp, #12]
   164b2:	9500      	str	r5, [sp, #0]
   164b4:	e9cd 1201 	strd	r1, r2, [sp, #4]
   164b8:	4631      	mov	r1, r6
   164ba:	462a      	mov	r2, r5
   164bc:	f00d fbd2 	bl	23c64 <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;

}
   164c0:	4620      	mov	r0, r4
   164c2:	b004      	add	sp, #16
   164c4:	bd70      	pop	{r4, r5, r6, pc}
   164c6:	bf00      	nop

000164c8 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
   164c8:	b570      	push	{r4, r5, r6, lr}
   164ca:	461e      	mov	r6, r3
   164cc:	b084      	sub	sp, #16
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
   164ce:	2400      	movs	r4, #0
   164d0:	2501      	movs	r5, #1
   164d2:	2302      	movs	r3, #2
   164d4:	9403      	str	r4, [sp, #12]
   164d6:	9500      	str	r5, [sp, #0]
   164d8:	e9cd 1201 	strd	r1, r2, [sp, #4]
   164dc:	4631      	mov	r1, r6
   164de:	462a      	mov	r2, r5
   164e0:	f00d fbc0 	bl	23c64 <USBH_LL_SubmitURB>
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
}
   164e4:	4620      	mov	r0, r4
   164e6:	b004      	add	sp, #16
   164e8:	bd70      	pop	{r4, r5, r6, pc}
   164ea:	bf00      	nop

000164ec <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
   164ec:	b530      	push	{r4, r5, lr}
   164ee:	b085      	sub	sp, #20
   164f0:	f89d 4020 	ldrb.w	r4, [sp, #32]
   164f4:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
   164f8:	9400      	str	r4, [sp, #0]
{
   164fa:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
   164fe:	e9cd 5401 	strd	r5, r4, [sp, #4]
   16502:	f00d fb87 	bl	23c14 <USBH_LL_OpenPipe>

  return USBH_OK;
}
   16506:	2000      	movs	r0, #0
   16508:	b005      	add	sp, #20
   1650a:	bd30      	pop	{r4, r5, pc}

0001650c <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
   1650c:	b508      	push	{r3, lr}
  USBH_LL_ClosePipe(phost, pipe_num);
   1650e:	f00d fb9b 	bl	23c48 <USBH_LL_ClosePipe>

  return USBH_OK;
}
   16512:	2000      	movs	r0, #0
   16514:	bd08      	pop	{r3, pc}
   16516:	bf00      	nop

00016518 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
   16518:	4603      	mov	r3, r0
{
  uint8_t idx = 0U;

  for (idx = 0U ; idx < 11U ; idx++)
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
   1651a:	f8d0 04f4 	ldr.w	r0, [r0, #1268]	; 0x4f4
   1651e:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
   16522:	d02a      	beq.n	1657a <USBH_AllocPipe+0x62>
   16524:	f8d3 24f8 	ldr.w	r2, [r3, #1272]	; 0x4f8
   16528:	0410      	lsls	r0, r2, #16
   1652a:	d52d      	bpl.n	16588 <USBH_AllocPipe+0x70>
   1652c:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
   16530:	0412      	lsls	r2, r2, #16
   16532:	d52b      	bpl.n	1658c <USBH_AllocPipe+0x74>
   16534:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
   16538:	0410      	lsls	r0, r2, #16
   1653a:	d529      	bpl.n	16590 <USBH_AllocPipe+0x78>
   1653c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   16540:	0412      	lsls	r2, r2, #16
   16542:	d527      	bpl.n	16594 <USBH_AllocPipe+0x7c>
   16544:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
   16548:	0410      	lsls	r0, r2, #16
   1654a:	d525      	bpl.n	16598 <USBH_AllocPipe+0x80>
   1654c:	f8d3 250c 	ldr.w	r2, [r3, #1292]	; 0x50c
   16550:	0412      	lsls	r2, r2, #16
   16552:	d525      	bpl.n	165a0 <USBH_AllocPipe+0x88>
   16554:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   16558:	0410      	lsls	r0, r2, #16
   1655a:	d523      	bpl.n	165a4 <USBH_AllocPipe+0x8c>
   1655c:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
   16560:	0412      	lsls	r2, r2, #16
   16562:	d51b      	bpl.n	1659c <USBH_AllocPipe+0x84>
   16564:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   16568:	0410      	lsls	r0, r2, #16
   1656a:	d505      	bpl.n	16578 <USBH_AllocPipe+0x60>
   1656c:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
   16570:	0412      	lsls	r2, r2, #16
   16572:	d519      	bpl.n	165a8 <USBH_AllocPipe+0x90>
   16574:	20ff      	movs	r0, #255	; 0xff
}
   16576:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
   16578:	2009      	movs	r0, #9
    phost->Pipes[pipe & 0xFU] = 0x8000U | ep_addr;
   1657a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   1657e:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
   16582:	f8c3 14f4 	str.w	r1, [r3, #1268]	; 0x4f4
   16586:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
   16588:	2001      	movs	r0, #1
   1658a:	e7f6      	b.n	1657a <USBH_AllocPipe+0x62>
   1658c:	2002      	movs	r0, #2
   1658e:	e7f4      	b.n	1657a <USBH_AllocPipe+0x62>
   16590:	2003      	movs	r0, #3
   16592:	e7f2      	b.n	1657a <USBH_AllocPipe+0x62>
   16594:	2004      	movs	r0, #4
   16596:	e7f0      	b.n	1657a <USBH_AllocPipe+0x62>
   16598:	2005      	movs	r0, #5
   1659a:	e7ee      	b.n	1657a <USBH_AllocPipe+0x62>
   1659c:	2008      	movs	r0, #8
   1659e:	e7ec      	b.n	1657a <USBH_AllocPipe+0x62>
   165a0:	2006      	movs	r0, #6
   165a2:	e7ea      	b.n	1657a <USBH_AllocPipe+0x62>
   165a4:	2007      	movs	r0, #7
   165a6:	e7e8      	b.n	1657a <USBH_AllocPipe+0x62>
   165a8:	200a      	movs	r0, #10
   165aa:	e7e6      	b.n	1657a <USBH_AllocPipe+0x62>

000165ac <USBH_FreePipe>:
  if (idx < 11U)
   165ac:	290a      	cmp	r1, #10
   165ae:	d807      	bhi.n	165c0 <USBH_FreePipe+0x14>
   165b0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    phost->Pipes[idx] &= 0x7FFFU;
   165b4:	f8d0 34f4 	ldr.w	r3, [r0, #1268]	; 0x4f4
   165b8:	f3c3 030e 	ubfx	r3, r3, #0, #15
   165bc:	f8c0 34f4 	str.w	r3, [r0, #1268]	; 0x4f4
}
   165c0:	2000      	movs	r0, #0
   165c2:	4770      	bx	lr

000165c4 <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
   165c4:	4b11      	ldr	r3, [pc, #68]	; (1660c <FATFS_LinkDriver+0x48>)
   165c6:	7a5a      	ldrb	r2, [r3, #9]
   165c8:	b10a      	cbz	r2, 165ce <FATFS_LinkDriver+0xa>
  uint8_t ret = 1;
   165ca:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
}
   165cc:	4770      	bx	lr
{
   165ce:	b5f0      	push	{r4, r5, r6, r7, lr}
   165d0:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    disk.is_initialized[disk.nbr] = 0;
   165d4:	f893 e009 	ldrb.w	lr, [r3, #9]
    disk.drv[disk.nbr] = drv;
   165d8:	7a5e      	ldrb	r6, [r3, #9]
    path[1] = ':';
   165da:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
    disk.lun[disk.nbr] = lun;
   165de:	7a5d      	ldrb	r5, [r3, #9]
    path[2] = '/';
   165e0:	272f      	movs	r7, #47	; 0x2f
    DiskNum = disk.nbr++;
   165e2:	7a5a      	ldrb	r2, [r3, #9]
    disk.drv[disk.nbr] = drv;
   165e4:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    disk.lun[disk.nbr] = lun;
   165e8:	441d      	add	r5, r3
    disk.is_initialized[disk.nbr] = 0;
   165ea:	f803 400e 	strb.w	r4, [r3, lr]
    DiskNum = disk.nbr++;
   165ee:	b2d2      	uxtb	r2, r2
    disk.drv[disk.nbr] = drv;
   165f0:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
   165f2:	722c      	strb	r4, [r5, #8]
    DiskNum = disk.nbr++;
   165f4:	1c50      	adds	r0, r2, #1
    path[0] = DiskNum + '0';
   165f6:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
   165f8:	b2c0      	uxtb	r0, r0
   165fa:	7258      	strb	r0, [r3, #9]
    path[3] = 0;
   165fc:	4620      	mov	r0, r4
    path[0] = DiskNum + '0';
   165fe:	700a      	strb	r2, [r1, #0]
    path[3] = 0;
   16600:	70cc      	strb	r4, [r1, #3]
    path[1] = ':';
   16602:	f881 c001 	strb.w	ip, [r1, #1]
    path[2] = '/';
   16606:	708f      	strb	r7, [r1, #2]
}
   16608:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1660a:	bf00      	nop
   1660c:	020e30c8 	.word	0x020e30c8

00016610 <MIDI_Application>:
 * @brief  Main routine for MIDI application, looped in main.c
 * @param  None
 * @retval none
 */
void MIDI_Application(void)
{
   16610:	b510      	push	{r4, lr}
	if(Appli_state == APPLICATION_READY)
   16612:	4c15      	ldr	r4, [pc, #84]	; (16668 <MIDI_Application+0x58>)
   16614:	7823      	ldrb	r3, [r4, #0]
   16616:	2b02      	cmp	r3, #2
   16618:	d016      	beq.n	16648 <MIDI_Application+0x38>
	if(Appli_state == APPLICATION_RUNNING)
	{
			//....pffff......grrrrr......
	}

	if(Appli_state == APPLICATION_DISCONNECT)
   1661a:	2b04      	cmp	r3, #4
   1661c:	d000      	beq.n	16620 <MIDI_Application+0x10>
		HAL_Delay(10);
		MX_USB_HOST_Init();

	}

}
   1661e:	bd10      	pop	{r4, pc}
		Appli_state = APPLICATION_IDLE;
   16620:	2300      	movs	r3, #0
		setLED_USB(0);
   16622:	4618      	mov	r0, r3
		Appli_state = APPLICATION_IDLE;
   16624:	7023      	strb	r3, [r4, #0]
		setLED_USB(0);
   16626:	f002 ff5b 	bl	194e0 <setLED_USB>
		USBH_MIDI_Stop(&hUsbHostFS);
   1662a:	4810      	ldr	r0, [pc, #64]	; (1666c <MIDI_Application+0x5c>)
   1662c:	f00d fa1e 	bl	23a6c <USBH_MIDI_Stop>
		HAL_Delay(10);
   16630:	200a      	movs	r0, #10
   16632:	f7f1 fee5 	bl	8400 <HAL_Delay>
		MX_USB_HOST_DeInit();
   16636:	f00d f8a7 	bl	23788 <MX_USB_HOST_DeInit>
		HAL_Delay(10);
   1663a:	200a      	movs	r0, #10
   1663c:	f7f1 fee0 	bl	8400 <HAL_Delay>
}
   16640:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		MX_USB_HOST_Init();
   16644:	f00d b87e 	b.w	23744 <MX_USB_HOST_Init>
		USBH_MIDI_Receive(&hUsbHostFS, MIDI_RX_Buffer[MIDI_write_buffer], RX_BUFF_SIZE); // just once at the beginning, start the first reception
   16648:	4909      	ldr	r1, [pc, #36]	; (16670 <MIDI_Application+0x60>)
   1664a:	2240      	movs	r2, #64	; 0x40
   1664c:	4b09      	ldr	r3, [pc, #36]	; (16674 <MIDI_Application+0x64>)
   1664e:	7809      	ldrb	r1, [r1, #0]
   16650:	4806      	ldr	r0, [pc, #24]	; (1666c <MIDI_Application+0x5c>)
   16652:	eb03 1181 	add.w	r1, r3, r1, lsl #6
   16656:	f00d fa1f 	bl	23a98 <USBH_MIDI_Receive>
		Appli_state = APPLICATION_RUNNING;
   1665a:	2303      	movs	r3, #3
		setLED_USB(1);
   1665c:	2001      	movs	r0, #1
		Appli_state = APPLICATION_RUNNING;
   1665e:	7023      	strb	r3, [r4, #0]
		setLED_USB(1);
   16660:	f002 ff3e 	bl	194e0 <setLED_USB>
   16664:	7823      	ldrb	r3, [r4, #0]
   16666:	e7d8      	b.n	1661a <MIDI_Application+0xa>
   16668:	020e325c 	.word	0x020e325c
   1666c:	00063de0 	.word	0x00063de0
   16670:	0006289c 	.word	0x0006289c
   16674:	00062d40 	.word	0x00062d40

00016678 <ProcessReceivedMidiDatas>:

}
volatile testInt = 0;
/*-----------------------------------------------------------------------------*/
void ProcessReceivedMidiDatas(void)
{
   16678:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t miniBufferPosition = 0;
	uint8_t processed = 0;
   1667c:	2500      	movs	r5, #0
   1667e:	4c3a      	ldr	r4, [pc, #232]	; (16768 <ProcessReceivedMidiDatas+0xf0>)
   16680:	4f3a      	ldr	r7, [pc, #232]	; (1676c <ProcessReceivedMidiDatas+0xf4>)
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   16682:	f8df 8108 	ldr.w	r8, [pc, #264]	; 1678c <ProcessReceivedMidiDatas+0x114>
			(processed < 32)) // maximum notes to process in a frame * 4
	{

		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   16686:	f8df 9108 	ldr.w	r9, [pc, #264]	; 16790 <ProcessReceivedMidiDatas+0x118>
   1668a:	4e39      	ldr	r6, [pc, #228]	; (16770 <ProcessReceivedMidiDatas+0xf8>)
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   1668c:	e008      	b.n	166a0 <ProcessReceivedMidiDatas+0x28>
		myUSB_FIFO_readPointer++;
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
		{
			parse_MIDI_Message();
		}
		if (myUSB_FIFO_readPointer >= USB_FIFO_SIZE)
   1668e:	8823      	ldrh	r3, [r4, #0]
   16690:	2bff      	cmp	r3, #255	; 0xff
   16692:	d903      	bls.n	1669c <ProcessReceivedMidiDatas+0x24>
		{
			myUSB_FIFO_overflowBit = 0;
   16694:	2300      	movs	r3, #0
   16696:	f888 3000 	strb.w	r3, [r8]
			myUSB_FIFO_readPointer = 0;
   1669a:	8023      	strh	r3, [r4, #0]
		}
		processed++;
   1669c:	3501      	adds	r5, #1
   1669e:	b2ed      	uxtb	r5, r5
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
   166a0:	883b      	ldrh	r3, [r7, #0]
   166a2:	8822      	ldrh	r2, [r4, #0]
   166a4:	429a      	cmp	r2, r3
   166a6:	d303      	bcc.n	166b0 <ProcessReceivedMidiDatas+0x38>
   166a8:	f898 3000 	ldrb.w	r3, [r8]
   166ac:	2b00      	cmp	r3, #0
   166ae:	d04c      	beq.n	1674a <ProcessReceivedMidiDatas+0xd2>
   166b0:	2d20      	cmp	r5, #32
   166b2:	d04e      	beq.n	16752 <ProcessReceivedMidiDatas+0xda>
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
   166b4:	8822      	ldrh	r2, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166b6:	8823      	ldrh	r3, [r4, #0]
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
   166b8:	f002 0203 	and.w	r2, r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166bc:	b29b      	uxth	r3, r3
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
   166be:	2a03      	cmp	r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166c0:	f819 1003 	ldrb.w	r1, [r9, r3]
		myUSB_FIFO_readPointer++;
   166c4:	8823      	ldrh	r3, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
   166c6:	54b1      	strb	r1, [r6, r2]
		myUSB_FIFO_readPointer++;
   166c8:	f103 0301 	add.w	r3, r3, #1
   166cc:	b29b      	uxth	r3, r3
   166ce:	8023      	strh	r3, [r4, #0]
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
   166d0:	d1dd      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
	switch(USB_message[1])
   166d2:	7873      	ldrb	r3, [r6, #1]
   166d4:	2b90      	cmp	r3, #144	; 0x90
   166d6:	d01a      	beq.n	1670e <ProcessReceivedMidiDatas+0x96>
   166d8:	d90a      	bls.n	166f0 <ProcessReceivedMidiDatas+0x78>
   166da:	2bb0      	cmp	r3, #176	; 0xb0
   166dc:	d024      	beq.n	16728 <ProcessReceivedMidiDatas+0xb0>
   166de:	2be0      	cmp	r3, #224	; 0xe0
   166e0:	d1d5      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
			pitchBend((USB_message[2]) + (USB_message[3] << 7));
   166e2:	78f0      	ldrb	r0, [r6, #3]
   166e4:	78b3      	ldrb	r3, [r6, #2]
   166e6:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
   166ea:	f00b f82d 	bl	21748 <pitchBend>
   166ee:	e7ce      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
	switch(USB_message[1])
   166f0:	2b80      	cmp	r3, #128	; 0x80
   166f2:	d1cc      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
			key = USB_message[2];
   166f4:	78b2      	ldrb	r2, [r6, #2]
			velocity = USB_message[3];
   166f6:	78f3      	ldrb	r3, [r6, #3]
			key = USB_message[2];
   166f8:	491e      	ldr	r1, [pc, #120]	; (16774 <ProcessReceivedMidiDatas+0xfc>)
			noteOff(key, velocity);
   166fa:	4610      	mov	r0, r2
			velocity = USB_message[3];
   166fc:	f8df c094 	ldr.w	ip, [pc, #148]	; 16794 <ProcessReceivedMidiDatas+0x11c>
			key = USB_message[2];
   16700:	700a      	strb	r2, [r1, #0]
			noteOff(key, velocity);
   16702:	4619      	mov	r1, r3
			velocity = USB_message[3];
   16704:	f88c 3000 	strb.w	r3, [ip]
			noteOff(key, velocity);
   16708:	f00a fe16 	bl	21338 <noteOff>
   1670c:	e7bf      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
			key = USB_message[2];
   1670e:	78b2      	ldrb	r2, [r6, #2]
			velocity = USB_message[3];
   16710:	78f3      	ldrb	r3, [r6, #3]
			key = USB_message[2];
   16712:	4918      	ldr	r1, [pc, #96]	; (16774 <ProcessReceivedMidiDatas+0xfc>)
			noteOn(key, velocity);
   16714:	4610      	mov	r0, r2
			velocity = USB_message[3];
   16716:	f8df c07c 	ldr.w	ip, [pc, #124]	; 16794 <ProcessReceivedMidiDatas+0x11c>
			key = USB_message[2];
   1671a:	700a      	strb	r2, [r1, #0]
			noteOn(key, velocity);
   1671c:	4619      	mov	r1, r3
			velocity = USB_message[3];
   1671e:	f88c 3000 	strb.w	r3, [ip]
			noteOn(key, velocity);
   16722:	f00a feb5 	bl	21490 <noteOn>
   16726:	e7b2      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
			ctrl = USB_message[2];
   16728:	78b3      	ldrb	r3, [r6, #2]
   1672a:	4913      	ldr	r1, [pc, #76]	; (16778 <ProcessReceivedMidiDatas+0x100>)
			data = USB_message[3];
   1672c:	78f2      	ldrb	r2, [r6, #3]
			switch(ctrl)
   1672e:	2b40      	cmp	r3, #64	; 0x40
			ctrl = USB_message[2];
   16730:	700b      	strb	r3, [r1, #0]
			CCs[ctrl] = data;
   16732:	4812      	ldr	r0, [pc, #72]	; (1677c <ProcessReceivedMidiDatas+0x104>)
			data = USB_message[3];
   16734:	4912      	ldr	r1, [pc, #72]	; (16780 <ProcessReceivedMidiDatas+0x108>)
			CCs[ctrl] = data;
   16736:	54c2      	strb	r2, [r0, r3]
			data = USB_message[3];
   16738:	700a      	strb	r2, [r1, #0]
			switch(ctrl)
   1673a:	d1a8      	bne.n	1668e <ProcessReceivedMidiDatas+0x16>
   1673c:	4b11      	ldr	r3, [pc, #68]	; (16784 <ProcessReceivedMidiDatas+0x10c>)
   1673e:	781b      	ldrb	r3, [r3, #0]
					if (data)
   16740:	b162      	cbz	r2, 1675c <ProcessReceivedMidiDatas+0xe4>
						if (sustainInverted) 	sustainOff();
   16742:	b16b      	cbz	r3, 16760 <ProcessReceivedMidiDatas+0xe8>
   16744:	f00b f80c 	bl	21760 <sustainOff>
   16748:	e7a1      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
	}
	if (processed >= 32)
   1674a:	2d20      	cmp	r5, #32
   1674c:	d001      	beq.n	16752 <ProcessReceivedMidiDatas+0xda>
	{
		testInt = 1;
	}
}
   1674e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		testInt = 1;
   16752:	4b0d      	ldr	r3, [pc, #52]	; (16788 <ProcessReceivedMidiDatas+0x110>)
   16754:	2201      	movs	r2, #1
   16756:	601a      	str	r2, [r3, #0]
}
   16758:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (sustainInverted) 	sustainOn();
   1675c:	2b00      	cmp	r3, #0
   1675e:	d0f1      	beq.n	16744 <ProcessReceivedMidiDatas+0xcc>
						else					sustainOn();
   16760:	f00b f800 	bl	21764 <sustainOn>
   16764:	e793      	b.n	1668e <ProcessReceivedMidiDatas+0x16>
   16766:	bf00      	nop
   16768:	020e325e 	.word	0x020e325e
   1676c:	020e3260 	.word	0x020e3260
   16770:	020e330c 	.word	0x020e330c
   16774:	020e3310 	.word	0x020e3310
   16778:	020e3285 	.word	0x020e3285
   1677c:	020e3288 	.word	0x020e3288
   16780:	020e3309 	.word	0x020e3309
   16784:	020e3284 	.word	0x020e3284
   16788:	020e30d8 	.word	0x020e30d8
   1678c:	020e325d 	.word	0x020e325d
   16790:	020fbce4 	.word	0x020fbce4
   16794:	020e3308 	.word	0x020e3308

00016798 <MX_ADC1_Init>:
  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /** Common config 
  */
  hadc1.Instance = ADC1;
   16798:	4b49      	ldr	r3, [pc, #292]	; (168c0 <MX_ADC1_Init+0x128>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
   1679a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  hadc1.Instance = ADC1;
   1679e:	4949      	ldr	r1, [pc, #292]	; (168c4 <MX_ADC1_Init+0x12c>)
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
   167a0:	2208      	movs	r2, #8
{
   167a2:	b530      	push	{r4, r5, lr}
  hadc1.Instance = ADC1;
   167a4:	6019      	str	r1, [r3, #0]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = ENABLE;
  hadc1.Init.Oversampling.Ratio = 64;
   167a6:	2140      	movs	r1, #64	; 0x40
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
   167a8:	6058      	str	r0, [r3, #4]
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
   167aa:	20c0      	movs	r0, #192	; 0xc0
{
   167ac:	b08b      	sub	sp, #44	; 0x2c
  hadc1.Init.NbrOfConversion = 6;
   167ae:	2506      	movs	r5, #6
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
   167b0:	2403      	movs	r4, #3
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
   167b2:	611a      	str	r2, [r3, #16]
  hadc1.Init.Oversampling.Ratio = 64;
   167b4:	63d9      	str	r1, [r3, #60]	; 0x3c
  ADC_MultiModeTypeDef multimode = {0};
   167b6:	2200      	movs	r2, #0
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
   167b8:	2101      	movs	r1, #1
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
   167ba:	6418      	str	r0, [r3, #64]	; 0x40
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
   167bc:	4618      	mov	r0, r3
  hadc1.Init.NbrOfConversion = 6;
   167be:	619d      	str	r5, [r3, #24]
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
   167c0:	62dc      	str	r4, [r3, #44]	; 0x2c
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
   167c2:	609a      	str	r2, [r3, #8]
  ADC_MultiModeTypeDef multimode = {0};
   167c4:	9200      	str	r2, [sp, #0]
  ADC_ChannelConfTypeDef sConfig = {0};
   167c6:	9203      	str	r2, [sp, #12]
  hadc1.Init.LowPowerAutoWait = DISABLE;
   167c8:	751a      	strb	r2, [r3, #20]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
   167ca:	771a      	strb	r2, [r3, #28]
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
   167cc:	645a      	str	r2, [r3, #68]	; 0x44
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
   167ce:	60d9      	str	r1, [r3, #12]
  hadc1.Init.ContinuousConvMode = ENABLE;
   167d0:	7559      	strb	r1, [r3, #21]
  hadc1.Init.OversamplingMode = ENABLE;
   167d2:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
   167d6:	6499      	str	r1, [r3, #72]	; 0x48
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
   167d8:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
   167dc:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
  ADC_MultiModeTypeDef multimode = {0};
   167e0:	e9cd 2201 	strd	r2, r2, [sp, #4]
  ADC_ChannelConfTypeDef sConfig = {0};
   167e4:	e9cd 2204 	strd	r2, r2, [sp, #16]
   167e8:	e9cd 2206 	strd	r2, r2, [sp, #24]
   167ec:	e9cd 2208 	strd	r2, r2, [sp, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
   167f0:	f7f2 fd06 	bl	9200 <HAL_ADC_Init>
   167f4:	2800      	cmp	r0, #0
   167f6:	d160      	bne.n	168ba <MX_ADC1_Init+0x122>
  {
    Error_Handler();
  }
  /** Configure the ADC multi-mode 
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
   167f8:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   167fa:	4669      	mov	r1, sp
   167fc:	4830      	ldr	r0, [pc, #192]	; (168c0 <MX_ADC1_Init+0x128>)
  multimode.Mode = ADC_MODE_INDEPENDENT;
   167fe:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
   16800:	f7f3 f80e 	bl	9820 <HAL_ADCEx_MultiModeConfigChannel>
   16804:	2800      	cmp	r0, #0
   16806:	d155      	bne.n	168b4 <MX_ADC1_Init+0x11c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_7;
   16808:	4b2f      	ldr	r3, [pc, #188]	; (168c8 <MX_ADC1_Init+0x130>)
  sConfig.Rank = ADC_REGULAR_RANK_1;
   1680a:	2106      	movs	r1, #6
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
   1680c:	2005      	movs	r0, #5
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
   1680e:	f240 74ff 	movw	r4, #2047	; 0x7ff
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
   16812:	2204      	movs	r2, #4
  sConfig.Channel = ADC_CHANNEL_7;
   16814:	9303      	str	r3, [sp, #12]
  sConfig.Offset = 0;
   16816:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_1;
   16818:	9104      	str	r1, [sp, #16]
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
   1681a:	9005      	str	r0, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1681c:	a903      	add	r1, sp, #12
   1681e:	4828      	ldr	r0, [pc, #160]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Offset = 0;
   16820:	9308      	str	r3, [sp, #32]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
   16822:	e9cd 4206 	strd	r4, r2, [sp, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16826:	f7f1 ff57 	bl	86d8 <HAL_ADC_ConfigChannel>
   1682a:	2800      	cmp	r0, #0
   1682c:	d13f      	bne.n	168ae <MX_ADC1_Init+0x116>
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_19;
  sConfig.Rank = ADC_REGULAR_RANK_2;
   1682e:	230c      	movs	r3, #12
  sConfig.Channel = ADC_CHANNEL_19;
   16830:	4a26      	ldr	r2, [pc, #152]	; (168cc <MX_ADC1_Init+0x134>)
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16832:	4823      	ldr	r0, [pc, #140]	; (168c0 <MX_ADC1_Init+0x128>)
   16834:	eb0d 0103 	add.w	r1, sp, r3
  sConfig.Rank = ADC_REGULAR_RANK_2;
   16838:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1683c:	f7f1 ff4c 	bl	86d8 <HAL_ADC_ConfigChannel>
   16840:	bb90      	cbnz	r0, 168a8 <MX_ADC1_Init+0x110>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_14;
   16842:	4a23      	ldr	r2, [pc, #140]	; (168d0 <MX_ADC1_Init+0x138>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
   16844:	2312      	movs	r3, #18
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16846:	a903      	add	r1, sp, #12
   16848:	481d      	ldr	r0, [pc, #116]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
   1684a:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1684e:	f7f1 ff43 	bl	86d8 <HAL_ADC_ConfigChannel>
   16852:	bb30      	cbnz	r0, 168a2 <MX_ADC1_Init+0x10a>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_16;
   16854:	4a1f      	ldr	r2, [pc, #124]	; (168d4 <MX_ADC1_Init+0x13c>)
  sConfig.Rank = ADC_REGULAR_RANK_4;
   16856:	2318      	movs	r3, #24
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16858:	a903      	add	r1, sp, #12
   1685a:	4819      	ldr	r0, [pc, #100]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_4;
   1685c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16860:	f7f1 ff3a 	bl	86d8 <HAL_ADC_ConfigChannel>
   16864:	b9d0      	cbnz	r0, 1689c <MX_ADC1_Init+0x104>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_15;
   16866:	4a1c      	ldr	r2, [pc, #112]	; (168d8 <MX_ADC1_Init+0x140>)
  sConfig.Rank = ADC_REGULAR_RANK_5;
   16868:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   1686c:	a903      	add	r1, sp, #12
   1686e:	4814      	ldr	r0, [pc, #80]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_5;
   16870:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16874:	f7f1 ff30 	bl	86d8 <HAL_ADC_ConfigChannel>
   16878:	b968      	cbnz	r0, 16896 <MX_ADC1_Init+0xfe>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_8;
   1687a:	4a18      	ldr	r2, [pc, #96]	; (168dc <MX_ADC1_Init+0x144>)
  sConfig.Rank = ADC_REGULAR_RANK_6;
   1687c:	f44f 7383 	mov.w	r3, #262	; 0x106
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16880:	a903      	add	r1, sp, #12
   16882:	480f      	ldr	r0, [pc, #60]	; (168c0 <MX_ADC1_Init+0x128>)
  sConfig.Rank = ADC_REGULAR_RANK_6;
   16884:	e9cd 2303 	strd	r2, r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   16888:	f7f1 ff26 	bl	86d8 <HAL_ADC_ConfigChannel>
   1688c:	b108      	cbz	r0, 16892 <MX_ADC1_Init+0xfa>
  {
    Error_Handler();
   1688e:	f002 fe15 	bl	194bc <Error_Handler>
  }

}
   16892:	b00b      	add	sp, #44	; 0x2c
   16894:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   16896:	f002 fe11 	bl	194bc <Error_Handler>
   1689a:	e7ee      	b.n	1687a <MX_ADC1_Init+0xe2>
    Error_Handler();
   1689c:	f002 fe0e 	bl	194bc <Error_Handler>
   168a0:	e7e1      	b.n	16866 <MX_ADC1_Init+0xce>
    Error_Handler();
   168a2:	f002 fe0b 	bl	194bc <Error_Handler>
   168a6:	e7d5      	b.n	16854 <MX_ADC1_Init+0xbc>
    Error_Handler();
   168a8:	f002 fe08 	bl	194bc <Error_Handler>
   168ac:	e7c9      	b.n	16842 <MX_ADC1_Init+0xaa>
    Error_Handler();
   168ae:	f002 fe05 	bl	194bc <Error_Handler>
   168b2:	e7bc      	b.n	1682e <MX_ADC1_Init+0x96>
    Error_Handler();
   168b4:	f002 fe02 	bl	194bc <Error_Handler>
   168b8:	e7a6      	b.n	16808 <MX_ADC1_Init+0x70>
    Error_Handler();
   168ba:	f002 fdff 	bl	194bc <Error_Handler>
   168be:	e79b      	b.n	167f8 <MX_ADC1_Init+0x60>
   168c0:	020e3314 	.word	0x020e3314
   168c4:	40022000 	.word	0x40022000
   168c8:	1d500080 	.word	0x1d500080
   168cc:	4fb80000 	.word	0x4fb80000
   168d0:	3ac04000 	.word	0x3ac04000
   168d4:	43210000 	.word	0x43210000
   168d8:	3ef08000 	.word	0x3ef08000
   168dc:	21800100 	.word	0x21800100

000168e0 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
   168e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
  if(adcHandle->Instance==ADC1)
   168e4:	4b46      	ldr	r3, [pc, #280]	; (16a00 <HAL_ADC_MspInit+0x120>)
{
   168e6:	b08f      	sub	sp, #60	; 0x3c
  if(adcHandle->Instance==ADC1)
   168e8:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   168ea:	2400      	movs	r4, #0
  if(adcHandle->Instance==ADC1)
   168ec:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   168ee:	940d      	str	r4, [sp, #52]	; 0x34
   168f0:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
   168f4:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
   168f8:	e9cd 4404 	strd	r4, r4, [sp, #16]
   168fc:	e9cd 4406 	strd	r4, r4, [sp, #24]
  if(adcHandle->Instance==ADC1)
   16900:	d002      	beq.n	16908 <HAL_ADC_MspInit+0x28>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
   16902:	b00f      	add	sp, #60	; 0x3c
   16904:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_ADC12_CLK_ENABLE();
   16908:	4b3e      	ldr	r3, [pc, #248]	; (16a04 <HAL_ADC_MspInit+0x124>)
   1690a:	4606      	mov	r6, r0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
   1690c:	2022      	movs	r0, #34	; 0x22
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1690e:	2703      	movs	r7, #3
    __HAL_RCC_ADC12_CLK_ENABLE();
   16910:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   16914:	a909      	add	r1, sp, #36	; 0x24
    hdma_adc1.Instance = DMA2_Stream0;
   16916:	4d3c      	ldr	r5, [pc, #240]	; (16a08 <HAL_ADC_MspInit+0x128>)
    __HAL_RCC_ADC12_CLK_ENABLE();
   16918:	f042 0220 	orr.w	r2, r2, #32
   1691c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   16920:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   16924:	f002 0220 	and.w	r2, r2, #32
   16928:	9201      	str	r2, [sp, #4]
   1692a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
   1692c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   16930:	f042 0204 	orr.w	r2, r2, #4
   16934:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   16938:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1693c:	f002 0204 	and.w	r2, r2, #4
   16940:	9202      	str	r2, [sp, #8]
   16942:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
   16944:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   16948:	f042 0201 	orr.w	r2, r2, #1
   1694c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   16950:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
   16954:	9009      	str	r0, [sp, #36]	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
   16956:	f003 0301 	and.w	r3, r3, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1695a:	482c      	ldr	r0, [pc, #176]	; (16a0c <HAL_ADC_MspInit+0x12c>)
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   1695c:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
   1695e:	9303      	str	r3, [sp, #12]
   16960:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   16962:	f7f5 f92d 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
   16966:	23ad      	movs	r3, #173	; 0xad
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   16968:	a909      	add	r1, sp, #36	; 0x24
   1696a:	4829      	ldr	r0, [pc, #164]	; (16a10 <HAL_ADC_MspInit+0x130>)
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
   1696c:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1696e:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   16972:	f7f5 f925 	bl	bbc0 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream0;
   16976:	4b27      	ldr	r3, [pc, #156]	; (16a14 <HAL_ADC_MspInit+0x134>)
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
   16978:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
   1697c:	f04f 0e09 	mov.w	lr, #9
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   16980:	f44f 6c00 	mov.w	ip, #2048	; 0x800
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   16984:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
   16988:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
   1698c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_adc1.Instance = DMA2_Stream0;
   16990:	602b      	str	r3, [r5, #0]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   16992:	2304      	movs	r3, #4
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
   16994:	6128      	str	r0, [r5, #16]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
   16996:	4628      	mov	r0, r5
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
   16998:	60ac      	str	r4, [r5, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
   1699a:	60ec      	str	r4, [r5, #12]
    hdma_adc1.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1699c:	632c      	str	r4, [r5, #48]	; 0x30
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
   1699e:	f8c5 e004 	str.w	lr, [r5, #4]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   169a2:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_adc1.Init.MemBurst = DMA_MBURST_SINGLE;
   169a4:	e9c5 440a 	strd	r4, r4, [r5, #40]	; 0x28
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   169a8:	e9c5 c705 	strd	ip, r7, [r5, #20]
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
   169ac:	e9c5 1207 	strd	r1, r2, [r5, #28]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
   169b0:	f7f3 f9dc 	bl	9d6c <HAL_DMA_Init>
   169b4:	b9f0      	cbnz	r0, 169f4 <HAL_ADC_MspInit+0x114>
    pSyncConfig.EventEnable = ENABLE;
   169b6:	2301      	movs	r3, #1
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   169b8:	f04f 0806 	mov.w	r8, #6
   169bc:	f44f 3900 	mov.w	r9, #131072	; 0x20000
    pSyncConfig.SyncEnable = DISABLE;
   169c0:	2200      	movs	r2, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   169c2:	a904      	add	r1, sp, #16
   169c4:	4810      	ldr	r0, [pc, #64]	; (16a08 <HAL_ADC_MspInit+0x128>)
    pSyncConfig.SyncEnable = DISABLE;
   169c6:	f88d 2018 	strb.w	r2, [sp, #24]
    pSyncConfig.EventEnable = ENABLE;
   169ca:	f88d 3019 	strb.w	r3, [sp, #25]
    pSyncConfig.RequestNumber = 1;
   169ce:	9307      	str	r3, [sp, #28]
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
   169d0:	e9cd 8904 	strd	r8, r9, [sp, #16]
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
   169d4:	f7f4 fc9c 	bl	b310 <HAL_DMAEx_ConfigMuxSync>
   169d8:	b978      	cbnz	r0, 169fa <HAL_ADC_MspInit+0x11a>
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   169da:	2200      	movs	r2, #0
   169dc:	2105      	movs	r1, #5
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
   169de:	64f5      	str	r5, [r6, #76]	; 0x4c
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   169e0:	2012      	movs	r0, #18
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
   169e2:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
   169e4:	f7f2 fff6 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
   169e8:	2012      	movs	r0, #18
   169ea:	f7f3 f839 	bl	9a60 <HAL_NVIC_EnableIRQ>
}
   169ee:	b00f      	add	sp, #60	; 0x3c
   169f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      Error_Handler();
   169f4:	f002 fd62 	bl	194bc <Error_Handler>
   169f8:	e7dd      	b.n	169b6 <HAL_ADC_MspInit+0xd6>
      Error_Handler();
   169fa:	f002 fd5f 	bl	194bc <Error_Handler>
   169fe:	e7ec      	b.n	169da <HAL_ADC_MspInit+0xfa>
   16a00:	40022000 	.word	0x40022000
   16a04:	58024400 	.word	0x58024400
   16a08:	020e3378 	.word	0x020e3378
   16a0c:	58020800 	.word	0x58020800
   16a10:	58020000 	.word	0x58020000
   16a14:	40020410 	.word	0x40020410

00016a18 <audioFrame>:
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void audioFrame(uint16_t buffer_offset)
{
   16a18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16a1c:	ed2d 8b04 	vpush	{d8-d9}
   16a20:	b087      	sub	sp, #28
   16a22:	4681      	mov	r9, r0
	//int32_t current_sample;
	uint32_t clipCatcher = 0;

	//tempCount5 = DWT->CYCCNT;

	buttonCheck();
   16a24:	f00b fe06 	bl	22634 <buttonCheck>

	adcCheck();
   16a28:	f00c f99c 	bl	22d64 <adcCheck>

	// if the USB write pointer has advanced (indicating unread data is in the buffer),
	// or the overflow bit is set, meaning that the write pointer wrapped around and the read pointer hasn't caught up to it yet
	// then process that new data this frame
	if ((myUSB_FIFO_overflowBit) || (myUSB_FIFO_writePointer > myUSB_FIFO_readPointer))
   16a2c:	4bbb      	ldr	r3, [pc, #748]	; (16d1c <audioFrame+0x304>)
   16a2e:	781b      	ldrb	r3, [r3, #0]
   16a30:	2b00      	cmp	r3, #0
   16a32:	f040 816f 	bne.w	16d14 <audioFrame+0x2fc>
   16a36:	4bba      	ldr	r3, [pc, #744]	; (16d20 <audioFrame+0x308>)
   16a38:	4aba      	ldr	r2, [pc, #744]	; (16d24 <audioFrame+0x30c>)
   16a3a:	881b      	ldrh	r3, [r3, #0]
   16a3c:	8812      	ldrh	r2, [r2, #0]
   16a3e:	429a      	cmp	r2, r3
   16a40:	f0c0 8168 	bcc.w	16d14 <audioFrame+0x2fc>
	{
		ProcessReceivedMidiDatas();
	}


	if (!loadingPreset)
   16a44:	4bb8      	ldr	r3, [pc, #736]	; (16d28 <audioFrame+0x310>)
   16a46:	781b      	ldrb	r3, [r3, #0]
   16a48:	2b00      	cmp	r3, #0
   16a4a:	d154      	bne.n	16af6 <audioFrame+0xde>
   16a4c:	4cb7      	ldr	r4, [pc, #732]	; (16d2c <audioFrame+0x314>)
   16a4e:	f8df 8324 	ldr.w	r8, [pc, #804]	; 16d74 <audioFrame+0x35c>
   16a52:	4627      	mov	r7, r4
   16a54:	f104 0518 	add.w	r5, r4, #24
   16a58:	f8df b31c 	ldr.w	fp, [pc, #796]	; 16d78 <audioFrame+0x360>
   16a5c:	4eb4      	ldr	r6, [pc, #720]	; (16d30 <audioFrame+0x318>)
	{

		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
		{
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
   16a5e:	4640      	mov	r0, r8
   16a60:	f108 0804 	add.w	r8, r8, #4
   16a64:	f011 fa86 	bl	27f74 <tExpSmooth_tick>
			for (int i = 0; i < KNOB_PAGE_SIZE; i++)
			{
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   16a68:	4bb2      	ldr	r3, [pc, #712]	; (16d34 <audioFrame+0x31c>)
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
   16a6a:	eca7 0a01 	vstmia	r7!, {s0}
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   16a6e:	42bd      	cmp	r5, r7
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
   16a70:	f893 a000 	ldrb.w	sl, [r3]
   16a74:	f89b 3000 	ldrb.w	r3, [fp]
   16a78:	eb0a 028a 	add.w	r2, sl, sl, lsl #2
   16a7c:	ed94 7a00 	vldr	s14, [r4]
   16a80:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   16a84:	edd4 7a01 	vldr	s15, [r4, #4]
   16a88:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   16a8c:	f103 0c01 	add.w	ip, r3, #1
   16a90:	f103 0002 	add.w	r0, r3, #2
   16a94:	eb02 0e03 	add.w	lr, r2, r3
   16a98:	f103 0103 	add.w	r1, r3, #3
   16a9c:	4494      	add	ip, r2
   16a9e:	f103 0304 	add.w	r3, r3, #4
   16aa2:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   16aa6:	4410      	add	r0, r2
   16aa8:	eb06 0c8c 	add.w	ip, r6, ip, lsl #2
   16aac:	4411      	add	r1, r2
   16aae:	ed8e 7a00 	vstr	s14, [lr]
   16ab2:	eb06 0080 	add.w	r0, r6, r0, lsl #2
   16ab6:	4413      	add	r3, r2
   16ab8:	f8d4 e008 	ldr.w	lr, [r4, #8]
   16abc:	edcc 7a00 	vstr	s15, [ip]
   16ac0:	eb06 0181 	add.w	r1, r6, r1, lsl #2
   16ac4:	f8c0 e000 	str.w	lr, [r0]
   16ac8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   16acc:	f8d4 c00c 	ldr.w	ip, [r4, #12]
   16ad0:	6920      	ldr	r0, [r4, #16]
   16ad2:	f8c1 c000 	str.w	ip, [r1]
   16ad6:	6018      	str	r0, [r3, #0]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   16ad8:	d1c1      	bne.n	16a5e <audioFrame+0x46>
			}
		}


		if (cvAddParam[currentPreset] >= 0)
   16ada:	4b97      	ldr	r3, [pc, #604]	; (16d38 <audioFrame+0x320>)
   16adc:	f913 300a 	ldrsb.w	r3, [r3, sl]
   16ae0:	2b00      	cmp	r3, #0
   16ae2:	db04      	blt.n	16aee <audioFrame+0xd6>
		{
			presetKnobValues[currentPreset][cvAddParam[currentPreset]] = smoothedADC[5];
   16ae4:	441a      	add	r2, r3
   16ae6:	6963      	ldr	r3, [r4, #20]
   16ae8:	eb06 0282 	add.w	r2, r6, r2, lsl #2
   16aec:	6013      	str	r3, [r2, #0]
		}

		frameFunctions[currentPreset]();
   16aee:	4b93      	ldr	r3, [pc, #588]	; (16d3c <audioFrame+0x324>)
   16af0:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
   16af4:	4798      	blx	r3
	//if the codec isn't ready, keep the buffer as all zeros
	//otherwise, start computing audio!

	bufferCleared = TRUE;

	if (codecReady)
   16af6:	4b92      	ldr	r3, [pc, #584]	; (16d40 <audioFrame+0x328>)
	bufferCleared = TRUE;
   16af8:	2201      	movs	r2, #1
   16afa:	4992      	ldr	r1, [pc, #584]	; (16d44 <audioFrame+0x32c>)
	if (codecReady)
   16afc:	781b      	ldrb	r3, [r3, #0]
	bufferCleared = TRUE;
   16afe:	700a      	strb	r2, [r1, #0]
	if (codecReady)
   16b00:	2b00      	cmp	r3, #0
   16b02:	f000 813f 	beq.w	16d84 <audioFrame+0x36c>
   16b06:	eb09 0402 	add.w	r4, r9, r2
	uint32_t clipCatcher = 0;
   16b0a:	2500      	movs	r5, #0
   16b0c:	f8df 826c 	ldr.w	r8, [pc, #620]	; 16d7c <audioFrame+0x364>
   16b10:	4b85      	ldr	r3, [pc, #532]	; (16d28 <audioFrame+0x310>)
   16b12:	00a4      	lsls	r4, r4, #2
   16b14:	9501      	str	r5, [sp, #4]
   16b16:	f508 6b00 	add.w	fp, r8, #2048	; 0x800
   16b1a:	7819      	ldrb	r1, [r3, #0]
	{

		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
		{
			float theSamples[2];
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b1c:	ed9f 8a8a 	vldr	s16, [pc, #552]	; 16d48 <audioFrame+0x330>
	//uint32_t tempCount5 = DWT->CYCCNT;

	//cycleCountVals[1][2] = 0;


	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   16b20:	eddf 9a8a 	vldr	s19, [pc, #552]	; 16d4c <audioFrame+0x334>
   16b24:	ed9f 9a8a 	vldr	s18, [pc, #552]	; 16d50 <audioFrame+0x338>
	{
		clips |= 2;
	}


	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16b28:	eddf 8a8a 	vldr	s17, [pc, #552]	; 16d54 <audioFrame+0x33c>
   16b2c:	e00b      	b.n	16b46 <audioFrame+0x12e>
	if (loadingPreset)
   16b2e:	2300      	movs	r3, #0
   16b30:	461a      	mov	r2, r3
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
   16b32:	3502      	adds	r5, #2
			audioOutBuffer[buffer_offset + i] = (int32_t)(theSamples[1] * TWO_TO_23);
   16b34:	f84b 2026 	str.w	r2, [fp, r6, lsl #2]
			audioOutBuffer[buffer_offset + i + 1] = (int32_t)(theSamples[0] * TWO_TO_23);
   16b38:	f84b 3004 	str.w	r3, [fp, r4]
   16b3c:	3408      	adds	r4, #8
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
   16b3e:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
   16b42:	f000 8166 	beq.w	16e12 <audioFrame+0x3fa>
   16b46:	eb05 0609 	add.w	r6, r5, r9
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b4a:	f858 2004 	ldr.w	r2, [r8, r4]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b4e:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b52:	0212      	lsls	r2, r2, #8
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b54:	021b      	lsls	r3, r3, #8
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b56:	ee00 2a90 	vmov	s1, r2
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b5a:	ee07 3a90 	vmov	s15, r3
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b5e:	eef8 0ae0 	vcvt.f32.s32	s1, s1
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b66:	ee60 0a88 	vmul.f32	s1, s1, s16
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b6a:	ee67 7a88 	vmul.f32	s15, s15, s16
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
   16b6e:	edcd 0a05 	vstr	s1, [sp, #20]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
   16b72:	edcd 7a04 	vstr	s15, [sp, #16]
	if (loadingPreset)
   16b76:	2900      	cmp	r1, #0
   16b78:	d1d9      	bne.n	16b2e <audioFrame+0x116>
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   16b7a:	eef4 0ae9 	vcmpe.f32	s1, s19
   16b7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16b82:	eef4 0ac9 	vcmpe.f32	s1, s18
   16b86:	bf94      	ite	ls
   16b88:	2201      	movls	r2, #1
   16b8a:	2200      	movhi	r2, #0
   16b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   16b90:	eef4 7ac9 	vcmpe.f32	s15, s18
	uint32_t clips = 0;
   16b94:	bfa8      	it	ge
   16b96:	f042 0201 	orrge.w	r2, r2, #1
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   16b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16b9e:	da04      	bge.n	16baa <audioFrame+0x192>
   16ba0:	eef4 7a69 	vcmp.f32	s15, s19
   16ba4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16ba8:	d801      	bhi.n	16bae <audioFrame+0x196>
		clips |= 2;
   16baa:	f042 0202 	orr.w	r2, r2, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bae:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   16bb2:	9203      	str	r2, [sp, #12]
   16bb4:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   16bb8:	4f67      	ldr	r7, [pc, #412]	; (16d58 <audioFrame+0x340>)
   16bba:	f012 fe65 	bl	29888 <LEAF_clip>
   16bbe:	4867      	ldr	r0, [pc, #412]	; (16d5c <audioFrame+0x344>)
   16bc0:	f00d fb90 	bl	242e4 <tEnvelopeFollower_tick>
   16bc4:	ee20 0a28 	vmul.f32	s0, s0, s17
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   16bc8:	4865      	ldr	r0, [pc, #404]	; (16d60 <audioFrame+0x348>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bca:	a904      	add	r1, sp, #16
   16bcc:	eddd 0a04 	vldr	s1, [sp, #16]
   16bd0:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bd4:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   16bd8:	6800      	ldr	r0, [r0, #0]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bda:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   16bde:	9102      	str	r1, [sp, #8]
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   16be0:	f8df a19c 	ldr.w	sl, [pc, #412]	; 16d80 <audioFrame+0x368>
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16be4:	ee17 3a90 	vmov	r3, s15
   16be8:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   16bec:	edd3 7a00 	vldr	s15, [r3]
   16bf0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
   16bf4:	ee17 3a90 	vmov	r3, s15
   16bf8:	b29b      	uxth	r3, r3
   16bfa:	6383      	str	r3, [r0, #56]	; 0x38
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16bfc:	f012 fe44 	bl	29888 <LEAF_clip>
   16c00:	4858      	ldr	r0, [pc, #352]	; (16d64 <audioFrame+0x34c>)
   16c02:	f00d fb6f 	bl	242e4 <tEnvelopeFollower_tick>
   16c06:	ee20 0a28 	vmul.f32	s0, s0, s17


	tickFunctions[currentPreset](samples);
   16c0a:	9902      	ldr	r1, [sp, #8]
   16c0c:	4b49      	ldr	r3, [pc, #292]	; (16d34 <audioFrame+0x31c>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c0e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	tickFunctions[currentPreset](samples);
   16c12:	4608      	mov	r0, r1
   16c14:	f893 e000 	ldrb.w	lr, [r3]
   16c18:	4b53      	ldr	r3, [pc, #332]	; (16d68 <audioFrame+0x350>)
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c1a:	ee17 1a90 	vmov	r1, s15
   16c1e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   16c22:	edd1 7a00 	vldr	s15, [r1]
   16c26:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
   16c2a:	ee17 2a90 	vmov	r2, s15
   16c2e:	b291      	uxth	r1, r2
   16c30:	f8da 2000 	ldr.w	r2, [sl]
   16c34:	6391      	str	r1, [r2, #56]	; 0x38
	tickFunctions[currentPreset](samples);
   16c36:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
   16c3a:	4798      	blx	r3

	//now the samples array is output
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
   16c3c:	eddd 0a05 	vldr	s1, [sp, #20]
   16c40:	9a03      	ldr	r2, [sp, #12]
   16c42:	eef4 0ac9 	vcmpe.f32	s1, s18
   16c46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c4a:	da04      	bge.n	16c56 <audioFrame+0x23e>
   16c4c:	eef4 0a69 	vcmp.f32	s1, s19
   16c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c54:	d801      	bhi.n	16c5a <audioFrame+0x242>
	{
		clips |= 4;
   16c56:	f042 0204 	orr.w	r2, r2, #4
	}

	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
   16c5a:	eddd 7a04 	vldr	s15, [sp, #16]
   16c5e:	eef4 7ae9 	vcmpe.f32	s15, s19
   16c62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c66:	d904      	bls.n	16c72 <audioFrame+0x25a>
   16c68:	eef4 7a49 	vcmp.f32	s15, s18
   16c6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   16c70:	db01      	blt.n	16c76 <audioFrame+0x25e>
	{
		clips |= 8;
   16c72:	f042 0208 	orr.w	r2, r2, #8
   16c76:	9b01      	ldr	r3, [sp, #4]
	}
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c78:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   16c7c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   16c80:	4313      	orrs	r3, r2
   16c82:	9301      	str	r3, [sp, #4]
   16c84:	f012 fe00 	bl	29888 <LEAF_clip>
   16c88:	4838      	ldr	r0, [pc, #224]	; (16d6c <audioFrame+0x354>)
   16c8a:	f00d fb2b 	bl	242e4 <tEnvelopeFollower_tick>
   16c8e:	ee60 7a28 	vmul.f32	s15, s0, s17
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
   16c92:	f8da 3000 	ldr.w	r3, [sl]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16c96:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   16c9a:	eddd 0a04 	vldr	s1, [sp, #16]
   16c9e:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16ca2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   16ca6:	ee17 2a90 	vmov	r2, s15
   16caa:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   16cae:	edd2 7a00 	vldr	s15, [r2]
   16cb2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
   16cb6:	ee17 2a90 	vmov	r2, s15
   16cba:	b292      	uxth	r2, r2
   16cbc:	63da      	str	r2, [r3, #60]	; 0x3c
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16cbe:	f012 fde3 	bl	29888 <LEAF_clip>
   16cc2:	482b      	ldr	r0, [pc, #172]	; (16d70 <audioFrame+0x358>)
   16cc4:	f00d fb0e 	bl	242e4 <tEnvelopeFollower_tick>
   16cc8:	ee20 0a28 	vmul.f32	s0, s0, s17
   16ccc:	4b16      	ldr	r3, [pc, #88]	; (16d28 <audioFrame+0x310>)
   16cce:	ed9d 7a05 	vldr	s14, [sp, #20]
   16cd2:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   16cd6:	7819      	ldrb	r1, [r3, #0]
   16cd8:	eddd 7a04 	vldr	s15, [sp, #16]
   16cdc:	eef0 6a47 	vmov.f32	s13, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
   16ce0:	f8da c000 	ldr.w	ip, [sl]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
   16ce4:	ee10 3a10 	vmov	r3, s0
   16ce8:	eeb0 7a67 	vmov.f32	s14, s15
   16cec:	eefe 6ae4 	vcvt.s32.f32	s13, s13, #23
   16cf0:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   16cf4:	eebe 7ae4 	vcvt.s32.f32	s14, s14, #23
   16cf8:	edd7 7a00 	vldr	s15, [r7]
   16cfc:	ee16 2a90 	vmov	r2, s13
   16d00:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   16d04:	ee17 3a10 	vmov	r3, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
   16d08:	ee17 0a90 	vmov	r0, s15
   16d0c:	b280      	uxth	r0, r0
   16d0e:	f8cc 0034 	str.w	r0, [ip, #52]	; 0x34
   16d12:	e70e      	b.n	16b32 <audioFrame+0x11a>
		ProcessReceivedMidiDatas();
   16d14:	f7ff fcb0 	bl	16678 <ProcessReceivedMidiDatas>
   16d18:	e694      	b.n	16a44 <audioFrame+0x2c>
   16d1a:	bf00      	nop
   16d1c:	020e325d 	.word	0x020e325d
   16d20:	020e3260 	.word	0x020e3260
   16d24:	020e325e 	.word	0x020e325e
   16d28:	020e325b 	.word	0x020e325b
   16d2c:	020f6f08 	.word	0x020f6f08
   16d30:	020f9318 	.word	0x020f9318
   16d34:	020e3259 	.word	0x020e3259
   16d38:	020fb540 	.word	0x020fb540
   16d3c:	020f6ec0 	.word	0x020f6ec0
   16d40:	020e3100 	.word	0x020e3100
   16d44:	0006289d 	.word	0x0006289d
   16d48:	2ffffff6 	.word	0x2ffffff6
   16d4c:	bf7fffef 	.word	0xbf7fffef
   16d50:	3f7fffef 	.word	0x3f7fffef
   16d54:	43ff8000 	.word	0x43ff8000
   16d58:	020f6f30 	.word	0x020f6f30
   16d5c:	020f6f20 	.word	0x020f6f20
   16d60:	020fb2b8 	.word	0x020fb2b8
   16d64:	020f6f28 	.word	0x020f6f28
   16d68:	020f6dc0 	.word	0x020f6dc0
   16d6c:	020f6f24 	.word	0x020f6f24
   16d70:	020f6f2c 	.word	0x020f6f2c
   16d74:	020f6ea8 	.word	0x020f6ea8
   16d78:	020e325a 	.word	0x020e325a
   16d7c:	00062dc0 	.word	0x00062dc0
   16d80:	020fb278 	.word	0x020fb278
	uint32_t clipCatcher = 0;
   16d84:	9301      	str	r3, [sp, #4]
		numBuffersCleared++;
   16d86:	4a4b      	ldr	r2, [pc, #300]	; (16eb4 <audioFrame+0x49c>)
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d88:	494b      	ldr	r1, [pc, #300]	; (16eb8 <audioFrame+0x4a0>)
		numBuffersCleared++;
   16d8a:	6813      	ldr	r3, [r2, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d8c:	6809      	ldr	r1, [r1, #0]
		numBuffersCleared++;
   16d8e:	3301      	adds	r3, #1
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d90:	428b      	cmp	r3, r1
		numBuffersCleared++;
   16d92:	6013      	str	r3, [r2, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
   16d94:	da47      	bge.n	16e26 <audioFrame+0x40e>
	uint32_t clipCatcher = 0;
   16d96:	2400      	movs	r4, #0
   16d98:	4d48      	ldr	r5, [pc, #288]	; (16ebc <audioFrame+0x4a4>)
   16d9a:	f8df 8148 	ldr.w	r8, [pc, #328]	; 16ee4 <audioFrame+0x4cc>
			clipCounter[i] = 80;
   16d9e:	2750      	movs	r7, #80	; 0x50
			clipHappened[i] = 0;
   16da0:	4e47      	ldr	r6, [pc, #284]	; (16ec0 <audioFrame+0x4a8>)
   16da2:	f8dd 9004 	ldr.w	r9, [sp, #4]
		if ((clipCatcher >> i) & 1)
   16da6:	fa29 f304 	lsr.w	r3, r9, r4
   16daa:	07db      	lsls	r3, r3, #31
   16dac:	d51c      	bpl.n	16de8 <audioFrame+0x3d0>
			switch (i)
   16dae:	2c02      	cmp	r4, #2
   16db0:	d06f      	beq.n	16e92 <audioFrame+0x47a>
   16db2:	2c03      	cmp	r4, #3
   16db4:	d069      	beq.n	16e8a <audioFrame+0x472>
   16db6:	2c01      	cmp	r4, #1
   16db8:	d063      	beq.n	16e82 <audioFrame+0x46a>
					setLED_leftin_clip(1);
   16dba:	2001      	movs	r0, #1
   16dbc:	f002 fc06 	bl	195cc <setLED_leftin_clip>
			clipped[i] = 1;
   16dc0:	2101      	movs	r1, #1
			clipHappened[i] = 0;
   16dc2:	2200      	movs	r2, #0
   16dc4:	00a3      	lsls	r3, r4, #2
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   16dc6:	2050      	movs	r0, #80	; 0x50
			clipCounter[i] = 80;
   16dc8:	f845 7024 	str.w	r7, [r5, r4, lsl #2]
			clipped[i] = 1;
   16dcc:	f808 1004 	strb.w	r1, [r8, r4]
			clipHappened[i] = 0;
   16dd0:	f846 2024 	str.w	r2, [r6, r4, lsl #2]
			clipCounter[i]--;
   16dd4:	3801      	subs	r0, #1
   16dd6:	50e8      	str	r0, [r5, r3]
	for (int i = 0; i < 4; i++)
   16dd8:	3401      	adds	r4, #1
   16dda:	2c04      	cmp	r4, #4
   16ddc:	d1e3      	bne.n	16da6 <audioFrame+0x38e>
}
   16dde:	b007      	add	sp, #28
   16de0:	ecbd 8b04 	vpop	{d8-d9}
   16de4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   16de8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   16dec:	00a3      	lsls	r3, r4, #2
   16dee:	f818 2004 	ldrb.w	r2, [r8, r4]
   16df2:	2800      	cmp	r0, #0
   16df4:	d15a      	bne.n	16eac <audioFrame+0x494>
		else if ((clipCounter[i] == 0) && (clipped[i] == 1))
   16df6:	2a01      	cmp	r2, #1
   16df8:	d1ee      	bne.n	16dd8 <audioFrame+0x3c0>
			switch (i)
   16dfa:	2c02      	cmp	r4, #2
   16dfc:	d04d      	beq.n	16e9a <audioFrame+0x482>
   16dfe:	2c03      	cmp	r4, #3
   16e00:	d051      	beq.n	16ea6 <audioFrame+0x48e>
   16e02:	2c01      	cmp	r4, #1
   16e04:	d04c      	beq.n	16ea0 <audioFrame+0x488>
					setLED_leftin_clip(0);
   16e06:	f002 fbe1 	bl	195cc <setLED_leftin_clip>
			clipped[i] = 0;
   16e0a:	2300      	movs	r3, #0
   16e0c:	f808 3004 	strb.w	r3, [r8, r4]
   16e10:	e7e2      	b.n	16dd8 <audioFrame+0x3c0>
			bufferCleared = 0;
   16e12:	4b2c      	ldr	r3, [pc, #176]	; (16ec4 <audioFrame+0x4ac>)
		if (!loadingPreset)
   16e14:	2900      	cmp	r1, #0
   16e16:	d032      	beq.n	16e7e <audioFrame+0x466>
	if (bufferCleared)
   16e18:	781b      	ldrb	r3, [r3, #0]
   16e1a:	2b00      	cmp	r3, #0
   16e1c:	d1b3      	bne.n	16d86 <audioFrame+0x36e>
	else numBuffersCleared = 0;
   16e1e:	4b25      	ldr	r3, [pc, #148]	; (16eb4 <audioFrame+0x49c>)
   16e20:	2200      	movs	r2, #0
   16e22:	601a      	str	r2, [r3, #0]
   16e24:	e7b7      	b.n	16d96 <audioFrame+0x37e>
			if (loadingPreset)
   16e26:	4b28      	ldr	r3, [pc, #160]	; (16ec8 <audioFrame+0x4b0>)
			numBuffersCleared = numBuffersToClearOnLoad;
   16e28:	6011      	str	r1, [r2, #0]
			if (loadingPreset)
   16e2a:	781b      	ldrb	r3, [r3, #0]
   16e2c:	2b00      	cmp	r3, #0
   16e2e:	d0b2      	beq.n	16d96 <audioFrame+0x37e>
				if (previousPreset != PresetNil)
   16e30:	4b26      	ldr	r3, [pc, #152]	; (16ecc <audioFrame+0x4b4>)
   16e32:	781b      	ldrb	r3, [r3, #0]
   16e34:	2b12      	cmp	r3, #18
   16e36:	d003      	beq.n	16e40 <audioFrame+0x428>
					freeFunctions[previousPreset]();
   16e38:	4a25      	ldr	r2, [pc, #148]	; (16ed0 <audioFrame+0x4b8>)
   16e3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16e3e:	4798      	blx	r3
				setLED_A(0);
   16e40:	2000      	movs	r0, #0
				knobPage = 0;
   16e42:	4604      	mov	r4, r0
				setLED_A(0);
   16e44:	f002 fb7a 	bl	1953c <setLED_A>
				setLED_B(0);
   16e48:	4620      	mov	r0, r4
   16e4a:	f002 fb85 	bl	19558 <setLED_B>
				setLED_C(0);
   16e4e:	4620      	mov	r0, r4
   16e50:	f002 fb90 	bl	19574 <setLED_C>
				setLED_Edit(0);
   16e54:	4620      	mov	r0, r4
   16e56:	f002 fb35 	bl	194c4 <setLED_Edit>
				setLED_1(0);
   16e5a:	4620      	mov	r0, r4
   16e5c:	f002 fb4e 	bl	194fc <setLED_1>
				knobPage = 0;
   16e60:	4b1c      	ldr	r3, [pc, #112]	; (16ed4 <audioFrame+0x4bc>)
   16e62:	701c      	strb	r4, [r3, #0]
				resetKnobValues();
   16e64:	f00c f87c 	bl	22f60 <resetKnobValues>
				allocFunctions[currentPreset]();
   16e68:	4b1b      	ldr	r3, [pc, #108]	; (16ed8 <audioFrame+0x4c0>)
				leaf.clearOnAllocation = 0;
   16e6a:	491c      	ldr	r1, [pc, #112]	; (16edc <audioFrame+0x4c4>)
				allocFunctions[currentPreset]();
   16e6c:	781a      	ldrb	r2, [r3, #0]
   16e6e:	4b1c      	ldr	r3, [pc, #112]	; (16ee0 <audioFrame+0x4c8>)
				leaf.clearOnAllocation = 0;
   16e70:	614c      	str	r4, [r1, #20]
				allocFunctions[currentPreset]();
   16e72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   16e76:	4798      	blx	r3
				loadingPreset = 0;
   16e78:	4b13      	ldr	r3, [pc, #76]	; (16ec8 <audioFrame+0x4b0>)
   16e7a:	701c      	strb	r4, [r3, #0]
   16e7c:	e78b      	b.n	16d96 <audioFrame+0x37e>
			bufferCleared = 0;
   16e7e:	7019      	strb	r1, [r3, #0]
   16e80:	e7cd      	b.n	16e1e <audioFrame+0x406>
					setLED_rightin_clip(1);
   16e82:	4620      	mov	r0, r4
   16e84:	f002 fbb0 	bl	195e8 <setLED_rightin_clip>
					break;
   16e88:	e79a      	b.n	16dc0 <audioFrame+0x3a8>
					setLED_rightout_clip(1);
   16e8a:	2001      	movs	r0, #1
   16e8c:	f002 fb90 	bl	195b0 <setLED_rightout_clip>
					break;
   16e90:	e796      	b.n	16dc0 <audioFrame+0x3a8>
					setLED_leftout_clip(1);
   16e92:	2001      	movs	r0, #1
   16e94:	f002 fb7e 	bl	19594 <setLED_leftout_clip>
					break;
   16e98:	e792      	b.n	16dc0 <audioFrame+0x3a8>
					setLED_leftout_clip(0);
   16e9a:	f002 fb7b 	bl	19594 <setLED_leftout_clip>
					break;
   16e9e:	e7b4      	b.n	16e0a <audioFrame+0x3f2>
					setLED_rightin_clip(0);
   16ea0:	f002 fba2 	bl	195e8 <setLED_rightin_clip>
					break;
   16ea4:	e7b1      	b.n	16e0a <audioFrame+0x3f2>
					setLED_rightout_clip(0);
   16ea6:	f002 fb83 	bl	195b0 <setLED_rightout_clip>
					break;
   16eaa:	e7ae      	b.n	16e0a <audioFrame+0x3f2>
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
   16eac:	2a01      	cmp	r2, #1
   16eae:	d193      	bne.n	16dd8 <audioFrame+0x3c0>
   16eb0:	e790      	b.n	16dd4 <audioFrame+0x3bc>
   16eb2:	bf00      	nop
   16eb4:	020e3104 	.word	0x020e3104
   16eb8:	000628a0 	.word	0x000628a0
   16ebc:	020e30dc 	.word	0x020e30dc
   16ec0:	020e30ec 	.word	0x020e30ec
   16ec4:	0006289d 	.word	0x0006289d
   16ec8:	020e325b 	.word	0x020e325b
   16ecc:	00062b60 	.word	0x00062b60
   16ed0:	020f6e0c 	.word	0x020f6e0c
   16ed4:	020e325a 	.word	0x020e325a
   16ed8:	020e3259 	.word	0x020e3259
   16edc:	020fc0a8 	.word	0x020fc0a8
   16ee0:	020f6e5c 	.word	0x020f6e5c
   16ee4:	020e30fc 	.word	0x020e30fc

00016ee8 <initFunctionPointers>:
}

*/

void initFunctionPointers(void)
{
   16ee8:	b430      	push	{r4, r5}
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   16eea:	484b      	ldr	r0, [pc, #300]	; (17018 <initFunctionPointers+0x130>)
   16eec:	4c4b      	ldr	r4, [pc, #300]	; (1701c <initFunctionPointers+0x134>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
	tickFunctions[Vocoder] = SFXVocoderTick;
	freeFunctions[Vocoder] = SFXVocoderFree;

	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   16eee:	4d4c      	ldr	r5, [pc, #304]	; (17020 <initFunctionPointers+0x138>)
	allocFunctions[Vocoder] = SFXVocoderAlloc;
   16ef0:	6004      	str	r4, [r0, #0]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
	tickFunctions[VocoderCh] = SFXVocoderChTick;
	freeFunctions[VocoderCh] = SFXVocoderChFree;

	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   16ef2:	4b4c      	ldr	r3, [pc, #304]	; (17024 <initFunctionPointers+0x13c>)
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
	freeFunctions[Pitchshift] = SFXPitchShiftFree;

	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   16ef4:	494c      	ldr	r1, [pc, #304]	; (17028 <initFunctionPointers+0x140>)
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
	freeFunctions[AutotuneMono] = SFXNeartuneFree;

	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   16ef6:	4a4d      	ldr	r2, [pc, #308]	; (1702c <initFunctionPointers+0x144>)
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
	freeFunctions[AutotunePoly] = SFXAutotuneFree;

	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   16ef8:	4c4d      	ldr	r4, [pc, #308]	; (17030 <initFunctionPointers+0x148>)
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
   16efa:	6045      	str	r5, [r0, #4]
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
   16efc:	6083      	str	r3, [r0, #8]
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
   16efe:	60c1      	str	r1, [r0, #12]
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
   16f00:	6102      	str	r2, [r0, #16]
	frameFunctions[Vocoder] = SFXVocoderFrame;
   16f02:	494c      	ldr	r1, [pc, #304]	; (17034 <initFunctionPointers+0x14c>)
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
   16f04:	6144      	str	r4, [r0, #20]
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;

	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   16f06:	4d4c      	ldr	r5, [pc, #304]	; (17038 <initFunctionPointers+0x150>)
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;

	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   16f08:	4b4c      	ldr	r3, [pc, #304]	; (1703c <initFunctionPointers+0x154>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
   16f0a:	4a4d      	ldr	r2, [pc, #308]	; (17040 <initFunctionPointers+0x158>)
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   16f0c:	4c4d      	ldr	r4, [pc, #308]	; (17044 <initFunctionPointers+0x15c>)
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
   16f0e:	6185      	str	r5, [r0, #24]
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
   16f10:	61c3      	str	r3, [r0, #28]
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   16f12:	4d4d      	ldr	r5, [pc, #308]	; (17048 <initFunctionPointers+0x160>)
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   16f14:	4b4d      	ldr	r3, [pc, #308]	; (1704c <initFunctionPointers+0x164>)
	frameFunctions[Vocoder] = SFXVocoderFrame;
   16f16:	600a      	str	r2, [r1, #0]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
   16f18:	604c      	str	r4, [r1, #4]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   16f1a:	4a4d      	ldr	r2, [pc, #308]	; (17050 <initFunctionPointers+0x168>)
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   16f1c:	4c4d      	ldr	r4, [pc, #308]	; (17054 <initFunctionPointers+0x16c>)
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
   16f1e:	608d      	str	r5, [r1, #8]
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
   16f20:	60cb      	str	r3, [r1, #12]
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   16f22:	4d4d      	ldr	r5, [pc, #308]	; (17058 <initFunctionPointers+0x170>)
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   16f24:	4b4d      	ldr	r3, [pc, #308]	; (1705c <initFunctionPointers+0x174>)
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
   16f26:	610a      	str	r2, [r1, #16]
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
   16f28:	614c      	str	r4, [r1, #20]
	tickFunctions[Vocoder] = SFXVocoderTick;
   16f2a:	4a4d      	ldr	r2, [pc, #308]	; (17060 <initFunctionPointers+0x178>)
   16f2c:	4c4d      	ldr	r4, [pc, #308]	; (17064 <initFunctionPointers+0x17c>)
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
   16f2e:	618d      	str	r5, [r1, #24]
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
   16f30:	61cb      	str	r3, [r1, #28]
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   16f32:	4d4d      	ldr	r5, [pc, #308]	; (17068 <initFunctionPointers+0x180>)
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   16f34:	4b4d      	ldr	r3, [pc, #308]	; (1706c <initFunctionPointers+0x184>)
	tickFunctions[Vocoder] = SFXVocoderTick;
   16f36:	6014      	str	r4, [r2, #0]
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   16f38:	4c4d      	ldr	r4, [pc, #308]	; (17070 <initFunctionPointers+0x188>)
	tickFunctions[VocoderCh] = SFXVocoderChTick;
   16f3a:	6055      	str	r5, [r2, #4]
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
   16f3c:	6093      	str	r3, [r2, #8]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   16f3e:	4d4d      	ldr	r5, [pc, #308]	; (17074 <initFunctionPointers+0x18c>)
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   16f40:	4b4d      	ldr	r3, [pc, #308]	; (17078 <initFunctionPointers+0x190>)
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
   16f42:	60d4      	str	r4, [r2, #12]
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   16f44:	4c4d      	ldr	r4, [pc, #308]	; (1707c <initFunctionPointers+0x194>)
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
   16f46:	6115      	str	r5, [r2, #16]
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
   16f48:	6153      	str	r3, [r2, #20]
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   16f4a:	4d4d      	ldr	r5, [pc, #308]	; (17080 <initFunctionPointers+0x198>)
	freeFunctions[Vocoder] = SFXVocoderFree;
   16f4c:	4b4d      	ldr	r3, [pc, #308]	; (17084 <initFunctionPointers+0x19c>)
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
   16f4e:	6194      	str	r4, [r2, #24]
	freeFunctions[Vocoder] = SFXVocoderFree;
   16f50:	4c4d      	ldr	r4, [pc, #308]	; (17088 <initFunctionPointers+0x1a0>)
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
   16f52:	61d5      	str	r5, [r2, #28]
	freeFunctions[Vocoder] = SFXVocoderFree;
   16f54:	601c      	str	r4, [r3, #0]
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   16f56:	4d4d      	ldr	r5, [pc, #308]	; (1708c <initFunctionPointers+0x1a4>)
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   16f58:	4c4d      	ldr	r4, [pc, #308]	; (17090 <initFunctionPointers+0x1a8>)
	freeFunctions[VocoderCh] = SFXVocoderChFree;
   16f5a:	605d      	str	r5, [r3, #4]
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
   16f5c:	609c      	str	r4, [r3, #8]
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   16f5e:	4d4d      	ldr	r5, [pc, #308]	; (17094 <initFunctionPointers+0x1ac>)
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   16f60:	4c4d      	ldr	r4, [pc, #308]	; (17098 <initFunctionPointers+0x1b0>)
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
   16f62:	60dd      	str	r5, [r3, #12]
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
   16f64:	611c      	str	r4, [r3, #16]
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   16f66:	4d4d      	ldr	r5, [pc, #308]	; (1709c <initFunctionPointers+0x1b4>)
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   16f68:	4c4d      	ldr	r4, [pc, #308]	; (170a0 <initFunctionPointers+0x1b8>)
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
   16f6a:	615d      	str	r5, [r3, #20]
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
   16f6c:	619c      	str	r4, [r3, #24]
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   16f6e:	4d4d      	ldr	r5, [pc, #308]	; (170a4 <initFunctionPointers+0x1bc>)

	allocFunctions[Distortion] = SFXDistortionAlloc;
   16f70:	4c4d      	ldr	r4, [pc, #308]	; (170a8 <initFunctionPointers+0x1c0>)
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
   16f72:	61dd      	str	r5, [r3, #28]
	allocFunctions[Distortion] = SFXDistortionAlloc;
   16f74:	6204      	str	r4, [r0, #32]
	frameFunctions[Distortion] = SFXDistortionFrame;
   16f76:	4d4d      	ldr	r5, [pc, #308]	; (170ac <initFunctionPointers+0x1c4>)
	tickFunctions[Distortion] = SFXDistortionTick;
   16f78:	4c4d      	ldr	r4, [pc, #308]	; (170b0 <initFunctionPointers+0x1c8>)
	frameFunctions[Distortion] = SFXDistortionFrame;
   16f7a:	620d      	str	r5, [r1, #32]
	tickFunctions[Distortion] = SFXDistortionTick;
   16f7c:	6214      	str	r4, [r2, #32]
	freeFunctions[Distortion] = SFXDistortionFree;
   16f7e:	4d4d      	ldr	r5, [pc, #308]	; (170b4 <initFunctionPointers+0x1cc>)

	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   16f80:	4c4d      	ldr	r4, [pc, #308]	; (170b8 <initFunctionPointers+0x1d0>)
	freeFunctions[Distortion] = SFXDistortionFree;
   16f82:	621d      	str	r5, [r3, #32]
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
   16f84:	6244      	str	r4, [r0, #36]	; 0x24
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   16f86:	4d4d      	ldr	r5, [pc, #308]	; (170bc <initFunctionPointers+0x1d4>)
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   16f88:	4c4d      	ldr	r4, [pc, #308]	; (170c0 <initFunctionPointers+0x1d8>)
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
   16f8a:	624d      	str	r5, [r1, #36]	; 0x24
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
   16f8c:	6254      	str	r4, [r2, #36]	; 0x24
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   16f8e:	4d4d      	ldr	r5, [pc, #308]	; (170c4 <initFunctionPointers+0x1dc>)

	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   16f90:	4c4d      	ldr	r4, [pc, #308]	; (170c8 <initFunctionPointers+0x1e0>)
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
   16f92:	625d      	str	r5, [r3, #36]	; 0x24
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
   16f94:	6284      	str	r4, [r0, #40]	; 0x28
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   16f96:	4d4d      	ldr	r5, [pc, #308]	; (170cc <initFunctionPointers+0x1e4>)
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   16f98:	4c4d      	ldr	r4, [pc, #308]	; (170d0 <initFunctionPointers+0x1e8>)
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
   16f9a:	628d      	str	r5, [r1, #40]	; 0x28
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
   16f9c:	6294      	str	r4, [r2, #40]	; 0x28
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   16f9e:	4d4d      	ldr	r5, [pc, #308]	; (170d4 <initFunctionPointers+0x1ec>)

	allocFunctions[Delay] = SFXDelayAlloc;
   16fa0:	4c4d      	ldr	r4, [pc, #308]	; (170d8 <initFunctionPointers+0x1f0>)
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
   16fa2:	629d      	str	r5, [r3, #40]	; 0x28
	allocFunctions[Delay] = SFXDelayAlloc;
   16fa4:	62c4      	str	r4, [r0, #44]	; 0x2c
	frameFunctions[Delay] = SFXDelayFrame;
   16fa6:	4d4d      	ldr	r5, [pc, #308]	; (170dc <initFunctionPointers+0x1f4>)
	tickFunctions[Delay] = SFXDelayTick;
   16fa8:	4c4d      	ldr	r4, [pc, #308]	; (170e0 <initFunctionPointers+0x1f8>)
	frameFunctions[Delay] = SFXDelayFrame;
   16faa:	62cd      	str	r5, [r1, #44]	; 0x2c
	tickFunctions[Delay] = SFXDelayTick;
   16fac:	62d4      	str	r4, [r2, #44]	; 0x2c
	freeFunctions[Delay] = SFXDelayFree;
   16fae:	4d4d      	ldr	r5, [pc, #308]	; (170e4 <initFunctionPointers+0x1fc>)

	allocFunctions[Reverb] = SFXReverbAlloc;
   16fb0:	4c4d      	ldr	r4, [pc, #308]	; (170e8 <initFunctionPointers+0x200>)
	freeFunctions[Delay] = SFXDelayFree;
   16fb2:	62dd      	str	r5, [r3, #44]	; 0x2c
	allocFunctions[Reverb] = SFXReverbAlloc;
   16fb4:	6304      	str	r4, [r0, #48]	; 0x30
	frameFunctions[Reverb] = SFXReverbFrame;
   16fb6:	4d4d      	ldr	r5, [pc, #308]	; (170ec <initFunctionPointers+0x204>)
	tickFunctions[Reverb] = SFXReverbTick;
   16fb8:	4c4d      	ldr	r4, [pc, #308]	; (170f0 <initFunctionPointers+0x208>)
	frameFunctions[Reverb] = SFXReverbFrame;
   16fba:	630d      	str	r5, [r1, #48]	; 0x30
	tickFunctions[Reverb] = SFXReverbTick;
   16fbc:	6314      	str	r4, [r2, #48]	; 0x30
	freeFunctions[Reverb] = SFXReverbFree;
   16fbe:	4d4d      	ldr	r5, [pc, #308]	; (170f4 <initFunctionPointers+0x20c>)

	allocFunctions[Reverb2] = SFXReverb2Alloc;
   16fc0:	4c4d      	ldr	r4, [pc, #308]	; (170f8 <initFunctionPointers+0x210>)
	freeFunctions[Reverb] = SFXReverbFree;
   16fc2:	631d      	str	r5, [r3, #48]	; 0x30
	allocFunctions[Reverb2] = SFXReverb2Alloc;
   16fc4:	6344      	str	r4, [r0, #52]	; 0x34
	frameFunctions[Reverb2] = SFXReverb2Frame;
   16fc6:	4d4d      	ldr	r5, [pc, #308]	; (170fc <initFunctionPointers+0x214>)
	tickFunctions[Reverb2] = SFXReverb2Tick;
   16fc8:	4c4d      	ldr	r4, [pc, #308]	; (17100 <initFunctionPointers+0x218>)
	frameFunctions[Reverb2] = SFXReverb2Frame;
   16fca:	634d      	str	r5, [r1, #52]	; 0x34
	tickFunctions[Reverb2] = SFXReverb2Tick;
   16fcc:	6354      	str	r4, [r2, #52]	; 0x34
	freeFunctions[Reverb2] = SFXReverb2Free;
   16fce:	4d4d      	ldr	r5, [pc, #308]	; (17104 <initFunctionPointers+0x21c>)

	allocFunctions[LivingString] = SFXLivingStringAlloc;
   16fd0:	4c4d      	ldr	r4, [pc, #308]	; (17108 <initFunctionPointers+0x220>)
	freeFunctions[Reverb2] = SFXReverb2Free;
   16fd2:	635d      	str	r5, [r3, #52]	; 0x34
	allocFunctions[LivingString] = SFXLivingStringAlloc;
   16fd4:	6384      	str	r4, [r0, #56]	; 0x38
	frameFunctions[LivingString] = SFXLivingStringFrame;
   16fd6:	4d4d      	ldr	r5, [pc, #308]	; (1710c <initFunctionPointers+0x224>)
	tickFunctions[LivingString] = SFXLivingStringTick;
   16fd8:	4c4d      	ldr	r4, [pc, #308]	; (17110 <initFunctionPointers+0x228>)
	frameFunctions[LivingString] = SFXLivingStringFrame;
   16fda:	638d      	str	r5, [r1, #56]	; 0x38
	tickFunctions[LivingString] = SFXLivingStringTick;
   16fdc:	6394      	str	r4, [r2, #56]	; 0x38
	freeFunctions[LivingString] = SFXLivingStringFree;
   16fde:	4d4d      	ldr	r5, [pc, #308]	; (17114 <initFunctionPointers+0x22c>)

	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   16fe0:	4c4d      	ldr	r4, [pc, #308]	; (17118 <initFunctionPointers+0x230>)
	freeFunctions[LivingString] = SFXLivingStringFree;
   16fe2:	639d      	str	r5, [r3, #56]	; 0x38
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
   16fe4:	63c4      	str	r4, [r0, #60]	; 0x3c
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   16fe6:	4d4d      	ldr	r5, [pc, #308]	; (1711c <initFunctionPointers+0x234>)
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   16fe8:	4c4d      	ldr	r4, [pc, #308]	; (17120 <initFunctionPointers+0x238>)
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
   16fea:	63cd      	str	r5, [r1, #60]	; 0x3c
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
   16fec:	63d4      	str	r4, [r2, #60]	; 0x3c
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   16fee:	4d4d      	ldr	r5, [pc, #308]	; (17124 <initFunctionPointers+0x23c>)

	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   16ff0:	4c4d      	ldr	r4, [pc, #308]	; (17128 <initFunctionPointers+0x240>)
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
   16ff2:	63dd      	str	r5, [r3, #60]	; 0x3c
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
   16ff4:	6404      	str	r4, [r0, #64]	; 0x40
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   16ff6:	4d4d      	ldr	r5, [pc, #308]	; (1712c <initFunctionPointers+0x244>)
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   16ff8:	4c4d      	ldr	r4, [pc, #308]	; (17130 <initFunctionPointers+0x248>)
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
   16ffa:	640d      	str	r5, [r1, #64]	; 0x40
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
   16ffc:	6414      	str	r4, [r2, #64]	; 0x40
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   16ffe:	4d4d      	ldr	r5, [pc, #308]	; (17134 <initFunctionPointers+0x24c>)

	allocFunctions[Rhodes] = SFXRhodesAlloc;
   17000:	4c4d      	ldr	r4, [pc, #308]	; (17138 <initFunctionPointers+0x250>)
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
   17002:	641d      	str	r5, [r3, #64]	; 0x40
	allocFunctions[Rhodes] = SFXRhodesAlloc;
   17004:	6444      	str	r4, [r0, #68]	; 0x44
	frameFunctions[Rhodes] = SFXRhodesFrame;
   17006:	4d4d      	ldr	r5, [pc, #308]	; (1713c <initFunctionPointers+0x254>)
	tickFunctions[Rhodes] = SFXRhodesTick;
   17008:	4c4d      	ldr	r4, [pc, #308]	; (17140 <initFunctionPointers+0x258>)
	freeFunctions[Rhodes] = SFXRhodesFree;
   1700a:	484e      	ldr	r0, [pc, #312]	; (17144 <initFunctionPointers+0x25c>)
	frameFunctions[Rhodes] = SFXRhodesFrame;
   1700c:	644d      	str	r5, [r1, #68]	; 0x44
	tickFunctions[Rhodes] = SFXRhodesTick;
   1700e:	6454      	str	r4, [r2, #68]	; 0x44
	freeFunctions[Rhodes] = SFXRhodesFree;
   17010:	6458      	str	r0, [r3, #68]	; 0x44
}
   17012:	bc30      	pop	{r4, r5}
   17014:	4770      	bx	lr
   17016:	bf00      	nop
   17018:	020f6e5c 	.word	0x020f6e5c
   1701c:	0001a895 	.word	0x0001a895
   17020:	0001aea9 	.word	0x0001aea9
   17024:	0001bd3d 	.word	0x0001bd3d
   17028:	0001c011 	.word	0x0001c011
   1702c:	0001c1c5 	.word	0x0001c1c5
   17030:	0001c3bd 	.word	0x0001c3bd
   17034:	020f6ec0 	.word	0x020f6ec0
   17038:	0001c725 	.word	0x0001c725
   1703c:	0001d169 	.word	0x0001d169
   17040:	0001a9e9 	.word	0x0001a9e9
   17044:	0001b2c5 	.word	0x0001b2c5
   17048:	0001bdf9 	.word	0x0001bdf9
   1704c:	0001c0e9 	.word	0x0001c0e9
   17050:	0001c1ed 	.word	0x0001c1ed
   17054:	0001c461 	.word	0x0001c461
   17058:	0001c88d 	.word	0x0001c88d
   1705c:	0001d295 	.word	0x0001d295
   17060:	020f6dc0 	.word	0x020f6dc0
   17064:	0001ac5d 	.word	0x0001ac5d
   17068:	0001b999 	.word	0x0001b999
   1706c:	0001bdfd 	.word	0x0001bdfd
   17070:	00021111 	.word	0x00021111
   17074:	0001c2ed 	.word	0x0001c2ed
   17078:	0001c465 	.word	0x0001c465
   1707c:	0001cb71 	.word	0x0001cb71
   17080:	0001d2c1 	.word	0x0001d2c1
   17084:	020f6e0c 	.word	0x020f6e0c
   17088:	0001ae35 	.word	0x0001ae35
   1708c:	0001bc89 	.word	0x0001bc89
   17090:	0001bfc5 	.word	0x0001bfc5
   17094:	0001c1a1 	.word	0x0001c1a1
   17098:	0001c3b1 	.word	0x0001c3b1
   1709c:	0001c6f5 	.word	0x0001c6f5
   170a0:	0001d139 	.word	0x0001d139
   170a4:	0001d851 	.word	0x0001d851
   170a8:	0001d891 	.word	0x0001d891
   170ac:	0001d96d 	.word	0x0001d96d
   170b0:	0001da35 	.word	0x0001da35
   170b4:	0001db21 	.word	0x0001db21
   170b8:	0001db51 	.word	0x0001db51
   170bc:	0001dbad 	.word	0x0001dbad
   170c0:	0001dbd5 	.word	0x0001dbd5
   170c4:	0001dce9 	.word	0x0001dce9
   170c8:	0001dd19 	.word	0x0001dd19
   170cc:	0001dd49 	.word	0x0001dd49
   170d0:	0001dd71 	.word	0x0001dd71
   170d4:	0001ded9 	.word	0x0001ded9
   170d8:	0001def5 	.word	0x0001def5
   170dc:	0001dfe9 	.word	0x0001dfe9
   170e0:	0001e04d 	.word	0x0001e04d
   170e4:	0001e2c5 	.word	0x0001e2c5
   170e8:	0001e31d 	.word	0x0001e31d
   170ec:	0001e36d 	.word	0x0001e36d
   170f0:	0001e3fd 	.word	0x0001e3fd
   170f4:	0001e4fd 	.word	0x0001e4fd
   170f8:	0001e519 	.word	0x0001e519
   170fc:	0001e5e5 	.word	0x0001e5e5
   17100:	0001e5e9 	.word	0x0001e5e9
   17104:	0001e7a5 	.word	0x0001e7a5
   17108:	0001e7f1 	.word	0x0001e7f1
   1710c:	0001e8e1 	.word	0x0001e8e1
   17110:	0001ed3d 	.word	0x0001ed3d
   17114:	0001ed95 	.word	0x0001ed95
   17118:	0001edb9 	.word	0x0001edb9
   1711c:	0001ef31 	.word	0x0001ef31
   17120:	0001f29d 	.word	0x0001f29d
   17124:	0001f365 	.word	0x0001f365
   17128:	0001f3bd 	.word	0x0001f3bd
   1712c:	0001f6c9 	.word	0x0001f6c9
   17130:	0001fd71 	.word	0x0001fd71
   17134:	0001fea5 	.word	0x0001fea5
   17138:	0001ff25 	.word	0x0001ff25
   1713c:	00020089 	.word	0x00020089
   17140:	00020aa9 	.word	0x00020aa9
   17144:	00020e25 	.word	0x00020e25

00017148 <audioInit>:
{
   17148:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   1714c:	4b47      	ldr	r3, [pc, #284]	; (1726c <audioInit+0x124>)
{
   1714e:	4606      	mov	r6, r0
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   17150:	ed9f 0a47 	vldr	s0, [pc, #284]	; 17270 <audioInit+0x128>
   17154:	2080      	movs	r0, #128	; 0x80
{
   17156:	4688      	mov	r8, r1
   17158:	4617      	mov	r7, r2
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   1715a:	4946      	ldr	r1, [pc, #280]	; (17274 <audioInit+0x12c>)
   1715c:	4a46      	ldr	r2, [pc, #280]	; (17278 <audioInit+0x130>)
   1715e:	4c47      	ldr	r4, [pc, #284]	; (1727c <audioInit+0x134>)
{
   17160:	ed2d 8b02 	vpush	{d8}
   17164:	b086      	sub	sp, #24
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   17166:	eddf 8a46 	vldr	s17, [pc, #280]	; 17280 <audioInit+0x138>
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
   1716a:	f015 fbf3 	bl	2c954 <LEAF_init>
	tMempool_init (&smallPool, small_memory, SMALL_MEM_SIZE);
   1716e:	4a45      	ldr	r2, [pc, #276]	; (17284 <audioInit+0x13c>)
   17170:	4945      	ldr	r1, [pc, #276]	; (17288 <audioInit+0x140>)
   17172:	f104 0518 	add.w	r5, r4, #24
   17176:	4845      	ldr	r0, [pc, #276]	; (1728c <audioInit+0x144>)
   17178:	f012 fe9a 	bl	29eb0 <tMempool_init>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
   1717c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   17180:	4943      	ldr	r1, [pc, #268]	; (17290 <audioInit+0x148>)
   17182:	4844      	ldr	r0, [pc, #272]	; (17294 <audioInit+0x14c>)
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   17184:	ed9f 8a44 	vldr	s16, [pc, #272]	; 17298 <audioInit+0x150>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
   17188:	f012 fe92 	bl	29eb0 <tMempool_init>
	initFunctionPointers();
   1718c:	f7ff feac 	bl	16ee8 <initFunctionPointers>
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
   17190:	4620      	mov	r0, r4
   17192:	3404      	adds	r4, #4
   17194:	eef0 0a68 	vmov.f32	s1, s17
   17198:	eeb0 0a48 	vmov.f32	s0, s16
   1719c:	f010 fe7a 	bl	27e94 <tExpSmooth_init>
	for (int i = 0; i < 6; i++)
   171a0:	42ac      	cmp	r4, r5
   171a2:	d1f5      	bne.n	17190 <audioInit+0x48>
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
   171a4:	eddf 0a3d 	vldr	s1, [pc, #244]	; 1729c <audioInit+0x154>
	loadingPreset = 1;
   171a8:	2401      	movs	r4, #1
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
   171aa:	ed9f 0a3d 	vldr	s0, [pc, #244]	; 172a0 <audioInit+0x158>
   171ae:	483d      	ldr	r0, [pc, #244]	; (172a4 <audioInit+0x15c>)
   171b0:	f00d f860 	bl	24274 <tEnvelopeFollower_init>
   171b4:	eddf 0a39 	vldr	s1, [pc, #228]	; 1729c <audioInit+0x154>
   171b8:	ed9f 0a39 	vldr	s0, [pc, #228]	; 172a0 <audioInit+0x158>
   171bc:	483a      	ldr	r0, [pc, #232]	; (172a8 <audioInit+0x160>)
   171be:	f00d f859 	bl	24274 <tEnvelopeFollower_init>
   171c2:	eddf 0a36 	vldr	s1, [pc, #216]	; 1729c <audioInit+0x154>
   171c6:	ed9f 0a36 	vldr	s0, [pc, #216]	; 172a0 <audioInit+0x158>
   171ca:	4838      	ldr	r0, [pc, #224]	; (172ac <audioInit+0x164>)
   171cc:	f00d f852 	bl	24274 <tEnvelopeFollower_init>
   171d0:	eddf 0a32 	vldr	s1, [pc, #200]	; 1729c <audioInit+0x154>
   171d4:	ed9f 0a32 	vldr	s0, [pc, #200]	; 172a0 <audioInit+0x158>
   171d8:	4835      	ldr	r0, [pc, #212]	; (172b0 <audioInit+0x168>)
   171da:	f00d f84b 	bl	24274 <tEnvelopeFollower_init>
	LEAF_generate_atodbPositiveClipped(atodbTable, -120.0f, 380.0f, ATODB_TABLE_SIZE);
   171de:	eddf 0a35 	vldr	s1, [pc, #212]	; 172b4 <audioInit+0x16c>
   171e2:	ed9f 0a35 	vldr	s0, [pc, #212]	; 172b8 <audioInit+0x170>
   171e6:	f44f 7100 	mov.w	r1, #512	; 0x200
   171ea:	4834      	ldr	r0, [pc, #208]	; (172bc <audioInit+0x174>)
   171ec:	f012 fbe8 	bl	299c0 <LEAF_generate_atodbPositiveClipped>
	initGlobalSFXObjects();
   171f0:	f003 f896 	bl	1a320 <initGlobalSFXObjects>
	previousPreset = PresetNil;
   171f4:	4b32      	ldr	r3, [pc, #200]	; (172c0 <audioInit+0x178>)
	loadingPreset = 1;
   171f6:	4933      	ldr	r1, [pc, #204]	; (172c4 <audioInit+0x17c>)
	previousPreset = PresetNil;
   171f8:	2212      	movs	r2, #18
	HAL_Delay(10);
   171fa:	200a      	movs	r0, #10
	previousPreset = PresetNil;
   171fc:	701a      	strb	r2, [r3, #0]
	loadingPreset = 1;
   171fe:	700c      	strb	r4, [r1, #0]
	HAL_Delay(10);
   17200:	f7f1 f8fe 	bl	8400 <HAL_Delay>
   17204:	f44f 6200 	mov.w	r2, #2048	; 0x800
   17208:	2100      	movs	r1, #0
   1720a:	482f      	ldr	r0, [pc, #188]	; (172c8 <audioInit+0x180>)
   1720c:	f015 fc19 	bl	2ca42 <memset>
	HAL_Delay(1);
   17210:	4620      	mov	r0, r4
   17212:	f7f1 f8f5 	bl	8400 <HAL_Delay>
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   17216:	4640      	mov	r0, r8
   17218:	f44f 7200 	mov.w	r2, #512	; 0x200
   1721c:	492a      	ldr	r1, [pc, #168]	; (172c8 <audioInit+0x180>)
   1721e:	f7f9 fe17 	bl	10e50 <HAL_SAI_Transmit_DMA>
   17222:	4b2a      	ldr	r3, [pc, #168]	; (172cc <audioInit+0x184>)
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   17224:	f44f 7200 	mov.w	r2, #512	; 0x200
   17228:	4929      	ldr	r1, [pc, #164]	; (172d0 <audioInit+0x188>)
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
   1722a:	7018      	strb	r0, [r3, #0]
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
   1722c:	4638      	mov	r0, r7
   1722e:	f7f9 fe9f 	bl	10f70 <HAL_SAI_Receive_DMA>
   17232:	4b28      	ldr	r3, [pc, #160]	; (172d4 <audioInit+0x18c>)
   17234:	7018      	strb	r0, [r3, #0]
	AudioCodec_init(hi2c);
   17236:	4630      	mov	r0, r6
   17238:	f000 f8e0 	bl	173fc <AudioCodec_init>
	HAL_Delay(1);
   1723c:	4620      	mov	r0, r4
   1723e:	f7f1 f8df 	bl	8400 <HAL_Delay>
	HAL_I2C_MspDeInit(hi2c);
   17242:	4630      	mov	r0, r6
   17244:	f001 ff3e 	bl	190c4 <HAL_I2C_MspDeInit>
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   17248:	2300      	movs	r3, #0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   1724a:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1724e:	a901      	add	r1, sp, #4
   17250:	4821      	ldr	r0, [pc, #132]	; (172d8 <audioInit+0x190>)
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   17252:	9302      	str	r3, [sp, #8]
   17254:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   17256:	9201      	str	r2, [sp, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
   17258:	e9cd 4303 	strd	r4, r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   1725c:	f7f4 fcb0 	bl	bbc0 <HAL_GPIO_Init>
}
   17260:	b006      	add	sp, #24
   17262:	ecbd 8b02 	vpop	{d8}
   17266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1726a:	bf00      	nop
   1726c:	00019395 	.word	0x00019395
   17270:	473b8000 	.word	0x473b8000
   17274:	00064340 	.word	0x00064340
   17278:	0007eb58 	.word	0x0007eb58
   1727c:	020f6ea8 	.word	0x020f6ea8
   17280:	3e4ccccd 	.word	0x3e4ccccd
   17284:	000139c8 	.word	0x000139c8
   17288:	020e33f8 	.word	0x020e33f8
   1728c:	020f7730 	.word	0x020f7730
   17290:	000e2ea0 	.word	0x000e2ea0
   17294:	020f6e58 	.word	0x020f6e58
   17298:	00000000 	.word	0x00000000
   1729c:	3f7fdf3b 	.word	0x3f7fdf3b
   172a0:	38d1b717 	.word	0x38d1b717
   172a4:	020f6f20 	.word	0x020f6f20
   172a8:	020f6f24 	.word	0x020f6f24
   172ac:	020f6f28 	.word	0x020f6f28
   172b0:	020f6f2c 	.word	0x020f6f2c
   172b4:	43be0000 	.word	0x43be0000
   172b8:	c2f00000 	.word	0xc2f00000
   172bc:	020f6f30 	.word	0x020f6f30
   172c0:	00062b60 	.word	0x00062b60
   172c4:	020e325b 	.word	0x020e325b
   172c8:	000635c0 	.word	0x000635c0
   172cc:	020f6e08 	.word	0x020f6e08
   172d0:	00062dc0 	.word	0x00062dc0
   172d4:	020f6ea4 	.word	0x020f6ea4
   172d8:	58020400 	.word	0x58020400

000172dc <HAL_SAI_ErrorCallback>:



void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
	setLED_Edit(1);
   172dc:	2001      	movs	r0, #1
   172de:	f002 b8f1 	b.w	194c4 <setLED_Edit>
   172e2:	bf00      	nop

000172e4 <HAL_SAI_TxCpltCallback>:
   172e4:	4770      	bx	lr
   172e6:	bf00      	nop

000172e8 <HAL_SAI_TxHalfCpltCallback>:
}

void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{

}
   172e8:	4770      	bx	lr
   172ea:	bf00      	nop

000172ec <HAL_SAI_RxCpltCallback>:


void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(HALF_BUFFER_SIZE);
   172ec:	f44f 7080 	mov.w	r0, #256	; 0x100
   172f0:	f7ff bb92 	b.w	16a18 <audioFrame>

000172f4 <HAL_SAI_RxHalfCpltCallback>:
}

void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(0);
   172f4:	2000      	movs	r0, #0
   172f6:	f7ff bb8f 	b.w	16a18 <audioFrame>
   172fa:	bf00      	nop

000172fc <MX_BDMA_Init>:
  */
void MX_BDMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_BDMA_CLK_ENABLE();
   172fc:	4b10      	ldr	r3, [pc, #64]	; (17340 <MX_BDMA_Init+0x44>)

  /* DMA interrupt init */
  /* BDMA_Channel0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   172fe:	2200      	movs	r2, #0
   17300:	2081      	movs	r0, #129	; 0x81
   17302:	4611      	mov	r1, r2
{
   17304:	b510      	push	{r4, lr}
  __HAL_RCC_BDMA_CLK_ENABLE();
   17306:	f8d3 40e0 	ldr.w	r4, [r3, #224]	; 0xe0
{
   1730a:	b082      	sub	sp, #8
  __HAL_RCC_BDMA_CLK_ENABLE();
   1730c:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
   17310:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
   17314:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   17318:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
   1731c:	9301      	str	r3, [sp, #4]
   1731e:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
   17320:	f7f2 fb58 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel0_IRQn);
   17324:	2081      	movs	r0, #129	; 0x81
   17326:	f7f2 fb9b 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* BDMA_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel1_IRQn, 0, 0);
   1732a:	2200      	movs	r2, #0
   1732c:	2082      	movs	r0, #130	; 0x82
   1732e:	4611      	mov	r1, r2
   17330:	f7f2 fb50 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
   17334:	2082      	movs	r0, #130	; 0x82

}
   17336:	b002      	add	sp, #8
   17338:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
   1733c:	f7f2 bb90 	b.w	9a60 <HAL_NVIC_EnableIRQ>
   17340:	58024400 	.word	0x58024400

00017344 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
   17344:	b500      	push	{lr}
   17346:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_ReadBlocks(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
   17348:	9300      	str	r3, [sp, #0]
   1734a:	4613      	mov	r3, r2
   1734c:	460a      	mov	r2, r1
   1734e:	4601      	mov	r1, r0
   17350:	4804      	ldr	r0, [pc, #16]	; (17364 <BSP_SD_ReadBlocks+0x20>)
   17352:	f7f9 ff9b 	bl	1128c <HAL_SD_ReadBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
   17356:	3000      	adds	r0, #0
   17358:	bf18      	it	ne
   1735a:	2001      	movne	r0, #1
   1735c:	b003      	add	sp, #12
   1735e:	f85d fb04 	ldr.w	pc, [sp], #4
   17362:	bf00      	nop
   17364:	020f84d0 	.word	0x020f84d0

00017368 <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
   17368:	b500      	push	{lr}
   1736a:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_WriteBlocks(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
   1736c:	9300      	str	r3, [sp, #0]
   1736e:	4613      	mov	r3, r2
   17370:	460a      	mov	r2, r1
   17372:	4601      	mov	r1, r0
   17374:	4804      	ldr	r0, [pc, #16]	; (17388 <BSP_SD_WriteBlocks+0x20>)
   17376:	f7fa f88b 	bl	11490 <HAL_SD_WriteBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
   1737a:	3000      	adds	r0, #0
   1737c:	bf18      	it	ne
   1737e:	2001      	movne	r0, #1
   17380:	b003      	add	sp, #12
   17382:	f85d fb04 	ldr.w	pc, [sp], #4
   17386:	bf00      	nop
   17388:	020f84d0 	.word	0x020f84d0

0001738c <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
   1738c:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
   1738e:	4803      	ldr	r0, [pc, #12]	; (1739c <BSP_SD_GetCardState+0x10>)
   17390:	f7fa fe1c 	bl	11fcc <HAL_SD_GetCardState>
}
   17394:	3804      	subs	r0, #4
   17396:	bf18      	it	ne
   17398:	2001      	movne	r0, #1
   1739a:	bd08      	pop	{r3, pc}
   1739c:	020f84d0 	.word	0x020f84d0

000173a0 <BSP_SD_GetCardInfo>:
  * @retval None 
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
   173a0:	4601      	mov	r1, r0
   173a2:	4801      	ldr	r0, [pc, #4]	; (173a8 <BSP_SD_GetCardInfo+0x8>)
   173a4:	f7fa bc88 	b.w	11cb8 <HAL_SD_GetCardInfo>
   173a8:	020f84d0 	.word	0x020f84d0

000173ac <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
   173ac:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
   173ae:	2301      	movs	r3, #1
{
   173b0:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
   173b2:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0) 
   173b6:	f000 fc69 	bl	17c8c <BSP_PlatformIsDetected>
   173ba:	b908      	cbnz	r0, 173c0 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
   173bc:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
   173c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
   173c4:	b003      	add	sp, #12
   173c6:	f85d fb04 	ldr.w	pc, [sp], #4
   173ca:	bf00      	nop

000173cc <BSP_SD_Init>:
{
   173cc:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
   173ce:	f7ff ffed 	bl	173ac <BSP_SD_IsDetected>
   173d2:	2801      	cmp	r0, #1
   173d4:	d001      	beq.n	173da <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
   173d6:	2002      	movs	r0, #2
}
   173d8:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
   173da:	4807      	ldr	r0, [pc, #28]	; (173f8 <BSP_SD_Init+0x2c>)
   173dc:	f7fa fd30 	bl	11e40 <HAL_SD_Init>
  if (sd_state == MSD_OK)
   173e0:	2800      	cmp	r0, #0
   173e2:	d1f9      	bne.n	173d8 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
   173e4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   173e8:	4803      	ldr	r0, [pc, #12]	; (173f8 <BSP_SD_Init+0x2c>)
   173ea:	f7fa fc79 	bl	11ce0 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
   173ee:	3000      	adds	r0, #0
   173f0:	bf18      	it	ne
   173f2:	2001      	movne	r0, #1
}
   173f4:	bd08      	pop	{r3, pc}
   173f6:	bf00      	nop
   173f8:	020f84d0 	.word	0x020f84d0

000173fc <AudioCodec_init>:

volatile int blankCount = 0;
uint16_t addressCounter = 0;


void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
   173fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	//pull codec reset pin high to start codec working
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   17400:	2201      	movs	r2, #1
void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
   17402:	b082      	sub	sp, #8
   17404:	4605      	mov	r5, r0

	HAL_Delay(2);
	//enable control port and put part in power-down mode while loading registers
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x03;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17406:	4e40      	ldr	r6, [pc, #256]	; (17508 <AudioCodec_init+0x10c>)
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
   17408:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   1740c:	483f      	ldr	r0, [pc, #252]	; (1750c <AudioCodec_init+0x110>)
   1740e:	f7f4 ff11 	bl	c234 <HAL_GPIO_WritePin>
	HAL_Delay(2);
   17412:	2002      	movs	r0, #2
	myI2cData[0] = 0x07;
   17414:	4c3e      	ldr	r4, [pc, #248]	; (17510 <AudioCodec_init+0x114>)
	HAL_Delay(2);
   17416:	f7f0 fff3 	bl	8400 <HAL_Delay>
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1741a:	4f3e      	ldr	r7, [pc, #248]	; (17514 <AudioCodec_init+0x118>)
	myI2cData[0] = 0x07;
   1741c:	f240 3c07 	movw	ip, #775	; 0x307
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17420:	6831      	ldr	r1, [r6, #0]
   17422:	4622      	mov	r2, r4
   17424:	883b      	ldrh	r3, [r7, #0]
   17426:	4628      	mov	r0, r5
   17428:	9100      	str	r1, [sp, #0]
   1742a:	2120      	movs	r1, #32
   1742c:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 1751c <AudioCodec_init+0x120>
	myI2cData[0] = 0x07;
   17430:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17434:	f7f5 fa20 	bl	c878 <HAL_I2C_Master_Transmit>
	//HAL_Delay(2);

	myI2cData[0] = 0x01;
	myI2cData[1] = 0x41;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17438:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x01;
   1743a:	f244 1c01 	movw	ip, #16641	; 0x4101
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1743e:	883b      	ldrh	r3, [r7, #0]
   17440:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17442:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17446:	4628      	mov	r0, r5
   17448:	9100      	str	r1, [sp, #0]
   1744a:	2120      	movs	r1, #32
	myI2cData[0] = 0x01;
   1744c:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17450:	f7f5 fa12 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x02;
	myI2cData[1] = 0x00;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17454:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x02;
   17456:	f04f 0c02 	mov.w	ip, #2
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1745a:	883b      	ldrh	r3, [r7, #0]
   1745c:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1745e:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17462:	4628      	mov	r0, r5
   17464:	9200      	str	r2, [sp, #0]
   17466:	4622      	mov	r2, r4
	myI2cData[0] = 0x02;
   17468:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1746c:	f7f5 fa04 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x03;
	myI2cData[1] = 0x79;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17470:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x03;
   17472:	f647 1c03 	movw	ip, #30979	; 0x7903
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17476:	883b      	ldrh	r3, [r7, #0]
   17478:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1747a:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1747e:	4628      	mov	r0, r5
   17480:	9100      	str	r1, [sp, #0]
   17482:	2120      	movs	r1, #32
	myI2cData[0] = 0x03;
   17484:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17488:	f7f5 f9f6 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x04;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1748c:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x04;
   1748e:	f44f 7c82 	mov.w	ip, #260	; 0x104
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17492:	883b      	ldrh	r3, [r7, #0]
   17494:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   17496:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   1749a:	4628      	mov	r0, r5
   1749c:	9200      	str	r2, [sp, #0]
   1749e:	4622      	mov	r2, r4
	myI2cData[0] = 0x04;
   174a0:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174a4:	f7f5 f9e8 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x05;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174a8:	6831      	ldr	r1, [r6, #0]
	myI2cData[0] = 0x05;
   174aa:	f240 1c05 	movw	ip, #261	; 0x105
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ae:	883b      	ldrh	r3, [r7, #0]
   174b0:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174b2:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174b6:	4628      	mov	r0, r5
   174b8:	9100      	str	r1, [sp, #0]
   174ba:	2120      	movs	r1, #32
	myI2cData[0] = 0x05;
   174bc:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174c0:	f7f5 f9da 	bl	c878 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x06;
	myI2cData[1] = 0x10;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174c4:	6832      	ldr	r2, [r6, #0]
	myI2cData[0] = 0x06;
   174c6:	f241 0c06 	movw	ip, #4102	; 0x1006
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ca:	883b      	ldrh	r3, [r7, #0]
   174cc:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ce:	f888 0000 	strb.w	r0, [r8]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174d2:	4628      	mov	r0, r5
   174d4:	9200      	str	r2, [sp, #0]
   174d6:	4622      	mov	r2, r4
	myI2cData[0] = 0x06;
   174d8:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174dc:	f7f5 f9cc 	bl	c878 <HAL_I2C_Master_Transmit>
	//HAL_Delay(1); // might not be necessary

	//turn off power down bit to start things cookin'
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x02;
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174e0:	6831      	ldr	r1, [r6, #0]
   174e2:	4622      	mov	r2, r4
   174e4:	883b      	ldrh	r3, [r7, #0]
	myI2cData[0] = 0x07;
   174e6:	f240 2707 	movw	r7, #519	; 0x207
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ea:	f888 0000 	strb.w	r0, [r8]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174ee:	4628      	mov	r0, r5
   174f0:	9100      	str	r1, [sp, #0]
   174f2:	2120      	movs	r1, #32
	myI2cData[0] = 0x07;
   174f4:	8027      	strh	r7, [r4, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
   174f6:	f7f5 f9bf 	bl	c878 <HAL_I2C_Master_Transmit>


	//HAL_Delay(1); // might not be necessary
	codecReady = 1;
   174fa:	4b07      	ldr	r3, [pc, #28]	; (17518 <AudioCodec_init+0x11c>)
   174fc:	2201      	movs	r2, #1
   174fe:	701a      	strb	r2, [r3, #0]

}
   17500:	b002      	add	sp, #8
   17502:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17506:	bf00      	nop
   17508:	000628a4 	.word	0x000628a4
   1750c:	58020800 	.word	0x58020800
   17510:	020e3108 	.word	0x020e3108
   17514:	000628a8 	.word	0x000628a8
   17518:	020e3100 	.word	0x020e3100
   1751c:	020f7734 	.word	0x020f7734

00017520 <MX_DMA_Init>:
  */
void MX_DMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
   17520:	4b1e      	ldr	r3, [pc, #120]	; (1759c <MX_DMA_Init+0x7c>)
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
   17522:	2200      	movs	r2, #0
   17524:	2103      	movs	r1, #3
   17526:	200c      	movs	r0, #12
{
   17528:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
   1752a:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
{
   1752e:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
   17530:	f044 0402 	orr.w	r4, r4, #2
   17534:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
   17538:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
   1753c:	f004 0402 	and.w	r4, r4, #2
   17540:	9400      	str	r4, [sp, #0]
   17542:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
   17544:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
   17548:	f044 0401 	orr.w	r4, r4, #1
   1754c:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
   17550:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
   17554:	f003 0301 	and.w	r3, r3, #1
   17558:	9301      	str	r3, [sp, #4]
   1755a:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
   1755c:	f7f2 fa3a 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
   17560:	200c      	movs	r0, #12
   17562:	f7f2 fa7d 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 3, 0);
   17566:	2200      	movs	r2, #0
   17568:	2103      	movs	r1, #3
   1756a:	200d      	movs	r0, #13
   1756c:	f7f2 fa32 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
   17570:	200d      	movs	r0, #13
   17572:	f7f2 fa75 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 4, 0);
   17576:	2200      	movs	r2, #0
   17578:	2104      	movs	r1, #4
   1757a:	2038      	movs	r0, #56	; 0x38
   1757c:	f7f2 fa2a 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
   17580:	2038      	movs	r0, #56	; 0x38
   17582:	f7f2 fa6d 	bl	9a60 <HAL_NVIC_EnableIRQ>
  /* DMAMUX1_OVR_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMAMUX1_OVR_IRQn, 0, 0);
   17586:	2200      	movs	r2, #0
   17588:	2066      	movs	r0, #102	; 0x66
   1758a:	4611      	mov	r1, r2
   1758c:	f7f2 fa22 	bl	99d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
   17590:	2066      	movs	r0, #102	; 0x66

}
   17592:	b002      	add	sp, #8
   17594:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
   17598:	f7f2 ba62 	b.w	9a60 <HAL_NVIC_EnableIRQ>
   1759c:	58024400 	.word	0x58024400

000175a0 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
   175a0:	b510      	push	{r4, lr}
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint16_t ValidPage = PAGE0;
  uint32_t Address = EEPROM_START_ADDRESS, PageEndAddress = EEPROM_START_ADDRESS+PAGE_SIZE;

  uint32_t data32[8] = {Data};
   175a2:	2300      	movs	r3, #0
{
   175a4:	b090      	sub	sp, #64	; 0x40
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   175a6:	4c25      	ldr	r4, [pc, #148]	; (1763c <EE_VerifyPageFullWriteVariable+0x9c>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   175a8:	4a25      	ldr	r2, [pc, #148]	; (17640 <EE_VerifyPageFullWriteVariable+0xa0>)
  uint32_t data32[8] = {Data};
   175aa:	9100      	str	r1, [sp, #0]
  uint32_t VirtAddress1[8] = {VirtAddress};
   175ac:	9008      	str	r0, [sp, #32]
  uint32_t data32[8] = {Data};
   175ae:	9307      	str	r3, [sp, #28]
  uint32_t VirtAddress1[8] = {VirtAddress};
   175b0:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t data32[8] = {Data};
   175b2:	e9cd 3301 	strd	r3, r3, [sp, #4]
   175b6:	e9cd 3303 	strd	r3, r3, [sp, #12]
   175ba:	e9cd 3305 	strd	r3, r3, [sp, #20]
  uint32_t VirtAddress1[8] = {VirtAddress};
   175be:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   175c2:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   175c6:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   175ca:	8823      	ldrh	r3, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   175cc:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   175ce:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   175d0:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
   175d2:	b9ea      	cbnz	r2, 17610 <EE_VerifyPageFullWriteVariable+0x70>
        if (PageStatus0 == RECEIVE_DATA)
   175d4:	f64e 62ee 	movw	r2, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
   175d8:	1a9b      	subs	r3, r3, r2
   175da:	bf18      	it	ne
   175dc:	2301      	movne	r3, #1
  {
    return  NO_VALID_PAGE;
  }

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   175de:	f203 440e 	addw	r4, r3, #1038	; 0x40e

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   175e2:	4a18      	ldr	r2, [pc, #96]	; (17644 <EE_VerifyPageFullWriteVariable+0xa4>)
   175e4:	3301      	adds	r3, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   175e6:	0464      	lsls	r4, r4, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   175e8:	eb02 4243 	add.w	r2, r2, r3, lsl #17

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
   175ec:	4294      	cmp	r4, r2
   175ee:	d303      	bcc.n	175f8 <EE_VerifyPageFullWriteVariable+0x58>
   175f0:	e016      	b.n	17620 <EE_VerifyPageFullWriteVariable+0x80>
     return FlashStatus;
    }
    else
    {
      /* Next address location */
      Address = Address + 64;
   175f2:	3440      	adds	r4, #64	; 0x40
  while (Address < PageEndAddress)
   175f4:	42a2      	cmp	r2, r4
   175f6:	d913      	bls.n	17620 <EE_VerifyPageFullWriteVariable+0x80>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
   175f8:	6823      	ldr	r3, [r4, #0]
   175fa:	3301      	adds	r3, #1
   175fc:	d1f9      	bne.n	175f2 <EE_VerifyPageFullWriteVariable+0x52>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
   175fe:	466a      	mov	r2, sp
   17600:	4621      	mov	r1, r4
   17602:	2001      	movs	r0, #1
   17604:	f7f4 f858 	bl	b6b8 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
   17608:	b180      	cbz	r0, 1762c <EE_VerifyPageFullWriteVariable+0x8c>
     return FlashStatus;
   1760a:	b280      	uxth	r0, r0
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
}
   1760c:	b010      	add	sp, #64	; 0x40
   1760e:	bd10      	pop	{r4, pc}
      else if (PageStatus0 == VALID_PAGE)
   17610:	b94b      	cbnz	r3, 17626 <EE_VerifyPageFullWriteVariable+0x86>
        if (PageStatus1 == RECEIVE_DATA)
   17612:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
   17616:	1ad3      	subs	r3, r2, r3
   17618:	fab3 f383 	clz	r3, r3
   1761c:	095b      	lsrs	r3, r3, #5
   1761e:	e7de      	b.n	175de <EE_VerifyPageFullWriteVariable+0x3e>
  return PAGE_FULL;
   17620:	2080      	movs	r0, #128	; 0x80
}
   17622:	b010      	add	sp, #64	; 0x40
   17624:	bd10      	pop	{r4, pc}
    return  NO_VALID_PAGE;
   17626:	20ab      	movs	r0, #171	; 0xab
}
   17628:	b010      	add	sp, #64	; 0x40
   1762a:	bd10      	pop	{r4, pc}
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
   1762c:	f104 0120 	add.w	r1, r4, #32
   17630:	aa08      	add	r2, sp, #32
   17632:	2001      	movs	r0, #1
   17634:	f7f4 f840 	bl	b6b8 <HAL_FLASH_Program>
   17638:	e7e7      	b.n	1760a <EE_VerifyPageFullWriteVariable+0x6a>
   1763a:	bf00      	nop
   1763c:	081c0000 	.word	0x081c0000
   17640:	081e0000 	.word	0x081e0000
   17644:	081bffff 	.word	0x081bffff

00017648 <EE_Init>:
{
   17648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t SectorError = 0;
   1764c:	f04f 0800 	mov.w	r8, #0
{
   17650:	b09f      	sub	sp, #124	; 0x7c
  uint32_t valid[8] = {0x0000};
   17652:	f04f 0920 	mov.w	r9, #32
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17656:	4cb3      	ldr	r4, [pc, #716]	; (17924 <EE_Init+0x2dc>)
  uint32_t valid[8] = {0x0000};
   17658:	4641      	mov	r1, r8
   1765a:	a80e      	add	r0, sp, #56	; 0x38
   1765c:	464a      	mov	r2, r9
  uint32_t SectorError = 0;
   1765e:	f8cd 8008 	str.w	r8, [sp, #8]
  uint32_t valid[8] = {0x0000};
   17662:	f015 f9ee 	bl	2ca42 <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17666:	8825      	ldrh	r5, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17668:	4eaf      	ldr	r6, [pc, #700]	; (17928 <EE_Init+0x2e0>)
  switch (PageStatus0)
   1766a:	f64e 62ee 	movw	r2, #61166	; 0xeeee
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1766e:	b2ad      	uxth	r5, r5
  pEraseInit.Banks = FLASH_BANK_2 ;
   17670:	2302      	movs	r3, #2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17672:	8830      	ldrh	r0, [r6, #0]
  pEraseInit.Sector = PAGE0_ID;
   17674:	f04f 0b06 	mov.w	fp, #6
  pEraseInit.NbSectors = 1;
   17678:	f04f 0a01 	mov.w	sl, #1
  switch (PageStatus0)
   1767c:	4295      	cmp	r5, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1767e:	b287      	uxth	r7, r0
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   17680:	f8cd 8010 	str.w	r8, [sp, #16]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17684:	f8cd 9020 	str.w	r9, [sp, #32]
  pEraseInit.NbSectors = 1;
   17688:	f8cd a01c 	str.w	sl, [sp, #28]
  pEraseInit.Sector = PAGE0_ID;
   1768c:	e9cd 3b05 	strd	r3, fp, [sp, #20]
  switch (PageStatus0)
   17690:	f000 80bf 	beq.w	17812 <EE_Init+0x1ca>
   17694:	f64f 71ff 	movw	r1, #65535	; 0xffff
   17698:	428d      	cmp	r5, r1
   1769a:	f000 808e 	beq.w	177ba <EE_Init+0x172>
   1769e:	b35d      	cbz	r5, 176f8 <EE_Init+0xb0>
   176a0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   176a2:	ab16      	add	r3, sp, #88	; 0x58
   176a4:	464a      	mov	r2, r9
   176a6:	4641      	mov	r1, r8
   176a8:	4618      	mov	r0, r3
   176aa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   176ac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   176b0:	f015 f9c7 	bl	2ca42 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   176b4:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
   176b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   176ba:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   176be:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   176c2:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   176c6:	e001      	b.n	176cc <EE_Init+0x84>
  while (Address <= PAGE0_END_ADDRESS)
   176c8:	42b4      	cmp	r4, r6
   176ca:	d009      	beq.n	176e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
   176cc:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   176ce:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   176d0:	429a      	cmp	r2, r3
   176d2:	d0f9      	beq.n	176c8 <EE_Init+0x80>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   176d4:	a903      	add	r1, sp, #12
   176d6:	a809      	add	r0, sp, #36	; 0x24
   176d8:	f7f4 f968 	bl	b9ac <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
   176dc:	2800      	cmp	r0, #0
   176de:	d167      	bne.n	177b0 <EE_Init+0x168>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
   176e0:	9a00      	ldr	r2, [sp, #0]
   176e2:	2001      	movs	r0, #1
   176e4:	498f      	ldr	r1, [pc, #572]	; (17924 <EE_Init+0x2dc>)
   176e6:	f7f3 ffe7 	bl	b6b8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   176ea:	2800      	cmp	r0, #0
   176ec:	d160      	bne.n	177b0 <EE_Init+0x168>
  return HAL_OK;
   176ee:	2700      	movs	r7, #0
}
   176f0:	4638      	mov	r0, r7
   176f2:	b01f      	add	sp, #124	; 0x7c
   176f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
   176f8:	2f00      	cmp	r7, #0
   176fa:	f000 8101 	beq.w	17900 <EE_Init+0x2b8>
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
   176fe:	f64f 73ff 	movw	r3, #65535	; 0xffff
   17702:	429f      	cmp	r7, r3
   17704:	d0f3      	beq.n	176ee <EE_Init+0xa6>
  int16_t x = -1;
   17706:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1770a:	4e88      	ldr	r6, [pc, #544]	; (1792c <EE_Init+0x2e4>)
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1770c:	f8df 822c 	ldr.w	r8, [pc, #556]	; 1793c <EE_Init+0x2f4>
      if (PageStatus0 == VALID_PAGE)
   17710:	f8df b22c 	ldr.w	fp, [pc, #556]	; 17940 <EE_Init+0x2f8>
   17714:	f8df 922c 	ldr.w	r9, [pc, #556]	; 17944 <EE_Init+0x2fc>
   17718:	f8df a22c 	ldr.w	sl, [pc, #556]	; 17948 <EE_Init+0x300>
      else if (PageStatus1 == VALID_PAGE)
   1771c:	4a84      	ldr	r2, [pc, #528]	; (17930 <EE_Init+0x2e8>)
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1771e:	f8b8 3000 	ldrh.w	r3, [r8]
   17722:	f836 0015 	ldrh.w	r0, [r6, r5, lsl #1]
   17726:	4298      	cmp	r0, r3
            x = VarIdx;
   17728:	bf08      	it	eq
   1772a:	b22c      	sxtheq	r4, r5
          if (VarIdx != x)
   1772c:	42a5      	cmp	r5, r4
   1772e:	d01d      	beq.n	1776c <EE_Init+0x124>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17730:	4b7c      	ldr	r3, [pc, #496]	; (17924 <EE_Init+0x2dc>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17732:	497d      	ldr	r1, [pc, #500]	; (17928 <EE_Init+0x2e0>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17734:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17736:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17738:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1773a:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   1773c:	2b00      	cmp	r3, #0
   1773e:	f000 8122 	beq.w	17986 <EE_Init+0x33e>
      else if (PageStatus1 == VALID_PAGE)
   17742:	2900      	cmp	r1, #0
   17744:	f040 8151 	bne.w	179ea <EE_Init+0x3a2>
   17748:	497a      	ldr	r1, [pc, #488]	; (17934 <EE_Init+0x2ec>)
   1774a:	4694      	mov	ip, r2
   1774c:	4f7a      	ldr	r7, [pc, #488]	; (17938 <EE_Init+0x2f0>)
   1774e:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   17750:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   17752:	4288      	cmp	r0, r1
   17754:	d106      	bne.n	17764 <EE_Init+0x11c>
   17756:	e12c      	b.n	179b2 <EE_Init+0x36a>
    AddressValue = (*(__IO uint16_t*)Address);
   17758:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
   1775c:	42b8      	cmp	r0, r7
   1775e:	f000 8126 	beq.w	179ae <EE_Init+0x366>
   17762:	460b      	mov	r3, r1
      Address = Address - 32;
   17764:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   17768:	458c      	cmp	ip, r1
   1776a:	d3f5      	bcc.n	17758 <EE_Init+0x110>
   1776c:	3501      	adds	r5, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   1776e:	2d03      	cmp	r5, #3
   17770:	d1d5      	bne.n	1771e <EE_Init+0xd6>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
   17772:	aa0e      	add	r2, sp, #56	; 0x38
   17774:	496c      	ldr	r1, [pc, #432]	; (17928 <EE_Init+0x2e0>)
   17776:	2001      	movs	r0, #1
   17778:	f7f3 ff9e 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   1777c:	b9c0      	cbnz	r0, 177b0 <EE_Init+0x168>
        pEraseInit.Sector = PAGE0_ID;
   1777e:	2006      	movs	r0, #6
        pEraseInit.Banks = FLASH_BANK_2 ;
   17780:	2502      	movs	r5, #2
        pEraseInit.NbSectors = 1;
   17782:	2401      	movs	r4, #1
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17784:	2220      	movs	r2, #32
        pEraseInit.Sector = PAGE0_ID;
   17786:	9006      	str	r0, [sp, #24]
    if (AddressValue != ERASED)
   17788:	f64f 71ff 	movw	r1, #65535	; 0xffff
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   1778c:	4b65      	ldr	r3, [pc, #404]	; (17924 <EE_Init+0x2dc>)
  while (Address <= PAGE0_END_ADDRESS)
   1778e:	4866      	ldr	r0, [pc, #408]	; (17928 <EE_Init+0x2e0>)
        pEraseInit.Banks = FLASH_BANK_2 ;
   17790:	9505      	str	r5, [sp, #20]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17792:	e9cd 4207 	strd	r4, r2, [sp, #28]
   17796:	e001      	b.n	1779c <EE_Init+0x154>
  while (Address <= PAGE0_END_ADDRESS)
   17798:	4283      	cmp	r3, r0
   1779a:	d0a8      	beq.n	176ee <EE_Init+0xa6>
    AddressValue = (*(__IO uint16_t*)Address);
   1779c:	881a      	ldrh	r2, [r3, #0]
    Address = Address + 4;
   1779e:	3304      	adds	r3, #4
    if (AddressValue != ERASED)
   177a0:	4291      	cmp	r1, r2
   177a2:	d0f9      	beq.n	17798 <EE_Init+0x150>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   177a4:	a902      	add	r1, sp, #8
   177a6:	a804      	add	r0, sp, #16
   177a8:	f7f4 f900 	bl	b9ac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   177ac:	2800      	cmp	r0, #0
   177ae:	d09e      	beq.n	176ee <EE_Init+0xa6>
        return FlashStatus;
   177b0:	b287      	uxth	r7, r0
}
   177b2:	4638      	mov	r0, r7
   177b4:	b01f      	add	sp, #124	; 0x7c
   177b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
   177ba:	b1ff      	cbz	r7, 177fc <EE_Init+0x1b4>
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
   177bc:	4297      	cmp	r7, r2
   177be:	f000 808b 	beq.w	178d8 <EE_Init+0x290>
   177c2:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   177c4:	ab16      	add	r3, sp, #88	; 0x58
   177c6:	464a      	mov	r2, r9
   177c8:	4641      	mov	r1, r8
   177ca:	4618      	mov	r0, r3
   177cc:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   177ce:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   177d2:	f015 f936 	bl	2ca42 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   177d6:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   177d8:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   177dc:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   177e0:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   177e4:	e002      	b.n	177ec <EE_Init+0x1a4>
  while (Address <= PAGE0_END_ADDRESS)
   177e6:	42b4      	cmp	r4, r6
   177e8:	f43f af7a 	beq.w	176e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
   177ec:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   177ee:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   177f0:	429d      	cmp	r5, r3
   177f2:	d0f8      	beq.n	177e6 <EE_Init+0x19e>
   177f4:	e76e      	b.n	176d4 <EE_Init+0x8c>
  while (Address <= PAGE0_END_ADDRESS)
   177f6:	42b4      	cmp	r4, r6
   177f8:	f43f af79 	beq.w	176ee <EE_Init+0xa6>
    AddressValue = (*(__IO uint16_t*)Address);
   177fc:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   177fe:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   17800:	429d      	cmp	r5, r3
   17802:	d0f8      	beq.n	177f6 <EE_Init+0x1ae>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   17804:	a902      	add	r1, sp, #8
   17806:	a804      	add	r0, sp, #16
   17808:	f7f4 f8d0 	bl	b9ac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   1780c:	2800      	cmp	r0, #0
   1780e:	d1cf      	bne.n	177b0 <EE_Init+0x168>
   17810:	e76d      	b.n	176ee <EE_Init+0xa6>
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
   17812:	2f00      	cmp	r7, #0
   17814:	d13f      	bne.n	17896 <EE_Init+0x24e>
   17816:	463c      	mov	r4, r7
  int16_t x = -1;
   17818:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   1781c:	4e43      	ldr	r6, [pc, #268]	; (1792c <EE_Init+0x2e4>)
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   1781e:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1794c <EE_Init+0x304>
      if (PageStatus0 == VALID_PAGE)
   17822:	f8df b11c 	ldr.w	fp, [pc, #284]	; 17940 <EE_Init+0x2f8>
   17826:	f8df a120 	ldr.w	sl, [pc, #288]	; 17948 <EE_Init+0x300>
   1782a:	f8df 9118 	ldr.w	r9, [pc, #280]	; 17944 <EE_Init+0x2fc>
      else if (PageStatus1 == VALID_PAGE)
   1782e:	4a40      	ldr	r2, [pc, #256]	; (17930 <EE_Init+0x2e8>)
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
   17830:	f8b8 3000 	ldrh.w	r3, [r8]
   17834:	f836 0014 	ldrh.w	r0, [r6, r4, lsl #1]
   17838:	4298      	cmp	r0, r3
            x = VarIdx;
   1783a:	bf08      	it	eq
   1783c:	b225      	sxtheq	r5, r4
          if (VarIdx != x)
   1783e:	42ac      	cmp	r4, r5
   17840:	d01d      	beq.n	1787e <EE_Init+0x236>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17842:	4b38      	ldr	r3, [pc, #224]	; (17924 <EE_Init+0x2dc>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17844:	4938      	ldr	r1, [pc, #224]	; (17928 <EE_Init+0x2e0>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17846:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17848:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   1784a:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   1784c:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   1784e:	2b00      	cmp	r3, #0
   17850:	f000 8094 	beq.w	1797c <EE_Init+0x334>
      else if (PageStatus1 == VALID_PAGE)
   17854:	2900      	cmp	r1, #0
   17856:	f040 80c5 	bne.w	179e4 <EE_Init+0x39c>
   1785a:	4936      	ldr	r1, [pc, #216]	; (17934 <EE_Init+0x2ec>)
   1785c:	4694      	mov	ip, r2
   1785e:	4f36      	ldr	r7, [pc, #216]	; (17938 <EE_Init+0x2f0>)
   17860:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   17862:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   17864:	4288      	cmp	r0, r1
   17866:	d106      	bne.n	17876 <EE_Init+0x22e>
   17868:	e094      	b.n	17994 <EE_Init+0x34c>
    AddressValue = (*(__IO uint16_t*)Address);
   1786a:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
   1786e:	42b8      	cmp	r0, r7
   17870:	f000 808e 	beq.w	17990 <EE_Init+0x348>
   17874:	460b      	mov	r3, r1
      Address = Address - 32;
   17876:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   1787a:	4561      	cmp	r1, ip
   1787c:	d8f5      	bhi.n	1786a <EE_Init+0x222>
   1787e:	3401      	adds	r4, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   17880:	2c03      	cmp	r4, #3
   17882:	d1d5      	bne.n	17830 <EE_Init+0x1e8>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   17884:	aa0e      	add	r2, sp, #56	; 0x38
   17886:	4927      	ldr	r1, [pc, #156]	; (17924 <EE_Init+0x2dc>)
   17888:	2001      	movs	r0, #1
   1788a:	f7f3 ff15 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   1788e:	2800      	cmp	r0, #0
   17890:	f43f af2d 	beq.w	176ee <EE_Init+0xa6>
   17894:	e78c      	b.n	177b0 <EE_Init+0x168>
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
   17896:	f64f 75ff 	movw	r5, #65535	; 0xffff
   1789a:	42af      	cmp	r7, r5
   1789c:	f000 8096 	beq.w	179cc <EE_Init+0x384>
   178a0:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   178a2:	ab16      	add	r3, sp, #88	; 0x58
   178a4:	464a      	mov	r2, r9
   178a6:	4641      	mov	r1, r8
   178a8:	4618      	mov	r0, r3
   178aa:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   178ac:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
   178b0:	f015 f8c7 	bl	2ca42 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   178b4:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   178b6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   178ba:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   178be:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   178c2:	e002      	b.n	178ca <EE_Init+0x282>
  while (Address <= PAGE0_END_ADDRESS)
   178c4:	42b4      	cmp	r4, r6
   178c6:	f43f af0b 	beq.w	176e0 <EE_Init+0x98>
    AddressValue = (*(__IO uint16_t*)Address);
   178ca:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   178cc:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   178ce:	429d      	cmp	r5, r3
   178d0:	d0f8      	beq.n	178c4 <EE_Init+0x27c>
   178d2:	e6ff      	b.n	176d4 <EE_Init+0x8c>
  while (Address <= PAGE0_END_ADDRESS)
   178d4:	42b4      	cmp	r4, r6
   178d6:	d00a      	beq.n	178ee <EE_Init+0x2a6>
    AddressValue = (*(__IO uint16_t*)Address);
   178d8:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   178da:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   178dc:	429d      	cmp	r5, r3
   178de:	d0f9      	beq.n	178d4 <EE_Init+0x28c>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   178e0:	a902      	add	r1, sp, #8
   178e2:	a804      	add	r0, sp, #16
   178e4:	f7f4 f862 	bl	b9ac <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
   178e8:	2800      	cmp	r0, #0
   178ea:	f47f af61 	bne.w	177b0 <EE_Init+0x168>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
   178ee:	aa0e      	add	r2, sp, #56	; 0x38
   178f0:	490d      	ldr	r1, [pc, #52]	; (17928 <EE_Init+0x2e0>)
   178f2:	2001      	movs	r0, #1
   178f4:	f7f3 fee0 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   178f8:	2800      	cmp	r0, #0
   178fa:	f43f aef8 	beq.w	176ee <EE_Init+0xa6>
   178fe:	e757      	b.n	177b0 <EE_Init+0x168>
   17900:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
   17902:	ab16      	add	r3, sp, #88	; 0x58
   17904:	464a      	mov	r2, r9
   17906:	4639      	mov	r1, r7
   17908:	4618      	mov	r0, r3
   1790a:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
   1790c:	9703      	str	r7, [sp, #12]
  uint32_t valid[8] = {0x0000};
   1790e:	f015 f898 	bl	2ca42 <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
   17912:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
   17914:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
   17918:	9709      	str	r7, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
   1791a:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   1791e:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
   17922:	e017      	b.n	17954 <EE_Init+0x30c>
   17924:	081c0000 	.word	0x081c0000
   17928:	081e0000 	.word	0x081e0000
   1792c:	000628ac 	.word	0x000628ac
   17930:	081e0020 	.word	0x081e0020
   17934:	081fffe0 	.word	0x081fffe0
   17938:	081fffc0 	.word	0x081fffc0
   1793c:	081e0006 	.word	0x081e0006
   17940:	081dffc0 	.word	0x081dffc0
   17944:	081dffe0 	.word	0x081dffe0
   17948:	081c0020 	.word	0x081c0020
   1794c:	081c0006 	.word	0x081c0006
  while (Address <= PAGE0_END_ADDRESS)
   17950:	42b4      	cmp	r4, r6
   17952:	d00a      	beq.n	1796a <EE_Init+0x322>
    AddressValue = (*(__IO uint16_t*)Address);
   17954:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
   17956:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
   17958:	429a      	cmp	r2, r3
   1795a:	d0f9      	beq.n	17950 <EE_Init+0x308>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   1795c:	a903      	add	r1, sp, #12
   1795e:	a809      	add	r0, sp, #36	; 0x24
   17960:	f7f4 f824 	bl	b9ac <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
   17964:	2800      	cmp	r0, #0
   17966:	f47f af23 	bne.w	177b0 <EE_Init+0x168>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
   1796a:	9a00      	ldr	r2, [sp, #0]
   1796c:	2001      	movs	r0, #1
   1796e:	4920      	ldr	r1, [pc, #128]	; (179f0 <EE_Init+0x3a8>)
   17970:	f7f3 fea2 	bl	b6b8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   17974:	2800      	cmp	r0, #0
   17976:	f43f aebb 	beq.w	176f0 <EE_Init+0xa8>
   1797a:	e719      	b.n	177b0 <EE_Init+0x168>
      if (PageStatus0 == VALID_PAGE)
   1797c:	465f      	mov	r7, fp
   1797e:	46d4      	mov	ip, sl
   17980:	4649      	mov	r1, r9
   17982:	464b      	mov	r3, r9
   17984:	e76d      	b.n	17862 <EE_Init+0x21a>
   17986:	465f      	mov	r7, fp
   17988:	4649      	mov	r1, r9
   1798a:	464b      	mov	r3, r9
   1798c:	46d4      	mov	ip, sl
   1798e:	e6df      	b.n	17750 <EE_Init+0x108>
   17990:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   17994:	8839      	ldrh	r1, [r7, #0]
   17996:	4b17      	ldr	r3, [pc, #92]	; (179f4 <EE_Init+0x3ac>)
   17998:	b289      	uxth	r1, r1
   1799a:	8019      	strh	r1, [r3, #0]
   1799c:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   1799e:	f7ff fdff 	bl	175a0 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
   179a2:	9a00      	ldr	r2, [sp, #0]
   179a4:	4607      	mov	r7, r0
   179a6:	2800      	cmp	r0, #0
   179a8:	f43f af69 	beq.w	1787e <EE_Init+0x236>
   179ac:	e6a0      	b.n	176f0 <EE_Init+0xa8>
   179ae:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   179b2:	8839      	ldrh	r1, [r7, #0]
   179b4:	4b0f      	ldr	r3, [pc, #60]	; (179f4 <EE_Init+0x3ac>)
   179b6:	b289      	uxth	r1, r1
   179b8:	8019      	strh	r1, [r3, #0]
   179ba:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   179bc:	f7ff fdf0 	bl	175a0 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
   179c0:	9a00      	ldr	r2, [sp, #0]
   179c2:	4607      	mov	r7, r0
   179c4:	2800      	cmp	r0, #0
   179c6:	f43f aed1 	beq.w	1776c <EE_Init+0x124>
   179ca:	e691      	b.n	176f0 <EE_Init+0xa8>
        pEraseInit.Sector = PAGE1_ID;
   179cc:	2307      	movs	r3, #7
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   179ce:	aa0e      	add	r2, sp, #56	; 0x38
   179d0:	4621      	mov	r1, r4
   179d2:	4650      	mov	r0, sl
        pEraseInit.Sector = PAGE1_ID;
   179d4:	e9cd a305 	strd	sl, r3, [sp, #20]
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
   179d8:	f7f3 fe6e 	bl	b6b8 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
   179dc:	2800      	cmp	r0, #0
   179de:	f43f ae86 	beq.w	176ee <EE_Init+0xa6>
   179e2:	e6e5      	b.n	177b0 <EE_Init+0x168>
   179e4:	4b03      	ldr	r3, [pc, #12]	; (179f4 <EE_Init+0x3ac>)
   179e6:	8819      	ldrh	r1, [r3, #0]
   179e8:	e7d8      	b.n	1799c <EE_Init+0x354>
   179ea:	4b02      	ldr	r3, [pc, #8]	; (179f4 <EE_Init+0x3ac>)
   179ec:	8819      	ldrh	r1, [r3, #0]
   179ee:	e7e4      	b.n	179ba <EE_Init+0x372>
   179f0:	081c0000 	.word	0x081c0000
   179f4:	020e310a 	.word	0x020e310a

000179f8 <EE_ReadVariable>:
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   179f8:	4b15      	ldr	r3, [pc, #84]	; (17a50 <EE_ReadVariable+0x58>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   179fa:	4a16      	ldr	r2, [pc, #88]	; (17a54 <EE_ReadVariable+0x5c>)
{
   179fc:	b430      	push	{r4, r5}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   179fe:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17a00:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17a02:	b29b      	uxth	r3, r3
      if (PageStatus0 == VALID_PAGE)
   17a04:	b133      	cbz	r3, 17a14 <EE_ReadVariable+0x1c>
   17a06:	b292      	uxth	r2, r2
      else if (PageStatus1 == VALID_PAGE)
   17a08:	b9fa      	cbnz	r2, 17a4a <EE_ReadVariable+0x52>
   17a0a:	4b13      	ldr	r3, [pc, #76]	; (17a58 <EE_ReadVariable+0x60>)
   17a0c:	4c13      	ldr	r4, [pc, #76]	; (17a5c <EE_ReadVariable+0x64>)
   17a0e:	461a      	mov	r2, r3
   17a10:	4d13      	ldr	r5, [pc, #76]	; (17a60 <EE_ReadVariable+0x68>)
   17a12:	e003      	b.n	17a1c <EE_ReadVariable+0x24>
      if (PageStatus0 == VALID_PAGE)
   17a14:	4b13      	ldr	r3, [pc, #76]	; (17a64 <EE_ReadVariable+0x6c>)
   17a16:	4c14      	ldr	r4, [pc, #80]	; (17a68 <EE_ReadVariable+0x70>)
   17a18:	461a      	mov	r2, r3
   17a1a:	4d14      	ldr	r5, [pc, #80]	; (17a6c <EE_ReadVariable+0x74>)
    AddressValue = (*(__IO uint16_t*)Address);
   17a1c:	8812      	ldrh	r2, [r2, #0]
    if (AddressValue == VirtAddress)
   17a1e:	4290      	cmp	r0, r2
   17a20:	d105      	bne.n	17a2e <EE_ReadVariable+0x36>
   17a22:	e00d      	b.n	17a40 <EE_ReadVariable+0x48>
    AddressValue = (*(__IO uint16_t*)Address);
   17a24:	f833 4c20 	ldrh.w	r4, [r3, #-32]
    if (AddressValue == VirtAddress)
   17a28:	42a0      	cmp	r0, r4
   17a2a:	d007      	beq.n	17a3c <EE_ReadVariable+0x44>
   17a2c:	4613      	mov	r3, r2
      Address = Address - 32;
   17a2e:	f1a3 0220 	sub.w	r2, r3, #32
  while (Address > (PageStartAddress + 32))
   17a32:	42aa      	cmp	r2, r5
   17a34:	d8f6      	bhi.n	17a24 <EE_ReadVariable+0x2c>
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
   17a36:	2001      	movs	r0, #1
}
   17a38:	bc30      	pop	{r4, r5}
   17a3a:	4770      	bx	lr
   17a3c:	f1a3 0440 	sub.w	r4, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   17a40:	8823      	ldrh	r3, [r4, #0]
      ReadStatus = 0;
   17a42:	2000      	movs	r0, #0
      *Data = (*(__IO uint16_t*)(Address - 32));
   17a44:	800b      	strh	r3, [r1, #0]
}
   17a46:	bc30      	pop	{r4, r5}
   17a48:	4770      	bx	lr
    return  NO_VALID_PAGE;
   17a4a:	20ab      	movs	r0, #171	; 0xab
}
   17a4c:	bc30      	pop	{r4, r5}
   17a4e:	4770      	bx	lr
   17a50:	081c0000 	.word	0x081c0000
   17a54:	081e0000 	.word	0x081e0000
   17a58:	081fffe0 	.word	0x081fffe0
   17a5c:	081fffc0 	.word	0x081fffc0
   17a60:	081e0020 	.word	0x081e0020
   17a64:	081dffe0 	.word	0x081dffe0
   17a68:	081dffc0 	.word	0x081dffc0
   17a6c:	081c0020 	.word	0x081c0020

00017a70 <EE_WriteVariable>:
{
   17a70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t data32[8] = {Data};
   17a74:	2300      	movs	r3, #0
{
   17a76:	b099      	sub	sp, #100	; 0x64
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17a78:	4c71      	ldr	r4, [pc, #452]	; (17c40 <EE_WriteVariable+0x1d0>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17a7a:	4a72      	ldr	r2, [pc, #456]	; (17c44 <EE_WriteVariable+0x1d4>)
  uint32_t VirtAddress1[8] = {VirtAddress};
   17a7c:	9010      	str	r0, [sp, #64]	; 0x40
  uint32_t data32[8] = {Data};
   17a7e:	9108      	str	r1, [sp, #32]
   17a80:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t VirtAddress1[8] = {VirtAddress};
   17a82:	9317      	str	r3, [sp, #92]	; 0x5c
  uint32_t data32[8] = {Data};
   17a84:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   17a88:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   17a8c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  uint32_t VirtAddress1[8] = {VirtAddress};
   17a90:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
   17a94:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
   17a98:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17a9c:	8823      	ldrh	r3, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17a9e:	8812      	ldrh	r2, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17aa0:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17aa2:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
   17aa4:	bb2a      	cbnz	r2, 17af2 <EE_WriteVariable+0x82>
        if (PageStatus0 == RECEIVE_DATA)
   17aa6:	f64e 62ee 	movw	r2, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
   17aaa:	1a9b      	subs	r3, r3, r2
   17aac:	bf18      	it	ne
   17aae:	2301      	movne	r3, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   17ab0:	f203 470e 	addw	r7, r3, #1038	; 0x40e
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   17ab4:	4a64      	ldr	r2, [pc, #400]	; (17c48 <EE_WriteVariable+0x1d8>)
   17ab6:	3301      	adds	r3, #1
   17ab8:	4688      	mov	r8, r1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
   17aba:	047f      	lsls	r7, r7, #17
   17abc:	4604      	mov	r4, r0
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
   17abe:	eb02 4243 	add.w	r2, r2, r3, lsl #17
  while (Address < PageEndAddress)
   17ac2:	4297      	cmp	r7, r2
   17ac4:	d303      	bcc.n	17ace <EE_WriteVariable+0x5e>
   17ac6:	e021      	b.n	17b0c <EE_WriteVariable+0x9c>
      Address = Address + 64;
   17ac8:	3740      	adds	r7, #64	; 0x40
  while (Address < PageEndAddress)
   17aca:	42ba      	cmp	r2, r7
   17acc:	d91e      	bls.n	17b0c <EE_WriteVariable+0x9c>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
   17ace:	683b      	ldr	r3, [r7, #0]
   17ad0:	3301      	adds	r3, #1
   17ad2:	d1f9      	bne.n	17ac8 <EE_WriteVariable+0x58>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
   17ad4:	ae08      	add	r6, sp, #32
   17ad6:	4639      	mov	r1, r7
   17ad8:	2001      	movs	r0, #1
   17ada:	4632      	mov	r2, r6
   17adc:	f7f3 fdec 	bl	b6b8 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
   17ae0:	2800      	cmp	r0, #0
   17ae2:	d03f      	beq.n	17b64 <EE_WriteVariable+0xf4>
     return FlashStatus;
   17ae4:	b285      	uxth	r5, r0
  if (Status == PAGE_FULL)
   17ae6:	2d80      	cmp	r5, #128	; 0x80
   17ae8:	d011      	beq.n	17b0e <EE_WriteVariable+0x9e>
}
   17aea:	4628      	mov	r0, r5
   17aec:	b019      	add	sp, #100	; 0x64
   17aee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (PageStatus0 == VALID_PAGE)
   17af2:	b933      	cbnz	r3, 17b02 <EE_WriteVariable+0x92>
        if (PageStatus1 == RECEIVE_DATA)
   17af4:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
   17af8:	1ad3      	subs	r3, r2, r3
   17afa:	fab3 f383 	clz	r3, r3
   17afe:	095b      	lsrs	r3, r3, #5
   17b00:	e7d6      	b.n	17ab0 <EE_WriteVariable+0x40>
    /* Old page ID where variable will be taken from */
    OldPageId = PAGE0_ID;
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
   17b02:	25ab      	movs	r5, #171	; 0xab
}
   17b04:	4628      	mov	r0, r5
   17b06:	b019      	add	sp, #100	; 0x64
   17b08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   17b0c:	ae08      	add	r6, sp, #32
  uint32_t SectorError = 0;
   17b0e:	2500      	movs	r5, #0
  uint32_t valid[8] = {0x0000};
   17b10:	2220      	movs	r2, #32
   17b12:	4630      	mov	r0, r6
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b14:	4f4b      	ldr	r7, [pc, #300]	; (17c44 <EE_WriteVariable+0x1d4>)
  uint32_t valid[8] = {0x0000};
   17b16:	4629      	mov	r1, r5
  uint32_t SectorError = 0;
   17b18:	9502      	str	r5, [sp, #8]
  uint32_t valid[8] = {0x0000};
   17b1a:	f014 ff92 	bl	2ca42 <memset>
  uint32_t receive[8] = {0xEEEE};
   17b1e:	f64e 63ee 	movw	r3, #61166	; 0xeeee
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b22:	4947      	ldr	r1, [pc, #284]	; (17c40 <EE_WriteVariable+0x1d0>)
  uint32_t receive[8] = {0xEEEE};
   17b24:	9517      	str	r5, [sp, #92]	; 0x5c
   17b26:	9310      	str	r3, [sp, #64]	; 0x40
   17b28:	e9cd 5511 	strd	r5, r5, [sp, #68]	; 0x44
   17b2c:	e9cd 5513 	strd	r5, r5, [sp, #76]	; 0x4c
   17b30:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b34:	880b      	ldrh	r3, [r1, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b36:	883a      	ldrh	r2, [r7, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b38:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b3a:	b292      	uxth	r2, r2
      if (PageStatus0 == VALID_PAGE)
   17b3c:	b17b      	cbz	r3, 17b5e <EE_WriteVariable+0xee>
      else if (PageStatus1 == VALID_PAGE)
   17b3e:	2a00      	cmp	r2, #0
   17b40:	d1df      	bne.n	17b02 <EE_WriteVariable+0x92>
    NewPageAddress = PAGE0_BASE_ADDRESS;
   17b42:	460f      	mov	r7, r1
      else if (PageStatus1 == VALID_PAGE)
   17b44:	f04f 0907 	mov.w	r9, #7
  }

  /* Set the new Page status to RECEIVE_DATA status */

  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)receive));
   17b48:	aa10      	add	r2, sp, #64	; 0x40
   17b4a:	4639      	mov	r1, r7
   17b4c:	2001      	movs	r0, #1
   17b4e:	f7f3 fdb3 	bl	b6b8 <HAL_FLASH_Program>

  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
   17b52:	b170      	cbz	r0, 17b72 <EE_WriteVariable+0x102>
  /* Set new Page status to VALID_PAGE status */
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
  {
    return FlashStatus;
   17b54:	b285      	uxth	r5, r0
}
   17b56:	4628      	mov	r0, r5
   17b58:	b019      	add	sp, #100	; 0x64
   17b5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus0 == VALID_PAGE)
   17b5e:	f04f 0906 	mov.w	r9, #6
   17b62:	e7f1      	b.n	17b48 <EE_WriteVariable+0xd8>
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
   17b64:	f107 0120 	add.w	r1, r7, #32
   17b68:	aa10      	add	r2, sp, #64	; 0x40
   17b6a:	2001      	movs	r0, #1
   17b6c:	f7f3 fda4 	bl	b6b8 <HAL_FLASH_Program>
   17b70:	e7b8      	b.n	17ae4 <EE_WriteVariable+0x74>
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
   17b72:	4641      	mov	r1, r8
   17b74:	4620      	mov	r0, r4
   17b76:	f7ff fd13 	bl	175a0 <EE_VerifyPageFullWriteVariable>
  if (EepromStatus != HAL_OK)
   17b7a:	4605      	mov	r5, r0
   17b7c:	2800      	cmp	r0, #0
   17b7e:	d1b4      	bne.n	17aea <EE_WriteVariable+0x7a>
   17b80:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 17c58 <EE_WriteVariable+0x1e8>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b84:	4a2e      	ldr	r2, [pc, #184]	; (17c40 <EE_WriteVariable+0x1d0>)
   17b86:	f108 0a06 	add.w	sl, r8, #6
      if (PageStatus0 == VALID_PAGE)
   17b8a:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 17c5c <EE_WriteVariable+0x1ec>
    if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
   17b8e:	f838 0b02 	ldrh.w	r0, [r8], #2
   17b92:	4284      	cmp	r4, r0
   17b94:	d01b      	beq.n	17bce <EE_WriteVariable+0x15e>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b96:	8813      	ldrh	r3, [r2, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b98:	492a      	ldr	r1, [pc, #168]	; (17c44 <EE_WriteVariable+0x1d4>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
   17b9a:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
   17b9c:	8809      	ldrh	r1, [r1, #0]
   17b9e:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
   17ba0:	2b00      	cmp	r3, #0
   17ba2:	d034      	beq.n	17c0e <EE_WriteVariable+0x19e>
      else if (PageStatus1 == VALID_PAGE)
   17ba4:	2900      	cmp	r1, #0
   17ba6:	d148      	bne.n	17c3a <EE_WriteVariable+0x1ca>
   17ba8:	4928      	ldr	r1, [pc, #160]	; (17c4c <EE_WriteVariable+0x1dc>)
   17baa:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 17c60 <EE_WriteVariable+0x1f0>
   17bae:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 17c64 <EE_WriteVariable+0x1f4>
   17bb2:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
   17bb4:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
   17bb6:	4288      	cmp	r0, r1
   17bb8:	d105      	bne.n	17bc6 <EE_WriteVariable+0x156>
   17bba:	e031      	b.n	17c20 <EE_WriteVariable+0x1b0>
    AddressValue = (*(__IO uint16_t*)Address);
   17bbc:	f833 cc20 	ldrh.w	ip, [r3, #-32]
    if (AddressValue == VirtAddress)
   17bc0:	4560      	cmp	r0, ip
   17bc2:	d02b      	beq.n	17c1c <EE_WriteVariable+0x1ac>
   17bc4:	460b      	mov	r3, r1
      Address = Address - 32;
   17bc6:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
   17bca:	458e      	cmp	lr, r1
   17bcc:	d3f6      	bcc.n	17bbc <EE_WriteVariable+0x14c>
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
   17bce:	45d0      	cmp	r8, sl
   17bd0:	d1dd      	bne.n	17b8e <EE_WriteVariable+0x11e>
  HAL_FLASH_Unlock();
   17bd2:	f7f3 fde7 	bl	b7a4 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   17bd6:	4b1e      	ldr	r3, [pc, #120]	; (17c50 <EE_WriteVariable+0x1e0>)
   17bd8:	f44f 008e 	mov.w	r0, #4653056	; 0x470000
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   17bdc:	2100      	movs	r1, #0
  pEraseInit.Banks = FLASH_BANK_2 ;
   17bde:	2202      	movs	r2, #2
  pEraseInit.NbSectors = 1;
   17be0:	2401      	movs	r4, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
   17be2:	6158      	str	r0, [r3, #20]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17be4:	2320      	movs	r3, #32
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
   17be6:	9103      	str	r1, [sp, #12]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   17be8:	a803      	add	r0, sp, #12
   17bea:	a902      	add	r1, sp, #8
  pEraseInit.Sector = OldPageId;
   17bec:	f8cd 9014 	str.w	r9, [sp, #20]
  pEraseInit.Banks = FLASH_BANK_2 ;
   17bf0:	9204      	str	r2, [sp, #16]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
   17bf2:	e9cd 4306 	strd	r4, r3, [sp, #24]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
   17bf6:	f7f3 fed9 	bl	b9ac <HAL_FLASHEx_Erase>
  if (FlashStatus != HAL_OK)
   17bfa:	2800      	cmp	r0, #0
   17bfc:	d1aa      	bne.n	17b54 <EE_WriteVariable+0xe4>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
   17bfe:	4632      	mov	r2, r6
   17c00:	4639      	mov	r1, r7
   17c02:	4620      	mov	r0, r4
   17c04:	f7f3 fd58 	bl	b6b8 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
   17c08:	2800      	cmp	r0, #0
   17c0a:	d1a3      	bne.n	17b54 <EE_WriteVariable+0xe4>
   17c0c:	e76d      	b.n	17aea <EE_WriteVariable+0x7a>
      if (PageStatus0 == VALID_PAGE)
   17c0e:	f8df c058 	ldr.w	ip, [pc, #88]	; 17c68 <EE_WriteVariable+0x1f8>
   17c12:	4659      	mov	r1, fp
   17c14:	465b      	mov	r3, fp
   17c16:	f8df e054 	ldr.w	lr, [pc, #84]	; 17c6c <EE_WriteVariable+0x1fc>
   17c1a:	e7cb      	b.n	17bb4 <EE_WriteVariable+0x144>
   17c1c:	f1a3 0c40 	sub.w	ip, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
   17c20:	f8bc 1000 	ldrh.w	r1, [ip]
   17c24:	4b0b      	ldr	r3, [pc, #44]	; (17c54 <EE_WriteVariable+0x1e4>)
   17c26:	b289      	uxth	r1, r1
   17c28:	8019      	strh	r1, [r3, #0]
   17c2a:	9201      	str	r2, [sp, #4]
        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
   17c2c:	f7ff fcb8 	bl	175a0 <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != HAL_OK)
   17c30:	9a01      	ldr	r2, [sp, #4]
   17c32:	2800      	cmp	r0, #0
   17c34:	d0cb      	beq.n	17bce <EE_WriteVariable+0x15e>
   17c36:	4605      	mov	r5, r0
  return Status;
   17c38:	e757      	b.n	17aea <EE_WriteVariable+0x7a>
   17c3a:	4b06      	ldr	r3, [pc, #24]	; (17c54 <EE_WriteVariable+0x1e4>)
   17c3c:	8819      	ldrh	r1, [r3, #0]
   17c3e:	e7f4      	b.n	17c2a <EE_WriteVariable+0x1ba>
   17c40:	081c0000 	.word	0x081c0000
   17c44:	081e0000 	.word	0x081e0000
   17c48:	081bffff 	.word	0x081bffff
   17c4c:	081fffe0 	.word	0x081fffe0
   17c50:	52002000 	.word	0x52002000
   17c54:	020e310a 	.word	0x020e310a
   17c58:	000628ac 	.word	0x000628ac
   17c5c:	081dffe0 	.word	0x081dffe0
   17c60:	081e0020 	.word	0x081e0020
   17c64:	081fffc0 	.word	0x081fffc0
   17c68:	081dffc0 	.word	0x081dffc0
   17c6c:	081c0020 	.word	0x081c0020

00017c70 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
   17c70:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
   17c72:	4903      	ldr	r1, [pc, #12]	; (17c80 <MX_FATFS_Init+0x10>)
   17c74:	4803      	ldr	r0, [pc, #12]	; (17c84 <MX_FATFS_Init+0x14>)
   17c76:	f7fe fca5 	bl	165c4 <FATFS_LinkDriver>
   17c7a:	4b03      	ldr	r3, [pc, #12]	; (17c88 <MX_FATFS_Init+0x18>)
   17c7c:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
   17c7e:	bd08      	pop	{r3, pc}
   17c80:	020f773c 	.word	0x020f773c
   17c84:	00030ffc 	.word	0x00030ffc
   17c88:	020f7738 	.word	0x020f7738

00017c8c <BSP_PlatformIsDetected>:
  *
  ******************************************************************************
*/
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
   17c8c:	b508      	push	{r3, lr}
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
   17c8e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   17c92:	4803      	ldr	r0, [pc, #12]	; (17ca0 <BSP_PlatformIsDetected+0x14>)
   17c94:	f7f4 fabc 	bl	c210 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */ 
    return status;
}  
   17c98:	fab0 f080 	clz	r0, r0
   17c9c:	0940      	lsrs	r0, r0, #5
   17c9e:	bd08      	pop	{r3, pc}
   17ca0:	58020800 	.word	0x58020800

00017ca4 <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram1;

/* FMC initialization function */
void MX_FMC_Init(void)
{
   17ca4:	b570      	push	{r4, r5, r6, lr}
  FMC_SDRAM_TimingTypeDef SdramTiming = {0};

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   17ca6:	4b18      	ldr	r3, [pc, #96]	; (17d08 <MX_FMC_Init+0x64>)
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
   17ca8:	2001      	movs	r0, #1
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   17caa:	4d18      	ldr	r5, [pc, #96]	; (17d0c <MX_FMC_Init+0x68>)
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
   17cac:	2108      	movs	r1, #8
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
   17cae:	2410      	movs	r4, #16
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   17cb0:	2240      	movs	r2, #64	; 0x40
  hsdram1.Instance = FMC_SDRAM_DEVICE;
   17cb2:	601d      	str	r5, [r3, #0]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
   17cb4:	f44f 7580 	mov.w	r5, #256	; 0x100
{
   17cb8:	b088      	sub	sp, #32
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
  SdramTiming.ExitSelfRefreshDelay = 6;
  SdramTiming.SelfRefreshTime = 4;
   17cba:	2604      	movs	r6, #4
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
   17cbc:	6098      	str	r0, [r3, #8]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
   17cbe:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
   17cc2:	60d9      	str	r1, [r3, #12]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
   17cc4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
   17cc8:	611c      	str	r4, [r3, #16]
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
   17cca:	2400      	movs	r4, #0
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
   17ccc:	615a      	str	r2, [r3, #20]
  SdramTiming.LoadToActiveDelay = 2;
   17cce:	2202      	movs	r2, #2
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
   17cd0:	619d      	str	r5, [r3, #24]
  SdramTiming.ExitSelfRefreshDelay = 6;
   17cd2:	2506      	movs	r5, #6
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
   17cd4:	6218      	str	r0, [r3, #32]
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 2;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   17cd6:	4618      	mov	r0, r3
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
   17cd8:	6259      	str	r1, [r3, #36]	; 0x24
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   17cda:	eb0d 0106 	add.w	r1, sp, r6
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
   17cde:	605c      	str	r4, [r3, #4]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
   17ce0:	61dc      	str	r4, [r3, #28]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
   17ce2:	629c      	str	r4, [r3, #40]	; 0x28
  SdramTiming.LoadToActiveDelay = 2;
   17ce4:	9201      	str	r2, [sp, #4]
  SdramTiming.RCDDelay = 2;
   17ce6:	9207      	str	r2, [sp, #28]
  SdramTiming.ExitSelfRefreshDelay = 6;
   17ce8:	9502      	str	r5, [sp, #8]
  SdramTiming.RPDelay = 2;
   17cea:	e9cd 2205 	strd	r2, r2, [sp, #20]
  SdramTiming.SelfRefreshTime = 4;
   17cee:	e9cd 6503 	strd	r6, r5, [sp, #12]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
   17cf2:	f7fa f97f 	bl	11ff4 <HAL_SDRAM_Init>
   17cf6:	b108      	cbz	r0, 17cfc <MX_FMC_Init+0x58>
  {
    Error_Handler( );
   17cf8:	f001 fbe0 	bl	194bc <Error_Handler>
  }

  HAL_SetFMCMemorySwappingConfig(FMC_SWAPBMAP_SDRAM_SRAM);
   17cfc:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
   17d00:	f7f0 fb96 	bl	8430 <HAL_SetFMCMemorySwappingConfig>

}
   17d04:	b008      	add	sp, #32
   17d06:	bd70      	pop	{r4, r5, r6, pc}
   17d08:	020f7ba0 	.word	0x020f7ba0
   17d0c:	52004140 	.word	0x52004140

00017d10 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (FMC_Initialized) {
   17d10:	4a2a      	ldr	r2, [pc, #168]	; (17dbc <HAL_SDRAM_MspInit+0xac>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   17d12:	2300      	movs	r3, #0
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
   17d14:	b5f0      	push	{r4, r5, r6, r7, lr}
   17d16:	b087      	sub	sp, #28
  if (FMC_Initialized) {
   17d18:	6814      	ldr	r4, [r2, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   17d1a:	e9cd 3301 	strd	r3, r3, [sp, #4]
   17d1e:	e9cd 3303 	strd	r3, r3, [sp, #12]
   17d22:	9305      	str	r3, [sp, #20]
  if (FMC_Initialized) {
   17d24:	b10c      	cbz	r4, 17d2a <HAL_SDRAM_MspInit+0x1a>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
   17d26:	b007      	add	sp, #28
   17d28:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_RCC_FMC_CLK_ENABLE();
   17d2a:	4b25      	ldr	r3, [pc, #148]	; (17dc0 <HAL_SDRAM_MspInit+0xb0>)
  FMC_Initialized = 1;
   17d2c:	2101      	movs	r1, #1
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
   17d2e:	f64f 003f 	movw	r0, #63551	; 0xf83f
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d32:	2702      	movs	r7, #2
  FMC_Initialized = 1;
   17d34:	6011      	str	r1, [r2, #0]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   17d36:	2603      	movs	r6, #3
  __HAL_RCC_FMC_CLK_ENABLE();
   17d38:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d3c:	250c      	movs	r5, #12
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   17d3e:	a901      	add	r1, sp, #4
  __HAL_RCC_FMC_CLK_ENABLE();
   17d40:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   17d44:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
   17d48:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
   17d4c:	9001      	str	r0, [sp, #4]
  __HAL_RCC_FMC_CLK_ENABLE();
   17d4e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   17d52:	481c      	ldr	r0, [pc, #112]	; (17dc4 <HAL_SDRAM_MspInit+0xb4>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d54:	9702      	str	r7, [sp, #8]
  __HAL_RCC_FMC_CLK_ENABLE();
   17d56:	9300      	str	r3, [sp, #0]
   17d58:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d5a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   17d5e:	f7f3 ff2f 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
   17d62:	230d      	movs	r3, #13
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   17d64:	a901      	add	r1, sp, #4
   17d66:	4818      	ldr	r0, [pc, #96]	; (17dc8 <HAL_SDRAM_MspInit+0xb8>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
   17d68:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d6a:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17d6c:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d6e:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   17d72:	f7f3 ff25 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
   17d76:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   17d7a:	a901      	add	r1, sp, #4
   17d7c:	4813      	ldr	r0, [pc, #76]	; (17dcc <HAL_SDRAM_MspInit+0xbc>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
   17d7e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d80:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17d82:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d84:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   17d88:	f7f3 ff1a 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
   17d8c:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   17d90:	a901      	add	r1, sp, #4
   17d92:	480f      	ldr	r0, [pc, #60]	; (17dd0 <HAL_SDRAM_MspInit+0xc0>)
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
   17d94:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17d96:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17d98:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17d9a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   17d9e:	f7f3 ff0f 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
   17da2:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   17da6:	a901      	add	r1, sp, #4
   17da8:	480a      	ldr	r0, [pc, #40]	; (17dd4 <HAL_SDRAM_MspInit+0xc4>)
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   17daa:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   17dac:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
   17dae:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
   17db0:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   17db4:	f7f3 ff04 	bl	bbc0 <HAL_GPIO_Init>
}
   17db8:	b007      	add	sp, #28
   17dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17dbc:	020e310c 	.word	0x020e310c
   17dc0:	58024400 	.word	0x58024400
   17dc4:	58021400 	.word	0x58021400
   17dc8:	58020800 	.word	0x58020800
   17dcc:	58021800 	.word	0x58021800
   17dd0:	58021000 	.word	0x58021000
   17dd4:	58020c00 	.word	0x58020c00

00017dd8 <GFXdrawPixel.part.0>:
void GFXstartWrite(GFX* myGFX){
    // Overwrite in subclasses if desired!
}

// the most basic function, set a single pixel
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
   17dd8:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
    return;

  // check rotation, move pixel around if necessary
  switch (GFXgetRotation(myGFX)) {
   17dda:	7a04      	ldrb	r4, [r0, #8]
   17ddc:	2c02      	cmp	r4, #2
   17dde:	d050      	beq.n	17e82 <GFXdrawPixel.part.0+0xaa>
   17de0:	2c03      	cmp	r4, #3
   17de2:	d048      	beq.n	17e76 <GFXdrawPixel.part.0+0x9e>
   17de4:	2c01      	cmp	r4, #1
   17de6:	d018      	beq.n	17e1a <GFXdrawPixel.part.0+0x42>
    y = myGFX->HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
   17de8:	2b01      	cmp	r3, #1
   17dea:	d01e      	beq.n	17e2a <GFXdrawPixel.part.0+0x52>
   17dec:	d32f      	bcc.n	17e4e <GFXdrawPixel.part.0+0x76>
   17dee:	2b02      	cmp	r3, #2
   17df0:	d111      	bne.n	17e16 <GFXdrawPixel.part.0+0x3e>
    {
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
   17df2:	2a00      	cmp	r2, #0
   17df4:	4613      	mov	r3, r2
   17df6:	8804      	ldrh	r4, [r0, #0]
   17df8:	f04f 0001 	mov.w	r0, #1
   17dfc:	bfb8      	it	lt
   17dfe:	1dd3      	addlt	r3, r2, #7
   17e00:	f002 0207 	and.w	r2, r2, #7
   17e04:	10db      	asrs	r3, r3, #3
   17e06:	fa00 f202 	lsl.w	r2, r0, r2
   17e0a:	fb13 1104 	smlabb	r1, r3, r4, r1
   17e0e:	4b21      	ldr	r3, [pc, #132]	; (17e94 <GFXdrawPixel.part.0+0xbc>)
   17e10:	5c58      	ldrb	r0, [r3, r1]
   17e12:	4042      	eors	r2, r0
   17e14:	545a      	strb	r2, [r3, r1]
    }

}
   17e16:	bc30      	pop	{r4, r5}
   17e18:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
   17e1a:	43d4      	mvns	r4, r2
   17e1c:	8805      	ldrh	r5, [r0, #0]
    _swap_int16_t(x, y);
   17e1e:	460a      	mov	r2, r1
    switch (color)
   17e20:	2b01      	cmp	r3, #1
    x = myGFX->WIDTH - x - 1;
   17e22:	eb04 0105 	add.w	r1, r4, r5
   17e26:	b209      	sxth	r1, r1
    switch (color)
   17e28:	d1e0      	bne.n	17dec <GFXdrawPixel.part.0+0x14>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
   17e2a:	2a00      	cmp	r2, #0
   17e2c:	4613      	mov	r3, r2
   17e2e:	8804      	ldrh	r4, [r0, #0]
   17e30:	f002 0007 	and.w	r0, r2, #7
   17e34:	bfb8      	it	lt
   17e36:	1dd3      	addlt	r3, r2, #7
   17e38:	2201      	movs	r2, #1
   17e3a:	10db      	asrs	r3, r3, #3
   17e3c:	4082      	lsls	r2, r0
   17e3e:	fb13 1104 	smlabb	r1, r3, r4, r1
   17e42:	4b14      	ldr	r3, [pc, #80]	; (17e94 <GFXdrawPixel.part.0+0xbc>)
   17e44:	5c58      	ldrb	r0, [r3, r1]
   17e46:	4302      	orrs	r2, r0
   17e48:	545a      	strb	r2, [r3, r1]
}
   17e4a:	bc30      	pop	{r4, r5}
   17e4c:	4770      	bx	lr
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
   17e4e:	2a00      	cmp	r2, #0
   17e50:	4613      	mov	r3, r2
   17e52:	8800      	ldrh	r0, [r0, #0]
   17e54:	f002 0407 	and.w	r4, r2, #7
   17e58:	bfb8      	it	lt
   17e5a:	1dd3      	addlt	r3, r2, #7
   17e5c:	2201      	movs	r2, #1
   17e5e:	10db      	asrs	r3, r3, #3
   17e60:	fb13 1100 	smlabb	r1, r3, r0, r1
   17e64:	480b      	ldr	r0, [pc, #44]	; (17e94 <GFXdrawPixel.part.0+0xbc>)
   17e66:	fa02 f304 	lsl.w	r3, r2, r4
   17e6a:	5c42      	ldrb	r2, [r0, r1]
   17e6c:	ea22 0203 	bic.w	r2, r2, r3
   17e70:	5442      	strb	r2, [r0, r1]
}
   17e72:	bc30      	pop	{r4, r5}
   17e74:	4770      	bx	lr
    y = myGFX->HEIGHT - y - 1;
   17e76:	43cc      	mvns	r4, r1
   17e78:	8845      	ldrh	r5, [r0, #2]
	_swap_int16_t(x, y);
   17e7a:	4611      	mov	r1, r2
    y = myGFX->HEIGHT - y - 1;
   17e7c:	1962      	adds	r2, r4, r5
   17e7e:	b212      	sxth	r2, r2
   17e80:	e7b2      	b.n	17de8 <GFXdrawPixel.part.0+0x10>
    x = myGFX->WIDTH - x - 1;
   17e82:	43c9      	mvns	r1, r1
    y = myGFX->HEIGHT - y - 1;
   17e84:	43d2      	mvns	r2, r2
    x = myGFX->WIDTH - x - 1;
   17e86:	8805      	ldrh	r5, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
   17e88:	8844      	ldrh	r4, [r0, #2]
    x = myGFX->WIDTH - x - 1;
   17e8a:	4429      	add	r1, r5
    y = myGFX->HEIGHT - y - 1;
   17e8c:	4422      	add	r2, r4
    x = myGFX->WIDTH - x - 1;
   17e8e:	b209      	sxth	r1, r1
    y = myGFX->HEIGHT - y - 1;
   17e90:	b212      	sxth	r2, r2
   17e92:	e7a9      	b.n	17de8 <GFXdrawPixel.part.0+0x10>
   17e94:	020fb06c 	.word	0x020fb06c

00017e98 <GFXinit>:
	myGfx->WIDTH = w;
   17e98:	2300      	movs	r3, #0
	myGfx->_width    = w;
   17e9a:	8081      	strh	r1, [r0, #4]
	myGfx->_height   = h;
   17e9c:	80c2      	strh	r2, [r0, #6]
	myGfx->WIDTH = w;
   17e9e:	f361 030f 	bfi	r3, r1, #0, #16
	myGfx->rotation  = 0;
   17ea2:	2101      	movs	r1, #1
	myGfx->WIDTH = w;
   17ea4:	f362 431f 	bfi	r3, r2, #16, #16
	myGfx->fontHeight = 8;
   17ea8:	2208      	movs	r2, #8
	myGfx->rotation  = 0;
   17eaa:	6141      	str	r1, [r0, #20]
	myGfx->WIDTH = w;
   17eac:	6003      	str	r3, [r0, #0]
	myGfx->rotation  = 0;
   17eae:	2300      	movs	r3, #0
	myGfx->fontHeight = 8;
   17eb0:	61c2      	str	r2, [r0, #28]
	myGfx->rotation  = 0;
   17eb2:	6083      	str	r3, [r0, #8]
	myGfx->gfxFont   = NULL;
   17eb4:	6183      	str	r3, [r0, #24]
{
   17eb6:	b430      	push	{r4, r5}
	myGfx->rotation  = 0;
   17eb8:	f44f 3580 	mov.w	r5, #65536	; 0x10000
   17ebc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   17ec0:	e9c0 5403 	strd	r5, r4, [r0, #12]
}
   17ec4:	bc30      	pop	{r4, r5}
   17ec6:	4770      	bx	lr

00017ec8 <GFXwriteLine>:
        uint16_t color) {
   17ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17ecc:	b083      	sub	sp, #12
   17ece:	461e      	mov	r6, r3
   17ed0:	4617      	mov	r7, r2
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   17ed2:	4694      	mov	ip, r2
        uint16_t color) {
   17ed4:	f9bd 5030 	ldrsh.w	r5, [sp, #48]	; 0x30
   17ed8:	4682      	mov	sl, r0
   17eda:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   17ede:	1aab      	subs	r3, r5, r2
   17ee0:	1a72      	subs	r2, r6, r1
        uint16_t color) {
   17ee2:	9001      	str	r0, [sp, #4]
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   17ee4:	2b00      	cmp	r3, #0
   17ee6:	bfb8      	it	lt
   17ee8:	425b      	neglt	r3, r3
   17eea:	2a00      	cmp	r2, #0
   17eec:	bfb8      	it	lt
   17eee:	4252      	neglt	r2, r2
    if (steep) {
   17ef0:	4293      	cmp	r3, r2
   17ef2:	dc7d      	bgt.n	17ff0 <GFXwriteLine+0x128>
   17ef4:	46ae      	mov	lr, r5
   17ef6:	462c      	mov	r4, r5
   17ef8:	46bb      	mov	fp, r7
   17efa:	4635      	mov	r5, r6
   17efc:	460f      	mov	r7, r1
   17efe:	4676      	mov	r6, lr
   17f00:	4661      	mov	r1, ip
   17f02:	4698      	mov	r8, r3
    if (x0 > x1) {
   17f04:	42af      	cmp	r7, r5
   17f06:	dd5f      	ble.n	17fc8 <GFXwriteLine+0x100>
    dx = x1 - x0;
   17f08:	eba7 0905 	sub.w	r9, r7, r5
   17f0c:	ebab 0004 	sub.w	r0, fp, r4
    if (y0 < y1) {
   17f10:	f64f 7bff 	movw	fp, #65535	; 0xffff
    dx = x1 - x0;
   17f14:	fa1f f989 	uxth.w	r9, r9
   17f18:	ea80 78e0 	eor.w	r8, r0, r0, asr #31
    int16_t err = dx / 2;
   17f1c:	fa0f f489 	sxth.w	r4, r9
   17f20:	eba8 78e0 	sub.w	r8, r8, r0, asr #31
   17f24:	2c00      	cmp	r4, #0
   17f26:	bfb8      	it	lt
   17f28:	3401      	addlt	r4, #1
    if (y0 < y1) {
   17f2a:	42b1      	cmp	r1, r6
   17f2c:	bfc8      	it	gt
   17f2e:	f04f 0b01 	movgt.w	fp, #1
    int16_t err = dx / 2;
   17f32:	1064      	asrs	r4, r4, #1
   17f34:	4293      	cmp	r3, r2
   17f36:	fa1f f888 	uxth.w	r8, r8
   17f3a:	dc3c      	bgt.n	17fb6 <GFXwriteLine+0xee>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   17f3c:	2d00      	cmp	r5, #0
   17f3e:	db0f      	blt.n	17f60 <GFXwriteLine+0x98>
   17f40:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   17f44:	42ab      	cmp	r3, r5
   17f46:	dd0b      	ble.n	17f60 <GFXwriteLine+0x98>
   17f48:	0432      	lsls	r2, r6, #16
   17f4a:	d409      	bmi.n	17f60 <GFXwriteLine+0x98>
   17f4c:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   17f50:	4632      	mov	r2, r6
   17f52:	4629      	mov	r1, r5
   17f54:	9b01      	ldr	r3, [sp, #4]
   17f56:	42b0      	cmp	r0, r6
   17f58:	4650      	mov	r0, sl
   17f5a:	dd01      	ble.n	17f60 <GFXwriteLine+0x98>
   17f5c:	f7ff ff3c 	bl	17dd8 <GFXdrawPixel.part.0>
        err -= dy;
   17f60:	eba4 0408 	sub.w	r4, r4, r8
   17f64:	3501      	adds	r5, #1
   17f66:	b2a3      	uxth	r3, r4
   17f68:	b22d      	sxth	r5, r5
   17f6a:	b21c      	sxth	r4, r3
        if (err < 0) {
   17f6c:	2c00      	cmp	r4, #0
   17f6e:	da04      	bge.n	17f7a <GFXwriteLine+0xb2>
            y0 += ystep;
   17f70:	445e      	add	r6, fp
            err += dx;
   17f72:	eb09 0403 	add.w	r4, r9, r3
            y0 += ystep;
   17f76:	b236      	sxth	r6, r6
            err += dx;
   17f78:	b224      	sxth	r4, r4
    for (; x0<=x1; x0++) {
   17f7a:	42af      	cmp	r7, r5
   17f7c:	dade      	bge.n	17f3c <GFXwriteLine+0x74>
}
   17f7e:	b003      	add	sp, #12
   17f80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   17f84:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   17f88:	462a      	mov	r2, r5
   17f8a:	4631      	mov	r1, r6
   17f8c:	9b01      	ldr	r3, [sp, #4]
   17f8e:	4285      	cmp	r5, r0
   17f90:	4650      	mov	r0, sl
   17f92:	da01      	bge.n	17f98 <GFXwriteLine+0xd0>
   17f94:	f7ff ff20 	bl	17dd8 <GFXdrawPixel.part.0>
        err -= dy;
   17f98:	eba4 0408 	sub.w	r4, r4, r8
   17f9c:	3501      	adds	r5, #1
   17f9e:	b2a3      	uxth	r3, r4
   17fa0:	b22d      	sxth	r5, r5
   17fa2:	b21c      	sxth	r4, r3
        if (err < 0) {
   17fa4:	2c00      	cmp	r4, #0
   17fa6:	da04      	bge.n	17fb2 <GFXwriteLine+0xea>
            y0 += ystep;
   17fa8:	445e      	add	r6, fp
            err += dx;
   17faa:	eb03 0409 	add.w	r4, r3, r9
            y0 += ystep;
   17fae:	b236      	sxth	r6, r6
            err += dx;
   17fb0:	b224      	sxth	r4, r4
    for (; x0<=x1; x0++) {
   17fb2:	42af      	cmp	r7, r5
   17fb4:	dbe3      	blt.n	17f7e <GFXwriteLine+0xb6>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   17fb6:	2e00      	cmp	r6, #0
   17fb8:	dbee      	blt.n	17f98 <GFXwriteLine+0xd0>
   17fba:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   17fbe:	429e      	cmp	r6, r3
   17fc0:	daea      	bge.n	17f98 <GFXwriteLine+0xd0>
   17fc2:	042b      	lsls	r3, r5, #16
   17fc4:	d4e8      	bmi.n	17f98 <GFXwriteLine+0xd0>
   17fc6:	e7dd      	b.n	17f84 <GFXwriteLine+0xbc>
    dx = x1 - x0;
   17fc8:	eba5 0907 	sub.w	r9, r5, r7
    if (y0 < y1) {
   17fcc:	4628      	mov	r0, r5
   17fce:	463d      	mov	r5, r7
    dx = x1 - x0;
   17fd0:	fa1f f989 	uxth.w	r9, r9
    int16_t err = dx / 2;
   17fd4:	fa0f f489 	sxth.w	r4, r9
   17fd8:	2c00      	cmp	r4, #0
   17fda:	bfb8      	it	lt
   17fdc:	3401      	addlt	r4, #1
    if (y0 < y1) {
   17fde:	42b1      	cmp	r1, r6
   17fe0:	460e      	mov	r6, r1
    int16_t err = dx / 2;
   17fe2:	ea4f 0464 	mov.w	r4, r4, asr #1
    if (y0 < y1) {
   17fe6:	da07      	bge.n	17ff8 <GFXwriteLine+0x130>
   17fe8:	f04f 0b01 	mov.w	fp, #1
   17fec:	4607      	mov	r7, r0
   17fee:	e7a1      	b.n	17f34 <GFXwriteLine+0x6c>
   17ff0:	4634      	mov	r4, r6
   17ff2:	468b      	mov	fp, r1
   17ff4:	4690      	mov	r8, r2
   17ff6:	e785      	b.n	17f04 <GFXwriteLine+0x3c>
   17ff8:	f64f 7bff 	movw	fp, #65535	; 0xffff
   17ffc:	4607      	mov	r7, r0
   17ffe:	e799      	b.n	17f34 <GFXwriteLine+0x6c>

00018000 <GFXdrawPixel>:
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   18000:	2900      	cmp	r1, #0
   18002:	db28      	blt.n	18056 <GFXdrawPixel+0x56>
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
   18004:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   18006:	8884      	ldrh	r4, [r0, #4]
   18008:	42a1      	cmp	r1, r4
   1800a:	da22      	bge.n	18052 <GFXdrawPixel+0x52>
   1800c:	2a00      	cmp	r2, #0
   1800e:	db20      	blt.n	18052 <GFXdrawPixel+0x52>
   18010:	88c4      	ldrh	r4, [r0, #6]
   18012:	42a2      	cmp	r2, r4
   18014:	da1d      	bge.n	18052 <GFXdrawPixel+0x52>
  switch (GFXgetRotation(myGFX)) {
   18016:	7a04      	ldrb	r4, [r0, #8]
   18018:	2c02      	cmp	r4, #2
   1801a:	d04e      	beq.n	180ba <GFXdrawPixel+0xba>
   1801c:	2c03      	cmp	r4, #3
   1801e:	d046      	beq.n	180ae <GFXdrawPixel+0xae>
   18020:	2c01      	cmp	r4, #1
   18022:	d019      	beq.n	18058 <GFXdrawPixel+0x58>
    switch (color)
   18024:	2b01      	cmp	r3, #1
   18026:	d02f      	beq.n	18088 <GFXdrawPixel+0x88>
   18028:	d31c      	bcc.n	18064 <GFXdrawPixel+0x64>
   1802a:	2b02      	cmp	r3, #2
   1802c:	d111      	bne.n	18052 <GFXdrawPixel+0x52>
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
   1802e:	2a00      	cmp	r2, #0
   18030:	4613      	mov	r3, r2
   18032:	8804      	ldrh	r4, [r0, #0]
   18034:	f04f 0001 	mov.w	r0, #1
   18038:	bfb8      	it	lt
   1803a:	1dd3      	addlt	r3, r2, #7
   1803c:	f002 0207 	and.w	r2, r2, #7
   18040:	10db      	asrs	r3, r3, #3
   18042:	fa00 f202 	lsl.w	r2, r0, r2
   18046:	fb13 1104 	smlabb	r1, r3, r4, r1
   1804a:	4b20      	ldr	r3, [pc, #128]	; (180cc <GFXdrawPixel+0xcc>)
   1804c:	5c58      	ldrb	r0, [r3, r1]
   1804e:	4042      	eors	r2, r0
   18050:	545a      	strb	r2, [r3, r1]
}
   18052:	bc30      	pop	{r4, r5}
   18054:	4770      	bx	lr
   18056:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
   18058:	43d4      	mvns	r4, r2
   1805a:	8805      	ldrh	r5, [r0, #0]
   1805c:	460a      	mov	r2, r1
   1805e:	1961      	adds	r1, r4, r5
   18060:	b209      	sxth	r1, r1
   18062:	e7df      	b.n	18024 <GFXdrawPixel+0x24>
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
   18064:	2a00      	cmp	r2, #0
   18066:	4613      	mov	r3, r2
   18068:	8800      	ldrh	r0, [r0, #0]
   1806a:	f002 0407 	and.w	r4, r2, #7
   1806e:	bfb8      	it	lt
   18070:	1dd3      	addlt	r3, r2, #7
   18072:	2201      	movs	r2, #1
   18074:	10db      	asrs	r3, r3, #3
   18076:	40a2      	lsls	r2, r4
   18078:	fb13 1100 	smlabb	r1, r3, r0, r1
   1807c:	4813      	ldr	r0, [pc, #76]	; (180cc <GFXdrawPixel+0xcc>)
   1807e:	5c43      	ldrb	r3, [r0, r1]
   18080:	ea23 0302 	bic.w	r3, r3, r2
   18084:	5443      	strb	r3, [r0, r1]
   18086:	e7e4      	b.n	18052 <GFXdrawPixel+0x52>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
   18088:	2a00      	cmp	r2, #0
   1808a:	4613      	mov	r3, r2
   1808c:	8804      	ldrh	r4, [r0, #0]
   1808e:	f04f 0001 	mov.w	r0, #1
   18092:	bfb8      	it	lt
   18094:	1dd3      	addlt	r3, r2, #7
   18096:	f002 0207 	and.w	r2, r2, #7
   1809a:	10db      	asrs	r3, r3, #3
   1809c:	fb13 1104 	smlabb	r1, r3, r4, r1
   180a0:	4c0a      	ldr	r4, [pc, #40]	; (180cc <GFXdrawPixel+0xcc>)
   180a2:	fa00 f302 	lsl.w	r3, r0, r2
   180a6:	5c62      	ldrb	r2, [r4, r1]
   180a8:	4313      	orrs	r3, r2
   180aa:	5463      	strb	r3, [r4, r1]
   180ac:	e7d1      	b.n	18052 <GFXdrawPixel+0x52>
    y = myGFX->HEIGHT - y - 1;
   180ae:	8844      	ldrh	r4, [r0, #2]
   180b0:	3c01      	subs	r4, #1
   180b2:	1a64      	subs	r4, r4, r1
   180b4:	4611      	mov	r1, r2
   180b6:	b222      	sxth	r2, r4
   180b8:	e7b4      	b.n	18024 <GFXdrawPixel+0x24>
    x = myGFX->WIDTH - x - 1;
   180ba:	8804      	ldrh	r4, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
   180bc:	43d2      	mvns	r2, r2
   180be:	8845      	ldrh	r5, [r0, #2]
    x = myGFX->WIDTH - x - 1;
   180c0:	3c01      	subs	r4, #1
    y = myGFX->HEIGHT - y - 1;
   180c2:	442a      	add	r2, r5
    x = myGFX->WIDTH - x - 1;
   180c4:	1a61      	subs	r1, r4, r1
    y = myGFX->HEIGHT - y - 1;
   180c6:	b212      	sxth	r2, r2
    x = myGFX->WIDTH - x - 1;
   180c8:	b209      	sxth	r1, r1
   180ca:	e7ab      	b.n	18024 <GFXdrawPixel+0x24>
   180cc:	020fb06c 	.word	0x020fb06c

000180d0 <GFXfillRect>:
   180d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   180d4:	440b      	add	r3, r1
   180d6:	b089      	sub	sp, #36	; 0x24
   180d8:	428b      	cmp	r3, r1
   180da:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
   180de:	f9bd 4048 	ldrsh.w	r4, [sp, #72]	; 0x48
   180e2:	9502      	str	r5, [sp, #8]
   180e4:	f340 80b5 	ble.w	18252 <GFXfillRect+0x182>
   180e8:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   180ec:	4494      	add	ip, r2
   180ee:	fa0f fc8c 	sxth.w	ip, ip
   180f2:	4562      	cmp	r2, ip
   180f4:	bfcb      	itete	gt
   180f6:	4615      	movgt	r5, r2
   180f8:	4665      	movle	r5, ip
   180fa:	4664      	movgt	r4, ip
   180fc:	4614      	movle	r4, r2
   180fe:	9504      	str	r5, [sp, #16]
   18100:	9403      	str	r4, [sp, #12]
   18102:	1b2c      	subs	r4, r5, r4
   18104:	b2a4      	uxth	r4, r4
   18106:	b225      	sxth	r5, r4
   18108:	9407      	str	r4, [sp, #28]
   1810a:	ebac 0402 	sub.w	r4, ip, r2
   1810e:	2d00      	cmp	r5, #0
   18110:	bfb8      	it	lt
   18112:	3501      	addlt	r5, #1
   18114:	2c00      	cmp	r4, #0
   18116:	ea4f 0565 	mov.w	r5, r5, asr #1
   1811a:	bfb8      	it	lt
   1811c:	4264      	neglt	r4, r4
   1811e:	9506      	str	r5, [sp, #24]
   18120:	9405      	str	r4, [sp, #20]
   18122:	4562      	cmp	r2, ip
   18124:	f040 8098 	bne.w	18258 <GFXfillRect+0x188>
   18128:	2600      	movs	r6, #0
   1812a:	460c      	mov	r4, r1
   1812c:	4688      	mov	r8, r1
   1812e:	f8dd e014 	ldr.w	lr, [sp, #20]
   18132:	46b2      	mov	sl, r6
   18134:	4617      	mov	r7, r2
   18136:	fa1f fe8e 	uxth.w	lr, lr
   1813a:	9301      	str	r3, [sp, #4]
   1813c:	e046      	b.n	181cc <GFXfillRect+0xfc>
   1813e:	2f00      	cmp	r7, #0
   18140:	db35      	blt.n	181ae <GFXfillRect+0xde>
   18142:	f8b0 9004 	ldrh.w	r9, [r0, #4]
   18146:	454f      	cmp	r7, r9
   18148:	da31      	bge.n	181ae <GFXfillRect+0xde>
   1814a:	0beb      	lsrs	r3, r5, #15
   1814c:	d12f      	bne.n	181ae <GFXfillRect+0xde>
   1814e:	f8b0 9006 	ldrh.w	r9, [r0, #6]
   18152:	454c      	cmp	r4, r9
   18154:	da2b      	bge.n	181ae <GFXfillRect+0xde>
   18156:	f890 9008 	ldrb.w	r9, [r0, #8]
   1815a:	f1b9 0f02 	cmp.w	r9, #2
   1815e:	f000 80df 	beq.w	18320 <GFXfillRect+0x250>
   18162:	f1b9 0f03 	cmp.w	r9, #3
   18166:	f000 80d3 	beq.w	18310 <GFXfillRect+0x240>
   1816a:	f1b9 0f01 	cmp.w	r9, #1
   1816e:	f000 80c5 	beq.w	182fc <GFXfillRect+0x22c>
   18172:	46b9      	mov	r9, r7
   18174:	9b02      	ldr	r3, [sp, #8]
   18176:	2b01      	cmp	r3, #1
   18178:	f000 80a9 	beq.w	182ce <GFXfillRect+0x1fe>
   1817c:	d378      	bcc.n	18270 <GFXfillRect+0x1a0>
   1817e:	2b02      	cmp	r3, #2
   18180:	d115      	bne.n	181ae <GFXfillRect+0xde>
   18182:	2c00      	cmp	r4, #0
   18184:	46a3      	mov	fp, r4
   18186:	8803      	ldrh	r3, [r0, #0]
   18188:	bfb8      	it	lt
   1818a:	f104 0b07 	addlt.w	fp, r4, #7
   1818e:	f004 0407 	and.w	r4, r4, #7
   18192:	ea4f 0beb 	mov.w	fp, fp, asr #3
   18196:	fb1b 9903 	smlabb	r9, fp, r3, r9
   1819a:	2301      	movs	r3, #1
   1819c:	fa03 f404 	lsl.w	r4, r3, r4
   181a0:	4b81      	ldr	r3, [pc, #516]	; (183a8 <GFXfillRect+0x2d8>)
   181a2:	f813 b009 	ldrb.w	fp, [r3, r9]
   181a6:	ea84 040b 	eor.w	r4, r4, fp
   181aa:	f803 4009 	strb.w	r4, [r3, r9]
   181ae:	eba6 060e 	sub.w	r6, r6, lr
   181b2:	b2b4      	uxth	r4, r6
   181b4:	b226      	sxth	r6, r4
   181b6:	2e00      	cmp	r6, #0
   181b8:	da04      	bge.n	181c4 <GFXfillRect+0xf4>
   181ba:	3f01      	subs	r7, #1
   181bc:	eb04 060a 	add.w	r6, r4, sl
   181c0:	b23f      	sxth	r7, r7
   181c2:	b236      	sxth	r6, r6
   181c4:	1c6c      	adds	r4, r5, #1
   181c6:	b224      	sxth	r4, r4
   181c8:	4544      	cmp	r4, r8
   181ca:	dc3c      	bgt.n	18246 <GFXfillRect+0x176>
   181cc:	4562      	cmp	r2, ip
   181ce:	b2a5      	uxth	r5, r4
   181d0:	d1b5      	bne.n	1813e <GFXfillRect+0x6e>
   181d2:	2c00      	cmp	r4, #0
   181d4:	dbeb      	blt.n	181ae <GFXfillRect+0xde>
   181d6:	f8b0 9004 	ldrh.w	r9, [r0, #4]
   181da:	454c      	cmp	r4, r9
   181dc:	dae7      	bge.n	181ae <GFXfillRect+0xde>
   181de:	043b      	lsls	r3, r7, #16
   181e0:	d4e5      	bmi.n	181ae <GFXfillRect+0xde>
   181e2:	f8b0 9006 	ldrh.w	r9, [r0, #6]
   181e6:	454f      	cmp	r7, r9
   181e8:	dae1      	bge.n	181ae <GFXfillRect+0xde>
   181ea:	f890 9008 	ldrb.w	r9, [r0, #8]
   181ee:	f1b9 0f02 	cmp.w	r9, #2
   181f2:	f000 80cc 	beq.w	1838e <GFXfillRect+0x2be>
   181f6:	f1b9 0f03 	cmp.w	r9, #3
   181fa:	f000 80be 	beq.w	1837a <GFXfillRect+0x2aa>
   181fe:	f1b9 0f01 	cmp.w	r9, #1
   18202:	f000 80b2 	beq.w	1836a <GFXfillRect+0x29a>
   18206:	46b9      	mov	r9, r7
   18208:	9b02      	ldr	r3, [sp, #8]
   1820a:	2b01      	cmp	r3, #1
   1820c:	f000 8095 	beq.w	1833a <GFXfillRect+0x26a>
   18210:	d345      	bcc.n	1829e <GFXfillRect+0x1ce>
   18212:	2b02      	cmp	r3, #2
   18214:	d1cb      	bne.n	181ae <GFXfillRect+0xde>
   18216:	f1b9 0f00 	cmp.w	r9, #0
   1821a:	46cb      	mov	fp, r9
   1821c:	8803      	ldrh	r3, [r0, #0]
   1821e:	bfb8      	it	lt
   18220:	f109 0b07 	addlt.w	fp, r9, #7
   18224:	f009 0907 	and.w	r9, r9, #7
   18228:	ea4f 0beb 	mov.w	fp, fp, asr #3
   1822c:	fb1b 4b03 	smlabb	fp, fp, r3, r4
   18230:	2301      	movs	r3, #1
   18232:	fa03 f909 	lsl.w	r9, r3, r9
   18236:	4b5c      	ldr	r3, [pc, #368]	; (183a8 <GFXfillRect+0x2d8>)
   18238:	f813 400b 	ldrb.w	r4, [r3, fp]
   1823c:	ea89 0404 	eor.w	r4, r9, r4
   18240:	f803 400b 	strb.w	r4, [r3, fp]
   18244:	e7b3      	b.n	181ae <GFXfillRect+0xde>
   18246:	9b01      	ldr	r3, [sp, #4]
   18248:	3101      	adds	r1, #1
   1824a:	b209      	sxth	r1, r1
   1824c:	4299      	cmp	r1, r3
   1824e:	f6ff af68 	blt.w	18122 <GFXfillRect+0x52>
   18252:	b009      	add	sp, #36	; 0x24
   18254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18258:	9c03      	ldr	r4, [sp, #12]
   1825a:	9e04      	ldr	r6, [sp, #16]
   1825c:	42b4      	cmp	r4, r6
   1825e:	dcf3      	bgt.n	18248 <GFXfillRect+0x178>
   18260:	46b0      	mov	r8, r6
   18262:	460f      	mov	r7, r1
   18264:	9e06      	ldr	r6, [sp, #24]
   18266:	f04f 0e00 	mov.w	lr, #0
   1826a:	f8dd a01c 	ldr.w	sl, [sp, #28]
   1826e:	e762      	b.n	18136 <GFXfillRect+0x66>
   18270:	2c00      	cmp	r4, #0
   18272:	46a3      	mov	fp, r4
   18274:	8803      	ldrh	r3, [r0, #0]
   18276:	bfb8      	it	lt
   18278:	f104 0b07 	addlt.w	fp, r4, #7
   1827c:	f004 0407 	and.w	r4, r4, #7
   18280:	ea4f 0beb 	mov.w	fp, fp, asr #3
   18284:	fb1b 9903 	smlabb	r9, fp, r3, r9
   18288:	2301      	movs	r3, #1
   1828a:	fa03 f404 	lsl.w	r4, r3, r4
   1828e:	4b46      	ldr	r3, [pc, #280]	; (183a8 <GFXfillRect+0x2d8>)
   18290:	f813 b009 	ldrb.w	fp, [r3, r9]
   18294:	ea2b 0404 	bic.w	r4, fp, r4
   18298:	f803 4009 	strb.w	r4, [r3, r9]
   1829c:	e787      	b.n	181ae <GFXfillRect+0xde>
   1829e:	f1b9 0f00 	cmp.w	r9, #0
   182a2:	46cb      	mov	fp, r9
   182a4:	8803      	ldrh	r3, [r0, #0]
   182a6:	bfb8      	it	lt
   182a8:	f109 0b07 	addlt.w	fp, r9, #7
   182ac:	f009 0907 	and.w	r9, r9, #7
   182b0:	ea4f 0beb 	mov.w	fp, fp, asr #3
   182b4:	fb1b 4b03 	smlabb	fp, fp, r3, r4
   182b8:	2301      	movs	r3, #1
   182ba:	fa03 f909 	lsl.w	r9, r3, r9
   182be:	4b3a      	ldr	r3, [pc, #232]	; (183a8 <GFXfillRect+0x2d8>)
   182c0:	f813 400b 	ldrb.w	r4, [r3, fp]
   182c4:	ea24 0409 	bic.w	r4, r4, r9
   182c8:	f803 400b 	strb.w	r4, [r3, fp]
   182cc:	e76f      	b.n	181ae <GFXfillRect+0xde>
   182ce:	2c00      	cmp	r4, #0
   182d0:	46a3      	mov	fp, r4
   182d2:	8803      	ldrh	r3, [r0, #0]
   182d4:	bfb8      	it	lt
   182d6:	f104 0b07 	addlt.w	fp, r4, #7
   182da:	f004 0407 	and.w	r4, r4, #7
   182de:	ea4f 0beb 	mov.w	fp, fp, asr #3
   182e2:	fb1b 9903 	smlabb	r9, fp, r3, r9
   182e6:	2301      	movs	r3, #1
   182e8:	fa03 f404 	lsl.w	r4, r3, r4
   182ec:	4b2e      	ldr	r3, [pc, #184]	; (183a8 <GFXfillRect+0x2d8>)
   182ee:	f813 b009 	ldrb.w	fp, [r3, r9]
   182f2:	ea44 040b 	orr.w	r4, r4, fp
   182f6:	f803 4009 	strb.w	r4, [r3, r9]
   182fa:	e758      	b.n	181ae <GFXfillRect+0xde>
   182fc:	f8b0 9000 	ldrh.w	r9, [r0]
   18300:	463c      	mov	r4, r7
   18302:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   18306:	eba9 0905 	sub.w	r9, r9, r5
   1830a:	fa0f f989 	sxth.w	r9, r9
   1830e:	e731      	b.n	18174 <GFXfillRect+0xa4>
   18310:	f8b0 b002 	ldrh.w	fp, [r0, #2]
   18314:	46a1      	mov	r9, r4
   18316:	f10b 34ff 	add.w	r4, fp, #4294967295	; 0xffffffff
   1831a:	1be4      	subs	r4, r4, r7
   1831c:	b224      	sxth	r4, r4
   1831e:	e729      	b.n	18174 <GFXfillRect+0xa4>
   18320:	f8b0 9000 	ldrh.w	r9, [r0]
   18324:	8844      	ldrh	r4, [r0, #2]
   18326:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   1832a:	3c01      	subs	r4, #1
   1832c:	eba9 0907 	sub.w	r9, r9, r7
   18330:	1b64      	subs	r4, r4, r5
   18332:	fa0f f989 	sxth.w	r9, r9
   18336:	b224      	sxth	r4, r4
   18338:	e71c      	b.n	18174 <GFXfillRect+0xa4>
   1833a:	f1b9 0f00 	cmp.w	r9, #0
   1833e:	46cb      	mov	fp, r9
   18340:	8803      	ldrh	r3, [r0, #0]
   18342:	bfb8      	it	lt
   18344:	f109 0b07 	addlt.w	fp, r9, #7
   18348:	f009 0907 	and.w	r9, r9, #7
   1834c:	ea4f 0beb 	mov.w	fp, fp, asr #3
   18350:	fb1b 4b03 	smlabb	fp, fp, r3, r4
   18354:	2301      	movs	r3, #1
   18356:	fa03 f909 	lsl.w	r9, r3, r9
   1835a:	4b13      	ldr	r3, [pc, #76]	; (183a8 <GFXfillRect+0x2d8>)
   1835c:	f813 400b 	ldrb.w	r4, [r3, fp]
   18360:	ea49 0404 	orr.w	r4, r9, r4
   18364:	f803 400b 	strb.w	r4, [r3, fp]
   18368:	e721      	b.n	181ae <GFXfillRect+0xde>
   1836a:	f8b0 b000 	ldrh.w	fp, [r0]
   1836e:	46a1      	mov	r9, r4
   18370:	f10b 34ff 	add.w	r4, fp, #4294967295	; 0xffffffff
   18374:	1be4      	subs	r4, r4, r7
   18376:	b224      	sxth	r4, r4
   18378:	e746      	b.n	18208 <GFXfillRect+0x138>
   1837a:	f8b0 9002 	ldrh.w	r9, [r0, #2]
   1837e:	463c      	mov	r4, r7
   18380:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   18384:	eba9 0905 	sub.w	r9, r9, r5
   18388:	fa0f f989 	sxth.w	r9, r9
   1838c:	e73c      	b.n	18208 <GFXfillRect+0x138>
   1838e:	8804      	ldrh	r4, [r0, #0]
   18390:	f8b0 9002 	ldrh.w	r9, [r0, #2]
   18394:	3c01      	subs	r4, #1
   18396:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   1839a:	1b64      	subs	r4, r4, r5
   1839c:	eba9 0907 	sub.w	r9, r9, r7
   183a0:	b224      	sxth	r4, r4
   183a2:	fa0f f989 	sxth.w	r9, r9
   183a6:	e72f      	b.n	18208 <GFXfillRect+0x138>
   183a8:	020fb06c 	.word	0x020fb06c

000183ac <GFXdrawChar>:

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void GFXdrawChar(GFX* myGFX, int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
   183ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   183b0:	b09b      	sub	sp, #108	; 0x6c
   183b2:	4682      	mov	sl, r0

    if(!myGFX->gfxFont) { // 'Classic' built-in font
   183b4:	6980      	ldr	r0, [r0, #24]
  uint16_t color, uint16_t bg, uint8_t size) {
   183b6:	9204      	str	r2, [sp, #16]
   183b8:	f8bd 2090 	ldrh.w	r2, [sp, #144]	; 0x90
   183bc:	920b      	str	r2, [sp, #44]	; 0x2c
   183be:	f8bd 2094 	ldrh.w	r2, [sp, #148]	; 0x94
   183c2:	9202      	str	r2, [sp, #8]
   183c4:	f89d 2098 	ldrb.w	r2, [sp, #152]	; 0x98
   183c8:	920d      	str	r2, [sp, #52]	; 0x34
    if(!myGFX->gfxFont) { // 'Classic' built-in font
   183ca:	2800      	cmp	r0, #0
   183cc:	f000 811e 	beq.w	1860c <GFXdrawChar+0x260>

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
   183d0:	7a04      	ldrb	r4, [r0, #8]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   183d2:	6842      	ldr	r2, [r0, #4]
        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
   183d4:	1b1b      	subs	r3, r3, r4
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
   183d6:	6800      	ldr	r0, [r0, #0]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   183d8:	b2db      	uxtb	r3, r3
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
   183da:	9010      	str	r0, [sp, #64]	; 0x40
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
   183dc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   183e0:	881a      	ldrh	r2, [r3, #0]
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
   183e2:	f993 0006 	ldrsb.w	r0, [r3, #6]
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   183e6:	920c      	str	r2, [sp, #48]	; 0x30
        uint8_t  w  = pgm_read_byte(&glyph->width),
   183e8:	789a      	ldrb	r2, [r3, #2]
                 yo = pgm_read_byte(&glyph->yOffset);
   183ea:	9019      	str	r0, [sp, #100]	; 0x64
        uint8_t  w  = pgm_read_byte(&glyph->width),
   183ec:	9209      	str	r2, [sp, #36]	; 0x24
                 h  = pgm_read_byte(&glyph->height);
   183ee:	78da      	ldrb	r2, [r3, #3]
   183f0:	9214      	str	r2, [sp, #80]	; 0x50
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
   183f2:	f993 2005 	ldrsb.w	r2, [r3, #5]
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
   183f6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   183f8:	2b01      	cmp	r3, #1
   183fa:	f240 80a7 	bls.w	1854c <GFXdrawChar+0x1a0>
            xo16 = xo;
            yo16 = yo;
   183fe:	b200      	sxth	r0, r0
            xo16 = xo;
   18400:	b213      	sxth	r3, r2
            yo16 = yo;
   18402:	9015      	str	r0, [sp, #84]	; 0x54
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        //startWrite();
        for(yy=0; yy<h; yy++) {
   18404:	9814      	ldr	r0, [sp, #80]	; 0x50
   18406:	2800      	cmp	r0, #0
   18408:	f000 80a6 	beq.w	18558 <GFXdrawChar+0x1ac>
   1840c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1840e:	2800      	cmp	r0, #0
   18410:	f000 80a2 	beq.w	18558 <GFXdrawChar+0x1ac>
                }
                if(bits & 0x80) {
                    if(size == 1) {
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
                    } else {
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18414:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   18418:	b289      	uxth	r1, r1
        uint8_t  xx, yy, bits = 0, bit = 0;
   1841a:	2000      	movs	r0, #0
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   1841c:	188a      	adds	r2, r1, r2
   1841e:	fb03 1104 	mla	r1, r3, r4, r1
   18422:	1e63      	subs	r3, r4, #1
        uint8_t  xx, yy, bits = 0, bit = 0;
   18424:	9007      	str	r0, [sp, #28]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   18426:	9218      	str	r2, [sp, #96]	; 0x60
   18428:	9317      	str	r3, [sp, #92]	; 0x5c
   1842a:	b28b      	uxth	r3, r1
   1842c:	f8bd 2010 	ldrh.w	r2, [sp, #16]
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18430:	940a      	str	r4, [sp, #40]	; 0x28
   18432:	9213      	str	r2, [sp, #76]	; 0x4c
        uint8_t  xx, yy, bits = 0, bit = 0;
   18434:	9002      	str	r0, [sp, #8]
        for(yy=0; yy<h; yy++) {
   18436:	900f      	str	r0, [sp, #60]	; 0x3c
   18438:	9316      	str	r3, [sp, #88]	; 0x58
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1843a:	9a15      	ldr	r2, [sp, #84]	; 0x54
    int16_t err = dx / 2;
   1843c:	2700      	movs	r7, #0
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1843e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   18440:	9913      	ldr	r1, [sp, #76]	; 0x4c
   18442:	4413      	add	r3, r2
   18444:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   18446:	fb03 1302 	mla	r3, r3, r2, r1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1844a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   1844c:	b29b      	uxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1844e:	189a      	adds	r2, r3, r2
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18450:	b21b      	sxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   18452:	b211      	sxth	r1, r2
   18454:	461a      	mov	r2, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   18456:	9311      	str	r3, [sp, #68]	; 0x44
   18458:	428b      	cmp	r3, r1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1845a:	9104      	str	r1, [sp, #16]
   1845c:	bfa8      	it	ge
   1845e:	460a      	movge	r2, r1
   18460:	428b      	cmp	r3, r1
   18462:	bfb8      	it	lt
   18464:	460b      	movlt	r3, r1
   18466:	9208      	str	r2, [sp, #32]
   18468:	9911      	ldr	r1, [sp, #68]	; 0x44
   1846a:	4699      	mov	r9, r3
    dx = x1 - x0;
   1846c:	1a9b      	subs	r3, r3, r2
   1846e:	9a04      	ldr	r2, [sp, #16]
   18470:	b29b      	uxth	r3, r3
   18472:	eba2 0801 	sub.w	r8, r2, r1
   18476:	9306      	str	r3, [sp, #24]
    int16_t err = dx / 2;
   18478:	b21b      	sxth	r3, r3
   1847a:	2b00      	cmp	r3, #0
   1847c:	bfb8      	it	lt
   1847e:	3301      	addlt	r3, #1
   18480:	f1b8 0f00 	cmp.w	r8, #0
   18484:	ea4f 0363 	mov.w	r3, r3, asr #1
   18488:	bfb8      	it	lt
   1848a:	f1c8 0800 	rsblt	r8, r8, #0
   1848e:	930e      	str	r3, [sp, #56]	; 0x38
   18490:	fa1f f888 	uxth.w	r8, r8
   18494:	9b16      	ldr	r3, [sp, #88]	; 0x58
   18496:	9303      	str	r3, [sp, #12]
   18498:	e00e      	b.n	184b8 <GFXdrawChar+0x10c>
                          size, size, color);
                    }
                }
                bits <<= 1;
   1849a:	9b02      	ldr	r3, [sp, #8]
   1849c:	3701      	adds	r7, #1
   1849e:	9a03      	ldr	r2, [sp, #12]
   184a0:	990a      	ldr	r1, [sp, #40]	; 0x28
   184a2:	005b      	lsls	r3, r3, #1
   184a4:	b2bf      	uxth	r7, r7
   184a6:	440a      	add	r2, r1
   184a8:	b2db      	uxtb	r3, r3
   184aa:	b292      	uxth	r2, r2
   184ac:	9302      	str	r3, [sp, #8]
            for(xx=0; xx<w; xx++) {
   184ae:	b2fb      	uxtb	r3, r7
   184b0:	9203      	str	r2, [sp, #12]
   184b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
   184b4:	429a      	cmp	r2, r3
   184b6:	d97b      	bls.n	185b0 <GFXdrawChar+0x204>
                if(!(bit++ & 7)) {
   184b8:	9b07      	ldr	r3, [sp, #28]
   184ba:	443b      	add	r3, r7
   184bc:	0759      	lsls	r1, r3, #29
   184be:	d106      	bne.n	184ce <GFXdrawChar+0x122>
                    bits = pgm_read_byte(&bitmap[bo++]);
   184c0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   184c2:	9910      	ldr	r1, [sp, #64]	; 0x40
   184c4:	1c53      	adds	r3, r2, #1
   184c6:	5c8a      	ldrb	r2, [r1, r2]
   184c8:	b29b      	uxth	r3, r3
   184ca:	9202      	str	r2, [sp, #8]
   184cc:	930c      	str	r3, [sp, #48]	; 0x30
                if(bits & 0x80) {
   184ce:	9b02      	ldr	r3, [sp, #8]
   184d0:	061a      	lsls	r2, r3, #24
   184d2:	d5e2      	bpl.n	1849a <GFXdrawChar+0xee>
                    if(size == 1) {
   184d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   184d6:	2b01      	cmp	r3, #1
   184d8:	d07a      	beq.n	185d0 <GFXdrawChar+0x224>
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
   184da:	f9bd 600c 	ldrsh.w	r6, [sp, #12]
    for (int16_t i=x; i<x+w; i++) {
   184de:	4433      	add	r3, r6
   184e0:	42b3      	cmp	r3, r6
   184e2:	9305      	str	r3, [sp, #20]
   184e4:	ddd9      	ble.n	1849a <GFXdrawChar+0xee>
   184e6:	9712      	str	r7, [sp, #72]	; 0x48
   184e8:	9f11      	ldr	r7, [sp, #68]	; 0x44
    if (steep) {
   184ea:	9b04      	ldr	r3, [sp, #16]
   184ec:	429f      	cmp	r7, r3
   184ee:	d036      	beq.n	1855e <GFXdrawChar+0x1b2>
    for (; x0<=x1; x0++) {
   184f0:	9b08      	ldr	r3, [sp, #32]
   184f2:	454b      	cmp	r3, r9
   184f4:	dc23      	bgt.n	1853e <GFXdrawChar+0x192>
   184f6:	461c      	mov	r4, r3
   184f8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   184fa:	46b3      	mov	fp, r6
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   184fc:	f1bb 0f00 	cmp.w	fp, #0
   18500:	db0f      	blt.n	18522 <GFXdrawChar+0x176>
   18502:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   18506:	459b      	cmp	fp, r3
   18508:	da0b      	bge.n	18522 <GFXdrawChar+0x176>
   1850a:	0423      	lsls	r3, r4, #16
   1850c:	d409      	bmi.n	18522 <GFXdrawChar+0x176>
   1850e:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   18512:	4622      	mov	r2, r4
   18514:	4659      	mov	r1, fp
   18516:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18518:	4284      	cmp	r4, r0
   1851a:	4650      	mov	r0, sl
   1851c:	da01      	bge.n	18522 <GFXdrawChar+0x176>
   1851e:	f7ff fc5b 	bl	17dd8 <GFXdrawPixel.part.0>
   18522:	3401      	adds	r4, #1
        if (err < 0) {
   18524:	2d00      	cmp	r5, #0
        err -= dy;
   18526:	b2ab      	uxth	r3, r5
   18528:	b224      	sxth	r4, r4
        if (err < 0) {
   1852a:	da06      	bge.n	1853a <GFXdrawChar+0x18e>
            err += dx;
   1852c:	9a06      	ldr	r2, [sp, #24]
            y0 += ystep;
   1852e:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
            err += dx;
   18532:	18d5      	adds	r5, r2, r3
            y0 += ystep;
   18534:	fa0f fb8b 	sxth.w	fp, fp
            err += dx;
   18538:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
   1853a:	45a1      	cmp	r9, r4
   1853c:	dade      	bge.n	184fc <GFXdrawChar+0x150>
   1853e:	3601      	adds	r6, #1
    for (int16_t i=x; i<x+w; i++) {
   18540:	9b05      	ldr	r3, [sp, #20]
   18542:	b236      	sxth	r6, r6
   18544:	429e      	cmp	r6, r3
   18546:	dbd0      	blt.n	184ea <GFXdrawChar+0x13e>
   18548:	9f12      	ldr	r7, [sp, #72]	; 0x48
   1854a:	e7a6      	b.n	1849a <GFXdrawChar+0xee>
        int16_t  xo16 = 0, yo16 = 0;
   1854c:	2300      	movs	r3, #0
        for(yy=0; yy<h; yy++) {
   1854e:	9814      	ldr	r0, [sp, #80]	; 0x50
        int16_t  xo16 = 0, yo16 = 0;
   18550:	9315      	str	r3, [sp, #84]	; 0x54
        for(yy=0; yy<h; yy++) {
   18552:	2800      	cmp	r0, #0
   18554:	f47f af5a 	bne.w	1840c <GFXdrawChar+0x60>
            }
        }
        //endWrite();

    } // End classic vs custom font
}
   18558:	b01b      	add	sp, #108	; 0x6c
   1855a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (steep) {
   1855e:	4634      	mov	r4, r6
   18560:	46bb      	mov	fp, r7
    int16_t err = dx / 2;
   18562:	2500      	movs	r5, #0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   18564:	2c00      	cmp	r4, #0
   18566:	db10      	blt.n	1858a <GFXdrawChar+0x1de>
   18568:	f8ba 3004 	ldrh.w	r3, [sl, #4]
   1856c:	42a3      	cmp	r3, r4
   1856e:	dd0c      	ble.n	1858a <GFXdrawChar+0x1de>
   18570:	f1bb 0f00 	cmp.w	fp, #0
   18574:	db09      	blt.n	1858a <GFXdrawChar+0x1de>
   18576:	f8ba 0006 	ldrh.w	r0, [sl, #6]
   1857a:	465a      	mov	r2, fp
   1857c:	4621      	mov	r1, r4
   1857e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18580:	4558      	cmp	r0, fp
   18582:	4650      	mov	r0, sl
   18584:	dd01      	ble.n	1858a <GFXdrawChar+0x1de>
   18586:	f7ff fc27 	bl	17dd8 <GFXdrawPixel.part.0>
        err -= dy;
   1858a:	eba5 0508 	sub.w	r5, r5, r8
   1858e:	3401      	adds	r4, #1
   18590:	b22d      	sxth	r5, r5
   18592:	b224      	sxth	r4, r4
        if (err < 0) {
   18594:	2d00      	cmp	r5, #0
   18596:	da03      	bge.n	185a0 <GFXdrawChar+0x1f4>
            y0 += ystep;
   18598:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   1859c:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
   185a0:	42a6      	cmp	r6, r4
   185a2:	dadf      	bge.n	18564 <GFXdrawChar+0x1b8>
   185a4:	3601      	adds	r6, #1
    for (int16_t i=x; i<x+w; i++) {
   185a6:	9b05      	ldr	r3, [sp, #20]
   185a8:	b236      	sxth	r6, r6
   185aa:	429e      	cmp	r6, r3
   185ac:	db9d      	blt.n	184ea <GFXdrawChar+0x13e>
   185ae:	e7cb      	b.n	18548 <GFXdrawChar+0x19c>
   185b0:	4611      	mov	r1, r2
   185b2:	9b07      	ldr	r3, [sp, #28]
        for(yy=0; yy<h; yy++) {
   185b4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   185b6:	440b      	add	r3, r1
   185b8:	3201      	adds	r2, #1
   185ba:	b2db      	uxtb	r3, r3
   185bc:	b2d2      	uxtb	r2, r2
   185be:	9307      	str	r3, [sp, #28]
   185c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
   185c2:	920f      	str	r2, [sp, #60]	; 0x3c
   185c4:	4293      	cmp	r3, r2
   185c6:	f63f af38 	bhi.w	1843a <GFXdrawChar+0x8e>
}
   185ca:	b01b      	add	sp, #108	; 0x6c
   185cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   185d0:	9b18      	ldr	r3, [sp, #96]	; 0x60
   185d2:	18f9      	adds	r1, r7, r3
   185d4:	b209      	sxth	r1, r1
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185d6:	2900      	cmp	r1, #0
   185d8:	f6ff af5f 	blt.w	1849a <GFXdrawChar+0xee>
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   185dc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   185de:	9a19      	ldr	r2, [sp, #100]	; 0x64
   185e0:	980f      	ldr	r0, [sp, #60]	; 0x3c
   185e2:	189a      	adds	r2, r3, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185e4:	f8ba 3004 	ldrh.w	r3, [sl, #4]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   185e8:	4402      	add	r2, r0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185ea:	4299      	cmp	r1, r3
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
   185ec:	b212      	sxth	r2, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
   185ee:	f6bf af54 	bge.w	1849a <GFXdrawChar+0xee>
   185f2:	2a00      	cmp	r2, #0
   185f4:	f6ff af51 	blt.w	1849a <GFXdrawChar+0xee>
   185f8:	f8ba 3006 	ldrh.w	r3, [sl, #6]
   185fc:	429a      	cmp	r2, r3
   185fe:	f6bf af4c 	bge.w	1849a <GFXdrawChar+0xee>
   18602:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18604:	4650      	mov	r0, sl
   18606:	f7ff fbe7 	bl	17dd8 <GFXdrawPixel.part.0>
   1860a:	e746      	b.n	1849a <GFXdrawChar+0xee>
        if((x >= myGFX->_width)            || // Clip right
   1860c:	f8ba 2004 	ldrh.w	r2, [sl, #4]
   18610:	4291      	cmp	r1, r2
   18612:	daa1      	bge.n	18558 <GFXdrawChar+0x1ac>
           (y >= myGFX->_height)           || // Clip bottom
   18614:	f8ba 2006 	ldrh.w	r2, [sl, #6]
        if((x >= myGFX->_width)            || // Clip right
   18618:	9c04      	ldr	r4, [sp, #16]
   1861a:	4294      	cmp	r4, r2
   1861c:	da9c      	bge.n	18558 <GFXdrawChar+0x1ac>
           ((x + 6 * size - 1) < 0) || // Clip left
   1861e:	2206      	movs	r2, #6
   18620:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   18622:	fb12 1205 	smlabb	r2, r2, r5, r1
           (y >= myGFX->_height)           || // Clip bottom
   18626:	2a00      	cmp	r2, #0
   18628:	dd96      	ble.n	18558 <GFXdrawChar+0x1ac>
           ((y + 8 * size - 1) < 0))   // Clip top
   1862a:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
           ((x + 6 * size - 1) < 0) || // Clip left
   1862e:	2a00      	cmp	r2, #0
   18630:	dd92      	ble.n	18558 <GFXdrawChar+0x1ac>
        if(!myGFX->_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
   18632:	f8ba 2016 	ldrh.w	r2, [sl, #22]
   18636:	b91a      	cbnz	r2, 18640 <GFXdrawChar+0x294>
   18638:	2baf      	cmp	r3, #175	; 0xaf
   1863a:	d901      	bls.n	18640 <GFXdrawChar+0x294>
   1863c:	3301      	adds	r3, #1
   1863e:	b2db      	uxtb	r3, r3
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
   18640:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   18644:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   18648:	b289      	uxth	r1, r1
   1864a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1864e:	9403      	str	r4, [sp, #12]
   18650:	1d4a      	adds	r2, r1, #5
   18652:	910f      	str	r1, [sp, #60]	; 0x3c
   18654:	009b      	lsls	r3, r3, #2
   18656:	9106      	str	r1, [sp, #24]
   18658:	b292      	uxth	r2, r2
   1865a:	9107      	str	r1, [sp, #28]
   1865c:	9308      	str	r3, [sp, #32]
   1865e:	1e63      	subs	r3, r4, #1
   18660:	920c      	str	r2, [sp, #48]	; 0x30
   18662:	9309      	str	r3, [sp, #36]	; 0x24
   18664:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   18668:	9a08      	ldr	r2, [sp, #32]
   1866a:	461d      	mov	r5, r3
   1866c:	9313      	str	r3, [sp, #76]	; 0x4c
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1866e:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
    for (int16_t i=x; i<x+w; i++) {
   18672:	2700      	movs	r7, #0
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
   18674:	f810 9002 	ldrb.w	r9, [r0, r2]
    for (int16_t i=x; i<x+w; i++) {
   18678:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    GFXdrawPixel(myGFX, x, y, color);
   1867a:	46b8      	mov	r8, r7
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1867c:	9305      	str	r3, [sp, #20]
    for (int16_t i=x; i<x+w; i++) {
   1867e:	189e      	adds	r6, r3, r2
    GFXdrawPixel(myGFX, x, y, color);
   18680:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
   18684:	930e      	str	r3, [sp, #56]	; 0x38
                if(line & 1) {
   18686:	f019 0f01 	tst.w	r9, #1
   1868a:	d037      	beq.n	186fc <GFXdrawChar+0x350>
                    if(size == 1)
   1868c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1868e:	2b01      	cmp	r3, #1
   18690:	d057      	beq.n	18742 <GFXdrawChar+0x396>
    for (int16_t i=x; i<x+w; i++) {
   18692:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, color);
   18694:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
   18698:	42b4      	cmp	r4, r6
   1869a:	da11      	bge.n	186c0 <GFXdrawChar+0x314>
   1869c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1869e:	950a      	str	r5, [sp, #40]	; 0x28
   186a0:	18ef      	adds	r7, r5, r3
   186a2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   186a4:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   186a6:	4623      	mov	r3, r4
   186a8:	4621      	mov	r1, r4
   186aa:	3401      	adds	r4, #1
   186ac:	9501      	str	r5, [sp, #4]
   186ae:	9700      	str	r7, [sp, #0]
   186b0:	465a      	mov	r2, fp
   186b2:	b224      	sxth	r4, r4
   186b4:	4650      	mov	r0, sl
   186b6:	f7ff fc07 	bl	17ec8 <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
   186ba:	42b4      	cmp	r4, r6
   186bc:	dbf3      	blt.n	186a6 <GFXdrawChar+0x2fa>
   186be:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   186c0:	9b03      	ldr	r3, [sp, #12]
   186c2:	f108 0801 	add.w	r8, r8, #1
            for(int8_t j=0; j<8; j++, line >>= 1) {
   186c6:	ea4f 0959 	mov.w	r9, r9, lsr #1
   186ca:	441d      	add	r5, r3
   186cc:	f1b8 0f08 	cmp.w	r8, #8
   186d0:	b2ad      	uxth	r5, r5
   186d2:	d1d8      	bne.n	18686 <GFXdrawChar+0x2da>
   186d4:	4619      	mov	r1, r3
   186d6:	9b07      	ldr	r3, [sp, #28]
   186d8:	9a06      	ldr	r2, [sp, #24]
   186da:	440b      	add	r3, r1
   186dc:	9908      	ldr	r1, [sp, #32]
   186de:	3201      	adds	r2, #1
   186e0:	b29b      	uxth	r3, r3
   186e2:	310c      	adds	r1, #12
   186e4:	b292      	uxth	r2, r2
   186e6:	9307      	str	r3, [sp, #28]
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
   186e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   186ea:	9108      	str	r1, [sp, #32]
   186ec:	4293      	cmp	r3, r2
   186ee:	9206      	str	r2, [sp, #24]
   186f0:	d03b      	beq.n	1876a <GFXdrawChar+0x3be>
   186f2:	f8da 0018 	ldr.w	r0, [sl, #24]
   186f6:	460a      	mov	r2, r1
   186f8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   186fa:	e7b8      	b.n	1866e <GFXdrawChar+0x2c2>
                } else if(bg != color) {
   186fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   186fe:	9a02      	ldr	r2, [sp, #8]
   18700:	4293      	cmp	r3, r2
   18702:	d0dd      	beq.n	186c0 <GFXdrawChar+0x314>
                    if(size == 1)
   18704:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18706:	2b01      	cmp	r3, #1
   18708:	d025      	beq.n	18756 <GFXdrawChar+0x3aa>
    for (int16_t i=x; i<x+w; i++) {
   1870a:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
   1870c:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
   18710:	42b4      	cmp	r4, r6
   18712:	dad5      	bge.n	186c0 <GFXdrawChar+0x314>
   18714:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18716:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   1871a:	46a9      	mov	r9, r5
   1871c:	18ef      	adds	r7, r5, r3
   1871e:	9d02      	ldr	r5, [sp, #8]
   18720:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   18722:	4623      	mov	r3, r4
   18724:	4621      	mov	r1, r4
   18726:	3401      	adds	r4, #1
   18728:	9501      	str	r5, [sp, #4]
   1872a:	9700      	str	r7, [sp, #0]
   1872c:	465a      	mov	r2, fp
   1872e:	b224      	sxth	r4, r4
   18730:	4650      	mov	r0, sl
   18732:	f7ff fbc9 	bl	17ec8 <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
   18736:	42b4      	cmp	r4, r6
   18738:	dbf3      	blt.n	18722 <GFXdrawChar+0x376>
   1873a:	464d      	mov	r5, r9
   1873c:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
   18740:	e7be      	b.n	186c0 <GFXdrawChar+0x314>
    GFXdrawPixel(myGFX, x, y, color);
   18742:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18744:	4650      	mov	r0, sl
   18746:	990e      	ldr	r1, [sp, #56]	; 0x38
   18748:	eb03 0208 	add.w	r2, r3, r8
   1874c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1874e:	b212      	sxth	r2, r2
   18750:	f7ff fc56 	bl	18000 <GFXdrawPixel>
   18754:	e7b4      	b.n	186c0 <GFXdrawChar+0x314>
   18756:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18758:	4650      	mov	r0, sl
   1875a:	990e      	ldr	r1, [sp, #56]	; 0x38
   1875c:	eb03 0208 	add.w	r2, r3, r8
   18760:	9b02      	ldr	r3, [sp, #8]
   18762:	b212      	sxth	r2, r2
   18764:	f7ff fc4c 	bl	18000 <GFXdrawPixel>
   18768:	e7aa      	b.n	186c0 <GFXdrawChar+0x314>
        if(bg != color) { // If opaque, draw vertical line for last column
   1876a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1876c:	9a02      	ldr	r2, [sp, #8]
   1876e:	4293      	cmp	r3, r2
   18770:	f43f aef2 	beq.w	18558 <GFXdrawChar+0x1ac>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
   18774:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   18776:	2b01      	cmp	r3, #1
   18778:	d01e      	beq.n	187b8 <GFXdrawChar+0x40c>
            else          GFXwriteFillRect(myGFX,x+5*size, y, size, 8*size, bg);
   1877a:	9b03      	ldr	r3, [sp, #12]
   1877c:	eb03 0583 	add.w	r5, r3, r3, lsl #2
   18780:	00dc      	lsls	r4, r3, #3
   18782:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   18784:	442b      	add	r3, r5
   18786:	b21d      	sxth	r5, r3
    for (int16_t i=x; i<x+w; i++) {
   18788:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1878a:	442b      	add	r3, r5
   1878c:	42ab      	cmp	r3, r5
   1878e:	461e      	mov	r6, r3
   18790:	f77f aee2 	ble.w	18558 <GFXdrawChar+0x1ac>
   18794:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18796:	3b01      	subs	r3, #1
   18798:	441c      	add	r4, r3
   1879a:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   1879c:	9b02      	ldr	r3, [sp, #8]
   1879e:	4629      	mov	r1, r5
   187a0:	9400      	str	r4, [sp, #0]
   187a2:	4650      	mov	r0, sl
   187a4:	9301      	str	r3, [sp, #4]
   187a6:	462b      	mov	r3, r5
   187a8:	3501      	adds	r5, #1
   187aa:	9a04      	ldr	r2, [sp, #16]
   187ac:	f7ff fb8c 	bl	17ec8 <GFXwriteLine>
   187b0:	b22d      	sxth	r5, r5
    for (int16_t i=x; i<x+w; i++) {
   187b2:	42ae      	cmp	r6, r5
   187b4:	dcf2      	bgt.n	1879c <GFXdrawChar+0x3f0>
   187b6:	e6cf      	b.n	18558 <GFXdrawChar+0x1ac>
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   187b8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   187ba:	4650      	mov	r0, sl
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
   187bc:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   187c0:	3407      	adds	r4, #7
   187c2:	9225      	str	r2, [sp, #148]	; 0x94
   187c4:	4619      	mov	r1, r3
   187c6:	9a04      	ldr	r2, [sp, #16]
   187c8:	b224      	sxth	r4, r4
   187ca:	9424      	str	r4, [sp, #144]	; 0x90
}
   187cc:	b01b      	add	sp, #108	; 0x6c
   187ce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
   187d2:	f7ff bb79 	b.w	17ec8 <GFXwriteLine>
   187d6:	bf00      	nop

000187d8 <GFXwrite>:
        }
  }
}


void GFXwrite(GFX* myGFX, uint8_t c) {
   187d8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(!myGFX->gfxFont) { // 'Classic' built-in font
   187da:	6983      	ldr	r3, [r0, #24]
void GFXwrite(GFX* myGFX, uint8_t c) {
   187dc:	b085      	sub	sp, #20
   187de:	4604      	mov	r4, r0
	if(!myGFX->gfxFont) { // 'Classic' built-in font
   187e0:	b32b      	cbz	r3, 1882e <GFXwrite+0x56>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
		}

	} else { // Custom font

		if(c == '\n') {
   187e2:	290a      	cmp	r1, #10
   187e4:	d018      	beq.n	18818 <GFXwrite+0x40>
			myGFX->cursor_x  = 0;
			myGFX->cursor_y += (int16_t)myGFX->textsize *
						(uint8_t)pgm_read_byte(&myGFX->gfxFont->yAdvance);
		} else if(c != '\r') {
   187e6:	290d      	cmp	r1, #13
   187e8:	d01f      	beq.n	1882a <GFXwrite+0x52>
			uint8_t first = pgm_read_byte(&myGFX->gfxFont->first);
   187ea:	7a1a      	ldrb	r2, [r3, #8]
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&myGFX->gfxFont->last))) {
   187ec:	4291      	cmp	r1, r2
   187ee:	d31c      	bcc.n	1882a <GFXwrite+0x52>
   187f0:	7a58      	ldrb	r0, [r3, #9]
   187f2:	4288      	cmp	r0, r1
   187f4:	d319      	bcc.n	1882a <GFXwrite+0x52>
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
				  &myGFX->gfxFont->glyph))[c - first]);
   187f6:	685d      	ldr	r5, [r3, #4]
   187f8:	1a8a      	subs	r2, r1, r2
   187fa:	89e0      	ldrh	r0, [r4, #14]
   187fc:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
				uint8_t   w     = pgm_read_byte(&glyph->width),
						  h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   18800:	78eb      	ldrb	r3, [r5, #3]
				uint8_t   w     = pgm_read_byte(&glyph->width),
   18802:	78ae      	ldrb	r6, [r5, #2]
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   18804:	b10b      	cbz	r3, 1880a <GFXwrite+0x32>
   18806:	2e00      	cmp	r6, #0
   18808:	d158      	bne.n	188bc <GFXwrite+0xe4>
					//     cursor_y += (int16_t)textsize *
					//       (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
					// }
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
				}
				myGFX->cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)myGFX->textsize;
   1880a:	792b      	ldrb	r3, [r5, #4]
   1880c:	89a2      	ldrh	r2, [r4, #12]
   1880e:	fb13 f300 	smulbb	r3, r3, r0
   18812:	4413      	add	r3, r2
   18814:	81a3      	strh	r3, [r4, #12]
			}
		}

	}
}
   18816:	e008      	b.n	1882a <GFXwrite+0x52>
			myGFX->cursor_x  = 0;
   18818:	2000      	movs	r0, #0
			myGFX->cursor_y += (int16_t)myGFX->textsize *
   1881a:	8962      	ldrh	r2, [r4, #10]
   1881c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
			myGFX->cursor_x  = 0;
   18820:	81a0      	strh	r0, [r4, #12]
			myGFX->cursor_y += (int16_t)myGFX->textsize *
   18822:	7a9b      	ldrb	r3, [r3, #10]
   18824:	fb01 2303 	mla	r3, r1, r3, r2
   18828:	8163      	strh	r3, [r4, #10]
}
   1882a:	b005      	add	sp, #20
   1882c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(c == '\n') {                        // Newline?
   1882e:	290a      	cmp	r1, #10
   18830:	d03c      	beq.n	188ac <GFXwrite+0xd4>
		} else if(c != '\r') {                 // Ignore carriage returns
   18832:	290d      	cmp	r1, #13
   18834:	d0f9      	beq.n	1882a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   18836:	8a85      	ldrh	r5, [r0, #20]
   18838:	8962      	ldrh	r2, [r4, #10]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
   1883a:	89c0      	ldrh	r0, [r0, #14]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   1883c:	b135      	cbz	r5, 1884c <GFXwrite+0x74>
   1883e:	89a7      	ldrh	r7, [r4, #12]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
   18840:	0085      	lsls	r5, r0, #2
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   18842:	88a6      	ldrh	r6, [r4, #4]
   18844:	fa07 f585 	sxtah	r5, r7, r5
   18848:	42b5      	cmp	r5, r6
   1884a:	da6c      	bge.n	18926 <GFXwrite+0x14e>
    if (myGFX->autoscroll) {
   1884c:	8c23      	ldrh	r3, [r4, #32]
   1884e:	b1b3      	cbz	r3, 1887e <GFXwrite+0xa6>
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   18850:	8ba3      	ldrh	r3, [r4, #28]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   18852:	8be5      	ldrh	r5, [r4, #30]
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   18854:	fb13 f300 	smulbb	r3, r3, r0
        if (cursor >= myGFX->_height) {
   18858:	88e7      	ldrh	r7, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   1885a:	fb15 f500 	smulbb	r5, r5, r0
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   1885e:	3b01      	subs	r3, #1
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   18860:	b2ad      	uxth	r5, r5
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
   18862:	b29b      	uxth	r3, r3
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   18864:	195e      	adds	r6, r3, r5
   18866:	4416      	add	r6, r2
        if (cursor >= myGFX->_height) {
   18868:	b2b6      	uxth	r6, r6
   1886a:	42be      	cmp	r6, r7
   1886c:	d307      	bcc.n	1887e <GFXwrite+0xa6>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   1886e:	43ed      	mvns	r5, r5
            myGFX->cursor_x  = 0;
   18870:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18872:	443d      	add	r5, r7
            myGFX->cursor_x  = 0;
   18874:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18876:	1aeb      	subs	r3, r5, r3
   18878:	b29a      	uxth	r2, r3
   1887a:	8162      	strh	r2, [r4, #10]
   1887c:	e001      	b.n	18882 <GFXwrite+0xaa>
   1887e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
			GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
   18882:	8a67      	ldrh	r7, [r4, #18]
   18884:	b2c0      	uxtb	r0, r0
   18886:	8a25      	ldrh	r5, [r4, #16]
   18888:	460b      	mov	r3, r1
   1888a:	9002      	str	r0, [sp, #8]
   1888c:	b212      	sxth	r2, r2
   1888e:	4631      	mov	r1, r6
   18890:	4620      	mov	r0, r4
   18892:	e9cd 5700 	strd	r5, r7, [sp]
   18896:	f7ff fd89 	bl	183ac <GFXdrawChar>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
   1889a:	89e3      	ldrh	r3, [r4, #14]
   1889c:	89a2      	ldrh	r2, [r4, #12]
   1889e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   188a2:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   188a6:	81a3      	strh	r3, [r4, #12]
}
   188a8:	b005      	add	sp, #20
   188aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
   188ac:	8b82      	ldrh	r2, [r0, #28]
   188ae:	8961      	ldrh	r1, [r4, #10]
   188b0:	89c0      	ldrh	r0, [r0, #14]
			myGFX->cursor_x  = 0;                     // Reset x to zero,
   188b2:	81a3      	strh	r3, [r4, #12]
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
   188b4:	fb12 1300 	smlabb	r3, r2, r0, r1
   188b8:	8163      	strh	r3, [r4, #10]
   188ba:	e7b6      	b.n	1882a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188bc:	8aa3      	ldrh	r3, [r4, #20]
   188be:	8962      	ldrh	r2, [r4, #10]
   188c0:	b18b      	cbz	r3, 188e6 <GFXwrite+0x10e>
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   188c2:	f995 3005 	ldrsb.w	r3, [r5, #5]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188c6:	89a7      	ldrh	r7, [r4, #12]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   188c8:	4433      	add	r3, r6
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188ca:	88a6      	ldrh	r6, [r4, #4]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
   188cc:	fb13 f300 	smulbb	r3, r3, r0
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
   188d0:	fa07 f383 	sxtah	r3, r7, r3
   188d4:	42b3      	cmp	r3, r6
   188d6:	db06      	blt.n	188e6 <GFXwrite+0x10e>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   188d8:	8ba3      	ldrh	r3, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
   188da:	2600      	movs	r6, #0
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   188dc:	fb13 2200 	smlabb	r2, r3, r0, r2
    	myGFX->cursor_x  = 0;            // Reset x to zero
   188e0:	81a6      	strh	r6, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   188e2:	b292      	uxth	r2, r2
   188e4:	8162      	strh	r2, [r4, #10]
    if (myGFX->autoscroll) {
   188e6:	8c23      	ldrh	r3, [r4, #32]
   188e8:	b323      	cbz	r3, 18934 <GFXwrite+0x15c>
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   188ea:	8be3      	ldrh	r3, [r4, #30]
        if (cursor >= myGFX->_height) {
   188ec:	88e6      	ldrh	r6, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
   188ee:	fb13 f300 	smulbb	r3, r3, r0
   188f2:	b29b      	uxth	r3, r3
   188f4:	18d7      	adds	r7, r2, r3
        if (cursor >= myGFX->_height) {
   188f6:	b2bf      	uxth	r7, r7
   188f8:	42b7      	cmp	r7, r6
   188fa:	d31b      	bcc.n	18934 <GFXwrite+0x15c>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   188fc:	1e72      	subs	r2, r6, #1
            myGFX->cursor_x  = 0;
   188fe:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18900:	1ad3      	subs	r3, r2, r3
   18902:	46b4      	mov	ip, r6
            myGFX->cursor_x  = 0;
   18904:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
   18906:	b29a      	uxth	r2, r3
   18908:	8162      	strh	r2, [r4, #10]
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
   1890a:	8a67      	ldrh	r7, [r4, #18]
   1890c:	b2c0      	uxtb	r0, r0
   1890e:	8a26      	ldrh	r6, [r4, #16]
   18910:	460b      	mov	r3, r1
   18912:	9002      	str	r0, [sp, #8]
   18914:	b212      	sxth	r2, r2
   18916:	4620      	mov	r0, r4
   18918:	4661      	mov	r1, ip
   1891a:	e9cd 6700 	strd	r6, r7, [sp]
   1891e:	f7ff fd45 	bl	183ac <GFXdrawChar>
   18922:	89e0      	ldrh	r0, [r4, #14]
   18924:	e771      	b.n	1880a <GFXwrite+0x32>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   18926:	8ba5      	ldrh	r5, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
   18928:	81a3      	strh	r3, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
   1892a:	fb15 2200 	smlabb	r2, r5, r0, r2
   1892e:	b292      	uxth	r2, r2
   18930:	8162      	strh	r2, [r4, #10]
   18932:	e78b      	b.n	1884c <GFXwrite+0x74>
   18934:	f9b4 c00c 	ldrsh.w	ip, [r4, #12]
   18938:	e7e7      	b.n	1890a <GFXwrite+0x132>
   1893a:	bf00      	nop

0001893c <GFXsetCursor>:

void GFXsetCursor(GFX* myGFX, int16_t x, int16_t y) {
	myGFX->cursor_x = x;
   1893c:	8181      	strh	r1, [r0, #12]
	myGFX->cursor_y = y;
   1893e:	8142      	strh	r2, [r0, #10]
}
   18940:	4770      	bx	lr
   18942:	bf00      	nop

00018944 <GFXgetCursorX>:

int16_t GFXgetCursorX(GFX* myGFX)
{
    return myGFX->cursor_x;
}
   18944:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
   18948:	4770      	bx	lr
   1894a:	bf00      	nop

0001894c <GFXsetTextSize>:
{
    return myGFX->cursor_y;
}

void GFXsetTextSize(GFX* myGFX, uint8_t s) {
	myGFX->textsize = (s > 0) ? s : 1;
   1894c:	2900      	cmp	r1, #0
   1894e:	bf08      	it	eq
   18950:	2101      	moveq	r1, #1
   18952:	81c1      	strh	r1, [r0, #14]
}
   18954:	4770      	bx	lr
   18956:	bf00      	nop

00018958 <GFXsetTextColor>:

void GFXsetTextColor(GFX* myGFX, uint16_t c, uint16_t b) {
	myGFX->textcolor   = c;
   18958:	8201      	strh	r1, [r0, #16]
	myGFX->textbgcolor = b;
   1895a:	8242      	strh	r2, [r0, #18]
}
   1895c:	4770      	bx	lr
   1895e:	bf00      	nop

00018960 <GFXsetFont>:
// to this function to use correct CP437 character values in your code.
void GFXcp437(GFX* myGFX, uint8_t x) {
	myGFX->_cp437 = x;
}

void GFXsetFont(GFX* myGFX, const GFXfont *f) {
   18960:	6983      	ldr	r3, [r0, #24]

	if(f)
   18962:	b139      	cbz	r1, 18974 <GFXsetFont+0x14>
    {            // Font struct pointer passed in?
        if(!myGFX->gfxFont) { // And no current font struct?
   18964:	b10b      	cbz	r3, 1896a <GFXsetFont+0xa>
		}

		myGFX->fontHeight = 8;
		myGFX->fontDesc = 0;
	}
    myGFX->gfxFont = (GFXfont *)f;
   18966:	6181      	str	r1, [r0, #24]
}
   18968:	4770      	bx	lr
        	myGFX->cursor_y += 6;
   1896a:	8943      	ldrh	r3, [r0, #10]
    myGFX->gfxFont = (GFXfont *)f;
   1896c:	6181      	str	r1, [r0, #24]
        	myGFX->cursor_y += 6;
   1896e:	3306      	adds	r3, #6
   18970:	8143      	strh	r3, [r0, #10]
}
   18972:	4770      	bx	lr
	else if(myGFX->gfxFont)
   18974:	b113      	cbz	r3, 1897c <GFXsetFont+0x1c>
		myGFX->fontDesc = 0;
   18976:	83c1      	strh	r1, [r0, #30]
		uint8_t first  = (uint8_t) pgm_read_byte(&f->first);
   18978:	7a0b      	ldrb	r3, [r1, #8]
   1897a:	deff      	udf	#255	; 0xff
		myGFX->fontHeight = 8;
   1897c:	2308      	movs	r3, #8
   1897e:	61c3      	str	r3, [r0, #28]
   18980:	e7f1      	b.n	18966 <GFXsetFont+0x6>
   18982:	bf00      	nop

00018984 <OLEDparseInt>:
	'A', '#',
	'B', ' '
};

int OLEDparseInt(char* buffer, uint32_t myNumber, uint8_t numDigits)
{
   18984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int i = 0; i < numDigits; i++)
   18986:	4617      	mov	r7, r2
   18988:	b1ca      	cbz	r2, 189be <OLEDparseInt+0x3a>
   1898a:	460d      	mov	r5, r1
   1898c:	4606      	mov	r6, r0
   1898e:	1e54      	subs	r4, r2, #1
	{
		int whichPlace = (uint32_t)(powf(10.0f,(numDigits - 1) - i));
   18990:	ee07 4a90 	vmov	s15, r4
   18994:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   18998:	3c01      	subs	r4, #1
   1899a:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   1899e:	f014 fb27 	bl	2cff0 <powf>
   189a2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   189a6:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
   189aa:	fbb5 f2f3 	udiv	r2, r5, r3
		buffer[i] = thisDigit + 48;
   189ae:	f102 0130 	add.w	r1, r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
   189b2:	fb02 5513 	mls	r5, r2, r3, r5
	for (int i = 0; i < numDigits; i++)
   189b6:	1c63      	adds	r3, r4, #1
		buffer[i] = thisDigit + 48;
   189b8:	f806 1b01 	strb.w	r1, [r6], #1
	for (int i = 0; i < numDigits; i++)
   189bc:	d1e8      	bne.n	18990 <OLEDparseInt+0xc>
	}

	return numDigits;
}
   189be:	4638      	mov	r0, r7
   189c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   189c2:	bf00      	nop

000189c4 <OLEDparsePitch>:

int OLEDparsePitch(char* buffer, float midi, uint8_t showCents)
{
	int pclass, octave, note, neg = 0; float offset;

	note = (int)midi;
   189c4:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	offset = midi - note;

	if ((midi + 0.5f) > (note+1))
   189c8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	note = (int)midi;
   189cc:	ee17 3a10 	vmov	r3, s14
	offset = midi - note;
   189d0:	eef8 6ac7 	vcvt.f32.s32	s13, s14
	if ((midi + 0.5f) > (note+1))
   189d4:	ee70 7a27 	vadd.f32	s15, s0, s15
   189d8:	1c5a      	adds	r2, r3, #1
	offset = midi - note;
   189da:	ee30 0a66 	vsub.f32	s0, s0, s13
	if ((midi + 0.5f) > (note+1))
   189de:	ee07 2a10 	vmov	s14, r2
   189e2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
{
   189e6:	b470      	push	{r4, r5, r6}
	if ((midi + 0.5f) > (note+1))
   189e8:	eef4 7ac7 	vcmpe.f32	s15, s14
   189ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   189f0:	dd3a      	ble.n	18a68 <OLEDparsePitch+0xa4>
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
   189f2:	eddf 7a20 	vldr	s15, [pc, #128]	; 18a74 <OLEDparsePitch+0xb0>
		note += 1;
   189f6:	4613      	mov	r3, r2
		neg = 1;
   189f8:	2601      	movs	r6, #1
		offset = (1.0f - offset) + 0.01f;
   189fa:	ee37 0ac0 	vsub.f32	s0, s15, s0
	}

	pclass = (note % 12);
   189fe:	4d1e      	ldr	r5, [pc, #120]	; (18a78 <OLEDparsePitch+0xb4>)
   18a00:	17da      	asrs	r2, r3, #31
	octave = (int)(note / 12) - 1;

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
   18a02:	4c1e      	ldr	r4, [pc, #120]	; (18a7c <OLEDparsePitch+0xb8>)
	pclass = (note % 12);
   18a04:	fb85 c503 	smull	ip, r5, r5, r3
   18a08:	ebc2 0265 	rsb	r2, r2, r5, asr #1
   18a0c:	eb02 0542 	add.w	r5, r2, r2, lsl #1
		buffer[i] = thisDigit + 48;
   18a10:	322f      	adds	r2, #47	; 0x2f
	pclass = (note % 12);
   18a12:	eba3 0385 	sub.w	r3, r3, r5, lsl #2
	buffer[idx++] = pitches[pclass*2];
   18a16:	f814 5013 	ldrb.w	r5, [r4, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
   18a1a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
   18a1e:	7005      	strb	r5, [r0, #0]
	buffer[idx++] = pitches[pclass*2+1];
   18a20:	785b      	ldrb	r3, [r3, #1]
		buffer[i] = thisDigit + 48;
   18a22:	7082      	strb	r2, [r0, #2]
	buffer[idx++] = pitches[pclass*2+1];
   18a24:	7043      	strb	r3, [r0, #1]

	OLEDparseInt(&buffer[idx++], octave, 1);

	if (showCents)
   18a26:	b309      	cbz	r1, 18a6c <OLEDparsePitch+0xa8>
		if (neg == 1)
			buffer[idx++] = '-';
		else
			buffer[idx++] = '+';

		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   18a28:	eddf 7a15 	vldr	s15, [pc, #84]	; 18a80 <OLEDparsePitch+0xbc>
		if (neg == 1)
   18a2c:	2e01      	cmp	r6, #1
		int thisDigit = (myNumber / whichPlace);
   18a2e:	4a15      	ldr	r2, [pc, #84]	; (18a84 <OLEDparsePitch+0xc0>)
		buffer[idx++] = ' ';
   18a30:	f04f 0120 	mov.w	r1, #32
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   18a34:	ee20 0a27 	vmul.f32	s0, s0, s15
			buffer[idx++] = '+';
   18a38:	bf0c      	ite	eq
   18a3a:	232d      	moveq	r3, #45	; 0x2d
   18a3c:	232b      	movne	r3, #43	; 0x2b
		buffer[idx++] = ' ';
   18a3e:	70c1      	strb	r1, [r0, #3]
		idx += 2;
   18a40:	2107      	movs	r1, #7
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
   18a42:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   18a46:	7103      	strb	r3, [r0, #4]
   18a48:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
   18a4c:	fba2 4203 	umull	r4, r2, r2, r3
   18a50:	08d2      	lsrs	r2, r2, #3
		myNumber -= thisDigit * whichPlace;
   18a52:	eb02 0482 	add.w	r4, r2, r2, lsl #2
		buffer[i] = thisDigit + 48;
   18a56:	3230      	adds	r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
   18a58:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
		buffer[i] = thisDigit + 48;
   18a5c:	7142      	strb	r2, [r0, #5]
   18a5e:	3330      	adds	r3, #48	; 0x30
   18a60:	7183      	strb	r3, [r0, #6]
	}

	return idx;
}
   18a62:	4608      	mov	r0, r1
   18a64:	bc70      	pop	{r4, r5, r6}
   18a66:	4770      	bx	lr
	int pclass, octave, note, neg = 0; float offset;
   18a68:	2600      	movs	r6, #0
   18a6a:	e7c8      	b.n	189fe <OLEDparsePitch+0x3a>
	OLEDparseInt(&buffer[idx++], octave, 1);
   18a6c:	2103      	movs	r1, #3
}
   18a6e:	bc70      	pop	{r4, r5, r6}
   18a70:	4608      	mov	r0, r1
   18a72:	4770      	bx	lr
   18a74:	3f8147ae 	.word	0x3f8147ae
   18a78:	2aaaaaab 	.word	0x2aaaaaab
   18a7c:	000628b4 	.word	0x000628b4
   18a80:	42c80000 	.word	0x42c80000
   18a84:	cccccccd 	.word	0xcccccccd

00018a88 <OLEDparsePitchClass>:
int OLEDparsePitchClass(char* buffer, float midi)
{
	int pclass, note;
	float offset;

	note = (int)midi;
   18a88:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
	}

	pclass = (note % 12);
   18a8c:	4a13      	ldr	r2, [pc, #76]	; (18adc <OLEDparsePitchClass+0x54>)
	if ((midi + 0.5f) > (note+1))
   18a8e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
   18a92:	4913      	ldr	r1, [pc, #76]	; (18ae0 <OLEDparsePitchClass+0x58>)
	note = (int)midi;
   18a94:	ee17 3a10 	vmov	r3, s14
	if ((midi + 0.5f) > (note+1))
   18a98:	ee30 0a27 	vadd.f32	s0, s0, s15
{
   18a9c:	b430      	push	{r4, r5}
	if ((midi + 0.5f) > (note+1))
   18a9e:	1c5c      	adds	r4, r3, #1
{
   18aa0:	4605      	mov	r5, r0
	buffer[idx++] = pitches[pclass*2+1];

	return idx;
}
   18aa2:	2002      	movs	r0, #2
	if ((midi + 0.5f) > (note+1))
   18aa4:	ee07 4a90 	vmov	s15, r4
   18aa8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		note += 1;
   18aac:	eeb4 0a67 	vcmp.f32	s0, s15
   18ab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   18ab4:	bfc8      	it	gt
   18ab6:	4623      	movgt	r3, r4
	pclass = (note % 12);
   18ab8:	fb82 2403 	smull	r2, r4, r2, r3
   18abc:	17da      	asrs	r2, r3, #31
   18abe:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   18ac2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   18ac6:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
	buffer[idx++] = pitches[pclass*2];
   18aca:	f811 2013 	ldrb.w	r2, [r1, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
   18ace:	eb01 0343 	add.w	r3, r1, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
   18ad2:	702a      	strb	r2, [r5, #0]
	buffer[idx++] = pitches[pclass*2+1];
   18ad4:	785b      	ldrb	r3, [r3, #1]
   18ad6:	706b      	strb	r3, [r5, #1]
}
   18ad8:	bc30      	pop	{r4, r5}
   18ada:	4770      	bx	lr
   18adc:	2aaaaaab 	.word	0x2aaaaaab
   18ae0:	000628b4 	.word	0x000628b4

00018ae4 <OLEDparseFixedFloat>:

int OLEDparseFixedFloat(char* buffer, float input, uint8_t numDigits, uint8_t numDecimal)
{
	float power = powf(10.0f, numDecimal);
   18ae4:	ee07 2a90 	vmov	s15, r2
{
   18ae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18aec:	ed2d 8b02 	vpush	{d8}
   18af0:	b085      	sub	sp, #20
   18af2:	eeb0 8a40 	vmov.f32	s16, s0
	float power = powf(10.0f, numDecimal);
   18af6:	eef8 0a67 	vcvt.f32.u32	s1, s15
{
   18afa:	4680      	mov	r8, r0
	float power = powf(10.0f, numDecimal);
   18afc:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
{
   18b00:	9201      	str	r2, [sp, #4]
   18b02:	9102      	str	r1, [sp, #8]
	float power = powf(10.0f, numDecimal);
   18b04:	f014 fa74 	bl	2cff0 <powf>
	float f = ((float)(int)(input * power + 0.5f)) / power;
   18b08:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   18b0c:	eee0 7a08 	vfma.f32	s15, s0, s16
   18b10:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   18b14:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   18b18:	ee87 7a80 	vdiv.f32	s14, s15, s0

	int nonzeroHasHappened = 0, decimalHasHappened = 0;

	int myNumber = (int)(f * power);
   18b1c:	ee27 0a00 	vmul.f32	s0, s14, s0
   18b20:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   18b24:	ee17 5a90 	vmov	r5, s15

	int idx = 0, i = 0;

	if (myNumber < 0)
   18b28:	2d00      	cmp	r5, #0
   18b2a:	f2c0 8082 	blt.w	18c32 <OLEDparseFixedFloat+0x14e>
	int idx = 0, i = 0;
   18b2e:	2600      	movs	r6, #0
		myNumber *= -1;
		buffer[idx++] = '-';
		i++;
	}

	while (i < numDigits)
   18b30:	9b02      	ldr	r3, [sp, #8]
   18b32:	429e      	cmp	r6, r3
   18b34:	da3e      	bge.n	18bb4 <OLEDparseFixedFloat+0xd0>
   18b36:	2400      	movs	r4, #0
   18b38:	1b9f      	subs	r7, r3, r6
   18b3a:	9603      	str	r6, [sp, #12]
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
		{
			if (nonzeroHasHappened == 0)
			{
				idx++; //get past the negative if there is one - this is hacky should figure out how to do it right
				buffer[idx-1] = '0';
   18b3c:	46a9      	mov	r9, r5
			decimalHasHappened = 1;
		}
		else
		{

			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18b3e:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
	while (i < numDigits)
   18b42:	9400      	str	r4, [sp, #0]
				buffer[idx-1] = '0';
   18b44:	46a3      	mov	fp, r4
   18b46:	e00d      	b.n	18b64 <OLEDparseFixedFloat+0x80>
			int thisDigit = (myNumber / whichPlace);

			if (nonzeroHasHappened == 0)
			{
				if (thisDigit > 0)
   18b48:	2b00      	cmp	r3, #0
   18b4a:	dd63      	ble.n	18c14 <OLEDparseFixedFloat+0x130>
				{
					buffer[idx++] = thisDigit + 48;
   18b4c:	f103 0e30 	add.w	lr, r3, #48	; 0x30
   18b50:	462e      	mov	r6, r5
					nonzeroHasHappened = 1;
   18b52:	f04f 0b01 	mov.w	fp, #1
					buffer[idx++] = thisDigit + 48;
   18b56:	f88c e000 	strb.w	lr, [ip]
   18b5a:	3401      	adds	r4, #1
   18b5c:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
   18b60:	42bc      	cmp	r4, r7
   18b62:	d027      	beq.n	18bb4 <OLEDparseFixedFloat+0xd0>
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
   18b64:	9b00      	ldr	r3, [sp, #0]
   18b66:	1c75      	adds	r5, r6, #1
   18b68:	b91b      	cbnz	r3, 18b72 <OLEDparseFixedFloat+0x8e>
   18b6a:	1b3b      	subs	r3, r7, r4
   18b6c:	9a01      	ldr	r2, [sp, #4]
   18b6e:	429a      	cmp	r2, r3
   18b70:	d026      	beq.n	18bc0 <OLEDparseFixedFloat+0xdc>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18b72:	ebaa 0304 	sub.w	r3, sl, r4
   18b76:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   18b7a:	ee07 3a90 	vmov	s15, r3
   18b7e:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   18b82:	f014 fa35 	bl	2cff0 <powf>
   18b86:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   18b8a:	eb08 0c06 	add.w	ip, r8, r6
   18b8e:	ee17 2a90 	vmov	r2, s15
			int thisDigit = (myNumber / whichPlace);
   18b92:	fb99 f3f2 	sdiv	r3, r9, r2
			if (nonzeroHasHappened == 0)
   18b96:	f1bb 0f00 	cmp.w	fp, #0
   18b9a:	d0d5      	beq.n	18b48 <OLEDparseFixedFloat+0x64>
					buffer[idx++] = ' ';
				}
			}
			else
			{
				buffer[idx++] = thisDigit + 48;
   18b9c:	f103 0130 	add.w	r1, r3, #48	; 0x30
   18ba0:	462e      	mov	r6, r5
   18ba2:	f04f 0b01 	mov.w	fp, #1
   18ba6:	f88c 1000 	strb.w	r1, [ip]
   18baa:	3401      	adds	r4, #1
   18bac:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
   18bb0:	42bc      	cmp	r4, r7
   18bb2:	d1d7      	bne.n	18b64 <OLEDparseFixedFloat+0x80>
			i++;
		}
	}

	return idx;
}
   18bb4:	4630      	mov	r0, r6
   18bb6:	b005      	add	sp, #20
   18bb8:	ecbd 8b02 	vpop	{d8}
   18bbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (nonzeroHasHappened == 0)
   18bc0:	f1bb 0f00 	cmp.w	fp, #0
   18bc4:	d02c      	beq.n	18c20 <OLEDparseFixedFloat+0x13c>
   18bc6:	4632      	mov	r2, r6
	while (i < numDigits)
   18bc8:	9b03      	ldr	r3, [sp, #12]
			buffer[idx++] = '.';
   18bca:	f04f 012e 	mov.w	r1, #46	; 0x2e
	while (i < numDigits)
   18bce:	4423      	add	r3, r4
			buffer[idx++] = '.';
   18bd0:	f808 1002 	strb.w	r1, [r8, r2]
	while (i < numDigits)
   18bd4:	9a02      	ldr	r2, [sp, #8]
   18bd6:	4293      	cmp	r3, r2
   18bd8:	da31      	bge.n	18c3e <OLEDparseFixedFloat+0x15a>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18bda:	ebaa 0304 	sub.w	r3, sl, r4
			decimalHasHappened = 1;
   18bde:	2201      	movs	r2, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18be0:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
				buffer[idx++] = thisDigit + 48;
   18be4:	f04f 0b01 	mov.w	fp, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18be8:	ee07 3a90 	vmov	s15, r3
			decimalHasHappened = 1;
   18bec:	9200      	str	r2, [sp, #0]
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
   18bee:	eef8 0ae7 	vcvt.f32.s32	s1, s15
   18bf2:	f014 f9fd 	bl	2cff0 <powf>
   18bf6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   18bfa:	eb08 0c05 	add.w	ip, r8, r5
   18bfe:	3501      	adds	r5, #1
   18c00:	ee17 2a90 	vmov	r2, s15
				buffer[idx++] = thisDigit + 48;
   18c04:	462e      	mov	r6, r5
			int thisDigit = (myNumber / whichPlace);
   18c06:	fb99 f3f2 	sdiv	r3, r9, r2
				buffer[idx++] = thisDigit + 48;
   18c0a:	f103 0130 	add.w	r1, r3, #48	; 0x30
   18c0e:	f88c 1000 	strb.w	r1, [ip]
   18c12:	e7ca      	b.n	18baa <OLEDparseFixedFloat+0xc6>
					buffer[idx++] = ' ';
   18c14:	f04f 0120 	mov.w	r1, #32
   18c18:	462e      	mov	r6, r5
   18c1a:	f88c 1000 	strb.w	r1, [ip]
   18c1e:	e79c      	b.n	18b5a <OLEDparseFixedFloat+0x76>
				buffer[idx-1] = '0';
   18c20:	eb08 0305 	add.w	r3, r8, r5
   18c24:	f04f 0130 	mov.w	r1, #48	; 0x30
   18c28:	462a      	mov	r2, r5
   18c2a:	1cb5      	adds	r5, r6, #2
   18c2c:	f803 1c01 	strb.w	r1, [r3, #-1]
   18c30:	e7ca      	b.n	18bc8 <OLEDparseFixedFloat+0xe4>
		buffer[idx++] = '-';
   18c32:	232d      	movs	r3, #45	; 0x2d
		myNumber *= -1;
   18c34:	426d      	negs	r5, r5
		buffer[idx++] = '-';
   18c36:	2601      	movs	r6, #1
   18c38:	f888 3000 	strb.w	r3, [r8]
   18c3c:	e778      	b.n	18b30 <OLEDparseFixedFloat+0x4c>
			buffer[idx++] = '.';
   18c3e:	462e      	mov	r6, r5
}
   18c40:	4630      	mov	r0, r6
   18c42:	b005      	add	sp, #20
   18c44:	ecbd 8b02 	vpop	{d8}
   18c48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00018c4c <MX_GPIO_Init>:
     PA13 (JTMS/SWDIO)   ------> DEBUG_JTMS-SWDIO
     PA14 (JTCK/SWCLK)   ------> DEBUG_JTCK-SWCLK
     PB3 (JTDO/TRACESWO)   ------> DEBUG_JTDO-SWO
*/
void MX_GPIO_Init(void)
{
   18c4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
   18c50:	4b8d      	ldr	r3, [pc, #564]	; (18e88 <MX_GPIO_Init+0x23c>)
{
   18c52:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c54:	2400      	movs	r4, #0
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PC14 PC4 PC6 PC7 */
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   18c56:	2501      	movs	r5, #1
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18c58:	f8df 8238 	ldr.w	r8, [pc, #568]	; 18e94 <MX_GPIO_Init+0x248>
   18c5c:	f244 01d0 	movw	r1, #16592	; 0x40d0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c60:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18c62:	4622      	mov	r2, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c64:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18c66:	4640      	mov	r0, r8
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c68:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   18c6a:	f8df a22c 	ldr.w	sl, [pc, #556]	; 18e98 <MX_GPIO_Init+0x24c>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18c6e:	f8df 922c 	ldr.w	r9, [pc, #556]	; 18e9c <MX_GPIO_Init+0x250>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   18c72:	f8df b22c 	ldr.w	fp, [pc, #556]	; 18ea0 <MX_GPIO_Init+0x254>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18c76:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  __HAL_RCC_GPIOE_CLK_ENABLE();
   18c7a:	f8d3 60e0 	ldr.w	r6, [r3, #224]	; 0xe0
   18c7e:	f046 0610 	orr.w	r6, r6, #16
   18c82:	f8c3 60e0 	str.w	r6, [r3, #224]	; 0xe0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pins : PF7 PF8 PF9 PF10 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   18c86:	2603      	movs	r6, #3
  __HAL_RCC_GPIOE_CLK_ENABLE();
   18c88:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18c8c:	f007 0710 	and.w	r7, r7, #16
   18c90:	9701      	str	r7, [sp, #4]
   18c92:	9f01      	ldr	r7, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
   18c94:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18c98:	f047 0704 	orr.w	r7, r7, #4
   18c9c:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18ca0:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18ca4:	f007 0704 	and.w	r7, r7, #4
   18ca8:	9702      	str	r7, [sp, #8]
   18caa:	9f02      	ldr	r7, [sp, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
   18cac:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cb0:	f047 0720 	orr.w	r7, r7, #32
   18cb4:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18cb8:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cbc:	f007 0720 	and.w	r7, r7, #32
   18cc0:	9703      	str	r7, [sp, #12]
   18cc2:	9f03      	ldr	r7, [sp, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
   18cc4:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cc8:	f047 0780 	orr.w	r7, r7, #128	; 0x80
   18ccc:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18cd0:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cd4:	f007 0780 	and.w	r7, r7, #128	; 0x80
   18cd8:	9704      	str	r7, [sp, #16]
   18cda:	9f04      	ldr	r7, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
   18cdc:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18ce0:	432f      	orrs	r7, r5
   18ce2:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18ce6:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cea:	402f      	ands	r7, r5
   18cec:	9705      	str	r7, [sp, #20]
   18cee:	9f05      	ldr	r7, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
   18cf0:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18cf4:	f047 0702 	orr.w	r7, r7, #2
   18cf8:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18cfc:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d00:	f007 0702 	and.w	r7, r7, #2
   18d04:	9706      	str	r7, [sp, #24]
   18d06:	9f06      	ldr	r7, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
   18d08:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d0c:	f047 0740 	orr.w	r7, r7, #64	; 0x40
   18d10:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18d14:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d18:	f007 0740 	and.w	r7, r7, #64	; 0x40
   18d1c:	9707      	str	r7, [sp, #28]
   18d1e:	9f07      	ldr	r7, [sp, #28]
  __HAL_RCC_GPIOD_CLK_ENABLE();
   18d20:	f8d3 70e0 	ldr.w	r7, [r3, #224]	; 0xe0
   18d24:	f047 0708 	orr.w	r7, r7, #8
   18d28:	f8c3 70e0 	str.w	r7, [r3, #224]	; 0xe0
   18d2c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   18d30:	4f56      	ldr	r7, [pc, #344]	; (18e8c <MX_GPIO_Init+0x240>)
  __HAL_RCC_GPIOD_CLK_ENABLE();
   18d32:	f003 0308 	and.w	r3, r3, #8
   18d36:	9308      	str	r3, [sp, #32]
   18d38:	9b08      	ldr	r3, [sp, #32]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
   18d3a:	f7f3 fa7b 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
   18d3e:	4622      	mov	r2, r4
   18d40:	4650      	mov	r0, sl
   18d42:	2140      	movs	r1, #64	; 0x40
   18d44:	f7f3 fa76 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18d48:	4622      	mov	r2, r4
   18d4a:	4648      	mov	r0, r9
   18d4c:	f44f 61ea 	mov.w	r1, #1872	; 0x750
   18d50:	f7f3 fa70 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
   18d54:	4622      	mov	r2, r4
   18d56:	4658      	mov	r0, fp
   18d58:	2111      	movs	r1, #17
   18d5a:	f7f3 fa6b 	bl	c234 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
   18d5e:	4622      	mov	r2, r4
   18d60:	4638      	mov	r0, r7
   18d62:	f44f 6198 	mov.w	r1, #1216	; 0x4c0
   18d66:	f7f3 fa65 	bl	c234 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13;
   18d6a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d6e:	a909      	add	r1, sp, #36	; 0x24
   18d70:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = GPIO_PIN_13;
   18d72:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18d74:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d78:	f7f2 ff22 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
   18d7c:	f244 03d0 	movw	r3, #16592	; 0x40d0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d80:	a909      	add	r1, sp, #36	; 0x24
   18d82:	4640      	mov	r0, r8
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   18d84:	e9cd 3509 	strd	r3, r5, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18d88:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d8c:	f7f2 ff18 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_15;
   18d90:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   18d94:	4b3e      	ldr	r3, [pc, #248]	; (18e90 <MX_GPIO_Init+0x244>)
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18d96:	4640      	mov	r0, r8
   18d98:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18d9a:	940b      	str	r4, [sp, #44]	; 0x2c

  /*Configure GPIO pins : PD11 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18d9c:	f508 6880 	add.w	r8, r8, #1024	; 0x400
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   18da0:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   18da4:	f7f2 ff0c 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_6;
   18da8:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18daa:	a909      	add	r1, sp, #36	; 0x24
   18dac:	4650      	mov	r0, sl
  GPIO_InitStruct.Pin = GPIO_PIN_6;
   18dae:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18db0:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18db2:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18db6:	f7f2 ff03 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
   18dba:	f44f 63f0 	mov.w	r3, #1920	; 0x780
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18dbe:	4650      	mov	r0, sl
   18dc0:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dc2:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
   18dc4:	e9cd 3609 	strd	r3, r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   18dc8:	f7f2 fefa 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
   18dcc:	f248 0302 	movw	r3, #32770	; 0x8002
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18dd0:	a909      	add	r1, sp, #36	; 0x24
   18dd2:	4648      	mov	r0, r9
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
   18dd4:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dd6:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18dda:	f7f2 fef1 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18dde:	f44f 63ea 	mov.w	r3, #1872	; 0x750
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18de2:	4648      	mov	r0, r9
   18de4:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
   18de6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18de8:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dea:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   18dee:	f7f2 fee7 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
   18df2:	2311      	movs	r3, #17
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18df4:	a909      	add	r1, sp, #36	; 0x24
   18df6:	4658      	mov	r0, fp
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
   18df8:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18dfa:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18dfc:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e00:	f7f2 fede 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
   18e04:	f24f 0302 	movw	r3, #61442	; 0xf002
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e08:	a909      	add	r1, sp, #36	; 0x24
   18e0a:	4658      	mov	r0, fp
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
   18e0c:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   18e0e:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e12:	f7f2 fed5 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
   18e16:	f44f 7301 	mov.w	r3, #516	; 0x204
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e1a:	4658      	mov	r0, fp
   18e1c:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
   18e1e:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e20:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   18e24:	f7f2 fecc 	bl	bbc0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
   18e28:	f44f 6308 	mov.w	r3, #2176	; 0x880
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e2c:	a909      	add	r1, sp, #36	; 0x24
   18e2e:	4640      	mov	r0, r8
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
   18e30:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   18e32:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e36:	f7f2 fec3 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG3 PG9 PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
   18e3a:	f246 2308 	movw	r3, #25096	; 0x6208
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e3e:	a909      	add	r1, sp, #36	; 0x24
   18e40:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
   18e42:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e44:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e48:	f7f2 feba 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG7 PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
   18e4c:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e50:	a909      	add	r1, sp, #36	; 0x24
   18e52:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
   18e54:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   18e56:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e58:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e5c:	f7f2 feb0 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD3 PD4 PD5 PD6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   18e60:	2378      	movs	r3, #120	; 0x78
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e62:	4640      	mov	r0, r8
   18e64:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
   18e66:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
   18e68:	e9cd 640a 	strd	r6, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18e6c:	f7f2 fea8 	bl	bbc0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG11 PG12 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   18e70:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e74:	a909      	add	r1, sp, #36	; 0x24
   18e76:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   18e78:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
   18e7a:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   18e7e:	f7f2 fe9f 	bl	bbc0 <HAL_GPIO_Init>

}
   18e82:	b00f      	add	sp, #60	; 0x3c
   18e84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18e88:	58024400 	.word	0x58024400
   18e8c:	58021800 	.word	0x58021800
   18e90:	11110000 	.word	0x11110000
   18e94:	58020800 	.word	0x58020800
   18e98:	58021400 	.word	0x58021400
   18e9c:	58020000 	.word	0x58020000
   18ea0:	58020400 	.word	0x58020400

00018ea4 <MX_I2C2_Init>:
DMA_HandleTypeDef hdma_i2c4_rx;
DMA_HandleTypeDef hdma_i2c4_tx;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
   18ea4:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
   18ea6:	4b13      	ldr	r3, [pc, #76]	; (18ef4 <MX_I2C2_Init+0x50>)
  hi2c2.Init.Timing = 0x505097F4;
  hi2c2.Init.OwnAddress1 = 0;
   18ea8:	2200      	movs	r2, #0
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   18eaa:	2101      	movs	r1, #1
  hi2c2.Instance = I2C2;
   18eac:	4d12      	ldr	r5, [pc, #72]	; (18ef8 <MX_I2C2_Init+0x54>)
  hi2c2.Init.Timing = 0x505097F4;
   18eae:	4c13      	ldr	r4, [pc, #76]	; (18efc <MX_I2C2_Init+0x58>)
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
   18eb0:	4618      	mov	r0, r3
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   18eb2:	621a      	str	r2, [r3, #32]
  hi2c2.Init.Timing = 0x505097F4;
   18eb4:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c2.Init.OwnAddress1 = 0;
   18eb8:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c2.Init.OwnAddress2 = 0;
   18ebc:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   18ec0:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
   18ec4:	f7f3 fbea 	bl	c69c <HAL_I2C_Init>
   18ec8:	b988      	cbnz	r0, 18eee <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
   18eca:	2100      	movs	r1, #0
   18ecc:	4809      	ldr	r0, [pc, #36]	; (18ef4 <MX_I2C2_Init+0x50>)
   18ece:	f7f4 fffd 	bl	decc <HAL_I2CEx_ConfigAnalogFilter>
   18ed2:	b948      	cbnz	r0, 18ee8 <MX_I2C2_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
   18ed4:	2100      	movs	r1, #0
   18ed6:	4807      	ldr	r0, [pc, #28]	; (18ef4 <MX_I2C2_Init+0x50>)
   18ed8:	f7f5 f850 	bl	df7c <HAL_I2CEx_ConfigDigitalFilter>
   18edc:	b900      	cbnz	r0, 18ee0 <MX_I2C2_Init+0x3c>
  {
    Error_Handler();
  }

}
   18ede:	bd38      	pop	{r3, r4, r5, pc}
   18ee0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
   18ee4:	f000 baea 	b.w	194bc <Error_Handler>
    Error_Handler();
   18ee8:	f000 fae8 	bl	194bc <Error_Handler>
   18eec:	e7f2      	b.n	18ed4 <MX_I2C2_Init+0x30>
    Error_Handler();
   18eee:	f000 fae5 	bl	194bc <Error_Handler>
   18ef2:	e7ea      	b.n	18eca <MX_I2C2_Init+0x26>
   18ef4:	020f7c98 	.word	0x020f7c98
   18ef8:	40005800 	.word	0x40005800
   18efc:	505097f4 	.word	0x505097f4

00018f00 <MX_I2C4_Init>:
/* I2C4 init function */
void MX_I2C4_Init(void)
{
   18f00:	b538      	push	{r3, r4, r5, lr}

  hi2c4.Instance = I2C4;
   18f02:	4b13      	ldr	r3, [pc, #76]	; (18f50 <MX_I2C4_Init+0x50>)
  hi2c4.Init.Timing = 0x307075B1;
  hi2c4.Init.OwnAddress1 = 0;
   18f04:	2200      	movs	r2, #0
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   18f06:	2101      	movs	r1, #1
  hi2c4.Instance = I2C4;
   18f08:	4d12      	ldr	r5, [pc, #72]	; (18f54 <MX_I2C4_Init+0x54>)
  hi2c4.Init.Timing = 0x307075B1;
   18f0a:	4c13      	ldr	r4, [pc, #76]	; (18f58 <MX_I2C4_Init+0x58>)
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   18f0c:	4618      	mov	r0, r3
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   18f0e:	621a      	str	r2, [r3, #32]
  hi2c4.Init.Timing = 0x307075B1;
   18f10:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c4.Init.OwnAddress1 = 0;
   18f14:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c4.Init.OwnAddress2 = 0;
   18f18:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   18f1c:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   18f20:	f7f3 fbbc 	bl	c69c <HAL_I2C_Init>
   18f24:	b988      	cbnz	r0, 18f4a <MX_I2C4_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
   18f26:	2100      	movs	r1, #0
   18f28:	4809      	ldr	r0, [pc, #36]	; (18f50 <MX_I2C4_Init+0x50>)
   18f2a:	f7f4 ffcf 	bl	decc <HAL_I2CEx_ConfigAnalogFilter>
   18f2e:	b948      	cbnz	r0, 18f44 <MX_I2C4_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
   18f30:	2100      	movs	r1, #0
   18f32:	4807      	ldr	r0, [pc, #28]	; (18f50 <MX_I2C4_Init+0x50>)
   18f34:	f7f5 f822 	bl	df7c <HAL_I2CEx_ConfigDigitalFilter>
   18f38:	b900      	cbnz	r0, 18f3c <MX_I2C4_Init+0x3c>
  {
    Error_Handler();
  }

}
   18f3a:	bd38      	pop	{r3, r4, r5, pc}
   18f3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
   18f40:	f000 babc 	b.w	194bc <Error_Handler>
    Error_Handler();
   18f44:	f000 faba 	bl	194bc <Error_Handler>
   18f48:	e7f2      	b.n	18f30 <MX_I2C4_Init+0x30>
    Error_Handler();
   18f4a:	f000 fab7 	bl	194bc <Error_Handler>
   18f4e:	e7ea      	b.n	18f26 <MX_I2C4_Init+0x26>
   18f50:	020f7c4c 	.word	0x020f7c4c
   18f54:	58001c00 	.word	0x58001c00
   18f58:	307075b1 	.word	0x307075b1

00018f5c <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
   18f5c:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance==I2C2)
   18f5e:	4a50      	ldr	r2, [pc, #320]	; (190a0 <HAL_I2C_MspInit+0x144>)
{
   18f60:	b08b      	sub	sp, #44	; 0x2c
  if(i2cHandle->Instance==I2C2)
   18f62:	6803      	ldr	r3, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18f64:	2400      	movs	r4, #0
  if(i2cHandle->Instance==I2C2)
   18f66:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   18f68:	9409      	str	r4, [sp, #36]	; 0x24
   18f6a:	e9cd 4405 	strd	r4, r4, [sp, #20]
   18f6e:	e9cd 4407 	strd	r4, r4, [sp, #28]
  if(i2cHandle->Instance==I2C2)
   18f72:	d069      	beq.n	19048 <HAL_I2C_MspInit+0xec>
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
   18f74:	4a4b      	ldr	r2, [pc, #300]	; (190a4 <HAL_I2C_MspInit+0x148>)
   18f76:	4293      	cmp	r3, r2
   18f78:	d001      	beq.n	18f7e <HAL_I2C_MspInit+0x22>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
  }
}
   18f7a:	b00b      	add	sp, #44	; 0x2c
   18f7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18f7e:	4f4a      	ldr	r7, [pc, #296]	; (190a8 <HAL_I2C_MspInit+0x14c>)
   18f80:	4605      	mov	r5, r0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
   18f82:	f44f 5040 	mov.w	r0, #12288	; 0x3000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   18f86:	2212      	movs	r2, #18
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18f88:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18f8c:	a905      	add	r1, sp, #20
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   18f8e:	4e47      	ldr	r6, [pc, #284]	; (190ac <HAL_I2C_MspInit+0x150>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18f90:	f043 0308 	orr.w	r3, r3, #8
   18f94:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
   18f98:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
   18f9c:	9005      	str	r0, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   18f9e:	2001      	movs	r0, #1
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18fa0:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   18fa4:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
   18fa6:	2204      	movs	r2, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   18fa8:	9008      	str	r0, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18faa:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18fac:	4840      	ldr	r0, [pc, #256]	; (190b0 <HAL_I2C_MspInit+0x154>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
   18fae:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
   18fb0:	9209      	str	r2, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   18fb2:	f7f2 fe05 	bl	bbc0 <HAL_GPIO_Init>
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fb6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
   18fba:	210d      	movs	r1, #13
    hdma_i2c4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   18fbc:	60b4      	str	r4, [r6, #8]
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
   18fbe:	f44f 6280 	mov.w	r2, #1024	; 0x400
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fc2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
   18fc6:	4630      	mov	r0, r6
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fc8:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
   18fcc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   18fd0:	60f4      	str	r4, [r6, #12]
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fd2:	f003 0380 	and.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
   18fd6:	6132      	str	r2, [r6, #16]
    __HAL_RCC_I2C4_CLK_ENABLE();
   18fd8:	9304      	str	r3, [sp, #16]
   18fda:	9b04      	ldr	r3, [sp, #16]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   18fdc:	4b35      	ldr	r3, [pc, #212]	; (190b4 <HAL_I2C_MspInit+0x158>)
    hdma_i2c4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   18fde:	e9c6 4405 	strd	r4, r4, [r6, #20]
    hdma_i2c4_rx.Init.Priority = DMA_PRIORITY_LOW;
   18fe2:	e9c6 4407 	strd	r4, r4, [r6, #28]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
   18fe6:	e9c6 3100 	strd	r3, r1, [r6]
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
   18fea:	f7f0 febf 	bl	9d6c <HAL_DMA_Init>
   18fee:	2800      	cmp	r0, #0
   18ff0:	d153      	bne.n	1909a <HAL_I2C_MspInit+0x13e>
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   18ff2:	4c31      	ldr	r4, [pc, #196]	; (190b8 <HAL_I2C_MspInit+0x15c>)
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   18ff4:	2300      	movs	r3, #0
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   18ff6:	4831      	ldr	r0, [pc, #196]	; (190bc <HAL_I2C_MspInit+0x160>)
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
   18ff8:	270e      	movs	r7, #14
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   18ffa:	2140      	movs	r1, #64	; 0x40
    hdma_i2c4_tx.Init.MemInc = DMA_MINC_ENABLE;
   18ffc:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_i2c4_tx.Instance = BDMA_Channel1;
   19000:	6020      	str	r0, [r4, #0]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
   19002:	4620      	mov	r0, r4
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
   19004:	63ee      	str	r6, [r5, #60]	; 0x3c
   19006:	63b5      	str	r5, [r6, #56]	; 0x38
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   19008:	e9c4 7101 	strd	r7, r1, [r4, #4]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   1900c:	e9c4 3203 	strd	r3, r2, [r4, #12]
    hdma_i2c4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   19010:	e9c4 3305 	strd	r3, r3, [r4, #20]
    hdma_i2c4_tx.Init.Priority = DMA_PRIORITY_LOW;
   19014:	e9c4 3307 	strd	r3, r3, [r4, #28]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
   19018:	f7f0 fea8 	bl	9d6c <HAL_DMA_Init>
   1901c:	2800      	cmp	r0, #0
   1901e:	d139      	bne.n	19094 <HAL_I2C_MspInit+0x138>
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
   19020:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
   19022:	2200      	movs	r2, #0
   19024:	2107      	movs	r1, #7
   19026:	205f      	movs	r0, #95	; 0x5f
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
   19028:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
   1902a:	f7f0 fcd3 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_EV_IRQn);
   1902e:	205f      	movs	r0, #95	; 0x5f
   19030:	f7f0 fd16 	bl	9a60 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C4_ER_IRQn, 7, 0);
   19034:	2200      	movs	r2, #0
   19036:	2107      	movs	r1, #7
   19038:	2060      	movs	r0, #96	; 0x60
   1903a:	f7f0 fccb 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
   1903e:	2060      	movs	r0, #96	; 0x60
   19040:	f7f0 fd0e 	bl	9a60 <HAL_NVIC_EnableIRQ>
}
   19044:	b00b      	add	sp, #44	; 0x2c
   19046:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19048:	4c17      	ldr	r4, [pc, #92]	; (190a8 <HAL_I2C_MspInit+0x14c>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
   1904a:	2204      	movs	r2, #4
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   1904c:	f44f 6640 	mov.w	r6, #3072	; 0xc00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   19050:	2512      	movs	r5, #18
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19052:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   19056:	a905      	add	r1, sp, #20
   19058:	4819      	ldr	r0, [pc, #100]	; (190c0 <HAL_I2C_MspInit+0x164>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   1905a:	f043 0302 	orr.w	r3, r3, #2
   1905e:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
   19062:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
   19066:	9605      	str	r6, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19068:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
   1906c:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
   1906e:	9209      	str	r2, [sp, #36]	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   19070:	9301      	str	r3, [sp, #4]
   19072:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   19074:	f7f2 fda4 	bl	bbc0 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
   19078:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   1907c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   19080:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
   19084:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   19088:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1908c:	9302      	str	r3, [sp, #8]
   1908e:	9b02      	ldr	r3, [sp, #8]
}
   19090:	b00b      	add	sp, #44	; 0x2c
   19092:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
   19094:	f000 fa12 	bl	194bc <Error_Handler>
   19098:	e7c2      	b.n	19020 <HAL_I2C_MspInit+0xc4>
      Error_Handler();
   1909a:	f000 fa0f 	bl	194bc <Error_Handler>
   1909e:	e7a8      	b.n	18ff2 <HAL_I2C_MspInit+0x96>
   190a0:	40005800 	.word	0x40005800
   190a4:	58001c00 	.word	0x58001c00
   190a8:	58024400 	.word	0x58024400
   190ac:	020f7ce4 	.word	0x020f7ce4
   190b0:	58020c00 	.word	0x58020c00
   190b4:	58025408 	.word	0x58025408
   190b8:	020f7bd4 	.word	0x020f7bd4
   190bc:	5802541c 	.word	0x5802541c
   190c0:	58020400 	.word	0x58020400

000190c4 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C2)
   190c4:	4a18      	ldr	r2, [pc, #96]	; (19128 <HAL_I2C_MspDeInit+0x64>)
   190c6:	6803      	ldr	r3, [r0, #0]
   190c8:	4293      	cmp	r3, r2
   190ca:	d020      	beq.n	1910e <HAL_I2C_MspDeInit+0x4a>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
   190cc:	4a17      	ldr	r2, [pc, #92]	; (1912c <HAL_I2C_MspDeInit+0x68>)
   190ce:	4293      	cmp	r3, r2
   190d0:	d000      	beq.n	190d4 <HAL_I2C_MspDeInit+0x10>
   190d2:	4770      	bx	lr
  {
  /* USER CODE BEGIN I2C4_MspDeInit 0 */

  /* USER CODE END I2C4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C4_CLK_DISABLE();
   190d4:	f502 320a 	add.w	r2, r2, #141312	; 0x22800
  
    /**I2C4 GPIO Configuration    
    PD12     ------> I2C4_SCL
    PD13     ------> I2C4_SDA 
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   190d8:	f44f 5140 	mov.w	r1, #12288	; 0x3000
{
   190dc:	b510      	push	{r4, lr}
    __HAL_RCC_I2C4_CLK_DISABLE();
   190de:	f8d2 30f4 	ldr.w	r3, [r2, #244]	; 0xf4
   190e2:	4604      	mov	r4, r0
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   190e4:	4812      	ldr	r0, [pc, #72]	; (19130 <HAL_I2C_MspDeInit+0x6c>)
    __HAL_RCC_I2C4_CLK_DISABLE();
   190e6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   190ea:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
   190ee:	f7f2 ff71 	bl	bfd4 <HAL_GPIO_DeInit>

    /* I2C4 DMA DeInit */
    HAL_DMA_DeInit(i2cHandle->hdmarx);
   190f2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   190f4:	f7f1 fa6a 	bl	a5cc <HAL_DMA_DeInit>
    HAL_DMA_DeInit(i2cHandle->hdmatx);
   190f8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   190fa:	f7f1 fa67 	bl	a5cc <HAL_DMA_DeInit>

    /* I2C4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C4_EV_IRQn);
   190fe:	205f      	movs	r0, #95	; 0x5f
   19100:	f7f0 fcc2 	bl	9a88 <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
   19104:	2060      	movs	r0, #96	; 0x60
  /* USER CODE BEGIN I2C4_MspDeInit 1 */

  /* USER CODE END I2C4_MspDeInit 1 */
  }
} 
   19106:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
   1910a:	f7f0 bcbd 	b.w	9a88 <HAL_NVIC_DisableIRQ>
    __HAL_RCC_I2C2_CLK_DISABLE();
   1910e:	4a09      	ldr	r2, [pc, #36]	; (19134 <HAL_I2C_MspDeInit+0x70>)
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   19110:	f44f 6140 	mov.w	r1, #3072	; 0xc00
   19114:	4808      	ldr	r0, [pc, #32]	; (19138 <HAL_I2C_MspDeInit+0x74>)
    __HAL_RCC_I2C2_CLK_DISABLE();
   19116:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
   1911a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1911e:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
   19122:	f7f2 bf57 	b.w	bfd4 <HAL_GPIO_DeInit>
   19126:	bf00      	nop
   19128:	40005800 	.word	0x40005800
   1912c:	58001c00 	.word	0x58001c00
   19130:	58020c00 	.word	0x58020c00
   19134:	58024400 	.word	0x58024400
   19138:	58020400 	.word	0x58020400

0001913c <SCB_EnableDCache>:
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
   1913c:	4816      	ldr	r0, [pc, #88]	; (19198 <SCB_EnableDCache+0x5c>)
   1913e:	2300      	movs	r3, #0
{
   19140:	b4f0      	push	{r4, r5, r6, r7}
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
   19142:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
   19146:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
   1914a:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1914e:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
   19152:	f3c5 06c9 	ubfx	r6, r5, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
   19156:	f3c5 354e 	ubfx	r5, r5, #13, #15
   1915a:	07b7      	lsls	r7, r6, #30
   1915c:	016d      	lsls	r5, r5, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1915e:	ea05 040c 	and.w	r4, r5, ip
   19162:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
   19164:	4632      	mov	r2, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   19166:	ea44 0301 	orr.w	r3, r4, r1
      } while (ways-- != 0U);
   1916a:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
   1916c:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
   19170:	f8c0 3260 	str.w	r3, [r0, #608]	; 0x260
      } while (ways-- != 0U);
   19174:	1c53      	adds	r3, r2, #1
   19176:	d1f6      	bne.n	19166 <SCB_EnableDCache+0x2a>
   19178:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
   1917a:	f115 0f20 	cmn.w	r5, #32
   1917e:	d1ee      	bne.n	1915e <SCB_EnableDCache+0x22>
   19180:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
   19184:	6943      	ldr	r3, [r0, #20]
   19186:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1918a:	6143      	str	r3, [r0, #20]
   1918c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   19190:	f3bf 8f6f 	isb	sy
}
   19194:	bcf0      	pop	{r4, r5, r6, r7}
   19196:	4770      	bx	lr
   19198:	e000ed00 	.word	0xe000ed00

0001919c <SystemClock_Config>:
{
   1919c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   191a0:	b0cc      	sub	sp, #304	; 0x130
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
   191a2:	224c      	movs	r2, #76	; 0x4c
   191a4:	2100      	movs	r1, #0
   191a6:	a80a      	add	r0, sp, #40	; 0x28
   191a8:	f013 fc4b 	bl	2ca42 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
   191ac:	2220      	movs	r2, #32
   191ae:	2100      	movs	r1, #0
   191b0:	a802      	add	r0, sp, #8
   191b2:	f013 fc46 	bl	2ca42 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
   191b6:	22bc      	movs	r2, #188	; 0xbc
   191b8:	2100      	movs	r1, #0
   191ba:	a81d      	add	r0, sp, #116	; 0x74
   191bc:	f013 fc41 	bl	2ca42 <memset>
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
   191c0:	2002      	movs	r0, #2
   191c2:	f7f4 ff31 	bl	e028 <HAL_PWREx_ConfigSupply>
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   191c6:	4b3f      	ldr	r3, [pc, #252]	; (192c4 <SystemClock_Config+0x128>)
   191c8:	2100      	movs	r1, #0
   191ca:	4a3f      	ldr	r2, [pc, #252]	; (192c8 <SystemClock_Config+0x12c>)
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   191cc:	4618      	mov	r0, r3
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   191ce:	9101      	str	r1, [sp, #4]
   191d0:	6999      	ldr	r1, [r3, #24]
   191d2:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
   191d6:	6199      	str	r1, [r3, #24]
   191d8:	699b      	ldr	r3, [r3, #24]
   191da:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
   191de:	9301      	str	r3, [sp, #4]
   191e0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   191e2:	f043 0301 	orr.w	r3, r3, #1
   191e6:	62d3      	str	r3, [r2, #44]	; 0x2c
   191e8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   191ea:	f003 0301 	and.w	r3, r3, #1
   191ee:	9301      	str	r3, [sp, #4]
   191f0:	9b01      	ldr	r3, [sp, #4]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   191f2:	6983      	ldr	r3, [r0, #24]
   191f4:	049b      	lsls	r3, r3, #18
   191f6:	d5fc      	bpl.n	191f2 <SystemClock_Config+0x56>
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   191f8:	4a34      	ldr	r2, [pc, #208]	; (192cc <SystemClock_Config+0x130>)
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   191fa:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   191fc:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
   19200:	f04f 0c21 	mov.w	ip, #33	; 0x21
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   19204:	6a93      	ldr	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
   19206:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLM = 10;
   19208:	210a      	movs	r1, #10
  RCC_OscInitStruct.PLL.PLLN = 384;
   1920a:	f44f 76c0 	mov.w	r6, #384	; 0x180
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   1920e:	f023 0303 	bic.w	r3, r3, #3
  RCC_OscInitStruct.PLL.PLLQ = 3;
   19212:	2703      	movs	r7, #3
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
   19214:	f04f 0804 	mov.w	r8, #4
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   19218:	4323      	orrs	r3, r4
   1921a:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   1921c:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   1921e:	900b      	str	r0, [sp, #44]	; 0x2c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   19220:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
   19222:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
   19226:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = 2;
   19228:	9417      	str	r4, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
   1922a:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 3;
   1922c:	9718      	str	r7, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
   1922e:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   19230:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLN = 384;
   19234:	e9cd 1615 	strd	r1, r6, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   19238:	e9cd 831a 	strd	r8, r3, [sp, #104]	; 0x68
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   1923c:	f7f4 ff34 	bl	e0a8 <HAL_RCC_OscConfig>
   19240:	b100      	cbz	r0, 19244 <SystemClock_Config+0xa8>
   19242:	e7fe      	b.n	19242 <SystemClock_Config+0xa6>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   19244:	223f      	movs	r2, #63	; 0x3f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   19246:	9703      	str	r7, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   19248:	2708      	movs	r7, #8
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
   1924a:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
   1924c:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
   1924e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
   19252:	9004      	str	r0, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
   19254:	4641      	mov	r1, r8
   19256:	eb0d 0007 	add.w	r0, sp, r7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   1925a:	9705      	str	r7, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
   1925c:	e9cd 3306 	strd	r3, r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
   19260:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
   19264:	f7f5 fb46 	bl	e8f4 <HAL_RCC_ClockConfig>
   19268:	4603      	mov	r3, r0
   1926a:	b100      	cbz	r0, 1926e <SystemClock_Config+0xd2>
   1926c:	e7fe      	b.n	1926c <SystemClock_Config+0xd0>
  PeriphClkInitStruct.PLL2.PLL2M = 25;
   1926e:	2219      	movs	r2, #25
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
   19270:	f8df e05c 	ldr.w	lr, [pc, #92]	; 192d0 <SystemClock_Config+0x134>
  PeriphClkInitStruct.PLL2.PLL2N = 344;
   19274:	f44f 7cac 	mov.w	ip, #344	; 0x158
  PeriphClkInitStruct.PLL3.PLL3N = 384;
   19278:	9627      	str	r6, [sp, #156]	; 0x9c
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
   1927a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  PeriphClkInitStruct.PLL2.PLL2P = 7;
   1927e:	2607      	movs	r6, #7
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   19280:	a81d      	add	r0, sp, #116	; 0x74
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
   19282:	9421      	str	r4, [sp, #132]	; 0x84
  PeriphClkInitStruct.PLL2.PLL2R = 1;
   19284:	9522      	str	r5, [sp, #136]	; 0x88
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
   19286:	9325      	str	r3, [sp, #148]	; 0x94
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
   19288:	932e      	str	r3, [sp, #184]	; 0xb8
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
   1928a:	9330      	str	r3, [sp, #192]	; 0xc0
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
   1928c:	9532      	str	r5, [sp, #200]	; 0xc8
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
   1928e:	9342      	str	r3, [sp, #264]	; 0x108
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
   19290:	9345      	str	r3, [sp, #276]	; 0x114
  PeriphClkInitStruct.PLL3.PLL3M = 25;
   19292:	9226      	str	r2, [sp, #152]	; 0x98
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
   19294:	913e      	str	r1, [sp, #248]	; 0xf8
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
   19296:	e9cd 3323 	strd	r3, r3, [sp, #140]	; 0x8c
  PeriphClkInitStruct.PLL3.PLL3Q = 8;
   1929a:	e9cd 4728 	strd	r4, r7, [sp, #160]	; 0xa0
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
   1929e:	e9cd 432a 	strd	r4, r3, [sp, #168]	; 0xa8
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
   192a2:	e9cd 332c 	strd	r3, r3, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
   192a6:	e9cd 333c 	strd	r3, r3, [sp, #240]	; 0xf0
  PeriphClkInitStruct.PLL2.PLL2M = 25;
   192aa:	e9cd e21d 	strd	lr, r2, [sp, #116]	; 0x74
  PeriphClkInitStruct.PLL2.PLL2P = 7;
   192ae:	e9cd c61f 	strd	ip, r6, [sp, #124]	; 0x7c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   192b2:	f7f5 ffb7 	bl	f224 <HAL_RCCEx_PeriphCLKConfig>
   192b6:	b100      	cbz	r0, 192ba <SystemClock_Config+0x11e>
   192b8:	e7fe      	b.n	192b8 <SystemClock_Config+0x11c>
  HAL_PWREx_EnableUSBVoltageDetector();
   192ba:	f7f4 fee5 	bl	e088 <HAL_PWREx_EnableUSBVoltageDetector>
}
   192be:	b04c      	add	sp, #304	; 0x130
   192c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   192c4:	58024800 	.word	0x58024800
   192c8:	58000400 	.word	0x58000400
   192cc:	58024400 	.word	0x58024400
   192d0:	010f0118 	.word	0x010f0118

000192d4 <HAL_ADC_ConvCpltCallback>:
}
   192d4:	4770      	bx	lr
   192d6:	bf00      	nop

000192d8 <HAL_ADC_ConvHalfCpltCallback>:
   192d8:	4770      	bx	lr
   192da:	bf00      	nop

000192dc <SDRAM_Initialization_sequence>:
{
   192dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   192e0:	4c2b      	ldr	r4, [pc, #172]	; (19390 <SDRAM_Initialization_sequence+0xb4>)
{
   192e2:	b087      	sub	sp, #28
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
   192e4:	2501      	movs	r5, #1
    __IO uint32_t tmpmrd = 0;
   192e6:	2600      	movs	r6, #0
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   192e8:	2710      	movs	r7, #16
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   192ea:	a902      	add	r1, sp, #8
   192ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
   192f0:	4620      	mov	r0, r4
    Command.AutoRefreshNumber = 8;
   192f2:	f04f 0808 	mov.w	r8, #8
    __IO uint32_t tmpmrd = 0;
   192f6:	9601      	str	r6, [sp, #4]
    Command.ModeRegisterDefinition = 0;
   192f8:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   192fa:	f04f 0903 	mov.w	r9, #3
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
   192fe:	9502      	str	r5, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   19300:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19304:	f7f8 fe9e 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
   19308:	4628      	mov	r0, r5
   1930a:	f7ef f879 	bl	8400 <HAL_Delay>
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
   1930e:	2302      	movs	r3, #2
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19310:	eb0d 0108 	add.w	r1, sp, r8
   19314:	4620      	mov	r0, r4
   19316:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
   1931a:	9302      	str	r3, [sp, #8]
    Command.ModeRegisterDefinition = 0;
   1931c:	9605      	str	r6, [sp, #20]
    Command.AutoRefreshNumber = 1;
   1931e:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19322:	f7f8 fe8f 	bl	12044 <HAL_SDRAM_SendCommand>
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
   19326:	f240 2222 	movw	r2, #546	; 0x222
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
   1932a:	2304      	movs	r3, #4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1932c:	eb0d 0108 	add.w	r1, sp, r8
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
   19330:	9201      	str	r2, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19332:	4620      	mov	r0, r4
    Command.ModeRegisterDefinition = tmpmrd;
   19334:	f8dd c004 	ldr.w	ip, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19338:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
   1933c:	9302      	str	r3, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   1933e:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = tmpmrd;
   19340:	e9cd 5c04 	strd	r5, ip, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19344:	f7f8 fe7e 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19348:	eb0d 0108 	add.w	r1, sp, r8
   1934c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   19350:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   19352:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = 0;
   19354:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
   19356:	f8cd 9008 	str.w	r9, [sp, #8]
    Command.AutoRefreshNumber = 8;
   1935a:	f8cd 8010 	str.w	r8, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1935e:	f7f8 fe71 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
   19362:	4628      	mov	r0, r5
   19364:	f7ef f84c 	bl	8400 <HAL_Delay>
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   19368:	eb0d 0108 	add.w	r1, sp, r8
   1936c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   19370:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
   19372:	e9cd 9702 	strd	r9, r7, [sp, #8]
    Command.ModeRegisterDefinition = 0;
   19376:	e9cd 8604 	strd	r8, r6, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
   1937a:	f7f8 fe63 	bl	12044 <HAL_SDRAM_SendCommand>
    HAL_SDRAM_ProgramRefreshRate(&hsdram1, SDRAM_REFRESH_COUNT);
   1937e:	f240 5169 	movw	r1, #1385	; 0x569
   19382:	4620      	mov	r0, r4
   19384:	f7f8 fe80 	bl	12088 <HAL_SDRAM_ProgramRefreshRate>
}
   19388:	b007      	add	sp, #28
   1938a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1938e:	bf00      	nop
   19390:	020f7ba0 	.word	0x020f7ba0

00019394 <randomNumber>:
float randomNumber(void) {
   19394:	b500      	push	{lr}
   19396:	b083      	sub	sp, #12
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
   19398:	4807      	ldr	r0, [pc, #28]	; (193b8 <randomNumber+0x24>)
   1939a:	a901      	add	r1, sp, #4
   1939c:	f7f7 f8d8 	bl	10550 <HAL_RNG_GenerateRandomNumber>
	float num = (float)rand * INV_TWO_TO_32;
   193a0:	eddd 7a01 	vldr	s15, [sp, #4]
   193a4:	ed9f 0a05 	vldr	s0, [pc, #20]	; 193bc <randomNumber+0x28>
   193a8:	eef8 7a67 	vcvt.f32.u32	s15, s15
}
   193ac:	ee27 0a80 	vmul.f32	s0, s15, s0
   193b0:	b003      	add	sp, #12
   193b2:	f85d fb04 	ldr.w	pc, [sp], #4
   193b6:	bf00      	nop
   193b8:	020f829c 	.word	0x020f829c
   193bc:	2f80000d 	.word	0x2f80000d

000193c0 <MPU_Conf>:
{
   193c0:	b510      	push	{r4, lr}
   193c2:	b084      	sub	sp, #16
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   193c4:	2400      	movs	r4, #0
	HAL_MPU_Disable();
   193c6:	f7f0 fb91 	bl	9aec <HAL_MPU_Disable>
  MPU_InitStruct.BaseAddress = 0x30000000;
   193ca:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193ce:	f240 1201 	movw	r2, #257	; 0x101
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   193d2:	4b0d      	ldr	r3, [pc, #52]	; (19408 <MPU_Conf+0x48>)
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193d4:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x30000000;
   193d6:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193d8:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   193dc:	e9cd 3402 	strd	r3, r4, [sp, #8]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193e0:	f7f0 fba6 	bl	9b30 <HAL_MPU_ConfigRegion>
  MPU_InitStruct.BaseAddress = 0x38000000;
   193e4:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193e8:	f240 2201 	movw	r2, #513	; 0x201
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   193ec:	4b07      	ldr	r3, [pc, #28]	; (1940c <MPU_Conf+0x4c>)
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193ee:	4668      	mov	r0, sp
  MPU_InitStruct.BaseAddress = 0x38000000;
   193f0:	9101      	str	r1, [sp, #4]
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   193f2:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
   193f6:	9302      	str	r3, [sp, #8]
   193f8:	9403      	str	r4, [sp, #12]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
   193fa:	f7f0 fb99 	bl	9b30 <HAL_MPU_ConfigRegion>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
   193fe:	2004      	movs	r0, #4
   19400:	f7f0 fb84 	bl	9b0c <HAL_MPU_Enable>
}
   19404:	b004      	add	sp, #16
   19406:	bd10      	pop	{r4, pc}
   19408:	03010011 	.word	0x03010011
   1940c:	0301000f 	.word	0x0301000f

00019410 <CycleCounterTrackMinAndMax>:



//this keeps min and max, but doesn't do the array for averaging - a bit less expensive
void CycleCounterTrackMinAndMax( uint8_t whichCount)
{
   19410:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if ((cycleCountVals[whichCount][2] == 0) && (cycleCountVals[whichCount][1] > 0)) //the [2] spot in the array will be set to 1 if an interrupt happened during the cycle count -- need to set that in any higher-priority interrupts to make that true
   19414:	0046      	lsls	r6, r0, #1
   19416:	4c27      	ldr	r4, [pc, #156]	; (194b4 <CycleCounterTrackMinAndMax+0xa4>)
   19418:	1833      	adds	r3, r6, r0
   1941a:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
{
   1941e:	ed2d 8b02 	vpush	{d8}
	if ((cycleCountVals[whichCount][2] == 0) && (cycleCountVals[whichCount][1] > 0)) //the [2] spot in the array will be set to 1 if an interrupt happened during the cycle count -- need to set that in any higher-priority interrupts to make that true
   19422:	e9d2 8904 	ldrd	r8, r9, [r2, #16]
   19426:	ea58 0109 	orrs.w	r1, r8, r9
   1942a:	d13e      	bne.n	194aa <CycleCounterTrackMinAndMax+0x9a>
   1942c:	e9d2 8902 	ldrd	r8, r9, [r2, #8]
   19430:	f1b8 0f01 	cmp.w	r8, #1
   19434:	f179 0100 	sbcs.w	r1, r9, #0
   19438:	db37      	blt.n	194aa <CycleCounterTrackMinAndMax+0x9a>
	{
		if ((cycleCountVals[whichCount][1] < cycleCountAverages[whichCount][1]) || (cycleCountAverages[whichCount][1] == 0))
   1943a:	4f1f      	ldr	r7, [pc, #124]	; (194b8 <CycleCounterTrackMinAndMax+0xa8>)
   1943c:	4605      	mov	r5, r0
   1943e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   19442:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
   19446:	ed93 8a01 	vldr	s16, [r3, #4]
   1944a:	f016 fb69 	bl	2fb20 <__aeabi_l2f>
   1944e:	ee07 0a90 	vmov	s15, r0
   19452:	eef4 7ac8 	vcmpe.f32	s15, s16
   19456:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1945a:	d404      	bmi.n	19466 <CycleCounterTrackMinAndMax+0x56>
   1945c:	eeb5 8a40 	vcmp.f32	s16, #0.0
   19460:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19464:	d10a      	bne.n	1947c <CycleCounterTrackMinAndMax+0x6c>
		{
			cycleCountAverages[whichCount][1] = cycleCountVals[whichCount][1];
   19466:	1973      	adds	r3, r6, r5
   19468:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   1946c:	eb07 0883 	add.w	r8, r7, r3, lsl #2
   19470:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
   19474:	f016 fb54 	bl	2fb20 <__aeabi_l2f>
   19478:	f8c8 0004 	str.w	r0, [r8, #4]
		}
		//update max value ([2])
		if (cycleCountVals[whichCount][1] > cycleCountAverages[whichCount][2])
   1947c:	1970      	adds	r0, r6, r5
   1947e:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
   19482:	eb07 0780 	add.w	r7, r7, r0, lsl #2
   19486:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
   1948a:	f016 fb49 	bl	2fb20 <__aeabi_l2f>
   1948e:	edd7 7a02 	vldr	s15, [r7, #8]
   19492:	ee07 0a10 	vmov	s14, r0
   19496:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1949a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1949e:	dd04      	ble.n	194aa <CycleCounterTrackMinAndMax+0x9a>
		{
			cycleCountAverages[whichCount][2] = cycleCountVals[whichCount][1];
   194a0:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
   194a4:	f016 fb3c 	bl	2fb20 <__aeabi_l2f>
   194a8:	60b8      	str	r0, [r7, #8]
		}
	}
}
   194aa:	ecbd 8b02 	vpop	{d8}
   194ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   194b2:	bf00      	nop
   194b4:	020f8198 	.word	0x020f8198
   194b8:	020f8168 	.word	0x020f8168

000194bc <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
   194bc:	e7fe      	b.n	194bc <Error_Handler>
   194be:	bf00      	nop

000194c0 <assert_failed>:
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
   194c0:	4770      	bx	lr
   194c2:	bf00      	nop

000194c4 <setLED_Edit>:
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
}

void setLED_Edit(uint8_t onOff)
{
	if (onOff)
   194c4:	b920      	cbnz	r0, 194d0 <setLED_Edit+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);
   194c6:	4602      	mov	r2, r0
   194c8:	2180      	movs	r1, #128	; 0x80
   194ca:	4804      	ldr	r0, [pc, #16]	; (194dc <setLED_Edit+0x18>)
   194cc:	f7f2 beb2 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
   194d0:	2201      	movs	r2, #1
   194d2:	2180      	movs	r1, #128	; 0x80
   194d4:	4801      	ldr	r0, [pc, #4]	; (194dc <setLED_Edit+0x18>)
   194d6:	f7f2 bead 	b.w	c234 <HAL_GPIO_WritePin>
   194da:	bf00      	nop
   194dc:	58020800 	.word	0x58020800

000194e0 <setLED_USB>:
}


void setLED_USB(uint8_t onOff)
{
	if (onOff)
   194e0:	b920      	cbnz	r0, 194ec <setLED_USB+0xc>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
   194e2:	4602      	mov	r2, r0
   194e4:	2140      	movs	r1, #64	; 0x40
   194e6:	4804      	ldr	r0, [pc, #16]	; (194f8 <setLED_USB+0x18>)
   194e8:	f7f2 bea4 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
   194ec:	2201      	movs	r2, #1
   194ee:	2140      	movs	r1, #64	; 0x40
   194f0:	4801      	ldr	r0, [pc, #4]	; (194f8 <setLED_USB+0x18>)
   194f2:	f7f2 be9f 	b.w	c234 <HAL_GPIO_WritePin>
   194f6:	bf00      	nop
   194f8:	58021800 	.word	0x58021800

000194fc <setLED_1>:
}


void setLED_1(uint8_t onOff)
{
	if (onOff)
   194fc:	b928      	cbnz	r0, 1950a <setLED_1+0xe>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
   194fe:	4602      	mov	r2, r0
   19500:	f44f 6180 	mov.w	r1, #1024	; 0x400
   19504:	4804      	ldr	r0, [pc, #16]	; (19518 <setLED_1+0x1c>)
   19506:	f7f2 be95 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
   1950a:	2201      	movs	r2, #1
   1950c:	f44f 6180 	mov.w	r1, #1024	; 0x400
   19510:	4801      	ldr	r0, [pc, #4]	; (19518 <setLED_1+0x1c>)
   19512:	f7f2 be8f 	b.w	c234 <HAL_GPIO_WritePin>
   19516:	bf00      	nop
   19518:	58020000 	.word	0x58020000

0001951c <setLED_2>:
	}
}

void setLED_2(uint8_t onOff)
{
	if (onOff)
   1951c:	b928      	cbnz	r0, 1952a <setLED_2+0xe>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
   1951e:	4602      	mov	r2, r0
   19520:	f44f 7180 	mov.w	r1, #256	; 0x100
   19524:	4804      	ldr	r0, [pc, #16]	; (19538 <setLED_2+0x1c>)
   19526:	f7f2 be85 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
   1952a:	2201      	movs	r2, #1
   1952c:	f44f 7180 	mov.w	r1, #256	; 0x100
   19530:	4801      	ldr	r0, [pc, #4]	; (19538 <setLED_2+0x1c>)
   19532:	f7f2 be7f 	b.w	c234 <HAL_GPIO_WritePin>
   19536:	bf00      	nop
   19538:	58020000 	.word	0x58020000

0001953c <setLED_A>:
}


void setLED_A(uint8_t onOff)
{
	if (onOff)
   1953c:	b920      	cbnz	r0, 19548 <setLED_A+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET);
   1953e:	4602      	mov	r2, r0
   19540:	2140      	movs	r1, #64	; 0x40
   19542:	4804      	ldr	r0, [pc, #16]	; (19554 <setLED_A+0x18>)
   19544:	f7f2 be76 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
   19548:	2201      	movs	r2, #1
   1954a:	2140      	movs	r1, #64	; 0x40
   1954c:	4801      	ldr	r0, [pc, #4]	; (19554 <setLED_A+0x18>)
   1954e:	f7f2 be71 	b.w	c234 <HAL_GPIO_WritePin>
   19552:	bf00      	nop
   19554:	58020800 	.word	0x58020800

00019558 <setLED_B>:
	}
}

void setLED_B(uint8_t onOff)
{
	if (onOff)
   19558:	b920      	cbnz	r0, 19564 <setLED_B+0xc>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
   1955a:	4602      	mov	r2, r0
   1955c:	2180      	movs	r1, #128	; 0x80
   1955e:	4804      	ldr	r0, [pc, #16]	; (19570 <setLED_B+0x18>)
   19560:	f7f2 be68 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
   19564:	2201      	movs	r2, #1
   19566:	2180      	movs	r1, #128	; 0x80
   19568:	4801      	ldr	r0, [pc, #4]	; (19570 <setLED_B+0x18>)
   1956a:	f7f2 be63 	b.w	c234 <HAL_GPIO_WritePin>
   1956e:	bf00      	nop
   19570:	58021800 	.word	0x58021800

00019574 <setLED_C>:
	}
}

void setLED_C(uint8_t onOff)
{
	if (onOff)
   19574:	b928      	cbnz	r0, 19582 <setLED_C+0xe>
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET);
   19576:	4602      	mov	r2, r0
   19578:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1957c:	4804      	ldr	r0, [pc, #16]	; (19590 <setLED_C+0x1c>)
   1957e:	f7f2 be59 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
   19582:	2201      	movs	r2, #1
   19584:	f44f 6180 	mov.w	r1, #1024	; 0x400
   19588:	4801      	ldr	r0, [pc, #4]	; (19590 <setLED_C+0x1c>)
   1958a:	f7f2 be53 	b.w	c234 <HAL_GPIO_WritePin>
   1958e:	bf00      	nop
   19590:	58021800 	.word	0x58021800

00019594 <setLED_leftout_clip>:
	}
}

void setLED_leftout_clip(uint8_t onOff)
{
	if (onOff)
   19594:	b920      	cbnz	r0, 195a0 <setLED_leftout_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
   19596:	4602      	mov	r2, r0
   19598:	2110      	movs	r1, #16
   1959a:	4804      	ldr	r0, [pc, #16]	; (195ac <setLED_leftout_clip+0x18>)
   1959c:	f7f2 be4a 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
   195a0:	2201      	movs	r2, #1
   195a2:	2110      	movs	r1, #16
   195a4:	4801      	ldr	r0, [pc, #4]	; (195ac <setLED_leftout_clip+0x18>)
   195a6:	f7f2 be45 	b.w	c234 <HAL_GPIO_WritePin>
   195aa:	bf00      	nop
   195ac:	58020000 	.word	0x58020000

000195b0 <setLED_rightout_clip>:
	}
}

void setLED_rightout_clip(uint8_t onOff)
{
	if (onOff)
   195b0:	b920      	cbnz	r0, 195bc <setLED_rightout_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
   195b2:	4602      	mov	r2, r0
   195b4:	2140      	movs	r1, #64	; 0x40
   195b6:	4804      	ldr	r0, [pc, #16]	; (195c8 <setLED_rightout_clip+0x18>)
   195b8:	f7f2 be3c 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
   195bc:	2201      	movs	r2, #1
   195be:	2140      	movs	r1, #64	; 0x40
   195c0:	4801      	ldr	r0, [pc, #4]	; (195c8 <setLED_rightout_clip+0x18>)
   195c2:	f7f2 be37 	b.w	c234 <HAL_GPIO_WritePin>
   195c6:	bf00      	nop
   195c8:	58020000 	.word	0x58020000

000195cc <setLED_leftin_clip>:
	}
}

void setLED_leftin_clip(uint8_t onOff)
{
	if (onOff)
   195cc:	b920      	cbnz	r0, 195d8 <setLED_leftin_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);
   195ce:	4602      	mov	r2, r0
   195d0:	2110      	movs	r1, #16
   195d2:	4804      	ldr	r0, [pc, #16]	; (195e4 <setLED_leftin_clip+0x18>)
   195d4:	f7f2 be2e 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
   195d8:	2201      	movs	r2, #1
   195da:	2110      	movs	r1, #16
   195dc:	4801      	ldr	r0, [pc, #4]	; (195e4 <setLED_leftin_clip+0x18>)
   195de:	f7f2 be29 	b.w	c234 <HAL_GPIO_WritePin>
   195e2:	bf00      	nop
   195e4:	58020800 	.word	0x58020800

000195e8 <setLED_rightin_clip>:
	}
}

void setLED_rightin_clip(uint8_t onOff)
{
	if (onOff)
   195e8:	b920      	cbnz	r0, 195f4 <setLED_rightin_clip+0xc>
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
   195ea:	4602      	mov	r2, r0
   195ec:	2101      	movs	r1, #1
   195ee:	4804      	ldr	r0, [pc, #16]	; (19600 <setLED_rightin_clip+0x18>)
   195f0:	f7f2 be20 	b.w	c234 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
   195f4:	2201      	movs	r2, #1
   195f6:	4802      	ldr	r0, [pc, #8]	; (19600 <setLED_rightin_clip+0x18>)
   195f8:	4611      	mov	r1, r2
   195fa:	f7f2 be1b 	b.w	c234 <HAL_GPIO_WritePin>
   195fe:	bf00      	nop
   19600:	58020400 	.word	0x58020400

00019604 <OLED_writePreset>:
	}
//	OLED_draw();
}

void OLED_writePreset()
{
   19604:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   19606:	4935      	ldr	r1, [pc, #212]	; (196dc <OLED_writePreset+0xd8>)
{
   19608:	b089      	sub	sp, #36	; 0x24
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1960a:	4835      	ldr	r0, [pc, #212]	; (196e0 <OLED_writePreset+0xdc>)
}


void OLEDclear()
{
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1960c:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
   1960e:	f7ff f9a7 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19612:	2320      	movs	r3, #32
	itoa((currentPreset+1), tempString, 10);
   19614:	4f33      	ldr	r7, [pc, #204]	; (196e4 <OLED_writePreset+0xe0>)
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19616:	4632      	mov	r2, r6
   19618:	4631      	mov	r1, r6
   1961a:	9300      	str	r3, [sp, #0]
   1961c:	4830      	ldr	r0, [pc, #192]	; (196e0 <OLED_writePreset+0xdc>)
   1961e:	2380      	movs	r3, #128	; 0x80
   19620:	9601      	str	r6, [sp, #4]
	itoa((currentPreset+1), tempString, 10);
   19622:	ac02      	add	r4, sp, #8
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19624:	f7fe fd54 	bl	180d0 <GFXfillRect>
	itoa((currentPreset+1), tempString, 10);
   19628:	7838      	ldrb	r0, [r7, #0]
   1962a:	4621      	mov	r1, r4
   1962c:	220a      	movs	r2, #10
   1962e:	3001      	adds	r0, #1
   19630:	f013 f9fa 	bl	2ca28 <itoa>
	strcat(tempString, ":");
   19634:	4620      	mov	r0, r4
   19636:	f013 fa15 	bl	2ca64 <strlen>
   1963a:	4a2b      	ldr	r2, [pc, #172]	; (196e8 <OLED_writePreset+0xe4>)
   1963c:	4603      	mov	r3, r0
	strcat(tempString, modeNames[currentPreset]);
   1963e:	783d      	ldrb	r5, [r7, #0]
	strcat(tempString, ":");
   19640:	8812      	ldrh	r2, [r2, #0]
   19642:	3001      	adds	r0, #1
	strcat(tempString, modeNames[currentPreset]);
   19644:	4929      	ldr	r1, [pc, #164]	; (196ec <OLED_writePreset+0xe8>)
	strcat(tempString, ":");
   19646:	52e2      	strh	r2, [r4, r3]
	strcat(tempString, modeNames[currentPreset]);
   19648:	4420      	add	r0, r4
   1964a:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
   1964e:	f013 fa00 	bl	2ca52 <stpcpy>
	int myLength = strlen(tempString);
   19652:	1b05      	subs	r5, r0, r4

void OLEDwriteString(char* myCharArray, uint8_t arrayLength, uint8_t startCursor, OLEDLine line)
{
	uint8_t cursorX = startCursor;
	uint8_t cursorY = 12 + (16 * (line%2));
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19654:	4631      	mov	r1, r6
   19656:	220c      	movs	r2, #12

	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19658:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1965a:	4821      	ldr	r0, [pc, #132]	; (196e0 <OLED_writePreset+0xdc>)
   1965c:	f7ff f96e 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19660:	2010      	movs	r0, #16
   19662:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19666:	9601      	str	r6, [sp, #4]
   19668:	9000      	str	r0, [sp, #0]
   1966a:	4632      	mov	r2, r6
   1966c:	4631      	mov	r1, r6
   1966e:	009b      	lsls	r3, r3, #2
   19670:	481b      	ldr	r0, [pc, #108]	; (196e0 <OLED_writePreset+0xdc>)
   19672:	f7fe fd2d 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19676:	b145      	cbz	r5, 1968a <OLED_writePreset+0x86>
	{
		GFXwrite(&theGFX, myCharArray[i]);
   19678:	4e19      	ldr	r6, [pc, #100]	; (196e0 <OLED_writePreset+0xdc>)
   1967a:	4425      	add	r5, r4
   1967c:	f814 1b01 	ldrb.w	r1, [r4], #1
   19680:	4630      	mov	r0, r6
   19682:	f7ff f8a9 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19686:	42a5      	cmp	r5, r4
   19688:	d1f8      	bne.n	1967c <OLED_writePreset+0x78>
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1968a:	4919      	ldr	r1, [pc, #100]	; (196f0 <OLED_writePreset+0xec>)
   1968c:	4814      	ldr	r0, [pc, #80]	; (196e0 <OLED_writePreset+0xdc>)
   1968e:	f7ff f967 	bl	18960 <GFXsetFont>
	OLEDwriteString(modeNamesDetails[currentPreset], strlen(modeNamesDetails[currentPreset]), 0, SecondLine);
   19692:	783a      	ldrb	r2, [r7, #0]
   19694:	4b17      	ldr	r3, [pc, #92]	; (196f4 <OLED_writePreset+0xf0>)
   19696:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
   1969a:	4620      	mov	r0, r4
   1969c:	f013 f9e2 	bl	2ca64 <strlen>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   196a0:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   196a2:	b2c5      	uxtb	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   196a4:	2100      	movs	r1, #0
   196a6:	480e      	ldr	r0, [pc, #56]	; (196e0 <OLED_writePreset+0xdc>)
   196a8:	f7ff f948 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   196ac:	2220      	movs	r2, #32
   196ae:	2100      	movs	r1, #0
   196b0:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   196b4:	9200      	str	r2, [sp, #0]
   196b6:	2210      	movs	r2, #16
   196b8:	9101      	str	r1, [sp, #4]
   196ba:	009b      	lsls	r3, r3, #2
   196bc:	4808      	ldr	r0, [pc, #32]	; (196e0 <OLED_writePreset+0xdc>)
   196be:	f7fe fd07 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   196c2:	b14d      	cbz	r5, 196d8 <OLED_writePreset+0xd4>
   196c4:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
   196c6:	4e06      	ldr	r6, [pc, #24]	; (196e0 <OLED_writePreset+0xdc>)
   196c8:	4425      	add	r5, r4
   196ca:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   196ce:	4630      	mov	r0, r6
   196d0:	f7ff f882 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   196d4:	42ac      	cmp	r4, r5
   196d6:	d1f8      	bne.n	196ca <OLED_writePreset+0xc6>
}
   196d8:	b009      	add	sp, #36	; 0x24
   196da:	bdf0      	pop	{r4, r5, r6, r7, pc}
   196dc:	00030960 	.word	0x00030960
   196e0:	020f8278 	.word	0x020f8278
   196e4:	020e3259 	.word	0x020e3259
   196e8:	00030ff8 	.word	0x00030ff8
   196ec:	020fb348 	.word	0x020fb348
   196f0:	000303ac 	.word	0x000303ac
   196f4:	020fb4f8 	.word	0x020fb4f8

000196f8 <OLED_init>:
{
   196f8:	b530      	push	{r4, r5, lr}
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   196fa:	2278      	movs	r2, #120	; 0x78
{
   196fc:	b083      	sub	sp, #12
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   196fe:	2102      	movs	r1, #2
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   19700:	4d28      	ldr	r5, [pc, #160]	; (197a4 <OLED_init+0xac>)
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
   19702:	f008 f831 	bl	21768 <ssd1306_begin>
   19706:	f44f 7200 	mov.w	r2, #512	; 0x200
   1970a:	2100      	movs	r1, #0
   1970c:	4826      	ldr	r0, [pc, #152]	; (197a8 <OLED_init+0xb0>)
   1970e:	f013 f998 	bl	2ca42 <memset>
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   19712:	4b26      	ldr	r3, [pc, #152]	; (197ac <OLED_init+0xb4>)
   19714:	4926      	ldr	r1, [pc, #152]	; (197b0 <OLED_init+0xb8>)
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   19716:	4a27      	ldr	r2, [pc, #156]	; (197b4 <OLED_init+0xbc>)
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
   19718:	6019      	str	r1, [r3, #0]
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
   1971a:	605a      	str	r2, [r3, #4]
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   1971c:	4826      	ldr	r0, [pc, #152]	; (197b8 <OLED_init+0xc0>)
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   1971e:	4927      	ldr	r1, [pc, #156]	; (197bc <OLED_init+0xc4>)
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   19720:	4a27      	ldr	r2, [pc, #156]	; (197c0 <OLED_init+0xc8>)
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
   19722:	609d      	str	r5, [r3, #8]
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
   19724:	60d8      	str	r0, [r3, #12]
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
   19726:	6119      	str	r1, [r3, #16]
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
   19728:	615a      	str	r2, [r3, #20]
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   1972a:	4d26      	ldr	r5, [pc, #152]	; (197c4 <OLED_init+0xcc>)
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   1972c:	4826      	ldr	r0, [pc, #152]	; (197c8 <OLED_init+0xd0>)
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   1972e:	4927      	ldr	r1, [pc, #156]	; (197cc <OLED_init+0xd4>)
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   19730:	4a27      	ldr	r2, [pc, #156]	; (197d0 <OLED_init+0xd8>)
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
   19732:	619d      	str	r5, [r3, #24]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
   19734:	61d8      	str	r0, [r3, #28]
	buttonActionFunctions[Distortion] = UIDistortionButtons;
   19736:	6219      	str	r1, [r3, #32]
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
   19738:	625a      	str	r2, [r3, #36]	; 0x24
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   1973a:	4d26      	ldr	r5, [pc, #152]	; (197d4 <OLED_init+0xdc>)
	buttonActionFunctions[Delay] = UIDelayButtons;
   1973c:	4826      	ldr	r0, [pc, #152]	; (197d8 <OLED_init+0xe0>)
	buttonActionFunctions[Reverb] = UIReverbButtons;
   1973e:	4927      	ldr	r1, [pc, #156]	; (197dc <OLED_init+0xe4>)
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
   19740:	4a27      	ldr	r2, [pc, #156]	; (197e0 <OLED_init+0xe8>)
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
   19742:	629d      	str	r5, [r3, #40]	; 0x28
	buttonActionFunctions[Delay] = UIDelayButtons;
   19744:	62d8      	str	r0, [r3, #44]	; 0x2c
	buttonActionFunctions[Reverb] = UIReverbButtons;
   19746:	6319      	str	r1, [r3, #48]	; 0x30
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
   19748:	635a      	str	r2, [r3, #52]	; 0x34
	  GFXinit(&theGFX, 128, 32);
   1974a:	4c26      	ldr	r4, [pc, #152]	; (197e4 <OLED_init+0xec>)
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
   1974c:	4826      	ldr	r0, [pc, #152]	; (197e8 <OLED_init+0xf0>)
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
   1974e:	4927      	ldr	r1, [pc, #156]	; (197ec <OLED_init+0xf4>)
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   19750:	4a27      	ldr	r2, [pc, #156]	; (197f0 <OLED_init+0xf8>)
	buttonActionFunctions[LivingString] = UILivingStringButtons;
   19752:	4d28      	ldr	r5, [pc, #160]	; (197f4 <OLED_init+0xfc>)
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
   19754:	e9c3 1210 	strd	r1, r2, [r3, #64]	; 0x40
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
   19758:	e9c3 500e 	strd	r5, r0, [r3, #56]	; 0x38
	  initModeNames();
   1975c:	f008 fb3a 	bl	21dd4 <initModeNames>
	  GFXinit(&theGFX, 128, 32);
   19760:	4620      	mov	r0, r4
   19762:	2220      	movs	r2, #32
   19764:	2180      	movs	r1, #128	; 0x80
   19766:	f7fe fb97 	bl	17e98 <GFXinit>
	  GFXsetFont(&theGFX, &EuphemiaCAS8pt7b); //this one is elegant but definitely not monospaced can fit 9 Ms
   1976a:	4620      	mov	r0, r4
   1976c:	4922      	ldr	r1, [pc, #136]	; (197f8 <OLED_init+0x100>)
   1976e:	f7ff f8f7 	bl	18960 <GFXsetFont>
	  GFXsetTextColor(&theGFX, 1, 0);
   19772:	4620      	mov	r0, r4
   19774:	2200      	movs	r2, #0
   19776:	2101      	movs	r1, #1
   19778:	f7ff f8ee 	bl	18958 <GFXsetTextColor>
	  GFXsetTextSize(&theGFX, 1);
   1977c:	4620      	mov	r0, r4
   1977e:	2101      	movs	r1, #1
   19780:	f7ff f8e4 	bl	1894c <GFXsetTextSize>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19784:	2200      	movs	r2, #0
   19786:	2320      	movs	r3, #32
   19788:	4620      	mov	r0, r4
   1978a:	4611      	mov	r1, r2
   1978c:	9201      	str	r2, [sp, #4]
   1978e:	9300      	str	r3, [sp, #0]
   19790:	2380      	movs	r3, #128	; 0x80
   19792:	f7fe fc9d 	bl	180d0 <GFXfillRect>
	  OLED_writePreset();
   19796:	f7ff ff35 	bl	19604 <OLED_writePreset>
}
   1979a:	b003      	add	sp, #12
   1979c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	ssd1306_display_full_buffer();
   197a0:	f008 b940 	b.w	21a24 <ssd1306_display_full_buffer>
   197a4:	00023119 	.word	0x00023119
   197a8:	020fb06c 	.word	0x020fb06c
   197ac:	020fbc80 	.word	0x020fbc80
   197b0:	00023011 	.word	0x00023011
   197b4:	00023095 	.word	0x00023095
   197b8:	00023121 	.word	0x00023121
   197bc:	0002317d 	.word	0x0002317d
   197c0:	00023185 	.word	0x00023185
   197c4:	00023275 	.word	0x00023275
   197c8:	00023309 	.word	0x00023309
   197cc:	0002338d 	.word	0x0002338d
   197d0:	000233c5 	.word	0x000233c5
   197d4:	000233fd 	.word	0x000233fd
   197d8:	00023435 	.word	0x00023435
   197dc:	00023491 	.word	0x00023491
   197e0:	000234ed 	.word	0x000234ed
   197e4:	020f8278 	.word	0x020f8278
   197e8:	000235a9 	.word	0x000235a9
   197ec:	0002362d 	.word	0x0002362d
   197f0:	00023679 	.word	0x00023679
   197f4:	00023525 	.word	0x00023525
   197f8:	00030960 	.word	0x00030960

000197fc <OLED_writeEditScreen>:
{
   197fc:	b570      	push	{r4, r5, r6, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   197fe:	4921      	ldr	r1, [pc, #132]	; (19884 <OLED_writeEditScreen+0x88>)
{
   19800:	b082      	sub	sp, #8
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19802:	4821      	ldr	r0, [pc, #132]	; (19888 <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   19804:	2500      	movs	r5, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19806:	f7ff f8ab 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
   1980a:	2320      	movs	r3, #32
   1980c:	462a      	mov	r2, r5
   1980e:	4629      	mov	r1, r5
   19810:	9501      	str	r5, [sp, #4]
   19812:	9300      	str	r3, [sp, #0]
   19814:	2380      	movs	r3, #128	; 0x80
   19816:	481c      	ldr	r0, [pc, #112]	; (19888 <OLED_writeEditScreen+0x8c>)
   19818:	f7fe fc5a 	bl	180d0 <GFXfillRect>
   1981c:	4c1b      	ldr	r4, [pc, #108]	; (1988c <OLED_writeEditScreen+0x90>)
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1981e:	4629      	mov	r1, r5
   19820:	220c      	movs	r2, #12
   19822:	4819      	ldr	r0, [pc, #100]	; (19888 <OLED_writeEditScreen+0x8c>)
   19824:	f104 060f 	add.w	r6, r4, #15
   19828:	f7ff f888 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1982c:	2310      	movs	r3, #16
   1982e:	9501      	str	r5, [sp, #4]
   19830:	462a      	mov	r2, r5
   19832:	4629      	mov	r1, r5
		GFXwrite(&theGFX, myCharArray[i]);
   19834:	4d14      	ldr	r5, [pc, #80]	; (19888 <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19836:	9300      	str	r3, [sp, #0]
   19838:	23b4      	movs	r3, #180	; 0xb4
   1983a:	4813      	ldr	r0, [pc, #76]	; (19888 <OLED_writeEditScreen+0x8c>)
   1983c:	f7fe fc48 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   19840:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19844:	4628      	mov	r0, r5
   19846:	f7fe ffc7 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1984a:	42a6      	cmp	r6, r4
   1984c:	d1f8      	bne.n	19840 <OLED_writeEditScreen+0x44>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   1984e:	221c      	movs	r2, #28
   19850:	2100      	movs	r1, #0
   19852:	480d      	ldr	r0, [pc, #52]	; (19888 <OLED_writeEditScreen+0x8c>)
   19854:	4c0e      	ldr	r4, [pc, #56]	; (19890 <OLED_writeEditScreen+0x94>)
   19856:	f7ff f871 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   1985a:	2100      	movs	r1, #0
   1985c:	2220      	movs	r2, #32
   1985e:	f104 0610 	add.w	r6, r4, #16
		GFXwrite(&theGFX, myCharArray[i]);
   19862:	4d09      	ldr	r5, [pc, #36]	; (19888 <OLED_writeEditScreen+0x8c>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19864:	23c0      	movs	r3, #192	; 0xc0
   19866:	4808      	ldr	r0, [pc, #32]	; (19888 <OLED_writeEditScreen+0x8c>)
   19868:	e9cd 2100 	strd	r2, r1, [sp]
   1986c:	2210      	movs	r2, #16
   1986e:	f7fe fc2f 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   19872:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19876:	4628      	mov	r0, r5
   19878:	f7fe ffae 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1987c:	42b4      	cmp	r4, r6
   1987e:	d1f8      	bne.n	19872 <OLED_writeEditScreen+0x76>
}
   19880:	b002      	add	sp, #8
   19882:	bd70      	pop	{r4, r5, r6, pc}
   19884:	000303ac 	.word	0x000303ac
   19888:	020f8278 	.word	0x020f8278
   1988c:	00030fd3 	.word	0x00030fd3
   19890:	00030fe3 	.word	0x00030fe3

00019894 <OLED_writeTuning>:
{
   19894:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19898:	2600      	movs	r6, #0
{
   1989a:	b083      	sub	sp, #12
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1989c:	2710      	movs	r7, #16
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   1989e:	4935      	ldr	r1, [pc, #212]	; (19974 <OLED_writeTuning+0xe0>)
   198a0:	4835      	ldr	r0, [pc, #212]	; (19978 <OLED_writeTuning+0xe4>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   198a2:	f04f 0920 	mov.w	r9, #32
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   198a6:	f7ff f85b 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   198aa:	2380      	movs	r3, #128	; 0x80
   198ac:	4631      	mov	r1, r6
   198ae:	463a      	mov	r2, r7
   198b0:	4831      	ldr	r0, [pc, #196]	; (19978 <OLED_writeTuning+0xe4>)
   198b2:	9601      	str	r6, [sp, #4]
   198b4:	9700      	str	r7, [sp, #0]
   198b6:	f7fe fc0b 	bl	180d0 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   198ba:	4631      	mov	r1, r6
   198bc:	221c      	movs	r2, #28
   198be:	482e      	ldr	r0, [pc, #184]	; (19978 <OLED_writeTuning+0xe4>)
   198c0:	f7ff f83c 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   198c4:	2318      	movs	r3, #24
   198c6:	463a      	mov	r2, r7
   198c8:	4631      	mov	r1, r6
   198ca:	482b      	ldr	r0, [pc, #172]	; (19978 <OLED_writeTuning+0xe4>)
   198cc:	9601      	str	r6, [sp, #4]
   198ce:	f8cd 9000 	str.w	r9, [sp]
   198d2:	f7fe fbfd 	bl	180d0 <GFXfillRect>
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
   198d6:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 19984 <OLED_writeTuning+0xf0>
		GFXwrite(&theGFX, myCharArray[i]);
   198da:	2154      	movs	r1, #84	; 0x54
   198dc:	4826      	ldr	r0, [pc, #152]	; (19978 <OLED_writeTuning+0xe4>)
	}
}

void OLEDwriteInt(uint32_t myNumber, uint8_t numDigits, uint8_t startCursor, OLEDLine line)
{
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   198de:	4c27      	ldr	r4, [pc, #156]	; (1997c <OLED_writeTuning+0xe8>)
		GFXwrite(&theGFX, myCharArray[i]);
   198e0:	f7fe ff7a 	bl	187d8 <GFXwrite>
   198e4:	4631      	mov	r1, r6
   198e6:	4824      	ldr	r0, [pc, #144]	; (19978 <OLED_writeTuning+0xe4>)
   198e8:	f7fe ff76 	bl	187d8 <GFXwrite>
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   198ec:	f8d8 1000 	ldr.w	r1, [r8]
   198f0:	2202      	movs	r2, #2
   198f2:	4620      	mov	r0, r4
   198f4:	f7ff f846 	bl	18984 <OLEDparseInt>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   198f8:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   198fa:	b2c5      	uxtb	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   198fc:	210c      	movs	r1, #12
   198fe:	481e      	ldr	r0, [pc, #120]	; (19978 <OLED_writeTuning+0xe4>)
   19900:	f7ff f81c 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19904:	f8cd 9000 	str.w	r9, [sp]
   19908:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1990c:	9601      	str	r6, [sp, #4]
   1990e:	463a      	mov	r2, r7
   19910:	210c      	movs	r1, #12
   19912:	009b      	lsls	r3, r3, #2
   19914:	4818      	ldr	r0, [pc, #96]	; (19978 <OLED_writeTuning+0xe4>)
   19916:	f7fe fbdb 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   1991a:	b145      	cbz	r5, 1992e <OLED_writeTuning+0x9a>
		GFXwrite(&theGFX, myCharArray[i]);
   1991c:	4e16      	ldr	r6, [pc, #88]	; (19978 <OLED_writeTuning+0xe4>)
   1991e:	4425      	add	r5, r4
   19920:	f814 1b01 	ldrb.w	r1, [r4], #1
   19924:	4630      	mov	r0, r6
   19926:	f7fe ff57 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1992a:	42ac      	cmp	r4, r5
   1992c:	d1f8      	bne.n	19920 <OLED_writeTuning+0x8c>
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   1992e:	f8d8 3000 	ldr.w	r3, [r8]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19932:	221c      	movs	r2, #28
   19934:	4810      	ldr	r0, [pc, #64]	; (19978 <OLED_writeTuning+0xe4>)
   19936:	2124      	movs	r1, #36	; 0x24
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   19938:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1993c:	4d10      	ldr	r5, [pc, #64]	; (19980 <OLED_writeTuning+0xec>)
		GFXwrite(&theGFX, myCharArray[i]);
   1993e:	4606      	mov	r6, r0
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
   19940:	eb05 0583 	add.w	r5, r5, r3, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19944:	f7fe fffa 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19948:	2200      	movs	r2, #0
   1994a:	2320      	movs	r3, #32
   1994c:	2124      	movs	r1, #36	; 0x24
   1994e:	4630      	mov	r0, r6
   19950:	1e6c      	subs	r4, r5, #1
   19952:	350b      	adds	r5, #11
   19954:	e9cd 3200 	strd	r3, r2, [sp]
   19958:	2390      	movs	r3, #144	; 0x90
   1995a:	2210      	movs	r2, #16
   1995c:	f7fe fbb8 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   19960:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19964:	4630      	mov	r0, r6
   19966:	f7fe ff37 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   1996a:	42a5      	cmp	r5, r4
   1996c:	d1f8      	bne.n	19960 <OLED_writeTuning+0xcc>
}
   1996e:	b003      	add	sp, #12
   19970:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   19974:	000303ac 	.word	0x000303ac
   19978:	020f8278 	.word	0x020f8278
   1997c:	020f8258 	.word	0x020f8258
   19980:	00031064 	.word	0x00031064
   19984:	020e3254 	.word	0x020e3254

00019988 <OLED_draw>:
	ssd1306_display_full_buffer();
   19988:	f008 b84c 	b.w	21a24 <ssd1306_display_full_buffer>

0001998c <OLEDclearLine>:
{
   1998c:	4602      	mov	r2, r0
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1998e:	2100      	movs	r1, #0
   19990:	2380      	movs	r3, #128	; 0x80
   19992:	4807      	ldr	r0, [pc, #28]	; (199b0 <OLEDclearLine+0x24>)
{
   19994:	b510      	push	{r4, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19996:	0854      	lsrs	r4, r2, #1
   19998:	f002 0201 	and.w	r2, r2, #1
{
   1999c:	b082      	sub	sp, #8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   1999e:	3401      	adds	r4, #1
   199a0:	0112      	lsls	r2, r2, #4
   199a2:	9101      	str	r1, [sp, #4]
   199a4:	0124      	lsls	r4, r4, #4
   199a6:	9400      	str	r4, [sp, #0]
   199a8:	f7fe fb92 	bl	180d0 <GFXfillRect>
}
   199ac:	b002      	add	sp, #8
   199ae:	bd10      	pop	{r4, pc}
   199b0:	020f8278 	.word	0x020f8278

000199b4 <OLEDwriteString>:
{
   199b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetCursor(&theGFX, cursorX, cursorY);
   199b6:	4617      	mov	r7, r2
	uint8_t cursorY = 12 + (16 * (line%2));
   199b8:	f003 0201 	and.w	r2, r3, #1
{
   199bc:	461e      	mov	r6, r3
   199be:	b083      	sub	sp, #12
	uint8_t cursorY = 12 + (16 * (line%2));
   199c0:	0112      	lsls	r2, r2, #4
{
   199c2:	460d      	mov	r5, r1
   199c4:	4604      	mov	r4, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   199c6:	4639      	mov	r1, r7
   199c8:	480e      	ldr	r0, [pc, #56]	; (19a04 <OLEDwriteString+0x50>)
   199ca:	320c      	adds	r2, #12
   199cc:	f7fe ffb6 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   199d0:	1c70      	adds	r0, r6, #1
   199d2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   199d6:	f04f 0c00 	mov.w	ip, #0
   199da:	0100      	lsls	r0, r0, #4
   199dc:	4639      	mov	r1, r7
   199de:	0132      	lsls	r2, r6, #4
   199e0:	009b      	lsls	r3, r3, #2
   199e2:	e9cd 0c00 	strd	r0, ip, [sp]
   199e6:	4807      	ldr	r0, [pc, #28]	; (19a04 <OLEDwriteString+0x50>)
   199e8:	f7fe fb72 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   199ec:	b145      	cbz	r5, 19a00 <OLEDwriteString+0x4c>
		GFXwrite(&theGFX, myCharArray[i]);
   199ee:	4e05      	ldr	r6, [pc, #20]	; (19a04 <OLEDwriteString+0x50>)
   199f0:	4425      	add	r5, r4
   199f2:	f814 1b01 	ldrb.w	r1, [r4], #1
   199f6:	4630      	mov	r0, r6
   199f8:	f7fe feee 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   199fc:	42a5      	cmp	r5, r4
   199fe:	d1f8      	bne.n	199f2 <OLEDwriteString+0x3e>
}
   19a00:	b003      	add	sp, #12
   19a02:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19a04:	020f8278 	.word	0x020f8278

00019a08 <OLEDwriteInt>:
{
   19a08:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19a0a:	4c16      	ldr	r4, [pc, #88]	; (19a64 <OLEDwriteInt+0x5c>)
{
   19a0c:	461f      	mov	r7, r3
   19a0e:	b083      	sub	sp, #12
   19a10:	4616      	mov	r6, r2
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19a12:	460a      	mov	r2, r1
   19a14:	4601      	mov	r1, r0
   19a16:	4620      	mov	r0, r4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a18:	b236      	sxth	r6, r6
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19a1a:	f7fe ffb3 	bl	18984 <OLEDparseInt>
	uint8_t cursorY = 12 + (16 * (line%2));
   19a1e:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
   19a22:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a24:	4631      	mov	r1, r6
	uint8_t cursorY = 12 + (16 * (line%2));
   19a26:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a28:	480f      	ldr	r0, [pc, #60]	; (19a68 <OLEDwriteInt+0x60>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19a2a:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a2c:	320c      	adds	r2, #12
   19a2e:	f7fe ff85 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19a32:	1c7a      	adds	r2, r7, #1
   19a34:	2000      	movs	r0, #0
   19a36:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19a3a:	0112      	lsls	r2, r2, #4
   19a3c:	4631      	mov	r1, r6
   19a3e:	009b      	lsls	r3, r3, #2
   19a40:	e9cd 2000 	strd	r2, r0, [sp]
   19a44:	013a      	lsls	r2, r7, #4
   19a46:	4808      	ldr	r0, [pc, #32]	; (19a68 <OLEDwriteInt+0x60>)
   19a48:	f7fe fb42 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19a4c:	b145      	cbz	r5, 19a60 <OLEDwriteInt+0x58>
		GFXwrite(&theGFX, myCharArray[i]);
   19a4e:	4e06      	ldr	r6, [pc, #24]	; (19a68 <OLEDwriteInt+0x60>)
   19a50:	4425      	add	r5, r4
   19a52:	f814 1b01 	ldrb.w	r1, [r4], #1
   19a56:	4630      	mov	r0, r6
   19a58:	f7fe febe 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19a5c:	42a5      	cmp	r5, r4
   19a5e:	d1f8      	bne.n	19a52 <OLEDwriteInt+0x4a>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19a60:	b003      	add	sp, #12
   19a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19a64:	020f8258 	.word	0x020f8258
   19a68:	020f8278 	.word	0x020f8278

00019a6c <OLEDwritePitch>:

	OLEDwriteLine(oled_buffer, len, line);
}

void OLEDwritePitch(float midi, uint8_t startCursor, OLEDLine line, uint8_t showCents)
{
   19a6c:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   19a6e:	4c16      	ldr	r4, [pc, #88]	; (19ac8 <OLEDwritePitch+0x5c>)
{
   19a70:	460f      	mov	r7, r1
   19a72:	b083      	sub	sp, #12
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   19a74:	4611      	mov	r1, r2
{
   19a76:	4606      	mov	r6, r0
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   19a78:	4620      	mov	r0, r4
   19a7a:	f7fe ffa3 	bl	189c4 <OLEDparsePitch>
	uint8_t cursorY = 12 + (16 * (line%2));
   19a7e:	f007 0201 	and.w	r2, r7, #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a82:	b236      	sxth	r6, r6
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
   19a84:	4605      	mov	r5, r0
	uint8_t cursorY = 12 + (16 * (line%2));
   19a86:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a88:	4810      	ldr	r0, [pc, #64]	; (19acc <OLEDwritePitch+0x60>)
   19a8a:	4631      	mov	r1, r6
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19a8c:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19a8e:	320c      	adds	r2, #12
   19a90:	f7fe ff54 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19a94:	1c7a      	adds	r2, r7, #1
   19a96:	2000      	movs	r0, #0
   19a98:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19a9c:	0112      	lsls	r2, r2, #4
   19a9e:	4631      	mov	r1, r6
   19aa0:	009b      	lsls	r3, r3, #2
   19aa2:	e9cd 2000 	strd	r2, r0, [sp]
   19aa6:	013a      	lsls	r2, r7, #4
   19aa8:	4808      	ldr	r0, [pc, #32]	; (19acc <OLEDwritePitch+0x60>)
   19aaa:	f7fe fb11 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19aae:	b145      	cbz	r5, 19ac2 <OLEDwritePitch+0x56>
		GFXwrite(&theGFX, myCharArray[i]);
   19ab0:	4e06      	ldr	r6, [pc, #24]	; (19acc <OLEDwritePitch+0x60>)
   19ab2:	4425      	add	r5, r4
   19ab4:	f814 1b01 	ldrb.w	r1, [r4], #1
   19ab8:	4630      	mov	r0, r6
   19aba:	f7fe fe8d 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19abe:	42a5      	cmp	r5, r4
   19ac0:	d1f8      	bne.n	19ab4 <OLEDwritePitch+0x48>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19ac2:	b003      	add	sp, #12
   19ac4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19ac6:	bf00      	nop
   19ac8:	020f8258 	.word	0x020f8258
   19acc:	020f8278 	.word	0x020f8278

00019ad0 <OLEDwritePitchClass>:

void OLEDwritePitchClass(float midi, uint8_t startCursor, OLEDLine line)
{
   19ad0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitchClass(oled_buffer, midi);
   19ad2:	4c15      	ldr	r4, [pc, #84]	; (19b28 <OLEDwritePitchClass+0x58>)
{
   19ad4:	460f      	mov	r7, r1
   19ad6:	b083      	sub	sp, #12
   19ad8:	4606      	mov	r6, r0
	int len = OLEDparsePitchClass(oled_buffer, midi);
   19ada:	4620      	mov	r0, r4
   19adc:	f7fe ffd4 	bl	18a88 <OLEDparsePitchClass>
	uint8_t cursorY = 12 + (16 * (line%2));
   19ae0:	f007 0201 	and.w	r2, r7, #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19ae4:	b236      	sxth	r6, r6
	int len = OLEDparsePitchClass(oled_buffer, midi);
   19ae6:	4605      	mov	r5, r0
	uint8_t cursorY = 12 + (16 * (line%2));
   19ae8:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19aea:	4810      	ldr	r0, [pc, #64]	; (19b2c <OLEDwritePitchClass+0x5c>)
   19aec:	4631      	mov	r1, r6
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19aee:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19af0:	320c      	adds	r2, #12
   19af2:	f7fe ff23 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19af6:	1c7a      	adds	r2, r7, #1
   19af8:	2000      	movs	r0, #0
   19afa:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19afe:	0112      	lsls	r2, r2, #4
   19b00:	4631      	mov	r1, r6
   19b02:	009b      	lsls	r3, r3, #2
   19b04:	e9cd 2000 	strd	r2, r0, [sp]
   19b08:	013a      	lsls	r2, r7, #4
   19b0a:	4808      	ldr	r0, [pc, #32]	; (19b2c <OLEDwritePitchClass+0x5c>)
   19b0c:	f7fe fae0 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19b10:	b145      	cbz	r5, 19b24 <OLEDwritePitchClass+0x54>
		GFXwrite(&theGFX, myCharArray[i]);
   19b12:	4e06      	ldr	r6, [pc, #24]	; (19b2c <OLEDwritePitchClass+0x5c>)
   19b14:	4425      	add	r5, r4
   19b16:	f814 1b01 	ldrb.w	r1, [r4], #1
   19b1a:	4630      	mov	r0, r6
   19b1c:	f7fe fe5c 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19b20:	42a5      	cmp	r5, r4
   19b22:	d1f8      	bne.n	19b16 <OLEDwritePitchClass+0x46>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19b24:	b003      	add	sp, #12
   19b26:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19b28:	020f8258 	.word	0x020f8258
   19b2c:	020f8278 	.word	0x020f8278

00019b30 <OLEDwriteFloat>:
	OLEDwriteLine(oled_buffer, len, line);
}


void OLEDwriteFloat(float input, uint8_t startCursor, OLEDLine line)
{
   19b30:	b5f0      	push	{r4, r5, r6, r7, lr}
   19b32:	ed2d 8b02 	vpush	{d8}
   19b36:	b083      	sub	sp, #12
   19b38:	4606      	mov	r6, r0
   19b3a:	460f      	mov	r7, r1
   19b3c:	eeb0 8a40 	vmov.f32	s16, s0
	int numDigits = 5;
	int numDecimal = 1;

	if (fastabsf(input)<1.0f)
   19b40:	f00f fdc8 	bl	296d4 <fastabsf>
   19b44:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   19b48:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19b4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19b50:	d438      	bmi.n	19bc4 <OLEDwriteFloat+0x94>
	{
		numDigits = 3;
		numDecimal = 2;
	}

	else if (fastabsf(input)<10.0f)
   19b52:	eeb0 0a48 	vmov.f32	s0, s16
   19b56:	f00f fdbd 	bl	296d4 <fastabsf>
   19b5a:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
   19b5e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19b62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19b66:	d530      	bpl.n	19bca <OLEDwriteFloat+0x9a>
   19b68:	2202      	movs	r2, #2
   19b6a:	2104      	movs	r1, #4
	{
		numDigits = 8;
		numDecimal = 0;
	}

	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   19b6c:	4c41      	ldr	r4, [pc, #260]	; (19c74 <OLEDwriteFloat+0x144>)
   19b6e:	eeb0 0a48 	vmov.f32	s0, s16
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19b72:	b236      	sxth	r6, r6
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   19b74:	4620      	mov	r0, r4
   19b76:	f7fe ffb5 	bl	18ae4 <OLEDparseFixedFloat>
	uint8_t cursorY = 12 + (16 * (line%2));
   19b7a:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
   19b7e:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19b80:	4631      	mov	r1, r6
	uint8_t cursorY = 12 + (16 * (line%2));
   19b82:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19b84:	483c      	ldr	r0, [pc, #240]	; (19c78 <OLEDwriteFloat+0x148>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19b86:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19b88:	320c      	adds	r2, #12
   19b8a:	f7fe fed7 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19b8e:	1c7a      	adds	r2, r7, #1
   19b90:	2000      	movs	r0, #0
   19b92:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19b96:	0112      	lsls	r2, r2, #4
   19b98:	4631      	mov	r1, r6
   19b9a:	009b      	lsls	r3, r3, #2
   19b9c:	e9cd 2000 	strd	r2, r0, [sp]
   19ba0:	013a      	lsls	r2, r7, #4
   19ba2:	4835      	ldr	r0, [pc, #212]	; (19c78 <OLEDwriteFloat+0x148>)
   19ba4:	f7fe fa94 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19ba8:	b145      	cbz	r5, 19bbc <OLEDwriteFloat+0x8c>
		GFXwrite(&theGFX, myCharArray[i]);
   19baa:	4e33      	ldr	r6, [pc, #204]	; (19c78 <OLEDwriteFloat+0x148>)
   19bac:	4425      	add	r5, r4
   19bae:	f814 1b01 	ldrb.w	r1, [r4], #1
   19bb2:	4630      	mov	r0, r6
   19bb4:	f7fe fe10 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19bb8:	42ac      	cmp	r4, r5
   19bba:	d1f8      	bne.n	19bae <OLEDwriteFloat+0x7e>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
   19bbc:	b003      	add	sp, #12
   19bbe:	ecbd 8b02 	vpop	{d8}
   19bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19bc4:	2202      	movs	r2, #2
   19bc6:	2103      	movs	r1, #3
   19bc8:	e7d0      	b.n	19b6c <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100.0f)
   19bca:	eeb0 0a48 	vmov.f32	s0, s16
   19bce:	f00f fd81 	bl	296d4 <fastabsf>
   19bd2:	eddf 7a2a 	vldr	s15, [pc, #168]	; 19c7c <OLEDwriteFloat+0x14c>
   19bd6:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19bda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19bde:	d502      	bpl.n	19be6 <OLEDwriteFloat+0xb6>
   19be0:	2202      	movs	r2, #2
   19be2:	2105      	movs	r1, #5
   19be4:	e7c2      	b.n	19b6c <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000.0f)
   19be6:	eeb0 0a48 	vmov.f32	s0, s16
   19bea:	f00f fd73 	bl	296d4 <fastabsf>
   19bee:	eddf 7a24 	vldr	s15, [pc, #144]	; 19c80 <OLEDwriteFloat+0x150>
   19bf2:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19bf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19bfa:	d502      	bpl.n	19c02 <OLEDwriteFloat+0xd2>
   19bfc:	2201      	movs	r2, #1
   19bfe:	2105      	movs	r1, #5
   19c00:	e7b4      	b.n	19b6c <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000.0f)
   19c02:	eeb0 0a48 	vmov.f32	s0, s16
   19c06:	f00f fd65 	bl	296d4 <fastabsf>
   19c0a:	eddf 7a1e 	vldr	s15, [pc, #120]	; 19c84 <OLEDwriteFloat+0x154>
   19c0e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19c12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19c16:	d502      	bpl.n	19c1e <OLEDwriteFloat+0xee>
   19c18:	2200      	movs	r2, #0
   19c1a:	2105      	movs	r1, #5
   19c1c:	e7a6      	b.n	19b6c <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100000.0f)
   19c1e:	eeb0 0a48 	vmov.f32	s0, s16
   19c22:	f00f fd57 	bl	296d4 <fastabsf>
   19c26:	eddf 7a18 	vldr	s15, [pc, #96]	; 19c88 <OLEDwriteFloat+0x158>
   19c2a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19c2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19c32:	d502      	bpl.n	19c3a <OLEDwriteFloat+0x10a>
   19c34:	2200      	movs	r2, #0
   19c36:	2106      	movs	r1, #6
   19c38:	e798      	b.n	19b6c <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000000.0f)
   19c3a:	eeb0 0a48 	vmov.f32	s0, s16
   19c3e:	f00f fd49 	bl	296d4 <fastabsf>
   19c42:	eddf 7a12 	vldr	s15, [pc, #72]	; 19c8c <OLEDwriteFloat+0x15c>
   19c46:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19c4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19c4e:	d502      	bpl.n	19c56 <OLEDwriteFloat+0x126>
   19c50:	2200      	movs	r2, #0
   19c52:	2107      	movs	r1, #7
   19c54:	e78a      	b.n	19b6c <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000000.0f)
   19c56:	eeb0 0a48 	vmov.f32	s0, s16
   19c5a:	f00f fd3b 	bl	296d4 <fastabsf>
   19c5e:	eddf 7a0c 	vldr	s15, [pc, #48]	; 19c90 <OLEDwriteFloat+0x160>
   19c62:	eeb4 0ae7 	vcmpe.f32	s0, s15
   19c66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   19c6a:	d5c7      	bpl.n	19bfc <OLEDwriteFloat+0xcc>
   19c6c:	2200      	movs	r2, #0
   19c6e:	2108      	movs	r1, #8
   19c70:	e77c      	b.n	19b6c <OLEDwriteFloat+0x3c>
   19c72:	bf00      	nop
   19c74:	020f8258 	.word	0x020f8258
   19c78:	020f8278 	.word	0x020f8278
   19c7c:	42c80000 	.word	0x42c80000
   19c80:	447a0000 	.word	0x447a0000
   19c84:	461c4000 	.word	0x461c4000
   19c88:	47c35000 	.word	0x47c35000
   19c8c:	49742400 	.word	0x49742400
   19c90:	4b189680 	.word	0x4b189680

00019c94 <OLED_writeKnobParameter.part.0>:
void OLED_writeKnobParameter(uint8_t whichKnob)
   19c94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19c98:	f8df 9130 	ldr.w	r9, [pc, #304]	; 19dcc <OLED_writeKnobParameter.part.0+0x138>
void OLED_writeKnobParameter(uint8_t whichKnob)
   19c9c:	4606      	mov	r6, r0
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   19c9e:	4f45      	ldr	r7, [pc, #276]	; (19db4 <OLED_writeKnobParameter.part.0+0x120>)
   19ca0:	2405      	movs	r4, #5
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19ca2:	f899 3000 	ldrb.w	r3, [r9]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19ca6:	0080      	lsls	r0, r0, #2
   19ca8:	4943      	ldr	r1, [pc, #268]	; (19db8 <OLED_writeKnobParameter.part.0+0x124>)
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19caa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   19cae:	f8df b120 	ldr.w	fp, [pc, #288]	; 19dd0 <OLED_writeKnobParameter.part.0+0x13c>
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19cb2:	4401      	add	r1, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19cb4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
void OLED_writeKnobParameter(uint8_t whichKnob)
   19cb8:	ed2d 8b02 	vpush	{d8}
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   19cbc:	783a      	ldrb	r2, [r7, #0]
void OLED_writeKnobParameter(uint8_t whichKnob)
   19cbe:	b083      	sub	sp, #12
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19cc0:	6809      	ldr	r1, [r1, #0]
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
   19cc2:	fb14 6402 	smlabb	r4, r4, r2, r6
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19cc6:	4a3d      	ldr	r2, [pc, #244]	; (19dbc <OLED_writeKnobParameter.part.0+0x128>)
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19cc8:	4423      	add	r3, r4
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19cca:	4402      	add	r2, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19ccc:	f85b 0023 	ldr.w	r0, [fp, r3, lsl #2]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
   19cd0:	6011      	str	r1, [r2, #0]
		int len = strlen(knobParamNames[currentPreset][whichParam]);
   19cd2:	f012 fec7 	bl	2ca64 <strlen>
		if (len > 0)
   19cd6:	2800      	cmp	r0, #0
   19cd8:	d066      	beq.n	19da8 <OLED_writeKnobParameter.part.0+0x114>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19cda:	f04f 0800 	mov.w	r8, #0
   19cde:	f04f 0a10 	mov.w	sl, #16
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19ce2:	b2c5      	uxtb	r5, r0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19ce4:	4936      	ldr	r1, [pc, #216]	; (19dc0 <OLED_writeKnobParameter.part.0+0x12c>)
   19ce6:	4837      	ldr	r0, [pc, #220]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
   19ce8:	f7fe fe3a 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19cec:	4641      	mov	r1, r8
   19cee:	4652      	mov	r2, sl
   19cf0:	2380      	movs	r3, #128	; 0x80
   19cf2:	4834      	ldr	r0, [pc, #208]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
   19cf4:	f8cd 8004 	str.w	r8, [sp, #4]
   19cf8:	f8cd a000 	str.w	sl, [sp]
   19cfc:	f7fe f9e8 	bl	180d0 <GFXfillRect>
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   19d00:	f899 3000 	ldrb.w	r3, [r9]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19d04:	4641      	mov	r1, r8
   19d06:	221c      	movs	r2, #28
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   19d08:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19d0c:	482d      	ldr	r0, [pc, #180]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
   19d0e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   19d12:	441c      	add	r4, r3
   19d14:	f85b 4024 	ldr.w	r4, [fp, r4, lsl #2]
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19d18:	f7fe fe10 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19d1c:	2020      	movs	r0, #32
   19d1e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19d22:	f8cd 8004 	str.w	r8, [sp, #4]
   19d26:	4652      	mov	r2, sl
   19d28:	9000      	str	r0, [sp, #0]
   19d2a:	4641      	mov	r1, r8
   19d2c:	009b      	lsls	r3, r3, #2
   19d2e:	4825      	ldr	r0, [pc, #148]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
   19d30:	f7fe f9ce 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19d34:	b155      	cbz	r5, 19d4c <OLED_writeKnobParameter.part.0+0xb8>
   19d36:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
   19d38:	f8df 8088 	ldr.w	r8, [pc, #136]	; 19dc4 <OLED_writeKnobParameter.part.0+0x130>
   19d3c:	4425      	add	r5, r4
   19d3e:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19d42:	4640      	mov	r0, r8
   19d44:	f7fe fd48 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19d48:	42ac      	cmp	r4, r5
   19d4a:	d1f8      	bne.n	19d3e <OLED_writeKnobParameter.part.0+0xaa>
	return GFXgetCursorX(&theGFX);
   19d4c:	481d      	ldr	r0, [pc, #116]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19d4e:	2420      	movs	r4, #32
	return GFXgetCursorX(&theGFX);
   19d50:	f7fe fdf8 	bl	18944 <GFXgetCursorX>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19d54:	221c      	movs	r2, #28
   19d56:	b2c5      	uxtb	r5, r0
   19d58:	481a      	ldr	r0, [pc, #104]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
   19d5a:	4629      	mov	r1, r5
   19d5c:	f7fe fdee 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19d60:	2300      	movs	r3, #0
   19d62:	4629      	mov	r1, r5
   19d64:	2210      	movs	r2, #16
   19d66:	4817      	ldr	r0, [pc, #92]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
   19d68:	e9cd 4300 	strd	r4, r3, [sp]
   19d6c:	230c      	movs	r3, #12
   19d6e:	f7fe f9af 	bl	180d0 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
   19d72:	4621      	mov	r1, r4
   19d74:	4813      	ldr	r0, [pc, #76]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
   19d76:	f7fe fd2f 	bl	187d8 <GFXwrite>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19d7a:	7839      	ldrb	r1, [r7, #0]
   19d7c:	2205      	movs	r2, #5
   19d7e:	4b12      	ldr	r3, [pc, #72]	; (19dc8 <OLED_writeKnobParameter.part.0+0x134>)
	return GFXgetCursorX(&theGFX);
   19d80:	4810      	ldr	r0, [pc, #64]	; (19dc4 <OLED_writeKnobParameter.part.0+0x130>)
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19d82:	fb12 6601 	smlabb	r6, r2, r1, r6
   19d86:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   19d8a:	ed96 8a00 	vldr	s16, [r6]
	return GFXgetCursorX(&theGFX);
   19d8e:	f7fe fdd9 	bl	18944 <GFXgetCursorX>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19d92:	2101      	movs	r1, #1
   19d94:	b2c0      	uxtb	r0, r0
   19d96:	eeb0 0a48 	vmov.f32	s0, s16
}
   19d9a:	b003      	add	sp, #12
   19d9c:	ecbd 8b02 	vpop	{d8}
   19da0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
   19da4:	f7ff bec4 	b.w	19b30 <OLEDwriteFloat>
}
   19da8:	b003      	add	sp, #12
   19daa:	ecbd 8b02 	vpop	{d8}
   19dae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19db2:	bf00      	nop
   19db4:	020e325a 	.word	0x020e325a
   19db8:	020f6f08 	.word	0x020f6f08
   19dbc:	020fb444 	.word	0x020fb444
   19dc0:	000303ac 	.word	0x000303ac
   19dc4:	020f8278 	.word	0x020f8278
   19dc8:	020fb3cc 	.word	0x020fb3cc
   19dcc:	020e3259 	.word	0x020e3259
   19dd0:	020fb56c 	.word	0x020fb56c

00019dd4 <OLED_process>:
{
   19dd4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (writeKnobFlag >= 0)
   19dd8:	4c2d      	ldr	r4, [pc, #180]	; (19e90 <OLED_process+0xbc>)
{
   19dda:	b083      	sub	sp, #12
	if (writeKnobFlag >= 0)
   19ddc:	f994 0000 	ldrsb.w	r0, [r4]
   19de0:	2800      	cmp	r0, #0
   19de2:	db03      	blt.n	19dec <OLED_process+0x18>
	if (whichKnob < KNOB_PAGE_SIZE)
   19de4:	2804      	cmp	r0, #4
   19de6:	dd4e      	ble.n	19e86 <OLED_process+0xb2>
		writeKnobFlag = -1;
   19de8:	23ff      	movs	r3, #255	; 0xff
   19dea:	7023      	strb	r3, [r4, #0]
	if (writeButtonFlag >= 0 && writeActionFlag >= 0) //These should always be set together
   19dec:	4e29      	ldr	r6, [pc, #164]	; (19e94 <OLED_process+0xc0>)
   19dee:	f996 0000 	ldrsb.w	r0, [r6]
   19df2:	2800      	cmp	r0, #0
   19df4:	db44      	blt.n	19e80 <OLED_process+0xac>
   19df6:	4f28      	ldr	r7, [pc, #160]	; (19e98 <OLED_process+0xc4>)
   19df8:	f997 1000 	ldrsb.w	r1, [r7]
   19dfc:	2900      	cmp	r1, #0
   19dfe:	db3f      	blt.n	19e80 <OLED_process+0xac>
	char* str = buttonActionFunctions[currentPreset](whichButton, whichAction);
   19e00:	4a26      	ldr	r2, [pc, #152]	; (19e9c <OLED_process+0xc8>)
   19e02:	b2c9      	uxtb	r1, r1
   19e04:	4b26      	ldr	r3, [pc, #152]	; (19ea0 <OLED_process+0xcc>)
   19e06:	b2c0      	uxtb	r0, r0
   19e08:	7812      	ldrb	r2, [r2, #0]
   19e0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   19e0e:	4798      	blx	r3
   19e10:	4604      	mov	r4, r0
	int len = strlen(str);
   19e12:	f012 fe27 	bl	2ca64 <strlen>
	if (len > 0)
   19e16:	b380      	cbz	r0, 19e7a <OLED_process+0xa6>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19e18:	f04f 0800 	mov.w	r8, #0
   19e1c:	f04f 0910 	mov.w	r9, #16
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19e20:	b2c5      	uxtb	r5, r0
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
   19e22:	4920      	ldr	r1, [pc, #128]	; (19ea4 <OLED_process+0xd0>)
   19e24:	4820      	ldr	r0, [pc, #128]	; (19ea8 <OLED_process+0xd4>)
   19e26:	f7fe fd9b 	bl	18960 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
   19e2a:	2380      	movs	r3, #128	; 0x80
   19e2c:	4641      	mov	r1, r8
   19e2e:	464a      	mov	r2, r9
   19e30:	481d      	ldr	r0, [pc, #116]	; (19ea8 <OLED_process+0xd4>)
   19e32:	f8cd 8004 	str.w	r8, [sp, #4]
   19e36:	f8cd 9000 	str.w	r9, [sp]
   19e3a:	f7fe f949 	bl	180d0 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
   19e3e:	4641      	mov	r1, r8
   19e40:	221c      	movs	r2, #28
   19e42:	4819      	ldr	r0, [pc, #100]	; (19ea8 <OLED_process+0xd4>)
   19e44:	f7fe fd7a 	bl	1893c <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
   19e48:	2020      	movs	r0, #32
   19e4a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   19e4e:	f8cd 8004 	str.w	r8, [sp, #4]
   19e52:	9000      	str	r0, [sp, #0]
   19e54:	464a      	mov	r2, r9
   19e56:	4641      	mov	r1, r8
   19e58:	009b      	lsls	r3, r3, #2
   19e5a:	4813      	ldr	r0, [pc, #76]	; (19ea8 <OLED_process+0xd4>)
   19e5c:	f7fe f938 	bl	180d0 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
   19e60:	b15d      	cbz	r5, 19e7a <OLED_process+0xa6>
   19e62:	4425      	add	r5, r4
		GFXwrite(&theGFX, myCharArray[i]);
   19e64:	f8df 8040 	ldr.w	r8, [pc, #64]	; 19ea8 <OLED_process+0xd4>
   19e68:	3c01      	subs	r4, #1
   19e6a:	3d01      	subs	r5, #1
   19e6c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   19e70:	4640      	mov	r0, r8
   19e72:	f7fe fcb1 	bl	187d8 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
   19e76:	42ac      	cmp	r4, r5
   19e78:	d1f8      	bne.n	19e6c <OLED_process+0x98>
		writeButtonFlag = -1;
   19e7a:	23ff      	movs	r3, #255	; 0xff
   19e7c:	7033      	strb	r3, [r6, #0]
		writeActionFlag = -1;
   19e7e:	703b      	strb	r3, [r7, #0]
}
   19e80:	b003      	add	sp, #12
   19e82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   19e86:	b2c0      	uxtb	r0, r0
   19e88:	f7ff ff04 	bl	19c94 <OLED_writeKnobParameter.part.0>
   19e8c:	e7ac      	b.n	19de8 <OLED_process+0x14>
   19e8e:	bf00      	nop
   19e90:	00062b63 	.word	0x00062b63
   19e94:	00062b62 	.word	0x00062b62
   19e98:	00062b61 	.word	0x00062b61
   19e9c:	020e3259 	.word	0x020e3259
   19ea0:	020fbc80 	.word	0x020fbc80
   19ea4:	000303ac 	.word	0x000303ac
   19ea8:	020f8278 	.word	0x020f8278

00019eac <OLEDgetCursor>:
	}
}

int16_t OLEDgetCursor()
{
	return GFXgetCursorX(&theGFX);
   19eac:	4801      	ldr	r0, [pc, #4]	; (19eb4 <OLEDgetCursor+0x8>)
   19eae:	f7fe bd49 	b.w	18944 <GFXgetCursorX>
   19eb2:	bf00      	nop
   19eb4:	020f8278 	.word	0x020f8278

00019eb8 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
   19eb8:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
   19eba:	4b07      	ldr	r3, [pc, #28]	; (19ed8 <MX_RNG_Init+0x20>)
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
   19ebc:	2100      	movs	r1, #0
  hrng.Instance = RNG;
   19ebe:	4a07      	ldr	r2, [pc, #28]	; (19edc <MX_RNG_Init+0x24>)
  if (HAL_RNG_Init(&hrng) != HAL_OK)
   19ec0:	4618      	mov	r0, r3
  hrng.Instance = RNG;
   19ec2:	e9c3 2100 	strd	r2, r1, [r3]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
   19ec6:	f7f6 faeb 	bl	104a0 <HAL_RNG_Init>
   19eca:	b900      	cbnz	r0, 19ece <MX_RNG_Init+0x16>
  {
    Error_Handler();
  }

}
   19ecc:	bd08      	pop	{r3, pc}
   19ece:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
   19ed2:	f7ff baf3 	b.w	194bc <Error_Handler>
   19ed6:	bf00      	nop
   19ed8:	020f829c 	.word	0x020f829c
   19edc:	48021800 	.word	0x48021800

00019ee0 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
   19ee0:	6802      	ldr	r2, [r0, #0]
   19ee2:	4b0a      	ldr	r3, [pc, #40]	; (19f0c <HAL_RNG_MspInit+0x2c>)
   19ee4:	429a      	cmp	r2, r3
   19ee6:	d000      	beq.n	19eea <HAL_RNG_MspInit+0xa>
   19ee8:	4770      	bx	lr
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
   19eea:	4b09      	ldr	r3, [pc, #36]	; (19f10 <HAL_RNG_MspInit+0x30>)
{
   19eec:	b082      	sub	sp, #8
    __HAL_RCC_RNG_CLK_ENABLE();
   19eee:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
   19ef2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   19ef6:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
   19efa:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
   19efe:	f003 0340 	and.w	r3, r3, #64	; 0x40
   19f02:	9301      	str	r3, [sp, #4]
   19f04:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
   19f06:	b002      	add	sp, #8
   19f08:	4770      	bx	lr
   19f0a:	bf00      	nop
   19f0c:	48021800 	.word	0x48021800
   19f10:	58024400 	.word	0x58024400

00019f14 <MX_SAI1_Init>:
DMA_HandleTypeDef hdma_sai1_a;
DMA_HandleTypeDef hdma_sai1_b;

/* SAI1 init function */
void MX_SAI1_Init(void)
{
   19f14:	b570      	push	{r4, r5, r6, lr}

  hsai_BlockA1.Instance = SAI1_Block_A;
   19f16:	481a      	ldr	r0, [pc, #104]	; (19f80 <MX_SAI1_Init+0x6c>)
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
   19f18:	2500      	movs	r5, #0
  hsai_BlockA1.Instance = SAI1_Block_A;
   19f1a:	4c1a      	ldr	r4, [pc, #104]	; (19f84 <MX_SAI1_Init+0x70>)
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   19f1c:	2101      	movs	r1, #1
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
   19f1e:	f64b 3280 	movw	r2, #48000	; 0xbb80
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockA1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f22:	2302      	movs	r3, #2
  hsai_BlockA1.Instance = SAI1_Block_A;
   19f24:	6020      	str	r0, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f26:	4620      	mov	r0, r4
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   19f28:	61e1      	str	r1, [r4, #28]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f2a:	4629      	mov	r1, r5
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
   19f2c:	6222      	str	r2, [r4, #32]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f2e:	461a      	mov	r2, r3
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
   19f30:	60e5      	str	r5, [r4, #12]
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
   19f32:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
   19f34:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
   19f38:	e9c4 5505 	strd	r5, r5, [r4, #20]
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
   19f3c:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f40:	f7f6 fb36 	bl	105b0 <HAL_SAI_InitProtocol>
   19f44:	b9c8      	cbnz	r0, 19f7a <MX_SAI1_Init+0x66>
  {
    Error_Handler();
  }

  hsai_BlockB1.Instance = SAI1_Block_B;
   19f46:	4c10      	ldr	r4, [pc, #64]	; (19f88 <MX_SAI1_Init+0x74>)
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
   19f48:	2500      	movs	r5, #0
  hsai_BlockB1.Instance = SAI1_Block_B;
   19f4a:	4910      	ldr	r1, [pc, #64]	; (19f8c <MX_SAI1_Init+0x78>)
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
   19f4c:	2203      	movs	r2, #3
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockB1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f4e:	2302      	movs	r3, #2
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
   19f50:	2601      	movs	r6, #1
  hsai_BlockB1.Instance = SAI1_Block_B;
   19f52:	6021      	str	r1, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f54:	4620      	mov	r0, r4
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
   19f56:	6062      	str	r2, [r4, #4]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f58:	4629      	mov	r1, r5
   19f5a:	461a      	mov	r2, r3
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
   19f5c:	60a6      	str	r6, [r4, #8]
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
   19f5e:	61e6      	str	r6, [r4, #28]
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
   19f60:	6165      	str	r5, [r4, #20]
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
   19f62:	60e5      	str	r5, [r4, #12]
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
   19f64:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
   19f66:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
   19f6a:	f7f6 fb21 	bl	105b0 <HAL_SAI_InitProtocol>
   19f6e:	b900      	cbnz	r0, 19f72 <MX_SAI1_Init+0x5e>
  {
    Error_Handler();
  }

}
   19f70:	bd70      	pop	{r4, r5, r6, pc}
   19f72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
   19f76:	f7ff baa1 	b.w	194bc <Error_Handler>
    Error_Handler();
   19f7a:	f7ff fa9f 	bl	194bc <Error_Handler>
   19f7e:	e7e2      	b.n	19f46 <MX_SAI1_Init+0x32>
   19f80:	40015804 	.word	0x40015804
   19f84:	020f8438 	.word	0x020f8438
   19f88:	020f82b0 	.word	0x020f82b0
   19f8c:	40015824 	.word	0x40015824

00019f90 <HAL_SAI_MspInit>:
static uint32_t SAI1_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{
   19f90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(hsai->Instance==SAI1_Block_A)
   19f94:	4a5e      	ldr	r2, [pc, #376]	; (1a110 <HAL_SAI_MspInit+0x180>)
{
   19f96:	b088      	sub	sp, #32
    if(hsai->Instance==SAI1_Block_A)
   19f98:	6803      	ldr	r3, [r0, #0]
{
   19f9a:	4605      	mov	r5, r0
    if(hsai->Instance==SAI1_Block_A)
   19f9c:	4293      	cmp	r3, r2
   19f9e:	d040      	beq.n	1a022 <HAL_SAI_MspInit+0x92>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
    }
    if(hsai->Instance==SAI1_Block_B)
   19fa0:	4a5c      	ldr	r2, [pc, #368]	; (1a114 <HAL_SAI_MspInit+0x184>)
   19fa2:	4293      	cmp	r3, r2
   19fa4:	d002      	beq.n	19fac <HAL_SAI_MspInit+0x1c>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
    }
}
   19fa6:	b008      	add	sp, #32
   19fa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (SAI1_client == 0)
   19fac:	4c5a      	ldr	r4, [pc, #360]	; (1a118 <HAL_SAI_MspInit+0x188>)
   19fae:	6822      	ldr	r2, [r4, #0]
   19fb0:	2a00      	cmp	r2, #0
   19fb2:	d07b      	beq.n	1a0ac <HAL_SAI_MspInit+0x11c>
    SAI1_client ++;
   19fb4:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_3;
   19fb6:	2008      	movs	r0, #8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19fb8:	2600      	movs	r6, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19fba:	2302      	movs	r3, #2
    SAI1_client ++;
   19fbc:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19fbe:	2206      	movs	r2, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19fc0:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_3;
   19fc2:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19fc4:	4855      	ldr	r0, [pc, #340]	; (1a11c <HAL_SAI_MspInit+0x18c>)
    hdma_sai1_b.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
   19fc6:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_b.Instance = DMA1_Stream2;
   19fca:	4c55      	ldr	r4, [pc, #340]	; (1a120 <HAL_SAI_MspInit+0x190>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   19fcc:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   19fce:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   19fd0:	9207      	str	r2, [sp, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   19fd2:	9605      	str	r6, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   19fd4:	f7f1 fdf4 	bl	bbc0 <HAL_GPIO_Init>
    hdma_sai1_b.Instance = DMA1_Stream2;
   19fd8:	4a52      	ldr	r2, [pc, #328]	; (1a124 <HAL_SAI_MspInit+0x194>)
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
   19fda:	2358      	movs	r3, #88	; 0x58
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   19fdc:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    hdma_sai1_b.Init.MemInc = DMA_MINC_ENABLE;
   19fe0:	f44f 6c80 	mov.w	ip, #1024	; 0x400
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
   19fe4:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_b.Instance = DMA1_Stream2;
   19fe8:	6022      	str	r2, [r4, #0]
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
   19fea:	6063      	str	r3, [r4, #4]
    hdma_sai1_b.Init.Priority = DMA_PRIORITY_VERY_HIGH;
   19fec:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   19ff0:	2304      	movs	r3, #4
    hdma_sai1_b.Init.Direction = DMA_PERIPH_TO_MEMORY;
   19ff2:	60a6      	str	r6, [r4, #8]
    hdma_sai1_b.Init.PeriphInc = DMA_PINC_DISABLE;
   19ff4:	60e6      	str	r6, [r4, #12]
    hdma_sai1_b.Init.PeriphBurst = DMA_PBURST_SINGLE;
   19ff6:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   19ff8:	e9c4 c004 	strd	ip, r0, [r4, #16]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
   19ffc:	4620      	mov	r0, r4
    hdma_sai1_b.Init.MemBurst = DMA_MBURST_SINGLE;
   19ffe:	e9c4 660a 	strd	r6, r6, [r4, #40]	; 0x28
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
   1a002:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1a006:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
   1a00a:	f7ef feaf 	bl	9d6c <HAL_DMA_Init>
   1a00e:	2800      	cmp	r0, #0
   1a010:	d162      	bne.n	1a0d8 <HAL_SAI_MspInit+0x148>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
   1a012:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
   1a016:	63a5      	str	r5, [r4, #56]	; 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
   1a018:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
}
   1a01c:	b008      	add	sp, #32
   1a01e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (SAI1_client == 0)
   1a022:	4c3d      	ldr	r4, [pc, #244]	; (1a118 <HAL_SAI_MspInit+0x188>)
   1a024:	6822      	ldr	r2, [r4, #0]
   1a026:	2a00      	cmp	r2, #0
   1a028:	d05c      	beq.n	1a0e4 <HAL_SAI_MspInit+0x154>
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
   1a02a:	2024      	movs	r0, #36	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a02c:	2600      	movs	r6, #0
    SAI1_client ++;
   1a02e:	3201      	adds	r2, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a030:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1a032:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1a034:	f04f 0806 	mov.w	r8, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1a038:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
   1a03a:	9003      	str	r0, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1a03c:	4837      	ldr	r0, [pc, #220]	; (1a11c <HAL_SAI_MspInit+0x18c>)
    SAI1_client ++;
   1a03e:	6022      	str	r2, [r4, #0]
    hdma_sai1_a.Instance = DMA1_Stream1;
   1a040:	4c39      	ldr	r4, [pc, #228]	; (1a128 <HAL_SAI_MspInit+0x198>)
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1a042:	e9cd 3806 	strd	r3, r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a046:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1a04a:	f7f1 fdb9 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
   1a04e:	2350      	movs	r3, #80	; 0x50
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1a050:	a903      	add	r1, sp, #12
   1a052:	4832      	ldr	r0, [pc, #200]	; (1a11c <HAL_SAI_MspInit+0x18c>)
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
   1a054:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
   1a056:	e9cd 7806 	strd	r7, r8, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a05a:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   1a05e:	f7f1 fdaf 	bl	bbc0 <HAL_GPIO_Init>
    hdma_sai1_a.Instance = DMA1_Stream1;
   1a062:	4b32      	ldr	r3, [pc, #200]	; (1a12c <HAL_SAI_MspInit+0x19c>)
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1a064:	2040      	movs	r0, #64	; 0x40
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
   1a066:	f04f 0857 	mov.w	r8, #87	; 0x57
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
   1a06a:	f44f 6e80 	mov.w	lr, #1024	; 0x400
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   1a06e:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
   1a072:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
   1a076:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_VERY_HIGH;
   1a07a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_a.Instance = DMA1_Stream1;
   1a07e:	6023      	str	r3, [r4, #0]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1a080:	2304      	movs	r3, #4
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
   1a082:	60e6      	str	r6, [r4, #12]
    hdma_sai1_a.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
   1a084:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_a.Init.MemBurst = DMA_MBURST_SINGLE;
   1a086:	62e6      	str	r6, [r4, #44]	; 0x2c
    hdma_sai1_a.Init.PeriphBurst = DMA_PBURST_SINGLE;
   1a088:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
   1a08a:	e9c4 8001 	strd	r8, r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
   1a08e:	4620      	mov	r0, r4
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
   1a090:	e9c4 ec04 	strd	lr, ip, [r4, #16]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
   1a094:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   1a098:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
   1a09c:	f7ef fe66 	bl	9d6c <HAL_DMA_Init>
   1a0a0:	b9e8      	cbnz	r0, 1a0de <HAL_SAI_MspInit+0x14e>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
   1a0a2:	63a5      	str	r5, [r4, #56]	; 0x38
   1a0a4:	682b      	ldr	r3, [r5, #0]
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
   1a0a6:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
   1a0aa:	e779      	b.n	19fa0 <HAL_SAI_MspInit+0x10>
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a0ac:	4b20      	ldr	r3, [pc, #128]	; (1a130 <HAL_SAI_MspInit+0x1a0>)
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a0ae:	2102      	movs	r1, #2
   1a0b0:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a0b2:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
   1a0b6:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
   1a0ba:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
   1a0be:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   1a0c2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1a0c6:	9302      	str	r3, [sp, #8]
   1a0c8:	9b02      	ldr	r3, [sp, #8]
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a0ca:	f7ef fc83 	bl	99d4 <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ(SAI1_IRQn);
   1a0ce:	2057      	movs	r0, #87	; 0x57
   1a0d0:	f7ef fcc6 	bl	9a60 <HAL_NVIC_EnableIRQ>
   1a0d4:	6822      	ldr	r2, [r4, #0]
   1a0d6:	e76d      	b.n	19fb4 <HAL_SAI_MspInit+0x24>
      Error_Handler();
   1a0d8:	f7ff f9f0 	bl	194bc <Error_Handler>
   1a0dc:	e799      	b.n	1a012 <HAL_SAI_MspInit+0x82>
      Error_Handler();
   1a0de:	f7ff f9ed 	bl	194bc <Error_Handler>
   1a0e2:	e7de      	b.n	1a0a2 <HAL_SAI_MspInit+0x112>
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a0e4:	4b12      	ldr	r3, [pc, #72]	; (1a130 <HAL_SAI_MspInit+0x1a0>)
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a0e6:	2102      	movs	r1, #2
   1a0e8:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
   1a0ea:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
   1a0ee:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
   1a0f2:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
   1a0f6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   1a0fa:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
   1a0fe:	9301      	str	r3, [sp, #4]
   1a100:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
   1a102:	f7ef fc67 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SAI1_IRQn);
   1a106:	2057      	movs	r0, #87	; 0x57
   1a108:	f7ef fcaa 	bl	9a60 <HAL_NVIC_EnableIRQ>
   1a10c:	6822      	ldr	r2, [r4, #0]
   1a10e:	e78c      	b.n	1a02a <HAL_SAI_MspInit+0x9a>
   1a110:	40015804 	.word	0x40015804
   1a114:	40015824 	.word	0x40015824
   1a118:	020e3114 	.word	0x020e3114
   1a11c:	58021000 	.word	0x58021000
   1a120:	020f83c0 	.word	0x020f83c0
   1a124:	40020040 	.word	0x40020040
   1a128:	020f8348 	.word	0x020f8348
   1a12c:	40020028 	.word	0x40020028
   1a130:	58024400 	.word	0x58024400

0001a134 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
   1a134:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;  
   1a136:	4c0a      	ldr	r4, [pc, #40]	; (1a160 <SD_initialize+0x2c>)
   1a138:	2501      	movs	r5, #1
   1a13a:	7025      	strb	r5, [r4, #0]

#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
   1a13c:	f7fd f946 	bl	173cc <BSP_SD_Init>
   1a140:	b108      	cbz	r0, 1a146 <SD_initialize+0x12>

#else
  Stat = SD_CheckStatus(lun);
#endif

  return Stat;
   1a142:	7820      	ldrb	r0, [r4, #0]
}
   1a144:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
   1a146:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
   1a148:	f7fd f920 	bl	1738c <BSP_SD_GetCardState>
   1a14c:	b918      	cbnz	r0, 1a156 <SD_initialize+0x22>
    Stat &= ~STA_NOINIT;
   1a14e:	7823      	ldrb	r3, [r4, #0]
   1a150:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   1a154:	7023      	strb	r3, [r4, #0]
  return Stat;
   1a156:	7823      	ldrb	r3, [r4, #0]
   1a158:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
   1a15a:	7023      	strb	r3, [r4, #0]
  return Stat;
   1a15c:	7820      	ldrb	r0, [r4, #0]
}
   1a15e:	bd38      	pop	{r3, r4, r5, pc}
   1a160:	000628cc 	.word	0x000628cc

0001a164 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
   1a164:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
   1a166:	2301      	movs	r3, #1
   1a168:	4c05      	ldr	r4, [pc, #20]	; (1a180 <SD_status+0x1c>)
   1a16a:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
   1a16c:	f7fd f90e 	bl	1738c <BSP_SD_GetCardState>
   1a170:	b918      	cbnz	r0, 1a17a <SD_status+0x16>
    Stat &= ~STA_NOINIT;
   1a172:	7823      	ldrb	r3, [r4, #0]
   1a174:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   1a178:	7023      	strb	r3, [r4, #0]
  return Stat;
   1a17a:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
   1a17c:	bd10      	pop	{r4, pc}
   1a17e:	bf00      	nop
   1a180:	000628cc 	.word	0x000628cc

0001a184 <SD_read>:
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
              
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
   1a184:	b508      	push	{r3, lr}
   1a186:	4608      	mov	r0, r1
   1a188:	4611      	mov	r1, r2
   1a18a:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
   1a18c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a190:	f7fd f8d8 	bl	17344 <BSP_SD_ReadBlocks>
   1a194:	b920      	cbnz	r0, 1a1a0 <SD_read+0x1c>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
   1a196:	f7fd f8f9 	bl	1738c <BSP_SD_GetCardState>
   1a19a:	2800      	cmp	r0, #0
   1a19c:	d1fb      	bne.n	1a196 <SD_read+0x12>
    }
    res = RES_OK;
  }

  return res;
}
   1a19e:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
   1a1a0:	2001      	movs	r0, #1
}
   1a1a2:	bd08      	pop	{r3, pc}

0001a1a4 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
   1a1a4:	4b16      	ldr	r3, [pc, #88]	; (1a200 <SD_ioctl+0x5c>)
   1a1a6:	781b      	ldrb	r3, [r3, #0]
   1a1a8:	07db      	lsls	r3, r3, #31
   1a1aa:	d408      	bmi.n	1a1be <SD_ioctl+0x1a>
{
   1a1ac:	b510      	push	{r4, lr}
   1a1ae:	4614      	mov	r4, r2
   1a1b0:	b08a      	sub	sp, #40	; 0x28

  switch (cmd)
   1a1b2:	2903      	cmp	r1, #3
   1a1b4:	d821      	bhi.n	1a1fa <SD_ioctl+0x56>
   1a1b6:	e8df f001 	tbb	[pc, r1]
   1a1ba:	0704      	.short	0x0704
   1a1bc:	170f      	.short	0x170f
  if (Stat & STA_NOINIT) return RES_NOTRDY;
   1a1be:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
   1a1c0:	4770      	bx	lr
    res = RES_OK;
   1a1c2:	2000      	movs	r0, #0
}
   1a1c4:	b00a      	add	sp, #40	; 0x28
   1a1c6:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1a1c8:	a801      	add	r0, sp, #4
   1a1ca:	f7fd f8e9 	bl	173a0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
   1a1ce:	9b07      	ldr	r3, [sp, #28]
    res = RES_OK;
   1a1d0:	2000      	movs	r0, #0
    *(DWORD*)buff = CardInfo.LogBlockNbr;
   1a1d2:	6023      	str	r3, [r4, #0]
}
   1a1d4:	b00a      	add	sp, #40	; 0x28
   1a1d6:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1a1d8:	a801      	add	r0, sp, #4
   1a1da:	f7fd f8e1 	bl	173a0 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
   1a1de:	9b08      	ldr	r3, [sp, #32]
    res = RES_OK;
   1a1e0:	2000      	movs	r0, #0
    *(WORD*)buff = CardInfo.LogBlockSize;
   1a1e2:	8023      	strh	r3, [r4, #0]
}
   1a1e4:	b00a      	add	sp, #40	; 0x28
   1a1e6:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
   1a1e8:	a801      	add	r0, sp, #4
   1a1ea:	f7fd f8d9 	bl	173a0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
   1a1ee:	9b08      	ldr	r3, [sp, #32]
   1a1f0:	2000      	movs	r0, #0
   1a1f2:	0a5b      	lsrs	r3, r3, #9
   1a1f4:	6023      	str	r3, [r4, #0]
}
   1a1f6:	b00a      	add	sp, #40	; 0x28
   1a1f8:	bd10      	pop	{r4, pc}
    res = RES_PARERR;
   1a1fa:	2004      	movs	r0, #4
}
   1a1fc:	b00a      	add	sp, #40	; 0x28
   1a1fe:	bd10      	pop	{r4, pc}
   1a200:	000628cc 	.word	0x000628cc

0001a204 <SD_write>:
{
   1a204:	b508      	push	{r3, lr}
   1a206:	4608      	mov	r0, r1
   1a208:	4611      	mov	r1, r2
   1a20a:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
   1a20c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a210:	f7fd f8aa 	bl	17368 <BSP_SD_WriteBlocks>
   1a214:	b920      	cbnz	r0, 1a220 <SD_write+0x1c>
    while(BSP_SD_GetCardState()!= MSD_OK)
   1a216:	f7fd f8b9 	bl	1738c <BSP_SD_GetCardState>
   1a21a:	2800      	cmp	r0, #0
   1a21c:	d1fb      	bne.n	1a216 <SD_write+0x12>
}
   1a21e:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
   1a220:	2001      	movs	r0, #1
}
   1a222:	bd08      	pop	{r3, pc}

0001a224 <MX_SDMMC1_SD_Init>:
SD_HandleTypeDef hsd1;

/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{
   1a224:	b410      	push	{r4}

  hsd1.Instance = SDMMC1;
   1a226:	4b08      	ldr	r3, [pc, #32]	; (1a248 <MX_SDMMC1_SD_Init+0x24>)
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
   1a228:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
   1a22c:	4807      	ldr	r0, [pc, #28]	; (1a24c <MX_SDMMC1_SD_Init+0x28>)
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd1.Init.ClockDiv = 0;
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
   1a22e:	2101      	movs	r1, #1
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
   1a230:	2200      	movs	r2, #0
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
   1a232:	60dc      	str	r4, [r3, #12]
  hsd1.Instance = SDMMC1;
   1a234:	6018      	str	r0, [r3, #0]
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
   1a236:	6199      	str	r1, [r3, #24]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
   1a238:	e9c3 2201 	strd	r2, r2, [r3, #4]
  hsd1.Init.ClockDiv = 0;
   1a23c:	e9c3 2204 	strd	r2, r2, [r3, #16]

}
   1a240:	f85d 4b04 	ldr.w	r4, [sp], #4
   1a244:	4770      	bx	lr
   1a246:	bf00      	nop
   1a248:	020f84d0 	.word	0x020f84d0
   1a24c:	52007000 	.word	0x52007000

0001a250 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
   1a250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(sdHandle->Instance==SDMMC1)
   1a254:	4b2e      	ldr	r3, [pc, #184]	; (1a310 <HAL_SD_MspInit+0xc0>)
{
   1a256:	b088      	sub	sp, #32
  if(sdHandle->Instance==SDMMC1)
   1a258:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a25a:	2400      	movs	r4, #0
  if(sdHandle->Instance==SDMMC1)
   1a25c:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   1a25e:	9407      	str	r4, [sp, #28]
   1a260:	e9cd 4403 	strd	r4, r4, [sp, #12]
   1a264:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(sdHandle->Instance==SDMMC1)
   1a268:	d002      	beq.n	1a270 <HAL_SD_MspInit+0x20>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
   1a26a:	b008      	add	sp, #32
   1a26c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1a270:	4b28      	ldr	r3, [pc, #160]	; (1a314 <HAL_SD_MspInit+0xc4>)
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a272:	250c      	movs	r5, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
   1a274:	f44f 6070 	mov.w	r0, #3840	; 0xf00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a278:	2702      	movs	r7, #2
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1a27a:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1a27e:	2603      	movs	r6, #3
    GPIO_InitStruct.Pull = GPIO_PULLUP;
   1a280:	f04f 0801 	mov.w	r8, #1
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a284:	eb0d 0105 	add.w	r1, sp, r5
    __HAL_RCC_SDMMC1_CLK_ENABLE();
   1a288:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   1a28c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
   1a290:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
   1a294:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
   1a298:	9200      	str	r2, [sp, #0]
   1a29a:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
   1a29c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1a2a0:	f042 0204 	orr.w	r2, r2, #4
   1a2a4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1a2a8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1a2ac:	f002 0204 	and.w	r2, r2, #4
   1a2b0:	9201      	str	r2, [sp, #4]
   1a2b2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1a2b4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1a2b8:	f042 0208 	orr.w	r2, r2, #8
   1a2bc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   1a2c0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
   1a2c4:	9003      	str	r0, [sp, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1a2c6:	f003 0308 	and.w	r3, r3, #8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a2ca:	4813      	ldr	r0, [pc, #76]	; (1a318 <HAL_SD_MspInit+0xc8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a2cc:	9704      	str	r7, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
   1a2ce:	9302      	str	r3, [sp, #8]
   1a2d0:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a2d2:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   1a2d4:	e9cd 8605 	strd	r8, r6, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a2d8:	f7f1 fc72 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12;
   1a2dc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a2e0:	eb0d 0105 	add.w	r1, sp, r5
   1a2e4:	480c      	ldr	r0, [pc, #48]	; (1a318 <HAL_SD_MspInit+0xc8>)
    GPIO_InitStruct.Pin = GPIO_PIN_12;
   1a2e6:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   1a2e8:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
   1a2ea:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a2ec:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   1a2f0:	f7f1 fc66 	bl	bbc0 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
   1a2f4:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a2f6:	eb0d 0105 	add.w	r1, sp, r5
   1a2fa:	4808      	ldr	r0, [pc, #32]	; (1a31c <HAL_SD_MspInit+0xcc>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
   1a2fc:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
   1a2fe:	e9cd 7804 	strd	r7, r8, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
   1a302:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   1a306:	f7f1 fc5b 	bl	bbc0 <HAL_GPIO_Init>
}
   1a30a:	b008      	add	sp, #32
   1a30c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a310:	52007000 	.word	0x52007000
   1a314:	58024400 	.word	0x58024400
   1a318:	58020800 	.word	0x58020800
   1a31c:	58020c00 	.word	0x58020c00

0001a320 <initGlobalSFXObjects>:
float oversamplerArray[MAX_OVERSAMPLER_RATIO];



void initGlobalSFXObjects()
{
   1a320:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
void calculateNoteArray()
{
	for (int i = 0; i < 128; i++)
	{
		float tempNote = i;
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a324:	4beb      	ldr	r3, [pc, #940]	; (1a6d4 <initGlobalSFXObjects+0x3b4>)
	for (int i = 0; i < 128; i++)
   1a326:	2000      	movs	r0, #0
   1a328:	4ceb      	ldr	r4, [pc, #940]	; (1a6d8 <initGlobalSFXObjects+0x3b8>)
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a32a:	781f      	ldrb	r7, [r3, #0]
   1a32c:	4eeb      	ldr	r6, [pc, #940]	; (1a6dc <initGlobalSFXObjects+0x3bc>)
   1a32e:	4dec      	ldr	r5, [pc, #944]	; (1a6e0 <initGlobalSFXObjects+0x3c0>)
		float tempNote = i;
   1a330:	ee07 0a90 	vmov	s15, r0
	for (int i = 0; i < 128; i++)
   1a334:	3001      	adds	r0, #1
		float tempNote = i;
   1a336:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	for (int i = 0; i < 128; i++)
   1a33a:	2880      	cmp	r0, #128	; 0x80
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1a33c:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1a340:	ee17 3a90 	vmov	r3, s15
   1a344:	eba3 0307 	sub.w	r3, r3, r7
   1a348:	fb85 2103 	smull	r2, r1, r5, r3
   1a34c:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1a350:	ebc2 0261 	rsb	r2, r2, r1, asr #1
   1a354:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1a358:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1a35c:	ee07 3a90 	vmov	s15, r3
   1a360:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1a364:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1a368:	ee17 3a90 	vmov	r3, s15
   1a36c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   1a370:	edd3 7a00 	vldr	s15, [r3]
   1a374:	ee37 7a87 	vadd.f32	s14, s15, s14
		notes[i] = tunedNote;
   1a378:	eca4 7a01 	vstmia	r4!, {s14}
	for (int i = 0; i < 128; i++)
   1a37c:	d1d8      	bne.n	1a330 <initGlobalSFXObjects+0x10>
   1a37e:	4cd9      	ldr	r4, [pc, #868]	; (1a6e4 <initGlobalSFXObjects+0x3c4>)
		tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1a380:	2600      	movs	r6, #0
   1a382:	f8df a3b4 	ldr.w	sl, [pc, #948]	; 1a738 <initGlobalSFXObjects+0x418>
	tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
   1a386:	2108      	movs	r1, #8
   1a388:	f104 0720 	add.w	r7, r4, #32
		tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1a38c:	4dd6      	ldr	r5, [pc, #856]	; (1a6e8 <initGlobalSFXObjects+0x3c8>)
	tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
   1a38e:	4ad6      	ldr	r2, [pc, #856]	; (1a6e8 <initGlobalSFXObjects+0x3c8>)
   1a390:	48d6      	ldr	r0, [pc, #856]	; (1a6ec <initGlobalSFXObjects+0x3cc>)
   1a392:	f00f fe07 	bl	29fa4 <tSimplePoly_initToPool>
		tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
   1a396:	4620      	mov	r0, r4
   1a398:	3404      	adds	r4, #4
   1a39a:	4629      	mov	r1, r5
   1a39c:	eddf 0ad4 	vldr	s1, [pc, #848]	; 1a6f0 <initGlobalSFXObjects+0x3d0>
   1a3a0:	ed9f 0ad4 	vldr	s0, [pc, #848]	; 1a6f4 <initGlobalSFXObjects+0x3d4>
   1a3a4:	f00d fda0 	bl	27ee8 <tExpSmooth_initToPool>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1a3a8:	42a7      	cmp	r7, r4
   1a3aa:	d1f4      	bne.n	1a396 <initGlobalSFXObjects+0x76>
	tExpSmooth_init(&comp, 1.0f, 0.01f);
   1a3ac:	eddf 0ad2 	vldr	s1, [pc, #840]	; 1a6f8 <initGlobalSFXObjects+0x3d8>
   1a3b0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1a3b4:	48d1      	ldr	r0, [pc, #836]	; (1a6fc <initGlobalSFXObjects+0x3dc>)
	defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
   1a3b6:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
	tExpSmooth_init(&comp, 1.0f, 0.01f);
   1a3ba:	f00d fd6b 	bl	27e94 <tExpSmooth_init>
	LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
   1a3be:	2180      	movs	r1, #128	; 0x80
   1a3c0:	eddf 1acf 	vldr	s3, [pc, #828]	; 1a700 <initGlobalSFXObjects+0x3e0>
   1a3c4:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
   1a3c8:	ed9f 1aca 	vldr	s2, [pc, #808]	; 1a6f4 <initGlobalSFXObjects+0x3d4>
   1a3cc:	ed9f 0acd 	vldr	s0, [pc, #820]	; 1a704 <initGlobalSFXObjects+0x3e4>
   1a3d0:	48cd      	ldr	r0, [pc, #820]	; (1a708 <initGlobalSFXObjects+0x3e8>)
   1a3d2:	f00f facd 	bl	29970 <LEAF_generate_exp>
	LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
   1a3d6:	f44f 7100 	mov.w	r1, #512	; 0x200
   1a3da:	48cc      	ldr	r0, [pc, #816]	; (1a70c <initGlobalSFXObjects+0x3ec>)
   1a3dc:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   1a3e0:	eddf 1ac7 	vldr	s3, [pc, #796]	; 1a700 <initGlobalSFXObjects+0x3e0>
   1a3e4:	eddf 0ac3 	vldr	s1, [pc, #780]	; 1a6f4 <initGlobalSFXObjects+0x3d4>
   1a3e8:	ed9f 0ac9 	vldr	s0, [pc, #804]	; 1a710 <initGlobalSFXObjects+0x3f0>
   1a3ec:	f00f fac0 	bl	29970 <LEAF_generate_exp>
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1a3f0:	4bc8      	ldr	r3, [pc, #800]	; (1a714 <initGlobalSFXObjects+0x3f4>)
	defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1a3f2:	48c9      	ldr	r0, [pc, #804]	; (1a718 <initGlobalSFXObjects+0x3f8>)
	defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
   1a3f4:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
	defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
   1a3f8:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1a3fc:	4fc7      	ldr	r7, [pc, #796]	; (1a71c <initGlobalSFXObjects+0x3fc>)
	defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1a3fe:	f8df c33c 	ldr.w	ip, [pc, #828]	; 1a73c <initGlobalSFXObjects+0x41c>
	defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
   1a402:	f04f 5e7d 	mov.w	lr, #1061158912	; 0x3f400000
	defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1a406:	f8df 8338 	ldr.w	r8, [pc, #824]	; 1a740 <initGlobalSFXObjects+0x420>
	defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
   1a40a:	f203 494c 	addw	r9, r3, #1100	; 0x44c
	defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
   1a40e:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
   1a412:	f503 6b8a 	add.w	fp, r3, #1104	; 0x450
	defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1a416:	48c2      	ldr	r0, [pc, #776]	; (1a720 <initGlobalSFXObjects+0x400>)
	defaultPresetKnobValues[Vocoder][5] = 0.02f; // breathiness
   1a418:	f8c3 a014 	str.w	sl, [r3, #20]
	defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
   1a41c:	f503 6a8b 	add.w	sl, r3, #1112	; 0x458
	defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
   1a420:	601f      	str	r7, [r3, #0]
	defaultPresetKnobValues[VocoderCh][0] = 0.4f; // volume
   1a422:	665f      	str	r7, [r3, #100]	; 0x64
	defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
   1a424:	f8c3 8008 	str.w	r8, [r3, #8]
	defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
   1a428:	f8c3 c010 	str.w	ip, [r3, #16]
	defaultPresetKnobValues[VocoderCh][4] = 0.2f; //noise thresh
   1a42c:	f8c3 c074 	str.w	ip, [r3, #116]	; 0x74
	defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
   1a430:	66dc      	str	r4, [r3, #108]	; 0x6c
	defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
   1a432:	f8c3 10dc 	str.w	r1, [r3, #220]	; 0xdc
	defaultPresetKnobValues[Pitchshift][6] = 0.25f;
   1a436:	f8c3 10e0 	str.w	r1, [r3, #224]	; 0xe0
	defaultPresetKnobValues[Vocoder][3] = 0.0f; // sawToPulse
   1a43a:	60de      	str	r6, [r3, #12]
	defaultPresetKnobValues[Vocoder][9] = 0.0f;
   1a43c:	625e      	str	r6, [r3, #36]	; 0x24
	defaultPresetKnobValues[VocoderCh][5] = 0.0f;// saw->pulse fade
   1a43e:	679e      	str	r6, [r3, #120]	; 0x78
	defaultPresetKnobValues[VocoderCh][8] = 0.0f; // breathiness
   1a440:	f8c3 6084 	str.w	r6, [r3, #132]	; 0x84
	defaultPresetKnobValues[VocoderCh][13] = 0.0f; // stereo
   1a444:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
	defaultPresetKnobValues[VocoderCh][14] = 0.0f; // barkpull
   1a448:	f8c3 609c 	str.w	r6, [r3, #156]	; 0x9c
	defaultPresetKnobValues[Pitchshift][2] = 0.0f; // f amount
   1a44c:	f8c3 60d0 	str.w	r6, [r3, #208]	; 0xd0
	defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
   1a450:	605a      	str	r2, [r3, #4]
	defaultPresetKnobValues[Vocoder][6] = 0.5f; // tilt
   1a452:	619a      	str	r2, [r3, #24]
	defaultPresetKnobValues[Vocoder][7] = 0.5f; // pulse width
   1a454:	61da      	str	r2, [r3, #28]
	defaultPresetKnobValues[Vocoder][8] = 0.5f; // pulse shape
   1a456:	621a      	str	r2, [r3, #32]
	defaultPresetKnobValues[VocoderCh][1] = 0.5f; // warp factor
   1a458:	669a      	str	r2, [r3, #104]	; 0x68
	defaultPresetKnobValues[VocoderCh][3] = 0.5f; //band width
   1a45a:	671a      	str	r2, [r3, #112]	; 0x70
	defaultPresetKnobValues[VocoderCh][6] = 0.5f; // pulse length
   1a45c:	67da      	str	r2, [r3, #124]	; 0x7c
	defaultPresetKnobValues[VocoderCh][7] = 0.5f; // pulse width
   1a45e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	defaultPresetKnobValues[VocoderCh][10] = 0.5f;// squish
   1a462:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	defaultPresetKnobValues[VocoderCh][11] = 0.5f; // offset
   1a466:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	defaultPresetKnobValues[VocoderCh][12] = 0.5f; // tilt
   1a46a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	defaultPresetKnobValues[Pitchshift][0] = 0.5f; // pitch
   1a46e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
	defaultPresetKnobValues[Pitchshift][1] = 0.5f; // fine pitch
   1a472:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
	defaultPresetKnobValues[Pitchshift][3] = 0.5f; // formant
   1a476:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
	defaultPresetKnobValues[Pitchshift][4] = 0.5f; //range
   1a47a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
	defaultPresetKnobValues[Pitchshift][7] = 0.25f;
   1a47e:	f8c3 10e4 	str.w	r1, [r3, #228]	; 0xe4
	defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
   1a482:	f8c3 02bc 	str.w	r0, [r3, #700]	; 0x2bc
	defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1a486:	48a7      	ldr	r0, [pc, #668]	; (1a724 <initGlobalSFXObjects+0x404>)
	defaultPresetKnobValues[Pitchshift][8] = 0.25f;
   1a488:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
	defaultPresetKnobValues[Pitchshift][9] = 0.25f;
   1a48c:	f8c3 10ec 	str.w	r1, [r3, #236]	; 0xec
	defaultPresetKnobValues[AutotuneMono][1] = 1.0f; // amount
   1a490:	f8c3 4130 	str.w	r4, [r3, #304]	; 0x130
	defaultPresetKnobValues[AutotuneMono][3] = 1.0f; // leap allow
   1a494:	f8c3 4138 	str.w	r4, [r3, #312]	; 0x138
	defaultPresetKnobValues[AutotuneMono][4] = 0.25f; // hysteresis
   1a498:	f8c3 113c 	str.w	r1, [r3, #316]	; 0x13c
	defaultPresetKnobValues[AutotunePoly][0] = 1.0f; // fidelity thresh
   1a49c:	f8c3 4190 	str.w	r4, [r3, #400]	; 0x190
	defaultPresetKnobValues[SamplerButtonPress][1] = 1.0f; // end
   1a4a0:	f8c3 41f8 	str.w	r4, [r3, #504]	; 0x1f8
	defaultPresetKnobValues[SamplerButtonPress][4] = 0.4f;//crossfade
   1a4a4:	f8c3 7204 	str.w	r7, [r3, #516]	; 0x204
	defaultPresetKnobValues[SamplerKeyboard][1] = 1.0f; // end
   1a4a8:	f8c3 425c 	str.w	r4, [r3, #604]	; 0x25c
	defaultPresetKnobValues[SamplerKeyboard][5] = 0.4f;//crossfade
   1a4ac:	f8c3 726c 	str.w	r7, [r3, #620]	; 0x26c
	defaultPresetKnobValues[SamplerAutoGrab][3] = 0.25f; // crossfade
   1a4b0:	f8c3 12c8 	str.w	r1, [r3, #712]	; 0x2c8
	defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
   1a4b4:	f8c3 e1fc 	str.w	lr, [r3, #508]	; 0x1fc
	defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
   1a4b8:	f8c3 0198 	str.w	r0, [r3, #408]	; 0x198
	defaultPresetKnobValues[SamplerKeyboard][2] = 0.75f; // speed
   1a4bc:	f8c3 e260 	str.w	lr, [r3, #608]	; 0x260
	defaultPresetKnobValues[SamplerAutoGrab][2] = 0.75f; // speed
   1a4c0:	f8c3 e2c4 	str.w	lr, [r3, #708]	; 0x2c4
	defaultPresetKnobValues[AutotuneMono][0] = 0.0f; // pickiness
   1a4c4:	f8c3 612c 	str.w	r6, [r3, #300]	; 0x12c
	defaultPresetKnobValues[AutotuneMono][2] = 0.5f; // speed
   1a4c8:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
	defaultPresetKnobValues[AutotunePoly][1] = 0.5f;
   1a4cc:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
	defaultPresetKnobValues[AutotunePoly][3] = 0.0f;
   1a4d0:	f8c3 619c 	str.w	r6, [r3, #412]	; 0x19c
	defaultPresetKnobValues[AutotunePoly][4] = 0.0f;
   1a4d4:	f8c3 61a0 	str.w	r6, [r3, #416]	; 0x1a0
	defaultPresetKnobValues[SamplerButtonPress][0] = 0.0f; // start
   1a4d8:	f8c3 61f4 	str.w	r6, [r3, #500]	; 0x1f4
	defaultPresetKnobValues[SamplerButtonPress][3] = 0.5f; // speed mult
   1a4dc:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
	defaultPresetKnobValues[SamplerKeyboard][0] = 0.0f; // start
   1a4e0:	f8c3 6258 	str.w	r6, [r3, #600]	; 0x258
	defaultPresetKnobValues[SamplerKeyboard][3] = 0.5f; // speed mult
   1a4e4:	f8c3 2264 	str.w	r2, [r3, #612]	; 0x264
	defaultPresetKnobValues[SamplerKeyboard][4] = 0.0f; //looping on
   1a4e8:	f8c3 6268 	str.w	r6, [r3, #616]	; 0x268
	defaultPresetKnobValues[SamplerKeyboard][6] = 0.0f;//velocity sensitivity
   1a4ec:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	defaultPresetKnobValues[SamplerAutoGrab][1] = 0.5f; // window
   1a4f0:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
	defaultPresetKnobValues[SamplerAutoGrab][4] = 0.0f;
   1a4f4:	f8c3 62cc 	str.w	r6, [r3, #716]	; 0x2cc
	defaultPresetKnobValues[SamplerAutoGrab][5] = 0.0f; // len rand
   1a4f8:	f8c3 62d0 	str.w	r6, [r3, #720]	; 0x2d0
	defaultPresetKnobValues[SamplerAutoGrab][6] = 0.0f; // speed rand
   1a4fc:	f8c3 62d4 	str.w	r6, [r3, #724]	; 0x2d4
	defaultPresetKnobValues[SamplerAutoGrab][7] = 0.0f;
   1a500:	f8c3 62d8 	str.w	r6, [r3, #728]	; 0x2d8
	defaultPresetKnobValues[SamplerAutoGrab][8] = 0.0f;
   1a504:	f8c3 62dc 	str.w	r6, [r3, #732]	; 0x2dc
	defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
   1a508:	f8c9 1000 	str.w	r1, [r9]
	defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
   1a50c:	f203 495c 	addw	r9, r3, #1116	; 0x45c
	defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
   1a510:	f8ca 4000 	str.w	r4, [sl]
	defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
   1a514:	f203 4ab4 	addw	sl, r3, #1204	; 0x4b4
	defaultPresetKnobValues[Wavefolder][3] = 0.75f; // post gain
   1a518:	f8c3 e390 	str.w	lr, [r3, #912]	; 0x390
	defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
   1a51c:	f503 6e8c 	add.w	lr, r3, #1120	; 0x460
	defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
   1a520:	f8cb 1000 	str.w	r1, [fp]
	defaultPresetKnobValues[Reverb][0] = 0.5f; // size
   1a524:	f503 6b96 	add.w	fp, r3, #1200	; 0x4b0
	defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
   1a528:	f8ce 4000 	str.w	r4, [lr]
	defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
   1a52c:	f203 4ebc 	addw	lr, r3, #1212	; 0x4bc
	defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
   1a530:	f8c9 2000 	str.w	r2, [r9]
	defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
   1a534:	f503 6997 	add.w	r9, r3, #1208	; 0x4b8
	defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
   1a538:	f8ca 2000 	str.w	r2, [sl]
	defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
   1a53c:	f203 5a14 	addw	sl, r3, #1300	; 0x514
	defaultPresetKnobValues[Reverb][0] = 0.5f; // size
   1a540:	f8cb 2000 	str.w	r2, [fp]
	defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
   1a544:	f503 6b98 	add.w	fp, r3, #1216	; 0x4c0
	defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
   1a548:	f8ca c000 	str.w	ip, [sl]
	defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
   1a54c:	f203 4a54 	addw	sl, r3, #1108	; 0x454
	defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
   1a550:	f8c9 2000 	str.w	r2, [r9]
	defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
   1a554:	f503 69a3 	add.w	r9, r3, #1304	; 0x518
	defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
   1a558:	f8ce 2000 	str.w	r2, [lr]
	defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
   1a55c:	f203 5e1c 	addw	lr, r3, #1308	; 0x51c
	defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
   1a560:	f8cb 2000 	str.w	r2, [fp]
	defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
   1a564:	f503 6ba4 	add.w	fp, r3, #1312	; 0x520
	defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
   1a568:	f8c9 2000 	str.w	r2, [r9]
	defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
   1a56c:	f203 5924 	addw	r9, r3, #1316	; 0x524
	defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
   1a570:	f8ce 2000 	str.w	r2, [lr]
	defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
   1a574:	f203 5e7c 	addw	lr, r3, #1404	; 0x57c
	defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
   1a578:	f8ca 6000 	str.w	r6, [sl]
	defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
   1a57c:	f203 5a8c 	addw	sl, r3, #1420	; 0x58c
	defaultPresetKnobValues[Distortion][0] = .25f; // pre gain
   1a580:	f8c3 1320 	str.w	r1, [r3, #800]	; 0x320
	defaultPresetKnobValues[Distortion][4] = 0.25f; //post gain
   1a584:	f8c3 1330 	str.w	r1, [r3, #816]	; 0x330
	defaultPresetKnobValues[Wavefolder][0] = 0.4f; // gain
   1a588:	f8c3 7384 	str.w	r7, [r3, #900]	; 0x384
	defaultPresetKnobValues[BitCrusher][0] = 0.1f; // quality
   1a58c:	f8c3 03e8 	str.w	r0, [r3, #1000]	; 0x3e8
	defaultPresetKnobValues[SamplerAutoGrab][9] = 0.0f;
   1a590:	f8c3 62e0 	str.w	r6, [r3, #736]	; 0x2e0
	defaultPresetKnobValues[Distortion][1] = 0.5f; // tilt (low and high shelves, opposing gains)
   1a594:	f8c3 2324 	str.w	r2, [r3, #804]	; 0x324
	defaultPresetKnobValues[Distortion][2] = 0.5f; // mid gain
   1a598:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
	defaultPresetKnobValues[Distortion][3] = 0.5f; // mid freq
   1a59c:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
	defaultPresetKnobValues[Wavefolder][1] = 0.5f; // offset1
   1a5a0:	f8c3 2388 	str.w	r2, [r3, #904]	; 0x388
	defaultPresetKnobValues[Wavefolder][2] = 0.5f; // offset2
   1a5a4:	f8c3 238c 	str.w	r2, [r3, #908]	; 0x38c
	defaultPresetKnobValues[Wavefolder][4] = 0.0f;
   1a5a8:	f8c3 6394 	str.w	r6, [r3, #916]	; 0x394
	defaultPresetKnobValues[BitCrusher][1] = 0.5f; // samp ratio
   1a5ac:	f8c3 23ec 	str.w	r2, [r3, #1004]	; 0x3ec
	defaultPresetKnobValues[BitCrusher][2] = 0.0f; // rounding
   1a5b0:	f8c3 63f0 	str.w	r6, [r3, #1008]	; 0x3f0
	defaultPresetKnobValues[BitCrusher][3] = 0.0f; // operation
   1a5b4:	f8c3 63f4 	str.w	r6, [r3, #1012]	; 0x3f4
	defaultPresetKnobValues[BitCrusher][4] = 0.5f; // post gain
   1a5b8:	f8c3 23f8 	str.w	r2, [r3, #1016]	; 0x3f8
	defaultPresetKnobValues[BitCrusher][5] = 0.0f; // pre gain
   1a5bc:	f8c3 63fc 	str.w	r6, [r3, #1020]	; 0x3fc
	defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
   1a5c0:	f8cb 2000 	str.w	r2, [fp]
	defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
   1a5c4:	f503 6bb1 	add.w	fp, r3, #1416	; 0x588
	defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
   1a5c8:	f8c9 2000 	str.w	r2, [r9]
	defaultPresetKnobValues[LivingString][9] = 0.5f;
   1a5cc:	f203 599c 	addw	r9, r3, #1436	; 0x59c
	defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
   1a5d0:	f8ce 0000 	str.w	r0, [lr]
	defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
   1a5d4:	f203 5edc 	addw	lr, r3, #1500	; 0x5dc
	defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
   1a5d8:	f8ca 1000 	str.w	r1, [sl]
	defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
   1a5dc:	f203 5ae4 	addw	sl, r3, #1508	; 0x5e4
	defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
   1a5e0:	f8ce 2000 	str.w	r2, [lr]
	defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
   1a5e4:	f503 6ebd 	add.w	lr, r3, #1512	; 0x5e8
	defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
   1a5e8:	f8ca 8000 	str.w	r8, [sl]
	defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
   1a5ec:	f503 6abe 	add.w	sl, r3, #1520	; 0x5f0
	defaultPresetKnobValues[LivingString][9] = 0.5f;
   1a5f0:	f8c9 2000 	str.w	r2, [r9]
	defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
   1a5f4:	f203 59ec 	addw	r9, r3, #1516	; 0x5ec
	defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
   1a5f8:	f8ce 4000 	str.w	r4, [lr]
	defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
   1a5fc:	f503 64c0 	add.w	r4, r3, #1536	; 0x600
	defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
   1a600:	f8ca 1000 	str.w	r1, [sl]
	defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
   1a604:	f503 6ec8 	add.w	lr, r3, #1600	; 0x640
	defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
   1a608:	f503 6ac9 	add.w	sl, r3, #1608	; 0x648
	defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
   1a60c:	f8c9 7000 	str.w	r7, [r9]
	defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
   1a610:	f8ce 2000 	str.w	r2, [lr]
	defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
   1a614:	f203 6844 	addw	r8, r3, #1604	; 0x644
	defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
   1a618:	f8ca c000 	str.w	ip, [sl]
	defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1a61c:	f503 69af 	add.w	r9, r3, #1400	; 0x578
	defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
   1a620:	6027      	str	r7, [r4, #0]
	defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
   1a622:	f503 6eb0 	add.w	lr, r3, #1408	; 0x580
	defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1a626:	4c40      	ldr	r4, [pc, #256]	; (1a728 <initGlobalSFXObjects+0x408>)
	defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
   1a628:	f203 5ca4 	addw	ip, r3, #1444	; 0x5a4
	defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
   1a62c:	f503 67b5 	add.w	r7, r3, #1448	; 0x5a8
	defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
   1a630:	f8c8 2000 	str.w	r2, [r8]
	defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
   1a634:	f8c9 4000 	str.w	r4, [r9]
	defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
   1a638:	f503 68b4 	add.w	r8, r3, #1440	; 0x5a0
	defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
   1a63c:	f8ce 4000 	str.w	r4, [lr]
	defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
   1a640:	f203 59ac 	addw	r9, r3, #1452	; 0x5ac
	defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
   1a644:	f8cc 4000 	str.w	r4, [ip]
	defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
   1a648:	f503 6eb6 	add.w	lr, r3, #1456	; 0x5b0
	defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
   1a64c:	f203 5afc 	addw	sl, r3, #1532	; 0x5fc
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1a650:	f203 5c84 	addw	ip, r3, #1412	; 0x584
	defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
   1a654:	603c      	str	r4, [r7, #0]
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1a656:	4f35      	ldr	r7, [pc, #212]	; (1a72c <initGlobalSFXObjects+0x40c>)
	defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
   1a658:	f8c8 4000 	str.w	r4, [r8]
	defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
   1a65c:	f503 68b2 	add.w	r8, r3, #1424	; 0x590
	defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
   1a660:	f8c9 4000 	str.w	r4, [r9]
	defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
   1a664:	f203 5994 	addw	r9, r3, #1428	; 0x594
	defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
   1a668:	f8cb 2000 	str.w	r2, [fp]
	defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
   1a66c:	f503 6bbc 	add.w	fp, r3, #1504	; 0x5e0
	defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
   1a670:	f8ce 4000 	str.w	r4, [lr]
	defaultPresetKnobValues[LivingString][8] = 0.8f;
   1a674:	f503 6eb3 	add.w	lr, r3, #1432	; 0x598
	defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
   1a678:	f8ca 4000 	str.w	r4, [sl]
	defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
   1a67c:	f203 6454 	addw	r4, r3, #1620	; 0x654
	defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
   1a680:	f8cc 7000 	str.w	r7, [ip]
	defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
   1a684:	f503 6cbf 	add.w	ip, r3, #1528	; 0x5f8
	defaultPresetKnobValues[LivingString][8] = 0.8f;
   1a688:	eddf 7a29 	vldr	s15, [pc, #164]	; 1a730 <initGlobalSFXObjects+0x410>
	defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
   1a68c:	f203 5af4 	addw	sl, r3, #1524	; 0x5f4
	defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
   1a690:	f8cb 2000 	str.w	r2, [fp]
	defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1a694:	f503 6bcb 	add.w	fp, r3, #1624	; 0x658
	defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
   1a698:	f8c8 6000 	str.w	r6, [r8]
	defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
   1a69c:	f203 684c 	addw	r8, r3, #1612	; 0x64c
	defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
   1a6a0:	f8c9 6000 	str.w	r6, [r9]
	defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
   1a6a4:	f503 69ca 	add.w	r9, r3, #1616	; 0x650
	defaultPresetKnobValues[LivingString][8] = 0.8f;
   1a6a8:	edce 7a00 	vstr	s15, [lr]
	defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
   1a6ac:	f203 6e5c 	addw	lr, r3, #1628	; 0x65c
	defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
   1a6b0:	f8cc 6000 	str.w	r6, [ip]
	defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
   1a6b4:	f503 6ccc 	add.w	ip, r3, #1632	; 0x660
	defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
   1a6b8:	6026      	str	r6, [r4, #0]
	defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1a6ba:	4c1e      	ldr	r4, [pc, #120]	; (1a734 <initGlobalSFXObjects+0x414>)
	defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
   1a6bc:	f8ca 6000 	str.w	r6, [sl]
	defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
   1a6c0:	f203 6a6c 	addw	sl, r3, #1644	; 0x66c
	defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
   1a6c4:	f8cb 4000 	str.w	r4, [fp]
	defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
   1a6c8:	f8c8 6000 	str.w	r6, [r8]
	defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
   1a6cc:	f203 6864 	addw	r8, r3, #1636	; 0x664
   1a6d0:	e038      	b.n	1a744 <initGlobalSFXObjects+0x424>
   1a6d2:	bf00      	nop
   1a6d4:	020e3258 	.word	0x020e3258
   1a6d8:	020f9050 	.word	0x020f9050
   1a6dc:	020e3224 	.word	0x020e3224
   1a6e0:	2aaaaaab 	.word	0x2aaaaaab
   1a6e4:	020fa558 	.word	0x020fa558
   1a6e8:	020f7730 	.word	0x020f7730
   1a6ec:	020fa15c 	.word	0x020fa15c
   1a6f0:	3ca3d70a 	.word	0x3ca3d70a
   1a6f4:	00000000 	.word	0x00000000
   1a6f8:	3c23d70a 	.word	0x3c23d70a
   1a6fc:	020f9e9c 	.word	0x020f9e9c
   1a700:	ba51b717 	.word	0xba51b717
   1a704:	447a0000 	.word	0x447a0000
   1a708:	020f9c84 	.word	0x020f9c84
   1a70c:	020fa578 	.word	0x020fa578
   1a710:	3a83126f 	.word	0x3a83126f
   1a714:	020f8570 	.word	0x020f8570
   1a718:	3f28f5c3 	.word	0x3f28f5c3
   1a71c:	3ecccccd 	.word	0x3ecccccd
   1a720:	3f733333 	.word	0x3f733333
   1a724:	3dcccccd 	.word	0x3dcccccd
   1a728:	3e99999a 	.word	0x3e99999a
   1a72c:	3f666666 	.word	0x3f666666
   1a730:	3f4ccccd 	.word	0x3f4ccccd
   1a734:	3d75c28f 	.word	0x3d75c28f
   1a738:	3ca3d70a 	.word	0x3ca3d70a
   1a73c:	3e4ccccd 	.word	0x3e4ccccd
   1a740:	3f59999a 	.word	0x3f59999a
	defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
   1a744:	f8c9 6000 	str.w	r6, [r9]
	defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
   1a748:	f503 69ce 	add.w	r9, r3, #1648	; 0x670
	defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
   1a74c:	f8ce 7000 	str.w	r7, [lr]
	defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
   1a750:	f203 6e74 	addw	lr, r3, #1652	; 0x674
	defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
   1a754:	f8cc 0000 	str.w	r0, [ip]
	defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
   1a758:	f503 6ccf 	add.w	ip, r3, #1656	; 0x678
	defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
   1a75c:	f8c8 0000 	str.w	r0, [r8]
	defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
   1a760:	f503 68d0 	add.w	r8, r3, #1664	; 0x680
	defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
   1a764:	f8ce 0000 	str.w	r0, [lr]
	defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
   1a768:	f503 6ed1 	add.w	lr, r3, #1672	; 0x688
	defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
   1a76c:	f8cc 0000 	str.w	r0, [ip]
	defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
   1a770:	f203 6c8c 	addw	ip, r3, #1676	; 0x68c
	defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
   1a774:	f8c8 4000 	str.w	r4, [r8]
	defaultPresetKnobValues[Rhodes][0] = 0.25f;
   1a778:	f203 68a4 	addw	r8, r3, #1700	; 0x6a4
	defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
   1a77c:	f8ce 0000 	str.w	r0, [lr]
	defaultPresetKnobValues[Rhodes][2] = 0.25f;
   1a780:	f203 6eac 	addw	lr, r3, #1708	; 0x6ac
	defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
   1a784:	f8cc 0000 	str.w	r0, [ip]
	defaultPresetKnobValues[Rhodes][3] = 0.5f;
   1a788:	f503 6cd6 	add.w	ip, r3, #1712	; 0x6b0
	defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
   1a78c:	f8ca 4000 	str.w	r4, [sl]
	defaultPresetKnobValues[Rhodes][7] = 0.9f;
   1a790:	f503 60d8 	add.w	r0, r3, #1728	; 0x6c0
	defaultPresetKnobValues[Rhodes][1] = 0.25f;
   1a794:	f503 64d5 	add.w	r4, r3, #1704	; 0x6a8
	defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
   1a798:	f8c9 7000 	str.w	r7, [r9]
	defaultPresetKnobValues[Rhodes][0] = 0.25f;
   1a79c:	f8c8 1000 	str.w	r1, [r8]
	defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
   1a7a0:	f203 6984 	addw	r9, r3, #1668	; 0x684
	defaultPresetKnobValues[Rhodes][1] = 0.25f;
   1a7a4:	6021      	str	r1, [r4, #0]
	defaultPresetKnobValues[Rhodes][9] = 0.5f;
   1a7a6:	f503 68d9 	add.w	r8, r3, #1736	; 0x6c8
	defaultPresetKnobValues[Rhodes][2] = 0.25f;
   1a7aa:	f8ce 1000 	str.w	r1, [lr]
	defaultPresetKnobValues[Rhodes][12] = 0.9f;
   1a7ae:	f203 64d4 	addw	r4, r3, #1748	; 0x6d4
	defaultPresetKnobValues[Rhodes][7] = 0.9f;
   1a7b2:	6007      	str	r7, [r0, #0]
	defaultPresetKnobValues[Rhodes][14] = 0.5f;
   1a7b4:	f203 6edc 	addw	lr, r3, #1756	; 0x6dc
	defaultPresetKnobValues[Rhodes][3] = 0.5f;
   1a7b8:	f8cc 2000 	str.w	r2, [ip]
	defaultPresetKnobValues[Rhodes][15] = 0.8f;
   1a7bc:	f503 61dc 	add.w	r1, r3, #1760	; 0x6e0
	defaultPresetKnobValues[Rhodes][18] = 0.5f;
   1a7c0:	f203 6cec 	addw	ip, r3, #1772	; 0x6ec
	defaultPresetKnobValues[Rhodes][19] = 0.5f;
   1a7c4:	f503 60de 	add.w	r0, r3, #1776	; 0x6f0
	defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
   1a7c8:	f8c9 7000 	str.w	r7, [r9]
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1a7cc:	f203 6ac4 	addw	sl, r3, #1732	; 0x6c4
	defaultPresetKnobValues[Rhodes][12] = 0.9f;
   1a7d0:	6027      	str	r7, [r4, #0]
	defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
   1a7d2:	f203 647c 	addw	r4, r3, #1660	; 0x67c
	defaultPresetKnobValues[Rhodes][9] = 0.5f;
   1a7d6:	f8c8 2000 	str.w	r2, [r8]
	defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
   1a7da:	f203 67b4 	addw	r7, r3, #1716	; 0x6b4
	defaultPresetKnobValues[Rhodes][14] = 0.5f;
   1a7de:	f8ce 2000 	str.w	r2, [lr]
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1a7e2:	f503 68d7 	add.w	r8, r3, #1720	; 0x6b8
	defaultPresetKnobValues[Rhodes][6] = 0.05f;
   1a7e6:	f203 6ebc 	addw	lr, r3, #1724	; 0x6bc
	defaultPresetKnobValues[Rhodes][18] = 0.5f;
   1a7ea:	f8cc 2000 	str.w	r2, [ip]
	defaultPresetKnobValues[Rhodes][19] = 0.5f;
   1a7ee:	6002      	str	r2, [r0, #0]
	defaultPresetKnobValues[Rhodes][10] = 0.05f;
   1a7f0:	f203 6ccc 	addw	ip, r3, #1740	; 0x6cc
	defaultPresetKnobValues[Rhodes][11] = 0.05f;
   1a7f4:	f503 60da 	add.w	r0, r3, #1744	; 0x6d0
	defaultPresetKnobValues[Rhodes][15] = 0.8f;
   1a7f8:	edc1 7a00 	vstr	s15, [r1]
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1a7fc:	4920      	ldr	r1, [pc, #128]	; (1a880 <initGlobalSFXObjects+0x560>)
	defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
   1a7fe:	f503 69cd 	add.w	r9, r3, #1640	; 0x668
	defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
   1a802:	6026      	str	r6, [r4, #0]
	defaultPresetKnobValues[Rhodes][13] = 0.1007f;
   1a804:	f503 64db 	add.w	r4, r3, #1752	; 0x6d8
	defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
   1a808:	603e      	str	r6, [r7, #0]
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1a80a:	f203 67e4 	addw	r7, r3, #1764	; 0x6e4
	defaultPresetKnobValues[Rhodes][5] = 0.05f;
   1a80e:	f8c8 1000 	str.w	r1, [r8]
	defaultPresetKnobValues[Rhodes][20] = 0.5f;
   1a812:	f203 68f4 	addw	r8, r3, #1780	; 0x6f4
	defaultPresetKnobValues[Rhodes][6] = 0.05f;
   1a816:	f8ce 1000 	str.w	r1, [lr]
	defaultPresetKnobValues[Rhodes][21] = 0.0f;
   1a81a:	f503 6edf 	add.w	lr, r3, #1784	; 0x6f8
	defaultPresetKnobValues[Rhodes][10] = 0.05f;
   1a81e:	f8cc 1000 	str.w	r1, [ip]
	defaultPresetKnobValues[Rhodes][22] = 0.00f;
   1a822:	f203 6cfc 	addw	ip, r3, #1788	; 0x6fc
	defaultPresetKnobValues[Rhodes][11] = 0.05f;
   1a826:	6001      	str	r1, [r0, #0]
	defaultPresetKnobValues[Rhodes][23] = 0.00f;
   1a828:	f503 60e0 	add.w	r0, r3, #1792	; 0x700
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1a82c:	4915      	ldr	r1, [pc, #84]	; (1a884 <initGlobalSFXObjects+0x564>)
   1a82e:	4d16      	ldr	r5, [pc, #88]	; (1a888 <initGlobalSFXObjects+0x568>)
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1a830:	f8df b05c 	ldr.w	fp, [pc, #92]	; 1a890 <initGlobalSFXObjects+0x570>
	defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
   1a834:	f8c9 6000 	str.w	r6, [r9]
	defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1a838:	f503 69dd 	add.w	r9, r3, #1768	; 0x6e8
	defaultPresetKnobValues[Rhodes][13] = 0.1007f;
   1a83c:	6021      	str	r1, [r4, #0]
   1a83e:	461c      	mov	r4, r3
	defaultPresetKnobValues[Rhodes][8] = 0.1007f;
   1a840:	f8ca 1000 	str.w	r1, [sl]
	defaultPresetKnobValues[Rhodes][24] = 0.00f;
   1a844:	f203 7104 	addw	r1, r3, #1796	; 0x704
	defaultPresetKnobValues[Rhodes][16] = 0.6f;
   1a848:	f8c7 b000 	str.w	fp, [r7]
   1a84c:	f505 67e1 	add.w	r7, r5, #1800	; 0x708
	defaultPresetKnobValues[Rhodes][17] = 0.7f;
   1a850:	4b0e      	ldr	r3, [pc, #56]	; (1a88c <initGlobalSFXObjects+0x56c>)
   1a852:	f8c9 3000 	str.w	r3, [r9]
	defaultPresetKnobValues[Rhodes][20] = 0.5f;
   1a856:	f8c8 2000 	str.w	r2, [r8]
	defaultPresetKnobValues[Rhodes][21] = 0.0f;
   1a85a:	f8ce 6000 	str.w	r6, [lr]
	defaultPresetKnobValues[Rhodes][22] = 0.00f;
   1a85e:	f8cc 6000 	str.w	r6, [ip]
	defaultPresetKnobValues[Rhodes][23] = 0.00f;
   1a862:	6006      	str	r6, [r0, #0]
	defaultPresetKnobValues[Rhodes][24] = 0.00f;
   1a864:	600e      	str	r6, [r1, #0]
   1a866:	4628      	mov	r0, r5
   1a868:	3564      	adds	r5, #100	; 0x64
   1a86a:	4621      	mov	r1, r4
   1a86c:	2264      	movs	r2, #100	; 0x64
   1a86e:	f012 f8dd 	bl	2ca2c <memcpy>
	for (int p = 0; p < PresetNil; p++)
   1a872:	42af      	cmp	r7, r5
   1a874:	f104 0464 	add.w	r4, r4, #100	; 0x64
   1a878:	d1f5      	bne.n	1a866 <initGlobalSFXObjects+0x546>
}
   1a87a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a87e:	bf00      	nop
   1a880:	3d4ccccd 	.word	0x3d4ccccd
   1a884:	3dce3bcd 	.word	0x3dce3bcd
   1a888:	020f9318 	.word	0x020f9318
   1a88c:	3f333333 	.word	0x3f333333
   1a890:	3f19999a 	.word	0x3f19999a

0001a894 <SFXVocoderAlloc>:
{
   1a894:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	leaf.clearOnAllocation = 1;
   1a898:	4b3c      	ldr	r3, [pc, #240]	; (1a98c <SFXVocoderAlloc+0xf8>)
   1a89a:	2501      	movs	r5, #1
	tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1a89c:	4a3c      	ldr	r2, [pc, #240]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a89e:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1a8a2:	483c      	ldr	r0, [pc, #240]	; (1a994 <SFXVocoderAlloc+0x100>)
	tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
   1a8a4:	2400      	movs	r4, #0
	tSimplePoly_setNumVoices(&poly, numVoices);
   1a8a6:	f8df 9138 	ldr.w	r9, [pc, #312]	; 1a9e0 <SFXVocoderAlloc+0x14c>
   1a8aa:	f8df 8138 	ldr.w	r8, [pc, #312]	; 1a9e4 <SFXVocoderAlloc+0x150>
   1a8ae:	4f3a      	ldr	r7, [pc, #232]	; (1a998 <SFXVocoderAlloc+0x104>)
		tSawtooth_initToPool(&osc[i], &smallPool);
   1a8b0:	4e37      	ldr	r6, [pc, #220]	; (1a990 <SFXVocoderAlloc+0xfc>)
{
   1a8b2:	ed2d 8b02 	vpush	{d8}
	leaf.clearOnAllocation = 1;
   1a8b6:	615d      	str	r5, [r3, #20]
	tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
   1a8b8:	f00b fadc 	bl	25e74 <tTalkboxFloat_initToPool>
	tTalkboxFloat_setWarpOn(&vocoder, 1);
   1a8bc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1a8c0:	4834      	ldr	r0, [pc, #208]	; (1a994 <SFXVocoderAlloc+0x100>)
   1a8c2:	f00b fd8b 	bl	263dc <tTalkboxFloat_setWarpOn>
	tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1a8c6:	4a32      	ldr	r2, [pc, #200]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a8c8:	4621      	mov	r1, r4
   1a8ca:	4834      	ldr	r0, [pc, #208]	; (1a99c <SFXVocoderAlloc+0x108>)
   1a8cc:	f00f ffb0 	bl	2a830 <tNoise_initToPool>
	tZeroCrossing_initToPool(&zerox, 16, &smallPool);
   1a8d0:	4a2f      	ldr	r2, [pc, #188]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a8d2:	2110      	movs	r1, #16
   1a8d4:	4832      	ldr	r0, [pc, #200]	; (1a9a0 <SFXVocoderAlloc+0x10c>)
   1a8d6:	f009 fd37 	bl	24348 <tZeroCrossing_initToPool>
	tSimplePoly_setNumVoices(&poly, numVoices);
   1a8da:	f899 1000 	ldrb.w	r1, [r9]
   1a8de:	4831      	ldr	r0, [pc, #196]	; (1a9a4 <SFXVocoderAlloc+0x110>)
   1a8e0:	f00f fe32 	bl	2a548 <tSimplePoly_setNumVoices>
	tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.005f, &smallPool);
   1a8e4:	492a      	ldr	r1, [pc, #168]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a8e6:	eddf 0a30 	vldr	s1, [pc, #192]	; 1a9a8 <SFXVocoderAlloc+0x114>
   1a8ea:	ed9f 0a30 	vldr	s0, [pc, #192]	; 1a9ac <SFXVocoderAlloc+0x118>
   1a8ee:	4830      	ldr	r0, [pc, #192]	; (1a9b0 <SFXVocoderAlloc+0x11c>)
   1a8f0:	f00d fafa 	bl	27ee8 <tExpSmooth_initToPool>
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1a8f4:	4a26      	ldr	r2, [pc, #152]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a8f6:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1a8fa:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 1a9b4 <SFXVocoderAlloc+0x120>
   1a8fe:	2106      	movs	r1, #6
   1a900:	482d      	ldr	r0, [pc, #180]	; (1a9b8 <SFXVocoderAlloc+0x124>)
   1a902:	f00d fe7f 	bl	28604 <tVZFilter_initToPool>
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1a906:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1a90a:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 1a9bc <SFXVocoderAlloc+0x128>
   1a90e:	2107      	movs	r1, #7
   1a910:	4a1f      	ldr	r2, [pc, #124]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a912:	482b      	ldr	r0, [pc, #172]	; (1a9c0 <SFXVocoderAlloc+0x12c>)
   1a914:	f00d fe76 	bl	28604 <tVZFilter_initToPool>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1a918:	eddf 8a2a 	vldr	s17, [pc, #168]	; 1a9c4 <SFXVocoderAlloc+0x130>
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1a91c:	4a1c      	ldr	r2, [pc, #112]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a91e:	4621      	mov	r1, r4
   1a920:	4829      	ldr	r0, [pc, #164]	; (1a9c8 <SFXVocoderAlloc+0x134>)
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1a922:	ed9f 8a2a 	vldr	s16, [pc, #168]	; 1a9cc <SFXVocoderAlloc+0x138>
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1a926:	f00f ff83 	bl	2a830 <tNoise_initToPool>
	tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
   1a92a:	4919      	ldr	r1, [pc, #100]	; (1a990 <SFXVocoderAlloc+0xfc>)
   1a92c:	ed9f 0a28 	vldr	s0, [pc, #160]	; 1a9d0 <SFXVocoderAlloc+0x13c>
   1a930:	4828      	ldr	r0, [pc, #160]	; (1a9d4 <SFXVocoderAlloc+0x140>)
   1a932:	f00d fe23 	bl	2857c <tHighpass_initToPool>
   1a936:	193d      	adds	r5, r7, r4
		tSawtooth_initToPool(&osc[i], &smallPool);
   1a938:	eb08 0004 	add.w	r0, r8, r4
   1a93c:	4631      	mov	r1, r6
   1a93e:	3404      	adds	r4, #4
   1a940:	f00f fec0 	bl	2a6c4 <tSawtooth_initToPool>
		tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
   1a944:	4628      	mov	r0, r5
   1a946:	4631      	mov	r1, r6
   1a948:	f00b fd54 	bl	263f4 <tRosenbergGlottalPulse_initToPool>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
   1a94c:	eef0 0a68 	vmov.f32	s1, s17
   1a950:	eeb0 0a48 	vmov.f32	s0, s16
   1a954:	4628      	mov	r0, r5
   1a956:	f00b fe67 	bl	26628 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1a95a:	2c20      	cmp	r4, #32
   1a95c:	d1eb      	bne.n	1a936 <SFXVocoderAlloc+0xa2>
	setLED_A(numVoices == 1);
   1a95e:	f899 0000 	ldrb.w	r0, [r9]
   1a962:	f1a0 0001 	sub.w	r0, r0, #1
   1a966:	fab0 f080 	clz	r0, r0
   1a96a:	0940      	lsrs	r0, r0, #5
   1a96c:	f7fe fde6 	bl	1953c <setLED_A>
	setLED_B(internalExternal);
   1a970:	4b19      	ldr	r3, [pc, #100]	; (1a9d8 <SFXVocoderAlloc+0x144>)
   1a972:	7818      	ldrb	r0, [r3, #0]
   1a974:	f7fe fdf0 	bl	19558 <setLED_B>
	vocFreezeLPC = 0;
   1a978:	2300      	movs	r3, #0
   1a97a:	4a18      	ldr	r2, [pc, #96]	; (1a9dc <SFXVocoderAlloc+0x148>)
	setLED_C(vocFreezeLPC);
   1a97c:	4618      	mov	r0, r3
	vocFreezeLPC = 0;
   1a97e:	6013      	str	r3, [r2, #0]
}
   1a980:	ecbd 8b02 	vpop	{d8}
   1a984:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	setLED_C(vocFreezeLPC);
   1a988:	f7fe bdf4 	b.w	19574 <setLED_C>
   1a98c:	020fc0a8 	.word	0x020fc0a8
   1a990:	020f7730 	.word	0x020f7730
   1a994:	020fad7c 	.word	0x020fad7c
   1a998:	020f8e50 	.word	0x020f8e50
   1a99c:	020f9a6c 	.word	0x020f9a6c
   1a9a0:	020fa2cc 	.word	0x020fa2cc
   1a9a4:	020fa15c 	.word	0x020fa15c
   1a9a8:	3ba3d70a 	.word	0x3ba3d70a
   1a9ac:	00000000 	.word	0x00000000
   1a9b0:	020fae64 	.word	0x020fae64
   1a9b4:	42a00000 	.word	0x42a00000
   1a9b8:	020fa13c 	.word	0x020fa13c
   1a9bc:	463b8000 	.word	0x463b8000
   1a9c0:	020fa064 	.word	0x020fa064
   1a9c4:	3ecccccd 	.word	0x3ecccccd
   1a9c8:	020f8e20 	.word	0x020f8e20
   1a9cc:	3e99999a 	.word	0x3e99999a
   1a9d0:	458ca000 	.word	0x458ca000
   1a9d4:	020f9a64 	.word	0x020f9a64
   1a9d8:	020e31a4 	.word	0x020e31a4
   1a9dc:	020e321c 	.word	0x020e321c
   1a9e0:	00062ae4 	.word	0x00062ae4
   1a9e4:	020f9f1c 	.word	0x020f9f1c

0001a9e8 <SFXVocoderFrame>:
{
   1a9e8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1a9ec:	4c84      	ldr	r4, [pc, #528]	; (1ac00 <SFXVocoderFrame+0x218>)
{
   1a9ee:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1a9f2:	7d23      	ldrb	r3, [r4, #20]
   1a9f4:	2b01      	cmp	r3, #1
   1a9f6:	d113      	bne.n	1aa20 <SFXVocoderFrame+0x38>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1a9f8:	4d82      	ldr	r5, [pc, #520]	; (1ac04 <SFXVocoderFrame+0x21c>)
		tSimplePoly_setNumVoices(&poly, numVoices);
   1a9fa:	4883      	ldr	r0, [pc, #524]	; (1ac08 <SFXVocoderFrame+0x220>)
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1a9fc:	782a      	ldrb	r2, [r5, #0]
   1a9fe:	2a01      	cmp	r2, #1
   1aa00:	bf98      	it	ls
   1aa02:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   1aa04:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1aa06:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   1aa08:	f00f fd9e 	bl	2a548 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   1aa0c:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1aa0e:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   1aa10:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1aa14:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   1aa16:	fab0 f080 	clz	r0, r0
   1aa1a:	0940      	lsrs	r0, r0, #5
   1aa1c:	f7fe fd8e 	bl	1953c <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1aa20:	7e23      	ldrb	r3, [r4, #24]
   1aa22:	2b01      	cmp	r3, #1
   1aa24:	f000 80e0 	beq.w	1abe8 <SFXVocoderFrame+0x200>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1aa28:	7f23      	ldrb	r3, [r4, #28]
   1aa2a:	2b01      	cmp	r3, #1
   1aa2c:	f000 80c9 	beq.w	1abc2 <SFXVocoderFrame+0x1da>
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1aa30:	4b76      	ldr	r3, [pc, #472]	; (1ac0c <SFXVocoderFrame+0x224>)
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1aa32:	eeb3 6a0e 	vmov.f32	s12, #62	; 0x41f00000  30.0
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1aa36:	eddf 6a76 	vldr	s13, [pc, #472]	; 1ac10 <SFXVocoderFrame+0x228>
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1aa3a:	eeba 7a0e 	vmov.f32	s14, #174	; 0xc1700000 -15.0
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1aa3e:	ed93 5a01 	vldr	s10, [r3, #4]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aa42:	2400      	movs	r4, #0
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1aa44:	eddf 7a73 	vldr	s15, [pc, #460]	; 1ac14 <SFXVocoderFrame+0x22c>
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1aa48:	edd3 5a06 	vldr	s11, [r3, #24]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aa4c:	46a1      	mov	r9, r4
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1aa4e:	eee5 7a26 	vfma.f32	s15, s10, s13
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1aa52:	edd3 6a02 	vldr	s13, [r3, #8]
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1aa56:	eea5 7a86 	vfma.f32	s14, s11, s12
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1aa5a:	ed9f 6a6f 	vldr	s12, [pc, #444]	; 1ac18 <SFXVocoderFrame+0x230>
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1aa5e:	4d6f      	ldr	r5, [pc, #444]	; (1ac1c <SFXVocoderFrame+0x234>)
   1aa60:	6819      	ldr	r1, [r3, #0]
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1aa62:	ee66 6a86 	vmul.f32	s13, s13, s12
	displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
   1aa66:	68da      	ldr	r2, [r3, #12]
	displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
   1aa68:	6918      	ldr	r0, [r3, #16]
	displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
   1aa6a:	6029      	str	r1, [r5, #0]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1aa6c:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
   1aa70:	6959      	ldr	r1, [r3, #20]
	displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
   1aa72:	60ea      	str	r2, [r5, #12]
	displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
   1aa74:	69da      	ldr	r2, [r3, #28]
	displayValues[8] = presetKnobValues[Vocoder][8]; //open length
   1aa76:	6a1b      	ldr	r3, [r3, #32]
	displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
   1aa78:	6128      	str	r0, [r5, #16]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1aa7a:	4869      	ldr	r0, [pc, #420]	; (1ac20 <SFXVocoderFrame+0x238>)
	displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
   1aa7c:	edc5 7a01 	vstr	s15, [r5, #4]
	displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
   1aa80:	edc5 6a02 	vstr	s13, [r5, #8]
	displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
   1aa84:	6169      	str	r1, [r5, #20]
	displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
   1aa86:	ed85 7a06 	vstr	s14, [r5, #24]
	displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
   1aa8a:	61ea      	str	r2, [r5, #28]
	displayValues[8] = presetKnobValues[Vocoder][8]; //open length
   1aa8c:	622b      	str	r3, [r5, #32]
	tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
   1aa8e:	f00b fca1 	bl	263d4 <tTalkboxFloat_setWarpFactor>
	tTalkboxFloat_setQuality(&vocoder, displayValues[2]);
   1aa92:	ed95 0a02 	vldr	s0, [r5, #8]
   1aa96:	4862      	ldr	r0, [pc, #392]	; (1ac20 <SFXVocoderFrame+0x238>)
   1aa98:	f00b fc7e 	bl	26398 <tTalkboxFloat_setQuality>
   1aa9c:	4f61      	ldr	r7, [pc, #388]	; (1ac24 <SFXVocoderFrame+0x23c>)
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aa9e:	4e5a      	ldr	r6, [pc, #360]	; (1ac08 <SFXVocoderFrame+0x220>)
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1aaa0:	ed9f 8a61 	vldr	s16, [pc, #388]	; 1ac28 <SFXVocoderFrame+0x240>
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aaa4:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 1ac58 <SFXVocoderFrame+0x270>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1aaa8:	e04f      	b.n	1ab4a <SFXVocoderFrame+0x162>
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1aaaa:	f00f fd7d 	bl	2a5a8 <tSimplePoly_getVelocity>
   1aaae:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1aab2:	2800      	cmp	r0, #0
   1aab4:	4658      	mov	r0, fp
   1aab6:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1aaba:	f00d fa51 	bl	27f60 <tExpSmooth_setDest>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1aabe:	4651      	mov	r1, sl
   1aac0:	4630      	mov	r0, r6
   1aac2:	f00f fd65 	bl	2a590 <tSimplePoly_getPitch>
   1aac6:	ee07 0a90 	vmov	s15, r0
   1aaca:	4a58      	ldr	r2, [pc, #352]	; (1ac2c <SFXVocoderFrame+0x244>)
   1aacc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aad0:	4b57      	ldr	r3, [pc, #348]	; (1ac30 <SFXVocoderFrame+0x248>)
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1aad2:	ed92 0a00 	vldr	s0, [r2]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aad6:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1aad8:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1aadc:	4955      	ldr	r1, [pc, #340]	; (1ac34 <SFXVocoderFrame+0x24c>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1aade:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1aae2:	ee17 3a90 	vmov	r3, s15
   1aae6:	1a9b      	subs	r3, r3, r2
   1aae8:	fb88 2003 	smull	r2, r0, r8, r3
   1aaec:	17da      	asrs	r2, r3, #31
   1aaee:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1aaf2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1aaf6:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1aafa:	ee07 3a90 	vmov	s15, r3
   1aafe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1ab02:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1ab06:	ee17 3a90 	vmov	r3, s15
   1ab0a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1ab0e:	ed93 0a00 	vldr	s0, [r3]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1ab12:	ee37 0a00 	vadd.f32	s0, s14, s0
   1ab16:	f00e ffa1 	bl	29a5c <LEAF_midiToFrequency>
		tSawtooth_setFreq(&osc[i], freq[i]);
   1ab1a:	4847      	ldr	r0, [pc, #284]	; (1ac38 <SFXVocoderFrame+0x250>)
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1ab1c:	ed87 0a00 	vstr	s0, [r7]
		tSawtooth_setFreq(&osc[i], freq[i]);
   1ab20:	4420      	add	r0, r4
   1ab22:	f00f fdf7 	bl	2a714 <tSawtooth_setFreq>
   1ab26:	4b45      	ldr	r3, [pc, #276]	; (1ac3c <SFXVocoderFrame+0x254>)
		tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
   1ab28:	ecb7 0a01 	vldmia	r7!, {s0}
   1ab2c:	eb04 0a03 	add.w	sl, r4, r3
   1ab30:	3404      	adds	r4, #4
   1ab32:	4650      	mov	r0, sl
   1ab34:	f00b fd4e 	bl	265d4 <tRosenbergGlottalPulse_setFreq>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[8] * displayValues[7], displayValues[7]);
   1ab38:	edd5 0a07 	vldr	s1, [r5, #28]
   1ab3c:	ed95 0a08 	vldr	s0, [r5, #32]
   1ab40:	4650      	mov	r0, sl
   1ab42:	ee20 0a80 	vmul.f32	s0, s1, s0
   1ab46:	f00b fd6f 	bl	26628 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ab4a:	4630      	mov	r0, r6
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1ab4c:	fa5f fa89 	uxtb.w	sl, r9
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ab50:	f00f fd02 	bl	2a558 <tSimplePoly_getNumVoices>
   1ab54:	4b3a      	ldr	r3, [pc, #232]	; (1ac40 <SFXVocoderFrame+0x258>)
   1ab56:	4548      	cmp	r0, r9
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1ab58:	4651      	mov	r1, sl
   1ab5a:	4630      	mov	r0, r6
   1ab5c:	eb04 0b03 	add.w	fp, r4, r3
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ab60:	f109 0901 	add.w	r9, r9, #1
   1ab64:	dca1      	bgt.n	1aaaa <SFXVocoderFrame+0xc2>
	if (tSimplePoly_getNumActiveVoices(&poly) != 0)
   1ab66:	4828      	ldr	r0, [pc, #160]	; (1ac08 <SFXVocoderFrame+0x220>)
   1ab68:	f00f fcfa 	bl	2a560 <tSimplePoly_getNumActiveVoices>
   1ab6c:	b9c0      	cbnz	r0, 1aba0 <SFXVocoderFrame+0x1b8>
		tExpSmooth_setDest(&comp, 0.0f);
   1ab6e:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 1ac28 <SFXVocoderFrame+0x240>
   1ab72:	4834      	ldr	r0, [pc, #208]	; (1ac44 <SFXVocoderFrame+0x25c>)
   1ab74:	f00d f9f4 	bl	27f60 <tExpSmooth_setDest>
	tVZFilter_setGain(&shelf1, fasterdbtoa(-1.0f * displayValues[6]));
   1ab78:	ed95 0a06 	vldr	s0, [r5, #24]
   1ab7c:	eeb1 0a40 	vneg.f32	s0, s0
   1ab80:	f00f f848 	bl	29c14 <fasterdbtoa>
   1ab84:	4830      	ldr	r0, [pc, #192]	; (1ac48 <SFXVocoderFrame+0x260>)
   1ab86:	f00e fb77 	bl	29278 <tVZFilter_setGain>
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1ab8a:	ed95 0a06 	vldr	s0, [r5, #24]
   1ab8e:	f00f f839 	bl	29c04 <fastdbtoa>
   1ab92:	482e      	ldr	r0, [pc, #184]	; (1ac4c <SFXVocoderFrame+0x264>)
}
   1ab94:	ecbd 8b02 	vpop	{d8}
   1ab98:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
   1ab9c:	f00e bb6c 	b.w	29278 <tVZFilter_setGain>
		tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
   1aba0:	4819      	ldr	r0, [pc, #100]	; (1ac08 <SFXVocoderFrame+0x220>)
   1aba2:	f00f fcdd 	bl	2a560 <tSimplePoly_getNumActiveVoices>
   1aba6:	ee07 0a90 	vmov	s15, r0
   1abaa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1abae:	4825      	ldr	r0, [pc, #148]	; (1ac44 <SFXVocoderFrame+0x25c>)
   1abb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1abb4:	ee87 0a27 	vdiv.f32	s0, s14, s15
   1abb8:	eeb1 0ac0 	vsqrt.f32	s0, s0
   1abbc:	f00d f9d0 	bl	27f60 <tExpSmooth_setDest>
   1abc0:	e7da      	b.n	1ab78 <SFXVocoderFrame+0x190>
		vocFreezeLPC = !vocFreezeLPC;
   1abc2:	4d23      	ldr	r5, [pc, #140]	; (1ac50 <SFXVocoderFrame+0x268>)
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1abc4:	4816      	ldr	r0, [pc, #88]	; (1ac20 <SFXVocoderFrame+0x238>)
		vocFreezeLPC = !vocFreezeLPC;
   1abc6:	682b      	ldr	r3, [r5, #0]
   1abc8:	fab3 f383 	clz	r3, r3
   1abcc:	095b      	lsrs	r3, r3, #5
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1abce:	ee07 3a90 	vmov	s15, r3
		vocFreezeLPC = !vocFreezeLPC;
   1abd2:	602b      	str	r3, [r5, #0]
		tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
   1abd4:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   1abd8:	f00b fc06 	bl	263e8 <tTalkboxFloat_setFreeze>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1abdc:	2300      	movs	r3, #0
		setLED_C(vocFreezeLPC);
   1abde:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1abe0:	7723      	strb	r3, [r4, #28]
		setLED_C(vocFreezeLPC);
   1abe2:	f7fe fcc7 	bl	19574 <setLED_C>
   1abe6:	e723      	b.n	1aa30 <SFXVocoderFrame+0x48>
		internalExternal = !internalExternal;
   1abe8:	4a1a      	ldr	r2, [pc, #104]	; (1ac54 <SFXVocoderFrame+0x26c>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1abea:	2100      	movs	r1, #0
		internalExternal = !internalExternal;
   1abec:	7813      	ldrb	r3, [r2, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1abee:	7621      	strb	r1, [r4, #24]
		internalExternal = !internalExternal;
   1abf0:	fab3 f383 	clz	r3, r3
   1abf4:	095b      	lsrs	r3, r3, #5
		setLED_B(internalExternal);
   1abf6:	4618      	mov	r0, r3
		internalExternal = !internalExternal;
   1abf8:	7013      	strb	r3, [r2, #0]
		setLED_B(internalExternal);
   1abfa:	f7fe fcad 	bl	19558 <setLED_B>
   1abfe:	e713      	b.n	1aa28 <SFXVocoderFrame+0x40>
   1ac00:	020fb31c 	.word	0x020fb31c
   1ac04:	00062ae4 	.word	0x00062ae4
   1ac08:	020fa15c 	.word	0x020fa15c
   1ac0c:	020f9318 	.word	0x020f9318
   1ac10:	3ecccccd 	.word	0x3ecccccd
   1ac14:	be4ccccd 	.word	0xbe4ccccd
   1ac18:	3f8ccccd 	.word	0x3f8ccccd
   1ac1c:	020fb3cc 	.word	0x020fb3cc
   1ac20:	020fad7c 	.word	0x020fad7c
   1ac24:	020f9a44 	.word	0x020f9a44
   1ac28:	00000000 	.word	0x00000000
   1ac2c:	020e31e0 	.word	0x020e31e0
   1ac30:	020e3258 	.word	0x020e3258
   1ac34:	020e3224 	.word	0x020e3224
   1ac38:	020f9f1c 	.word	0x020f9f1c
   1ac3c:	020f8e50 	.word	0x020f8e50
   1ac40:	020fa558 	.word	0x020fa558
   1ac44:	020f9e9c 	.word	0x020f9e9c
   1ac48:	020fa13c 	.word	0x020fa13c
   1ac4c:	020fa064 	.word	0x020fa064
   1ac50:	020e321c 	.word	0x020e321c
   1ac54:	020e31a4 	.word	0x020e31a4
   1ac58:	2aaaaaab 	.word	0x2aaaaaab

0001ac5c <SFXVocoderTick>:
	if (internalExternal == 1)
   1ac5c:	4b60      	ldr	r3, [pc, #384]	; (1ade0 <SFXVocoderTick+0x184>)
{
   1ac5e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1ac62:	ed2d 8b08 	vpush	{d8-d11}
	if (internalExternal == 1)
   1ac66:	781b      	ldrb	r3, [r3, #0]
{
   1ac68:	4680      	mov	r8, r0
   1ac6a:	ed90 8a01 	vldr	s16, [r0, #4]
	if (internalExternal == 1)
   1ac6e:	2b01      	cmp	r3, #1
   1ac70:	f000 80b1 	beq.w	1add6 <SFXVocoderTick+0x17a>
		zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1ac74:	eeb0 0a48 	vmov.f32	s0, s16
   1ac78:	485a      	ldr	r0, [pc, #360]	; (1ade4 <SFXVocoderTick+0x188>)
   1ac7a:	f009 fb9b 	bl	243b4 <tZeroCrossing_tick>
		if (!vocChFreeze)
   1ac7e:	4b5a      	ldr	r3, [pc, #360]	; (1ade8 <SFXVocoderTick+0x18c>)
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1ac80:	4f5a      	ldr	r7, [pc, #360]	; (1adec <SFXVocoderTick+0x190>)
		if (!vocChFreeze)
   1ac82:	681b      	ldr	r3, [r3, #0]
   1ac84:	2b00      	cmp	r3, #0
   1ac86:	f000 808f 	beq.w	1ada8 <SFXVocoderTick+0x14c>
		noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1ac8a:	4859      	ldr	r0, [pc, #356]	; (1adf0 <SFXVocoderTick+0x194>)
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ac8c:	2400      	movs	r4, #0
		noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1ac8e:	f00d f971 	bl	27f74 <tExpSmooth_tick>
   1ac92:	eeb0 ba40 	vmov.f32	s22, s0
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1ac96:	4857      	ldr	r0, [pc, #348]	; (1adf4 <SFXVocoderTick+0x198>)
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ac98:	4626      	mov	r6, r4
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1ac9a:	f00f fddf 	bl	2a85c <tNoise_tick>
   1ac9e:	eddf 7a56 	vldr	s15, [pc, #344]	; 1adf8 <SFXVocoderTick+0x19c>
   1aca2:	ee20 0a0b 	vmul.f32	s0, s0, s22
	float sample = 0.0f;
   1aca6:	ed9f 9a55 	vldr	s18, [pc, #340]	; 1adfc <SFXVocoderTick+0x1a0>
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1acaa:	f8df a180 	ldr.w	sl, [pc, #384]	; 1ae2c <SFXVocoderTick+0x1d0>
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1acae:	f8df 9180 	ldr.w	r9, [pc, #384]	; 1ae30 <SFXVocoderTick+0x1d4>
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
   1acb2:	ee20 aa27 	vmul.f32	s20, s0, s15
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1acb6:	eddf aa52 	vldr	s21, [pc, #328]	; 1ae00 <SFXVocoderTick+0x1a4>
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1acba:	e026      	b.n	1ad0a <SFXVocoderTick+0xae>
   1acbc:	4d51      	ldr	r5, [pc, #324]	; (1ae04 <SFXVocoderTick+0x1a8>)
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1acbe:	f00f fd5b 	bl	2a778 <tSawtooth_tick>
   1acc2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   1acc6:	4425      	add	r5, r4
   1acc8:	eef0 8a40 	vmov.f32	s17, s0
   1accc:	4628      	mov	r0, r5
   1acce:	f00d f951 	bl	27f74 <tExpSmooth_tick>
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1acd2:	484d      	ldr	r0, [pc, #308]	; (1ae08 <SFXVocoderTick+0x1ac>)
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1acd4:	edd7 7a03 	vldr	s15, [r7, #12]
   1acd8:	ee68 8a80 	vmul.f32	s17, s17, s0
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1acdc:	4420      	add	r0, r4
   1acde:	3404      	adds	r4, #4
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1ace0:	ee38 8a67 	vsub.f32	s16, s16, s15
			sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
   1ace4:	f00b fc06 	bl	264f4 <tRosenbergGlottalPulse_tickHQ>
   1ace8:	4628      	mov	r0, r5
   1acea:	eef0 9a40 	vmov.f32	s19, s0
   1acee:	f00d f941 	bl	27f74 <tExpSmooth_tick>
   1acf2:	edd7 7a03 	vldr	s15, [r7, #12]
   1acf6:	ee67 7aaa 	vmul.f32	s15, s15, s21
   1acfa:	ee67 7aa9 	vmul.f32	s15, s15, s19
   1acfe:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ad02:	eea8 0a88 	vfma.f32	s0, s17, s16
   1ad06:	ee39 9a00 	vadd.f32	s18, s18, s0
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ad0a:	4650      	mov	r0, sl
   1ad0c:	f00f fc24 	bl	2a558 <tSimplePoly_getNumVoices>
   1ad10:	42b0      	cmp	r0, r6
			sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
   1ad12:	eb09 0004 	add.w	r0, r9, r4
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1ad16:	f106 0601 	add.w	r6, r6, #1
   1ad1a:	dccf      	bgt.n	1acbc <SFXVocoderTick+0x60>
		sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1ad1c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ad20:	ed97 7a05 	vldr	s14, [r7, #20]
   1ad24:	eddf 7a39 	vldr	s15, [pc, #228]	; 1ae0c <SFXVocoderTick+0x1b0>
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ad28:	4839      	ldr	r0, [pc, #228]	; (1ae10 <SFXVocoderTick+0x1b4>)
		sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
   1ad2a:	eeb0 8a40 	vmov.f32	s16, s0
   1ad2e:	ee30 0a4b 	vsub.f32	s0, s0, s22
   1ad32:	eea7 8a67 	vfms.f32	s16, s14, s15
   1ad36:	ee28 8a00 	vmul.f32	s16, s16, s0
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ad3a:	f00f fd8f 	bl	2a85c <tNoise_tick>
   1ad3e:	4835      	ldr	r0, [pc, #212]	; (1ae14 <SFXVocoderTick+0x1b8>)
   1ad40:	f00d fc50 	bl	285e4 <tHighpass_tick>
   1ad44:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
   1ad48:	edd7 7a05 	vldr	s15, [r7, #20]
		sample *= tExpSmooth_tick(&comp);
   1ad4c:	4832      	ldr	r0, [pc, #200]	; (1ae18 <SFXVocoderTick+0x1bc>)
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
   1ad4e:	ee67 7a87 	vmul.f32	s15, s15, s14
   1ad52:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ad56:	eea9 0a08 	vfma.f32	s0, s18, s16
   1ad5a:	ee3a aa00 	vadd.f32	s20, s20, s0
		sample *= tExpSmooth_tick(&comp);
   1ad5e:	f00d f909 	bl	27f74 <tExpSmooth_tick>
   1ad62:	ed98 8a01 	vldr	s16, [r8, #4]
   1ad66:	ee2a 0a00 	vmul.f32	s0, s20, s0
	sample = tanhf(sample);
   1ad6a:	f012 faa7 	bl	2d2bc <tanhf>
	sample = tTalkboxFloat_tick(&vocoder, sample, input[1]);
   1ad6e:	eef0 0a48 	vmov.f32	s1, s16
   1ad72:	482a      	ldr	r0, [pc, #168]	; (1ae1c <SFXVocoderTick+0x1c0>)
   1ad74:	f00b fa40 	bl	261f8 <tTalkboxFloat_tick>
	sample = tVZFilter_tick(&shelf1, sample); //put it through the low shelf
   1ad78:	4829      	ldr	r0, [pc, #164]	; (1ae20 <SFXVocoderTick+0x1c4>)
   1ad7a:	f00d fe43 	bl	28a04 <tVZFilter_tick>
	sample = tVZFilter_tick(&shelf2, sample); // now put that result through the high shelf
   1ad7e:	4829      	ldr	r0, [pc, #164]	; (1ae24 <SFXVocoderTick+0x1c8>)
   1ad80:	f00d fe40 	bl	28a04 <tVZFilter_tick>
	sample *= displayValues[0] * 0.6f;
   1ad84:	edd7 7a00 	vldr	s15, [r7]
   1ad88:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 1adf8 <SFXVocoderTick+0x19c>
   1ad8c:	ee67 7a87 	vmul.f32	s15, s15, s14
	sample = tanhf(sample);
   1ad90:	ee27 0a80 	vmul.f32	s0, s15, s0
   1ad94:	f012 fa92 	bl	2d2bc <tanhf>
	input[0] = sample;
   1ad98:	ed88 0a00 	vstr	s0, [r8]
	input[1] = sample;
   1ad9c:	ed88 0a01 	vstr	s0, [r8, #4]
}
   1ada0:	ecbd 8b08 	vpop	{d8-d11}
   1ada4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1ada8:	ed9f 6a1f 	vldr	s12, [pc, #124]	; 1ae28 <SFXVocoderTick+0x1cc>
   1adac:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   1adb0:	edd7 7a04 	vldr	s15, [r7, #16]
   1adb4:	ed9f 7a11 	vldr	s14, [pc, #68]	; 1adfc <SFXVocoderTick+0x1a0>
   1adb8:	ee77 7ac6 	vsub.f32	s15, s15, s12
   1adbc:	480c      	ldr	r0, [pc, #48]	; (1adf0 <SFXVocoderTick+0x194>)
   1adbe:	eef4 7ac0 	vcmpe.f32	s15, s0
   1adc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1adc6:	bf54      	ite	pl
   1adc8:	eeb0 0a47 	vmovpl.f32	s0, s14
   1adcc:	eeb0 0a66 	vmovmi.f32	s0, s13
   1add0:	f00d f8c6 	bl	27f60 <tExpSmooth_setDest>
   1add4:	e759      	b.n	1ac8a <SFXVocoderTick+0x2e>
		sample = input[0];
   1add6:	ed90 0a00 	vldr	s0, [r0]
   1adda:	4f04      	ldr	r7, [pc, #16]	; (1adec <SFXVocoderTick+0x190>)
   1addc:	e7c5      	b.n	1ad6a <SFXVocoderTick+0x10e>
   1adde:	bf00      	nop
   1ade0:	020e31a4 	.word	0x020e31a4
   1ade4:	020fa2cc 	.word	0x020fa2cc
   1ade8:	020e3218 	.word	0x020e3218
   1adec:	020fb3cc 	.word	0x020fb3cc
   1adf0:	020fae64 	.word	0x020fae64
   1adf4:	020f9a6c 	.word	0x020f9a6c
   1adf8:	3f19999a 	.word	0x3f19999a
   1adfc:	00000000 	.word	0x00000000
   1ae00:	3ff33333 	.word	0x3ff33333
   1ae04:	020fa558 	.word	0x020fa558
   1ae08:	020f8e50 	.word	0x020f8e50
   1ae0c:	3e99999a 	.word	0x3e99999a
   1ae10:	020f8e20 	.word	0x020f8e20
   1ae14:	020f9a64 	.word	0x020f9a64
   1ae18:	020f9e9c 	.word	0x020f9e9c
   1ae1c:	020fad7c 	.word	0x020fad7c
   1ae20:	020fa13c 	.word	0x020fa13c
   1ae24:	020fa064 	.word	0x020fa064
   1ae28:	3dcccccd 	.word	0x3dcccccd
   1ae2c:	020fa15c 	.word	0x020fa15c
   1ae30:	020f9f1c 	.word	0x020f9f1c

0001ae34 <SFXVocoderFree>:
{
   1ae34:	b570      	push	{r4, r5, r6, lr}
	tTalkboxFloat_free(&vocoder);
   1ae36:	4812      	ldr	r0, [pc, #72]	; (1ae80 <SFXVocoderFree+0x4c>)
	tVZFilter_free(&shelf2);
   1ae38:	2400      	movs	r4, #0
	tTalkboxFloat_free(&vocoder);
   1ae3a:	f00a ff77 	bl	25d2c <tTalkboxFloat_free>
	tNoise_free(&vocoderNoise);
   1ae3e:	4811      	ldr	r0, [pc, #68]	; (1ae84 <SFXVocoderFree+0x50>)
   1ae40:	f00f fd08 	bl	2a854 <tNoise_free>
	tZeroCrossing_free(&zerox);
   1ae44:	4810      	ldr	r0, [pc, #64]	; (1ae88 <SFXVocoderFree+0x54>)
   1ae46:	f009 faa5 	bl	24394 <tZeroCrossing_free>
	tExpSmooth_free(&noiseRamp);
   1ae4a:	4810      	ldr	r0, [pc, #64]	; (1ae8c <SFXVocoderFree+0x58>)
   1ae4c:	f00d f872 	bl	27f34 <tExpSmooth_free>
	tNoise_free(&breathNoise);
   1ae50:	480f      	ldr	r0, [pc, #60]	; (1ae90 <SFXVocoderFree+0x5c>)
   1ae52:	f00f fcff 	bl	2a854 <tNoise_free>
	tHighpass_free(&noiseHP);
   1ae56:	480f      	ldr	r0, [pc, #60]	; (1ae94 <SFXVocoderFree+0x60>)
   1ae58:	f00d fbb0 	bl	285bc <tHighpass_free>
	tVZFilter_free(&shelf1);
   1ae5c:	480e      	ldr	r0, [pc, #56]	; (1ae98 <SFXVocoderFree+0x64>)
   1ae5e:	f00d fdc3 	bl	289e8 <tVZFilter_free>
	tVZFilter_free(&shelf2);
   1ae62:	480e      	ldr	r0, [pc, #56]	; (1ae9c <SFXVocoderFree+0x68>)
   1ae64:	4e0e      	ldr	r6, [pc, #56]	; (1aea0 <SFXVocoderFree+0x6c>)
   1ae66:	4d0f      	ldr	r5, [pc, #60]	; (1aea4 <SFXVocoderFree+0x70>)
   1ae68:	f00d fdbe 	bl	289e8 <tVZFilter_free>
		tSawtooth_free(&osc[i]);
   1ae6c:	1930      	adds	r0, r6, r4
   1ae6e:	f00f fc4d 	bl	2a70c <tSawtooth_free>
		tRosenbergGlottalPulse_free(&glottal[i]);
   1ae72:	1928      	adds	r0, r5, r4
   1ae74:	3404      	adds	r4, #4
   1ae76:	f00b facd 	bl	26414 <tRosenbergGlottalPulse_free>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1ae7a:	2c20      	cmp	r4, #32
   1ae7c:	d1f6      	bne.n	1ae6c <SFXVocoderFree+0x38>
}
   1ae7e:	bd70      	pop	{r4, r5, r6, pc}
   1ae80:	020fad7c 	.word	0x020fad7c
   1ae84:	020f9a6c 	.word	0x020f9a6c
   1ae88:	020fa2cc 	.word	0x020fa2cc
   1ae8c:	020fae64 	.word	0x020fae64
   1ae90:	020f8e20 	.word	0x020f8e20
   1ae94:	020f9a64 	.word	0x020f9a64
   1ae98:	020fa13c 	.word	0x020fa13c
   1ae9c:	020fa064 	.word	0x020fa064
   1aea0:	020f9f1c 	.word	0x020f9f1c
   1aea4:	020f8e50 	.word	0x020f8e50

0001aea8 <SFXVocoderChAlloc>:
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1aea8:	4bd7      	ldr	r3, [pc, #860]	; (1b208 <SFXVocoderChAlloc+0x360>)
   1aeaa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1aeae:	ed9f 6ad7 	vldr	s12, [pc, #860]	; 1b20c <SFXVocoderChAlloc+0x364>
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1aeb2:	eeb0 3a00 	vmov.f32	s6, #0	; 0x40000000  2.0
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1aeb6:	4ad6      	ldr	r2, [pc, #856]	; (1b210 <SFXVocoderChAlloc+0x368>)
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1aeb8:	eebf 5a00 	vmov.f32	s10, #240	; 0xbf800000 -1.0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1aebc:	eddf 6ad5 	vldr	s13, [pc, #852]	; 1b214 <SFXVocoderChAlloc+0x36c>
   1aec0:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1aec4:	ed9f 2ad4 	vldr	s4, [pc, #848]	; 1b218 <SFXVocoderChAlloc+0x370>
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1aec8:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1aecc:	ed9f 4ad3 	vldr	s8, [pc, #844]	; 1b21c <SFXVocoderChAlloc+0x374>
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1aed0:	2107      	movs	r1, #7
   1aed2:	ed9f 0ad3 	vldr	s0, [pc, #844]	; 1b220 <SFXVocoderChAlloc+0x378>
{
   1aed6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1aeda:	ed2d 8b04 	vpush	{d8-d9}
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1aede:	781b      	ldrb	r3, [r3, #0]
{
   1aee0:	b083      	sub	sp, #12
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1aee2:	edd2 4a1b 	vldr	s9, [r2, #108]	; 0x6c
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1aee6:	2400      	movs	r4, #0
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1aee8:	ee07 3a10 	vmov	s14, r3
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1aeec:	edd2 5a1c 	vldr	s11, [r2, #112]	; 0x70
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1aef0:	ee64 4aa6 	vmul.f32	s9, s9, s13
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1aef4:	eddf 6acb 	vldr	s13, [pc, #812]	; 1b224 <SFXVocoderChAlloc+0x37c>
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1aef8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1aefc:	edd2 1a1a 	vldr	s3, [r2, #104]	; 0x68
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1af00:	4bc9      	ldr	r3, [pc, #804]	; (1b228 <SFXVocoderChAlloc+0x380>)
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1af02:	f04f 0801 	mov.w	r8, #1
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af06:	eefc 4ae4 	vcvt.u32.f32	s9, s9
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1af0a:	6e57      	ldr	r7, [r2, #100]	; 0x64
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1af0c:	ee37 7a46 	vsub.f32	s14, s14, s12
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1af10:	ed9f 6ac6 	vldr	s12, [pc, #792]	; 1b22c <SFXVocoderChAlloc+0x384>
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1af14:	eea1 4a82 	vfma.f32	s8, s3, s4
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1af18:	ed9f 2ac5 	vldr	s4, [pc, #788]	; 1b230 <SFXVocoderChAlloc+0x388>
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af1c:	edcd 4a01 	vstr	s9, [sp, #4]
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1af20:	eea5 6a83 	vfma.f32	s12, s11, s6
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1af24:	eec7 3a87 	vdiv.f32	s7, s15, s14
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af28:	f89d 0004 	ldrb.w	r0, [sp, #4]
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1af2c:	edd2 7a25 	vldr	s15, [r2, #148]	; 0x94
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1af30:	4625      	mov	r5, r4
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1af32:	ed9f 7ac0 	vldr	s14, [pc, #768]	; 1b234 <SFXVocoderChAlloc+0x38c>
	displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1af36:	edd2 5a23 	vldr	s11, [r2, #140]	; 0x8c
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1af3a:	edd2 4a24 	vldr	s9, [r2, #144]	; 0x90
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1af3e:	eea7 5a83 	vfma.f32	s10, s15, s6
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af42:	ee07 0a90 	vmov	s15, r0
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1af46:	6f90      	ldr	r0, [r2, #120]	; 0x78
	displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1af48:	ee75 5aa5 	vadd.f32	s11, s11, s11
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af4c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1af50:	f8d2 c074 	ldr.w	ip, [r2, #116]	; 0x74
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1af54:	f8d2 a07c 	ldr.w	sl, [r2, #124]	; 0x7c
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1af58:	ee64 4a82 	vmul.f32	s9, s9, s4
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1af5c:	f8d2 6080 	ldr.w	r6, [r2, #128]	; 0x80
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af60:	ee77 7aa2 	vadd.f32	s15, s15, s5
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1af64:	601f      	str	r7, [r3, #0]
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1af66:	f8d2 7084 	ldr.w	r7, [r2, #132]	; 0x84
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1af6a:	f8d2 9088 	ldr.w	r9, [r2, #136]	; 0x88
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1af6e:	edc3 7a02 	vstr	s15, [r3, #8]
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1af72:	6158      	str	r0, [r3, #20]
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1af74:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1af78:	ee63 6aa6 	vmul.f32	s13, s7, s13
	displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
   1af7c:	f8d2 e09c 	ldr.w	lr, [r2, #156]	; 0x9c
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1af80:	f8c3 c010 	str.w	ip, [r3, #16]
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1af84:	f8c3 a018 	str.w	sl, [r3, #24]
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1af88:	ee66 7a87 	vmul.f32	s15, s13, s14
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1af8c:	61de      	str	r6, [r3, #28]
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1af8e:	621f      	str	r7, [r3, #32]
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1af90:	f8df c318 	ldr.w	ip, [pc, #792]	; 1b2ac <SFXVocoderChAlloc+0x404>
	thisBandwidth = bandWidthInOctaves * myQ;
   1af94:	ee26 7a27 	vmul.f32	s14, s12, s15
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1af98:	4fa7      	ldr	r7, [pc, #668]	; (1b238 <SFXVocoderChAlloc+0x390>)
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1af9a:	f8df a314 	ldr.w	sl, [pc, #788]	; 1b2b0 <SFXVocoderChAlloc+0x408>
	thisBandwidth = bandWidthInOctaves * myQ;
   1af9e:	4ea7      	ldr	r6, [pc, #668]	; (1b23c <SFXVocoderChAlloc+0x394>)
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1afa0:	f8c3 9024 	str.w	r9, [r3, #36]	; 0x24
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1afa4:	ed83 4a01 	vstr	s8, [r3, #4]
	displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
   1afa8:	edc3 5a0a 	vstr	s11, [r3, #40]	; 0x28
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1afac:	edc3 4a0b 	vstr	s9, [r3, #44]	; 0x2c
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
   1afb0:	ed83 5a0c 	vstr	s10, [r3, #48]	; 0x30
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1afb4:	4aa2      	ldr	r2, [pc, #648]	; (1b240 <SFXVocoderChAlloc+0x398>)
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1afb6:	ed83 6a03 	vstr	s12, [r3, #12]
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1afba:	6358      	str	r0, [r3, #52]	; 0x34
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1afbc:	48a1      	ldr	r0, [pc, #644]	; (1b244 <SFXVocoderChAlloc+0x39c>)
	bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1afbe:	edc7 7a00 	vstr	s15, [r7]
	displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
   1afc2:	f8c3 e038 	str.w	lr, [r3, #56]	; 0x38
	invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1afc6:	edcc 3a00 	vstr	s7, [ip]
	bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
   1afca:	edca 6a00 	vstr	s13, [sl]
	thisBandwidth = bandWidthInOctaves * myQ;
   1afce:	ed86 7a00 	vstr	s14, [r6]
	tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
   1afd2:	f00d fb17 	bl	28604 <tVZFilter_initToPool>
	tVZFilter_setGain(&vocodec_highshelf, 4.0f);
   1afd6:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1afda:	489a      	ldr	r0, [pc, #616]	; (1b244 <SFXVocoderChAlloc+0x39c>)
   1afdc:	f8df b2d4 	ldr.w	fp, [pc, #724]	; 1b2b4 <SFXVocoderChAlloc+0x40c>
   1afe0:	f00e f94a 	bl	29278 <tVZFilter_setGain>
   1afe4:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 1b2b8 <SFXVocoderChAlloc+0x410>
   1afe8:	4f97      	ldr	r7, [pc, #604]	; (1b248 <SFXVocoderChAlloc+0x3a0>)
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1afea:	ed9f 9a98 	vldr	s18, [pc, #608]	; 1b24c <SFXVocoderChAlloc+0x3a4>
   1afee:	eddf 8a98 	vldr	s17, [pc, #608]	; 1b250 <SFXVocoderChAlloc+0x3a8>
   1aff2:	e004      	b.n	1affe <SFXVocoderChAlloc+0x156>
   1aff4:	3501      	adds	r5, #1
   1aff6:	f108 0801 	add.w	r8, r8, #1
   1affa:	3704      	adds	r7, #4
   1affc:	3408      	adds	r4, #8
		float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1affe:	ee07 5a90 	vmov	s15, r5
   1b002:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
   1b006:	ed9a 7a00 	vldr	s14, [sl]
   1b00a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1b00e:	eea7 0a87 	vfma.f32	s0, s15, s14
   1b012:	f00e fda7 	bl	29b64 <faster_mtof>
		bandGains[i] = 1.0f;
   1b016:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b01a:	eeb0 8a40 	vmov.f32	s16, s0
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1b01e:	eb0b 0004 	add.w	r0, fp, r4
   1b022:	4a87      	ldr	r2, [pc, #540]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b024:	2103      	movs	r1, #3
		bandGains[i] = 1.0f;
   1b026:	f849 3b04 	str.w	r3, [r9], #4
		if (i == 0)
   1b02a:	2d00      	cmp	r5, #0
   1b02c:	f000 80c2 	beq.w	1b1b4 <SFXVocoderChAlloc+0x30c>
   1b030:	edd6 7a00 	vldr	s15, [r6]
		else if (i == (MAX_NUM_VOCODER_BANDS-1))
   1b034:	2d17      	cmp	r5, #23
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1b036:	eef0 0a67 	vmov.f32	s1, s15
		else if (i == (MAX_NUM_VOCODER_BANDS-1))
   1b03a:	f000 8092 	beq.w	1b162 <SFXVocoderChAlloc+0x2ba>
			tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1b03e:	f00d fae1 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&analysisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1b042:	4b84      	ldr	r3, [pc, #528]	; (1b254 <SFXVocoderChAlloc+0x3ac>)
   1b044:	4a7e      	ldr	r2, [pc, #504]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b046:	eeb0 0a48 	vmov.f32	s0, s16
   1b04a:	1918      	adds	r0, r3, r4
   1b04c:	edd6 0a00 	vldr	s1, [r6]
   1b050:	2103      	movs	r1, #3
   1b052:	f00d fad7 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1b056:	4b80      	ldr	r3, [pc, #512]	; (1b258 <SFXVocoderChAlloc+0x3b0>)
   1b058:	4a79      	ldr	r2, [pc, #484]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b05a:	eeb0 0a48 	vmov.f32	s0, s16
   1b05e:	1918      	adds	r0, r3, r4
   1b060:	edd6 0a00 	vldr	s1, [r6]
   1b064:	2103      	movs	r1, #3
   1b066:	f00d facd 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
   1b06a:	4b7c      	ldr	r3, [pc, #496]	; (1b25c <SFXVocoderChAlloc+0x3b4>)
   1b06c:	eeb0 0a48 	vmov.f32	s0, s16
   1b070:	4a73      	ldr	r2, [pc, #460]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b072:	1918      	adds	r0, r3, r4
   1b074:	2103      	movs	r1, #3
   1b076:	edd6 0a00 	vldr	s1, [r6]
   1b07a:	f00d fac3 	bl	28604 <tVZFilter_initToPool>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1b07e:	4970      	ldr	r1, [pc, #448]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b080:	eef0 0a49 	vmov.f32	s1, s18
   1b084:	4638      	mov	r0, r7
   1b086:	eeb0 0a68 	vmov.f32	s0, s17
   1b08a:	f00c ff2d 	bl	27ee8 <tExpSmooth_initToPool>
	for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
   1b08e:	f1b8 0f18 	cmp.w	r8, #24
   1b092:	d1af      	bne.n	1aff4 <SFXVocoderChAlloc+0x14c>
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1b094:	2100      	movs	r1, #0
   1b096:	4a6a      	ldr	r2, [pc, #424]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b098:	4871      	ldr	r0, [pc, #452]	; (1b260 <SFXVocoderChAlloc+0x3b8>)
	tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1b09a:	460c      	mov	r4, r1
	tSimplePoly_setNumVoices(&poly, numVoices);
   1b09c:	f8df 921c 	ldr.w	r9, [pc, #540]	; 1b2bc <SFXVocoderChAlloc+0x414>
	tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
   1b0a0:	f00f fbc6 	bl	2a830 <tNoise_initToPool>
	tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
   1b0a4:	4a66      	ldr	r2, [pc, #408]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b0a6:	4621      	mov	r1, r4
   1b0a8:	486e      	ldr	r0, [pc, #440]	; (1b264 <SFXVocoderChAlloc+0x3bc>)
   1b0aa:	f00f fbc1 	bl	2a830 <tNoise_initToPool>
	tZeroCrossing_initToPool(&zerox, 256, &smallPool);
   1b0ae:	4a64      	ldr	r2, [pc, #400]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b0b0:	f44f 7180 	mov.w	r1, #256	; 0x100
   1b0b4:	486c      	ldr	r0, [pc, #432]	; (1b268 <SFXVocoderChAlloc+0x3c0>)
   1b0b6:	f009 f947 	bl	24348 <tZeroCrossing_initToPool>
	tSimplePoly_setNumVoices(&poly, numVoices);
   1b0ba:	f899 1000 	ldrb.w	r1, [r9]
   1b0be:	486b      	ldr	r0, [pc, #428]	; (1b26c <SFXVocoderChAlloc+0x3c4>)
   1b0c0:	f00f fa42 	bl	2a548 <tSimplePoly_setNumVoices>
	tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.05f, &smallPool);
   1b0c4:	eddf 0a6a 	vldr	s1, [pc, #424]	; 1b270 <SFXVocoderChAlloc+0x3c8>
   1b0c8:	495d      	ldr	r1, [pc, #372]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b0ca:	ed9f 0a61 	vldr	s0, [pc, #388]	; 1b250 <SFXVocoderChAlloc+0x3a8>
   1b0ce:	4869      	ldr	r0, [pc, #420]	; (1b274 <SFXVocoderChAlloc+0x3cc>)
   1b0d0:	f00c ff0a 	bl	27ee8 <tExpSmooth_initToPool>
	tHighpass_initToPool(&noiseHP, 5000.0f, &smallPool);
   1b0d4:	495a      	ldr	r1, [pc, #360]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b0d6:	ed9f 0a68 	vldr	s0, [pc, #416]	; 1b278 <SFXVocoderChAlloc+0x3d0>
   1b0da:	4868      	ldr	r0, [pc, #416]	; (1b27c <SFXVocoderChAlloc+0x3d4>)
   1b0dc:	f00d fa4e 	bl	2857c <tHighpass_initToPool>
   1b0e0:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 1b2c0 <SFXVocoderChAlloc+0x418>
	tHighpass_initToPool(&chVocFinalHP1, 20.0f, &smallPool);
   1b0e4:	4956      	ldr	r1, [pc, #344]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b0e6:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1b0ea:	4865      	ldr	r0, [pc, #404]	; (1b280 <SFXVocoderChAlloc+0x3d8>)
		tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1b0ec:	eddf 8a65 	vldr	s17, [pc, #404]	; 1b284 <SFXVocoderChAlloc+0x3dc>
	tHighpass_initToPool(&chVocFinalHP1, 20.0f, &smallPool);
   1b0f0:	f00d fa44 	bl	2857c <tHighpass_initToPool>
		tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1b0f4:	ed9f 8a64 	vldr	s16, [pc, #400]	; 1b288 <SFXVocoderChAlloc+0x3e0>
	tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1b0f8:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1b0fc:	4f63      	ldr	r7, [pc, #396]	; (1b28c <SFXVocoderChAlloc+0x3e4>)
		tSawtooth_initToPool(&osc[i], &smallPool);
   1b0fe:	4e50      	ldr	r6, [pc, #320]	; (1b240 <SFXVocoderChAlloc+0x398>)
	tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
   1b100:	494f      	ldr	r1, [pc, #316]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b102:	4863      	ldr	r0, [pc, #396]	; (1b290 <SFXVocoderChAlloc+0x3e8>)
   1b104:	f00d fa3a 	bl	2857c <tHighpass_initToPool>
   1b108:	193d      	adds	r5, r7, r4
		tSawtooth_initToPool(&osc[i], &smallPool);
   1b10a:	eb08 0004 	add.w	r0, r8, r4
   1b10e:	4631      	mov	r1, r6
   1b110:	3404      	adds	r4, #4
   1b112:	f00f fad7 	bl	2a6c4 <tSawtooth_initToPool>
		tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
   1b116:	4631      	mov	r1, r6
   1b118:	4628      	mov	r0, r5
   1b11a:	f00b f96b 	bl	263f4 <tRosenbergGlottalPulse_initToPool>
		tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
   1b11e:	eeb0 0a68 	vmov.f32	s0, s17
   1b122:	4628      	mov	r0, r5
   1b124:	f00b fa64 	bl	265f0 <tRosenbergGlottalPulse_setOpenLength>
		tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
   1b128:	eeb0 0a48 	vmov.f32	s0, s16
   1b12c:	4628      	mov	r0, r5
   1b12e:	f00b fa6d 	bl	2660c <tRosenbergGlottalPulse_setPulseLength>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1b132:	2c20      	cmp	r4, #32
   1b134:	d1e8      	bne.n	1b108 <SFXVocoderChAlloc+0x260>
	setLED_A(numVoices == 1);
   1b136:	f899 0000 	ldrb.w	r0, [r9]
   1b13a:	f1a0 0001 	sub.w	r0, r0, #1
   1b13e:	fab0 f080 	clz	r0, r0
   1b142:	0940      	lsrs	r0, r0, #5
   1b144:	f7fe f9fa 	bl	1953c <setLED_A>
	setLED_B(internalExternal);
   1b148:	4b52      	ldr	r3, [pc, #328]	; (1b294 <SFXVocoderChAlloc+0x3ec>)
   1b14a:	7818      	ldrb	r0, [r3, #0]
   1b14c:	f7fe fa04 	bl	19558 <setLED_B>
	setLED_C(vocChFreeze);
   1b150:	4b51      	ldr	r3, [pc, #324]	; (1b298 <SFXVocoderChAlloc+0x3f0>)
   1b152:	7818      	ldrb	r0, [r3, #0]
}
   1b154:	b003      	add	sp, #12
   1b156:	ecbd 8b04 	vpop	{d8-d9}
   1b15a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	setLED_C(vocChFreeze);
   1b15e:	f7fe ba09 	b.w	19574 <setLED_C>
			tVZFilter_initToPool(&analysisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b162:	4a37      	ldr	r2, [pc, #220]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b164:	2100      	movs	r1, #0
   1b166:	484d      	ldr	r0, [pc, #308]	; (1b29c <SFXVocoderChAlloc+0x3f4>)
   1b168:	f00d fa4c 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&analysisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b16c:	edd6 0a00 	vldr	s1, [r6]
   1b170:	eeb0 0a48 	vmov.f32	s0, s16
   1b174:	4a32      	ldr	r2, [pc, #200]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b176:	2100      	movs	r1, #0
   1b178:	4849      	ldr	r0, [pc, #292]	; (1b2a0 <SFXVocoderChAlloc+0x3f8>)
   1b17a:	f00d fa43 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b17e:	edd6 0a00 	vldr	s1, [r6]
   1b182:	eeb0 0a48 	vmov.f32	s0, s16
   1b186:	4a2e      	ldr	r2, [pc, #184]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b188:	2100      	movs	r1, #0
   1b18a:	4846      	ldr	r0, [pc, #280]	; (1b2a4 <SFXVocoderChAlloc+0x3fc>)
   1b18c:	f00d fa3a 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
   1b190:	eeb0 0a48 	vmov.f32	s0, s16
   1b194:	edd6 0a00 	vldr	s1, [r6]
   1b198:	2100      	movs	r1, #0
   1b19a:	4a29      	ldr	r2, [pc, #164]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b19c:	4842      	ldr	r0, [pc, #264]	; (1b2a8 <SFXVocoderChAlloc+0x400>)
   1b19e:	f00d fa31 	bl	28604 <tVZFilter_initToPool>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1b1a2:	4638      	mov	r0, r7
   1b1a4:	4926      	ldr	r1, [pc, #152]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b1a6:	eddf 0a29 	vldr	s1, [pc, #164]	; 1b24c <SFXVocoderChAlloc+0x3a4>
   1b1aa:	ed9f 0a29 	vldr	s0, [pc, #164]	; 1b250 <SFXVocoderChAlloc+0x3a8>
   1b1ae:	f00c fe9b 	bl	27ee8 <tExpSmooth_initToPool>
   1b1b2:	e76f      	b.n	1b094 <SFXVocoderChAlloc+0x1ec>
			tVZFilter_initToPool(&analysisBands[i][0], Lowpass, bandFreq, thisBandwidth, &smallPool);
   1b1b4:	edd6 0a00 	vldr	s1, [r6]
   1b1b8:	4658      	mov	r0, fp
   1b1ba:	2101      	movs	r1, #1
   1b1bc:	f00d fa22 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&analysisBands[i][1], Lowpass, bandFreq, thisBandwidth, &smallPool);
   1b1c0:	edd6 0a00 	vldr	s1, [r6]
   1b1c4:	eeb0 0a48 	vmov.f32	s0, s16
   1b1c8:	4a1d      	ldr	r2, [pc, #116]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b1ca:	2101      	movs	r1, #1
   1b1cc:	4821      	ldr	r0, [pc, #132]	; (1b254 <SFXVocoderChAlloc+0x3ac>)
   1b1ce:	f00d fa19 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][0], Lowpass, bandFreq,thisBandwidth, &smallPool);
   1b1d2:	edd6 0a00 	vldr	s1, [r6]
   1b1d6:	eeb0 0a48 	vmov.f32	s0, s16
   1b1da:	4a19      	ldr	r2, [pc, #100]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b1dc:	2101      	movs	r1, #1
   1b1de:	481e      	ldr	r0, [pc, #120]	; (1b258 <SFXVocoderChAlloc+0x3b0>)
   1b1e0:	f00d fa10 	bl	28604 <tVZFilter_initToPool>
			tVZFilter_initToPool(&synthesisBands[i][1], Lowpass, bandFreq,thisBandwidth, &smallPool);
   1b1e4:	eeb0 0a48 	vmov.f32	s0, s16
   1b1e8:	edd6 0a00 	vldr	s1, [r6]
   1b1ec:	2101      	movs	r1, #1
   1b1ee:	4a14      	ldr	r2, [pc, #80]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b1f0:	481a      	ldr	r0, [pc, #104]	; (1b25c <SFXVocoderChAlloc+0x3b4>)
   1b1f2:	f00d fa07 	bl	28604 <tVZFilter_initToPool>
		tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
   1b1f6:	4912      	ldr	r1, [pc, #72]	; (1b240 <SFXVocoderChAlloc+0x398>)
   1b1f8:	eef0 0a49 	vmov.f32	s1, s18
   1b1fc:	4638      	mov	r0, r7
   1b1fe:	eeb0 0a68 	vmov.f32	s0, s17
   1b202:	f00c fe71 	bl	27ee8 <tExpSmooth_initToPool>
   1b206:	e6f5      	b.n	1aff4 <SFXVocoderChAlloc+0x14c>
   1b208:	00062ae5 	.word	0x00062ae5
   1b20c:	3f7d70a4 	.word	0x3f7d70a4
   1b210:	020f9318 	.word	0x020f9318
   1b214:	41873333 	.word	0x41873333
   1b218:	3f4ccccd 	.word	0x3f4ccccd
   1b21c:	becccccd 	.word	0xbecccccd
   1b220:	45bb8000 	.word	0x45bb8000
   1b224:	42c60000 	.word	0x42c60000
   1b228:	020fb3cc 	.word	0x020fb3cc
   1b22c:	3dcccccd 	.word	0x3dcccccd
   1b230:	42700000 	.word	0x42700000
   1b234:	3daaaaab 	.word	0x3daaaaab
   1b238:	020f9a70 	.word	0x020f9a70
   1b23c:	020f8e48 	.word	0x020f8e48
   1b240:	020f7730 	.word	0x020f7730
   1b244:	020fa22c 	.word	0x020fa22c
   1b248:	020fa268 	.word	0x020fa268
   1b24c:	3a83126f 	.word	0x3a83126f
   1b250:	00000000 	.word	0x00000000
   1b254:	020fae78 	.word	0x020fae78
   1b258:	020fa068 	.word	0x020fa068
   1b25c:	020fa06c 	.word	0x020fa06c
   1b260:	020f8e20 	.word	0x020f8e20
   1b264:	020f9a6c 	.word	0x020f9a6c
   1b268:	020fa2cc 	.word	0x020fa2cc
   1b26c:	020fa15c 	.word	0x020fa15c
   1b270:	3d4ccccd 	.word	0x3d4ccccd
   1b274:	020fae64 	.word	0x020fae64
   1b278:	459c4000 	.word	0x459c4000
   1b27c:	020f9a64 	.word	0x020f9a64
   1b280:	020f8e44 	.word	0x020f8e44
   1b284:	3e99999a 	.word	0x3e99999a
   1b288:	3ecccccd 	.word	0x3ecccccd
   1b28c:	020f8e50 	.word	0x020f8e50
   1b290:	020fae68 	.word	0x020fae68
   1b294:	020e31a4 	.word	0x020e31a4
   1b298:	020e3218 	.word	0x020e3218
   1b29c:	020faf2c 	.word	0x020faf2c
   1b2a0:	020faf30 	.word	0x020faf30
   1b2a4:	020fa120 	.word	0x020fa120
   1b2a8:	020fa124 	.word	0x020fa124
   1b2ac:	00062ad8 	.word	0x00062ad8
   1b2b0:	020fa150 	.word	0x020fa150
   1b2b4:	020fae74 	.word	0x020fae74
   1b2b8:	020f9eb8 	.word	0x020f9eb8
   1b2bc:	00062ae4 	.word	0x00062ae4
   1b2c0:	020f9f1c 	.word	0x020f9f1c

0001b2c4 <SFXVocoderChFrame>:
{
   1b2c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1b2c8:	4c4c      	ldr	r4, [pc, #304]	; (1b3fc <SFXVocoderChFrame+0x138>)
{
   1b2ca:	ed2d 8b08 	vpush	{d8-d11}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1b2ce:	7d23      	ldrb	r3, [r4, #20]
{
   1b2d0:	b087      	sub	sp, #28
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1b2d2:	2b01      	cmp	r3, #1
   1b2d4:	d113      	bne.n	1b2fe <SFXVocoderChFrame+0x3a>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1b2d6:	4d4a      	ldr	r5, [pc, #296]	; (1b400 <SFXVocoderChFrame+0x13c>)
		tSimplePoly_setNumVoices(&poly, numVoices);
   1b2d8:	484a      	ldr	r0, [pc, #296]	; (1b404 <SFXVocoderChFrame+0x140>)
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1b2da:	782a      	ldrb	r2, [r5, #0]
   1b2dc:	2a01      	cmp	r2, #1
   1b2de:	bf98      	it	ls
   1b2e0:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   1b2e2:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1b2e4:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   1b2e6:	f00f f92f 	bl	2a548 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   1b2ea:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1b2ec:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   1b2ee:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1b2f2:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   1b2f4:	fab0 f080 	clz	r0, r0
   1b2f8:	0940      	lsrs	r0, r0, #5
   1b2fa:	f7fe f91f 	bl	1953c <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1b2fe:	7e23      	ldrb	r3, [r4, #24]
   1b300:	2b01      	cmp	r3, #1
   1b302:	f000 8295 	beq.w	1b830 <SFXVocoderChFrame+0x56c>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1b306:	7f23      	ldrb	r3, [r4, #28]
   1b308:	2b01      	cmp	r3, #1
   1b30a:	f000 82a0 	beq.w	1b84e <SFXVocoderChFrame+0x58a>
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b30e:	4b3e      	ldr	r3, [pc, #248]	; (1b408 <SFXVocoderChFrame+0x144>)
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b310:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b314:	eddf 6a3d 	vldr	s13, [pc, #244]	; 1b40c <SFXVocoderChFrame+0x148>
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b318:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b31c:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b320:	eeb8 6a00 	vmov.f32	s12, #128	; 0xc0000000 -2.0
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b324:	ed93 5a1c 	vldr	s10, [r3, #112]	; 0x70
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b328:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b32c:	ee27 7a26 	vmul.f32	s14, s14, s13
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b330:	eddf 4a37 	vldr	s9, [pc, #220]	; 1b410 <SFXVocoderChFrame+0x14c>
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b334:	ed93 2a1a 	vldr	s4, [r3, #104]	; 0x68
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b338:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b33c:	eee5 4a27 	vfma.f32	s9, s10, s15
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b340:	ed9f 3a34 	vldr	s6, [pc, #208]	; 1b414 <SFXVocoderChFrame+0x150>
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b344:	eebc 7ac7 	vcvt.u32.f32	s14, s14
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b348:	ed9f 4a33 	vldr	s8, [pc, #204]	; 1b418 <SFXVocoderChFrame+0x154>
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b34c:	ed93 5a23 	vldr	s10, [r3, #140]	; 0x8c
	chVocOutputGain = 9.0f * displayValues[0];
   1b350:	eef2 6a02 	vmov.f32	s13, #34	; 0x41100000  9.0
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b354:	eea2 4a03 	vfma.f32	s8, s4, s6
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b358:	ed93 3a19 	vldr	s6, [r3, #100]	; 0x64
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b35c:	ed8d 7a00 	vstr	s14, [sp]
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b360:	ee35 5a23 	vadd.f32	s10, s10, s7
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b364:	f89d 2000 	ldrb.w	r2, [sp]
	chVocOutputGain = 9.0f * displayValues[0];
   1b368:	ee63 6a26 	vmul.f32	s13, s6, s13
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b36c:	ed93 7a25 	vldr	s14, [r3, #148]	; 0x94
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b370:	2500      	movs	r5, #0
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b372:	ee07 2a90 	vmov	s15, r2
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1b376:	edd3 3a26 	vldr	s7, [r3, #152]	; 0x98
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b37a:	eea7 6a25 	vfma.f32	s12, s14, s11
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b37e:	ed9f 2a27 	vldr	s4, [pc, #156]	; 1b41c <SFXVocoderChFrame+0x158>
	oneMinusStereo = 1.0f - displayValues[13];
   1b382:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b386:	edd3 5a24 	vldr	s11, [r3, #144]	; 0x90
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b38a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b38e:	4c24      	ldr	r4, [pc, #144]	; (1b420 <SFXVocoderChFrame+0x15c>)
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1b390:	6f5e      	ldr	r6, [r3, #116]	; 0x74
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b392:	ee65 5a82 	vmul.f32	s11, s11, s4
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1b396:	6f98      	ldr	r0, [r3, #120]	; 0x78
	oneMinusStereo = 1.0f - displayValues[13];
   1b398:	ee37 7a63 	vsub.f32	s14, s14, s7
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1b39c:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b39e:	ee77 7aa2 	vadd.f32	s15, s15, s5
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1b3a2:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b3a6:	46a9      	mov	r9, r5
	displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
   1b3a8:	6126      	str	r6, [r4, #16]
	displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
   1b3aa:	6160      	str	r0, [r4, #20]
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1b3ac:	f8d3 6084 	ldr.w	r6, [r3, #132]	; 0x84
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1b3b0:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
	displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
   1b3b4:	61a1      	str	r1, [r4, #24]
	displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
   1b3b6:	61e2      	str	r2, [r4, #28]
	displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
   1b3b8:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
	chVocOutputGain = 9.0f * displayValues[0];
   1b3bc:	4a19      	ldr	r2, [pc, #100]	; (1b424 <SFXVocoderChFrame+0x160>)
	oneMinusStereo = 1.0f - displayValues[13];
   1b3be:	4b1a      	ldr	r3, [pc, #104]	; (1b428 <SFXVocoderChFrame+0x164>)
	displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
   1b3c0:	6226      	str	r6, [r4, #32]
	displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
   1b3c2:	edc4 7a02 	vstr	s15, [r4, #8]
	displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
   1b3c6:	ed84 4a01 	vstr	s8, [r4, #4]
	displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
   1b3ca:	edc4 4a03 	vstr	s9, [r4, #12]
	displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
   1b3ce:	6260      	str	r0, [r4, #36]	; 0x24
	displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
   1b3d0:	ed84 5a0a 	vstr	s10, [r4, #40]	; 0x28
	displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
   1b3d4:	edc4 5a0b 	vstr	s11, [r4, #44]	; 0x2c
	displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
   1b3d8:	ed84 6a0c 	vstr	s12, [r4, #48]	; 0x30
	displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
   1b3dc:	63a1      	str	r1, [r4, #56]	; 0x38
	displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
   1b3de:	ed84 3a00 	vstr	s6, [r4]
	chVocOutputGain = 9.0f * displayValues[0];
   1b3e2:	edc2 6a00 	vstr	s13, [r2]
   1b3e6:	4f11      	ldr	r7, [pc, #68]	; (1b42c <SFXVocoderChFrame+0x168>)
	displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
   1b3e8:	edc4 3a0d 	vstr	s7, [r4, #52]	; 0x34
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b3ec:	4e05      	ldr	r6, [pc, #20]	; (1b404 <SFXVocoderChFrame+0x140>)
	oneMinusStereo = 1.0f - displayValues[13];
   1b3ee:	ed83 7a00 	vstr	s14, [r3]
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b3f2:	ed9f 8a0f 	vldr	s16, [pc, #60]	; 1b430 <SFXVocoderChFrame+0x16c>
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b3f6:	f8df 803c 	ldr.w	r8, [pc, #60]	; 1b434 <SFXVocoderChFrame+0x170>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b3fa:	e06d      	b.n	1b4d8 <SFXVocoderChFrame+0x214>
   1b3fc:	020fb31c 	.word	0x020fb31c
   1b400:	00062ae4 	.word	0x00062ae4
   1b404:	020fa15c 	.word	0x020fa15c
   1b408:	020f9318 	.word	0x020f9318
   1b40c:	41873333 	.word	0x41873333
   1b410:	3dcccccd 	.word	0x3dcccccd
   1b414:	3f4ccccd 	.word	0x3f4ccccd
   1b418:	becccccd 	.word	0xbecccccd
   1b41c:	42700000 	.word	0x42700000
   1b420:	020fb3cc 	.word	0x020fb3cc
   1b424:	00062a80 	.word	0x00062a80
   1b428:	00062ae8 	.word	0x00062ae8
   1b42c:	020f9a44 	.word	0x020f9a44
   1b430:	00000000 	.word	0x00000000
   1b434:	2aaaaaab 	.word	0x2aaaaaab
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b438:	f00f f8b6 	bl	2a5a8 <tSimplePoly_getVelocity>
   1b43c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1b440:	2800      	cmp	r0, #0
   1b442:	4658      	mov	r0, fp
   1b444:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1b448:	f00c fd8a 	bl	27f60 <tExpSmooth_setDest>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1b44c:	4651      	mov	r1, sl
   1b44e:	4630      	mov	r0, r6
   1b450:	f00f f89e 	bl	2a590 <tSimplePoly_getPitch>
   1b454:	ee07 0a90 	vmov	s15, r0
   1b458:	4ad0      	ldr	r2, [pc, #832]	; (1b79c <SFXVocoderChFrame+0x4d8>)
   1b45a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b45e:	4bd0      	ldr	r3, [pc, #832]	; (1b7a0 <SFXVocoderChFrame+0x4dc>)
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1b460:	ed92 0a00 	vldr	s0, [r2]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b464:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1b466:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1b46a:	49ce      	ldr	r1, [pc, #824]	; (1b7a4 <SFXVocoderChFrame+0x4e0>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1b46c:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1b470:	ee17 3a90 	vmov	r3, s15
   1b474:	1a9b      	subs	r3, r3, r2
   1b476:	fb88 2003 	smull	r2, r0, r8, r3
   1b47a:	17da      	asrs	r2, r3, #31
   1b47c:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1b480:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1b484:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1b488:	ee07 3a90 	vmov	s15, r3
   1b48c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1b490:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1b494:	ee17 3a90 	vmov	r3, s15
   1b498:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1b49c:	ed93 0a00 	vldr	s0, [r3]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1b4a0:	ee37 0a00 	vadd.f32	s0, s14, s0
   1b4a4:	f00e fada 	bl	29a5c <LEAF_midiToFrequency>
		tSawtooth_setFreq(&osc[i], freq[i]);
   1b4a8:	48bf      	ldr	r0, [pc, #764]	; (1b7a8 <SFXVocoderChFrame+0x4e4>)
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1b4aa:	ed87 0a00 	vstr	s0, [r7]
		tSawtooth_setFreq(&osc[i], freq[i]);
   1b4ae:	4428      	add	r0, r5
   1b4b0:	f00f f930 	bl	2a714 <tSawtooth_setFreq>
   1b4b4:	4bbd      	ldr	r3, [pc, #756]	; (1b7ac <SFXVocoderChFrame+0x4e8>)
		tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
   1b4b6:	ecb7 0a01 	vldmia	r7!, {s0}
   1b4ba:	eb05 0a03 	add.w	sl, r5, r3
   1b4be:	3504      	adds	r5, #4
   1b4c0:	4650      	mov	r0, sl
   1b4c2:	f00b f887 	bl	265d4 <tRosenbergGlottalPulse_setFreq>
		tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[6] * displayValues[7], displayValues[6]);
   1b4c6:	edd4 0a06 	vldr	s1, [r4, #24]
   1b4ca:	ed94 0a07 	vldr	s0, [r4, #28]
   1b4ce:	4650      	mov	r0, sl
   1b4d0:	ee20 0a80 	vmul.f32	s0, s1, s0
   1b4d4:	f00b f8a8 	bl	26628 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b4d8:	4630      	mov	r0, r6
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b4da:	fa5f fa89 	uxtb.w	sl, r9
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b4de:	f00f f83b 	bl	2a558 <tSimplePoly_getNumVoices>
   1b4e2:	4bb3      	ldr	r3, [pc, #716]	; (1b7b0 <SFXVocoderChFrame+0x4ec>)
   1b4e4:	4548      	cmp	r0, r9
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1b4e6:	4651      	mov	r1, sl
   1b4e8:	4630      	mov	r0, r6
   1b4ea:	eb05 0b03 	add.w	fp, r5, r3
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1b4ee:	f109 0901 	add.w	r9, r9, #1
   1b4f2:	dca1      	bgt.n	1b438 <SFXVocoderChFrame+0x174>
	numberOfVocoderBands = displayValues[2];
   1b4f4:	ed94 7a02 	vldr	s14, [r4, #8]
	float warpFactor = 1.0f + displayValues[1];
   1b4f8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b4fc:	4ead      	ldr	r6, [pc, #692]	; (1b7b4 <SFXVocoderChFrame+0x4f0>)
	numberOfVocoderBands = displayValues[2];
   1b4fe:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   1b502:	4dad      	ldr	r5, [pc, #692]	; (1b7b8 <SFXVocoderChFrame+0x4f4>)
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b504:	7833      	ldrb	r3, [r6, #0]
	float warpFactor = 1.0f + displayValues[1];
   1b506:	edd4 8a01 	vldr	s17, [r4, #4]
	numberOfVocoderBands = displayValues[2];
   1b50a:	ed8d 7a00 	vstr	s14, [sp]
   1b50e:	f89d 1000 	ldrb.w	r1, [sp]
	float warpFactor = 1.0f + displayValues[1];
   1b512:	ee78 8aa7 	vadd.f32	s17, s17, s15
	float myQ = displayValues[3];
   1b516:	ed94 8a03 	vldr	s16, [r4, #12]
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b51a:	428b      	cmp	r3, r1
	float bandSquish = displayValues[10];
   1b51c:	ed94 9a0a 	vldr	s18, [r4, #40]	; 0x28
	numberOfVocoderBands = displayValues[2];
   1b520:	7029      	strb	r1, [r5, #0]
	float bandOffset = displayValues[11];
   1b522:	ed94 aa0b 	vldr	s20, [r4, #44]	; 0x2c
	float myTilt = displayValues[12];
   1b526:	edd4 aa0c 	vldr	s21, [r4, #48]	; 0x30
	float barkPull = displayValues[14];
   1b52a:	edd4 9a0e 	vldr	s19, [r4, #56]	; 0x38
   1b52e:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 1b81c <SFXVocoderChFrame+0x558>
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b532:	f000 8107 	beq.w	1b744 <SFXVocoderChFrame+0x480>
   1b536:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 1b820 <SFXVocoderChFrame+0x55c>
   1b53a:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 1b824 <SFXVocoderChFrame+0x560>
   1b53e:	4b9f      	ldr	r3, [pc, #636]	; (1b7bc <SFXVocoderChFrame+0x4f8>)
   1b540:	9300      	str	r3, [sp, #0]
   1b542:	4b9f      	ldr	r3, [pc, #636]	; (1b7c0 <SFXVocoderChFrame+0x4fc>)
   1b544:	9301      	str	r3, [sp, #4]
   1b546:	4b9f      	ldr	r3, [pc, #636]	; (1b7c4 <SFXVocoderChFrame+0x500>)
   1b548:	9302      	str	r3, [sp, #8]
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b54a:	ee07 1a90 	vmov	s15, r1
   1b54e:	ed9f 6a9e 	vldr	s12, [pc, #632]	; 1b7c8 <SFXVocoderChFrame+0x504>
   1b552:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b556:	ed9f 7a9d 	vldr	s14, [pc, #628]	; 1b7cc <SFXVocoderChFrame+0x508>
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b55a:	eef8 6a67 	vcvt.f32.u32	s13, s15
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b55e:	eddf 7a9c 	vldr	s15, [pc, #624]	; 1b7d0 <SFXVocoderChFrame+0x50c>
		alteringBands = 1;
   1b562:	499c      	ldr	r1, [pc, #624]	; (1b7d4 <SFXVocoderChFrame+0x510>)
   1b564:	f04f 0c01 	mov.w	ip, #1
		invMyQ = 1.0f / myQ;
   1b568:	ee85 5a88 	vdiv.f32	s10, s11, s16
   1b56c:	4b9a      	ldr	r3, [pc, #616]	; (1b7d8 <SFXVocoderChFrame+0x514>)
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b56e:	489b      	ldr	r0, [pc, #620]	; (1b7dc <SFXVocoderChFrame+0x518>)
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b570:	4a9b      	ldr	r2, [pc, #620]	; (1b7e0 <SFXVocoderChFrame+0x51c>)
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b572:	f8df e2b4 	ldr.w	lr, [pc, #692]	; 1b828 <SFXVocoderChFrame+0x564>
		thisBandwidth = bandWidthInOctaves * myQ;
   1b576:	4f9b      	ldr	r7, [pc, #620]	; (1b7e4 <SFXVocoderChFrame+0x520>)
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b578:	ee76 6ac6 	vsub.f32	s13, s13, s12
		alteringBands = 1;
   1b57c:	9103      	str	r1, [sp, #12]
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b57e:	ee69 7a27 	vmul.f32	s15, s18, s15
		alteringBands = 1;
   1b582:	f8c1 c000 	str.w	ip, [r1]
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b586:	ee85 6aa6 	vdiv.f32	s12, s11, s13
		invMyQ = 1.0f / myQ;
   1b58a:	ed83 5a00 	vstr	s10, [r3]
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b58e:	ee67 7a86 	vmul.f32	s15, s15, s12
		invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
   1b592:	ed82 6a00 	vstr	s12, [r2]
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b596:	ee27 7a87 	vmul.f32	s14, s15, s14
		bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
   1b59a:	edc0 7a00 	vstr	s15, [r0]
		thisBandwidth = bandWidthInOctaves * myQ;
   1b59e:	ee67 6a08 	vmul.f32	s13, s14, s16
		bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
   1b5a2:	ed8e 7a00 	vstr	s14, [lr]
		thisBandwidth = bandWidthInOctaves * myQ;
   1b5a6:	edc7 6a00 	vstr	s13, [r7]
		float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b5aa:	f8df 9280 	ldr.w	r9, [pc, #640]	; 1b82c <SFXVocoderChFrame+0x568>
   1b5ae:	eeb0 0a4a 	vmov.f32	s0, s20
	float oneMinusBarkPull = 1.0f - barkPull;
   1b5b2:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
		float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b5b6:	ed99 7a00 	vldr	s14, [r9]
   1b5ba:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	float oneMinusBarkPull = 1.0f - barkPull;
   1b5be:	ee7b ba69 	vsub.f32	s23, s22, s19
		float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
   1b5c2:	eea7 0a27 	vfma.f32	s0, s14, s15
   1b5c6:	e9cd 3204 	strd	r3, r2, [sp, #16]
   1b5ca:	f00e facb 	bl	29b64 <faster_mtof>
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b5ce:	f8d9 c000 	ldr.w	ip, [r9]
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b5d2:	9a05      	ldr	r2, [sp, #20]
   1b5d4:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b5d8:	ea4f 018c 	mov.w	r1, ip, lsl #2
   1b5dc:	4882      	ldr	r0, [pc, #520]	; (1b7e8 <SFXVocoderChFrame+0x524>)
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b5de:	edd2 6a00 	vldr	s13, [r2]
		float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
   1b5e2:	ee06 ca10 	vmov	s12, ip
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b5e6:	4408      	add	r0, r1
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b5e8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
   1b5ec:	eeb8 4ac6 	vcvt.f32.s32	s8, s12
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b5f0:	4a7e      	ldr	r2, [pc, #504]	; (1b7ec <SFXVocoderChFrame+0x528>)
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b5f2:	ee66 6aa7 	vmul.f32	s13, s13, s15
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b5f6:	edd0 7a00 	vldr	s15, [r0]
		float tiltOffset = (1.0f - ((myTilt * 0.5f) + 0.5f)) + 0.5f;
   1b5fa:	ee7a 4a8b 	vadd.f32	s9, s21, s22
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b5fe:	9b04      	ldr	r3, [sp, #16]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b600:	ee69 7aa7 	vmul.f32	s15, s19, s15
		if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
   1b604:	eddf 5a7a 	vldr	s11, [pc, #488]	; 1b7f0 <SFXVocoderChFrame+0x52c>
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b608:	eea4 7a26 	vfma.f32	s14, s8, s13
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b60c:	440a      	add	r2, r1
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b60e:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b612:	ed93 6a00 	vldr	s12, [r3]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b616:	eeeb 7a80 	vfma.f32	s15, s23, s0
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b61a:	4b76      	ldr	r3, [pc, #472]	; (1b7f4 <SFXVocoderChFrame+0x530>)
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b61c:	ee68 6a29 	vmul.f32	s13, s16, s19
   1b620:	edd2 0a00 	vldr	s1, [r2]
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b624:	4419      	add	r1, r3
		if (analysisOrSynthesis == 0)
   1b626:	4b74      	ldr	r3, [pc, #464]	; (1b7f8 <SFXVocoderChFrame+0x534>)
   1b628:	ea4f 00cc 	mov.w	r0, ip, lsl #3
		float tiltY = displayValues[12] * myHeight + tiltOffset;
   1b62c:	eea4 7ac5 	vfms.f32	s14, s9, s10
		if (analysisOrSynthesis == 0)
   1b630:	681b      	ldr	r3, [r3, #0]
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b632:	ee66 0aa0 	vmul.f32	s1, s13, s1
   1b636:	edd7 6a00 	vldr	s13, [r7]
		bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
   1b63a:	eeb0 0a67 	vmov.f32	s0, s15
   1b63e:	eddf 7a6f 	vldr	s15, [pc, #444]	; 1b7fc <SFXVocoderChFrame+0x538>
		float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
   1b642:	eee6 0aab 	vfma.f32	s1, s13, s23
		float tempWarpFactor = warpFactor;
   1b646:	eeb4 0ae5 	vcmpe.f32	s0, s11
   1b64a:	fe80 0a67 	vminnm.f32	s0, s0, s15
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b64e:	ee27 7a06 	vmul.f32	s14, s14, s12
		float tempWarpFactor = warpFactor;
   1b652:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		bandGains[currentBandToAlter] = invMyQ * tiltY;
   1b656:	ed81 7a00 	vstr	s14, [r1]
		float tempWarpFactor = warpFactor;
   1b65a:	bf98      	it	ls
   1b65c:	eeb0 ba68 	vmovls.f32	s22, s17
		if (analysisOrSynthesis == 0)
   1b660:	2b00      	cmp	r3, #0
   1b662:	f040 8100 	bne.w	1b866 <SFXVocoderChFrame+0x5a2>
			tVZFilter_setFreqAndBandwidth(&analysisBands[currentBandToAlter][0], bandFreq, bandBandwidth);
   1b666:	4f66      	ldr	r7, [pc, #408]	; (1b800 <SFXVocoderChFrame+0x53c>)
   1b668:	4438      	add	r0, r7
   1b66a:	f00d fc19 	bl	28ea0 <tVZFilter_setFreqAndBandwidth>
			analysisBands[currentBandToAlter][1]->B = analysisBands[currentBandToAlter][0]->B;
   1b66e:	f8d9 3000 	ldr.w	r3, [r9]
   1b672:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b676:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   1b67a:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1b67c:	6851      	ldr	r1, [r2, #4]
   1b67e:	6348      	str	r0, [r1, #52]	; 0x34
			analysisBands[currentBandToAlter][1]->fc = analysisBands[currentBandToAlter][0]->fc;
   1b680:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b684:	6851      	ldr	r1, [r2, #4]
   1b686:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1b688:	6288      	str	r0, [r1, #40]	; 0x28
			analysisBands[currentBandToAlter][1]->R2 = analysisBands[currentBandToAlter][0]->R2;
   1b68a:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b68e:	6851      	ldr	r1, [r2, #4]
   1b690:	6940      	ldr	r0, [r0, #20]
   1b692:	6148      	str	r0, [r1, #20]
			analysisBands[currentBandToAlter][1]->cL = analysisBands[currentBandToAlter][0]->cL;
   1b694:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b698:	6851      	ldr	r1, [r2, #4]
   1b69a:	69c0      	ldr	r0, [r0, #28]
   1b69c:	61c8      	str	r0, [r1, #28]
			analysisBands[currentBandToAlter][1]->cB = analysisBands[currentBandToAlter][0]->cB;
   1b69e:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b6a2:	6851      	ldr	r1, [r2, #4]
   1b6a4:	6a00      	ldr	r0, [r0, #32]
   1b6a6:	6208      	str	r0, [r1, #32]
			analysisBands[currentBandToAlter][1]->cH = analysisBands[currentBandToAlter][0]->cH;
   1b6a8:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b6ac:	6851      	ldr	r1, [r2, #4]
   1b6ae:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1b6b0:	6248      	str	r0, [r1, #36]	; 0x24
			analysisBands[currentBandToAlter][1]->h = analysisBands[currentBandToAlter][0]->h;
   1b6b2:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b6b6:	6851      	ldr	r1, [r2, #4]
   1b6b8:	6980      	ldr	r0, [r0, #24]
   1b6ba:	6188      	str	r0, [r1, #24]
			analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
   1b6bc:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   1b6c0:	6852      	ldr	r2, [r2, #4]
   1b6c2:	6909      	ldr	r1, [r1, #16]
			analysisOrSynthesis++;
   1b6c4:	484c      	ldr	r0, [pc, #304]	; (1b7f8 <SFXVocoderChFrame+0x534>)
			analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
   1b6c6:	6111      	str	r1, [r2, #16]
			analysisOrSynthesis++;
   1b6c8:	6802      	ldr	r2, [r0, #0]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b6ca:	7829      	ldrb	r1, [r5, #0]
			analysisOrSynthesis++;
   1b6cc:	3201      	adds	r2, #1
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b6ce:	428b      	cmp	r3, r1
			analysisOrSynthesis++;
   1b6d0:	6002      	str	r2, [r0, #0]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b6d2:	db02      	blt.n	1b6da <SFXVocoderChFrame+0x416>
   1b6d4:	2a00      	cmp	r2, #0
   1b6d6:	f000 8105 	beq.w	1b8e4 <SFXVocoderChFrame+0x620>
	prevBandOffset = bandOffset;
   1b6da:	9b00      	ldr	r3, [sp, #0]
	prevNumberOfVocoderBands = numberOfVocoderBands;
   1b6dc:	7031      	strb	r1, [r6, #0]
	prevBandOffset = bandOffset;
   1b6de:	ed83 aa00 	vstr	s20, [r3]
	prevMyTilt = myTilt;
   1b6e2:	9b01      	ldr	r3, [sp, #4]
	prevMyQ = myQ;
   1b6e4:	ed88 8a00 	vstr	s16, [r8]
	prevMyTilt = myTilt;
   1b6e8:	edc3 aa00 	vstr	s21, [r3]
	prevBarkPull = barkPull;
   1b6ec:	9b02      	ldr	r3, [sp, #8]
	prevWarpFactor = warpFactor;
   1b6ee:	edca 8a00 	vstr	s17, [sl]
	prevBandSquish = bandSquish;
   1b6f2:	ed8b 9a00 	vstr	s18, [fp]
	prevBarkPull = barkPull;
   1b6f6:	edc3 9a00 	vstr	s19, [r3]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1b6fa:	b199      	cbz	r1, 1b724 <SFXVocoderChFrame+0x460>
   1b6fc:	4f41      	ldr	r7, [pc, #260]	; (1b804 <SFXVocoderChFrame+0x540>)
   1b6fe:	2600      	movs	r6, #0
		tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1b700:	eddf 8a41 	vldr	s17, [pc, #260]	; 1b808 <SFXVocoderChFrame+0x544>
   1b704:	ed9f 8a41 	vldr	s16, [pc, #260]	; 1b80c <SFXVocoderChFrame+0x548>
   1b708:	eeb0 0a48 	vmov.f32	s0, s16
   1b70c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   1b710:	4638      	mov	r0, r7
	for (int i = 0; i < numberOfVocoderBands; i++)
   1b712:	3601      	adds	r6, #1
   1b714:	3704      	adds	r7, #4
		tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
   1b716:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1b71a:	f00c fc0f 	bl	27f3c <tExpSmooth_setFactor>
	for (int i = 0; i < numberOfVocoderBands; i++)
   1b71e:	782b      	ldrb	r3, [r5, #0]
   1b720:	42b3      	cmp	r3, r6
   1b722:	dcf1      	bgt.n	1b708 <SFXVocoderChFrame+0x444>
	if (tSimplePoly_getNumActiveVoices(&poly) != 0)
   1b724:	483a      	ldr	r0, [pc, #232]	; (1b810 <SFXVocoderChFrame+0x54c>)
   1b726:	f00e ff1b 	bl	2a560 <tSimplePoly_getNumActiveVoices>
   1b72a:	2800      	cmp	r0, #0
   1b72c:	f040 80e0 	bne.w	1b8f0 <SFXVocoderChFrame+0x62c>
		tExpSmooth_setDest(&comp, 0.0f);
   1b730:	ed9f 0a38 	vldr	s0, [pc, #224]	; 1b814 <SFXVocoderChFrame+0x550>
   1b734:	4838      	ldr	r0, [pc, #224]	; (1b818 <SFXVocoderChFrame+0x554>)
}
   1b736:	b007      	add	sp, #28
   1b738:	ecbd 8b08 	vpop	{d8-d11}
   1b73c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		tExpSmooth_setDest(&comp, 0.0f);
   1b740:	f00c bc0e 	b.w	27f60 <tExpSmooth_setDest>
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b744:	edd8 7a00 	vldr	s15, [r8]
   1b748:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 1b820 <SFXVocoderChFrame+0x55c>
   1b74c:	eef4 7a48 	vcmp.f32	s15, s16
   1b750:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b754:	f47f aef1 	bne.w	1b53a <SFXVocoderChFrame+0x276>
   1b758:	edda 7a00 	vldr	s15, [sl]
   1b75c:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 1b824 <SFXVocoderChFrame+0x560>
   1b760:	eef4 7a68 	vcmp.f32	s15, s17
   1b764:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b768:	f47f aee9 	bne.w	1b53e <SFXVocoderChFrame+0x27a>
   1b76c:	eddb 7a00 	vldr	s15, [fp]
   1b770:	4b12      	ldr	r3, [pc, #72]	; (1b7bc <SFXVocoderChFrame+0x4f8>)
   1b772:	eef4 7a49 	vcmp.f32	s15, s18
   1b776:	9300      	str	r3, [sp, #0]
   1b778:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b77c:	f040 80cd 	bne.w	1b91a <SFXVocoderChFrame+0x656>
   1b780:	edd3 7a00 	vldr	s15, [r3]
   1b784:	4b0e      	ldr	r3, [pc, #56]	; (1b7c0 <SFXVocoderChFrame+0x4fc>)
   1b786:	eef4 7a4a 	vcmp.f32	s15, s20
   1b78a:	9301      	str	r3, [sp, #4]
   1b78c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b790:	f000 80c8 	beq.w	1b924 <SFXVocoderChFrame+0x660>
   1b794:	4b0b      	ldr	r3, [pc, #44]	; (1b7c4 <SFXVocoderChFrame+0x500>)
   1b796:	9302      	str	r3, [sp, #8]
   1b798:	e6d7      	b.n	1b54a <SFXVocoderChFrame+0x286>
   1b79a:	bf00      	nop
   1b79c:	020e31e0 	.word	0x020e31e0
   1b7a0:	020e3258 	.word	0x020e3258
   1b7a4:	020e3224 	.word	0x020e3224
   1b7a8:	020f9f1c 	.word	0x020f9f1c
   1b7ac:	020f8e50 	.word	0x020f8e50
   1b7b0:	020fa558 	.word	0x020fa558
   1b7b4:	00062afc 	.word	0x00062afc
   1b7b8:	00062ae5 	.word	0x00062ae5
   1b7bc:	00062af0 	.word	0x00062af0
   1b7c0:	020e31ec 	.word	0x020e31ec
   1b7c4:	020e31e8 	.word	0x020e31e8
   1b7c8:	3f7d70a4 	.word	0x3f7d70a4
   1b7cc:	3daaaaab 	.word	0x3daaaaab
   1b7d0:	42bc0000 	.word	0x42bc0000
   1b7d4:	020e311c 	.word	0x020e311c
   1b7d8:	00062ad4 	.word	0x00062ad4
   1b7dc:	020fa150 	.word	0x020fa150
   1b7e0:	00062ad8 	.word	0x00062ad8
   1b7e4:	020f8e48 	.word	0x020f8e48
   1b7e8:	000629c0 	.word	0x000629c0
   1b7ec:	00062a20 	.word	0x00062a20
   1b7f0:	459c4000 	.word	0x459c4000
   1b7f4:	020f9eb8 	.word	0x020f9eb8
   1b7f8:	020e3120 	.word	0x020e3120
   1b7fc:	467a0000 	.word	0x467a0000
   1b800:	020fae74 	.word	0x020fae74
   1b804:	020fa268 	.word	0x020fa268
   1b808:	3ac49ba6 	.word	0x3ac49ba6
   1b80c:	38d1b717 	.word	0x38d1b717
   1b810:	020fa15c 	.word	0x020fa15c
   1b814:	00000000 	.word	0x00000000
   1b818:	020f9e9c 	.word	0x020f9e9c
   1b81c:	00062af8 	.word	0x00062af8
   1b820:	00062b04 	.word	0x00062b04
   1b824:	00062af4 	.word	0x00062af4
   1b828:	020f9a70 	.word	0x020f9a70
   1b82c:	020e3174 	.word	0x020e3174
		internalExternal = !internalExternal;
   1b830:	4a4c      	ldr	r2, [pc, #304]	; (1b964 <SFXVocoderChFrame+0x6a0>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1b832:	2100      	movs	r1, #0
		internalExternal = !internalExternal;
   1b834:	7813      	ldrb	r3, [r2, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1b836:	7621      	strb	r1, [r4, #24]
		internalExternal = !internalExternal;
   1b838:	fab3 f383 	clz	r3, r3
   1b83c:	095b      	lsrs	r3, r3, #5
		setLED_B(internalExternal);
   1b83e:	4618      	mov	r0, r3
		internalExternal = !internalExternal;
   1b840:	7013      	strb	r3, [r2, #0]
		setLED_B(internalExternal);
   1b842:	f7fd fe89 	bl	19558 <setLED_B>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1b846:	7f23      	ldrb	r3, [r4, #28]
   1b848:	2b01      	cmp	r3, #1
   1b84a:	f47f ad60 	bne.w	1b30e <SFXVocoderChFrame+0x4a>
		vocChFreeze = !vocChFreeze;
   1b84e:	4a46      	ldr	r2, [pc, #280]	; (1b968 <SFXVocoderChFrame+0x6a4>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1b850:	2100      	movs	r1, #0
		vocChFreeze = !vocChFreeze;
   1b852:	6813      	ldr	r3, [r2, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1b854:	7721      	strb	r1, [r4, #28]
		vocChFreeze = !vocChFreeze;
   1b856:	fab3 f383 	clz	r3, r3
   1b85a:	095b      	lsrs	r3, r3, #5
		setLED_C(vocChFreeze);
   1b85c:	4618      	mov	r0, r3
		vocChFreeze = !vocChFreeze;
   1b85e:	6013      	str	r3, [r2, #0]
		setLED_C(vocChFreeze);
   1b860:	f7fd fe88 	bl	19574 <setLED_C>
   1b864:	e553      	b.n	1b30e <SFXVocoderChFrame+0x4a>
			tVZFilter_setFreqAndBandwidth(&synthesisBands[currentBandToAlter][0], bandFreq * tempWarpFactor, bandBandwidth);
   1b866:	4f41      	ldr	r7, [pc, #260]	; (1b96c <SFXVocoderChFrame+0x6a8>)
   1b868:	ee2b 0a00 	vmul.f32	s0, s22, s0
   1b86c:	4438      	add	r0, r7
   1b86e:	f00d fb17 	bl	28ea0 <tVZFilter_setFreqAndBandwidth>
			synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1b872:	f8d9 3000 	ldr.w	r3, [r9]
			analysisOrSynthesis = 0;
   1b876:	f04f 0e00 	mov.w	lr, #0
			synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1b87a:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b87e:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
			currentBandToAlter++;
   1b882:	f103 0c01 	add.w	ip, r3, #1
			synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
   1b886:	6851      	ldr	r1, [r2, #4]
   1b888:	6b40      	ldr	r0, [r0, #52]	; 0x34
   1b88a:	6348      	str	r0, [r1, #52]	; 0x34
			synthesisBands[currentBandToAlter][1]->fc = synthesisBands[currentBandToAlter][0]->fc;
   1b88c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b890:	6851      	ldr	r1, [r2, #4]
   1b892:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1b894:	6288      	str	r0, [r1, #40]	; 0x28
			synthesisBands[currentBandToAlter][1]->R2 = synthesisBands[currentBandToAlter][0]->R2;
   1b896:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b89a:	6851      	ldr	r1, [r2, #4]
   1b89c:	6940      	ldr	r0, [r0, #20]
   1b89e:	6148      	str	r0, [r1, #20]
			synthesisBands[currentBandToAlter][1]->cL = synthesisBands[currentBandToAlter][0]->cL;
   1b8a0:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b8a4:	6851      	ldr	r1, [r2, #4]
   1b8a6:	69c0      	ldr	r0, [r0, #28]
   1b8a8:	61c8      	str	r0, [r1, #28]
			synthesisBands[currentBandToAlter][1]->cB = synthesisBands[currentBandToAlter][0]->cB;
   1b8aa:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b8ae:	6851      	ldr	r1, [r2, #4]
   1b8b0:	6a00      	ldr	r0, [r0, #32]
   1b8b2:	6208      	str	r0, [r1, #32]
			synthesisBands[currentBandToAlter][1]->cH = synthesisBands[currentBandToAlter][0]->cH;
   1b8b4:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b8b8:	6851      	ldr	r1, [r2, #4]
   1b8ba:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1b8bc:	6248      	str	r0, [r1, #36]	; 0x24
			synthesisBands[currentBandToAlter][1]->h = synthesisBands[currentBandToAlter][0]->h;
   1b8be:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
   1b8c2:	6851      	ldr	r1, [r2, #4]
   1b8c4:	6980      	ldr	r0, [r0, #24]
   1b8c6:	6188      	str	r0, [r1, #24]
			synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
   1b8c8:	f857 3033 	ldr.w	r3, [r7, r3, lsl #3]
   1b8cc:	6852      	ldr	r2, [r2, #4]
   1b8ce:	691b      	ldr	r3, [r3, #16]
   1b8d0:	6113      	str	r3, [r2, #16]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b8d2:	7829      	ldrb	r1, [r5, #0]
			analysisOrSynthesis = 0;
   1b8d4:	4b26      	ldr	r3, [pc, #152]	; (1b970 <SFXVocoderChFrame+0x6ac>)
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b8d6:	458c      	cmp	ip, r1
			currentBandToAlter++;
   1b8d8:	f8c9 c000 	str.w	ip, [r9]
			analysisOrSynthesis = 0;
   1b8dc:	f8c3 e000 	str.w	lr, [r3]
		if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
   1b8e0:	f6ff aefb 	blt.w	1b6da <SFXVocoderChFrame+0x416>
			alteringBands = 0;
   1b8e4:	2300      	movs	r3, #0
   1b8e6:	9a03      	ldr	r2, [sp, #12]
			currentBandToAlter = 0;
   1b8e8:	f8c9 3000 	str.w	r3, [r9]
			alteringBands = 0;
   1b8ec:	6013      	str	r3, [r2, #0]
   1b8ee:	e6f4      	b.n	1b6da <SFXVocoderChFrame+0x416>
		tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
   1b8f0:	4820      	ldr	r0, [pc, #128]	; (1b974 <SFXVocoderChFrame+0x6b0>)
   1b8f2:	f00e fe35 	bl	2a560 <tSimplePoly_getNumActiveVoices>
   1b8f6:	ee07 0a90 	vmov	s15, r0
   1b8fa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1b8fe:	481e      	ldr	r0, [pc, #120]	; (1b978 <SFXVocoderChFrame+0x6b4>)
   1b900:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1b904:	ee87 0a27 	vdiv.f32	s0, s14, s15
   1b908:	eeb1 0ac0 	vsqrt.f32	s0, s0
}
   1b90c:	b007      	add	sp, #28
   1b90e:	ecbd 8b08 	vpop	{d8-d11}
   1b912:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		tExpSmooth_setDest(&comp, 0.0f);
   1b916:	f00c bb23 	b.w	27f60 <tExpSmooth_setDest>
   1b91a:	4b18      	ldr	r3, [pc, #96]	; (1b97c <SFXVocoderChFrame+0x6b8>)
   1b91c:	9301      	str	r3, [sp, #4]
   1b91e:	4b18      	ldr	r3, [pc, #96]	; (1b980 <SFXVocoderChFrame+0x6bc>)
   1b920:	9302      	str	r3, [sp, #8]
   1b922:	e612      	b.n	1b54a <SFXVocoderChFrame+0x286>
	if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
   1b924:	edd3 7a00 	vldr	s15, [r3]
   1b928:	4b15      	ldr	r3, [pc, #84]	; (1b980 <SFXVocoderChFrame+0x6bc>)
   1b92a:	eef4 7a6a 	vcmp.f32	s15, s21
   1b92e:	9302      	str	r3, [sp, #8]
   1b930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b934:	f47f ae09 	bne.w	1b54a <SFXVocoderChFrame+0x286>
   1b938:	edd3 7a00 	vldr	s15, [r3]
   1b93c:	eef4 7a69 	vcmp.f32	s15, s19
   1b940:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1b944:	f47f ae01 	bne.w	1b54a <SFXVocoderChFrame+0x286>
	if (alteringBands)
   1b948:	4b0e      	ldr	r3, [pc, #56]	; (1b984 <SFXVocoderChFrame+0x6c0>)
   1b94a:	9303      	str	r3, [sp, #12]
   1b94c:	681b      	ldr	r3, [r3, #0]
   1b94e:	2b00      	cmp	r3, #0
   1b950:	f43f aec3 	beq.w	1b6da <SFXVocoderChFrame+0x416>
   1b954:	4b0c      	ldr	r3, [pc, #48]	; (1b988 <SFXVocoderChFrame+0x6c4>)
   1b956:	4a0d      	ldr	r2, [pc, #52]	; (1b98c <SFXVocoderChFrame+0x6c8>)
   1b958:	edd3 7a00 	vldr	s15, [r3]
   1b95c:	4f0c      	ldr	r7, [pc, #48]	; (1b990 <SFXVocoderChFrame+0x6cc>)
   1b95e:	4b0d      	ldr	r3, [pc, #52]	; (1b994 <SFXVocoderChFrame+0x6d0>)
   1b960:	e623      	b.n	1b5aa <SFXVocoderChFrame+0x2e6>
   1b962:	bf00      	nop
   1b964:	020e31a4 	.word	0x020e31a4
   1b968:	020e3218 	.word	0x020e3218
   1b96c:	020fa068 	.word	0x020fa068
   1b970:	020e3120 	.word	0x020e3120
   1b974:	020fa15c 	.word	0x020fa15c
   1b978:	020f9e9c 	.word	0x020f9e9c
   1b97c:	020e31ec 	.word	0x020e31ec
   1b980:	020e31e8 	.word	0x020e31e8
   1b984:	020e311c 	.word	0x020e311c
   1b988:	020fa150 	.word	0x020fa150
   1b98c:	00062ad8 	.word	0x00062ad8
   1b990:	020f8e48 	.word	0x020f8e48
   1b994:	00062ad4 	.word	0x00062ad4

0001b998 <SFXVocoderChTick>:
{
   1b998:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b99c:	4605      	mov	r5, r0
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1b99e:	489c      	ldr	r0, [pc, #624]	; (1bc10 <SFXVocoderChTick+0x278>)
{
   1b9a0:	ed2d 8b06 	vpush	{d8-d10}
   1b9a4:	b083      	sub	sp, #12
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1b9a6:	ed95 0a01 	vldr	s0, [r5, #4]
   1b9aa:	f00d f82b 	bl	28a04 <tVZFilter_tick>
	if (internalExternal == 1)
   1b9ae:	4b99      	ldr	r3, [pc, #612]	; (1bc14 <SFXVocoderChTick+0x27c>)
	input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
   1b9b0:	ed85 0a01 	vstr	s0, [r5, #4]
	if (internalExternal == 1)
   1b9b4:	781b      	ldrb	r3, [r3, #0]
   1b9b6:	2b01      	cmp	r3, #1
   1b9b8:	f040 80a8 	bne.w	1bb0c <SFXVocoderChTick+0x174>
		sample = input[0];
   1b9bc:	ed95 0a00 	vldr	s0, [r5]
   1b9c0:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 1bc7c <SFXVocoderChTick+0x2e4>
	sample = LEAF_tanh(sample);
   1b9c4:	f00d ffb0 	bl	29928 <LEAF_tanh>
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1b9c8:	eeb3 7a0e 	vmov.f32	s14, #62	; 0x41f00000  30.0
	sample = LEAF_tanh(sample);
   1b9cc:	eeb0 9a40 	vmov.f32	s18, s0
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1b9d0:	ed98 0a00 	vldr	s0, [r8]
   1b9d4:	edd5 7a01 	vldr	s15, [r5, #4]
   1b9d8:	ee20 0a07 	vmul.f32	s0, s0, s14
	for (int i = 0; i < numberOfVocoderBands; i++)
   1b9dc:	4f8e      	ldr	r7, [pc, #568]	; (1bc18 <SFXVocoderChTick+0x280>)
	float output[2] = {0.0f, 0.0f};
   1b9de:	ed9f 8a8f 	vldr	s16, [pc, #572]	; 1bc1c <SFXVocoderChTick+0x284>
	for (int i = 0; i < numberOfVocoderBands; i++)
   1b9e2:	783b      	ldrb	r3, [r7, #0]
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1b9e4:	ee20 0a27 	vmul.f32	s0, s0, s15
	float output[2] = {0.0f, 0.0f};
   1b9e8:	ed8d 8a00 	vstr	s16, [sp]
   1b9ec:	ed8d 8a01 	vstr	s16, [sp, #4]
	input[1] = input[1] * (displayValues[0] * 30.0f);
   1b9f0:	ed85 0a01 	vstr	s0, [r5, #4]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1b9f4:	2b00      	cmp	r3, #0
   1b9f6:	f000 8108 	beq.w	1bc0a <SFXVocoderChTick+0x272>
   1b9fa:	f04f 0b00 	mov.w	fp, #0
		tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1b9fe:	eef0 9a48 	vmov.f32	s19, s16
   1ba02:	4e87      	ldr	r6, [pc, #540]	; (1bc20 <SFXVocoderChTick+0x288>)
   1ba04:	46da      	mov	sl, fp
   1ba06:	f8df 8278 	ldr.w	r8, [pc, #632]	; 1bc80 <SFXVocoderChTick+0x2e8>
   1ba0a:	e02f      	b.n	1ba6c <SFXVocoderChTick+0xd4>
		tempSamp = tExpSmooth_tick(&envFollowers[i]);
   1ba0c:	4648      	mov	r0, r9
	for (int i = 0; i < numberOfVocoderBands; i++)
   1ba0e:	f10b 0b01 	add.w	fp, fp, #1
		tempSamp = tExpSmooth_tick(&envFollowers[i]);
   1ba12:	f00c faaf 	bl	27f74 <tExpSmooth_tick>
		tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1ba16:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
   1ba1a:	eef0 0a40 	vmov.f32	s1, s0
   1ba1e:	eeb0 0a69 	vmov.f32	s0, s19
   1ba22:	f00d ff31 	bl	29888 <LEAF_clip>
		tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
   1ba26:	4b7f      	ldr	r3, [pc, #508]	; (1bc24 <SFXVocoderChTick+0x28c>)
		tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
   1ba28:	eef0 8a40 	vmov.f32	s17, s0
		tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
   1ba2c:	1918      	adds	r0, r3, r4
   1ba2e:	eeb0 0a49 	vmov.f32	s0, s18
   1ba32:	f00d f825 	bl	28a80 <tVZFilter_tickEfficient>
		tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][1], tempSynth);
   1ba36:	4b7c      	ldr	r3, [pc, #496]	; (1bc28 <SFXVocoderChTick+0x290>)
   1ba38:	1918      	adds	r0, r3, r4
   1ba3a:	f00d f821 	bl	28a80 <tVZFilter_tickEfficient>
		output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1ba3e:	ee28 0a80 	vmul.f32	s0, s17, s0
   1ba42:	ecf6 7a01 	vldmia	r6!, {s15}
   1ba46:	ab02      	add	r3, sp, #8
   1ba48:	a902      	add	r1, sp, #8
   1ba4a:	eea0 8a27 	vfma.f32	s16, s0, s15
   1ba4e:	eb03 028a 	add.w	r2, r3, sl, lsl #2
	for (int i = 0; i < numberOfVocoderBands; i++)
   1ba52:	783b      	ldrb	r3, [r7, #0]
   1ba54:	f00b 0a01 	and.w	sl, fp, #1
   1ba58:	455b      	cmp	r3, fp
   1ba5a:	eb01 018a 	add.w	r1, r1, sl, lsl #2
		output[oddEven] += tempSynth * tempSamp * bandGains[i];
   1ba5e:	ed02 8a02 	vstr	s16, [r2, #-8]
	for (int i = 0; i < numberOfVocoderBands; i++)
   1ba62:	dd1a      	ble.n	1ba9a <SFXVocoderChTick+0x102>
   1ba64:	ed11 8a02 	vldr	s16, [r1, #-8]
   1ba68:	ed95 0a01 	vldr	s0, [r5, #4]
   1ba6c:	4a6f      	ldr	r2, [pc, #444]	; (1bc2c <SFXVocoderChTick+0x294>)
   1ba6e:	ea4f 04cb 	mov.w	r4, fp, lsl #3
		if (!vocChFreeze)
   1ba72:	f8d8 3000 	ldr.w	r3, [r8]
   1ba76:	eb02 098b 	add.w	r9, r2, fp, lsl #2
   1ba7a:	2b00      	cmp	r3, #0
   1ba7c:	d1c6      	bne.n	1ba0c <SFXVocoderChTick+0x74>
			tempSamp = tVZFilter_tickEfficient(&analysisBands[i][0], tempSamp);
   1ba7e:	4b6c      	ldr	r3, [pc, #432]	; (1bc30 <SFXVocoderChTick+0x298>)
   1ba80:	1918      	adds	r0, r3, r4
   1ba82:	f00c fffd 	bl	28a80 <tVZFilter_tickEfficient>
			tempSamp = tVZFilter_tickEfficient(&analysisBands[i][1], tempSamp);
   1ba86:	4b6b      	ldr	r3, [pc, #428]	; (1bc34 <SFXVocoderChTick+0x29c>)
   1ba88:	1918      	adds	r0, r3, r4
   1ba8a:	f00c fff9 	bl	28a80 <tVZFilter_tickEfficient>
			tExpSmooth_setDest(&envFollowers[i], fabsf(tempSamp));
   1ba8e:	4648      	mov	r0, r9
   1ba90:	eeb0 0ac0 	vabs.f32	s0, s0
   1ba94:	f00c fa64 	bl	27f60 <tExpSmooth_setDest>
   1ba98:	e7b8      	b.n	1ba0c <SFXVocoderChTick+0x74>
   1ba9a:	ed9d 9a00 	vldr	s18, [sp]
   1ba9e:	ed9d 8a01 	vldr	s16, [sp, #4]
	float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1baa2:	4e65      	ldr	r6, [pc, #404]	; (1bc38 <SFXVocoderChTick+0x2a0>)
   1baa4:	eeb0 0a49 	vmov.f32	s0, s18
   1baa8:	4c64      	ldr	r4, [pc, #400]	; (1bc3c <SFXVocoderChTick+0x2a4>)
   1baaa:	ed96 7a00 	vldr	s14, [r6]
   1baae:	edd4 7a00 	vldr	s15, [r4]
   1bab2:	eea7 0a08 	vfma.f32	s0, s14, s16
   1bab6:	4862      	ldr	r0, [pc, #392]	; (1bc40 <SFXVocoderChTick+0x2a8>)
	input[0] = 0.98f * tanhf(finalSample1);
   1bab8:	eddf 8a62 	vldr	s17, [pc, #392]	; 1bc44 <SFXVocoderChTick+0x2ac>
	float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1babc:	ee20 0a27 	vmul.f32	s0, s0, s15
   1bac0:	f00c fd90 	bl	285e4 <tHighpass_tick>
	float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
   1bac4:	edd6 7a00 	vldr	s15, [r6]
	float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
   1bac8:	eef0 9a40 	vmov.f32	s19, s0
	float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
   1bacc:	ed94 0a00 	vldr	s0, [r4]
   1bad0:	eea7 8a89 	vfma.f32	s16, s15, s18
   1bad4:	485c      	ldr	r0, [pc, #368]	; (1bc48 <SFXVocoderChTick+0x2b0>)
   1bad6:	ee28 0a00 	vmul.f32	s0, s16, s0
   1bada:	f00c fd83 	bl	285e4 <tHighpass_tick>
   1bade:	eeb0 8a40 	vmov.f32	s16, s0
	input[0] = 0.98f * tanhf(finalSample1);
   1bae2:	eeb0 0a69 	vmov.f32	s0, s19
   1bae6:	f011 fbe9 	bl	2d2bc <tanhf>
   1baea:	ee60 7a28 	vmul.f32	s15, s0, s17
	input[1] = 0.98f * tanhf(finalSample2);
   1baee:	eeb0 0a48 	vmov.f32	s0, s16
	input[0] = 0.98f * tanhf(finalSample1);
   1baf2:	edc5 7a00 	vstr	s15, [r5]
	input[1] = 0.98f * tanhf(finalSample2);
   1baf6:	f011 fbe1 	bl	2d2bc <tanhf>
   1bafa:	ee20 0a28 	vmul.f32	s0, s0, s17
   1bafe:	ed85 0a01 	vstr	s0, [r5, #4]
}
   1bb02:	b003      	add	sp, #12
   1bb04:	ecbd 8b06 	vpop	{d8-d10}
   1bb08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!vocChFreeze)
   1bb0c:	f8df 8170 	ldr.w	r8, [pc, #368]	; 1bc80 <SFXVocoderChTick+0x2e8>
		float zerocross = tZeroCrossing_tick(&zerox, input[1]);
   1bb10:	484e      	ldr	r0, [pc, #312]	; (1bc4c <SFXVocoderChTick+0x2b4>)
   1bb12:	f008 fc4f 	bl	243b4 <tZeroCrossing_tick>
		if (!vocChFreeze)
   1bb16:	f8d8 3000 	ldr.w	r3, [r8]
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1bb1a:	f8df 8160 	ldr.w	r8, [pc, #352]	; 1bc7c <SFXVocoderChTick+0x2e4>
		if (!vocChFreeze)
   1bb1e:	b9ab      	cbnz	r3, 1bb4c <SFXVocoderChTick+0x1b4>
			tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
   1bb20:	ed9f 6a4b 	vldr	s12, [pc, #300]	; 1bc50 <SFXVocoderChTick+0x2b8>
   1bb24:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   1bb28:	edd8 7a04 	vldr	s15, [r8, #16]
   1bb2c:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 1bc1c <SFXVocoderChTick+0x284>
   1bb30:	ee77 7ac6 	vsub.f32	s15, s15, s12
   1bb34:	4847      	ldr	r0, [pc, #284]	; (1bc54 <SFXVocoderChTick+0x2bc>)
   1bb36:	eef4 7ac0 	vcmpe.f32	s15, s0
   1bb3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1bb3e:	bf54      	ite	pl
   1bb40:	eeb0 0a47 	vmovpl.f32	s0, s14
   1bb44:	eeb0 0a66 	vmovmi.f32	s0, s13
   1bb48:	f00c fa0a 	bl	27f60 <tExpSmooth_setDest>
		float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1bb4c:	4841      	ldr	r0, [pc, #260]	; (1bc54 <SFXVocoderChTick+0x2bc>)
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bb4e:	2400      	movs	r4, #0
		float noiseRampVal = tExpSmooth_tick(&noiseRamp);
   1bb50:	f00c fa10 	bl	27f74 <tExpSmooth_tick>
   1bb54:	eeb0 aa40 	vmov.f32	s20, s0
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1bb58:	483f      	ldr	r0, [pc, #252]	; (1bc58 <SFXVocoderChTick+0x2c0>)
   1bb5a:	f00e fe7f 	bl	2a85c <tNoise_tick>
	float sample = 0.0f;
   1bb5e:	ed9f 9a2f 	vldr	s18, [pc, #188]	; 1bc1c <SFXVocoderChTick+0x284>
		float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
   1bb62:	ee60 8a0a 	vmul.f32	s17, s0, s20
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bb66:	f8df 911c 	ldr.w	r9, [pc, #284]	; 1bc84 <SFXVocoderChTick+0x2ec>
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bb6a:	4f3c      	ldr	r7, [pc, #240]	; (1bc5c <SFXVocoderChTick+0x2c4>)
			if (tempRamp > 0.0001f)
   1bb6c:	eddf 9a3c 	vldr	s19, [pc, #240]	; 1bc60 <SFXVocoderChTick+0x2c8>
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bb70:	e005      	b.n	1bb7e <SFXVocoderChTick+0x1e6>
					sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1bb72:	1998      	adds	r0, r3, r6
   1bb74:	f00e fe00 	bl	2a778 <tSawtooth_tick>
   1bb78:	eea0 9a08 	vfma.f32	s18, s0, s16
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bb7c:	3401      	adds	r4, #1
   1bb7e:	4648      	mov	r0, r9
   1bb80:	00a6      	lsls	r6, r4, #2
   1bb82:	f00e fce9 	bl	2a558 <tSimplePoly_getNumVoices>
   1bb86:	42a0      	cmp	r0, r4
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bb88:	eb07 0006 	add.w	r0, r7, r6
		for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1bb8c:	dd19      	ble.n	1bbc2 <SFXVocoderChTick+0x22a>
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bb8e:	f00c f9f1 	bl	27f74 <tExpSmooth_tick>
			if (tempRamp > 0.0001f)
   1bb92:	eeb4 0ae9 	vcmpe.f32	s0, s19
			float tempRamp = tExpSmooth_tick(&polyRamp[i]);
   1bb96:	eeb0 8a40 	vmov.f32	s16, s0
				if (displayValues[5] < 0.5f)
   1bb9a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
			if (tempRamp > 0.0001f)
   1bb9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1bba2:	ddeb      	ble.n	1bb7c <SFXVocoderChTick+0x1e4>
				if (displayValues[5] < 0.5f)
   1bba4:	ed98 7a05 	vldr	s14, [r8, #20]
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1bba8:	482e      	ldr	r0, [pc, #184]	; (1bc64 <SFXVocoderChTick+0x2cc>)
				if (displayValues[5] < 0.5f)
   1bbaa:	eeb4 7ae7 	vcmpe.f32	s14, s15
					sample += tSawtooth_tick(&osc[i]) * tempRamp;
   1bbae:	4b2e      	ldr	r3, [pc, #184]	; (1bc68 <SFXVocoderChTick+0x2d0>)
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1bbb0:	4430      	add	r0, r6
				if (displayValues[5] < 0.5f)
   1bbb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1bbb6:	d4dc      	bmi.n	1bb72 <SFXVocoderChTick+0x1da>
					sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
   1bbb8:	f00a fc30 	bl	2641c <tRosenbergGlottalPulse_tick>
   1bbbc:	eea0 9a08 	vfma.f32	s18, s0, s16
   1bbc0:	e7dc      	b.n	1bb7c <SFXVocoderChTick+0x1e4>
		sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1bbc2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1bbc6:	edd8 6a08 	vldr	s13, [r8, #32]
   1bbca:	ed9f 7a28 	vldr	s14, [pc, #160]	; 1bc6c <SFXVocoderChTick+0x2d4>
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1bbce:	4828      	ldr	r0, [pc, #160]	; (1bc70 <SFXVocoderChTick+0x2d8>)
		sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
   1bbd0:	eeb0 8a67 	vmov.f32	s16, s15
   1bbd4:	ee77 7aca 	vsub.f32	s15, s15, s20
   1bbd8:	eea6 8ac7 	vfms.f32	s16, s13, s14
   1bbdc:	ee28 8a27 	vmul.f32	s16, s16, s15
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1bbe0:	f00e fe3c 	bl	2a85c <tNoise_tick>
   1bbe4:	4823      	ldr	r0, [pc, #140]	; (1bc74 <SFXVocoderChTick+0x2dc>)
   1bbe6:	f00c fcfd 	bl	285e4 <tHighpass_tick>
   1bbea:	edd8 7a08 	vldr	s15, [r8, #32]
		sample *= tExpSmooth_tick(&comp);
   1bbee:	4822      	ldr	r0, [pc, #136]	; (1bc78 <SFXVocoderChTick+0x2e0>)
		sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
   1bbf0:	ee77 7aa7 	vadd.f32	s15, s15, s15
   1bbf4:	ee67 7a80 	vmul.f32	s15, s15, s0
   1bbf8:	eee9 7a08 	vfma.f32	s15, s18, s16
   1bbfc:	ee78 8aa7 	vadd.f32	s17, s17, s15
		sample *= tExpSmooth_tick(&comp);
   1bc00:	f00c f9b8 	bl	27f74 <tExpSmooth_tick>
   1bc04:	ee28 0a80 	vmul.f32	s0, s17, s0
   1bc08:	e6dc      	b.n	1b9c4 <SFXVocoderChTick+0x2c>
	for (int i = 0; i < numberOfVocoderBands; i++)
   1bc0a:	eeb0 9a48 	vmov.f32	s18, s16
   1bc0e:	e748      	b.n	1baa2 <SFXVocoderChTick+0x10a>
   1bc10:	020fa22c 	.word	0x020fa22c
   1bc14:	020e31a4 	.word	0x020e31a4
   1bc18:	00062ae5 	.word	0x00062ae5
   1bc1c:	00000000 	.word	0x00000000
   1bc20:	020f9eb8 	.word	0x020f9eb8
   1bc24:	020fa068 	.word	0x020fa068
   1bc28:	020fa06c 	.word	0x020fa06c
   1bc2c:	020fa268 	.word	0x020fa268
   1bc30:	020fae74 	.word	0x020fae74
   1bc34:	020fae78 	.word	0x020fae78
   1bc38:	00062ae8 	.word	0x00062ae8
   1bc3c:	00062a80 	.word	0x00062a80
   1bc40:	020f8e44 	.word	0x020f8e44
   1bc44:	3f7ae148 	.word	0x3f7ae148
   1bc48:	020fae68 	.word	0x020fae68
   1bc4c:	020fa2cc 	.word	0x020fa2cc
   1bc50:	3dcccccd 	.word	0x3dcccccd
   1bc54:	020fae64 	.word	0x020fae64
   1bc58:	020f9a6c 	.word	0x020f9a6c
   1bc5c:	020fa558 	.word	0x020fa558
   1bc60:	38d1b717 	.word	0x38d1b717
   1bc64:	020f8e50 	.word	0x020f8e50
   1bc68:	020f9f1c 	.word	0x020f9f1c
   1bc6c:	3e99999a 	.word	0x3e99999a
   1bc70:	020f8e20 	.word	0x020f8e20
   1bc74:	020f9a64 	.word	0x020f9a64
   1bc78:	020f9e9c 	.word	0x020f9e9c
   1bc7c:	020fb3cc 	.word	0x020fb3cc
   1bc80:	020e3218 	.word	0x020e3218
   1bc84:	020fa15c 	.word	0x020fa15c

0001bc88 <SFXVocoderChFree>:
{
   1bc88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bc8a:	4c1f      	ldr	r4, [pc, #124]	; (1bd08 <SFXVocoderChFree+0x80>)
   1bc8c:	4d1f      	ldr	r5, [pc, #124]	; (1bd0c <SFXVocoderChFree+0x84>)
   1bc8e:	f104 07c0 	add.w	r7, r4, #192	; 0xc0
   1bc92:	4e1f      	ldr	r6, [pc, #124]	; (1bd10 <SFXVocoderChFree+0x88>)
		tVZFilter_free(&analysisBands[i][0]);
   1bc94:	4620      	mov	r0, r4
   1bc96:	f00c fea7 	bl	289e8 <tVZFilter_free>
		tVZFilter_free(&analysisBands[i][1]);
   1bc9a:	1d20      	adds	r0, r4, #4
   1bc9c:	f00c fea4 	bl	289e8 <tVZFilter_free>
		tVZFilter_free(&synthesisBands[i][0]);
   1bca0:	1f28      	subs	r0, r5, #4
   1bca2:	f00c fea1 	bl	289e8 <tVZFilter_free>
   1bca6:	3408      	adds	r4, #8
		tVZFilter_free(&synthesisBands[i][1]);
   1bca8:	4628      	mov	r0, r5
   1bcaa:	3508      	adds	r5, #8
   1bcac:	f00c fe9c 	bl	289e8 <tVZFilter_free>
		tExpSmooth_free(&envFollowers[i]);
   1bcb0:	4630      	mov	r0, r6
   1bcb2:	f00c f93f 	bl	27f34 <tExpSmooth_free>
	for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
   1bcb6:	42a7      	cmp	r7, r4
   1bcb8:	f106 0604 	add.w	r6, r6, #4
   1bcbc:	d1ea      	bne.n	1bc94 <SFXVocoderChFree+0xc>
	tNoise_free(&breathNoise);
   1bcbe:	4815      	ldr	r0, [pc, #84]	; (1bd14 <SFXVocoderChFree+0x8c>)
	tHighpass_free(&chVocFinalHP2);
   1bcc0:	2400      	movs	r4, #0
	tNoise_free(&breathNoise);
   1bcc2:	f00e fdc7 	bl	2a854 <tNoise_free>
	tNoise_free(&vocoderNoise);
   1bcc6:	4814      	ldr	r0, [pc, #80]	; (1bd18 <SFXVocoderChFree+0x90>)
   1bcc8:	f00e fdc4 	bl	2a854 <tNoise_free>
	tZeroCrossing_free(&zerox);
   1bccc:	4813      	ldr	r0, [pc, #76]	; (1bd1c <SFXVocoderChFree+0x94>)
   1bcce:	f008 fb61 	bl	24394 <tZeroCrossing_free>
	tExpSmooth_free(&noiseRamp);
   1bcd2:	4813      	ldr	r0, [pc, #76]	; (1bd20 <SFXVocoderChFree+0x98>)
   1bcd4:	f00c f92e 	bl	27f34 <tExpSmooth_free>
	tHighpass_free(&noiseHP);
   1bcd8:	4812      	ldr	r0, [pc, #72]	; (1bd24 <SFXVocoderChFree+0x9c>)
   1bcda:	f00c fc6f 	bl	285bc <tHighpass_free>
	tVZFilter_free(&vocodec_highshelf);
   1bcde:	4812      	ldr	r0, [pc, #72]	; (1bd28 <SFXVocoderChFree+0xa0>)
   1bce0:	f00c fe82 	bl	289e8 <tVZFilter_free>
	tHighpass_free(&chVocFinalHP1);
   1bce4:	4811      	ldr	r0, [pc, #68]	; (1bd2c <SFXVocoderChFree+0xa4>)
   1bce6:	f00c fc69 	bl	285bc <tHighpass_free>
	tHighpass_free(&chVocFinalHP2);
   1bcea:	4811      	ldr	r0, [pc, #68]	; (1bd30 <SFXVocoderChFree+0xa8>)
   1bcec:	4e11      	ldr	r6, [pc, #68]	; (1bd34 <SFXVocoderChFree+0xac>)
   1bcee:	4d12      	ldr	r5, [pc, #72]	; (1bd38 <SFXVocoderChFree+0xb0>)
   1bcf0:	f00c fc64 	bl	285bc <tHighpass_free>
		tSawtooth_free(&osc[i]);
   1bcf4:	1930      	adds	r0, r6, r4
   1bcf6:	f00e fd09 	bl	2a70c <tSawtooth_free>
		tRosenbergGlottalPulse_free(&glottal[i]);
   1bcfa:	1928      	adds	r0, r5, r4
   1bcfc:	3404      	adds	r4, #4
   1bcfe:	f00a fb89 	bl	26414 <tRosenbergGlottalPulse_free>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1bd02:	2c20      	cmp	r4, #32
   1bd04:	d1f6      	bne.n	1bcf4 <SFXVocoderChFree+0x6c>
}
   1bd06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1bd08:	020fae74 	.word	0x020fae74
   1bd0c:	020fa06c 	.word	0x020fa06c
   1bd10:	020fa268 	.word	0x020fa268
   1bd14:	020f8e20 	.word	0x020f8e20
   1bd18:	020f9a6c 	.word	0x020f9a6c
   1bd1c:	020fa2cc 	.word	0x020fa2cc
   1bd20:	020fae64 	.word	0x020fae64
   1bd24:	020f9a64 	.word	0x020f9a64
   1bd28:	020fa22c 	.word	0x020fa22c
   1bd2c:	020f8e44 	.word	0x020f8e44
   1bd30:	020fae68 	.word	0x020fae68
   1bd34:	020f9f1c 	.word	0x020f9f1c
   1bd38:	020f8e50 	.word	0x020f8e50

0001bd3c <SFXPitchShiftAlloc>:
{
   1bd3c:	b510      	push	{r4, lr}
	tFormantShifter_initToPool(&fs, 7, &smallPool);
   1bd3e:	4a22      	ldr	r2, [pc, #136]	; (1bdc8 <SFXPitchShiftAlloc+0x8c>)
   1bd40:	2107      	movs	r1, #7
   1bd42:	4822      	ldr	r0, [pc, #136]	; (1bdcc <SFXPitchShiftAlloc+0x90>)
	tRamp_init(&pitchshiftRamp, 100.0f, 1);
   1bd44:	4c22      	ldr	r4, [pc, #136]	; (1bdd0 <SFXPitchShiftAlloc+0x94>)
{
   1bd46:	ed2d 8b02 	vpush	{d8}
	tFormantShifter_initToPool(&fs, 7, &smallPool);
   1bd4a:	f00b fa45 	bl	271d8 <tFormantShifter_initToPool>
	tRetune_init(&retune, NUM_RETUNE, 1024, 512);
   1bd4e:	f44f 7300 	mov.w	r3, #512	; 0x200
   1bd52:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1bd56:	2101      	movs	r1, #1
   1bd58:	481e      	ldr	r0, [pc, #120]	; (1bdd4 <SFXPitchShiftAlloc+0x98>)
   1bd5a:	f00a fecb 	bl	26af4 <tRetune_init>
	tRetune_init(&retune2, NUM_RETUNE, 1024, 512);
   1bd5e:	f44f 7300 	mov.w	r3, #512	; 0x200
   1bd62:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1bd66:	2101      	movs	r1, #1
   1bd68:	481b      	ldr	r0, [pc, #108]	; (1bdd8 <SFXPitchShiftAlloc+0x9c>)
   1bd6a:	f00a fec3 	bl	26af4 <tRetune_init>
	tRamp_init(&pitchshiftRamp, 100.0f, 1);
   1bd6e:	4620      	mov	r0, r4
   1bd70:	2101      	movs	r1, #1
   1bd72:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 1bddc <SFXPitchShiftAlloc+0xa0>
   1bd76:	f00b ffd9 	bl	27d2c <tRamp_init>
	tExpSmooth_init(&smoother1, 0.0f, 0.01f);
   1bd7a:	eddf 8a19 	vldr	s17, [pc, #100]	; 1bde0 <SFXPitchShiftAlloc+0xa4>
   1bd7e:	ed9f 8a19 	vldr	s16, [pc, #100]	; 1bde4 <SFXPitchShiftAlloc+0xa8>
	tRamp_setVal(&pitchshiftRamp, 1.0f);
   1bd82:	4620      	mov	r0, r4
   1bd84:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1bd88:	f00c f84a 	bl	27e20 <tRamp_setVal>
	tSimplePoly_setNumVoices(&poly, 1);
   1bd8c:	2101      	movs	r1, #1
   1bd8e:	4816      	ldr	r0, [pc, #88]	; (1bde8 <SFXPitchShiftAlloc+0xac>)
   1bd90:	f00e fbda 	bl	2a548 <tSimplePoly_setNumVoices>
	tExpSmooth_init(&smoother1, 0.0f, 0.01f);
   1bd94:	eef0 0a68 	vmov.f32	s1, s17
   1bd98:	eeb0 0a48 	vmov.f32	s0, s16
   1bd9c:	4813      	ldr	r0, [pc, #76]	; (1bdec <SFXPitchShiftAlloc+0xb0>)
   1bd9e:	f00c f879 	bl	27e94 <tExpSmooth_init>
	tExpSmooth_init(&smoother2, 0.0f, 0.01f);
   1bda2:	eef0 0a68 	vmov.f32	s1, s17
   1bda6:	eeb0 0a48 	vmov.f32	s0, s16
   1bdaa:	4811      	ldr	r0, [pc, #68]	; (1bdf0 <SFXPitchShiftAlloc+0xb4>)
   1bdac:	f00c f872 	bl	27e94 <tExpSmooth_init>
	tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1bdb0:	eef0 0a68 	vmov.f32	s1, s17
   1bdb4:	eeb0 0a48 	vmov.f32	s0, s16
   1bdb8:	480e      	ldr	r0, [pc, #56]	; (1bdf4 <SFXPitchShiftAlloc+0xb8>)
}
   1bdba:	ecbd 8b02 	vpop	{d8}
   1bdbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tExpSmooth_init(&smoother3, 0.0f, 0.01f);
   1bdc2:	f00c b867 	b.w	27e94 <tExpSmooth_init>
   1bdc6:	bf00      	nop
   1bdc8:	020f7730 	.word	0x020f7730
   1bdcc:	020f8f6c 	.word	0x020f8f6c
   1bdd0:	020fa2d0 	.word	0x020fa2d0
   1bdd4:	020f8c90 	.word	0x020f8c90
   1bdd8:	020fa488 	.word	0x020fa488
   1bddc:	42c80000 	.word	0x42c80000
   1bde0:	3c23d70a 	.word	0x3c23d70a
   1bde4:	00000000 	.word	0x00000000
   1bde8:	020fa15c 	.word	0x020fa15c
   1bdec:	020f8e4c 	.word	0x020f8e4c
   1bdf0:	020f9c80 	.word	0x020f9c80
   1bdf4:	020fa3bc 	.word	0x020fa3bc

0001bdf8 <SFXPitchShiftFrame>:
}
   1bdf8:	4770      	bx	lr
   1bdfa:	bf00      	nop

0001bdfc <SFXPitchShiftTick>:
{
   1bdfc:	b570      	push	{r4, r5, r6, lr}
   1bdfe:	ed2d 8b04 	vpush	{d8-d9}
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1be02:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
   1be06:	4e60      	ldr	r6, [pc, #384]	; (1bf88 <SFXPitchShiftTick+0x18c>)
   1be08:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
	float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1be0c:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 1bf8c <SFXPitchShiftTick+0x190>
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1be10:	edd6 6a33 	vldr	s13, [r6, #204]	; 0xcc
{
   1be14:	b082      	sub	sp, #8
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1be16:	eef0 5a48 	vmov.f32	s11, s16
	float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
   1be1a:	ed96 6a32 	vldr	s12, [r6, #200]	; 0xc8
	displayValues[0] = myPitchFactorCombined;
   1be1e:	4c5c      	ldr	r4, [pc, #368]	; (1bf90 <SFXPitchShiftTick+0x194>)
{
   1be20:	4605      	mov	r5, r0
	float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
   1be22:	eea6 8a27 	vfma.f32	s16, s12, s15
	float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1be26:	2100      	movs	r1, #0
	float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
   1be28:	eee6 5aa7 	vfma.f32	s11, s13, s15
	float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1be2c:	4859      	ldr	r0, [pc, #356]	; (1bf94 <SFXPitchShiftTick+0x198>)
	float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
   1be2e:	eea5 8a87 	vfma.f32	s16, s11, s14
	displayValues[0] = myPitchFactorCombined;
   1be32:	ed84 8a00 	vstr	s16, [r4]
	displayValues[1] = myPitchFactorCombined;
   1be36:	ed84 8a01 	vstr	s16, [r4, #4]
	float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
   1be3a:	f00e fbaf 	bl	2a59c <tSimplePoly_getPitchAndCheckActive>
   1be3e:	ee07 0a90 	vmov	s15, r0
   1be42:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
	if (keyPitch >= 0)
   1be46:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   1be4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1be4e:	f280 8094 	bge.w	1bf7a <SFXPitchShiftTick+0x17e>
		keyPitch = 1.0f;
   1be52:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
	float myPitchFactor = fastexp2f(myPitchFactorCombined);
   1be56:	eeb0 0a48 	vmov.f32	s0, s16
   1be5a:	f00d fc43 	bl	296e4 <fastexp2f>
	myPitchFactor *= keyPitch;
   1be5e:	ee68 8a80 	vmul.f32	s17, s17, s0
	tRetune_setPitchFactor(&retune, myPitchFactor, 0);
   1be62:	2100      	movs	r1, #0
   1be64:	484c      	ldr	r0, [pc, #304]	; (1bf98 <SFXPitchShiftTick+0x19c>)
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1be66:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
	tRetune_setPitchFactor(&retune, myPitchFactor, 0);
   1be6a:	eeb0 0a68 	vmov.f32	s0, s17
   1be6e:	f00a ff61 	bl	26d34 <tRetune_setPitchFactor>
	tRetune_setPitchFactor(&retune2, myPitchFactor, 0);
   1be72:	2100      	movs	r1, #0
   1be74:	4849      	ldr	r0, [pc, #292]	; (1bf9c <SFXPitchShiftTick+0x1a0>)
   1be76:	eeb0 0a68 	vmov.f32	s0, s17
   1be7a:	f00a ff5b 	bl	26d34 <tRetune_setPitchFactor>
	displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
   1be7e:	eeb0 1a08 	vmov.f32	s2, #8	; 0x40400000  3.0
   1be82:	edd6 7a34 	vldr	s15, [r6, #208]	; 0xd0
   1be86:	eddf 0a46 	vldr	s1, [pc, #280]	; 1bfa0 <SFXPitchShiftTick+0x1a4>
   1be8a:	ed9f 0a46 	vldr	s0, [pc, #280]	; 1bfa4 <SFXPitchShiftTick+0x1a8>
   1be8e:	eee7 0a81 	vfma.f32	s1, s15, s2
   1be92:	f00d fcf9 	bl	29888 <LEAF_clip>
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1be96:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
	displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
   1be9a:	ed84 0a02 	vstr	s0, [r4, #8]
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1be9e:	eeb0 0a49 	vmov.f32	s0, s18
   1bea2:	ed96 7a35 	vldr	s14, [r6, #212]	; 0xd4
   1bea6:	eea7 0a27 	vfma.f32	s0, s14, s15
   1beaa:	f00d fc1b 	bl	296e4 <fastexp2f>
	tExpSmooth_setDest(&smoother3, displayValues[2]);
   1beae:	483e      	ldr	r0, [pc, #248]	; (1bfa8 <SFXPitchShiftTick+0x1ac>)
	displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
   1beb0:	ed84 0a03 	vstr	s0, [r4, #12]
	tExpSmooth_setDest(&smoother3, displayValues[2]);
   1beb4:	ed94 0a02 	vldr	s0, [r4, #8]
   1beb8:	f00c f852 	bl	27f60 <tExpSmooth_setDest>
	tFormantShifter_setIntensity(&fs, tExpSmooth_tick(&smoother3)+.1f);
   1bebc:	483a      	ldr	r0, [pc, #232]	; (1bfa8 <SFXPitchShiftTick+0x1ac>)
   1bebe:	f00c f859 	bl	27f74 <tExpSmooth_tick>
   1bec2:	eddf 7a32 	vldr	s15, [pc, #200]	; 1bf8c <SFXPitchShiftTick+0x190>
   1bec6:	4839      	ldr	r0, [pc, #228]	; (1bfac <SFXPitchShiftTick+0x1b0>)
   1bec8:	ee30 0a27 	vadd.f32	s0, s0, s15
   1becc:	f00b fc34 	bl	27738 <tFormantShifter_setIntensity>
	tFormantShifter_setShiftFactor(&fs, displayValues[3]);
   1bed0:	ed94 0a03 	vldr	s0, [r4, #12]
   1bed4:	4835      	ldr	r0, [pc, #212]	; (1bfac <SFXPitchShiftTick+0x1b0>)
   1bed6:	f00b fc2b 	bl	27730 <tFormantShifter_setShiftFactor>
	if (displayValues[2] > 0.01f)
   1beda:	eddf 7a35 	vldr	s15, [pc, #212]	; 1bfb0 <SFXPitchShiftTick+0x1b4>
   1bede:	ed94 7a02 	vldr	s14, [r4, #8]
		tRamp_setDest(&pitchshiftRamp, 1.0f);
   1bee2:	4834      	ldr	r0, [pc, #208]	; (1bfb4 <SFXPitchShiftTick+0x1b8>)
	if (displayValues[2] > 0.01f)
   1bee4:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1bee8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		tRamp_setDest(&pitchshiftRamp, -1.0f);
   1beec:	bfcc      	ite	gt
   1beee:	eeb0 0a49 	vmovgt.f32	s0, s18
		tRamp_setDest(&pitchshiftRamp, 1.0f);
   1bef2:	eeb7 0a00 	vmovle.f32	s0, #112	; 0x3f800000  1.0
   1bef6:	f00b ff85 	bl	27e04 <tRamp_setDest>
	float crossfadeVal = tRamp_tick(&pitchshiftRamp);
   1befa:	482e      	ldr	r0, [pc, #184]	; (1bfb4 <SFXPitchShiftTick+0x1b8>)
   1befc:	f00b ff9e 	bl	27e3c <tRamp_tick>
	LEAF_crossfade(crossfadeVal, myGains);
   1bf00:	4668      	mov	r0, sp
   1bf02:	f00d fc3d 	bl	29780 <LEAF_crossfade>
	tExpSmooth_setDest(&smoother1, myGains[0]);
   1bf06:	ed9d 0a00 	vldr	s0, [sp]
   1bf0a:	482b      	ldr	r0, [pc, #172]	; (1bfb8 <SFXPitchShiftTick+0x1bc>)
   1bf0c:	f00c f828 	bl	27f60 <tExpSmooth_setDest>
	tExpSmooth_setDest(&smoother2, myGains[1]);
   1bf10:	ed9d 0a01 	vldr	s0, [sp, #4]
   1bf14:	4829      	ldr	r0, [pc, #164]	; (1bfbc <SFXPitchShiftTick+0x1c0>)
   1bf16:	f00c f823 	bl	27f60 <tExpSmooth_setDest>
	float formantsample = tanhf(tFormantShifter_remove(&fs, input[1]));
   1bf1a:	4824      	ldr	r0, [pc, #144]	; (1bfac <SFXPitchShiftTick+0x1b0>)
   1bf1c:	ed95 0a01 	vldr	s0, [r5, #4]
   1bf20:	f00b fa52 	bl	273c8 <tFormantShifter_remove>
   1bf24:	f011 f9ca 	bl	2d2bc <tanhf>
	float* samples = tRetune_tick(&retune2, formantsample);
   1bf28:	481c      	ldr	r0, [pc, #112]	; (1bf9c <SFXPitchShiftTick+0x1a0>)
   1bf2a:	f00a fe2f 	bl	26b8c <tRetune_tick>
	formantsample = samples[0];
   1bf2e:	ed90 8a00 	vldr	s16, [r0]
	samples = tRetune_tick(&retune, sample);
   1bf32:	ed95 0a01 	vldr	s0, [r5, #4]
   1bf36:	4818      	ldr	r0, [pc, #96]	; (1bf98 <SFXPitchShiftTick+0x19c>)
   1bf38:	f00a fe28 	bl	26b8c <tRetune_tick>
	formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1bf3c:	eeb0 0a48 	vmov.f32	s0, s16
	sample = samples[0];
   1bf40:	ed90 8a00 	vldr	s16, [r0]
	formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1bf44:	4819      	ldr	r0, [pc, #100]	; (1bfac <SFXPitchShiftTick+0x1b0>)
   1bf46:	f00b fabd 	bl	274c4 <tFormantShifter_add>
   1bf4a:	f011 f9b7 	bl	2d2bc <tanhf>
   1bf4e:	481b      	ldr	r0, [pc, #108]	; (1bfbc <SFXPitchShiftTick+0x1c0>)
   1bf50:	eeb0 9a40 	vmov.f32	s18, s0
   1bf54:	f00c f80e 	bl	27f74 <tExpSmooth_tick>
	sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
   1bf58:	4817      	ldr	r0, [pc, #92]	; (1bfb8 <SFXPitchShiftTick+0x1bc>)
	formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
   1bf5a:	eef0 8a40 	vmov.f32	s17, s0
	sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
   1bf5e:	f00c f809 	bl	27f74 <tExpSmooth_tick>
   1bf62:	ee20 0a08 	vmul.f32	s0, s0, s16
   1bf66:	eea9 0a28 	vfma.f32	s0, s18, s17
	input[0] = sample;
   1bf6a:	ed85 0a00 	vstr	s0, [r5]
	input[1] = sample;
   1bf6e:	ed85 0a01 	vstr	s0, [r5, #4]
}
   1bf72:	b002      	add	sp, #8
   1bf74:	ecbd 8b04 	vpop	{d8-d9}
   1bf78:	bd70      	pop	{r4, r5, r6, pc}
		keyPitch = LEAF_midiToFrequency(keyPitch) * 0.003822629969419f ;
   1bf7a:	eddf 8a11 	vldr	s17, [pc, #68]	; 1bfc0 <SFXPitchShiftTick+0x1c4>
   1bf7e:	f00d fd6d 	bl	29a5c <LEAF_midiToFrequency>
   1bf82:	ee60 8a28 	vmul.f32	s17, s0, s17
   1bf86:	e766      	b.n	1be56 <SFXPitchShiftTick+0x5a>
   1bf88:	020f9318 	.word	0x020f9318
   1bf8c:	3dcccccd 	.word	0x3dcccccd
   1bf90:	020fb3cc 	.word	0x020fb3cc
   1bf94:	020fa15c 	.word	0x020fa15c
   1bf98:	020f8c90 	.word	0x020f8c90
   1bf9c:	020fa488 	.word	0x020fa488
   1bfa0:	be4ccccd 	.word	0xbe4ccccd
   1bfa4:	00000000 	.word	0x00000000
   1bfa8:	020fa3bc 	.word	0x020fa3bc
   1bfac:	020f8f6c 	.word	0x020f8f6c
   1bfb0:	3c23d70a 	.word	0x3c23d70a
   1bfb4:	020fa2d0 	.word	0x020fa2d0
   1bfb8:	020f8e4c 	.word	0x020f8e4c
   1bfbc:	020f9c80 	.word	0x020f9c80
   1bfc0:	3b7a8517 	.word	0x3b7a8517

0001bfc4 <SFXPitchShiftFree>:
{
   1bfc4:	b508      	push	{r3, lr}
	tFormantShifter_free(&fs);
   1bfc6:	480b      	ldr	r0, [pc, #44]	; (1bff4 <SFXPitchShiftFree+0x30>)
   1bfc8:	f00b f9c2 	bl	27350 <tFormantShifter_free>
	tRetune_free(&retune);
   1bfcc:	480a      	ldr	r0, [pc, #40]	; (1bff8 <SFXPitchShiftFree+0x34>)
   1bfce:	f00a fd9b 	bl	26b08 <tRetune_free>
	tRetune_free(&retune2);
   1bfd2:	480a      	ldr	r0, [pc, #40]	; (1bffc <SFXPitchShiftFree+0x38>)
   1bfd4:	f00a fd98 	bl	26b08 <tRetune_free>
	tRamp_free(&pitchshiftRamp);
   1bfd8:	4809      	ldr	r0, [pc, #36]	; (1c000 <SFXPitchShiftFree+0x3c>)
   1bfda:	f00b ff0f 	bl	27dfc <tRamp_free>
	tExpSmooth_free(&smoother1);
   1bfde:	4809      	ldr	r0, [pc, #36]	; (1c004 <SFXPitchShiftFree+0x40>)
   1bfe0:	f00b ffa8 	bl	27f34 <tExpSmooth_free>
	tExpSmooth_free(&smoother2);
   1bfe4:	4808      	ldr	r0, [pc, #32]	; (1c008 <SFXPitchShiftFree+0x44>)
   1bfe6:	f00b ffa5 	bl	27f34 <tExpSmooth_free>
	tExpSmooth_free(&smoother3);
   1bfea:	4808      	ldr	r0, [pc, #32]	; (1c00c <SFXPitchShiftFree+0x48>)
}
   1bfec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tExpSmooth_free(&smoother3);
   1bff0:	f00b bfa0 	b.w	27f34 <tExpSmooth_free>
   1bff4:	020f8f6c 	.word	0x020f8f6c
   1bff8:	020f8c90 	.word	0x020f8c90
   1bffc:	020fa488 	.word	0x020fa488
   1c000:	020fa2d0 	.word	0x020fa2d0
   1c004:	020f8e4c 	.word	0x020f8e4c
   1c008:	020f9c80 	.word	0x020f9c80
   1c00c:	020fa3bc 	.word	0x020fa3bc

0001c010 <SFXNeartuneAlloc>:
{
   1c010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	leaf.clearOnAllocation = 1;
   1c012:	2401      	movs	r4, #1
   1c014:	4d28      	ldr	r5, [pc, #160]	; (1c0b8 <SFXNeartuneAlloc+0xa8>)
	tRetune_init(&autotuneMono, 1, 512, 256);
   1c016:	f44f 7380 	mov.w	r3, #256	; 0x100
   1c01a:	4828      	ldr	r0, [pc, #160]	; (1c0bc <SFXNeartuneAlloc+0xac>)
   1c01c:	4621      	mov	r1, r4
   1c01e:	f44f 7200 	mov.w	r2, #512	; 0x200
	leaf.clearOnAllocation = 1;
   1c022:	616c      	str	r4, [r5, #20]
	tRetune_init(&autotuneMono, 1, 512, 256);
   1c024:	f00a fd66 	bl	26af4 <tRetune_init>
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c028:	4b25      	ldr	r3, [pc, #148]	; (1c0c0 <SFXNeartuneAlloc+0xb0>)
	for (int i = 0; i < 128; i++)
   1c02a:	2100      	movs	r1, #0
   1c02c:	4825      	ldr	r0, [pc, #148]	; (1c0c4 <SFXNeartuneAlloc+0xb4>)
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c02e:	781f      	ldrb	r7, [r3, #0]
   1c030:	4e25      	ldr	r6, [pc, #148]	; (1c0c8 <SFXNeartuneAlloc+0xb8>)
   1c032:	4d26      	ldr	r5, [pc, #152]	; (1c0cc <SFXNeartuneAlloc+0xbc>)
		float tempNote = i;
   1c034:	ee07 1a90 	vmov	s15, r1
	for (int i = 0; i < 128; i++)
   1c038:	3101      	adds	r1, #1
		float tempNote = i;
   1c03a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	for (int i = 0; i < 128; i++)
   1c03e:	2980      	cmp	r1, #128	; 0x80
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c040:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1c044:	ee17 3a90 	vmov	r3, s15
   1c048:	eba3 0307 	sub.w	r3, r3, r7
   1c04c:	fb85 2403 	smull	r2, r4, r5, r3
   1c050:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1c054:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   1c058:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1c05c:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1c060:	ee07 3a90 	vmov	s15, r3
   1c064:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1c068:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1c06c:	ee17 3a90 	vmov	r3, s15
   1c070:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   1c074:	edd3 7a00 	vldr	s15, [r3]
   1c078:	ee77 7a87 	vadd.f32	s15, s15, s14
		notes[i] = tunedNote;
   1c07c:	ece0 7a01 	vstmia	r0!, {s15}
	for (int i = 0; i < 128; i++)
   1c080:	d1d8      	bne.n	1c034 <SFXNeartuneAlloc+0x24>
	tExpSmooth_init(&neartune_smoother, 1.0f, .007f);
   1c082:	eddf 0a13 	vldr	s1, [pc, #76]	; 1c0d0 <SFXNeartuneAlloc+0xc0>
   1c086:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c08a:	4812      	ldr	r0, [pc, #72]	; (1c0d4 <SFXNeartuneAlloc+0xc4>)
   1c08c:	f00b ff02 	bl	27e94 <tExpSmooth_init>
	tRamp_init(&nearWetRamp, 20.0f, 1);
   1c090:	2101      	movs	r1, #1
   1c092:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1c096:	4810      	ldr	r0, [pc, #64]	; (1c0d8 <SFXNeartuneAlloc+0xc8>)
   1c098:	f00b fe48 	bl	27d2c <tRamp_init>
	setLED_A(autotuneChromatic);
   1c09c:	4b0f      	ldr	r3, [pc, #60]	; (1c0dc <SFXNeartuneAlloc+0xcc>)
   1c09e:	7818      	ldrb	r0, [r3, #0]
   1c0a0:	f7fd fa4c 	bl	1953c <setLED_A>
	setLED_C(autotuneLock);
   1c0a4:	4b0e      	ldr	r3, [pc, #56]	; (1c0e0 <SFXNeartuneAlloc+0xd0>)
   1c0a6:	7818      	ldrb	r0, [r3, #0]
   1c0a8:	f7fd fa64 	bl	19574 <setLED_C>
	lastSnap = 1.0f;
   1c0ac:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
   1c0b0:	4b0c      	ldr	r3, [pc, #48]	; (1c0e4 <SFXNeartuneAlloc+0xd4>)
   1c0b2:	601a      	str	r2, [r3, #0]
}
   1c0b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c0b6:	bf00      	nop
   1c0b8:	020fc0a8 	.word	0x020fc0a8
   1c0bc:	020fa154 	.word	0x020fa154
   1c0c0:	020e3258 	.word	0x020e3258
   1c0c4:	020f9050 	.word	0x020f9050
   1c0c8:	020e3224 	.word	0x020e3224
   1c0cc:	2aaaaaab 	.word	0x2aaaaaab
   1c0d0:	3be56042 	.word	0x3be56042
   1c0d4:	020fa224 	.word	0x020fa224
   1c0d8:	020faf9c 	.word	0x020faf9c
   1c0dc:	020e3124 	.word	0x020e3124
   1c0e0:	020e3128 	.word	0x020e3128
   1c0e4:	00062ae0 	.word	0x00062ae0

0001c0e8 <SFXNeartuneFrame>:
{
   1c0e8:	b538      	push	{r3, r4, r5, lr}
	if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
   1c0ea:	4826      	ldr	r0, [pc, #152]	; (1c184 <SFXNeartuneFrame+0x9c>)
   1c0ec:	f00e fa38 	bl	2a560 <tSimplePoly_getNumActiveVoices>
   1c0f0:	b9e8      	cbnz	r0, 1c12e <SFXNeartuneFrame+0x46>
   1c0f2:	4b25      	ldr	r3, [pc, #148]	; (1c188 <SFXNeartuneFrame+0xa0>)
   1c0f4:	781b      	ldrb	r3, [r3, #0]
   1c0f6:	2b01      	cmp	r3, #1
   1c0f8:	d019      	beq.n	1c12e <SFXNeartuneFrame+0x46>
   1c0fa:	4b24      	ldr	r3, [pc, #144]	; (1c18c <SFXNeartuneFrame+0xa4>)
   1c0fc:	681b      	ldr	r3, [r3, #0]
   1c0fe:	2b01      	cmp	r3, #1
   1c100:	d015      	beq.n	1c12e <SFXNeartuneFrame+0x46>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c102:	4c23      	ldr	r4, [pc, #140]	; (1c190 <SFXNeartuneFrame+0xa8>)
		tRamp_setDest(&nearWetRamp, -1.0f);
   1c104:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   1c108:	4822      	ldr	r0, [pc, #136]	; (1c194 <SFXNeartuneFrame+0xac>)
   1c10a:	f00b fe7b 	bl	27e04 <tRamp_setDest>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c10e:	7d23      	ldrb	r3, [r4, #20]
   1c110:	b1b3      	cbz	r3, 1c140 <SFXNeartuneFrame+0x58>
		autotuneChromatic = !autotuneChromatic;
   1c112:	4a1d      	ldr	r2, [pc, #116]	; (1c188 <SFXNeartuneFrame+0xa0>)
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c114:	2100      	movs	r1, #0
		autotuneChromatic = !autotuneChromatic;
   1c116:	7813      	ldrb	r3, [r2, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c118:	7521      	strb	r1, [r4, #20]
		autotuneChromatic = !autotuneChromatic;
   1c11a:	fab3 f383 	clz	r3, r3
   1c11e:	095b      	lsrs	r3, r3, #5
		setLED_A(autotuneChromatic);
   1c120:	4618      	mov	r0, r3
		autotuneChromatic = !autotuneChromatic;
   1c122:	7013      	strb	r3, [r2, #0]
		setLED_A(autotuneChromatic);
   1c124:	f7fd fa0a 	bl	1953c <setLED_A>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1c128:	7f23      	ldrb	r3, [r4, #28]
   1c12a:	b963      	cbnz	r3, 1c146 <SFXNeartuneFrame+0x5e>
}
   1c12c:	bd38      	pop	{r3, r4, r5, pc}
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c12e:	4c18      	ldr	r4, [pc, #96]	; (1c190 <SFXNeartuneFrame+0xa8>)
		tRamp_setDest(&nearWetRamp, 1.0f);
   1c130:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c134:	4817      	ldr	r0, [pc, #92]	; (1c194 <SFXNeartuneFrame+0xac>)
   1c136:	f00b fe65 	bl	27e04 <tRamp_setDest>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c13a:	7d23      	ldrb	r3, [r4, #20]
   1c13c:	2b00      	cmp	r3, #0
   1c13e:	d1e8      	bne.n	1c112 <SFXNeartuneFrame+0x2a>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1c140:	7f23      	ldrb	r3, [r4, #28]
   1c142:	2b00      	cmp	r3, #0
   1c144:	d0f2      	beq.n	1c12c <SFXNeartuneFrame+0x44>
		autotuneLock = !autotuneLock;
   1c146:	4d11      	ldr	r5, [pc, #68]	; (1c18c <SFXNeartuneFrame+0xa4>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c148:	2200      	movs	r2, #0
		autotuneLock = !autotuneLock;
   1c14a:	682b      	ldr	r3, [r5, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c14c:	7722      	strb	r2, [r4, #28]
		autotuneLock = !autotuneLock;
   1c14e:	fab3 f383 	clz	r3, r3
   1c152:	095b      	lsrs	r3, r3, #5
		setLED_C(autotuneLock);
   1c154:	4618      	mov	r0, r3
		autotuneLock = !autotuneLock;
   1c156:	602b      	str	r3, [r5, #0]
		setLED_C(autotuneLock);
   1c158:	f7fd fa0c 	bl	19574 <setLED_C>
		if (autotuneLock)
   1c15c:	6829      	ldr	r1, [r5, #0]
   1c15e:	b151      	cbz	r1, 1c176 <SFXNeartuneFrame+0x8e>
   1c160:	4d0d      	ldr	r5, [pc, #52]	; (1c198 <SFXNeartuneFrame+0xb0>)
   1c162:	4c0e      	ldr	r4, [pc, #56]	; (1c19c <SFXNeartuneFrame+0xb4>)
   1c164:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1c166:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1c168:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1c16a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1c16c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1c170:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
   1c174:	bd38      	pop	{r3, r4, r5, pc}
   1c176:	2230      	movs	r2, #48	; 0x30
   1c178:	4808      	ldr	r0, [pc, #32]	; (1c19c <SFXNeartuneFrame+0xb4>)
   1c17a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c17e:	f010 bc60 	b.w	2ca42 <memset>
   1c182:	bf00      	nop
   1c184:	020fa15c 	.word	0x020fa15c
   1c188:	020e3124 	.word	0x020e3124
   1c18c:	020e3128 	.word	0x020e3128
   1c190:	020fb31c 	.word	0x020fb31c
   1c194:	020faf9c 	.word	0x020faf9c
   1c198:	020e3138 	.word	0x020e3138
   1c19c:	020e31b0 	.word	0x020e31b0

0001c1a0 <SFXNeartuneFree>:
{
   1c1a0:	b508      	push	{r3, lr}
	tRetune_free(&autotuneMono);
   1c1a2:	4805      	ldr	r0, [pc, #20]	; (1c1b8 <SFXNeartuneFree+0x18>)
   1c1a4:	f00a fcb0 	bl	26b08 <tRetune_free>
	tExpSmooth_free(&neartune_smoother);
   1c1a8:	4804      	ldr	r0, [pc, #16]	; (1c1bc <SFXNeartuneFree+0x1c>)
   1c1aa:	f00b fec3 	bl	27f34 <tExpSmooth_free>
	tRamp_free(&nearWetRamp);
   1c1ae:	4804      	ldr	r0, [pc, #16]	; (1c1c0 <SFXNeartuneFree+0x20>)
}
   1c1b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tRamp_free(&nearWetRamp);
   1c1b4:	f00b be22 	b.w	27dfc <tRamp_free>
   1c1b8:	020fa154 	.word	0x020fa154
   1c1bc:	020fa224 	.word	0x020fa224
   1c1c0:	020faf9c 	.word	0x020faf9c

0001c1c4 <SFXAutotuneAlloc>:
{
   1c1c4:	b508      	push	{r3, lr}
	tAutotune_init(&autotunePoly, NUM_AUTOTUNE, 1024, 512);
   1c1c6:	2104      	movs	r1, #4
   1c1c8:	f44f 7300 	mov.w	r3, #512	; 0x200
   1c1cc:	4805      	ldr	r0, [pc, #20]	; (1c1e4 <SFXAutotuneAlloc+0x20>)
   1c1ce:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1c1d2:	f00a fead 	bl	26f30 <tAutotune_init>
	tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
   1c1d6:	2104      	movs	r1, #4
   1c1d8:	4803      	ldr	r0, [pc, #12]	; (1c1e8 <SFXAutotuneAlloc+0x24>)
}
   1c1da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
   1c1de:	f00e b9b3 	b.w	2a548 <tSimplePoly_setNumVoices>
   1c1e2:	bf00      	nop
   1c1e4:	020f9a40 	.word	0x020f9a40
   1c1e8:	020fa15c 	.word	0x020fa15c

0001c1ec <SFXAutotuneFrame>:
{
   1c1ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c1f0:	4f35      	ldr	r7, [pc, #212]	; (1c2c8 <SFXAutotuneFrame+0xdc>)
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c1f2:	2400      	movs	r4, #0
   1c1f4:	4d35      	ldr	r5, [pc, #212]	; (1c2cc <SFXAutotuneFrame+0xe0>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c1f6:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 1c2e8 <SFXAutotuneFrame+0xfc>
{
   1c1fa:	ed2d 8b02 	vpush	{d8}
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c1fe:	ed9f 8a34 	vldr	s16, [pc, #208]	; 1c2d0 <SFXAutotuneFrame+0xe4>
{
   1c202:	b082      	sub	sp, #8
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c204:	e03e      	b.n	1c284 <SFXAutotuneFrame+0x98>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c206:	f00e f9c3 	bl	2a590 <tSimplePoly_getPitch>
   1c20a:	ee07 0a90 	vmov	s15, r0
   1c20e:	4a31      	ldr	r2, [pc, #196]	; (1c2d4 <SFXAutotuneFrame+0xe8>)
   1c210:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c214:	4b30      	ldr	r3, [pc, #192]	; (1c2d8 <SFXAutotuneFrame+0xec>)
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c216:	ed92 0a00 	vldr	s0, [r2]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c21a:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c21c:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1c220:	492e      	ldr	r1, [pc, #184]	; (1c2dc <SFXAutotuneFrame+0xf0>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1c222:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1c226:	ee17 3a90 	vmov	r3, s15
   1c22a:	1a9b      	subs	r3, r3, r2
   1c22c:	fb88 2003 	smull	r2, r0, r8, r3
   1c230:	17da      	asrs	r2, r3, #31
   1c232:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1c236:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1c23a:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1c23e:	ee07 3a90 	vmov	s15, r3
   1c242:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1c246:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1c24a:	ee17 3a90 	vmov	r3, s15
   1c24e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1c252:	ed93 0a00 	vldr	s0, [r3]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1c256:	ee37 0a00 	vadd.f32	s0, s14, s0
   1c25a:	f00d fbff 	bl	29a5c <LEAF_midiToFrequency>
   1c25e:	4b20      	ldr	r3, [pc, #128]	; (1c2e0 <SFXAutotuneFrame+0xf4>)
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c260:	4631      	mov	r1, r6
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1c262:	eca7 0a01 	vstmia	r7!, {s0}
		tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
   1c266:	4628      	mov	r0, r5
   1c268:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   1c26c:	f00e f99c 	bl	2a5a8 <tSimplePoly_getVelocity>
   1c270:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c274:	2800      	cmp	r0, #0
   1c276:	4630      	mov	r0, r6
   1c278:	f104 0401 	add.w	r4, r4, #1
   1c27c:	fe30 0a08 	vselgt.f32	s0, s0, s16
   1c280:	f00b fe6e 	bl	27f60 <tExpSmooth_setDest>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c284:	4628      	mov	r0, r5
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c286:	b2e6      	uxtb	r6, r4
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c288:	f00e f966 	bl	2a558 <tSimplePoly_getNumVoices>
   1c28c:	42a0      	cmp	r0, r4
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1c28e:	4631      	mov	r1, r6
   1c290:	4628      	mov	r0, r5
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c292:	dcb8      	bgt.n	1c206 <SFXAutotuneFrame+0x1a>
	int tempNumVoices = tSimplePoly_getNumActiveVoices(&poly);
   1c294:	480d      	ldr	r0, [pc, #52]	; (1c2cc <SFXAutotuneFrame+0xe0>)
   1c296:	f00e f963 	bl	2a560 <tSimplePoly_getNumActiveVoices>
	if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1c29a:	9001      	str	r0, [sp, #4]
   1c29c:	b920      	cbnz	r0, 1c2a8 <SFXAutotuneFrame+0xbc>
}
   1c29e:	b002      	add	sp, #8
   1c2a0:	ecbd 8b02 	vpop	{d8}
   1c2a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1c2a8:	ee07 0a90 	vmov	s15, r0
   1c2ac:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1c2b0:	480c      	ldr	r0, [pc, #48]	; (1c2e4 <SFXAutotuneFrame+0xf8>)
   1c2b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1c2b6:	ee80 0a27 	vdiv.f32	s0, s0, s15
}
   1c2ba:	b002      	add	sp, #8
   1c2bc:	ecbd 8b02 	vpop	{d8}
   1c2c0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
   1c2c4:	f00b be4c 	b.w	27f60 <tExpSmooth_setDest>
   1c2c8:	020f9a44 	.word	0x020f9a44
   1c2cc:	020fa15c 	.word	0x020fa15c
   1c2d0:	00000000 	.word	0x00000000
   1c2d4:	020e31e0 	.word	0x020e31e0
   1c2d8:	020e3258 	.word	0x020e3258
   1c2dc:	020e3224 	.word	0x020e3224
   1c2e0:	020fa558 	.word	0x020fa558
   1c2e4:	020f9e9c 	.word	0x020f9e9c
   1c2e8:	2aaaaaab 	.word	0x2aaaaaab

0001c2ec <SFXAutotuneTick>:
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c2ec:	4b27      	ldr	r3, [pc, #156]	; (1c38c <SFXAutotuneTick+0xa0>)
   1c2ee:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1c2f2:	ed9f 7a27 	vldr	s14, [pc, #156]	; 1c390 <SFXAutotuneTick+0xa4>
{
   1c2f6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c2fa:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c2fe:	edd3 6a64 	vldr	s13, [r3, #400]	; 0x190
{
   1c302:	4680      	mov	r8, r0
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c304:	4b23      	ldr	r3, [pc, #140]	; (1c394 <SFXAutotuneTick+0xa8>)
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c306:	2400      	movs	r4, #0
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c308:	eee6 7a87 	vfma.f32	s15, s13, s14
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1c30c:	4822      	ldr	r0, [pc, #136]	; (1c398 <SFXAutotuneTick+0xac>)
   1c30e:	4d23      	ldr	r5, [pc, #140]	; (1c39c <SFXAutotuneTick+0xb0>)
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c310:	4f23      	ldr	r7, [pc, #140]	; (1c3a0 <SFXAutotuneTick+0xb4>)
		tAutotune_setFreq(&autotunePoly, freq[i], i);
   1c312:	4606      	mov	r6, r0
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1c314:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
   1c318:	edc3 7a00 	vstr	s15, [r3]
	tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
   1c31c:	f00a ff58 	bl	271d0 <tAutotune_setFidelityThreshold>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c320:	e003      	b.n	1c32a <SFXAutotuneTick+0x3e>
		tAutotune_setFreq(&autotunePoly, freq[i], i);
   1c322:	ecb5 0a01 	vldmia	r5!, {s0}
   1c326:	f00a ff4b 	bl	271c0 <tAutotune_setFreq>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c32a:	4638      	mov	r0, r7
   1c32c:	f00e f914 	bl	2a558 <tSimplePoly_getNumVoices>
   1c330:	42a0      	cmp	r0, r4
		tAutotune_setFreq(&autotunePoly, freq[i], i);
   1c332:	4621      	mov	r1, r4
   1c334:	4630      	mov	r0, r6
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c336:	f104 0401 	add.w	r4, r4, #1
   1c33a:	dcf2      	bgt.n	1c322 <SFXAutotuneTick+0x36>
	float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1c33c:	ed98 0a01 	vldr	s0, [r8, #4]
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c340:	2400      	movs	r4, #0
	float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1c342:	4815      	ldr	r0, [pc, #84]	; (1c398 <SFXAutotuneTick+0xac>)
   1c344:	f00a fe40 	bl	26fc8 <tAutotune_tick>
	float sample = 0.0f;
   1c348:	ed9f 8a16 	vldr	s16, [pc, #88]	; 1c3a4 <SFXAutotuneTick+0xb8>
	float* samples = tAutotune_tick(&autotunePoly, input[1]);
   1c34c:	4605      	mov	r5, r0
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c34e:	4f14      	ldr	r7, [pc, #80]	; (1c3a0 <SFXAutotuneTick+0xb4>)
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1c350:	4e15      	ldr	r6, [pc, #84]	; (1c3a8 <SFXAutotuneTick+0xbc>)
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c352:	e005      	b.n	1c360 <SFXAutotuneTick+0x74>
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1c354:	ecf5 8a01 	vldmia	r5!, {s17}
   1c358:	f00b fe0c 	bl	27f74 <tExpSmooth_tick>
   1c35c:	eea8 8a80 	vfma.f32	s16, s17, s0
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c360:	4638      	mov	r0, r7
   1c362:	f00e f8f9 	bl	2a558 <tSimplePoly_getNumVoices>
   1c366:	42a0      	cmp	r0, r4
		sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
   1c368:	eb06 0084 	add.w	r0, r6, r4, lsl #2
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
   1c36c:	f104 0401 	add.w	r4, r4, #1
   1c370:	dcf0      	bgt.n	1c354 <SFXAutotuneTick+0x68>
	sample *= tExpSmooth_tick(&comp);
   1c372:	480e      	ldr	r0, [pc, #56]	; (1c3ac <SFXAutotuneTick+0xc0>)
   1c374:	f00b fdfe 	bl	27f74 <tExpSmooth_tick>
   1c378:	ee28 0a00 	vmul.f32	s0, s16, s0
	input[0] = sample;
   1c37c:	ed88 0a00 	vstr	s0, [r8]
	input[1] = sample;
   1c380:	ed88 0a01 	vstr	s0, [r8, #4]
}
   1c384:	ecbd 8b02 	vpop	{d8}
   1c388:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1c38c:	020f9318 	.word	0x020f9318
   1c390:	3ef0a3d7 	.word	0x3ef0a3d7
   1c394:	020fb3cc 	.word	0x020fb3cc
   1c398:	020f9a40 	.word	0x020f9a40
   1c39c:	020f9a44 	.word	0x020f9a44
   1c3a0:	020fa15c 	.word	0x020fa15c
   1c3a4:	00000000 	.word	0x00000000
   1c3a8:	020fa558 	.word	0x020fa558
   1c3ac:	020f9e9c 	.word	0x020f9e9c

0001c3b0 <SFXAutotuneFree>:
	tAutotune_free(&autotunePoly);
   1c3b0:	4801      	ldr	r0, [pc, #4]	; (1c3b8 <SFXAutotuneFree+0x8>)
   1c3b2:	f00a bdc7 	b.w	26f44 <tAutotune_free>
   1c3b6:	bf00      	nop
   1c3b8:	020f9a40 	.word	0x020f9a40

0001c3bc <SFXSamplerBPAlloc>:
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c3bc:	4b1d      	ldr	r3, [pc, #116]	; (1c434 <SFXSamplerBPAlloc+0x78>)
   1c3be:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 1c438 <SFXSamplerBPAlloc+0x7c>
   1c3c2:	4a1e      	ldr	r2, [pc, #120]	; (1c43c <SFXSamplerBPAlloc+0x80>)
{
   1c3c4:	b570      	push	{r4, r5, r6, lr}
   1c3c6:	ed2d 8b02 	vpush	{d8}
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c3ca:	edd3 7a00 	vldr	s15, [r3]
   1c3ce:	4c1c      	ldr	r4, [pc, #112]	; (1c440 <SFXSamplerBPAlloc+0x84>)
   1c3d0:	ee67 7a87 	vmul.f32	s15, s15, s14
	tSampler_init(&sampler, &buff);
   1c3d4:	4e1b      	ldr	r6, [pc, #108]	; (1c444 <SFXSamplerBPAlloc+0x88>)
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c3d6:	4620      	mov	r0, r4
	tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1c3d8:	eddf 8a1b 	vldr	s17, [pc, #108]	; 1c448 <SFXSamplerBPAlloc+0x8c>
   1c3dc:	ed9f 8a1b 	vldr	s16, [pc, #108]	; 1c44c <SFXSamplerBPAlloc+0x90>
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c3e0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1c3e4:	4d1a      	ldr	r5, [pc, #104]	; (1c450 <SFXSamplerBPAlloc+0x94>)
	tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
   1c3e6:	ee17 1a90 	vmov	r1, s15
   1c3ea:	f00f fc61 	bl	2bcb0 <tBuffer_initToPool>
	tBuffer_setRecordMode(&buff, RecordOneShot);
   1c3ee:	4620      	mov	r0, r4
   1c3f0:	2100      	movs	r1, #0
   1c3f2:	f00f fcc3 	bl	2bd7c <tBuffer_setRecordMode>
	tSampler_init(&sampler, &buff);
   1c3f6:	4621      	mov	r1, r4
   1c3f8:	4630      	mov	r0, r6
   1c3fa:	f00f fccf 	bl	2bd9c <tSampler_init>
	tSampler_setMode(&sampler, bpMode + 1);
   1c3fe:	4b15      	ldr	r3, [pc, #84]	; (1c454 <SFXSamplerBPAlloc+0x98>)
   1c400:	4630      	mov	r0, r6
   1c402:	6819      	ldr	r1, [r3, #0]
   1c404:	3101      	adds	r1, #1
   1c406:	b2c9      	uxtb	r1, r1
   1c408:	f00f fd70 	bl	2beec <tSampler_setMode>
	tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
   1c40c:	4629      	mov	r1, r5
   1c40e:	eef0 0a68 	vmov.f32	s1, s17
   1c412:	4811      	ldr	r0, [pc, #68]	; (1c458 <SFXSamplerBPAlloc+0x9c>)
   1c414:	eeb0 0a48 	vmov.f32	s0, s16
   1c418:	f00b fd66 	bl	27ee8 <tExpSmooth_initToPool>
	tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
   1c41c:	eef0 0a68 	vmov.f32	s1, s17
   1c420:	eeb0 0a48 	vmov.f32	s0, s16
   1c424:	4629      	mov	r1, r5
   1c426:	480d      	ldr	r0, [pc, #52]	; (1c45c <SFXSamplerBPAlloc+0xa0>)
}
   1c428:	ecbd 8b02 	vpop	{d8}
   1c42c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
   1c430:	f00b bd5a 	b.w	27ee8 <tExpSmooth_initToPool>
   1c434:	020fc0a8 	.word	0x020fc0a8
   1c438:	432c0000 	.word	0x432c0000
   1c43c:	020f6e58 	.word	0x020f6e58
   1c440:	020f9bf8 	.word	0x020f9bf8
   1c444:	020f9e94 	.word	0x020f9e94
   1c448:	3c23d70a 	.word	0x3c23d70a
   1c44c:	00000000 	.word	0x00000000
   1c450:	020f7730 	.word	0x020f7730
   1c454:	020e312c 	.word	0x020e312c
   1c458:	020fa3c0 	.word	0x020fa3c0
   1c45c:	020f9c64 	.word	0x020f9c64

0001c460 <SFXSamplerBPFrame>:
   1c460:	4770      	bx	lr
   1c462:	bf00      	nop

0001c464 <SFXSamplerBPTick>:
{
   1c464:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (buttonActionsSFX[ButtonC][ActionPress])
   1c468:	4e91      	ldr	r6, [pc, #580]	; (1c6b0 <SFXSamplerBPTick+0x24c>)
{
   1c46a:	4607      	mov	r7, r0
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1c46c:	4891      	ldr	r0, [pc, #580]	; (1c6b4 <SFXSamplerBPTick+0x250>)
{
   1c46e:	ed2d 8b02 	vpush	{d8}
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1c472:	f00f fc7b 	bl	2bd6c <tBuffer_getRecordPosition>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1c476:	7f33      	ldrb	r3, [r6, #28]
	int recordPosition = tBuffer_getRecordPosition(&buff);
   1c478:	ee08 0a10 	vmov	s16, r0
	if (buttonActionsSFX[ButtonC][ActionPress])
   1c47c:	2b00      	cmp	r3, #0
   1c47e:	f040 80a8 	bne.w	1c5d2 <SFXSamplerBPTick+0x16e>
	if (buttonActionsSFX[ButtonB][ActionPress])
   1c482:	7e33      	ldrb	r3, [r6, #24]
   1c484:	f8df 825c 	ldr.w	r8, [pc, #604]	; 1c6e4 <SFXSamplerBPTick+0x280>
   1c488:	4c8b      	ldr	r4, [pc, #556]	; (1c6b8 <SFXSamplerBPTick+0x254>)
   1c48a:	4d8c      	ldr	r5, [pc, #560]	; (1c6bc <SFXSamplerBPTick+0x258>)
   1c48c:	2b00      	cmp	r3, #0
   1c48e:	f040 80b3 	bne.w	1c5f8 <SFXSamplerBPTick+0x194>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c492:	7d33      	ldrb	r3, [r6, #20]
   1c494:	2b00      	cmp	r3, #0
   1c496:	f040 80c6 	bne.w	1c626 <SFXSamplerBPTick+0x1c2>
	if (buttonActionsSFX[ButtonA][ActionRelease])
   1c49a:	7d73      	ldrb	r3, [r6, #21]
   1c49c:	2b00      	cmp	r3, #0
   1c49e:	f040 80d1 	bne.w	1c644 <SFXSamplerBPTick+0x1e0>
	sampleLength = recordPosition * leaf.invSampleRate;
   1c4a2:	4b87      	ldr	r3, [pc, #540]	; (1c6c0 <SFXSamplerBPTick+0x25c>)
   1c4a4:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c4a8:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
	displayValues[0] = knobs[0] * sampleLength;
   1c4ac:	ed94 7a7d 	vldr	s14, [r4, #500]	; 0x1f4
	sampleLength = recordPosition * leaf.invSampleRate;
   1c4b0:	edd3 7a01 	vldr	s15, [r3, #4]
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c4b4:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
	sampleLength = recordPosition * leaf.invSampleRate;
   1c4b8:	ee68 7a27 	vmul.f32	s15, s16, s15
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c4bc:	ed9f 0a81 	vldr	s0, [pc, #516]	; 1c6c4 <SFXSamplerBPTick+0x260>
   1c4c0:	ee38 1ac7 	vsub.f32	s2, s17, s14
	displayValues[0] = knobs[0] * sampleLength;
   1c4c4:	ee27 7a87 	vmul.f32	s14, s15, s14
	sampleLength = recordPosition * leaf.invSampleRate;
   1c4c8:	edc8 7a00 	vstr	s15, [r8]
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c4cc:	ee21 1a27 	vmul.f32	s2, s2, s15
   1c4d0:	ee67 0aa0 	vmul.f32	s1, s15, s1
	displayValues[0] = knobs[0] * sampleLength;
   1c4d4:	ed85 7a00 	vstr	s14, [r5]
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c4d8:	f00d f9d6 	bl	29888 <LEAF_clip>
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c4dc:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1c4e0:	edd4 6a7f 	vldr	s13, [r4, #508]	; 0x1fc
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c4e4:	ed94 7a80 	vldr	s14, [r4, #512]	; 0x200
   1c4e8:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c4ec:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
	displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c4f0:	ed85 0a01 	vstr	s0, [r5, #4]
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c4f4:	ee76 6ae7 	vsub.f32	s13, s13, s15
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c4f8:	ee77 7a67 	vsub.f32	s15, s14, s15
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c4fc:	ee66 6aa5 	vmul.f32	s13, s13, s11
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c500:	ee67 7a86 	vmul.f32	s15, s15, s12
	displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1c504:	edc5 6a02 	vstr	s13, [r5, #8]
	float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1c508:	fef8 7a67 	vrinta.f32	s15, s15
	if (rate < 0.0f)
   1c50c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1c510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c514:	f100 80c0 	bmi.w	1c698 <SFXSamplerBPTick+0x234>
		rate += 1.0f;
   1c518:	ee77 7aa8 	vadd.f32	s15, s15, s17
	displayValues[4] = knobs[4] * 4000.0f;
   1c51c:	ed9f 6a6a 	vldr	s12, [pc, #424]	; 1c6c8 <SFXSamplerBPTick+0x264>
	samplerRate = displayValues[3] * displayValues[2];
   1c520:	ee66 6aa7 	vmul.f32	s13, s13, s15
	displayValues[4] = knobs[4] * 4000.0f;
   1c524:	ed94 7a81 	vldr	s14, [r4, #516]	; 0x204
	tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1c528:	ed94 0a7d 	vldr	s0, [r4, #500]	; 0x1f4
	displayValues[4] = knobs[4] * 4000.0f;
   1c52c:	ee27 7a06 	vmul.f32	s14, s14, s12
	samplerRate = displayValues[3] * displayValues[2];
   1c530:	4e66      	ldr	r6, [pc, #408]	; (1c6cc <SFXSamplerBPTick+0x268>)
	tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1c532:	ee28 0a00 	vmul.f32	s0, s16, s0
   1c536:	4866      	ldr	r0, [pc, #408]	; (1c6d0 <SFXSamplerBPTick+0x26c>)
	samplerRate = displayValues[3] * displayValues[2];
   1c538:	edc6 6a00 	vstr	s13, [r6]
	displayValues[4] = knobs[4] * 4000.0f;
   1c53c:	ed85 7a04 	vstr	s14, [r5, #16]
	displayValues[3] = rate;
   1c540:	edc5 7a03 	vstr	s15, [r5, #12]
	tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
   1c544:	f00b fd0c 	bl	27f60 <tExpSmooth_setDest>
	tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
   1c548:	ed94 0a7e 	vldr	s0, [r4, #504]	; 0x1f8
   1c54c:	4861      	ldr	r0, [pc, #388]	; (1c6d4 <SFXSamplerBPTick+0x270>)
   1c54e:	ee28 0a00 	vmul.f32	s0, s16, s0
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1c552:	f8df 9194 	ldr.w	r9, [pc, #404]	; 1c6e8 <SFXSamplerBPTick+0x284>
	tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
   1c556:	f00b fd03 	bl	27f60 <tExpSmooth_setDest>
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1c55a:	485d      	ldr	r0, [pc, #372]	; (1c6d0 <SFXSamplerBPTick+0x26c>)
   1c55c:	f00b fd0a 	bl	27f74 <tExpSmooth_tick>
   1c560:	eebd 0ac0 	vcvt.s32.f32	s0, s0
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c564:	485b      	ldr	r0, [pc, #364]	; (1c6d4 <SFXSamplerBPTick+0x270>)
   1c566:	f8df 8184 	ldr.w	r8, [pc, #388]	; 1c6ec <SFXSamplerBPTick+0x288>
	samplePlayStart = tExpSmooth_tick(&startSmooth);
   1c56a:	ed89 0a00 	vstr	s0, [r9]
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c56e:	f00b fd01 	bl	27f74 <tExpSmooth_tick>
	crossfadeLength = displayValues[4];
   1c572:	edd5 7a04 	vldr	s15, [r5, #16]
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c576:	eebd 0ac0 	vcvt.s32.f32	s0, s0
	crossfadeLength = displayValues[4];
   1c57a:	4c57      	ldr	r4, [pc, #348]	; (1c6d8 <SFXSamplerBPTick+0x274>)
   1c57c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	tSampler_setStart(&sampler, samplePlayStart);
   1c580:	f8d9 1000 	ldr.w	r1, [r9]
   1c584:	4855      	ldr	r0, [pc, #340]	; (1c6dc <SFXSamplerBPTick+0x278>)
	samplePlayLength = tExpSmooth_tick(&lengthSmooth);
   1c586:	ed88 0a00 	vstr	s0, [r8]
	crossfadeLength = displayValues[4];
   1c58a:	edc4 7a00 	vstr	s15, [r4]
	tSampler_setStart(&sampler, samplePlayStart);
   1c58e:	f00f fd23 	bl	2bfd8 <tSampler_setStart>
	tSampler_setLength(&sampler, samplePlayLength);
   1c592:	f8d8 1000 	ldr.w	r1, [r8]
   1c596:	4851      	ldr	r0, [pc, #324]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c598:	f010 f92c 	bl	2c7f4 <tSampler_setLength>
	tSampler_setRate(&sampler, samplerRate);
   1c59c:	ed96 0a00 	vldr	s0, [r6]
   1c5a0:	484e      	ldr	r0, [pc, #312]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c5a2:	f010 f9c1 	bl	2c928 <tSampler_setRate>
	tSampler_setCrossfadeLength(&sampler, crossfadeLength);
   1c5a6:	6821      	ldr	r1, [r4, #0]
   1c5a8:	484c      	ldr	r0, [pc, #304]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c5aa:	f00f fca3 	bl	2bef4 <tSampler_setCrossfadeLength>
	tBuffer_tick(&buff, input[1]);
   1c5ae:	ed97 0a01 	vldr	s0, [r7, #4]
   1c5b2:	4840      	ldr	r0, [pc, #256]	; (1c6b4 <SFXSamplerBPTick+0x250>)
   1c5b4:	f00f fba0 	bl	2bcf8 <tBuffer_tick>
	sample = tanhf(tSampler_tick(&sampler));
   1c5b8:	4848      	ldr	r0, [pc, #288]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c5ba:	f00f fe39 	bl	2c230 <tSampler_tick>
   1c5be:	f010 fe7d 	bl	2d2bc <tanhf>
	input[0] = sample;
   1c5c2:	ed87 0a00 	vstr	s0, [r7]
	input[1] = sample;
   1c5c6:	ed87 0a01 	vstr	s0, [r7, #4]
}
   1c5ca:	ecbd 8b02 	vpop	{d8}
   1c5ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (samplePlaying)
   1c5d2:	4b43      	ldr	r3, [pc, #268]	; (1c6e0 <SFXSamplerBPTick+0x27c>)
   1c5d4:	781a      	ldrb	r2, [r3, #0]
   1c5d6:	2a00      	cmp	r2, #0
   1c5d8:	d140      	bne.n	1c65c <SFXSamplerBPTick+0x1f8>
			samplePlaying = 1;
   1c5da:	2201      	movs	r2, #1
			tSampler_play(&sampler);
   1c5dc:	483f      	ldr	r0, [pc, #252]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c5de:	f8df 8104 	ldr.w	r8, [pc, #260]	; 1c6e4 <SFXSamplerBPTick+0x280>
   1c5e2:	4c35      	ldr	r4, [pc, #212]	; (1c6b8 <SFXSamplerBPTick+0x254>)
			samplePlaying = 1;
   1c5e4:	701a      	strb	r2, [r3, #0]
   1c5e6:	4d35      	ldr	r5, [pc, #212]	; (1c6bc <SFXSamplerBPTick+0x258>)
			tSampler_play(&sampler);
   1c5e8:	f00f fc9a 	bl	2bf20 <tSampler_play>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c5ec:	2300      	movs	r3, #0
   1c5ee:	7733      	strb	r3, [r6, #28]
	if (buttonActionsSFX[ButtonB][ActionPress])
   1c5f0:	7e33      	ldrb	r3, [r6, #24]
   1c5f2:	2b00      	cmp	r3, #0
   1c5f4:	f43f af4d 	beq.w	1c492 <SFXSamplerBPTick+0x2e>
		bpMode = !bpMode;
   1c5f8:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 1c6f0 <SFXSamplerBPTick+0x28c>
		tSampler_setMode(&sampler, bpMode + 1);
   1c5fc:	4837      	ldr	r0, [pc, #220]	; (1c6dc <SFXSamplerBPTick+0x278>)
		bpMode = !bpMode;
   1c5fe:	f8d9 3000 	ldr.w	r3, [r9]
   1c602:	fab3 f383 	clz	r3, r3
   1c606:	095b      	lsrs	r3, r3, #5
		tSampler_setMode(&sampler, bpMode + 1);
   1c608:	1c59      	adds	r1, r3, #1
		bpMode = !bpMode;
   1c60a:	f8c9 3000 	str.w	r3, [r9]
		tSampler_setMode(&sampler, bpMode + 1);
   1c60e:	f00f fc6d 	bl	2beec <tSampler_setMode>
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c612:	2300      	movs	r3, #0
		setLED_B(bpMode);
   1c614:	f899 0000 	ldrb.w	r0, [r9]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c618:	7633      	strb	r3, [r6, #24]
		setLED_B(bpMode);
   1c61a:	f7fc ff9d 	bl	19558 <setLED_B>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c61e:	7d33      	ldrb	r3, [r6, #20]
   1c620:	2b00      	cmp	r3, #0
   1c622:	f43f af3a 	beq.w	1c49a <SFXSamplerBPTick+0x36>
		tSampler_stop(&sampler);
   1c626:	482d      	ldr	r0, [pc, #180]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c628:	f00f fcca 	bl	2bfc0 <tSampler_stop>
		tBuffer_record(&buff);
   1c62c:	4821      	ldr	r0, [pc, #132]	; (1c6b4 <SFXSamplerBPTick+0x250>)
   1c62e:	f00f fb93 	bl	2bd58 <tBuffer_record>
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c632:	2300      	movs	r3, #0
		setLED_A(1);
   1c634:	2001      	movs	r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c636:	7533      	strb	r3, [r6, #20]
		setLED_A(1);
   1c638:	f7fc ff80 	bl	1953c <setLED_A>
	if (buttonActionsSFX[ButtonA][ActionRelease])
   1c63c:	7d73      	ldrb	r3, [r6, #21]
   1c63e:	2b00      	cmp	r3, #0
   1c640:	f43f af2f 	beq.w	1c4a2 <SFXSamplerBPTick+0x3e>
		tBuffer_stop(&buff);
   1c644:	481b      	ldr	r0, [pc, #108]	; (1c6b4 <SFXSamplerBPTick+0x250>)
   1c646:	f00f fb8d 	bl	2bd64 <tBuffer_stop>
		if (samplePlaying) tSampler_play(&sampler);
   1c64a:	4b25      	ldr	r3, [pc, #148]	; (1c6e0 <SFXSamplerBPTick+0x27c>)
   1c64c:	781b      	ldrb	r3, [r3, #0]
   1c64e:	bb53      	cbnz	r3, 1c6a6 <SFXSamplerBPTick+0x242>
		buttonActionsSFX[ButtonA][ActionRelease] = 0;
   1c650:	2300      	movs	r3, #0
		setLED_A(0);
   1c652:	4618      	mov	r0, r3
		buttonActionsSFX[ButtonA][ActionRelease] = 0;
   1c654:	7573      	strb	r3, [r6, #21]
		setLED_A(0);
   1c656:	f7fc ff71 	bl	1953c <setLED_A>
   1c65a:	e722      	b.n	1c4a2 <SFXSamplerBPTick+0x3e>
			samplePlaying = 0;
   1c65c:	2200      	movs	r2, #0
			tSampler_stop(&sampler);
   1c65e:	481f      	ldr	r0, [pc, #124]	; (1c6dc <SFXSamplerBPTick+0x278>)
			displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c660:	4c15      	ldr	r4, [pc, #84]	; (1c6b8 <SFXSamplerBPTick+0x254>)
			samplePlaying = 0;
   1c662:	701a      	strb	r2, [r3, #0]
			tSampler_stop(&sampler);
   1c664:	f00f fcac 	bl	2bfc0 <tSampler_stop>
			displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1c668:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1c66c:	ed94 1a7d 	vldr	s2, [r4, #500]	; 0x1f4
   1c670:	f8df 8070 	ldr.w	r8, [pc, #112]	; 1c6e4 <SFXSamplerBPTick+0x280>
   1c674:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
   1c678:	ee77 7ac1 	vsub.f32	s15, s15, s2
   1c67c:	ed98 1a00 	vldr	s2, [r8]
   1c680:	4d0e      	ldr	r5, [pc, #56]	; (1c6bc <SFXSamplerBPTick+0x258>)
   1c682:	ee61 0a20 	vmul.f32	s1, s2, s1
   1c686:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 1c6c4 <SFXSamplerBPTick+0x260>
   1c68a:	ee27 1a81 	vmul.f32	s2, s15, s2
   1c68e:	f00d f8fb 	bl	29888 <LEAF_clip>
   1c692:	ed85 0a01 	vstr	s0, [r5, #4]
   1c696:	e7a9      	b.n	1c5ec <SFXSamplerBPTick+0x188>
		(rate = 1.0f / fabsf(rate-1.0f));
   1c698:	ee77 7ae8 	vsub.f32	s15, s15, s17
   1c69c:	eeb0 7ae7 	vabs.f32	s14, s15
   1c6a0:	eec8 7a87 	vdiv.f32	s15, s17, s14
   1c6a4:	e73a      	b.n	1c51c <SFXSamplerBPTick+0xb8>
		if (samplePlaying) tSampler_play(&sampler);
   1c6a6:	480d      	ldr	r0, [pc, #52]	; (1c6dc <SFXSamplerBPTick+0x278>)
   1c6a8:	f00f fc3a 	bl	2bf20 <tSampler_play>
   1c6ac:	e7d0      	b.n	1c650 <SFXSamplerBPTick+0x1ec>
   1c6ae:	bf00      	nop
   1c6b0:	020fb31c 	.word	0x020fb31c
   1c6b4:	020f9bf8 	.word	0x020f9bf8
   1c6b8:	020f9318 	.word	0x020f9318
   1c6bc:	020fb3cc 	.word	0x020fb3cc
   1c6c0:	020fc0a8 	.word	0x020fc0a8
   1c6c4:	00000000 	.word	0x00000000
   1c6c8:	457a0000 	.word	0x457a0000
   1c6cc:	00062b3c 	.word	0x00062b3c
   1c6d0:	020fa3c0 	.word	0x020fa3c0
   1c6d4:	020f9c64 	.word	0x020f9c64
   1c6d8:	020e316c 	.word	0x020e316c
   1c6dc:	020f9e94 	.word	0x020f9e94
   1c6e0:	00062b38 	.word	0x00062b38
   1c6e4:	020e3204 	.word	0x020e3204
   1c6e8:	020e320c 	.word	0x020e320c
   1c6ec:	020e3208 	.word	0x020e3208
   1c6f0:	020e312c 	.word	0x020e312c

0001c6f4 <SFXSamplerBPFree>:
{
   1c6f4:	b508      	push	{r3, lr}
	tBuffer_free(&buff);
   1c6f6:	4807      	ldr	r0, [pc, #28]	; (1c714 <SFXSamplerBPFree+0x20>)
   1c6f8:	f00f faf2 	bl	2bce0 <tBuffer_free>
	tSampler_free(&sampler);
   1c6fc:	4806      	ldr	r0, [pc, #24]	; (1c718 <SFXSamplerBPFree+0x24>)
   1c6fe:	f00f fbe9 	bl	2bed4 <tSampler_free>
	tExpSmooth_free(&startSmooth);
   1c702:	4806      	ldr	r0, [pc, #24]	; (1c71c <SFXSamplerBPFree+0x28>)
   1c704:	f00b fc16 	bl	27f34 <tExpSmooth_free>
	tExpSmooth_free(&lengthSmooth);
   1c708:	4805      	ldr	r0, [pc, #20]	; (1c720 <SFXSamplerBPFree+0x2c>)
}
   1c70a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tExpSmooth_free(&lengthSmooth);
   1c70e:	f00b bc11 	b.w	27f34 <tExpSmooth_free>
   1c712:	bf00      	nop
   1c714:	020f9bf8 	.word	0x020f9bf8
   1c718:	020f9e94 	.word	0x020f9e94
   1c71c:	020fa3c0 	.word	0x020fa3c0
   1c720:	020f9c64 	.word	0x020f9c64

0001c724 <SFXSamplerKAlloc>:
{
   1c724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c728:	4b41      	ldr	r3, [pc, #260]	; (1c830 <SFXSamplerKAlloc+0x10c>)
	leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1c72a:	2200      	movs	r2, #0
   1c72c:	f8df b14c 	ldr.w	fp, [pc, #332]	; 1c87c <SFXSamplerKAlloc+0x158>
	currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1c730:	2018      	movs	r0, #24
   1c732:	4940      	ldr	r1, [pc, #256]	; (1c834 <SFXSamplerKAlloc+0x110>)
   1c734:	4614      	mov	r4, r2
   1c736:	f8df a148 	ldr.w	sl, [pc, #328]	; 1c880 <SFXSamplerKAlloc+0x15c>
   1c73a:	f8df 9148 	ldr.w	r9, [pc, #328]	; 1c884 <SFXSamplerKAlloc+0x160>
   1c73e:	f8df 8148 	ldr.w	r8, [pc, #328]	; 1c888 <SFXSamplerKAlloc+0x164>
		tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1c742:	4f3d      	ldr	r7, [pc, #244]	; (1c838 <SFXSamplerKAlloc+0x114>)
	leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
   1c744:	f8cb 2014 	str.w	r2, [fp, #20]
{
   1c748:	ed2d 8b04 	vpush	{d8-d9}
   1c74c:	b085      	sub	sp, #20
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c74e:	ed9f 9a3b 	vldr	s18, [pc, #236]	; 1c83c <SFXSamplerKAlloc+0x118>
		samplePlayStarts[i] = 0;
   1c752:	ed9f 8a3b 	vldr	s16, [pc, #236]	; 1c840 <SFXSamplerKAlloc+0x11c>
   1c756:	9303      	str	r3, [sp, #12]
   1c758:	4b3a      	ldr	r3, [pc, #232]	; (1c844 <SFXSamplerKAlloc+0x120>)
		crossfadeLengths[i] = 1000;
   1c75a:	eddf 8a3b 	vldr	s17, [pc, #236]	; 1c848 <SFXSamplerKAlloc+0x124>
   1c75e:	9300      	str	r3, [sp, #0]
   1c760:	4b3a      	ldr	r3, [pc, #232]	; (1c84c <SFXSamplerKAlloc+0x128>)
	currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
   1c762:	6008      	str	r0, [r1, #0]
   1c764:	9302      	str	r3, [sp, #8]
   1c766:	4b3a      	ldr	r3, [pc, #232]	; (1c850 <SFXSamplerKAlloc+0x12c>)
   1c768:	9301      	str	r3, [sp, #4]
		tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
   1c76a:	eef0 7a0c 	vmov.f32	s15, #12	; 0x40600000  3.5
   1c76e:	ed9b 7a00 	vldr	s14, [fp]
   1c772:	4b38      	ldr	r3, [pc, #224]	; (1c854 <SFXSamplerKAlloc+0x130>)
   1c774:	4a38      	ldr	r2, [pc, #224]	; (1c858 <SFXSamplerKAlloc+0x134>)
   1c776:	ee67 7a27 	vmul.f32	s15, s14, s15
   1c77a:	191d      	adds	r5, r3, r4
   1c77c:	4b37      	ldr	r3, [pc, #220]	; (1c85c <SFXSamplerKAlloc+0x138>)
   1c77e:	4628      	mov	r0, r5
   1c780:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1c784:	191e      	adds	r6, r3, r4
   1c786:	ee17 1a90 	vmov	r1, s15
   1c78a:	f00f fa91 	bl	2bcb0 <tBuffer_initToPool>
		tBuffer_setRecordMode(&keyBuff[i], RecordOneShot);
   1c78e:	4628      	mov	r0, r5
   1c790:	2100      	movs	r1, #0
   1c792:	f00f faf3 	bl	2bd7c <tBuffer_setRecordMode>
		tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
   1c796:	463a      	mov	r2, r7
   1c798:	4629      	mov	r1, r5
   1c79a:	4630      	mov	r0, r6
   1c79c:	f00f fb4e 	bl	2be3c <tSampler_initToPool>
		tSampler_setMode(&keySampler[i], PlayLoop);
   1c7a0:	4630      	mov	r0, r6
   1c7a2:	2101      	movs	r1, #1
   1c7a4:	f00f fba2 	bl	2beec <tSampler_setMode>
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c7a8:	4b2d      	ldr	r3, [pc, #180]	; (1c860 <SFXSamplerKAlloc+0x13c>)
   1c7aa:	4639      	mov	r1, r7
   1c7ac:	eef0 0a49 	vmov.f32	s1, s18
   1c7b0:	1918      	adds	r0, r3, r4
		samplePlayStarts[i] = 0;
   1c7b2:	9b03      	ldr	r3, [sp, #12]
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c7b4:	ed9f 0a22 	vldr	s0, [pc, #136]	; 1c840 <SFXSamplerKAlloc+0x11c>
		samplePlayStarts[i] = 0;
   1c7b8:	eca3 8a01 	vstmia	r3!, {s16}
   1c7bc:	9303      	str	r3, [sp, #12]
		samplePlayLengths[i] = 0;
   1c7be:	9b00      	ldr	r3, [sp, #0]
   1c7c0:	eca3 8a01 	vstmia	r3!, {s16}
   1c7c4:	9300      	str	r3, [sp, #0]
		detectedAttackPos[i] = 0;
   1c7c6:	9b02      	ldr	r3, [sp, #8]
   1c7c8:	461a      	mov	r2, r3
   1c7ca:	2300      	movs	r3, #0
   1c7cc:	f842 3f04 	str.w	r3, [r2, #4]!
		crossfadeLengths[i] = 1000;
   1c7d0:	9b01      	ldr	r3, [sp, #4]
		detectedAttackPos[i] = 0;
   1c7d2:	9202      	str	r2, [sp, #8]
		crossfadeLengths[i] = 1000;
   1c7d4:	ece3 8a01 	vstmia	r3!, {s17}
   1c7d8:	9301      	str	r3, [sp, #4]
		samplerKeyHeld[i] = 0;
   1c7da:	f04f 0300 	mov.w	r3, #0
   1c7de:	f80a 3f01 	strb.w	r3, [sl, #1]!
		tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
   1c7e2:	f00b fb81 	bl	27ee8 <tExpSmooth_initToPool>
		loopOns[i] = 1;
   1c7e6:	2101      	movs	r1, #1
   1c7e8:	4b1e      	ldr	r3, [pc, #120]	; (1c864 <SFXSamplerKAlloc+0x140>)
		sampleRates[i] = 1.0f;
   1c7ea:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
		loopOns[i] = 1;
   1c7ee:	5119      	str	r1, [r3, r4]
   1c7f0:	3404      	adds	r4, #4
		sampleRates[i] = 1.0f;
   1c7f2:	f849 2b04 	str.w	r2, [r9], #4
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1c7f6:	2cc4      	cmp	r4, #196	; 0xc4
		sampleRatesMult[i] = 1.0f;
   1c7f8:	f848 2b04 	str.w	r2, [r8], #4
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1c7fc:	d1b5      	bne.n	1c76a <SFXSamplerKAlloc+0x46>
	tSimplePoly_setNumVoices(&poly, NUM_SAMPLER_VOICES);
   1c7fe:	2106      	movs	r1, #6
   1c800:	4819      	ldr	r0, [pc, #100]	; (1c868 <SFXSamplerKAlloc+0x144>)
   1c802:	f00d fea1 	bl	2a548 <tSimplePoly_setNumVoices>
	setLED_B(controlAllKeys);
   1c806:	4919      	ldr	r1, [pc, #100]	; (1c86c <SFXSamplerKAlloc+0x148>)
		waitingForDeactivation[i] = -1;
   1c808:	4b19      	ldr	r3, [pc, #100]	; (1c870 <SFXSamplerKAlloc+0x14c>)
   1c80a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	setLED_B(controlAllKeys);
   1c80e:	7808      	ldrb	r0, [r1, #0]
		waitingForDeactivation[i] = -1;
   1c810:	e9c3 2200 	strd	r2, r2, [r3]
   1c814:	e9c3 2202 	strd	r2, r2, [r3, #8]
   1c818:	e9c3 2204 	strd	r2, r2, [r3, #16]
	setLED_B(controlAllKeys);
   1c81c:	f7fc fe9c 	bl	19558 <setLED_B>
	samp_thresh = 0.0002f;
   1c820:	4b14      	ldr	r3, [pc, #80]	; (1c874 <SFXSamplerKAlloc+0x150>)
   1c822:	4a15      	ldr	r2, [pc, #84]	; (1c878 <SFXSamplerKAlloc+0x154>)
   1c824:	601a      	str	r2, [r3, #0]
}
   1c826:	b005      	add	sp, #20
   1c828:	ecbd 8b04 	vpop	{d8-d9}
   1c82c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c830:	020f9f84 	.word	0x020f9f84
   1c834:	00062ab4 	.word	0x00062ab4
   1c838:	020f7730 	.word	0x020f7730
   1c83c:	3d23d70a 	.word	0x3d23d70a
   1c840:	00000000 	.word	0x00000000
   1c844:	020f8e88 	.word	0x020f8e88
   1c848:	447a0000 	.word	0x447a0000
   1c84c:	020fafa4 	.word	0x020fafa4
   1c850:	020fa3c4 	.word	0x020fa3c4
   1c854:	020fada0 	.word	0x020fada0
   1c858:	020f6e58 	.word	0x020f6e58
   1c85c:	020f9b34 	.word	0x020f9b34
   1c860:	020f8c94 	.word	0x020f8c94
   1c864:	020f9254 	.word	0x020f9254
   1c868:	020fa15c 	.word	0x020fa15c
   1c86c:	020e3168 	.word	0x020e3168
   1c870:	020fa250 	.word	0x020fa250
   1c874:	020e31fc 	.word	0x020e31fc
   1c878:	3951b717 	.word	0x3951b717
   1c87c:	020fc0a8 	.word	0x020fc0a8
   1c880:	020fa373 	.word	0x020fa373
   1c884:	020f8f70 	.word	0x020f8f70
   1c888:	020fa48c 	.word	0x020fa48c

0001c88c <SFXSamplerKFrame>:
	int currentSamplerKey = currentSamplerKeyGlobal;
   1c88c:	4aa5      	ldr	r2, [pc, #660]	; (1cb24 <SFXSamplerKFrame+0x298>)
	if (samplerKeyHeld[currentSamplerKey])
   1c88e:	4ba6      	ldr	r3, [pc, #664]	; (1cb28 <SFXSamplerKFrame+0x29c>)
{
   1c890:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c894:	ed2d 8b04 	vpush	{d8-d9}
	int currentSamplerKey = currentSamplerKeyGlobal;
   1c898:	6814      	ldr	r4, [r2, #0]
{
   1c89a:	b083      	sub	sp, #12
	if (samplerKeyHeld[currentSamplerKey])
   1c89c:	5d1b      	ldrb	r3, [r3, r4]
   1c89e:	2b00      	cmp	r3, #0
   1c8a0:	f040 8101 	bne.w	1caa6 <SFXSamplerKFrame+0x21a>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1c8a4:	4da1      	ldr	r5, [pc, #644]	; (1cb2c <SFXSamplerKFrame+0x2a0>)
   1c8a6:	7d2b      	ldrb	r3, [r5, #20]
   1c8a8:	b163      	cbz	r3, 1c8c4 <SFXSamplerKFrame+0x38>
		tBuffer_setRecordPosition(&keyBuff[currentSamplerKey],0);
   1c8aa:	48a1      	ldr	r0, [pc, #644]	; (1cb30 <SFXSamplerKFrame+0x2a4>)
   1c8ac:	2100      	movs	r1, #0
   1c8ae:	eb00 0684 	add.w	r6, r0, r4, lsl #2
   1c8b2:	4630      	mov	r0, r6
   1c8b4:	f00f fa5e 	bl	2bd74 <tBuffer_setRecordPosition>
		tBuffer_setRecordedLength(&keyBuff[currentSamplerKey],0);
   1c8b8:	4630      	mov	r0, r6
   1c8ba:	2100      	movs	r1, #0
   1c8bc:	f00f fa66 	bl	2bd8c <tBuffer_setRecordedLength>
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1c8c0:	2300      	movs	r3, #0
   1c8c2:	752b      	strb	r3, [r5, #20]
	if (buttonActionsSFX[ButtonB][ActionPress])
   1c8c4:	7e2b      	ldrb	r3, [r5, #24]
   1c8c6:	b153      	cbz	r3, 1c8de <SFXSamplerKFrame+0x52>
		controlAllKeys = !controlAllKeys;
   1c8c8:	4a9a      	ldr	r2, [pc, #616]	; (1cb34 <SFXSamplerKFrame+0x2a8>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c8ca:	2100      	movs	r1, #0
		controlAllKeys = !controlAllKeys;
   1c8cc:	6813      	ldr	r3, [r2, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1c8ce:	7629      	strb	r1, [r5, #24]
		controlAllKeys = !controlAllKeys;
   1c8d0:	fab3 f383 	clz	r3, r3
   1c8d4:	095b      	lsrs	r3, r3, #5
		setLED_B(controlAllKeys);
   1c8d6:	4618      	mov	r0, r3
		controlAllKeys = !controlAllKeys;
   1c8d8:	6013      	str	r3, [r2, #0]
		setLED_B(controlAllKeys);
   1c8da:	f7fc fe3d 	bl	19558 <setLED_B>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1c8de:	7f2b      	ldrb	r3, [r5, #28]
   1c8e0:	2b00      	cmp	r3, #0
   1c8e2:	f000 80c2 	beq.w	1ca6a <SFXSamplerKFrame+0x1de>
		if (!controlAllKeys)
   1c8e6:	4a93      	ldr	r2, [pc, #588]	; (1cb34 <SFXSamplerKFrame+0x2a8>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c8e8:	2300      	movs	r3, #0
		if (!controlAllKeys)
   1c8ea:	f8d2 9000 	ldr.w	r9, [r2]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1c8ee:	772b      	strb	r3, [r5, #28]
		if (!controlAllKeys)
   1c8f0:	f1b9 0f00 	cmp.w	r9, #0
   1c8f4:	d053      	beq.n	1c99e <SFXSamplerKFrame+0x112>
   1c8f6:	2306      	movs	r3, #6
   1c8f8:	f8df 9268 	ldr.w	r9, [pc, #616]	; 1cb64 <SFXSamplerKFrame+0x2d8>
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c8fc:	eddf 8a8e 	vldr	s17, [pc, #568]	; 1cb38 <SFXSamplerKFrame+0x2ac>
						float previousPower = 0.0f;
   1c900:	ed9f 9a8e 	vldr	s18, [pc, #568]	; 1cb3c <SFXSamplerKFrame+0x2b0>
   1c904:	9301      	str	r3, [sp, #4]
   1c906:	4f8a      	ldr	r7, [pc, #552]	; (1cb30 <SFXSamplerKFrame+0x2a4>)
   1c908:	4e8d      	ldr	r6, [pc, #564]	; (1cb40 <SFXSamplerKFrame+0x2b4>)
   1c90a:	f8df 8238 	ldr.w	r8, [pc, #568]	; 1cb44 <SFXSamplerKFrame+0x2b8>
   1c90e:	e01c      	b.n	1c94a <SFXSamplerKFrame+0xbe>
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c910:	eeb4 8ac0 	vcmpe.f32	s16, s0
   1c914:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c918:	d53b      	bpl.n	1c992 <SFXSamplerKFrame+0x106>
								int thePos = (i + detectedAttackPos[key] - 480) % buffLength;
   1c91a:	6833      	ldr	r3, [r6, #0]
   1c91c:	441d      	add	r5, r3
   1c91e:	f5a5 75f0 	sub.w	r5, r5, #480	; 0x1e0
   1c922:	fb95 f3f4 	sdiv	r3, r5, r4
   1c926:	fb04 5513 	mls	r5, r4, r3, r5
   1c92a:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
								samplePlayStarts[key] = thePos;
   1c92e:	ee07 5a90 	vmov	s15, r5
								detectedAttackPos[key] = thePos;
   1c932:	6035      	str	r5, [r6, #0]
								samplePlayStarts[key] = thePos;
   1c934:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1c938:	edc8 7a00 	vstr	s15, [r8]
   1c93c:	3604      	adds	r6, #4
   1c93e:	3704      	adds	r7, #4
   1c940:	f108 0804 	add.w	r8, r8, #4
				for (int key = 0; key < NUM_SAMPLER_KEYS; key++)
   1c944:	45b1      	cmp	r9, r6
   1c946:	f000 80a4 	beq.w	1ca92 <SFXSamplerKFrame+0x206>
					int buffLength = tBuffer_getRecordedLength(&keyBuff[key]);
   1c94a:	4638      	mov	r0, r7
   1c94c:	f00f fa1a 	bl	2bd84 <tBuffer_getRecordedLength>
					if (buffLength > 0)
   1c950:	1e04      	subs	r4, r0, #0
   1c952:	ddf3      	ble.n	1c93c <SFXSamplerKFrame+0xb0>
						if (detectedAttackPos[key] > 0)
   1c954:	6833      	ldr	r3, [r6, #0]
   1c956:	2b00      	cmp	r3, #0
   1c958:	f300 808c 	bgt.w	1ca74 <SFXSamplerKFrame+0x1e8>
						float previousPower = 0.0f;
   1c95c:	eeb0 0a49 	vmov.f32	s0, s18
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c960:	ee30 8a28 	vadd.f32	s16, s0, s17
{
   1c964:	f04f 0b01 	mov.w	fp, #1
   1c968:	f8df a1fc 	ldr.w	sl, [pc, #508]	; 1cb68 <SFXSamplerKFrame+0x2dc>
   1c96c:	f10b 35ff 	add.w	r5, fp, #4294967295	; 0xffffffff
							float testSample = tBuffer_get(&keyBuff[key], (i + detectedAttackPos[key]) % buffLength);
   1c970:	4638      	mov	r0, r7
   1c972:	442b      	add	r3, r5
   1c974:	fb93 f1f4 	sdiv	r1, r3, r4
   1c978:	fb04 3111 	mls	r1, r4, r1, r3
   1c97c:	f00f f9da 	bl	2bd34 <tBuffer_get>
							currentPower = testSample*testSample;
   1c980:	ee20 0a00 	vmul.f32	s0, s0, s0
							if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c984:	edda 7a00 	vldr	s15, [sl]
   1c988:	eef4 7ac0 	vcmpe.f32	s15, s0
   1c98c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c990:	d4be      	bmi.n	1c910 <SFXSamplerKFrame+0x84>
							if (i >= buffLength)
   1c992:	455c      	cmp	r4, fp
   1c994:	ddd2      	ble.n	1c93c <SFXSamplerKFrame+0xb0>
   1c996:	f10b 0b01 	add.w	fp, fp, #1
   1c99a:	6833      	ldr	r3, [r6, #0]
   1c99c:	e7e6      	b.n	1c96c <SFXSamplerKFrame+0xe0>
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1c99e:	ea4f 0884 	mov.w	r8, r4, lsl #2
   1c9a2:	4f63      	ldr	r7, [pc, #396]	; (1cb30 <SFXSamplerKFrame+0x2a4>)
			if (detectedAttackPos[currentSamplerKey] > 0)
   1c9a4:	4e66      	ldr	r6, [pc, #408]	; (1cb40 <SFXSamplerKFrame+0x2b4>)
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1c9a6:	4447      	add	r7, r8
   1c9a8:	4638      	mov	r0, r7
   1c9aa:	f00f f9eb 	bl	2bd84 <tBuffer_getRecordedLength>
			if (detectedAttackPos[currentSamplerKey] > 0)
   1c9ae:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
			int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1c9b2:	4605      	mov	r5, r0
			if (detectedAttackPos[currentSamplerKey] > 0)
   1c9b4:	2b00      	cmp	r3, #0
   1c9b6:	f300 80a4 	bgt.w	1cb02 <SFXSamplerKFrame+0x276>
			float previousPower = 0.0f;
   1c9ba:	ed9f 0a60 	vldr	s0, [pc, #384]	; 1cb3c <SFXSamplerKFrame+0x2b0>
				if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c9be:	ed9f 8a5e 	vldr	s16, [pc, #376]	; 1cb38 <SFXSamplerKFrame+0x2ac>
   1c9c2:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 1cb68 <SFXSamplerKFrame+0x2dc>
   1c9c6:	ee30 8a08 	vadd.f32	s16, s0, s16
				float testSample = tBuffer_get(&keyBuff[currentSamplerKey], (i + detectedAttackPos[currentSamplerKey]) % buffLength);
   1c9ca:	444b      	add	r3, r9
   1c9cc:	4638      	mov	r0, r7
   1c9ce:	f109 0b01 	add.w	fp, r9, #1
   1c9d2:	fb93 f1f5 	sdiv	r1, r3, r5
   1c9d6:	fb05 3111 	mls	r1, r5, r1, r3
   1c9da:	f00f f9ab 	bl	2bd34 <tBuffer_get>
				currentPower = testSample*testSample;
   1c9de:	ee20 0a00 	vmul.f32	s0, s0, s0
				if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
   1c9e2:	edda 7a00 	vldr	s15, [sl]
   1c9e6:	eef4 7ac0 	vcmpe.f32	s15, s0
   1c9ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c9ee:	f140 8082 	bpl.w	1caf6 <SFXSamplerKFrame+0x26a>
   1c9f2:	eeb4 8ac0 	vcmpe.f32	s16, s0
   1c9f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1c9fa:	d57c      	bpl.n	1caf6 <SFXSamplerKFrame+0x26a>
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1c9fc:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
					OLEDclearLine(SecondLine);
   1ca00:	2001      	movs	r0, #1
					samplePlayStarts[currentSamplerKey] = thePos;
   1ca02:	4a50      	ldr	r2, [pc, #320]	; (1cb44 <SFXSamplerKFrame+0x2b8>)
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1ca04:	444b      	add	r3, r9
					samplePlayStarts[currentSamplerKey] = thePos;
   1ca06:	4490      	add	r8, r2
					int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
   1ca08:	f5a3 72f0 	sub.w	r2, r3, #480	; 0x1e0
   1ca0c:	fb92 f3f5 	sdiv	r3, r2, r5
   1ca10:	fb05 2313 	mls	r3, r5, r3, r2
   1ca14:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
					samplePlayStarts[currentSamplerKey] = thePos;
   1ca18:	ee07 3a90 	vmov	s15, r3
					detectedAttackPos[currentSamplerKey] = thePos;
   1ca1c:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
					samplePlayStarts[currentSamplerKey] = thePos;
   1ca20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ca24:	edc8 7a00 	vstr	s15, [r8]
					OLEDclearLine(SecondLine);
   1ca28:	f7fc ffb0 	bl	1998c <OLEDclearLine>
					OLEDwriteString("ATKDETECT ", 10, 0, SecondLine);
   1ca2c:	2200      	movs	r2, #0
   1ca2e:	210a      	movs	r1, #10
   1ca30:	2301      	movs	r3, #1
   1ca32:	4845      	ldr	r0, [pc, #276]	; (1cb48 <SFXSamplerKFrame+0x2bc>)
   1ca34:	f7fc ffbe 	bl	199b4 <OLEDwriteString>
					OLEDwriteFloat((samplePlayStarts[currentSamplerKey] / (float)buffLength) * (buffLength * leaf.invSampleRate), OLEDgetCursor(), SecondLine);
   1ca38:	ee07 5a90 	vmov	s15, r5
   1ca3c:	ed98 7a00 	vldr	s14, [r8]
   1ca40:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1ca44:	4b41      	ldr	r3, [pc, #260]	; (1cb4c <SFXSamplerKFrame+0x2c0>)
   1ca46:	ee87 8a27 	vdiv.f32	s16, s14, s15
   1ca4a:	ed93 7a01 	vldr	s14, [r3, #4]
   1ca4e:	ee67 7a87 	vmul.f32	s15, s15, s14
   1ca52:	ee28 8a27 	vmul.f32	s16, s16, s15
   1ca56:	f7fd fa29 	bl	19eac <OLEDgetCursor>
   1ca5a:	2101      	movs	r1, #1
   1ca5c:	b2c0      	uxtb	r0, r0
   1ca5e:	eeb0 0a48 	vmov.f32	s0, s16
   1ca62:	f7fd f865 	bl	19b30 <OLEDwriteFloat>
				if (i >= buffLength)
   1ca66:	455d      	cmp	r5, fp
   1ca68:	dd34      	ble.n	1cad4 <SFXSamplerKFrame+0x248>
}
   1ca6a:	b003      	add	sp, #12
   1ca6c:	ecbd 8b04 	vpop	{d8-d9}
   1ca70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
							previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1ca74:	f241 22bf 	movw	r2, #4799	; 0x12bf
							detectedAttackPos[key] += 4800;
   1ca78:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
							previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1ca7c:	4638      	mov	r0, r7
   1ca7e:	441a      	add	r2, r3
							detectedAttackPos[key] += 4800;
   1ca80:	6031      	str	r1, [r6, #0]
							previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
   1ca82:	fb92 f1f4 	sdiv	r1, r2, r4
   1ca86:	fb04 2111 	mls	r1, r4, r1, r2
   1ca8a:	f00f f953 	bl	2bd34 <tBuffer_get>
   1ca8e:	6833      	ldr	r3, [r6, #0]
   1ca90:	e766      	b.n	1c960 <SFXSamplerKFrame+0xd4>
			for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1ca92:	9b01      	ldr	r3, [sp, #4]
   1ca94:	3b01      	subs	r3, #1
   1ca96:	9301      	str	r3, [sp, #4]
   1ca98:	f47f af35 	bne.w	1c906 <SFXSamplerKFrame+0x7a>
}
   1ca9c:	b003      	add	sp, #12
   1ca9e:	ecbd 8b04 	vpop	{d8-d9}
   1caa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
   1caa6:	4822      	ldr	r0, [pc, #136]	; (1cb30 <SFXSamplerKFrame+0x2a4>)
   1caa8:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   1caac:	f00f f972 	bl	2bd94 <tBuffer_isActive>
   1cab0:	4b27      	ldr	r3, [pc, #156]	; (1cb50 <SFXSamplerKFrame+0x2c4>)
   1cab2:	b158      	cbz	r0, 1cacc <SFXSamplerKFrame+0x240>
			buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1cab4:	4a27      	ldr	r2, [pc, #156]	; (1cb54 <SFXSamplerKFrame+0x2c8>)
   1cab6:	2101      	movs	r1, #1
			writeButtonFlag = ExtraMessage;
   1cab8:	4827      	ldr	r0, [pc, #156]	; (1cb58 <SFXSamplerKFrame+0x2cc>)
   1caba:	250a      	movs	r5, #10
			buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
   1cabc:	f882 102b 	strb.w	r1, [r2, #43]	; 0x2b
			writeActionFlag = ActionHoldContinuous;
   1cac0:	2103      	movs	r1, #3
   1cac2:	4a26      	ldr	r2, [pc, #152]	; (1cb5c <SFXSamplerKFrame+0x2d0>)
			writeButtonFlag = ExtraMessage;
   1cac4:	7005      	strb	r5, [r0, #0]
			writeActionFlag = ActionHoldContinuous;
   1cac6:	7011      	strb	r1, [r2, #0]
		prevSamplerKey = currentSamplerKey;
   1cac8:	601c      	str	r4, [r3, #0]
   1caca:	e6eb      	b.n	1c8a4 <SFXSamplerKFrame+0x18>
		if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
   1cacc:	681a      	ldr	r2, [r3, #0]
   1cace:	42a2      	cmp	r2, r4
   1cad0:	d1f0      	bne.n	1cab4 <SFXSamplerKFrame+0x228>
   1cad2:	e7f9      	b.n	1cac8 <SFXSamplerKFrame+0x23c>
					detectedAttackPos[currentSamplerKey] = 0;
   1cad4:	2500      	movs	r5, #0
					OLEDclearLine(SecondLine);
   1cad6:	2001      	movs	r0, #1
					detectedAttackPos[currentSamplerKey] = 0;
   1cad8:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
					OLEDclearLine(SecondLine);
   1cadc:	f7fc ff56 	bl	1998c <OLEDclearLine>
					OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
   1cae0:	462a      	mov	r2, r5
   1cae2:	2301      	movs	r3, #1
   1cae4:	210a      	movs	r1, #10
   1cae6:	481e      	ldr	r0, [pc, #120]	; (1cb60 <SFXSamplerKFrame+0x2d4>)
}
   1cae8:	b003      	add	sp, #12
   1caea:	ecbd 8b04 	vpop	{d8-d9}
   1caee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
   1caf2:	f7fc bf5f 	b.w	199b4 <OLEDwriteString>
				if (i >= buffLength)
   1caf6:	455d      	cmp	r5, fp
   1caf8:	ddec      	ble.n	1cad4 <SFXSamplerKFrame+0x248>
{
   1cafa:	46d9      	mov	r9, fp
   1cafc:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1cb00:	e763      	b.n	1c9ca <SFXSamplerKFrame+0x13e>
				previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1cb02:	f241 22bf 	movw	r2, #4799	; 0x12bf
				detectedAttackPos[currentSamplerKey] += 4800;
   1cb06:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
				previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1cb0a:	4638      	mov	r0, r7
   1cb0c:	441a      	add	r2, r3
				detectedAttackPos[currentSamplerKey] += 4800;
   1cb0e:	f846 1024 	str.w	r1, [r6, r4, lsl #2]
				previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
   1cb12:	fb92 f1f5 	sdiv	r1, r2, r5
   1cb16:	fb05 2111 	mls	r1, r5, r1, r2
   1cb1a:	f00f f90b 	bl	2bd34 <tBuffer_get>
   1cb1e:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1cb22:	e74c      	b.n	1c9be <SFXSamplerKFrame+0x132>
   1cb24:	00062ab4 	.word	0x00062ab4
   1cb28:	020fa374 	.word	0x020fa374
   1cb2c:	020fb31c 	.word	0x020fb31c
   1cb30:	020fada0 	.word	0x020fada0
   1cb34:	020e3168 	.word	0x020e3168
   1cb38:	3a03126f 	.word	0x3a03126f
   1cb3c:	00000000 	.word	0x00000000
   1cb40:	020fafa8 	.word	0x020fafa8
   1cb44:	020f9f84 	.word	0x020f9f84
   1cb48:	00031048 	.word	0x00031048
   1cb4c:	020fc0a8 	.word	0x020fc0a8
   1cb50:	00062b00 	.word	0x00062b00
   1cb54:	020fb45c 	.word	0x020fb45c
   1cb58:	00062b62 	.word	0x00062b62
   1cb5c:	00062b61 	.word	0x00062b61
   1cb60:	00031038 	.word	0x00031038
   1cb64:	020fb06c 	.word	0x020fb06c
   1cb68:	020e31fc 	.word	0x020e31fc
   1cb6c:	00000000 	.word	0x00000000

0001cb70 <SFXSamplerKTick>:
	if (!controlAllKeys)
   1cb70:	4baf      	ldr	r3, [pc, #700]	; (1ce30 <SFXSamplerKTick+0x2c0>)
{
   1cb72:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cb76:	ed2d 8b04 	vpush	{d8-d9}
	if (!controlAllKeys)
   1cb7a:	681b      	ldr	r3, [r3, #0]
{
   1cb7c:	b087      	sub	sp, #28
   1cb7e:	4682      	mov	sl, r0
	if (!controlAllKeys)
   1cb80:	2b00      	cmp	r3, #0
   1cb82:	f000 817d 	beq.w	1ce80 <SFXSamplerKTick+0x310>
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1cb86:	2700      	movs	r7, #0
   1cb88:	4caa      	ldr	r4, [pc, #680]	; (1ce34 <SFXSamplerKTick+0x2c4>)
   1cb8a:	4dab      	ldr	r5, [pc, #684]	; (1ce38 <SFXSamplerKTick+0x2c8>)
   1cb8c:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 1ce6c <SFXSamplerKTick+0x2fc>
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cb90:	eddf 8aaa 	vldr	s17, [pc, #680]	; 1ce3c <SFXSamplerKTick+0x2cc>
			displayValues[5] = knobs[5] * 4000.0f;
   1cb94:	ed9f 8aaa 	vldr	s16, [pc, #680]	; 1ce40 <SFXSamplerKTick+0x2d0>
			if (tSimplePoly_isOn(&poly, i) > 0)
   1cb98:	f8df b2dc 	ldr.w	fp, [pc, #732]	; 1ce78 <SFXSamplerKTick+0x308>
   1cb9c:	9000      	str	r0, [sp, #0]
   1cb9e:	e003      	b.n	1cba8 <SFXSamplerKTick+0x38>
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1cba0:	3701      	adds	r7, #1
   1cba2:	2f06      	cmp	r7, #6
   1cba4:	f000 80f5 	beq.w	1cd92 <SFXSamplerKTick+0x222>
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cba8:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
			displayValues[0] = knobs[0];
   1cbac:	ed94 1a96 	vldr	s2, [r4, #600]	; 0x258
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cbb0:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
   1cbb4:	eeb0 0a68 	vmov.f32	s0, s17
			displayValues[0] = knobs[0];
   1cbb8:	ed85 1a00 	vstr	s2, [r5]
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cbbc:	ee39 1a41 	vsub.f32	s2, s18, s2
   1cbc0:	f00c fe62 	bl	29888 <LEAF_clip>
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cbc4:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1cbc8:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cbcc:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
   1cbd0:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cbd4:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
   1cbd8:	ee75 5ae7 	vsub.f32	s11, s11, s15
			displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
   1cbdc:	ed85 0a01 	vstr	s0, [r5, #4]
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cbe0:	ee76 7ae7 	vsub.f32	s15, s13, s15
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cbe4:	ee25 6a86 	vmul.f32	s12, s11, s12
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cbe8:	ee67 7a87 	vmul.f32	s15, s15, s14
			displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cbec:	ed85 6a02 	vstr	s12, [r5, #8]
			float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cbf0:	fef8 7a67 	vrinta.f32	s15, s15
			if (rate < 0.0f)
   1cbf4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1cbf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cbfc:	f100 8107 	bmi.w	1ce0e <SFXSamplerKTick+0x29e>
				rate += 1.0f;
   1cc00:	ee77 7a89 	vadd.f32	s15, s15, s18
			displayValues[5] = knobs[5] * 4000.0f;
   1cc04:	edd4 6a9b 	vldr	s13, [r4, #620]	; 0x26c
			if (tSimplePoly_isOn(&poly, i) > 0)
   1cc08:	b2fe      	uxtb	r6, r7
			displayValues[4] = roundf(knobs[4]);
   1cc0a:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
			if (tSimplePoly_isOn(&poly, i) > 0)
   1cc0e:	4658      	mov	r0, fp
			displayValues[5] = knobs[5] * 4000.0f;
   1cc10:	ee66 6a88 	vmul.f32	s13, s13, s16
			displayValues[6] = knobs[6];
   1cc14:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
			if (tSimplePoly_isOn(&poly, i) > 0)
   1cc18:	4631      	mov	r1, r6
			displayValues[3] = rate;
   1cc1a:	edc5 7a03 	vstr	s15, [r5, #12]
			displayValues[6] = knobs[6];
   1cc1e:	61ab      	str	r3, [r5, #24]
			displayValues[4] = roundf(knobs[4]);
   1cc20:	fef8 7a47 	vrinta.f32	s15, s14
			displayValues[5] = knobs[5] * 4000.0f;
   1cc24:	edc5 6a05 	vstr	s13, [r5, #20]
			displayValues[4] = roundf(knobs[4]);
   1cc28:	edc5 7a04 	vstr	s15, [r5, #16]
			if (tSimplePoly_isOn(&poly, i) > 0)
   1cc2c:	f00d fcc2 	bl	2a5b4 <tSimplePoly_isOn>
   1cc30:	2800      	cmp	r0, #0
   1cc32:	ddb5      	ble.n	1cba0 <SFXSamplerKTick+0x30>
				int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
   1cc34:	4631      	mov	r1, r6
   1cc36:	4658      	mov	r0, fp
   1cc38:	f00d fcaa 	bl	2a590 <tSimplePoly_getPitch>
   1cc3c:	f1a0 0a24 	sub.w	sl, r0, #36	; 0x24
				if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
   1cc40:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
   1cc44:	d8ac      	bhi.n	1cba0 <SFXSamplerKTick+0x30>
					tBuffer_tick(&keyBuff[key], input[1]);
   1cc46:	4a7f      	ldr	r2, [pc, #508]	; (1ce44 <SFXSamplerKTick+0x2d4>)
   1cc48:	ea4f 068a 	mov.w	r6, sl, lsl #2
   1cc4c:	9b00      	ldr	r3, [sp, #0]
   1cc4e:	eb02 0806 	add.w	r8, r2, r6
   1cc52:	ed93 0a01 	vldr	s0, [r3, #4]
   1cc56:	4640      	mov	r0, r8
   1cc58:	f00f f84e 	bl	2bcf8 <tBuffer_tick>
					int recordedLength = tBuffer_getRecordedLength(&keyBuff[key]);
   1cc5c:	4640      	mov	r0, r8
   1cc5e:	f00f f891 	bl	2bd84 <tBuffer_getRecordedLength>
					if (knobs[0] != prevKnobs[0])
   1cc62:	edd4 6a96 	vldr	s13, [r4, #600]	; 0x258
					sampleLength = recordedLength * leaf.invSampleRate;
   1cc66:	ee07 0a90 	vmov	s15, r0
					if (knobs[0] != prevKnobs[0])
   1cc6a:	ed99 6a00 	vldr	s12, [r9]
					sampleLength = recordedLength * leaf.invSampleRate;
   1cc6e:	4976      	ldr	r1, [pc, #472]	; (1ce48 <SFXSamplerKTick+0x2d8>)
   1cc70:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1cc74:	4a75      	ldr	r2, [pc, #468]	; (1ce4c <SFXSamplerKTick+0x2dc>)
					if (knobs[0] != prevKnobs[0])
   1cc76:	eef4 6a46 	vcmp.f32	s13, s12
					sampleLength = recordedLength * leaf.invSampleRate;
   1cc7a:	ed91 7a01 	vldr	s14, [r1, #4]
   1cc7e:	ee27 7a27 	vmul.f32	s14, s14, s15
					if (knobs[0] != prevKnobs[0])
   1cc82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
					sampleLength = recordedLength * leaf.invSampleRate;
   1cc86:	ed82 7a00 	vstr	s14, [r2]
						samplePlayStarts[key]= (knobs[0] * recordedLength);
   1cc8a:	4a71      	ldr	r2, [pc, #452]	; (1ce50 <SFXSamplerKTick+0x2e0>)
					if (knobs[0] != prevKnobs[0])
   1cc8c:	f040 80c6 	bne.w	1ce1c <SFXSamplerKTick+0x2ac>
   1cc90:	4432      	add	r2, r6
   1cc92:	edd2 6a00 	vldr	s13, [r2]
					if (knobs[1] != prevKnobs[1])
   1cc96:	ed94 7a97 	vldr	s14, [r4, #604]	; 0x25c
   1cc9a:	ed99 6a01 	vldr	s12, [r9, #4]
						samplePlayLengths[key] = (knobs[1] * recordedLength);
   1cc9e:	4a6d      	ldr	r2, [pc, #436]	; (1ce54 <SFXSamplerKTick+0x2e4>)
					if (knobs[1] != prevKnobs[1])
   1cca0:	eeb4 7a46 	vcmp.f32	s14, s12
   1cca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cca8:	d004      	beq.n	1ccb4 <SFXSamplerKTick+0x144>
						samplePlayLengths[key] = (knobs[1] * recordedLength);
   1ccaa:	ee67 7a87 	vmul.f32	s15, s15, s14
   1ccae:	1991      	adds	r1, r2, r6
   1ccb0:	edc1 7a00 	vstr	s15, [r1]
					if (knobs[2] != prevKnobs[2])
   1ccb4:	ed94 7a98 	vldr	s14, [r4, #608]	; 0x260
   1ccb8:	edd9 7a02 	vldr	s15, [r9, #8]
						sampleRates[key] = displayValues[2];
   1ccbc:	4b66      	ldr	r3, [pc, #408]	; (1ce58 <SFXSamplerKTick+0x2e8>)
					if (knobs[2] != prevKnobs[2])
   1ccbe:	eeb4 7a67 	vcmp.f32	s14, s15
						sampleRates[key] = displayValues[2];
   1ccc2:	9302      	str	r3, [sp, #8]
					if (knobs[2] != prevKnobs[2])
   1ccc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ccc8:	d002      	beq.n	1ccd0 <SFXSamplerKTick+0x160>
						sampleRates[key] = displayValues[2];
   1ccca:	68a8      	ldr	r0, [r5, #8]
   1cccc:	1999      	adds	r1, r3, r6
   1ccce:	6008      	str	r0, [r1, #0]
					if (knobs[3] != prevKnobs[3])
   1ccd0:	ed94 7a99 	vldr	s14, [r4, #612]	; 0x264
   1ccd4:	edd9 7a03 	vldr	s15, [r9, #12]
						sampleRatesMult[key] = displayValues[3];
   1ccd8:	4b60      	ldr	r3, [pc, #384]	; (1ce5c <SFXSamplerKTick+0x2ec>)
					if (knobs[3] != prevKnobs[3])
   1ccda:	eeb4 7a67 	vcmp.f32	s14, s15
   1ccde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cce2:	d002      	beq.n	1ccea <SFXSamplerKTick+0x17a>
						sampleRatesMult[key] = displayValues[3];
   1cce4:	68e8      	ldr	r0, [r5, #12]
   1cce6:	1999      	adds	r1, r3, r6
   1cce8:	6008      	str	r0, [r1, #0]
					if (knobs[4] != prevKnobs[4])
   1ccea:	edd4 7a9a 	vldr	s15, [r4, #616]	; 0x268
   1ccee:	ed99 7a04 	vldr	s14, [r9, #16]
   1ccf2:	eef4 7a47 	vcmp.f32	s15, s14
   1ccf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1ccfa:	f040 81d8 	bne.w	1d0ae <SFXSamplerKTick+0x53e>
   1ccfe:	4958      	ldr	r1, [pc, #352]	; (1ce60 <SFXSamplerKTick+0x2f0>)
   1cd00:	9101      	str	r1, [sp, #4]
					if (knobs[5] != prevKnobs[5])
   1cd02:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
   1cd06:	edd9 7a05 	vldr	s15, [r9, #20]
						crossfadeLengths[key] = displayValues[5];
   1cd0a:	4956      	ldr	r1, [pc, #344]	; (1ce64 <SFXSamplerKTick+0x2f4>)
					if (knobs[5] != prevKnobs[5])
   1cd0c:	eeb4 7a67 	vcmp.f32	s14, s15
						crossfadeLengths[key] = displayValues[5];
   1cd10:	9103      	str	r1, [sp, #12]
					if (knobs[5] != prevKnobs[5])
   1cd12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cd16:	d002      	beq.n	1cd1e <SFXSamplerKTick+0x1ae>
						crossfadeLengths[key] = displayValues[5];
   1cd18:	6968      	ldr	r0, [r5, #20]
   1cd1a:	4431      	add	r1, r6
   1cd1c:	6008      	str	r0, [r1, #0]
					tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
   1cd1e:	4852      	ldr	r0, [pc, #328]	; (1ce68 <SFXSamplerKTick+0x2f8>)
   1cd20:	eefd 7ae6 	vcvt.s32.f32	s15, s13
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1cd24:	3701      	adds	r7, #1
					tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
   1cd26:	eb00 0806 	add.w	r8, r0, r6
   1cd2a:	ee17 1a90 	vmov	r1, s15
   1cd2e:	4640      	mov	r0, r8
   1cd30:	e9cd 3204 	strd	r3, r2, [sp, #16]
   1cd34:	f00f f950 	bl	2bfd8 <tSampler_setStart>
					tSampler_setLength(&keySampler[key], samplePlayLengths[key]);
   1cd38:	9a05      	ldr	r2, [sp, #20]
   1cd3a:	4640      	mov	r0, r8
   1cd3c:	4432      	add	r2, r6
   1cd3e:	edd2 7a00 	vldr	s15, [r2]
   1cd42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1cd46:	ee17 1a90 	vmov	r1, s15
   1cd4a:	f00f fd53 	bl	2c7f4 <tSampler_setLength>
					tSampler_setCrossfadeLength(&keySampler[key], crossfadeLengths[key]);
   1cd4e:	9b03      	ldr	r3, [sp, #12]
   1cd50:	4640      	mov	r0, r8
   1cd52:	4433      	add	r3, r6
   1cd54:	edd3 7a00 	vldr	s15, [r3]
   1cd58:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1cd5c:	ee17 1a90 	vmov	r1, s15
   1cd60:	f00f f8c8 	bl	2bef4 <tSampler_setCrossfadeLength>
					tSampler_setRate(&keySampler[key], sampleRates[key] * sampleRatesMult[key]);
   1cd64:	9b02      	ldr	r3, [sp, #8]
   1cd66:	4640      	mov	r0, r8
   1cd68:	4433      	add	r3, r6
   1cd6a:	461a      	mov	r2, r3
   1cd6c:	9b04      	ldr	r3, [sp, #16]
   1cd6e:	441e      	add	r6, r3
   1cd70:	ed92 0a00 	vldr	s0, [r2]
   1cd74:	edd6 7a00 	vldr	s15, [r6]
   1cd78:	ee20 0a27 	vmul.f32	s0, s0, s15
   1cd7c:	f00f fdd4 	bl	2c928 <tSampler_setRate>
					tSampler_setMode(&keySampler[key], loopOns[key]);
   1cd80:	9b01      	ldr	r3, [sp, #4]
   1cd82:	4640      	mov	r0, r8
   1cd84:	f813 102a 	ldrb.w	r1, [r3, sl, lsl #2]
   1cd88:	f00f f8b0 	bl	2beec <tSampler_setMode>
		for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
   1cd8c:	2f06      	cmp	r7, #6
   1cd8e:	f47f af0b 	bne.w	1cba8 <SFXSamplerKTick+0x38>
   1cd92:	f8dd a000 	ldr.w	sl, [sp]
   1cd96:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 1ce7c <SFXSamplerKTick+0x30c>
   1cd9a:	2400      	movs	r4, #0
   1cd9c:	4f33      	ldr	r7, [pc, #204]	; (1ce6c <SFXSamplerKTick+0x2fc>)
	float sample = 0.0f;
   1cd9e:	ed9f 9a27 	vldr	s18, [pc, #156]	; 1ce3c <SFXSamplerKTick+0x2cc>
		if ( tempGain > 0.0001f)
   1cda2:	eddf 8a33 	vldr	s17, [pc, #204]	; 1ce70 <SFXSamplerKTick+0x300>
   1cda6:	4d33      	ldr	r5, [pc, #204]	; (1ce74 <SFXSamplerKTick+0x304>)
			sample += tSampler_tick(&keySampler[i]) * tempGain;
   1cda8:	4e2f      	ldr	r6, [pc, #188]	; (1ce68 <SFXSamplerKTick+0x2f8>)
   1cdaa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1cdae:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   1cdb0:	e89c 0003 	ldmia.w	ip, {r0, r1}
   1cdb4:	e887 0003 	stmia.w	r7, {r0, r1}
   1cdb8:	e002      	b.n	1cdc0 <SFXSamplerKTick+0x250>
   1cdba:	3404      	adds	r4, #4
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1cdbc:	2cc4      	cmp	r4, #196	; 0xc4
   1cdbe:	d011      	beq.n	1cde4 <SFXSamplerKTick+0x274>
		float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
   1cdc0:	1928      	adds	r0, r5, r4
   1cdc2:	f00b f8d7 	bl	27f74 <tExpSmooth_tick>
		if ( tempGain > 0.0001f)
   1cdc6:	eeb4 0ae8 	vcmpe.f32	s0, s17
		float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
   1cdca:	eeb0 8a40 	vmov.f32	s16, s0
		if ( tempGain > 0.0001f)
   1cdce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cdd2:	ddf2      	ble.n	1cdba <SFXSamplerKTick+0x24a>
			sample += tSampler_tick(&keySampler[i]) * tempGain;
   1cdd4:	1930      	adds	r0, r6, r4
   1cdd6:	3404      	adds	r4, #4
   1cdd8:	f00f fa2a 	bl	2c230 <tSampler_tick>
   1cddc:	eea0 9a08 	vfma.f32	s18, s0, s16
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1cde0:	2cc4      	cmp	r4, #196	; 0xc4
   1cde2:	d1ed      	bne.n	1cdc0 <SFXSamplerKTick+0x250>
	sample = tanhf(sample) * 0.98;
   1cde4:	eeb0 0a49 	vmov.f32	s0, s18
   1cde8:	f010 fa68 	bl	2d2bc <tanhf>
   1cdec:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
   1cdf0:	ed9f 7b0d 	vldr	d7, [pc, #52]	; 1ce28 <SFXSamplerKTick+0x2b8>
   1cdf4:	ee20 0b07 	vmul.f64	d0, d0, d7
   1cdf8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
	input[0] = sample;
   1cdfc:	ed8a 0a00 	vstr	s0, [sl]
	input[1] = sample;
   1ce00:	ed8a 0a01 	vstr	s0, [sl, #4]
}
   1ce04:	b007      	add	sp, #28
   1ce06:	ecbd 8b04 	vpop	{d8-d9}
   1ce0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				(rate = 1.0f / fabsf(rate-1.0f));
   1ce0e:	ee77 7ac9 	vsub.f32	s15, s15, s18
   1ce12:	eeb0 7ae7 	vabs.f32	s14, s15
   1ce16:	eec9 7a07 	vdiv.f32	s15, s18, s14
   1ce1a:	e6f3      	b.n	1cc04 <SFXSamplerKTick+0x94>
						samplePlayStarts[key]= (knobs[0] * recordedLength);
   1ce1c:	ee67 6aa6 	vmul.f32	s13, s15, s13
   1ce20:	4432      	add	r2, r6
   1ce22:	edc2 6a00 	vstr	s13, [r2]
   1ce26:	e736      	b.n	1cc96 <SFXSamplerKTick+0x126>
   1ce28:	f5c28f5c 	.word	0xf5c28f5c
   1ce2c:	3fef5c28 	.word	0x3fef5c28
   1ce30:	020e3168 	.word	0x020e3168
   1ce34:	020f9318 	.word	0x020f9318
   1ce38:	020fb3cc 	.word	0x020fb3cc
   1ce3c:	00000000 	.word	0x00000000
   1ce40:	457a0000 	.word	0x457a0000
   1ce44:	020fada0 	.word	0x020fada0
   1ce48:	020fc0a8 	.word	0x020fc0a8
   1ce4c:	020e3204 	.word	0x020e3204
   1ce50:	020f9f84 	.word	0x020f9f84
   1ce54:	020f8e88 	.word	0x020f8e88
   1ce58:	020f8f70 	.word	0x020f8f70
   1ce5c:	020fa48c 	.word	0x020fa48c
   1ce60:	020f9254 	.word	0x020f9254
   1ce64:	020fa3c4 	.word	0x020fa3c4
   1ce68:	020f9b34 	.word	0x020f9b34
   1ce6c:	020fad88 	.word	0x020fad88
   1ce70:	38d1b717 	.word	0x38d1b717
   1ce74:	020f8c94 	.word	0x020f8c94
   1ce78:	020fa15c 	.word	0x020fa15c
   1ce7c:	020f9570 	.word	0x020f9570
	int currentSamplerKey = currentSamplerKeyGlobal;
   1ce80:	4b9b      	ldr	r3, [pc, #620]	; (1d0f0 <SFXSamplerKTick+0x580>)
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1ce82:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
		int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1ce86:	489b      	ldr	r0, [pc, #620]	; (1d0f4 <SFXSamplerKTick+0x584>)
	int currentSamplerKey = currentSamplerKeyGlobal;
   1ce88:	681f      	ldr	r7, [r3, #0]
		displayValues[0] = knobs[0] * sampleLength;
   1ce8a:	4c9b      	ldr	r4, [pc, #620]	; (1d0f8 <SFXSamplerKTick+0x588>)
   1ce8c:	00be      	lsls	r6, r7, #2
   1ce8e:	4d9b      	ldr	r5, [pc, #620]	; (1d0fc <SFXSamplerKTick+0x58c>)
		int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
   1ce90:	4430      	add	r0, r6
   1ce92:	f00e ff77 	bl	2bd84 <tBuffer_getRecordedLength>
		sampleLength = recordedLength * leaf.invSampleRate;
   1ce96:	ee07 0a90 	vmov	s15, r0
   1ce9a:	4b99      	ldr	r3, [pc, #612]	; (1d100 <SFXSamplerKTick+0x590>)
   1ce9c:	eef8 8ae7 	vcvt.f32.s32	s17, s15
		displayValues[0] = knobs[0] * sampleLength;
   1cea0:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
		sampleLength = recordedLength * leaf.invSampleRate;
   1cea4:	edd3 7a01 	vldr	s15, [r3, #4]
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1cea8:	ee38 1a47 	vsub.f32	s2, s16, s14
   1ceac:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
		sampleLength = recordedLength * leaf.invSampleRate;
   1ceb0:	ee68 7aa7 	vmul.f32	s15, s17, s15
   1ceb4:	4b93      	ldr	r3, [pc, #588]	; (1d104 <SFXSamplerKTick+0x594>)
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1ceb6:	ed9f 0a94 	vldr	s0, [pc, #592]	; 1d108 <SFXSamplerKTick+0x598>
		displayValues[0] = knobs[0] * sampleLength;
   1ceba:	ee27 7a87 	vmul.f32	s14, s15, s14
		sampleLength = recordedLength * leaf.invSampleRate;
   1cebe:	edc3 7a00 	vstr	s15, [r3]
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1cec2:	ee21 1a27 	vmul.f32	s2, s2, s15
   1cec6:	ee67 0aa0 	vmul.f32	s1, s15, s1
		displayValues[0] = knobs[0] * sampleLength;
   1ceca:	ed85 7a00 	vstr	s14, [r5]
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1cece:	f00c fcdb 	bl	29888 <LEAF_clip>
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ced2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   1ced6:	ed94 6a98 	vldr	s12, [r4, #608]	; 0x260
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1ceda:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
   1cede:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cee2:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
		displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
   1cee6:	ed85 0a01 	vstr	s0, [r5, #4]
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1ceea:	ee76 4a67 	vsub.f32	s9, s12, s15
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1ceee:	ee76 7ae7 	vsub.f32	s15, s13, s15
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cef2:	ee64 4aa5 	vmul.f32	s9, s9, s11
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cef6:	ee67 7a87 	vmul.f32	s15, s15, s14
		displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
   1cefa:	edc5 4a02 	vstr	s9, [r5, #8]
		float rate = roundf((knobs[3] - 0.5f) * 14.0f);
   1cefe:	fef8 7a67 	vrinta.f32	s15, s15
		if (rate < 0.0f)
   1cf02:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   1cf06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cf0a:	f100 80e9 	bmi.w	1d0e0 <SFXSamplerKTick+0x570>
			rate += 1.0f;
   1cf0e:	ee77 3a88 	vadd.f32	s7, s15, s16
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1cf12:	f8df 9218 	ldr.w	r9, [pc, #536]	; 1d12c <SFXSamplerKTick+0x5bc>
   1cf16:	ed94 5a96 	vldr	s10, [r4, #600]	; 0x258
   1cf1a:	edd9 5a00 	vldr	s11, [r9]
   1cf1e:	ed9f 3a7b 	vldr	s6, [pc, #492]	; 1d10c <SFXSamplerKTick+0x59c>
   1cf22:	ee75 5a65 	vsub.f32	s11, s10, s11
		displayValues[5] = knobs[5] * 4000.0f;
   1cf26:	edd4 7a9b 	vldr	s15, [r4, #620]	; 0x26c
   1cf2a:	eddf 2a79 	vldr	s5, [pc, #484]	; 1d110 <SFXSamplerKTick+0x5a0>
		displayValues[6] = knobs[6];
   1cf2e:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1cf32:	eef0 5ae5 	vabs.f32	s11, s11
		displayValues[4] = roundf(knobs[4]);
   1cf36:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
		displayValues[5] = knobs[5] * 4000.0f;
   1cf3a:	ee67 2aa2 	vmul.f32	s5, s15, s5
		displayValues[6] = knobs[6];
   1cf3e:	61ab      	str	r3, [r5, #24]
		displayValues[4] = roundf(knobs[4]);
   1cf40:	feb8 4a47 	vrinta.f32	s8, s14
		displayValues[3] = rate;
   1cf44:	edc5 3a03 	vstr	s7, [r5, #12]
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1cf48:	eef4 5ac3 	vcmpe.f32	s11, s6
		displayValues[4] = roundf(knobs[4]);
   1cf4c:	ed85 4a04 	vstr	s8, [r5, #16]
		displayValues[5] = knobs[5] * 4000.0f;
   1cf50:	edc5 2a05 	vstr	s5, [r5, #20]
			samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
   1cf54:	4b6f      	ldr	r3, [pc, #444]	; (1d114 <SFXSamplerKTick+0x5a4>)
		if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
   1cf56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cf5a:	f300 80b3 	bgt.w	1d0c4 <SFXSamplerKTick+0x554>
   1cf5e:	4433      	add	r3, r6
   1cf60:	ed93 5a00 	vldr	s10, [r3]
		if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
   1cf64:	ed94 3a97 	vldr	s6, [r4, #604]	; 0x25c
   1cf68:	edd9 5a01 	vldr	s11, [r9, #4]
   1cf6c:	ed9f 2a67 	vldr	s4, [pc, #412]	; 1d10c <SFXSamplerKTick+0x59c>
   1cf70:	ee73 5a65 	vsub.f32	s11, s6, s11
			samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
   1cf74:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 1d130 <SFXSamplerKTick+0x5c0>
		if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
   1cf78:	eef0 5ae5 	vabs.f32	s11, s11
   1cf7c:	eef4 5ac2 	vcmpe.f32	s11, s4
   1cf80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cf84:	dd05      	ble.n	1cf92 <SFXSamplerKTick+0x422>
			samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
   1cf86:	ee68 5a83 	vmul.f32	s11, s17, s6
   1cf8a:	eb0b 0306 	add.w	r3, fp, r6
   1cf8e:	edc3 5a00 	vstr	s11, [r3]
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1cf92:	ed99 3a02 	vldr	s6, [r9, #8]
   1cf96:	eddf 5a5d 	vldr	s11, [pc, #372]	; 1d10c <SFXSamplerKTick+0x59c>
   1cf9a:	ee36 6a43 	vsub.f32	s12, s12, s6
			sampleRates[currentSamplerKey] = displayValues[2];
   1cf9e:	4b5e      	ldr	r3, [pc, #376]	; (1d118 <SFXSamplerKTick+0x5a8>)
   1cfa0:	9301      	str	r3, [sp, #4]
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1cfa2:	eeb0 6ac6 	vabs.f32	s12, s12
   1cfa6:	eeb4 6ae5 	vcmpe.f32	s12, s11
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cfaa:	edd9 5a03 	vldr	s11, [r9, #12]
   1cfae:	ed9f 6a57 	vldr	s12, [pc, #348]	; 1d10c <SFXSamplerKTick+0x59c>
   1cfb2:	ee76 6ae5 	vsub.f32	s13, s13, s11
		if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
   1cfb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cfba:	eef0 6ae6 	vabs.f32	s13, s13
			sampleRates[currentSamplerKey] = displayValues[2];
   1cfbe:	bfc8      	it	gt
   1cfc0:	199b      	addgt	r3, r3, r6
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cfc2:	eef4 6ac6 	vcmpe.f32	s13, s12
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cfc6:	ed99 6a04 	vldr	s12, [r9, #16]
			sampleRates[currentSamplerKey] = displayValues[2];
   1cfca:	bfc8      	it	gt
   1cfcc:	edc3 4a00 	vstrgt	s9, [r3]
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cfd0:	ee37 7a46 	vsub.f32	s14, s14, s12
   1cfd4:	eddf 6a4d 	vldr	s13, [pc, #308]	; 1d10c <SFXSamplerKTick+0x59c>
		if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
   1cfd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			sampleRatesMult[currentSamplerKey] = displayValues[3];
   1cfdc:	4b4f      	ldr	r3, [pc, #316]	; (1d11c <SFXSamplerKTick+0x5ac>)
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cfde:	eeb0 7ac7 	vabs.f32	s14, s14
			sampleRatesMult[currentSamplerKey] = displayValues[3];
   1cfe2:	9300      	str	r3, [sp, #0]
   1cfe4:	bfc8      	it	gt
   1cfe6:	199b      	addgt	r3, r3, r6
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cfe8:	eeb4 7ae6 	vcmpe.f32	s14, s13
			sampleRatesMult[currentSamplerKey] = displayValues[3];
   1cfec:	bfc8      	it	gt
   1cfee:	edc3 3a00 	vstrgt	s7, [r3]
		if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
   1cff2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1cff6:	dc6b      	bgt.n	1d0d0 <SFXSamplerKTick+0x560>
   1cff8:	4a49      	ldr	r2, [pc, #292]	; (1d120 <SFXSamplerKTick+0x5b0>)
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1cffa:	edd9 6a05 	vldr	s13, [r9, #20]
		tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
   1cffe:	44b3      	add	fp, r6
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1d000:	ed9f 7a42 	vldr	s14, [pc, #264]	; 1d10c <SFXSamplerKTick+0x59c>
   1d004:	ee77 7ae6 	vsub.f32	s15, s15, s13
			crossfadeLengths[currentSamplerKey] = displayValues[5];
   1d008:	f8df 9128 	ldr.w	r9, [pc, #296]	; 1d134 <SFXSamplerKTick+0x5c4>
		tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1d00c:	4845      	ldr	r0, [pc, #276]	; (1d124 <SFXSamplerKTick+0x5b4>)
   1d00e:	9202      	str	r2, [sp, #8]
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1d010:	eef0 7ae7 	vabs.f32	s15, s15
		tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1d014:	eb00 0806 	add.w	r8, r0, r6
   1d018:	4c43      	ldr	r4, [pc, #268]	; (1d128 <SFXSamplerKTick+0x5b8>)
   1d01a:	4640      	mov	r0, r8
   1d01c:	4d35      	ldr	r5, [pc, #212]	; (1d0f4 <SFXSamplerKTick+0x584>)
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1d01e:	eef4 7ac7 	vcmpe.f32	s15, s14
		tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1d022:	eefd 7ac5 	vcvt.s32.f32	s15, s10
		if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
   1d026:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			crossfadeLengths[currentSamplerKey] = displayValues[5];
   1d02a:	bfc4      	itt	gt
   1d02c:	eb09 0106 	addgt.w	r1, r9, r6
   1d030:	edc1 2a00 	vstrgt	s5, [r1]
		tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
   1d034:	ee17 1a90 	vmov	r1, s15
   1d038:	f00e ffce 	bl	2bfd8 <tSampler_setStart>
		tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
   1d03c:	eddb 7a00 	vldr	s15, [fp]
   1d040:	4640      	mov	r0, r8
   1d042:	f104 0b31 	add.w	fp, r4, #49	; 0x31
   1d046:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d04a:	ee17 1a90 	vmov	r1, s15
   1d04e:	f00f fbd1 	bl	2c7f4 <tSampler_setLength>
		tSampler_setCrossfadeLength(&keySampler[currentSamplerKey], crossfadeLengths[currentSamplerKey]);
   1d052:	eb09 0306 	add.w	r3, r9, r6
   1d056:	4640      	mov	r0, r8
   1d058:	edd3 7a00 	vldr	s15, [r3]
   1d05c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1d060:	ee17 1a90 	vmov	r1, s15
   1d064:	f00e ff46 	bl	2bef4 <tSampler_setCrossfadeLength>
		tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
   1d068:	9b01      	ldr	r3, [sp, #4]
   1d06a:	9a00      	ldr	r2, [sp, #0]
   1d06c:	4640      	mov	r0, r8
   1d06e:	4433      	add	r3, r6
   1d070:	4432      	add	r2, r6
   1d072:	ed93 0a00 	vldr	s0, [r3]
   1d076:	edd2 7a00 	vldr	s15, [r2]
   1d07a:	ee20 0a27 	vmul.f32	s0, s0, s15
   1d07e:	f00f fc53 	bl	2c928 <tSampler_setRate>
		tSampler_setMode(&keySampler[currentSamplerKey], loopOns[currentSamplerKey]);
   1d082:	9a02      	ldr	r2, [sp, #8]
   1d084:	4640      	mov	r0, r8
   1d086:	f812 1027 	ldrb.w	r1, [r2, r7, lsl #2]
   1d08a:	f00e ff2f 	bl	2beec <tSampler_setMode>
   1d08e:	e004      	b.n	1d09a <SFXSamplerKTick+0x52a>
		for (int i = 0; i < NUM_SAMPLER_KEYS; ++i)
   1d090:	45a3      	cmp	fp, r4
   1d092:	f105 0504 	add.w	r5, r5, #4
   1d096:	f43f ae7e 	beq.w	1cd96 <SFXSamplerKTick+0x226>
			if (samplerKeyHeld[i] > 0)
   1d09a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   1d09e:	2b00      	cmp	r3, #0
   1d0a0:	d0f6      	beq.n	1d090 <SFXSamplerKTick+0x520>
				tBuffer_tick(&keyBuff[i], input[1]);
   1d0a2:	ed9a 0a01 	vldr	s0, [sl, #4]
   1d0a6:	4628      	mov	r0, r5
   1d0a8:	f00e fe26 	bl	2bcf8 <tBuffer_tick>
   1d0ac:	e7f0      	b.n	1d090 <SFXSamplerKTick+0x520>
						loopOns[key] = roundf(knobs[4]);
   1d0ae:	fef8 7a67 	vrinta.f32	s15, s15
   1d0b2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d0b6:	491a      	ldr	r1, [pc, #104]	; (1d120 <SFXSamplerKTick+0x5b0>)
   1d0b8:	ee17 0a90 	vmov	r0, s15
   1d0bc:	9101      	str	r1, [sp, #4]
   1d0be:	f841 002a 	str.w	r0, [r1, sl, lsl #2]
   1d0c2:	e61e      	b.n	1cd02 <SFXSamplerKTick+0x192>
			samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
   1d0c4:	ee28 5a85 	vmul.f32	s10, s17, s10
   1d0c8:	4433      	add	r3, r6
   1d0ca:	ed83 5a00 	vstr	s10, [r3]
   1d0ce:	e749      	b.n	1cf64 <SFXSamplerKTick+0x3f4>
			loopOns[currentSamplerKey] = roundf(knobs[4]);
   1d0d0:	eebd 4ac4 	vcvt.s32.f32	s8, s8
   1d0d4:	4a12      	ldr	r2, [pc, #72]	; (1d120 <SFXSamplerKTick+0x5b0>)
   1d0d6:	ee14 3a10 	vmov	r3, s8
   1d0da:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   1d0de:	e78c      	b.n	1cffa <SFXSamplerKTick+0x48a>
			(rate = 1.0f / fabsf(rate-1.0f));
   1d0e0:	ee77 7ac8 	vsub.f32	s15, s15, s16
   1d0e4:	eef0 7ae7 	vabs.f32	s15, s15
   1d0e8:	eec8 3a27 	vdiv.f32	s7, s16, s15
   1d0ec:	e711      	b.n	1cf12 <SFXSamplerKTick+0x3a2>
   1d0ee:	bf00      	nop
   1d0f0:	00062ab4 	.word	0x00062ab4
   1d0f4:	020fada0 	.word	0x020fada0
   1d0f8:	020f9318 	.word	0x020f9318
   1d0fc:	020fb3cc 	.word	0x020fb3cc
   1d100:	020fc0a8 	.word	0x020fc0a8
   1d104:	020e3204 	.word	0x020e3204
   1d108:	00000000 	.word	0x00000000
   1d10c:	38d1b717 	.word	0x38d1b717
   1d110:	457a0000 	.word	0x457a0000
   1d114:	020f9f84 	.word	0x020f9f84
   1d118:	020f8f70 	.word	0x020f8f70
   1d11c:	020fa48c 	.word	0x020fa48c
   1d120:	020f9254 	.word	0x020f9254
   1d124:	020f9b34 	.word	0x020f9b34
   1d128:	020fa373 	.word	0x020fa373
   1d12c:	020fad88 	.word	0x020fad88
   1d130:	020f8e88 	.word	0x020f8e88
   1d134:	020fa3c4 	.word	0x020fa3c4

0001d138 <SFXSamplerKFree>:
{
   1d138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d13a:	2400      	movs	r4, #0
   1d13c:	4f07      	ldr	r7, [pc, #28]	; (1d15c <SFXSamplerKFree+0x24>)
   1d13e:	4e08      	ldr	r6, [pc, #32]	; (1d160 <SFXSamplerKFree+0x28>)
   1d140:	4d08      	ldr	r5, [pc, #32]	; (1d164 <SFXSamplerKFree+0x2c>)
		tBuffer_free(&keyBuff[i]);
   1d142:	1938      	adds	r0, r7, r4
   1d144:	f00e fdcc 	bl	2bce0 <tBuffer_free>
		tSampler_free(&keySampler[i]);
   1d148:	1930      	adds	r0, r6, r4
   1d14a:	f00e fec3 	bl	2bed4 <tSampler_free>
		tExpSmooth_free(&kSamplerGains[i]);
   1d14e:	1928      	adds	r0, r5, r4
   1d150:	3404      	adds	r4, #4
   1d152:	f00a feef 	bl	27f34 <tExpSmooth_free>
	for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
   1d156:	2cc4      	cmp	r4, #196	; 0xc4
   1d158:	d1f3      	bne.n	1d142 <SFXSamplerKFree+0xa>
}
   1d15a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d15c:	020fada0 	.word	0x020fada0
   1d160:	020f9b34 	.word	0x020f9b34
   1d164:	020f8c94 	.word	0x020f8c94

0001d168 <SFXSamplerAutoAlloc>:
{
   1d168:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1d16c:	4d36      	ldr	r5, [pc, #216]	; (1d248 <SFXSamplerAutoAlloc+0xe0>)
   1d16e:	f8df 8120 	ldr.w	r8, [pc, #288]	; 1d290 <SFXSamplerAutoAlloc+0x128>
   1d172:	4f36      	ldr	r7, [pc, #216]	; (1d24c <SFXSamplerAutoAlloc+0xe4>)
	tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1d174:	1d2e      	adds	r6, r5, #4
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1d176:	4642      	mov	r2, r8
   1d178:	4628      	mov	r0, r5
   1d17a:	4639      	mov	r1, r7
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d17c:	4c34      	ldr	r4, [pc, #208]	; (1d250 <SFXSamplerAutoAlloc+0xe8>)
	tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
   1d17e:	f00e fd97 	bl	2bcb0 <tBuffer_initToPool>
	tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
   1d182:	4628      	mov	r0, r5
   1d184:	2100      	movs	r1, #0
   1d186:	f00e fdf9 	bl	2bd7c <tBuffer_setRecordMode>
	tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1d18a:	4642      	mov	r2, r8
   1d18c:	4639      	mov	r1, r7
   1d18e:	4630      	mov	r0, r6
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d190:	4f30      	ldr	r7, [pc, #192]	; (1d254 <SFXSamplerAutoAlloc+0xec>)
	tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
   1d192:	f00e fd8d 	bl	2bcb0 <tBuffer_initToPool>
	tBuffer_setRecordMode(&asBuff[1], RecordOneShot);
   1d196:	4630      	mov	r0, r6
   1d198:	2100      	movs	r1, #0
   1d19a:	f00e fdef 	bl	2bd7c <tBuffer_setRecordMode>
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d19e:	4622      	mov	r2, r4
   1d1a0:	4629      	mov	r1, r5
   1d1a2:	4638      	mov	r0, r7
	tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
   1d1a4:	1d3d      	adds	r5, r7, #4
	tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
   1d1a6:	f00e fe49 	bl	2be3c <tSampler_initToPool>
	tSampler_setMode(&asSampler[0], PlayLoop);
   1d1aa:	4638      	mov	r0, r7
   1d1ac:	2101      	movs	r1, #1
   1d1ae:	f00e fe9d 	bl	2beec <tSampler_setMode>
	tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
   1d1b2:	4622      	mov	r2, r4
   1d1b4:	4631      	mov	r1, r6
   1d1b6:	4628      	mov	r0, r5
   1d1b8:	f00e fe40 	bl	2be3c <tSampler_initToPool>
	tSampler_setMode(&asSampler[1], PlayLoop);
   1d1bc:	4628      	mov	r0, r5
   1d1be:	2101      	movs	r1, #1
   1d1c0:	f00e fe94 	bl	2beec <tSampler_setMode>
	tEnvelopeFollower_initToPool(&envfollow, 0.00001f, 0.9999f, &smallPool);
   1d1c4:	4621      	mov	r1, r4
   1d1c6:	eddf 0a24 	vldr	s1, [pc, #144]	; 1d258 <SFXSamplerAutoAlloc+0xf0>
   1d1ca:	ed9f 0a24 	vldr	s0, [pc, #144]	; 1d25c <SFXSamplerAutoAlloc+0xf4>
   1d1ce:	4824      	ldr	r0, [pc, #144]	; (1d260 <SFXSamplerAutoAlloc+0xf8>)
   1d1d0:	f007 f86c 	bl	242ac <tEnvelopeFollower_initToPool>
	tExpSmooth_initToPool(&cfxSmooth, 0.0f, 0.01f, &smallPool);
   1d1d4:	4621      	mov	r1, r4
   1d1d6:	eddf 0a23 	vldr	s1, [pc, #140]	; 1d264 <SFXSamplerAutoAlloc+0xfc>
   1d1da:	ed9f 0a23 	vldr	s0, [pc, #140]	; 1d268 <SFXSamplerAutoAlloc+0x100>
   1d1de:	4823      	ldr	r0, [pc, #140]	; (1d26c <SFXSamplerAutoAlloc+0x104>)
   1d1e0:	f00a fe82 	bl	27ee8 <tExpSmooth_initToPool>
	setLED_A(samplerMode == PlayBackAndForth);
   1d1e4:	4b22      	ldr	r3, [pc, #136]	; (1d270 <SFXSamplerAutoAlloc+0x108>)
   1d1e6:	7818      	ldrb	r0, [r3, #0]
   1d1e8:	f1a0 0002 	sub.w	r0, r0, #2
   1d1ec:	fab0 f080 	clz	r0, r0
   1d1f0:	0940      	lsrs	r0, r0, #5
   1d1f2:	f7fc f9a3 	bl	1953c <setLED_A>
	setLED_B(triggerChannel);
   1d1f6:	4b1f      	ldr	r3, [pc, #124]	; (1d274 <SFXSamplerAutoAlloc+0x10c>)
   1d1f8:	7818      	ldrb	r0, [r3, #0]
   1d1fa:	f7fc f9ad 	bl	19558 <setLED_B>
	currentSampler = 1;
   1d1fe:	2001      	movs	r0, #1
	sample_countdown = 0;
   1d200:	2200      	movs	r2, #0
	currentSampler = 1;
   1d202:	491d      	ldr	r1, [pc, #116]	; (1d278 <SFXSamplerAutoAlloc+0x110>)
	sample_countdown = 0;
   1d204:	4b1d      	ldr	r3, [pc, #116]	; (1d27c <SFXSamplerAutoAlloc+0x114>)
	currentSampler = 1;
   1d206:	7008      	strb	r0, [r1, #0]
	sample_countdown = 0;
   1d208:	601a      	str	r2, [r3, #0]
	randLengthVal = randomNumber() * 10000.0f;
   1d20a:	f7fc f8c3 	bl	19394 <randomNumber>
   1d20e:	eddf 7a1c 	vldr	s15, [pc, #112]	; 1d280 <SFXSamplerAutoAlloc+0x118>
   1d212:	4b1c      	ldr	r3, [pc, #112]	; (1d284 <SFXSamplerAutoAlloc+0x11c>)
   1d214:	ee20 0a27 	vmul.f32	s0, s0, s15
   1d218:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   1d21c:	ed83 0a00 	vstr	s0, [r3]
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1d220:	f7fc f8b8 	bl	19394 <randomNumber>
   1d224:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	setLED_C(pitchQuantization);
   1d228:	4a17      	ldr	r2, [pc, #92]	; (1d288 <SFXSamplerAutoAlloc+0x120>)
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1d22a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   1d22e:	4b17      	ldr	r3, [pc, #92]	; (1d28c <SFXSamplerAutoAlloc+0x124>)
	setLED_C(pitchQuantization);
   1d230:	7810      	ldrb	r0, [r2, #0]
	randRateVal = (randomNumber() - 0.5f) * 4.0f;
   1d232:	ee30 0a67 	vsub.f32	s0, s0, s15
   1d236:	ee20 0a07 	vmul.f32	s0, s0, s14
   1d23a:	ed83 0a00 	vstr	s0, [r3]
}
   1d23e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	setLED_C(pitchQuantization);
   1d242:	f7fc b997 	b.w	19574 <setLED_C>
   1d246:	bf00      	nop
   1d248:	020fa140 	.word	0x020fa140
   1d24c:	0002ee00 	.word	0x0002ee00
   1d250:	020f7730 	.word	0x020f7730
   1d254:	020fa3b0 	.word	0x020fa3b0
   1d258:	3f7ff972 	.word	0x3f7ff972
   1d25c:	3727c5ac 	.word	0x3727c5ac
   1d260:	020fafa0 	.word	0x020fafa0
   1d264:	3c23d70a 	.word	0x3c23d70a
   1d268:	00000000 	.word	0x00000000
   1d26c:	020f9e98 	.word	0x020f9e98
   1d270:	00062b39 	.word	0x00062b39
   1d274:	020e3215 	.word	0x020e3215
   1d278:	020e317c 	.word	0x020e317c
   1d27c:	020e3210 	.word	0x020e3210
   1d280:	461c4000 	.word	0x461c4000
   1d284:	020e31f4 	.word	0x020e31f4
   1d288:	020e31e4 	.word	0x020e31e4
   1d28c:	020e31f8 	.word	0x020e31f8
   1d290:	020f6e58 	.word	0x020f6e58

0001d294 <SFXSamplerAutoFrame>:
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1d294:	4b07      	ldr	r3, [pc, #28]	; (1d2b4 <SFXSamplerAutoFrame+0x20>)
   1d296:	7f1a      	ldrb	r2, [r3, #28]
   1d298:	2a01      	cmp	r2, #1
   1d29a:	d000      	beq.n	1d29e <SFXSamplerAutoFrame+0xa>
}
   1d29c:	4770      	bx	lr
		pitchQuantization = !pitchQuantization;
   1d29e:	4906      	ldr	r1, [pc, #24]	; (1d2b8 <SFXSamplerAutoFrame+0x24>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1d2a0:	2000      	movs	r0, #0
		pitchQuantization = !pitchQuantization;
   1d2a2:	680a      	ldr	r2, [r1, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1d2a4:	7718      	strb	r0, [r3, #28]
		pitchQuantization = !pitchQuantization;
   1d2a6:	fab2 f282 	clz	r2, r2
   1d2aa:	0952      	lsrs	r2, r2, #5
		setLED_C(pitchQuantization);
   1d2ac:	4610      	mov	r0, r2
		pitchQuantization = !pitchQuantization;
   1d2ae:	600a      	str	r2, [r1, #0]
		setLED_C(pitchQuantization);
   1d2b0:	f7fc b960 	b.w	19574 <setLED_C>
   1d2b4:	020fb31c 	.word	0x020fb31c
   1d2b8:	020e31e4 	.word	0x020e31e4
   1d2bc:	00000000 	.word	0x00000000

0001d2c0 <SFXSamplerAutoTick>:
{
   1d2c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (triggerChannel > 0)
   1d2c4:	f8df 935c 	ldr.w	r9, [pc, #860]	; 1d624 <SFXSamplerAutoTick+0x364>
{
   1d2c8:	4604      	mov	r4, r0
	if (triggerChannel > 0)
   1d2ca:	f899 3000 	ldrb.w	r3, [r9]
{
   1d2ce:	ed2d 8b06 	vpush	{d8-d10}
   1d2d2:	b089      	sub	sp, #36	; 0x24
	if (triggerChannel > 0)
   1d2d4:	2b00      	cmp	r3, #0
   1d2d6:	d072      	beq.n	1d3be <SFXSamplerAutoTick+0xfe>
		currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
   1d2d8:	4db9      	ldr	r5, [pc, #740]	; (1d5c0 <SFXSamplerAutoTick+0x300>)
   1d2da:	ed90 0a00 	vldr	s0, [r0]
   1d2de:	48b9      	ldr	r0, [pc, #740]	; (1d5c4 <SFXSamplerAutoTick+0x304>)
   1d2e0:	f007 f800 	bl	242e4 <tEnvelopeFollower_tick>
   1d2e4:	ed85 0a00 	vstr	s0, [r5]
	samp_thresh = 1.0f - knobs[0];
   1d2e8:	4ab7      	ldr	r2, [pc, #732]	; (1d5c8 <SFXSamplerAutoTick+0x308>)
   1d2ea:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d2ee:	4bb7      	ldr	r3, [pc, #732]	; (1d5cc <SFXSamplerAutoTick+0x30c>)
   1d2f0:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
   1d2f4:	edd2 6ab0 	vldr	s13, [r2, #704]	; 0x2c0
   1d2f8:	edd3 7a00 	vldr	s15, [r3]
   1d2fc:	49b4      	ldr	r1, [pc, #720]	; (1d5d0 <SFXSamplerAutoTick+0x310>)
   1d2fe:	ee66 6aa7 	vmul.f32	s13, s13, s15
   1d302:	ed9f 5ab4 	vldr	s10, [pc, #720]	; 1d5d4 <SFXSamplerAutoTick+0x314>
   1d306:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 1d5d8 <SFXSamplerAutoTick+0x318>
   1d30a:	edd2 7ab2 	vldr	s15, [r2, #712]	; 0x2c8
   1d30e:	eefd 6ae6 	vcvt.s32.f32	s13, s13
	samp_thresh = 1.0f - knobs[0];
   1d312:	ed92 6aaf 	vldr	s12, [r2, #700]	; 0x2bc
   1d316:	ee67 7a87 	vmul.f32	s15, s15, s14
	displayValues[0] = samp_thresh;
   1d31a:	4bb0      	ldr	r3, [pc, #704]	; (1d5dc <SFXSamplerAutoTick+0x31c>)
	samp_thresh = 1.0f - knobs[0];
   1d31c:	ee35 6ac6 	vsub.f32	s12, s11, s12
   1d320:	f8df 8304 	ldr.w	r8, [pc, #772]	; 1d628 <SFXSamplerAutoTick+0x368>
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d324:	ee16 0a90 	vmov	r0, s13
	if (pitchQuantization)
   1d328:	4ead      	ldr	r6, [pc, #692]	; (1d5e0 <SFXSamplerAutoTick+0x320>)
   1d32a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d32e:	ed92 7ab1 	vldr	s14, [r2, #708]	; 0x2c4
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d332:	eb01 0180 	add.w	r1, r1, r0, lsl #2
	displayValues[0] = samp_thresh;
   1d336:	ed83 6a00 	vstr	s12, [r3]
	samp_thresh = 1.0f - knobs[0];
   1d33a:	ed88 6a00 	vstr	s12, [r8]
   1d33e:	ee37 7a64 	vsub.f32	s14, s14, s9
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d342:	edd1 0a00 	vldr	s1, [r1]
   1d346:	eef8 6ae7 	vcvt.f32.s32	s13, s15
   1d34a:	ed92 9ab4 	vldr	s18, [r2, #720]	; 0x2d0
   1d34e:	ee60 0a85 	vmul.f32	s1, s1, s10
	if (pitchQuantization)
   1d352:	6831      	ldr	r1, [r6, #0]
   1d354:	ed9f 5aa3 	vldr	s10, [pc, #652]	; 1d5e4 <SFXSamplerAutoTick+0x324>
	int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
   1d358:	eefd 8ae0 	vcvt.s32.f32	s17, s1
   1d35c:	ee29 9a05 	vmul.f32	s18, s18, s10
	displayValues[1] = window_size;
   1d360:	eeb8 6ae8 	vcvt.f32.s32	s12, s17
   1d364:	ed83 6a01 	vstr	s12, [r3, #4]
	if (pitchQuantization)
   1d368:	b391      	cbz	r1, 1d3d0 <SFXSamplerAutoTick+0x110>
		rate = roundf((knobs[2] - 0.5f) * 14.0f);
   1d36a:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d36e:	ed9f 6a9e 	vldr	s12, [pc, #632]	; 1d5e8 <SFXSamplerAutoTick+0x328>
		rate = roundf((knobs[2] - 0.5f) * 14.0f);
   1d372:	ee27 7a05 	vmul.f32	s14, s14, s10
   1d376:	feb8 7a47 	vrinta.f32	s14, s14
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d37a:	eeb4 7ac6 	vcmpe.f32	s14, s12
   1d37e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d382:	f100 81a4 	bmi.w	1d6ce <SFXSamplerAutoTick+0x40e>
		else rate += 1.0f;
   1d386:	ee77 9a25 	vadd.f32	s19, s14, s11
	crossfadeLength = knobs[3] * 1000.0f;
   1d38a:	4f98      	ldr	r7, [pc, #608]	; (1d5ec <SFXSamplerAutoTick+0x32c>)
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d38c:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
	displayValues[3] = crossfadeLength;
   1d390:	edc3 6a03 	vstr	s13, [r3, #12]
	crossfadeLength = knobs[3] * 1000.0f;
   1d394:	edc7 7a00 	vstr	s15, [r7]
	displayValues[2] = rate;
   1d398:	edc3 9a02 	vstr	s19, [r3, #8]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d39c:	eeb4 9ac7 	vcmpe.f32	s18, s14
   1d3a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d3a4:	f100 81aa 	bmi.w	1d6fc <SFXSamplerAutoTick+0x43c>
	displayValues[5] = randLengthAmount;
   1d3a8:	ed83 9a05 	vstr	s18, [r3, #20]
		randRateAmount = roundf(knobs[6] * 8.0f);
   1d3ac:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
   1d3b0:	ed92 8ab5 	vldr	s16, [r2, #724]	; 0x2d4
   1d3b4:	ee28 8a07 	vmul.f32	s16, s16, s14
   1d3b8:	feb8 8a48 	vrinta.f32	s16, s16
   1d3bc:	e02e      	b.n	1d41c <SFXSamplerAutoTick+0x15c>
		currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
   1d3be:	4d80      	ldr	r5, [pc, #512]	; (1d5c0 <SFXSamplerAutoTick+0x300>)
   1d3c0:	ed90 0a01 	vldr	s0, [r0, #4]
   1d3c4:	487f      	ldr	r0, [pc, #508]	; (1d5c4 <SFXSamplerAutoTick+0x304>)
   1d3c6:	f006 ff8d 	bl	242e4 <tEnvelopeFollower_tick>
   1d3ca:	ed85 0a00 	vstr	s0, [r5]
   1d3ce:	e78b      	b.n	1d2e8 <SFXSamplerAutoTick+0x28>
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d3d0:	eeb3 6a04 	vmov.f32	s12, #52	; 0x41a00000  20.0
	crossfadeLength = knobs[3] * 1000.0f;
   1d3d4:	4f85      	ldr	r7, [pc, #532]	; (1d5ec <SFXSamplerAutoTick+0x32c>)
		rate = (knobs[2] - 0.5f) * 4.0f;
   1d3d6:	eef1 9a00 	vmov.f32	s19, #16	; 0x40800000  4.0
	displayValues[3] = crossfadeLength;
   1d3da:	edc3 6a03 	vstr	s13, [r3, #12]
	crossfadeLength = knobs[3] * 1000.0f;
   1d3de:	edc7 7a00 	vstr	s15, [r7]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d3e2:	eeb4 9ac6 	vcmpe.f32	s18, s12
		rate = (knobs[2] - 0.5f) * 4.0f;
   1d3e6:	ee67 9a29 	vmul.f32	s19, s14, s19
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d3ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	displayValues[2] = rate;
   1d3ee:	edc3 9a02 	vstr	s19, [r3, #8]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d3f2:	f100 80d9 	bmi.w	1d5a8 <SFXSamplerAutoTick+0x2e8>
	displayValues[5] = randLengthAmount;
   1d3f6:	ed83 9a05 	vstr	s18, [r3, #20]
		randRateAmount = knobs[6] * 2.0f;
   1d3fa:	ed92 8ab5 	vldr	s16, [r2, #724]	; 0x2d4
		if (randRateAmount < 0.01) randRateAmount = 0.0f;
   1d3fe:	ed9f 7a7a 	vldr	s14, [pc, #488]	; 1d5e8 <SFXSamplerAutoTick+0x328>
		randRateAmount = knobs[6] * 2.0f;
   1d402:	ee38 8a08 	vadd.f32	s16, s16, s16
		if (randRateAmount < 0.01) randRateAmount = 0.0f;
   1d406:	ed9f 6b6c 	vldr	d6, [pc, #432]	; 1d5b8 <SFXSamplerAutoTick+0x2f8>
   1d40a:	eeb7 5ac8 	vcvt.f64.f32	d5, s16
   1d40e:	eeb4 5b46 	vcmp.f64	d5, d6
   1d412:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d416:	bf48      	it	mi
   1d418:	eeb0 8a47 	vmovmi.f32	s16, s14
	tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
   1d41c:	ee17 1a90 	vmov	r1, s15
   1d420:	4873      	ldr	r0, [pc, #460]	; (1d5f0 <SFXSamplerAutoTick+0x330>)
	displayValues[6] = randRateAmount;
   1d422:	ed83 8a06 	vstr	s16, [r3, #24]
	tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
   1d426:	f00e fd65 	bl	2bef4 <tSampler_setCrossfadeLength>
	tSampler_setCrossfadeLength(&asSampler[1], crossfadeLength);
   1d42a:	6839      	ldr	r1, [r7, #0]
   1d42c:	4871      	ldr	r0, [pc, #452]	; (1d5f4 <SFXSamplerAutoTick+0x334>)
   1d42e:	f00e fd61 	bl	2bef4 <tSampler_setCrossfadeLength>
	if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1d432:	ed95 7a00 	vldr	s14, [r5]
   1d436:	edd8 7a00 	vldr	s15, [r8]
   1d43a:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 1d62c <SFXSamplerAutoTick+0x36c>
   1d43e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1d442:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d446:	f340 80b4 	ble.w	1d5b2 <SFXSamplerAutoTick+0x2f2>
   1d44a:	edda 7a00 	vldr	s15, [sl]
   1d44e:	eddf 6a6a 	vldr	s13, [pc, #424]	; 1d5f8 <SFXSamplerAutoTick+0x338>
   1d452:	ed95 7a00 	vldr	s14, [r5]
   1d456:	ee77 7aa6 	vadd.f32	s15, s15, s13
   1d45a:	eef4 7ac7 	vcmpe.f32	s15, s14
   1d45e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d462:	f140 80a6 	bpl.w	1d5b2 <SFXSamplerAutoTick+0x2f2>
   1d466:	4f65      	ldr	r7, [pc, #404]	; (1d5fc <SFXSamplerAutoTick+0x33c>)
   1d468:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 1d630 <SFXSamplerAutoTick+0x370>
   1d46c:	683b      	ldr	r3, [r7, #0]
   1d46e:	2b00      	cmp	r3, #0
   1d470:	f000 8149 	beq.w	1d706 <SFXSamplerAutoTick+0x446>
   1d474:	4b62      	ldr	r3, [pc, #392]	; (1d600 <SFXSamplerAutoTick+0x340>)
   1d476:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 1d634 <SFXSamplerAutoTick+0x374>
   1d47a:	9301      	str	r3, [sp, #4]
   1d47c:	4f61      	ldr	r7, [pc, #388]	; (1d604 <SFXSamplerAutoTick+0x344>)
   1d47e:	4b5c      	ldr	r3, [pc, #368]	; (1d5f0 <SFXSamplerAutoTick+0x330>)
   1d480:	9302      	str	r3, [sp, #8]
	tBuffer_tick(&asBuff[0], input[1]);
   1d482:	ed94 0a01 	vldr	s0, [r4, #4]
   1d486:	4860      	ldr	r0, [pc, #384]	; (1d608 <SFXSamplerAutoTick+0x348>)
   1d488:	f00e fc36 	bl	2bcf8 <tBuffer_tick>
	tBuffer_tick(&asBuff[1], input[1]);
   1d48c:	ed94 0a01 	vldr	s0, [r4, #4]
   1d490:	485e      	ldr	r0, [pc, #376]	; (1d60c <SFXSamplerAutoTick+0x34c>)
   1d492:	f00e fc31 	bl	2bcf8 <tBuffer_tick>
	if (sample_countdown > 0)
   1d496:	f8db 2000 	ldr.w	r2, [fp]
   1d49a:	2a00      	cmp	r2, #0
   1d49c:	f000 80ce 	beq.w	1d63c <SFXSamplerAutoTick+0x37c>
		sample_countdown--;
   1d4a0:	3a01      	subs	r2, #1
   1d4a2:	f8cb 2000 	str.w	r2, [fp]
	if (pitchQuantization)
   1d4a6:	6833      	ldr	r3, [r6, #0]
   1d4a8:	ed98 0a00 	vldr	s0, [r8]
   1d4ac:	2b00      	cmp	r3, #0
   1d4ae:	f000 80f4 	beq.w	1d69a <SFXSamplerAutoTick+0x3da>
		tSampler_setRate(&asSampler[0], rate * randRateVal);
   1d4b2:	ee29 0a80 	vmul.f32	s0, s19, s0
   1d4b6:	484e      	ldr	r0, [pc, #312]	; (1d5f0 <SFXSamplerAutoTick+0x330>)
   1d4b8:	f00f fa36 	bl	2c928 <tSampler_setRate>
		tSampler_setRate(&asSampler[1], rate * randRateVal);
   1d4bc:	ed98 0a00 	vldr	s0, [r8]
   1d4c0:	484c      	ldr	r0, [pc, #304]	; (1d5f4 <SFXSamplerAutoTick+0x334>)
   1d4c2:	ee29 0a80 	vmul.f32	s0, s19, s0
   1d4c6:	f00f fa2f 	bl	2c928 <tSampler_setRate>
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d4ca:	9b01      	ldr	r3, [sp, #4]
   1d4cc:	ee18 2a90 	vmov	r2, s17
   1d4d0:	ed9f 1a40 	vldr	s2, [pc, #256]	; 1d5d4 <SFXSamplerAutoTick+0x314>
   1d4d4:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1d4d8:	681b      	ldr	r3, [r3, #0]
	if (buttonActionsSFX[ButtonA][ActionPress])
   1d4da:	4e4d      	ldr	r6, [pc, #308]	; (1d610 <SFXSamplerAutoTick+0x350>)
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d4dc:	441a      	add	r2, r3
   1d4de:	ee00 2a90 	vmov	s1, r2
   1d4e2:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   1d4e6:	f00c f9cf 	bl	29888 <LEAF_clip>
   1d4ea:	eefd 7ac0 	vcvt.s32.f32	s15, s0
	tSampler_setEnd(&asSampler[0], finalWindowSize);
   1d4ee:	4840      	ldr	r0, [pc, #256]	; (1d5f0 <SFXSamplerAutoTick+0x330>)
	finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d4f0:	ee17 1a90 	vmov	r1, s15
   1d4f4:	edc7 7a00 	vstr	s15, [r7]
	tSampler_setEnd(&asSampler[0], finalWindowSize);
   1d4f8:	f00e fe04 	bl	2c104 <tSampler_setEnd>
	tSampler_setEnd(&asSampler[1], finalWindowSize);
   1d4fc:	6839      	ldr	r1, [r7, #0]
   1d4fe:	483d      	ldr	r0, [pc, #244]	; (1d5f4 <SFXSamplerAutoTick+0x334>)
   1d500:	f00e fe00 	bl	2c104 <tSampler_setEnd>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1d504:	7d33      	ldrb	r3, [r6, #20]
   1d506:	b14b      	cbz	r3, 1d51c <SFXSamplerAutoTick+0x25c>
		if (samplerMode == PlayLoop)
   1d508:	f8df 812c 	ldr.w	r8, [pc, #300]	; 1d638 <SFXSamplerAutoTick+0x378>
   1d50c:	f898 7000 	ldrb.w	r7, [r8]
   1d510:	2f01      	cmp	r7, #1
   1d512:	f000 8155 	beq.w	1d7c0 <SFXSamplerAutoTick+0x500>
		else if (samplerMode == PlayBackAndForth)
   1d516:	2f02      	cmp	r7, #2
   1d518:	f000 8163 	beq.w	1d7e2 <SFXSamplerAutoTick+0x522>
	if (buttonActionsSFX[ButtonB][ActionPress])
   1d51c:	7e33      	ldrb	r3, [r6, #24]
   1d51e:	2b00      	cmp	r3, #0
   1d520:	f040 80c8 	bne.w	1d6b4 <SFXSamplerAutoTick+0x3f4>
	float fade = tExpSmooth_tick(&cfxSmooth);
   1d524:	4e3b      	ldr	r6, [pc, #236]	; (1d614 <SFXSamplerAutoTick+0x354>)
   1d526:	4630      	mov	r0, r6
   1d528:	f00a fd24 	bl	27f74 <tExpSmooth_tick>
	if (fabsf(cfxSmooth->curr - cfxSmooth->dest) < 0.00001f)
   1d52c:	6833      	ldr	r3, [r6, #0]
   1d52e:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 1d618 <SFXSamplerAutoTick+0x358>
   1d532:	edd3 7a03 	vldr	s15, [r3, #12]
   1d536:	edd3 6a04 	vldr	s13, [r3, #16]
   1d53a:	ee77 7ae6 	vsub.f32	s15, s15, s13
   1d53e:	eef0 7ae7 	vabs.f32	s15, s15
   1d542:	eef4 7ac7 	vcmpe.f32	s15, s14
   1d546:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d54a:	d502      	bpl.n	1d552 <SFXSamplerAutoTick+0x292>
		fadeDone = 1;
   1d54c:	4b33      	ldr	r3, [pc, #204]	; (1d61c <SFXSamplerAutoTick+0x35c>)
   1d54e:	2201      	movs	r2, #1
   1d550:	601a      	str	r2, [r3, #0]
	LEAF_crossfade((fade * 2.0f) - 1.0f, volumes);
   1d552:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   1d556:	a806      	add	r0, sp, #24
   1d558:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1d55c:	eee0 7a07 	vfma.f32	s15, s0, s14
   1d560:	eeb0 0a67 	vmov.f32	s0, s15
   1d564:	f00c f90c 	bl	29780 <LEAF_crossfade>
	sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1d568:	4821      	ldr	r0, [pc, #132]	; (1d5f0 <SFXSamplerAutoTick+0x330>)
   1d56a:	f00e fe61 	bl	2c230 <tSampler_tick>
   1d56e:	4821      	ldr	r0, [pc, #132]	; (1d5f4 <SFXSamplerAutoTick+0x334>)
   1d570:	eef0 8a40 	vmov.f32	s17, s0
   1d574:	ed9d 8a07 	vldr	s16, [sp, #28]
   1d578:	f00e fe5a 	bl	2c230 <tSampler_tick>
   1d57c:	eddd 7a06 	vldr	s15, [sp, #24]
	input[0] = sample * 0.99f;
   1d580:	ed9f 7a27 	vldr	s14, [pc, #156]	; 1d620 <SFXSamplerAutoTick+0x360>
	sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1d584:	ee20 0a27 	vmul.f32	s0, s0, s15
	previousPower = currentPower;
   1d588:	682b      	ldr	r3, [r5, #0]
   1d58a:	f8ca 3000 	str.w	r3, [sl]
	sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
   1d58e:	eea8 0a88 	vfma.f32	s0, s17, s16
	input[0] = sample * 0.99f;
   1d592:	ee20 0a07 	vmul.f32	s0, s0, s14
   1d596:	ed84 0a00 	vstr	s0, [r4]
	input[1] = sample * 0.99f;
   1d59a:	ed84 0a01 	vstr	s0, [r4, #4]
}
   1d59e:	b009      	add	sp, #36	; 0x24
   1d5a0:	ecbd 8b06 	vpop	{d8-d10}
   1d5a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	displayValues[5] = randLengthAmount;
   1d5a8:	ed9f 9a0f 	vldr	s18, [pc, #60]	; 1d5e8 <SFXSamplerAutoTick+0x328>
   1d5ac:	ed83 9a05 	vstr	s18, [r3, #20]
   1d5b0:	e723      	b.n	1d3fa <SFXSamplerAutoTick+0x13a>
   1d5b2:	f8df b07c 	ldr.w	fp, [pc, #124]	; 1d630 <SFXSamplerAutoTick+0x370>
   1d5b6:	e75d      	b.n	1d474 <SFXSamplerAutoTick+0x1b4>
   1d5b8:	47ae147b 	.word	0x47ae147b
   1d5bc:	3f847ae1 	.word	0x3f847ae1
   1d5c0:	020e3178 	.word	0x020e3178
   1d5c4:	020fafa0 	.word	0x020fafa0
   1d5c8:	020f9318 	.word	0x020f9318
   1d5cc:	00062acc 	.word	0x00062acc
   1d5d0:	020f9c84 	.word	0x020f9c84
   1d5d4:	483b8000 	.word	0x483b8000
   1d5d8:	447a0000 	.word	0x447a0000
   1d5dc:	020fb3cc 	.word	0x020fb3cc
   1d5e0:	020e31e4 	.word	0x020e31e4
   1d5e4:	459c4000 	.word	0x459c4000
   1d5e8:	00000000 	.word	0x00000000
   1d5ec:	020e316c 	.word	0x020e316c
   1d5f0:	020fa3b0 	.word	0x020fa3b0
   1d5f4:	020fa3b4 	.word	0x020fa3b4
   1d5f8:	3a83126f 	.word	0x3a83126f
   1d5fc:	020e3200 	.word	0x020e3200
   1d600:	020e31f4 	.word	0x020e31f4
   1d604:	00062ad0 	.word	0x00062ad0
   1d608:	020fa140 	.word	0x020fa140
   1d60c:	020fa144 	.word	0x020fa144
   1d610:	020fb31c 	.word	0x020fb31c
   1d614:	020f9e98 	.word	0x020f9e98
   1d618:	3727c5ac 	.word	0x3727c5ac
   1d61c:	020e318c 	.word	0x020e318c
   1d620:	3f7d70a4 	.word	0x3f7d70a4
   1d624:	020e3215 	.word	0x020e3215
   1d628:	020e31fc 	.word	0x020e31fc
   1d62c:	020e31f0 	.word	0x020e31f0
   1d630:	020e3210 	.word	0x020e3210
   1d634:	020e31f8 	.word	0x020e31f8
   1d638:	00062b39 	.word	0x00062b39
	else if (samp_triggered == 1)
   1d63c:	4b78      	ldr	r3, [pc, #480]	; (1d820 <SFXSamplerAutoTick+0x560>)
   1d63e:	6819      	ldr	r1, [r3, #0]
   1d640:	2901      	cmp	r1, #1
   1d642:	f47f af30 	bne.w	1d4a6 <SFXSamplerAutoTick+0x1e6>
		currentSampler = !currentSampler;
   1d646:	4977      	ldr	r1, [pc, #476]	; (1d824 <SFXSamplerAutoTick+0x564>)
		setLED_1(0);
   1d648:	4610      	mov	r0, r2
   1d64a:	9203      	str	r2, [sp, #12]
   1d64c:	9305      	str	r3, [sp, #20]
		currentSampler = !currentSampler;
   1d64e:	9104      	str	r1, [sp, #16]
		setLED_1(0);
   1d650:	f7fb ff54 	bl	194fc <setLED_1>
		currentSampler = !currentSampler;
   1d654:	9904      	ldr	r1, [sp, #16]
		tSampler_play(&asSampler[currentSampler]);
   1d656:	9b02      	ldr	r3, [sp, #8]
		currentSampler = !currentSampler;
   1d658:	f891 c000 	ldrb.w	ip, [r1]
   1d65c:	9102      	str	r1, [sp, #8]
   1d65e:	fabc fc8c 	clz	ip, ip
   1d662:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
		tSampler_play(&asSampler[currentSampler]);
   1d666:	eb03 008c 	add.w	r0, r3, ip, lsl #2
		currentSampler = !currentSampler;
   1d66a:	f881 c000 	strb.w	ip, [r1]
		tSampler_play(&asSampler[currentSampler]);
   1d66e:	f00e fc57 	bl	2bf20 <tSampler_play>
		tExpSmooth_setDest(&cfxSmooth,(float)currentSampler);
   1d672:	9902      	ldr	r1, [sp, #8]
   1d674:	486c      	ldr	r0, [pc, #432]	; (1d828 <SFXSamplerAutoTick+0x568>)
   1d676:	780b      	ldrb	r3, [r1, #0]
   1d678:	ee00 3a10 	vmov	s0, r3
   1d67c:	eeb8 0a40 	vcvt.f32.u32	s0, s0
   1d680:	f00a fc6e 	bl	27f60 <tExpSmooth_setDest>
		samp_triggered = 0;
   1d684:	9a03      	ldr	r2, [sp, #12]
   1d686:	9b05      	ldr	r3, [sp, #20]
		fadeDone = 0;
   1d688:	4968      	ldr	r1, [pc, #416]	; (1d82c <SFXSamplerAutoTick+0x56c>)
		samp_triggered = 0;
   1d68a:	601a      	str	r2, [r3, #0]
	if (pitchQuantization)
   1d68c:	6833      	ldr	r3, [r6, #0]
		fadeDone = 0;
   1d68e:	600a      	str	r2, [r1, #0]
   1d690:	ed98 0a00 	vldr	s0, [r8]
	if (pitchQuantization)
   1d694:	2b00      	cmp	r3, #0
   1d696:	f47f af0c 	bne.w	1d4b2 <SFXSamplerAutoTick+0x1f2>
		tSampler_setRate(&asSampler[0], rate + randRateVal);
   1d69a:	ee39 0a80 	vadd.f32	s0, s19, s0
   1d69e:	4864      	ldr	r0, [pc, #400]	; (1d830 <SFXSamplerAutoTick+0x570>)
   1d6a0:	f00f f942 	bl	2c928 <tSampler_setRate>
		tSampler_setRate(&asSampler[1], rate + randRateVal);
   1d6a4:	ed98 0a00 	vldr	s0, [r8]
   1d6a8:	4862      	ldr	r0, [pc, #392]	; (1d834 <SFXSamplerAutoTick+0x574>)
   1d6aa:	ee39 0a80 	vadd.f32	s0, s19, s0
   1d6ae:	f00f f93b 	bl	2c928 <tSampler_setRate>
   1d6b2:	e70a      	b.n	1d4ca <SFXSamplerAutoTick+0x20a>
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d6b4:	f899 3000 	ldrb.w	r3, [r9]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1d6b8:	2200      	movs	r2, #0
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d6ba:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1d6be:	7632      	strb	r2, [r6, #24]
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d6c0:	095b      	lsrs	r3, r3, #5
		setLED_B(triggerChannel);
   1d6c2:	4618      	mov	r0, r3
		triggerChannel = (triggerChannel > 0) ? 0 : 1;
   1d6c4:	f889 3000 	strb.w	r3, [r9]
		setLED_B(triggerChannel);
   1d6c8:	f7fb ff46 	bl	19558 <setLED_B>
   1d6cc:	e72a      	b.n	1d524 <SFXSamplerAutoTick+0x264>
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d6ce:	ee37 7a65 	vsub.f32	s14, s14, s11
	crossfadeLength = knobs[3] * 1000.0f;
   1d6d2:	4f59      	ldr	r7, [pc, #356]	; (1d838 <SFXSamplerAutoTick+0x578>)
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d6d4:	eeb3 5a04 	vmov.f32	s10, #52	; 0x41a00000  20.0
	displayValues[3] = crossfadeLength;
   1d6d8:	edc3 6a03 	vstr	s13, [r3, #12]
	crossfadeLength = knobs[3] * 1000.0f;
   1d6dc:	edc7 7a00 	vstr	s15, [r7]
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d6e0:	eeb0 7ac7 	vabs.f32	s14, s14
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d6e4:	eeb4 9a45 	vcmp.f32	s18, s10
		if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   1d6e8:	eec5 9a87 	vdiv.f32	s19, s11, s14
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d6ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d6f0:	bf48      	it	mi
   1d6f2:	eeb0 9a46 	vmovmi.f32	s18, s12
	displayValues[2] = rate;
   1d6f6:	edc3 9a02 	vstr	s19, [r3, #8]
   1d6fa:	e655      	b.n	1d3a8 <SFXSamplerAutoTick+0xe8>
	displayValues[5] = randLengthAmount;
   1d6fc:	ed83 6a05 	vstr	s12, [r3, #20]
	if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
   1d700:	eeb0 9a46 	vmov.f32	s18, s12
   1d704:	e652      	b.n	1d3ac <SFXSamplerAutoTick+0xec>
	if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
   1d706:	f8db 2000 	ldr.w	r2, [fp]
   1d70a:	2a00      	cmp	r2, #0
   1d70c:	f47f aeb2 	bne.w	1d474 <SFXSamplerAutoTick+0x1b4>
   1d710:	4a46      	ldr	r2, [pc, #280]	; (1d82c <SFXSamplerAutoTick+0x56c>)
   1d712:	6812      	ldr	r2, [r2, #0]
   1d714:	2a01      	cmp	r2, #1
   1d716:	f47f aead 	bne.w	1d474 <SFXSamplerAutoTick+0x1b4>
		randLengthVal = (randomNumber() - 0.5f) * randLengthAmount * 2.0f;
   1d71a:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
   1d71e:	f7fb fe39 	bl	19394 <randomNumber>
   1d722:	ee39 9a09 	vadd.f32	s18, s18, s18
   1d726:	4b45      	ldr	r3, [pc, #276]	; (1d83c <SFXSamplerAutoTick+0x57c>)
		if (pitchQuantization) randRateVal = roundf(randomNumber() * randRateAmount) + 1.0f;
   1d728:	6832      	ldr	r2, [r6, #0]
		randLengthVal = (randomNumber() - 0.5f) * randLengthAmount * 2.0f;
   1d72a:	ee70 7a4a 	vsub.f32	s15, s0, s20
   1d72e:	9301      	str	r3, [sp, #4]
   1d730:	ee67 7a89 	vmul.f32	s15, s15, s18
   1d734:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1d738:	edc3 7a00 	vstr	s15, [r3]
		if (pitchQuantization) randRateVal = roundf(randomNumber() * randRateAmount) + 1.0f;
   1d73c:	2a00      	cmp	r2, #0
   1d73e:	d061      	beq.n	1d804 <SFXSamplerAutoTick+0x544>
   1d740:	f7fb fe28 	bl	19394 <randomNumber>
   1d744:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   1d748:	ee60 7a08 	vmul.f32	s15, s0, s16
   1d74c:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 1d84c <SFXSamplerAutoTick+0x58c>
   1d750:	fef8 7a67 	vrinta.f32	s15, s15
   1d754:	ee77 7a87 	vadd.f32	s15, s15, s14
   1d758:	edc8 7a00 	vstr	s15, [r8]
		samp_triggered = 1;
   1d75c:	2201      	movs	r2, #1
		tSampler_stop(&asSampler[!currentSampler]);
   1d75e:	4b34      	ldr	r3, [pc, #208]	; (1d830 <SFXSamplerAutoTick+0x570>)
		setLED_1(1);
   1d760:	4610      	mov	r0, r2
		tSampler_stop(&asSampler[!currentSampler]);
   1d762:	9302      	str	r3, [sp, #8]
		samp_triggered = 1;
   1d764:	603a      	str	r2, [r7, #0]
		setLED_1(1);
   1d766:	f7fb fec9 	bl	194fc <setLED_1>
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d76a:	9a01      	ldr	r2, [sp, #4]
   1d76c:	ee18 1a90 	vmov	r1, s17
   1d770:	ed9f 1a33 	vldr	s2, [pc, #204]	; 1d840 <SFXSamplerAutoTick+0x580>
   1d774:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1d778:	6812      	ldr	r2, [r2, #0]
   1d77a:	4f32      	ldr	r7, [pc, #200]	; (1d844 <SFXSamplerAutoTick+0x584>)
   1d77c:	188a      	adds	r2, r1, r2
   1d77e:	ee00 2a90 	vmov	s1, r2
   1d782:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   1d786:	f00c f87f 	bl	29888 <LEAF_clip>
		tSampler_stop(&asSampler[!currentSampler]);
   1d78a:	4a26      	ldr	r2, [pc, #152]	; (1d824 <SFXSamplerAutoTick+0x564>)
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d78c:	eefd 7ac0 	vcvt.s32.f32	s15, s0
		tSampler_stop(&asSampler[!currentSampler]);
   1d790:	9b02      	ldr	r3, [sp, #8]
   1d792:	7810      	ldrb	r0, [r2, #0]
   1d794:	fab0 f080 	clz	r0, r0
		sample_countdown = finalWindowSize;
   1d798:	edcb 7a00 	vstr	s15, [fp]
		finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
   1d79c:	edc7 7a00 	vstr	s15, [r7]
		tSampler_stop(&asSampler[!currentSampler]);
   1d7a0:	0940      	lsrs	r0, r0, #5
   1d7a2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1d7a6:	f00e fc0b 	bl	2bfc0 <tSampler_stop>
		tBuffer_record(&asBuff[!currentSampler]);
   1d7aa:	4a1e      	ldr	r2, [pc, #120]	; (1d824 <SFXSamplerAutoTick+0x564>)
   1d7ac:	4826      	ldr	r0, [pc, #152]	; (1d848 <SFXSamplerAutoTick+0x588>)
   1d7ae:	7812      	ldrb	r2, [r2, #0]
   1d7b0:	fab2 f282 	clz	r2, r2
   1d7b4:	0952      	lsrs	r2, r2, #5
   1d7b6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
   1d7ba:	f00e facd 	bl	2bd58 <tBuffer_record>
   1d7be:	e660      	b.n	1d482 <SFXSamplerAutoTick+0x1c2>
			tSampler_setMode(&asSampler[0], PlayBackAndForth);
   1d7c0:	2102      	movs	r1, #2
   1d7c2:	481b      	ldr	r0, [pc, #108]	; (1d830 <SFXSamplerAutoTick+0x570>)
   1d7c4:	f00e fb92 	bl	2beec <tSampler_setMode>
			tSampler_setMode(&asSampler[1], PlayBackAndForth);
   1d7c8:	2102      	movs	r1, #2
   1d7ca:	481a      	ldr	r0, [pc, #104]	; (1d834 <SFXSamplerAutoTick+0x574>)
   1d7cc:	f00e fb8e 	bl	2beec <tSampler_setMode>
			samplerMode = PlayBackAndForth;
   1d7d0:	2302      	movs	r3, #2
			setLED_A(1);
   1d7d2:	4638      	mov	r0, r7
			samplerMode = PlayBackAndForth;
   1d7d4:	f888 3000 	strb.w	r3, [r8]
			setLED_A(1);
   1d7d8:	f7fb feb0 	bl	1953c <setLED_A>
			buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d7dc:	2300      	movs	r3, #0
   1d7de:	7533      	strb	r3, [r6, #20]
   1d7e0:	e69c      	b.n	1d51c <SFXSamplerAutoTick+0x25c>
			tSampler_setMode(&asSampler[0], PlayLoop);
   1d7e2:	2101      	movs	r1, #1
   1d7e4:	4812      	ldr	r0, [pc, #72]	; (1d830 <SFXSamplerAutoTick+0x570>)
   1d7e6:	f00e fb81 	bl	2beec <tSampler_setMode>
			tSampler_setMode(&asSampler[1], PlayLoop);
   1d7ea:	2101      	movs	r1, #1
   1d7ec:	4811      	ldr	r0, [pc, #68]	; (1d834 <SFXSamplerAutoTick+0x574>)
   1d7ee:	f00e fb7d 	bl	2beec <tSampler_setMode>
			samplerMode = PlayLoop;
   1d7f2:	2301      	movs	r3, #1
			setLED_A(0);
   1d7f4:	2000      	movs	r0, #0
			samplerMode = PlayLoop;
   1d7f6:	f888 3000 	strb.w	r3, [r8]
			setLED_A(0);
   1d7fa:	f7fb fe9f 	bl	1953c <setLED_A>
			buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d7fe:	2300      	movs	r3, #0
   1d800:	7533      	strb	r3, [r6, #20]
   1d802:	e68b      	b.n	1d51c <SFXSamplerAutoTick+0x25c>
		else randRateVal = (randomNumber() - 0.5f) * randRateAmount * 2.0f;
   1d804:	f7fb fdc6 	bl	19394 <randomNumber>
   1d808:	ee38 8a08 	vadd.f32	s16, s16, s16
   1d80c:	ee30 0a4a 	vsub.f32	s0, s0, s20
   1d810:	f8df 8038 	ldr.w	r8, [pc, #56]	; 1d84c <SFXSamplerAutoTick+0x58c>
   1d814:	ee20 8a08 	vmul.f32	s16, s0, s16
   1d818:	ed88 8a00 	vstr	s16, [r8]
   1d81c:	e79e      	b.n	1d75c <SFXSamplerAutoTick+0x49c>
   1d81e:	bf00      	nop
   1d820:	020e3200 	.word	0x020e3200
   1d824:	020e317c 	.word	0x020e317c
   1d828:	020f9e98 	.word	0x020f9e98
   1d82c:	020e318c 	.word	0x020e318c
   1d830:	020fa3b0 	.word	0x020fa3b0
   1d834:	020fa3b4 	.word	0x020fa3b4
   1d838:	020e316c 	.word	0x020e316c
   1d83c:	020e31f4 	.word	0x020e31f4
   1d840:	483b8000 	.word	0x483b8000
   1d844:	00062ad0 	.word	0x00062ad0
   1d848:	020fa140 	.word	0x020fa140
   1d84c:	020e31f8 	.word	0x020e31f8

0001d850 <SFXSamplerAutoFree>:
{
   1d850:	b538      	push	{r3, r4, r5, lr}
	tBuffer_free(&asBuff[0]);
   1d852:	4d0b      	ldr	r5, [pc, #44]	; (1d880 <SFXSamplerAutoFree+0x30>)
	tSampler_free(&asSampler[0]);
   1d854:	4c0b      	ldr	r4, [pc, #44]	; (1d884 <SFXSamplerAutoFree+0x34>)
	tBuffer_free(&asBuff[0]);
   1d856:	4628      	mov	r0, r5
   1d858:	f00e fa42 	bl	2bce0 <tBuffer_free>
	tBuffer_free(&asBuff[1]);
   1d85c:	1d28      	adds	r0, r5, #4
   1d85e:	f00e fa3f 	bl	2bce0 <tBuffer_free>
	tSampler_free(&asSampler[0]);
   1d862:	4620      	mov	r0, r4
   1d864:	f00e fb36 	bl	2bed4 <tSampler_free>
	tSampler_free(&asSampler[1]);
   1d868:	1d20      	adds	r0, r4, #4
   1d86a:	f00e fb33 	bl	2bed4 <tSampler_free>
	tEnvelopeFollower_free(&envfollow);
   1d86e:	4806      	ldr	r0, [pc, #24]	; (1d888 <SFXSamplerAutoFree+0x38>)
   1d870:	f006 fd34 	bl	242dc <tEnvelopeFollower_free>
	tExpSmooth_free(&cfxSmooth);
   1d874:	4805      	ldr	r0, [pc, #20]	; (1d88c <SFXSamplerAutoFree+0x3c>)
}
   1d876:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	tExpSmooth_free(&cfxSmooth);
   1d87a:	f00a bb5b 	b.w	27f34 <tExpSmooth_free>
   1d87e:	bf00      	nop
   1d880:	020fa140 	.word	0x020fa140
   1d884:	020fa3b0 	.word	0x020fa3b0
   1d888:	020fafa0 	.word	0x020fafa0
   1d88c:	020f9e98 	.word	0x020f9e98

0001d890 <SFXDistortionAlloc>:
{
   1d890:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1d894:	4e29      	ldr	r6, [pc, #164]	; (1d93c <SFXDistortionAlloc+0xac>)
	leaf.clearOnAllocation = 1;
   1d896:	2701      	movs	r7, #1
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1d898:	4d29      	ldr	r5, [pc, #164]	; (1d940 <SFXDistortionAlloc+0xb0>)
   1d89a:	2200      	movs	r2, #0
	leaf.clearOnAllocation = 1;
   1d89c:	4c29      	ldr	r4, [pc, #164]	; (1d944 <SFXDistortionAlloc+0xb4>)
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1d89e:	4633      	mov	r3, r6
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1d8a0:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 1d964 <SFXDistortionAlloc+0xd4>
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1d8a4:	6829      	ldr	r1, [r5, #0]
   1d8a6:	4828      	ldr	r0, [pc, #160]	; (1d948 <SFXDistortionAlloc+0xb8>)
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1d8a8:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 1d968 <SFXDistortionAlloc+0xd8>
	leaf.clearOnAllocation = 1;
   1d8ac:	6167      	str	r7, [r4, #20]
	tOversampler_initToPool(&oversampler, distOS_ratio, 0, &smallPool);
   1d8ae:	f007 fd41 	bl	25334 <tOversampler_initToPool>
	tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
   1d8b2:	4f26      	ldr	r7, [pc, #152]	; (1d94c <SFXDistortionAlloc+0xbc>)
	tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
   1d8b4:	4632      	mov	r2, r6
   1d8b6:	4648      	mov	r0, r9
   1d8b8:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1d8bc:	ed9f 0a24 	vldr	s0, [pc, #144]	; 1d950 <SFXDistortionAlloc+0xc0>
   1d8c0:	2106      	movs	r1, #6
   1d8c2:	f00a fe9f 	bl	28604 <tVZFilter_initToPool>
	tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
   1d8c6:	4632      	mov	r2, r6
   1d8c8:	4640      	mov	r0, r8
   1d8ca:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
   1d8ce:	ed9f 0a21 	vldr	s0, [pc, #132]	; 1d954 <SFXDistortionAlloc+0xc4>
   1d8d2:	2107      	movs	r1, #7
   1d8d4:	f00a fe96 	bl	28604 <tVZFilter_initToPool>
	tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
   1d8d8:	4632      	mov	r2, r6
   1d8da:	eddf 0a1f 	vldr	s1, [pc, #124]	; 1d958 <SFXDistortionAlloc+0xc8>
   1d8de:	2105      	movs	r1, #5
   1d8e0:	4638      	mov	r0, r7
   1d8e2:	ed9f 0a1e 	vldr	s0, [pc, #120]	; 1d95c <SFXDistortionAlloc+0xcc>
   1d8e6:	f00a fe8d 	bl	28604 <tVZFilter_initToPool>
	tVZFilter_setSampleRate(&shelf1, leaf.sampleRate * distOS_ratio);
   1d8ea:	edd5 7a00 	vldr	s15, [r5]
   1d8ee:	ed94 0a00 	vldr	s0, [r4]
   1d8f2:	4648      	mov	r0, r9
   1d8f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1d8f8:	ee27 0a80 	vmul.f32	s0, s15, s0
   1d8fc:	f00b f878 	bl	289f0 <tVZFilter_setSampleRate>
	tVZFilter_setSampleRate(&shelf2, leaf.sampleRate * distOS_ratio);
   1d900:	edd5 7a00 	vldr	s15, [r5]
   1d904:	ed94 0a00 	vldr	s0, [r4]
   1d908:	4640      	mov	r0, r8
   1d90a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1d90e:	ee27 0a80 	vmul.f32	s0, s15, s0
   1d912:	f00b f86d 	bl	289f0 <tVZFilter_setSampleRate>
	tVZFilter_setSampleRate(&bell1, leaf.sampleRate * distOS_ratio);
   1d916:	ed95 0a00 	vldr	s0, [r5]
   1d91a:	edd4 7a00 	vldr	s15, [r4]
   1d91e:	4638      	mov	r0, r7
   1d920:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   1d924:	ee20 0a27 	vmul.f32	s0, s0, s15
   1d928:	f00b f862 	bl	289f0 <tVZFilter_setSampleRate>
	setLED_A(distortionMode);
   1d92c:	4b0c      	ldr	r3, [pc, #48]	; (1d960 <SFXDistortionAlloc+0xd0>)
   1d92e:	7818      	ldrb	r0, [r3, #0]
   1d930:	f7fb fe04 	bl	1953c <setLED_A>
	leaf.clearOnAllocation = 0;
   1d934:	2300      	movs	r3, #0
   1d936:	6163      	str	r3, [r4, #20]
}
   1d938:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1d93c:	020f7730 	.word	0x020f7730
   1d940:	00062ac8 	.word	0x00062ac8
   1d944:	020fc0a8 	.word	0x020fc0a8
   1d948:	020fad84 	.word	0x020fad84
   1d94c:	020f9f7c 	.word	0x020f9f7c
   1d950:	42a00000 	.word	0x42a00000
   1d954:	463b8000 	.word	0x463b8000
   1d958:	3ff33333 	.word	0x3ff33333
   1d95c:	447a0000 	.word	0x447a0000
   1d960:	020e3184 	.word	0x020e3184
   1d964:	020fa13c 	.word	0x020fa13c
   1d968:	020fa064 	.word	0x020fa064

0001d96c <SFXDistortionFrame>:
	if (buttonActionsSFX[ButtonA][ActionPress])
   1d96c:	4a27      	ldr	r2, [pc, #156]	; (1da0c <SFXDistortionFrame+0xa0>)
{
   1d96e:	b510      	push	{r4, lr}
	if (buttonActionsSFX[ButtonA][ActionPress])
   1d970:	7d13      	ldrb	r3, [r2, #20]
   1d972:	b153      	cbz	r3, 1d98a <SFXDistortionFrame+0x1e>
		distortionMode = !distortionMode;
   1d974:	4926      	ldr	r1, [pc, #152]	; (1da10 <SFXDistortionFrame+0xa4>)
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d976:	2000      	movs	r0, #0
		distortionMode = !distortionMode;
   1d978:	780b      	ldrb	r3, [r1, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1d97a:	7510      	strb	r0, [r2, #20]
		distortionMode = !distortionMode;
   1d97c:	fab3 f383 	clz	r3, r3
   1d980:	095b      	lsrs	r3, r3, #5
		setLED_A(distortionMode);
   1d982:	4618      	mov	r0, r3
		distortionMode = !distortionMode;
   1d984:	700b      	strb	r3, [r1, #0]
		setLED_A(distortionMode);
   1d986:	f7fb fdd9 	bl	1953c <setLED_A>
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d98a:	4b22      	ldr	r3, [pc, #136]	; (1da14 <SFXDistortionFrame+0xa8>)
   1d98c:	eeb3 6a0e 	vmov.f32	s12, #62	; 0x41f00000  30.0
   1d990:	eeba 7a0e 	vmov.f32	s14, #174	; 0xc1700000 -15.0
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d994:	eddf 6a20 	vldr	s13, [pc, #128]	; 1da18 <SFXDistortionFrame+0xac>
   1d998:	eefb 7a01 	vmov.f32	s15, #177	; 0xc1880000 -17.0
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d99c:	ed93 5ac9 	vldr	s10, [r3, #804]	; 0x324
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d9a0:	edd3 5aca 	vldr	s11, [r3, #808]	; 0x328
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d9a4:	eea5 7a06 	vfma.f32	s14, s10, s12
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d9a8:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 1da1c <SFXDistortionFrame+0xb0>
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d9ac:	eee5 7aa6 	vfma.f32	s15, s11, s13
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d9b0:	ed93 6acb 	vldr	s12, [r3, #812]	; 0x32c
   1d9b4:	eddf 6a1a 	vldr	s13, [pc, #104]	; 1da20 <SFXDistortionFrame+0xb4>
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d9b8:	4c1a      	ldr	r4, [pc, #104]	; (1da24 <SFXDistortionFrame+0xb8>)
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d9ba:	eea6 0a26 	vfma.f32	s0, s12, s13
	displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
   1d9be:	ed84 7a01 	vstr	s14, [r4, #4]
	displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
   1d9c2:	edc4 7a02 	vstr	s15, [r4, #8]
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d9c6:	f00c f8cd 	bl	29b64 <faster_mtof>
	tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
   1d9ca:	edd4 7a01 	vldr	s15, [r4, #4]
	displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
   1d9ce:	ed84 0a03 	vstr	s0, [r4, #12]
	tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
   1d9d2:	eeb1 0a67 	vneg.f32	s0, s15
   1d9d6:	f00c f915 	bl	29c04 <fastdbtoa>
   1d9da:	4813      	ldr	r0, [pc, #76]	; (1da28 <SFXDistortionFrame+0xbc>)
   1d9dc:	f00b fc4c 	bl	29278 <tVZFilter_setGain>
	tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[1]));
   1d9e0:	ed94 0a01 	vldr	s0, [r4, #4]
   1d9e4:	f00c f90e 	bl	29c04 <fastdbtoa>
   1d9e8:	4810      	ldr	r0, [pc, #64]	; (1da2c <SFXDistortionFrame+0xc0>)
   1d9ea:	f00b fc45 	bl	29278 <tVZFilter_setGain>
	tVZFilter_setFreq(&bell1, displayValues[3]);
   1d9ee:	ed94 0a03 	vldr	s0, [r4, #12]
   1d9f2:	480f      	ldr	r0, [pc, #60]	; (1da30 <SFXDistortionFrame+0xc4>)
   1d9f4:	f00b f876 	bl	28ae4 <tVZFilter_setFreq>
	tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
   1d9f8:	ed94 0a02 	vldr	s0, [r4, #8]
   1d9fc:	f00c f902 	bl	29c04 <fastdbtoa>
   1da00:	480b      	ldr	r0, [pc, #44]	; (1da30 <SFXDistortionFrame+0xc4>)
}
   1da02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
   1da06:	f00b bc37 	b.w	29278 <tVZFilter_setGain>
   1da0a:	bf00      	nop
   1da0c:	020fb31c 	.word	0x020fb31c
   1da10:	020e3184 	.word	0x020e3184
   1da14:	020f9318 	.word	0x020f9318
   1da18:	42080000 	.word	0x42080000
   1da1c:	42280000 	.word	0x42280000
   1da20:	429a0000 	.word	0x429a0000
   1da24:	020fb3cc 	.word	0x020fb3cc
   1da28:	020fa13c 	.word	0x020fa13c
   1da2c:	020fa064 	.word	0x020fa064
   1da30:	020f9f7c 	.word	0x020f9f7c

0001da34 <SFXDistortionTick>:
{
   1da34:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   1da38:	4e2f      	ldr	r6, [pc, #188]	; (1daf8 <SFXDistortionTick+0xc4>)
   1da3a:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
   1da3e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1da42:	4b2e      	ldr	r3, [pc, #184]	; (1dafc <SFXDistortionTick+0xc8>)
   1da44:	edd6 6ac8 	vldr	s13, [r6, #800]	; 0x320
{
   1da48:	4683      	mov	fp, r0
	displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
   1da4a:	f8d6 2330 	ldr.w	r2, [r6, #816]	; 0x330
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   1da4e:	eee6 7a87 	vfma.f32	s15, s13, s14
	for (int i = 0; i < distOS_ratio; i++)
   1da52:	4f2b      	ldr	r7, [pc, #172]	; (1db00 <SFXDistortionTick+0xcc>)
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1da54:	492b      	ldr	r1, [pc, #172]	; (1db04 <SFXDistortionTick+0xd0>)
{
   1da56:	ed2d 8b02 	vpush	{d8}
	float sample = input[1];
   1da5a:	ed90 0a01 	vldr	s0, [r0, #4]
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1da5e:	482a      	ldr	r0, [pc, #168]	; (1db08 <SFXDistortionTick+0xd4>)
   1da60:	ee27 0a80 	vmul.f32	s0, s15, s0
	displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
   1da64:	611a      	str	r2, [r3, #16]
	displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
   1da66:	edc3 7a00 	vstr	s15, [r3]
	tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1da6a:	f007 fd4d 	bl	25508 <tOversampler_upsample>
	for (int i = 0; i < distOS_ratio; i++)
   1da6e:	683b      	ldr	r3, [r7, #0]
   1da70:	2b00      	cmp	r3, #0
   1da72:	dd2d      	ble.n	1dad0 <SFXDistortionTick+0x9c>
   1da74:	4c23      	ldr	r4, [pc, #140]	; (1db04 <SFXDistortionTick+0xd0>)
   1da76:	2500      	movs	r5, #0
   1da78:	f8df a098 	ldr.w	sl, [pc, #152]	; 1db14 <SFXDistortionTick+0xe0>
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1da7c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1db18 <SFXDistortionTick+0xe4>
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1da80:	f8df 8098 	ldr.w	r8, [pc, #152]	; 1db1c <SFXDistortionTick+0xe8>
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1da84:	ed9f 8a21 	vldr	s16, [pc, #132]	; 1db0c <SFXDistortionTick+0xd8>
		if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
   1da88:	f89a 3000 	ldrb.w	r3, [sl]
   1da8c:	ecb4 0a01 	vldmia	r4!, {s0}
   1da90:	bb53      	cbnz	r3, 1dae8 <SFXDistortionTick+0xb4>
		else oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1da92:	f00f fc13 	bl	2d2bc <tanhf>
   1da96:	ed04 0a01 	vstr	s0, [r4, #-4]
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1da9a:	4648      	mov	r0, r9
	for (int i = 0; i < distOS_ratio; i++)
   1da9c:	3501      	adds	r5, #1
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1da9e:	f00a ffb1 	bl	28a04 <tVZFilter_tick>
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1daa2:	4640      	mov	r0, r8
		oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
   1daa4:	ed04 0a01 	vstr	s0, [r4, #-4]
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1daa8:	f00a ffac 	bl	28a04 <tVZFilter_tick>
		oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
   1daac:	4818      	ldr	r0, [pc, #96]	; (1db10 <SFXDistortionTick+0xdc>)
		oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
   1daae:	ed04 0a01 	vstr	s0, [r4, #-4]
		oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
   1dab2:	f00a ffa7 	bl	28a04 <tVZFilter_tick>
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1dab6:	edd6 7acc 	vldr	s15, [r6, #816]	; 0x330
   1daba:	ee20 0a27 	vmul.f32	s0, s0, s15
   1dabe:	f00f fbfd 	bl	2d2bc <tanhf>
	for (int i = 0; i < distOS_ratio; i++)
   1dac2:	683b      	ldr	r3, [r7, #0]
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1dac4:	ee20 0a08 	vmul.f32	s0, s0, s16
	for (int i = 0; i < distOS_ratio; i++)
   1dac8:	42ab      	cmp	r3, r5
		oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
   1daca:	ed04 0a01 	vstr	s0, [r4, #-4]
	for (int i = 0; i < distOS_ratio; i++)
   1dace:	dcdb      	bgt.n	1da88 <SFXDistortionTick+0x54>
	sample = tOversampler_downsample(&oversampler, oversamplerArray);
   1dad0:	490c      	ldr	r1, [pc, #48]	; (1db04 <SFXDistortionTick+0xd0>)
   1dad2:	480d      	ldr	r0, [pc, #52]	; (1db08 <SFXDistortionTick+0xd4>)
   1dad4:	f007 fd62 	bl	2559c <tOversampler_downsample>
	input[0] = sample;
   1dad8:	ed8b 0a00 	vstr	s0, [fp]
	input[1] = sample;
   1dadc:	ed8b 0a01 	vstr	s0, [fp, #4]
}
   1dae0:	ecbd 8b02 	vpop	{d8}
   1dae4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
   1dae8:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1daec:	f00b fe72 	bl	297d4 <LEAF_shaper>
   1daf0:	ed04 0a01 	vstr	s0, [r4, #-4]
   1daf4:	e7d1      	b.n	1da9a <SFXDistortionTick+0x66>
   1daf6:	bf00      	nop
   1daf8:	020f9318 	.word	0x020f9318
   1dafc:	020fb3cc 	.word	0x020fb3cc
   1db00:	00062ac8 	.word	0x00062ac8
   1db04:	020f9ea8 	.word	0x020f9ea8
   1db08:	020fad84 	.word	0x020fad84
   1db0c:	3f733333 	.word	0x3f733333
   1db10:	020f9f7c 	.word	0x020f9f7c
   1db14:	020e3184 	.word	0x020e3184
   1db18:	020fa13c 	.word	0x020fa13c
   1db1c:	020fa064 	.word	0x020fa064

0001db20 <SFXDistortionFree>:
{
   1db20:	b508      	push	{r3, lr}
	tOversampler_free(&oversampler);
   1db22:	4807      	ldr	r0, [pc, #28]	; (1db40 <SFXDistortionFree+0x20>)
   1db24:	f007 fc56 	bl	253d4 <tOversampler_free>
	tVZFilter_free(&shelf1);
   1db28:	4806      	ldr	r0, [pc, #24]	; (1db44 <SFXDistortionFree+0x24>)
   1db2a:	f00a ff5d 	bl	289e8 <tVZFilter_free>
	tVZFilter_free(&shelf2);
   1db2e:	4806      	ldr	r0, [pc, #24]	; (1db48 <SFXDistortionFree+0x28>)
   1db30:	f00a ff5a 	bl	289e8 <tVZFilter_free>
	tVZFilter_free(&bell1);
   1db34:	4805      	ldr	r0, [pc, #20]	; (1db4c <SFXDistortionFree+0x2c>)
}
   1db36:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tVZFilter_free(&bell1);
   1db3a:	f00a bf55 	b.w	289e8 <tVZFilter_free>
   1db3e:	bf00      	nop
   1db40:	020fad84 	.word	0x020fad84
   1db44:	020fa13c 	.word	0x020fa13c
   1db48:	020fa064 	.word	0x020fa064
   1db4c:	020f9f7c 	.word	0x020f9f7c

0001db50 <SFXWaveFolderAlloc>:
{
   1db50:	b538      	push	{r3, r4, r5, lr}
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   1db52:	4c0f      	ldr	r4, [pc, #60]	; (1db90 <SFXWaveFolderAlloc+0x40>)
	leaf.clearOnAllocation = 1;
   1db54:	2301      	movs	r3, #1
   1db56:	4d0f      	ldr	r5, [pc, #60]	; (1db94 <SFXWaveFolderAlloc+0x44>)
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   1db58:	4621      	mov	r1, r4
   1db5a:	480f      	ldr	r0, [pc, #60]	; (1db98 <SFXWaveFolderAlloc+0x48>)
	leaf.clearOnAllocation = 1;
   1db5c:	616b      	str	r3, [r5, #20]
	tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
   1db5e:	f007 fd4f 	bl	25600 <tLockhartWavefolder_initToPool>
	tLockhartWavefolder_initToPool(&wavefolder2, &smallPool);
   1db62:	4621      	mov	r1, r4
   1db64:	480d      	ldr	r0, [pc, #52]	; (1db9c <SFXWaveFolderAlloc+0x4c>)
   1db66:	f007 fd4b 	bl	25600 <tLockhartWavefolder_initToPool>
	tHighpass_initToPool(&wfHP, 10.0f, &smallPool);
   1db6a:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1db6e:	4621      	mov	r1, r4
   1db70:	480b      	ldr	r0, [pc, #44]	; (1dba0 <SFXWaveFolderAlloc+0x50>)
   1db72:	f00a fd03 	bl	2857c <tHighpass_initToPool>
	tOversampler_initToPool(&oversampler, 2, 0, &smallPool);
   1db76:	4623      	mov	r3, r4
   1db78:	2200      	movs	r2, #0
   1db7a:	2102      	movs	r1, #2
   1db7c:	4809      	ldr	r0, [pc, #36]	; (1dba4 <SFXWaveFolderAlloc+0x54>)
   1db7e:	f007 fbd9 	bl	25334 <tOversampler_initToPool>
	setLED_A(foldMode);
   1db82:	4b09      	ldr	r3, [pc, #36]	; (1dba8 <SFXWaveFolderAlloc+0x58>)
   1db84:	7818      	ldrb	r0, [r3, #0]
   1db86:	f7fb fcd9 	bl	1953c <setLED_A>
	leaf.clearOnAllocation = 0;
   1db8a:	2300      	movs	r3, #0
   1db8c:	616b      	str	r3, [r5, #20]
}
   1db8e:	bd38      	pop	{r3, r4, r5, pc}
   1db90:	020f7730 	.word	0x020f7730
   1db94:	020fc0a8 	.word	0x020fc0a8
   1db98:	020f8d58 	.word	0x020f8d58
   1db9c:	020fa060 	.word	0x020fa060
   1dba0:	020f9ea4 	.word	0x020f9ea4
   1dba4:	020fad84 	.word	0x020fad84
   1dba8:	020e3194 	.word	0x020e3194

0001dbac <SFXWaveFolderFrame>:
	if (buttonActionsSFX[ButtonA][ActionPress])
   1dbac:	4a07      	ldr	r2, [pc, #28]	; (1dbcc <SFXWaveFolderFrame+0x20>)
   1dbae:	7d13      	ldrb	r3, [r2, #20]
   1dbb0:	b903      	cbnz	r3, 1dbb4 <SFXWaveFolderFrame+0x8>
}
   1dbb2:	4770      	bx	lr
		foldMode = !foldMode;
   1dbb4:	4906      	ldr	r1, [pc, #24]	; (1dbd0 <SFXWaveFolderFrame+0x24>)
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1dbb6:	2000      	movs	r0, #0
		foldMode = !foldMode;
   1dbb8:	680b      	ldr	r3, [r1, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1dbba:	7510      	strb	r0, [r2, #20]
		foldMode = !foldMode;
   1dbbc:	fab3 f383 	clz	r3, r3
   1dbc0:	095b      	lsrs	r3, r3, #5
		setLED_A(foldMode);
   1dbc2:	4618      	mov	r0, r3
		foldMode = !foldMode;
   1dbc4:	600b      	str	r3, [r1, #0]
		setLED_A(foldMode);
   1dbc6:	f7fb bcb9 	b.w	1953c <setLED_A>
   1dbca:	bf00      	nop
   1dbcc:	020fb31c 	.word	0x020fb31c
   1dbd0:	020e3194 	.word	0x020e3194

0001dbd4 <SFXWaveFolderTick>:
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1dbd4:	4b3a      	ldr	r3, [pc, #232]	; (1dcc0 <SFXWaveFolderTick+0xec>)
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1dbd6:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1dbda:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
	if (foldMode == 0)
   1dbde:	4939      	ldr	r1, [pc, #228]	; (1dcc4 <SFXWaveFolderTick+0xf0>)
{
   1dbe0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1dbe4:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1dbe8:	ed93 0ae1 	vldr	s0, [r3, #900]	; 0x384
{
   1dbec:	4606      	mov	r6, r0
	displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   1dbee:	ed93 7ae3 	vldr	s14, [r3, #908]	; 0x38c
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1dbf2:	edd3 7ae2 	vldr	s15, [r3, #904]	; 0x388
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1dbf6:	ee20 0a06 	vmul.f32	s0, s0, s12
	displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   1dbfa:	ee37 7a66 	vsub.f32	s14, s14, s13
	float sample = input[1];
   1dbfe:	ed90 8a01 	vldr	s16, [r0, #4]
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1dc02:	ee77 7ae6 	vsub.f32	s15, s15, s13
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1dc06:	4c30      	ldr	r4, [pc, #192]	; (1dcc8 <SFXWaveFolderTick+0xf4>)
	displayValues[3] = presetKnobValues[Wavefolder][3];
   1dc08:	f8d3 2390 	ldr.w	r2, [r3, #912]	; 0x390
	sample = sample * gain;
   1dc0c:	ee20 8a08 	vmul.f32	s16, s0, s16
	if (foldMode == 0)
   1dc10:	680b      	ldr	r3, [r1, #0]
	displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
   1dc12:	ed84 0a00 	vstr	s0, [r4]
	displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
   1dc16:	ed84 7a02 	vstr	s14, [r4, #8]
	displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
   1dc1a:	edc4 7a01 	vstr	s15, [r4, #4]
	displayValues[3] = presetKnobValues[Wavefolder][3];
   1dc1e:	60e2      	str	r2, [r4, #12]
	if (foldMode == 0)
   1dc20:	bb93      	cbnz	r3, 1dc88 <SFXWaveFolderTick+0xb4>
   1dc22:	4d2a      	ldr	r5, [pc, #168]	; (1dccc <SFXWaveFolderTick+0xf8>)
		tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1dc24:	eeb0 0a48 	vmov.f32	s0, s16
   1dc28:	4829      	ldr	r0, [pc, #164]	; (1dcd0 <SFXWaveFolderTick+0xfc>)
   1dc2a:	4629      	mov	r1, r5
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   1dc2c:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 1dcd8 <SFXWaveFolderTick+0x104>
   1dc30:	f105 0708 	add.w	r7, r5, #8
		tOversampler_upsample(&oversampler, sample, oversamplerArray);
   1dc34:	f007 fc68 	bl	25508 <tOversampler_upsample>
			oversamplerArray[i] = sample + displayValues[1];
   1dc38:	edd4 7a01 	vldr	s15, [r4, #4]
			oversamplerArray[i] *= displayValues[0];
   1dc3c:	ed94 0a00 	vldr	s0, [r4]
			oversamplerArray[i] = sample + displayValues[1];
   1dc40:	ee78 7a27 	vadd.f32	s15, s16, s15
			oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1dc44:	ee27 0a80 	vmul.f32	s0, s15, s0
   1dc48:	f00f fb38 	bl	2d2bc <tanhf>
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   1dc4c:	4640      	mov	r0, r8
			oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1dc4e:	ed85 0a00 	vstr	s0, [r5]
			oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
   1dc52:	f007 fd61 	bl	25718 <tLockhartWavefolder_tick>
			oversamplerArray[i] = tanhf(oversamplerArray[i]);
   1dc56:	f00f fb31 	bl	2d2bc <tanhf>
   1dc5a:	eca5 0a01 	vstmia	r5!, {s0}
		for (int i = 0; i < 2; i++)
   1dc5e:	42bd      	cmp	r5, r7
   1dc60:	d1ea      	bne.n	1dc38 <SFXWaveFolderTick+0x64>
		sample = tHighpass_tick(&wfHP, tOversampler_downsample(&oversampler, oversamplerArray)) * displayValues[3];
   1dc62:	491a      	ldr	r1, [pc, #104]	; (1dccc <SFXWaveFolderTick+0xf8>)
   1dc64:	481a      	ldr	r0, [pc, #104]	; (1dcd0 <SFXWaveFolderTick+0xfc>)
   1dc66:	f007 fc99 	bl	2559c <tOversampler_downsample>
		sample = tHighpass_tick(&wfHP, sample) * displayValues[3];
   1dc6a:	481a      	ldr	r0, [pc, #104]	; (1dcd4 <SFXWaveFolderTick+0x100>)
   1dc6c:	f00a fcba 	bl	285e4 <tHighpass_tick>
   1dc70:	edd4 7a03 	vldr	s15, [r4, #12]
   1dc74:	ee20 0a27 	vmul.f32	s0, s0, s15
		input[0] = sample;
   1dc78:	ed86 0a00 	vstr	s0, [r6]
		input[1] = sample;
   1dc7c:	ed86 0a01 	vstr	s0, [r6, #4]
}
   1dc80:	ecbd 8b02 	vpop	{d8}
   1dc84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		sample = sample + displayValues[1];
   1dc88:	ee77 7a88 	vadd.f32	s15, s15, s16
		sample = LEAF_tanh(sample);
   1dc8c:	ee20 0a27 	vmul.f32	s0, s0, s15
   1dc90:	f00b fe4a 	bl	29928 <LEAF_tanh>
		sample = tLockhartWavefolder_tick(&wavefolder1, sample);
   1dc94:	4810      	ldr	r0, [pc, #64]	; (1dcd8 <SFXWaveFolderTick+0x104>)
   1dc96:	f007 fd3f 	bl	25718 <tLockhartWavefolder_tick>
		sample = sample + displayValues[2];
   1dc9a:	edd4 7a02 	vldr	s15, [r4, #8]
		sample *= displayValues[0];
   1dc9e:	ed94 7a00 	vldr	s14, [r4]
		sample = sample + displayValues[2];
   1dca2:	ee30 0a27 	vadd.f32	s0, s0, s15
		sample = LEAF_tanh(sample);
   1dca6:	ee20 0a07 	vmul.f32	s0, s0, s14
   1dcaa:	f00b fe3d 	bl	29928 <LEAF_tanh>
		sample = tLockhartWavefolder_tick(&wavefolder2, sample);
   1dcae:	480b      	ldr	r0, [pc, #44]	; (1dcdc <SFXWaveFolderTick+0x108>)
   1dcb0:	f007 fd32 	bl	25718 <tLockhartWavefolder_tick>
		sample = tOversampler_tick(&oversampler, sample, oversampleBuf, &LEAF_tanh);
   1dcb4:	4a0a      	ldr	r2, [pc, #40]	; (1dce0 <SFXWaveFolderTick+0x10c>)
   1dcb6:	490b      	ldr	r1, [pc, #44]	; (1dce4 <SFXWaveFolderTick+0x110>)
   1dcb8:	4805      	ldr	r0, [pc, #20]	; (1dcd0 <SFXWaveFolderTick+0xfc>)
   1dcba:	f007 fb9b 	bl	253f4 <tOversampler_tick>
   1dcbe:	e7d4      	b.n	1dc6a <SFXWaveFolderTick+0x96>
   1dcc0:	020f9318 	.word	0x020f9318
   1dcc4:	020e3194 	.word	0x020e3194
   1dcc8:	020fb3cc 	.word	0x020fb3cc
   1dccc:	020f9ea8 	.word	0x020f9ea8
   1dcd0:	020fad84 	.word	0x020fad84
   1dcd4:	020f9ea4 	.word	0x020f9ea4
   1dcd8:	020f8d58 	.word	0x020f8d58
   1dcdc:	020fa060 	.word	0x020fa060
   1dce0:	00029929 	.word	0x00029929
   1dce4:	020faf34 	.word	0x020faf34

0001dce8 <SFXWaveFolderFree>:
{
   1dce8:	b508      	push	{r3, lr}
	tLockhartWavefolder_free(&wavefolder1);
   1dcea:	4807      	ldr	r0, [pc, #28]	; (1dd08 <SFXWaveFolderFree+0x20>)
   1dcec:	f007 fd10 	bl	25710 <tLockhartWavefolder_free>
	tLockhartWavefolder_free(&wavefolder2);
   1dcf0:	4806      	ldr	r0, [pc, #24]	; (1dd0c <SFXWaveFolderFree+0x24>)
   1dcf2:	f007 fd0d 	bl	25710 <tLockhartWavefolder_free>
	tHighpass_free(&wfHP);
   1dcf6:	4806      	ldr	r0, [pc, #24]	; (1dd10 <SFXWaveFolderFree+0x28>)
   1dcf8:	f00a fc60 	bl	285bc <tHighpass_free>
	tOversampler_free(&oversampler);
   1dcfc:	4805      	ldr	r0, [pc, #20]	; (1dd14 <SFXWaveFolderFree+0x2c>)
}
   1dcfe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tOversampler_free(&oversampler);
   1dd02:	f007 bb67 	b.w	253d4 <tOversampler_free>
   1dd06:	bf00      	nop
   1dd08:	020f8d58 	.word	0x020f8d58
   1dd0c:	020fa060 	.word	0x020fa060
   1dd10:	020f9ea4 	.word	0x020f9ea4
   1dd14:	020fad84 	.word	0x020fad84

0001dd18 <SFXBitcrusherAlloc>:
{
   1dd18:	b510      	push	{r4, lr}
	tCrusher_initToPool(&crush, &smallPool);
   1dd1a:	4c07      	ldr	r4, [pc, #28]	; (1dd38 <SFXBitcrusherAlloc+0x20>)
   1dd1c:	4807      	ldr	r0, [pc, #28]	; (1dd3c <SFXBitcrusherAlloc+0x24>)
   1dd1e:	4621      	mov	r1, r4
   1dd20:	f007 fe12 	bl	25948 <tCrusher_initToPool>
	tCrusher_initToPool(&crush2, &smallPool);
   1dd24:	4621      	mov	r1, r4
   1dd26:	4806      	ldr	r0, [pc, #24]	; (1dd40 <SFXBitcrusherAlloc+0x28>)
   1dd28:	f007 fe0e 	bl	25948 <tCrusher_initToPool>
	setLED_A(crusherStereo);
   1dd2c:	4b05      	ldr	r3, [pc, #20]	; (1dd44 <SFXBitcrusherAlloc+0x2c>)
}
   1dd2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	setLED_A(crusherStereo);
   1dd32:	7818      	ldrb	r0, [r3, #0]
   1dd34:	f7fb bc02 	b.w	1953c <setLED_A>
   1dd38:	020f7730 	.word	0x020f7730
   1dd3c:	020f9a68 	.word	0x020f9a68
   1dd40:	020f9034 	.word	0x020f9034
   1dd44:	020e3170 	.word	0x020e3170

0001dd48 <SFXBitcrusherFrame>:
	if (buttonActionsSFX[ButtonA][ActionPress])
   1dd48:	4a07      	ldr	r2, [pc, #28]	; (1dd68 <SFXBitcrusherFrame+0x20>)
   1dd4a:	7d13      	ldrb	r3, [r2, #20]
   1dd4c:	b903      	cbnz	r3, 1dd50 <SFXBitcrusherFrame+0x8>
}
   1dd4e:	4770      	bx	lr
		crusherStereo = !crusherStereo;
   1dd50:	4906      	ldr	r1, [pc, #24]	; (1dd6c <SFXBitcrusherFrame+0x24>)
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1dd52:	2000      	movs	r0, #0
		crusherStereo = !crusherStereo;
   1dd54:	680b      	ldr	r3, [r1, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1dd56:	7510      	strb	r0, [r2, #20]
		crusherStereo = !crusherStereo;
   1dd58:	fab3 f383 	clz	r3, r3
   1dd5c:	095b      	lsrs	r3, r3, #5
		setLED_A(crusherStereo);
   1dd5e:	4618      	mov	r0, r3
		crusherStereo = !crusherStereo;
   1dd60:	600b      	str	r3, [r1, #0]
		setLED_A(crusherStereo);
   1dd62:	f7fb bbeb 	b.w	1953c <setLED_A>
   1dd66:	bf00      	nop
   1dd68:	020fb31c 	.word	0x020fb31c
   1dd6c:	020e3170 	.word	0x020e3170

0001dd70 <SFXBitcrusherTick>:
{
   1dd70:	b570      	push	{r4, r5, r6, lr}
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dd72:	4d51      	ldr	r5, [pc, #324]	; (1deb8 <SFXBitcrusherTick+0x148>)
{
   1dd74:	4606      	mov	r6, r0
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dd76:	eddf 6a51 	vldr	s13, [pc, #324]	; 1debc <SFXBitcrusherTick+0x14c>
   1dd7a:	ed95 7afa 	vldr	s14, [r5, #1000]	; 0x3e8
   1dd7e:	eddf 7a50 	vldr	s15, [pc, #320]	; 1dec0 <SFXBitcrusherTick+0x150>
   1dd82:	4c50      	ldr	r4, [pc, #320]	; (1dec4 <SFXBitcrusherTick+0x154>)
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   1dd84:	eeb0 0a47 	vmov.f32	s0, s14
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dd88:	eee7 7a26 	vfma.f32	s15, s14, s13
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   1dd8c:	484e      	ldr	r0, [pc, #312]	; (1dec8 <SFXBitcrusherTick+0x158>)
{
   1dd8e:	ed2d 8b02 	vpush	{d8}
	tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   1dd92:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1dd96:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 1decc <SFXBitcrusherTick+0x15c>
	displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
   1dd9a:	edc4 7a00 	vstr	s15, [r4]
	tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
   1dd9e:	f007 fe5b 	bl	25a58 <tCrusher_setQuality>
	tCrusher_setQuality (&crush2, presetKnobValues[BitCrusher][0]);
   1dda2:	ed95 0afa 	vldr	s0, [r5, #1000]	; 0x3e8
   1dda6:	484a      	ldr	r0, [pc, #296]	; (1ded0 <SFXBitcrusherTick+0x160>)
   1dda8:	f007 fe56 	bl	25a58 <tCrusher_setQuality>
	displayValues[1] = presetKnobValues[BitCrusher][1];
   1ddac:	edd5 7afb 	vldr	s15, [r5, #1004]	; 0x3ec
	tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   1ddb0:	4845      	ldr	r0, [pc, #276]	; (1dec8 <SFXBitcrusherTick+0x158>)
   1ddb2:	ee27 0aa8 	vmul.f32	s0, s15, s17
	displayValues[1] = presetKnobValues[BitCrusher][1];
   1ddb6:	edc4 7a01 	vstr	s15, [r4, #4]
	tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
   1ddba:	f007 fe79 	bl	25ab0 <tCrusher_setSamplingRatio>
	tCrusher_setSamplingRatio (&crush2, presetKnobValues[BitCrusher][1] * 0.5f);
   1ddbe:	ed95 0afb 	vldr	s0, [r5, #1004]	; 0x3ec
   1ddc2:	4843      	ldr	r0, [pc, #268]	; (1ded0 <SFXBitcrusherTick+0x160>)
   1ddc4:	ee20 0a28 	vmul.f32	s0, s0, s17
   1ddc8:	f007 fe72 	bl	25ab0 <tCrusher_setSamplingRatio>
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1ddcc:	edd5 7afc 	vldr	s15, [r5, #1008]	; 0x3f0
	tCrusher_setRound (&crush, displayValues[2]);
   1ddd0:	483d      	ldr	r0, [pc, #244]	; (1dec8 <SFXBitcrusherTick+0x158>)
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1ddd2:	ee67 7a88 	vmul.f32	s15, s15, s16
	tCrusher_setRound (&crush, displayValues[2]);
   1ddd6:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
   1ddda:	edc4 7a02 	vstr	s15, [r4, #8]
	tCrusher_setRound (&crush, displayValues[2]);
   1ddde:	f007 fe61 	bl	25aa4 <tCrusher_setRound>
	tCrusher_setRound (&crush2, displayValues[2]);
   1dde2:	ed94 0a02 	vldr	s0, [r4, #8]
   1dde6:	483a      	ldr	r0, [pc, #232]	; (1ded0 <SFXBitcrusherTick+0x160>)
   1dde8:	f007 fe5c 	bl	25aa4 <tCrusher_setRound>
	displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   1ddec:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   1ddf0:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
	tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   1ddf4:	4834      	ldr	r0, [pc, #208]	; (1dec8 <SFXBitcrusherTick+0x158>)
	displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
   1ddf6:	ee60 7a27 	vmul.f32	s15, s0, s15
   1ddfa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1ddfe:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1de02:	edc4 7a03 	vstr	s15, [r4, #12]
	tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
   1de06:	f007 fe1d 	bl	25a44 <tCrusher_setOperation>
	tCrusher_setOperation (&crush2, presetKnobValues[BitCrusher][3]);
   1de0a:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
   1de0e:	4830      	ldr	r0, [pc, #192]	; (1ded0 <SFXBitcrusherTick+0x160>)
   1de10:	f007 fe18 	bl	25a44 <tCrusher_setOperation>
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1de14:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1de18:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
   1de1c:	ed95 6aff 	vldr	s12, [r5, #1020]	; 0x3fc
	if (displayValues[0] < 0.1f)
   1de20:	edd4 6a00 	vldr	s13, [r4]
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1de24:	eef0 5a67 	vmov.f32	s11, s15
	displayValues[4] = presetKnobValues[BitCrusher][4];
   1de28:	f8d5 33f8 	ldr.w	r3, [r5, #1016]	; 0x3f8
	if (displayValues[0] < 0.1f)
   1de2c:	eef4 6ac8 	vcmpe.f32	s13, s16
	displayValues[4] = presetKnobValues[BitCrusher][4];
   1de30:	6123      	str	r3, [r4, #16]
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1de32:	eee6 5a07 	vfma.f32	s11, s12, s14
	if (displayValues[0] < 0.1f)
   1de36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
   1de3a:	eeb0 7a65 	vmov.f32	s14, s11
   1de3e:	edc4 5a05 	vstr	s11, [r4, #20]
	if (displayValues[0] < 0.1f)
   1de42:	d41e      	bmi.n	1de82 <SFXBitcrusherTick+0x112>
		volumeComp = (1.0f / (displayValues[3] + 1.0f));
   1de44:	edd4 6a03 	vldr	s13, [r4, #12]
   1de48:	ee76 6aa7 	vadd.f32	s13, s13, s15
   1de4c:	eec7 8aa6 	vdiv.f32	s17, s15, s13
	sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   1de50:	ed96 0a01 	vldr	s0, [r6, #4]
   1de54:	481c      	ldr	r0, [pc, #112]	; (1dec8 <SFXBitcrusherTick+0x158>)
   1de56:	ee27 0a00 	vmul.f32	s0, s14, s0
   1de5a:	f007 fdb3 	bl	259c4 <tCrusher_tick>
   1de5e:	f00f fa2d 	bl	2d2bc <tanhf>
	if (crusherStereo)
   1de62:	4b1c      	ldr	r3, [pc, #112]	; (1ded4 <SFXBitcrusherTick+0x164>)
	sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   1de64:	ee20 0a28 	vmul.f32	s0, s0, s17
   1de68:	ed94 8a04 	vldr	s16, [r4, #16]
	if (crusherStereo)
   1de6c:	681b      	ldr	r3, [r3, #0]
	sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
   1de6e:	ee20 8a08 	vmul.f32	s16, s0, s16
	if (crusherStereo)
   1de72:	b94b      	cbnz	r3, 1de88 <SFXBitcrusherTick+0x118>
		input[1] = sample;
   1de74:	ed86 8a01 	vstr	s16, [r6, #4]
	input[0] = sample;
   1de78:	ed86 8a00 	vstr	s16, [r6]
}
   1de7c:	ecbd 8b02 	vpop	{d8}
   1de80:	bd70      	pop	{r4, r5, r6, pc}
		volumeComp = 1.0f;
   1de82:	eef0 8a67 	vmov.f32	s17, s15
   1de86:	e7e3      	b.n	1de50 <SFXBitcrusherTick+0xe0>
		input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
   1de88:	edd4 7a05 	vldr	s15, [r4, #20]
   1de8c:	ed96 0a00 	vldr	s0, [r6]
   1de90:	480f      	ldr	r0, [pc, #60]	; (1ded0 <SFXBitcrusherTick+0x160>)
   1de92:	ee20 0a27 	vmul.f32	s0, s0, s15
   1de96:	f007 fd95 	bl	259c4 <tCrusher_tick>
   1de9a:	f00f fa0f 	bl	2d2bc <tanhf>
   1de9e:	edd4 7a04 	vldr	s15, [r4, #16]
	input[0] = sample;
   1dea2:	ed86 8a00 	vstr	s16, [r6]
		input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
   1dea6:	ee68 8aa7 	vmul.f32	s17, s17, s15
   1deaa:	ee68 8a80 	vmul.f32	s17, s17, s0
   1deae:	edc6 8a01 	vstr	s17, [r6, #4]
}
   1deb2:	ecbd 8b02 	vpop	{d8}
   1deb6:	bd70      	pop	{r4, r5, r6, pc}
   1deb8:	020f9318 	.word	0x020f9318
   1debc:	3f7d70a4 	.word	0x3f7d70a4
   1dec0:	3c23d70a 	.word	0x3c23d70a
   1dec4:	020fb3cc 	.word	0x020fb3cc
   1dec8:	020f9a68 	.word	0x020f9a68
   1decc:	3dcccccd 	.word	0x3dcccccd
   1ded0:	020f9034 	.word	0x020f9034
   1ded4:	020e3170 	.word	0x020e3170

0001ded8 <SFXBitcrusherFree>:
{
   1ded8:	b508      	push	{r3, lr}
	tCrusher_free(&crush);
   1deda:	4804      	ldr	r0, [pc, #16]	; (1deec <SFXBitcrusherFree+0x14>)
   1dedc:	f007 fd66 	bl	259ac <tCrusher_free>
	tCrusher_free(&crush2);
   1dee0:	4803      	ldr	r0, [pc, #12]	; (1def0 <SFXBitcrusherFree+0x18>)
}
   1dee2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tCrusher_free(&crush2);
   1dee6:	f007 bd61 	b.w	259ac <tCrusher_free>
   1deea:	bf00      	nop
   1deec:	020f9a68 	.word	0x020f9a68
   1def0:	020f9034 	.word	0x020f9034

0001def4 <SFXDelayAlloc>:
{
   1def4:	b570      	push	{r4, r5, r6, lr}
   1def6:	ed2d 8b04 	vpush	{d8-d9}
	tTapeDelay_init(&delay, 2000, 30000);
   1defa:	ed9f 9a2a 	vldr	s18, [pc, #168]	; 1dfa4 <SFXDelayAlloc+0xb0>
	leaf.clearOnAllocation = 1;
   1defe:	2501      	movs	r5, #1
   1df00:	4e29      	ldr	r6, [pc, #164]	; (1dfa8 <SFXDelayAlloc+0xb4>)
	tTapeDelay_init(&delay, 2000, 30000);
   1df02:	f247 5130 	movw	r1, #30000	; 0x7530
	tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   1df06:	ed9f 8a29 	vldr	s16, [pc, #164]	; 1dfac <SFXDelayAlloc+0xb8>
	tTapeDelay_init(&delay, 2000, 30000);
   1df0a:	eeb0 0a49 	vmov.f32	s0, s18
	tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   1df0e:	eddf 8a28 	vldr	s17, [pc, #160]	; 1dfb0 <SFXDelayAlloc+0xbc>
	delayShaper = 0;
   1df12:	2400      	movs	r4, #0
	tTapeDelay_init(&delay, 2000, 30000);
   1df14:	4827      	ldr	r0, [pc, #156]	; (1dfb4 <SFXDelayAlloc+0xc0>)
	leaf.clearOnAllocation = 1;
   1df16:	6175      	str	r5, [r6, #20]
	tTapeDelay_init(&delay, 2000, 30000);
   1df18:	f007 f8ca 	bl	250b0 <tTapeDelay_init>
	tTapeDelay_init(&delay2, 2000, 30000);
   1df1c:	eeb0 0a49 	vmov.f32	s0, s18
   1df20:	f247 5130 	movw	r1, #30000	; 0x7530
   1df24:	4824      	ldr	r0, [pc, #144]	; (1dfb8 <SFXDelayAlloc+0xc4>)
   1df26:	f007 f8c3 	bl	250b0 <tTapeDelay_init>
	tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
   1df2a:	eef0 0a48 	vmov.f32	s1, s16
   1df2e:	eeb0 0a68 	vmov.f32	s0, s17
   1df32:	4629      	mov	r1, r5
   1df34:	4821      	ldr	r0, [pc, #132]	; (1dfbc <SFXDelayAlloc+0xc8>)
   1df36:	f00a f951 	bl	281dc <tSVF_init>
	tSVF_init(&delayHP, SVFTypeHighpass, 20.f, .7f);
   1df3a:	eef0 0a48 	vmov.f32	s1, s16
   1df3e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1df42:	4621      	mov	r1, r4
   1df44:	481e      	ldr	r0, [pc, #120]	; (1dfc0 <SFXDelayAlloc+0xcc>)
   1df46:	f00a f949 	bl	281dc <tSVF_init>
	tSVF_init(&delayLP2, SVFTypeLowpass, 16000.f, .7f);
   1df4a:	eef0 0a48 	vmov.f32	s1, s16
   1df4e:	eeb0 0a68 	vmov.f32	s0, s17
   1df52:	4629      	mov	r1, r5
   1df54:	481b      	ldr	r0, [pc, #108]	; (1dfc4 <SFXDelayAlloc+0xd0>)
   1df56:	f00a f941 	bl	281dc <tSVF_init>
	tSVF_init(&delayHP2, SVFTypeHighpass, 20.f, .7f);
   1df5a:	eef0 0a48 	vmov.f32	s1, s16
   1df5e:	4621      	mov	r1, r4
   1df60:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1df64:	4818      	ldr	r0, [pc, #96]	; (1dfc8 <SFXDelayAlloc+0xd4>)
   1df66:	f00a f939 	bl	281dc <tSVF_init>
	tHighpass_init(&delayShaperHp, 20.0f);
   1df6a:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1df6e:	4817      	ldr	r0, [pc, #92]	; (1dfcc <SFXDelayAlloc+0xd8>)
   1df70:	f00a fae4 	bl	2853c <tHighpass_init>
	tFeedbackLeveler_init(&feedbackControl, .99f, 0.01, 0.125f, 0);
   1df74:	4621      	mov	r1, r4
   1df76:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
   1df7a:	eddf 0a15 	vldr	s1, [pc, #84]	; 1dfd0 <SFXDelayAlloc+0xdc>
   1df7e:	ed9f 0a15 	vldr	s0, [pc, #84]	; 1dfd4 <SFXDelayAlloc+0xe0>
   1df82:	4815      	ldr	r0, [pc, #84]	; (1dfd8 <SFXDelayAlloc+0xe4>)
   1df84:	f007 fdaa 	bl	25adc <tFeedbackLeveler_init>
	capFeedback = 1;
   1df88:	4b14      	ldr	r3, [pc, #80]	; (1dfdc <SFXDelayAlloc+0xe8>)
	delayShaper = 0;
   1df8a:	4a15      	ldr	r2, [pc, #84]	; (1dfe0 <SFXDelayAlloc+0xec>)
	setLED_A(delayShaper);
   1df8c:	4620      	mov	r0, r4
	capFeedback = 1;
   1df8e:	701d      	strb	r5, [r3, #0]
	freeze = 0;
   1df90:	4b14      	ldr	r3, [pc, #80]	; (1dfe4 <SFXDelayAlloc+0xf0>)
	delayShaper = 0;
   1df92:	6014      	str	r4, [r2, #0]
	freeze = 0;
   1df94:	601c      	str	r4, [r3, #0]
	setLED_A(delayShaper);
   1df96:	f7fb fad1 	bl	1953c <setLED_A>
	leaf.clearOnAllocation = 0;
   1df9a:	6174      	str	r4, [r6, #20]
}
   1df9c:	ecbd 8b04 	vpop	{d8-d9}
   1dfa0:	bd70      	pop	{r4, r5, r6, pc}
   1dfa2:	bf00      	nop
   1dfa4:	44fa0000 	.word	0x44fa0000
   1dfa8:	020fc0a8 	.word	0x020fc0a8
   1dfac:	3f333333 	.word	0x3f333333
   1dfb0:	467a0000 	.word	0x467a0000
   1dfb4:	020fa3b8 	.word	0x020fa3b8
   1dfb8:	020f9c60 	.word	0x020f9c60
   1dfbc:	020fa2d4 	.word	0x020fa2d4
   1dfc0:	020f9f18 	.word	0x020f9f18
   1dfc4:	020fa24c 	.word	0x020fa24c
   1dfc8:	020fa160 	.word	0x020fa160
   1dfcc:	020fa148 	.word	0x020fa148
   1dfd0:	3c23d70a 	.word	0x3c23d70a
   1dfd4:	3f7d70a4 	.word	0x3f7d70a4
   1dfd8:	020f9f80 	.word	0x020f9f80
   1dfdc:	020e3130 	.word	0x020e3130
   1dfe0:	020e3180 	.word	0x020e3180
   1dfe4:	020e3198 	.word	0x020e3198

0001dfe8 <SFXDelayFrame>:
{
   1dfe8:	b510      	push	{r4, lr}
	if (buttonActionsSFX[ButtonA][ActionPress])
   1dfea:	4c14      	ldr	r4, [pc, #80]	; (1e03c <SFXDelayFrame+0x54>)
   1dfec:	7d23      	ldrb	r3, [r4, #20]
   1dfee:	b9cb      	cbnz	r3, 1e024 <SFXDelayFrame+0x3c>
	if (buttonActionsSFX[ButtonB][ActionPress])
   1dff0:	7e23      	ldrb	r3, [r4, #24]
   1dff2:	b13b      	cbz	r3, 1e004 <SFXDelayFrame+0x1c>
		capFeedback = !capFeedback;
   1dff4:	4a12      	ldr	r2, [pc, #72]	; (1e040 <SFXDelayFrame+0x58>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1dff6:	2100      	movs	r1, #0
		capFeedback = !capFeedback;
   1dff8:	7813      	ldrb	r3, [r2, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1dffa:	7621      	strb	r1, [r4, #24]
		capFeedback = !capFeedback;
   1dffc:	fab3 f383 	clz	r3, r3
   1e000:	095b      	lsrs	r3, r3, #5
   1e002:	7013      	strb	r3, [r2, #0]
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e004:	7f23      	ldrb	r3, [r4, #28]
   1e006:	b903      	cbnz	r3, 1e00a <SFXDelayFrame+0x22>
}
   1e008:	bd10      	pop	{r4, pc}
		freeze = !freeze;
   1e00a:	4a0e      	ldr	r2, [pc, #56]	; (1e044 <SFXDelayFrame+0x5c>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e00c:	2100      	movs	r1, #0
		freeze = !freeze;
   1e00e:	6813      	ldr	r3, [r2, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e010:	7721      	strb	r1, [r4, #28]
		freeze = !freeze;
   1e012:	fab3 f383 	clz	r3, r3
   1e016:	095b      	lsrs	r3, r3, #5
   1e018:	6013      	str	r3, [r2, #0]
		setLED_C(freeze);
   1e01a:	4618      	mov	r0, r3
}
   1e01c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		setLED_C(freeze);
   1e020:	f7fb baa8 	b.w	19574 <setLED_C>
		delayShaper = !delayShaper;
   1e024:	4a08      	ldr	r2, [pc, #32]	; (1e048 <SFXDelayFrame+0x60>)
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e026:	2100      	movs	r1, #0
		delayShaper = !delayShaper;
   1e028:	6813      	ldr	r3, [r2, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e02a:	7521      	strb	r1, [r4, #20]
		delayShaper = !delayShaper;
   1e02c:	fab3 f383 	clz	r3, r3
   1e030:	095b      	lsrs	r3, r3, #5
		setLED_A(delayShaper);
   1e032:	4618      	mov	r0, r3
		delayShaper = !delayShaper;
   1e034:	6013      	str	r3, [r2, #0]
		setLED_A(delayShaper);
   1e036:	f7fb fa81 	bl	1953c <setLED_A>
   1e03a:	e7d9      	b.n	1dff0 <SFXDelayFrame+0x8>
   1e03c:	020fb31c 	.word	0x020fb31c
   1e040:	020e3130 	.word	0x020e3130
   1e044:	020e3198 	.word	0x020e3198
   1e048:	020e3180 	.word	0x020e3180

0001e04c <SFXDelayTick>:
{
   1e04c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1e04e:	4d88      	ldr	r5, [pc, #544]	; (1e270 <SFXDelayTick+0x224>)
{
   1e050:	4607      	mov	r7, r0
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1e052:	eddf 6a88 	vldr	s13, [pc, #544]	; 1e274 <SFXDelayTick+0x228>
   1e056:	462b      	mov	r3, r5
   1e058:	4c87      	ldr	r4, [pc, #540]	; (1e278 <SFXDelayTick+0x22c>)
{
   1e05a:	ed2d 8b02 	vpush	{d8}
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1e05e:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1e062:	ecb3 7a01 	vldmia	r3!, {s14}
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1e066:	edd5 7a02 	vldr	s15, [r5, #8]
   1e06a:	eddf 8a84 	vldr	s17, [pc, #528]	; 1e27c <SFXDelayTick+0x230>
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1e06e:	ee27 7a26 	vmul.f32	s14, s14, s13
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1e072:	eeb0 0a48 	vmov.f32	s0, s16
	displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
   1e076:	ed84 7a00 	vstr	s14, [r4]
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1e07a:	eea7 0aa8 	vfma.f32	s0, s15, s17
	displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
   1e07e:	edd3 7a00 	vldr	s15, [r3]
   1e082:	ee67 7aa6 	vmul.f32	s15, s15, s13
   1e086:	edc4 7a01 	vstr	s15, [r4, #4]
	displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
   1e08a:	f00b fd6b 	bl	29b64 <faster_mtof>
   1e08e:	ed84 0a02 	vstr	s0, [r4, #8]
	displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
   1e092:	eeb0 0a48 	vmov.f32	s0, s16
   1e096:	edd5 7a03 	vldr	s15, [r5, #12]
   1e09a:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1e09e:	f00b fd61 	bl	29b64 <faster_mtof>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e0a2:	4b77      	ldr	r3, [pc, #476]	; (1e280 <SFXDelayTick+0x234>)
	displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
   1e0a4:	ed84 0a03 	vstr	s0, [r4, #12]
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e0a8:	781b      	ldrb	r3, [r3, #0]
   1e0aa:	2b00      	cmp	r3, #0
   1e0ac:	f040 80d1 	bne.w	1e252 <SFXDelayTick+0x206>
   1e0b0:	edd5 7a04 	vldr	s15, [r5, #16]
   1e0b4:	ed9f 7a73 	vldr	s14, [pc, #460]	; 1e284 <SFXDelayTick+0x238>
   1e0b8:	ee67 7a87 	vmul.f32	s15, s15, s14
	displayValues[5] = presetKnobValues[Delay][5];
   1e0bc:	4b72      	ldr	r3, [pc, #456]	; (1e288 <SFXDelayTick+0x23c>)
	tSVF_setFreq(&delayHP, displayValues[2]);
   1e0be:	ed94 0a02 	vldr	s0, [r4, #8]
	displayValues[5] = presetKnobValues[Delay][5];
   1e0c2:	681b      	ldr	r3, [r3, #0]
	tSVF_setFreq(&delayHP, displayValues[2]);
   1e0c4:	4871      	ldr	r0, [pc, #452]	; (1e28c <SFXDelayTick+0x240>)
	displayValues[5] = presetKnobValues[Delay][5];
   1e0c6:	6163      	str	r3, [r4, #20]
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e0c8:	edc4 7a04 	vstr	s15, [r4, #16]
	tSVF_setFreq(&delayHP, displayValues[2]);
   1e0cc:	f00a f93a 	bl	28344 <tSVF_setFreq>
	tSVF_setFreq(&delayHP2, displayValues[2]);
   1e0d0:	ed94 0a02 	vldr	s0, [r4, #8]
   1e0d4:	486e      	ldr	r0, [pc, #440]	; (1e290 <SFXDelayTick+0x244>)
   1e0d6:	f00a f935 	bl	28344 <tSVF_setFreq>
	tSVF_setFreq(&delayLP, displayValues[3]);
   1e0da:	ed94 0a03 	vldr	s0, [r4, #12]
   1e0de:	486d      	ldr	r0, [pc, #436]	; (1e294 <SFXDelayTick+0x248>)
   1e0e0:	f00a f930 	bl	28344 <tSVF_setFreq>
	tSVF_setFreq(&delayLP2, displayValues[3]);
   1e0e4:	ed94 0a03 	vldr	s0, [r4, #12]
   1e0e8:	486b      	ldr	r0, [pc, #428]	; (1e298 <SFXDelayTick+0x24c>)
   1e0ea:	f00a f92b 	bl	28344 <tSVF_setFreq>
	if (delayShaper == 0)
   1e0ee:	4b6b      	ldr	r3, [pc, #428]	; (1e29c <SFXDelayTick+0x250>)
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e0f0:	4e6b      	ldr	r6, [pc, #428]	; (1e2a0 <SFXDelayTick+0x254>)
	if (delayShaper == 0)
   1e0f2:	681b      	ldr	r3, [r3, #0]
   1e0f4:	2b00      	cmp	r3, #0
   1e0f6:	d16d      	bne.n	1e1d4 <SFXDelayTick+0x188>
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e0f8:	ed94 7a04 	vldr	s14, [r4, #16]
   1e0fc:	edd6 7a00 	vldr	s15, [r6]
   1e100:	ed97 0a01 	vldr	s0, [r7, #4]
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   1e104:	4d67      	ldr	r5, [pc, #412]	; (1e2a4 <SFXDelayTick+0x258>)
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e106:	eea7 0a27 	vfma.f32	s0, s14, s15
   1e10a:	f00f f8d7 	bl	2d2bc <tanhf>
   1e10e:	4866      	ldr	r0, [pc, #408]	; (1e2a8 <SFXDelayTick+0x25c>)
   1e110:	f007 fd46 	bl	25ba0 <tFeedbackLeveler_tick>
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   1e114:	edd5 7a00 	vldr	s15, [r5]
   1e118:	ed94 7a04 	vldr	s14, [r4, #16]
		input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
   1e11c:	eef0 8a40 	vmov.f32	s17, s0
		input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
   1e120:	ed97 0a01 	vldr	s0, [r7, #4]
   1e124:	eea7 0a27 	vfma.f32	s0, s14, s15
   1e128:	f00f f8c8 	bl	2d2bc <tanhf>
   1e12c:	485e      	ldr	r0, [pc, #376]	; (1e2a8 <SFXDelayTick+0x25c>)
   1e12e:	f007 fd37 	bl	25ba0 <tFeedbackLeveler_tick>
   1e132:	eeb0 8a40 	vmov.f32	s16, s0
	tTapeDelay_setDelay(&delay, displayValues[0]);
   1e136:	ed94 0a00 	vldr	s0, [r4]
   1e13a:	485c      	ldr	r0, [pc, #368]	; (1e2ac <SFXDelayTick+0x260>)
   1e13c:	f007 f8a0 	bl	25280 <tTapeDelay_setDelay>
	tTapeDelay_setDelay(&delay2, displayValues[1]);
   1e140:	ed94 0a01 	vldr	s0, [r4, #4]
   1e144:	485a      	ldr	r0, [pc, #360]	; (1e2b0 <SFXDelayTick+0x264>)
   1e146:	f007 f89b 	bl	25280 <tTapeDelay_setDelay>
	if (!freeze)
   1e14a:	4b5a      	ldr	r3, [pc, #360]	; (1e2b4 <SFXDelayTick+0x268>)
   1e14c:	681b      	ldr	r3, [r3, #0]
   1e14e:	2b00      	cmp	r3, #0
   1e150:	d070      	beq.n	1e234 <SFXDelayTick+0x1e8>
		delayFB1 = tTapeDelay_tick(&delay, delayFB1);
   1e152:	4856      	ldr	r0, [pc, #344]	; (1e2ac <SFXDelayTick+0x260>)
   1e154:	ed96 0a00 	vldr	s0, [r6]
   1e158:	f007 f81c 	bl	25194 <tTapeDelay_tick>
		delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
   1e15c:	4854      	ldr	r0, [pc, #336]	; (1e2b0 <SFXDelayTick+0x264>)
		delayFB1 = tTapeDelay_tick(&delay, delayFB1);
   1e15e:	ed86 0a00 	vstr	s0, [r6]
		delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
   1e162:	ed95 0a00 	vldr	s0, [r5]
   1e166:	f007 f815 	bl	25194 <tTapeDelay_tick>
   1e16a:	ed85 0a00 	vstr	s0, [r5]
	delayFB1 = tSVF_tick(&delayLP, delayFB1);
   1e16e:	4849      	ldr	r0, [pc, #292]	; (1e294 <SFXDelayTick+0x248>)
   1e170:	ed96 0a00 	vldr	s0, [r6]
   1e174:	f00a f8b0 	bl	282d8 <tSVF_tick>
	delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   1e178:	4847      	ldr	r0, [pc, #284]	; (1e298 <SFXDelayTick+0x24c>)
	delayFB1 = tSVF_tick(&delayLP, delayFB1);
   1e17a:	ed86 0a00 	vstr	s0, [r6]
	delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   1e17e:	ed95 0a00 	vldr	s0, [r5]
   1e182:	f00a f8a9 	bl	282d8 <tSVF_tick>
	delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   1e186:	4841      	ldr	r0, [pc, #260]	; (1e28c <SFXDelayTick+0x240>)
	delayFB2 = tSVF_tick(&delayLP2, delayFB2);
   1e188:	ed85 0a00 	vstr	s0, [r5]
	delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   1e18c:	ed96 0a00 	vldr	s0, [r6]
   1e190:	f00a f8a2 	bl	282d8 <tSVF_tick>
   1e194:	f00f f892 	bl	2d2bc <tanhf>
	delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   1e198:	483d      	ldr	r0, [pc, #244]	; (1e290 <SFXDelayTick+0x244>)
	delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
   1e19a:	ed86 0a00 	vstr	s0, [r6]
	delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   1e19e:	ed95 0a00 	vldr	s0, [r5]
   1e1a2:	f00a f899 	bl	282d8 <tSVF_tick>
   1e1a6:	f00f f889 	bl	2d2bc <tanhf>
	input[0] = delayFB1 * displayValues[5];
   1e1aa:	edd4 7a05 	vldr	s15, [r4, #20]
   1e1ae:	ed96 7a00 	vldr	s14, [r6]
	delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
   1e1b2:	ed85 0a00 	vstr	s0, [r5]
	input[0] = delayFB1 * displayValues[5];
   1e1b6:	ee67 7a87 	vmul.f32	s15, s15, s14
   1e1ba:	edc7 7a00 	vstr	s15, [r7]
	input[1] = delayFB2 * displayValues[5];
   1e1be:	edd4 7a05 	vldr	s15, [r4, #20]
   1e1c2:	ed95 7a00 	vldr	s14, [r5]
   1e1c6:	ee67 7a87 	vmul.f32	s15, s15, s14
   1e1ca:	edc7 7a01 	vstr	s15, [r7, #4]
}
   1e1ce:	ecbd 8b02 	vpop	{d8}
   1e1d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   1e1d4:	ed96 7a00 	vldr	s14, [r6]
   1e1d8:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
   1e1dc:	edd4 7a04 	vldr	s15, [r4, #16]
   1e1e0:	ed97 0a01 	vldr	s0, [r7, #4]
   1e1e4:	ee67 7a87 	vmul.f32	s15, s15, s14
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   1e1e8:	4d2e      	ldr	r5, [pc, #184]	; (1e2a4 <SFXDelayTick+0x258>)
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   1e1ea:	eef0 0a48 	vmov.f32	s1, s16
   1e1ee:	eea7 0a88 	vfma.f32	s0, s15, s16
   1e1f2:	f00b faef 	bl	297d4 <LEAF_shaper>
   1e1f6:	4830      	ldr	r0, [pc, #192]	; (1e2b8 <SFXDelayTick+0x26c>)
   1e1f8:	f00a f9f4 	bl	285e4 <tHighpass_tick>
   1e1fc:	482a      	ldr	r0, [pc, #168]	; (1e2a8 <SFXDelayTick+0x25c>)
   1e1fe:	f007 fccf 	bl	25ba0 <tFeedbackLeveler_tick>
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   1e202:	ed95 7a00 	vldr	s14, [r5]
   1e206:	edd4 7a04 	vldr	s15, [r4, #16]
		input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
   1e20a:	eef0 8a40 	vmov.f32	s17, s0
		input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
   1e20e:	ed97 0a01 	vldr	s0, [r7, #4]
   1e212:	eef0 0a48 	vmov.f32	s1, s16
   1e216:	ee67 7a87 	vmul.f32	s15, s15, s14
   1e21a:	eea7 0a88 	vfma.f32	s0, s15, s16
   1e21e:	f00b fad9 	bl	297d4 <LEAF_shaper>
   1e222:	4825      	ldr	r0, [pc, #148]	; (1e2b8 <SFXDelayTick+0x26c>)
   1e224:	f00a f9de 	bl	285e4 <tHighpass_tick>
   1e228:	481f      	ldr	r0, [pc, #124]	; (1e2a8 <SFXDelayTick+0x25c>)
   1e22a:	f007 fcb9 	bl	25ba0 <tFeedbackLeveler_tick>
   1e22e:	eeb0 8a40 	vmov.f32	s16, s0
   1e232:	e780      	b.n	1e136 <SFXDelayTick+0xea>
		delayFB1 = tTapeDelay_tick(&delay, input1);
   1e234:	481d      	ldr	r0, [pc, #116]	; (1e2ac <SFXDelayTick+0x260>)
   1e236:	eeb0 0a68 	vmov.f32	s0, s17
   1e23a:	f006 ffab 	bl	25194 <tTapeDelay_tick>
		delayFB2 = tTapeDelay_tick(&delay2, input2);
   1e23e:	481c      	ldr	r0, [pc, #112]	; (1e2b0 <SFXDelayTick+0x264>)
		delayFB1 = tTapeDelay_tick(&delay, input1);
   1e240:	ed86 0a00 	vstr	s0, [r6]
		delayFB2 = tTapeDelay_tick(&delay2, input2);
   1e244:	eeb0 0a48 	vmov.f32	s0, s16
   1e248:	f006 ffa4 	bl	25194 <tTapeDelay_tick>
   1e24c:	ed85 0a00 	vstr	s0, [r5]
   1e250:	e78d      	b.n	1e16e <SFXDelayTick+0x122>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
   1e252:	eddf 7a0c 	vldr	s15, [pc, #48]	; 1e284 <SFXDelayTick+0x238>
   1e256:	edd5 0a04 	vldr	s1, [r5, #16]
   1e25a:	ed9f 1a18 	vldr	s2, [pc, #96]	; 1e2bc <SFXDelayTick+0x270>
   1e25e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   1e262:	ed9f 0a17 	vldr	s0, [pc, #92]	; 1e2c0 <SFXDelayTick+0x274>
   1e266:	f00b fb0f 	bl	29888 <LEAF_clip>
   1e26a:	eef0 7a40 	vmov.f32	s15, s0
   1e26e:	e725      	b.n	1e0bc <SFXDelayTick+0x70>
   1e270:	020f9764 	.word	0x020f9764
   1e274:	46ea6000 	.word	0x46ea6000
   1e278:	020fb3cc 	.word	0x020fb3cc
   1e27c:	43000000 	.word	0x43000000
   1e280:	020e3130 	.word	0x020e3130
   1e284:	3f8ccccd 	.word	0x3f8ccccd
   1e288:	020f9778 	.word	0x020f9778
   1e28c:	020f9f18 	.word	0x020f9f18
   1e290:	020fa160 	.word	0x020fa160
   1e294:	020fa2d4 	.word	0x020fa2d4
   1e298:	020fa24c 	.word	0x020fa24c
   1e29c:	020e3180 	.word	0x020e3180
   1e2a0:	020fa158 	.word	0x020fa158
   1e2a4:	020fae6c 	.word	0x020fae6c
   1e2a8:	020f9f80 	.word	0x020f9f80
   1e2ac:	020fa3b8 	.word	0x020fa3b8
   1e2b0:	020f9c60 	.word	0x020f9c60
   1e2b4:	020e3198 	.word	0x020e3198
   1e2b8:	020fa148 	.word	0x020fa148
   1e2bc:	3f666666 	.word	0x3f666666
   1e2c0:	00000000 	.word	0x00000000

0001e2c4 <SFXDelayFree>:
{
   1e2c4:	b508      	push	{r3, lr}
	tTapeDelay_free(&delay);
   1e2c6:	480d      	ldr	r0, [pc, #52]	; (1e2fc <SFXDelayFree+0x38>)
   1e2c8:	f006 ff58 	bl	2517c <tTapeDelay_free>
	tTapeDelay_free(&delay2);
   1e2cc:	480c      	ldr	r0, [pc, #48]	; (1e300 <SFXDelayFree+0x3c>)
   1e2ce:	f006 ff55 	bl	2517c <tTapeDelay_free>
	tSVF_free(&delayLP);
   1e2d2:	480c      	ldr	r0, [pc, #48]	; (1e304 <SFXDelayFree+0x40>)
   1e2d4:	f009 fffc 	bl	282d0 <tSVF_free>
	tSVF_free(&delayHP);
   1e2d8:	480b      	ldr	r0, [pc, #44]	; (1e308 <SFXDelayFree+0x44>)
   1e2da:	f009 fff9 	bl	282d0 <tSVF_free>
	tSVF_free(&delayLP2);
   1e2de:	480b      	ldr	r0, [pc, #44]	; (1e30c <SFXDelayFree+0x48>)
   1e2e0:	f009 fff6 	bl	282d0 <tSVF_free>
	tSVF_free(&delayHP2);
   1e2e4:	480a      	ldr	r0, [pc, #40]	; (1e310 <SFXDelayFree+0x4c>)
   1e2e6:	f009 fff3 	bl	282d0 <tSVF_free>
	tHighpass_free(&delayShaperHp);
   1e2ea:	480a      	ldr	r0, [pc, #40]	; (1e314 <SFXDelayFree+0x50>)
   1e2ec:	f00a f966 	bl	285bc <tHighpass_free>
	tFeedbackLeveler_free(&feedbackControl);
   1e2f0:	4809      	ldr	r0, [pc, #36]	; (1e318 <SFXDelayFree+0x54>)
}
   1e2f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tFeedbackLeveler_free(&feedbackControl);
   1e2f6:	f007 bc43 	b.w	25b80 <tFeedbackLeveler_free>
   1e2fa:	bf00      	nop
   1e2fc:	020fa3b8 	.word	0x020fa3b8
   1e300:	020f9c60 	.word	0x020f9c60
   1e304:	020fa2d4 	.word	0x020fa2d4
   1e308:	020f9f18 	.word	0x020f9f18
   1e30c:	020fa24c 	.word	0x020fa24c
   1e310:	020fa160 	.word	0x020fa160
   1e314:	020fa148 	.word	0x020fa148
   1e318:	020f9f80 	.word	0x020f9f80

0001e31c <SFXReverbAlloc>:
{
   1e31c:	b570      	push	{r4, r5, r6, lr}
	tDattorroReverb_init(&reverb);
   1e31e:	4e0d      	ldr	r6, [pc, #52]	; (1e354 <SFXReverbAlloc+0x38>)
	leaf.clearOnAllocation = 1;
   1e320:	2501      	movs	r5, #1
   1e322:	4c0d      	ldr	r4, [pc, #52]	; (1e358 <SFXReverbAlloc+0x3c>)
	tDattorroReverb_init(&reverb);
   1e324:	4630      	mov	r0, r6
	leaf.clearOnAllocation = 1;
   1e326:	6165      	str	r5, [r4, #20]
	tDattorroReverb_init(&reverb);
   1e328:	f00d f9b4 	bl	2b694 <tDattorroReverb_init>
	tExpSmooth_init(&sizeSmoother, 0.5f, 0.001f);
   1e32c:	eddf 0a0b 	vldr	s1, [pc, #44]	; 1e35c <SFXReverbAlloc+0x40>
   1e330:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
   1e334:	480a      	ldr	r0, [pc, #40]	; (1e360 <SFXReverbAlloc+0x44>)
   1e336:	f009 fdad 	bl	27e94 <tExpSmooth_init>
	tDattorroReverb_setMix(&reverb, 1.0f);
   1e33a:	4630      	mov	r0, r6
   1e33c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e340:	f00d fbae 	bl	2baa0 <tDattorroReverb_setMix>
	freeze = 0;
   1e344:	2300      	movs	r3, #0
	capFeedback = 1;
   1e346:	4907      	ldr	r1, [pc, #28]	; (1e364 <SFXReverbAlloc+0x48>)
	freeze = 0;
   1e348:	4a07      	ldr	r2, [pc, #28]	; (1e368 <SFXReverbAlloc+0x4c>)
	capFeedback = 1;
   1e34a:	700d      	strb	r5, [r1, #0]
	leaf.clearOnAllocation = 0;
   1e34c:	6163      	str	r3, [r4, #20]
	freeze = 0;
   1e34e:	6013      	str	r3, [r2, #0]
}
   1e350:	bd70      	pop	{r4, r5, r6, pc}
   1e352:	bf00      	nop
   1e354:	020f9250 	.word	0x020f9250
   1e358:	020fc0a8 	.word	0x020fc0a8
   1e35c:	3a83126f 	.word	0x3a83126f
   1e360:	020fad78 	.word	0x020fad78
   1e364:	020e3130 	.word	0x020e3130
   1e368:	020e3198 	.word	0x020e3198

0001e36c <SFXReverbFrame>:
	if (buttonActionsSFX[ButtonB][ActionPress])
   1e36c:	4a1c      	ldr	r2, [pc, #112]	; (1e3e0 <SFXReverbFrame+0x74>)
{
   1e36e:	b570      	push	{r4, r5, r6, lr}
   1e370:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonB][ActionPress])
   1e374:	7e13      	ldrb	r3, [r2, #24]
   1e376:	b13b      	cbz	r3, 1e388 <SFXReverbFrame+0x1c>
		capFeedback = !capFeedback;
   1e378:	491a      	ldr	r1, [pc, #104]	; (1e3e4 <SFXReverbFrame+0x78>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1e37a:	2000      	movs	r0, #0
		capFeedback = !capFeedback;
   1e37c:	780b      	ldrb	r3, [r1, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1e37e:	7610      	strb	r0, [r2, #24]
		capFeedback = !capFeedback;
   1e380:	fab3 f383 	clz	r3, r3
   1e384:	095b      	lsrs	r3, r3, #5
   1e386:	700b      	strb	r3, [r1, #0]
	displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
   1e388:	4e17      	ldr	r6, [pc, #92]	; (1e3e8 <SFXReverbFrame+0x7c>)
   1e38a:	ed9f 8a18 	vldr	s16, [pc, #96]	; 1e3ec <SFXReverbFrame+0x80>
   1e38e:	4635      	mov	r5, r6
   1e390:	4c17      	ldr	r4, [pc, #92]	; (1e3f0 <SFXReverbFrame+0x84>)
   1e392:	ecb5 0a01 	vldmia	r5!, {s0}
   1e396:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e39a:	f00b fbe3 	bl	29b64 <faster_mtof>
	tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
   1e39e:	4815      	ldr	r0, [pc, #84]	; (1e3f4 <SFXReverbFrame+0x88>)
	displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
   1e3a0:	ed84 0a01 	vstr	s0, [r4, #4]
	tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
   1e3a4:	f00d fc64 	bl	2bc70 <tDattorroReverb_setFeedbackFilter>
	displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
   1e3a8:	eddf 7a13 	vldr	s15, [pc, #76]	; 1e3f8 <SFXReverbFrame+0x8c>
   1e3ac:	ed95 0a00 	vldr	s0, [r5]
   1e3b0:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e3b4:	f00b fbd6 	bl	29b64 <faster_mtof>
	tDattorroReverb_setHP(&reverb, displayValues[2]);
   1e3b8:	480e      	ldr	r0, [pc, #56]	; (1e3f4 <SFXReverbFrame+0x88>)
	displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
   1e3ba:	ed84 0a02 	vstr	s0, [r4, #8]
	tDattorroReverb_setHP(&reverb, displayValues[2]);
   1e3be:	f00d fbbd 	bl	2bb3c <tDattorroReverb_setHP>
	displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
   1e3c2:	ed96 0a02 	vldr	s0, [r6, #8]
   1e3c6:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e3ca:	f00b fbcb 	bl	29b64 <faster_mtof>
	tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   1e3ce:	4809      	ldr	r0, [pc, #36]	; (1e3f4 <SFXReverbFrame+0x88>)
	displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
   1e3d0:	ed84 0a03 	vstr	s0, [r4, #12]
}
   1e3d4:	ecbd 8b02 	vpop	{d8}
   1e3d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
   1e3dc:	f00d bc32 	b.w	2bc44 <tDattorroReverb_setInputFilter>
   1e3e0:	020fb31c 	.word	0x020fb31c
   1e3e4:	020e3130 	.word	0x020e3130
   1e3e8:	020f97cc 	.word	0x020f97cc
   1e3ec:	43010000 	.word	0x43010000
   1e3f0:	020fb3cc 	.word	0x020fb3cc
   1e3f4:	020f9250 	.word	0x020f9250
   1e3f8:	42f60000 	.word	0x42f60000

0001e3fc <SFXReverbTick>:
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e3fc:	4b34      	ldr	r3, [pc, #208]	; (1e4d0 <SFXReverbTick+0xd4>)
{
   1e3fe:	b570      	push	{r4, r5, r6, lr}
   1e400:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e404:	7f1a      	ldrb	r2, [r3, #28]
{
   1e406:	b082      	sub	sp, #8
   1e408:	4604      	mov	r4, r0
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e40a:	2a00      	cmp	r2, #0
   1e40c:	d144      	bne.n	1e498 <SFXReverbTick+0x9c>
	input[1] *= 4.0f;
   1e40e:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
   1e412:	edd4 7a01 	vldr	s15, [r4, #4]
	displayValues[0] = presetKnobValues[Reverb][0];
   1e416:	4e2f      	ldr	r6, [pc, #188]	; (1e4d4 <SFXReverbTick+0xd8>)
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e418:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 1e4d8 <SFXReverbTick+0xdc>
	input[1] *= 4.0f;
   1e41c:	ee67 7aa6 	vmul.f32	s15, s15, s13
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e420:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 1e4dc <SFXReverbTick+0xe0>
	displayValues[0] = presetKnobValues[Reverb][0];
   1e424:	4d2e      	ldr	r5, [pc, #184]	; (1e4e0 <SFXReverbTick+0xe4>)
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e426:	482f      	ldr	r0, [pc, #188]	; (1e4e4 <SFXReverbTick+0xe8>)
	input[1] *= 4.0f;
   1e428:	edc4 7a01 	vstr	s15, [r4, #4]
	displayValues[0] = presetKnobValues[Reverb][0];
   1e42c:	edd6 7a00 	vldr	s15, [r6]
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e430:	eea7 0a87 	vfma.f32	s0, s15, s14
	displayValues[0] = presetKnobValues[Reverb][0];
   1e434:	edc5 7a00 	vstr	s15, [r5]
	tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
   1e438:	f009 fd92 	bl	27f60 <tExpSmooth_setDest>
	float tempSize = tExpSmooth_tick(&sizeSmoother);
   1e43c:	4829      	ldr	r0, [pc, #164]	; (1e4e4 <SFXReverbTick+0xe8>)
   1e43e:	f009 fd99 	bl	27f74 <tExpSmooth_tick>
	tDattorroReverb_setSize(&reverb, tempSize);
   1e442:	4829      	ldr	r0, [pc, #164]	; (1e4e8 <SFXReverbTick+0xec>)
   1e444:	f00d fb98 	bl	2bb78 <tDattorroReverb_setSize>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   1e448:	4b28      	ldr	r3, [pc, #160]	; (1e4ec <SFXReverbTick+0xf0>)
   1e44a:	781b      	ldrb	r3, [r3, #0]
   1e44c:	bba3      	cbnz	r3, 1e4b8 <SFXReverbTick+0xbc>
   1e44e:	edd6 7a04 	vldr	s15, [r6, #16]
	tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
   1e452:	eeb0 0a67 	vmov.f32	s0, s15
   1e456:	4824      	ldr	r0, [pc, #144]	; (1e4e8 <SFXReverbTick+0xec>)
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   1e458:	edc5 7a04 	vstr	s15, [r5, #16]
	tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
   1e45c:	f00d fc24 	bl	2bca8 <tDattorroReverb_setFeedbackGain>
	sample = tanhf(stereo[0]) * 0.99f;
   1e460:	ed9f 8a23 	vldr	s16, [pc, #140]	; 1e4f0 <SFXReverbTick+0xf4>
	tDattorroReverb_tickStereo(&reverb, input[1], stereo);
   1e464:	4669      	mov	r1, sp
   1e466:	4820      	ldr	r0, [pc, #128]	; (1e4e8 <SFXReverbTick+0xec>)
   1e468:	ed94 0a01 	vldr	s0, [r4, #4]
   1e46c:	f00d f970 	bl	2b750 <tDattorroReverb_tickStereo>
	sample = tanhf(stereo[0]) * 0.99f;
   1e470:	ed9d 0a00 	vldr	s0, [sp]
   1e474:	f00e ff22 	bl	2d2bc <tanhf>
   1e478:	ee60 7a08 	vmul.f32	s15, s0, s16
	input[1] = tanhf(stereo[1]) * 0.99f;
   1e47c:	ed9d 0a01 	vldr	s0, [sp, #4]
	input[0] = sample;
   1e480:	edc4 7a00 	vstr	s15, [r4]
	input[1] = tanhf(stereo[1]) * 0.99f;
   1e484:	f00e ff1a 	bl	2d2bc <tanhf>
   1e488:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e48c:	ed84 0a01 	vstr	s0, [r4, #4]
}
   1e490:	b002      	add	sp, #8
   1e492:	ecbd 8b02 	vpop	{d8}
   1e496:	bd70      	pop	{r4, r5, r6, pc}
		freeze = !freeze;
   1e498:	4d16      	ldr	r5, [pc, #88]	; (1e4f4 <SFXReverbTick+0xf8>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e49a:	2100      	movs	r1, #0
		tDattorroReverb_setFreeze(&reverb, freeze);
   1e49c:	4812      	ldr	r0, [pc, #72]	; (1e4e8 <SFXReverbTick+0xec>)
		freeze = !freeze;
   1e49e:	682a      	ldr	r2, [r5, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e4a0:	7719      	strb	r1, [r3, #28]
		freeze = !freeze;
   1e4a2:	fab2 f282 	clz	r2, r2
   1e4a6:	0952      	lsrs	r2, r2, #5
		tDattorroReverb_setFreeze(&reverb, freeze);
   1e4a8:	4611      	mov	r1, r2
		freeze = !freeze;
   1e4aa:	602a      	str	r2, [r5, #0]
		tDattorroReverb_setFreeze(&reverb, freeze);
   1e4ac:	f00d fb08 	bl	2bac0 <tDattorroReverb_setFreeze>
		setLED_C(freeze);
   1e4b0:	7828      	ldrb	r0, [r5, #0]
   1e4b2:	f7fb f85f 	bl	19574 <setLED_C>
   1e4b6:	e7aa      	b.n	1e40e <SFXReverbTick+0x12>
	displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
   1e4b8:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
   1e4bc:	edd6 0a04 	vldr	s1, [r6, #16]
   1e4c0:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 1e4f8 <SFXReverbTick+0xfc>
   1e4c4:	f00b f9e0 	bl	29888 <LEAF_clip>
   1e4c8:	eef0 7a40 	vmov.f32	s15, s0
   1e4cc:	e7c1      	b.n	1e452 <SFXReverbTick+0x56>
   1e4ce:	bf00      	nop
   1e4d0:	020fb31c 	.word	0x020fb31c
   1e4d4:	020f97c8 	.word	0x020f97c8
   1e4d8:	3f666666 	.word	0x3f666666
   1e4dc:	3dcccccd 	.word	0x3dcccccd
   1e4e0:	020fb3cc 	.word	0x020fb3cc
   1e4e4:	020fad78 	.word	0x020fad78
   1e4e8:	020f9250 	.word	0x020f9250
   1e4ec:	020e3130 	.word	0x020e3130
   1e4f0:	3f7d70a4 	.word	0x3f7d70a4
   1e4f4:	020e3198 	.word	0x020e3198
   1e4f8:	00000000 	.word	0x00000000

0001e4fc <SFXReverbFree>:
{
   1e4fc:	b508      	push	{r3, lr}
	tDattorroReverb_free(&reverb);
   1e4fe:	4804      	ldr	r0, [pc, #16]	; (1e510 <SFXReverbFree+0x14>)
   1e500:	f00d f8ce 	bl	2b6a0 <tDattorroReverb_free>
	tExpSmooth_free(&sizeSmoother);
   1e504:	4803      	ldr	r0, [pc, #12]	; (1e514 <SFXReverbFree+0x18>)
}
   1e506:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tExpSmooth_free(&sizeSmoother);
   1e50a:	f009 bd13 	b.w	27f34 <tExpSmooth_free>
   1e50e:	bf00      	nop
   1e510:	020f9250 	.word	0x020f9250
   1e514:	020fad78 	.word	0x020fad78

0001e518 <SFXReverb2Alloc>:
{
   1e518:	b570      	push	{r4, r5, r6, lr}
	tNReverb_init(&reverb2, 1.0f);
   1e51a:	4e26      	ldr	r6, [pc, #152]	; (1e5b4 <SFXReverb2Alloc+0x9c>)
	leaf.clearOnAllocation = 1;
   1e51c:	2401      	movs	r4, #1
   1e51e:	4d26      	ldr	r5, [pc, #152]	; (1e5b8 <SFXReverb2Alloc+0xa0>)
	tNReverb_init(&reverb2, 1.0f);
   1e520:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1e524:	4630      	mov	r0, r6
	leaf.clearOnAllocation = 1;
   1e526:	616c      	str	r4, [r5, #20]
{
   1e528:	ed2d 8b04 	vpush	{d8-d9}
	tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
   1e52c:	ed9f 9a23 	vldr	s18, [pc, #140]	; 1e5bc <SFXReverb2Alloc+0xa4>
	tNReverb_init(&reverb2, 1.0f);
   1e530:	f00c fdda 	bl	2b0e8 <tNReverb_init>
	tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
   1e534:	eddf 8a22 	vldr	s17, [pc, #136]	; 1e5c0 <SFXReverb2Alloc+0xa8>
	tNReverb_setMix(&reverb2, 1.0f);
   1e538:	4630      	mov	r0, r6
   1e53a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
	tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
   1e53e:	ed9f 8a21 	vldr	s16, [pc, #132]	; 1e5c4 <SFXReverb2Alloc+0xac>
	tNReverb_setMix(&reverb2, 1.0f);
   1e542:	f00c fe39 	bl	2b1b8 <tNReverb_setMix>
	tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
   1e546:	eeb0 0a49 	vmov.f32	s0, s18
   1e54a:	4621      	mov	r1, r4
   1e54c:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e550:	481d      	ldr	r0, [pc, #116]	; (1e5c8 <SFXReverb2Alloc+0xb0>)
   1e552:	f009 fe43 	bl	281dc <tSVF_init>
	tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
   1e556:	eeb0 0a68 	vmov.f32	s0, s17
   1e55a:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e55e:	2100      	movs	r1, #0
   1e560:	481a      	ldr	r0, [pc, #104]	; (1e5cc <SFXReverb2Alloc+0xb4>)
   1e562:	f009 fe3b 	bl	281dc <tSVF_init>
	tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
   1e566:	eeb0 0a48 	vmov.f32	s0, s16
   1e56a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1e56e:	2102      	movs	r1, #2
   1e570:	4817      	ldr	r0, [pc, #92]	; (1e5d0 <SFXReverb2Alloc+0xb8>)
   1e572:	f009 fe33 	bl	281dc <tSVF_init>
	tSVF_init(&lowpass2, SVFTypeLowpass, 18000.0f, 0.75f);
   1e576:	eeb0 0a49 	vmov.f32	s0, s18
   1e57a:	4621      	mov	r1, r4
   1e57c:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e580:	4814      	ldr	r0, [pc, #80]	; (1e5d4 <SFXReverb2Alloc+0xbc>)
   1e582:	f009 fe2b 	bl	281dc <tSVF_init>
	tSVF_init(&highpass2, SVFTypeHighpass, 40.0f, 0.75f);
   1e586:	eeb0 0a68 	vmov.f32	s0, s17
   1e58a:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
   1e58e:	2100      	movs	r1, #0
   1e590:	4811      	ldr	r0, [pc, #68]	; (1e5d8 <SFXReverb2Alloc+0xc0>)
   1e592:	f009 fe23 	bl	281dc <tSVF_init>
	tSVF_init(&bandpass2, SVFTypeBandpass, 2000.0f, 1.0f);
   1e596:	eeb0 0a48 	vmov.f32	s0, s16
   1e59a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1e59e:	2102      	movs	r1, #2
   1e5a0:	480e      	ldr	r0, [pc, #56]	; (1e5dc <SFXReverb2Alloc+0xc4>)
   1e5a2:	f009 fe1b 	bl	281dc <tSVF_init>
	freeze = 0;
   1e5a6:	2300      	movs	r3, #0
   1e5a8:	4a0d      	ldr	r2, [pc, #52]	; (1e5e0 <SFXReverb2Alloc+0xc8>)
	leaf.clearOnAllocation = 0;
   1e5aa:	616b      	str	r3, [r5, #20]
	freeze = 0;
   1e5ac:	6013      	str	r3, [r2, #0]
}
   1e5ae:	ecbd 8b04 	vpop	{d8-d9}
   1e5b2:	bd70      	pop	{r4, r5, r6, pc}
   1e5b4:	020fae70 	.word	0x020fae70
   1e5b8:	020fc0a8 	.word	0x020fc0a8
   1e5bc:	468ca000 	.word	0x468ca000
   1e5c0:	42200000 	.word	0x42200000
   1e5c4:	44fa0000 	.word	0x44fa0000
   1e5c8:	020f8f50 	.word	0x020f8f50
   1e5cc:	020fad80 	.word	0x020fad80
   1e5d0:	020fa248 	.word	0x020fa248
   1e5d4:	020f9ea0 	.word	0x020f9ea0
   1e5d8:	020fa14c 	.word	0x020fa14c
   1e5dc:	020fa228 	.word	0x020fa228
   1e5e0:	020e3198 	.word	0x020e3198

0001e5e4 <SFXReverb2Frame>:
   1e5e4:	4770      	bx	lr
   1e5e6:	bf00      	nop

0001e5e8 <SFXReverb2Tick>:
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e5e8:	4b5f      	ldr	r3, [pc, #380]	; (1e768 <SFXReverb2Tick+0x180>)
   1e5ea:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
{
   1e5ee:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1e5f2:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e5f6:	ed93 0a00 	vldr	s0, [r3]
{
   1e5fa:	b083      	sub	sp, #12
	if (!freeze)
   1e5fc:	f8df 919c 	ldr.w	r9, [pc, #412]	; 1e79c <SFXReverb2Tick+0x1b4>
{
   1e600:	4605      	mov	r5, r0
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e602:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e606:	4c59      	ldr	r4, [pc, #356]	; (1e76c <SFXReverb2Tick+0x184>)
	if (!freeze)
   1e608:	f8d9 3000 	ldr.w	r3, [r9]
	displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
   1e60c:	ed84 0a00 	vstr	s0, [r4]
	if (!freeze)
   1e610:	2b00      	cmp	r3, #0
   1e612:	f040 8092 	bne.w	1e73a <SFXReverb2Tick+0x152>
		tNReverb_setT60(&reverb2, displayValues[0]);
   1e616:	4856      	ldr	r0, [pc, #344]	; (1e770 <SFXReverb2Tick+0x188>)
   1e618:	f00c fd8a 	bl	2b130 <tNReverb_setT60>
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   1e61c:	4e55      	ldr	r6, [pc, #340]	; (1e774 <SFXReverb2Tick+0x18c>)
   1e61e:	eddf 7a56 	vldr	s15, [pc, #344]	; 1e778 <SFXReverb2Tick+0x190>
   1e622:	4637      	mov	r7, r6
	displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   1e624:	ed9f 8a55 	vldr	s16, [pc, #340]	; 1e77c <SFXReverb2Tick+0x194>
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e628:	f8df 8174 	ldr.w	r8, [pc, #372]	; 1e7a0 <SFXReverb2Tick+0x1b8>
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   1e62c:	ecb7 0a01 	vldmia	r7!, {s0}
   1e630:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e634:	f00b fa96 	bl	29b64 <faster_mtof>
	tSVF_setFreq(&lowpass, displayValues[1]);
   1e638:	4851      	ldr	r0, [pc, #324]	; (1e780 <SFXReverb2Tick+0x198>)
	displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
   1e63a:	ed84 0a01 	vstr	s0, [r4, #4]
	tSVF_setFreq(&lowpass, displayValues[1]);
   1e63e:	f009 fe81 	bl	28344 <tSVF_setFreq>
	tSVF_setFreq(&lowpass2, displayValues[1]);
   1e642:	4850      	ldr	r0, [pc, #320]	; (1e784 <SFXReverb2Tick+0x19c>)
   1e644:	ed94 0a01 	vldr	s0, [r4, #4]
   1e648:	f009 fe7c 	bl	28344 <tSVF_setFreq>
	displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   1e64c:	ed97 0a00 	vldr	s0, [r7]
   1e650:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e654:	f00b fa86 	bl	29b64 <faster_mtof>
	tSVF_setFreq(&highpass, displayValues[2]);
   1e658:	484b      	ldr	r0, [pc, #300]	; (1e788 <SFXReverb2Tick+0x1a0>)
	displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
   1e65a:	ed84 0a02 	vstr	s0, [r4, #8]
	tSVF_setFreq(&highpass, displayValues[2]);
   1e65e:	f009 fe71 	bl	28344 <tSVF_setFreq>
	tSVF_setFreq(&highpass2, displayValues[2]);
   1e662:	484a      	ldr	r0, [pc, #296]	; (1e78c <SFXReverb2Tick+0x1a4>)
   1e664:	ed94 0a02 	vldr	s0, [r4, #8]
   1e668:	f009 fe6c 	bl	28344 <tSVF_setFreq>
	displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
   1e66c:	ed96 0a02 	vldr	s0, [r6, #8]
   1e670:	ee20 0a08 	vmul.f32	s0, s0, s16
   1e674:	f00b fa76 	bl	29b64 <faster_mtof>
	tSVF_setFreq(&bandpass, displayValues[3]);
   1e678:	4845      	ldr	r0, [pc, #276]	; (1e790 <SFXReverb2Tick+0x1a8>)
	displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
   1e67a:	ed84 0a03 	vstr	s0, [r4, #12]
	tSVF_setFreq(&bandpass, displayValues[3]);
   1e67e:	f009 fe61 	bl	28344 <tSVF_setFreq>
	tSVF_setFreq(&bandpass2, displayValues[3]);
   1e682:	ed94 0a03 	vldr	s0, [r4, #12]
   1e686:	4843      	ldr	r0, [pc, #268]	; (1e794 <SFXReverb2Tick+0x1ac>)
   1e688:	f009 fe5c 	bl	28344 <tSVF_setFreq>
	displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
   1e68c:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   1e690:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
   1e694:	edd6 6a03 	vldr	s13, [r6, #12]
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e698:	f898 301c 	ldrb.w	r3, [r8, #28]
	displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
   1e69c:	eee6 7a87 	vfma.f32	s15, s13, s14
   1e6a0:	edc4 7a04 	vstr	s15, [r4, #16]
	if (buttonActionsSFX[ButtonC][ActionPress])
   1e6a4:	2b00      	cmp	r3, #0
   1e6a6:	d150      	bne.n	1e74a <SFXReverb2Tick+0x162>
	if (buttonActionsSFX[ButtonA][ActionPress])
   1e6a8:	f898 3014 	ldrb.w	r3, [r8, #20]
   1e6ac:	b163      	cbz	r3, 1e6c8 <SFXReverb2Tick+0xe0>
		freeze = !freeze;
   1e6ae:	f8d9 3000 	ldr.w	r3, [r9]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e6b2:	2200      	movs	r2, #0
		freeze = !freeze;
   1e6b4:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1e6b8:	f888 2014 	strb.w	r2, [r8, #20]
		freeze = !freeze;
   1e6bc:	095b      	lsrs	r3, r3, #5
		setLED_C(freeze);
   1e6be:	4618      	mov	r0, r3
		freeze = !freeze;
   1e6c0:	f8c9 3000 	str.w	r3, [r9]
		setLED_C(freeze);
   1e6c4:	f7fa ff56 	bl	19574 <setLED_C>
	tNReverb_tickStereo(&reverb2, input[1], stereoOuts);
   1e6c8:	4669      	mov	r1, sp
   1e6ca:	ed95 0a01 	vldr	s0, [r5, #4]
   1e6ce:	4828      	ldr	r0, [pc, #160]	; (1e770 <SFXReverb2Tick+0x188>)
   1e6d0:	f00c fd76 	bl	2b1c0 <tNReverb_tickStereo>
	float leftOut = tSVF_tick(&lowpass, stereoOuts[0]);
   1e6d4:	ed9d 0a00 	vldr	s0, [sp]
   1e6d8:	4829      	ldr	r0, [pc, #164]	; (1e780 <SFXReverb2Tick+0x198>)
   1e6da:	f009 fdfd 	bl	282d8 <tSVF_tick>
	leftOut = tSVF_tick(&highpass, leftOut);
   1e6de:	482a      	ldr	r0, [pc, #168]	; (1e788 <SFXReverb2Tick+0x1a0>)
   1e6e0:	f009 fdfa 	bl	282d8 <tSVF_tick>
	leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   1e6e4:	482a      	ldr	r0, [pc, #168]	; (1e790 <SFXReverb2Tick+0x1a8>)
	leftOut = tSVF_tick(&highpass, leftOut);
   1e6e6:	eef0 8a40 	vmov.f32	s17, s0
	leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   1e6ea:	f009 fdf5 	bl	282d8 <tSVF_tick>
   1e6ee:	edd4 7a04 	vldr	s15, [r4, #16]
	float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
   1e6f2:	4824      	ldr	r0, [pc, #144]	; (1e784 <SFXReverb2Tick+0x19c>)
	leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
   1e6f4:	eee0 8a27 	vfma.f32	s17, s0, s15
	float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
   1e6f8:	ed9d 0a01 	vldr	s0, [sp, #4]
   1e6fc:	f009 fdec 	bl	282d8 <tSVF_tick>
	rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
   1e700:	4822      	ldr	r0, [pc, #136]	; (1e78c <SFXReverb2Tick+0x1a4>)
   1e702:	f009 fde9 	bl	282d8 <tSVF_tick>
	rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
   1e706:	4822      	ldr	r0, [pc, #136]	; (1e790 <SFXReverb2Tick+0x1a8>)
	rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
   1e708:	eeb0 8a40 	vmov.f32	s16, s0
	rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
   1e70c:	f009 fde4 	bl	282d8 <tSVF_tick>
   1e710:	edd4 7a04 	vldr	s15, [r4, #16]
   1e714:	eea0 8a27 	vfma.f32	s16, s0, s15
	sample = tanhf(leftOut);
   1e718:	eeb0 0a68 	vmov.f32	s0, s17
   1e71c:	f00e fdce 	bl	2d2bc <tanhf>
	input[0] = sample;
   1e720:	ed85 0a00 	vstr	s0, [r5]
	input[1] = tanhf(rightOutTemp);
   1e724:	eeb0 0a48 	vmov.f32	s0, s16
   1e728:	f00e fdc8 	bl	2d2bc <tanhf>
   1e72c:	ed85 0a01 	vstr	s0, [r5, #4]
}
   1e730:	b003      	add	sp, #12
   1e732:	ecbd 8b02 	vpop	{d8}
   1e736:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		tNReverb_setT60(&reverb2, 1000.0f);
   1e73a:	ed9f 0a17 	vldr	s0, [pc, #92]	; 1e798 <SFXReverb2Tick+0x1b0>
   1e73e:	480c      	ldr	r0, [pc, #48]	; (1e770 <SFXReverb2Tick+0x188>)
   1e740:	f00c fcf6 	bl	2b130 <tNReverb_setT60>
		input[1] = 0.0f;
   1e744:	2300      	movs	r3, #0
   1e746:	606b      	str	r3, [r5, #4]
   1e748:	e768      	b.n	1e61c <SFXReverb2Tick+0x34>
		freeze = !freeze;
   1e74a:	f8d9 3000 	ldr.w	r3, [r9]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e74e:	2200      	movs	r2, #0
		freeze = !freeze;
   1e750:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1e754:	f888 201c 	strb.w	r2, [r8, #28]
		freeze = !freeze;
   1e758:	095b      	lsrs	r3, r3, #5
		setLED_C(freeze);
   1e75a:	4618      	mov	r0, r3
		freeze = !freeze;
   1e75c:	f8c9 3000 	str.w	r3, [r9]
		setLED_C(freeze);
   1e760:	f7fa ff08 	bl	19574 <setLED_C>
   1e764:	e7a0      	b.n	1e6a8 <SFXReverb2Tick+0xc0>
   1e766:	bf00      	nop
   1e768:	020f982c 	.word	0x020f982c
   1e76c:	020fb3cc 	.word	0x020fb3cc
   1e770:	020fae70 	.word	0x020fae70
   1e774:	020f9830 	.word	0x020f9830
   1e778:	43070000 	.word	0x43070000
   1e77c:	43000000 	.word	0x43000000
   1e780:	020f8f50 	.word	0x020f8f50
   1e784:	020f9ea0 	.word	0x020f9ea0
   1e788:	020fad80 	.word	0x020fad80
   1e78c:	020fa14c 	.word	0x020fa14c
   1e790:	020fa248 	.word	0x020fa248
   1e794:	020fa228 	.word	0x020fa228
   1e798:	447a0000 	.word	0x447a0000
   1e79c:	020e3198 	.word	0x020e3198
   1e7a0:	020fb31c 	.word	0x020fb31c

0001e7a4 <SFXReverb2Free>:
{
   1e7a4:	b508      	push	{r3, lr}
	tNReverb_free(&reverb2);
   1e7a6:	480b      	ldr	r0, [pc, #44]	; (1e7d4 <SFXReverb2Free+0x30>)
   1e7a8:	f00c fca4 	bl	2b0f4 <tNReverb_free>
	tSVF_free(&lowpass);
   1e7ac:	480a      	ldr	r0, [pc, #40]	; (1e7d8 <SFXReverb2Free+0x34>)
   1e7ae:	f009 fd8f 	bl	282d0 <tSVF_free>
	tSVF_free(&highpass);
   1e7b2:	480a      	ldr	r0, [pc, #40]	; (1e7dc <SFXReverb2Free+0x38>)
   1e7b4:	f009 fd8c 	bl	282d0 <tSVF_free>
	tSVF_free(&bandpass);
   1e7b8:	4809      	ldr	r0, [pc, #36]	; (1e7e0 <SFXReverb2Free+0x3c>)
   1e7ba:	f009 fd89 	bl	282d0 <tSVF_free>
	tSVF_free(&lowpass2);
   1e7be:	4809      	ldr	r0, [pc, #36]	; (1e7e4 <SFXReverb2Free+0x40>)
   1e7c0:	f009 fd86 	bl	282d0 <tSVF_free>
	tSVF_free(&highpass2);
   1e7c4:	4808      	ldr	r0, [pc, #32]	; (1e7e8 <SFXReverb2Free+0x44>)
   1e7c6:	f009 fd83 	bl	282d0 <tSVF_free>
	tSVF_free(&bandpass2);
   1e7ca:	4808      	ldr	r0, [pc, #32]	; (1e7ec <SFXReverb2Free+0x48>)
}
   1e7cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	tSVF_free(&bandpass2);
   1e7d0:	f009 bd7e 	b.w	282d0 <tSVF_free>
   1e7d4:	020fae70 	.word	0x020fae70
   1e7d8:	020f8f50 	.word	0x020f8f50
   1e7dc:	020fad80 	.word	0x020fad80
   1e7e0:	020fa248 	.word	0x020fa248
   1e7e4:	020f9ea0 	.word	0x020f9ea0
   1e7e8:	020fa14c 	.word	0x020fa14c
   1e7ec:	020fa228 	.word	0x020fa228

0001e7f0 <SFXLivingStringAlloc>:
{
   1e7f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	levMode = 0;
   1e7f4:	2300      	movs	r3, #0
   1e7f6:	4e2a      	ldr	r6, [pc, #168]	; (1e8a0 <SFXLivingStringAlloc+0xb0>)
   1e7f8:	4d2a      	ldr	r5, [pc, #168]	; (1e8a4 <SFXLivingStringAlloc+0xb4>)
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1e7fa:	2106      	movs	r1, #6
   1e7fc:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 1e8dc <SFXLivingStringAlloc+0xec>
   1e800:	461c      	mov	r4, r3
   1e802:	4f29      	ldr	r7, [pc, #164]	; (1e8a8 <SFXLivingStringAlloc+0xb8>)
   1e804:	4829      	ldr	r0, [pc, #164]	; (1e8ac <SFXLivingStringAlloc+0xbc>)
	levMode = 0;
   1e806:	6033      	str	r3, [r6, #0]
{
   1e808:	ed2d 8b06 	vpush	{d8-d10}
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   1e80c:	eddf aa28 	vldr	s21, [pc, #160]	; 1e8b0 <SFXLivingStringAlloc+0xc0>
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1e810:	f00b fe9a 	bl	2a548 <tSimplePoly_setNumVoices>
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   1e814:	ed9f aa27 	vldr	s20, [pc, #156]	; 1e8b4 <SFXLivingStringAlloc+0xc4>
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e818:	eddf 9a27 	vldr	s19, [pc, #156]	; 1e8b8 <SFXLivingStringAlloc+0xc8>
   1e81c:	ed9f 9a27 	vldr	s18, [pc, #156]	; 1e8bc <SFXLivingStringAlloc+0xcc>
   1e820:	ed9f 8a27 	vldr	s16, [pc, #156]	; 1e8c0 <SFXLivingStringAlloc+0xd0>
   1e824:	eddf 8a27 	vldr	s17, [pc, #156]	; 1e8c4 <SFXLivingStringAlloc+0xd4>
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   1e828:	f7fa fdb4 	bl	19394 <randomNumber>
   1e82c:	eef0 7a4a 	vmov.f32	s15, s20
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e830:	ed9f 3a1f 	vldr	s6, [pc, #124]	; 1e8b0 <SFXLivingStringAlloc+0xc0>
   1e834:	eb08 0004 	add.w	r0, r8, r4
   1e838:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
   1e83c:	6831      	ldr	r1, [r6, #0]
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   1e83e:	eee0 7a2a 	vfma.f32	s15, s0, s21
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e842:	ed9f 0a21 	vldr	s0, [pc, #132]	; 1e8c8 <SFXLivingStringAlloc+0xd8>
   1e846:	eef0 3a69 	vmov.f32	s7, s19
   1e84a:	eeb0 1a43 	vmov.f32	s2, s6
   1e84e:	eeb0 2a49 	vmov.f32	s4, s18
   1e852:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
   1e856:	eef0 1a48 	vmov.f32	s3, s16
   1e85a:	eef0 0a68 	vmov.f32	s1, s17
		myDetune[i] = (randomNumber() * 0.3f) - 0.15f;
   1e85e:	ece5 7a01 	vstmia	r5!, {s15}
		tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
   1e862:	f00c f973 	bl	2ab4c <tComplexLivingString_init>
		tExpSmooth_initToPool(&stringGains[i], 0.0f, 0.002f, &smallPool);
   1e866:	1938      	adds	r0, r7, r4
   1e868:	3404      	adds	r4, #4
   1e86a:	4918      	ldr	r1, [pc, #96]	; (1e8cc <SFXLivingStringAlloc+0xdc>)
   1e86c:	eddf 0a18 	vldr	s1, [pc, #96]	; 1e8d0 <SFXLivingStringAlloc+0xe0>
   1e870:	eeb0 0a48 	vmov.f32	s0, s16
   1e874:	f009 fb38 	bl	27ee8 <tExpSmooth_initToPool>
	for (int i = 0; i < NUM_STRINGS; i++)
   1e878:	2c18      	cmp	r4, #24
   1e87a:	d1d5      	bne.n	1e828 <SFXLivingStringAlloc+0x38>
	ignoreFreqKnobs = 0;
   1e87c:	2300      	movs	r3, #0
   1e87e:	4a15      	ldr	r2, [pc, #84]	; (1e8d4 <SFXLivingStringAlloc+0xe4>)
	setLED_A(ignoreFreqKnobs);
   1e880:	4618      	mov	r0, r3
	ignoreFreqKnobs = 0;
   1e882:	6013      	str	r3, [r2, #0]
	setLED_A(ignoreFreqKnobs);
   1e884:	f7fa fe5a 	bl	1953c <setLED_A>
	setLED_B(independentStrings);
   1e888:	4b13      	ldr	r3, [pc, #76]	; (1e8d8 <SFXLivingStringAlloc+0xe8>)
   1e88a:	7818      	ldrb	r0, [r3, #0]
   1e88c:	f7fa fe64 	bl	19558 <setLED_B>
	setLED_C(levMode);
   1e890:	7830      	ldrb	r0, [r6, #0]
}
   1e892:	ecbd 8b06 	vpop	{d8-d10}
   1e896:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	setLED_C(levMode);
   1e89a:	f7fa be6b 	b.w	19574 <setLED_C>
   1e89e:	bf00      	nop
   1e8a0:	020e31a8 	.word	0x020e31a8
   1e8a4:	020f8e70 	.word	0x020f8e70
   1e8a8:	020f9c68 	.word	0x020f9c68
   1e8ac:	020fa15c 	.word	0x020fa15c
   1e8b0:	3e99999a 	.word	0x3e99999a
   1e8b4:	be19999a 	.word	0xbe19999a
   1e8b8:	3c23d70a 	.word	0x3c23d70a
   1e8bc:	460ca000 	.word	0x460ca000
   1e8c0:	00000000 	.word	0x00000000
   1e8c4:	3f4ccccd 	.word	0x3f4ccccd
   1e8c8:	43dc0000 	.word	0x43dc0000
   1e8cc:	020f7730 	.word	0x020f7730
   1e8d0:	3b03126f 	.word	0x3b03126f
   1e8d4:	020e319c 	.word	0x020e319c
   1e8d8:	020e31a0 	.word	0x020e31a0
   1e8dc:	020f8c78 	.word	0x020f8c78

0001e8e0 <SFXLivingStringFrame>:
{
   1e8e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1e8e4:	4dba      	ldr	r5, [pc, #744]	; (1ebd0 <SFXLivingStringFrame+0x2f0>)
{
   1e8e6:	ed2d 8b04 	vpush	{d8-d9}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1e8ea:	7d2b      	ldrb	r3, [r5, #20]
{
   1e8ec:	b083      	sub	sp, #12
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1e8ee:	2b01      	cmp	r3, #1
   1e8f0:	f000 820a 	beq.w	1ed08 <SFXLivingStringFrame+0x428>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1e8f4:	7f2b      	ldrb	r3, [r5, #28]
   1e8f6:	2b01      	cmp	r3, #1
   1e8f8:	f000 813b 	beq.w	1eb72 <SFXLivingStringFrame+0x292>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1e8fc:	7e2b      	ldrb	r3, [r5, #24]
   1e8fe:	4fb5      	ldr	r7, [pc, #724]	; (1ebd4 <SFXLivingStringFrame+0x2f4>)
   1e900:	2b01      	cmp	r3, #1
		independentStrings = !independentStrings;
   1e902:	4eb5      	ldr	r6, [pc, #724]	; (1ebd8 <SFXLivingStringFrame+0x2f8>)
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1e904:	f000 8151 	beq.w	1ebaa <SFXLivingStringFrame+0x2ca>
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   1e908:	f8df b300 	ldr.w	fp, [pc, #768]	; 1ec0c <SFXLivingStringFrame+0x32c>
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e90c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   1e910:	eddf 8ab2 	vldr	s17, [pc, #712]	; 1ebdc <SFXLivingStringFrame+0x2fc>
   1e914:	465d      	mov	r5, fp
   1e916:	4cb2      	ldr	r4, [pc, #712]	; (1ebe0 <SFXLivingStringFrame+0x300>)
   1e918:	ecb5 0a01 	vldmia	r5!, {s0}
   1e91c:	ee20 0a28 	vmul.f32	s0, s0, s17
   1e920:	f00b f89c 	bl	29a5c <LEAF_midiToFrequency>
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e924:	eef2 7a08 	vmov.f32	s15, #40	; 0x41400000  12.0
   1e928:	eddb 6a03 	vldr	s13, [fp, #12]
   1e92c:	ed9f 7aad 	vldr	s14, [pc, #692]	; 1ebe4 <SFXLivingStringFrame+0x304>
	displayValues[2] = presetKnobValues[LivingString][2]; //decay
   1e930:	f8db 2008 	ldr.w	r2, [fp, #8]
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e934:	eee6 7a87 	vfma.f32	s15, s13, s14
	displayValues[1] = presetKnobValues[LivingString][1]; //detune
   1e938:	6829      	ldr	r1, [r5, #0]
	displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
   1e93a:	ed84 0a00 	vstr	s0, [r4]
	displayValues[2] = presetKnobValues[LivingString][2]; //decay
   1e93e:	60a2      	str	r2, [r4, #8]
	displayValues[1] = presetKnobValues[LivingString][1]; //detune
   1e940:	6061      	str	r1, [r4, #4]
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e942:	eeb0 0a67 	vmov.f32	s0, s15
   1e946:	f00b f8e9 	bl	29b1c <mtof>
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e94a:	ed9b 4a04 	vldr	s8, [fp, #16]
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e94e:	ed9b 5a05 	vldr	s10, [fp, #20]
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e952:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
   1e956:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
	displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
   1e95a:	ed84 0a03 	vstr	s0, [r4, #12]
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e95e:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e962:	ed9b 2a06 	vldr	s4, [fp, #24]
   1e966:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
   1e96a:	eeb9 0a00 	vmov.f32	s0, #144	; 0xc0800000 -4.0
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e96e:	ed9f 3b94 	vldr	d3, [pc, #592]	; 1ebc0 <SFXLivingStringFrame+0x2e0>
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e972:	ed9f 7b95 	vldr	d7, [pc, #596]	; 1ebc8 <SFXLivingStringFrame+0x2e8>
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e976:	eea2 0a22 	vfma.f32	s0, s4, s5
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e97a:	eea4 6b03 	vfma.f64	d6, d4, d3
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e97e:	eea5 7b03 	vfma.f64	d7, d5, d3
	displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
   1e982:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
   1e986:	ed84 6a04 	vstr	s12, [r4, #16]
	displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
   1e98a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   1e98e:	ed84 7a05 	vstr	s14, [r4, #20]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e992:	f00e fc93 	bl	2d2bc <tanhf>
   1e996:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	displayValues[7] = presetKnobValues[LivingString][7];// let ring
   1e99a:	f8db 201c 	ldr.w	r2, [fp, #28]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e99e:	ee30 0a08 	vadd.f32	s0, s0, s16
	if (!independentStrings)
   1e9a2:	6836      	ldr	r6, [r6, #0]
	displayValues[7] = presetKnobValues[LivingString][7];// let ring
   1e9a4:	61e2      	str	r2, [r4, #28]
	displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
   1e9a6:	ee20 0a27 	vmul.f32	s0, s0, s15
   1e9aa:	ed84 0a06 	vstr	s0, [r4, #24]
	if (!independentStrings)
   1e9ae:	2e00      	cmp	r6, #0
   1e9b0:	f040 8134 	bne.w	1ec1c <SFXLivingStringFrame+0x33c>
		if (!ignoreFreqKnobs)
   1e9b4:	4b8c      	ldr	r3, [pc, #560]	; (1ebe8 <SFXLivingStringFrame+0x308>)
   1e9b6:	f8d3 9000 	ldr.w	r9, [r3]
   1e9ba:	f1b9 0f00 	cmp.w	r9, #0
   1e9be:	f000 808b 	beq.w	1ead8 <SFXLivingStringFrame+0x1f8>
   1e9c2:	f8df 824c 	ldr.w	r8, [pc, #588]	; 1ec10 <SFXLivingStringFrame+0x330>
   1e9c6:	46b1      	mov	r9, r6
   1e9c8:	4b88      	ldr	r3, [pc, #544]	; (1ebec <SFXLivingStringFrame+0x30c>)
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1e9ca:	f8cd 8000 	str.w	r8, [sp]
   1e9ce:	46b0      	mov	r8, r6
   1e9d0:	9701      	str	r7, [sp, #4]
   1e9d2:	461f      	mov	r7, r3
   1e9d4:	f8df a23c 	ldr.w	sl, [pc, #572]	; 1ec14 <SFXLivingStringFrame+0x334>
   1e9d8:	f8df b23c 	ldr.w	fp, [pc, #572]	; 1ec18 <SFXLivingStringFrame+0x338>
   1e9dc:	ed9f 9a84 	vldr	s18, [pc, #528]	; 1ebf0 <SFXLivingStringFrame+0x310>
   1e9e0:	eddf 8a84 	vldr	s17, [pc, #528]	; 1ebf4 <SFXLivingStringFrame+0x314>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1e9e4:	fa5f f688 	uxtb.w	r6, r8
   1e9e8:	9b01      	ldr	r3, [sp, #4]
   1e9ea:	4883      	ldr	r0, [pc, #524]	; (1ebf8 <SFXLivingStringFrame+0x318>)
   1e9ec:	4631      	mov	r1, r6
   1e9ee:	eb03 0509 	add.w	r5, r3, r9
   1e9f2:	f00b fdcd 	bl	2a590 <tSimplePoly_getPitch>
   1e9f6:	ee07 0a90 	vmov	s15, r0
   1e9fa:	ed9b 0a00 	vldr	s0, [fp]
   1e9fe:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ea02:	4b7e      	ldr	r3, [pc, #504]	; (1ebfc <SFXLivingStringFrame+0x31c>)
   1ea04:	7818      	ldrb	r0, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1ea06:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ea0a:	4b7d      	ldr	r3, [pc, #500]	; (1ec00 <SFXLivingStringFrame+0x320>)
   1ea0c:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1ea10:	ee17 1a90 	vmov	r1, s15
   1ea14:	1a09      	subs	r1, r1, r0
   1ea16:	fb83 3c01 	smull	r3, ip, r3, r1
   1ea1a:	17c8      	asrs	r0, r1, #31
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1ea1c:	4b79      	ldr	r3, [pc, #484]	; (1ec04 <SFXLivingStringFrame+0x324>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1ea1e:	ebc0 006c 	rsb	r0, r0, ip, asr #1
   1ea22:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1ea26:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   1ea2a:	ee07 0a90 	vmov	s15, r0
   1ea2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1ea32:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1ea36:	ee17 1a90 	vmov	r1, s15
   1ea3a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   1ea3e:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1ea42:	ee37 0a00 	vadd.f32	s0, s14, s0
   1ea46:	f00b f809 	bl	29a5c <LEAF_midiToFrequency>
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ea4a:	eef0 6a48 	vmov.f32	s13, s16
   1ea4e:	ecb7 7a01 	vldmia	r7!, {s14}
   1ea52:	4628      	mov	r0, r5
   1ea54:	edd4 7a01 	vldr	s15, [r4, #4]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1ea58:	ecaa 0a01 	vstmia	sl!, {s0}
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ea5c:	eee7 6a27 	vfma.f32	s13, s14, s15
   1ea60:	ee26 0a80 	vmul.f32	s0, s13, s0
   1ea64:	f00c f8c4 	bl	2abf0 <tComplexLivingString_setFreq>
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ea68:	eeb0 0a68 	vmov.f32	s0, s17
   1ea6c:	edd4 7a02 	vldr	s15, [r4, #8]
   1ea70:	4628      	mov	r0, r5
   1ea72:	eea7 0a89 	vfma.f32	s0, s15, s18
   1ea76:	f00c f923 	bl	2acc0 <tComplexLivingString_setDecay>
				tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1ea7a:	4628      	mov	r0, r5
   1ea7c:	ed94 0a03 	vldr	s0, [r4, #12]
   1ea80:	f00c f8fe 	bl	2ac80 <tComplexLivingString_setDampFreq>
				tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1ea84:	4628      	mov	r0, r5
   1ea86:	ed94 0a04 	vldr	s0, [r4, #16]
   1ea8a:	f00c f8c9 	bl	2ac20 <tComplexLivingString_setPickPos>
				tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1ea8e:	4628      	mov	r0, r5
   1ea90:	ed94 0a05 	vldr	s0, [r4, #20]
   1ea94:	f00c f8d4 	bl	2ac40 <tComplexLivingString_setPrepPos>
				tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1ea98:	ed94 0a06 	vldr	s0, [r4, #24]
   1ea9c:	4628      	mov	r0, r5
   1ea9e:	f00c f8e1 	bl	2ac64 <tComplexLivingString_setPrepIndex>
				if (tSimplePoly_isOn(&poly, i))
   1eaa2:	4631      	mov	r1, r6
   1eaa4:	4854      	ldr	r0, [pc, #336]	; (1ebf8 <SFXLivingStringFrame+0x318>)
   1eaa6:	f00b fd85 	bl	2a5b4 <tSimplePoly_isOn>
   1eaaa:	9b00      	ldr	r3, [sp, #0]
					tExpSmooth_setDest(&stringGains[i], 1.0f);
   1eaac:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1eab0:	eb03 0109 	add.w	r1, r3, r9
				if (tSimplePoly_isOn(&poly, i))
   1eab4:	b908      	cbnz	r0, 1eaba <SFXLivingStringFrame+0x1da>
					tExpSmooth_setDest(&stringGains[i], displayValues[7]);
   1eab6:	ed94 0a07 	vldr	s0, [r4, #28]
			for (int i = 0; i < NUM_STRINGS; i++)
   1eaba:	f108 0801 	add.w	r8, r8, #1
					tExpSmooth_setDest(&stringGains[i], displayValues[7]);
   1eabe:	4608      	mov	r0, r1
   1eac0:	f009 fa4e 	bl	27f60 <tExpSmooth_setDest>
   1eac4:	f109 0904 	add.w	r9, r9, #4
			for (int i = 0; i < NUM_STRINGS; i++)
   1eac8:	f1b8 0f06 	cmp.w	r8, #6
   1eacc:	d18a      	bne.n	1e9e4 <SFXLivingStringFrame+0x104>
}
   1eace:	b003      	add	sp, #12
   1ead0:	ecbd 8b04 	vpop	{d8-d9}
   1ead4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ead8:	f8df a110 	ldr.w	sl, [pc, #272]	; 1ebec <SFXLivingStringFrame+0x30c>
		if (!ignoreFreqKnobs)
   1eadc:	464e      	mov	r6, r9
   1eade:	f8df 8130 	ldr.w	r8, [pc, #304]	; 1ec10 <SFXLivingStringFrame+0x330>
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1eae2:	ed9f 9a43 	vldr	s18, [pc, #268]	; 1ebf0 <SFXLivingStringFrame+0x310>
   1eae6:	eddf 8a43 	vldr	s17, [pc, #268]	; 1ebf4 <SFXLivingStringFrame+0x314>
				float freqVal = displayValues[0] * (i+1);
   1eaea:	f109 0901 	add.w	r9, r9, #1
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1eaee:	eeb0 0a48 	vmov.f32	s0, s16
   1eaf2:	ecba 6a01 	vldmia	sl!, {s12}
   1eaf6:	19bd      	adds	r5, r7, r6
   1eaf8:	edd4 6a01 	vldr	s13, [r4, #4]
				float freqVal = displayValues[0] * (i+1);
   1eafc:	ee07 9a90 	vmov	s15, r9
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1eb00:	4628      	mov	r0, r5
				float freqVal = displayValues[0] * (i+1);
   1eb02:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   1eb06:	edd4 7a00 	vldr	s15, [r4]
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1eb0a:	eea6 0a26 	vfma.f32	s0, s12, s13
				float freqVal = displayValues[0] * (i+1);
   1eb0e:	ee67 7a27 	vmul.f32	s15, s14, s15
				tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1eb12:	ee27 0a80 	vmul.f32	s0, s15, s0
   1eb16:	f00c f86b 	bl	2abf0 <tComplexLivingString_setFreq>
				tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1eb1a:	eeb0 0a68 	vmov.f32	s0, s17
   1eb1e:	edd4 7a02 	vldr	s15, [r4, #8]
   1eb22:	4628      	mov	r0, r5
   1eb24:	eea7 0a89 	vfma.f32	s0, s15, s18
   1eb28:	f00c f8ca 	bl	2acc0 <tComplexLivingString_setDecay>
				tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1eb2c:	4628      	mov	r0, r5
   1eb2e:	ed94 0a03 	vldr	s0, [r4, #12]
   1eb32:	f00c f8a5 	bl	2ac80 <tComplexLivingString_setDampFreq>
				tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1eb36:	4628      	mov	r0, r5
   1eb38:	ed94 0a04 	vldr	s0, [r4, #16]
   1eb3c:	f00c f870 	bl	2ac20 <tComplexLivingString_setPickPos>
				tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1eb40:	4628      	mov	r0, r5
   1eb42:	ed94 0a05 	vldr	s0, [r4, #20]
   1eb46:	f00c f87b 	bl	2ac40 <tComplexLivingString_setPrepPos>
				tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1eb4a:	4628      	mov	r0, r5
   1eb4c:	ed94 0a06 	vldr	s0, [r4, #24]
   1eb50:	f00c f888 	bl	2ac64 <tComplexLivingString_setPrepIndex>
				tExpSmooth_setDest(&stringGains[i], 1.0f);
   1eb54:	eb08 0006 	add.w	r0, r8, r6
   1eb58:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1eb5c:	3604      	adds	r6, #4
   1eb5e:	f009 f9ff 	bl	27f60 <tExpSmooth_setDest>
			for (int i = 0; i < NUM_STRINGS; i++)
   1eb62:	f1b9 0f06 	cmp.w	r9, #6
   1eb66:	d1c0      	bne.n	1eaea <SFXLivingStringFrame+0x20a>
}
   1eb68:	b003      	add	sp, #12
   1eb6a:	ecbd 8b04 	vpop	{d8-d9}
   1eb6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		levMode = !levMode;
   1eb72:	4e25      	ldr	r6, [pc, #148]	; (1ec08 <SFXLivingStringFrame+0x328>)
   1eb74:	4f17      	ldr	r7, [pc, #92]	; (1ebd4 <SFXLivingStringFrame+0x2f4>)
   1eb76:	6831      	ldr	r1, [r6, #0]
   1eb78:	463c      	mov	r4, r7
   1eb7a:	f107 0818 	add.w	r8, r7, #24
   1eb7e:	fab1 f181 	clz	r1, r1
   1eb82:	0949      	lsrs	r1, r1, #5
   1eb84:	6031      	str	r1, [r6, #0]
   1eb86:	e000      	b.n	1eb8a <SFXLivingStringFrame+0x2aa>
   1eb88:	6831      	ldr	r1, [r6, #0]
			tComplexLivingString_setLevMode(&theString[i], levMode);
   1eb8a:	4620      	mov	r0, r4
   1eb8c:	3404      	adds	r4, #4
   1eb8e:	f00c f8af 	bl	2acf0 <tComplexLivingString_setLevMode>
		for (int i = 0; i < NUM_STRINGS; i++)
   1eb92:	4544      	cmp	r4, r8
   1eb94:	d1f8      	bne.n	1eb88 <SFXLivingStringFrame+0x2a8>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1eb96:	2300      	movs	r3, #0
		setLED_C(levMode);
   1eb98:	7830      	ldrb	r0, [r6, #0]
		independentStrings = !independentStrings;
   1eb9a:	4e0f      	ldr	r6, [pc, #60]	; (1ebd8 <SFXLivingStringFrame+0x2f8>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1eb9c:	772b      	strb	r3, [r5, #28]
		setLED_C(levMode);
   1eb9e:	f7fa fce9 	bl	19574 <setLED_C>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1eba2:	7e2b      	ldrb	r3, [r5, #24]
   1eba4:	2b01      	cmp	r3, #1
   1eba6:	f47f aeaf 	bne.w	1e908 <SFXLivingStringFrame+0x28>
		independentStrings = !independentStrings;
   1ebaa:	6833      	ldr	r3, [r6, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1ebac:	2200      	movs	r2, #0
		independentStrings = !independentStrings;
   1ebae:	fab3 f383 	clz	r3, r3
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1ebb2:	762a      	strb	r2, [r5, #24]
		independentStrings = !independentStrings;
   1ebb4:	095b      	lsrs	r3, r3, #5
		setLED_B(independentStrings);
   1ebb6:	4618      	mov	r0, r3
		independentStrings = !independentStrings;
   1ebb8:	6033      	str	r3, [r6, #0]
		setLED_B(independentStrings);
   1ebba:	f7fa fccd 	bl	19558 <setLED_B>
   1ebbe:	e6a3      	b.n	1e908 <SFXLivingStringFrame+0x28>
   1ebc0:	eb851eb8 	.word	0xeb851eb8
   1ebc4:	3fdeb851 	.word	0x3fdeb851
   1ebc8:	40000000 	.word	0x40000000
   1ebcc:	3f947ae1 	.word	0x3f947ae1
   1ebd0:	020fb31c 	.word	0x020fb31c
   1ebd4:	020f8c78 	.word	0x020f8c78
   1ebd8:	020e31a0 	.word	0x020e31a0
   1ebdc:	42b40000 	.word	0x42b40000
   1ebe0:	020fb3cc 	.word	0x020fb3cc
   1ebe4:	43020000 	.word	0x43020000
   1ebe8:	020e319c 	.word	0x020e319c
   1ebec:	020f8e70 	.word	0x020f8e70
   1ebf0:	3c75c28f 	.word	0x3c75c28f
   1ebf4:	3f7eb852 	.word	0x3f7eb852
   1ebf8:	020fa15c 	.word	0x020fa15c
   1ebfc:	020e3258 	.word	0x020e3258
   1ec00:	2aaaaaab 	.word	0x2aaaaaab
   1ec04:	020e3224 	.word	0x020e3224
   1ec08:	020e31a8 	.word	0x020e31a8
   1ec0c:	020f9890 	.word	0x020f9890
   1ec10:	020f9c68 	.word	0x020f9c68
   1ec14:	020f9a44 	.word	0x020f9a44
   1ec18:	020e31e0 	.word	0x020e31e0
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1ec1c:	ed9b 0a0a 	vldr	s0, [fp, #40]	; 0x28
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   1ec20:	2600      	movs	r6, #0
   1ec22:	4d41      	ldr	r5, [pc, #260]	; (1ed28 <SFXLivingStringFrame+0x448>)
   1ec24:	f104 0a24 	add.w	sl, r4, #36	; 0x24
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1ec28:	ee20 0a28 	vmul.f32	s0, s0, s17
		for (int i = 0; i < NUM_STRINGS; i++)
   1ec2c:	46b1      	mov	r9, r6
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1ec2e:	f00a ff15 	bl	29a5c <LEAF_midiToFrequency>
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1ec32:	eddb 7a0b 	vldr	s15, [fp, #44]	; 0x2c
		displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
   1ec36:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1ec3a:	ee27 0aa8 	vmul.f32	s0, s15, s17
			tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ec3e:	eddf 9a3b 	vldr	s19, [pc, #236]	; 1ed2c <SFXLivingStringFrame+0x44c>
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1ec42:	f00a ff0b 	bl	29a5c <LEAF_midiToFrequency>
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ec46:	eddb 7a0c 	vldr	s15, [fp, #48]	; 0x30
		displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
   1ec4a:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ec4e:	ee27 0aa8 	vmul.f32	s0, s15, s17
			tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ec52:	ed9f 9a37 	vldr	s18, [pc, #220]	; 1ed30 <SFXLivingStringFrame+0x450>
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ec56:	f00a ff01 	bl	29a5c <LEAF_midiToFrequency>
		displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   1ec5a:	eddb 7a0d 	vldr	s15, [fp, #52]	; 0x34
		displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
   1ec5e:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
		displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   1ec62:	ee27 0aa8 	vmul.f32	s0, s15, s17
   1ec66:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 1ed38 <SFXLivingStringFrame+0x458>
   1ec6a:	f00a fef7 	bl	29a5c <LEAF_midiToFrequency>
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   1ec6e:	eddb 7a0e 	vldr	s15, [fp, #56]	; 0x38
   1ec72:	46ab      	mov	fp, r5
		displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
   1ec74:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
		displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
   1ec78:	ee27 0aa8 	vmul.f32	s0, s15, s17
   1ec7c:	f00a feee 	bl	29a5c <LEAF_midiToFrequency>
   1ec80:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
			float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
   1ec84:	2e00      	cmp	r6, #0
   1ec86:	d04b      	beq.n	1ed20 <SFXLivingStringFrame+0x440>
   1ec88:	edda 7a00 	vldr	s15, [sl]
			tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1ec8c:	eeb0 0a48 	vmov.f32	s0, s16
   1ec90:	ecfb 6a01 	vldmia	fp!, {s13}
   1ec94:	ed94 7a01 	vldr	s14, [r4, #4]
   1ec98:	eb07 0509 	add.w	r5, r7, r9
		for (int i = 0; i < NUM_STRINGS; i++)
   1ec9c:	3601      	adds	r6, #1
   1ec9e:	f10a 0a04 	add.w	sl, sl, #4
			tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
   1eca2:	eea6 0a87 	vfma.f32	s0, s13, s14
   1eca6:	4628      	mov	r0, r5
   1eca8:	ee20 0a27 	vmul.f32	s0, s0, s15
   1ecac:	f00b ffa0 	bl	2abf0 <tComplexLivingString_setFreq>
			tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
   1ecb0:	eeb0 0a49 	vmov.f32	s0, s18
   1ecb4:	edd4 7a02 	vldr	s15, [r4, #8]
   1ecb8:	4628      	mov	r0, r5
   1ecba:	eea7 0aa9 	vfma.f32	s0, s15, s19
   1ecbe:	f00b ffff 	bl	2acc0 <tComplexLivingString_setDecay>
			tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1ecc2:	4628      	mov	r0, r5
   1ecc4:	ed94 0a03 	vldr	s0, [r4, #12]
   1ecc8:	f00b ffda 	bl	2ac80 <tComplexLivingString_setDampFreq>
			tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1eccc:	4628      	mov	r0, r5
   1ecce:	ed94 0a04 	vldr	s0, [r4, #16]
   1ecd2:	f00b ffa5 	bl	2ac20 <tComplexLivingString_setPickPos>
			tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1ecd6:	4628      	mov	r0, r5
   1ecd8:	ed94 0a05 	vldr	s0, [r4, #20]
   1ecdc:	f00b ffb0 	bl	2ac40 <tComplexLivingString_setPrepPos>
			tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1ece0:	4628      	mov	r0, r5
   1ece2:	ed94 0a06 	vldr	s0, [r4, #24]
   1ece6:	f00b ffbd 	bl	2ac64 <tComplexLivingString_setPrepIndex>
			tExpSmooth_setDest(&stringGains[i], 1.0f);
   1ecea:	eb08 0009 	add.w	r0, r8, r9
   1ecee:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ecf2:	f109 0904 	add.w	r9, r9, #4
   1ecf6:	f009 f933 	bl	27f60 <tExpSmooth_setDest>
		for (int i = 0; i < NUM_STRINGS; i++)
   1ecfa:	2e06      	cmp	r6, #6
   1ecfc:	d1c2      	bne.n	1ec84 <SFXLivingStringFrame+0x3a4>
}
   1ecfe:	b003      	add	sp, #12
   1ed00:	ecbd 8b04 	vpop	{d8-d9}
   1ed04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ignoreFreqKnobs = !ignoreFreqKnobs;
   1ed08:	4a0a      	ldr	r2, [pc, #40]	; (1ed34 <SFXLivingStringFrame+0x454>)
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ed0a:	2100      	movs	r1, #0
		ignoreFreqKnobs = !ignoreFreqKnobs;
   1ed0c:	6813      	ldr	r3, [r2, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ed0e:	7529      	strb	r1, [r5, #20]
		ignoreFreqKnobs = !ignoreFreqKnobs;
   1ed10:	fab3 f383 	clz	r3, r3
   1ed14:	095b      	lsrs	r3, r3, #5
		setLED_A(ignoreFreqKnobs);
   1ed16:	4618      	mov	r0, r3
		ignoreFreqKnobs = !ignoreFreqKnobs;
   1ed18:	6013      	str	r3, [r2, #0]
		setLED_A(ignoreFreqKnobs);
   1ed1a:	f7fa fc0f 	bl	1953c <setLED_A>
   1ed1e:	e5e9      	b.n	1e8f4 <SFXLivingStringFrame+0x14>
			float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
   1ed20:	edd4 7a00 	vldr	s15, [r4]
   1ed24:	e7b2      	b.n	1ec8c <SFXLivingStringFrame+0x3ac>
   1ed26:	bf00      	nop
   1ed28:	020f8e70 	.word	0x020f8e70
   1ed2c:	3c75c28f 	.word	0x3c75c28f
   1ed30:	3f7eb852 	.word	0x3f7eb852
   1ed34:	020e319c 	.word	0x020e319c
   1ed38:	020f9c68 	.word	0x020f9c68

0001ed3c <SFXLivingStringTick>:
{
   1ed3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ed3e:	4605      	mov	r5, r0
   1ed40:	2400      	movs	r4, #0
   1ed42:	4f10      	ldr	r7, [pc, #64]	; (1ed84 <SFXLivingStringTick+0x48>)
   1ed44:	4e10      	ldr	r6, [pc, #64]	; (1ed88 <SFXLivingStringTick+0x4c>)
   1ed46:	ed2d 8b02 	vpush	{d8}
	float sample = 0.0f;
   1ed4a:	ed9f 8a10 	vldr	s16, [pc, #64]	; 1ed8c <SFXLivingStringTick+0x50>
		float tick = tComplexLivingString_tick(&theString[i], input[1]);
   1ed4e:	1938      	adds	r0, r7, r4
   1ed50:	ed95 0a01 	vldr	s0, [r5, #4]
   1ed54:	f00b ffe2 	bl	2ad1c <tComplexLivingString_tick>
		sample += tick * tExpSmooth_tick(&stringGains[i]);
   1ed58:	1930      	adds	r0, r6, r4
   1ed5a:	3404      	adds	r4, #4
		float tick = tComplexLivingString_tick(&theString[i], input[1]);
   1ed5c:	eef0 8a40 	vmov.f32	s17, s0
		sample += tick * tExpSmooth_tick(&stringGains[i]);
   1ed60:	f009 f908 	bl	27f74 <tExpSmooth_tick>
	for (int i = 0; i < NUM_STRINGS; i++)
   1ed64:	2c18      	cmp	r4, #24
		sample += tick * tExpSmooth_tick(&stringGains[i]);
   1ed66:	eea0 8a28 	vfma.f32	s16, s0, s17
	for (int i = 0; i < NUM_STRINGS; i++)
   1ed6a:	d1f0      	bne.n	1ed4e <SFXLivingStringTick+0x12>
	sample *= 0.1625f;
   1ed6c:	eddf 7a08 	vldr	s15, [pc, #32]	; 1ed90 <SFXLivingStringTick+0x54>
   1ed70:	ee28 8a27 	vmul.f32	s16, s16, s15
	input[0] = sample;
   1ed74:	ed85 8a00 	vstr	s16, [r5]
	input[1] = sample;
   1ed78:	ed85 8a01 	vstr	s16, [r5, #4]
}
   1ed7c:	ecbd 8b02 	vpop	{d8}
   1ed80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ed82:	bf00      	nop
   1ed84:	020f8c78 	.word	0x020f8c78
   1ed88:	020f9c68 	.word	0x020f9c68
   1ed8c:	00000000 	.word	0x00000000
   1ed90:	3e266666 	.word	0x3e266666

0001ed94 <SFXLivingStringFree>:
{
   1ed94:	b570      	push	{r4, r5, r6, lr}
   1ed96:	2400      	movs	r4, #0
   1ed98:	4e05      	ldr	r6, [pc, #20]	; (1edb0 <SFXLivingStringFree+0x1c>)
   1ed9a:	4d06      	ldr	r5, [pc, #24]	; (1edb4 <SFXLivingStringFree+0x20>)
		tComplexLivingString_free(&theString[i]);
   1ed9c:	1930      	adds	r0, r6, r4
   1ed9e:	f00b fedb 	bl	2ab58 <tComplexLivingString_free>
		tExpSmooth_free(&stringGains[i]);
   1eda2:	1928      	adds	r0, r5, r4
   1eda4:	3404      	adds	r4, #4
   1eda6:	f009 f8c5 	bl	27f34 <tExpSmooth_free>
	for (int i = 0; i < NUM_STRINGS; i++)
   1edaa:	2c18      	cmp	r4, #24
   1edac:	d1f6      	bne.n	1ed9c <SFXLivingStringFree+0x8>
}
   1edae:	bd70      	pop	{r4, r5, r6, pc}
   1edb0:	020f8c78 	.word	0x020f8c78
   1edb4:	020f9c68 	.word	0x020f9c68

0001edb8 <SFXLivingStringSynthAlloc>:
	levMode = 1;
   1edb8:	4a44      	ldr	r2, [pc, #272]	; (1eecc <SFXLivingStringSynthAlloc+0x114>)
   1edba:	2001      	movs	r0, #1
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1edbc:	2106      	movs	r1, #6
{
   1edbe:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	leaf.clearOnAllocation = 0;
   1edc2:	2300      	movs	r3, #0
   1edc4:	f8df b158 	ldr.w	fp, [pc, #344]	; 1ef20 <SFXLivingStringSynthAlloc+0x168>
   1edc8:	4e41      	ldr	r6, [pc, #260]	; (1eed0 <SFXLivingStringSynthAlloc+0x118>)
   1edca:	f8df a158 	ldr.w	sl, [pc, #344]	; 1ef24 <SFXLivingStringSynthAlloc+0x16c>
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1edce:	461c      	mov	r4, r3
   1edd0:	f8df 9154 	ldr.w	r9, [pc, #340]	; 1ef28 <SFXLivingStringSynthAlloc+0x170>
   1edd4:	f8df 8154 	ldr.w	r8, [pc, #340]	; 1ef2c <SFXLivingStringSynthAlloc+0x174>
   1edd8:	4f3e      	ldr	r7, [pc, #248]	; (1eed4 <SFXLivingStringSynthAlloc+0x11c>)
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   1edda:	4d3f      	ldr	r5, [pc, #252]	; (1eed8 <SFXLivingStringSynthAlloc+0x120>)
	leaf.clearOnAllocation = 0;
   1eddc:	f8cb 3014 	str.w	r3, [fp, #20]
{
   1ede0:	ed2d 8b06 	vpush	{d8-d10}
		tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   1ede4:	ed9f aa3d 	vldr	s20, [pc, #244]	; 1eedc <SFXLivingStringSynthAlloc+0x124>
   1ede8:	eddf 8a3d 	vldr	s17, [pc, #244]	; 1eee0 <SFXLivingStringSynthAlloc+0x128>
   1edec:	eddf 9a3d 	vldr	s19, [pc, #244]	; 1eee4 <SFXLivingStringSynthAlloc+0x12c>
   1edf0:	ed9f 9a3d 	vldr	s18, [pc, #244]	; 1eee8 <SFXLivingStringSynthAlloc+0x130>
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   1edf4:	ed9f 8a3d 	vldr	s16, [pc, #244]	; 1eeec <SFXLivingStringSynthAlloc+0x134>
	levMode = 1;
   1edf8:	6010      	str	r0, [r2, #0]
	tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
   1edfa:	483d      	ldr	r0, [pc, #244]	; (1eef0 <SFXLivingStringSynthAlloc+0x138>)
   1edfc:	f00b fba4 	bl	2a548 <tSimplePoly_setNumVoices>
		tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
   1ee00:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
   1ee04:	eddf 1a36 	vldr	s3, [pc, #216]	; 1eee0 <SFXLivingStringSynthAlloc+0x128>
   1ee08:	eef0 3a4a 	vmov.f32	s7, s20
   1ee0c:	eb0a 0004 	add.w	r0, sl, r4
   1ee10:	eeb0 3a68 	vmov.f32	s6, s17
   1ee14:	6831      	ldr	r1, [r6, #0]
   1ee16:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
   1ee1a:	eddf 0a36 	vldr	s1, [pc, #216]	; 1eef4 <SFXLivingStringSynthAlloc+0x13c>
   1ee1e:	eeb0 2a69 	vmov.f32	s4, s19
   1ee22:	ed9f 0a35 	vldr	s0, [pc, #212]	; 1eef8 <SFXLivingStringSynthAlloc+0x140>
   1ee26:	eeb0 1a49 	vmov.f32	s2, s18
   1ee2a:	f00b fe8f 	bl	2ab4c <tComplexLivingString_init>
		tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
   1ee2e:	eb09 0004 	add.w	r0, r9, r4
   1ee32:	4629      	mov	r1, r5
   1ee34:	eef0 0a48 	vmov.f32	s1, s16
   1ee38:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1ee3c:	f009 f8aa 	bl	27f94 <tSlide_initToPool>
		tSlide_initToPool(&stringInEnvs[i], 12.0f, 1000.0f, &smallPool);
   1ee40:	eb08 0004 	add.w	r0, r8, r4
   1ee44:	4629      	mov	r1, r5
   1ee46:	eef0 0a48 	vmov.f32	s1, s16
   1ee4a:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
   1ee4e:	f009 f8a1 	bl	27f94 <tSlide_initToPool>
		tADSR4_initToPool(&pluckEnvs[i], 4.0f, 70.0f, 0.0f, 5.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1ee52:	1938      	adds	r0, r7, r4
   1ee54:	3404      	adds	r4, #4
   1ee56:	462b      	mov	r3, r5
   1ee58:	f44f 7200 	mov.w	r2, #512	; 0x200
   1ee5c:	4927      	ldr	r1, [pc, #156]	; (1eefc <SFXLivingStringSynthAlloc+0x144>)
   1ee5e:	eef1 1a04 	vmov.f32	s3, #20	; 0x40a00000  5.0
   1ee62:	eddf 0a27 	vldr	s1, [pc, #156]	; 1ef00 <SFXLivingStringSynthAlloc+0x148>
   1ee66:	eeb0 1a68 	vmov.f32	s2, s17
   1ee6a:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
   1ee6e:	f008 fc83 	bl	27778 <tADSR4_initToPool>
	for (int i = 0; i < NUM_STRINGS; i++)
   1ee72:	2c18      	cmp	r4, #24
   1ee74:	d1c4      	bne.n	1ee00 <SFXLivingStringSynthAlloc+0x48>
	tVZFilter_initToPool(&pluckFilt, BandpassPeak, 2000.0f, 4.0f, &smallPool);
   1ee76:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
   1ee7a:	ed9f 0a22 	vldr	s0, [pc, #136]	; 1ef04 <SFXLivingStringSynthAlloc+0x14c>
   1ee7e:	4a16      	ldr	r2, [pc, #88]	; (1eed8 <SFXLivingStringSynthAlloc+0x120>)
   1ee80:	2103      	movs	r1, #3
   1ee82:	4821      	ldr	r0, [pc, #132]	; (1ef08 <SFXLivingStringSynthAlloc+0x150>)
   1ee84:	f009 fbbe 	bl	28604 <tVZFilter_initToPool>
	tNoise_initToPool(&stringPluckNoise, WhiteNoise, &smallPool);
   1ee88:	4a13      	ldr	r2, [pc, #76]	; (1eed8 <SFXLivingStringSynthAlloc+0x120>)
   1ee8a:	2100      	movs	r1, #0
   1ee8c:	481f      	ldr	r0, [pc, #124]	; (1ef0c <SFXLivingStringSynthAlloc+0x154>)
   1ee8e:	f00b fccf 	bl	2a830 <tNoise_initToPool>
	setLED_A(numVoices == 1);
   1ee92:	4b1f      	ldr	r3, [pc, #124]	; (1ef10 <SFXLivingStringSynthAlloc+0x158>)
   1ee94:	7818      	ldrb	r0, [r3, #0]
   1ee96:	f1a0 0001 	sub.w	r0, r0, #1
   1ee9a:	fab0 f080 	clz	r0, r0
   1ee9e:	0940      	lsrs	r0, r0, #5
   1eea0:	f7fa fb4c 	bl	1953c <setLED_A>
	setLED_B(voicePluck);
   1eea4:	4b1b      	ldr	r3, [pc, #108]	; (1ef14 <SFXLivingStringSynthAlloc+0x15c>)
   1eea6:	7818      	ldrb	r0, [r3, #0]
   1eea8:	f7fa fb56 	bl	19558 <setLED_B>
	setLED_C(levModeStr);
   1eeac:	7830      	ldrb	r0, [r6, #0]
   1eeae:	f7fa fb61 	bl	19574 <setLED_C>
	samplesPerMs = leaf.sampleRate / 1000.0f;
   1eeb2:	eddb 7a00 	vldr	s15, [fp]
   1eeb6:	ed9f 7a18 	vldr	s14, [pc, #96]	; 1ef18 <SFXLivingStringSynthAlloc+0x160>
   1eeba:	4b18      	ldr	r3, [pc, #96]	; (1ef1c <SFXLivingStringSynthAlloc+0x164>)
   1eebc:	ee67 7a87 	vmul.f32	s15, s15, s14
   1eec0:	edc3 7a00 	vstr	s15, [r3]
}
   1eec4:	ecbd 8b06 	vpop	{d8-d10}
   1eec8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1eecc:	020e31a8 	.word	0x020e31a8
   1eed0:	020e31ac 	.word	0x020e31ac
   1eed4:	020fa048 	.word	0x020fa048
   1eed8:	020f7730 	.word	0x020f7730
   1eedc:	3c23d70a 	.word	0x3c23d70a
   1eee0:	00000000 	.word	0x00000000
   1eee4:	460ca000 	.word	0x460ca000
   1eee8:	3e99999a 	.word	0x3e99999a
   1eeec:	447a0000 	.word	0x447a0000
   1eef0:	020fa15c 	.word	0x020fa15c
   1eef4:	3e4ccccd 	.word	0x3e4ccccd
   1eef8:	43dc0000 	.word	0x43dc0000
   1eefc:	020fa578 	.word	0x020fa578
   1ef00:	428c0000 	.word	0x428c0000
   1ef04:	44fa0000 	.word	0x44fa0000
   1ef08:	020fafa4 	.word	0x020fafa4
   1ef0c:	020f8f4c 	.word	0x020f8f4c
   1ef10:	00062ae4 	.word	0x00062ae4
   1ef14:	020e3220 	.word	0x020e3220
   1ef18:	3a83126f 	.word	0x3a83126f
   1ef1c:	00062b40 	.word	0x00062b40
   1ef20:	020fc0a8 	.word	0x020fc0a8
   1ef24:	020f8c78 	.word	0x020f8c78
   1ef28:	020fa230 	.word	0x020fa230
   1ef2c:	020fa2f8 	.word	0x020fa2f8

0001ef30 <SFXLivingStringSynthFrame>:
{
   1ef30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ef34:	4dc0      	ldr	r5, [pc, #768]	; (1f238 <SFXLivingStringSynthFrame+0x308>)
{
   1ef36:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ef3a:	7d2b      	ldrb	r3, [r5, #20]
{
   1ef3c:	b083      	sub	sp, #12
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1ef3e:	2b01      	cmp	r3, #1
   1ef40:	d113      	bne.n	1ef6a <SFXLivingStringSynthFrame+0x3a>
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   1ef42:	4cbe      	ldr	r4, [pc, #760]	; (1f23c <SFXLivingStringSynthFrame+0x30c>)
		tSimplePoly_setNumVoices(&poly, numVoices);
   1ef44:	48be      	ldr	r0, [pc, #760]	; (1f240 <SFXLivingStringSynthFrame+0x310>)
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   1ef46:	7822      	ldrb	r2, [r4, #0]
   1ef48:	2a01      	cmp	r2, #1
   1ef4a:	bf98      	it	ls
   1ef4c:	2306      	movls	r3, #6
		tSimplePoly_setNumVoices(&poly, numVoices);
   1ef4e:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
   1ef50:	7023      	strb	r3, [r4, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   1ef52:	f00b faf9 	bl	2a548 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   1ef56:	7820      	ldrb	r0, [r4, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ef58:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   1ef5a:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1ef5e:	752b      	strb	r3, [r5, #20]
		setLED_A(numVoices == 1);
   1ef60:	fab0 f080 	clz	r0, r0
   1ef64:	0940      	lsrs	r0, r0, #5
   1ef66:	f7fa fae9 	bl	1953c <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1ef6a:	7e2b      	ldrb	r3, [r5, #24]
   1ef6c:	2b01      	cmp	r3, #1
   1ef6e:	f000 814a 	beq.w	1f206 <SFXLivingStringSynthFrame+0x2d6>
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   1ef72:	7f2b      	ldrb	r3, [r5, #28]
   1ef74:	2b01      	cmp	r3, #1
   1ef76:	f000 812d 	beq.w	1f1d4 <SFXLivingStringSynthFrame+0x2a4>
   1ef7a:	f8df a318 	ldr.w	sl, [pc, #792]	; 1f294 <SFXLivingStringSynthFrame+0x364>
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1ef7e:	4db1      	ldr	r5, [pc, #708]	; (1f244 <SFXLivingStringSynthFrame+0x314>)
   1ef80:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1ef84:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1ef88:	eddf 6aaf 	vldr	s13, [pc, #700]	; 1f248 <SFXLivingStringSynthFrame+0x318>
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1ef8c:	462b      	mov	r3, r5
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1ef8e:	ed95 6a03 	vldr	s12, [r5, #12]
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1ef92:	4cae      	ldr	r4, [pc, #696]	; (1f24c <SFXLivingStringSynthFrame+0x31c>)
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1ef94:	2600      	movs	r6, #0
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1ef96:	ecf3 7a01 	vldmia	r3!, {s15}
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1ef9a:	eea6 0a26 	vfma.f32	s0, s12, s13
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   1ef9e:	eddf 8aac 	vldr	s17, [pc, #688]	; 1f250 <SFXLivingStringSynthFrame+0x320>
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1efa2:	ee67 7a87 	vmul.f32	s15, s15, s14
	displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
   1efa6:	681a      	ldr	r2, [r3, #0]
	displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
   1efa8:	68ab      	ldr	r3, [r5, #8]
	displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
   1efaa:	6062      	str	r2, [r4, #4]
	displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
   1efac:	60a3      	str	r3, [r4, #8]
	displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
   1efae:	edc4 7a00 	vstr	s15, [r4]
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1efb2:	f00a fdd7 	bl	29b64 <faster_mtof>
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1efb6:	eeb2 7a01 	vmov.f32	s14, #33	; 0x41080000  8.5
   1efba:	edd5 6a06 	vldr	s13, [r5, #24]
   1efbe:	eef9 7a01 	vmov.f32	s15, #145	; 0xc0880000 -4.250
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1efc2:	ed95 4a04 	vldr	s8, [r5, #16]
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1efc6:	ed95 5a05 	vldr	s10, [r5, #20]
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1efca:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
	displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
   1efce:	ed84 0a03 	vstr	s0, [r4, #12]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1efd2:	eee6 7a87 	vfma.f32	s15, s13, s14
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   1efd6:	ed9f 8a9f 	vldr	s16, [pc, #636]	; 1f254 <SFXLivingStringSynthFrame+0x324>
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1efda:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
   1efde:	f8df b2b8 	ldr.w	fp, [pc, #696]	; 1f298 <SFXLivingStringSynthFrame+0x368>
   1efe2:	4f9d      	ldr	r7, [pc, #628]	; (1f258 <SFXLivingStringSynthFrame+0x328>)
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1efe4:	ed9f 3b8e 	vldr	d3, [pc, #568]	; 1f220 <SFXLivingStringSynthFrame+0x2f0>
   1efe8:	ed9f 6b8f 	vldr	d6, [pc, #572]	; 1f228 <SFXLivingStringSynthFrame+0x2f8>
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1efec:	eeb0 0a67 	vmov.f32	s0, s15
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1eff0:	ed9f 7b8f 	vldr	d7, [pc, #572]	; 1f230 <SFXLivingStringSynthFrame+0x300>
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1eff4:	eea4 6b03 	vfma.f64	d6, d4, d3
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1eff8:	eea5 7b03 	vfma.f64	d7, d5, d3
	displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
   1effc:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
   1f000:	ed84 6a04 	vstr	s12, [r4, #16]
	displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
   1f004:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   1f008:	ed84 7a05 	vstr	s14, [r4, #20]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1f00c:	f00a fc8c 	bl	29928 <LEAF_tanh>
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f010:	4b92      	ldr	r3, [pc, #584]	; (1f25c <SFXLivingStringSynthFrame+0x32c>)
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1f012:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f016:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1f01a:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f01e:	edd3 5a00 	vldr	s11, [r3]
	displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
   1f022:	6a2a      	ldr	r2, [r5, #32]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1f024:	ee30 0a07 	vadd.f32	s0, s0, s14
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f028:	ee67 7aa5 	vmul.f32	s15, s15, s11
   1f02c:	4b8c      	ldr	r3, [pc, #560]	; (1f260 <SFXLivingStringSynthFrame+0x330>)
	displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
   1f02e:	6222      	str	r2, [r4, #32]
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f030:	eddf 6a8c 	vldr	s13, [pc, #560]	; 1f264 <SFXLivingStringSynthFrame+0x334>
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1f034:	ee20 0a06 	vmul.f32	s0, s0, s12
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f038:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
   1f03c:	69e9      	ldr	r1, [r5, #28]
	displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
   1f03e:	ed84 0a06 	vstr	s0, [r4, #24]
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f042:	ee17 2a90 	vmov	r2, s15
	displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
   1f046:	61e1      	str	r1, [r4, #28]
	displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
   1f048:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1f04c:	edd3 7a00 	vldr	s15, [r3]
   1f050:	ee67 7aa6 	vmul.f32	s15, s15, s13
   1f054:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
		tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
   1f058:	eeb0 0a48 	vmov.f32	s0, s16
   1f05c:	edd4 7a02 	vldr	s15, [r4, #8]
   1f060:	eb0a 0506 	add.w	r5, sl, r6
   1f064:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1f068:	4628      	mov	r0, r5
   1f06a:	f00b fe29 	bl	2acc0 <tComplexLivingString_setDecay>
		tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
   1f06e:	4628      	mov	r0, r5
   1f070:	ed94 0a03 	vldr	s0, [r4, #12]
   1f074:	f00b fe04 	bl	2ac80 <tComplexLivingString_setDampFreq>
		tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
   1f078:	4628      	mov	r0, r5
   1f07a:	ed94 0a04 	vldr	s0, [r4, #16]
   1f07e:	f00b fdcf 	bl	2ac20 <tComplexLivingString_setPickPos>
		tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
   1f082:	4628      	mov	r0, r5
   1f084:	ed94 0a05 	vldr	s0, [r4, #20]
   1f088:	f00b fdda 	bl	2ac40 <tComplexLivingString_setPrepPos>
		tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
   1f08c:	4628      	mov	r0, r5
   1f08e:	ed94 0a06 	vldr	s0, [r4, #24]
   1f092:	f00b fde7 	bl	2ac64 <tComplexLivingString_setPrepIndex>
		tSlide_setDownSlide(&stringOutEnvs[i], displayValues[9] * samplesPerMs);
   1f096:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   1f09a:	edd7 7a00 	vldr	s15, [r7]
   1f09e:	eb0b 0006 	add.w	r0, fp, r6
   1f0a2:	3604      	adds	r6, #4
   1f0a4:	ee20 0a27 	vmul.f32	s0, s0, s15
   1f0a8:	f008 ff9e 	bl	27fe8 <tSlide_setDownSlide>
	for (int i = 0; i < NUM_STRINGS; i++)
   1f0ac:	2e18      	cmp	r6, #24
   1f0ae:	d1d3      	bne.n	1f058 <SFXLivingStringSynthFrame+0x128>
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   1f0b0:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   1f0b4:	ed94 7a01 	vldr	s14, [r4, #4]
   1f0b8:	eddf 7a6b 	vldr	s15, [pc, #428]	; 1f268 <SFXLivingStringSynthFrame+0x338>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f0bc:	2500      	movs	r5, #0
   1f0be:	4b6b      	ldr	r3, [pc, #428]	; (1f26c <SFXLivingStringSynthFrame+0x33c>)
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   1f0c0:	eea7 0a27 	vfma.f32	s0, s14, s15
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f0c4:	462e      	mov	r6, r5
   1f0c6:	9301      	str	r3, [sp, #4]
	tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
   1f0c8:	f00a fd4c 	bl	29b64 <faster_mtof>
   1f0cc:	4868      	ldr	r0, [pc, #416]	; (1f270 <SFXLivingStringSynthFrame+0x340>)
   1f0ce:	f009 fd09 	bl	28ae4 <tVZFilter_setFreq>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f0d2:	f8df 816c 	ldr.w	r8, [pc, #364]	; 1f240 <SFXLivingStringSynthFrame+0x310>
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f0d6:	eddf 8a67 	vldr	s17, [pc, #412]	; 1f274 <SFXLivingStringSynthFrame+0x344>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f0da:	e01a      	b.n	1f112 <SFXLivingStringSynthFrame+0x1e2>
			tComplexLivingString_setTargetLev(&theString[i],voiceOn * displayValues[8]);
   1f0dc:	ed94 0a08 	vldr	s0, [r4, #32]
   1f0e0:	ee28 0a00 	vmul.f32	s0, s16, s0
   1f0e4:	f00b fdf0 	bl	2acc8 <tComplexLivingString_setTargetLev>
		if (voiceOn)
   1f0e8:	eeb5 8a40 	vcmp.f32	s16, #0.0
   1f0ec:	4f62      	ldr	r7, [pc, #392]	; (1f278 <SFXLivingStringSynthFrame+0x348>)
   1f0ee:	eb0b 0305 	add.w	r3, fp, r5
			tSlide_setDest(&stringOutEnvs[i], 1.0f);
   1f0f2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1f0f6:	442f      	add	r7, r5
		if (voiceOn)
   1f0f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			tSlide_setDest(&stringOutEnvs[i], 1.0f);
   1f0fc:	4618      	mov	r0, r3
		if (voiceOn)
   1f0fe:	d05a      	beq.n	1f1b6 <SFXLivingStringSynthFrame+0x286>
			tSlide_setDest(&stringOutEnvs[i], 1.0f);
   1f100:	f008 ff7a 	bl	27ff8 <tSlide_setDest>
			tSlide_setDest(&stringInEnvs[i], 1.0f);
   1f104:	4638      	mov	r0, r7
   1f106:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1f10a:	f008 ff75 	bl	27ff8 <tSlide_setDest>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f10e:	3601      	adds	r6, #1
   1f110:	3504      	adds	r5, #4
   1f112:	4640      	mov	r0, r8
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f114:	fa5f f986 	uxtb.w	r9, r6
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f118:	f00b fa1e 	bl	2a558 <tSimplePoly_getNumVoices>
   1f11c:	42b0      	cmp	r0, r6
   1f11e:	eb0a 0705 	add.w	r7, sl, r5
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f122:	4649      	mov	r1, r9
   1f124:	4640      	mov	r0, r8
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1f126:	dd50      	ble.n	1f1ca <SFXLivingStringSynthFrame+0x29a>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f128:	f00b fa32 	bl	2a590 <tSimplePoly_getPitch>
   1f12c:	ee07 0a90 	vmov	s15, r0
   1f130:	4a52      	ldr	r2, [pc, #328]	; (1f27c <SFXLivingStringSynthFrame+0x34c>)
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f132:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f136:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f13a:	4b51      	ldr	r3, [pc, #324]	; (1f280 <SFXLivingStringSynthFrame+0x350>)
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f13c:	ed92 0a00 	vldr	s0, [r2]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f140:	781a      	ldrb	r2, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f142:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f146:	494f      	ldr	r1, [pc, #316]	; (1f284 <SFXLivingStringSynthFrame+0x354>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f148:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1f14c:	ee17 3a90 	vmov	r3, s15
   1f150:	1a9b      	subs	r3, r3, r2
   1f152:	4a4d      	ldr	r2, [pc, #308]	; (1f288 <SFXLivingStringSynthFrame+0x358>)
   1f154:	fb82 2003 	smull	r2, r0, r2, r3
   1f158:	17da      	asrs	r2, r3, #31
   1f15a:	ebc2 0260 	rsb	r2, r2, r0, asr #1
   1f15e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1f162:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   1f166:	ee07 3a90 	vmov	s15, r3
   1f16a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f16e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f172:	ee17 3a90 	vmov	r3, s15
   1f176:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   1f17a:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1f17e:	ee37 0a00 	vadd.f32	s0, s14, s0
   1f182:	f00a fc6b 	bl	29a5c <LEAF_midiToFrequency>
   1f186:	9b01      	ldr	r3, [sp, #4]
		tComplexLivingString_setFreq(&theString[i], freq[i]);
   1f188:	4638      	mov	r0, r7
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1f18a:	eca3 0a01 	vstmia	r3!, {s0}
   1f18e:	9301      	str	r3, [sp, #4]
		tComplexLivingString_setFreq(&theString[i], freq[i]);
   1f190:	f00b fd2e 	bl	2abf0 <tComplexLivingString_setFreq>
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f194:	4649      	mov	r1, r9
   1f196:	4640      	mov	r0, r8
   1f198:	f00b fa06 	bl	2a5a8 <tSimplePoly_getVelocity>
		if (levModeStr)
   1f19c:	4b3b      	ldr	r3, [pc, #236]	; (1f28c <SFXLivingStringSynthFrame+0x35c>)
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f19e:	2800      	cmp	r0, #0
			tComplexLivingString_setTargetLev(&theString[i],1.0f);
   1f1a0:	eeb0 0a48 	vmov.f32	s0, s16
		if (levModeStr)
   1f1a4:	681b      	ldr	r3, [r3, #0]
			tComplexLivingString_setTargetLev(&theString[i],1.0f);
   1f1a6:	4638      	mov	r0, r7
		float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
   1f1a8:	fe38 8a28 	vselgt.f32	s16, s16, s17
		if (levModeStr)
   1f1ac:	2b00      	cmp	r3, #0
   1f1ae:	d195      	bne.n	1f0dc <SFXLivingStringSynthFrame+0x1ac>
			tComplexLivingString_setTargetLev(&theString[i],1.0f);
   1f1b0:	f00b fd8a 	bl	2acc8 <tComplexLivingString_setTargetLev>
   1f1b4:	e798      	b.n	1f0e8 <SFXLivingStringSynthFrame+0x1b8>
			tSlide_setDest(&stringOutEnvs[i], displayValues[7]);
   1f1b6:	ed94 0a07 	vldr	s0, [r4, #28]
   1f1ba:	f008 ff1d 	bl	27ff8 <tSlide_setDest>
			tSlide_setDest(&stringInEnvs[i], 0.0f);
   1f1be:	eeb0 0a68 	vmov.f32	s0, s17
   1f1c2:	4638      	mov	r0, r7
   1f1c4:	f008 ff18 	bl	27ff8 <tSlide_setDest>
   1f1c8:	e7a1      	b.n	1f10e <SFXLivingStringSynthFrame+0x1de>
}
   1f1ca:	b003      	add	sp, #12
   1f1cc:	ecbd 8b02 	vpop	{d8}
   1f1d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		levModeStr = !levModeStr;
   1f1d4:	4e2d      	ldr	r6, [pc, #180]	; (1f28c <SFXLivingStringSynthFrame+0x35c>)
   1f1d6:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 1f294 <SFXLivingStringSynthFrame+0x364>
   1f1da:	6831      	ldr	r1, [r6, #0]
   1f1dc:	4654      	mov	r4, sl
   1f1de:	f10a 0718 	add.w	r7, sl, #24
   1f1e2:	fab1 f181 	clz	r1, r1
   1f1e6:	0949      	lsrs	r1, r1, #5
   1f1e8:	6031      	str	r1, [r6, #0]
   1f1ea:	e000      	b.n	1f1ee <SFXLivingStringSynthFrame+0x2be>
   1f1ec:	6831      	ldr	r1, [r6, #0]
			tComplexLivingString_setLevMode(&theString[i], levModeStr);
   1f1ee:	4620      	mov	r0, r4
   1f1f0:	3404      	adds	r4, #4
   1f1f2:	f00b fd7d 	bl	2acf0 <tComplexLivingString_setLevMode>
		for (int i = 0; i < NUM_STRINGS; i++)
   1f1f6:	42a7      	cmp	r7, r4
   1f1f8:	d1f8      	bne.n	1f1ec <SFXLivingStringSynthFrame+0x2bc>
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1f1fa:	2300      	movs	r3, #0
		setLED_C(levModeStr);
   1f1fc:	7830      	ldrb	r0, [r6, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   1f1fe:	772b      	strb	r3, [r5, #28]
		setLED_C(levModeStr);
   1f200:	f7fa f9b8 	bl	19574 <setLED_C>
   1f204:	e6bb      	b.n	1ef7e <SFXLivingStringSynthFrame+0x4e>
		voicePluck = !voicePluck;
   1f206:	4a22      	ldr	r2, [pc, #136]	; (1f290 <SFXLivingStringSynthFrame+0x360>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f208:	2100      	movs	r1, #0
		voicePluck = !voicePluck;
   1f20a:	6813      	ldr	r3, [r2, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f20c:	7629      	strb	r1, [r5, #24]
		voicePluck = !voicePluck;
   1f20e:	fab3 f383 	clz	r3, r3
   1f212:	095b      	lsrs	r3, r3, #5
		setLED_B(voicePluck);
   1f214:	4618      	mov	r0, r3
		voicePluck = !voicePluck;
   1f216:	6013      	str	r3, [r2, #0]
		setLED_B(voicePluck);
   1f218:	f7fa f99e 	bl	19558 <setLED_B>
   1f21c:	e6a9      	b.n	1ef72 <SFXLivingStringSynthFrame+0x42>
   1f21e:	bf00      	nop
   1f220:	c28f5c29 	.word	0xc28f5c29
   1f224:	3fdc28f5 	.word	0x3fdc28f5
   1f228:	00000000 	.word	0x00000000
   1f22c:	3fe0a3d7 	.word	0x3fe0a3d7
   1f230:	40000000 	.word	0x40000000
   1f234:	3fa47ae1 	.word	0x3fa47ae1
   1f238:	020fb31c 	.word	0x020fb31c
   1f23c:	00062ae4 	.word	0x00062ae4
   1f240:	020fa15c 	.word	0x020fa15c
   1f244:	020f98f4 	.word	0x020f98f4
   1f248:	42ee0000 	.word	0x42ee0000
   1f24c:	020fb3cc 	.word	0x020fb3cc
   1f250:	3ca3d70a 	.word	0x3ca3d70a
   1f254:	3f7ae148 	.word	0x3f7ae148
   1f258:	00062b40 	.word	0x00062b40
   1f25c:	00062acc 	.word	0x00062acc
   1f260:	020f9c84 	.word	0x020f9c84
   1f264:	46000000 	.word	0x46000000
   1f268:	42c80000 	.word	0x42c80000
   1f26c:	020f9a44 	.word	0x020f9a44
   1f270:	020fafa4 	.word	0x020fafa4
   1f274:	00000000 	.word	0x00000000
   1f278:	020fa2f8 	.word	0x020fa2f8
   1f27c:	020e31e0 	.word	0x020e31e0
   1f280:	020e3258 	.word	0x020e3258
   1f284:	020e3224 	.word	0x020e3224
   1f288:	2aaaaaab 	.word	0x2aaaaaab
   1f28c:	020e31ac 	.word	0x020e31ac
   1f290:	020e3220 	.word	0x020e3220
   1f294:	020f8c78 	.word	0x020f8c78
   1f298:	020fa230 	.word	0x020fa230

0001f29c <SFXLivingStringSynthTick>:
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f29c:	4b27      	ldr	r3, [pc, #156]	; (1f33c <SFXLivingStringSynthTick+0xa0>)
{
   1f29e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1f2a2:	ed2d 8b06 	vpush	{d8-d10}
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f2a6:	ed93 8a00 	vldr	s16, [r3]
{
   1f2aa:	4606      	mov	r6, r0
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f2ac:	4824      	ldr	r0, [pc, #144]	; (1f340 <SFXLivingStringSynthTick+0xa4>)
	pluck = tVZFilter_tick(&pluckFilt, pluck);
   1f2ae:	2400      	movs	r4, #0
	float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
   1f2b0:	f00b fad4 	bl	2a85c <tNoise_tick>
	pluck = tVZFilter_tick(&pluckFilt, pluck);
   1f2b4:	4823      	ldr	r0, [pc, #140]	; (1f344 <SFXLivingStringSynthTick+0xa8>)
   1f2b6:	ee28 0a00 	vmul.f32	s0, s16, s0
	float sample = 0.0f;
   1f2ba:	ed9f 9a23 	vldr	s18, [pc, #140]	; 1f348 <SFXLivingStringSynthTick+0xac>
	pluck = tVZFilter_tick(&pluckFilt, pluck);
   1f2be:	f009 fba1 	bl	28a04 <tVZFilter_tick>
   1f2c2:	eeb0 aa40 	vmov.f32	s20, s0
   1f2c6:	f8df a090 	ldr.w	sl, [pc, #144]	; 1f358 <SFXLivingStringSynthTick+0xbc>
   1f2ca:	f8df 9090 	ldr.w	r9, [pc, #144]	; 1f35c <SFXLivingStringSynthTick+0xc0>
   1f2ce:	f8df 8090 	ldr.w	r8, [pc, #144]	; 1f360 <SFXLivingStringSynthTick+0xc4>
   1f2d2:	4f1e      	ldr	r7, [pc, #120]	; (1f34c <SFXLivingStringSynthTick+0xb0>)
		inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
   1f2d4:	edda 7a00 	vldr	s15, [sl]
   1f2d8:	eb09 0004 	add.w	r0, r9, r4
   1f2dc:	edd6 9a01 	vldr	s19, [r6, #4]
   1f2e0:	eb08 0504 	add.w	r5, r8, r4
   1f2e4:	eef8 8ae7 	vcvt.f32.s32	s17, s15
   1f2e8:	f008 fb02 	bl	278f0 <tADSR4_tick>
   1f2ec:	ee20 8a0a 	vmul.f32	s16, s0, s20
		sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   1f2f0:	4628      	mov	r0, r5
   1f2f2:	f008 fe85 	bl	28000 <tSlide_tickNoInput>
   1f2f6:	1938      	adds	r0, r7, r4
   1f2f8:	3404      	adds	r4, #4
		inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
   1f2fa:	eea9 8aa8 	vfma.f32	s16, s19, s17
		sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   1f2fe:	ee20 0a08 	vmul.f32	s0, s0, s16
   1f302:	f00b fd0b 	bl	2ad1c <tComplexLivingString_tick>
   1f306:	4628      	mov	r0, r5
   1f308:	eeb0 8a40 	vmov.f32	s16, s0
   1f30c:	f008 fe78 	bl	28000 <tSlide_tickNoInput>
	for (int i = 0; i < NUM_STRINGS; i++)
   1f310:	2c18      	cmp	r4, #24
		sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
   1f312:	eea8 9a00 	vfma.f32	s18, s16, s0
	for (int i = 0; i < NUM_STRINGS; i++)
   1f316:	d1dd      	bne.n	1f2d4 <SFXLivingStringSynthTick+0x38>
	sample *= 0.1625f;
   1f318:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 1f350 <SFXLivingStringSynthTick+0xb4>
	sample = LEAF_tanh(sample) * 0.98f;
   1f31c:	ee29 0a00 	vmul.f32	s0, s18, s0
   1f320:	f00a fb02 	bl	29928 <LEAF_tanh>
   1f324:	eddf 7a0b 	vldr	s15, [pc, #44]	; 1f354 <SFXLivingStringSynthTick+0xb8>
   1f328:	ee20 0a27 	vmul.f32	s0, s0, s15
	input[0] = sample;
   1f32c:	ed86 0a00 	vstr	s0, [r6]
	input[1] = sample;
   1f330:	ed86 0a01 	vstr	s0, [r6, #4]
}
   1f334:	ecbd 8b06 	vpop	{d8-d10}
   1f338:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1f33c:	020fb3cc 	.word	0x020fb3cc
   1f340:	020f8f4c 	.word	0x020f8f4c
   1f344:	020fafa4 	.word	0x020fafa4
   1f348:	00000000 	.word	0x00000000
   1f34c:	020f8c78 	.word	0x020f8c78
   1f350:	3e266666 	.word	0x3e266666
   1f354:	3f7ae148 	.word	0x3f7ae148
   1f358:	020e3220 	.word	0x020e3220
   1f35c:	020fa048 	.word	0x020fa048
   1f360:	020fa230 	.word	0x020fa230

0001f364 <SFXLivingStringSynthFree>:
{
   1f364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f368:	2400      	movs	r4, #0
   1f36a:	f8df 804c 	ldr.w	r8, [pc, #76]	; 1f3b8 <SFXLivingStringSynthFree+0x54>
   1f36e:	4f0d      	ldr	r7, [pc, #52]	; (1f3a4 <SFXLivingStringSynthFree+0x40>)
   1f370:	4e0d      	ldr	r6, [pc, #52]	; (1f3a8 <SFXLivingStringSynthFree+0x44>)
   1f372:	4d0e      	ldr	r5, [pc, #56]	; (1f3ac <SFXLivingStringSynthFree+0x48>)
		tComplexLivingString_free(&theString[i]);
   1f374:	eb08 0004 	add.w	r0, r8, r4
   1f378:	f00b fbee 	bl	2ab58 <tComplexLivingString_free>
		tSlide_free(&stringInEnvs[i]);
   1f37c:	1938      	adds	r0, r7, r4
   1f37e:	f008 fe2f 	bl	27fe0 <tSlide_free>
		tSlide_free(&stringOutEnvs[i]);
   1f382:	1930      	adds	r0, r6, r4
   1f384:	f008 fe2c 	bl	27fe0 <tSlide_free>
		tADSR4_free(&pluckEnvs[i]);
   1f388:	1928      	adds	r0, r5, r4
   1f38a:	3404      	adds	r4, #4
   1f38c:	f008 fa4e 	bl	2782c <tADSR4_free>
	for (int i = 0; i < NUM_STRINGS; i++)
   1f390:	2c18      	cmp	r4, #24
   1f392:	d1ef      	bne.n	1f374 <SFXLivingStringSynthFree+0x10>
	tVZFilter_free(&pluckFilt);
   1f394:	4806      	ldr	r0, [pc, #24]	; (1f3b0 <SFXLivingStringSynthFree+0x4c>)
   1f396:	f009 fb27 	bl	289e8 <tVZFilter_free>
	tNoise_free(&stringPluckNoise);
   1f39a:	4806      	ldr	r0, [pc, #24]	; (1f3b4 <SFXLivingStringSynthFree+0x50>)
}
   1f39c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	tNoise_free(&stringPluckNoise);
   1f3a0:	f00b ba58 	b.w	2a854 <tNoise_free>
   1f3a4:	020fa2f8 	.word	0x020fa2f8
   1f3a8:	020fa230 	.word	0x020fa230
   1f3ac:	020fa048 	.word	0x020fa048
   1f3b0:	020fafa4 	.word	0x020fafa4
   1f3b4:	020f8f4c 	.word	0x020f8f4c
   1f3b8:	020f8c78 	.word	0x020f8c78

0001f3bc <SFXClassicSynthAlloc>:
	tSimplePoly_setNumVoices(&poly, numVoices);
   1f3bc:	4aa5      	ldr	r2, [pc, #660]	; (1f654 <SFXClassicSynthAlloc+0x298>)
   1f3be:	48a6      	ldr	r0, [pc, #664]	; (1f658 <SFXClassicSynthAlloc+0x29c>)
{
   1f3c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	leaf.clearOnAllocation = 1;
   1f3c4:	2301      	movs	r3, #1
   1f3c6:	f8df a2fc 	ldr.w	sl, [pc, #764]	; 1f6c4 <SFXClassicSynthAlloc+0x308>
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f3ca:	f04f 0800 	mov.w	r8, #0
	leaf.clearOnAllocation = 1;
   1f3ce:	f8ca 3014 	str.w	r3, [sl, #20]
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f3d2:	4644      	mov	r4, r8
{
   1f3d4:	ed2d 8b08 	vpush	{d8-d11}
	tSimplePoly_setNumVoices(&poly, numVoices);
   1f3d8:	7811      	ldrb	r1, [r2, #0]
   1f3da:	f00b f8b5 	bl	2a548 <tSimplePoly_setNumVoices>
	displayValues[0] = knobs[0]; //synth volume
   1f3de:	4b9f      	ldr	r3, [pc, #636]	; (1f65c <SFXClassicSynthAlloc+0x2a0>)
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3e0:	4a9f      	ldr	r2, [pc, #636]	; (1f660 <SFXClassicSynthAlloc+0x2a4>)
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f3e2:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3e6:	ed93 5a05 	vldr	s10, [r3, #20]
	displayValues[0] = knobs[0]; //synth volume
   1f3ea:	461f      	mov	r7, r3
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3ec:	edd2 7a00 	vldr	s15, [r2]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f3f0:	edd3 5a06 	vldr	s11, [r3, #24]
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f3f4:	ed93 6a08 	vldr	s12, [r3, #32]
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3f8:	ee27 5a85 	vmul.f32	s10, s15, s10
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f3fc:	edd3 6a0a 	vldr	s13, [r3, #40]	; 0x28
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f400:	ee67 5aa5 	vmul.f32	s11, s15, s11
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f404:	ed93 7a0b 	vldr	s14, [r3, #44]	; 0x2c
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f408:	ee27 6a86 	vmul.f32	s12, s15, s12
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f40c:	ee67 6aa6 	vmul.f32	s13, s15, s13
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f410:	eddf 8a94 	vldr	s17, [pc, #592]	; 1f664 <SFXClassicSynthAlloc+0x2a8>
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f414:	ee27 7a87 	vmul.f32	s14, s15, s14
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f418:	4a93      	ldr	r2, [pc, #588]	; (1f668 <SFXClassicSynthAlloc+0x2ac>)
   1f41a:	eebd 5ac5 	vcvt.s32.f32	s10, s10
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f41e:	ed93 4a04 	vldr	s8, [r3, #16]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f422:	eefd 5ae5 	vcvt.s32.f32	s11, s11
	displayValues[0] = knobs[0]; //synth volume
   1f426:	f857 eb04 	ldr.w	lr, [r7], #4
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f42a:	eebd 6ac6 	vcvt.s32.f32	s12, s12
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f42e:	ed9f aa8f 	vldr	s20, [pc, #572]	; 1f66c <SFXClassicSynthAlloc+0x2b0>
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f432:	eefd 6ae6 	vcvt.s32.f32	s13, s13
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f436:	ee15 ca10 	vmov	ip, s10
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f43a:	eebd 7ac7 	vcvt.s32.f32	s14, s14
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f43e:	ee15 6a90 	vmov	r6, s11
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f442:	eef0 3a68 	vmov.f32	s7, s17
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f446:	ee16 5a10 	vmov	r5, s12
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f44a:	ee16 0a90 	vmov	r0, s13
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f44e:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f452:	ee17 1a10 	vmov	r1, s14
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f456:	eb02 0686 	add.w	r6, r2, r6, lsl #2
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f45a:	eb02 0585 	add.w	r5, r2, r5, lsl #2
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f45e:	eee4 3a24 	vfma.f32	s7, s8, s9
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f462:	eb02 0080 	add.w	r0, r2, r0, lsl #2
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f466:	edd7 4a00 	vldr	s9, [r7]
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f46a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f46e:	ed9f 7a80 	vldr	s14, [pc, #512]	; 1f670 <SFXClassicSynthAlloc+0x2b4>
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f472:	ed9f 6a80 	vldr	s12, [pc, #512]	; 1f674 <SFXClassicSynthAlloc+0x2b8>
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f476:	edd5 5a00 	vldr	s11, [r5]
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f47a:	ee64 4a87 	vmul.f32	s9, s9, s14
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f47e:	ed9c 4a00 	vldr	s8, [ip]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f482:	ed96 5a00 	vldr	s10, [r6]
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f486:	ee65 5a86 	vmul.f32	s11, s11, s12
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f48a:	edd0 6a00 	vldr	s13, [r0]
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f48e:	ee24 4a06 	vmul.f32	s8, s8, s12
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f492:	ed91 7a00 	vldr	s14, [r1]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f496:	ee25 5a06 	vmul.f32	s10, s10, s12
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f49a:	ee66 6a86 	vmul.f32	s13, s13, s12
	displayValues[0] = knobs[0]; //synth volume
   1f49e:	4d76      	ldr	r5, [pc, #472]	; (1f678 <SFXClassicSynthAlloc+0x2bc>)
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f4a0:	ee27 7a06 	vmul.f32	s14, s14, s12
	displayValues[7] = knobs[7]; //sus
   1f4a4:	69de      	ldr	r6, [r3, #28]
	displayValues[12] = knobs[12]; //sus
   1f4a6:	6b19      	ldr	r1, [r3, #48]	; 0x30
	displayValues[2] = knobs[2]; //keyfollow filter cutoff
   1f4a8:	f8d3 c008 	ldr.w	ip, [r3, #8]
	displayValues[3] = knobs[3]; //detune
   1f4ac:	68df      	ldr	r7, [r3, #12]
	displayValues[9] = knobs[9]; //leak
   1f4ae:	6a58      	ldr	r0, [r3, #36]	; 0x24
	displayValues[7] = knobs[7]; //sus
   1f4b0:	61ee      	str	r6, [r5, #28]
	displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f4b2:	edc5 6a0a 	vstr	s13, [r5, #40]	; 0x28
	displayValues[12] = knobs[12]; //sus
   1f4b6:	6329      	str	r1, [r5, #48]	; 0x30
	displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1f4b8:	ed85 4a05 	vstr	s8, [r5, #20]
	displayValues[0] = knobs[0]; //synth volume
   1f4bc:	f8c5 e000 	str.w	lr, [r5]
	displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1f4c0:	edc5 4a01 	vstr	s9, [r5, #4]
	displayValues[2] = knobs[2]; //keyfollow filter cutoff
   1f4c4:	f8c5 c008 	str.w	ip, [r5, #8]
	displayValues[3] = knobs[3]; //detune
   1f4c8:	60ef      	str	r7, [r5, #12]
	displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1f4ca:	edc5 3a04 	vstr	s7, [r5, #16]
	displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f4ce:	ed85 5a06 	vstr	s10, [r5, #24]
	displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f4d2:	edc5 5a08 	vstr	s11, [r5, #32]
	displayValues[9] = knobs[9]; //leak
   1f4d6:	6268      	str	r0, [r5, #36]	; 0x24
	displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1f4d8:	ed85 7a0b 	vstr	s14, [r5, #44]	; 0x2c
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f4dc:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
	displayValues[14] = knobs[14]; //leak
   1f4e0:	6b99      	ldr	r1, [r3, #56]	; 0x38
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f4e2:	ee67 7a87 	vmul.f32	s15, s15, s14
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f4e6:	ed93 7a0f 	vldr	s14, [r3, #60]	; 0x3c
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f4ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f4ec:	eddf 6a63 	vldr	s13, [pc, #396]	; 1f67c <SFXClassicSynthAlloc+0x2c0>
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f4f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f4f4:	642b      	str	r3, [r5, #64]	; 0x40
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f4f6:	ee27 7a26 	vmul.f32	s14, s14, s13
			tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f4fa:	4e61      	ldr	r6, [pc, #388]	; (1f680 <SFXClassicSynthAlloc+0x2c4>)
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f4fc:	eddf 9a61 	vldr	s19, [pc, #388]	; 1f684 <SFXClassicSynthAlloc+0x2c8>
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f500:	ee17 3a90 	vmov	r3, s15
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   1f504:	ed9f 9a60 	vldr	s18, [pc, #384]	; 1f688 <SFXClassicSynthAlloc+0x2cc>
	displayValues[14] = knobs[14]; //leak
   1f508:	63a9      	str	r1, [r5, #56]	; 0x38
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f50a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
	displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f50e:	ed85 7a0f 	vstr	s14, [r5, #60]	; 0x3c
	displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f512:	edd2 7a00 	vldr	s15, [r2]
   1f516:	ee27 6a86 	vmul.f32	s12, s15, s12
   1f51a:	ed85 6a0d 	vstr	s12, [r5, #52]	; 0x34
   1f51e:	4b5b      	ldr	r3, [pc, #364]	; (1f68c <SFXClassicSynthAlloc+0x2d0>)
   1f520:	f104 0b0c 	add.w	fp, r4, #12
   1f524:	eb03 0904 	add.w	r9, r3, r4
			tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f528:	4b59      	ldr	r3, [pc, #356]	; (1f690 <SFXClassicSynthAlloc+0x2d4>)
   1f52a:	4631      	mov	r1, r6
   1f52c:	1918      	adds	r0, r3, r4
   1f52e:	f00b f8c9 	bl	2a6c4 <tSawtooth_initToPool>
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f532:	f8da 3010 	ldr.w	r3, [sl, #16]
   1f536:	4798      	blx	r3
   1f538:	eef0 7a69 	vmov.f32	s15, s19
   1f53c:	4b55      	ldr	r3, [pc, #340]	; (1f694 <SFXClassicSynthAlloc+0x2d8>)
			tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f53e:	4631      	mov	r1, r6
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f540:	eee0 7a0a 	vfma.f32	s15, s0, s20
   1f544:	191f      	adds	r7, r3, r4
   1f546:	3404      	adds	r4, #4
			tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f548:	4638      	mov	r0, r7
			synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
   1f54a:	ece9 7a01 	vstmia	r9!, {s15}
			tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
   1f54e:	f006 ff51 	bl	263f4 <tRosenbergGlottalPulse_initToPool>
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
   1f552:	eeb0 0a49 	vmov.f32	s0, s18
   1f556:	4638      	mov	r0, r7
   1f558:	f007 f84a 	bl	265f0 <tRosenbergGlottalPulse_setOpenLength>
			tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.4f);
   1f55c:	eeb0 0a68 	vmov.f32	s0, s17
   1f560:	4638      	mov	r0, r7
   1f562:	f007 f853 	bl	2660c <tRosenbergGlottalPulse_setPulseLength>
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1f566:	455c      	cmp	r4, fp
   1f568:	d1de      	bne.n	1f528 <SFXClassicSynthAlloc+0x16c>
   1f56a:	4b4b      	ldr	r3, [pc, #300]	; (1f698 <SFXClassicSynthAlloc+0x2dc>)
		tEfficientSVF_initToPool(&synthLP[i], SVFTypeLowpass, 6000.0f, displayValues[4], &smallPool);
   1f56c:	f241 7270 	movw	r2, #6000	; 0x1770
   1f570:	484a      	ldr	r0, [pc, #296]	; (1f69c <SFXClassicSynthAlloc+0x2e0>)
   1f572:	2101      	movs	r1, #1
   1f574:	eb03 0908 	add.w	r9, r3, r8
   1f578:	ed95 0a04 	vldr	s0, [r5, #16]
   1f57c:	4440      	add	r0, r8
   1f57e:	4633      	mov	r3, r6
   1f580:	f008 ff0e 	bl	283a0 <tEfficientSVF_initToPool>
		tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1f584:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
		tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1f588:	4633      	mov	r3, r6
   1f58a:	f44f 7200 	mov.w	r2, #512	; 0x200
   1f58e:	4944      	ldr	r1, [pc, #272]	; (1f6a0 <SFXClassicSynthAlloc+0x2e4>)
   1f590:	4648      	mov	r0, r9
   1f592:	edd5 1a08 	vldr	s3, [r5, #32]
   1f596:	ed95 1a07 	vldr	s2, [r5, #28]
   1f59a:	edd5 0a06 	vldr	s1, [r5, #24]
   1f59e:	ed95 0a05 	vldr	s0, [r5, #20]
   1f5a2:	f008 f8e9 	bl	27778 <tADSR4_initToPool>
		tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1f5a6:	eddf aa3f 	vldr	s21, [pc, #252]	; 1f6a4 <SFXClassicSynthAlloc+0x2e8>
   1f5aa:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
   1f5ae:	4648      	mov	r0, r9
   1f5b0:	4f3d      	ldr	r7, [pc, #244]	; (1f6a8 <SFXClassicSynthAlloc+0x2ec>)
   1f5b2:	eeb0 0a6a 	vmov.f32	s0, s21
   1f5b6:	ee78 7a67 	vsub.f32	s15, s16, s15
   1f5ba:	ed9f ba3c 	vldr	s22, [pc, #240]	; 1f6ac <SFXClassicSynthAlloc+0x2f0>
   1f5be:	4447      	add	r7, r8
   1f5c0:	f108 0804 	add.w	r8, r8, #4
   1f5c4:	eea7 0a8b 	vfma.f32	s0, s15, s22
   1f5c8:	f008 f974 	bl	278b4 <tADSR4_setLeakFactor>
		tADSR4_initToPool(&polyFiltEnvs[i], displayValues[10], displayValues[11], displayValues[12], displayValues[13], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1f5cc:	4638      	mov	r0, r7
   1f5ce:	4633      	mov	r3, r6
   1f5d0:	f44f 7200 	mov.w	r2, #512	; 0x200
   1f5d4:	4932      	ldr	r1, [pc, #200]	; (1f6a0 <SFXClassicSynthAlloc+0x2e4>)
   1f5d6:	edd5 1a0d 	vldr	s3, [r5, #52]	; 0x34
   1f5da:	ed95 1a0c 	vldr	s2, [r5, #48]	; 0x30
   1f5de:	edd5 0a0b 	vldr	s1, [r5, #44]	; 0x2c
   1f5e2:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
   1f5e6:	f008 f8c7 	bl	27778 <tADSR4_initToPool>
		tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f5ea:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
   1f5ee:	eeb0 0a6a 	vmov.f32	s0, s21
   1f5f2:	4638      	mov	r0, r7
   1f5f4:	ee38 8a67 	vsub.f32	s16, s16, s15
   1f5f8:	eea8 0a0b 	vfma.f32	s0, s16, s22
   1f5fc:	f008 f95a 	bl	278b4 <tADSR4_setLeakFactor>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1f600:	f1b8 0f20 	cmp.w	r8, #32
   1f604:	d18b      	bne.n	1f51e <SFXClassicSynthAlloc+0x162>
	tCycle_initToPool(&pwmLFO1, &smallPool);
   1f606:	491e      	ldr	r1, [pc, #120]	; (1f680 <SFXClassicSynthAlloc+0x2c4>)
   1f608:	4829      	ldr	r0, [pc, #164]	; (1f6b0 <SFXClassicSynthAlloc+0x2f4>)
   1f60a:	f00a ffdd 	bl	2a5c8 <tCycle_initToPool>
	tCycle_initToPool(&pwmLFO2, &smallPool);
   1f60e:	491c      	ldr	r1, [pc, #112]	; (1f680 <SFXClassicSynthAlloc+0x2c4>)
   1f610:	4828      	ldr	r0, [pc, #160]	; (1f6b4 <SFXClassicSynthAlloc+0x2f8>)
   1f612:	f00a ffd9 	bl	2a5c8 <tCycle_initToPool>
	tCycle_setFreq(&pwmLFO1, 63.0f);
   1f616:	ed9f 0a28 	vldr	s0, [pc, #160]	; 1f6b8 <SFXClassicSynthAlloc+0x2fc>
   1f61a:	4825      	ldr	r0, [pc, #148]	; (1f6b0 <SFXClassicSynthAlloc+0x2f4>)
   1f61c:	f00a ffe6 	bl	2a5ec <tCycle_setFreq>
	tCycle_setFreq(&pwmLFO2, 72.11f);
   1f620:	ed9f 0a26 	vldr	s0, [pc, #152]	; 1f6bc <SFXClassicSynthAlloc+0x300>
   1f624:	4823      	ldr	r0, [pc, #140]	; (1f6b4 <SFXClassicSynthAlloc+0x2f8>)
   1f626:	f00a ffe1 	bl	2a5ec <tCycle_setFreq>
	setLED_A(numVoices == 1);
   1f62a:	4b0a      	ldr	r3, [pc, #40]	; (1f654 <SFXClassicSynthAlloc+0x298>)
   1f62c:	7818      	ldrb	r0, [r3, #0]
   1f62e:	f1a0 0001 	sub.w	r0, r0, #1
   1f632:	fab0 f080 	clz	r0, r0
   1f636:	0940      	lsrs	r0, r0, #5
   1f638:	f7f9 ff80 	bl	1953c <setLED_A>
	cycleCountVals[0][2] = 2;
   1f63c:	4b20      	ldr	r3, [pc, #128]	; (1f6c0 <SFXClassicSynthAlloc+0x304>)
   1f63e:	2002      	movs	r0, #2
   1f640:	2100      	movs	r1, #0
	leaf.clearOnAllocation = 0;
   1f642:	2200      	movs	r2, #0
	cycleCountVals[0][2] = 2;
   1f644:	e9c3 0104 	strd	r0, r1, [r3, #16]
}
   1f648:	ecbd 8b08 	vpop	{d8-d11}
	leaf.clearOnAllocation = 0;
   1f64c:	f8ca 2014 	str.w	r2, [sl, #20]
}
   1f650:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1f654:	00062ae4 	.word	0x00062ae4
   1f658:	020fa15c 	.word	0x020fa15c
   1f65c:	020f9958 	.word	0x020f9958
   1f660:	00062acc 	.word	0x00062acc
   1f664:	3ecccccd 	.word	0x3ecccccd
   1f668:	020f9c84 	.word	0x020f9c84
   1f66c:	3cd844d0 	.word	0x3cd844d0
   1f670:	45800000 	.word	0x45800000
   1f674:	46000000 	.word	0x46000000
   1f678:	020fb3cc 	.word	0x020fb3cc
   1f67c:	457ff000 	.word	0x457ff000
   1f680:	020f7730 	.word	0x020f7730
   1f684:	bc5844d0 	.word	0xbc5844d0
   1f688:	3e99999a 	.word	0x3e99999a
   1f68c:	020faf3c 	.word	0x020faf3c
   1f690:	020f9f1c 	.word	0x020f9f1c
   1f694:	020f8e50 	.word	0x020f8e50
   1f698:	020fa2d8 	.word	0x020fa2d8
   1f69c:	020f9a20 	.word	0x020f9a20
   1f6a0:	020fa578 	.word	0x020fa578
   1f6a4:	3f7ffcb9 	.word	0x3f7ffcb9
   1f6a8:	020f8550 	.word	0x020f8550
   1f6ac:	3851b717 	.word	0x3851b717
   1f6b0:	020fa2c8 	.word	0x020fa2c8
   1f6b4:	020fa3ac 	.word	0x020fa3ac
   1f6b8:	427c0000 	.word	0x427c0000
   1f6bc:	42903852 	.word	0x42903852
   1f6c0:	020f8198 	.word	0x020f8198
   1f6c4:	020fc0a8 	.word	0x020fc0a8

0001f6c8 <SFXClassicSynthFrame>:
{
   1f6c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1f6cc:	4cbf      	ldr	r4, [pc, #764]	; (1f9cc <SFXClassicSynthFrame+0x304>)
{
   1f6ce:	ed2d 8b08 	vpush	{d8-d11}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1f6d2:	7d23      	ldrb	r3, [r4, #20]
{
   1f6d4:	b085      	sub	sp, #20
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   1f6d6:	2b01      	cmp	r3, #1
   1f6d8:	f000 80f5 	beq.w	1f8c6 <SFXClassicSynthFrame+0x1fe>
   1f6dc:	4bbc      	ldr	r3, [pc, #752]	; (1f9d0 <SFXClassicSynthFrame+0x308>)
   1f6de:	9302      	str	r3, [sp, #8]
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1f6e0:	7e23      	ldrb	r3, [r4, #24]
   1f6e2:	2b01      	cmp	r3, #1
   1f6e4:	f000 8108 	beq.w	1f8f8 <SFXClassicSynthFrame+0x230>
	if (writeKnobFlag != -1)
   1f6e8:	4bba      	ldr	r3, [pc, #744]	; (1f9d4 <SFXClassicSynthFrame+0x30c>)
   1f6ea:	f993 2000 	ldrsb.w	r2, [r3]
   1f6ee:	1c53      	adds	r3, r2, #1
   1f6f0:	d01d      	beq.n	1f72e <SFXClassicSynthFrame+0x66>
		switch(writeKnobFlag + (knobPage * KNOB_PAGE_SIZE))
   1f6f2:	49b9      	ldr	r1, [pc, #740]	; (1f9d8 <SFXClassicSynthFrame+0x310>)
   1f6f4:	2305      	movs	r3, #5
   1f6f6:	7809      	ldrb	r1, [r1, #0]
   1f6f8:	fb13 2301 	smlabb	r3, r3, r1, r2
   1f6fc:	2b10      	cmp	r3, #16
   1f6fe:	d816      	bhi.n	1f72e <SFXClassicSynthFrame+0x66>
   1f700:	e8df f013 	tbh	[pc, r3, lsl #1]
   1f704:	02fd0011 	.word	0x02fd0011
   1f708:	02f302f8 	.word	0x02f302f8
   1f70c:	02a902d4 	.word	0x02a902d4
   1f710:	0265027e 	.word	0x0265027e
   1f714:	0215023a 	.word	0x0215023a
   1f718:	01bf01ea 	.word	0x01bf01ea
   1f71c:	013901a6 	.word	0x013901a6
   1f720:	01090114 	.word	0x01090114
   1f724:	0104      	.short	0x0104
				displayValues[0] = knobs[0]; //synth volume
   1f726:	4bad      	ldr	r3, [pc, #692]	; (1f9dc <SFXClassicSynthFrame+0x314>)
   1f728:	4ead      	ldr	r6, [pc, #692]	; (1f9e0 <SFXClassicSynthFrame+0x318>)
   1f72a:	681b      	ldr	r3, [r3, #0]
   1f72c:	6033      	str	r3, [r6, #0]
	float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
   1f72e:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
   1f732:	48ac      	ldr	r0, [pc, #688]	; (1f9e4 <SFXClassicSynthFrame+0x31c>)
   1f734:	eeb5 8a00 	vmov.f32	s16, #80	; 0x3e800000  0.250
   1f738:	f00a ff66 	bl	2a608 <tCycle_tick>
	float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   1f73c:	48aa      	ldr	r0, [pc, #680]	; (1f9e8 <SFXClassicSynthFrame+0x320>)
	float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
   1f73e:	eef0 9a68 	vmov.f32	s19, s17
   1f742:	eee0 9a08 	vfma.f32	s19, s0, s16
	float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   1f746:	f00a ff5f 	bl	2a608 <tCycle_tick>
   1f74a:	eee0 8a08 	vfma.f32	s17, s0, s16
	for (int i = 0; i < numVoices; i++)
   1f74e:	9b02      	ldr	r3, [sp, #8]
   1f750:	781b      	ldrb	r3, [r3, #0]
	float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
   1f752:	ee68 8aa9 	vmul.f32	s17, s17, s19
	for (int i = 0; i < numVoices; i++)
   1f756:	2b00      	cmp	r3, #0
   1f758:	f000 80a3 	beq.w	1f8a2 <SFXClassicSynthFrame+0x1da>
   1f75c:	f04f 0a00 	mov.w	sl, #0
   1f760:	4ba2      	ldr	r3, [pc, #648]	; (1f9ec <SFXClassicSynthFrame+0x324>)
   1f762:	f8df 82e8 	ldr.w	r8, [pc, #744]	; 1fa4c <SFXClassicSynthFrame+0x384>
   1f766:	4657      	mov	r7, sl
   1f768:	4e9d      	ldr	r6, [pc, #628]	; (1f9e0 <SFXClassicSynthFrame+0x318>)
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f76a:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 1fa1c <SFXClassicSynthFrame+0x354>
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f76e:	eddf baa0 	vldr	s23, [pc, #640]	; 1f9f0 <SFXClassicSynthFrame+0x328>
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f772:	ed9f baa0 	vldr	s22, [pc, #640]	; 1f9f4 <SFXClassicSynthFrame+0x32c>
   1f776:	eddf aaa0 	vldr	s21, [pc, #640]	; 1f9f8 <SFXClassicSynthFrame+0x330>
   1f77a:	9301      	str	r3, [sp, #4]
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f77c:	b2fb      	uxtb	r3, r7
   1f77e:	4a9f      	ldr	r2, [pc, #636]	; (1f9fc <SFXClassicSynthFrame+0x334>)
   1f780:	4658      	mov	r0, fp
			float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   1f782:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f786:	461c      	mov	r4, r3
   1f788:	4619      	mov	r1, r3
   1f78a:	9303      	str	r3, [sp, #12]
   1f78c:	eb02 050a 	add.w	r5, r2, sl
   1f790:	f00a fefe 	bl	2a590 <tSimplePoly_getPitch>
   1f794:	ee07 0a90 	vmov	s15, r0
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f798:	4621      	mov	r1, r4
   1f79a:	4658      	mov	r0, fp
		float myMidiNote = tSimplePoly_getPitch(&poly, i);
   1f79c:	eeb8 aae7 	vcvt.f32.s32	s20, s15
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f7a0:	f00a fef6 	bl	2a590 <tSimplePoly_getPitch>
   1f7a4:	ee07 0a90 	vmov	s15, r0
   1f7a8:	4b95      	ldr	r3, [pc, #596]	; (1fa00 <SFXClassicSynthFrame+0x338>)
   1f7aa:	f10a 090c 	add.w	r9, sl, #12
   1f7ae:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   1f7b2:	ed93 0a00 	vldr	s0, [r3]
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f7b6:	4b93      	ldr	r3, [pc, #588]	; (1fa04 <SFXClassicSynthFrame+0x33c>)
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   1f7b8:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f7bc:	7818      	ldrb	r0, [r3, #0]
   1f7be:	4b92      	ldr	r3, [pc, #584]	; (1fa08 <SFXClassicSynthFrame+0x340>)
   1f7c0:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   1f7c4:	ee17 1a90 	vmov	r1, s15
   1f7c8:	1a09      	subs	r1, r1, r0
   1f7ca:	fb83 3401 	smull	r3, r4, r3, r1
   1f7ce:	17c8      	asrs	r0, r1, #31
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f7d0:	4b8e      	ldr	r3, [pc, #568]	; (1fa0c <SFXClassicSynthFrame+0x344>)
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   1f7d2:	ebc0 0064 	rsb	r0, r0, r4, asr #1
   1f7d6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1f7da:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
   1f7de:	ee07 0a90 	vmov	s15, r0
   1f7e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   1f7e6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   1f7ea:	ee17 1a90 	vmov	r1, s15
   1f7ee:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   1f7f2:	ed91 0a00 	vldr	s0, [r1]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   1f7f6:	ee37 0a00 	vadd.f32	s0, s14, s0
   1f7fa:	f00a f92f 	bl	29a5c <LEAF_midiToFrequency>
   1f7fe:	eca8 0a01 	vstmia	r8!, {s0}
			float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   1f802:	eeb0 8a49 	vmov.f32	s16, s18
   1f806:	ecb5 7a01 	vldmia	r5!, {s14}
   1f80a:	edd6 7a03 	vldr	s15, [r6, #12]
   1f80e:	4b80      	ldr	r3, [pc, #512]	; (1fa10 <SFXClassicSynthFrame+0x348>)
   1f810:	eea7 8a27 	vfma.f32	s16, s14, s15
   1f814:	eb03 040a 	add.w	r4, r3, sl
			tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   1f818:	4b7e      	ldr	r3, [pc, #504]	; (1fa14 <SFXClassicSynthFrame+0x34c>)
   1f81a:	eb03 000a 	add.w	r0, r3, sl
   1f81e:	f10a 0a04 	add.w	sl, sl, #4
			float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
   1f822:	ee28 8a00 	vmul.f32	s16, s16, s0
			tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   1f826:	eeb0 0a48 	vmov.f32	s0, s16
   1f82a:	f00a ff73 	bl	2a714 <tSawtooth_setFreq>
			tRosenbergGlottalPulse_setFreq(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
   1f82e:	eeb0 0a48 	vmov.f32	s0, s16
   1f832:	4620      	mov	r0, r4
   1f834:	f006 fece 	bl	265d4 <tRosenbergGlottalPulse_setFreq>
			tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO1);
   1f838:	eeb0 0a69 	vmov.f32	s0, s19
   1f83c:	4620      	mov	r0, r4
   1f83e:	f006 fee5 	bl	2660c <tRosenbergGlottalPulse_setPulseLength>
			tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO2);
   1f842:	eeb0 0a68 	vmov.f32	s0, s17
   1f846:	4620      	mov	r0, r4
   1f848:	f006 fed2 	bl	265f0 <tRosenbergGlottalPulse_setOpenLength>
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1f84c:	45ca      	cmp	sl, r9
   1f84e:	d002      	beq.n	1f856 <SFXClassicSynthFrame+0x18e>
   1f850:	ed18 0a01 	vldr	s0, [r8, #-4]
   1f854:	e7d5      	b.n	1f802 <SFXClassicSynthFrame+0x13a>
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f856:	edd6 7a02 	vldr	s15, [r6, #8]
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f85a:	eeb0 1a4b 	vmov.f32	s2, s22
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f85e:	edd6 0a01 	vldr	s1, [r6, #4]
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f862:	eeb0 0a6a 	vmov.f32	s0, s21
		float tempFreq2 = displayValues[1] +  keyFollowFilt;
   1f866:	ee67 7aab 	vmul.f32	s15, s15, s23
		tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
   1f86a:	eeea 0a27 	vfma.f32	s1, s20, s15
   1f86e:	f00a f80b 	bl	29888 <LEAF_clip>
		if (numVoices > 1)
   1f872:	9b02      	ldr	r3, [sp, #8]
		filtFreqs[i] = (uint16_t) tempFreq2;
   1f874:	eebc 0ac0 	vcvt.u32.f32	s0, s0
		if (numVoices > 1)
   1f878:	7819      	ldrb	r1, [r3, #0]
		filtFreqs[i] = (uint16_t) tempFreq2;
   1f87a:	9b01      	ldr	r3, [sp, #4]
   1f87c:	ee10 2a10 	vmov	r2, s0
		if (numVoices > 1)
   1f880:	2901      	cmp	r1, #1
		filtFreqs[i] = (uint16_t) tempFreq2;
   1f882:	f823 2f02 	strh.w	r2, [r3, #2]!
   1f886:	9301      	str	r3, [sp, #4]
		if (numVoices > 1)
   1f888:	d907      	bls.n	1f89a <SFXClassicSynthFrame+0x1d2>
			if (poly->voices[i][0] == -2)
   1f88a:	f8db 0000 	ldr.w	r0, [fp]
   1f88e:	6900      	ldr	r0, [r0, #16]
   1f890:	f850 0027 	ldr.w	r0, [r0, r7, lsl #2]
   1f894:	6800      	ldr	r0, [r0, #0]
   1f896:	3002      	adds	r0, #2
   1f898:	d008      	beq.n	1f8ac <SFXClassicSynthFrame+0x1e4>
	for (int i = 0; i < numVoices; i++)
   1f89a:	3701      	adds	r7, #1
   1f89c:	42b9      	cmp	r1, r7
   1f89e:	f73f af6d 	bgt.w	1f77c <SFXClassicSynthFrame+0xb4>
}
   1f8a2:	b005      	add	sp, #20
   1f8a4:	ecbd 8b08 	vpop	{d8-d11}
   1f8a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (polyEnvs[i]->whichStage == env_idle)
   1f8ac:	4b5a      	ldr	r3, [pc, #360]	; (1fa18 <SFXClassicSynthFrame+0x350>)
   1f8ae:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   1f8b2:	6a80      	ldr	r0, [r0, #40]	; 0x28
   1f8b4:	2800      	cmp	r0, #0
   1f8b6:	d1f0      	bne.n	1f89a <SFXClassicSynthFrame+0x1d2>
					tSimplePoly_deactivateVoice(&poly, i);
   1f8b8:	9903      	ldr	r1, [sp, #12]
   1f8ba:	4658      	mov	r0, fp
   1f8bc:	f00a fd8e 	bl	2a3dc <tSimplePoly_deactivateVoice>
   1f8c0:	9b02      	ldr	r3, [sp, #8]
   1f8c2:	7819      	ldrb	r1, [r3, #0]
   1f8c4:	e7e9      	b.n	1f89a <SFXClassicSynthFrame+0x1d2>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1f8c6:	4d42      	ldr	r5, [pc, #264]	; (1f9d0 <SFXClassicSynthFrame+0x308>)
		tSimplePoly_setNumVoices(&poly, numVoices);
   1f8c8:	4854      	ldr	r0, [pc, #336]	; (1fa1c <SFXClassicSynthFrame+0x354>)
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1f8ca:	782a      	ldrb	r2, [r5, #0]
   1f8cc:	9502      	str	r5, [sp, #8]
   1f8ce:	2a01      	cmp	r2, #1
   1f8d0:	bf98      	it	ls
   1f8d2:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   1f8d4:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   1f8d6:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   1f8d8:	f00a fe36 	bl	2a548 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   1f8dc:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1f8de:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   1f8e0:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   1f8e4:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   1f8e6:	fab0 f080 	clz	r0, r0
   1f8ea:	0940      	lsrs	r0, r0, #5
   1f8ec:	f7f9 fe26 	bl	1953c <setLED_A>
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   1f8f0:	7e23      	ldrb	r3, [r4, #24]
   1f8f2:	2b01      	cmp	r3, #1
   1f8f4:	f47f aef8 	bne.w	1f6e8 <SFXClassicSynthFrame+0x20>
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f8f8:	2000      	movs	r0, #0
		cycleCountVals[0][1] = 0;
   1f8fa:	4b49      	ldr	r3, [pc, #292]	; (1fa20 <SFXClassicSynthFrame+0x358>)
   1f8fc:	2600      	movs	r6, #0
   1f8fe:	2700      	movs	r7, #0
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   1f900:	7620      	strb	r0, [r4, #24]
		cycleCountVals[0][1] = 0;
   1f902:	e9c3 6702 	strd	r6, r7, [r3, #8]
		setLED_Edit(0);
   1f906:	f7f9 fddd 	bl	194c4 <setLED_Edit>
   1f90a:	e6ed      	b.n	1f6e8 <SFXClassicSynthFrame+0x20>
				displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
   1f90c:	4b45      	ldr	r3, [pc, #276]	; (1fa24 <SFXClassicSynthFrame+0x35c>)
   1f90e:	4e34      	ldr	r6, [pc, #208]	; (1f9e0 <SFXClassicSynthFrame+0x318>)
   1f910:	681b      	ldr	r3, [r3, #0]
   1f912:	6433      	str	r3, [r6, #64]	; 0x40
				break;
   1f914:	e70b      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
   1f916:	4b44      	ldr	r3, [pc, #272]	; (1fa28 <SFXClassicSynthFrame+0x360>)
   1f918:	ed9f 7a36 	vldr	s14, [pc, #216]	; 1f9f4 <SFXClassicSynthFrame+0x32c>
   1f91c:	edd3 7a00 	vldr	s15, [r3]
   1f920:	4e2f      	ldr	r6, [pc, #188]	; (1f9e0 <SFXClassicSynthFrame+0x318>)
   1f922:	ee67 7a87 	vmul.f32	s15, s15, s14
   1f926:	edc6 7a0f 	vstr	s15, [r6, #60]	; 0x3c
				break;
   1f92a:	e700      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[14] = knobs[14]; //leak
   1f92c:	4b3f      	ldr	r3, [pc, #252]	; (1fa2c <SFXClassicSynthFrame+0x364>)
				for (int i = 0; i < numVoices; i++)
   1f92e:	9f02      	ldr	r7, [sp, #8]
				displayValues[14] = knobs[14]; //leak
   1f930:	edd3 7a00 	vldr	s15, [r3]
   1f934:	4e2a      	ldr	r6, [pc, #168]	; (1f9e0 <SFXClassicSynthFrame+0x318>)
				for (int i = 0; i < numVoices; i++)
   1f936:	783b      	ldrb	r3, [r7, #0]
				displayValues[14] = knobs[14]; //leak
   1f938:	edc6 7a0e 	vstr	s15, [r6, #56]	; 0x38
				for (int i = 0; i < numVoices; i++)
   1f93c:	2b00      	cmp	r3, #0
   1f93e:	f43f aef6 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
					tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f942:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   1f946:	4d3a      	ldr	r5, [pc, #232]	; (1fa30 <SFXClassicSynthFrame+0x368>)
				for (int i = 0; i < numVoices; i++)
   1f948:	2400      	movs	r4, #0
					tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f94a:	eddf 8a3a 	vldr	s17, [pc, #232]	; 1fa34 <SFXClassicSynthFrame+0x36c>
   1f94e:	ed9f 8a3a 	vldr	s16, [pc, #232]	; 1fa38 <SFXClassicSynthFrame+0x370>
   1f952:	e001      	b.n	1f958 <SFXClassicSynthFrame+0x290>
   1f954:	edd6 7a0e 	vldr	s15, [r6, #56]	; 0x38
   1f958:	ee79 7a67 	vsub.f32	s15, s18, s15
   1f95c:	4628      	mov	r0, r5
   1f95e:	eeb0 0a48 	vmov.f32	s0, s16
				for (int i = 0; i < numVoices; i++)
   1f962:	3401      	adds	r4, #1
   1f964:	3504      	adds	r5, #4
					tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
   1f966:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1f96a:	f007 ffa3 	bl	278b4 <tADSR4_setLeakFactor>
				for (int i = 0; i < numVoices; i++)
   1f96e:	783b      	ldrb	r3, [r7, #0]
   1f970:	42a3      	cmp	r3, r4
   1f972:	dcef      	bgt.n	1f954 <SFXClassicSynthFrame+0x28c>
   1f974:	e6db      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f976:	4a31      	ldr	r2, [pc, #196]	; (1fa3c <SFXClassicSynthFrame+0x374>)
   1f978:	4b31      	ldr	r3, [pc, #196]	; (1fa40 <SFXClassicSynthFrame+0x378>)
   1f97a:	edd2 7a00 	vldr	s15, [r2]
   1f97e:	ed93 7a00 	vldr	s14, [r3]
   1f982:	4b30      	ldr	r3, [pc, #192]	; (1fa44 <SFXClassicSynthFrame+0x37c>)
   1f984:	ee67 7a87 	vmul.f32	s15, s15, s14
   1f988:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 1fa48 <SFXClassicSynthFrame+0x380>
				for (int i = 0; i < numVoices; i++)
   1f98c:	9f02      	ldr	r7, [sp, #8]
				displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f98e:	4e14      	ldr	r6, [pc, #80]	; (1f9e0 <SFXClassicSynthFrame+0x318>)
   1f990:	eefd 7ae7 	vcvt.s32.f32	s15, s15
				for (int i = 0; i < numVoices; i++)
   1f994:	783a      	ldrb	r2, [r7, #0]
				displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1f996:	ee17 1a90 	vmov	r1, s15
   1f99a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1f99e:	ed93 0a00 	vldr	s0, [r3]
   1f9a2:	ee20 0a07 	vmul.f32	s0, s0, s14
   1f9a6:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
				for (int i = 0; i < numVoices; i++)
   1f9aa:	2a00      	cmp	r2, #0
   1f9ac:	f43f aebf 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1f9b0:	4d1f      	ldr	r5, [pc, #124]	; (1fa30 <SFXClassicSynthFrame+0x368>)
   1f9b2:	2400      	movs	r4, #0
   1f9b4:	e001      	b.n	1f9ba <SFXClassicSynthFrame+0x2f2>
   1f9b6:	ed96 0a0d 	vldr	s0, [r6, #52]	; 0x34
					tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
   1f9ba:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1f9bc:	3401      	adds	r4, #1
					tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
   1f9be:	f007 ff6b 	bl	27898 <tADSR4_setRelease>
				for (int i = 0; i < numVoices; i++)
   1f9c2:	783b      	ldrb	r3, [r7, #0]
   1f9c4:	3504      	adds	r5, #4
   1f9c6:	42a3      	cmp	r3, r4
   1f9c8:	dcf5      	bgt.n	1f9b6 <SFXClassicSynthFrame+0x2ee>
   1f9ca:	e6b0      	b.n	1f72e <SFXClassicSynthFrame+0x66>
   1f9cc:	020fb31c 	.word	0x020fb31c
   1f9d0:	00062ae4 	.word	0x00062ae4
   1f9d4:	00062b63 	.word	0x00062b63
   1f9d8:	020e325a 	.word	0x020e325a
   1f9dc:	020f9958 	.word	0x020f9958
   1f9e0:	020fb3cc 	.word	0x020fb3cc
   1f9e4:	020fa2c8 	.word	0x020fa2c8
   1f9e8:	020fa3ac 	.word	0x020fa3ac
   1f9ec:	020f9e82 	.word	0x020f9e82
   1f9f0:	42800000 	.word	0x42800000
   1f9f4:	457ff000 	.word	0x457ff000
   1f9f8:	00000000 	.word	0x00000000
   1f9fc:	020faf3c 	.word	0x020faf3c
   1fa00:	020e31e0 	.word	0x020e31e0
   1fa04:	020e3258 	.word	0x020e3258
   1fa08:	2aaaaaab 	.word	0x2aaaaaab
   1fa0c:	020e3224 	.word	0x020e3224
   1fa10:	020f8e50 	.word	0x020f8e50
   1fa14:	020f9f1c 	.word	0x020f9f1c
   1fa18:	020fa2d8 	.word	0x020fa2d8
   1fa1c:	020fa15c 	.word	0x020fa15c
   1fa20:	020f8198 	.word	0x020f8198
   1fa24:	020f9998 	.word	0x020f9998
   1fa28:	020f9994 	.word	0x020f9994
   1fa2c:	020f9990 	.word	0x020f9990
   1fa30:	020f8550 	.word	0x020f8550
   1fa34:	3851b717 	.word	0x3851b717
   1fa38:	3f7ffcb9 	.word	0x3f7ffcb9
   1fa3c:	020f998c 	.word	0x020f998c
   1fa40:	00062acc 	.word	0x00062acc
   1fa44:	020f9c84 	.word	0x020f9c84
   1fa48:	46000000 	.word	0x46000000
   1fa4c:	020f9a44 	.word	0x020f9a44
				displayValues[12] = knobs[12]; //sus
   1fa50:	4bb0      	ldr	r3, [pc, #704]	; (1fd14 <SFXClassicSynthFrame+0x64c>)
				for (int i = 0; i < numVoices; i++)
   1fa52:	9f02      	ldr	r7, [sp, #8]
				displayValues[12] = knobs[12]; //sus
   1fa54:	ed93 0a00 	vldr	s0, [r3]
   1fa58:	4eaf      	ldr	r6, [pc, #700]	; (1fd18 <SFXClassicSynthFrame+0x650>)
				for (int i = 0; i < numVoices; i++)
   1fa5a:	783b      	ldrb	r3, [r7, #0]
				displayValues[12] = knobs[12]; //sus
   1fa5c:	ed86 0a0c 	vstr	s0, [r6, #48]	; 0x30
				for (int i = 0; i < numVoices; i++)
   1fa60:	2b00      	cmp	r3, #0
   1fa62:	f43f ae64 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fa66:	4dad      	ldr	r5, [pc, #692]	; (1fd1c <SFXClassicSynthFrame+0x654>)
   1fa68:	2400      	movs	r4, #0
   1fa6a:	e001      	b.n	1fa70 <SFXClassicSynthFrame+0x3a8>
   1fa6c:	ed96 0a0c 	vldr	s0, [r6, #48]	; 0x30
					tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
   1fa70:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fa72:	3401      	adds	r4, #1
					tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
   1fa74:	f007 fefa 	bl	2786c <tADSR4_setSustain>
				for (int i = 0; i < numVoices; i++)
   1fa78:	783b      	ldrb	r3, [r7, #0]
   1fa7a:	3504      	adds	r5, #4
   1fa7c:	42a3      	cmp	r3, r4
   1fa7e:	dcf5      	bgt.n	1fa6c <SFXClassicSynthFrame+0x3a4>
   1fa80:	e655      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fa82:	4aa7      	ldr	r2, [pc, #668]	; (1fd20 <SFXClassicSynthFrame+0x658>)
   1fa84:	4ba7      	ldr	r3, [pc, #668]	; (1fd24 <SFXClassicSynthFrame+0x65c>)
   1fa86:	edd2 7a00 	vldr	s15, [r2]
   1fa8a:	ed93 7a00 	vldr	s14, [r3]
   1fa8e:	4ba6      	ldr	r3, [pc, #664]	; (1fd28 <SFXClassicSynthFrame+0x660>)
   1fa90:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fa94:	ed9f 7aa5 	vldr	s14, [pc, #660]	; 1fd2c <SFXClassicSynthFrame+0x664>
				for (int i = 0; i < numVoices; i++)
   1fa98:	9f02      	ldr	r7, [sp, #8]
				displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fa9a:	4e9f      	ldr	r6, [pc, #636]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fa9c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
				for (int i = 0; i < numVoices; i++)
   1faa0:	783a      	ldrb	r2, [r7, #0]
				displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1faa2:	ee17 1a90 	vmov	r1, s15
   1faa6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1faaa:	ed93 0a00 	vldr	s0, [r3]
   1faae:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fab2:	ed86 0a0b 	vstr	s0, [r6, #44]	; 0x2c
				for (int i = 0; i < numVoices; i++)
   1fab6:	2a00      	cmp	r2, #0
   1fab8:	f43f ae39 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fabc:	4d97      	ldr	r5, [pc, #604]	; (1fd1c <SFXClassicSynthFrame+0x654>)
   1fabe:	2400      	movs	r4, #0
   1fac0:	e001      	b.n	1fac6 <SFXClassicSynthFrame+0x3fe>
   1fac2:	ed96 0a0b 	vldr	s0, [r6, #44]	; 0x2c
					tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
   1fac6:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fac8:	3401      	adds	r4, #1
					tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
   1faca:	f007 fec1 	bl	27850 <tADSR4_setDecay>
				for (int i = 0; i < numVoices; i++)
   1face:	783b      	ldrb	r3, [r7, #0]
   1fad0:	3504      	adds	r5, #4
   1fad2:	42a3      	cmp	r3, r4
   1fad4:	dcf5      	bgt.n	1fac2 <SFXClassicSynthFrame+0x3fa>
   1fad6:	e62a      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fad8:	4a95      	ldr	r2, [pc, #596]	; (1fd30 <SFXClassicSynthFrame+0x668>)
   1fada:	4b92      	ldr	r3, [pc, #584]	; (1fd24 <SFXClassicSynthFrame+0x65c>)
   1fadc:	edd2 7a00 	vldr	s15, [r2]
   1fae0:	ed93 7a00 	vldr	s14, [r3]
   1fae4:	4b90      	ldr	r3, [pc, #576]	; (1fd28 <SFXClassicSynthFrame+0x660>)
   1fae6:	ee67 7a87 	vmul.f32	s15, s15, s14
   1faea:	ed9f 7a90 	vldr	s14, [pc, #576]	; 1fd2c <SFXClassicSynthFrame+0x664>
				for (int i = 0; i < numVoices; i++)
   1faee:	9f02      	ldr	r7, [sp, #8]
				displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1faf0:	4e89      	ldr	r6, [pc, #548]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1faf2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
				for (int i = 0; i < numVoices; i++)
   1faf6:	783a      	ldrb	r2, [r7, #0]
				displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
   1faf8:	ee17 1a90 	vmov	r1, s15
   1fafc:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fb00:	ed93 0a00 	vldr	s0, [r3]
   1fb04:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fb08:	ed86 0a0a 	vstr	s0, [r6, #40]	; 0x28
				for (int i = 0; i < numVoices; i++)
   1fb0c:	2a00      	cmp	r2, #0
   1fb0e:	f43f ae0e 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fb12:	4d82      	ldr	r5, [pc, #520]	; (1fd1c <SFXClassicSynthFrame+0x654>)
   1fb14:	2400      	movs	r4, #0
   1fb16:	e001      	b.n	1fb1c <SFXClassicSynthFrame+0x454>
   1fb18:	ed96 0a0a 	vldr	s0, [r6, #40]	; 0x28
					tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
   1fb1c:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fb1e:	3401      	adds	r4, #1
					tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
   1fb20:	f007 fe88 	bl	27834 <tADSR4_setAttack>
				for (int i = 0; i < numVoices; i++)
   1fb24:	783b      	ldrb	r3, [r7, #0]
   1fb26:	3504      	adds	r5, #4
   1fb28:	42a3      	cmp	r3, r4
   1fb2a:	dcf5      	bgt.n	1fb18 <SFXClassicSynthFrame+0x450>
   1fb2c:	e5ff      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[9] = knobs[9]; //leak
   1fb2e:	4b81      	ldr	r3, [pc, #516]	; (1fd34 <SFXClassicSynthFrame+0x66c>)
				for (int i = 0; i < numVoices; i++)
   1fb30:	9f02      	ldr	r7, [sp, #8]
				displayValues[9] = knobs[9]; //leak
   1fb32:	edd3 7a00 	vldr	s15, [r3]
   1fb36:	4e78      	ldr	r6, [pc, #480]	; (1fd18 <SFXClassicSynthFrame+0x650>)
				for (int i = 0; i < numVoices; i++)
   1fb38:	783b      	ldrb	r3, [r7, #0]
				displayValues[9] = knobs[9]; //leak
   1fb3a:	edc6 7a09 	vstr	s15, [r6, #36]	; 0x24
				for (int i = 0; i < numVoices; i++)
   1fb3e:	2b00      	cmp	r3, #0
   1fb40:	f43f adf5 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
					tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1fb44:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   1fb48:	4d7b      	ldr	r5, [pc, #492]	; (1fd38 <SFXClassicSynthFrame+0x670>)
				for (int i = 0; i < numVoices; i++)
   1fb4a:	2400      	movs	r4, #0
					tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1fb4c:	eddf 8a7b 	vldr	s17, [pc, #492]	; 1fd3c <SFXClassicSynthFrame+0x674>
   1fb50:	ed9f 8a7b 	vldr	s16, [pc, #492]	; 1fd40 <SFXClassicSynthFrame+0x678>
   1fb54:	e001      	b.n	1fb5a <SFXClassicSynthFrame+0x492>
   1fb56:	edd6 7a09 	vldr	s15, [r6, #36]	; 0x24
   1fb5a:	ee79 7a67 	vsub.f32	s15, s18, s15
   1fb5e:	4628      	mov	r0, r5
   1fb60:	eeb0 0a48 	vmov.f32	s0, s16
				for (int i = 0; i < numVoices; i++)
   1fb64:	3401      	adds	r4, #1
   1fb66:	3504      	adds	r5, #4
					tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
   1fb68:	eea7 0aa8 	vfma.f32	s0, s15, s17
   1fb6c:	f007 fea2 	bl	278b4 <tADSR4_setLeakFactor>
				for (int i = 0; i < numVoices; i++)
   1fb70:	783b      	ldrb	r3, [r7, #0]
   1fb72:	42a3      	cmp	r3, r4
   1fb74:	dcef      	bgt.n	1fb56 <SFXClassicSynthFrame+0x48e>
   1fb76:	e5da      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1fb78:	4a72      	ldr	r2, [pc, #456]	; (1fd44 <SFXClassicSynthFrame+0x67c>)
   1fb7a:	4b6a      	ldr	r3, [pc, #424]	; (1fd24 <SFXClassicSynthFrame+0x65c>)
   1fb7c:	edd2 7a00 	vldr	s15, [r2]
   1fb80:	ed93 7a00 	vldr	s14, [r3]
   1fb84:	4b68      	ldr	r3, [pc, #416]	; (1fd28 <SFXClassicSynthFrame+0x660>)
   1fb86:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fb8a:	ed9f 7a68 	vldr	s14, [pc, #416]	; 1fd2c <SFXClassicSynthFrame+0x664>
				for (int i = 0; i < numVoices; i++)
   1fb8e:	9f02      	ldr	r7, [sp, #8]
				displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1fb90:	4e61      	ldr	r6, [pc, #388]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fb92:	eefd 7ae7 	vcvt.s32.f32	s15, s15
				for (int i = 0; i < numVoices; i++)
   1fb96:	783a      	ldrb	r2, [r7, #0]
				displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
   1fb98:	ee17 1a90 	vmov	r1, s15
   1fb9c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fba0:	ed93 0a00 	vldr	s0, [r3]
   1fba4:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fba8:	ed86 0a08 	vstr	s0, [r6, #32]
				for (int i = 0; i < numVoices; i++)
   1fbac:	2a00      	cmp	r2, #0
   1fbae:	f43f adbe 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fbb2:	4d61      	ldr	r5, [pc, #388]	; (1fd38 <SFXClassicSynthFrame+0x670>)
   1fbb4:	2400      	movs	r4, #0
   1fbb6:	e001      	b.n	1fbbc <SFXClassicSynthFrame+0x4f4>
   1fbb8:	ed96 0a08 	vldr	s0, [r6, #32]
					tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
   1fbbc:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fbbe:	3401      	adds	r4, #1
					tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
   1fbc0:	f007 fe6a 	bl	27898 <tADSR4_setRelease>
				for (int i = 0; i < numVoices; i++)
   1fbc4:	783b      	ldrb	r3, [r7, #0]
   1fbc6:	3504      	adds	r5, #4
   1fbc8:	42a3      	cmp	r3, r4
   1fbca:	dcf5      	bgt.n	1fbb8 <SFXClassicSynthFrame+0x4f0>
   1fbcc:	e5af      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[7] = knobs[7]; //sus
   1fbce:	4b5e      	ldr	r3, [pc, #376]	; (1fd48 <SFXClassicSynthFrame+0x680>)
				for (int i = 0; i < numVoices; i++)
   1fbd0:	9f02      	ldr	r7, [sp, #8]
				displayValues[7] = knobs[7]; //sus
   1fbd2:	ed93 0a00 	vldr	s0, [r3]
   1fbd6:	4e50      	ldr	r6, [pc, #320]	; (1fd18 <SFXClassicSynthFrame+0x650>)
				for (int i = 0; i < numVoices; i++)
   1fbd8:	783b      	ldrb	r3, [r7, #0]
				displayValues[7] = knobs[7]; //sus
   1fbda:	ed86 0a07 	vstr	s0, [r6, #28]
				for (int i = 0; i < numVoices; i++)
   1fbde:	2b00      	cmp	r3, #0
   1fbe0:	f43f ada5 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fbe4:	4d54      	ldr	r5, [pc, #336]	; (1fd38 <SFXClassicSynthFrame+0x670>)
   1fbe6:	2400      	movs	r4, #0
   1fbe8:	e001      	b.n	1fbee <SFXClassicSynthFrame+0x526>
   1fbea:	ed96 0a07 	vldr	s0, [r6, #28]
					tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
   1fbee:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fbf0:	3401      	adds	r4, #1
					tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
   1fbf2:	f007 fe3b 	bl	2786c <tADSR4_setSustain>
				for (int i = 0; i < numVoices; i++)
   1fbf6:	783b      	ldrb	r3, [r7, #0]
   1fbf8:	3504      	adds	r5, #4
   1fbfa:	42a3      	cmp	r3, r4
   1fbfc:	dcf5      	bgt.n	1fbea <SFXClassicSynthFrame+0x522>
   1fbfe:	e596      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fc00:	4a52      	ldr	r2, [pc, #328]	; (1fd4c <SFXClassicSynthFrame+0x684>)
   1fc02:	4b48      	ldr	r3, [pc, #288]	; (1fd24 <SFXClassicSynthFrame+0x65c>)
   1fc04:	edd2 7a00 	vldr	s15, [r2]
   1fc08:	ed93 7a00 	vldr	s14, [r3]
   1fc0c:	4b46      	ldr	r3, [pc, #280]	; (1fd28 <SFXClassicSynthFrame+0x660>)
   1fc0e:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fc12:	ed9f 7a46 	vldr	s14, [pc, #280]	; 1fd2c <SFXClassicSynthFrame+0x664>
				for (int i = 0; i < numVoices; i++)
   1fc16:	9f02      	ldr	r7, [sp, #8]
				displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fc18:	4e3f      	ldr	r6, [pc, #252]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fc1a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
				for (int i = 0; i < numVoices; i++)
   1fc1e:	783a      	ldrb	r2, [r7, #0]
				displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
   1fc20:	ee17 1a90 	vmov	r1, s15
   1fc24:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fc28:	ed93 0a00 	vldr	s0, [r3]
   1fc2c:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fc30:	ed86 0a06 	vstr	s0, [r6, #24]
				for (int i = 0; i < numVoices; i++)
   1fc34:	2a00      	cmp	r2, #0
   1fc36:	f43f ad7a 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fc3a:	4d3f      	ldr	r5, [pc, #252]	; (1fd38 <SFXClassicSynthFrame+0x670>)
   1fc3c:	2400      	movs	r4, #0
   1fc3e:	e001      	b.n	1fc44 <SFXClassicSynthFrame+0x57c>
   1fc40:	ed96 0a06 	vldr	s0, [r6, #24]
					tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
   1fc44:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fc46:	3401      	adds	r4, #1
					tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
   1fc48:	f007 fe02 	bl	27850 <tADSR4_setDecay>
				for (int i = 0; i < numVoices; i++)
   1fc4c:	783b      	ldrb	r3, [r7, #0]
   1fc4e:	3504      	adds	r5, #4
   1fc50:	42a3      	cmp	r3, r4
   1fc52:	dcf5      	bgt.n	1fc40 <SFXClassicSynthFrame+0x578>
   1fc54:	e56b      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fc56:	4a3e      	ldr	r2, [pc, #248]	; (1fd50 <SFXClassicSynthFrame+0x688>)
   1fc58:	4b32      	ldr	r3, [pc, #200]	; (1fd24 <SFXClassicSynthFrame+0x65c>)
   1fc5a:	edd2 7a00 	vldr	s15, [r2]
   1fc5e:	ed93 7a00 	vldr	s14, [r3]
   1fc62:	4b31      	ldr	r3, [pc, #196]	; (1fd28 <SFXClassicSynthFrame+0x660>)
   1fc64:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fc68:	ed9f 7a30 	vldr	s14, [pc, #192]	; 1fd2c <SFXClassicSynthFrame+0x664>
				for (int i = 0; i < numVoices; i++)
   1fc6c:	9f02      	ldr	r7, [sp, #8]
				displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fc6e:	4e2a      	ldr	r6, [pc, #168]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fc70:	eefd 7ae7 	vcvt.s32.f32	s15, s15
				for (int i = 0; i < numVoices; i++)
   1fc74:	783a      	ldrb	r2, [r7, #0]
				displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
   1fc76:	ee17 1a90 	vmov	r1, s15
   1fc7a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1fc7e:	ed93 0a00 	vldr	s0, [r3]
   1fc82:	ee20 0a07 	vmul.f32	s0, s0, s14
   1fc86:	ed86 0a05 	vstr	s0, [r6, #20]
				for (int i = 0; i < numVoices; i++)
   1fc8a:	2a00      	cmp	r2, #0
   1fc8c:	f43f ad4f 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fc90:	4d29      	ldr	r5, [pc, #164]	; (1fd38 <SFXClassicSynthFrame+0x670>)
   1fc92:	2400      	movs	r4, #0
   1fc94:	e001      	b.n	1fc9a <SFXClassicSynthFrame+0x5d2>
   1fc96:	ed96 0a05 	vldr	s0, [r6, #20]
					tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
   1fc9a:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fc9c:	3401      	adds	r4, #1
					tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
   1fc9e:	f007 fdc9 	bl	27834 <tADSR4_setAttack>
				for (int i = 0; i < numVoices; i++)
   1fca2:	783b      	ldrb	r3, [r7, #0]
   1fca4:	3504      	adds	r5, #4
   1fca6:	42a3      	cmp	r3, r4
   1fca8:	dcf5      	bgt.n	1fc96 <SFXClassicSynthFrame+0x5ce>
   1fcaa:	e540      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1fcac:	4b29      	ldr	r3, [pc, #164]	; (1fd54 <SFXClassicSynthFrame+0x68c>)
   1fcae:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   1fcb2:	ed9f 0a29 	vldr	s0, [pc, #164]	; 1fd58 <SFXClassicSynthFrame+0x690>
   1fcb6:	ed93 7a00 	vldr	s14, [r3]
				for (int i = 0; i < numVoices; i++)
   1fcba:	9f02      	ldr	r7, [sp, #8]
				displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1fcbc:	eea7 0a27 	vfma.f32	s0, s14, s15
   1fcc0:	4e15      	ldr	r6, [pc, #84]	; (1fd18 <SFXClassicSynthFrame+0x650>)
				for (int i = 0; i < numVoices; i++)
   1fcc2:	783b      	ldrb	r3, [r7, #0]
				displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
   1fcc4:	ed86 0a04 	vstr	s0, [r6, #16]
				for (int i = 0; i < numVoices; i++)
   1fcc8:	2b00      	cmp	r3, #0
   1fcca:	f43f ad30 	beq.w	1f72e <SFXClassicSynthFrame+0x66>
   1fcce:	4d23      	ldr	r5, [pc, #140]	; (1fd5c <SFXClassicSynthFrame+0x694>)
   1fcd0:	2400      	movs	r4, #0
   1fcd2:	e001      	b.n	1fcd8 <SFXClassicSynthFrame+0x610>
   1fcd4:	ed96 0a04 	vldr	s0, [r6, #16]
					tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
   1fcd8:	4628      	mov	r0, r5
				for (int i = 0; i < numVoices; i++)
   1fcda:	3401      	adds	r4, #1
					tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
   1fcdc:	f008 fc12 	bl	28504 <tEfficientSVF_setQ>
				for (int i = 0; i < numVoices; i++)
   1fce0:	783b      	ldrb	r3, [r7, #0]
   1fce2:	3504      	adds	r5, #4
   1fce4:	42a3      	cmp	r3, r4
   1fce6:	dcf5      	bgt.n	1fcd4 <SFXClassicSynthFrame+0x60c>
   1fce8:	e521      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[3] = knobs[3]; //detune
   1fcea:	4b1d      	ldr	r3, [pc, #116]	; (1fd60 <SFXClassicSynthFrame+0x698>)
   1fcec:	4e0a      	ldr	r6, [pc, #40]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fcee:	681b      	ldr	r3, [r3, #0]
   1fcf0:	60f3      	str	r3, [r6, #12]
				break;
   1fcf2:	e51c      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[2] = knobs[2]; //keyfollow filter cutoff
   1fcf4:	4b1b      	ldr	r3, [pc, #108]	; (1fd64 <SFXClassicSynthFrame+0x69c>)
   1fcf6:	4e08      	ldr	r6, [pc, #32]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fcf8:	681b      	ldr	r3, [r3, #0]
   1fcfa:	60b3      	str	r3, [r6, #8]
				break;
   1fcfc:	e517      	b.n	1f72e <SFXClassicSynthFrame+0x66>
				displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
   1fcfe:	4b1a      	ldr	r3, [pc, #104]	; (1fd68 <SFXClassicSynthFrame+0x6a0>)
   1fd00:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 1fd6c <SFXClassicSynthFrame+0x6a4>
   1fd04:	edd3 7a00 	vldr	s15, [r3]
   1fd08:	4e03      	ldr	r6, [pc, #12]	; (1fd18 <SFXClassicSynthFrame+0x650>)
   1fd0a:	ee67 7a87 	vmul.f32	s15, s15, s14
   1fd0e:	edc6 7a01 	vstr	s15, [r6, #4]
				break;
   1fd12:	e50c      	b.n	1f72e <SFXClassicSynthFrame+0x66>
   1fd14:	020f9988 	.word	0x020f9988
   1fd18:	020fb3cc 	.word	0x020fb3cc
   1fd1c:	020f8550 	.word	0x020f8550
   1fd20:	020f9984 	.word	0x020f9984
   1fd24:	00062acc 	.word	0x00062acc
   1fd28:	020f9c84 	.word	0x020f9c84
   1fd2c:	46000000 	.word	0x46000000
   1fd30:	020f9980 	.word	0x020f9980
   1fd34:	020f997c 	.word	0x020f997c
   1fd38:	020fa2d8 	.word	0x020fa2d8
   1fd3c:	3851b717 	.word	0x3851b717
   1fd40:	3f7ffcb9 	.word	0x3f7ffcb9
   1fd44:	020f9978 	.word	0x020f9978
   1fd48:	020f9974 	.word	0x020f9974
   1fd4c:	020f9970 	.word	0x020f9970
   1fd50:	020f996c 	.word	0x020f996c
   1fd54:	020f9968 	.word	0x020f9968
   1fd58:	3ecccccd 	.word	0x3ecccccd
   1fd5c:	020f9a20 	.word	0x020f9a20
   1fd60:	020f9964 	.word	0x020f9964
   1fd64:	020f9960 	.word	0x020f9960
   1fd68:	020f995c 	.word	0x020f995c
   1fd6c:	45800000 	.word	0x45800000

0001fd70 <SFXClassicSynthTick>:
{
   1fd70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fd74:	2500      	movs	r5, #0
   1fd76:	f8df a124 	ldr.w	sl, [pc, #292]	; 1fe9c <SFXClassicSynthTick+0x12c>
   1fd7a:	260c      	movs	r6, #12
   1fd7c:	4c3e      	ldr	r4, [pc, #248]	; (1fe78 <SFXClassicSynthTick+0x108>)
   1fd7e:	46a9      	mov	r9, r5
{
   1fd80:	ed2d 8b08 	vpush	{d8-d11}
   1fd84:	b083      	sub	sp, #12
	float sample = 0.0f;
   1fd86:	eddf aa3d 	vldr	s21, [pc, #244]	; 1fe7c <SFXClassicSynthTick+0x10c>
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fd8a:	ed9f ba3d 	vldr	s22, [pc, #244]	; 1fe80 <SFXClassicSynthTick+0x110>
{
   1fd8e:	9001      	str	r0, [sp, #4]
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fd90:	eef0 ba6a 	vmov.f32	s23, s21
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fd94:	483b      	ldr	r0, [pc, #236]	; (1fe84 <SFXClassicSynthTick+0x114>)
   1fd96:	f00a fbdf 	bl	2a558 <tSimplePoly_getNumVoices>
   1fd9a:	4548      	cmp	r0, r9
   1fd9c:	dd58      	ble.n	1fe50 <SFXClassicSynthTick+0xe0>
		float env = tADSR4_tick(&polyEnvs[i]);
   1fd9e:	483a      	ldr	r0, [pc, #232]	; (1fe88 <SFXClassicSynthTick+0x118>)
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fda0:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
   1fda4:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
		float tempSample = 0.0f;
   1fda8:	eddf 8a34 	vldr	s17, [pc, #208]	; 1fe7c <SFXClassicSynthTick+0x10c>
		float env = tADSR4_tick(&polyEnvs[i]);
   1fdac:	4428      	add	r0, r5
   1fdae:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 1fea0 <SFXClassicSynthTick+0x130>
   1fdb2:	f007 fd9d 	bl	278f0 <tADSR4_tick>
   1fdb6:	eef0 9a40 	vmov.f32	s19, s0
   1fdba:	4f34      	ldr	r7, [pc, #208]	; (1fe8c <SFXClassicSynthTick+0x11c>)
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fdbc:	eb08 000b 	add.w	r0, r8, fp
   1fdc0:	f00a fcda 	bl	2a778 <tSawtooth_tick>
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fdc4:	eb07 000b 	add.w	r0, r7, fp
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fdc8:	eeb0 9a40 	vmov.f32	s18, s0
   1fdcc:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fdd0:	f006 fb24 	bl	2641c <tRosenbergGlottalPulse_tick>
   1fdd4:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
			tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
   1fdd8:	ee3a 8a48 	vsub.f32	s16, s20, s16
   1fddc:	f10b 0b04 	add.w	fp, fp, #4
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fde0:	ee20 0a27 	vmul.f32	s0, s0, s15
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1fde4:	45b3      	cmp	fp, r6
			tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
   1fde6:	eea9 0a08 	vfma.f32	s0, s18, s16
   1fdea:	eee9 8a80 	vfma.f32	s17, s19, s0
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1fdee:	d1e5      	bne.n	1fdbc <SFXClassicSynthTick+0x4c>
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fdf0:	f83a 3f02 	ldrh.w	r3, [sl, #2]!
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fdf4:	f109 0901 	add.w	r9, r9, #1
		tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
   1fdf8:	4825      	ldr	r0, [pc, #148]	; (1fe90 <SFXClassicSynthTick+0x120>)
   1fdfa:	360c      	adds	r6, #12
   1fdfc:	ee08 3a10 	vmov	s16, r3
   1fe00:	ed94 9a0f 	vldr	s18, [r4, #60]	; 0x3c
   1fe04:	4428      	add	r0, r5
   1fe06:	4f23      	ldr	r7, [pc, #140]	; (1fe94 <SFXClassicSynthTick+0x124>)
   1fe08:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
   1fe0c:	f007 fd70 	bl	278f0 <tADSR4_tick>
   1fe10:	eeb0 1a4b 	vmov.f32	s2, s22
   1fe14:	442f      	add	r7, r5
   1fe16:	3504      	adds	r5, #4
   1fe18:	eef0 0a48 	vmov.f32	s1, s16
   1fe1c:	eee9 0a00 	vfma.f32	s1, s18, s0
   1fe20:	eeb0 0a6b 	vmov.f32	s0, s23
   1fe24:	f009 fd30 	bl	29888 <LEAF_clip>
   1fe28:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   1fe2c:	4638      	mov	r0, r7
   1fe2e:	ee10 3a10 	vmov	r3, s0
   1fe32:	b299      	uxth	r1, r3
   1fe34:	f008 fb42 	bl	284bc <tEfficientSVF_setFreq>
		sample += tEfficientSVF_tick(&synthLP[i], tempSample);
   1fe38:	4638      	mov	r0, r7
   1fe3a:	eeb0 0a68 	vmov.f32	s0, s17
   1fe3e:	f008 faed 	bl	2841c <tEfficientSVF_tick>
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fe42:	4810      	ldr	r0, [pc, #64]	; (1fe84 <SFXClassicSynthTick+0x114>)
		sample += tEfficientSVF_tick(&synthLP[i], tempSample);
   1fe44:	ee7a aa80 	vadd.f32	s21, s21, s0
	for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
   1fe48:	f00a fb86 	bl	2a558 <tSimplePoly_getNumVoices>
   1fe4c:	4548      	cmp	r0, r9
   1fe4e:	dca6      	bgt.n	1fd9e <SFXClassicSynthTick+0x2e>
	sample *= INV_NUM_OSC_PER_VOICE * displayValues[0];
   1fe50:	ed94 0a00 	vldr	s0, [r4]
   1fe54:	eddf 7a10 	vldr	s15, [pc, #64]	; 1fe98 <SFXClassicSynthTick+0x128>
   1fe58:	ee20 0a27 	vmul.f32	s0, s0, s15
	sample = tanhf(sample);
   1fe5c:	ee20 0a2a 	vmul.f32	s0, s0, s21
   1fe60:	f00d fa2c 	bl	2d2bc <tanhf>
	input[0] = sample;
   1fe64:	9b01      	ldr	r3, [sp, #4]
   1fe66:	ed83 0a00 	vstr	s0, [r3]
	input[1] = sample;
   1fe6a:	ed83 0a01 	vstr	s0, [r3, #4]
}
   1fe6e:	b003      	add	sp, #12
   1fe70:	ecbd 8b08 	vpop	{d8-d11}
   1fe74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1fe78:	020fb3cc 	.word	0x020fb3cc
   1fe7c:	00000000 	.word	0x00000000
   1fe80:	457ff000 	.word	0x457ff000
   1fe84:	020fa15c 	.word	0x020fa15c
   1fe88:	020fa2d8 	.word	0x020fa2d8
   1fe8c:	020f8e50 	.word	0x020f8e50
   1fe90:	020f8550 	.word	0x020f8550
   1fe94:	020f9a20 	.word	0x020f9a20
   1fe98:	3ea8f5c3 	.word	0x3ea8f5c3
   1fe9c:	020f9e82 	.word	0x020f9e82
   1fea0:	020f9f1c 	.word	0x020f9f1c

0001fea4 <SFXClassicSynthFree>:
{
   1fea4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fea8:	2500      	movs	r5, #0
   1feaa:	260c      	movs	r6, #12
   1feac:	f8df 8064 	ldr.w	r8, [pc, #100]	; 1ff14 <SFXClassicSynthFree+0x70>
   1feb0:	4f15      	ldr	r7, [pc, #84]	; (1ff08 <SFXClassicSynthFree+0x64>)
   1feb2:	f8df b064 	ldr.w	fp, [pc, #100]	; 1ff18 <SFXClassicSynthFree+0x74>
   1feb6:	f8df a064 	ldr.w	sl, [pc, #100]	; 1ff1c <SFXClassicSynthFree+0x78>
   1feba:	f8df 9064 	ldr.w	r9, [pc, #100]	; 1ff20 <SFXClassicSynthFree+0x7c>
   1febe:	eb05 0445 	add.w	r4, r5, r5, lsl #1
			tSawtooth_free(&osc[(i * NUM_OSC_PER_VOICE) + j]);
   1fec2:	eb08 0004 	add.w	r0, r8, r4
   1fec6:	f00a fc21 	bl	2a70c <tSawtooth_free>
			tRosenbergGlottalPulse_free(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
   1feca:	1938      	adds	r0, r7, r4
   1fecc:	3404      	adds	r4, #4
   1fece:	f006 faa1 	bl	26414 <tRosenbergGlottalPulse_free>
		for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
   1fed2:	42b4      	cmp	r4, r6
   1fed4:	d1f5      	bne.n	1fec2 <SFXClassicSynthFree+0x1e>
		tEfficientSVF_free(&synthLP[i]);
   1fed6:	eb0b 0005 	add.w	r0, fp, r5
   1feda:	f104 060c 	add.w	r6, r4, #12
   1fede:	f008 fa99 	bl	28414 <tEfficientSVF_free>
		tADSR4_free(&polyEnvs[i]);
   1fee2:	eb0a 0005 	add.w	r0, sl, r5
   1fee6:	f007 fca1 	bl	2782c <tADSR4_free>
		tADSR4_free(&polyFiltEnvs[i]);
   1feea:	eb09 0005 	add.w	r0, r9, r5
   1feee:	3504      	adds	r5, #4
   1fef0:	f007 fc9c 	bl	2782c <tADSR4_free>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1fef4:	2d20      	cmp	r5, #32
   1fef6:	d1e2      	bne.n	1febe <SFXClassicSynthFree+0x1a>
	tCycle_free(&pwmLFO1);
   1fef8:	4804      	ldr	r0, [pc, #16]	; (1ff0c <SFXClassicSynthFree+0x68>)
   1fefa:	f00a fb73 	bl	2a5e4 <tCycle_free>
	tCycle_free(&pwmLFO2);
   1fefe:	4804      	ldr	r0, [pc, #16]	; (1ff10 <SFXClassicSynthFree+0x6c>)
}
   1ff00:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tCycle_free(&pwmLFO2);
   1ff04:	f00a bb6e 	b.w	2a5e4 <tCycle_free>
   1ff08:	020f8e50 	.word	0x020f8e50
   1ff0c:	020fa2c8 	.word	0x020fa2c8
   1ff10:	020fa3ac 	.word	0x020fa3ac
   1ff14:	020f9f1c 	.word	0x020f9f1c
   1ff18:	020f9a20 	.word	0x020f9a20
   1ff1c:	020fa2d8 	.word	0x020fa2d8
   1ff20:	020f8550 	.word	0x020f8550

0001ff24 <SFXRhodesAlloc>:
{
   1ff24:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	leaf.clearOnAllocation = 1;
   1ff28:	2101      	movs	r1, #1
	soundNames[0] = "DARK  ";
   1ff2a:	f8df b150 	ldr.w	fp, [pc, #336]	; 2007c <SFXRhodesAlloc+0x158>
   1ff2e:	4a41      	ldr	r2, [pc, #260]	; (20034 <SFXRhodesAlloc+0x110>)
	soundNames[4] = "CUSTOM";
   1ff30:	2400      	movs	r4, #0
	soundNames[1] = "LIGHT ";
   1ff32:	4b41      	ldr	r3, [pc, #260]	; (20038 <SFXRhodesAlloc+0x114>)
	leaf.clearOnAllocation = 1;
   1ff34:	4841      	ldr	r0, [pc, #260]	; (2003c <SFXRhodesAlloc+0x118>)
	soundNames[0] = "DARK  ";
   1ff36:	f8cb 2000 	str.w	r2, [fp]
	soundNames[1] = "LIGHT ";
   1ff3a:	f8cb 3004 	str.w	r3, [fp, #4]
	soundNames[3] = "PAD   ";
   1ff3e:	4a40      	ldr	r2, [pc, #256]	; (20040 <SFXRhodesAlloc+0x11c>)
	soundNames[4] = "CUSTOM";
   1ff40:	4b40      	ldr	r3, [pc, #256]	; (20044 <SFXRhodesAlloc+0x120>)
   1ff42:	f8df a13c 	ldr.w	sl, [pc, #316]	; 20080 <SFXRhodesAlloc+0x15c>
   1ff46:	f8df 913c 	ldr.w	r9, [pc, #316]	; 20084 <SFXRhodesAlloc+0x160>
   1ff4a:	f8cb 3010 	str.w	r3, [fp, #16]
{
   1ff4e:	ed2d 8b04 	vpush	{d8-d9}
	leaf.clearOnAllocation = 1;
   1ff52:	6141      	str	r1, [r0, #20]
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1ff54:	ed9f 9a3c 	vldr	s18, [pc, #240]	; 20048 <SFXRhodesAlloc+0x124>
	soundNames[2] = "BASS  ";
   1ff58:	493c      	ldr	r1, [pc, #240]	; (2004c <SFXRhodesAlloc+0x128>)
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1ff5a:	eddf 8a3d 	vldr	s17, [pc, #244]	; 20050 <SFXRhodesAlloc+0x12c>
			tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   1ff5e:	ed9f 8a3d 	vldr	s16, [pc, #244]	; 20054 <SFXRhodesAlloc+0x130>
	soundNames[3] = "PAD   ";
   1ff62:	e9cb 1202 	strd	r1, r2, [fp, #8]
   1ff66:	f104 0818 	add.w	r8, r4, #24
			tCycle_initToPool(&FM_sines[i][j], &smallPool);
   1ff6a:	4e3b      	ldr	r6, [pc, #236]	; (20058 <SFXRhodesAlloc+0x134>)
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1ff6c:	4f3b      	ldr	r7, [pc, #236]	; (2005c <SFXRhodesAlloc+0x138>)
   1ff6e:	eb09 0504 	add.w	r5, r9, r4
			tCycle_initToPool(&FM_sines[i][j], &smallPool);
   1ff72:	eb0a 0004 	add.w	r0, sl, r4
   1ff76:	4631      	mov	r1, r6
   1ff78:	3404      	adds	r4, #4
   1ff7a:	f00a fb25 	bl	2a5c8 <tCycle_initToPool>
			tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
   1ff7e:	4628      	mov	r0, r5
   1ff80:	4633      	mov	r3, r6
   1ff82:	f44f 7200 	mov.w	r2, #512	; 0x200
   1ff86:	4639      	mov	r1, r7
   1ff88:	eef0 1a49 	vmov.f32	s3, s18
   1ff8c:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
   1ff90:	eef0 0a68 	vmov.f32	s1, s17
   1ff94:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   1ff98:	f007 fbee 	bl	27778 <tADSR4_initToPool>
			tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
   1ff9c:	eeb0 0a48 	vmov.f32	s0, s16
   1ffa0:	4628      	mov	r0, r5
   1ffa2:	f007 fc87 	bl	278b4 <tADSR4_setLeakFactor>
		for (int j = 0; j < 6; j++)
   1ffa6:	4544      	cmp	r4, r8
   1ffa8:	d1e1      	bne.n	1ff6e <SFXRhodesAlloc+0x4a>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   1ffaa:	2cc0      	cmp	r4, #192	; 0xc0
   1ffac:	d1db      	bne.n	1ff66 <SFXRhodesAlloc+0x42>
   1ffae:	4c2c      	ldr	r4, [pc, #176]	; (20060 <SFXRhodesAlloc+0x13c>)
		tExpSmooth_initToPool(&susSmoothers[i], 1.0f, 0.01f, &smallPool);
   1ffb0:	4e29      	ldr	r6, [pc, #164]	; (20058 <SFXRhodesAlloc+0x134>)
   1ffb2:	f104 0518 	add.w	r5, r4, #24
   1ffb6:	ed9f 8a2b 	vldr	s16, [pc, #172]	; 20064 <SFXRhodesAlloc+0x140>
   1ffba:	4620      	mov	r0, r4
   1ffbc:	3404      	adds	r4, #4
   1ffbe:	4631      	mov	r1, r6
   1ffc0:	eef0 0a48 	vmov.f32	s1, s16
   1ffc4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   1ffc8:	f007 ff8e 	bl	27ee8 <tExpSmooth_initToPool>
	for (int i = 0; i < 6; i++)
   1ffcc:	42a5      	cmp	r5, r4
   1ffce:	d1f4      	bne.n	1ffba <SFXRhodesAlloc+0x96>
	tCycle_initToPool(&tremolo, &smallPool);
   1ffd0:	4921      	ldr	r1, [pc, #132]	; (20058 <SFXRhodesAlloc+0x134>)
   1ffd2:	4825      	ldr	r0, [pc, #148]	; (20068 <SFXRhodesAlloc+0x144>)
   1ffd4:	f00a faf8 	bl	2a5c8 <tCycle_initToPool>
	tCycle_setFreq(&tremolo, 3.0f);
   1ffd8:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
   1ffdc:	4822      	ldr	r0, [pc, #136]	; (20068 <SFXRhodesAlloc+0x144>)
   1ffde:	f00a fb05 	bl	2a5ec <tCycle_setFreq>
	tSimplePoly_setNumVoices(&poly, NUM_VOC_VOICES);
   1ffe2:	2108      	movs	r1, #8
   1ffe4:	4821      	ldr	r0, [pc, #132]	; (2006c <SFXRhodesAlloc+0x148>)
   1ffe6:	f00a faaf 	bl	2a548 <tSimplePoly_setNumVoices>
	setLED_A(numVoices == 1);
   1ffea:	4b21      	ldr	r3, [pc, #132]	; (20070 <SFXRhodesAlloc+0x14c>)
   1ffec:	7818      	ldrb	r0, [r3, #0]
   1ffee:	f1a0 0001 	sub.w	r0, r0, #1
   1fff2:	fab0 f080 	clz	r0, r0
   1fff6:	0940      	lsrs	r0, r0, #5
   1fff8:	f7f9 faa0 	bl	1953c <setLED_A>
	setLED_C(tremoloStereo == 1);
   1fffc:	4b1d      	ldr	r3, [pc, #116]	; (20074 <SFXRhodesAlloc+0x150>)
   1fffe:	7818      	ldrb	r0, [r3, #0]
   20000:	f1a0 0001 	sub.w	r0, r0, #1
   20004:	fab0 f080 	clz	r0, r0
   20008:	0940      	lsrs	r0, r0, #5
   2000a:	f7f9 fab3 	bl	19574 <setLED_C>
	OLEDclearLine(SecondLine);
   2000e:	2001      	movs	r0, #1
   20010:	f7f9 fcbc 	bl	1998c <OLEDclearLine>
	OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   20014:	4918      	ldr	r1, [pc, #96]	; (20078 <SFXRhodesAlloc+0x154>)
   20016:	2301      	movs	r3, #1
   20018:	2200      	movs	r2, #0
   2001a:	6808      	ldr	r0, [r1, #0]
   2001c:	2106      	movs	r1, #6
   2001e:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
   20022:	f7f9 fcc7 	bl	199b4 <OLEDwriteString>
	leaf.clearOnAllocation = 0;
   20026:	2300      	movs	r3, #0
   20028:	4a04      	ldr	r2, [pc, #16]	; (2003c <SFXRhodesAlloc+0x118>)
   2002a:	6153      	str	r3, [r2, #20]
}
   2002c:	ecbd 8b04 	vpop	{d8-d9}
   20030:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20034:	00031010 	.word	0x00031010
   20038:	00031018 	.word	0x00031018
   2003c:	020fc0a8 	.word	0x020fc0a8
   20040:	00031028 	.word	0x00031028
   20044:	00031030 	.word	0x00031030
   20048:	42c80000 	.word	0x42c80000
   2004c:	00031020 	.word	0x00031020
   20050:	447a0000 	.word	0x447a0000
   20054:	3f7ffeb0 	.word	0x3f7ffeb0
   20058:	020f7730 	.word	0x020f7730
   2005c:	020fa578 	.word	0x020fa578
   20060:	020f9038 	.word	0x020f9038
   20064:	3c23d70a 	.word	0x3c23d70a
   20068:	020fa3a8 	.word	0x020fa3a8
   2006c:	020fa15c 	.word	0x020fa15c
   20070:	00062ae4 	.word	0x00062ae4
   20074:	020e3214 	.word	0x020e3214
   20078:	020e3118 	.word	0x020e3118
   2007c:	020fa128 	.word	0x020fa128
   20080:	020f9a74 	.word	0x020f9a74
   20084:	020fa164 	.word	0x020fa164

00020088 <SFXRhodesFrame>:
{
   20088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   2008c:	4ce0      	ldr	r4, [pc, #896]	; (20410 <SFXRhodesFrame+0x388>)
{
   2008e:	ed2d 8b04 	vpush	{d8-d9}
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   20092:	7d23      	ldrb	r3, [r4, #20]
{
   20094:	b083      	sub	sp, #12
	if (buttonActionsSFX[ButtonA][ActionPress] == 1)
   20096:	2b01      	cmp	r3, #1
   20098:	f000 846d 	beq.w	20976 <SFXRhodesFrame+0x8ee>
   2009c:	4bdd      	ldr	r3, [pc, #884]	; (20414 <SFXRhodesFrame+0x38c>)
   2009e:	9301      	str	r3, [sp, #4]
	if (buttonActionsSFX[ButtonB][ActionPress] == 1)
   200a0:	7e23      	ldrb	r3, [r4, #24]
   200a2:	2b01      	cmp	r3, #1
   200a4:	d10e      	bne.n	200c4 <SFXRhodesFrame+0x3c>
		Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   200a6:	48dc      	ldr	r0, [pc, #880]	; (20418 <SFXRhodesFrame+0x390>)
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   200a8:	2100      	movs	r1, #0
		Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   200aa:	4adc      	ldr	r2, [pc, #880]	; (2041c <SFXRhodesFrame+0x394>)
   200ac:	6803      	ldr	r3, [r0, #0]
		buttonActionsSFX[ButtonB][ActionPress] = 0;
   200ae:	7621      	strb	r1, [r4, #24]
		Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
   200b0:	3301      	adds	r3, #1
   200b2:	fb82 2103 	smull	r2, r1, r2, r3
   200b6:	17da      	asrs	r2, r3, #31
   200b8:	ebc2 0261 	rsb	r2, r2, r1, asr #1
   200bc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   200c0:	1a9b      	subs	r3, r3, r2
   200c2:	6003      	str	r3, [r0, #0]
	if (buttonActionsSFX[ButtonC][ActionPress] == 1)
   200c4:	7f23      	ldrb	r3, [r4, #28]
   200c6:	2b01      	cmp	r3, #1
   200c8:	f000 846c 	beq.w	209a4 <SFXRhodesFrame+0x91c>
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   200cc:	4dd4      	ldr	r5, [pc, #848]	; (20420 <SFXRhodesFrame+0x398>)
   200ce:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   200d2:	4bd4      	ldr	r3, [pc, #848]	; (20424 <SFXRhodesFrame+0x39c>)
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   200d4:	eeb2 2a04 	vmov.f32	s4, #36	; 0x41200000  10.0
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   200d8:	ed95 6a08 	vldr	s12, [r5, #32]
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   200dc:	4628      	mov	r0, r5
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   200de:	edd3 6a00 	vldr	s13, [r3]
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   200e2:	eefa 0a04 	vmov.f32	s1, #164	; 0xc1200000 -10.0
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   200e6:	ed95 7a05 	vldr	s14, [r5, #20]
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   200ea:	edd5 7a06 	vldr	s15, [r5, #24]
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   200ee:	ee26 7a87 	vmul.f32	s14, s13, s14
   200f2:	49cd      	ldr	r1, [pc, #820]	; (20428 <SFXRhodesFrame+0x3a0>)
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   200f4:	ee66 7aa7 	vmul.f32	s15, s13, s15
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   200f8:	ecf0 3a01 	vldmia	r0!, {s7}
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   200fc:	ee66 6a86 	vmul.f32	s13, s13, s12
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20100:	edd5 4a03 	vldr	s9, [r5, #12]
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20104:	eebd 7ac7 	vcvt.s32.f32	s14, s14
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20108:	ed9f 1ac8 	vldr	s2, [pc, #800]	; 2042c <SFXRhodesFrame+0x3a4>
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   2010c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20110:	eddf 2ac7 	vldr	s5, [pc, #796]	; 20430 <SFXRhodesFrame+0x3a8>
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   20114:	eefd 6ae6 	vcvt.s32.f32	s13, s13
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20118:	ed95 6a0a 	vldr	s12, [r5, #40]	; 0x28
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   2011c:	ee17 2a10 	vmov	r2, s14
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   20120:	ee63 3aa5 	vmul.f32	s7, s7, s11
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20124:	ee17 3a90 	vmov	r3, s15
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20128:	eddf 7ac2 	vldr	s15, [pc, #776]	; 20434 <SFXRhodesFrame+0x3ac>
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2012c:	ee16 4a90 	vmov	r4, s13
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20130:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20134:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20138:	ee64 4aa7 	vmul.f32	s9, s9, s15
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2013c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20140:	ed92 3a00 	vldr	s6, [r2]
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20144:	ed93 5a00 	vldr	s10, [r3]
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20148:	ee66 6a01 	vmul.f32	s13, s12, s2
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   2014c:	edd1 5a00 	vldr	s11, [r1]
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   20150:	ee23 3a22 	vmul.f32	s6, s6, s5
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   20154:	ed95 4a02 	vldr	s8, [r5, #8]
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   20158:	ee25 5a22 	vmul.f32	s10, s10, s5
	FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   2015c:	ed95 7a0b 	vldr	s14, [r5, #44]	; 0x2c
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   20160:	ee65 5aa2 	vmul.f32	s11, s11, s5
	FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   20164:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   20168:	ee24 4a02 	vmul.f32	s8, s8, s4
	FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   2016c:	ee27 7a01 	vmul.f32	s14, s14, s2
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   20170:	4cb1      	ldr	r4, [pc, #708]	; (20438 <SFXRhodesFrame+0x3b0>)
	FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   20172:	ee67 7a81 	vmul.f32	s15, s15, s2
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   20176:	4eb1      	ldr	r6, [pc, #708]	; (2043c <SFXRhodesFrame+0x3b4>)
	displayValues[9] = presetKnobValues[Rhodes][9];
   20178:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
   2017a:	6800      	ldr	r0, [r0, #0]
	displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
   2017c:	6929      	ldr	r1, [r5, #16]
	displayValues[7] = presetKnobValues[Rhodes][7];
   2017e:	69ea      	ldr	r2, [r5, #28]
	displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
   20180:	ed84 4a02 	vstr	s8, [r4, #8]
	displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
   20184:	edc4 5a08 	vstr	s11, [r4, #32]
	displayValues[9] = presetKnobValues[Rhodes][9];
   20188:	6263      	str	r3, [r4, #36]	; 0x24
	displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
   2018a:	ed84 3a05 	vstr	s6, [r4, #20]
	displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
   2018e:	6060      	str	r0, [r4, #4]
	displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
   20190:	edc4 3a00 	vstr	s7, [r4]
	displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
   20194:	edc4 4a03 	vstr	s9, [r4, #12]
	displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
   20198:	6121      	str	r1, [r4, #16]
	displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
   2019a:	ed84 5a06 	vstr	s10, [r4, #24]
	displayValues[7] = presetKnobValues[Rhodes][7];
   2019e:	61e2      	str	r2, [r4, #28]
	FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
   201a0:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
   201a4:	edc6 6a18 	vstr	s13, [r6, #96]	; 0x60
	FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
   201a8:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
   201ac:	ed86 7a19 	vstr	s14, [r6, #100]	; 0x64
	FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
   201b0:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
   201b4:	edc6 7a1a 	vstr	s15, [r6, #104]	; 0x68
	FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   201b8:	ed95 7a0d 	vldr	s14, [r5, #52]	; 0x34
	FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   201bc:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
	FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   201c0:	ee27 7a01 	vmul.f32	s14, s14, s2
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   201c4:	edd5 6a15 	vldr	s13, [r5, #84]	; 0x54
	FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   201c8:	ee67 7a81 	vmul.f32	s15, s15, s2
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201cc:	f8df 8294 	ldr.w	r8, [pc, #660]	; 20464 <SFXRhodesFrame+0x3dc>
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   201d0:	eee6 0a81 	vfma.f32	s1, s13, s2
   201d4:	ed9f 0a9a 	vldr	s0, [pc, #616]	; 20440 <SFXRhodesFrame+0x3b8>
	FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
   201d8:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
   201dc:	ed86 7a1b 	vstr	s14, [r6, #108]	; 0x6c
	FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
   201e0:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
   201e4:	edc6 7a1c 	vstr	s15, [r6, #112]	; 0x70
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   201e8:	f009 fb4e 	bl	29888 <LEAF_clip>
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201ec:	ed95 4a0f 	vldr	s8, [r5, #60]	; 0x3c
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   201f0:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201f4:	edd8 6a0f 	vldr	s13, [r8, #60]	; 0x3c
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   201f8:	4b92      	ldr	r3, [pc, #584]	; (20444 <SFXRhodesFrame+0x3bc>)
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   201fa:	eef4 6a44 	vcmp.f32	s13, s8
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   201fe:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20202:	ed93 7a00 	vldr	s14, [r3]
	FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
   20206:	ed86 0a1d 	vstr	s0, [r6, #116]	; 0x74
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2020a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2020e:	ee75 7ac7 	vsub.f32	s15, s11, s14
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20212:	d01a      	beq.n	2024a <SFXRhodesFrame+0x1c2>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20214:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   20218:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   2021c:	ee74 6a66 	vsub.f32	s13, s8, s13
   20220:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20224:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   20228:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2022c:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20230:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
   20234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20238:	f100 83e1 	bmi.w	209fe <SFXRhodesFrame+0x976>
			else rate += 1.0f;
   2023c:	ee36 6a25 	vadd.f32	s12, s12, s11
			FM_freqRatios[4][k-15] = rate;
   20240:	4a81      	ldr	r2, [pc, #516]	; (20448 <SFXRhodesFrame+0x3c0>)
			displayValues[k] = rate;
   20242:	ed84 6a0f 	vstr	s12, [r4, #60]	; 0x3c
			FM_freqRatios[4][k-15] = rate;
   20246:	ed82 6a18 	vstr	s12, [r2, #96]	; 0x60
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2024a:	4a80      	ldr	r2, [pc, #512]	; (2044c <SFXRhodesFrame+0x3c4>)
   2024c:	edd8 6a10 	vldr	s13, [r8, #64]	; 0x40
   20250:	edd2 4a00 	vldr	s9, [r2]
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   20254:	ed88 4a0f 	vstr	s8, [r8, #60]	; 0x3c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20258:	eef4 6a64 	vcmp.f32	s13, s9
   2025c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20260:	d01e      	beq.n	202a0 <SFXRhodesFrame+0x218>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20262:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   20266:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   2026a:	ee74 6ae6 	vsub.f32	s13, s9, s13
   2026e:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20272:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   20276:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2027a:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2027e:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20282:	eef0 6a46 	vmov.f32	s13, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20286:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2028a:	f100 83bf 	bmi.w	20a0c <SFXRhodesFrame+0x984>
			else rate += 1.0f;
   2028e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   20292:	ee36 6a86 	vadd.f32	s12, s13, s12
			FM_freqRatios[4][k-15] = rate;
   20296:	4a6c      	ldr	r2, [pc, #432]	; (20448 <SFXRhodesFrame+0x3c0>)
			displayValues[k] = rate;
   20298:	ed84 6a10 	vstr	s12, [r4, #64]	; 0x40
			FM_freqRatios[4][k-15] = rate;
   2029c:	ed82 6a19 	vstr	s12, [r2, #100]	; 0x64
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   202a0:	4a6b      	ldr	r2, [pc, #428]	; (20450 <SFXRhodesFrame+0x3c8>)
   202a2:	edd8 6a11 	vldr	s13, [r8, #68]	; 0x44
   202a6:	ed92 5a00 	vldr	s10, [r2]
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   202aa:	edc8 4a10 	vstr	s9, [r8, #64]	; 0x40
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   202ae:	eef4 6a45 	vcmp.f32	s13, s10
   202b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   202b6:	d01e      	beq.n	202f6 <SFXRhodesFrame+0x26e>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   202b8:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   202bc:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   202c0:	ee75 6a66 	vsub.f32	s13, s10, s13
   202c4:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   202c8:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   202cc:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   202d0:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   202d4:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   202d8:	eef0 6a46 	vmov.f32	s13, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   202dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   202e0:	f100 839d 	bmi.w	20a1e <SFXRhodesFrame+0x996>
			else rate += 1.0f;
   202e4:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   202e8:	ee36 6a86 	vadd.f32	s12, s13, s12
			FM_freqRatios[4][k-15] = rate;
   202ec:	4a56      	ldr	r2, [pc, #344]	; (20448 <SFXRhodesFrame+0x3c0>)
			displayValues[k] = rate;
   202ee:	ed84 6a11 	vstr	s12, [r4, #68]	; 0x44
			FM_freqRatios[4][k-15] = rate;
   202f2:	ed82 6a1a 	vstr	s12, [r2, #104]	; 0x68
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   202f6:	4a57      	ldr	r2, [pc, #348]	; (20454 <SFXRhodesFrame+0x3cc>)
   202f8:	edd8 6a12 	vldr	s13, [r8, #72]	; 0x48
   202fc:	edd2 5a00 	vldr	s11, [r2]
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   20300:	ed88 5a11 	vstr	s10, [r8, #68]	; 0x44
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   20304:	eef4 6a65 	vcmp.f32	s13, s11
   20308:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2030c:	d01e      	beq.n	2034c <SFXRhodesFrame+0x2c4>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2030e:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   20312:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
   20316:	ee75 6ae6 	vsub.f32	s13, s11, s13
   2031a:	ee66 6a86 	vmul.f32	s13, s13, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2031e:	ee27 6aa6 	vmul.f32	s12, s15, s13
			float snapRate = roundf(rawRate);
   20322:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20326:	eea7 6a26 	vfma.f32	s12, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2032a:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2032e:	eef0 6a46 	vmov.f32	s13, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20332:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20336:	f100 8342 	bmi.w	209be <SFXRhodesFrame+0x936>
			else rate += 1.0f;
   2033a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2033e:	ee36 6a86 	vadd.f32	s12, s13, s12
			FM_freqRatios[4][k-15] = rate;
   20342:	4a41      	ldr	r2, [pc, #260]	; (20448 <SFXRhodesFrame+0x3c0>)
			displayValues[k] = rate;
   20344:	ed84 6a12 	vstr	s12, [r4, #72]	; 0x48
			FM_freqRatios[4][k-15] = rate;
   20348:	ed82 6a1b 	vstr	s12, [r2, #108]	; 0x6c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2034c:	4a42      	ldr	r2, [pc, #264]	; (20458 <SFXRhodesFrame+0x3d0>)
   2034e:	edd8 6a13 	vldr	s13, [r8, #76]	; 0x4c
   20352:	ed92 6a00 	vldr	s12, [r2]
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   20356:	edc8 5a12 	vstr	s11, [r8, #72]	; 0x48
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   2035a:	eef4 6a46 	vcmp.f32	s13, s12
   2035e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20362:	d01e      	beq.n	203a2 <SFXRhodesFrame+0x31a>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20364:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   20368:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
   2036c:	ee76 6a66 	vsub.f32	s13, s12, s13
   20370:	ee66 6aa3 	vmul.f32	s13, s13, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20374:	ee67 3aa6 	vmul.f32	s7, s15, s13
			float snapRate = roundf(rawRate);
   20378:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2037c:	eee7 3a26 	vfma.f32	s7, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20380:	eef5 3ac0 	vcmpe.f32	s7, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20384:	eef0 6a63 	vmov.f32	s13, s7
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20388:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2038c:	f100 8320 	bmi.w	209d0 <SFXRhodesFrame+0x948>
			else rate += 1.0f;
   20390:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
   20394:	ee76 3aa3 	vadd.f32	s7, s13, s7
			FM_freqRatios[4][k-15] = rate;
   20398:	4a2b      	ldr	r2, [pc, #172]	; (20448 <SFXRhodesFrame+0x3c0>)
			displayValues[k] = rate;
   2039a:	edc4 3a13 	vstr	s7, [r4, #76]	; 0x4c
			FM_freqRatios[4][k-15] = rate;
   2039e:	edc2 3a1c 	vstr	s7, [r2, #112]	; 0x70
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   203a2:	4a2e      	ldr	r2, [pc, #184]	; (2045c <SFXRhodesFrame+0x3d4>)
   203a4:	edd8 3a14 	vldr	s7, [r8, #80]	; 0x50
   203a8:	edd2 6a00 	vldr	s13, [r2]
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   203ac:	ed88 6a13 	vstr	s12, [r8, #76]	; 0x4c
		if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
   203b0:	eef4 6a63 	vcmp.f32	s13, s7
   203b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   203b8:	d01c      	beq.n	203f4 <SFXRhodesFrame+0x36c>
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   203ba:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
   203be:	eeb2 3a0c 	vmov.f32	s6, #44	; 0x41600000  14.0
   203c2:	ee76 3ae3 	vsub.f32	s7, s13, s7
   203c6:	ee63 3a83 	vmul.f32	s7, s7, s6
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   203ca:	ee67 7aa3 	vmul.f32	s15, s15, s7
			float snapRate = roundf(rawRate);
   203ce:	fef8 3a63 	vrinta.f32	s7, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   203d2:	eee7 7a23 	vfma.f32	s15, s14, s7
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   203d6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   203da:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   203de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   203e2:	f100 82fe 	bmi.w	209e2 <SFXRhodesFrame+0x95a>
			else rate += 1.0f;
   203e6:	ee77 7a87 	vadd.f32	s15, s15, s14
			FM_freqRatios[4][k-15] = rate;
   203ea:	4a17      	ldr	r2, [pc, #92]	; (20448 <SFXRhodesFrame+0x3c0>)
			displayValues[k] = rate;
   203ec:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
			FM_freqRatios[4][k-15] = rate;
   203f0:	edc2 7a1d 	vstr	s15, [r2, #116]	; 0x74
	if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
   203f4:	4a1a      	ldr	r2, [pc, #104]	; (20460 <SFXRhodesFrame+0x3d8>)
   203f6:	edd8 7a16 	vldr	s15, [r8, #88]	; 0x58
   203fa:	ed92 7a00 	vldr	s14, [r2]
		prevKnobValues[k] = presetKnobValues[Rhodes][k];
   203fe:	edc8 6a14 	vstr	s13, [r8, #80]	; 0x50
	if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
   20402:	eeb4 7a67 	vcmp.f32	s14, s15
   20406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2040a:	f000 80e4 	beq.w	205d6 <SFXRhodesFrame+0x54e>
   2040e:	e02b      	b.n	20468 <SFXRhodesFrame+0x3e0>
   20410:	020fb31c 	.word	0x020fb31c
   20414:	00062ae4 	.word	0x00062ae4
   20418:	020e3118 	.word	0x020e3118
   2041c:	66666667 	.word	0x66666667
   20420:	020f99bc 	.word	0x020f99bc
   20424:	00062acc 	.word	0x00062acc
   20428:	020f9c84 	.word	0x020f9c84
   2042c:	447a0000 	.word	0x447a0000
   20430:	46000000 	.word	0x46000000
   20434:	3fa66666 	.word	0x3fa66666
   20438:	020fb3cc 	.word	0x020fb3cc
   2043c:	00062948 	.word	0x00062948
   20440:	00000000 	.word	0x00000000
   20444:	00062aec 	.word	0x00062aec
   20448:	000628d0 	.word	0x000628d0
   2044c:	020f99fc 	.word	0x020f99fc
   20450:	020f9a00 	.word	0x020f9a00
   20454:	020f9a04 	.word	0x020f9a04
   20458:	020f9a08 	.word	0x020f9a08
   2045c:	020f9a0c 	.word	0x020f9a0c
   20460:	020f9a14 	.word	0x020f9a14
   20464:	020fa310 	.word	0x020fa310
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20468:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
		overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
   2046c:	ed84 7a16 	vstr	s14, [r4, #88]	; 0x58
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20470:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
		overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
   20474:	ed83 7a00 	vstr	s14, [r3]
   20478:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2047c:	ee34 4a67 	vsub.f32	s8, s8, s15
   20480:	ee73 7a47 	vsub.f32	s15, s6, s14
   20484:	ee24 4a23 	vmul.f32	s8, s8, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20488:	ee64 3a27 	vmul.f32	s7, s8, s15
			float snapRate = roundf(rawRate);
   2048c:	feb8 4a44 	vrinta.f32	s8, s8
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20490:	eee7 3a04 	vfma.f32	s7, s14, s8
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20494:	eef5 3ac0 	vcmpe.f32	s7, #0.0
   20498:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2049c:	f100 82a8 	bmi.w	209f0 <SFXRhodesFrame+0x968>
			else rate += 1.0f;
   204a0:	ee33 4a83 	vadd.f32	s8, s7, s6
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204a4:	eeb6 3a00 	vmov.f32	s6, #96	; 0x3f000000  0.5
			FM_freqRatios[4][k-15] = rate;
   204a8:	4bc7      	ldr	r3, [pc, #796]	; (207c8 <SFXRhodesFrame+0x740>)
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204aa:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
			displayValues[k] = rate;
   204ae:	ed84 4a0f 	vstr	s8, [r4, #60]	; 0x3c
			FM_freqRatios[4][k-15] = rate;
   204b2:	ed83 4a18 	vstr	s8, [r3, #96]	; 0x60
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204b6:	ee74 4ac3 	vsub.f32	s9, s9, s6
   204ba:	ee64 4aa3 	vmul.f32	s9, s9, s7
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204be:	ee24 4aa7 	vmul.f32	s8, s9, s15
			float snapRate = roundf(rawRate);
   204c2:	fef8 4a64 	vrinta.f32	s9, s9
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204c6:	eea7 4a24 	vfma.f32	s8, s14, s9
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   204ca:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204ce:	eef0 4a44 	vmov.f32	s9, s8
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   204d2:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
   204d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   204da:	f100 82c5 	bmi.w	20a68 <SFXRhodesFrame+0x9e0>
			else rate += 1.0f;
   204de:	ee74 4a84 	vadd.f32	s9, s9, s8
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204e2:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   204e6:	edc4 4a10 	vstr	s9, [r4, #64]	; 0x40
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204ea:	eeb2 4a0c 	vmov.f32	s8, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   204ee:	edc3 4a19 	vstr	s9, [r3, #100]	; 0x64
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   204f2:	ee35 5a63 	vsub.f32	s10, s10, s7
   204f6:	ee25 5a04 	vmul.f32	s10, s10, s8
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   204fa:	ee65 4a27 	vmul.f32	s9, s10, s15
			float snapRate = roundf(rawRate);
   204fe:	feb8 5a45 	vrinta.f32	s10, s10
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20502:	eee7 4a05 	vfma.f32	s9, s14, s10
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20506:	eef5 4ac0 	vcmpe.f32	s9, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2050a:	eeb0 5a64 	vmov.f32	s10, s9
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2050e:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
   20512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20516:	f100 82a0 	bmi.w	20a5a <SFXRhodesFrame+0x9d2>
			else rate += 1.0f;
   2051a:	ee35 5a24 	vadd.f32	s10, s10, s9
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2051e:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   20522:	ed84 5a11 	vstr	s10, [r4, #68]	; 0x44
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20526:	eef2 4a0c 	vmov.f32	s9, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   2052a:	ed83 5a1a 	vstr	s10, [r3, #104]	; 0x68
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2052e:	ee75 5ac4 	vsub.f32	s11, s11, s8
   20532:	ee65 5aa4 	vmul.f32	s11, s11, s9
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20536:	ee25 5aa7 	vmul.f32	s10, s11, s15
			float snapRate = roundf(rawRate);
   2053a:	fef8 5a65 	vrinta.f32	s11, s11
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2053e:	eea7 5a25 	vfma.f32	s10, s14, s11
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20542:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20546:	eef0 5a45 	vmov.f32	s11, s10
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2054a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   2054e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20552:	f100 827b 	bmi.w	20a4c <SFXRhodesFrame+0x9c4>
			else rate += 1.0f;
   20556:	ee75 5a85 	vadd.f32	s11, s11, s10
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2055a:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   2055e:	edc4 5a12 	vstr	s11, [r4, #72]	; 0x48
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20562:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   20566:	edc3 5a1b 	vstr	s11, [r3, #108]	; 0x6c
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2056a:	ee36 6a64 	vsub.f32	s12, s12, s9
   2056e:	ee26 6a05 	vmul.f32	s12, s12, s10
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20572:	ee66 5a27 	vmul.f32	s11, s12, s15
			float snapRate = roundf(rawRate);
   20576:	feb8 6a46 	vrinta.f32	s12, s12
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   2057a:	eee7 5a06 	vfma.f32	s11, s14, s12
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   2057e:	eef5 5ac0 	vcmpe.f32	s11, #0.0
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   20582:	eeb0 6a65 	vmov.f32	s12, s11
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20586:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   2058a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2058e:	f100 8256 	bmi.w	20a3e <SFXRhodesFrame+0x9b6>
			else rate += 1.0f;
   20592:	ee36 6a25 	vadd.f32	s12, s12, s11
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   20596:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
			displayValues[k] = rate;
   2059a:	ed84 6a13 	vstr	s12, [r4, #76]	; 0x4c
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   2059e:	eef2 5a0c 	vmov.f32	s11, #44	; 0x41600000  14.0
			FM_freqRatios[4][k-15] = rate;
   205a2:	ed83 6a1c 	vstr	s12, [r3, #112]	; 0x70
			float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
   205a6:	ee76 6ac5 	vsub.f32	s13, s13, s10
   205aa:	ee66 6aa5 	vmul.f32	s13, s13, s11
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   205ae:	ee66 7aa7 	vmul.f32	s15, s13, s15
			float snapRate = roundf(rawRate);
   205b2:	fef8 6a66 	vrinta.f32	s13, s13
			float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
   205b6:	eee7 7a26 	vfma.f32	s15, s14, s13
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   205ba:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   205be:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   205c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   205c6:	f100 8233 	bmi.w	20a30 <SFXRhodesFrame+0x9a8>
			else rate += 1.0f;
   205ca:	ee77 7aa6 	vadd.f32	s15, s15, s13
			displayValues[k] = rate;
   205ce:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
			FM_freqRatios[4][k-15] = rate;
   205d2:	edc3 7a1d 	vstr	s15, [r3, #116]	; 0x74
	displayValues[23] = presetKnobValues[Rhodes][23];
   205d6:	4b7d      	ldr	r3, [pc, #500]	; (207cc <SFXRhodesFrame+0x744>)
	prevKnobValues[22] = presetKnobValues[Rhodes][22];
   205d8:	ed88 7a16 	vstr	s14, [r8, #88]	; 0x58
	displayValues[23] = presetKnobValues[Rhodes][23];
   205dc:	edd3 7a00 	vldr	s15, [r3]
	if (prevDisplayValues[23] != displayValues[23])
   205e0:	4b7b      	ldr	r3, [pc, #492]	; (207d0 <SFXRhodesFrame+0x748>)
	displayValues[23] = presetKnobValues[Rhodes][23];
   205e2:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
	if (prevDisplayValues[23] != displayValues[23])
   205e6:	edd3 6a17 	vldr	s13, [r3, #92]	; 0x5c
   205ea:	eef4 7a66 	vcmp.f32	s15, s13
   205ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   205f2:	d03a      	beq.n	2066a <SFXRhodesFrame+0x5e2>
   205f4:	f8df 9210 	ldr.w	r9, [pc, #528]	; 20808 <SFXRhodesFrame+0x780>
			randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   205f8:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
   205fc:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   20600:	ed9f 8a74 	vldr	s16, [pc, #464]	; 207d4 <SFXRhodesFrame+0x74c>
   20604:	f109 0518 	add.w	r5, r9, #24
	if (prevDisplayValues[23] != displayValues[23])
   20608:	464e      	mov	r6, r9
			float randomNumberDraw = (randomNumber() * 2.0f) + 0.08f;
   2060a:	f7f8 fec3 	bl	19394 <randomNumber>
			randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
   2060e:	eeb0 7a48 	vmov.f32	s14, s16
   20612:	eef0 6a68 	vmov.f32	s13, s17
   20616:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
   2061a:	eea0 7a09 	vfma.f32	s14, s0, s18
   2061e:	eee7 6a27 	vfma.f32	s13, s14, s15
   20622:	ece6 6a01 	vstmia	r6!, {s13}
		for (int i = 0; i < 6; i++)
   20626:	42ae      	cmp	r6, r5
   20628:	d1ef      	bne.n	2060a <SFXRhodesFrame+0x582>
   2062a:	4f6b      	ldr	r7, [pc, #428]	; (207d8 <SFXRhodesFrame+0x750>)
				tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
   2062c:	ed9f 8a6b 	vldr	s16, [pc, #428]	; 207dc <SFXRhodesFrame+0x754>
   20630:	f107 0ac0 	add.w	sl, r7, #192	; 0xc0
	if (prevDisplayValues[23] != displayValues[23])
   20634:	46bb      	mov	fp, r7
   20636:	464d      	mov	r5, r9
				tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
   20638:	ecf5 0a01 	vldmia	r5!, {s1}
   2063c:	eeb0 1a48 	vmov.f32	s2, s16
   20640:	edd4 7a06 	vldr	s15, [r4, #24]
   20644:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   20648:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2064c:	f009 f91c 	bl	29888 <LEAF_clip>
   20650:	4658      	mov	r0, fp
   20652:	f007 f8fd 	bl	27850 <tADSR4_setDecay>
			for (int j = 0; j < 6; j++)
   20656:	42b5      	cmp	r5, r6
   20658:	f10b 0b04 	add.w	fp, fp, #4
   2065c:	d1ec      	bne.n	20638 <SFXRhodesFrame+0x5b0>
   2065e:	3718      	adds	r7, #24
		for (int i = 0; i < NUM_VOC_VOICES; i++)
   20660:	4557      	cmp	r7, sl
   20662:	d1e7      	bne.n	20634 <SFXRhodesFrame+0x5ac>
   20664:	4b59      	ldr	r3, [pc, #356]	; (207cc <SFXRhodesFrame+0x744>)
   20666:	edd3 6a00 	vldr	s13, [r3]
	displayValues[24] = presetKnobValues[Rhodes][24];
   2066a:	4b5d      	ldr	r3, [pc, #372]	; (207e0 <SFXRhodesFrame+0x758>)
	if (prevDisplayValues[24] != displayValues[24])
   2066c:	4a58      	ldr	r2, [pc, #352]	; (207d0 <SFXRhodesFrame+0x748>)
	displayValues[24] = presetKnobValues[Rhodes][24];
   2066e:	ed93 7a00 	vldr	s14, [r3]
	if (prevDisplayValues[24] != displayValues[24])
   20672:	edd2 7a18 	vldr	s15, [r2, #96]	; 0x60
	prevKnobValues[23] = presetKnobValues[Rhodes][23];
   20676:	edc8 6a17 	vstr	s13, [r8, #92]	; 0x5c
	if (prevDisplayValues[24] != displayValues[24])
   2067a:	eeb4 7a67 	vcmp.f32	s14, s15
	displayValues[24] = presetKnobValues[Rhodes][24];
   2067e:	ed84 7a18 	vstr	s14, [r4, #96]	; 0x60
	if (prevDisplayValues[24] != displayValues[24])
   20682:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20686:	d023      	beq.n	206d0 <SFXRhodesFrame+0x648>
   20688:	4d56      	ldr	r5, [pc, #344]	; (207e4 <SFXRhodesFrame+0x75c>)
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   2068a:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
   2068e:	eeff 8a00 	vmov.f32	s17, #240	; 0xbf800000 -1.0
   20692:	4e55      	ldr	r6, [pc, #340]	; (207e8 <SFXRhodesFrame+0x760>)
   20694:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   20698:	f105 0718 	add.w	r7, r5, #24
			float randomNumberDraw = randomNumber() * 2.0f;
   2069c:	f7f8 fe7a 	bl	19394 <randomNumber>
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   206a0:	eeb0 7a68 	vmov.f32	s14, s17
   206a4:	eef0 6a48 	vmov.f32	s13, s16
   206a8:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
			tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   206ac:	4630      	mov	r0, r6
   206ae:	3604      	adds	r6, #4
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   206b0:	eea0 7a09 	vfma.f32	s14, s0, s18
			tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   206b4:	ed94 0a07 	vldr	s0, [r4, #28]
			randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
   206b8:	eee7 6a27 	vfma.f32	s13, s14, s15
   206bc:	ece5 6a01 	vstmia	r5!, {s13}
			tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   206c0:	ee26 0a80 	vmul.f32	s0, s13, s0
   206c4:	f007 fc4c 	bl	27f60 <tExpSmooth_setDest>
		for (int i = 0; i < 6; i++)
   206c8:	42bd      	cmp	r5, r7
   206ca:	d1e7      	bne.n	2069c <SFXRhodesFrame+0x614>
   206cc:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
	prevDisplayValues[24] = displayValues[24];
   206d0:	4b3f      	ldr	r3, [pc, #252]	; (207d0 <SFXRhodesFrame+0x748>)
   206d2:	f04f 0906 	mov.w	r9, #6
   206d6:	4e45      	ldr	r6, [pc, #276]	; (207ec <SFXRhodesFrame+0x764>)
   206d8:	edc3 7a18 	vstr	s15, [r3, #96]	; 0x60
   206dc:	f103 0814 	add.w	r8, r3, #20
							tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   206e0:	ed9f 8a3e 	vldr	s16, [pc, #248]	; 207dc <SFXRhodesFrame+0x754>
   206e4:	4b42      	ldr	r3, [pc, #264]	; (207f0 <SFXRhodesFrame+0x768>)
   206e6:	9300      	str	r3, [sp, #0]
		if (prevDisplayValues[k] != displayValues[k])
   206e8:	ecf3 7a01 	vldmia	r3!, {s15}
   206ec:	ecb8 7a01 	vldmia	r8!, {s14}
   206f0:	9300      	str	r3, [sp, #0]
   206f2:	eeb4 7a67 	vcmp.f32	s14, s15
   206f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   206fa:	d02d      	beq.n	20758 <SFXRhodesFrame+0x6d0>
			switch(k)
   206fc:	f1a9 0307 	sub.w	r3, r9, #7
   20700:	2b03      	cmp	r3, #3
   20702:	d805      	bhi.n	20710 <SFXRhodesFrame+0x688>
   20704:	e8df f013 	tbh	[pc, r3, lsl #1]
   20708:	00fd0113 	.word	0x00fd0113
   2070c:	003100e8 	.word	0x003100e8
   20710:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 207d8 <SFXRhodesFrame+0x750>
							uint64_t tempCount1 = DWT->CYCCNT;
   20714:	4d37      	ldr	r5, [pc, #220]	; (207f4 <SFXRhodesFrame+0x76c>)
   20716:	f10b 0718 	add.w	r7, fp, #24
							cycleCountVals[1][2] = 0;
   2071a:	2200      	movs	r2, #0
   2071c:	2300      	movs	r3, #0
							tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
   2071e:	4658      	mov	r0, fp
   20720:	ed94 0a05 	vldr	s0, [r4, #20]
   20724:	f10b 0b04 	add.w	fp, fp, #4
							cycleCountVals[1][2] = 0;
   20728:	e9c6 230a 	strd	r2, r3, [r6, #40]	; 0x28
							uint64_t tempCount1 = DWT->CYCCNT;
   2072c:	f8d5 a004 	ldr.w	sl, [r5, #4]
							tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
   20730:	f007 f880 	bl	27834 <tADSR4_setAttack>
							uint64_t tempCount2 = DWT->CYCCNT;
   20734:	686a      	ldr	r2, [r5, #4]
							CycleCounterTrackMinAndMax(1);
   20736:	2001      	movs	r0, #1
							cycleCountVals[1][1] = tempCount2-tempCount1;
   20738:	ebb2 020a 	subs.w	r2, r2, sl
   2073c:	eb62 0302 	sbc.w	r3, r2, r2
   20740:	e9c6 2308 	strd	r2, r3, [r6, #32]
							CycleCounterTrackMinAndMax(1);
   20744:	f7f8 fe64 	bl	19410 <CycleCounterTrackMinAndMax>
						for (int j = 0; j < 6; j++)
   20748:	455f      	cmp	r7, fp
   2074a:	d1e6      	bne.n	2071a <SFXRhodesFrame+0x692>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   2074c:	4b2a      	ldr	r3, [pc, #168]	; (207f8 <SFXRhodesFrame+0x770>)
   2074e:	429f      	cmp	r7, r3
   20750:	d1e1      	bne.n	20716 <SFXRhodesFrame+0x68e>
   20752:	9b00      	ldr	r3, [sp, #0]
   20754:	ed53 7a01 	vldr	s15, [r3, #-4]
	for (int k = 5; k < 10; k++)
   20758:	f1b9 0f0a 	cmp.w	r9, #10
		prevDisplayValues[k] = displayValues[k];
   2075c:	ed48 7a01 	vstr	s15, [r8, #-4]
	for (int k = 5; k < 10; k++)
   20760:	d021      	beq.n	207a6 <SFXRhodesFrame+0x71e>
   20762:	f109 0901 	add.w	r9, r9, #1
   20766:	9b00      	ldr	r3, [sp, #0]
   20768:	e7be      	b.n	206e8 <SFXRhodesFrame+0x660>
   2076a:	4d1b      	ldr	r5, [pc, #108]	; (207d8 <SFXRhodesFrame+0x750>)
							tADSR4_setLeakFactor(&FM_envs[i][j], ((1.0f - displayValues[9])  * 0.00004f) + 0.99996f);
   2076c:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   20770:	eddf 8a22 	vldr	s17, [pc, #136]	; 207fc <SFXRhodesFrame+0x774>
   20774:	f105 07c0 	add.w	r7, r5, #192	; 0xc0
   20778:	ed9f 8a21 	vldr	s16, [pc, #132]	; 20800 <SFXRhodesFrame+0x778>
   2077c:	f105 0618 	add.w	r6, r5, #24
   20780:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   20784:	eeb0 0a48 	vmov.f32	s0, s16
   20788:	4628      	mov	r0, r5
   2078a:	3504      	adds	r5, #4
   2078c:	ee79 7a67 	vsub.f32	s15, s18, s15
   20790:	eea7 0aa8 	vfma.f32	s0, s15, s17
   20794:	f007 f88e 	bl	278b4 <tADSR4_setLeakFactor>
						for (int j = 0; j < 6; j++)
   20798:	42b5      	cmp	r5, r6
   2079a:	d1f1      	bne.n	20780 <SFXRhodesFrame+0x6f8>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   2079c:	42bd      	cmp	r5, r7
   2079e:	d1ed      	bne.n	2077c <SFXRhodesFrame+0x6f4>
		prevDisplayValues[k] = displayValues[k];
   207a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   207a2:	4a0b      	ldr	r2, [pc, #44]	; (207d0 <SFXRhodesFrame+0x748>)
   207a4:	6253      	str	r3, [r2, #36]	; 0x24
	for (int i = 0; i < numVoices; i++)
   207a6:	9b01      	ldr	r3, [sp, #4]
   207a8:	781b      	ldrb	r3, [r3, #0]
   207aa:	2b00      	cmp	r3, #0
   207ac:	f000 808a 	beq.w	208c4 <SFXRhodesFrame+0x83c>
   207b0:	f8df b058 	ldr.w	fp, [pc, #88]	; 2080c <SFXRhodesFrame+0x784>
   207b4:	2500      	movs	r5, #0
   207b6:	4f13      	ldr	r7, [pc, #76]	; (20804 <SFXRhodesFrame+0x77c>)
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   207b8:	465e      	mov	r6, fp
   207ba:	f8df a054 	ldr.w	sl, [pc, #84]	; 20810 <SFXRhodesFrame+0x788>
   207be:	f8df 9054 	ldr.w	r9, [pc, #84]	; 20814 <SFXRhodesFrame+0x78c>
				if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   207c2:	46b8      	mov	r8, r7
   207c4:	e02b      	b.n	2081e <SFXRhodesFrame+0x796>
   207c6:	bf00      	nop
   207c8:	000628d0 	.word	0x000628d0
   207cc:	020f9a18 	.word	0x020f9a18
   207d0:	020f9bfc 	.word	0x020f9bfc
   207d4:	bf6b851f 	.word	0xbf6b851f
   207d8:	020fa164 	.word	0x020fa164
   207dc:	469c4000 	.word	0x469c4000
   207e0:	020f9a1c 	.word	0x020f9a1c
   207e4:	00062b20 	.word	0x00062b20
   207e8:	020f9038 	.word	0x020f9038
   207ec:	020f8198 	.word	0x020f8198
   207f0:	020fb3e0 	.word	0x020fb3e0
   207f4:	e0001000 	.word	0xe0001000
   207f8:	020fa224 	.word	0x020fa224
   207fc:	3827c5ac 	.word	0x3827c5ac
   20800:	3f7ffd61 	.word	0x3f7ffd61
   20804:	020f9a44 	.word	0x020f9a44
   20808:	00062b08 	.word	0x00062b08
   2080c:	020fa15c 	.word	0x020fa15c
   20810:	020e31e0 	.word	0x020e31e0
   20814:	020e3224 	.word	0x020e3224
	for (int i = 0; i < numVoices; i++)
   20818:	3501      	adds	r5, #1
   2081a:	42ab      	cmp	r3, r5
   2081c:	dd52      	ble.n	208c4 <SFXRhodesFrame+0x83c>
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   2081e:	b2ef      	uxtb	r7, r5
   20820:	4630      	mov	r0, r6
   20822:	4639      	mov	r1, r7
   20824:	f009 feb4 	bl	2a590 <tSimplePoly_getPitch>
   20828:	ee07 0a90 	vmov	s15, r0
   2082c:	ed9a 0a00 	vldr	s0, [sl]
   20830:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20834:	4b90      	ldr	r3, [pc, #576]	; (20a78 <SFXRhodesFrame+0x9f0>)
   20836:	4a91      	ldr	r2, [pc, #580]	; (20a7c <SFXRhodesFrame+0x9f4>)
   20838:	7819      	ldrb	r1, [r3, #0]
	float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
   2083a:	ee37 7a00 	vadd.f32	s14, s14, s0
	float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   2083e:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   20842:	ee17 3a90 	vmov	r3, s15
   20846:	1a5b      	subs	r3, r3, r1
   20848:	fb82 2003 	smull	r2, r0, r2, r3
   2084c:	17d9      	asrs	r1, r3, #31
   2084e:	ebc1 0160 	rsb	r1, r1, r0, asr #1
   20852:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   20856:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
   2085a:	ee07 3a90 	vmov	s15, r3
   2085e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   20862:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   20866:	ee17 3a90 	vmov	r3, s15
   2086a:	eb09 0383 	add.w	r3, r9, r3, lsl #2
   2086e:	ed93 0a00 	vldr	s0, [r3]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   20872:	ee37 0a00 	vadd.f32	s0, s14, s0
   20876:	f009 f8f1 	bl	29a5c <LEAF_midiToFrequency>
		if (numVoices > 1)
   2087a:	9b01      	ldr	r3, [sp, #4]
	freq[voice] = LEAF_midiToFrequency(tunedNote);
   2087c:	eca8 0a01 	vstmia	r8!, {s0}
		if (numVoices > 1)
   20880:	781b      	ldrb	r3, [r3, #0]
   20882:	2b01      	cmp	r3, #1
   20884:	d9c8      	bls.n	20818 <SFXRhodesFrame+0x790>
			if (poly->voices[i][0] == -2)
   20886:	f8db 1000 	ldr.w	r1, [fp]
   2088a:	6909      	ldr	r1, [r1, #16]
   2088c:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
   20890:	6809      	ldr	r1, [r1, #0]
   20892:	3102      	adds	r1, #2
   20894:	d1c0      	bne.n	20818 <SFXRhodesFrame+0x790>
   20896:	eb05 0145 	add.w	r1, r5, r5, lsl #1
				if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
   2089a:	4a79      	ldr	r2, [pc, #484]	; (20a80 <SFXRhodesFrame+0x9f8>)
   2089c:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
   208a0:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   208a4:	6a80      	ldr	r0, [r0, #40]	; 0x28
   208a6:	2800      	cmp	r0, #0
   208a8:	d1b6      	bne.n	20818 <SFXRhodesFrame+0x790>
   208aa:	6889      	ldr	r1, [r1, #8]
   208ac:	6a89      	ldr	r1, [r1, #40]	; 0x28
   208ae:	2900      	cmp	r1, #0
   208b0:	d1b2      	bne.n	20818 <SFXRhodesFrame+0x790>
					tSimplePoly_deactivateVoice(&poly, i);
   208b2:	4639      	mov	r1, r7
   208b4:	4630      	mov	r0, r6
   208b6:	f009 fd91 	bl	2a3dc <tSimplePoly_deactivateVoice>
   208ba:	9b01      	ldr	r3, [sp, #4]
	for (int i = 0; i < numVoices; i++)
   208bc:	3501      	adds	r5, #1
   208be:	781b      	ldrb	r3, [r3, #0]
   208c0:	42ab      	cmp	r3, r5
   208c2:	dcac      	bgt.n	2081e <SFXRhodesFrame+0x796>
	tCycle_setFreq(&tremolo, displayValues[2]);
   208c4:	ed94 0a02 	vldr	s0, [r4, #8]
   208c8:	486e      	ldr	r0, [pc, #440]	; (20a84 <SFXRhodesFrame+0x9fc>)
}
   208ca:	b003      	add	sp, #12
   208cc:	ecbd 8b04 	vpop	{d8-d9}
   208d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tCycle_setFreq(&tremolo, displayValues[2]);
   208d4:	f009 be8a 	b.w	2a5ec <tCycle_setFreq>
   208d8:	4d69      	ldr	r5, [pc, #420]	; (20a80 <SFXRhodesFrame+0x9f8>)
   208da:	f105 0ac0 	add.w	sl, r5, #192	; 0xc0
   208de:	f105 0718 	add.w	r7, r5, #24
							tADSR4_setRelease(&FM_envs[i][j], displayValues[8]);
   208e2:	4628      	mov	r0, r5
   208e4:	3504      	adds	r5, #4
   208e6:	ed94 0a08 	vldr	s0, [r4, #32]
   208ea:	f006 ffd5 	bl	27898 <tADSR4_setRelease>
						for (int j = 0; j < 6; j++)
   208ee:	42af      	cmp	r7, r5
   208f0:	d1f7      	bne.n	208e2 <SFXRhodesFrame+0x85a>
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   208f2:	45aa      	cmp	sl, r5
   208f4:	d1f3      	bne.n	208de <SFXRhodesFrame+0x856>
		prevDisplayValues[k] = displayValues[k];
   208f6:	9b00      	ldr	r3, [sp, #0]
   208f8:	f853 3c04 	ldr.w	r3, [r3, #-4]
   208fc:	f848 3c04 	str.w	r3, [r8, #-4]
   20900:	e72f      	b.n	20762 <SFXRhodesFrame+0x6da>
   20902:	4d61      	ldr	r5, [pc, #388]	; (20a88 <SFXRhodesFrame+0xa00>)
   20904:	4f61      	ldr	r7, [pc, #388]	; (20a8c <SFXRhodesFrame+0xa04>)
   20906:	f105 0a18 	add.w	sl, r5, #24
						tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
   2090a:	ecb5 0a01 	vldmia	r5!, {s0}
   2090e:	4638      	mov	r0, r7
   20910:	edd4 7a07 	vldr	s15, [r4, #28]
   20914:	3704      	adds	r7, #4
   20916:	ee20 0a27 	vmul.f32	s0, s0, s15
   2091a:	f007 fb21 	bl	27f60 <tExpSmooth_setDest>
					for (int i = 0; i < 6; i++)
   2091e:	45aa      	cmp	sl, r5
   20920:	d1f3      	bne.n	2090a <SFXRhodesFrame+0x882>
		prevDisplayValues[k] = displayValues[k];
   20922:	9b00      	ldr	r3, [sp, #0]
   20924:	f853 3c04 	ldr.w	r3, [r3, #-4]
   20928:	f848 3c04 	str.w	r3, [r8, #-4]
   2092c:	e719      	b.n	20762 <SFXRhodesFrame+0x6da>
   2092e:	4f58      	ldr	r7, [pc, #352]	; (20a90 <SFXRhodesFrame+0xa08>)
   20930:	f8df a14c 	ldr.w	sl, [pc, #332]	; 20a80 <SFXRhodesFrame+0x9f8>
   20934:	46bb      	mov	fp, r7
   20936:	4f57      	ldr	r7, [pc, #348]	; (20a94 <SFXRhodesFrame+0xa0c>)
	prevDisplayValues[24] = displayValues[24];
   20938:	4655      	mov	r5, sl
							tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
   2093a:	ecf7 0a01 	vldmia	r7!, {s1}
   2093e:	eeb0 1a48 	vmov.f32	s2, s16
   20942:	edd4 7a06 	vldr	s15, [r4, #24]
   20946:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
   2094a:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2094e:	f008 ff9b 	bl	29888 <LEAF_clip>
   20952:	4628      	mov	r0, r5
   20954:	f006 ff7c 	bl	27850 <tADSR4_setDecay>
						for (int j = 0; j < 6; j++)
   20958:	45bb      	cmp	fp, r7
   2095a:	f105 0504 	add.w	r5, r5, #4
   2095e:	d1ec      	bne.n	2093a <SFXRhodesFrame+0x8b2>
   20960:	f10a 0a18 	add.w	sl, sl, #24
					for (int i = 0; i < NUM_VOC_VOICES; i++)
   20964:	4b4c      	ldr	r3, [pc, #304]	; (20a98 <SFXRhodesFrame+0xa10>)
   20966:	4553      	cmp	r3, sl
   20968:	d1e5      	bne.n	20936 <SFXRhodesFrame+0x8ae>
		prevDisplayValues[k] = displayValues[k];
   2096a:	9b00      	ldr	r3, [sp, #0]
   2096c:	f853 3c04 	ldr.w	r3, [r3, #-4]
   20970:	f848 3c04 	str.w	r3, [r8, #-4]
   20974:	e6f5      	b.n	20762 <SFXRhodesFrame+0x6da>
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   20976:	4d49      	ldr	r5, [pc, #292]	; (20a9c <SFXRhodesFrame+0xa14>)
		tSimplePoly_setNumVoices(&poly, numVoices);
   20978:	4849      	ldr	r0, [pc, #292]	; (20aa0 <SFXRhodesFrame+0xa18>)
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   2097a:	782a      	ldrb	r2, [r5, #0]
   2097c:	9501      	str	r5, [sp, #4]
   2097e:	2a01      	cmp	r2, #1
   20980:	bf98      	it	ls
   20982:	2308      	movls	r3, #8
		tSimplePoly_setNumVoices(&poly, numVoices);
   20984:	4619      	mov	r1, r3
		numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
   20986:	702b      	strb	r3, [r5, #0]
		tSimplePoly_setNumVoices(&poly, numVoices);
   20988:	f009 fdde 	bl	2a548 <tSimplePoly_setNumVoices>
		setLED_A(numVoices == 1);
   2098c:	7828      	ldrb	r0, [r5, #0]
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   2098e:	2300      	movs	r3, #0
		setLED_A(numVoices == 1);
   20990:	f1a0 0001 	sub.w	r0, r0, #1
		buttonActionsSFX[ButtonA][ActionPress] = 0;
   20994:	7523      	strb	r3, [r4, #20]
		setLED_A(numVoices == 1);
   20996:	fab0 f080 	clz	r0, r0
   2099a:	0940      	lsrs	r0, r0, #5
   2099c:	f7f8 fdce 	bl	1953c <setLED_A>
   209a0:	f7ff bb7e 	b.w	200a0 <SFXRhodesFrame+0x18>
		tremoloStereo = !tremoloStereo;
   209a4:	4a3f      	ldr	r2, [pc, #252]	; (20aa4 <SFXRhodesFrame+0xa1c>)
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   209a6:	2100      	movs	r1, #0
		tremoloStereo = !tremoloStereo;
   209a8:	7813      	ldrb	r3, [r2, #0]
		buttonActionsSFX[ButtonC][ActionPress] = 0;
   209aa:	7721      	strb	r1, [r4, #28]
		tremoloStereo = !tremoloStereo;
   209ac:	fab3 f383 	clz	r3, r3
   209b0:	095b      	lsrs	r3, r3, #5
		setLED_C(tremoloStereo == 1);
   209b2:	4618      	mov	r0, r3
		tremoloStereo = !tremoloStereo;
   209b4:	7013      	strb	r3, [r2, #0]
		setLED_C(tremoloStereo == 1);
   209b6:	f7f8 fddd 	bl	19574 <setLED_C>
   209ba:	f7ff bb87 	b.w	200cc <SFXRhodesFrame+0x44>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   209be:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
   209c2:	ee76 6a63 	vsub.f32	s13, s12, s7
   209c6:	eef0 6ae6 	vabs.f32	s13, s13
   209ca:	ee83 6aa6 	vdiv.f32	s12, s7, s13
   209ce:	e4b8      	b.n	20342 <SFXRhodesFrame+0x2ba>
   209d0:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
   209d4:	ee73 6ac3 	vsub.f32	s13, s7, s6
   209d8:	eef0 6ae6 	vabs.f32	s13, s13
   209dc:	eec3 3a26 	vdiv.f32	s7, s6, s13
   209e0:	e4da      	b.n	20398 <SFXRhodesFrame+0x310>
   209e2:	ee77 7ac7 	vsub.f32	s15, s15, s14
   209e6:	eef0 3ae7 	vabs.f32	s7, s15
   209ea:	eec7 7a23 	vdiv.f32	s15, s14, s7
   209ee:	e4fc      	b.n	203ea <SFXRhodesFrame+0x362>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   209f0:	ee33 4ac3 	vsub.f32	s8, s7, s6
   209f4:	eef0 3ac4 	vabs.f32	s7, s8
   209f8:	ee83 4a23 	vdiv.f32	s8, s6, s7
   209fc:	e552      	b.n	204a4 <SFXRhodesFrame+0x41c>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   209fe:	ee76 6a65 	vsub.f32	s13, s12, s11
   20a02:	eef0 6ae6 	vabs.f32	s13, s13
   20a06:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   20a0a:	e419      	b.n	20240 <SFXRhodesFrame+0x1b8>
   20a0c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   20a10:	ee76 6a65 	vsub.f32	s13, s12, s11
   20a14:	eef0 6ae6 	vabs.f32	s13, s13
   20a18:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   20a1c:	e43b      	b.n	20296 <SFXRhodesFrame+0x20e>
   20a1e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   20a22:	ee76 6a65 	vsub.f32	s13, s12, s11
   20a26:	eef0 6ae6 	vabs.f32	s13, s13
   20a2a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   20a2e:	e45d      	b.n	202ec <SFXRhodesFrame+0x264>
			if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
   20a30:	ee77 7ae6 	vsub.f32	s15, s15, s13
   20a34:	eeb0 6ae7 	vabs.f32	s12, s15
   20a38:	eec6 7a86 	vdiv.f32	s15, s13, s12
   20a3c:	e5c7      	b.n	205ce <SFXRhodesFrame+0x546>
   20a3e:	ee36 6a65 	vsub.f32	s12, s12, s11
   20a42:	eeb0 5ac6 	vabs.f32	s10, s12
   20a46:	ee85 6a85 	vdiv.f32	s12, s11, s10
   20a4a:	e5a4      	b.n	20596 <SFXRhodesFrame+0x50e>
   20a4c:	ee75 5ac5 	vsub.f32	s11, s11, s10
   20a50:	eef0 4ae5 	vabs.f32	s9, s11
   20a54:	eec5 5a24 	vdiv.f32	s11, s10, s9
   20a58:	e57f      	b.n	2055a <SFXRhodesFrame+0x4d2>
   20a5a:	ee35 5a64 	vsub.f32	s10, s10, s9
   20a5e:	eeb0 4ac5 	vabs.f32	s8, s10
   20a62:	ee84 5a84 	vdiv.f32	s10, s9, s8
   20a66:	e55a      	b.n	2051e <SFXRhodesFrame+0x496>
   20a68:	ee74 4ac4 	vsub.f32	s9, s9, s8
   20a6c:	eef0 3ae4 	vabs.f32	s7, s9
   20a70:	eec4 4a23 	vdiv.f32	s9, s8, s7
   20a74:	e535      	b.n	204e2 <SFXRhodesFrame+0x45a>
   20a76:	bf00      	nop
   20a78:	020e3258 	.word	0x020e3258
   20a7c:	2aaaaaab 	.word	0x2aaaaaab
   20a80:	020fa164 	.word	0x020fa164
   20a84:	020fa3a8 	.word	0x020fa3a8
   20a88:	00062b20 	.word	0x00062b20
   20a8c:	020f9038 	.word	0x020f9038
   20a90:	00062b20 	.word	0x00062b20
   20a94:	00062b08 	.word	0x00062b08
   20a98:	020fa224 	.word	0x020fa224
   20a9c:	00062ae4 	.word	0x00062ae4
   20aa0:	020fa15c 	.word	0x020fa15c
   20aa4:	020e3214 	.word	0x020e3214

00020aa8 <SFXRhodesTick>:
{
   20aa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20aac:	f8df 8364 	ldr.w	r8, [pc, #868]	; 20e14 <SFXRhodesTick+0x36c>
   20ab0:	4cc8      	ldr	r4, [pc, #800]	; (20dd4 <SFXRhodesTick+0x32c>)
   20ab2:	f108 0518 	add.w	r5, r8, #24
   20ab6:	4646      	mov	r6, r8
   20ab8:	ed2d 8b08 	vpush	{d8-d11}
   20abc:	b08d      	sub	sp, #52	; 0x34
   20abe:	900b      	str	r0, [sp, #44]	; 0x2c
		sustainsFinal[i] = tExpSmooth_tick(&susSmoothers[i]);
   20ac0:	4620      	mov	r0, r4
   20ac2:	3404      	adds	r4, #4
   20ac4:	f007 fa56 	bl	27f74 <tExpSmooth_tick>
   20ac8:	eca6 0a01 	vstmia	r6!, {s0}
	for (int i = 0; i < 6; i++)
   20acc:	42ae      	cmp	r6, r5
   20ace:	d1f7      	bne.n	20ac0 <SFXRhodesTick+0x18>
   20ad0:	4bc1      	ldr	r3, [pc, #772]	; (20dd8 <SFXRhodesTick+0x330>)
   20ad2:	f103 09c0 	add.w	r9, r3, #192	; 0xc0
   20ad6:	461f      	mov	r7, r3
{
   20ad8:	463d      	mov	r5, r7
   20ada:	4644      	mov	r4, r8
			tADSR4_setSustain(&FM_envs[i][j], sustainsFinal[j]); //FM_sustains[Rsound][j] * displayValues[7]);
   20adc:	ecb4 0a01 	vldmia	r4!, {s0}
   20ae0:	4628      	mov	r0, r5
   20ae2:	f006 fec3 	bl	2786c <tADSR4_setSustain>
   20ae6:	3504      	adds	r5, #4
		for (int j = 0; j < 6; j++)
   20ae8:	42a6      	cmp	r6, r4
   20aea:	d1f7      	bne.n	20adc <SFXRhodesTick+0x34>
   20aec:	3718      	adds	r7, #24
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   20aee:	454f      	cmp	r7, r9
   20af0:	d1f2      	bne.n	20ad8 <SFXRhodesTick+0x30>
	for (int i = 0; i < numVoices; i++)
   20af2:	4bba      	ldr	r3, [pc, #744]	; (20ddc <SFXRhodesTick+0x334>)
   20af4:	781b      	ldrb	r3, [r3, #0]
   20af6:	2b00      	cmp	r3, #0
   20af8:	f000 8164 	beq.w	20dc4 <SFXRhodesTick+0x31c>
   20afc:	4bb6      	ldr	r3, [pc, #728]	; (20dd8 <SFXRhodesTick+0x330>)
   20afe:	f04f 0a00 	mov.w	sl, #0
   20b02:	f8df 8314 	ldr.w	r8, [pc, #788]	; 20e18 <SFXRhodesTick+0x370>
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20b06:	eef7 aa00 	vmov.f32	s21, #112	; 0x3f800000  1.0
   20b0a:	f103 0014 	add.w	r0, r3, #20
	float rightSample = 0.0f;
   20b0e:	ed9f 9ab4 	vldr	s18, [pc, #720]	; 20de0 <SFXRhodesTick+0x338>
   20b12:	49b4      	ldr	r1, [pc, #720]	; (20de4 <SFXRhodesTick+0x33c>)
   20b14:	4642      	mov	r2, r8
   20b16:	900a      	str	r0, [sp, #40]	; 0x28
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20b18:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
   20b1c:	48b2      	ldr	r0, [pc, #712]	; (20de8 <SFXRhodesTick+0x340>)
	float leftSample = 0.0f;
   20b1e:	eef0 9a49 	vmov.f32	s19, s18
   20b22:	46d0      	mov	r8, sl
   20b24:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 20e1c <SFXRhodesTick+0x374>
   20b28:	9003      	str	r0, [sp, #12]
   20b2a:	f103 0010 	add.w	r0, r3, #16
   20b2e:	4caf      	ldr	r4, [pc, #700]	; (20dec <SFXRhodesTick+0x344>)
   20b30:	9009      	str	r0, [sp, #36]	; 0x24
   20b32:	f103 000c 	add.w	r0, r3, #12
   20b36:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 20e20 <SFXRhodesTick+0x378>
   20b3a:	9008      	str	r0, [sp, #32]
   20b3c:	1d18      	adds	r0, r3, #4
   20b3e:	3308      	adds	r3, #8
   20b40:	4dab      	ldr	r5, [pc, #684]	; (20df0 <SFXRhodesTick+0x348>)
   20b42:	9006      	str	r0, [sp, #24]
   20b44:	9307      	str	r3, [sp, #28]
   20b46:	460b      	mov	r3, r1
   20b48:	4651      	mov	r1, sl
   20b4a:	4692      	mov	sl, r2
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20b4c:	f8d9 7000 	ldr.w	r7, [r9]
	for (int i = 0; i < numVoices; i++)
   20b50:	3101      	adds	r1, #1
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20b52:	ed9a 0a00 	vldr	s0, [sl]
   20b56:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   20b5a:	eddb 7a00 	vldr	s15, [fp]
		float myFrequency = freq[i];
   20b5e:	ecf3 8a01 	vldmia	r3!, {s17}
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20b62:	00ff      	lsls	r7, r7, #3
   20b64:	ee67 7a80 	vmul.f32	s15, s15, s0
   20b68:	4aa2      	ldr	r2, [pc, #648]	; (20df4 <SFXRhodesTick+0x34c>)
   20b6a:	eb05 0c07 	add.w	ip, r5, r7
   20b6e:	4427      	add	r7, r4
   20b70:	eb02 0608 	add.w	r6, r2, r8
		float myFrequency = freq[i];
   20b74:	9305      	str	r3, [sp, #20]
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20b76:	ed9c 0a05 	vldr	s0, [ip, #20]
   20b7a:	3a04      	subs	r2, #4
	for (int i = 0; i < numVoices; i++)
   20b7c:	9104      	str	r1, [sp, #16]
		tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
   20b7e:	4630      	mov	r0, r6
   20b80:	ee27 0a80 	vmul.f32	s0, s15, s0
   20b84:	4b9c      	ldr	r3, [pc, #624]	; (20df8 <SFXRhodesTick+0x350>)
   20b86:	499d      	ldr	r1, [pc, #628]	; (20dfc <SFXRhodesTick+0x354>)
   20b88:	4442      	add	r2, r8
   20b8a:	ed97 7a05 	vldr	s14, [r7, #20]
   20b8e:	4443      	add	r3, r8
   20b90:	4441      	add	r1, r8
   20b92:	9202      	str	r2, [sp, #8]
   20b94:	eea7 0a28 	vfma.f32	s0, s14, s17
   20b98:	9301      	str	r3, [sp, #4]
   20b9a:	9100      	str	r1, [sp, #0]
   20b9c:	f009 fd26 	bl	2a5ec <tCycle_setFreq>
		feedback_output = tCycle_tick(&FM_sines[i][5]);
   20ba0:	4630      	mov	r0, r6
   20ba2:	4f97      	ldr	r7, [pc, #604]	; (20e00 <SFXRhodesTick+0x358>)
   20ba4:	f009 fd30 	bl	2a608 <tCycle_tick>
		tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
   20ba8:	f8d9 0000 	ldr.w	r0, [r9]
   20bac:	edda 7a00 	vldr	s15, [sl]
   20bb0:	4447      	add	r7, r8
   20bb2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
		feedback_output = tCycle_tick(&FM_sines[i][5]);
   20bb6:	ed8b 0a00 	vstr	s0, [fp]
		tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
   20bba:	00c0      	lsls	r0, r0, #3
   20bbc:	eb05 0c00 	add.w	ip, r5, r0
   20bc0:	1826      	adds	r6, r4, r0
   20bc2:	980a      	ldr	r0, [sp, #40]	; 0x28
   20bc4:	ed9c 8a04 	vldr	s16, [ip, #16]
   20bc8:	4440      	add	r0, r8
   20bca:	ed96 ba04 	vldr	s22, [r6, #16]
   20bce:	ee28 8a27 	vmul.f32	s16, s16, s15
   20bd2:	4e8c      	ldr	r6, [pc, #560]	; (20e04 <SFXRhodesTick+0x35c>)
   20bd4:	4446      	add	r6, r8
   20bd6:	ee28 8a00 	vmul.f32	s16, s16, s0
   20bda:	f006 fe89 	bl	278f0 <tADSR4_tick>
   20bde:	9802      	ldr	r0, [sp, #8]
   20be0:	ee28 0a00 	vmul.f32	s0, s16, s0
   20be4:	eeab 0a28 	vfma.f32	s0, s22, s17
   20be8:	f009 fd00 	bl	2a5ec <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][3], (myFrequency  * FM_freqRatios[Rsound][3]) + (FM_indices[Rsound][3] * displayValues[0] * tCycle_tick(&FM_sines[i][4]) * tADSR4_tickNoInterp(&FM_envs[i][4])));
   20bec:	f8d9 2000 	ldr.w	r2, [r9]
   20bf0:	edda 7a00 	vldr	s15, [sl]
   20bf4:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20bf8:	9802      	ldr	r0, [sp, #8]
   20bfa:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   20bfe:	eb05 0e0c 	add.w	lr, r5, ip
   20c02:	44a4      	add	ip, r4
   20c04:	ed9e 8a03 	vldr	s16, [lr, #12]
   20c08:	ed9c ba03 	vldr	s22, [ip, #12]
   20c0c:	ee28 8a27 	vmul.f32	s16, s16, s15
   20c10:	f009 fcfa 	bl	2a608 <tCycle_tick>
   20c14:	9a09      	ldr	r2, [sp, #36]	; 0x24
   20c16:	ee28 8a00 	vmul.f32	s16, s16, s0
   20c1a:	eb02 0008 	add.w	r0, r2, r8
   20c1e:	f006 ffc5 	bl	27bac <tADSR4_tickNoInterp>
   20c22:	9801      	ldr	r0, [sp, #4]
   20c24:	ee28 0a00 	vmul.f32	s0, s16, s0
   20c28:	eeab 0a28 	vfma.f32	s0, s22, s17
   20c2c:	f009 fcde 	bl	2a5ec <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][2], (myFrequency  * FM_freqRatios[Rsound][2]) + (FM_indices[Rsound][2] * displayValues[0] * tCycle_tick(&FM_sines[i][3]) * tADSR4_tickNoInterp(&FM_envs[i][3])));
   20c30:	f8d9 2000 	ldr.w	r2, [r9]
   20c34:	edda 7a00 	vldr	s15, [sl]
   20c38:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20c3c:	9801      	ldr	r0, [sp, #4]
   20c3e:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   20c42:	eb05 0e0c 	add.w	lr, r5, ip
   20c46:	44a4      	add	ip, r4
   20c48:	ed9e 8a02 	vldr	s16, [lr, #8]
   20c4c:	ed9c ba02 	vldr	s22, [ip, #8]
   20c50:	ee28 8a27 	vmul.f32	s16, s16, s15
   20c54:	f009 fcd8 	bl	2a608 <tCycle_tick>
   20c58:	9b08      	ldr	r3, [sp, #32]
   20c5a:	ee28 8a00 	vmul.f32	s16, s16, s0
   20c5e:	eb03 0008 	add.w	r0, r3, r8
   20c62:	f006 ffa3 	bl	27bac <tADSR4_tickNoInterp>
   20c66:	9800      	ldr	r0, [sp, #0]
   20c68:	ee28 0a00 	vmul.f32	s0, s16, s0
   20c6c:	eeab 0a28 	vfma.f32	s0, s22, s17
   20c70:	f009 fcbc 	bl	2a5ec <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][1], myFrequency  * FM_freqRatios[Rsound][1]);
   20c74:	f8d9 2000 	ldr.w	r2, [r9]
   20c78:	4638      	mov	r0, r7
   20c7a:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20c7e:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
   20c82:	ed9c 0a01 	vldr	s0, [ip, #4]
   20c86:	ee28 0a80 	vmul.f32	s0, s17, s0
   20c8a:	f009 fcaf 	bl	2a5ec <tCycle_setFreq>
		tCycle_setFreq(&FM_sines[i][0],( myFrequency  * FM_freqRatios[Rsound][0]) + (FM_indices[Rsound][0] * displayValues[0] * tCycle_tick(&FM_sines[i][1]) * tADSR4_tickNoInterp(&FM_envs[i][1])));
   20c8e:	f8d9 2000 	ldr.w	r2, [r9]
   20c92:	4638      	mov	r0, r7
   20c94:	edda 7a00 	vldr	s15, [sl]
   20c98:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
   20c9c:	ea4f 07cc 	mov.w	r7, ip, lsl #3
   20ca0:	eb05 0c07 	add.w	ip, r5, r7
   20ca4:	4427      	add	r7, r4
   20ca6:	ed9c 8a00 	vldr	s16, [ip]
   20caa:	ed97 ba00 	vldr	s22, [r7]
   20cae:	ee28 8a27 	vmul.f32	s16, s16, s15
   20cb2:	f009 fca9 	bl	2a608 <tCycle_tick>
   20cb6:	9b06      	ldr	r3, [sp, #24]
   20cb8:	ee28 8a00 	vmul.f32	s16, s16, s0
   20cbc:	eb03 0008 	add.w	r0, r3, r8
   20cc0:	f006 ff74 	bl	27bac <tADSR4_tickNoInterp>
   20cc4:	4630      	mov	r0, r6
   20cc6:	ee28 0a00 	vmul.f32	s0, s16, s0
   20cca:	eeab 0a28 	vfma.f32	s0, s22, s17
   20cce:	f009 fc8d 	bl	2a5ec <tCycle_setFreq>
		sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
   20cd2:	9800      	ldr	r0, [sp, #0]
   20cd4:	f009 fc98 	bl	2a608 <tCycle_tick>
   20cd8:	9b07      	ldr	r3, [sp, #28]
   20cda:	eeb0 ba40 	vmov.f32	s22, s0
   20cde:	eb03 0008 	add.w	r0, r3, r8
   20ce2:	f006 ff63 	bl	27bac <tADSR4_tickNoInterp>
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20ce6:	4630      	mov	r0, r6
		sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
   20ce8:	eef0 8a40 	vmov.f32	s17, s0
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20cec:	f009 fc8c 	bl	2a608 <tCycle_tick>
   20cf0:	4b39      	ldr	r3, [pc, #228]	; (20dd8 <SFXRhodesTick+0x330>)
   20cf2:	eeb0 8a40 	vmov.f32	s16, s0
   20cf6:	eb03 0008 	add.w	r0, r3, r8
   20cfa:	f108 0818 	add.w	r8, r8, #24
   20cfe:	f006 ff55 	bl	27bac <tADSR4_tickNoInterp>
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20d02:	9b03      	ldr	r3, [sp, #12]
   20d04:	edda 7a04 	vldr	s15, [sl, #16]
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20d08:	ee28 0a00 	vmul.f32	s0, s16, s0
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20d0c:	ecf3 6a01 	vldmia	r3!, {s13}
   20d10:	ee3a 6ae7 	vsub.f32	s12, s21, s15
	for (int i = 0; i < numVoices; i++)
   20d14:	9904      	ldr	r1, [sp, #16]
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20d16:	ee3a 7ae6 	vsub.f32	s14, s21, s13
   20d1a:	9303      	str	r3, [sp, #12]
		rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   20d1c:	ee67 6aa6 	vmul.f32	s13, s15, s13
	for (int i = 0; i < numVoices; i++)
   20d20:	4b2e      	ldr	r3, [pc, #184]	; (20ddc <SFXRhodesTick+0x334>)
		sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
   20d22:	eeab 0a28 	vfma.f32	s0, s22, s17
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20d26:	ee67 7a27 	vmul.f32	s15, s14, s15
	for (int i = 0; i < numVoices; i++)
   20d2a:	7818      	ldrb	r0, [r3, #0]
		rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   20d2c:	eee6 6a0a 	vfma.f32	s13, s12, s20
	for (int i = 0; i < numVoices; i++)
   20d30:	9b05      	ldr	r3, [sp, #20]
   20d32:	4288      	cmp	r0, r1
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20d34:	eee6 7a0a 	vfma.f32	s15, s12, s20
		rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
   20d38:	eea6 9a80 	vfma.f32	s18, s13, s0
		leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
   20d3c:	eee7 9a80 	vfma.f32	s19, s15, s0
	for (int i = 0; i < numVoices; i++)
   20d40:	f73f af04 	bgt.w	20b4c <SFXRhodesTick+0xa4>
   20d44:	eddf 7a30 	vldr	s15, [pc, #192]	; 20e08 <SFXRhodesTick+0x360>
   20d48:	46d0      	mov	r8, sl
   20d4a:	ee69 9aa7 	vmul.f32	s19, s19, s15
   20d4e:	ee29 9a27 	vmul.f32	s18, s18, s15
	float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   20d52:	482e      	ldr	r0, [pc, #184]	; (20e0c <SFXRhodesTick+0x364>)
   20d54:	f009 fc58 	bl	2a608 <tCycle_tick>
   20d58:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   20d5c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   20d60:	edd8 6a01 	vldr	s13, [r8, #4]
	if (tremoloStereo)
   20d64:	4b2a      	ldr	r3, [pc, #168]	; (20e10 <SFXRhodesTick+0x368>)
	float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   20d66:	ee30 0a27 	vadd.f32	s0, s0, s15
   20d6a:	ee26 7a87 	vmul.f32	s14, s13, s14
	if (tremoloStereo)
   20d6e:	781b      	ldrb	r3, [r3, #0]
   20d70:	ee77 7ae6 	vsub.f32	s15, s15, s13
	float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
   20d74:	ee20 7a07 	vmul.f32	s14, s0, s14
   20d78:	ee37 0a87 	vadd.f32	s0, s15, s14
	if (tremoloStereo)
   20d7c:	b9cb      	cbnz	r3, 20db2 <SFXRhodesTick+0x30a>
		rightSample *= ((tremoloSignal) + (1.0f - displayValues[1]));
   20d7e:	ee29 9a00 	vmul.f32	s18, s18, s0
	leftSample *= displayValues[3]; //drive
   20d82:	ed98 8a03 	vldr	s16, [r8, #12]
   20d86:	ee68 9a29 	vmul.f32	s19, s16, s19
	leftSample = tanhf(leftSample);
   20d8a:	ee29 0a80 	vmul.f32	s0, s19, s0
   20d8e:	f00c fa95 	bl	2d2bc <tanhf>
   20d92:	eef0 8a40 	vmov.f32	s17, s0
	rightSample = tanhf(rightSample);
   20d96:	ee28 0a09 	vmul.f32	s0, s16, s18
   20d9a:	f00c fa8f 	bl	2d2bc <tanhf>
	input[0] = leftSample;
   20d9e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   20da0:	edc3 8a00 	vstr	s17, [r3]
	input[1] = rightSample;
   20da4:	ed83 0a01 	vstr	s0, [r3, #4]
}
   20da8:	b00d      	add	sp, #52	; 0x34
   20daa:	ecbd 8b08 	vpop	{d8-d11}
   20dae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rightSample *= ((1.0f-tremoloSignal) + (1.0f - displayValues[1]));
   20db2:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   20db6:	ee77 6ae6 	vsub.f32	s13, s15, s13
   20dba:	ee36 7ac7 	vsub.f32	s14, s13, s14
   20dbe:	ee27 9a09 	vmul.f32	s18, s14, s18
   20dc2:	e7de      	b.n	20d82 <SFXRhodesTick+0x2da>
	for (int i = 0; i < numVoices; i++)
   20dc4:	ed9f 9a06 	vldr	s18, [pc, #24]	; 20de0 <SFXRhodesTick+0x338>
   20dc8:	f8df 804c 	ldr.w	r8, [pc, #76]	; 20e18 <SFXRhodesTick+0x370>
   20dcc:	eef0 9a49 	vmov.f32	s19, s18
   20dd0:	e7bf      	b.n	20d52 <SFXRhodesTick+0x2aa>
   20dd2:	bf00      	nop
   20dd4:	020f9038 	.word	0x020f9038
   20dd8:	020fa164 	.word	0x020fa164
   20ddc:	00062ae4 	.word	0x00062ae4
   20de0:	00000000 	.word	0x00000000
   20de4:	020f9a44 	.word	0x020f9a44
   20de8:	020f8e24 	.word	0x020f8e24
   20dec:	000628d0 	.word	0x000628d0
   20df0:	00062948 	.word	0x00062948
   20df4:	020f9a88 	.word	0x020f9a88
   20df8:	020f9a80 	.word	0x020f9a80
   20dfc:	020f9a7c 	.word	0x020f9a7c
   20e00:	020f9a78 	.word	0x020f9a78
   20e04:	020f9a74 	.word	0x020f9a74
   20e08:	3ecccccd 	.word	0x3ecccccd
   20e0c:	020fa3a8 	.word	0x020fa3a8
   20e10:	020e3214 	.word	0x020e3214
   20e14:	020f8f54 	.word	0x020f8f54
   20e18:	020fb3cc 	.word	0x020fb3cc
   20e1c:	020e3118 	.word	0x020e3118
   20e20:	020e3190 	.word	0x020e3190

00020e24 <SFXRhodesFree>:
{
   20e24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   20e26:	2400      	movs	r4, #0
   20e28:	4f12      	ldr	r7, [pc, #72]	; (20e74 <SFXRhodesFree+0x50>)
   20e2a:	4e13      	ldr	r6, [pc, #76]	; (20e78 <SFXRhodesFree+0x54>)
   20e2c:	f104 0518 	add.w	r5, r4, #24
			tCycle_free(&FM_sines[i][j]);
   20e30:	1938      	adds	r0, r7, r4
   20e32:	f009 fbd7 	bl	2a5e4 <tCycle_free>
			tADSR4_free(&FM_envs[i][j]);
   20e36:	1930      	adds	r0, r6, r4
   20e38:	3404      	adds	r4, #4
   20e3a:	f006 fcf7 	bl	2782c <tADSR4_free>
		for (int j = 0; j < 6; j++)
   20e3e:	42ac      	cmp	r4, r5
   20e40:	d1f6      	bne.n	20e30 <SFXRhodesFree+0xc>
	for (int i = 0; i < NUM_VOC_VOICES; i++)
   20e42:	2cc0      	cmp	r4, #192	; 0xc0
   20e44:	d1f2      	bne.n	20e2c <SFXRhodesFree+0x8>
		tExpSmooth_free(&susSmoothers[i]);
   20e46:	480d      	ldr	r0, [pc, #52]	; (20e7c <SFXRhodesFree+0x58>)
   20e48:	f007 f874 	bl	27f34 <tExpSmooth_free>
   20e4c:	480c      	ldr	r0, [pc, #48]	; (20e80 <SFXRhodesFree+0x5c>)
   20e4e:	f007 f871 	bl	27f34 <tExpSmooth_free>
   20e52:	480c      	ldr	r0, [pc, #48]	; (20e84 <SFXRhodesFree+0x60>)
   20e54:	f007 f86e 	bl	27f34 <tExpSmooth_free>
   20e58:	480b      	ldr	r0, [pc, #44]	; (20e88 <SFXRhodesFree+0x64>)
   20e5a:	f007 f86b 	bl	27f34 <tExpSmooth_free>
   20e5e:	480b      	ldr	r0, [pc, #44]	; (20e8c <SFXRhodesFree+0x68>)
   20e60:	f007 f868 	bl	27f34 <tExpSmooth_free>
   20e64:	480a      	ldr	r0, [pc, #40]	; (20e90 <SFXRhodesFree+0x6c>)
   20e66:	f007 f865 	bl	27f34 <tExpSmooth_free>
	tCycle_free(&tremolo);
   20e6a:	480a      	ldr	r0, [pc, #40]	; (20e94 <SFXRhodesFree+0x70>)
}
   20e6c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	tCycle_free(&tremolo);
   20e70:	f009 bbb8 	b.w	2a5e4 <tCycle_free>
   20e74:	020f9a74 	.word	0x020f9a74
   20e78:	020fa164 	.word	0x020fa164
   20e7c:	020f9038 	.word	0x020f9038
   20e80:	020f903c 	.word	0x020f903c
   20e84:	020f9040 	.word	0x020f9040
   20e88:	020f9044 	.word	0x020f9044
   20e8c:	020f9048 	.word	0x020f9048
   20e90:	020f904c 	.word	0x020f904c
   20e94:	020fa3a8 	.word	0x020fa3a8

00020e98 <calculateNoteArray>:
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20e98:	4b17      	ldr	r3, [pc, #92]	; (20ef8 <calculateNoteArray+0x60>)
	for (int i = 0; i < 128; i++)
   20e9a:	2100      	movs	r1, #0
   20e9c:	4817      	ldr	r0, [pc, #92]	; (20efc <calculateNoteArray+0x64>)
{
   20e9e:	b4f0      	push	{r4, r5, r6, r7}
   20ea0:	4e17      	ldr	r6, [pc, #92]	; (20f00 <calculateNoteArray+0x68>)
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20ea2:	781f      	ldrb	r7, [r3, #0]
   20ea4:	4d17      	ldr	r5, [pc, #92]	; (20f04 <calculateNoteArray+0x6c>)
		float tempNote = i;
   20ea6:	ee07 1a90 	vmov	s15, r1
	for (int i = 0; i < 128; i++)
   20eaa:	3101      	adds	r1, #1
		float tempNote = i;
   20eac:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	for (int i = 0; i < 128; i++)
   20eb0:	2980      	cmp	r1, #128	; 0x80
		float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
   20eb2:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   20eb6:	ee17 3a90 	vmov	r3, s15
   20eba:	eba3 0307 	sub.w	r3, r3, r7
   20ebe:	fb85 2403 	smull	r2, r4, r5, r3
   20ec2:	ea4f 72e3 	mov.w	r2, r3, asr #31
   20ec6:	ebc2 0264 	rsb	r2, r2, r4, asr #1
   20eca:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   20ece:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
   20ed2:	ee07 3a90 	vmov	s15, r3
   20ed6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
   20eda:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   20ede:	ee17 3a90 	vmov	r3, s15
   20ee2:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   20ee6:	edd3 7a00 	vldr	s15, [r3]
   20eea:	ee77 7a87 	vadd.f32	s15, s15, s14
		notes[i] = tunedNote;
   20eee:	ece0 7a01 	vstmia	r0!, {s15}
	for (int i = 0; i < 128; i++)
   20ef2:	d1d8      	bne.n	20ea6 <calculateNoteArray+0xe>
	}
}
   20ef4:	bcf0      	pop	{r4, r5, r6, r7}
   20ef6:	4770      	bx	lr
   20ef8:	020e3258 	.word	0x020e3258
   20efc:	020f9050 	.word	0x020f9050
   20f00:	020e3224 	.word	0x020e3224
   20f04:	2aaaaaab 	.word	0x2aaaaaab

00020f08 <nearestNoteWithHysteresis>:

int lastNearNote = -1;


float nearestNoteWithHysteresis(float note, float hysteresis)
{
   20f08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	float leastDifference = fastabsf(note - notes[0]);
   20f0c:	4f76      	ldr	r7, [pc, #472]	; (210e8 <nearestNoteWithHysteresis+0x1e0>)
{
   20f0e:	ed2d 8b04 	vpush	{d8-d9}
   20f12:	eef0 8a40 	vmov.f32	s17, s0
	float leastDifference = fastabsf(note - notes[0]);
   20f16:	ed97 0a00 	vldr	s0, [r7]
{
   20f1a:	eeb0 9a60 	vmov.f32	s18, s1
	float leastDifference = fastabsf(note - notes[0]);
   20f1e:	ee38 0ac0 	vsub.f32	s0, s17, s0
   20f22:	f008 fbd7 	bl	296d4 <fastabsf>
	float difference;
	int nearIndex = 0;
	int* chord;
	float output = 0.0f;

	if (autotuneChromatic > 0)
   20f26:	4b71      	ldr	r3, [pc, #452]	; (210ec <nearestNoteWithHysteresis+0x1e4>)
	{
		chord = chromaticArray;
   20f28:	4971      	ldr	r1, [pc, #452]	; (210f0 <nearestNoteWithHysteresis+0x1e8>)
	float leastDifference = fastabsf(note - notes[0]);
   20f2a:	eeb0 8a40 	vmov.f32	s16, s0
	if (autotuneChromatic > 0)
   20f2e:	f893 8000 	ldrb.w	r8, [r3]
	}
	else
	{
		chord = chordArray;
	}
	if (autotuneLock > 0)
   20f32:	4a70      	ldr	r2, [pc, #448]	; (210f4 <nearestNoteWithHysteresis+0x1ec>)
		chord = chromaticArray;
   20f34:	4b70      	ldr	r3, [pc, #448]	; (210f8 <nearestNoteWithHysteresis+0x1f0>)
	if (autotuneLock > 0)
   20f36:	6812      	ldr	r2, [r2, #0]
		chord = chromaticArray;
   20f38:	f1b8 0f00 	cmp.w	r8, #0
   20f3c:	bf0c      	ite	eq
   20f3e:	4688      	moveq	r8, r1
   20f40:	4698      	movne	r8, r3
	{
		chord = lockArray;
   20f42:	4b6e      	ldr	r3, [pc, #440]	; (210fc <nearestNoteWithHysteresis+0x1f4>)
   20f44:	2a00      	cmp	r2, #0
   20f46:	bf18      	it	ne
   20f48:	4698      	movne	r8, r3
	}
	int hasNotes = 0;
	for (int i = 0; i < 12; i++)
	{
		if (chord[i] > 0)
   20f4a:	e9d8 3200 	ldrd	r3, r2, [r8]
   20f4e:	f8d8 0008 	ldr.w	r0, [r8, #8]
   20f52:	2b00      	cmp	r3, #0
   20f54:	bfcc      	ite	gt
   20f56:	2301      	movgt	r3, #1
   20f58:	2300      	movle	r3, #0
		{
			hasNotes = 1;
   20f5a:	2a00      	cmp	r2, #0
		if (chord[i] > 0)
   20f5c:	e9d8 1203 	ldrd	r1, r2, [r8, #12]
			hasNotes = 1;
   20f60:	bfc8      	it	gt
   20f62:	2301      	movgt	r3, #1
   20f64:	2800      	cmp	r0, #0
		if (chord[i] > 0)
   20f66:	f8d8 0014 	ldr.w	r0, [r8, #20]
			hasNotes = 1;
   20f6a:	bfc8      	it	gt
   20f6c:	2301      	movgt	r3, #1
   20f6e:	2900      	cmp	r1, #0
		if (chord[i] > 0)
   20f70:	f8d8 1018 	ldr.w	r1, [r8, #24]
			hasNotes = 1;
   20f74:	bfc8      	it	gt
   20f76:	2301      	movgt	r3, #1
   20f78:	2a00      	cmp	r2, #0
		if (chord[i] > 0)
   20f7a:	f8d8 201c 	ldr.w	r2, [r8, #28]
			hasNotes = 1;
   20f7e:	bfc8      	it	gt
   20f80:	2301      	movgt	r3, #1
   20f82:	2800      	cmp	r0, #0
		if (chord[i] > 0)
   20f84:	f8d8 0020 	ldr.w	r0, [r8, #32]
			hasNotes = 1;
   20f88:	bfc8      	it	gt
   20f8a:	2301      	movgt	r3, #1
   20f8c:	2900      	cmp	r1, #0
		if (chord[i] > 0)
   20f8e:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
			hasNotes = 1;
   20f92:	bfc8      	it	gt
   20f94:	2301      	movgt	r3, #1
   20f96:	2a00      	cmp	r2, #0
		if (chord[i] > 0)
   20f98:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
			hasNotes = 1;
   20f9c:	bfc8      	it	gt
   20f9e:	2301      	movgt	r3, #1
   20fa0:	2800      	cmp	r0, #0
   20fa2:	bfc8      	it	gt
   20fa4:	2301      	movgt	r3, #1
   20fa6:	2900      	cmp	r1, #0
   20fa8:	bfc8      	it	gt
   20faa:	2301      	movgt	r3, #1
		if (chord[i] > 0)
   20fac:	2a00      	cmp	r2, #0
   20fae:	f340 808d 	ble.w	210cc <nearestNoteWithHysteresis+0x1c4>
   20fb2:	4d53      	ldr	r5, [pc, #332]	; (21100 <nearestNoteWithHysteresis+0x1f8>)

	}
	if (hasNotes)
	{

		for(int i = 1; i < 128; i++)
   20fb4:	2401      	movs	r4, #1
	int nearIndex = 0;
   20fb6:	2600      	movs	r6, #0
		{
			if (chord[i%12] > 0)
   20fb8:	f8df 914c 	ldr.w	r9, [pc, #332]	; 21108 <nearestNoteWithHysteresis+0x200>
   20fbc:	e003      	b.n	20fc6 <nearestNoteWithHysteresis+0xbe>
		for(int i = 1; i < 128; i++)
   20fbe:	3401      	adds	r4, #1
   20fc0:	3504      	adds	r5, #4
   20fc2:	2c80      	cmp	r4, #128	; 0x80
   20fc4:	d01c      	beq.n	21000 <nearestNoteWithHysteresis+0xf8>
			if (chord[i%12] > 0)
   20fc6:	fba9 2304 	umull	r2, r3, r9, r4
   20fca:	08db      	lsrs	r3, r3, #3
   20fcc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   20fd0:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
   20fd4:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   20fd8:	2b00      	cmp	r3, #0
   20fda:	ddf0      	ble.n	20fbe <nearestNoteWithHysteresis+0xb6>
			{
				difference = fastabsf(note - notes[i]);
   20fdc:	ed95 0a00 	vldr	s0, [r5]
   20fe0:	ee38 0ac0 	vsub.f32	s0, s17, s0
   20fe4:	f008 fb76 	bl	296d4 <fastabsf>
				if(difference < leastDifference)
   20fe8:	eeb4 0ac8 	vcmpe.f32	s0, s16
   20fec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   20ff0:	d5e5      	bpl.n	20fbe <nearestNoteWithHysteresis+0xb6>
   20ff2:	4626      	mov	r6, r4
		for(int i = 1; i < 128; i++)
   20ff4:	3401      	adds	r4, #1
				{
					leastDifference = difference;
   20ff6:	eeb0 8a40 	vmov.f32	s16, s0
   20ffa:	3504      	adds	r5, #4
		for(int i = 1; i < 128; i++)
   20ffc:	2c80      	cmp	r4, #128	; 0x80
   20ffe:	d1e2      	bne.n	20fc6 <nearestNoteWithHysteresis+0xbe>
					nearIndex = i;
				}
			}
		}

		if (lastNearNote == -1)
   21000:	4840      	ldr	r0, [pc, #256]	; (21104 <nearestNoteWithHysteresis+0x1fc>)
   21002:	6801      	ldr	r1, [r0, #0]
   21004:	1c4b      	adds	r3, r1, #1
   21006:	d058      	beq.n	210ba <nearestNoteWithHysteresis+0x1b2>
   21008:	eb07 0381 	add.w	r3, r7, r1, lsl #2
		{
			output = notes[nearIndex];
			lastNearNote = nearIndex;
			return output;
		}
		if (nearIndex != lastNearNote)
   2100c:	42b1      	cmp	r1, r6
   2100e:	ed93 0a00 	vldr	s0, [r3]
   21012:	d057      	beq.n	210c4 <nearestNoteWithHysteresis+0x1bc>
   21014:	460b      	mov	r3, r1
		{
			//check if it's beyond the hysteresis

			//find closest note in chord upward from lastNearNote
			int upNote = 0;
   21016:	2400      	movs	r4, #0
			int downNote = 128;
			int i = lastNearNote;
			while ((i < 128) && (upNote == 0))
			{
				i++;
				if (chord[i%12] > 0)
   21018:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 2110c <nearestNoteWithHysteresis+0x204>
   2101c:	e00f      	b.n	2103e <nearestNoteWithHysteresis+0x136>
   2101e:	ebc2 0265 	rsb	r2, r2, r5, asr #1
			while ((i < 128) && (upNote == 0))
   21022:	b9a4      	cbnz	r4, 2104e <nearestNoteWithHysteresis+0x146>
				if (chord[i%12] > 0)
   21024:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   21028:	eba3 0282 	sub.w	r2, r3, r2, lsl #2
   2102c:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
   21030:	2a00      	cmp	r2, #0
   21032:	bfcc      	ite	gt
   21034:	461c      	movgt	r4, r3
   21036:	2400      	movle	r4, #0
				{
					upNote = i;
				}
				if (i == 128)
				{
					upNote = 128;
   21038:	2b80      	cmp	r3, #128	; 0x80
   2103a:	bf08      	it	eq
   2103c:	461c      	moveq	r4, r3
			while ((i < 128) && (upNote == 0))
   2103e:	2b7f      	cmp	r3, #127	; 0x7f
				i++;
   21040:	f103 0301 	add.w	r3, r3, #1
				if (chord[i%12] > 0)
   21044:	fb8c 2503 	smull	r2, r5, ip, r3
   21048:	ea4f 72e3 	mov.w	r2, r3, asr #31
			while ((i < 128) && (upNote == 0))
   2104c:	dde7      	ble.n	2101e <nearestNoteWithHysteresis+0x116>
			int downNote = 128;
   2104e:	2280      	movs	r2, #128	; 0x80
			}
			i = lastNearNote;
			while ((i > 0) && (downNote == 128))
			{
				i--;
				if (chord[i%12] > 0)
   21050:	4d2d      	ldr	r5, [pc, #180]	; (21108 <nearestNoteWithHysteresis+0x200>)
   21052:	e010      	b.n	21076 <nearestNoteWithHysteresis+0x16e>
			while ((i > 0) && (downNote == 128))
   21054:	2a80      	cmp	r2, #128	; 0x80
				if (chord[i%12] > 0)
   21056:	ea4f 03d3 	mov.w	r3, r3, lsr #3
			while ((i > 0) && (downNote == 128))
   2105a:	d112      	bne.n	21082 <nearestNoteWithHysteresis+0x17a>
				if (chord[i%12] > 0)
   2105c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   21060:	eba1 0383 	sub.w	r3, r1, r3, lsl #2
   21064:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
   21068:	2b00      	cmp	r3, #0
   2106a:	bfcc      	ite	gt
   2106c:	460a      	movgt	r2, r1
   2106e:	2280      	movle	r2, #128	; 0x80
				{
					downNote = i;
				}
				if (i == 0)
				{
					downNote = 0;
   21070:	2900      	cmp	r1, #0
   21072:	bf08      	it	eq
   21074:	460a      	moveq	r2, r1
			while ((i > 0) && (downNote == 128))
   21076:	2900      	cmp	r1, #0
				i--;
   21078:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
				if (chord[i%12] > 0)
   2107c:	fba5 c301 	umull	ip, r3, r5, r1
			while ((i > 0) && (downNote == 128))
   21080:	dce8      	bgt.n	21054 <nearestNoteWithHysteresis+0x14c>
				}
			}
			//now should have adjacent notes in array available
			//calculate the differences that should be necessary to move away
			float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
			float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
   21082:	eb07 0282 	add.w	r2, r7, r2, lsl #2

			float theDifference = note - notes[lastNearNote];
   21086:	ee78 8ac0 	vsub.f32	s17, s17, s0
			float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
   2108a:	edd2 7a00 	vldr	s15, [r2]
   2108e:	ee70 7a67 	vsub.f32	s15, s0, s15
			if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
   21092:	ee69 7a67 	vnmul.f32	s15, s18, s15
   21096:	eef4 7ae8 	vcmpe.f32	s15, s17
   2109a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2109e:	dc0c      	bgt.n	210ba <nearestNoteWithHysteresis+0x1b2>
			float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
   210a0:	eb07 0484 	add.w	r4, r7, r4, lsl #2
   210a4:	edd4 7a00 	vldr	s15, [r4]
   210a8:	ee77 7ac0 	vsub.f32	s15, s15, s0
   210ac:	ee27 9a89 	vmul.f32	s18, s15, s18
			if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
   210b0:	eeb4 9a68 	vcmp.f32	s18, s17
   210b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   210b8:	d504      	bpl.n	210c4 <nearestNoteWithHysteresis+0x1bc>
			{
				output = notes[nearIndex];
   210ba:	eb07 0786 	add.w	r7, r7, r6, lsl #2
				lastNearNote = nearIndex;
   210be:	6006      	str	r6, [r0, #0]
				output = notes[nearIndex];
   210c0:	ed97 0a00 	vldr	s0, [r7]
	else
	{
		output = -1.0f; //signal that there are no notes to snap to
	}
	return output;
}
   210c4:	ecbd 8b04 	vpop	{d8-d9}
   210c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (chord[i] > 0)
   210cc:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
   210d0:	2a00      	cmp	r2, #0
   210d2:	f73f af6e 	bgt.w	20fb2 <nearestNoteWithHysteresis+0xaa>
	if (hasNotes)
   210d6:	2b00      	cmp	r3, #0
   210d8:	f47f af6b 	bne.w	20fb2 <nearestNoteWithHysteresis+0xaa>
		output = -1.0f; //signal that there are no notes to snap to
   210dc:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
}
   210e0:	ecbd 8b04 	vpop	{d8-d9}
   210e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   210e8:	020f9050 	.word	0x020f9050
   210ec:	020e3124 	.word	0x020e3124
   210f0:	020e3138 	.word	0x020e3138
   210f4:	020e3128 	.word	0x020e3128
   210f8:	00062a84 	.word	0x00062a84
   210fc:	020e31b0 	.word	0x020e31b0
   21100:	020f9054 	.word	0x020f9054
   21104:	00062adc 	.word	0x00062adc
   21108:	aaaaaaab 	.word	0xaaaaaaab
   2110c:	2aaaaaab 	.word	0x2aaaaaab

00021110 <SFXNeartuneTick>:
{
   21110:	b5f0      	push	{r4, r5, r6, r7, lr}
   21112:	ed2d 8b02 	vpush	{d8}
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21116:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
   2111a:	4d75      	ldr	r5, [pc, #468]	; (212f0 <SFXNeartuneTick+0x1e0>)
   2111c:	eddf 7a75 	vldr	s15, [pc, #468]	; 212f4 <SFXNeartuneTick+0x1e4>
{
   21120:	b083      	sub	sp, #12
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21122:	ed95 7a4b 	vldr	s14, [r5, #300]	; 0x12c
{
   21126:	4606      	mov	r6, r0
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21128:	eef0 6a48 	vmov.f32	s13, s16
   2112c:	4c72      	ldr	r4, [pc, #456]	; (212f8 <SFXNeartuneTick+0x1e8>)
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   2112e:	4873      	ldr	r0, [pc, #460]	; (212fc <SFXNeartuneTick+0x1ec>)
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21130:	eee7 6a27 	vfma.f32	s13, s14, s15
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   21134:	eeb0 0a66 	vmov.f32	s0, s13
	displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
   21138:	edc4 6a00 	vstr	s13, [r4]
	tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
   2113c:	f005 fe0c 	bl	26d58 <tRetune_setFidelityThreshold>
	displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
   21140:	eddf 7a6f 	vldr	s15, [pc, #444]	; 21300 <SFXNeartuneTick+0x1f0>
   21144:	edd5 0a4c 	vldr	s1, [r5, #304]	; 0x130
   21148:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   2114c:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 21304 <SFXNeartuneTick+0x1f4>
   21150:	ee60 0aa7 	vmul.f32	s1, s1, s15
   21154:	f008 fb98 	bl	29888 <LEAF_clip>
	displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   21158:	eef2 5a08 	vmov.f32	s11, #40	; 0x41400000  12.0
   2115c:	edd5 7a4e 	vldr	s15, [r5, #312]	; 0x138
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   21160:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
	displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
   21164:	edd5 6a4d 	vldr	s13, [r5, #308]	; 0x134
	displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   21168:	ee67 7aa5 	vmul.f32	s15, s15, s11
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   2116c:	ed95 7a4f 	vldr	s14, [r5, #316]	; 0x13c
	if (displayValues[2] > .90f)
   21170:	eddf 5a65 	vldr	s11, [pc, #404]	; 21308 <SFXNeartuneTick+0x1f8>
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   21174:	ee37 7a06 	vadd.f32	s14, s14, s12
	displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
   21178:	ed84 0a01 	vstr	s0, [r4, #4]
	if (displayValues[2] > .90f)
   2117c:	eef4 6ae5 	vcmpe.f32	s13, s11
	displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
   21180:	edc4 6a02 	vstr	s13, [r4, #8]
	displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
   21184:	edc4 7a03 	vstr	s15, [r4, #12]
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   21188:	ee27 7a08 	vmul.f32	s14, s14, s16
	if (displayValues[2] > .90f)
   2118c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
   21190:	ed84 7a04 	vstr	s14, [r4, #16]
	if (displayValues[2] > .90f)
   21194:	f300 8084 	bgt.w	212a0 <SFXNeartuneTick+0x190>
   21198:	ee66 7aa6 	vmul.f32	s15, s13, s13
   2119c:	ee67 7aa6 	vmul.f32	s15, s15, s13
	tExpSmooth_setFactor(&neartune_smoother, expBuffer[(int)(displayValues[2] * displayValues[2] * displayValues[2] * expBufferSizeMinusOne)]);
   211a0:	4a5a      	ldr	r2, [pc, #360]	; (2130c <SFXNeartuneTick+0x1fc>)
   211a2:	4b5b      	ldr	r3, [pc, #364]	; (21310 <SFXNeartuneTick+0x200>)
   211a4:	ed92 7a00 	vldr	s14, [r2]
   211a8:	485a      	ldr	r0, [pc, #360]	; (21314 <SFXNeartuneTick+0x204>)
   211aa:	ee67 7a87 	vmul.f32	s15, s15, s14
   211ae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   211b2:	ee17 2a90 	vmov	r2, s15
   211b6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   211ba:	ed93 0a00 	vldr	s0, [r3]
   211be:	f006 febd 	bl	27f3c <tExpSmooth_setFactor>
	float destFactor = tExpSmooth_tick(&neartune_smoother);
   211c2:	4854      	ldr	r0, [pc, #336]	; (21314 <SFXNeartuneTick+0x204>)
   211c4:	f006 fed6 	bl	27f74 <tExpSmooth_tick>
	float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
   211c8:	484c      	ldr	r0, [pc, #304]	; (212fc <SFXNeartuneTick+0x1ec>)
	float destFactor = tExpSmooth_tick(&neartune_smoother);
   211ca:	eef0 8a40 	vmov.f32	s17, s0
	float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
   211ce:	f005 fdc7 	bl	26d60 <tRetune_getInputPeriod>
	if (detectedPeriod > 0.0f)
   211d2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   211d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   211da:	dd3b      	ble.n	21254 <SFXNeartuneTick+0x144>
		detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
   211dc:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   211e0:	4d4d      	ldr	r5, [pc, #308]	; (21318 <SFXNeartuneTick+0x208>)
   211e2:	ee88 0a00 	vdiv.f32	s0, s16, s0
   211e6:	f008 fae1 	bl	297ac <LEAF_frequencyToMidi>
		desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   211ea:	edd4 0a04 	vldr	s1, [r4, #16]
		detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
   211ee:	ed85 0a00 	vstr	s0, [r5]
		desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   211f2:	f7ff fe89 	bl	20f08 <nearestNoteWithHysteresis>
   211f6:	4b49      	ldr	r3, [pc, #292]	; (2131c <SFXNeartuneTick+0x20c>)
		if (desiredSnap > 0.0f)
   211f8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
		desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
   211fc:	ed83 0a00 	vstr	s0, [r3]
		if (desiredSnap > 0.0f)
   21200:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   21204:	dd68      	ble.n	212d8 <SFXNeartuneTick+0x1c8>
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   21206:	edd4 6a01 	vldr	s13, [r4, #4]
   2120a:	edd5 7a00 	vldr	s15, [r5]
   2120e:	ee38 8a66 	vsub.f32	s16, s16, s13
			factorDiff = (fabsf(destinationNote-lastSnap));
   21212:	4c43      	ldr	r4, [pc, #268]	; (21320 <SFXNeartuneTick+0x210>)
			changeAmount = (fabsf(destinationNote-detectedNote));
   21214:	4a43      	ldr	r2, [pc, #268]	; (21324 <SFXNeartuneTick+0x214>)
			factorDiff = (fabsf(destinationNote-lastSnap));
   21216:	ed94 7a00 	vldr	s14, [r4]
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   2121a:	ee28 8a27 	vmul.f32	s16, s16, s15
			factorDiff = (fabsf(destinationNote-lastSnap));
   2121e:	4b42      	ldr	r3, [pc, #264]	; (21328 <SFXNeartuneTick+0x218>)
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   21220:	4f42      	ldr	r7, [pc, #264]	; (2132c <SFXNeartuneTick+0x21c>)
   21222:	eea0 8a26 	vfma.f32	s16, s0, s13
			if ((changeAmount < 11.9))
   21226:	ed9f 6b30 	vldr	d6, [pc, #192]	; 212e8 <SFXNeartuneTick+0x1d8>
			changeAmount = (fabsf(destinationNote-detectedNote));
   2122a:	ee78 7a67 	vsub.f32	s15, s16, s15
			destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
   2122e:	ed87 8a00 	vstr	s16, [r7]
			factorDiff = (fabsf(destinationNote-lastSnap));
   21232:	ee38 7a47 	vsub.f32	s14, s16, s14
			changeAmount = (fabsf(destinationNote-detectedNote));
   21236:	eef0 7ae7 	vabs.f32	s15, s15
			factorDiff = (fabsf(destinationNote-lastSnap));
   2123a:	eeb0 7ac7 	vabs.f32	s14, s14
			if ((changeAmount < 11.9))
   2123e:	eeb7 5ae7 	vcvt.f64.f32	d5, s15
			changeAmount = (fabsf(destinationNote-detectedNote));
   21242:	edc2 7a00 	vstr	s15, [r2]
			factorDiff = (fabsf(destinationNote-lastSnap));
   21246:	ed83 7a00 	vstr	s14, [r3]
			if ((changeAmount < 11.9))
   2124a:	eeb4 5bc6 	vcmpe.f64	d5, d6
   2124e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   21252:	d42a      	bmi.n	212aa <SFXNeartuneTick+0x19a>
	tRetune_setPitchFactor(&autotuneMono, destFactor, 0);
   21254:	2100      	movs	r1, #0
   21256:	eeb0 0a68 	vmov.f32	s0, s17
   2125a:	4828      	ldr	r0, [pc, #160]	; (212fc <SFXNeartuneTick+0x1ec>)
   2125c:	f005 fd6a 	bl	26d34 <tRetune_setPitchFactor>
	float* samples = tRetune_tick(&autotuneMono, input[1]);
   21260:	ed96 0a01 	vldr	s0, [r6, #4]
   21264:	4825      	ldr	r0, [pc, #148]	; (212fc <SFXNeartuneTick+0x1ec>)
   21266:	f005 fc91 	bl	26b8c <tRetune_tick>
   2126a:	4604      	mov	r4, r0
	LEAF_crossfade(tRamp_tick(&nearWetRamp), fades);
   2126c:	4830      	ldr	r0, [pc, #192]	; (21330 <SFXNeartuneTick+0x220>)
   2126e:	f006 fde5 	bl	27e3c <tRamp_tick>
   21272:	4668      	mov	r0, sp
   21274:	f008 fa84 	bl	29780 <LEAF_crossfade>
	sample += input[1] * fades[1]; // crossfade to dry signal if no notes held down.
   21278:	edd6 7a01 	vldr	s15, [r6, #4]
   2127c:	ed9d 7a01 	vldr	s14, [sp, #4]
   21280:	edd4 6a00 	vldr	s13, [r4]
   21284:	ee67 7a87 	vmul.f32	s15, s15, s14
   21288:	ed9d 7a00 	vldr	s14, [sp]
   2128c:	eee6 7a87 	vfma.f32	s15, s13, s14
	input[0] = sample;
   21290:	edc6 7a00 	vstr	s15, [r6]
	input[1] = sample;
   21294:	edc6 7a01 	vstr	s15, [r6, #4]
}
   21298:	b003      	add	sp, #12
   2129a:	ecbd 8b02 	vpop	{d8}
   2129e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		displayValues[2] = 1.0f;
   212a0:	eef0 7a46 	vmov.f32	s15, s12
   212a4:	ed84 6a02 	vstr	s12, [r4, #8]
   212a8:	e77a      	b.n	211a0 <SFXNeartuneTick+0x90>
				destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   212aa:	eeb0 0a48 	vmov.f32	s0, s16
   212ae:	f008 fbd5 	bl	29a5c <LEAF_midiToFrequency>
   212b2:	eeb0 8a40 	vmov.f32	s16, s0
   212b6:	ed95 0a00 	vldr	s0, [r5]
   212ba:	f008 fbcf 	bl	29a5c <LEAF_midiToFrequency>
   212be:	4b1d      	ldr	r3, [pc, #116]	; (21334 <SFXNeartuneTick+0x224>)
   212c0:	eec8 7a00 	vdiv.f32	s15, s16, s0
				tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   212c4:	4813      	ldr	r0, [pc, #76]	; (21314 <SFXNeartuneTick+0x204>)
   212c6:	eeb0 0a67 	vmov.f32	s0, s15
				destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
   212ca:	edc3 7a00 	vstr	s15, [r3]
				tExpSmooth_setDest(&neartune_smoother, destinationFactor);
   212ce:	f006 fe47 	bl	27f60 <tExpSmooth_setDest>
				lastSnap = destinationNote;
   212d2:	683b      	ldr	r3, [r7, #0]
   212d4:	6023      	str	r3, [r4, #0]
   212d6:	e7bd      	b.n	21254 <SFXNeartuneTick+0x144>
			tExpSmooth_setDest(&neartune_smoother, 1.0f);
   212d8:	eeb0 0a48 	vmov.f32	s0, s16
   212dc:	480d      	ldr	r0, [pc, #52]	; (21314 <SFXNeartuneTick+0x204>)
   212de:	f006 fe3f 	bl	27f60 <tExpSmooth_setDest>
   212e2:	e7b7      	b.n	21254 <SFXNeartuneTick+0x144>
   212e4:	f3af 8000 	nop.w
   212e8:	cccccccd 	.word	0xcccccccd
   212ec:	4027cccc 	.word	0x4027cccc
   212f0:	020f9318 	.word	0x020f9318
   212f4:	3efae148 	.word	0x3efae148
   212f8:	020fb3cc 	.word	0x020fb3cc
   212fc:	020fa154 	.word	0x020fa154
   21300:	3f8ccccd 	.word	0x3f8ccccd
   21304:	00000000 	.word	0x00000000
   21308:	3f666666 	.word	0x3f666666
   2130c:	00062acc 	.word	0x00062acc
   21310:	020f9c84 	.word	0x020f9c84
   21314:	020fa224 	.word	0x020fa224
   21318:	00062ac4 	.word	0x00062ac4
   2131c:	00062ab8 	.word	0x00062ab8
   21320:	00062ae0 	.word	0x00062ae0
   21324:	020e3134 	.word	0x020e3134
   21328:	020e3188 	.word	0x020e3188
   2132c:	00062ac0 	.word	0x00062ac0
   21330:	020faf9c 	.word	0x020faf9c
   21334:	00062abc 	.word	0x00062abc

00021338 <noteOff>:
}

void noteOff(int key, int velocity)
{
	UNUSED(velocity);
	if (chordArray[key%12] > 0) chordArray[key%12]--;
   21338:	4a48      	ldr	r2, [pc, #288]	; (2145c <noteOff+0x124>)
   2133a:	4949      	ldr	r1, [pc, #292]	; (21460 <noteOff+0x128>)
   2133c:	fb82 3200 	smull	r3, r2, r2, r0
   21340:	17c3      	asrs	r3, r0, #31
   21342:	ebc3 0362 	rsb	r3, r3, r2, asr #1
   21346:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   2134a:	eba0 0383 	sub.w	r3, r0, r3, lsl #2
{
   2134e:	b570      	push	{r4, r5, r6, lr}
	if (chordArray[key%12] > 0) chordArray[key%12]--;
   21350:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
{
   21354:	4604      	mov	r4, r0
	if (chordArray[key%12] > 0) chordArray[key%12]--;
   21356:	2a00      	cmp	r2, #0
   21358:	dd02      	ble.n	21360 <noteOff+0x28>
   2135a:	3a01      	subs	r2, #1
   2135c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]



	if (currentPreset == Rhodes)
   21360:	4b40      	ldr	r3, [pc, #256]	; (21464 <noteOff+0x12c>)
   21362:	781b      	ldrb	r3, [r3, #0]
   21364:	2b11      	cmp	r3, #17
   21366:	d031      	beq.n	213cc <noteOff+0x94>
				tADSR4_off(&FM_envs[voice][j]);
			}
		}

	}
	else if (currentPreset == ClassicSynth)
   21368:	2b10      	cmp	r3, #16
   2136a:	d04c      	beq.n	21406 <noteOff+0xce>
			tADSR4_off(&polyEnvs[voice]);
			tADSR4_off(&polyFiltEnvs[voice]);
		}
	}

	else if (currentPreset == SamplerKeyboard)
   2136c:	2b06      	cmp	r3, #6
   2136e:	d00b      	beq.n	21388 <noteOff+0x50>
			UISamplerKButtons(ButtonC, ActionHoldContinuous);
			tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
			//waitingForDeactivation[voice] = key;
		}
	}
	else if (currentPreset == LivingStringSynth)
   21370:	2b0f      	cmp	r3, #15
   21372:	b2e1      	uxtb	r1, r4
	{
		int voice;

		voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21374:	483c      	ldr	r0, [pc, #240]	; (21468 <noteOff+0x130>)
	else if (currentPreset == LivingStringSynth)
   21376:	d05b      	beq.n	21430 <noteOff+0xf8>
			tADSR4_off(&pluckEnvs[voice]);
		}
	}
	else
	{
		tSimplePoly_noteOff(&poly, key);
   21378:	f008 ff96 	bl	2a2a8 <tSimplePoly_noteOff>
	}

	if (tSimplePoly_getNumActiveVoices(&poly) < 1)
   2137c:	483a      	ldr	r0, [pc, #232]	; (21468 <noteOff+0x130>)
   2137e:	f009 f8ef 	bl	2a560 <tSimplePoly_getNumActiveVoices>
   21382:	2800      	cmp	r0, #0
   21384:	dd1d      	ble.n	213c2 <noteOff+0x8a>
	{
		setLED_2(0);
	}

}
   21386:	bd70      	pop	{r4, r5, r6, pc}
		if (key >= LOWEST_SAMPLER_KEY && key < LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS)
   21388:	3c24      	subs	r4, #36	; 0x24
   2138a:	2c30      	cmp	r4, #48	; 0x30
   2138c:	d8f6      	bhi.n	2137c <noteOff+0x44>
   2138e:	00a6      	lsls	r6, r4, #2
			if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
   21390:	4d36      	ldr	r5, [pc, #216]	; (2146c <noteOff+0x134>)
   21392:	4435      	add	r5, r6
   21394:	4628      	mov	r0, r5
   21396:	f00a fcfd 	bl	2bd94 <tBuffer_isActive>
   2139a:	2801      	cmp	r0, #1
   2139c:	d055      	beq.n	2144a <noteOff+0x112>
				tExpSmooth_setDest(&kSamplerGains[key-LOWEST_SAMPLER_KEY], 0.0f);
   2139e:	4834      	ldr	r0, [pc, #208]	; (21470 <noteOff+0x138>)
   213a0:	ed9f 0a34 	vldr	s0, [pc, #208]	; 21474 <noteOff+0x13c>
   213a4:	4430      	add	r0, r6
   213a6:	f006 fddb 	bl	27f60 <tExpSmooth_setDest>
			samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
   213aa:	4b33      	ldr	r3, [pc, #204]	; (21478 <noteOff+0x140>)
   213ac:	2200      	movs	r2, #0
			UISamplerKButtons(ButtonC, ActionHoldContinuous);
   213ae:	2103      	movs	r1, #3
   213b0:	2007      	movs	r0, #7
			samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
   213b2:	551a      	strb	r2, [r3, r4]
			UISamplerKButtons(ButtonC, ActionHoldContinuous);
   213b4:	f001 ff5e 	bl	23274 <UISamplerKButtons>
			tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
   213b8:	4830      	ldr	r0, [pc, #192]	; (2147c <noteOff+0x144>)
   213ba:	4430      	add	r0, r6
   213bc:	f00a fe00 	bl	2bfc0 <tSampler_stop>
   213c0:	e7dc      	b.n	2137c <noteOff+0x44>
		setLED_2(0);
   213c2:	2000      	movs	r0, #0
}
   213c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		setLED_2(0);
   213c8:	f7f8 b8a8 	b.w	1951c <setLED_2>
		if (tSimplePoly_getNumVoices(&poly) > 1)
   213cc:	4826      	ldr	r0, [pc, #152]	; (21468 <noteOff+0x130>)
   213ce:	f009 f8c3 	bl	2a558 <tSimplePoly_getNumVoices>
   213d2:	2801      	cmp	r0, #1
   213d4:	b2e1      	uxtb	r1, r4
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   213d6:	4824      	ldr	r0, [pc, #144]	; (21468 <noteOff+0x130>)
		if (tSimplePoly_getNumVoices(&poly) > 1)
   213d8:	dd12      	ble.n	21400 <noteOff+0xc8>
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   213da:	f009 f849 	bl	2a470 <tSimplePoly_markPendingNoteOff>
		if (voice >= 0)
   213de:	2800      	cmp	r0, #0
   213e0:	dbcc      	blt.n	2137c <noteOff+0x44>
   213e2:	4c27      	ldr	r4, [pc, #156]	; (21480 <noteOff+0x148>)
   213e4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   213e8:	f104 0518 	add.w	r5, r4, #24
   213ec:	00c0      	lsls	r0, r0, #3
   213ee:	4404      	add	r4, r0
   213f0:	4405      	add	r5, r0
				tADSR4_off(&FM_envs[voice][j]);
   213f2:	4620      	mov	r0, r4
   213f4:	3404      	adds	r4, #4
   213f6:	f006 fa73 	bl	278e0 <tADSR4_off>
			for (int j = 0; j < 6; j++)
   213fa:	42a5      	cmp	r5, r4
   213fc:	d1f9      	bne.n	213f2 <noteOff+0xba>
   213fe:	e7bd      	b.n	2137c <noteOff+0x44>
			voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21400:	f008 ff52 	bl	2a2a8 <tSimplePoly_noteOff>
   21404:	e7eb      	b.n	213de <noteOff+0xa6>
		if (tSimplePoly_getNumVoices(&poly) > 1)
   21406:	4818      	ldr	r0, [pc, #96]	; (21468 <noteOff+0x130>)
   21408:	f009 f8a6 	bl	2a558 <tSimplePoly_getNumVoices>
   2140c:	2801      	cmp	r0, #1
   2140e:	b2e1      	uxtb	r1, r4
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   21410:	4815      	ldr	r0, [pc, #84]	; (21468 <noteOff+0x130>)
		if (tSimplePoly_getNumVoices(&poly) > 1)
   21412:	dd17      	ble.n	21444 <noteOff+0x10c>
			voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
   21414:	f009 f82c 	bl	2a470 <tSimplePoly_markPendingNoteOff>
		if (voice >= 0)
   21418:	2800      	cmp	r0, #0
   2141a:	dbaf      	blt.n	2137c <noteOff+0x44>
   2141c:	0084      	lsls	r4, r0, #2
			tADSR4_off(&polyEnvs[voice]);
   2141e:	4819      	ldr	r0, [pc, #100]	; (21484 <noteOff+0x14c>)
   21420:	4420      	add	r0, r4
   21422:	f006 fa5d 	bl	278e0 <tADSR4_off>
			tADSR4_off(&polyFiltEnvs[voice]);
   21426:	4818      	ldr	r0, [pc, #96]	; (21488 <noteOff+0x150>)
   21428:	4420      	add	r0, r4
   2142a:	f006 fa59 	bl	278e0 <tADSR4_off>
   2142e:	e7a5      	b.n	2137c <noteOff+0x44>
		voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21430:	f008 ff3a 	bl	2a2a8 <tSimplePoly_noteOff>
		if (voice >= 0)
   21434:	2800      	cmp	r0, #0
   21436:	dba1      	blt.n	2137c <noteOff+0x44>
			tADSR4_off(&pluckEnvs[voice]);
   21438:	4b14      	ldr	r3, [pc, #80]	; (2148c <noteOff+0x154>)
   2143a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   2143e:	f006 fa4f 	bl	278e0 <tADSR4_off>
   21442:	e79b      	b.n	2137c <noteOff+0x44>
			voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
   21444:	f008 ff30 	bl	2a2a8 <tSimplePoly_noteOff>
   21448:	e7e6      	b.n	21418 <noteOff+0xe0>
				tBuffer_stop(&keyBuff[key-LOWEST_SAMPLER_KEY]);
   2144a:	4628      	mov	r0, r5
   2144c:	f00a fc8a 	bl	2bd64 <tBuffer_stop>
				UISamplerKButtons(ButtonUp, ActionPress);
   21450:	2100      	movs	r1, #0
   21452:	2004      	movs	r0, #4
   21454:	f001 ff0e 	bl	23274 <UISamplerKButtons>
   21458:	e7a7      	b.n	213aa <noteOff+0x72>
   2145a:	bf00      	nop
   2145c:	2aaaaaab 	.word	0x2aaaaaab
   21460:	020e3138 	.word	0x020e3138
   21464:	020e3259 	.word	0x020e3259
   21468:	020fa15c 	.word	0x020fa15c
   2146c:	020fada0 	.word	0x020fada0
   21470:	020f8c94 	.word	0x020f8c94
   21474:	00000000 	.word	0x00000000
   21478:	020fa374 	.word	0x020fa374
   2147c:	020f9b34 	.word	0x020f9b34
   21480:	020fa164 	.word	0x020fa164
   21484:	020fa2d8 	.word	0x020fa2d8
   21488:	020f8550 	.word	0x020f8550
   2148c:	020fa048 	.word	0x020fa048

00021490 <noteOn>:
	if (!velocity)
   21490:	2900      	cmp	r1, #0
   21492:	d038      	beq.n	21506 <noteOn+0x76>
		chordArray[key%12]++;
   21494:	4a93      	ldr	r2, [pc, #588]	; (216e4 <noteOn+0x254>)
{
   21496:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2149a:	4604      	mov	r4, r0
   2149c:	460d      	mov	r5, r1
		chordArray[key%12]++;
   2149e:	17c3      	asrs	r3, r0, #31
   214a0:	4891      	ldr	r0, [pc, #580]	; (216e8 <noteOn+0x258>)
   214a2:	fb82 1204 	smull	r1, r2, r2, r4
		if (currentPreset == AutotuneMono)
   214a6:	4991      	ldr	r1, [pc, #580]	; (216ec <noteOn+0x25c>)
		chordArray[key%12]++;
   214a8:	ebc3 0362 	rsb	r3, r3, r2, asr #1
   214ac:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   214b0:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
{
   214b4:	ed2d 8b02 	vpush	{d8}
		chordArray[key%12]++;
   214b8:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
		if (currentPreset == AutotuneMono)
   214bc:	7809      	ldrb	r1, [r1, #0]
		chordArray[key%12]++;
   214be:	3201      	adds	r2, #1
		if (currentPreset == AutotuneMono)
   214c0:	2903      	cmp	r1, #3
		chordArray[key%12]++;
   214c2:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
		if (currentPreset == AutotuneMono)
   214c6:	d00f      	beq.n	214e8 <noteOn+0x58>
		if (currentPreset == Rhodes)
   214c8:	2911      	cmp	r1, #17
   214ca:	d039      	beq.n	21540 <noteOn+0xb0>
		else if (currentPreset == ClassicSynth)
   214cc:	2910      	cmp	r1, #16
   214ce:	d05e      	beq.n	2158e <noteOn+0xfe>
		else if (currentPreset == SamplerKeyboard)
   214d0:	2906      	cmp	r1, #6
   214d2:	d122      	bne.n	2151a <noteOn+0x8a>
			if ((key >= LOWEST_SAMPLER_KEY) && key < (LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS))
   214d4:	3c24      	subs	r4, #36	; 0x24
   214d6:	2c30      	cmp	r4, #48	; 0x30
   214d8:	d972      	bls.n	215c0 <noteOn+0x130>
		setLED_2(1);
   214da:	2001      	movs	r0, #1
}
   214dc:	ecbd 8b02 	vpop	{d8}
   214e0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		setLED_2(1);
   214e4:	f7f8 b81a 	b.w	1951c <setLED_2>
			if (autotuneLock)
   214e8:	4a81      	ldr	r2, [pc, #516]	; (216f0 <noteOn+0x260>)
   214ea:	6812      	ldr	r2, [r2, #0]
   214ec:	b96a      	cbnz	r2, 2150a <noteOn+0x7a>
   214ee:	b2ea      	uxtb	r2, r5
			tSimplePoly_noteOn(&poly, key, velocity);
   214f0:	4621      	mov	r1, r4
   214f2:	4880      	ldr	r0, [pc, #512]	; (216f4 <noteOn+0x264>)
   214f4:	f008 fdac 	bl	2a050 <tSimplePoly_noteOn>
		setLED_2(1);
   214f8:	2001      	movs	r0, #1
}
   214fa:	ecbd 8b02 	vpop	{d8}
   214fe:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		setLED_2(1);
   21502:	f7f8 b80b 	b.w	1951c <setLED_2>
		noteOff(key, velocity);
   21506:	f7ff bf17 	b.w	21338 <noteOff>
				lockArray[key%12]++;
   2150a:	487b      	ldr	r0, [pc, #492]	; (216f8 <noteOn+0x268>)
   2150c:	b2ea      	uxtb	r2, r5
   2150e:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
   21512:	3101      	adds	r1, #1
   21514:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
   21518:	e7ea      	b.n	214f0 <noteOn+0x60>
		else if (currentPreset == LivingStringSynth)
   2151a:	290f      	cmp	r1, #15
   2151c:	b2ea      	uxtb	r2, r5
   2151e:	d1e7      	bne.n	214f0 <noteOn+0x60>
			int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   21520:	4621      	mov	r1, r4
   21522:	4874      	ldr	r0, [pc, #464]	; (216f4 <noteOn+0x264>)
   21524:	f008 fd94 	bl	2a050 <tSimplePoly_noteOn>
			if (whichVoice >= 0)
   21528:	2800      	cmp	r0, #0
   2152a:	dbd6      	blt.n	214da <noteOn+0x4a>
				tADSR4_on(&pluckEnvs[whichVoice], velocity * 0.0078125f);
   2152c:	4b73      	ldr	r3, [pc, #460]	; (216fc <noteOn+0x26c>)
   2152e:	ee00 5a10 	vmov	s0, r5
   21532:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   21536:	eeba 0aec 	vcvt.f32.s32	s0, s0, #7
   2153a:	f006 f9bf 	bl	278bc <tADSR4_on>
   2153e:	e7cc      	b.n	214da <noteOn+0x4a>
			int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   21540:	b2ea      	uxtb	r2, r5
   21542:	4621      	mov	r1, r4
   21544:	486b      	ldr	r0, [pc, #428]	; (216f4 <noteOn+0x264>)
   21546:	f008 fd83 	bl	2a050 <tSimplePoly_noteOn>
			if (whichVoice >= 0)
   2154a:	1e07      	subs	r7, r0, #0
   2154c:	dbc5      	blt.n	214da <noteOn+0x4a>
   2154e:	eb07 0647 	add.w	r6, r7, r7, lsl #1
   21552:	4b6b      	ldr	r3, [pc, #428]	; (21700 <noteOn+0x270>)
					tADSR4_on(&FM_envs[whichVoice][j], velocity * 0.0078125f);
   21554:	ee08 5a10 	vmov	s16, r5
   21558:	00f2      	lsls	r2, r6, #3
   2155a:	f103 0618 	add.w	r6, r3, #24
   2155e:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
   21562:	18d5      	adds	r5, r2, r3
   21564:	4416      	add	r6, r2
   21566:	4628      	mov	r0, r5
   21568:	3504      	adds	r5, #4
   2156a:	eeb0 0a48 	vmov.f32	s0, s16
   2156e:	f006 f9a5 	bl	278bc <tADSR4_on>
				for (int j = 0; j < 6; j++)
   21572:	42ae      	cmp	r6, r5
   21574:	d1f7      	bne.n	21566 <noteOn+0xd6>
				panValues[whichVoice] = key * 0.0078125; // divide by 128.0f
   21576:	ee07 4a10 	vmov	s14, r4
   2157a:	eeba 7bec 	vcvt.f64.s32	d7, d7, #7
   2157e:	4b61      	ldr	r3, [pc, #388]	; (21704 <noteOn+0x274>)
   21580:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   21584:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
   21588:	ed87 7a00 	vstr	s14, [r7]
   2158c:	e7a5      	b.n	214da <noteOn+0x4a>
			int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
   2158e:	4621      	mov	r1, r4
   21590:	b2ea      	uxtb	r2, r5
   21592:	4858      	ldr	r0, [pc, #352]	; (216f4 <noteOn+0x264>)
   21594:	f008 fd5c 	bl	2a050 <tSimplePoly_noteOn>
			if (whichVoice >= 0)
   21598:	2800      	cmp	r0, #0
   2159a:	db9e      	blt.n	214da <noteOn+0x4a>
				tADSR4_on(&polyEnvs[whichVoice], velocity * 0.0078125f);
   2159c:	ee08 5a10 	vmov	s16, r5
   215a0:	0084      	lsls	r4, r0, #2
   215a2:	4859      	ldr	r0, [pc, #356]	; (21708 <noteOn+0x278>)
   215a4:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
   215a8:	4420      	add	r0, r4
   215aa:	eeb0 0a48 	vmov.f32	s0, s16
   215ae:	f006 f985 	bl	278bc <tADSR4_on>
				tADSR4_on(&polyFiltEnvs[whichVoice], velocity * 0.0078125f);
   215b2:	4856      	ldr	r0, [pc, #344]	; (2170c <noteOn+0x27c>)
   215b4:	eeb0 0a48 	vmov.f32	s0, s16
   215b8:	4420      	add	r0, r4
   215ba:	f006 f97f 	bl	278bc <tADSR4_on>
   215be:	e78c      	b.n	214da <noteOn+0x4a>
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   215c0:	4f53      	ldr	r7, [pc, #332]	; (21710 <noteOn+0x280>)
					currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   215c2:	4e54      	ldr	r6, [pc, #336]	; (21714 <noteOn+0x284>)
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   215c4:	eb07 0084 	add.w	r0, r7, r4, lsl #2
					currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
   215c8:	6034      	str	r4, [r6, #0]
					if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
   215ca:	f00a fbdb 	bl	2bd84 <tBuffer_getRecordedLength>
   215ce:	2800      	cmp	r0, #0
   215d0:	d06b      	beq.n	216aa <noteOn+0x21a>
						keySampler[currentSamplerKeyGlobal]->active = -1;
   215d2:	6832      	ldr	r2, [r6, #0]
   215d4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   215d8:	4c4f      	ldr	r4, [pc, #316]	; (21718 <noteOn+0x288>)
						tSampler_setStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   215da:	0090      	lsls	r0, r2, #2
   215dc:	4b4f      	ldr	r3, [pc, #316]	; (2171c <noteOn+0x28c>)
						keySampler[currentSamplerKeyGlobal]->active = -1;
   215de:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
						tSampler_setStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   215e2:	4403      	add	r3, r0
   215e4:	4420      	add	r0, r4
						keySampler[currentSamplerKeyGlobal]->active = -1;
   215e6:	6451      	str	r1, [r2, #68]	; 0x44
						tSampler_setStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   215e8:	edd3 7a00 	vldr	s15, [r3]
						tSampler_setLength(&keySampler[currentSamplerKeyGlobal], samplePlayLengths[currentSamplerKeyGlobal]);
   215ec:	f8df 8154 	ldr.w	r8, [pc, #340]	; 21744 <noteOn+0x2b4>
						tSampler_setStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   215f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
						if (newBuffer[currentSamplerKeyGlobal])
   215f4:	f8df 9148 	ldr.w	r9, [pc, #328]	; 21740 <noteOn+0x2b0>
						tSampler_setStart(&keySampler[currentSamplerKeyGlobal], samplePlayStarts[currentSamplerKeyGlobal]);
   215f8:	ee17 1a90 	vmov	r1, s15
   215fc:	f00a fcec 	bl	2bfd8 <tSampler_setStart>
						tSampler_setLength(&keySampler[currentSamplerKeyGlobal], samplePlayLengths[currentSamplerKeyGlobal]);
   21600:	6830      	ldr	r0, [r6, #0]
   21602:	0080      	lsls	r0, r0, #2
   21604:	eb08 0300 	add.w	r3, r8, r0
   21608:	4420      	add	r0, r4
   2160a:	edd3 7a00 	vldr	s15, [r3]
   2160e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   21612:	ee17 1a90 	vmov	r1, s15
   21616:	f00b f8ed 	bl	2c7f4 <tSampler_setLength>
						tSampler_setCrossfadeLength(&keySampler[currentSamplerKeyGlobal], crossfadeLengths[currentSamplerKeyGlobal]);
   2161a:	6830      	ldr	r0, [r6, #0]
   2161c:	4b40      	ldr	r3, [pc, #256]	; (21720 <noteOn+0x290>)
   2161e:	0080      	lsls	r0, r0, #2
   21620:	4403      	add	r3, r0
   21622:	4420      	add	r0, r4
   21624:	edd3 7a00 	vldr	s15, [r3]
   21628:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2162c:	ee17 1a90 	vmov	r1, s15
   21630:	f00a fc60 	bl	2bef4 <tSampler_setCrossfadeLength>
						tSampler_setRate(&keySampler[currentSamplerKeyGlobal], sampleRates[currentSamplerKeyGlobal] * sampleRatesMult[currentSamplerKeyGlobal]);
   21634:	6830      	ldr	r0, [r6, #0]
   21636:	4a3b      	ldr	r2, [pc, #236]	; (21724 <noteOn+0x294>)
   21638:	0080      	lsls	r0, r0, #2
   2163a:	4b3b      	ldr	r3, [pc, #236]	; (21728 <noteOn+0x298>)
   2163c:	4402      	add	r2, r0
   2163e:	4403      	add	r3, r0
   21640:	4420      	add	r0, r4
   21642:	edd3 7a00 	vldr	s15, [r3]
   21646:	ed92 0a00 	vldr	s0, [r2]
   2164a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2164e:	f00b f96b 	bl	2c928 <tSampler_setRate>
						tSampler_setMode(&keySampler[currentSamplerKeyGlobal], loopOns[currentSamplerKeyGlobal]);
   21652:	6833      	ldr	r3, [r6, #0]
   21654:	4a35      	ldr	r2, [pc, #212]	; (2172c <noteOn+0x29c>)
   21656:	eb04 0083 	add.w	r0, r4, r3, lsl #2
   2165a:	f812 1023 	ldrb.w	r1, [r2, r3, lsl #2]
   2165e:	f00a fc45 	bl	2beec <tSampler_setMode>
						tSampler_play(&keySampler[currentSamplerKeyGlobal]);
   21662:	6830      	ldr	r0, [r6, #0]
   21664:	eb04 0080 	add.w	r0, r4, r0, lsl #2
   21668:	f00a fc5a 	bl	2bf20 <tSampler_play>
						if (newBuffer[currentSamplerKeyGlobal])
   2166c:	6833      	ldr	r3, [r6, #0]
   2166e:	f859 2023 	ldr.w	r2, [r9, r3, lsl #2]
   21672:	bb2a      	cbnz	r2, 216c0 <noteOn+0x230>
   21674:	009a      	lsls	r2, r3, #2
						float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   21676:	4b2e      	ldr	r3, [pc, #184]	; (21730 <noteOn+0x2a0>)
   21678:	ee07 5a90 	vmov	s15, r5
   2167c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   21680:	eddf 6a2c 	vldr	s13, [pc, #176]	; 21734 <noteOn+0x2a4>
   21684:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   21688:	edd3 7a06 	vldr	s15, [r3, #24]
						tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   2168c:	482a      	ldr	r0, [pc, #168]	; (21738 <noteOn+0x2a8>)
						float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
   2168e:	ee30 0a67 	vsub.f32	s0, s0, s15
   21692:	ee67 7aa6 	vmul.f32	s15, s15, s13
						tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
   21696:	4410      	add	r0, r2
   21698:	eea7 0a27 	vfma.f32	s0, s14, s15
   2169c:	f006 fc60 	bl	27f60 <tExpSmooth_setDest>
   216a0:	6833      	ldr	r3, [r6, #0]
					samplerKeyHeld[currentSamplerKeyGlobal] = 1;
   216a2:	4a26      	ldr	r2, [pc, #152]	; (2173c <noteOn+0x2ac>)
   216a4:	2101      	movs	r1, #1
   216a6:	54d1      	strb	r1, [r2, r3]
   216a8:	e717      	b.n	214da <noteOn+0x4a>
						tBuffer_record(&keyBuff[currentSamplerKeyGlobal]);
   216aa:	6830      	ldr	r0, [r6, #0]
   216ac:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   216b0:	f00a fb52 	bl	2bd58 <tBuffer_record>
						newBuffer[currentSamplerKeyGlobal] = 1;
   216b4:	6833      	ldr	r3, [r6, #0]
   216b6:	4a22      	ldr	r2, [pc, #136]	; (21740 <noteOn+0x2b0>)
   216b8:	2101      	movs	r1, #1
   216ba:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   216be:	e7f0      	b.n	216a2 <noteOn+0x212>
							int recordLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]);
   216c0:	eb07 0083 	add.w	r0, r7, r3, lsl #2
   216c4:	f00a fb5e 	bl	2bd84 <tBuffer_getRecordedLength>
							samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   216c8:	6833      	ldr	r3, [r6, #0]
   216ca:	ee07 0a90 	vmov	s15, r0
							newBuffer[currentSamplerKeyGlobal] = 0;
   216ce:	2100      	movs	r1, #0
							samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   216d0:	009a      	lsls	r2, r3, #2
   216d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
							newBuffer[currentSamplerKeyGlobal] = 0;
   216d6:	f849 1023 	str.w	r1, [r9, r3, lsl #2]
							samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
   216da:	4490      	add	r8, r2
   216dc:	edc8 7a00 	vstr	s15, [r8]
   216e0:	e7c9      	b.n	21676 <noteOn+0x1e6>
   216e2:	bf00      	nop
   216e4:	2aaaaaab 	.word	0x2aaaaaab
   216e8:	020e3138 	.word	0x020e3138
   216ec:	020e3259 	.word	0x020e3259
   216f0:	020e3128 	.word	0x020e3128
   216f4:	020fa15c 	.word	0x020fa15c
   216f8:	020e31b0 	.word	0x020e31b0
   216fc:	020fa048 	.word	0x020fa048
   21700:	020fa164 	.word	0x020fa164
   21704:	020f8e24 	.word	0x020f8e24
   21708:	020fa2d8 	.word	0x020fa2d8
   2170c:	020f8550 	.word	0x020f8550
   21710:	020fada0 	.word	0x020fada0
   21714:	00062ab4 	.word	0x00062ab4
   21718:	020f9b34 	.word	0x020f9b34
   2171c:	020f9f84 	.word	0x020f9f84
   21720:	020fa3c4 	.word	0x020fa3c4
   21724:	020f8f70 	.word	0x020f8f70
   21728:	020fa48c 	.word	0x020fa48c
   2172c:	020f9254 	.word	0x020f9254
   21730:	020fb3cc 	.word	0x020fb3cc
   21734:	3c000000 	.word	0x3c000000
   21738:	020f8c94 	.word	0x020f8c94
   2173c:	020fa374 	.word	0x020fa374
   21740:	020f8d5c 	.word	0x020f8d5c
   21744:	020f8e88 	.word	0x020f8e88

00021748 <pitchBend>:


void pitchBend(int data)
{
	pitchBendValue = (data - 8192) * 0.000244140625f;
   21748:	f5a0 5300 	sub.w	r3, r0, #8192	; 0x2000
   2174c:	ee07 3a90 	vmov	s15, r3
   21750:	4b02      	ldr	r3, [pc, #8]	; (2175c <pitchBend+0x14>)
   21752:	eefa 7aca 	vcvt.f32.s32	s15, s15, #12
   21756:	edc3 7a00 	vstr	s15, [r3]
}
   2175a:	4770      	bx	lr
   2175c:	020e31e0 	.word	0x020e31e0

00021760 <sustainOff>:
   21760:	4770      	bx	lr
   21762:	bf00      	nop

00021764 <sustainOn>:
}

void sustainOn()
{

}
   21764:	4770      	bx	lr
   21766:	bf00      	nop

00021768 <ssd1306_begin>:
uint8_t OLED_i2c_address;
uint8_t OLED_externalVCC;
I2C_HandleTypeDef* OLED_i2c_handle;

void ssd1306_begin(I2C_HandleTypeDef* hi2c, uint8_t vccstate, uint8_t i2caddr)
{
   21768:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	OLED_i2c_address = i2caddr;
   2176c:	4ea9      	ldr	r6, [pc, #676]	; (21a14 <ssd1306_begin+0x2ac>)
{
   2176e:	4688      	mov	r8, r1
	OLED_externalVCC = vccstate;
	OLED_i2c_handle = hi2c;
   21770:	4da9      	ldr	r5, [pc, #676]	; (21a18 <ssd1306_begin+0x2b0>)
{
   21772:	b084      	sub	sp, #16
	OLED_externalVCC = vccstate;
   21774:	4ba9      	ldr	r3, [pc, #676]	; (21a1c <ssd1306_begin+0x2b4>)

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   21776:	f44f 7100 	mov.w	r1, #512	; 0x200
	OLED_i2c_address = i2caddr;
   2177a:	7032      	strb	r2, [r6, #0]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   2177c:	2201      	movs	r2, #1
	OLED_i2c_handle = hi2c;
   2177e:	6028      	str	r0, [r5, #0]

void ssd1306_command(uint8_t c) {
	// I2C
	//	uint8_t control = 0x00;   // Co = 0, D/C = 0

	uint8_t i2c_message[2] = {0,0};
   21780:	ac04      	add	r4, sp, #16
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   21782:	48a7      	ldr	r0, [pc, #668]	; (21a20 <ssd1306_begin+0x2b8>)
	i2c_message[1] = c;
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21784:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	OLED_externalVCC = vccstate;
   21788:	f883 8000 	strb.w	r8, [r3]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   2178c:	f7ea fd52 	bl	c234 <HAL_GPIO_WritePin>
	HAL_Delay(1);
   21790:	2001      	movs	r0, #1
   21792:	f7e6 fe35 	bl	8400 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
   21796:	2200      	movs	r2, #0
   21798:	f44f 7100 	mov.w	r1, #512	; 0x200
   2179c:	48a0      	ldr	r0, [pc, #640]	; (21a20 <ssd1306_begin+0x2b8>)
   2179e:	f7ea fd49 	bl	c234 <HAL_GPIO_WritePin>
	HAL_Delay(10);
   217a2:	200a      	movs	r0, #10
   217a4:	f7e6 fe2c 	bl	8400 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
   217a8:	2201      	movs	r2, #1
   217aa:	f44f 7100 	mov.w	r1, #512	; 0x200
   217ae:	489c      	ldr	r0, [pc, #624]	; (21a20 <ssd1306_begin+0x2b8>)
   217b0:	f7ea fd40 	bl	c234 <HAL_GPIO_WritePin>
	uint8_t i2c_message[2] = {0,0};
   217b4:	f44f 432e 	mov.w	r3, #44544	; 0xae00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217b8:	7831      	ldrb	r1, [r6, #0]
   217ba:	6828      	ldr	r0, [r5, #0]
   217bc:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   217be:	f824 3d04 	strh.w	r3, [r4, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217c2:	2302      	movs	r3, #2
   217c4:	4622      	mov	r2, r4
   217c6:	f7eb f857 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217ca:	f44f 4c55 	mov.w	ip, #54528	; 0xd500
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217ce:	7831      	ldrb	r1, [r6, #0]
   217d0:	4622      	mov	r2, r4
   217d2:	6828      	ldr	r0, [r5, #0]
   217d4:	2302      	movs	r3, #2
   217d6:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   217d8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217dc:	f7eb f84c 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217e0:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217e4:	7831      	ldrb	r1, [r6, #0]
   217e6:	6828      	ldr	r0, [r5, #0]
   217e8:	4622      	mov	r2, r4
   217ea:	9700      	str	r7, [sp, #0]
   217ec:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   217ee:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217f2:	f7eb f841 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   217f6:	f44f 4c28 	mov.w	ip, #43008	; 0xa800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   217fa:	7831      	ldrb	r1, [r6, #0]
   217fc:	6828      	ldr	r0, [r5, #0]
   217fe:	4622      	mov	r2, r4
   21800:	9700      	str	r7, [sp, #0]
   21802:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21804:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21808:	f7eb f836 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2180c:	f44f 5cf8 	mov.w	ip, #7936	; 0x1f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21810:	7831      	ldrb	r1, [r6, #0]
   21812:	6828      	ldr	r0, [r5, #0]
   21814:	4622      	mov	r2, r4
   21816:	9700      	str	r7, [sp, #0]
   21818:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2181a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2181e:	f7eb f82b 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21822:	f44f 4c53 	mov.w	ip, #54016	; 0xd300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21826:	7831      	ldrb	r1, [r6, #0]
   21828:	6828      	ldr	r0, [r5, #0]
   2182a:	4622      	mov	r2, r4
   2182c:	9700      	str	r7, [sp, #0]
   2182e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21830:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21834:	f7eb f820 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21838:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2183c:	7831      	ldrb	r1, [r6, #0]
   2183e:	6828      	ldr	r0, [r5, #0]
   21840:	4622      	mov	r2, r4
   21842:	9700      	str	r7, [sp, #0]
   21844:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21846:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2184a:	f7eb f815 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2184e:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21852:	7831      	ldrb	r1, [r6, #0]
   21854:	6828      	ldr	r0, [r5, #0]
   21856:	4622      	mov	r2, r4
   21858:	9700      	str	r7, [sp, #0]
   2185a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2185c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21860:	f7eb f80a 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21864:	f44f 4c0d 	mov.w	ip, #36096	; 0x8d00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21868:	7831      	ldrb	r1, [r6, #0]
   2186a:	6828      	ldr	r0, [r5, #0]
   2186c:	4622      	mov	r2, r4
   2186e:	9700      	str	r7, [sp, #0]
   21870:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21872:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21876:	f7ea ffff 	bl	c878 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
   2187a:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2187e:	6828      	ldr	r0, [r5, #0]
   21880:	7831      	ldrb	r1, [r6, #0]
   21882:	4622      	mov	r2, r4
	uint8_t i2c_message[2] = {0,0};
   21884:	bf0c      	ite	eq
   21886:	f44f 5c80 	moveq.w	ip, #4096	; 0x1000
   2188a:	f44f 5ca0 	movne.w	ip, #5120	; 0x1400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2188e:	9700      	str	r7, [sp, #0]
   21890:	2302      	movs	r3, #2
   21892:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   21896:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2189a:	f7ea ffed 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2189e:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218a2:	7831      	ldrb	r1, [r6, #0]
   218a4:	4622      	mov	r2, r4
   218a6:	6828      	ldr	r0, [r5, #0]
   218a8:	2302      	movs	r3, #2
   218aa:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   218ac:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218b0:	f7ea ffe2 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   218b4:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218b8:	7831      	ldrb	r1, [r6, #0]
   218ba:	6828      	ldr	r0, [r5, #0]
   218bc:	4622      	mov	r2, r4
   218be:	9700      	str	r7, [sp, #0]
   218c0:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   218c2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218c6:	f7ea ffd7 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   218ca:	f44f 4c21 	mov.w	ip, #41216	; 0xa100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218ce:	7831      	ldrb	r1, [r6, #0]
   218d0:	6828      	ldr	r0, [r5, #0]
   218d2:	4622      	mov	r2, r4
   218d4:	9700      	str	r7, [sp, #0]
   218d6:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   218d8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218dc:	f7ea ffcc 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   218e0:	f44f 4c48 	mov.w	ip, #51200	; 0xc800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218e4:	7831      	ldrb	r1, [r6, #0]
   218e6:	6828      	ldr	r0, [r5, #0]
   218e8:	4622      	mov	r2, r4
   218ea:	9700      	str	r7, [sp, #0]
   218ec:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   218ee:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218f2:	f7ea ffc1 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   218f6:	f44f 4c5a 	mov.w	ip, #55808	; 0xda00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   218fa:	7831      	ldrb	r1, [r6, #0]
   218fc:	6828      	ldr	r0, [r5, #0]
   218fe:	4622      	mov	r2, r4
   21900:	9700      	str	r7, [sp, #0]
   21902:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21904:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21908:	f7ea ffb6 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2190c:	f44f 7c00 	mov.w	ip, #512	; 0x200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21910:	7831      	ldrb	r1, [r6, #0]
   21912:	6828      	ldr	r0, [r5, #0]
   21914:	4622      	mov	r2, r4
   21916:	9700      	str	r7, [sp, #0]
   21918:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2191a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2191e:	f7ea ffab 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21922:	f44f 4c01 	mov.w	ip, #33024	; 0x8100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21926:	7831      	ldrb	r1, [r6, #0]
   21928:	6828      	ldr	r0, [r5, #0]
   2192a:	4622      	mov	r2, r4
   2192c:	9700      	str	r7, [sp, #0]
   2192e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21930:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21934:	f7ea ffa0 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21938:	f44f 4c0f 	mov.w	ip, #36608	; 0x8f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2193c:	7831      	ldrb	r1, [r6, #0]
   2193e:	6828      	ldr	r0, [r5, #0]
   21940:	4622      	mov	r2, r4
   21942:	9700      	str	r7, [sp, #0]
   21944:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21946:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2194a:	f7ea ff95 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2194e:	f44f 4c59 	mov.w	ip, #55552	; 0xd900
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21952:	7831      	ldrb	r1, [r6, #0]
   21954:	6828      	ldr	r0, [r5, #0]
   21956:	4622      	mov	r2, r4
   21958:	9700      	str	r7, [sp, #0]
   2195a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   2195c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21960:	f7ea ff8a 	bl	c878 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
   21964:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21968:	6828      	ldr	r0, [r5, #0]
   2196a:	7831      	ldrb	r1, [r6, #0]
   2196c:	4622      	mov	r2, r4
	uint8_t i2c_message[2] = {0,0};
   2196e:	bf0c      	ite	eq
   21970:	f44f 5c08 	moveq.w	ip, #8704	; 0x2200
   21974:	f44f 4c71 	movne.w	ip, #61696	; 0xf100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21978:	9700      	str	r7, [sp, #0]
   2197a:	2302      	movs	r3, #2
   2197c:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   21980:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21984:	f7ea ff78 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21988:	f44f 4c5b 	mov.w	ip, #56064	; 0xdb00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2198c:	7831      	ldrb	r1, [r6, #0]
   2198e:	4622      	mov	r2, r4
   21990:	6828      	ldr	r0, [r5, #0]
   21992:	2302      	movs	r3, #2
   21994:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21996:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   2199a:	f7ea ff6d 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   2199e:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219a2:	7831      	ldrb	r1, [r6, #0]
   219a4:	6828      	ldr	r0, [r5, #0]
   219a6:	4622      	mov	r2, r4
   219a8:	9700      	str	r7, [sp, #0]
   219aa:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   219ac:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219b0:	f7ea ff62 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   219b4:	f44f 4c24 	mov.w	ip, #41984	; 0xa400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219b8:	7831      	ldrb	r1, [r6, #0]
   219ba:	6828      	ldr	r0, [r5, #0]
   219bc:	4622      	mov	r2, r4
   219be:	9700      	str	r7, [sp, #0]
   219c0:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   219c2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219c6:	f7ea ff57 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   219ca:	f44f 4c26 	mov.w	ip, #42496	; 0xa600
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219ce:	7831      	ldrb	r1, [r6, #0]
   219d0:	6828      	ldr	r0, [r5, #0]
   219d2:	4622      	mov	r2, r4
   219d4:	9700      	str	r7, [sp, #0]
   219d6:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   219d8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219dc:	f7ea ff4c 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   219e0:	f44f 5c38 	mov.w	ip, #11776	; 0x2e00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219e4:	7831      	ldrb	r1, [r6, #0]
   219e6:	6828      	ldr	r0, [r5, #0]
   219e8:	4622      	mov	r2, r4
   219ea:	9700      	str	r7, [sp, #0]
   219ec:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   219ee:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   219f2:	f7ea ff41 	bl	c878 <HAL_I2C_Master_Transmit>
   219f6:	6828      	ldr	r0, [r5, #0]
   219f8:	4622      	mov	r2, r4
   219fa:	7831      	ldrb	r1, [r6, #0]
	uint8_t i2c_message[2] = {0,0};
   219fc:	f44f 452f 	mov.w	r5, #44800	; 0xaf00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a00:	2302      	movs	r3, #2
   21a02:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21a04:	f8ad 500c 	strh.w	r5, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a08:	f7ea ff36 	bl	c878 <HAL_I2C_Master_Transmit>
}
   21a0c:	b004      	add	sp, #16
   21a0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21a12:	bf00      	nop
   21a14:	020fb274 	.word	0x020fb274
   21a18:	020fb270 	.word	0x020fb270
   21a1c:	020fb26c 	.word	0x020fb26c
   21a20:	58020000 	.word	0x58020000

00021a24 <ssd1306_display_full_buffer>:
  ssd1306_command(contrast);
}



void ssd1306_display_full_buffer(void) {
   21a24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21a28:	b084      	sub	sp, #16
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a2a:	4e2d      	ldr	r6, [pc, #180]	; (21ae0 <ssd1306_display_full_buffer+0xbc>)
   21a2c:	4d2d      	ldr	r5, [pc, #180]	; (21ae4 <ssd1306_display_full_buffer+0xc0>)
   21a2e:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
   21a32:	ac04      	add	r4, sp, #16
   21a34:	f44f 5204 	mov.w	r2, #8448	; 0x2100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a38:	7831      	ldrb	r1, [r6, #0]
	uint8_t i2c_message[2] = {0,0};
   21a3a:	f04f 0800 	mov.w	r8, #0
   21a3e:	f824 2d04 	strh.w	r2, [r4, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a42:	2302      	movs	r3, #2
   21a44:	4622      	mov	r2, r4
   21a46:	6828      	ldr	r0, [r5, #0]
   21a48:	9700      	str	r7, [sp, #0]
   21a4a:	f7ea ff15 	bl	c878 <HAL_I2C_Master_Transmit>
   21a4e:	7831      	ldrb	r1, [r6, #0]
   21a50:	4622      	mov	r2, r4
   21a52:	6828      	ldr	r0, [r5, #0]
   21a54:	9700      	str	r7, [sp, #0]
   21a56:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21a58:	f8ad 800c 	strh.w	r8, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a5c:	f7ea ff0c 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21a60:	f44f 4cfe 	mov.w	ip, #32512	; 0x7f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a64:	7831      	ldrb	r1, [r6, #0]
   21a66:	4622      	mov	r2, r4
   21a68:	6828      	ldr	r0, [r5, #0]
   21a6a:	9700      	str	r7, [sp, #0]
   21a6c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21a6e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a72:	f7ea ff01 	bl	c878 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
   21a76:	f44f 5c08 	mov.w	ip, #8704	; 0x2200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a7a:	7831      	ldrb	r1, [r6, #0]
   21a7c:	4622      	mov	r2, r4
   21a7e:	6828      	ldr	r0, [r5, #0]
   21a80:	9700      	str	r7, [sp, #0]
   21a82:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
   21a84:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a88:	f7ea fef6 	bl	c878 <HAL_I2C_Master_Transmit>
   21a8c:	7831      	ldrb	r1, [r6, #0]
   21a8e:	4622      	mov	r2, r4
   21a90:	6828      	ldr	r0, [r5, #0]
   21a92:	2302      	movs	r3, #2
   21a94:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21a96:	f8ad 800c 	strh.w	r8, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21a9a:	f7ea feed 	bl	c878 <HAL_I2C_Master_Transmit>
//		HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17);
////		HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17, 2000);
////		HAL_Delay(1);
//		i--;
//	}
	displayBufferChunk[0] = 0x40;
   21a9e:	f8df 804c 	ldr.w	r8, [pc, #76]	; 21aec <ssd1306_display_full_buffer+0xc8>
	uint8_t i2c_message[2] = {0,0};
   21aa2:	f44f 7c40 	mov.w	ip, #768	; 0x300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21aa6:	7831      	ldrb	r1, [r6, #0]
   21aa8:	4622      	mov	r2, r4
   21aaa:	6828      	ldr	r0, [r5, #0]
   21aac:	2302      	movs	r3, #2
   21aae:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
   21ab0:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
   21ab4:	f7ea fee0 	bl	c878 <HAL_I2C_Master_Transmit>
	displayBufferChunk[0] = 0x40;
   21ab8:	4640      	mov	r0, r8
   21aba:	2340      	movs	r3, #64	; 0x40
   21abc:	f44f 7200 	mov.w	r2, #512	; 0x200
   21ac0:	4909      	ldr	r1, [pc, #36]	; (21ae8 <ssd1306_display_full_buffer+0xc4>)
   21ac2:	f800 3b01 	strb.w	r3, [r0], #1
   21ac6:	f00a ffb1 	bl	2ca2c <memcpy>
	for (int i = 0; i < 512; i++)
	{
		displayBufferChunk[i+1] = buffer[i];
	}
	HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 513);
   21aca:	4642      	mov	r2, r8
   21acc:	7831      	ldrb	r1, [r6, #0]
   21ace:	f240 2301 	movw	r3, #513	; 0x201
   21ad2:	6828      	ldr	r0, [r5, #0]
   21ad4:	f7ea fffa 	bl	cacc <HAL_I2C_Master_Transmit_DMA>
}
   21ad8:	b004      	add	sp, #16
   21ada:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21ade:	bf00      	nop
   21ae0:	020fb274 	.word	0x020fb274
   21ae4:	020fb270 	.word	0x020fb270
   21ae8:	020fb06c 	.word	0x020fb06c
   21aec:	020e2ea0 	.word	0x020e2ea0

00021af0 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
   21af0:	4b07      	ldr	r3, [pc, #28]	; (21b10 <HAL_MspInit+0x20>)
{
   21af2:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
   21af4:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
   21af8:	f042 0202 	orr.w	r2, r2, #2
   21afc:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
   21b00:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
   21b04:	f003 0302 	and.w	r3, r3, #2
   21b08:	9301      	str	r3, [sp, #4]
   21b0a:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
   21b0c:	b002      	add	sp, #8
   21b0e:	4770      	bx	lr
   21b10:	58024400 	.word	0x58024400

00021b14 <_exit>:
	errno = EINVAL;
	return -1;
}

void _exit (int status)
{
   21b14:	b508      	push	{r3, lr}
	errno = EINVAL;
   21b16:	f00a ff45 	bl	2c9a4 <__errno>
   21b1a:	2316      	movs	r3, #22
   21b1c:	6003      	str	r3, [r0, #0]
   21b1e:	e7fe      	b.n	21b1e <_exit+0xa>

00021b20 <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

/* TIM3 init function */
void MX_TIM3_Init(void)
{
   21b20:	b530      	push	{r4, r5, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  htim3.Instance = TIM3;
   21b22:	4c39      	ldr	r4, [pc, #228]	; (21c08 <MX_TIM3_Init+0xe8>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21b24:	2300      	movs	r3, #0
{
   21b26:	b093      	sub	sp, #76	; 0x4c
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1024;
   21b28:	f44f 6280 	mov.w	r2, #1024	; 0x400
  htim3.Instance = TIM3;
   21b2c:	4937      	ldr	r1, [pc, #220]	; (21c0c <MX_TIM3_Init+0xec>)
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   21b2e:	4620      	mov	r0, r4
  htim3.Init.Period = 1024;
   21b30:	60e2      	str	r2, [r4, #12]
  htim3.Instance = TIM3;
   21b32:	6021      	str	r1, [r4, #0]
  htim3.Init.Prescaler = 0;
   21b34:	6063      	str	r3, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21b36:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
   21b38:	930b      	str	r3, [sp, #44]	; 0x2c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
   21b3a:	60a3      	str	r3, [r4, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   21b3c:	6123      	str	r3, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   21b3e:	61a3      	str	r3, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21b40:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
   21b44:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
   21b48:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
   21b4c:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   21b50:	f7f0 fcc4 	bl	124dc <HAL_TIM_PWM_Init>
   21b54:	bb38      	cbnz	r0, 21ba6 <MX_TIM3_Init+0x86>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21b56:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   21b58:	a903      	add	r1, sp, #12
   21b5a:	482b      	ldr	r0, [pc, #172]	; (21c08 <MX_TIM3_Init+0xe8>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21b5c:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   21b5e:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   21b60:	f7f1 fcc2 	bl	134e8 <HAL_TIMEx_MasterConfigSynchronization>
   21b64:	b9e0      	cbnz	r0, 21ba0 <MX_TIM3_Init+0x80>
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
   21b66:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   21b68:	2560      	movs	r5, #96	; 0x60
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   21b6a:	a90b      	add	r1, sp, #44	; 0x2c
   21b6c:	2204      	movs	r2, #4
   21b6e:	4826      	ldr	r0, [pc, #152]	; (21c08 <MX_TIM3_Init+0xe8>)
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   21b70:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   21b72:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 0;
   21b74:	e9cd 530b 	strd	r5, r3, [sp, #44]	; 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   21b78:	f7f1 fa28 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21b7c:	b108      	cbz	r0, 21b82 <MX_TIM3_Init+0x62>
  {
    Error_Handler();
   21b7e:	f7f7 fc9d 	bl	194bc <Error_Handler>
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM3)
   21b82:	6822      	ldr	r2, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21b84:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
   21b86:	4921      	ldr	r1, [pc, #132]	; (21c0c <MX_TIM3_Init+0xec>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21b88:	930a      	str	r3, [sp, #40]	; 0x28
  if(timHandle->Instance==TIM3)
   21b8a:	428a      	cmp	r2, r1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21b8c:	e9cd 3306 	strd	r3, r3, [sp, #24]
   21b90:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if(timHandle->Instance==TIM3)
   21b94:	d021      	beq.n	21bda <MX_TIM3_Init+0xba>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
   21b96:	4b1e      	ldr	r3, [pc, #120]	; (21c10 <MX_TIM3_Init+0xf0>)
   21b98:	429a      	cmp	r2, r3
   21b9a:	d007      	beq.n	21bac <MX_TIM3_Init+0x8c>
}
   21b9c:	b013      	add	sp, #76	; 0x4c
   21b9e:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   21ba0:	f7f7 fc8c 	bl	194bc <Error_Handler>
   21ba4:	e7df      	b.n	21b66 <MX_TIM3_Init+0x46>
    Error_Handler();
   21ba6:	f7f7 fc89 	bl	194bc <Error_Handler>
   21baa:	e7d4      	b.n	21b56 <MX_TIM3_Init+0x36>
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bac:	4b19      	ldr	r3, [pc, #100]	; (21c14 <MX_TIM3_Init+0xf4>)
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bae:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21bb0:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bb4:	a906      	add	r1, sp, #24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bb6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bba:	4817      	ldr	r0, [pc, #92]	; (21c18 <MX_TIM3_Init+0xf8>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bbc:	4322      	orrs	r2, r4
   21bbe:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21bc2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21bc6:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bc8:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bca:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
   21bcc:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bce:	9302      	str	r3, [sp, #8]
   21bd0:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bd2:	f7e9 fff5 	bl	bbc0 <HAL_GPIO_Init>
}
   21bd6:	b013      	add	sp, #76	; 0x4c
   21bd8:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bda:	4b0e      	ldr	r3, [pc, #56]	; (21c14 <MX_TIM3_Init+0xf4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bdc:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21bde:	2520      	movs	r5, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21be0:	a906      	add	r1, sp, #24
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21be2:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21be6:	480c      	ldr	r0, [pc, #48]	; (21c18 <MX_TIM3_Init+0xf8>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21be8:	4322      	orrs	r2, r4
   21bea:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21bee:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21bf2:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bf4:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21bf6:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
   21bf8:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21bfa:	9301      	str	r3, [sp, #4]
   21bfc:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21bfe:	f7e9 ffdf 	bl	bbc0 <HAL_GPIO_Init>
}
   21c02:	b013      	add	sp, #76	; 0x4c
   21c04:	bd30      	pop	{r4, r5, pc}
   21c06:	bf00      	nop
   21c08:	020fb2b8 	.word	0x020fb2b8
   21c0c:	40000400 	.word	0x40000400
   21c10:	40000800 	.word	0x40000800
   21c14:	58024400 	.word	0x58024400
   21c18:	58020400 	.word	0x58020400

00021c1c <MX_TIM4_Init>:
{
   21c1c:	b530      	push	{r4, r5, lr}
  htim4.Instance = TIM4;
   21c1e:	4c4e      	ldr	r4, [pc, #312]	; (21d58 <MX_TIM4_Init+0x13c>)
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   21c20:	2300      	movs	r3, #0
{
   21c22:	b097      	sub	sp, #92	; 0x5c
  htim4.Init.Period = 1024;
   21c24:	f44f 6280 	mov.w	r2, #1024	; 0x400
  htim4.Instance = TIM4;
   21c28:	494c      	ldr	r1, [pc, #304]	; (21d5c <MX_TIM4_Init+0x140>)
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
   21c2a:	4620      	mov	r0, r4
  htim4.Init.Period = 1024;
   21c2c:	60e2      	str	r2, [r4, #12]
  htim4.Instance = TIM4;
   21c2e:	6021      	str	r1, [r4, #0]
  htim4.Init.Prescaler = 0;
   21c30:	6063      	str	r3, [r4, #4]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   21c32:	9306      	str	r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21c34:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
   21c36:	930f      	str	r3, [sp, #60]	; 0x3c
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
   21c38:	60a3      	str	r3, [r4, #8]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   21c3a:	6123      	str	r3, [r4, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   21c3c:	61a3      	str	r3, [r4, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
   21c3e:	9309      	str	r3, [sp, #36]	; 0x24
   21c40:	e9cd 3307 	strd	r3, r3, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
   21c44:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
   21c48:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
   21c4c:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
   21c50:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
   21c54:	f7f0 fb2c 	bl	122b0 <HAL_TIM_Base_Init>
   21c58:	2800      	cmp	r0, #0
   21c5a:	d14d      	bne.n	21cf8 <MX_TIM4_Init+0xdc>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   21c5c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   21c60:	a906      	add	r1, sp, #24
   21c62:	483d      	ldr	r0, [pc, #244]	; (21d58 <MX_TIM4_Init+0x13c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
   21c64:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
   21c66:	f7f0 fe39 	bl	128dc <HAL_TIM_ConfigClockSource>
   21c6a:	2800      	cmp	r0, #0
   21c6c:	d141      	bne.n	21cf2 <MX_TIM4_Init+0xd6>
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
   21c6e:	483a      	ldr	r0, [pc, #232]	; (21d58 <MX_TIM4_Init+0x13c>)
   21c70:	f7f0 fc34 	bl	124dc <HAL_TIM_PWM_Init>
   21c74:	2800      	cmp	r0, #0
   21c76:	d139      	bne.n	21cec <MX_TIM4_Init+0xd0>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21c78:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   21c7a:	a903      	add	r1, sp, #12
   21c7c:	4836      	ldr	r0, [pc, #216]	; (21d58 <MX_TIM4_Init+0x13c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   21c7e:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   21c80:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
   21c82:	f7f1 fc31 	bl	134e8 <HAL_TIMEx_MasterConfigSynchronization>
   21c86:	bb70      	cbnz	r0, 21ce6 <MX_TIM4_Init+0xca>
  sConfigOC.Pulse = 0;
   21c88:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   21c8a:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   21c8c:	a90f      	add	r1, sp, #60	; 0x3c
   21c8e:	4832      	ldr	r0, [pc, #200]	; (21d58 <MX_TIM4_Init+0x13c>)
   21c90:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
   21c92:	9310      	str	r3, [sp, #64]	; 0x40
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   21c94:	9311      	str	r3, [sp, #68]	; 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   21c96:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
   21c98:	950f      	str	r5, [sp, #60]	; 0x3c
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
   21c9a:	f7f1 f997 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21c9e:	b9f8      	cbnz	r0, 21ce0 <MX_TIM4_Init+0xc4>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   21ca0:	2204      	movs	r2, #4
   21ca2:	a90f      	add	r1, sp, #60	; 0x3c
   21ca4:	482c      	ldr	r0, [pc, #176]	; (21d58 <MX_TIM4_Init+0x13c>)
   21ca6:	f7f1 f991 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21caa:	b9b0      	cbnz	r0, 21cda <MX_TIM4_Init+0xbe>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
   21cac:	a90f      	add	r1, sp, #60	; 0x3c
   21cae:	2208      	movs	r2, #8
   21cb0:	4829      	ldr	r0, [pc, #164]	; (21d58 <MX_TIM4_Init+0x13c>)
   21cb2:	f7f1 f98b 	bl	12fcc <HAL_TIM_PWM_ConfigChannel>
   21cb6:	b108      	cbz	r0, 21cbc <MX_TIM4_Init+0xa0>
    Error_Handler();
   21cb8:	f7f7 fc00 	bl	194bc <Error_Handler>
  if(timHandle->Instance==TIM3)
   21cbc:	6822      	ldr	r2, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21cbe:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
   21cc0:	4927      	ldr	r1, [pc, #156]	; (21d60 <MX_TIM4_Init+0x144>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21cc2:	930e      	str	r3, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM3)
   21cc4:	428a      	cmp	r2, r1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   21cc6:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
   21cca:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if(timHandle->Instance==TIM3)
   21cce:	d02d      	beq.n	21d2c <MX_TIM4_Init+0x110>
  else if(timHandle->Instance==TIM4)
   21cd0:	4b22      	ldr	r3, [pc, #136]	; (21d5c <MX_TIM4_Init+0x140>)
   21cd2:	429a      	cmp	r2, r3
   21cd4:	d013      	beq.n	21cfe <MX_TIM4_Init+0xe2>
}
   21cd6:	b017      	add	sp, #92	; 0x5c
   21cd8:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
   21cda:	f7f7 fbef 	bl	194bc <Error_Handler>
   21cde:	e7e5      	b.n	21cac <MX_TIM4_Init+0x90>
    Error_Handler();
   21ce0:	f7f7 fbec 	bl	194bc <Error_Handler>
   21ce4:	e7dc      	b.n	21ca0 <MX_TIM4_Init+0x84>
    Error_Handler();
   21ce6:	f7f7 fbe9 	bl	194bc <Error_Handler>
   21cea:	e7cd      	b.n	21c88 <MX_TIM4_Init+0x6c>
    Error_Handler();
   21cec:	f7f7 fbe6 	bl	194bc <Error_Handler>
   21cf0:	e7c2      	b.n	21c78 <MX_TIM4_Init+0x5c>
    Error_Handler();
   21cf2:	f7f7 fbe3 	bl	194bc <Error_Handler>
   21cf6:	e7ba      	b.n	21c6e <MX_TIM4_Init+0x52>
    Error_Handler();
   21cf8:	f7f7 fbe0 	bl	194bc <Error_Handler>
   21cfc:	e7ae      	b.n	21c5c <MX_TIM4_Init+0x40>
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21cfe:	4b19      	ldr	r3, [pc, #100]	; (21d64 <MX_TIM4_Init+0x148>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21d00:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21d02:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21d06:	a90a      	add	r1, sp, #40	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d08:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21d0c:	4816      	ldr	r0, [pc, #88]	; (21d68 <MX_TIM4_Init+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d0e:	4322      	orrs	r2, r4
   21d10:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21d14:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
   21d18:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d1a:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21d1c:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
   21d1e:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d20:	9302      	str	r3, [sp, #8]
   21d22:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21d24:	f7e9 ff4c 	bl	bbc0 <HAL_GPIO_Init>
}
   21d28:	b017      	add	sp, #92	; 0x5c
   21d2a:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d2c:	4b0d      	ldr	r3, [pc, #52]	; (21d64 <MX_TIM4_Init+0x148>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21d2e:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21d30:	2520      	movs	r5, #32
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21d32:	a90a      	add	r1, sp, #40	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d34:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21d38:	480b      	ldr	r0, [pc, #44]	; (21d68 <MX_TIM4_Init+0x14c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d3a:	4322      	orrs	r2, r4
   21d3c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   21d40:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
   21d44:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d46:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   21d48:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
   21d4a:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
   21d4c:	9301      	str	r3, [sp, #4]
   21d4e:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   21d50:	f7e9 ff36 	bl	bbc0 <HAL_GPIO_Init>
}
   21d54:	b017      	add	sp, #92	; 0x5c
   21d56:	bd30      	pop	{r4, r5, pc}
   21d58:	020fb278 	.word	0x020fb278
   21d5c:	40000800 	.word	0x40000800
   21d60:	40000400 	.word	0x40000400
   21d64:	58024400 	.word	0x58024400
   21d68:	58020400 	.word	0x58020400

00021d6c <HAL_TIM_PWM_MspInit>:
  if(tim_pwmHandle->Instance==TIM3)
   21d6c:	6802      	ldr	r2, [r0, #0]
   21d6e:	4b0a      	ldr	r3, [pc, #40]	; (21d98 <HAL_TIM_PWM_MspInit+0x2c>)
   21d70:	429a      	cmp	r2, r3
   21d72:	d000      	beq.n	21d76 <HAL_TIM_PWM_MspInit+0xa>
   21d74:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_ENABLE();
   21d76:	4b09      	ldr	r3, [pc, #36]	; (21d9c <HAL_TIM_PWM_MspInit+0x30>)
{
   21d78:	b082      	sub	sp, #8
    __HAL_RCC_TIM3_CLK_ENABLE();
   21d7a:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   21d7e:	f042 0202 	orr.w	r2, r2, #2
   21d82:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
   21d86:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
   21d8a:	f003 0302 	and.w	r3, r3, #2
   21d8e:	9301      	str	r3, [sp, #4]
   21d90:	9b01      	ldr	r3, [sp, #4]
}
   21d92:	b002      	add	sp, #8
   21d94:	4770      	bx	lr
   21d96:	bf00      	nop
   21d98:	40000400 	.word	0x40000400
   21d9c:	58024400 	.word	0x58024400

00021da0 <HAL_TIM_Base_MspInit>:
  if(tim_baseHandle->Instance==TIM4)
   21da0:	6802      	ldr	r2, [r0, #0]
   21da2:	4b0a      	ldr	r3, [pc, #40]	; (21dcc <HAL_TIM_Base_MspInit+0x2c>)
   21da4:	429a      	cmp	r2, r3
   21da6:	d000      	beq.n	21daa <HAL_TIM_Base_MspInit+0xa>
   21da8:	4770      	bx	lr
    __HAL_RCC_TIM4_CLK_ENABLE();
   21daa:	4b09      	ldr	r3, [pc, #36]	; (21dd0 <HAL_TIM_Base_MspInit+0x30>)
{
   21dac:	b082      	sub	sp, #8
    __HAL_RCC_TIM4_CLK_ENABLE();
   21dae:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
   21db2:	f042 0204 	orr.w	r2, r2, #4
   21db6:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
   21dba:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
   21dbe:	f003 0304 	and.w	r3, r3, #4
   21dc2:	9301      	str	r3, [sp, #4]
   21dc4:	9b01      	ldr	r3, [sp, #4]
}
   21dc6:	b002      	add	sp, #8
   21dc8:	4770      	bx	lr
   21dca:	bf00      	nop
   21dcc:	40000800 	.word	0x40000800
   21dd0:	58024400 	.word	0x58024400

00021dd4 <initModeNames>:
VocodecPresetType currentPreset = 0;
VocodecPresetType previousPreset = PresetNil;
uint8_t loadingPreset = 0;

void initModeNames(void)
{
   21dd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21dd8:	4ad2      	ldr	r2, [pc, #840]	; (22124 <initModeNames+0x350>)
   21dda:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
	for (int i = 0; i < NUM_ADC_CHANNELS; i++)
	{
		floatADCUI[i] = -1.0f;
		orderedParams[i] = i;
   21dde:	4cd2      	ldr	r4, [pc, #840]	; (22128 <initModeNames+0x354>)
	}
	orderedParams[6] = ButtonA;
	orderedParams[7] = ButtonB;
   21de0:	f04f 0906 	mov.w	r9, #6
		floatADCUI[i] = -1.0f;
   21de4:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
		cvAddParam[i] = -1;
	}

	modeNames[Vocoder] = "VOCODER1";
	shortModeNames[Vocoder] = "VL";
	modeNamesDetails[Vocoder] = "LPC";
   21de8:	f8df b45c 	ldr.w	fp, [pc, #1116]	; 22248 <initModeNames+0x474>
		floatADCUI[i] = -1.0f;
   21dec:	4bcf      	ldr	r3, [pc, #828]	; (2212c <initModeNames+0x358>)
	orderedParams[7] = ButtonB;
   21dee:	f884 9007 	strb.w	r9, [r4, #7]
		orderedParams[i] = i;
   21df2:	f04f 0904 	mov.w	r9, #4
   21df6:	6017      	str	r7, [r2, #0]
   21df8:	6057      	str	r7, [r2, #4]
   21dfa:	6097      	str	r7, [r2, #8]
   21dfc:	60d7      	str	r7, [r2, #12]
   21dfe:	8217      	strh	r7, [r2, #16]
   21e00:	f8df e448 	ldr.w	lr, [pc, #1096]	; 2224c <initModeNames+0x478>
	modeNamesDetails[Vocoder] = "LPC";
   21e04:	4aca      	ldr	r2, [pc, #808]	; (22130 <initModeNames+0x35c>)
		floatADCUI[i] = -1.0f;
   21e06:	edc3 7a00 	vstr	s15, [r3]
   21e0a:	edc3 7a01 	vstr	s15, [r3, #4]
   21e0e:	edc3 7a02 	vstr	s15, [r3, #8]
   21e12:	edc3 7a03 	vstr	s15, [r3, #12]
   21e16:	edc3 7a04 	vstr	s15, [r3, #16]
   21e1a:	edc3 7a05 	vstr	s15, [r3, #20]
		orderedParams[i] = i;
   21e1e:	f8c4 e000 	str.w	lr, [r4]
	numPages[Vocoder] = 2;
	knobParamNames[Vocoder][0] = "VOLUME";
   21e22:	4bc4      	ldr	r3, [pc, #784]	; (22134 <initModeNames+0x360>)
	knobParamNames[Vocoder][1] = "WARP";
   21e24:	f8df e428 	ldr.w	lr, [pc, #1064]	; 22250 <initModeNames+0x47c>
		orderedParams[i] = i;
   21e28:	f884 9004 	strb.w	r9, [r4, #4]
   21e2c:	f04f 0905 	mov.w	r9, #5
	modeNamesDetails[Vocoder] = "LPC";
   21e30:	f8cb 2000 	str.w	r2, [fp]
	knobParamNames[Vocoder][0] = "VOLUME";
   21e34:	4ac0      	ldr	r2, [pc, #768]	; (22138 <initModeNames+0x364>)
		orderedParams[i] = i;
   21e36:	f884 9005 	strb.w	r9, [r4, #5]
	orderedParams[6] = ButtonA;
   21e3a:	f884 9006 	strb.w	r9, [r4, #6]
	knobParamNames[Vocoder][2] = "QUALITY";
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   21e3e:	4cbf      	ldr	r4, [pc, #764]	; (2213c <initModeNames+0x368>)
	modeNames[Vocoder] = "VOCODER1";
   21e40:	f8df 8410 	ldr.w	r8, [pc, #1040]	; 22254 <initModeNames+0x480>
   21e44:	f8df a410 	ldr.w	sl, [pc, #1040]	; 22258 <initModeNames+0x484>
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
	knobParamNames[Vocoder][8] = "PULSESHAPE";
	knobParamNames[Vocoder][9] = "";


	modeNames[VocoderCh] = "VOCODER2";
   21e48:	4dbd      	ldr	r5, [pc, #756]	; (22140 <initModeNames+0x36c>)
	shortModeNames[Vocoder] = "VL";
   21e4a:	f8df c410 	ldr.w	ip, [pc, #1040]	; 2225c <initModeNames+0x488>
   21e4e:	48bd      	ldr	r0, [pc, #756]	; (22144 <initModeNames+0x370>)
	shortModeNames[VocoderCh] = "VC";
   21e50:	49bd      	ldr	r1, [pc, #756]	; (22148 <initModeNames+0x374>)
	knobParamNames[Vocoder][4] = "NOISTHRESH";
   21e52:	4fbe      	ldr	r7, [pc, #760]	; (2214c <initModeNames+0x378>)
	shortModeNames[Vocoder] = "VL";
   21e54:	f8cc 0000 	str.w	r0, [ip]
	shortModeNames[VocoderCh] = "VC";
   21e58:	f8cc 1004 	str.w	r1, [ip, #4]
	knobParamNames[Vocoder][8] = "PULSESHAPE";
   21e5c:	48bc      	ldr	r0, [pc, #752]	; (22150 <initModeNames+0x37c>)
	knobParamNames[Vocoder][9] = "";
   21e5e:	49bd      	ldr	r1, [pc, #756]	; (22154 <initModeNames+0x380>)
	modeNamesDetails[VocoderCh] = "CHANNEL";
   21e60:	4ebd      	ldr	r6, [pc, #756]	; (22158 <initModeNames+0x384>)
	knobParamNames[Vocoder][4] = "NOISTHRESH";
   21e62:	611f      	str	r7, [r3, #16]
	modeNamesDetails[VocoderCh] = "CHANNEL";
   21e64:	f8cb 6004 	str.w	r6, [fp, #4]
	knobParamNames[VocoderCh][11] = "BANDOFF";
	knobParamNames[VocoderCh][12] = "TILT";
	knobParamNames[VocoderCh][13] = "STEREO";
	knobParamNames[VocoderCh][14] = "BARKPULL";

	modeNames[Pitchshift] = "PITCHSHIFT";
   21e68:	f8df 93f4 	ldr.w	r9, [pc, #1012]	; 22260 <initModeNames+0x48c>
	knobParamNames[VocoderCh][10] = "BANDSQUISH";
   21e6c:	4ebb      	ldr	r6, [pc, #748]	; (2215c <initModeNames+0x388>)
	knobParamNames[Vocoder][1] = "WARP";
   21e6e:	e9c3 2e00 	strd	r2, lr, [r3]
	knobParamNames[Vocoder][2] = "QUALITY";
   21e72:	4abb      	ldr	r2, [pc, #748]	; (22160 <initModeNames+0x38c>)
	knobParamNames[Vocoder][3] = "SAWtoPULSE";
   21e74:	e9c3 2402 	strd	r2, r4, [r3, #8]
	knobParamNames[Vocoder][5] = "BREATH";
   21e78:	4aba      	ldr	r2, [pc, #744]	; (22164 <initModeNames+0x390>)
	modeNames[VocoderCh] = "VOCODER2";
   21e7a:	e9c8 a500 	strd	sl, r5, [r8]
	knobParamNames[Vocoder][5] = "BREATH";
   21e7e:	615a      	str	r2, [r3, #20]
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
   21e80:	4db9      	ldr	r5, [pc, #740]	; (22168 <initModeNames+0x394>)
	knobParamNames[Vocoder][6] = "TILT";
   21e82:	4aba      	ldr	r2, [pc, #744]	; (2216c <initModeNames+0x398>)
	knobParamNames[VocoderCh][3] = "BANDWIDTH";
   21e84:	f8df a3dc 	ldr.w	sl, [pc, #988]	; 22264 <initModeNames+0x490>
	knobParamNames[Vocoder][7] = "PULSEWIDTH";
   21e88:	e9c3 2506 	strd	r2, r5, [r3, #24]
	knobParamNames[VocoderCh][0] = "VOLUME";
   21e8c:	4aaa      	ldr	r2, [pc, #680]	; (22138 <initModeNames+0x364>)
	knobParamNames[Vocoder][9] = "";
   21e8e:	e9c3 0108 	strd	r0, r1, [r3, #32]
	knobParamNames[VocoderCh][1] = "WARP";
   21e92:	e9c3 2e19 	strd	r2, lr, [r3, #100]	; 0x64
	knobParamNames[VocoderCh][2] = "QUALITY";
   21e96:	4ab2      	ldr	r2, [pc, #712]	; (22160 <initModeNames+0x38c>)
	knobParamNames[VocoderCh][5] = "SAWtoPULSE";
   21e98:	679c      	str	r4, [r3, #120]	; 0x78
	knobParamNames[VocoderCh][2] = "QUALITY";
   21e9a:	66da      	str	r2, [r3, #108]	; 0x6c
	knobParamNames[VocoderCh][14] = "BARKPULL";
   21e9c:	4cb4      	ldr	r4, [pc, #720]	; (22170 <initModeNames+0x39c>)
	knobParamNames[VocoderCh][7] = "PULSESHAPE";
   21e9e:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
	knobParamNames[VocoderCh][8] = "BREATH";
   21ea2:	4ab0      	ldr	r2, [pc, #704]	; (22164 <initModeNames+0x390>)
	knobParamNames[VocoderCh][12] = "TILT";
   21ea4:	48b1      	ldr	r0, [pc, #708]	; (2216c <initModeNames+0x398>)
	modeNames[Pitchshift] = "PITCHSHIFT";
   21ea6:	f8c8 9008 	str.w	r9, [r8, #8]
	knobParamNames[VocoderCh][4] = "NOISTHRESH";
   21eaa:	675f      	str	r7, [r3, #116]	; 0x74
	knobParamNames[VocoderCh][11] = "BANDOFF";
   21eac:	f8df e3b8 	ldr.w	lr, [pc, #952]	; 22268 <initModeNames+0x494>
	knobParamNames[VocoderCh][6] = "PULSEWIDTH";
   21eb0:	67dd      	str	r5, [r3, #124]	; 0x7c
	shortModeNames[Pitchshift] = "PS";
   21eb2:	4fb0      	ldr	r7, [pc, #704]	; (22174 <initModeNames+0x3a0>)
	modeNamesDetails[Pitchshift] = "";
	numPages[Pitchshift] = 2;
	knobParamNames[Pitchshift][0] = "SHIFT";
   21eb4:	4db0      	ldr	r5, [pc, #704]	; (22178 <initModeNames+0x3a4>)
	knobParamNames[VocoderCh][8] = "BREATH";
   21eb6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	knobParamNames[VocoderCh][12] = "TILT";
   21eba:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	knobParamNames[Pitchshift][1] = "FINE";
   21ebe:	4aaf      	ldr	r2, [pc, #700]	; (2217c <initModeNames+0x3a8>)
	knobParamNames[Pitchshift][2] = "F AMT";
   21ec0:	f8df 93a8 	ldr.w	r9, [pc, #936]	; 2226c <initModeNames+0x498>
	knobParamNames[Pitchshift][3] = "FORMANT";
   21ec4:	48ae      	ldr	r0, [pc, #696]	; (22180 <initModeNames+0x3ac>)
	knobParamNames[VocoderCh][10] = "BANDSQUISH";
   21ec6:	f8c3 608c 	str.w	r6, [r3, #140]	; 0x8c
	knobParamNames[VocoderCh][14] = "BARKPULL";
   21eca:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
	knobParamNames[Pitchshift][4] = "RANGE";
   21ece:	4ead      	ldr	r6, [pc, #692]	; (22184 <initModeNames+0x3b0>)
	knobParamNames[Pitchshift][6] = "";
	knobParamNames[Pitchshift][7] = "";
	knobParamNames[Pitchshift][8] = "";
	knobParamNames[Pitchshift][9] = "";

	modeNames[AutotuneMono] = "AUTOTUNE";
   21ed0:	4cad      	ldr	r4, [pc, #692]	; (22188 <initModeNames+0x3b4>)
	shortModeNames[Pitchshift] = "PS";
   21ed2:	f8cc 7008 	str.w	r7, [ip, #8]
	modeNames[AutotuneMono] = "AUTOTUNE";
   21ed6:	f8c8 400c 	str.w	r4, [r8, #12]
	knobParamNames[VocoderCh][11] = "BANDOFF";
   21eda:	f8c3 e090 	str.w	lr, [r3, #144]	; 0x90
	shortModeNames[AutotuneMono] = "NT";
   21ede:	4fab      	ldr	r7, [pc, #684]	; (2218c <initModeNames+0x3b8>)
	knobParamNames[Pitchshift][5] = "OFFSET";
   21ee0:	f8df e38c 	ldr.w	lr, [pc, #908]	; 22270 <initModeNames+0x49c>
	knobParamNames[Pitchshift][0] = "SHIFT";
   21ee4:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
	knobParamNames[Pitchshift][1] = "FINE";
   21ee8:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
	modeNamesDetails[AutotuneMono] = "";
	numPages[AutotuneMono] = 1;
	knobParamNames[AutotuneMono][0] = "PICKINESS";
	knobParamNames[AutotuneMono][1] = "AMOUNT";
   21eec:	4da8      	ldr	r5, [pc, #672]	; (22190 <initModeNames+0x3bc>)
	knobParamNames[VocoderCh][9] = "SPEED";
   21eee:	4aa9      	ldr	r2, [pc, #676]	; (22194 <initModeNames+0x3c0>)
	knobParamNames[Pitchshift][4] = "RANGE";
   21ef0:	f8c3 60d8 	str.w	r6, [r3, #216]	; 0xd8
	knobParamNames[VocoderCh][13] = "STEREO";
   21ef4:	4ca8      	ldr	r4, [pc, #672]	; (22198 <initModeNames+0x3c4>)
	knobParamNames[AutotuneMono][2] = "SPEED";
	knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   21ef6:	4ea9      	ldr	r6, [pc, #676]	; (2219c <initModeNames+0x3c8>)
	modeNamesDetails[Pitchshift] = "";
   21ef8:	f8cb 1008 	str.w	r1, [fp, #8]
	modeNamesDetails[AutotuneMono] = "";
   21efc:	f8cb 100c 	str.w	r1, [fp, #12]
	shortModeNames[AutotuneMono] = "NT";
   21f00:	f8cc 700c 	str.w	r7, [ip, #12]
	knobParamNames[VocoderCh][3] = "BANDWIDTH";
   21f04:	f8c3 a070 	str.w	sl, [r3, #112]	; 0x70
	knobParamNames[Pitchshift][5] = "OFFSET";
   21f08:	f8c3 e0dc 	str.w	lr, [r3, #220]	; 0xdc
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";


	modeNames[AutotunePoly] = "HARMONIZE";
	shortModeNames[AutotunePoly] = "AT";
   21f0c:	4fa4      	ldr	r7, [pc, #656]	; (221a0 <initModeNames+0x3cc>)
	knobParamNames[AutotuneMono][1] = "AMOUNT";
   21f0e:	f8c3 5130 	str.w	r5, [r3, #304]	; 0x130
	knobParamNames[VocoderCh][9] = "SPEED";
   21f12:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	knobParamNames[AutotunePoly][2] = "";
	knobParamNames[AutotunePoly][3] = "";
	knobParamNames[AutotunePoly][4] = "";


	modeNames[SamplerButtonPress] = "SAMPLER BP";
   21f16:	4da3      	ldr	r5, [pc, #652]	; (221a4 <initModeNames+0x3d0>)
	knobParamNames[VocoderCh][13] = "STEREO";
   21f18:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
	shortModeNames[SamplerButtonPress] = "SB";
   21f1c:	f8df e354 	ldr.w	lr, [pc, #852]	; 22274 <initModeNames+0x4a0>
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";



	modeNames[SamplerKeyboard] = "KEYSAMPLER";
	shortModeNames[SamplerKeyboard] = "KS";
   21f20:	4ca1      	ldr	r4, [pc, #644]	; (221a8 <initModeNames+0x3d4>)
	modeNames[AutotunePoly] = "HARMONIZE";
   21f22:	f8df a354 	ldr.w	sl, [pc, #852]	; 22278 <initModeNames+0x4a4>
	knobParamNames[Pitchshift][3] = "FORMANT";
   21f26:	e9c3 9034 	strd	r9, r0, [r3, #208]	; 0xd0
	knobParamNames[AutotuneMono][0] = "PICKINESS";
   21f2a:	48a0      	ldr	r0, [pc, #640]	; (221ac <initModeNames+0x3d8>)
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   21f2c:	f8df 934c 	ldr.w	r9, [pc, #844]	; 2227c <initModeNames+0x4a8>
	knobParamNames[Pitchshift][7] = "";
   21f30:	e9c3 1138 	strd	r1, r1, [r3, #224]	; 0xe0
	knobParamNames[Pitchshift][9] = "";
   21f34:	e9c3 113a 	strd	r1, r1, [r3, #232]	; 0xe8
	knobParamNames[AutotuneMono][0] = "PICKINESS";
   21f38:	f8c3 012c 	str.w	r0, [r3, #300]	; 0x12c
	knobParamNames[AutotuneMono][3] = "LEAPALLOW";
   21f3c:	f8c3 6138 	str.w	r6, [r3, #312]	; 0x138
	modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   21f40:	4e9b      	ldr	r6, [pc, #620]	; (221b0 <initModeNames+0x3dc>)
	shortModeNames[AutotunePoly] = "AT";
   21f42:	f8cc 7010 	str.w	r7, [ip, #16]
	modeNames[SamplerButtonPress] = "SAMPLER BP";
   21f46:	f8c8 5014 	str.w	r5, [r8, #20]
	modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
   21f4a:	f8cb 6014 	str.w	r6, [fp, #20]
	knobParamNames[AutotunePoly][0] = "PICKINESS";
   21f4e:	f8c3 0190 	str.w	r0, [r3, #400]	; 0x190
	modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   21f52:	4f98      	ldr	r7, [pc, #608]	; (221b4 <initModeNames+0x3e0>)
	modeNames[SamplerKeyboard] = "KEYSAMPLER";
   21f54:	4898      	ldr	r0, [pc, #608]	; (221b8 <initModeNames+0x3e4>)
	numPages[SamplerKeyboard] = 2;
	knobParamNames[SamplerKeyboard][0] = "START";
	knobParamNames[SamplerKeyboard][1] = "LENGTH";
	knobParamNames[SamplerKeyboard][2] = "SPEED";
	knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
	knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   21f56:	4d99      	ldr	r5, [pc, #612]	; (221bc <initModeNames+0x3e8>)
	knobParamNames[SamplerKeyboard][7] = "";
	knobParamNames[SamplerKeyboard][8] = "";
	knobParamNames[SamplerKeyboard][9] = "";


	modeNames[SamplerAutoGrab] = "AUTOSAMP";
   21f58:	4e99      	ldr	r6, [pc, #612]	; (221c0 <initModeNames+0x3ec>)
	shortModeNames[SamplerButtonPress] = "SB";
   21f5a:	f8cc e014 	str.w	lr, [ip, #20]
	modeNames[SamplerKeyboard] = "KEYSAMPLER";
   21f5e:	f8c8 0018 	str.w	r0, [r8, #24]
	shortModeNames[SamplerKeyboard] = "KS";
   21f62:	f8cc 4018 	str.w	r4, [ip, #24]
	knobParamNames[SamplerButtonPress][0] = "START";
   21f66:	4897      	ldr	r0, [pc, #604]	; (221c4 <initModeNames+0x3f0>)
	knobParamNames[SamplerButtonPress][1] = "LENGTH";
   21f68:	4c97      	ldr	r4, [pc, #604]	; (221c8 <initModeNames+0x3f4>)
	modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
   21f6a:	f8cb 7018 	str.w	r7, [fp, #24]
	modeNames[SamplerAutoGrab] = "AUTOSAMP";
   21f6e:	f8c8 601c 	str.w	r6, [r8, #28]
	knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   21f72:	4f96      	ldr	r7, [pc, #600]	; (221cc <initModeNames+0x3f8>)
	knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   21f74:	f8df e308 	ldr.w	lr, [pc, #776]	; 22280 <initModeNames+0x4ac>
	knobParamNames[SamplerKeyboard][4] = "LOOP ON";
   21f78:	f8c3 5268 	str.w	r5, [r3, #616]	; 0x268
	shortModeNames[SamplerAutoGrab] = "AS";
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
	numPages[SamplerAutoGrab] = 2;
	knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   21f7c:	4e94      	ldr	r6, [pc, #592]	; (221d0 <initModeNames+0x3fc>)
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   21f7e:	4d95      	ldr	r5, [pc, #596]	; (221d4 <initModeNames+0x400>)
	modeNamesDetails[AutotunePoly] = "";
   21f80:	f8cb 1010 	str.w	r1, [fp, #16]
	modeNames[AutotunePoly] = "HARMONIZE";
   21f84:	f8c8 a010 	str.w	sl, [r8, #16]
	knobParamNames[AutotuneMono][2] = "SPEED";
   21f88:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
	knobParamNames[AutotunePoly][1] = "";
   21f8c:	f8c3 1194 	str.w	r1, [r3, #404]	; 0x194
	knobParamNames[AutotunePoly][2] = "";
   21f90:	f8c3 1198 	str.w	r1, [r3, #408]	; 0x198
	knobParamNames[AutotunePoly][3] = "";
   21f94:	f8c3 119c 	str.w	r1, [r3, #412]	; 0x19c
	knobParamNames[AutotunePoly][4] = "";
   21f98:	f8c3 11a0 	str.w	r1, [r3, #416]	; 0x1a0
	knobParamNames[SamplerButtonPress][2] = "SPEED";
   21f9c:	f8c3 21fc 	str.w	r2, [r3, #508]	; 0x1fc
	knobParamNames[SamplerKeyboard][2] = "SPEED";
   21fa0:	f8c3 2260 	str.w	r2, [r3, #608]	; 0x260
	knobParamNames[SamplerKeyboard][7] = "";
   21fa4:	f8c3 1274 	str.w	r1, [r3, #628]	; 0x274
	knobParamNames[SamplerKeyboard][8] = "";
   21fa8:	f8c3 1278 	str.w	r1, [r3, #632]	; 0x278
	knobParamNames[SamplerKeyboard][9] = "";
   21fac:	f8c3 127c 	str.w	r1, [r3, #636]	; 0x27c
	knobParamNames[AutotuneMono][4] = "HYSTERESIS";
   21fb0:	f8c3 913c 	str.w	r9, [r3, #316]	; 0x13c
	knobParamNames[SamplerKeyboard][6] = "VELO SENS";
   21fb4:	f8c3 e270 	str.w	lr, [r3, #624]	; 0x270
	shortModeNames[SamplerAutoGrab] = "AS";
   21fb8:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 22284 <initModeNames+0x4b0>
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   21fbc:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 22288 <initModeNames+0x4b4>
	knobParamNames[SamplerButtonPress][0] = "START";
   21fc0:	f8c3 01f4 	str.w	r0, [r3, #500]	; 0x1f4
	knobParamNames[SamplerKeyboard][0] = "START";
   21fc4:	f8c3 0258 	str.w	r0, [r3, #600]	; 0x258
	knobParamNames[SamplerButtonPress][1] = "LENGTH";
   21fc8:	f8c3 41f8 	str.w	r4, [r3, #504]	; 0x1f8
	knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   21fcc:	4882      	ldr	r0, [pc, #520]	; (221d8 <initModeNames+0x404>)
	knobParamNames[SamplerKeyboard][1] = "LENGTH";
   21fce:	f8c3 425c 	str.w	r4, [r3, #604]	; 0x25c
	knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
   21fd2:	f8c3 7200 	str.w	r7, [r3, #512]	; 0x200
	knobParamNames[SamplerAutoGrab][2] = "SPEED";
	knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
	knobParamNames[SamplerAutoGrab][4] = "";
	knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   21fd6:	4c81      	ldr	r4, [pc, #516]	; (221dc <initModeNames+0x408>)
	knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
   21fd8:	f8c3 7264 	str.w	r7, [r3, #612]	; 0x264
	knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
   21fdc:	f8c3 5204 	str.w	r5, [r3, #516]	; 0x204
	knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
   21fe0:	f8c3 526c 	str.w	r5, [r3, #620]	; 0x26c
	knobParamNames[SamplerAutoGrab][2] = "SPEED";
   21fe4:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
	knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
   21fe8:	f8c3 52c8 	str.w	r5, [r3, #712]	; 0x2c8

	modeNames[BitCrusher] = "BITCRUSH";
	shortModeNames[BitCrusher] = "BC";
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
	numPages[BitCrusher] = 2;
	knobParamNames[BitCrusher][0] = "QUALITY";
   21fec:	4a5c      	ldr	r2, [pc, #368]	; (22160 <initModeNames+0x38c>)
	knobParamNames[Distortion][1] = "TILT";
   21fee:	4d5f      	ldr	r5, [pc, #380]	; (2216c <initModeNames+0x398>)
	knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
   21ff0:	f8c3 62bc 	str.w	r6, [r3, #700]	; 0x2bc
	modeNames[Wavefolder] = "WAVEFOLD";
   21ff4:	4e7a      	ldr	r6, [pc, #488]	; (221e0 <initModeNames+0x40c>)
	shortModeNames[SamplerAutoGrab] = "AS";
   21ff6:	f8cc 901c 	str.w	r9, [ip, #28]
	modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
   21ffa:	f8cb a01c 	str.w	sl, [fp, #28]
	modeNames[Wavefolder] = "WAVEFOLD";
   21ffe:	f8c8 6024 	str.w	r6, [r8, #36]	; 0x24
	knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   22002:	f8df e288 	ldr.w	lr, [pc, #648]	; 2228c <initModeNames+0x4b8>
	modeNames[Distortion] = "DISTORT";
   22006:	f8df 9288 	ldr.w	r9, [pc, #648]	; 22290 <initModeNames+0x4bc>
	shortModeNames[Distortion] = "DT";
   2200a:	4f76      	ldr	r7, [pc, #472]	; (221e4 <initModeNames+0x410>)
	knobParamNames[Distortion][1] = "TILT";
   2200c:	f8c3 5324 	str.w	r5, [r3, #804]	; 0x324
	knobParamNames[BitCrusher][0] = "QUALITY";
   22010:	f8c3 23e8 	str.w	r2, [r3, #1000]	; 0x3e8
	modeNamesDetails[Distortion] = "WITH EQ";
   22014:	4d74      	ldr	r5, [pc, #464]	; (221e8 <initModeNames+0x414>)
	knobParamNames[Distortion][2] = "MID GAIN";
   22016:	4a75      	ldr	r2, [pc, #468]	; (221ec <initModeNames+0x418>)
	knobParamNames[Distortion][3] = "MID FREQ";
   22018:	f8df a278 	ldr.w	sl, [pc, #632]	; 22294 <initModeNames+0x4c0>
	knobParamNames[SamplerAutoGrab][1] = "WINDOW";
   2201c:	f8c3 02c0 	str.w	r0, [r3, #704]	; 0x2c0
	knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
   22020:	f8c3 42d0 	str.w	r4, [r3, #720]	; 0x2d0
	shortModeNames[Wavefolder] = "WF";
   22024:	4872      	ldr	r0, [pc, #456]	; (221f0 <initModeNames+0x41c>)
	modeNamesDetails[Wavefolder] = "SERGE STYLE";
   22026:	4c73      	ldr	r4, [pc, #460]	; (221f4 <initModeNames+0x420>)
	knobParamNames[BitCrusher][1] = "SAMP RATIO";
   22028:	4e73      	ldr	r6, [pc, #460]	; (221f8 <initModeNames+0x424>)
	modeNames[Distortion] = "DISTORT";
   2202a:	f8c8 9020 	str.w	r9, [r8, #32]
	shortModeNames[Distortion] = "DT";
   2202e:	f8cc 7020 	str.w	r7, [ip, #32]
	modeNamesDetails[Distortion] = "WITH EQ";
   22032:	f8cb 5020 	str.w	r5, [fp, #32]
	shortModeNames[Wavefolder] = "WF";
   22036:	f8cc 0024 	str.w	r0, [ip, #36]	; 0x24
	modeNamesDetails[Wavefolder] = "SERGE STYLE";
   2203a:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
	knobParamNames[Distortion][0] = "PRE GAIN";
   2203e:	486f      	ldr	r0, [pc, #444]	; (221fc <initModeNames+0x428>)
	knobParamNames[Distortion][4] = "POST GAIN";
   22040:	4c6f      	ldr	r4, [pc, #444]	; (22200 <initModeNames+0x42c>)
	knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
   22042:	f8c3 e2d4 	str.w	lr, [r3, #724]	; 0x2d4
	knobParamNames[Wavefolder][1] = "OFFSET1";
   22046:	f8df 9250 	ldr.w	r9, [pc, #592]	; 22298 <initModeNames+0x4c4>
	knobParamNames[Wavefolder][0] = "GAIN";
   2204a:	f8df e250 	ldr.w	lr, [pc, #592]	; 2229c <initModeNames+0x4c8>
	knobParamNames[Wavefolder][2] = "OFFSET2";
   2204e:	4f6d      	ldr	r7, [pc, #436]	; (22204 <initModeNames+0x430>)
	modeNames[BitCrusher] = "BITCRUSH";
   22050:	4d6d      	ldr	r5, [pc, #436]	; (22208 <initModeNames+0x434>)
	knobParamNames[Distortion][2] = "MID GAIN";
   22052:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328
	knobParamNames[Distortion][3] = "MID FREQ";
   22056:	f8c3 a32c 	str.w	sl, [r3, #812]	; 0x32c
	shortModeNames[BitCrusher] = "BC";
   2205a:	4a6c      	ldr	r2, [pc, #432]	; (2220c <initModeNames+0x438>)
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
   2205c:	f8df a240 	ldr.w	sl, [pc, #576]	; 222a0 <initModeNames+0x4cc>
	knobParamNames[BitCrusher][1] = "SAMP RATIO";
   22060:	f8c3 63ec 	str.w	r6, [r3, #1004]	; 0x3ec
	knobParamNames[BitCrusher][8] = "";
	knobParamNames[BitCrusher][9] = "";

	modeNames[Delay] = "DELAY";
	shortModeNames[Delay] = "DL";
	modeNamesDetails[Delay] = "STEREO";
   22064:	4e4c      	ldr	r6, [pc, #304]	; (22198 <initModeNames+0x3c4>)
	modeNames[BitCrusher] = "BITCRUSH";
   22066:	f8c8 5028 	str.w	r5, [r8, #40]	; 0x28
	shortModeNames[BitCrusher] = "BC";
   2206a:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
	modeNamesDetails[BitCrusher] = "AHH HALP ME";
   2206e:	f8cb a028 	str.w	sl, [fp, #40]	; 0x28
	knobParamNames[SamplerAutoGrab][4] = "";
   22072:	f8c3 12cc 	str.w	r1, [r3, #716]	; 0x2cc
	knobParamNames[SamplerAutoGrab][7] = "";
   22076:	f8c3 12d8 	str.w	r1, [r3, #728]	; 0x2d8
	knobParamNames[SamplerAutoGrab][8] = "";
   2207a:	f8c3 12dc 	str.w	r1, [r3, #732]	; 0x2dc
	knobParamNames[SamplerAutoGrab][9] = "";
   2207e:	f8c3 12e0 	str.w	r1, [r3, #736]	; 0x2e0
	knobParamNames[Wavefolder][4] = "";
   22082:	f8c3 1394 	str.w	r1, [r3, #916]	; 0x394
	knobParamNames[Wavefolder][0] = "GAIN";
   22086:	f8c3 e384 	str.w	lr, [r3, #900]	; 0x384
	knobParamNames[Wavefolder][1] = "OFFSET1";
   2208a:	f8c3 9388 	str.w	r9, [r3, #904]	; 0x388
	knobParamNames[Wavefolder][2] = "OFFSET2";
   2208e:	f8c3 738c 	str.w	r7, [r3, #908]	; 0x38c
	knobParamNames[Distortion][0] = "PRE GAIN";
   22092:	f8c3 0320 	str.w	r0, [r3, #800]	; 0x320
	knobParamNames[Distortion][4] = "POST GAIN";
   22096:	f8c3 4330 	str.w	r4, [r3, #816]	; 0x330
	knobParamNames[Wavefolder][3] = "POST GAIN";
   2209a:	f8c3 4390 	str.w	r4, [r3, #912]	; 0x390
	modeNamesDetails[Delay] = "STEREO";
   2209e:	f8cb 602c 	str.w	r6, [fp, #44]	; 0x2c
	knobParamNames[BitCrusher][4] = "POST GAIN";
   220a2:	f8c3 43f8 	str.w	r4, [r3, #1016]	; 0x3f8
	knobParamNames[Delay][0] = "DELAY_L";
	knobParamNames[Delay][1] = "DELAY_R";
	knobParamNames[Delay][2] = "HIGHPASS";
	knobParamNames[Delay][3] = "LOWPASS";
	knobParamNames[Delay][4] = "FEEDBACK";
	knobParamNames[Delay][5] = "POST GAIN";
   220a6:	f8c3 4460 	str.w	r4, [r3, #1120]	; 0x460
	knobParamNames[Delay][6] = "POST GAIN";
   220aa:	f8c3 4464 	str.w	r4, [r3, #1124]	; 0x464
	knobParamNames[Delay][7] = "POST GAIN";
   220ae:	f8c3 4468 	str.w	r4, [r3, #1128]	; 0x468
	knobParamNames[Delay][8] = "POST GAIN";
   220b2:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
	knobParamNames[Delay][1] = "DELAY_R";
   220b6:	4e56      	ldr	r6, [pc, #344]	; (22210 <initModeNames+0x43c>)
	numPages[Reverb] = 1;
	knobParamNames[Reverb][0] = "SIZE";
	knobParamNames[Reverb][1] = "FB LOPASS";
	knobParamNames[Reverb][2] = "IN HIPASS";
	knobParamNames[Reverb][3] = "IN LOPASS";
	knobParamNames[Reverb][4] = "FB GAIN";
   220b8:	4c56      	ldr	r4, [pc, #344]	; (22214 <initModeNames+0x440>)
	knobParamNames[BitCrusher][2] = "ROUNDING";
   220ba:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 222a4 <initModeNames+0x4d0>
	knobParamNames[BitCrusher][3] = "OPERATION";
   220be:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 222a8 <initModeNames+0x4d4>
	modeNames[Delay] = "DELAY";
   220c2:	4f55      	ldr	r7, [pc, #340]	; (22218 <initModeNames+0x444>)
	shortModeNames[Delay] = "DL";
   220c4:	4d55      	ldr	r5, [pc, #340]	; (2221c <initModeNames+0x448>)
	knobParamNames[Delay][0] = "DELAY_L";
   220c6:	4a56      	ldr	r2, [pc, #344]	; (22220 <initModeNames+0x44c>)
	knobParamNames[BitCrusher][5] = "PRE GAIN";
   220c8:	f8c3 03fc 	str.w	r0, [r3, #1020]	; 0x3fc
	knobParamNames[Delay][1] = "DELAY_R";
   220cc:	f8c3 6450 	str.w	r6, [r3, #1104]	; 0x450
	knobParamNames[Reverb][2] = "IN HIPASS";
   220d0:	4854      	ldr	r0, [pc, #336]	; (22224 <initModeNames+0x450>)
	knobParamNames[Reverb][1] = "FB LOPASS";
   220d2:	4e55      	ldr	r6, [pc, #340]	; (22228 <initModeNames+0x454>)
	knobParamNames[Reverb][4] = "FB GAIN";
   220d4:	f8c3 44c0 	str.w	r4, [r3, #1216]	; 0x4c0
	knobParamNames[Delay][3] = "LOWPASS";
   220d8:	4c54      	ldr	r4, [pc, #336]	; (2222c <initModeNames+0x458>)
	modeNames[Delay] = "DELAY";
   220da:	f8c8 702c 	str.w	r7, [r8, #44]	; 0x2c
	shortModeNames[Delay] = "DL";
   220de:	f8cc 502c 	str.w	r5, [ip, #44]	; 0x2c
	modeNames[Reverb] = "REVERB1";
   220e2:	f8df a1c8 	ldr.w	sl, [pc, #456]	; 222ac <initModeNames+0x4d8>
	knobParamNames[BitCrusher][2] = "ROUNDING";
   220e6:	f8c3 e3f0 	str.w	lr, [r3, #1008]	; 0x3f0
	knobParamNames[BitCrusher][3] = "OPERATION";
   220ea:	f8c3 93f4 	str.w	r9, [r3, #1012]	; 0x3f4
	knobParamNames[Reverb][3] = "IN LOPASS";
   220ee:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 222b0 <initModeNames+0x4dc>
	modeNamesDetails[Reverb] = "DATTORRO ALG";
   220f2:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 222b4 <initModeNames+0x4e0>


	modeNames[Reverb2] = "REVERB2";
   220f6:	4f4e      	ldr	r7, [pc, #312]	; (22230 <initModeNames+0x45c>)
	shortModeNames[Reverb2] = "RV";
	modeNamesDetails[Reverb2] = "NREVERB ALG";
   220f8:	4d4e      	ldr	r5, [pc, #312]	; (22234 <initModeNames+0x460>)
	knobParamNames[Delay][0] = "DELAY_L";
   220fa:	f8c3 244c 	str.w	r2, [r3, #1100]	; 0x44c
	knobParamNames[Reverb][1] = "FB LOPASS";
   220fe:	f8c3 64b4 	str.w	r6, [r3, #1204]	; 0x4b4
	knobParamNames[Delay][2] = "HIGHPASS";
   22102:	4a4d      	ldr	r2, [pc, #308]	; (22238 <initModeNames+0x464>)
	shortModeNames[Reverb] = "RV";
   22104:	4e4d      	ldr	r6, [pc, #308]	; (2223c <initModeNames+0x468>)
	knobParamNames[Reverb][2] = "IN HIPASS";
   22106:	f8c3 04b8 	str.w	r0, [r3, #1208]	; 0x4b8
	knobParamNames[Delay][3] = "LOWPASS";
   2210a:	f8c3 4458 	str.w	r4, [r3, #1112]	; 0x458
	knobParamNames[Reverb][0] = "SIZE";
   2210e:	484c      	ldr	r0, [pc, #304]	; (22240 <initModeNames+0x46c>)
	knobParamNames[Delay][4] = "FEEDBACK";
   22110:	4c4c      	ldr	r4, [pc, #304]	; (22244 <initModeNames+0x470>)
	modeNames[Reverb] = "REVERB1";
   22112:	f8c8 a030 	str.w	sl, [r8, #48]	; 0x30
	modeNamesDetails[Reverb] = "DATTORRO ALG";
   22116:	f8cb 9030 	str.w	r9, [fp, #48]	; 0x30
	modeNames[Reverb2] = "REVERB2";
   2211a:	f8c8 7034 	str.w	r7, [r8, #52]	; 0x34
	modeNamesDetails[Reverb2] = "NREVERB ALG";
   2211e:	f8cb 5034 	str.w	r5, [fp, #52]	; 0x34
   22122:	e0c9      	b.n	222b8 <initModeNames+0x4e4>
   22124:	020fb540 	.word	0x020fb540
   22128:	020fb390 	.word	0x020fb390
   2212c:	020fb444 	.word	0x020fb444
   22130:	00032130 	.word	0x00032130
   22134:	020fb56c 	.word	0x020fb56c
   22138:	00032134 	.word	0x00032134
   2213c:	0003214c 	.word	0x0003214c
   22140:	0003218c 	.word	0x0003218c
   22144:	0003212c 	.word	0x0003212c
   22148:	00032198 	.word	0x00032198
   2214c:	00032158 	.word	0x00032158
   22150:	00032180 	.word	0x00032180
   22154:	0003209c 	.word	0x0003209c
   22158:	0003219c 	.word	0x0003219c
   2215c:	000321b8 	.word	0x000321b8
   22160:	00032144 	.word	0x00032144
   22164:	00032164 	.word	0x00032164
   22168:	00032174 	.word	0x00032174
   2216c:	0003216c 	.word	0x0003216c
   22170:	000321d4 	.word	0x000321d4
   22174:	000321ec 	.word	0x000321ec
   22178:	000321f0 	.word	0x000321f0
   2217c:	000321f8 	.word	0x000321f8
   22180:	00032208 	.word	0x00032208
   22184:	00032210 	.word	0x00032210
   22188:	00032220 	.word	0x00032220
   2218c:	0003223c 	.word	0x0003223c
   22190:	00032238 	.word	0x00032238
   22194:	000321b0 	.word	0x000321b0
   22198:	000321cc 	.word	0x000321cc
   2219c:	00032240 	.word	0x00032240
   221a0:	00032264 	.word	0x00032264
   221a4:	00032268 	.word	0x00032268
   221a8:	000322bc 	.word	0x000322bc
   221ac:	0003222c 	.word	0x0003222c
   221b0:	00032278 	.word	0x00032278
   221b4:	000322c0 	.word	0x000322c0
   221b8:	000322b0 	.word	0x000322b0
   221bc:	000322cc 	.word	0x000322cc
   221c0:	000322e0 	.word	0x000322e0
   221c4:	00032288 	.word	0x00032288
   221c8:	00032290 	.word	0x00032290
   221cc:	00032298 	.word	0x00032298
   221d0:	00032300 	.word	0x00032300
   221d4:	000322a4 	.word	0x000322a4
   221d8:	0003230c 	.word	0x0003230c
   221dc:	00032314 	.word	0x00032314
   221e0:	00032370 	.word	0x00032370
   221e4:	00032334 	.word	0x00032334
   221e8:	00032338 	.word	0x00032338
   221ec:	0003234c 	.word	0x0003234c
   221f0:	0003237c 	.word	0x0003237c
   221f4:	00032380 	.word	0x00032380
   221f8:	000323b8 	.word	0x000323b8
   221fc:	00032340 	.word	0x00032340
   22200:	00032364 	.word	0x00032364
   22204:	00032394 	.word	0x00032394
   22208:	0003239c 	.word	0x0003239c
   2220c:	000323a8 	.word	0x000323a8
   22210:	000323f0 	.word	0x000323f0
   22214:	00032460 	.word	0x00032460
   22218:	000323dc 	.word	0x000323dc
   2221c:	000323e4 	.word	0x000323e4
   22220:	000323e8 	.word	0x000323e8
   22224:	00032448 	.word	0x00032448
   22228:	0003243c 	.word	0x0003243c
   2222c:	00032404 	.word	0x00032404
   22230:	00032468 	.word	0x00032468
   22234:	00032470 	.word	0x00032470
   22238:	000323f8 	.word	0x000323f8
   2223c:	00032420 	.word	0x00032420
   22240:	00032434 	.word	0x00032434
   22244:	0003240c 	.word	0x0003240c
   22248:	020fb4f8 	.word	0x020fb4f8
   2224c:	03020100 	.word	0x03020100
   22250:	0003213c 	.word	0x0003213c
   22254:	020fb348 	.word	0x020fb348
   22258:	00032120 	.word	0x00032120
   2225c:	020fb488 	.word	0x020fb488
   22260:	000321e0 	.word	0x000321e0
   22264:	000321a4 	.word	0x000321a4
   22268:	000321c4 	.word	0x000321c4
   2226c:	00032200 	.word	0x00032200
   22270:	00032218 	.word	0x00032218
   22274:	00032274 	.word	0x00032274
   22278:	00032258 	.word	0x00032258
   2227c:	0003224c 	.word	0x0003224c
   22280:	000322d4 	.word	0x000322d4
   22284:	000322ec 	.word	0x000322ec
   22288:	000322f0 	.word	0x000322f0
   2228c:	00032320 	.word	0x00032320
   22290:	0003232c 	.word	0x0003232c
   22294:	00032358 	.word	0x00032358
   22298:	0003238c 	.word	0x0003238c
   2229c:	00032350 	.word	0x00032350
   222a0:	000323ac 	.word	0x000323ac
   222a4:	000323c4 	.word	0x000323c4
   222a8:	000323d0 	.word	0x000323d0
   222ac:	00032418 	.word	0x00032418
   222b0:	00032454 	.word	0x00032454
   222b4:	00032424 	.word	0x00032424
	knobParamNames[BitCrusher][6] = "";
   222b8:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
	knobParamNames[BitCrusher][7] = "";
   222bc:	f8c3 1404 	str.w	r1, [r3, #1028]	; 0x404
	knobParamNames[BitCrusher][8] = "";
   222c0:	f8c3 1408 	str.w	r1, [r3, #1032]	; 0x408
	knobParamNames[BitCrusher][9] = "";
   222c4:	f8c3 140c 	str.w	r1, [r3, #1036]	; 0x40c
	knobParamNames[Delay][9] = "";
   222c8:	f8c3 1470 	str.w	r1, [r3, #1136]	; 0x470
	knobParamNames[Reverb][3] = "IN LOPASS";
   222cc:	f8c3 e4bc 	str.w	lr, [r3, #1212]	; 0x4bc
	knobParamNames[Delay][2] = "HIGHPASS";
   222d0:	f8c3 2454 	str.w	r2, [r3, #1108]	; 0x454
	knobParamNames[Delay][4] = "FEEDBACK";
   222d4:	f8c3 445c 	str.w	r4, [r3, #1116]	; 0x45c
	knobParamNames[Reverb][0] = "SIZE";
   222d8:	f8c3 04b0 	str.w	r0, [r3, #1200]	; 0x4b0
	numPages[Reverb2] = 1;
	knobParamNames[Reverb2][0] = "SIZE";
	knobParamNames[Reverb2][1] = "LOWPASS";
	knobParamNames[Reverb2][2] = "HIGHPASS";
	knobParamNames[Reverb2][3] = "PEAK_FREQ";
   222dc:	f8df e2fc 	ldr.w	lr, [pc, #764]	; 225dc <initModeNames+0x808>

	modeNames[LivingString] = "STRING1";
	shortModeNames[LivingString] = "LS";
	modeNamesDetails[LivingString] = "SYMP STRING";
	numPages[LivingString] = 3;
	knobParamNames[LivingString][0] = "FREQ1";
   222e0:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 225e0 <initModeNames+0x80c>
	knobParamNames[LivingString][5] = "PREP POS";
	knobParamNames[LivingString][6] = "PREP FORCE";
	knobParamNames[LivingString][7] = "LET RING";
	knobParamNames[LivingString][8] = "";
	knobParamNames[LivingString][9] = "";
	knobParamNames[LivingString][10] = "FREQ2";
   222e4:	4f8d      	ldr	r7, [pc, #564]	; (2251c <initModeNames+0x748>)
	knobParamNames[LivingString][11] = "FREQ3";
   222e6:	4d8e      	ldr	r5, [pc, #568]	; (22520 <initModeNames+0x74c>)
	knobParamNames[Reverb2][1] = "LOWPASS";
   222e8:	4c8e      	ldr	r4, [pc, #568]	; (22524 <initModeNames+0x750>)
	knobParamNames[LivingString][12] = "FREQ4";
   222ea:	f8df a2f8 	ldr.w	sl, [pc, #760]	; 225e4 <initModeNames+0x810>
	shortModeNames[Reverb2] = "RV";
   222ee:	e9cc 660c 	strd	r6, r6, [ip, #48]	; 0x30
	knobParamNames[Reverb2][0] = "SIZE";
   222f2:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	knobParamNames[Reverb2][2] = "HIGHPASS";
   222f6:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
	knobParamNames[Reverb2][4] = "PEAK_GAIN";
   222fa:	4a8b      	ldr	r2, [pc, #556]	; (22528 <initModeNames+0x754>)
	knobParamNames[Reverb2][3] = "PEAK_FREQ";
   222fc:	f8c3 e520 	str.w	lr, [r3, #1312]	; 0x520
	knobParamNames[Reverb2][4] = "PEAK_GAIN";
   22300:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	knobParamNames[LivingString][4] = "PICK POS";
   22304:	4a89      	ldr	r2, [pc, #548]	; (2252c <initModeNames+0x758>)
	knobParamNames[LivingString][13] = "FREQ5";
	knobParamNames[LivingString][14] = "FREQ6";
   22306:	f8df e2e0 	ldr.w	lr, [pc, #736]	; 225e8 <initModeNames+0x814>
	knobParamNames[LivingString][4] = "PICK POS";
   2230a:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
	modeNames[LivingString] = "STRING1";
   2230e:	4a88      	ldr	r2, [pc, #544]	; (22530 <initModeNames+0x75c>)
	knobParamNames[LivingString][13] = "FREQ5";
   22310:	4e88      	ldr	r6, [pc, #544]	; (22534 <initModeNames+0x760>)
	modeNames[LivingString] = "STRING1";
   22312:	f8c8 2038 	str.w	r2, [r8, #56]	; 0x38
	knobParamNames[LivingString][14] = "FREQ6";
   22316:	f8c3 e5b0 	str.w	lr, [r3, #1456]	; 0x5b0
	knobParamNames[LivingString][3] = "DAMPING";
   2231a:	4a87      	ldr	r2, [pc, #540]	; (22538 <initModeNames+0x764>)

	modeNames[LivingStringSynth] = "STRING2";
	shortModeNames[LivingStringSynth] = "SS";
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   2231c:	f8df e2cc 	ldr.w	lr, [pc, #716]	; 225ec <initModeNames+0x818>
	knobParamNames[Reverb2][1] = "LOWPASS";
   22320:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
	modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
   22324:	f8cb e03c 	str.w	lr, [fp, #60]	; 0x3c
	numPages[LivingStringSynth] = 2;
	knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   22328:	4c84      	ldr	r4, [pc, #528]	; (2253c <initModeNames+0x768>)
	knobParamNames[LivingString][0] = "FREQ1";
   2232a:	f8c3 9578 	str.w	r9, [r3, #1400]	; 0x578
	knobParamNames[LivingString][10] = "FREQ2";
   2232e:	f8c3 75a0 	str.w	r7, [r3, #1440]	; 0x5a0
	knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   22332:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 225f0 <initModeNames+0x81c>
	shortModeNames[LivingString] = "LS";
   22336:	4f82      	ldr	r7, [pc, #520]	; (22540 <initModeNames+0x76c>)
	knobParamNames[LivingString][11] = "FREQ3";
   22338:	f8c3 55a4 	str.w	r5, [r3, #1444]	; 0x5a4
	modeNames[LivingStringSynth] = "STRING2";
   2233c:	4881      	ldr	r0, [pc, #516]	; (22544 <initModeNames+0x770>)
	modeNamesDetails[LivingString] = "SYMP STRING";
   2233e:	4d82      	ldr	r5, [pc, #520]	; (22548 <initModeNames+0x774>)
	knobParamNames[LivingString][13] = "FREQ5";
   22340:	f8c3 65ac 	str.w	r6, [r3, #1452]	; 0x5ac
	numPages[Vocoder] = 2;
   22344:	f8df e2ac 	ldr.w	lr, [pc, #684]	; 225f4 <initModeNames+0x820>
	shortModeNames[LivingStringSynth] = "SS";
   22348:	4e80      	ldr	r6, [pc, #512]	; (2254c <initModeNames+0x778>)
	knobParamNames[LivingString][3] = "DAMPING";
   2234a:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
	knobParamNames[LivingStringSynth][2] = "DECAY";
	knobParamNames[LivingStringSynth][3] = "DAMPING";
   2234e:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8
	numPages[Vocoder] = 2;
   22352:	4a7f      	ldr	r2, [pc, #508]	; (22550 <initModeNames+0x77c>)
	shortModeNames[LivingString] = "LS";
   22354:	f8cc 7038 	str.w	r7, [ip, #56]	; 0x38
	modeNamesDetails[LivingString] = "SYMP STRING";
   22358:	f8cb 5038 	str.w	r5, [fp, #56]	; 0x38
	knobParamNames[LivingString][5] = "PREP POS";
   2235c:	4f7d      	ldr	r7, [pc, #500]	; (22554 <initModeNames+0x780>)
	knobParamNames[LivingString][6] = "PREP FORCE";
   2235e:	4d7e      	ldr	r5, [pc, #504]	; (22558 <initModeNames+0x784>)
	modeNames[LivingStringSynth] = "STRING2";
   22360:	f8c8 003c 	str.w	r0, [r8, #60]	; 0x3c
	shortModeNames[LivingStringSynth] = "SS";
   22364:	f8cc 603c 	str.w	r6, [ip, #60]	; 0x3c
	knobParamNames[LivingString][7] = "LET RING";
   22368:	487c      	ldr	r0, [pc, #496]	; (2255c <initModeNames+0x788>)
	knobParamNames[LivingString][2] = "DECAY";
   2236a:	4e7d      	ldr	r6, [pc, #500]	; (22560 <initModeNames+0x78c>)
	numPages[Vocoder] = 2;
   2236c:	f8c2 e000 	str.w	lr, [r2]
	knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
   22370:	f8c3 45dc 	str.w	r4, [r3, #1500]	; 0x5dc
	numPages[Vocoder] = 2;
   22374:	f8df e280 	ldr.w	lr, [pc, #640]	; 225f8 <initModeNames+0x824>
	knobParamNames[LivingString][1] = "DETUNE";
   22378:	4c7a      	ldr	r4, [pc, #488]	; (22564 <initModeNames+0x790>)
	knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
   2237a:	f8c3 95e0 	str.w	r9, [r3, #1504]	; 0x5e0
	numPages[Vocoder] = 2;
   2237e:	f8df 927c 	ldr.w	r9, [pc, #636]	; 225fc <initModeNames+0x828>
   22382:	f8c2 e004 	str.w	lr, [r2, #4]
   22386:	f8c2 900c 	str.w	r9, [r2, #12]
	knobParamNames[LivingString][8] = "";
   2238a:	f8c3 1598 	str.w	r1, [r3, #1432]	; 0x598
	knobParamNames[LivingString][9] = "";
   2238e:	f8c3 159c 	str.w	r1, [r3, #1436]	; 0x59c
	knobParamNames[LivingString][12] = "FREQ4";
   22392:	f8c3 a5a8 	str.w	sl, [r3, #1448]	; 0x5a8
	knobParamNames[LivingString][1] = "DETUNE";
   22396:	f8c3 457c 	str.w	r4, [r3, #1404]	; 0x57c
	knobParamNames[LivingString][2] = "DECAY";
   2239a:	f8c3 6580 	str.w	r6, [r3, #1408]	; 0x580
	knobParamNames[LivingStringSynth][2] = "DECAY";
   2239e:	f8c3 65e4 	str.w	r6, [r3, #1508]	; 0x5e4
	knobParamNames[LivingString][5] = "PREP POS";
   223a2:	f8c3 758c 	str.w	r7, [r3, #1420]	; 0x58c
	knobParamNames[LivingString][6] = "PREP FORCE";
   223a6:	f8c3 5590 	str.w	r5, [r3, #1424]	; 0x590
	knobParamNames[LivingString][7] = "LET RING";
   223aa:	f8c3 0594 	str.w	r0, [r3, #1428]	; 0x594
	numPages[Vocoder] = 2;
   223ae:	f8c2 e008 	str.w	lr, [r2, #8]
	knobParamNames[LivingStringSynth][4] = "PICK_POS";
	knobParamNames[LivingStringSynth][5] = "PREP POS";
	knobParamNames[LivingStringSynth][6] = "PREP FORCE";
	knobParamNames[LivingStringSynth][7] = "LET RING";
   223b2:	f8c3 05f8 	str.w	r0, [r3, #1528]	; 0x5f8
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
	knobParamNames[ClassicSynth][14] = "F_LEAK";
	knobParamNames[ClassicSynth][15] = "F_AMOUNT";
	knobParamNames[ClassicSynth][16] = "SAW/PULSE";
	knobParamNames[ClassicSynth][17] = "";
   223b6:	f8c3 1684 	str.w	r1, [r3, #1668]	; 0x684
	knobParamNames[ClassicSynth][0] = "VOLUME";
   223ba:	486b      	ldr	r0, [pc, #428]	; (22568 <initModeNames+0x794>)
	knobParamNames[ClassicSynth][18] = "";
   223bc:	f8c3 1688 	str.w	r1, [r3, #1672]	; 0x688
	knobParamNames[ClassicSynth][19] = "";
   223c0:	f8c3 168c 	str.w	r1, [r3, #1676]	; 0x68c
	numPages[ClassicSynth] = 4;
   223c4:	f04f 0104 	mov.w	r1, #4
	knobParamNames[LivingStringSynth][4] = "PICK_POS";
   223c8:	f8df 9234 	ldr.w	r9, [pc, #564]	; 22600 <initModeNames+0x82c>
	numPages[ClassicSynth] = 4;
   223cc:	7411      	strb	r1, [r2, #16]
	knobParamNames[ClassicSynth][0] = "VOLUME";
   223ce:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
	knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   223d2:	4a66      	ldr	r2, [pc, #408]	; (2256c <initModeNames+0x798>)
	knobParamNames[ClassicSynth][1] = "LOWPASS";
   223d4:	4853      	ldr	r0, [pc, #332]	; (22524 <initModeNames+0x750>)
	knobParamNames[LivingStringSynth][4] = "PICK_POS";
   223d6:	f8c3 95ec 	str.w	r9, [r3, #1516]	; 0x5ec
	knobParamNames[LivingStringSynth][5] = "PREP POS";
   223da:	f8c3 75f0 	str.w	r7, [r3, #1520]	; 0x5f0
	knobParamNames[ClassicSynth][4] = "FILTER Q";
   223de:	f8df a224 	ldr.w	sl, [pc, #548]	; 22604 <initModeNames+0x830>
	knobParamNames[LivingStringSynth][6] = "PREP FORCE";
   223e2:	f8c3 55f4 	str.w	r5, [r3, #1524]	; 0x5f4
	knobParamNames[ClassicSynth][10] = "F_ATTACK";
   223e6:	f8df 9220 	ldr.w	r9, [pc, #544]	; 22608 <initModeNames+0x834>
	knobParamNames[ClassicSynth][11] = "F_DECAY";
   223ea:	f8df e220 	ldr.w	lr, [pc, #544]	; 2260c <initModeNames+0x838>
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   223ee:	4f60      	ldr	r7, [pc, #384]	; (22570 <initModeNames+0x79c>)
	knobParamNames[ClassicSynth][1] = "LOWPASS";
   223f0:	f8c3 0644 	str.w	r0, [r3, #1604]	; 0x644
	knobParamNames[ClassicSynth][3] = "DETUNE";
   223f4:	f8c3 464c 	str.w	r4, [r3, #1612]	; 0x64c
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   223f8:	485e      	ldr	r0, [pc, #376]	; (22574 <initModeNames+0x7a0>)
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   223fa:	4d5f      	ldr	r5, [pc, #380]	; (22578 <initModeNames+0x7a4>)
	knobParamNames[ClassicSynth][6] = "DECAY";
   223fc:	f8c3 6658 	str.w	r6, [r3, #1624]	; 0x658
	knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   22400:	4c5e      	ldr	r4, [pc, #376]	; (2257c <initModeNames+0x7a8>)
	knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   22402:	495f      	ldr	r1, [pc, #380]	; (22580 <initModeNames+0x7ac>)
	knobParamNames[LivingStringSynth][8] = "FB LEVEL";
   22404:	f8c3 25fc 	str.w	r2, [r3, #1532]	; 0x5fc
	knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   22408:	4e5e      	ldr	r6, [pc, #376]	; (22584 <initModeNames+0x7b0>)
	modeNames[ClassicSynth] = "POLYSYNTH";
   2240a:	4a5f      	ldr	r2, [pc, #380]	; (22588 <initModeNames+0x7b4>)
	knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
   2240c:	f8c3 6648 	str.w	r6, [r3, #1608]	; 0x648
	modeNames[ClassicSynth] = "POLYSYNTH";
   22410:	f8c8 2040 	str.w	r2, [r8, #64]	; 0x40
	knobParamNames[ClassicSynth][4] = "FILTER Q";
   22414:	f8c3 a650 	str.w	sl, [r3, #1616]	; 0x650
	knobParamNames[ClassicSynth][10] = "F_ATTACK";
   22418:	f8c3 9668 	str.w	r9, [r3, #1640]	; 0x668
	modeNamesDetails[ClassicSynth] = "VCO+VCF";
   2241c:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 22610 <initModeNames+0x83c>

	modeNames[Rhodes] = "RHODES";
   22420:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 22614 <initModeNames+0x840>
	knobParamNames[ClassicSynth][11] = "F_DECAY";
   22424:	f8c3 e66c 	str.w	lr, [r3, #1644]	; 0x66c
	knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
   22428:	f8c3 7670 	str.w	r7, [r3, #1648]	; 0x670
	shortModeNames[Rhodes] = "RD";
   2242c:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 22618 <initModeNames+0x844>
	modeNamesDetails[Rhodes] = "DARK";
   22430:	4f56      	ldr	r7, [pc, #344]	; (2258c <initModeNames+0x7b8>)
	knobParamNames[ClassicSynth][13] = "F_RELEASE";
   22432:	f8c3 0674 	str.w	r0, [r3, #1652]	; 0x674
	knobParamNames[ClassicSynth][14] = "F_LEAK";
   22436:	f8c3 5678 	str.w	r5, [r3, #1656]	; 0x678
	knobParamNames[LivingStringSynth][9] = "RELEASE";
   2243a:	4855      	ldr	r0, [pc, #340]	; (22590 <initModeNames+0x7bc>)
	knobParamNames[ClassicSynth][5] = "ATTACK";
   2243c:	4d55      	ldr	r5, [pc, #340]	; (22594 <initModeNames+0x7c0>)
	knobParamNames[ClassicSynth][15] = "F_AMOUNT";
   2243e:	f8c3 467c 	str.w	r4, [r3, #1660]	; 0x67c
	knobParamNames[ClassicSynth][16] = "SAW/PULSE";
   22442:	f8c3 1680 	str.w	r1, [r3, #1664]	; 0x680
	knobParamNames[ClassicSynth][7] = "SUSTAIN";
   22446:	4c54      	ldr	r4, [pc, #336]	; (22598 <initModeNames+0x7c4>)
	knobParamNames[ClassicSynth][9] = "LEAK";
   22448:	4954      	ldr	r1, [pc, #336]	; (2259c <initModeNames+0x7c8>)
	numPages[Rhodes] = 5;
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   2244a:	4a55      	ldr	r2, [pc, #340]	; (225a0 <initModeNames+0x7cc>)
	shortModeNames[ClassicSynth] = "CS";
   2244c:	4e55      	ldr	r6, [pc, #340]	; (225a4 <initModeNames+0x7d0>)
	modeNamesDetails[ClassicSynth] = "VCO+VCF";
   2244e:	f8cb a040 	str.w	sl, [fp, #64]	; 0x40
	shortModeNames[ClassicSynth] = "CS";
   22452:	f8cc 6040 	str.w	r6, [ip, #64]	; 0x40
	modeNames[Rhodes] = "RHODES";
   22456:	f8c8 9044 	str.w	r9, [r8, #68]	; 0x44
	shortModeNames[Rhodes] = "RD";
   2245a:	f8cc e044 	str.w	lr, [ip, #68]	; 0x44
	modeNamesDetails[Rhodes] = "DARK";
   2245e:	f8cb 7044 	str.w	r7, [fp, #68]	; 0x44
	numPages[Rhodes] = 5;
   22462:	f04f 0705 	mov.w	r7, #5
	knobParamNames[LivingStringSynth][9] = "RELEASE";
   22466:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
	knobParamNames[ClassicSynth][8] = "RELEASE";
   2246a:	f8c3 0660 	str.w	r0, [r3, #1632]	; 0x660
	knobParamNames[ClassicSynth][5] = "ATTACK";
   2246e:	f8c3 5654 	str.w	r5, [r3, #1620]	; 0x654
	knobParamNames[ClassicSynth][7] = "SUSTAIN";
   22472:	f8c3 465c 	str.w	r4, [r3, #1628]	; 0x65c
	knobParamNames[ClassicSynth][9] = "LEAK";
   22476:	f8c3 1664 	str.w	r1, [r3, #1636]	; 0x664
	knobParamNames[Rhodes][0] = "BRIGHTNESS";
   2247a:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   2247e:	4a4a      	ldr	r2, [pc, #296]	; (225a8 <initModeNames+0x7d4>)
	numPages[Rhodes] = 5;
   22480:	4e33      	ldr	r6, [pc, #204]	; (22550 <initModeNames+0x77c>)
	knobParamNames[Rhodes][1] = "TREM DEPTH";
   22482:	f8c3 26a8 	str.w	r2, [r3, #1704]	; 0x6a8
	knobParamNames[Rhodes][2] = "TREM RATE";
   22486:	4a49      	ldr	r2, [pc, #292]	; (225ac <initModeNames+0x7d8>)
	numPages[Rhodes] = 5;
   22488:	7477      	strb	r7, [r6, #17]
	knobParamNames[Rhodes][2] = "TREM RATE";
   2248a:	f8c3 26ac 	str.w	r2, [r3, #1708]	; 0x6ac
	knobParamNames[Rhodes][3] = "DRIVE";
   2248e:	4a48      	ldr	r2, [pc, #288]	; (225b0 <initModeNames+0x7dc>)
	knobParamNames[Rhodes][4] = "PAN SPREAD";
	knobParamNames[Rhodes][5] = "ATTACK";
	knobParamNames[Rhodes][6] = "DECAY";
   22490:	4e33      	ldr	r6, [pc, #204]	; (22560 <initModeNames+0x78c>)
	knobParamNames[Rhodes][3] = "DRIVE";
   22492:	f8c3 26b0 	str.w	r2, [r3, #1712]	; 0x6b0
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   22496:	4a47      	ldr	r2, [pc, #284]	; (225b4 <initModeNames+0x7e0>)
	knobParamNames[Rhodes][7] = "SUSTAIN";
	knobParamNames[Rhodes][8] = "RELEASE";
	knobParamNames[Rhodes][9] = "LEAK";
   22498:	f8c3 16c8 	str.w	r1, [r3, #1736]	; 0x6c8
	knobParamNames[Rhodes][4] = "PAN SPREAD";
   2249c:	f8c3 26b4 	str.w	r2, [r3, #1716]	; 0x6b4
	knobParamNames[Rhodes][16] = "RATIO2";
	knobParamNames[Rhodes][17] = "RATIO3";
	knobParamNames[Rhodes][18] = "RATIO4";
	knobParamNames[Rhodes][19] = "RATIO5";
	knobParamNames[Rhodes][20] = "RATIO6";
	knobParamNames[Rhodes][21] = "FEEDBACK";
   224a0:	4945      	ldr	r1, [pc, #276]	; (225b8 <initModeNames+0x7e4>)
	knobParamNames[Rhodes][10] = "INDEX1";
   224a2:	4a46      	ldr	r2, [pc, #280]	; (225bc <initModeNames+0x7e8>)
	knobParamNames[Rhodes][12] = "INDEX3";
   224a4:	f8df a174 	ldr.w	sl, [pc, #372]	; 2261c <initModeNames+0x848>
	knobParamNames[Rhodes][13] = "INDEX4";
   224a8:	f8df 9174 	ldr.w	r9, [pc, #372]	; 22620 <initModeNames+0x84c>
	knobParamNames[Rhodes][14] = "INDEX5";
   224ac:	f8df 8174 	ldr.w	r8, [pc, #372]	; 22624 <initModeNames+0x850>
	knobParamNames[Rhodes][15] = "RATIO1";
   224b0:	f8df e174 	ldr.w	lr, [pc, #372]	; 22628 <initModeNames+0x854>
	knobParamNames[Rhodes][5] = "ATTACK";
   224b4:	f8c3 56b8 	str.w	r5, [r3, #1720]	; 0x6b8
	knobParamNames[Rhodes][16] = "RATIO2";
   224b8:	f8df c170 	ldr.w	ip, [pc, #368]	; 2262c <initModeNames+0x858>
	knobParamNames[Rhodes][6] = "DECAY";
   224bc:	f8c3 66bc 	str.w	r6, [r3, #1724]	; 0x6bc
	knobParamNames[Rhodes][17] = "RATIO3";
   224c0:	4f3f      	ldr	r7, [pc, #252]	; (225c0 <initModeNames+0x7ec>)
	knobParamNames[Rhodes][7] = "SUSTAIN";
   224c2:	f8c3 46c0 	str.w	r4, [r3, #1728]	; 0x6c0
	knobParamNames[Rhodes][18] = "RATIO4";
   224c6:	4e3f      	ldr	r6, [pc, #252]	; (225c4 <initModeNames+0x7f0>)
	knobParamNames[Rhodes][8] = "RELEASE";
   224c8:	f8c3 06c4 	str.w	r0, [r3, #1732]	; 0x6c4
	knobParamNames[Rhodes][19] = "RATIO5";
   224cc:	4d3e      	ldr	r5, [pc, #248]	; (225c8 <initModeNames+0x7f4>)
	knobParamNames[Rhodes][20] = "RATIO6";
   224ce:	4c3f      	ldr	r4, [pc, #252]	; (225cc <initModeNames+0x7f8>)
	knobParamNames[Rhodes][21] = "FEEDBACK";
   224d0:	f8c3 16f8 	str.w	r1, [r3, #1784]	; 0x6f8
	knobParamNames[Rhodes][22] = "TUNE SNAP";
   224d4:	483e      	ldr	r0, [pc, #248]	; (225d0 <initModeNames+0x7fc>)
	knobParamNames[Rhodes][23] = "RAND DECAY";
   224d6:	493f      	ldr	r1, [pc, #252]	; (225d4 <initModeNames+0x800>)
	knobParamNames[Rhodes][24] = "RAND SUST";
   224d8:	f8df b154 	ldr.w	fp, [pc, #340]	; 22630 <initModeNames+0x85c>
	knobParamNames[Rhodes][10] = "INDEX1";
   224dc:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
	knobParamNames[Rhodes][11] = "INDEX2";
   224e0:	4a3d      	ldr	r2, [pc, #244]	; (225d8 <initModeNames+0x804>)
	knobParamNames[Rhodes][12] = "INDEX3";
   224e2:	f8c3 a6d4 	str.w	sl, [r3, #1748]	; 0x6d4
	knobParamNames[Rhodes][11] = "INDEX2";
   224e6:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
	knobParamNames[Rhodes][13] = "INDEX4";
   224ea:	f8c3 96d8 	str.w	r9, [r3, #1752]	; 0x6d8
	knobParamNames[Rhodes][14] = "INDEX5";
   224ee:	f8c3 86dc 	str.w	r8, [r3, #1756]	; 0x6dc
	knobParamNames[Rhodes][15] = "RATIO1";
   224f2:	f8c3 e6e0 	str.w	lr, [r3, #1760]	; 0x6e0
	knobParamNames[Rhodes][16] = "RATIO2";
   224f6:	f8c3 c6e4 	str.w	ip, [r3, #1764]	; 0x6e4
	knobParamNames[Rhodes][17] = "RATIO3";
   224fa:	f8c3 76e8 	str.w	r7, [r3, #1768]	; 0x6e8
	knobParamNames[Rhodes][18] = "RATIO4";
   224fe:	f8c3 66ec 	str.w	r6, [r3, #1772]	; 0x6ec
	knobParamNames[Rhodes][19] = "RATIO5";
   22502:	f8c3 56f0 	str.w	r5, [r3, #1776]	; 0x6f0
	knobParamNames[Rhodes][20] = "RATIO6";
   22506:	f8c3 46f4 	str.w	r4, [r3, #1780]	; 0x6f4
	knobParamNames[Rhodes][22] = "TUNE SNAP";
   2250a:	f8c3 06fc 	str.w	r0, [r3, #1788]	; 0x6fc
	knobParamNames[Rhodes][23] = "RAND DECAY";
   2250e:	f8c3 1700 	str.w	r1, [r3, #1792]	; 0x700
	knobParamNames[Rhodes][24] = "RAND SUST";
   22512:	f8c3 b704 	str.w	fp, [r3, #1796]	; 0x704
}
   22516:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2251a:	bf00      	nop
   2251c:	000324fc 	.word	0x000324fc
   22520:	00032504 	.word	0x00032504
   22524:	00032404 	.word	0x00032404
   22528:	00032488 	.word	0x00032488
   2252c:	000324cc 	.word	0x000324cc
   22530:	00032494 	.word	0x00032494
   22534:	00032514 	.word	0x00032514
   22538:	000324c4 	.word	0x000324c4
   2253c:	0003253c 	.word	0x0003253c
   22540:	0003249c 	.word	0x0003249c
   22544:	00032524 	.word	0x00032524
   22548:	000324a0 	.word	0x000324a0
   2254c:	00032624 	.word	0x00032624
   22550:	020fb430 	.word	0x020fb430
   22554:	000324d8 	.word	0x000324d8
   22558:	000324e4 	.word	0x000324e4
   2255c:	000324f0 	.word	0x000324f0
   22560:	000324bc 	.word	0x000324bc
   22564:	000324b4 	.word	0x000324b4
   22568:	00032134 	.word	0x00032134
   2256c:	00032560 	.word	0x00032560
   22570:	000325d0 	.word	0x000325d0
   22574:	000325dc 	.word	0x000325dc
   22578:	000325e8 	.word	0x000325e8
   2257c:	000325f0 	.word	0x000325f0
   22580:	000325fc 	.word	0x000325fc
   22584:	0003258c 	.word	0x0003258c
   22588:	00032574 	.word	0x00032574
   2258c:	00032614 	.word	0x00032614
   22590:	0003256c 	.word	0x0003256c
   22594:	000325a4 	.word	0x000325a4
   22598:	000325ac 	.word	0x000325ac
   2259c:	000325b4 	.word	0x000325b4
   225a0:	0003261c 	.word	0x0003261c
   225a4:	00032580 	.word	0x00032580
   225a8:	00032628 	.word	0x00032628
   225ac:	00032634 	.word	0x00032634
   225b0:	00032640 	.word	0x00032640
   225b4:	00032648 	.word	0x00032648
   225b8:	0003240c 	.word	0x0003240c
   225bc:	00032654 	.word	0x00032654
   225c0:	0003268c 	.word	0x0003268c
   225c4:	00032694 	.word	0x00032694
   225c8:	0003269c 	.word	0x0003269c
   225cc:	000326a4 	.word	0x000326a4
   225d0:	000326ac 	.word	0x000326ac
   225d4:	000326b8 	.word	0x000326b8
   225d8:	0003265c 	.word	0x0003265c
   225dc:	0003247c 	.word	0x0003247c
   225e0:	000324ac 	.word	0x000324ac
   225e4:	0003250c 	.word	0x0003250c
   225e8:	0003251c 	.word	0x0003251c
   225ec:	0003252c 	.word	0x0003252c
   225f0:	00032548 	.word	0x00032548
   225f4:	01020302 	.word	0x01020302
   225f8:	02020101 	.word	0x02020101
   225fc:	02030101 	.word	0x02030101
   22600:	00032554 	.word	0x00032554
   22604:	00032598 	.word	0x00032598
   22608:	000325bc 	.word	0x000325bc
   2260c:	000325c8 	.word	0x000325c8
   22610:	00032584 	.word	0x00032584
   22614:	00032608 	.word	0x00032608
   22618:	00032610 	.word	0x00032610
   2261c:	00032664 	.word	0x00032664
   22620:	0003266c 	.word	0x0003266c
   22624:	00032674 	.word	0x00032674
   22628:	0003267c 	.word	0x0003267c
   2262c:	00032684 	.word	0x00032684
   22630:	000326c4 	.word	0x000326c4

00022634 <buttonCheck>:

void buttonCheck(void)
{
	if (codecReady)
   22634:	4ba0      	ldr	r3, [pc, #640]	; (228b8 <buttonCheck+0x284>)
   22636:	781b      	ldrb	r3, [r3, #0]
   22638:	2b00      	cmp	r3, #0
   2263a:	f000 80e7 	beq.w	2280c <buttonCheck+0x1d8>
		buttonValues[8] = !HAL_GPIO_ReadPin(GPIOG, GPIO_PIN_11); // D
		buttonValues[9] = !HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_10); // E
		 */

		//A little more efficient since it avoids a function call
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   2263e:	499f      	ldr	r1, [pc, #636]	; (228bc <buttonCheck+0x288>)
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
		buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);

		for (int i = 0; i < NUM_BUTTONS; i++)
   22640:	2300      	movs	r3, #0
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   22642:	4a9f      	ldr	r2, [pc, #636]	; (228c0 <buttonCheck+0x28c>)
{
   22644:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   22648:	6908      	ldr	r0, [r1, #16]
{
   2264a:	b087      	sub	sp, #28
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
				buttonActionsUI[i][ActionHoldContinuous] = TRUE;
				writeButtonFlag = i;
				writeActionFlag = ActionHoldContinuous;
			}
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   2264c:	4f9d      	ldr	r7, [pc, #628]	; (228c4 <buttonCheck+0x290>)
   2264e:	4694      	mov	ip, r2
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   22650:	f480 5000 	eor.w	r0, r0, #8192	; 0x2000
			{
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   22654:	4d9c      	ldr	r5, [pc, #624]	; (228c8 <buttonCheck+0x294>)
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   22656:	f8d7 a000 	ldr.w	sl, [r7]
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   2265a:	f3c0 3040 	ubfx	r0, r0, #13, #1
   2265e:	4f9b      	ldr	r7, [pc, #620]	; (228cc <buttonCheck+0x298>)
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   22660:	4c9b      	ldr	r4, [pc, #620]	; (228d0 <buttonCheck+0x29c>)
		buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
   22662:	7010      	strb	r0, [r2, #0]
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   22664:	6908      	ldr	r0, [r1, #16]
   22666:	f997 7000 	ldrsb.w	r7, [r7]
   2266a:	f480 5080 	eor.w	r0, r0, #4096	; 0x1000
		buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   2266e:	4e99      	ldr	r6, [pc, #612]	; (228d4 <buttonCheck+0x2a0>)
   22670:	9701      	str	r7, [sp, #4]
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   22672:	f3c0 3000 	ubfx	r0, r0, #12, #1
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   22676:	682d      	ldr	r5, [r5, #0]
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   22678:	6824      	ldr	r4, [r4, #0]
		buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
   2267a:	7050      	strb	r0, [r2, #1]
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   2267c:	6908      	ldr	r0, [r1, #16]
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   2267e:	9405      	str	r4, [sp, #20]
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   22680:	f480 4080 	eor.w	r0, r0, #16384	; 0x4000
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   22684:	9504      	str	r5, [sp, #16]
   22686:	4f94      	ldr	r7, [pc, #592]	; (228d8 <buttonCheck+0x2a4>)
		buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
   22688:	f3c0 3080 	ubfx	r0, r0, #14, #1
   2268c:	4c93      	ldr	r4, [pc, #588]	; (228dc <buttonCheck+0x2a8>)
   2268e:	f997 b000 	ldrsb.w	fp, [r7]
   22692:	7090      	strb	r0, [r2, #2]
		buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
   22694:	6930      	ldr	r0, [r6, #16]
   22696:	4f92      	ldr	r7, [pc, #584]	; (228e0 <buttonCheck+0x2ac>)
   22698:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
   2269c:	f8df e268 	ldr.w	lr, [pc, #616]	; 22908 <buttonCheck+0x2d4>
   226a0:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   226a4:	70d0      	strb	r0, [r2, #3]
		buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   226a6:	690d      	ldr	r5, [r1, #16]
		buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   226a8:	6908      	ldr	r0, [r1, #16]
		buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   226aa:	f485 4900 	eor.w	r9, r5, #32768	; 0x8000
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   226ae:	6936      	ldr	r6, [r6, #16]
		buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   226b0:	f080 0802 	eor.w	r8, r0, #2
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   226b4:	488b      	ldr	r0, [pc, #556]	; (228e4 <buttonCheck+0x2b0>)
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   226b6:	690d      	ldr	r5, [r1, #16]
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   226b8:	f086 0680 	eor.w	r6, r6, #128	; 0x80
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   226bc:	6900      	ldr	r0, [r0, #16]
		buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   226be:	f3c9 39c0 	ubfx	r9, r9, #15, #1
		buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   226c2:	6909      	ldr	r1, [r1, #16]
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   226c4:	f485 6500 	eor.w	r5, r5, #2048	; 0x800
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   226c8:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
		buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   226cc:	f3c8 0840 	ubfx	r8, r8, #1, #1
		buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   226d0:	f481 6180 	eor.w	r1, r1, #1024	; 0x400
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   226d4:	f3c6 16c0 	ubfx	r6, r6, #7, #1
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   226d8:	f3c5 25c0 	ubfx	r5, r5, #11, #1
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   226dc:	f3c0 20c0 	ubfx	r0, r0, #11, #1
		buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   226e0:	f3c1 2180 	ubfx	r1, r1, #10, #1
		buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
   226e4:	f882 9004 	strb.w	r9, [r2, #4]
		buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
   226e8:	f882 8005 	strb.w	r8, [r2, #5]
		buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
   226ec:	7196      	strb	r6, [r2, #6]
		buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
   226ee:	71d5      	strb	r5, [r2, #7]
		buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
   226f0:	7210      	strb	r0, [r2, #8]
   226f2:	f8df 8218 	ldr.w	r8, [pc, #536]	; 2290c <buttonCheck+0x2d8>
		buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
   226f6:	7251      	strb	r1, [r2, #9]
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   226f8:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 228f4 <buttonCheck+0x2c0>
   226fc:	e00f      	b.n	2271e <buttonCheck+0xea>
				if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
   226fe:	f858 1002 	ldr.w	r1, [r8, r2]
   22702:	9804      	ldr	r0, [sp, #16]
   22704:	4281      	cmp	r1, r0
   22706:	d202      	bcs.n	2270e <buttonCheck+0xda>
   22708:	3101      	adds	r1, #1
   2270a:	f848 1002 	str.w	r1, [r8, r2]
				if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
   2270e:	9805      	ldr	r0, [sp, #20]
   22710:	4288      	cmp	r0, r1
   22712:	d801      	bhi.n	22718 <buttonCheck+0xe4>
   22714:	2d01      	cmp	r5, #1
   22716:	d07a      	beq.n	2280e <buttonCheck+0x1da>
		for (int i = 0; i < NUM_BUTTONS; i++)
   22718:	3301      	adds	r3, #1
   2271a:	2b0a      	cmp	r3, #10
   2271c:	d037      	beq.n	2278e <buttonCheck+0x15a>
			if (buttonValues[i] != buttonValuesPrev[i])
   2271e:	f81c 1b01 	ldrb.w	r1, [ip], #1
   22722:	f817 2f01 	ldrb.w	r2, [r7, #1]!
   22726:	f854 0f04 	ldr.w	r0, [r4, #4]!
   2272a:	428a      	cmp	r2, r1
   2272c:	d001      	beq.n	22732 <buttonCheck+0xfe>
				buttonHysteresis[i]++;
   2272e:	3001      	adds	r0, #1
   22730:	6020      	str	r0, [r4, #0]
			if (cleanButtonValues[i] == 1)
   22732:	f81e 5003 	ldrb.w	r5, [lr, r3]
   22736:	009a      	lsls	r2, r3, #2
   22738:	2d01      	cmp	r5, #1
   2273a:	d10d      	bne.n	22758 <buttonCheck+0x124>
				writeButtonFlag = i;
   2273c:	b25e      	sxtb	r6, r3
				writeActionFlag = ActionHoldContinuous;
   2273e:	f04f 0b03 	mov.w	fp, #3
				writeButtonFlag = i;
   22742:	9601      	str	r6, [sp, #4]
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   22744:	eb09 0602 	add.w	r6, r9, r2
   22748:	9602      	str	r6, [sp, #8]
				buttonActionsUI[i][ActionHoldContinuous] = TRUE;
   2274a:	4e67      	ldr	r6, [pc, #412]	; (228e8 <buttonCheck+0x2b4>)
   2274c:	4416      	add	r6, r2
   2274e:	9603      	str	r6, [sp, #12]
				buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
   22750:	9e02      	ldr	r6, [sp, #8]
   22752:	70f5      	strb	r5, [r6, #3]
				buttonActionsUI[i][ActionHoldContinuous] = TRUE;
   22754:	9e03      	ldr	r6, [sp, #12]
   22756:	70f5      	strb	r5, [r6, #3]
			if (buttonHysteresis[i] < buttonHysteresisThreshold)
   22758:	4582      	cmp	sl, r0
   2275a:	d8d0      	bhi.n	226fe <buttonCheck+0xca>
				}
			}
			else
			{
				cleanButtonValues[i] = buttonValues[i];
				buttonHysteresis[i] = 0;
   2275c:	2000      	movs	r0, #0
				buttonCounters[i] = 0;

				if (cleanButtonValues[i] == 1)
   2275e:	2901      	cmp	r1, #1
				cleanButtonValues[i] = buttonValues[i];
   22760:	f80e 1003 	strb.w	r1, [lr, r3]
				buttonHysteresis[i] = 0;
   22764:	6020      	str	r0, [r4, #0]
				buttonCounters[i] = 0;
   22766:	f848 0002 	str.w	r0, [r8, r2]
				if (cleanButtonValues[i] == 1)
   2276a:	d045      	beq.n	227f8 <buttonCheck+0x1c4>
					buttonActionsSFX[i][ActionPress] = TRUE;
					buttonActionsUI[i][ActionPress] = TRUE;
					writeButtonFlag = i;
					writeActionFlag = ActionPress;
				}
				else if (cleanButtonValues[i] == 0)
   2276c:	b959      	cbnz	r1, 22786 <buttonCheck+0x152>
				{
					buttonActionsSFX[i][ActionRelease] = TRUE;
					buttonActionsUI[i][ActionRelease] = TRUE;
   2276e:	4d5e      	ldr	r5, [pc, #376]	; (228e8 <buttonCheck+0x2b4>)
					buttonActionsSFX[i][ActionRelease] = TRUE;
   22770:	eb09 0002 	add.w	r0, r9, r2
					writeButtonFlag = i;
					writeActionFlag = ActionRelease;
   22774:	f04f 0b01 	mov.w	fp, #1
					buttonActionsUI[i][ActionRelease] = TRUE;
   22778:	442a      	add	r2, r5
					writeButtonFlag = i;
   2277a:	b25d      	sxtb	r5, r3
   2277c:	9501      	str	r5, [sp, #4]
					buttonActionsSFX[i][ActionRelease] = TRUE;
   2277e:	f04f 0501 	mov.w	r5, #1
   22782:	7045      	strb	r5, [r0, #1]
					buttonActionsUI[i][ActionRelease] = TRUE;
   22784:	7055      	strb	r5, [r2, #1]
				}
				buttonValuesPrev[i] = buttonValues[i];
   22786:	7039      	strb	r1, [r7, #0]
		for (int i = 0; i < NUM_BUTTONS; i++)
   22788:	3301      	adds	r3, #1
   2278a:	2b0a      	cmp	r3, #10
   2278c:	d1c7      	bne.n	2271e <buttonCheck+0xea>

		// make some if statements if you want to find the "attack" of the buttons (getting the "press" action)

		/// DEFINE GLOBAL BUTTON BEHAVIOR HERE

		if (buttonActionsUI[ButtonLeft][ActionPress] == 1)
   2278e:	4b56      	ldr	r3, [pc, #344]	; (228e8 <buttonCheck+0x2b4>)
   22790:	4a4e      	ldr	r2, [pc, #312]	; (228cc <buttonCheck+0x298>)
   22792:	791b      	ldrb	r3, [r3, #4]
   22794:	9901      	ldr	r1, [sp, #4]
   22796:	2b01      	cmp	r3, #1
   22798:	7011      	strb	r1, [r2, #0]
   2279a:	4a4f      	ldr	r2, [pc, #316]	; (228d8 <buttonCheck+0x2a4>)
   2279c:	f882 b000 	strb.w	fp, [r2]
   227a0:	f000 815c 	beq.w	22a5c <buttonCheck+0x428>
			loadingPreset = 1;
			OLED_writePreset();
			writeCurrentPresetToFlash();
			clearButtonActions();
		}
		if (buttonActionsUI[ButtonRight][ActionPress] == 1)
   227a4:	4b50      	ldr	r3, [pc, #320]	; (228e8 <buttonCheck+0x2b4>)
   227a6:	7a1b      	ldrb	r3, [r3, #8]
   227a8:	2b01      	cmp	r3, #1
   227aa:	f000 8191 	beq.w	22ad0 <buttonCheck+0x49c>
			loadingPreset = 1;
			OLED_writePreset();
			writeCurrentPresetToFlash();
			clearButtonActions();
		}
		if (buttonActionsUI[ButtonD][ActionPress] == 1)
   227ae:	4b4e      	ldr	r3, [pc, #312]	; (228e8 <buttonCheck+0x2b4>)
   227b0:	f893 3020 	ldrb.w	r3, [r3, #32]
   227b4:	2b01      	cmp	r3, #1
   227b6:	f000 81c6 	beq.w	22b46 <buttonCheck+0x512>
			}
			changeTuning();
			OLED_writeTuning();
			buttonActionsUI[ButtonD][ActionPress] = 0;
		}
		if (buttonActionsUI[ButtonE][ActionPress] == 1)
   227ba:	4b4b      	ldr	r3, [pc, #300]	; (228e8 <buttonCheck+0x2b4>)
   227bc:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   227c0:	2b01      	cmp	r3, #1
   227c2:	f000 81fd 	beq.w	22bc0 <buttonCheck+0x58c>
			changeTuning();
			OLED_writeTuning();
			buttonActionsUI[ButtonE][ActionPress] = 0;
		}

		if (buttonActionsUI[ButtonEdit][ActionPress])
   227c6:	4b48      	ldr	r3, [pc, #288]	; (228e8 <buttonCheck+0x2b4>)
   227c8:	781b      	ldrb	r3, [r3, #0]
   227ca:	2b00      	cmp	r3, #0
   227cc:	f040 81e9 	bne.w	22ba2 <buttonCheck+0x56e>
		{
			OLED_writeEditScreen();
			setLED_Edit(1);
			buttonActionsUI[ButtonEdit][ActionPress] = 0;
		}
		if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   227d0:	4b45      	ldr	r3, [pc, #276]	; (228e8 <buttonCheck+0x2b4>)
   227d2:	78db      	ldrb	r3, [r3, #3]
   227d4:	2b01      	cmp	r3, #1
		{
			if (buttonActionsUI[ButtonC][ActionPress] == 1)
   227d6:	4b44      	ldr	r3, [pc, #272]	; (228e8 <buttonCheck+0x2b4>)
		if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   227d8:	d026      	beq.n	22828 <buttonCheck+0x1f4>
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
			}

//			OLEDdrawFloatArray(audioDisplayBuffer, -1.0f, 1.0f, 128, displayBufferIndex, 0, BothLines);
		}
		if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
   227da:	785b      	ldrb	r3, [r3, #1]
   227dc:	2b01      	cmp	r3, #1
   227de:	d038      	beq.n	22852 <buttonCheck+0x21e>
			buttonActionsUI[ButtonEdit][ActionRelease] = 0;
			buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
			buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;

		}
		if (buttonActionsUI[ButtonDown][ActionPress] == 1)
   227e0:	4b41      	ldr	r3, [pc, #260]	; (228e8 <buttonCheck+0x2b4>)
   227e2:	7b1b      	ldrb	r3, [r3, #12]
   227e4:	2b01      	cmp	r3, #1
   227e6:	d044      	beq.n	22872 <buttonCheck+0x23e>
			decrementPage();
			OLEDwriteString("P", 1, 110, FirstLine);
			OLEDwriteInt(knobPage, 1, 120, FirstLine);
			buttonActionsUI[ButtonDown][ActionPress] = 0;
		}
		if (buttonActionsUI[ButtonUp][ActionPress] == 1)
   227e8:	4b3f      	ldr	r3, [pc, #252]	; (228e8 <buttonCheck+0x2b4>)
   227ea:	7c1b      	ldrb	r3, [r3, #16]
   227ec:	2b01      	cmp	r3, #1
   227ee:	f000 80e3 	beq.w	229b8 <buttonCheck+0x384>
//			OLEDwriteString(" ", 1, getCursorX(), SecondLine);
//			OLEDwriteString(paramNames[orderedParams[currentParamIndex]], getCursorX(), SecondLine);
//			buttonActionsUI[ButtonEdit][ActionPress] = 0;
//		}
	}
}
   227f2:	b007      	add	sp, #28
   227f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					writeButtonFlag = i;
   227f8:	b258      	sxtb	r0, r3
					buttonActionsSFX[i][ActionPress] = TRUE;
   227fa:	f809 1002 	strb.w	r1, [r9, r2]
					writeActionFlag = ActionPress;
   227fe:	f04f 0b00 	mov.w	fp, #0
				buttonValuesPrev[i] = buttonValues[i];
   22802:	7039      	strb	r1, [r7, #0]
					writeButtonFlag = i;
   22804:	9001      	str	r0, [sp, #4]
					buttonActionsUI[i][ActionPress] = TRUE;
   22806:	4838      	ldr	r0, [pc, #224]	; (228e8 <buttonCheck+0x2b4>)
   22808:	5481      	strb	r1, [r0, r2]
   2280a:	e7bd      	b.n	22788 <buttonCheck+0x154>
   2280c:	4770      	bx	lr
					buttonActionsUI[i][ActionHoldInstant] = TRUE;
   2280e:	4836      	ldr	r0, [pc, #216]	; (228e8 <buttonCheck+0x2b4>)
					buttonActionsSFX[i][ActionHoldInstant] = TRUE;
   22810:	eb09 0102 	add.w	r1, r9, r2
					writeActionFlag = ActionHoldInstant;
   22814:	f04f 0b02 	mov.w	fp, #2
					buttonActionsUI[i][ActionHoldInstant] = TRUE;
   22818:	4402      	add	r2, r0
					writeButtonFlag = i;
   2281a:	b258      	sxtb	r0, r3
   2281c:	9001      	str	r0, [sp, #4]
					buttonActionsSFX[i][ActionHoldInstant] = TRUE;
   2281e:	f04f 0001 	mov.w	r0, #1
   22822:	7088      	strb	r0, [r1, #2]
					buttonActionsUI[i][ActionHoldInstant] = TRUE;
   22824:	7090      	strb	r0, [r2, #2]
   22826:	e777      	b.n	22718 <buttonCheck+0xe4>
			if (buttonActionsUI[ButtonC][ActionPress] == 1)
   22828:	7f1c      	ldrb	r4, [r3, #28]
   2282a:	2c01      	cmp	r4, #1
   2282c:	f000 8261 	beq.w	22cf2 <buttonCheck+0x6be>
			if (buttonActionsUI[ButtonDown][ActionPress])
   22830:	4d2d      	ldr	r5, [pc, #180]	; (228e8 <buttonCheck+0x2b4>)
   22832:	7b2b      	ldrb	r3, [r5, #12]
   22834:	b14b      	cbz	r3, 2284a <buttonCheck+0x216>
				cvAddParam[currentPreset] = -1;
   22836:	4a2d      	ldr	r2, [pc, #180]	; (228ec <buttonCheck+0x2b8>)
				buttonActionsUI[ButtonDown][ActionPress] = 0;
   22838:	2300      	movs	r3, #0
				cvAddParam[currentPreset] = -1;
   2283a:	20ff      	movs	r0, #255	; 0xff
   2283c:	4c2c      	ldr	r4, [pc, #176]	; (228f0 <buttonCheck+0x2bc>)
   2283e:	7811      	ldrb	r1, [r2, #0]
				buttonActionsSFX[ButtonDown][ActionPress] = 0;
   22840:	4a2c      	ldr	r2, [pc, #176]	; (228f4 <buttonCheck+0x2c0>)
				cvAddParam[currentPreset] = -1;
   22842:	5460      	strb	r0, [r4, r1]
				buttonActionsUI[ButtonDown][ActionPress] = 0;
   22844:	732b      	strb	r3, [r5, #12]
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   22846:	70eb      	strb	r3, [r5, #3]
				buttonActionsSFX[ButtonDown][ActionPress] = 0;
   22848:	7313      	strb	r3, [r2, #12]
		if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
   2284a:	4b27      	ldr	r3, [pc, #156]	; (228e8 <buttonCheck+0x2b4>)
   2284c:	785b      	ldrb	r3, [r3, #1]
   2284e:	2b01      	cmp	r3, #1
   22850:	d1ca      	bne.n	227e8 <buttonCheck+0x1b4>
			OLED_writePreset();
   22852:	f7f6 fed7 	bl	19604 <OLED_writePreset>
			setLED_Edit(0);
   22856:	2000      	movs	r0, #0
   22858:	f7f6 fe34 	bl	194c4 <setLED_Edit>
			buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
   2285c:	2300      	movs	r3, #0
   2285e:	4a25      	ldr	r2, [pc, #148]	; (228f4 <buttonCheck+0x2c0>)
			buttonActionsUI[ButtonEdit][ActionRelease] = 0;
   22860:	4921      	ldr	r1, [pc, #132]	; (228e8 <buttonCheck+0x2b4>)
			buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
   22862:	7053      	strb	r3, [r2, #1]
			buttonActionsUI[ButtonEdit][ActionRelease] = 0;
   22864:	704b      	strb	r3, [r1, #1]
			buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   22866:	70cb      	strb	r3, [r1, #3]
			buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;
   22868:	70d3      	strb	r3, [r2, #3]
		if (buttonActionsUI[ButtonDown][ActionPress] == 1)
   2286a:	4b1f      	ldr	r3, [pc, #124]	; (228e8 <buttonCheck+0x2b4>)
   2286c:	7b1b      	ldrb	r3, [r3, #12]
   2286e:	2b01      	cmp	r3, #1
   22870:	d1ba      	bne.n	227e8 <buttonCheck+0x1b4>

}

void decrementPage(void)
{
	if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
   22872:	4f21      	ldr	r7, [pc, #132]	; (228f8 <buttonCheck+0x2c4>)
   22874:	4d1d      	ldr	r5, [pc, #116]	; (228ec <buttonCheck+0x2b8>)
   22876:	783b      	ldrb	r3, [r7, #0]
   22878:	7829      	ldrb	r1, [r5, #0]
   2287a:	2b00      	cmp	r3, #0
   2287c:	f000 8231 	beq.w	22ce2 <buttonCheck+0x6ae>
	else knobPage--;
   22880:	3b01      	subs	r3, #1
   22882:	b2db      	uxtb	r3, r3
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   22884:	4a1d      	ldr	r2, [pc, #116]	; (228fc <buttonCheck+0x2c8>)
   22886:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
   2288a:	2064      	movs	r0, #100	; 0x64
   2288c:	4c18      	ldr	r4, [pc, #96]	; (228f0 <buttonCheck+0x2bc>)
   2288e:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
	}
}

void setKnobValues(float* values)
{
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22892:	f04f 0900 	mov.w	r9, #0
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   22896:	fb00 2001 	mla	r0, r0, r1, r2
   2289a:	4a19      	ldr	r2, [pc, #100]	; (22900 <buttonCheck+0x2cc>)
   2289c:	9401      	str	r4, [sp, #4]
   2289e:	9203      	str	r2, [sp, #12]
		{
			knob = 5;
		}
		knobActive[knob] = 0;
		floatADCUI[knob] = -1.0f;
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228a0:	f10b 0214 	add.w	r2, fp, #20
   228a4:	4c17      	ldr	r4, [pc, #92]	; (22904 <buttonCheck+0x2d0>)
   228a6:	4606      	mov	r6, r0
   228a8:	1882      	adds	r2, r0, r2
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   228aa:	9004      	str	r0, [sp, #16]
   228ac:	f8df 8060 	ldr.w	r8, [pc, #96]	; 22910 <buttonCheck+0x2dc>
   228b0:	9402      	str	r4, [sp, #8]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   228b2:	9205      	str	r2, [sp, #20]
   228b4:	703b      	strb	r3, [r7, #0]
   228b6:	e043      	b.n	22940 <buttonCheck+0x30c>
   228b8:	020e3100 	.word	0x020e3100
   228bc:	58020400 	.word	0x58020400
   228c0:	020fbc74 	.word	0x020fbc74
   228c4:	00062b58 	.word	0x00062b58
   228c8:	00062b50 	.word	0x00062b50
   228cc:	00062b62 	.word	0x00062b62
   228d0:	00062b54 	.word	0x00062b54
   228d4:	58020c00 	.word	0x58020c00
   228d8:	00062b61 	.word	0x00062b61
   228dc:	020fb394 	.word	0x020fb394
   228e0:	020fb2f7 	.word	0x020fb2f7
   228e4:	58021800 	.word	0x58021800
   228e8:	020fb45c 	.word	0x020fb45c
   228ec:	020e3259 	.word	0x020e3259
   228f0:	020fb540 	.word	0x020fb540
   228f4:	020fb31c 	.word	0x020fb31c
   228f8:	020e325a 	.word	0x020e325a
   228fc:	020f9318 	.word	0x020f9318
   22900:	020fa550 	.word	0x020fa550
   22904:	020f6f08 	.word	0x020f6f08
   22908:	020fb3c0 	.word	0x020fb3c0
   2290c:	020fb4d0 	.word	0x020fb4d0
   22910:	020fb444 	.word	0x020fb444
		knobActive[knob] = 0;
   22914:	9b03      	ldr	r3, [sp, #12]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22916:	ed9a 0a00 	vldr	s0, [sl]
		knobActive[knob] = 0;
   2291a:	f803 e009 	strb.w	lr, [r3, r9]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   2291e:	f109 0901 	add.w	r9, r9, #1
		floatADCUI[knob] = -1.0f;
   22922:	edcc 7a00 	vstr	s15, [ip]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22926:	f005 fb1f 	bl	27f68 <tExpSmooth_setValAndDest>

		smoothedADC[knob] = values[knob];
   2292a:	9b02      	ldr	r3, [sp, #8]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   2292c:	f1b9 0f05 	cmp.w	r9, #5
		smoothedADC[knob] = values[knob];
   22930:	441c      	add	r4, r3
   22932:	f8da 3000 	ldr.w	r3, [sl]
   22936:	6023      	str	r3, [r4, #0]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22938:	d02a      	beq.n	22990 <buttonCheck+0x35c>
   2293a:	783b      	ldrb	r3, [r7, #0]
   2293c:	7829      	ldrb	r1, [r5, #0]
   2293e:	9e04      	ldr	r6, [sp, #16]
   22940:	ea4f 0489 	mov.w	r4, r9, lsl #2
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22944:	2205      	movs	r2, #5
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22946:	48b9      	ldr	r0, [pc, #740]	; (22c2c <buttonCheck+0x5f8>)
		floatADCUI[knob] = -1.0f;
   22948:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   2294c:	eb0b 0a04 	add.w	sl, fp, r4
		knobActive[knob] = 0;
   22950:	f04f 0e00 	mov.w	lr, #0
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22954:	fb12 9203 	smlabb	r2, r2, r3, r9
		floatADCUI[knob] = -1.0f;
   22958:	eb08 0c04 	add.w	ip, r8, r4
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   2295c:	44b2      	add	sl, r6
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   2295e:	9e01      	ldr	r6, [sp, #4]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22960:	4420      	add	r0, r4
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22962:	5671      	ldrsb	r1, [r6, r1]
   22964:	428a      	cmp	r2, r1
   22966:	d1d5      	bne.n	22914 <buttonCheck+0x2e0>
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22968:	9c05      	ldr	r4, [sp, #20]
		knobActive[knob] = 0;
   2296a:	2200      	movs	r2, #0
		floatADCUI[knob] = -1.0f;
   2296c:	4bb0      	ldr	r3, [pc, #704]	; (22c30 <buttonCheck+0x5fc>)
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   2296e:	f109 0901 	add.w	r9, r9, #1
		knobActive[knob] = 0;
   22972:	9903      	ldr	r1, [sp, #12]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22974:	ed94 0a00 	vldr	s0, [r4]
   22978:	48ae      	ldr	r0, [pc, #696]	; (22c34 <buttonCheck+0x600>)
		knobActive[knob] = 0;
   2297a:	714a      	strb	r2, [r1, #5]
		floatADCUI[knob] = -1.0f;
   2297c:	f8c8 3014 	str.w	r3, [r8, #20]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22980:	f005 faf2 	bl	27f68 <tExpSmooth_setValAndDest>
		smoothedADC[knob] = values[knob];
   22984:	6823      	ldr	r3, [r4, #0]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22986:	f1b9 0f05 	cmp.w	r9, #5
		smoothedADC[knob] = values[knob];
   2298a:	9a02      	ldr	r2, [sp, #8]
   2298c:	6153      	str	r3, [r2, #20]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   2298e:	d1d4      	bne.n	2293a <buttonCheck+0x306>
			OLEDwriteString("P", 1, 110, FirstLine);
   22990:	2300      	movs	r3, #0
   22992:	226e      	movs	r2, #110	; 0x6e
   22994:	2101      	movs	r1, #1
   22996:	48a8      	ldr	r0, [pc, #672]	; (22c38 <buttonCheck+0x604>)
   22998:	f7f7 f80c 	bl	199b4 <OLEDwriteString>
			OLEDwriteInt(knobPage, 1, 120, FirstLine);
   2299c:	2300      	movs	r3, #0
   2299e:	2278      	movs	r2, #120	; 0x78
   229a0:	7838      	ldrb	r0, [r7, #0]
   229a2:	2101      	movs	r1, #1
   229a4:	f7f7 f830 	bl	19a08 <OLEDwriteInt>
			buttonActionsUI[ButtonDown][ActionPress] = 0;
   229a8:	2300      	movs	r3, #0
   229aa:	4aa4      	ldr	r2, [pc, #656]	; (22c3c <buttonCheck+0x608>)
   229ac:	7313      	strb	r3, [r2, #12]
		if (buttonActionsUI[ButtonUp][ActionPress] == 1)
   229ae:	4ba3      	ldr	r3, [pc, #652]	; (22c3c <buttonCheck+0x608>)
   229b0:	7c1b      	ldrb	r3, [r3, #16]
   229b2:	2b01      	cmp	r3, #1
   229b4:	f47f af1d 	bne.w	227f2 <buttonCheck+0x1be>
	knobPage = (knobPage + 1) % numPages[currentPreset];
   229b8:	4fa1      	ldr	r7, [pc, #644]	; (22c40 <buttonCheck+0x60c>)
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   229ba:	2464      	movs	r4, #100	; 0x64
	knobPage = (knobPage + 1) % numPages[currentPreset];
   229bc:	4da1      	ldr	r5, [pc, #644]	; (22c44 <buttonCheck+0x610>)
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   229be:	f04f 0a00 	mov.w	sl, #0
	knobPage = (knobPage + 1) % numPages[currentPreset];
   229c2:	783b      	ldrb	r3, [r7, #0]
   229c4:	7829      	ldrb	r1, [r5, #0]
   229c6:	4aa0      	ldr	r2, [pc, #640]	; (22c48 <buttonCheck+0x614>)
   229c8:	4ea0      	ldr	r6, [pc, #640]	; (22c4c <buttonCheck+0x618>)
   229ca:	5c50      	ldrb	r0, [r2, r1]
   229cc:	1c5a      	adds	r2, r3, #1
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   229ce:	4ba0      	ldr	r3, [pc, #640]	; (22c50 <buttonCheck+0x61c>)
   229d0:	9601      	str	r6, [sp, #4]
   229d2:	fb04 3401 	mla	r4, r4, r1, r3
   229d6:	4b9f      	ldr	r3, [pc, #636]	; (22c54 <buttonCheck+0x620>)
   229d8:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 22c84 <buttonCheck+0x650>
   229dc:	9303      	str	r3, [sp, #12]
   229de:	4626      	mov	r6, r4
   229e0:	4b9d      	ldr	r3, [pc, #628]	; (22c58 <buttonCheck+0x624>)
   229e2:	9404      	str	r4, [sp, #16]
   229e4:	9302      	str	r3, [sp, #8]
	knobPage = (knobPage + 1) % numPages[currentPreset];
   229e6:	fb92 f3f0 	sdiv	r3, r2, r0
   229ea:	fb00 2313 	mls	r3, r0, r3, r2
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   229ee:	eb03 0983 	add.w	r9, r3, r3, lsl #2
	knobPage = (knobPage + 1) % numPages[currentPreset];
   229f2:	b2db      	uxtb	r3, r3
	setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
   229f4:	ea4f 0989 	mov.w	r9, r9, lsl #2
	knobPage = (knobPage + 1) % numPages[currentPreset];
   229f8:	703b      	strb	r3, [r7, #0]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   229fa:	f109 0214 	add.w	r2, r9, #20
   229fe:	18a2      	adds	r2, r4, r2
   22a00:	9205      	str	r2, [sp, #20]
   22a02:	ea4f 048a 	mov.w	r4, sl, lsl #2
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22a06:	2205      	movs	r2, #5
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22a08:	4888      	ldr	r0, [pc, #544]	; (22c2c <buttonCheck+0x5f8>)
		floatADCUI[knob] = -1.0f;
   22a0a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22a0e:	eb09 0b04 	add.w	fp, r9, r4
		knobActive[knob] = 0;
   22a12:	f04f 0e00 	mov.w	lr, #0
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22a16:	fb12 a203 	smlabb	r2, r2, r3, sl
		floatADCUI[knob] = -1.0f;
   22a1a:	eb08 0c04 	add.w	ip, r8, r4
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22a1e:	44b3      	add	fp, r6
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22a20:	9e01      	ldr	r6, [sp, #4]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22a22:	4420      	add	r0, r4
		if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
   22a24:	5671      	ldrsb	r1, [r6, r1]
   22a26:	428a      	cmp	r2, r1
   22a28:	f000 812e 	beq.w	22c88 <buttonCheck+0x654>
		knobActive[knob] = 0;
   22a2c:	9b03      	ldr	r3, [sp, #12]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22a2e:	ed9b 0a00 	vldr	s0, [fp]
		knobActive[knob] = 0;
   22a32:	f803 e00a 	strb.w	lr, [r3, sl]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22a36:	f10a 0a01 	add.w	sl, sl, #1
		floatADCUI[knob] = -1.0f;
   22a3a:	edcc 7a00 	vstr	s15, [ip]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22a3e:	f005 fa93 	bl	27f68 <tExpSmooth_setValAndDest>
		smoothedADC[knob] = values[knob];
   22a42:	9b02      	ldr	r3, [sp, #8]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22a44:	f1ba 0f05 	cmp.w	sl, #5
		smoothedADC[knob] = values[knob];
   22a48:	441c      	add	r4, r3
   22a4a:	f8db 3000 	ldr.w	r3, [fp]
   22a4e:	6023      	str	r3, [r4, #0]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22a50:	f000 812f 	beq.w	22cb2 <buttonCheck+0x67e>
   22a54:	783b      	ldrb	r3, [r7, #0]
   22a56:	7829      	ldrb	r1, [r5, #0]
   22a58:	9e04      	ldr	r6, [sp, #16]
   22a5a:	e7d2      	b.n	22a02 <buttonCheck+0x3ce>
			previousPreset = currentPreset;
   22a5c:	4d79      	ldr	r5, [pc, #484]	; (22c44 <buttonCheck+0x610>)
   22a5e:	4a7f      	ldr	r2, [pc, #508]	; (22c5c <buttonCheck+0x628>)
   22a60:	782b      	ldrb	r3, [r5, #0]
   22a62:	7013      	strb	r3, [r2, #0]
			if (currentPreset <= 0) currentPreset = PresetNil - 1;
   22a64:	2b00      	cmp	r3, #0
   22a66:	f000 813a 	beq.w	22cde <buttonCheck+0x6aa>
			else currentPreset--;
   22a6a:	3b01      	subs	r3, #1
   22a6c:	b2db      	uxtb	r3, r3
			loadingPreset = 1;
   22a6e:	2101      	movs	r1, #1
   22a70:	4a7b      	ldr	r2, [pc, #492]	; (22c60 <buttonCheck+0x62c>)
   22a72:	702b      	strb	r3, [r5, #0]
   22a74:	7011      	strb	r1, [r2, #0]
			OLED_writePreset();
   22a76:	f7f6 fdc5 	bl	19604 <OLED_writePreset>
	if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
   22a7a:	4b7a      	ldr	r3, [pc, #488]	; (22c64 <buttonCheck+0x630>)
   22a7c:	7829      	ldrb	r1, [r5, #0]
   22a7e:	8818      	ldrh	r0, [r3, #0]
   22a80:	f7f4 fff6 	bl	17a70 <EE_WriteVariable>
   22a84:	b108      	cbz	r0, 22a8a <buttonCheck+0x456>
		Error_Handler();
   22a86:	f7f6 fd19 	bl	194bc <Error_Handler>
			buttonActionsUI[b][a] = 0;
   22a8a:	2300      	movs	r3, #0
			buttonActionsSFX[b][a] = 0;
   22a8c:	4a76      	ldr	r2, [pc, #472]	; (22c68 <buttonCheck+0x634>)
			buttonActionsUI[b][a] = 0;
   22a8e:	486b      	ldr	r0, [pc, #428]	; (22c3c <buttonCheck+0x608>)
   22a90:	21ff      	movs	r1, #255	; 0xff
			buttonActionsSFX[b][a] = 0;
   22a92:	6013      	str	r3, [r2, #0]
			buttonActionsUI[b][a] = 0;
   22a94:	6083      	str	r3, [r0, #8]
   22a96:	60c3      	str	r3, [r0, #12]
   22a98:	6103      	str	r3, [r0, #16]
   22a9a:	6143      	str	r3, [r0, #20]
   22a9c:	6183      	str	r3, [r0, #24]
   22a9e:	61c3      	str	r3, [r0, #28]
   22aa0:	6203      	str	r3, [r0, #32]
   22aa2:	6243      	str	r3, [r0, #36]	; 0x24
   22aa4:	6283      	str	r3, [r0, #40]	; 0x28
   22aa6:	6003      	str	r3, [r0, #0]
   22aa8:	6043      	str	r3, [r0, #4]
			buttonActionsSFX[b][a] = 0;
   22aaa:	6053      	str	r3, [r2, #4]
   22aac:	6093      	str	r3, [r2, #8]
   22aae:	60d3      	str	r3, [r2, #12]
   22ab0:	6113      	str	r3, [r2, #16]
   22ab2:	6153      	str	r3, [r2, #20]
   22ab4:	6193      	str	r3, [r2, #24]
   22ab6:	61d3      	str	r3, [r2, #28]
   22ab8:	6213      	str	r3, [r2, #32]
   22aba:	6253      	str	r3, [r2, #36]	; 0x24
   22abc:	6293      	str	r3, [r2, #40]	; 0x28
   22abe:	4b6b      	ldr	r3, [pc, #428]	; (22c6c <buttonCheck+0x638>)
   22ac0:	7019      	strb	r1, [r3, #0]
   22ac2:	4b6b      	ldr	r3, [pc, #428]	; (22c70 <buttonCheck+0x63c>)
   22ac4:	7019      	strb	r1, [r3, #0]
		if (buttonActionsUI[ButtonRight][ActionPress] == 1)
   22ac6:	4b5d      	ldr	r3, [pc, #372]	; (22c3c <buttonCheck+0x608>)
   22ac8:	7a1b      	ldrb	r3, [r3, #8]
   22aca:	2b01      	cmp	r3, #1
   22acc:	f47f ae6f 	bne.w	227ae <buttonCheck+0x17a>
			previousPreset = currentPreset;
   22ad0:	4d5c      	ldr	r5, [pc, #368]	; (22c44 <buttonCheck+0x610>)
   22ad2:	4a62      	ldr	r2, [pc, #392]	; (22c5c <buttonCheck+0x628>)
   22ad4:	782b      	ldrb	r3, [r5, #0]
			if (currentPreset >= PresetNil - 1) currentPreset = 0;
   22ad6:	2b10      	cmp	r3, #16
			previousPreset = currentPreset;
   22ad8:	7013      	strb	r3, [r2, #0]
			if (currentPreset >= PresetNil - 1) currentPreset = 0;
   22ada:	f200 80fe 	bhi.w	22cda <buttonCheck+0x6a6>
			else currentPreset++;
   22ade:	3301      	adds	r3, #1
   22ae0:	b2db      	uxtb	r3, r3
			loadingPreset = 1;
   22ae2:	2101      	movs	r1, #1
   22ae4:	4a5e      	ldr	r2, [pc, #376]	; (22c60 <buttonCheck+0x62c>)
   22ae6:	702b      	strb	r3, [r5, #0]
   22ae8:	7011      	strb	r1, [r2, #0]
			OLED_writePreset();
   22aea:	f7f6 fd8b 	bl	19604 <OLED_writePreset>
	if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
   22aee:	4b5d      	ldr	r3, [pc, #372]	; (22c64 <buttonCheck+0x630>)
   22af0:	7829      	ldrb	r1, [r5, #0]
   22af2:	8818      	ldrh	r0, [r3, #0]
   22af4:	f7f4 ffbc 	bl	17a70 <EE_WriteVariable>
   22af8:	b108      	cbz	r0, 22afe <buttonCheck+0x4ca>
		Error_Handler();
   22afa:	f7f6 fcdf 	bl	194bc <Error_Handler>
			buttonActionsUI[b][a] = 0;
   22afe:	2300      	movs	r3, #0
			buttonActionsSFX[b][a] = 0;
   22b00:	4a59      	ldr	r2, [pc, #356]	; (22c68 <buttonCheck+0x634>)
			buttonActionsUI[b][a] = 0;
   22b02:	484e      	ldr	r0, [pc, #312]	; (22c3c <buttonCheck+0x608>)
   22b04:	21ff      	movs	r1, #255	; 0xff
			buttonActionsSFX[b][a] = 0;
   22b06:	6013      	str	r3, [r2, #0]
			buttonActionsUI[b][a] = 0;
   22b08:	6203      	str	r3, [r0, #32]
   22b0a:	6243      	str	r3, [r0, #36]	; 0x24
   22b0c:	6283      	str	r3, [r0, #40]	; 0x28
   22b0e:	6003      	str	r3, [r0, #0]
   22b10:	6043      	str	r3, [r0, #4]
   22b12:	6083      	str	r3, [r0, #8]
   22b14:	60c3      	str	r3, [r0, #12]
   22b16:	6103      	str	r3, [r0, #16]
   22b18:	6143      	str	r3, [r0, #20]
   22b1a:	6183      	str	r3, [r0, #24]
   22b1c:	61c3      	str	r3, [r0, #28]
			buttonActionsSFX[b][a] = 0;
   22b1e:	6053      	str	r3, [r2, #4]
   22b20:	6093      	str	r3, [r2, #8]
   22b22:	60d3      	str	r3, [r2, #12]
   22b24:	6113      	str	r3, [r2, #16]
   22b26:	6153      	str	r3, [r2, #20]
   22b28:	6193      	str	r3, [r2, #24]
   22b2a:	61d3      	str	r3, [r2, #28]
   22b2c:	6213      	str	r3, [r2, #32]
   22b2e:	6253      	str	r3, [r2, #36]	; 0x24
   22b30:	6293      	str	r3, [r2, #40]	; 0x28
   22b32:	4b4e      	ldr	r3, [pc, #312]	; (22c6c <buttonCheck+0x638>)
   22b34:	7019      	strb	r1, [r3, #0]
   22b36:	4b4e      	ldr	r3, [pc, #312]	; (22c70 <buttonCheck+0x63c>)
   22b38:	7019      	strb	r1, [r3, #0]
		if (buttonActionsUI[ButtonD][ActionPress] == 1)
   22b3a:	4b40      	ldr	r3, [pc, #256]	; (22c3c <buttonCheck+0x608>)
   22b3c:	f893 3020 	ldrb.w	r3, [r3, #32]
   22b40:	2b01      	cmp	r3, #1
   22b42:	f47f ae3a 	bne.w	227ba <buttonCheck+0x186>
			if (currentTuning == 0)
   22b46:	4a4b      	ldr	r2, [pc, #300]	; (22c74 <buttonCheck+0x640>)
   22b48:	6813      	ldr	r3, [r2, #0]
   22b4a:	2b00      	cmp	r3, #0
   22b4c:	f040 80c3 	bne.w	22cd6 <buttonCheck+0x6a2>
				currentTuning = NUM_TUNINGS - 1;
   22b50:	233e      	movs	r3, #62	; 0x3e
		centsDeviation[i] = tuningPresets[currentTuning][i];
   22b52:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   22b56:	4c48      	ldr	r4, [pc, #288]	; (22c78 <buttonCheck+0x644>)
   22b58:	4f48      	ldr	r7, [pc, #288]	; (22c7c <buttonCheck+0x648>)
   22b5a:	eb04 1401 	add.w	r4, r4, r1, lsl #4
   22b5e:	6013      	str	r3, [r2, #0]
   22b60:	f104 0c30 	add.w	ip, r4, #48	; 0x30
   22b64:	6820      	ldr	r0, [r4, #0]
   22b66:	3410      	adds	r4, #16
   22b68:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   22b6c:	463d      	mov	r5, r7
   22b6e:	f854 2c08 	ldr.w	r2, [r4, #-8]
   22b72:	3710      	adds	r7, #16
   22b74:	f854 3c04 	ldr.w	r3, [r4, #-4]
   22b78:	4564      	cmp	r4, ip
   22b7a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   22b7c:	d1f2      	bne.n	22b64 <buttonCheck+0x530>
	if (currentPreset == AutotuneMono)
   22b7e:	4b31      	ldr	r3, [pc, #196]	; (22c44 <buttonCheck+0x610>)
   22b80:	781b      	ldrb	r3, [r3, #0]
   22b82:	2b03      	cmp	r3, #3
   22b84:	f000 80b2 	beq.w	22cec <buttonCheck+0x6b8>
			OLED_writeTuning();
   22b88:	f7f6 fe84 	bl	19894 <OLED_writeTuning>
			buttonActionsUI[ButtonD][ActionPress] = 0;
   22b8c:	2300      	movs	r3, #0
   22b8e:	4a2b      	ldr	r2, [pc, #172]	; (22c3c <buttonCheck+0x608>)
   22b90:	f882 3020 	strb.w	r3, [r2, #32]
		if (buttonActionsUI[ButtonE][ActionPress] == 1)
   22b94:	4b29      	ldr	r3, [pc, #164]	; (22c3c <buttonCheck+0x608>)
   22b96:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   22b9a:	2b01      	cmp	r3, #1
   22b9c:	f47f ae13 	bne.w	227c6 <buttonCheck+0x192>
   22ba0:	e00e      	b.n	22bc0 <buttonCheck+0x58c>
			OLED_writeEditScreen();
   22ba2:	f7f6 fe2b 	bl	197fc <OLED_writeEditScreen>
			setLED_Edit(1);
   22ba6:	2001      	movs	r0, #1
   22ba8:	f7f6 fc8c 	bl	194c4 <setLED_Edit>
			buttonActionsUI[ButtonEdit][ActionPress] = 0;
   22bac:	2300      	movs	r3, #0
   22bae:	4a23      	ldr	r2, [pc, #140]	; (22c3c <buttonCheck+0x608>)
   22bb0:	7013      	strb	r3, [r2, #0]
		if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   22bb2:	4b22      	ldr	r3, [pc, #136]	; (22c3c <buttonCheck+0x608>)
   22bb4:	78db      	ldrb	r3, [r3, #3]
   22bb6:	2b01      	cmp	r3, #1
			if (buttonActionsUI[ButtonC][ActionPress] == 1)
   22bb8:	4b20      	ldr	r3, [pc, #128]	; (22c3c <buttonCheck+0x608>)
		if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
   22bba:	f47f ae0e 	bne.w	227da <buttonCheck+0x1a6>
   22bbe:	e633      	b.n	22828 <buttonCheck+0x1f4>
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   22bc0:	492c      	ldr	r1, [pc, #176]	; (22c74 <buttonCheck+0x640>)
   22bc2:	4b2f      	ldr	r3, [pc, #188]	; (22c80 <buttonCheck+0x64c>)
   22bc4:	680a      	ldr	r2, [r1, #0]
		centsDeviation[i] = tuningPresets[currentTuning][i];
   22bc6:	4c2c      	ldr	r4, [pc, #176]	; (22c78 <buttonCheck+0x644>)
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   22bc8:	3201      	adds	r2, #1
   22bca:	4f2c      	ldr	r7, [pc, #176]	; (22c7c <buttonCheck+0x648>)
   22bcc:	fba3 0302 	umull	r0, r3, r3, r2
   22bd0:	1ad0      	subs	r0, r2, r3
   22bd2:	eb03 0350 	add.w	r3, r3, r0, lsr #1
   22bd6:	095b      	lsrs	r3, r3, #5
   22bd8:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
   22bdc:	1ad3      	subs	r3, r2, r3
		centsDeviation[i] = tuningPresets[currentTuning][i];
   22bde:	eb03 0243 	add.w	r2, r3, r3, lsl #1
			currentTuning = (currentTuning + 1) % NUM_TUNINGS;
   22be2:	600b      	str	r3, [r1, #0]
		centsDeviation[i] = tuningPresets[currentTuning][i];
   22be4:	eb04 1402 	add.w	r4, r4, r2, lsl #4
   22be8:	f104 0c30 	add.w	ip, r4, #48	; 0x30
   22bec:	6820      	ldr	r0, [r4, #0]
   22bee:	3410      	adds	r4, #16
   22bf0:	f854 1c0c 	ldr.w	r1, [r4, #-12]
   22bf4:	463d      	mov	r5, r7
   22bf6:	f854 2c08 	ldr.w	r2, [r4, #-8]
   22bfa:	3710      	adds	r7, #16
   22bfc:	f854 3c04 	ldr.w	r3, [r4, #-4]
   22c00:	4564      	cmp	r4, ip
   22c02:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   22c04:	d1f2      	bne.n	22bec <buttonCheck+0x5b8>
	if (currentPreset == AutotuneMono)
   22c06:	4b0f      	ldr	r3, [pc, #60]	; (22c44 <buttonCheck+0x610>)
   22c08:	781b      	ldrb	r3, [r3, #0]
   22c0a:	2b03      	cmp	r3, #3
   22c0c:	d101      	bne.n	22c12 <buttonCheck+0x5de>
		calculateNoteArray();
   22c0e:	f7fe f943 	bl	20e98 <calculateNoteArray>
			OLED_writeTuning();
   22c12:	f7f6 fe3f 	bl	19894 <OLED_writeTuning>
			buttonActionsUI[ButtonE][ActionPress] = 0;
   22c16:	2300      	movs	r3, #0
   22c18:	4a08      	ldr	r2, [pc, #32]	; (22c3c <buttonCheck+0x608>)
   22c1a:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
		if (buttonActionsUI[ButtonEdit][ActionPress])
   22c1e:	4b07      	ldr	r3, [pc, #28]	; (22c3c <buttonCheck+0x608>)
   22c20:	781b      	ldrb	r3, [r3, #0]
   22c22:	2b00      	cmp	r3, #0
   22c24:	f43f add4 	beq.w	227d0 <buttonCheck+0x19c>
   22c28:	e7bb      	b.n	22ba2 <buttonCheck+0x56e>
   22c2a:	bf00      	nop
   22c2c:	020f6ea8 	.word	0x020f6ea8
   22c30:	bf800000 	.word	0xbf800000
   22c34:	020f6ebc 	.word	0x020f6ebc
   22c38:	000326b4 	.word	0x000326b4
   22c3c:	020fb45c 	.word	0x020fb45c
   22c40:	020e325a 	.word	0x020e325a
   22c44:	020e3259 	.word	0x020e3259
   22c48:	020fb430 	.word	0x020fb430
   22c4c:	020fb540 	.word	0x020fb540
   22c50:	020f9318 	.word	0x020f9318
   22c54:	020fa550 	.word	0x020fa550
   22c58:	020f6f08 	.word	0x020f6f08
   22c5c:	00062b60 	.word	0x00062b60
   22c60:	020e325b 	.word	0x020e325b
   22c64:	000628ac 	.word	0x000628ac
   22c68:	020fb31c 	.word	0x020fb31c
   22c6c:	00062b62 	.word	0x00062b62
   22c70:	00062b61 	.word	0x00062b61
   22c74:	020e3254 	.word	0x020e3254
   22c78:	00031358 	.word	0x00031358
   22c7c:	020e3224 	.word	0x020e3224
   22c80:	04104105 	.word	0x04104105
   22c84:	020fb444 	.word	0x020fb444
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22c88:	9c05      	ldr	r4, [sp, #20]
		knobActive[knob] = 0;
   22c8a:	2200      	movs	r2, #0
		floatADCUI[knob] = -1.0f;
   22c8c:	4b2c      	ldr	r3, [pc, #176]	; (22d40 <buttonCheck+0x70c>)
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22c8e:	f10a 0a01 	add.w	sl, sl, #1
		knobActive[knob] = 0;
   22c92:	9903      	ldr	r1, [sp, #12]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22c94:	ed94 0a00 	vldr	s0, [r4]
   22c98:	482a      	ldr	r0, [pc, #168]	; (22d44 <buttonCheck+0x710>)
		knobActive[knob] = 0;
   22c9a:	714a      	strb	r2, [r1, #5]
		floatADCUI[knob] = -1.0f;
   22c9c:	f8c8 3014 	str.w	r3, [r8, #20]
		tExpSmooth_setValAndDest(&adc[knob], values[knob]);
   22ca0:	f005 f962 	bl	27f68 <tExpSmooth_setValAndDest>
		smoothedADC[knob] = values[knob];
   22ca4:	6823      	ldr	r3, [r4, #0]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22ca6:	f1ba 0f05 	cmp.w	sl, #5
		smoothedADC[knob] = values[knob];
   22caa:	9a02      	ldr	r2, [sp, #8]
   22cac:	6153      	str	r3, [r2, #20]
	for (int i = 0; i < KNOB_PAGE_SIZE; i++)
   22cae:	f47f aed1 	bne.w	22a54 <buttonCheck+0x420>
			OLEDwriteString("P", 1, 110, FirstLine);
   22cb2:	2300      	movs	r3, #0
   22cb4:	226e      	movs	r2, #110	; 0x6e
   22cb6:	2101      	movs	r1, #1
   22cb8:	4823      	ldr	r0, [pc, #140]	; (22d48 <buttonCheck+0x714>)
   22cba:	f7f6 fe7b 	bl	199b4 <OLEDwriteString>
			OLEDwriteInt(knobPage, 1, 120, FirstLine);
   22cbe:	7838      	ldrb	r0, [r7, #0]
   22cc0:	2300      	movs	r3, #0
   22cc2:	2278      	movs	r2, #120	; 0x78
   22cc4:	2101      	movs	r1, #1
   22cc6:	f7f6 fe9f 	bl	19a08 <OLEDwriteInt>
			buttonActionsUI[ButtonUp][ActionPress] = 0;
   22cca:	2300      	movs	r3, #0
   22ccc:	4a1f      	ldr	r2, [pc, #124]	; (22d4c <buttonCheck+0x718>)
   22cce:	7413      	strb	r3, [r2, #16]
}
   22cd0:	b007      	add	sp, #28
   22cd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				currentTuning = (currentTuning - 1);
   22cd6:	3b01      	subs	r3, #1
   22cd8:	e73b      	b.n	22b52 <buttonCheck+0x51e>
			if (currentPreset >= PresetNil - 1) currentPreset = 0;
   22cda:	2300      	movs	r3, #0
   22cdc:	e701      	b.n	22ae2 <buttonCheck+0x4ae>
			if (currentPreset <= 0) currentPreset = PresetNil - 1;
   22cde:	2311      	movs	r3, #17
   22ce0:	e6c5      	b.n	22a6e <buttonCheck+0x43a>
	if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
   22ce2:	4b1b      	ldr	r3, [pc, #108]	; (22d50 <buttonCheck+0x71c>)
   22ce4:	5c5b      	ldrb	r3, [r3, r1]
   22ce6:	3b01      	subs	r3, #1
   22ce8:	b2db      	uxtb	r3, r3
   22cea:	e5cb      	b.n	22884 <buttonCheck+0x250>
		calculateNoteArray();
   22cec:	f7fe f8d4 	bl	20e98 <calculateNoteArray>
   22cf0:	e74a      	b.n	22b88 <buttonCheck+0x554>
				keyCenter = (keyCenter + 1) % 12;
   22cf2:	4d18      	ldr	r5, [pc, #96]	; (22d54 <buttonCheck+0x720>)
				OLEDclearLine(SecondLine);
   22cf4:	4620      	mov	r0, r4
				keyCenter = (keyCenter + 1) % 12;
   22cf6:	4b18      	ldr	r3, [pc, #96]	; (22d58 <buttonCheck+0x724>)
   22cf8:	782a      	ldrb	r2, [r5, #0]
   22cfa:	3201      	adds	r2, #1
   22cfc:	fba3 1302 	umull	r1, r3, r3, r2
   22d00:	08db      	lsrs	r3, r3, #3
   22d02:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   22d06:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
   22d0a:	702b      	strb	r3, [r5, #0]
				OLEDclearLine(SecondLine);
   22d0c:	f7f6 fe3e 	bl	1998c <OLEDclearLine>
				OLEDwriteString("KEY: ", 5, 0, SecondLine);
   22d10:	2200      	movs	r2, #0
   22d12:	4623      	mov	r3, r4
   22d14:	2105      	movs	r1, #5
   22d16:	4811      	ldr	r0, [pc, #68]	; (22d5c <buttonCheck+0x728>)
   22d18:	f7f6 fe4c 	bl	199b4 <OLEDwriteString>
				OLEDwritePitchClass(keyCenter+60, 64, SecondLine);
   22d1c:	782b      	ldrb	r3, [r5, #0]
   22d1e:	4621      	mov	r1, r4
   22d20:	2040      	movs	r0, #64	; 0x40
   22d22:	333c      	adds	r3, #60	; 0x3c
   22d24:	ee00 3a10 	vmov	s0, r3
   22d28:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   22d2c:	f7f6 fed0 	bl	19ad0 <OLEDwritePitchClass>
				buttonActionsUI[ButtonC][ActionPress] = 0;
   22d30:	2300      	movs	r3, #0
   22d32:	4906      	ldr	r1, [pc, #24]	; (22d4c <buttonCheck+0x718>)
				buttonActionsSFX[ButtonC][ActionPress] = 0;
   22d34:	4a0a      	ldr	r2, [pc, #40]	; (22d60 <buttonCheck+0x72c>)
				buttonActionsUI[ButtonC][ActionPress] = 0;
   22d36:	770b      	strb	r3, [r1, #28]
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   22d38:	70cb      	strb	r3, [r1, #3]
				buttonActionsSFX[ButtonC][ActionPress] = 0;
   22d3a:	7713      	strb	r3, [r2, #28]
   22d3c:	e578      	b.n	22830 <buttonCheck+0x1fc>
   22d3e:	bf00      	nop
   22d40:	bf800000 	.word	0xbf800000
   22d44:	020f6ebc 	.word	0x020f6ebc
   22d48:	000326b4 	.word	0x000326b4
   22d4c:	020fb45c 	.word	0x020fb45c
   22d50:	020fb430 	.word	0x020fb430
   22d54:	020e3258 	.word	0x020e3258
   22d58:	aaaaaaab 	.word	0xaaaaaaab
   22d5c:	00032118 	.word	0x00032118
   22d60:	020fb31c 	.word	0x020fb31c

00022d64 <adcCheck>:
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22d64:	486f      	ldr	r0, [pc, #444]	; (22f24 <adcCheck+0x1c0>)
   22d66:	eddf 4a70 	vldr	s9, [pc, #448]	; 22f28 <adcCheck+0x1c4>
{
   22d6a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22d6e:	8801      	ldrh	r1, [r0, #0]
   22d70:	8842      	ldrh	r2, [r0, #2]
   22d72:	8883      	ldrh	r3, [r0, #4]
   22d74:	0989      	lsrs	r1, r1, #6
   22d76:	0992      	lsrs	r2, r2, #6
	if (firstADCPass)
   22d78:	4e6c      	ldr	r6, [pc, #432]	; (22f2c <adcCheck+0x1c8>)
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22d7a:	099b      	lsrs	r3, r3, #6
   22d7c:	ee05 1a10 	vmov	s10, r1
   22d80:	ee05 2a90 	vmov	s11, r2
   22d84:	88c1      	ldrh	r1, [r0, #6]
   22d86:	ee06 3a10 	vmov	s12, r3
   22d8a:	8902      	ldrh	r2, [r0, #8]
   22d8c:	8943      	ldrh	r3, [r0, #10]
   22d8e:	0989      	lsrs	r1, r1, #6
   22d90:	0992      	lsrs	r2, r2, #6
   22d92:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
   22d96:	099b      	lsrs	r3, r3, #6
   22d98:	ee06 1a90 	vmov	s13, r1
   22d9c:	ee07 2a10 	vmov	s14, r2
   22da0:	eef8 5ae5 	vcvt.f32.s32	s11, s11
   22da4:	ee07 3a90 	vmov	s15, r3
   22da8:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   22dac:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   22db0:	4c5f      	ldr	r4, [pc, #380]	; (22f30 <adcCheck+0x1cc>)
   22db2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	if (firstADCPass)
   22db6:	6832      	ldr	r2, [r6, #0]
		floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
   22db8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   22dbc:	ee25 5a24 	vmul.f32	s10, s10, s9
   22dc0:	ee65 5aa4 	vmul.f32	s11, s11, s9
   22dc4:	ee26 6a24 	vmul.f32	s12, s12, s9
   22dc8:	ee66 6aa4 	vmul.f32	s13, s13, s9
   22dcc:	ed84 5a00 	vstr	s10, [r4]
   22dd0:	ee27 7a24 	vmul.f32	s14, s14, s9
   22dd4:	edc4 5a01 	vstr	s11, [r4, #4]
   22dd8:	ee67 7aa4 	vmul.f32	s15, s15, s9
   22ddc:	ed84 6a02 	vstr	s12, [r4, #8]
   22de0:	edc4 6a03 	vstr	s13, [r4, #12]
   22de4:	ed84 7a04 	vstr	s14, [r4, #16]
   22de8:	edc4 7a05 	vstr	s15, [r4, #20]
	if (firstADCPass)
   22dec:	b142      	cbz	r2, 22e00 <adcCheck+0x9c>
   22dee:	4d51      	ldr	r5, [pc, #324]	; (22f34 <adcCheck+0x1d0>)
		firstADCPass = 0;
   22df0:	2700      	movs	r7, #0
   22df2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   22df4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   22df6:	e894 0003 	ldmia.w	r4, {r0, r1}
   22dfa:	6037      	str	r7, [r6, #0]
   22dfc:	e885 0003 	stmia.w	r5, {r0, r1}
   22e00:	4d4b      	ldr	r5, [pc, #300]	; (22f30 <adcCheck+0x1cc>)
{
   22e02:	f04f 0b00 	mov.w	fp, #0
   22e06:	4e4b      	ldr	r6, [pc, #300]	; (22f34 <adcCheck+0x1d0>)
   22e08:	4c4b      	ldr	r4, [pc, #300]	; (22f38 <adcCheck+0x1d4>)
   22e0a:	4f4c      	ldr	r7, [pc, #304]	; (22f3c <adcCheck+0x1d8>)
   22e0c:	f8df 8144 	ldr.w	r8, [pc, #324]	; 22f54 <adcCheck+0x1f0>
   22e10:	f8df 9144 	ldr.w	r9, [pc, #324]	; 22f58 <adcCheck+0x1f4>
				else writeKnobFlag = i;
   22e14:	f8df a144 	ldr.w	sl, [pc, #324]	; 22f5c <adcCheck+0x1f8>
   22e18:	e031      	b.n	22e7e <adcCheck+0x11a>
			if (buttonActionsUI[ButtonEdit][ActionHoldContinuous])
   22e1a:	4949      	ldr	r1, [pc, #292]	; (22f40 <adcCheck+0x1dc>)
   22e1c:	78ca      	ldrb	r2, [r1, #3]
   22e1e:	b16a      	cbz	r2, 22e3c <adcCheck+0xd8>
				if (i != 5) cvAddParam[currentPreset] = i + (knobPage * KNOB_PAGE_SIZE);;
   22e20:	f1bb 0f05 	cmp.w	fp, #5
   22e24:	d008      	beq.n	22e38 <adcCheck+0xd4>
   22e26:	4a47      	ldr	r2, [pc, #284]	; (22f44 <adcCheck+0x1e0>)
   22e28:	4847      	ldr	r0, [pc, #284]	; (22f48 <adcCheck+0x1e4>)
   22e2a:	7812      	ldrb	r2, [r2, #0]
   22e2c:	7800      	ldrb	r0, [r0, #0]
   22e2e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   22e32:	4b46      	ldr	r3, [pc, #280]	; (22f4c <adcCheck+0x1e8>)
   22e34:	445a      	add	r2, fp
   22e36:	541a      	strb	r2, [r3, r0]
				buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
   22e38:	2200      	movs	r2, #0
   22e3a:	70ca      	strb	r2, [r1, #3]
			lastFloatADC[i] = floatADC[i];
   22e3c:	ed15 0a01 	vldr	s0, [r5, #-4]
			if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22e40:	f1bb 0f05 	cmp.w	fp, #5
			lastFloatADC[i] = floatADC[i];
   22e44:	ed06 0a01 	vstr	s0, [r6, #-4]
			if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22e48:	d05e      	beq.n	22f08 <adcCheck+0x1a4>
			else writeKnobFlag = i;
   22e4a:	fa4f f28b 	sxtb.w	r2, fp
		if (floatADCUI[i] >= 0.0f)
   22e4e:	edd4 7a00 	vldr	s15, [r4]
			knobActive[i] = 1;
   22e52:	2101      	movs	r1, #1
   22e54:	f88a 2000 	strb.w	r2, [sl]
		if (floatADCUI[i] >= 0.0f)
   22e58:	eef5 7ac0 	vcmpe.f32	s15, #0.0
			knobActive[i] = 1;
   22e5c:	f809 100b 	strb.w	r1, [r9, fp]
		if (floatADCUI[i] >= 0.0f)
   22e60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22e64:	da28      	bge.n	22eb8 <adcCheck+0x154>
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22e66:	4b3a      	ldr	r3, [pc, #232]	; (22f50 <adcCheck+0x1ec>)
   22e68:	eb03 008b 	add.w	r0, r3, fp, lsl #2
   22e6c:	f005 f878 	bl	27f60 <tExpSmooth_setDest>
	for (int i = 0; i < 6; i++)
   22e70:	f10b 0b01 	add.w	fp, fp, #1
   22e74:	3404      	adds	r4, #4
   22e76:	3704      	adds	r7, #4
   22e78:	f1bb 0f06 	cmp.w	fp, #6
   22e7c:	d042      	beq.n	22f04 <adcCheck+0x1a0>
		if (fastabsf(floatADC[i] - lastFloatADC[i]) > adcHysteresisThreshold)
   22e7e:	ecf6 7a01 	vldmia	r6!, {s15}
   22e82:	ecb5 0a01 	vldmia	r5!, {s0}
   22e86:	ee30 0a67 	vsub.f32	s0, s0, s15
   22e8a:	f006 fc23 	bl	296d4 <fastabsf>
   22e8e:	edd8 7a00 	vldr	s15, [r8]
   22e92:	eeb4 0ae7 	vcmpe.f32	s0, s15
   22e96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22e9a:	dcbe      	bgt.n	22e1a <adcCheck+0xb6>
		if (floatADCUI[i] >= 0.0f)
   22e9c:	edd4 7a00 	vldr	s15, [r4]
   22ea0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   22ea4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22ea8:	da06      	bge.n	22eb8 <adcCheck+0x154>
   22eaa:	f819 200b 	ldrb.w	r2, [r9, fp]
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22eae:	2a00      	cmp	r2, #0
   22eb0:	d0de      	beq.n	22e70 <adcCheck+0x10c>
   22eb2:	ed15 0a01 	vldr	s0, [r5, #-4]
   22eb6:	e7d6      	b.n	22e66 <adcCheck+0x102>
			if (fastabsf(smoothedADC[i] - floatADCUI[i]) > adcHysteresisThreshold)
   22eb8:	ed97 0a00 	vldr	s0, [r7]
   22ebc:	ee30 0a67 	vsub.f32	s0, s0, s15
   22ec0:	f006 fc08 	bl	296d4 <fastabsf>
   22ec4:	edd8 7a00 	vldr	s15, [r8]
   22ec8:	f819 200b 	ldrb.w	r2, [r9, fp]
   22ecc:	eeb4 0ae7 	vcmpe.f32	s0, s15
   22ed0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   22ed4:	ddeb      	ble.n	22eae <adcCheck+0x14a>
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22ed6:	f1bb 0f05 	cmp.w	fp, #5
   22eda:	d004      	beq.n	22ee6 <adcCheck+0x182>
				else writeKnobFlag = i;
   22edc:	f88a b000 	strb.w	fp, [sl]
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22ee0:	2a00      	cmp	r2, #0
   22ee2:	d0c5      	beq.n	22e70 <adcCheck+0x10c>
   22ee4:	e7e5      	b.n	22eb2 <adcCheck+0x14e>
				if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22ee6:	4917      	ldr	r1, [pc, #92]	; (22f44 <adcCheck+0x1e0>)
   22ee8:	4817      	ldr	r0, [pc, #92]	; (22f48 <adcCheck+0x1e4>)
   22eea:	7809      	ldrb	r1, [r1, #0]
   22eec:	7800      	ldrb	r0, [r0, #0]
   22eee:	ebc1 1c81 	rsb	ip, r1, r1, lsl #6
   22ef2:	4b16      	ldr	r3, [pc, #88]	; (22f4c <adcCheck+0x1e8>)
   22ef4:	ebc1 018c 	rsb	r1, r1, ip, lsl #2
   22ef8:	5c18      	ldrb	r0, [r3, r0]
   22efa:	4401      	add	r1, r0
   22efc:	f88a 1000 	strb.w	r1, [sl]
		if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
   22f00:	2a00      	cmp	r2, #0
   22f02:	d1d6      	bne.n	22eb2 <adcCheck+0x14e>
}
   22f04:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
   22f08:	490e      	ldr	r1, [pc, #56]	; (22f44 <adcCheck+0x1e0>)
   22f0a:	4a0f      	ldr	r2, [pc, #60]	; (22f48 <adcCheck+0x1e4>)
   22f0c:	7809      	ldrb	r1, [r1, #0]
   22f0e:	7812      	ldrb	r2, [r2, #0]
   22f10:	ebc1 1081 	rsb	r0, r1, r1, lsl #6
   22f14:	4b0d      	ldr	r3, [pc, #52]	; (22f4c <adcCheck+0x1e8>)
   22f16:	ebc1 0180 	rsb	r1, r1, r0, lsl #2
   22f1a:	5c9a      	ldrb	r2, [r3, r2]
   22f1c:	440a      	add	r2, r1
   22f1e:	b252      	sxtb	r2, r2
   22f20:	e795      	b.n	22e4e <adcCheck+0xea>
   22f22:	bf00      	nop
   22f24:	00063dc0 	.word	0x00063dc0
   22f28:	3a800000 	.word	0x3a800000
   22f2c:	00062b5c 	.word	0x00062b5c
   22f30:	020fb304 	.word	0x020fb304
   22f34:	020fb554 	.word	0x020fb554
   22f38:	020fb444 	.word	0x020fb444
   22f3c:	020f6f08 	.word	0x020f6f08
   22f40:	020fb45c 	.word	0x020fb45c
   22f44:	020e325a 	.word	0x020e325a
   22f48:	020e3259 	.word	0x020e3259
   22f4c:	020fb540 	.word	0x020fb540
   22f50:	020f6ea8 	.word	0x020f6ea8
   22f54:	00062b4c 	.word	0x00062b4c
   22f58:	020fa550 	.word	0x020fa550
   22f5c:	00062b63 	.word	0x00062b63

00022f60 <resetKnobValues>:
{
   22f60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		floatADCUI[i] = -1.0f;
   22f64:	4820      	ldr	r0, [pc, #128]	; (22fe8 <resetKnobValues+0x88>)
		knobActive[i] = 0;
   22f66:	2600      	movs	r6, #0
   22f68:	4f20      	ldr	r7, [pc, #128]	; (22fec <resetKnobValues+0x8c>)
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22f6a:	f04f 0a05 	mov.w	sl, #5
	for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   22f6e:	4634      	mov	r4, r6
		floatADCUI[i] = -1.0f;
   22f70:	f8df b098 	ldr.w	fp, [pc, #152]	; 2300c <resetKnobValues+0xac>
		knobActive[i] = 0;
   22f74:	46b1      	mov	r9, r6
   22f76:	f8df 8090 	ldr.w	r8, [pc, #144]	; 23008 <resetKnobValues+0xa8>
   22f7a:	4d1d      	ldr	r5, [pc, #116]	; (22ff0 <resetKnobValues+0x90>)
		floatADCUI[i] = -1.0f;
   22f7c:	f84b 0b04 	str.w	r0, [fp], #4
{
   22f80:	ed2d 8b02 	vpush	{d8}
		knobActive[i] = 0;
   22f84:	f807 6b01 	strb.w	r6, [r7], #1
		floatADCUI[i] = -1.0f;
   22f88:	ee08 0a90 	vmov	s17, r0
   22f8c:	4e19      	ldr	r6, [pc, #100]	; (22ff4 <resetKnobValues+0x94>)
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22f8e:	4b1a      	ldr	r3, [pc, #104]	; (22ff8 <resetKnobValues+0x98>)
		tExpSmooth_setValAndDest(&adc[i], value);
   22f90:	4628      	mov	r0, r5
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22f92:	7832      	ldrb	r2, [r6, #0]
   22f94:	3504      	adds	r5, #4
   22f96:	781b      	ldrb	r3, [r3, #0]
   22f98:	fb1a 4202 	smlabb	r2, sl, r2, r4
	for (int i = 0; i < NUM_ADC_CHANNELS; i++)
   22f9c:	3401      	adds	r4, #1
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22f9e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   22fa2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   22fa6:	4413      	add	r3, r2
   22fa8:	4a14      	ldr	r2, [pc, #80]	; (22ffc <resetKnobValues+0x9c>)
   22faa:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   22fae:	ed93 8a00 	vldr	s16, [r3]
		tExpSmooth_setValAndDest(&adc[i], value);
   22fb2:	eeb0 0a48 	vmov.f32	s0, s16
   22fb6:	f004 ffd7 	bl	27f68 <tExpSmooth_setValAndDest>
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22fba:	2c05      	cmp	r4, #5
		smoothedADC[i] = value;
   22fbc:	eca8 8a01 	vstmia	r8!, {s16}
		knobActive[i] = 0;
   22fc0:	f807 9b01 	strb.w	r9, [r7], #1
		floatADCUI[i] = -1.0f;
   22fc4:	eceb 8a01 	vstmia	fp!, {s17}
		if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
   22fc8:	d1e1      	bne.n	22f8e <resetKnobValues+0x2e>
		tExpSmooth_setValAndDest(&adc[i], value);
   22fca:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 23000 <resetKnobValues+0xa0>
   22fce:	480d      	ldr	r0, [pc, #52]	; (23004 <resetKnobValues+0xa4>)
   22fd0:	eeb0 0a48 	vmov.f32	s0, s16
   22fd4:	f004 ffc8 	bl	27f68 <tExpSmooth_setValAndDest>
		smoothedADC[i] = value;
   22fd8:	4b0b      	ldr	r3, [pc, #44]	; (23008 <resetKnobValues+0xa8>)
   22fda:	ed83 8a05 	vstr	s16, [r3, #20]
}
   22fde:	ecbd 8b02 	vpop	{d8}
   22fe2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22fe6:	bf00      	nop
   22fe8:	bf800000 	.word	0xbf800000
   22fec:	020fa550 	.word	0x020fa550
   22ff0:	020f6ea8 	.word	0x020f6ea8
   22ff4:	020e325a 	.word	0x020e325a
   22ff8:	020e3259 	.word	0x020e3259
   22ffc:	020f9318 	.word	0x020f9318
   23000:	00000000 	.word	0x00000000
   23004:	020f6ebc 	.word	0x020f6ebc
   23008:	020f6f08 	.word	0x020f6f08
   2300c:	020fb444 	.word	0x020fb444

00023010 <UIVocoderButtons>:
}

char* UIVocoderButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23010:	4b15      	ldr	r3, [pc, #84]	; (23068 <UIVocoderButtons+0x58>)
{
   23012:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23014:	7d1a      	ldrb	r2, [r3, #20]
   23016:	2a01      	cmp	r2, #1
   23018:	d01b      	beq.n	23052 <UIVocoderButtons+0x42>
	char* writeString = "";
   2301a:	4814      	ldr	r0, [pc, #80]	; (2306c <UIVocoderButtons+0x5c>)
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2301c:	7e1a      	ldrb	r2, [r3, #24]
   2301e:	2a01      	cmp	r2, #1
   23020:	d108      	bne.n	23034 <UIVocoderButtons+0x24>
	{
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   23022:	4a13      	ldr	r2, [pc, #76]	; (23070 <UIVocoderButtons+0x60>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23024:	2400      	movs	r4, #0
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   23026:	4813      	ldr	r0, [pc, #76]	; (23074 <UIVocoderButtons+0x64>)
   23028:	7811      	ldrb	r1, [r2, #0]
   2302a:	4a13      	ldr	r2, [pc, #76]	; (23078 <UIVocoderButtons+0x68>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2302c:	761c      	strb	r4, [r3, #24]
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   2302e:	42a1      	cmp	r1, r4
   23030:	bf08      	it	eq
   23032:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   23034:	7f1a      	ldrb	r2, [r3, #28]
   23036:	2a01      	cmp	r2, #1
   23038:	d108      	bne.n	2304c <UIVocoderButtons+0x3c>
	{
		writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   2303a:	4a10      	ldr	r2, [pc, #64]	; (2307c <UIVocoderButtons+0x6c>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   2303c:	2400      	movs	r4, #0
		writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   2303e:	4810      	ldr	r0, [pc, #64]	; (23080 <UIVocoderButtons+0x70>)
   23040:	6811      	ldr	r1, [r2, #0]
   23042:	4a10      	ldr	r2, [pc, #64]	; (23084 <UIVocoderButtons+0x74>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23044:	771c      	strb	r4, [r3, #28]
		writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
   23046:	42a1      	cmp	r1, r4
   23048:	bf08      	it	eq
   2304a:	4610      	moveq	r0, r2
	}
	return writeString;
}
   2304c:	f85d 4b04 	ldr.w	r4, [sp], #4
   23050:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23052:	4a0d      	ldr	r2, [pc, #52]	; (23088 <UIVocoderButtons+0x78>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23054:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23056:	480d      	ldr	r0, [pc, #52]	; (2308c <UIVocoderButtons+0x7c>)
   23058:	7811      	ldrb	r1, [r2, #0]
   2305a:	4a0d      	ldr	r2, [pc, #52]	; (23090 <UIVocoderButtons+0x80>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2305c:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   2305e:	2901      	cmp	r1, #1
   23060:	bf98      	it	ls
   23062:	4610      	movls	r0, r2
   23064:	e7da      	b.n	2301c <UIVocoderButtons+0xc>
   23066:	bf00      	nop
   23068:	020fb45c 	.word	0x020fb45c
   2306c:	0003209c 	.word	0x0003209c
   23070:	020e31a4 	.word	0x020e31a4
   23074:	000320d0 	.word	0x000320d0
   23078:	000320dc 	.word	0x000320dc
   2307c:	020e321c 	.word	0x020e321c
   23080:	000320e8 	.word	0x000320e8
   23084:	000320f0 	.word	0x000320f0
   23088:	00062ae4 	.word	0x00062ae4
   2308c:	000320c0 	.word	0x000320c0
   23090:	000320c8 	.word	0x000320c8

00023094 <UIVocoderChButtons>:

char* UIVocoderChButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23094:	4b15      	ldr	r3, [pc, #84]	; (230ec <UIVocoderChButtons+0x58>)
{
   23096:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23098:	7d1a      	ldrb	r2, [r3, #20]
   2309a:	2a01      	cmp	r2, #1
   2309c:	d01b      	beq.n	230d6 <UIVocoderChButtons+0x42>
	char* writeString = "";
   2309e:	4814      	ldr	r0, [pc, #80]	; (230f0 <UIVocoderChButtons+0x5c>)
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   230a0:	7e1a      	ldrb	r2, [r3, #24]
   230a2:	2a01      	cmp	r2, #1
   230a4:	d108      	bne.n	230b8 <UIVocoderChButtons+0x24>
	{
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   230a6:	4a13      	ldr	r2, [pc, #76]	; (230f4 <UIVocoderChButtons+0x60>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   230a8:	2400      	movs	r4, #0
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   230aa:	4813      	ldr	r0, [pc, #76]	; (230f8 <UIVocoderChButtons+0x64>)
   230ac:	7811      	ldrb	r1, [r2, #0]
   230ae:	4a13      	ldr	r2, [pc, #76]	; (230fc <UIVocoderChButtons+0x68>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   230b0:	761c      	strb	r4, [r3, #24]
		writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
   230b2:	42a1      	cmp	r1, r4
   230b4:	bf08      	it	eq
   230b6:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   230b8:	7f1a      	ldrb	r2, [r3, #28]
   230ba:	2a01      	cmp	r2, #1
   230bc:	d108      	bne.n	230d0 <UIVocoderChButtons+0x3c>
	{
		writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   230be:	4a10      	ldr	r2, [pc, #64]	; (23100 <UIVocoderChButtons+0x6c>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   230c0:	2400      	movs	r4, #0
		writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   230c2:	4810      	ldr	r0, [pc, #64]	; (23104 <UIVocoderChButtons+0x70>)
   230c4:	6811      	ldr	r1, [r2, #0]
   230c6:	4a10      	ldr	r2, [pc, #64]	; (23108 <UIVocoderChButtons+0x74>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   230c8:	771c      	strb	r4, [r3, #28]
		writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
   230ca:	42a1      	cmp	r1, r4
   230cc:	bf08      	it	eq
   230ce:	4610      	moveq	r0, r2
	}
	return writeString;
}
   230d0:	f85d 4b04 	ldr.w	r4, [sp], #4
   230d4:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   230d6:	4a0d      	ldr	r2, [pc, #52]	; (2310c <UIVocoderChButtons+0x78>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   230d8:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   230da:	480d      	ldr	r0, [pc, #52]	; (23110 <UIVocoderChButtons+0x7c>)
   230dc:	7811      	ldrb	r1, [r2, #0]
   230de:	4a0d      	ldr	r2, [pc, #52]	; (23114 <UIVocoderChButtons+0x80>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   230e0:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   230e2:	2901      	cmp	r1, #1
   230e4:	bf98      	it	ls
   230e6:	4610      	movls	r0, r2
   230e8:	e7da      	b.n	230a0 <UIVocoderChButtons+0xc>
   230ea:	bf00      	nop
   230ec:	020fb45c 	.word	0x020fb45c
   230f0:	0003209c 	.word	0x0003209c
   230f4:	020e31a4 	.word	0x020e31a4
   230f8:	000320d0 	.word	0x000320d0
   230fc:	000320dc 	.word	0x000320dc
   23100:	020e3218 	.word	0x020e3218
   23104:	000320e8 	.word	0x000320e8
   23108:	000320f0 	.word	0x000320f0
   2310c:	00062ae4 	.word	0x00062ae4
   23110:	000320c0 	.word	0x000320c0
   23114:	000320c8 	.word	0x000320c8

00023118 <UIPitchShiftButtons>:

char* UIPitchShiftButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	return writeString;
}
   23118:	4800      	ldr	r0, [pc, #0]	; (2311c <UIPitchShiftButtons+0x4>)
   2311a:	4770      	bx	lr
   2311c:	0003209c 	.word	0x0003209c

00023120 <UINeartuneButtons>:

char* UINeartuneButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   23120:	4b0e      	ldr	r3, [pc, #56]	; (2315c <UINeartuneButtons+0x3c>)
{
   23122:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress])
   23124:	7d1a      	ldrb	r2, [r3, #20]
   23126:	b1b2      	cbz	r2, 23156 <UINeartuneButtons+0x36>
	{
		writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   23128:	4a0d      	ldr	r2, [pc, #52]	; (23160 <UINeartuneButtons+0x40>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2312a:	2400      	movs	r4, #0
		writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   2312c:	480d      	ldr	r0, [pc, #52]	; (23164 <UINeartuneButtons+0x44>)
   2312e:	7811      	ldrb	r1, [r2, #0]
   23130:	4a0d      	ldr	r2, [pc, #52]	; (23168 <UINeartuneButtons+0x48>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23132:	751c      	strb	r4, [r3, #20]
		writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
   23134:	42a1      	cmp	r1, r4
   23136:	bf08      	it	eq
   23138:	4610      	moveq	r0, r2
	}

	if (buttonActionsUI[ButtonC][ActionPress])
   2313a:	7f1a      	ldrb	r2, [r3, #28]
   2313c:	b142      	cbz	r2, 23150 <UINeartuneButtons+0x30>
	{
		writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   2313e:	4a0b      	ldr	r2, [pc, #44]	; (2316c <UINeartuneButtons+0x4c>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23140:	2400      	movs	r4, #0
		writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   23142:	480b      	ldr	r0, [pc, #44]	; (23170 <UINeartuneButtons+0x50>)
   23144:	6811      	ldr	r1, [r2, #0]
   23146:	4a0b      	ldr	r2, [pc, #44]	; (23174 <UINeartuneButtons+0x54>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23148:	771c      	strb	r4, [r3, #28]
		writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
   2314a:	42a1      	cmp	r1, r4
   2314c:	bf08      	it	eq
   2314e:	4610      	moveq	r0, r2
	}


	return writeString;
}
   23150:	f85d 4b04 	ldr.w	r4, [sp], #4
   23154:	4770      	bx	lr
	char* writeString = "";
   23156:	4808      	ldr	r0, [pc, #32]	; (23178 <UINeartuneButtons+0x58>)
   23158:	e7ef      	b.n	2313a <UINeartuneButtons+0x1a>
   2315a:	bf00      	nop
   2315c:	020fb45c 	.word	0x020fb45c
   23160:	020e3124 	.word	0x020e3124
   23164:	00031fc4 	.word	0x00031fc4
   23168:	00031fd4 	.word	0x00031fd4
   2316c:	020e3128 	.word	0x020e3128
   23170:	00031fe4 	.word	0x00031fe4
   23174:	00031ff4 	.word	0x00031ff4
   23178:	0003209c 	.word	0x0003209c

0002317c <UIAutotuneButtons>:
   2317c:	4800      	ldr	r0, [pc, #0]	; (23180 <UIAutotuneButtons+0x4>)
   2317e:	4770      	bx	lr
   23180:	0003209c 	.word	0x0003209c

00023184 <UISamplerBPButtons>:
	char* writeString = "";
	return writeString;
}

char* UISamplerBPButtons(VocodecButton button, ButtonAction action)
{
   23184:	b570      	push	{r4, r5, r6, lr}
	char* writeString = "";
	if (buttonActionsUI[ButtonC][ActionPress])
   23186:	4c31      	ldr	r4, [pc, #196]	; (2324c <UISamplerBPButtons+0xc8>)
   23188:	7f23      	ldrb	r3, [r4, #28]
   2318a:	2b00      	cmp	r3, #0
   2318c:	d144      	bne.n	23218 <UISamplerBPButtons+0x94>
		OLEDwriteFloat(sampleLength, 0, SecondLine);
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
		buttonActionsUI[ButtonC][ActionPress] = 0;
	}

	if (buttonActionsUI[ButtonB][ActionPress])
   2318e:	7e23      	ldrb	r3, [r4, #24]
   23190:	bb83      	cbnz	r3, 231f4 <UISamplerBPButtons+0x70>
	{
		OLEDclearLine(SecondLine);
		OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
		buttonActionsUI[ButtonB][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonA][ActionHoldContinuous])
   23192:	7de3      	ldrb	r3, [r4, #23]
   23194:	b9db      	cbnz	r3, 231ce <UISamplerBPButtons+0x4a>
		OLEDclearLine(SecondLine);
		OLEDwriteString("RECORDING", 9, 0, SecondLine);
		OLEDwriteFloat(sampleLength, 84, SecondLine);
		buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
	}
	if (buttonActionsUI[ButtonA][ActionRelease])
   23196:	7d63      	ldrb	r3, [r4, #21]
   23198:	b1bb      	cbz	r3, 231ca <UISamplerBPButtons+0x46>
	{
		OLEDclearLine(SecondLine);
   2319a:	2001      	movs	r0, #1
		OLEDwriteFloat(sampleLength, 0, SecondLine);
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   2319c:	4d2c      	ldr	r5, [pc, #176]	; (23250 <UISamplerBPButtons+0xcc>)
		OLEDclearLine(SecondLine);
   2319e:	f7f6 fbf5 	bl	1998c <OLEDclearLine>
		OLEDwriteFloat(sampleLength, 0, SecondLine);
   231a2:	4b2c      	ldr	r3, [pc, #176]	; (23254 <UISamplerBPButtons+0xd0>)
   231a4:	2101      	movs	r1, #1
   231a6:	2000      	movs	r0, #0
   231a8:	ed93 0a00 	vldr	s0, [r3]
   231ac:	f7f6 fcc0 	bl	19b30 <OLEDwriteFloat>
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   231b0:	4a29      	ldr	r2, [pc, #164]	; (23258 <UISamplerBPButtons+0xd4>)
   231b2:	482a      	ldr	r0, [pc, #168]	; (2325c <UISamplerBPButtons+0xd8>)
   231b4:	2301      	movs	r3, #1
   231b6:	7816      	ldrb	r6, [r2, #0]
   231b8:	2107      	movs	r1, #7
   231ba:	2230      	movs	r2, #48	; 0x30
   231bc:	2e00      	cmp	r6, #0
   231be:	bf08      	it	eq
   231c0:	4628      	moveq	r0, r5
   231c2:	f7f6 fbf7 	bl	199b4 <OLEDwriteString>
		buttonActionsUI[ButtonA][ActionRelease] = 0;
   231c6:	2300      	movs	r3, #0
   231c8:	7563      	strb	r3, [r4, #21]
	}
	return writeString;
}
   231ca:	4825      	ldr	r0, [pc, #148]	; (23260 <UISamplerBPButtons+0xdc>)
   231cc:	bd70      	pop	{r4, r5, r6, pc}
		OLEDclearLine(SecondLine);
   231ce:	2001      	movs	r0, #1
   231d0:	f7f6 fbdc 	bl	1998c <OLEDclearLine>
		OLEDwriteString("RECORDING", 9, 0, SecondLine);
   231d4:	2301      	movs	r3, #1
   231d6:	2200      	movs	r2, #0
   231d8:	2109      	movs	r1, #9
   231da:	4822      	ldr	r0, [pc, #136]	; (23264 <UISamplerBPButtons+0xe0>)
   231dc:	f7f6 fbea 	bl	199b4 <OLEDwriteString>
		OLEDwriteFloat(sampleLength, 84, SecondLine);
   231e0:	4b1c      	ldr	r3, [pc, #112]	; (23254 <UISamplerBPButtons+0xd0>)
   231e2:	2101      	movs	r1, #1
   231e4:	2054      	movs	r0, #84	; 0x54
   231e6:	ed93 0a00 	vldr	s0, [r3]
   231ea:	f7f6 fca1 	bl	19b30 <OLEDwriteFloat>
		buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
   231ee:	2300      	movs	r3, #0
   231f0:	75e3      	strb	r3, [r4, #23]
   231f2:	e7d0      	b.n	23196 <UISamplerBPButtons+0x12>
		OLEDclearLine(SecondLine);
   231f4:	2001      	movs	r0, #1
		OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
   231f6:	4d1c      	ldr	r5, [pc, #112]	; (23268 <UISamplerBPButtons+0xe4>)
		OLEDclearLine(SecondLine);
   231f8:	f7f6 fbc8 	bl	1998c <OLEDclearLine>
		OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
   231fc:	4a1b      	ldr	r2, [pc, #108]	; (2326c <UISamplerBPButtons+0xe8>)
   231fe:	481c      	ldr	r0, [pc, #112]	; (23270 <UISamplerBPButtons+0xec>)
   23200:	2301      	movs	r3, #1
   23202:	6816      	ldr	r6, [r2, #0]
   23204:	2200      	movs	r2, #0
   23206:	210c      	movs	r1, #12
   23208:	4296      	cmp	r6, r2
   2320a:	bf08      	it	eq
   2320c:	4628      	moveq	r0, r5
   2320e:	f7f6 fbd1 	bl	199b4 <OLEDwriteString>
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23212:	2300      	movs	r3, #0
   23214:	7623      	strb	r3, [r4, #24]
   23216:	e7bc      	b.n	23192 <UISamplerBPButtons+0xe>
		OLEDclearLine(SecondLine);
   23218:	2001      	movs	r0, #1
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   2321a:	4d0d      	ldr	r5, [pc, #52]	; (23250 <UISamplerBPButtons+0xcc>)
		OLEDclearLine(SecondLine);
   2321c:	f7f6 fbb6 	bl	1998c <OLEDclearLine>
		OLEDwriteFloat(sampleLength, 0, SecondLine);
   23220:	4b0c      	ldr	r3, [pc, #48]	; (23254 <UISamplerBPButtons+0xd0>)
   23222:	2101      	movs	r1, #1
   23224:	2000      	movs	r0, #0
   23226:	ed93 0a00 	vldr	s0, [r3]
   2322a:	f7f6 fc81 	bl	19b30 <OLEDwriteFloat>
		OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
   2322e:	4a0a      	ldr	r2, [pc, #40]	; (23258 <UISamplerBPButtons+0xd4>)
   23230:	480a      	ldr	r0, [pc, #40]	; (2325c <UISamplerBPButtons+0xd8>)
   23232:	2301      	movs	r3, #1
   23234:	7816      	ldrb	r6, [r2, #0]
   23236:	2107      	movs	r1, #7
   23238:	2230      	movs	r2, #48	; 0x30
   2323a:	2e00      	cmp	r6, #0
   2323c:	bf08      	it	eq
   2323e:	4628      	moveq	r0, r5
   23240:	f7f6 fbb8 	bl	199b4 <OLEDwriteString>
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23244:	2300      	movs	r3, #0
   23246:	7723      	strb	r3, [r4, #28]
   23248:	e7a1      	b.n	2318e <UISamplerBPButtons+0xa>
   2324a:	bf00      	nop
   2324c:	020fb45c 	.word	0x020fb45c
   23250:	00032078 	.word	0x00032078
   23254:	020e3204 	.word	0x020e3204
   23258:	00062b38 	.word	0x00062b38
   2325c:	00032070 	.word	0x00032070
   23260:	0003209c 	.word	0x0003209c
   23264:	000320a0 	.word	0x000320a0
   23268:	00032090 	.word	0x00032090
   2326c:	020e312c 	.word	0x020e312c
   23270:	00032080 	.word	0x00032080

00023274 <UISamplerKButtons>:

char* UISamplerKButtons(VocodecButton button, ButtonAction action)
{
   23274:	b510      	push	{r4, lr}
	char* writeString = "";


	if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
   23276:	4c1d      	ldr	r4, [pc, #116]	; (232ec <UISamplerKButtons+0x78>)
   23278:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
{
   2327c:	ed2d 8b02 	vpush	{d8}
	if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
   23280:	b97b      	cbnz	r3, 232a2 <UISamplerKButtons+0x2e>
   23282:	7d23      	ldrb	r3, [r4, #20]
   23284:	b96b      	cbnz	r3, 232a2 <UISamplerKButtons+0x2e>
		OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
		buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}

	if (buttonActionsUI[ButtonB][ActionPress])
   23286:	7e23      	ldrb	r3, [r4, #24]
   23288:	b363      	cbz	r3, 232e4 <UISamplerKButtons+0x70>
	{
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   2328a:	4b19      	ldr	r3, [pc, #100]	; (232f0 <UISamplerKButtons+0x7c>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2328c:	2100      	movs	r1, #0
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   2328e:	4819      	ldr	r0, [pc, #100]	; (232f4 <UISamplerKButtons+0x80>)
   23290:	681a      	ldr	r2, [r3, #0]
   23292:	4b19      	ldr	r3, [pc, #100]	; (232f8 <UISamplerKButtons+0x84>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23294:	7621      	strb	r1, [r4, #24]
		writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
   23296:	428a      	cmp	r2, r1
   23298:	bf08      	it	eq
   2329a:	4618      	moveq	r0, r3
	}
	return writeString;
}
   2329c:	ecbd 8b02 	vpop	{d8}
   232a0:	bd10      	pop	{r4, pc}
		OLEDclearLine(SecondLine);
   232a2:	2001      	movs	r0, #1
   232a4:	f7f6 fb72 	bl	1998c <OLEDclearLine>
		OLEDwritePitch(currentSamplerKeyGlobal + LOWEST_SAMPLER_KEY, 0, SecondLine, false);
   232a8:	4b14      	ldr	r3, [pc, #80]	; (232fc <UISamplerKButtons+0x88>)
   232aa:	2200      	movs	r2, #0
   232ac:	2101      	movs	r1, #1
   232ae:	681b      	ldr	r3, [r3, #0]
   232b0:	4610      	mov	r0, r2
   232b2:	3324      	adds	r3, #36	; 0x24
   232b4:	ee00 3a10 	vmov	s0, r3
   232b8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   232bc:	f7f6 fbd6 	bl	19a6c <OLEDwritePitch>
		OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
   232c0:	4b0f      	ldr	r3, [pc, #60]	; (23300 <UISamplerKButtons+0x8c>)
   232c2:	ed93 8a00 	vldr	s16, [r3]
   232c6:	f7f6 fdf1 	bl	19eac <OLEDgetCursor>
   232ca:	2101      	movs	r1, #1
   232cc:	b2c0      	uxtb	r0, r0
   232ce:	eeb0 0a48 	vmov.f32	s0, s16
   232d2:	f7f6 fc2d 	bl	19b30 <OLEDwriteFloat>
		buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
   232d6:	2300      	movs	r3, #0
   232d8:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
		buttonActionsUI[ButtonA][ActionPress] = 0;
   232dc:	7523      	strb	r3, [r4, #20]
	if (buttonActionsUI[ButtonB][ActionPress])
   232de:	7e23      	ldrb	r3, [r4, #24]
   232e0:	2b00      	cmp	r3, #0
   232e2:	d1d2      	bne.n	2328a <UISamplerKButtons+0x16>
	char* writeString = "";
   232e4:	4807      	ldr	r0, [pc, #28]	; (23304 <UISamplerKButtons+0x90>)
}
   232e6:	ecbd 8b02 	vpop	{d8}
   232ea:	bd10      	pop	{r4, pc}
   232ec:	020fb45c 	.word	0x020fb45c
   232f0:	020e3168 	.word	0x020e3168
   232f4:	000320ac 	.word	0x000320ac
   232f8:	000320b4 	.word	0x000320b4
   232fc:	00062ab4 	.word	0x00062ab4
   23300:	020e3204 	.word	0x020e3204
   23304:	0003209c 	.word	0x0003209c

00023308 <UISamplerAutoButtons>:

char* UISamplerAutoButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   23308:	4b15      	ldr	r3, [pc, #84]	; (23360 <UISamplerAutoButtons+0x58>)
{
   2330a:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress])
   2330c:	7d1a      	ldrb	r2, [r3, #20]
   2330e:	b15a      	cbz	r2, 23328 <UISamplerAutoButtons+0x20>
	{
		if (samplerMode == PlayLoop)
   23310:	4a14      	ldr	r2, [pc, #80]	; (23364 <UISamplerAutoButtons+0x5c>)
   23312:	7812      	ldrb	r2, [r2, #0]
   23314:	2a01      	cmp	r2, #1
   23316:	d021      	beq.n	2335c <UISamplerAutoButtons+0x54>
		{
			writeString = "LOOP";
		}
		else if (samplerMode == PlayBackAndForth)
		{
			writeString = "BACK'N'FORTH";
   23318:	4813      	ldr	r0, [pc, #76]	; (23368 <UISamplerAutoButtons+0x60>)
   2331a:	4914      	ldr	r1, [pc, #80]	; (2336c <UISamplerAutoButtons+0x64>)
   2331c:	2a02      	cmp	r2, #2
   2331e:	bf08      	it	eq
   23320:	4608      	moveq	r0, r1
		}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23322:	2200      	movs	r2, #0
   23324:	751a      	strb	r2, [r3, #20]
   23326:	e000      	b.n	2332a <UISamplerAutoButtons+0x22>
	char* writeString = "";
   23328:	480f      	ldr	r0, [pc, #60]	; (23368 <UISamplerAutoButtons+0x60>)
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   2332a:	7e1a      	ldrb	r2, [r3, #24]
   2332c:	b142      	cbz	r2, 23340 <UISamplerAutoButtons+0x38>
	{
		writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   2332e:	4a10      	ldr	r2, [pc, #64]	; (23370 <UISamplerAutoButtons+0x68>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23330:	2400      	movs	r4, #0
		writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   23332:	4810      	ldr	r0, [pc, #64]	; (23374 <UISamplerAutoButtons+0x6c>)
   23334:	7811      	ldrb	r1, [r2, #0]
   23336:	4a10      	ldr	r2, [pc, #64]	; (23378 <UISamplerAutoButtons+0x70>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23338:	761c      	strb	r4, [r3, #24]
		writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
   2333a:	42a1      	cmp	r1, r4
   2333c:	bf08      	it	eq
   2333e:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress])
   23340:	7f1a      	ldrb	r2, [r3, #28]
   23342:	b142      	cbz	r2, 23356 <UISamplerAutoButtons+0x4e>
	{
		writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   23344:	4a0d      	ldr	r2, [pc, #52]	; (2337c <UISamplerAutoButtons+0x74>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23346:	2400      	movs	r4, #0
		writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   23348:	480d      	ldr	r0, [pc, #52]	; (23380 <UISamplerAutoButtons+0x78>)
   2334a:	6811      	ldr	r1, [r2, #0]
   2334c:	4a0d      	ldr	r2, [pc, #52]	; (23384 <UISamplerAutoButtons+0x7c>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   2334e:	771c      	strb	r4, [r3, #28]
		writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
   23350:	42a1      	cmp	r1, r4
   23352:	bf08      	it	eq
   23354:	4610      	moveq	r0, r2
	}
	return writeString;
}
   23356:	f85d 4b04 	ldr.w	r4, [sp], #4
   2335a:	4770      	bx	lr
			writeString = "LOOP";
   2335c:	480a      	ldr	r0, [pc, #40]	; (23388 <UISamplerAutoButtons+0x80>)
   2335e:	e7e0      	b.n	23322 <UISamplerAutoButtons+0x1a>
   23360:	020fb45c 	.word	0x020fb45c
   23364:	00062b39 	.word	0x00062b39
   23368:	0003209c 	.word	0x0003209c
   2336c:	00032030 	.word	0x00032030
   23370:	020e3215 	.word	0x020e3215
   23374:	00032040 	.word	0x00032040
   23378:	0003204c 	.word	0x0003204c
   2337c:	020e31e4 	.word	0x020e31e4
   23380:	00032058 	.word	0x00032058
   23384:	00032064 	.word	0x00032064
   23388:	00032028 	.word	0x00032028

0002338c <UIDistortionButtons>:

char* UIDistortionButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   2338c:	4b08      	ldr	r3, [pc, #32]	; (233b0 <UIDistortionButtons+0x24>)
   2338e:	7d1a      	ldrb	r2, [r3, #20]
   23390:	b162      	cbz	r2, 233ac <UIDistortionButtons+0x20>
	{
		writeString = distortionMode ? "SHAPER" : "TANH";
   23392:	4a08      	ldr	r2, [pc, #32]	; (233b4 <UIDistortionButtons+0x28>)
   23394:	4808      	ldr	r0, [pc, #32]	; (233b8 <UIDistortionButtons+0x2c>)
{
   23396:	b410      	push	{r4}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23398:	2400      	movs	r4, #0
		writeString = distortionMode ? "SHAPER" : "TANH";
   2339a:	7811      	ldrb	r1, [r2, #0]
   2339c:	4a07      	ldr	r2, [pc, #28]	; (233bc <UIDistortionButtons+0x30>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2339e:	751c      	strb	r4, [r3, #20]
		writeString = distortionMode ? "SHAPER" : "TANH";
   233a0:	42a1      	cmp	r1, r4
   233a2:	bf08      	it	eq
   233a4:	4610      	moveq	r0, r2
	}
	return writeString;
}
   233a6:	f85d 4b04 	ldr.w	r4, [sp], #4
   233aa:	4770      	bx	lr
	char* writeString = "";
   233ac:	4804      	ldr	r0, [pc, #16]	; (233c0 <UIDistortionButtons+0x34>)
}
   233ae:	4770      	bx	lr
   233b0:	020fb45c 	.word	0x020fb45c
   233b4:	020e3184 	.word	0x020e3184
   233b8:	00031f54 	.word	0x00031f54
   233bc:	00031f5c 	.word	0x00031f5c
   233c0:	0003209c 	.word	0x0003209c

000233c4 <UIWaveFolderButtons>:

char* UIWaveFolderButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   233c4:	4b08      	ldr	r3, [pc, #32]	; (233e8 <UIWaveFolderButtons+0x24>)
   233c6:	7d1a      	ldrb	r2, [r3, #20]
   233c8:	b162      	cbz	r2, 233e4 <UIWaveFolderButtons+0x20>
	{
		writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   233ca:	4a08      	ldr	r2, [pc, #32]	; (233ec <UIWaveFolderButtons+0x28>)
   233cc:	4808      	ldr	r0, [pc, #32]	; (233f0 <UIWaveFolderButtons+0x2c>)
{
   233ce:	b410      	push	{r4}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   233d0:	2400      	movs	r4, #0
		writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   233d2:	6811      	ldr	r1, [r2, #0]
   233d4:	4a07      	ldr	r2, [pc, #28]	; (233f4 <UIWaveFolderButtons+0x30>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   233d6:	751c      	strb	r4, [r3, #20]
		writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
   233d8:	42a1      	cmp	r1, r4
   233da:	bf08      	it	eq
   233dc:	4610      	moveq	r0, r2
	}
	return writeString;
}
   233de:	f85d 4b04 	ldr.w	r4, [sp], #4
   233e2:	4770      	bx	lr
	char* writeString = "";
   233e4:	4804      	ldr	r0, [pc, #16]	; (233f8 <UIWaveFolderButtons+0x34>)
}
   233e6:	4770      	bx	lr
   233e8:	020fb45c 	.word	0x020fb45c
   233ec:	020e3194 	.word	0x020e3194
   233f0:	000320fc 	.word	0x000320fc
   233f4:	0003210c 	.word	0x0003210c
   233f8:	0003209c 	.word	0x0003209c

000233fc <UIBitcrusherButtons>:

char* UIBitcrusherButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";

	if (buttonActionsUI[ButtonA][ActionPress])
   233fc:	4b08      	ldr	r3, [pc, #32]	; (23420 <UIBitcrusherButtons+0x24>)
   233fe:	7d1a      	ldrb	r2, [r3, #20]
   23400:	b162      	cbz	r2, 2341c <UIBitcrusherButtons+0x20>
	{
		writeString = crusherStereo ? "STEREO" : "MONO";
   23402:	4a08      	ldr	r2, [pc, #32]	; (23424 <UIBitcrusherButtons+0x28>)
   23404:	4808      	ldr	r0, [pc, #32]	; (23428 <UIBitcrusherButtons+0x2c>)
{
   23406:	b410      	push	{r4}
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23408:	2400      	movs	r4, #0
		writeString = crusherStereo ? "STEREO" : "MONO";
   2340a:	6811      	ldr	r1, [r2, #0]
   2340c:	4a07      	ldr	r2, [pc, #28]	; (2342c <UIBitcrusherButtons+0x30>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2340e:	751c      	strb	r4, [r3, #20]
		writeString = crusherStereo ? "STEREO" : "MONO";
   23410:	42a1      	cmp	r1, r4
   23412:	bf08      	it	eq
   23414:	4610      	moveq	r0, r2
	}


	return writeString;
}
   23416:	f85d 4b04 	ldr.w	r4, [sp], #4
   2341a:	4770      	bx	lr
	char* writeString = "";
   2341c:	4804      	ldr	r0, [pc, #16]	; (23430 <UIBitcrusherButtons+0x34>)
}
   2341e:	4770      	bx	lr
   23420:	020fb45c 	.word	0x020fb45c
   23424:	020e3170 	.word	0x020e3170
   23428:	000321cc 	.word	0x000321cc
   2342c:	000320c8 	.word	0x000320c8
   23430:	0003209c 	.word	0x0003209c

00023434 <UIDelayButtons>:

char* UIDelayButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress])
   23434:	4b0e      	ldr	r3, [pc, #56]	; (23470 <UIDelayButtons+0x3c>)
{
   23436:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress])
   23438:	7d1a      	ldrb	r2, [r3, #20]
   2343a:	b1b2      	cbz	r2, 2346a <UIDelayButtons+0x36>
	{
		writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   2343c:	4a0d      	ldr	r2, [pc, #52]	; (23474 <UIDelayButtons+0x40>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2343e:	2400      	movs	r4, #0
		writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   23440:	480d      	ldr	r0, [pc, #52]	; (23478 <UIDelayButtons+0x44>)
   23442:	6811      	ldr	r1, [r2, #0]
   23444:	4a0d      	ldr	r2, [pc, #52]	; (2347c <UIDelayButtons+0x48>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23446:	751c      	strb	r4, [r3, #20]
		writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
   23448:	42a1      	cmp	r1, r4
   2344a:	bf08      	it	eq
   2344c:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   2344e:	7e1a      	ldrb	r2, [r3, #24]
   23450:	b142      	cbz	r2, 23464 <UIDelayButtons+0x30>
	{
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   23452:	4a0b      	ldr	r2, [pc, #44]	; (23480 <UIDelayButtons+0x4c>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23454:	2400      	movs	r4, #0
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   23456:	480b      	ldr	r0, [pc, #44]	; (23484 <UIDelayButtons+0x50>)
   23458:	7811      	ldrb	r1, [r2, #0]
   2345a:	4a0b      	ldr	r2, [pc, #44]	; (23488 <UIDelayButtons+0x54>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2345c:	761c      	strb	r4, [r3, #24]
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   2345e:	42a1      	cmp	r1, r4
   23460:	bf08      	it	eq
   23462:	4610      	moveq	r0, r2
	}
	return writeString;
}
   23464:	f85d 4b04 	ldr.w	r4, [sp], #4
   23468:	4770      	bx	lr
	char* writeString = "";
   2346a:	4808      	ldr	r0, [pc, #32]	; (2348c <UIDelayButtons+0x58>)
   2346c:	e7ef      	b.n	2344e <UIDelayButtons+0x1a>
   2346e:	bf00      	nop
   23470:	020fb45c 	.word	0x020fb45c
   23474:	020e3180 	.word	0x020e3180
   23478:	00031f28 	.word	0x00031f28
   2347c:	00031f34 	.word	0x00031f34
   23480:	020e3130 	.word	0x020e3130
   23484:	00031f40 	.word	0x00031f40
   23488:	00031f48 	.word	0x00031f48
   2348c:	0003209c 	.word	0x0003209c

00023490 <UIReverbButtons>:

char* UIReverbButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonC][ActionPress])
   23490:	4b0e      	ldr	r3, [pc, #56]	; (234cc <UIReverbButtons+0x3c>)
{
   23492:	b410      	push	{r4}
	if (buttonActionsUI[ButtonC][ActionPress])
   23494:	7f1a      	ldrb	r2, [r3, #28]
   23496:	b1b2      	cbz	r2, 234c6 <UIReverbButtons+0x36>
	{
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   23498:	4a0d      	ldr	r2, [pc, #52]	; (234d0 <UIReverbButtons+0x40>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   2349a:	2400      	movs	r4, #0
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   2349c:	480d      	ldr	r0, [pc, #52]	; (234d4 <UIReverbButtons+0x44>)
   2349e:	6811      	ldr	r1, [r2, #0]
   234a0:	4a0d      	ldr	r2, [pc, #52]	; (234d8 <UIReverbButtons+0x48>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   234a2:	771c      	strb	r4, [r3, #28]
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   234a4:	42a1      	cmp	r1, r4
   234a6:	bf08      	it	eq
   234a8:	4610      	moveq	r0, r2
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   234aa:	7e1a      	ldrb	r2, [r3, #24]
   234ac:	b142      	cbz	r2, 234c0 <UIReverbButtons+0x30>
	{
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   234ae:	4a0b      	ldr	r2, [pc, #44]	; (234dc <UIReverbButtons+0x4c>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   234b0:	2400      	movs	r4, #0
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   234b2:	480b      	ldr	r0, [pc, #44]	; (234e0 <UIReverbButtons+0x50>)
   234b4:	7811      	ldrb	r1, [r2, #0]
   234b6:	4a0b      	ldr	r2, [pc, #44]	; (234e4 <UIReverbButtons+0x54>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   234b8:	761c      	strb	r4, [r3, #24]
		writeString = capFeedback ? "FB CAP" : "FB UNCAP";
   234ba:	42a1      	cmp	r1, r4
   234bc:	bf08      	it	eq
   234be:	4610      	moveq	r0, r2
	}
	return writeString;
}
   234c0:	f85d 4b04 	ldr.w	r4, [sp], #4
   234c4:	4770      	bx	lr
	char* writeString = "";
   234c6:	4808      	ldr	r0, [pc, #32]	; (234e8 <UIReverbButtons+0x58>)
   234c8:	e7ef      	b.n	234aa <UIReverbButtons+0x1a>
   234ca:	bf00      	nop
   234cc:	020fb45c 	.word	0x020fb45c
   234d0:	020e3198 	.word	0x020e3198
   234d4:	00032004 	.word	0x00032004
   234d8:	0003200c 	.word	0x0003200c
   234dc:	020e3130 	.word	0x020e3130
   234e0:	00031f40 	.word	0x00031f40
   234e4:	00031f48 	.word	0x00031f48
   234e8:	0003209c 	.word	0x0003209c

000234ec <UIReverb2Buttons>:

char* UIReverb2Buttons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonC][ActionPress])
   234ec:	4b08      	ldr	r3, [pc, #32]	; (23510 <UIReverb2Buttons+0x24>)
   234ee:	7f1a      	ldrb	r2, [r3, #28]
   234f0:	b162      	cbz	r2, 2350c <UIReverb2Buttons+0x20>
	{
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   234f2:	4a08      	ldr	r2, [pc, #32]	; (23514 <UIReverb2Buttons+0x28>)
   234f4:	4808      	ldr	r0, [pc, #32]	; (23518 <UIReverb2Buttons+0x2c>)
{
   234f6:	b410      	push	{r4}
		buttonActionsUI[ButtonC][ActionPress] = 0;
   234f8:	2400      	movs	r4, #0
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   234fa:	6811      	ldr	r1, [r2, #0]
   234fc:	4a07      	ldr	r2, [pc, #28]	; (2351c <UIReverb2Buttons+0x30>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   234fe:	771c      	strb	r4, [r3, #28]
		writeString = freeze ? "FREEZE" : "UNFREEZE";
   23500:	42a1      	cmp	r1, r4
   23502:	bf08      	it	eq
   23504:	4610      	moveq	r0, r2
	}
	return writeString;
}
   23506:	f85d 4b04 	ldr.w	r4, [sp], #4
   2350a:	4770      	bx	lr
	char* writeString = "";
   2350c:	4804      	ldr	r0, [pc, #16]	; (23520 <UIReverb2Buttons+0x34>)
}
   2350e:	4770      	bx	lr
   23510:	020fb45c 	.word	0x020fb45c
   23514:	020e3198 	.word	0x020e3198
   23518:	00032004 	.word	0x00032004
   2351c:	0003200c 	.word	0x0003200c
   23520:	0003209c 	.word	0x0003209c

00023524 <UILivingStringButtons>:

char* UILivingStringButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23524:	4b15      	ldr	r3, [pc, #84]	; (2357c <UILivingStringButtons+0x58>)
{
   23526:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   23528:	7d1a      	ldrb	r2, [r3, #20]
   2352a:	2a01      	cmp	r2, #1
   2352c:	d01b      	beq.n	23566 <UILivingStringButtons+0x42>
	char* writeString = "";
   2352e:	4814      	ldr	r0, [pc, #80]	; (23580 <UILivingStringButtons+0x5c>)
	{
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   23530:	7f1a      	ldrb	r2, [r3, #28]
   23532:	2a01      	cmp	r2, #1
   23534:	d108      	bne.n	23548 <UILivingStringButtons+0x24>
	{
		writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   23536:	4a13      	ldr	r2, [pc, #76]	; (23584 <UILivingStringButtons+0x60>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23538:	2400      	movs	r4, #0
		writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   2353a:	4813      	ldr	r0, [pc, #76]	; (23588 <UILivingStringButtons+0x64>)
   2353c:	6811      	ldr	r1, [r2, #0]
   2353e:	4a13      	ldr	r2, [pc, #76]	; (2358c <UILivingStringButtons+0x68>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   23540:	771c      	strb	r4, [r3, #28]
		writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
   23542:	42a1      	cmp	r1, r4
   23544:	bfd8      	it	le
   23546:	4610      	movle	r0, r2
	}

	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   23548:	7e1a      	ldrb	r2, [r3, #24]
   2354a:	2a01      	cmp	r2, #1
   2354c:	d108      	bne.n	23560 <UILivingStringButtons+0x3c>
	{
		writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   2354e:	4a10      	ldr	r2, [pc, #64]	; (23590 <UILivingStringButtons+0x6c>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23550:	2400      	movs	r4, #0
		writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   23552:	4810      	ldr	r0, [pc, #64]	; (23594 <UILivingStringButtons+0x70>)
   23554:	6811      	ldr	r1, [r2, #0]
   23556:	4a10      	ldr	r2, [pc, #64]	; (23598 <UILivingStringButtons+0x74>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   23558:	761c      	strb	r4, [r3, #24]
		writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
   2355a:	42a1      	cmp	r1, r4
   2355c:	bfd8      	it	le
   2355e:	4610      	movle	r0, r2
	}

	return writeString;
}
   23560:	f85d 4b04 	ldr.w	r4, [sp], #4
   23564:	4770      	bx	lr
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   23566:	4a0d      	ldr	r2, [pc, #52]	; (2359c <UILivingStringButtons+0x78>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23568:	2400      	movs	r4, #0
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   2356a:	480d      	ldr	r0, [pc, #52]	; (235a0 <UILivingStringButtons+0x7c>)
   2356c:	6811      	ldr	r1, [r2, #0]
   2356e:	4a0d      	ldr	r2, [pc, #52]	; (235a4 <UILivingStringButtons+0x80>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23570:	751c      	strb	r4, [r3, #20]
		writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
   23572:	42a1      	cmp	r1, r4
   23574:	bfd8      	it	le
   23576:	4610      	movle	r0, r2
   23578:	e7da      	b.n	23530 <UILivingStringButtons+0xc>
   2357a:	bf00      	nop
   2357c:	020fb45c 	.word	0x020fb45c
   23580:	0003209c 	.word	0x0003209c
   23584:	020e31a8 	.word	0x020e31a8
   23588:	00031f7c 	.word	0x00031f7c
   2358c:	00031f84 	.word	0x00031f84
   23590:	020e31a0 	.word	0x020e31a0
   23594:	00031f90 	.word	0x00031f90
   23598:	00031fa0 	.word	0x00031fa0
   2359c:	020e319c 	.word	0x020e319c
   235a0:	00031f64 	.word	0x00031f64
   235a4:	00031f70 	.word	0x00031f70

000235a8 <UILivingStringSynthButtons>:

char* UILivingStringSynthButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   235a8:	4b15      	ldr	r3, [pc, #84]	; (23600 <UILivingStringSynthButtons+0x58>)
{
   235aa:	b410      	push	{r4}
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   235ac:	7d1a      	ldrb	r2, [r3, #20]
   235ae:	2a01      	cmp	r2, #1
   235b0:	d01b      	beq.n	235ea <UILivingStringSynthButtons+0x42>
	char* writeString = "";
   235b2:	4814      	ldr	r0, [pc, #80]	; (23604 <UILivingStringSynthButtons+0x5c>)
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   235b4:	7e1a      	ldrb	r2, [r3, #24]
   235b6:	2a01      	cmp	r2, #1
   235b8:	d108      	bne.n	235cc <UILivingStringSynthButtons+0x24>
	{
		writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   235ba:	4a13      	ldr	r2, [pc, #76]	; (23608 <UILivingStringSynthButtons+0x60>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   235bc:	2400      	movs	r4, #0
		writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   235be:	4813      	ldr	r0, [pc, #76]	; (2360c <UILivingStringSynthButtons+0x64>)
   235c0:	6811      	ldr	r1, [r2, #0]
   235c2:	4a13      	ldr	r2, [pc, #76]	; (23610 <UILivingStringSynthButtons+0x68>)
		buttonActionsUI[ButtonB][ActionPress] = 0;
   235c4:	761c      	strb	r4, [r3, #24]
		writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
   235c6:	42a1      	cmp	r1, r4
   235c8:	bfd8      	it	le
   235ca:	4610      	movle	r0, r2
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   235cc:	7f1a      	ldrb	r2, [r3, #28]
   235ce:	2a01      	cmp	r2, #1
   235d0:	d108      	bne.n	235e4 <UILivingStringSynthButtons+0x3c>
	{
		writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   235d2:	4a10      	ldr	r2, [pc, #64]	; (23614 <UILivingStringSynthButtons+0x6c>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   235d4:	2400      	movs	r4, #0
		writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   235d6:	4810      	ldr	r0, [pc, #64]	; (23618 <UILivingStringSynthButtons+0x70>)
   235d8:	6811      	ldr	r1, [r2, #0]
   235da:	4a10      	ldr	r2, [pc, #64]	; (2361c <UILivingStringSynthButtons+0x74>)
		buttonActionsUI[ButtonC][ActionPress] = 0;
   235dc:	771c      	strb	r4, [r3, #28]
		writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
   235de:	42a1      	cmp	r1, r4
   235e0:	bfd8      	it	le
   235e2:	4610      	movle	r0, r2
	}
	return writeString;
}
   235e4:	f85d 4b04 	ldr.w	r4, [sp], #4
   235e8:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   235ea:	4a0d      	ldr	r2, [pc, #52]	; (23620 <UILivingStringSynthButtons+0x78>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   235ec:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   235ee:	480d      	ldr	r0, [pc, #52]	; (23624 <UILivingStringSynthButtons+0x7c>)
   235f0:	7811      	ldrb	r1, [r2, #0]
   235f2:	4a0d      	ldr	r2, [pc, #52]	; (23628 <UILivingStringSynthButtons+0x80>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   235f4:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   235f6:	2901      	cmp	r1, #1
   235f8:	bf98      	it	ls
   235fa:	4610      	movls	r0, r2
   235fc:	e7da      	b.n	235b4 <UILivingStringSynthButtons+0xc>
   235fe:	bf00      	nop
   23600:	020fb45c 	.word	0x020fb45c
   23604:	0003209c 	.word	0x0003209c
   23608:	020e3220 	.word	0x020e3220
   2360c:	00031fac 	.word	0x00031fac
   23610:	00031fb8 	.word	0x00031fb8
   23614:	020e31ac 	.word	0x020e31ac
   23618:	00031f7c 	.word	0x00031f7c
   2361c:	00031f84 	.word	0x00031f84
   23620:	00062ae4 	.word	0x00062ae4
   23624:	000320c0 	.word	0x000320c0
   23628:	000320c8 	.word	0x000320c8

0002362c <UIClassicSynthButtons>:

char* UIClassicSynthButtons(VocodecButton button, ButtonAction action)
{
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2362c:	4b0d      	ldr	r3, [pc, #52]	; (23664 <UIClassicSynthButtons+0x38>)
   2362e:	7d1a      	ldrb	r2, [r3, #20]
   23630:	2a01      	cmp	r2, #1
   23632:	d006      	beq.n	23642 <UIClassicSynthButtons+0x16>
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress])
   23634:	7e1a      	ldrb	r2, [r3, #24]
	char* writeString = "";
   23636:	480c      	ldr	r0, [pc, #48]	; (23668 <UIClassicSynthButtons+0x3c>)
	if (buttonActionsUI[ButtonB][ActionPress])
   23638:	b112      	cbz	r2, 23640 <UIClassicSynthButtons+0x14>
	{
		//writeString = knobPage == 0 ? "SETTINGS" : "ADSR";
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2363a:	2200      	movs	r2, #0
   2363c:	761a      	strb	r2, [r3, #24]
   2363e:	4770      	bx	lr
	}
	return writeString;
}
   23640:	4770      	bx	lr
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23642:	4a0a      	ldr	r2, [pc, #40]	; (2366c <UIClassicSynthButtons+0x40>)
   23644:	480a      	ldr	r0, [pc, #40]	; (23670 <UIClassicSynthButtons+0x44>)
{
   23646:	b410      	push	{r4}
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23648:	7811      	ldrb	r1, [r2, #0]
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2364a:	2400      	movs	r4, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   2364c:	4a09      	ldr	r2, [pc, #36]	; (23674 <UIClassicSynthButtons+0x48>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   2364e:	751c      	strb	r4, [r3, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23650:	2901      	cmp	r1, #1
   23652:	bf98      	it	ls
   23654:	4610      	movls	r0, r2
	if (buttonActionsUI[ButtonB][ActionPress])
   23656:	7e1a      	ldrb	r2, [r3, #24]
   23658:	b10a      	cbz	r2, 2365e <UIClassicSynthButtons+0x32>
		buttonActionsUI[ButtonB][ActionPress] = 0;
   2365a:	2200      	movs	r2, #0
   2365c:	761a      	strb	r2, [r3, #24]
}
   2365e:	f85d 4b04 	ldr.w	r4, [sp], #4
   23662:	4770      	bx	lr
   23664:	020fb45c 	.word	0x020fb45c
   23668:	0003209c 	.word	0x0003209c
   2366c:	00062ae4 	.word	0x00062ae4
   23670:	000320c0 	.word	0x000320c0
   23674:	000320c8 	.word	0x000320c8

00023678 <UIRhodesButtons>:

char* UIRhodesButtons(VocodecButton button, ButtonAction action)
{
   23678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	char* writeString = "";
	if (buttonActionsUI[ButtonA][ActionPress] == 1)
   2367a:	4c1f      	ldr	r4, [pc, #124]	; (236f8 <UIRhodesButtons+0x80>)
   2367c:	7d23      	ldrb	r3, [r4, #20]
   2367e:	2b01      	cmp	r3, #1
   23680:	d008      	beq.n	23694 <UIRhodesButtons+0x1c>
	{
		writeString = (numVoices > 1) ? "POLY" : "MONO";
		buttonActionsUI[ButtonA][ActionPress] = 0;
	}
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   23682:	7e25      	ldrb	r5, [r4, #24]
	char* writeString = "";
   23684:	4e1d      	ldr	r6, [pc, #116]	; (236fc <UIRhodesButtons+0x84>)
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   23686:	2d01      	cmp	r5, #1
   23688:	d010      	beq.n	236ac <UIRhodesButtons+0x34>
	{
		buttonActionsUI[ButtonB][ActionPress] = 0;
		OLEDclearLine(SecondLine);
		OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
	}
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   2368a:	7f25      	ldrb	r5, [r4, #28]
   2368c:	2d01      	cmp	r5, #1
   2368e:	d01f      	beq.n	236d0 <UIRhodesButtons+0x58>
		OLEDclearLine(SecondLine);
		OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
		OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
	}
	return writeString;
}
   23690:	4630      	mov	r0, r6
   23692:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23694:	4b1a      	ldr	r3, [pc, #104]	; (23700 <UIRhodesButtons+0x88>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   23696:	2100      	movs	r1, #0
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   23698:	4e1a      	ldr	r6, [pc, #104]	; (23704 <UIRhodesButtons+0x8c>)
   2369a:	781a      	ldrb	r2, [r3, #0]
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   2369c:	7e25      	ldrb	r5, [r4, #24]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   2369e:	4b1a      	ldr	r3, [pc, #104]	; (23708 <UIRhodesButtons+0x90>)
		buttonActionsUI[ButtonA][ActionPress] = 0;
   236a0:	7521      	strb	r1, [r4, #20]
		writeString = (numVoices > 1) ? "POLY" : "MONO";
   236a2:	2a01      	cmp	r2, #1
   236a4:	bf98      	it	ls
   236a6:	461e      	movls	r6, r3
	if (buttonActionsUI[ButtonB][ActionPress] == 1)
   236a8:	2d01      	cmp	r5, #1
   236aa:	d1ee      	bne.n	2368a <UIRhodesButtons+0x12>
		buttonActionsUI[ButtonB][ActionPress] = 0;
   236ac:	2700      	movs	r7, #0
		OLEDclearLine(SecondLine);
   236ae:	4628      	mov	r0, r5
		buttonActionsUI[ButtonB][ActionPress] = 0;
   236b0:	7627      	strb	r7, [r4, #24]
		OLEDclearLine(SecondLine);
   236b2:	f7f6 f96b 	bl	1998c <OLEDclearLine>
		OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
   236b6:	4915      	ldr	r1, [pc, #84]	; (2370c <UIRhodesButtons+0x94>)
   236b8:	462b      	mov	r3, r5
   236ba:	4815      	ldr	r0, [pc, #84]	; (23710 <UIRhodesButtons+0x98>)
   236bc:	463a      	mov	r2, r7
   236be:	680d      	ldr	r5, [r1, #0]
   236c0:	2106      	movs	r1, #6
   236c2:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
   236c6:	f7f6 f975 	bl	199b4 <OLEDwriteString>
	if (buttonActionsUI[ButtonC][ActionPress] == 1)
   236ca:	7f25      	ldrb	r5, [r4, #28]
   236cc:	2d01      	cmp	r5, #1
   236ce:	d1df      	bne.n	23690 <UIRhodesButtons+0x18>
		buttonActionsUI[ButtonC][ActionPress] = 0;
   236d0:	2700      	movs	r7, #0
		OLEDclearLine(SecondLine);
   236d2:	4628      	mov	r0, r5
		buttonActionsUI[ButtonC][ActionPress] = 0;
   236d4:	7727      	strb	r7, [r4, #28]
		OLEDclearLine(SecondLine);
   236d6:	f7f6 f959 	bl	1998c <OLEDclearLine>
		OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
   236da:	462b      	mov	r3, r5
   236dc:	463a      	mov	r2, r7
   236de:	210c      	movs	r1, #12
   236e0:	480c      	ldr	r0, [pc, #48]	; (23714 <UIRhodesButtons+0x9c>)
   236e2:	f7f6 f967 	bl	199b4 <OLEDwriteString>
		OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
   236e6:	4a0c      	ldr	r2, [pc, #48]	; (23718 <UIRhodesButtons+0xa0>)
   236e8:	462b      	mov	r3, r5
   236ea:	4629      	mov	r1, r5
   236ec:	7810      	ldrb	r0, [r2, #0]
   236ee:	226e      	movs	r2, #110	; 0x6e
   236f0:	f7f6 f98a 	bl	19a08 <OLEDwriteInt>
}
   236f4:	4630      	mov	r0, r6
   236f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   236f8:	020fb45c 	.word	0x020fb45c
   236fc:	0003209c 	.word	0x0003209c
   23700:	00062ae4 	.word	0x00062ae4
   23704:	000320c0 	.word	0x000320c0
   23708:	000320c8 	.word	0x000320c8
   2370c:	020e3118 	.word	0x020e3118
   23710:	020fa128 	.word	0x020fa128
   23714:	00032018 	.word	0x00032018
   23718:	020e3214 	.word	0x020e3214

0002371c <USBH_UserProcess>:
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
   2371c:	2904      	cmp	r1, #4
   2371e:	d00b      	beq.n	23738 <USBH_UserProcess+0x1c>
   23720:	2905      	cmp	r1, #5
   23722:	d005      	beq.n	23730 <USBH_UserProcess+0x14>
   23724:	2902      	cmp	r1, #2
   23726:	d000      	beq.n	2372a <USBH_UserProcess+0xe>

  default:
  break;
  }
  /* USER CODE END CALL_BACK_1 */
}
   23728:	4770      	bx	lr
  Appli_state = APPLICATION_READY;
   2372a:	4b05      	ldr	r3, [pc, #20]	; (23740 <USBH_UserProcess+0x24>)
   2372c:	7019      	strb	r1, [r3, #0]
  break;
   2372e:	4770      	bx	lr
  Appli_state = APPLICATION_DISCONNECT;
   23730:	4b03      	ldr	r3, [pc, #12]	; (23740 <USBH_UserProcess+0x24>)
   23732:	2204      	movs	r2, #4
   23734:	701a      	strb	r2, [r3, #0]
  break;
   23736:	4770      	bx	lr
  Appli_state = APPLICATION_START;
   23738:	4b01      	ldr	r3, [pc, #4]	; (23740 <USBH_UserProcess+0x24>)
   2373a:	2201      	movs	r2, #1
   2373c:	701a      	strb	r2, [r3, #0]
}
   2373e:	4770      	bx	lr
   23740:	020e325c 	.word	0x020e325c

00023744 <MX_USB_HOST_Init>:
{
   23744:	b508      	push	{r3, lr}
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
   23746:	2201      	movs	r2, #1
   23748:	490c      	ldr	r1, [pc, #48]	; (2377c <MX_USB_HOST_Init+0x38>)
   2374a:	480d      	ldr	r0, [pc, #52]	; (23780 <MX_USB_HOST_Init+0x3c>)
   2374c:	f7f1 fb9e 	bl	14e8c <USBH_Init>
   23750:	b988      	cbnz	r0, 23776 <MX_USB_HOST_Init+0x32>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MIDI_CLASS) != USBH_OK)
   23752:	490c      	ldr	r1, [pc, #48]	; (23784 <MX_USB_HOST_Init+0x40>)
   23754:	480a      	ldr	r0, [pc, #40]	; (23780 <MX_USB_HOST_Init+0x3c>)
   23756:	f7f1 fbff 	bl	14f58 <USBH_RegisterClass>
   2375a:	b948      	cbnz	r0, 23770 <MX_USB_HOST_Init+0x2c>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
   2375c:	4808      	ldr	r0, [pc, #32]	; (23780 <MX_USB_HOST_Init+0x3c>)
   2375e:	f7f1 fceb 	bl	15138 <USBH_Start>
   23762:	b108      	cbz	r0, 23768 <MX_USB_HOST_Init+0x24>
    Error_Handler();
   23764:	f7f5 feaa 	bl	194bc <Error_Handler>
}
   23768:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
   2376c:	f7ea bc8c 	b.w	e088 <HAL_PWREx_EnableUSBVoltageDetector>
    Error_Handler();
   23770:	f7f5 fea4 	bl	194bc <Error_Handler>
   23774:	e7f2      	b.n	2375c <MX_USB_HOST_Init+0x18>
    Error_Handler();
   23776:	f7f5 fea1 	bl	194bc <Error_Handler>
   2377a:	e7ea      	b.n	23752 <MX_USB_HOST_Init+0xe>
   2377c:	0002371d 	.word	0x0002371d
   23780:	00063de0 	.word	0x00063de0
   23784:	00062b64 	.word	0x00062b64

00023788 <MX_USB_HOST_DeInit>:
{
   23788:	b508      	push	{r3, lr}
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
   2378a:	4808      	ldr	r0, [pc, #32]	; (237ac <MX_USB_HOST_DeInit+0x24>)
   2378c:	f7f1 fcde 	bl	1514c <USBH_Stop>
   23790:	b948      	cbnz	r0, 237a6 <MX_USB_HOST_DeInit+0x1e>
  if (USBH_DeInit(&hUsbHostFS) != USBH_OK)
   23792:	4806      	ldr	r0, [pc, #24]	; (237ac <MX_USB_HOST_DeInit+0x24>)
   23794:	f7f1 fbb2 	bl	14efc <USBH_DeInit>
   23798:	b108      	cbz	r0, 2379e <MX_USB_HOST_DeInit+0x16>
    Error_Handler();
   2379a:	f7f5 fe8f 	bl	194bc <Error_Handler>
}
   2379e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_DisableUSBVoltageDetector();
   237a2:	f7ea bc79 	b.w	e098 <HAL_PWREx_DisableUSBVoltageDetector>
    Error_Handler();
   237a6:	f7f5 fe89 	bl	194bc <Error_Handler>
   237aa:	e7f2      	b.n	23792 <MX_USB_HOST_DeInit+0xa>
   237ac:	00063de0 	.word	0x00063de0

000237b0 <MX_USB_HOST_Process>:
{
   237b0:	b508      	push	{r3, lr}
	MIDI_Application();
   237b2:	f7f2 ff2d 	bl	16610 <MIDI_Application>
	USBH_Process(&hUsbHostFS);
   237b6:	4802      	ldr	r0, [pc, #8]	; (237c0 <MX_USB_HOST_Process+0x10>)
}
   237b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	USBH_Process(&hUsbHostFS);
   237bc:	f7f1 bcd8 	b.w	15170 <USBH_Process>
   237c0:	00063de0 	.word	0x00063de0

000237c4 <USBH_MIDI_ClassRequest>:
 *         for MIDI class.
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_ClassRequest (USBH_HandleTypeDef *phost)
{   
   237c4:	b508      	push	{r3, lr}

	phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
   237c6:	2102      	movs	r1, #2
   237c8:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
   237cc:	4798      	blx	r3

	return USBH_OK;
}
   237ce:	2000      	movs	r0, #0
   237d0:	bd08      	pop	{r3, pc}
   237d2:	bf00      	nop

000237d4 <USBH_MIDI_Process>:
 *         (background process)
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_Process (USBH_HandleTypeDef *phost)
{
   237d4:	b510      	push	{r4, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   237d6:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
   237da:	69dc      	ldr	r4, [r3, #28]

	switch(MIDI_Handle->state)
   237dc:	7823      	ldrb	r3, [r4, #0]
   237de:	b153      	cbz	r3, 237f6 <USBH_MIDI_Process+0x22>
   237e0:	2b02      	cmp	r3, #2
   237e2:	d106      	bne.n	237f2 <USBH_MIDI_Process+0x1e>
		//MIDI_ProcessTransmission(phost);
		//MIDI_ProcessReception(phost);
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
   237e4:	2100      	movs	r1, #0
   237e6:	f7f2 fd4f 	bl	16288 <USBH_ClrFeature>

		if(req_status == USBH_OK )
   237ea:	b910      	cbnz	r0, 237f2 <USBH_MIDI_Process+0x1e>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
   237ec:	7020      	strb	r0, [r4, #0]
	USBH_StatusTypeDef status = USBH_BUSY;
   237ee:	2001      	movs	r0, #1
		break;

	}

	return status;
}
   237f0:	bd10      	pop	{r4, pc}
	USBH_StatusTypeDef status = USBH_BUSY;
   237f2:	2001      	movs	r0, #1
}
   237f4:	bd10      	pop	{r4, pc}
		status = USBH_OK;
   237f6:	4618      	mov	r0, r3
}
   237f8:	bd10      	pop	{r4, pc}
   237fa:	bf00      	nop

000237fc <USBH_MIDI_SOFProcess>:
  *         The function is for managing SOF callback
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MIDI_SOFProcess (USBH_HandleTypeDef *phost)
{
   237fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23800:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
   23804:	b083      	sub	sp, #12
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23806:	69dc      	ldr	r4, [r3, #28]
	USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
	uint16_t length;
	switch(MIDI_Handle->state)
   23808:	7823      	ldrb	r3, [r4, #0]
   2380a:	2b01      	cmp	r3, #1
   2380c:	d00a      	beq.n	23824 <USBH_MIDI_SOFProcess+0x28>
   2380e:	2b02      	cmp	r3, #2
   23810:	d104      	bne.n	2381c <USBH_MIDI_SOFProcess+0x20>
				break;
		}
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
   23812:	2100      	movs	r1, #0
   23814:	f7f2 fd38 	bl	16288 <USBH_ClrFeature>

		if(req_status == USBH_OK )
   23818:	b900      	cbnz	r0, 2381c <USBH_MIDI_SOFProcess+0x20>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
   2381a:	7020      	strb	r0, [r4, #0]
		break;

	}

	return USBH_OK;
}
   2381c:	2000      	movs	r0, #0
   2381e:	b003      	add	sp, #12
   23820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(MIDI_Handle->data_rx_state)
   23824:	7e63      	ldrb	r3, [r4, #25]
   23826:	2b03      	cmp	r3, #3
   23828:	d06f      	beq.n	2390a <USBH_MIDI_SOFProcess+0x10e>
   2382a:	2b04      	cmp	r3, #4
   2382c:	d1f6      	bne.n	2381c <USBH_MIDI_SOFProcess+0x20>
				URB_Status = USBH_LL_GetURBState(phost, MIDI_Handle->InPipe);
   2382e:	7861      	ldrb	r1, [r4, #1]
   23830:	4605      	mov	r5, r0
   23832:	f000 fa33 	bl	23c9c <USBH_LL_GetURBState>
				if(URB_Status == USBH_URB_DONE )
   23836:	2801      	cmp	r0, #1
   23838:	d1f0      	bne.n	2381c <USBH_MIDI_SOFProcess+0x20>
					length = USBH_LL_GetLastXferSize(phost, MIDI_Handle->InPipe);
   2383a:	7861      	ldrb	r1, [r4, #1]
   2383c:	4628      	mov	r0, r5
   2383e:	f000 f9e5 	bl	23c0c <USBH_LL_GetLastXferSize>
					if(((MIDI_Handle->RxDataLength - length) > 0) && (length > MIDI_Handle->InEpSize))
   23842:	8ae3      	ldrh	r3, [r4, #22]
   23844:	b286      	uxth	r6, r0
   23846:	1b9a      	subs	r2, r3, r6
   23848:	2a00      	cmp	r2, #0
   2384a:	dd02      	ble.n	23852 <USBH_MIDI_SOFProcess+0x56>
   2384c:	8922      	ldrh	r2, [r4, #8]
   2384e:	42b2      	cmp	r2, r6
   23850:	d366      	bcc.n	23920 <USBH_MIDI_SOFProcess+0x124>
						MIDI_write_buffer = !MIDI_write_buffer;
   23852:	4837      	ldr	r0, [pc, #220]	; (23930 <USBH_MIDI_SOFProcess+0x134>)
						MIDI_Handle->data_rx_state = MIDI_IDLE;
   23854:	2300      	movs	r3, #0
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23856:	4937      	ldr	r1, [pc, #220]	; (23934 <USBH_MIDI_SOFProcess+0x138>)
						MIDI_write_buffer = !MIDI_write_buffer;
   23858:	f890 c000 	ldrb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   2385c:	780a      	ldrb	r2, [r1, #0]
						MIDI_write_buffer = !MIDI_write_buffer;
   2385e:	fabc fc8c 	clz	ip, ip
						MIDI_Handle->data_rx_state = MIDI_IDLE;
   23862:	7663      	strb	r3, [r4, #25]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23864:	fab2 f282 	clz	r2, r2
						MIDI_write_buffer = !MIDI_write_buffer;
   23868:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   2386c:	0952      	lsrs	r2, r2, #5
						MIDI_write_buffer = !MIDI_write_buffer;
   2386e:	f880 c000 	strb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
   23872:	700a      	strb	r2, [r1, #0]
						for (int i = 0; i < length; i++)
   23874:	2e00      	cmp	r6, #0
   23876:	d035      	beq.n	238e4 <USBH_MIDI_SOFProcess+0xe8>
   23878:	482f      	ldr	r0, [pc, #188]	; (23938 <USBH_MIDI_SOFProcess+0x13c>)
								myUSB_FIFO_overflowBit = 1;
   2387a:	f04f 0801 	mov.w	r8, #1
   2387e:	492f      	ldr	r1, [pc, #188]	; (2393c <USBH_MIDI_SOFProcess+0x140>)
								myUSB_FIFO_writePointer = 0;
   23880:	469e      	mov	lr, r3
   23882:	eb00 1282 	add.w	r2, r0, r2, lsl #6
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   23886:	4f2e      	ldr	r7, [pc, #184]	; (23940 <USBH_MIDI_SOFProcess+0x144>)
								myUSB_FIFO_overflowBit = 1;
   23888:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 23944 <USBH_MIDI_SOFProcess+0x148>
   2388c:	9401      	str	r4, [sp, #4]
							if ((i % 4) == 0)
   2388e:	f003 0003 	and.w	r0, r3, #3
   23892:	3301      	adds	r3, #1
   23894:	b9d8      	cbnz	r0, 238ce <USBH_MIDI_SOFProcess+0xd2>
								if (MIDI_RX_Buffer[MIDI_read_buffer][i] > 0)
   23896:	7810      	ldrb	r0, [r2, #0]
   23898:	b1c8      	cbz	r0, 238ce <USBH_MIDI_SOFProcess+0xd2>
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   2389a:	f8b1 b000 	ldrh.w	fp, [r1]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   2389e:	f892 a001 	ldrb.w	sl, [r2, #1]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   238a2:	fa1f fb8b 	uxth.w	fp, fp
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
   238a6:	7894      	ldrb	r4, [r2, #2]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
   238a8:	f807 000b 	strb.w	r0, [r7, fp]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   238ac:	8808      	ldrh	r0, [r1, #0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
   238ae:	f892 b003 	ldrb.w	fp, [r2, #3]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
   238b2:	3001      	adds	r0, #1
   238b4:	f807 a000 	strb.w	sl, [r7, r0]
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
   238b8:	8808      	ldrh	r0, [r1, #0]
   238ba:	3002      	adds	r0, #2
   238bc:	543c      	strb	r4, [r7, r0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
   238be:	8808      	ldrh	r0, [r1, #0]
   238c0:	3003      	adds	r0, #3
   238c2:	f807 b000 	strb.w	fp, [r7, r0]
									myUSB_FIFO_writePointer+=4;
   238c6:	8808      	ldrh	r0, [r1, #0]
   238c8:	3004      	adds	r0, #4
   238ca:	b280      	uxth	r0, r0
   238cc:	8008      	strh	r0, [r1, #0]
							if (myUSB_FIFO_writePointer >= 256)
   238ce:	8808      	ldrh	r0, [r1, #0]
   238d0:	3201      	adds	r2, #1
   238d2:	28ff      	cmp	r0, #255	; 0xff
   238d4:	d903      	bls.n	238de <USBH_MIDI_SOFProcess+0xe2>
								myUSB_FIFO_writePointer = 0;
   238d6:	f8a1 e000 	strh.w	lr, [r1]
								myUSB_FIFO_overflowBit = 1;
   238da:	f889 8000 	strb.w	r8, [r9]
						for (int i = 0; i < length; i++)
   238de:	429e      	cmp	r6, r3
   238e0:	d1d5      	bne.n	2388e <USBH_MIDI_SOFProcess+0x92>
   238e2:	9c01      	ldr	r4, [sp, #4]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   238e4:	2304      	movs	r3, #4
   238e6:	7663      	strb	r3, [r4, #25]
 * @retval None
 */
USBH_StatusTypeDef  USBH_MIDI_Receive(USBH_HandleTypeDef *phost, uint8_t *pbuff, uint16_t length)
{
	USBH_StatusTypeDef Status = USBH_BUSY;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   238e8:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
   238ec:	69db      	ldr	r3, [r3, #28]

	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
   238ee:	781a      	ldrb	r2, [r3, #0]
   238f0:	2a01      	cmp	r2, #1
   238f2:	d893      	bhi.n	2381c <USBH_MIDI_SOFProcess+0x20>
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   238f4:	4a10      	ldr	r2, [pc, #64]	; (23938 <USBH_MIDI_SOFProcess+0x13c>)
	{
		MIDI_Handle->pRxData = pbuff;
		MIDI_Handle->RxDataLength = length;
   238f6:	2440      	movs	r4, #64	; 0x40
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   238f8:	2001      	movs	r0, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   238fa:	2103      	movs	r1, #3
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
   238fc:	eb02 128c 	add.w	r2, r2, ip, lsl #6
		MIDI_Handle->RxDataLength = length;
   23900:	82dc      	strh	r4, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   23902:	7018      	strb	r0, [r3, #0]
		MIDI_Handle->pRxData = pbuff;
   23904:	611a      	str	r2, [r3, #16]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   23906:	7659      	strb	r1, [r3, #25]
   23908:	e788      	b.n	2381c <USBH_MIDI_SOFProcess+0x20>
				USBH_BulkReceiveData (phost,
   2390a:	7863      	ldrb	r3, [r4, #1]
   2390c:	8922      	ldrh	r2, [r4, #8]
   2390e:	6921      	ldr	r1, [r4, #16]
   23910:	f7f2 fdda 	bl	164c8 <USBH_BulkReceiveData>
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   23914:	2304      	movs	r3, #4
}
   23916:	2000      	movs	r0, #0
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
   23918:	7663      	strb	r3, [r4, #25]
}
   2391a:	b003      	add	sp, #12
   2391c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						MIDI_Handle->pRxData += length;
   23920:	6922      	ldr	r2, [r4, #16]
						MIDI_Handle->RxDataLength -= length ;
   23922:	1b98      	subs	r0, r3, r6
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   23924:	2303      	movs	r3, #3
						MIDI_Handle->pRxData += length;
   23926:	4432      	add	r2, r6
						MIDI_Handle->RxDataLength -= length ;
   23928:	82e0      	strh	r0, [r4, #22]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   2392a:	7663      	strb	r3, [r4, #25]
						MIDI_Handle->pRxData += length;
   2392c:	6122      	str	r2, [r4, #16]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   2392e:	e775      	b.n	2381c <USBH_MIDI_SOFProcess+0x20>
   23930:	0006289c 	.word	0x0006289c
   23934:	020e30d4 	.word	0x020e30d4
   23938:	00062d40 	.word	0x00062d40
   2393c:	020e3260 	.word	0x020e3260
   23940:	020fbce4 	.word	0x020fbce4
   23944:	020e325d 	.word	0x020e325d

00023948 <USBH_MIDI_InterfaceDeInit>:
{
   23948:	b538      	push	{r3, r4, r5, lr}
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   2394a:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
   2394e:	4605      	mov	r5, r0
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23950:	69dc      	ldr	r4, [r3, #28]
	if ( MIDI_Handle->OutPipe)
   23952:	78a1      	ldrb	r1, [r4, #2]
   23954:	b949      	cbnz	r1, 2396a <USBH_MIDI_InterfaceDeInit+0x22>
	if ( MIDI_Handle->InPipe)
   23956:	7861      	ldrb	r1, [r4, #1]
   23958:	b991      	cbnz	r1, 23980 <USBH_MIDI_InterfaceDeInit+0x38>
	if(phost->pActiveClass->pData)
   2395a:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
   2395e:	69da      	ldr	r2, [r3, #28]
   23960:	b10a      	cbz	r2, 23966 <USBH_MIDI_InterfaceDeInit+0x1e>
		phost->pActiveClass->pData = 0;
   23962:	2200      	movs	r2, #0
   23964:	61da      	str	r2, [r3, #28]
}
   23966:	2000      	movs	r0, #0
   23968:	bd38      	pop	{r3, r4, r5, pc}
		USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
   2396a:	f7f2 fdcf 	bl	1650c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->OutPipe);
   2396e:	78a1      	ldrb	r1, [r4, #2]
   23970:	4628      	mov	r0, r5
   23972:	f7f2 fe1b 	bl	165ac <USBH_FreePipe>
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
   23976:	2300      	movs	r3, #0
	if ( MIDI_Handle->InPipe)
   23978:	7861      	ldrb	r1, [r4, #1]
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
   2397a:	70a3      	strb	r3, [r4, #2]
	if ( MIDI_Handle->InPipe)
   2397c:	2900      	cmp	r1, #0
   2397e:	d0ec      	beq.n	2395a <USBH_MIDI_InterfaceDeInit+0x12>
		USBH_ClosePipe(phost, MIDI_Handle->InPipe);
   23980:	4628      	mov	r0, r5
   23982:	f7f2 fdc3 	bl	1650c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->InPipe);
   23986:	7861      	ldrb	r1, [r4, #1]
   23988:	4628      	mov	r0, r5
   2398a:	f7f2 fe0f 	bl	165ac <USBH_FreePipe>
		MIDI_Handle->InPipe = 0;     /* Reset the Channel as Free */
   2398e:	2300      	movs	r3, #0
   23990:	7063      	strb	r3, [r4, #1]
   23992:	e7e2      	b.n	2395a <USBH_MIDI_InterfaceDeInit+0x12>

00023994 <USBH_MIDI_InterfaceInit>:
{	
   23994:	b5f0      	push	{r4, r5, r6, r7, lr}
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   23996:	23ff      	movs	r3, #255	; 0xff
{	
   23998:	b085      	sub	sp, #20
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   2399a:	2203      	movs	r2, #3
   2399c:	2101      	movs	r1, #1
{	
   2399e:	4605      	mov	r5, r0
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
   239a0:	f7f1 faf2 	bl	14f88 <USBH_FindInterface>
	if(interface == 0xFF) /* No Valid Interface */
   239a4:	28ff      	cmp	r0, #255	; 0xff
   239a6:	d058      	beq.n	23a5a <USBH_MIDI_InterfaceInit+0xc6>
		USBH_SelectInterface (phost, interface);
   239a8:	4601      	mov	r1, r0
   239aa:	4628      	mov	r0, r5
   239ac:	f7f1 fae2 	bl	14f74 <USBH_SelectInterface>
		phost->pActiveClass->pData = &myMIDIHandle;
   239b0:	4c2d      	ldr	r4, [pc, #180]	; (23a68 <USBH_MIDI_InterfaceInit+0xd4>)
   239b2:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   239b6:	222a      	movs	r2, #42	; 0x2a
		phost->pActiveClass->pData = &myMIDIHandle;
   239b8:	61dc      	str	r4, [r3, #28]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   239ba:	f895 3324 	ldrb.w	r3, [r5, #804]	; 0x324
   239be:	fb02 5203 	mla	r2, r2, r3, r5
   239c2:	f892 134e 	ldrb.w	r1, [r2, #846]	; 0x34e
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   239c6:	f8b2 2350 	ldrh.w	r2, [r2, #848]	; 0x350
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
   239ca:	0608      	lsls	r0, r1, #24
   239cc:	d442      	bmi.n	23a54 <USBH_MIDI_InterfaceInit+0xc0>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
   239ce:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   239d0:	80e2      	strh	r2, [r4, #6]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress & 0x80)
   239d2:	222a      	movs	r2, #42	; 0x2a
   239d4:	fb02 5303 	mla	r3, r2, r3, r5
   239d8:	f893 1356 	ldrb.w	r1, [r3, #854]	; 0x356
   239dc:	f8b3 3358 	ldrh.w	r3, [r3, #856]	; 0x358
   239e0:	060a      	lsls	r2, r1, #24
   239e2:	d43d      	bmi.n	23a60 <USBH_MIDI_InterfaceInit+0xcc>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
   239e4:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
   239e6:	80e3      	strh	r3, [r4, #6]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   239e8:	4628      	mov	r0, r5
		USBH_OpenPipe  (phost,
   239ea:	2702      	movs	r7, #2
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   239ec:	f7f2 fd94 	bl	16518 <USBH_AllocPipe>
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   239f0:	7921      	ldrb	r1, [r4, #4]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
   239f2:	70a0      	strb	r0, [r4, #2]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   239f4:	4628      	mov	r0, r5
   239f6:	f7f2 fd8f 	bl	16518 <USBH_AllocPipe>
		USBH_OpenPipe  (phost,
   239fa:	f8b4 c006 	ldrh.w	ip, [r4, #6]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
   239fe:	7060      	strb	r0, [r4, #1]
		myMIDIHandle.state = MIDI_IDLE_STATE;
   23a00:	2600      	movs	r6, #0
		USBH_OpenPipe  (phost,
   23a02:	f895 031d 	ldrb.w	r0, [r5, #797]	; 0x31d
   23a06:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
   23a0a:	78e2      	ldrb	r2, [r4, #3]
   23a0c:	78a1      	ldrb	r1, [r4, #2]
   23a0e:	9000      	str	r0, [sp, #0]
   23a10:	4628      	mov	r0, r5
   23a12:	e9cd 7c01 	strd	r7, ip, [sp, #4]
   23a16:	f7f2 fd69 	bl	164ec <USBH_OpenPipe>
		USBH_OpenPipe  (phost,
   23a1a:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
   23a1e:	f8b4 c008 	ldrh.w	ip, [r4, #8]
   23a22:	4628      	mov	r0, r5
   23a24:	9701      	str	r7, [sp, #4]
   23a26:	f895 731d 	ldrb.w	r7, [r5, #797]	; 0x31d
   23a2a:	7922      	ldrb	r2, [r4, #4]
   23a2c:	f8cd c008 	str.w	ip, [sp, #8]
   23a30:	7861      	ldrb	r1, [r4, #1]
   23a32:	9700      	str	r7, [sp, #0]
   23a34:	f7f2 fd5a 	bl	164ec <USBH_OpenPipe>
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
   23a38:	4632      	mov	r2, r6
   23a3a:	7861      	ldrb	r1, [r4, #1]
   23a3c:	4628      	mov	r0, r5
		myMIDIHandle.state = MIDI_IDLE_STATE;
   23a3e:	7026      	strb	r6, [r4, #0]
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
   23a40:	f000 f942 	bl	23cc8 <USBH_LL_SetToggle>
		USBH_LL_SetToggle  (phost, myMIDIHandle.OutPipe,0);
   23a44:	4632      	mov	r2, r6
   23a46:	78a1      	ldrb	r1, [r4, #2]
   23a48:	4628      	mov	r0, r5
   23a4a:	f000 f93d 	bl	23cc8 <USBH_LL_SetToggle>
   23a4e:	4630      	mov	r0, r6
}
   23a50:	b005      	add	sp, #20
   23a52:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
   23a54:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
   23a56:	8122      	strh	r2, [r4, #8]
   23a58:	e7bb      	b.n	239d2 <USBH_MIDI_InterfaceInit+0x3e>
		status = USBH_FAIL;
   23a5a:	2002      	movs	r0, #2
}
   23a5c:	b005      	add	sp, #20
   23a5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
   23a60:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
   23a62:	8123      	strh	r3, [r4, #8]
   23a64:	78e1      	ldrb	r1, [r4, #3]
   23a66:	e7bf      	b.n	239e8 <USBH_MIDI_InterfaceInit+0x54>
   23a68:	020fbcc8 	.word	0x020fbcc8

00023a6c <USBH_MIDI_Stop>:
  if(phost->gState == HOST_CLASS)
   23a6c:	7802      	ldrb	r2, [r0, #0]
   23a6e:	2a0b      	cmp	r2, #11
   23a70:	d001      	beq.n	23a76 <USBH_MIDI_Stop+0xa>
}
   23a72:	2000      	movs	r0, #0
   23a74:	4770      	bx	lr
{
   23a76:	b538      	push	{r3, r4, r5, lr}
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23a78:	f8d0 24ec 	ldr.w	r2, [r0, #1260]	; 0x4ec
    MIDI_Handle->state = MIDI_IDLE_STATE;
   23a7c:	2300      	movs	r3, #0
   23a7e:	4604      	mov	r4, r0
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23a80:	69d5      	ldr	r5, [r2, #28]
    MIDI_Handle->state = MIDI_IDLE_STATE;
   23a82:	702b      	strb	r3, [r5, #0]
    USBH_ClosePipe(phost, MIDI_Handle->InPipe);
   23a84:	7869      	ldrb	r1, [r5, #1]
   23a86:	f7f2 fd41 	bl	1650c <USBH_ClosePipe>
    USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
   23a8a:	78a9      	ldrb	r1, [r5, #2]
   23a8c:	4620      	mov	r0, r4
   23a8e:	f7f2 fd3d 	bl	1650c <USBH_ClosePipe>
}
   23a92:	2000      	movs	r0, #0
   23a94:	bd38      	pop	{r3, r4, r5, pc}
   23a96:	bf00      	nop

00023a98 <USBH_MIDI_Receive>:
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
   23a98:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
   23a9c:	69db      	ldr	r3, [r3, #28]
	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
   23a9e:	7818      	ldrb	r0, [r3, #0]
   23aa0:	2801      	cmp	r0, #1
   23aa2:	d901      	bls.n	23aa8 <USBH_MIDI_Receive+0x10>
	USBH_StatusTypeDef Status = USBH_BUSY;
   23aa4:	2001      	movs	r0, #1
#if (USBH_USE_OS == 1)
		osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);
#endif
	}
	return Status;
}
   23aa6:	4770      	bx	lr
{
   23aa8:	b430      	push	{r4, r5}
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   23aaa:	2501      	movs	r5, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   23aac:	2403      	movs	r4, #3
		MIDI_Handle->pRxData = pbuff;
   23aae:	6119      	str	r1, [r3, #16]
		Status = USBH_OK;
   23ab0:	2000      	movs	r0, #0
		MIDI_Handle->RxDataLength = length;
   23ab2:	82da      	strh	r2, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
   23ab4:	701d      	strb	r5, [r3, #0]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
   23ab6:	765c      	strb	r4, [r3, #25]
}
   23ab8:	bc30      	pop	{r4, r5}
   23aba:	4770      	bx	lr

00023abc <HAL_HCD_MspInit>:
                       LL Driver Callbacks (HCD -> USB Host Library)
*******************************************************************************/
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
   23abc:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcdHandle->Instance==USB_OTG_FS)
   23abe:	4b1e      	ldr	r3, [pc, #120]	; (23b38 <HAL_HCD_MspInit+0x7c>)
{
   23ac0:	b088      	sub	sp, #32
  if(hcdHandle->Instance==USB_OTG_FS)
   23ac2:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   23ac4:	2400      	movs	r4, #0
  if(hcdHandle->Instance==USB_OTG_FS)
   23ac6:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
   23ac8:	9407      	str	r4, [sp, #28]
   23aca:	e9cd 4403 	strd	r4, r4, [sp, #12]
   23ace:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(hcdHandle->Instance==USB_OTG_FS)
   23ad2:	d001      	beq.n	23ad8 <HAL_HCD_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
//
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
   23ad4:	b008      	add	sp, #32
   23ad6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
   23ad8:	4d18      	ldr	r5, [pc, #96]	; (23b3c <HAL_HCD_MspInit+0x80>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   23ada:	2202      	movs	r2, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   23adc:	2003      	movs	r0, #3
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   23ade:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
    __HAL_RCC_GPIOA_CLK_ENABLE();
   23ae2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   23ae6:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
   23ae8:	f043 0301 	orr.w	r3, r3, #1
   23aec:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
   23af0:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   23af4:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
   23af6:	220a      	movs	r2, #10
    __HAL_RCC_GPIOA_CLK_ENABLE();
   23af8:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   23afc:	9006      	str	r0, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   23afe:	4810      	ldr	r0, [pc, #64]	; (23b40 <HAL_HCD_MspInit+0x84>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
   23b00:	9301      	str	r3, [sp, #4]
   23b02:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
   23b04:	9207      	str	r2, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
   23b06:	9603      	str	r6, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   23b08:	f7e8 f85a 	bl	bbc0 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   23b0c:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   23b10:	4622      	mov	r2, r4
   23b12:	2101      	movs	r1, #1
   23b14:	2065      	movs	r0, #101	; 0x65
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   23b16:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   23b1a:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
   23b1e:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
   23b22:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
   23b26:	9302      	str	r3, [sp, #8]
   23b28:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
   23b2a:	f7e5 ff53 	bl	99d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
   23b2e:	2065      	movs	r0, #101	; 0x65
   23b30:	f7e5 ff96 	bl	9a60 <HAL_NVIC_EnableIRQ>
}
   23b34:	b008      	add	sp, #32
   23b36:	bd70      	pop	{r4, r5, r6, pc}
   23b38:	40080000 	.word	0x40080000
   23b3c:	58024400 	.word	0x58024400
   23b40:	58020000 	.word	0x58020000

00023b44 <USBH_LL_Init>:
  * @brief  Initialize the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
   23b44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
   23b46:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
   23b4a:	2b01      	cmp	r3, #1
   23b4c:	d001      	beq.n	23b52 <USBH_LL_Init+0xe>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
  }
  return USBH_OK;
}
   23b4e:	2000      	movs	r0, #0
   23b50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   23b52:	4a10      	ldr	r2, [pc, #64]	; (23b94 <USBH_LL_Init+0x50>)
   23b54:	4604      	mov	r4, r0
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
   23b56:	2606      	movs	r6, #6
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   23b58:	4f0f      	ldr	r7, [pc, #60]	; (23b98 <USBH_LL_Init+0x54>)
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
   23b5a:	2502      	movs	r5, #2
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   23b5c:	2100      	movs	r1, #0
  phost->pData = &hhcd_USB_OTG_FS;
   23b5e:	f8c0 2540 	str.w	r2, [r0, #1344]	; 0x540
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   23b62:	4610      	mov	r0, r2
  hhcd_USB_OTG_FS.pData = phost;
   23b64:	f8c2 42c0 	str.w	r4, [r2, #704]	; 0x2c0
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   23b68:	6017      	str	r7, [r2, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
   23b6a:	6096      	str	r6, [r2, #8]
  hhcd_USB_OTG_FS.Init.dma_enable = ENABLE;
   23b6c:	e9c2 3303 	strd	r3, r3, [r2, #12]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   23b70:	e9c2 5106 	strd	r5, r1, [r2, #24]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   23b74:	f7e8 fbc6 	bl	c304 <HAL_HCD_Init>
   23b78:	b940      	cbnz	r0, 23b8c <USBH_LL_Init+0x48>
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
   23b7a:	4806      	ldr	r0, [pc, #24]	; (23b94 <USBH_LL_Init+0x50>)
   23b7c:	f7e8 fccc 	bl	c518 <HAL_HCD_GetCurrentFrame>
   23b80:	4601      	mov	r1, r0
   23b82:	4620      	mov	r0, r4
   23b84:	f7f1 fd58 	bl	15638 <USBH_LL_SetTimer>
}
   23b88:	2000      	movs	r0, #0
   23b8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Error_Handler( );
   23b8c:	f7f5 fc96 	bl	194bc <Error_Handler>
   23b90:	e7f3      	b.n	23b7a <USBH_LL_Init+0x36>
   23b92:	bf00      	nop
   23b94:	020fbde4 	.word	0x020fbde4
   23b98:	40080000 	.word	0x40080000

00023b9c <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
   23b9c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Start(phost->pData);
   23b9e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23ba2:	f7e8 fc7f 	bl	c4a4 <HAL_HCD_Start>
   23ba6:	2803      	cmp	r0, #3
   23ba8:	d802      	bhi.n	23bb0 <USBH_LL_Start+0x14>
   23baa:	4b02      	ldr	r3, [pc, #8]	; (23bb4 <USBH_LL_Start+0x18>)
   23bac:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23bae:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Start(phost->pData);
   23bb0:	2002      	movs	r0, #2
}
   23bb2:	bd08      	pop	{r3, pc}
   23bb4:	000326dc 	.word	0x000326dc

00023bb8 <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
   23bb8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Stop(phost->pData);
   23bba:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23bbe:	f7e8 fc87 	bl	c4d0 <HAL_HCD_Stop>
   23bc2:	2803      	cmp	r0, #3
   23bc4:	d802      	bhi.n	23bcc <USBH_LL_Stop+0x14>
   23bc6:	4b02      	ldr	r3, [pc, #8]	; (23bd0 <USBH_LL_Stop+0x18>)
   23bc8:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
 
  return usb_status;
}
   23bca:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Stop(phost->pData);
   23bcc:	2002      	movs	r0, #2
}
   23bce:	bd08      	pop	{r3, pc}
   23bd0:	000326dc 	.word	0x000326dc

00023bd4 <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
   23bd4:	b508      	push	{r3, lr}
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   23bd6:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23bda:	f7e8 fca1 	bl	c520 <HAL_HCD_GetCurrentSpeed>
   23bde:	2802      	cmp	r0, #2
   23be0:	d802      	bhi.n	23be8 <USBH_LL_GetSpeed+0x14>
   23be2:	4b02      	ldr	r3, [pc, #8]	; (23bec <USBH_LL_GetSpeed+0x18>)
   23be4:	5c18      	ldrb	r0, [r3, r0]
  default:
   speed = USBH_SPEED_FULL;
    break;
  }
  return  speed;
}
   23be6:	bd08      	pop	{r3, pc}
  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   23be8:	2001      	movs	r0, #1
}
   23bea:	bd08      	pop	{r3, pc}
   23bec:	000326d8 	.word	0x000326d8

00023bf0 <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
   23bf0:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_ResetPort(phost->pData);
   23bf2:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23bf6:	f7e8 fc7d 	bl	c4f4 <HAL_HCD_ResetPort>
   23bfa:	2803      	cmp	r0, #3
   23bfc:	d802      	bhi.n	23c04 <USBH_LL_ResetPort+0x14>
   23bfe:	4b02      	ldr	r3, [pc, #8]	; (23c08 <USBH_LL_ResetPort+0x18>)
   23c00:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23c02:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_ResetPort(phost->pData);
   23c04:	2002      	movs	r0, #2
}
   23c06:	bd08      	pop	{r3, pc}
   23c08:	000326dc 	.word	0x000326dc

00023c0c <USBH_LL_GetLastXferSize>:
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
   23c0c:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23c10:	f7e8 bc7c 	b.w	c50c <HAL_HCD_HC_GetXferCount>

00023c14 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
   23c14:	b530      	push	{r4, r5, lr}
   23c16:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23c18:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
   23c1c:	f89d 4020 	ldrb.w	r4, [sp, #32]
   23c20:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23c24:	9400      	str	r4, [sp, #0]
{
   23c26:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23c2a:	e9cd 5401 	strd	r5, r4, [sp, #4]
   23c2e:	f7e8 fb1b 	bl	c268 <HAL_HCD_HC_Init>
   23c32:	2803      	cmp	r0, #3
   23c34:	d803      	bhi.n	23c3e <USBH_LL_OpenPipe+0x2a>
   23c36:	4b03      	ldr	r3, [pc, #12]	; (23c44 <USBH_LL_OpenPipe+0x30>)
   23c38:	5c18      	ldrb	r0, [r3, r0]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23c3a:	b005      	add	sp, #20
   23c3c:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
   23c3e:	2002      	movs	r0, #2
}
   23c40:	b005      	add	sp, #20
   23c42:	bd30      	pop	{r4, r5, pc}
   23c44:	000326dc 	.word	0x000326dc

00023c48 <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
   23c48:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
   23c4a:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23c4e:	f7e8 fb47 	bl	c2e0 <HAL_HCD_HC_Halt>
   23c52:	2803      	cmp	r0, #3
   23c54:	d802      	bhi.n	23c5c <USBH_LL_ClosePipe+0x14>
   23c56:	4b02      	ldr	r3, [pc, #8]	; (23c60 <USBH_LL_ClosePipe+0x18>)
   23c58:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23c5a:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
   23c5c:	2002      	movs	r0, #2
}
   23c5e:	bd08      	pop	{r3, pc}
   23c60:	000326dc 	.word	0x000326dc

00023c64 <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
   23c64:	b530      	push	{r4, r5, lr}
   23c66:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23c68:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
   23c6c:	f89d 5020 	ldrb.w	r5, [sp, #32]
   23c70:	9c09      	ldr	r4, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23c72:	9500      	str	r5, [sp, #0]
   23c74:	9401      	str	r4, [sp, #4]
{
   23c76:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
   23c7a:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23c7e:	e9cd 5402 	strd	r5, r4, [sp, #8]
   23c82:	f7e8 fb9f 	bl	c3c4 <HAL_HCD_HC_SubmitRequest>
   23c86:	2803      	cmp	r0, #3
   23c88:	d803      	bhi.n	23c92 <USBH_LL_SubmitURB+0x2e>
   23c8a:	4b03      	ldr	r3, [pc, #12]	; (23c98 <USBH_LL_SubmitURB+0x34>)
   23c8c:	5c18      	ldrb	r0, [r3, r0]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
   23c8e:	b005      	add	sp, #20
   23c90:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
   23c92:	2002      	movs	r0, #2
}
   23c94:	b005      	add	sp, #20
   23c96:	bd30      	pop	{r4, r5, pc}
   23c98:	000326dc 	.word	0x000326dc

00023c9c <USBH_LL_GetURBState>:
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
   23c9c:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
   23ca0:	f7e8 bc2c 	b.w	c4fc <HAL_HCD_HC_GetURBState>

00023ca4 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Active
  *           1 : VBUS Inactive
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
   23ca4:	b508      	push	{r3, lr}
  if (phost->id == HOST_FS) {
   23ca6:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
   23caa:	2b01      	cmp	r3, #1
   23cac:	d004      	beq.n	23cb8 <USBH_LL_DriverVBUS+0x14>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
   23cae:	20c8      	movs	r0, #200	; 0xc8
   23cb0:	f7e4 fba6 	bl	8400 <HAL_Delay>
  return USBH_OK;
}
   23cb4:	2000      	movs	r0, #0
   23cb6:	bd08      	pop	{r3, pc}
    MX_DriverVbusFS(state);
   23cb8:	4608      	mov	r0, r1
   23cba:	f000 f819 	bl	23cf0 <MX_DriverVbusFS>
  HAL_Delay(200);
   23cbe:	20c8      	movs	r0, #200	; 0xc8
   23cc0:	f7e4 fb9e 	bl	8400 <HAL_Delay>
}
   23cc4:	2000      	movs	r0, #0
   23cc6:	bd08      	pop	{r3, pc}

00023cc8 <USBH_LL_SetToggle>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
   23cc8:	f8d0 3540 	ldr.w	r3, [r0, #1344]	; 0x540

  if(pHandle->hc[pipe].ep_is_in)
   23ccc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   23cd0:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   23cd4:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
   23cd8:	b91b      	cbnz	r3, 23ce2 <USBH_LL_SetToggle+0x1a>
  {
    pHandle->hc[pipe].toggle_in = toggle;
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
   23cda:	f881 2051 	strb.w	r2, [r1, #81]	; 0x51
  }

  return USBH_OK;
}
   23cde:	2000      	movs	r0, #0
   23ce0:	4770      	bx	lr
    pHandle->hc[pipe].toggle_in = toggle;
   23ce2:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
}
   23ce6:	2000      	movs	r0, #0
   23ce8:	4770      	bx	lr
   23cea:	bf00      	nop

00023cec <USBH_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
   23cec:	f7e4 bb88 	b.w	8400 <HAL_Delay>

00023cf0 <MX_DriverVbusFS>:
  {
    /* Drive low Charge pump */
    data = GPIO_PIN_RESET;
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,(GPIO_PinState)data);
   23cf0:	fab0 f280 	clz	r2, r0
   23cf4:	2140      	movs	r1, #64	; 0x40
   23cf6:	4802      	ldr	r0, [pc, #8]	; (23d00 <MX_DriverVbusFS+0x10>)
   23cf8:	0952      	lsrs	r2, r2, #5
   23cfa:	f7e8 ba9b 	b.w	c234 <HAL_GPIO_WritePin>
   23cfe:	bf00      	nop
   23d00:	58021400 	.word	0x58021400
   23d04:	00000000 	.word	0x00000000

00023d08 <mayer_fht>:
 REAL f0,g0,f1,g1,f2,g2,f3,g3; */
 int  k,k1,k2,k3,k4,kx;
 REAL *fi,*fn,*gi;
 TRIG_VARS;

 for (k1=1,k2=0;k1<n;k1++)
   23d08:	2901      	cmp	r1, #1
{
   23d0a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23d0e:	ed2d 8b02 	vpush	{d8}
   23d12:	b08b      	sub	sp, #44	; 0x2c
 for (k1=1,k2=0;k1<n;k1++)
   23d14:	f340 822d 	ble.w	24172 <mayer_fht+0x46a>
    {
     REAL aa;
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   23d18:	ea4f 0c61 	mov.w	ip, r1, asr #1
   23d1c:	1d07      	adds	r7, r0, #4
 for (k1=1,k2=0;k1<n;k1++)
   23d1e:	2400      	movs	r4, #0
   23d20:	2601      	movs	r6, #1
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   23d22:	ea3c 0304 	bics.w	r3, ip, r4
   23d26:	ea8c 0204 	eor.w	r2, ip, r4
   23d2a:	f040 8220 	bne.w	2416e <mayer_fht+0x466>
   23d2e:	4663      	mov	r3, ip
   23d30:	105b      	asrs	r3, r3, #1
   23d32:	ea83 0402 	eor.w	r4, r3, r2
   23d36:	ea23 0502 	bic.w	r5, r3, r2
   23d3a:	4622      	mov	r2, r4
   23d3c:	2d00      	cmp	r5, #0
   23d3e:	d0f7      	beq.n	23d30 <mayer_fht+0x28>
     if (k1>k2)
   23d40:	42b4      	cmp	r4, r6
   23d42:	da05      	bge.n	23d50 <mayer_fht+0x48>
        {
             aa=fz[k1];fz[k1]=fz[k2];fz[k2]=aa;
   23d44:	eb00 0384 	add.w	r3, r0, r4, lsl #2
   23d48:	683a      	ldr	r2, [r7, #0]
   23d4a:	681d      	ldr	r5, [r3, #0]
   23d4c:	603d      	str	r5, [r7, #0]
   23d4e:	601a      	str	r2, [r3, #0]
 for (k1=1,k2=0;k1<n;k1++)
   23d50:	3601      	adds	r6, #1
   23d52:	3704      	adds	r7, #4
   23d54:	42b1      	cmp	r1, r6
   23d56:	d1e4      	bne.n	23d22 <mayer_fht+0x1a>
        }
    }
 for ( k=0 ; (1<<k)<n ; k++ );
   23d58:	2300      	movs	r3, #0
   23d5a:	2401      	movs	r4, #1
   23d5c:	3301      	adds	r3, #1
   23d5e:	fa04 f203 	lsl.w	r2, r4, r3
   23d62:	42b2      	cmp	r2, r6
   23d64:	dbfa      	blt.n	23d5c <mayer_fht+0x54>
 k  &= 1;
 if (k==0)
   23d66:	f013 0301 	ands.w	r3, r3, #1
   23d6a:	eb00 0a86 	add.w	sl, r0, r6, lsl #2
   23d6e:	9301      	str	r3, [sp, #4]
   23d70:	f000 8201 	beq.w	24176 <mayer_fht+0x46e>
             fi[1 ] = (f1+f3);
            }
    }
 else
    {
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
   23d74:	4550      	cmp	r0, sl
   23d76:	d266      	bcs.n	23e46 <mayer_fht+0x13e>
   23d78:	f100 0320 	add.w	r3, r0, #32
   23d7c:	f100 0440 	add.w	r4, r0, #64	; 0x40
   23d80:	f1c3 021f 	rsb	r2, r3, #31
   23d84:	4452      	add	r2, sl
   23d86:	f022 021f 	bic.w	r2, r2, #31
             bf0     = (bs1 + bs2);
             bg1     = (bc1 - bc2);     
             bg0     = (bc1 + bc2);
             bf3     = (bs3 - bs4);     
             bf2     = (bs3 + bs4);
             bg3     = SQRT2*bc4;               
   23d8a:	ed9f 3be9 	vldr	d3, [pc, #932]	; 24130 <mayer_fht+0x428>
   23d8e:	4422      	add	r2, r4
             bc3     = fi[4 ] - gi[4 ];
   23d90:	ed53 7a03 	vldr	s15, [r3, #-12]
   23d94:	3320      	adds	r3, #32
             bc4     = fi[6 ] - gi[6 ];
   23d96:	ed13 6a0a 	vldr	s12, [r3, #-40]	; 0xffffffd8
   23d9a:	ed13 7a09 	vldr	s14, [r3, #-36]	; 0xffffffdc
             bc3     = fi[4 ] - gi[4 ];
   23d9e:	ed53 6a0c 	vldr	s13, [r3, #-48]	; 0xffffffd0
             bc4     = fi[6 ] - gi[6 ];
   23da2:	ee36 2a47 	vsub.f32	s4, s12, s14
             bc1     = fi[0 ] - gi[0 ];
   23da6:	ed53 5a0f 	vldr	s11, [r3, #-60]	; 0xffffffc4
             bc3     = fi[4 ] - gi[4 ];
   23daa:	ee36 0ae7 	vsub.f32	s0, s13, s15
             bc2     = fi[2 ] - gi[2 ];
   23dae:	ed53 4a0e 	vldr	s9, [r3, #-56]	; 0xffffffc8
             bc1     = fi[0 ] - gi[0 ];
   23db2:	ed13 5a10 	vldr	s10, [r3, #-64]	; 0xffffffc0
             bs3     = fi[4 ] + gi[4 ];
   23db6:	ee76 6aa7 	vadd.f32	s13, s13, s15
             bg3     = SQRT2*bc4;               
   23dba:	eeb7 2ac2 	vcvt.f64.f32	d2, s4
             bc2     = fi[2 ] - gi[2 ];
   23dbe:	ed53 7a0d 	vldr	s15, [r3, #-52]	; 0xffffffcc
             bg2     = SQRT2*bc3;
   23dc2:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
             bc1     = fi[0 ] - gi[0 ];
   23dc6:	ee75 1a65 	vsub.f32	s3, s10, s11
             bg3     = SQRT2*bc4;               
   23dca:	ee22 2b03 	vmul.f64	d2, d2, d3
             bg2     = SQRT2*bc3;
   23dce:	ee20 0b03 	vmul.f64	d0, d0, d3
             bc2     = fi[2 ] - gi[2 ];
   23dd2:	ee34 4ae7 	vsub.f32	s8, s9, s15
             bs1     = fi[0 ] + gi[0 ];
   23dd6:	ee35 5a25 	vadd.f32	s10, s10, s11
             bg3     = SQRT2*bc4;               
   23dda:	eeb7 2bc2 	vcvt.f32.f64	s4, d2
             bs2     = fi[2 ] + gi[2 ];
   23dde:	ee74 5aa7 	vadd.f32	s11, s9, s15
             bg2     = SQRT2*bc3;
   23de2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
             bs4     = fi[6 ] + gi[6 ];
   23de6:	ee76 7a07 	vadd.f32	s15, s12, s14
             bg0     = (bc1 + bc2);
   23dea:	ee31 1a84 	vadd.f32	s2, s3, s8
             bg1     = (bc1 - bc2);     
   23dee:	ee71 4ac4 	vsub.f32	s9, s3, s8
             bf1     = (bs1 - bs2);     
   23df2:	ee35 7a65 	vsub.f32	s14, s10, s11
             bf2     = (bs3 + bs4);
   23df6:	ee36 6aa7 	vadd.f32	s12, s13, s15
             bf0     = (bs1 + bs2);
   23dfa:	ee75 5a25 	vadd.f32	s11, s10, s11
             bf3     = (bs3 - bs4);     
   23dfe:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[4 ] = bf0 - bf2;
             fi[0 ] = bf0 + bf2;
             fi[6 ] = bf1 - bf3;
             fi[2 ] = bf1 + bf3;
             gi[4 ] = bg0 - bg2;
   23e02:	ee31 5a40 	vsub.f32	s10, s2, s0
             gi[0 ] = bg0 + bg2;
             gi[6 ] = bg1 - bg3;
   23e06:	ee74 6ac2 	vsub.f32	s13, s9, s4
             gi[0 ] = bg0 + bg2;
   23e0a:	ee31 0a00 	vadd.f32	s0, s2, s0
             gi[4 ] = bg0 - bg2;
   23e0e:	ed03 5a0b 	vstr	s10, [r3, #-44]	; 0xffffffd4
             gi[2 ] = bg1 + bg3;
   23e12:	ee34 2a82 	vadd.f32	s4, s9, s4
             gi[6 ] = bg1 - bg3;
   23e16:	ed43 6a09 	vstr	s13, [r3, #-36]	; 0xffffffdc
             fi[4 ] = bf0 - bf2;
   23e1a:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[6 ] = bf1 - bf3;
   23e1e:	ee77 6a67 	vsub.f32	s13, s14, s15
             gi[0 ] = bg0 + bg2;
   23e22:	ed03 0a0f 	vstr	s0, [r3, #-60]	; 0xffffffc4
             fi[0 ] = bf0 + bf2;
   23e26:	ee35 6a86 	vadd.f32	s12, s11, s12
             gi[2 ] = bg1 + bg3;
   23e2a:	ed03 2a0d 	vstr	s4, [r3, #-52]	; 0xffffffcc
             fi[2 ] = bf1 + bf3;
   23e2e:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[4 ] = bf0 - bf2;
   23e32:	ed03 5a0c 	vstr	s10, [r3, #-48]	; 0xffffffd0
             fi[6 ] = bf1 - bf3;
   23e36:	ed43 6a0a 	vstr	s13, [r3, #-40]	; 0xffffffd8
             fi[0 ] = bf0 + bf2;
   23e3a:	ed03 6a10 	vstr	s12, [r3, #-64]	; 0xffffffc0
             fi[2 ] = bf1 + bf3;
   23e3e:	ed43 7a0e 	vstr	s15, [r3, #-56]	; 0xffffffc8
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
   23e42:	429a      	cmp	r2, r3
   23e44:	d1a4      	bne.n	23d90 <mayer_fht+0x88>
            }
    }
 if (n<16) return;
   23e46:	290f      	cmp	r1, #15
   23e48:	f340 818c 	ble.w	24164 <mayer_fht+0x45c>
   23e4c:	9b01      	ldr	r3, [sp, #4]
   23e4e:	3301      	adds	r3, #1
             fi[0 ]  = f0         + f2;
             fi[k3]  = f1         - f3;
             fi[k1]  = f1         + f3;
             g1      = gi[0 ] - gi[k1];
             g0      = gi[0 ] + gi[k1];
             g3      = SQRT2  * gi[k3];
   23e50:	ed9f 8bb7 	vldr	d8, [pc, #732]	; 24130 <mayer_fht+0x428>
   23e54:	009b      	lsls	r3, r3, #2
   23e56:	e9cd 0108 	strd	r0, r1, [sp, #32]
   23e5a:	9306      	str	r3, [sp, #24]
     k  += 2;
   23e5c:	9901      	ldr	r1, [sp, #4]
     k1  = 1  << k;
   23e5e:	2501      	movs	r5, #1
             f1      = fi[0 ] - fi[k1];
   23e60:	2204      	movs	r2, #4
             g2      = SQRT2  * gi[k2];
             gi[k2]  = g0         - g2;
             gi[0 ]  = g0         + g2;
             gi[k3]  = g1         - g3;
             gi[k1]  = g1         + g3;
             gi     += k4;
   23e62:	9808      	ldr	r0, [sp, #32]
     k  += 2;
   23e64:	3102      	adds	r1, #2
             gi     += k4;
   23e66:	4603      	mov	r3, r0
     k1  = 1  << k;
   23e68:	408d      	lsls	r5, r1
             f1      = fi[0 ] - fi[k1];
   23e6a:	fa02 f401 	lsl.w	r4, r2, r1
     k  += 2;
   23e6e:	9101      	str	r1, [sp, #4]
     kx  = k1 >> 1;
   23e70:	106f      	asrs	r7, r5, #1
   23e72:	eb00 0e04 	add.w	lr, r0, r4
     k3  = k2 + k1;
   23e76:	eb05 0145 	add.w	r1, r5, r5, lsl #1
             f1      = fi[0 ] - fi[k1];
   23e7a:	9403      	str	r4, [sp, #12]
         gi  = fi + kx;
   23e7c:	eb00 0287 	add.w	r2, r0, r7, lsl #2
     kx  = k1 >> 1;
   23e80:	9702      	str	r7, [sp, #8]
             f3      = fi[k2] - fi[k3];
   23e82:	0089      	lsls	r1, r1, #2
   23e84:	00ee      	lsls	r6, r5, #3
   23e86:	eb02 0c04 	add.w	ip, r2, r4
   23e8a:	460c      	mov	r4, r1
   23e8c:	9105      	str	r1, [sp, #20]
   23e8e:	9604      	str	r6, [sp, #16]
   23e90:	1857      	adds	r7, r2, r1
   23e92:	1906      	adds	r6, r0, r4
   23e94:	4601      	mov	r1, r0
   23e96:	00ec      	lsls	r4, r5, #3
   23e98:	1910      	adds	r0, r2, r4
   23e9a:	4421      	add	r1, r4
     k4  = k2 << 1;
   23e9c:	00ac      	lsls	r4, r5, #2
   23e9e:	9407      	str	r4, [sp, #28]
             gi     += k4;
   23ea0:	012c      	lsls	r4, r5, #4
             f1      = fi[0 ] - fi[k1];
   23ea2:	ed93 6a00 	vldr	s12, [r3]
             f3      = fi[k2] - fi[k3];
   23ea6:	edd6 6a00 	vldr	s13, [r6]
             f1      = fi[0 ] - fi[k1];
   23eaa:	ed9e 7a00 	vldr	s14, [lr]
             f3      = fi[k2] - fi[k3];
   23eae:	edd1 7a00 	vldr	s15, [r1]
             f0      = fi[0 ] + fi[k1];
   23eb2:	ee76 5a07 	vadd.f32	s11, s12, s14
             f1      = fi[0 ] - fi[k1];
   23eb6:	ee36 7a47 	vsub.f32	s14, s12, s14
             f2      = fi[k2] + fi[k3];
   23eba:	ee37 6aa6 	vadd.f32	s12, s15, s13
             f3      = fi[k2] - fi[k3];
   23ebe:	ee77 7ae6 	vsub.f32	s15, s15, s13
             fi[k2]  = f0         - f2;
   23ec2:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[k3]  = f1         - f3;
   23ec6:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ]  = f0         + f2;
   23eca:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[k1]  = f1         + f3;
   23ece:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[k2]  = f0         - f2;
   23ed2:	ed81 5a00 	vstr	s10, [r1]
   23ed6:	4421      	add	r1, r4
             fi[0 ]  = f0         + f2;
   23ed8:	ed83 6a00 	vstr	s12, [r3]
             fi     += k4;
   23edc:	4423      	add	r3, r4
             fi[k3]  = f1         - f3;
   23ede:	edc6 6a00 	vstr	s13, [r6]
   23ee2:	4426      	add	r6, r4
             fi[k1]  = f1         + f3;
   23ee4:	edce 7a00 	vstr	s15, [lr]
            } while (fi<fn);
   23ee8:	4553      	cmp	r3, sl
             g2      = SQRT2  * gi[k2];
   23eea:	ed90 5a00 	vldr	s10, [r0]
   23eee:	44a6      	add	lr, r4
             g3      = SQRT2  * gi[k3];
   23ef0:	ed97 7a00 	vldr	s14, [r7]
             g2      = SQRT2  * gi[k2];
   23ef4:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
             g1      = gi[0 ] - gi[k1];
   23ef8:	ed92 6a00 	vldr	s12, [r2]
             g3      = SQRT2  * gi[k3];
   23efc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
             g1      = gi[0 ] - gi[k1];
   23f00:	eddc 6a00 	vldr	s13, [ip]
             g2      = SQRT2  * gi[k2];
   23f04:	ee25 5b08 	vmul.f64	d5, d5, d8
             g3      = SQRT2  * gi[k3];
   23f08:	ee27 7b08 	vmul.f64	d7, d7, d8
             g2      = SQRT2  * gi[k2];
   23f0c:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
             g0      = gi[0 ] + gi[k1];
   23f10:	ee76 5a26 	vadd.f32	s11, s12, s13
             g1      = gi[0 ] - gi[k1];
   23f14:	ee76 6a66 	vsub.f32	s13, s12, s13
             g3      = SQRT2  * gi[k3];
   23f18:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
             gi[k2]  = g0         - g2;
   23f1c:	ee35 6ac5 	vsub.f32	s12, s11, s10
             gi[0 ]  = g0         + g2;
   23f20:	ee35 5a85 	vadd.f32	s10, s11, s10
             gi[k3]  = g1         - g3;
   23f24:	ee76 7ac7 	vsub.f32	s15, s13, s14
             gi[k1]  = g1         + g3;
   23f28:	ee36 7a87 	vadd.f32	s14, s13, s14
             gi[k2]  = g0         - g2;
   23f2c:	ed80 6a00 	vstr	s12, [r0]
             gi[0 ]  = g0         + g2;
   23f30:	ed82 5a00 	vstr	s10, [r2]
   23f34:	4420      	add	r0, r4
             gi[k3]  = g1         - g3;
   23f36:	edc7 7a00 	vstr	s15, [r7]
             gi     += k4;
   23f3a:	4422      	add	r2, r4
             gi[k1]  = g1         + g3;
   23f3c:	ed8c 7a00 	vstr	s14, [ip]
   23f40:	4427      	add	r7, r4
   23f42:	44a4      	add	ip, r4
            } while (fi<fn);
   23f44:	d3ad      	bcc.n	23ea2 <mayer_fht+0x19a>
   23f46:	9e06      	ldr	r6, [sp, #24]
   23f48:	497b      	ldr	r1, [pc, #492]	; (24138 <mayer_fht+0x430>)
   23f4a:	4632      	mov	r2, r6
   23f4c:	487b      	ldr	r0, [pc, #492]	; (2413c <mayer_fht+0x434>)
   23f4e:	f008 fd6d 	bl	2ca2c <memcpy>
   23f52:	4632      	mov	r2, r6
   23f54:	497a      	ldr	r1, [pc, #488]	; (24140 <mayer_fht+0x438>)
   23f56:	487b      	ldr	r0, [pc, #492]	; (24144 <mayer_fht+0x43c>)
   23f58:	f008 fd68 	bl	2ca2c <memcpy>
     TRIG_INIT(k,c1,s1);
     for (ii=1;ii<kx;ii++)
   23f5c:	9b02      	ldr	r3, [sp, #8]
   23f5e:	2b01      	cmp	r3, #1
   23f60:	f340 80f8 	ble.w	24154 <mayer_fht+0x44c>
   23f64:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
   23f68:	9a08      	ldr	r2, [sp, #32]
        {
         REAL c2,s2;
         TRIG_NEXT(k,c1,s1);
   23f6a:	f04f 0e01 	mov.w	lr, #1
   23f6e:	2300      	movs	r3, #0
   23f70:	44a8      	add	r8, r5
   23f72:	f102 0904 	add.w	r9, r2, #4
   23f76:	f8df b1d8 	ldr.w	fp, [pc, #472]	; 24150 <mayer_fht+0x448>
   23f7a:	eb02 0888 	add.w	r8, r2, r8, lsl #2
   23f7e:	9a01      	ldr	r2, [sp, #4]
   23f80:	4871      	ldr	r0, [pc, #452]	; (24148 <mayer_fht+0x440>)
   23f82:	1ad2      	subs	r2, r2, r3
   23f84:	0091      	lsls	r1, r2, #2
   23f86:	2a01      	cmp	r2, #1
   23f88:	eb0b 0501 	add.w	r5, fp, r1
   23f8c:	4408      	add	r0, r1
   23f8e:	ed95 2a00 	vldr	s4, [r5]
   23f92:	edd0 2a00 	vldr	s5, [r0]
   23f96:	dd30      	ble.n	23ffa <mayer_fht+0x2f2>
   23f98:	3302      	adds	r3, #2
   23f9a:	fa4e f003 	asr.w	r0, lr, r3
   23f9e:	07c5      	lsls	r5, r0, #31
   23fa0:	d504      	bpl.n	23fac <mayer_fht+0x2a4>
   23fa2:	3301      	adds	r3, #1
   23fa4:	fa4e f003 	asr.w	r0, lr, r3
   23fa8:	07c0      	lsls	r0, r0, #31
   23faa:	d4fa      	bmi.n	23fa2 <mayer_fht+0x29a>
   23fac:	9801      	ldr	r0, [sp, #4]
   23fae:	3a01      	subs	r2, #1
   23fb0:	4e65      	ldr	r6, [pc, #404]	; (24148 <mayer_fht+0x440>)
   23fb2:	1ac3      	subs	r3, r0, r3
   23fb4:	4865      	ldr	r0, [pc, #404]	; (2414c <mayer_fht+0x444>)
   23fb6:	0092      	lsls	r2, r2, #2
   23fb8:	4408      	add	r0, r1
   23fba:	009b      	lsls	r3, r3, #2
   23fbc:	eb0b 0502 	add.w	r5, fp, r2
   23fc0:	4432      	add	r2, r6
   23fc2:	edd0 7a00 	vldr	s15, [r0]
   23fc6:	eb0b 0003 	add.w	r0, fp, r3
   23fca:	4433      	add	r3, r6
   23fcc:	edd2 6a00 	vldr	s13, [r2]
   23fd0:	ed90 6a00 	vldr	s12, [r0]
   23fd4:	eb0b 0001 	add.w	r0, fp, r1
   23fd8:	edd5 5a00 	vldr	s11, [r5]
   23fdc:	4431      	add	r1, r6
   23fde:	ed93 7a00 	vldr	s14, [r3]
   23fe2:	ee35 6a86 	vadd.f32	s12, s11, s12
   23fe6:	ee36 7a87 	vadd.f32	s14, s13, s14
   23fea:	ee66 6a27 	vmul.f32	s13, s12, s15
   23fee:	ee67 7a27 	vmul.f32	s15, s14, s15
   23ff2:	edc0 6a00 	vstr	s13, [r0]
   23ff6:	edc1 7a00 	vstr	s15, [r1]
   23ffa:	9a03      	ldr	r2, [sp, #12]
         c2 = c1*c1 - s1*s1;
   23ffc:	ee22 3a42 	vnmul.f32	s6, s4, s4
         s2 = 2*(c1*s1);
   24000:	ee62 3a22 	vmul.f32	s7, s4, s5
             fn = fz + n;
             fi = fz +ii;
   24004:	464b      	mov	r3, r9
   24006:	eb02 0709 	add.w	r7, r2, r9
   2400a:	eb02 0608 	add.w	r6, r2, r8
   2400e:	9a05      	ldr	r2, [sp, #20]
         c2 = c1*c1 - s1*s1;
   24010:	eea2 3aa2 	vfma.f32	s6, s5, s5
         s2 = 2*(c1*s1);
   24014:	ee73 3aa3 	vadd.f32	s7, s7, s7
             gi = fz +k1-ii;
   24018:	46c4      	mov	ip, r8
   2401a:	eb02 0509 	add.w	r5, r2, r9
   2401e:	eb02 0008 	add.w	r0, r2, r8
   24022:	9a04      	ldr	r2, [sp, #16]
   24024:	4611      	mov	r1, r2
   24026:	4442      	add	r2, r8
   24028:	4449      	add	r1, r9
                 a       = c2*fi[k1] + s2*gi[k1];
                 f1      = fi[0 ]    - a;
                 f0      = fi[0 ]    + a;
                 g1      = gi[0 ]    - b;
                 g0      = gi[0 ]    + b;
                 b       = s2*fi[k3] - c2*gi[k3];
   2402a:	edd0 4a00 	vldr	s9, [r0]
   2402e:	edd5 7a00 	vldr	s15, [r5]
   24032:	ee63 1a64 	vnmul.f32	s3, s6, s9
                 a       = c2*fi[k3] + s2*gi[k3];
                 f3      = fi[k2]    - a;
                 f2      = fi[k2]    + a;
                 g3      = gi[k2]    - b;
   24036:	ed92 1a00 	vldr	s2, [r2]
                 a       = c2*fi[k3] + s2*gi[k3];
   2403a:	ee64 4aa3 	vmul.f32	s9, s9, s7
                 b       = s2*fi[k1] - c2*gi[k1];
   2403e:	edd6 5a00 	vldr	s11, [r6]
                 f3      = fi[k2]    - a;
   24042:	ed91 6a00 	vldr	s12, [r1]
                 b       = s2*fi[k3] - c2*gi[k3];
   24046:	eee7 1aa3 	vfma.f32	s3, s15, s7
                 b       = s2*fi[k1] - c2*gi[k1];
   2404a:	ed97 0a00 	vldr	s0, [r7]
                 a       = c2*fi[k3] + s2*gi[k3];
   2404e:	eee7 4a83 	vfma.f32	s9, s15, s6
                 f1      = fi[0 ]    - a;
   24052:	edd3 6a00 	vldr	s13, [r3]
                 a       = c2*fi[k1] + s2*gi[k1];
   24056:	ee25 7aa3 	vmul.f32	s14, s11, s7
                 g1      = gi[0 ]    - b;
   2405a:	ed9c 5a00 	vldr	s10, [ip]
                 b       = s2*fi[k1] - c2*gi[k1];
   2405e:	ee63 5a65 	vnmul.f32	s11, s6, s11
                 a       = c2*fi[k1] + s2*gi[k1];
   24062:	eea0 7a03 	vfma.f32	s14, s0, s6
                 g3      = gi[k2]    - b;
   24066:	ee31 4a61 	vsub.f32	s8, s2, s3
                 f3      = fi[k2]    - a;
   2406a:	ee76 7a64 	vsub.f32	s15, s12, s9
                 g2      = gi[k2]    + b;
   2406e:	ee71 1a21 	vadd.f32	s3, s2, s3
                 b       = s1*f2     - c1*g3;
                 a       = c1*f2     + s1*g3;
   24072:	ee62 0a04 	vmul.f32	s1, s4, s8
                 f2      = fi[k2]    + a;
   24076:	ee76 4a24 	vadd.f32	s9, s12, s9
                 b       = s1*f2     - c1*g3;
   2407a:	ee24 4a62 	vnmul.f32	s8, s8, s5
                 a       = c1*f2     + s1*g3;
   2407e:	eeb0 1a60 	vmov.f32	s2, s1
                 b       = s2*fi[k1] - c2*gi[k1];
   24082:	eee0 5a23 	vfma.f32	s11, s0, s7
                 fi[k2]  = f0        - a;
                 fi[0 ]  = f0        + a;
                 gi[k3]  = g1        - b;
                 gi[k1]  = g1        + b;
                 b       = c1*g2     - s1*f3;
                 a       = s1*g2     + c1*f3;
   24086:	ee22 6aa7 	vmul.f32	s12, s5, s15
                 a       = c1*f2     + s1*g3;
   2408a:	eea2 1aa4 	vfma.f32	s2, s5, s9
                 b       = s1*f2     - c1*g3;
   2408e:	eea2 4a24 	vfma.f32	s8, s4, s9
                 b       = c1*g2     - s1*f3;
   24092:	ee67 7ac2 	vnmul.f32	s15, s15, s4
                 a       = s1*g2     + c1*f3;
   24096:	eea2 6a21 	vfma.f32	s12, s4, s3
                 b       = c1*g2     - s1*f3;
   2409a:	eee2 7aa1 	vfma.f32	s15, s5, s3
                 f0      = fi[0 ]    + a;
   2409e:	ee76 1a87 	vadd.f32	s3, s13, s14
                 b       = s1*f2     - c1*g3;
   240a2:	eef0 4a44 	vmov.f32	s9, s8
                 f1      = fi[0 ]    - a;
   240a6:	ee36 7ac7 	vsub.f32	s14, s13, s14
                 g1      = gi[0 ]    - b;
   240aa:	ee35 4a65 	vsub.f32	s8, s10, s11
                 g0      = gi[0 ]    + b;
   240ae:	ee75 6a25 	vadd.f32	s13, s10, s11
                 fi[k2]  = f0        - a;
   240b2:	ee71 5ac1 	vsub.f32	s11, s3, s2
                 fi[0 ]  = f0        + a;
   240b6:	ee31 1a81 	vadd.f32	s2, s3, s2
                 gi[k3]  = g1        - b;
   240ba:	ee34 5a64 	vsub.f32	s10, s8, s9
                 fi[k2]  = f0        - a;
   240be:	edc1 5a00 	vstr	s11, [r1]
                 gi[k1]  = g1        + b;
   240c2:	ee74 4a24 	vadd.f32	s9, s8, s9
                 fi[0 ]  = f0        + a;
   240c6:	ed83 1a00 	vstr	s2, [r3]
                 gi[k2]  = g0        - a;
                 gi[0 ]  = g0        + a;
                 fi[k3]  = f1        - b;
                 fi[k1]  = f1        + b;
                 gi     += k4;
                 fi     += k4;
   240ca:	4423      	add	r3, r4
                 gi[k2]  = g0        - a;
   240cc:	ee76 5ac6 	vsub.f32	s11, s13, s12
                 gi[k3]  = g1        - b;
   240d0:	ed80 5a00 	vstr	s10, [r0]
                 gi[0 ]  = g0        + a;
   240d4:	ee36 6a86 	vadd.f32	s12, s13, s12
                } while (fi<fn);
   240d8:	4553      	cmp	r3, sl
                 fi[k3]  = f1        - b;
   240da:	ee77 6a67 	vsub.f32	s13, s14, s15
                 gi[k1]  = g1        + b;
   240de:	edc6 4a00 	vstr	s9, [r6]
                 fi[k1]  = f1        + b;
   240e2:	ee77 7a27 	vadd.f32	s15, s14, s15
                 gi[k2]  = g0        - a;
   240e6:	edc2 5a00 	vstr	s11, [r2]
   240ea:	4421      	add	r1, r4
                 gi[0 ]  = g0        + a;
   240ec:	ed8c 6a00 	vstr	s12, [ip]
   240f0:	4420      	add	r0, r4
                 fi[k3]  = f1        - b;
   240f2:	edc5 6a00 	vstr	s13, [r5]
   240f6:	4426      	add	r6, r4
                 fi[k1]  = f1        + b;
   240f8:	edc7 7a00 	vstr	s15, [r7]
   240fc:	4422      	add	r2, r4
                 gi     += k4;
   240fe:	44a4      	add	ip, r4
   24100:	4425      	add	r5, r4
   24102:	4427      	add	r7, r4
                } while (fi<fn);
   24104:	d391      	bcc.n	2402a <mayer_fht+0x322>
     for (ii=1;ii<kx;ii++)
   24106:	f10e 0e01 	add.w	lr, lr, #1
   2410a:	9b02      	ldr	r3, [sp, #8]
   2410c:	4573      	cmp	r3, lr
   2410e:	d021      	beq.n	24154 <mayer_fht+0x44c>
         TRIG_NEXT(k,c1,s1);
   24110:	f01e 0301 	ands.w	r3, lr, #1
   24114:	d161      	bne.n	241da <mayer_fht+0x4d2>
   24116:	3301      	adds	r3, #1
   24118:	fa4e f203 	asr.w	r2, lr, r3
   2411c:	07d6      	lsls	r6, r2, #31
   2411e:	d5fa      	bpl.n	24116 <mayer_fht+0x40e>
   24120:	f109 0904 	add.w	r9, r9, #4
   24124:	f1a8 0804 	sub.w	r8, r8, #4
   24128:	e729      	b.n	23f7e <mayer_fht+0x276>
   2412a:	bf00      	nop
   2412c:	f3af 8000 	nop.w
   24130:	667f3bcd 	.word	0x667f3bcd
   24134:	3ff6a09e 	.word	0x3ff6a09e
   24138:	000326e8 	.word	0x000326e8
   2413c:	00062b8c 	.word	0x00062b8c
   24140:	00032788 	.word	0x00032788
   24144:	00062bdc 	.word	0x00062bdc
   24148:	00062b84 	.word	0x00062b84
   2414c:	00032730 	.word	0x00032730
   24150:	00062bd4 	.word	0x00062bd4
   24154:	9b06      	ldr	r3, [sp, #24]
        }
     TRIG_RESET(k,c1,s1);
    } while (k4<n);
   24156:	9a07      	ldr	r2, [sp, #28]
   24158:	3308      	adds	r3, #8
   2415a:	9306      	str	r3, [sp, #24]
   2415c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2415e:	4293      	cmp	r3, r2
   24160:	f73f ae7c 	bgt.w	23e5c <mayer_fht+0x154>
}
   24164:	b00b      	add	sp, #44	; 0x2c
   24166:	ecbd 8b02 	vpop	{d8}
   2416a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
   2416e:	4614      	mov	r4, r2
   24170:	e5e6      	b.n	23d40 <mayer_fht+0x38>
   24172:	eb00 0a81 	add.w	sl, r0, r1, lsl #2
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
   24176:	4550      	cmp	r0, sl
   24178:	d22c      	bcs.n	241d4 <mayer_fht+0x4cc>
   2417a:	f100 0310 	add.w	r3, r0, #16
   2417e:	f100 0420 	add.w	r4, r0, #32
   24182:	f1c3 020f 	rsb	r2, r3, #15
   24186:	4452      	add	r2, sl
   24188:	f022 020f 	bic.w	r2, r2, #15
   2418c:	4422      	add	r2, r4
             f1     = fi[0 ]-fi[1 ];
   2418e:	ed13 6a03 	vldr	s12, [r3, #-12]
   24192:	3310      	adds	r3, #16
             f3     = fi[2 ]-fi[3 ];
   24194:	ed53 6a06 	vldr	s13, [r3, #-24]	; 0xffffffe8
             f1     = fi[0 ]-fi[1 ];
   24198:	ed53 5a08 	vldr	s11, [r3, #-32]	; 0xffffffe0
             f3     = fi[2 ]-fi[3 ];
   2419c:	ed53 7a05 	vldr	s15, [r3, #-20]	; 0xffffffec
             f1     = fi[0 ]-fi[1 ];
   241a0:	ee35 7ac6 	vsub.f32	s14, s11, s12
             f0     = fi[0 ]+fi[1 ];
   241a4:	ee75 5a86 	vadd.f32	s11, s11, s12
             f2     = fi[2 ]+fi[3 ];
   241a8:	ee36 6aa7 	vadd.f32	s12, s13, s15
             f3     = fi[2 ]-fi[3 ];
   241ac:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[2 ] = (f0-f2);  
   241b0:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[3 ] = (f1-f3);  
   241b4:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ] = (f0+f2);
   241b8:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[1 ] = (f1+f3);
   241bc:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[2 ] = (f0-f2);  
   241c0:	ed03 5a06 	vstr	s10, [r3, #-24]	; 0xffffffe8
             fi[3 ] = (f1-f3);  
   241c4:	ed43 6a05 	vstr	s13, [r3, #-20]	; 0xffffffec
             fi[0 ] = (f0+f2);
   241c8:	ed03 6a08 	vstr	s12, [r3, #-32]	; 0xffffffe0
             fi[1 ] = (f1+f3);
   241cc:	ed43 7a07 	vstr	s15, [r3, #-28]	; 0xffffffe4
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
   241d0:	429a      	cmp	r2, r3
   241d2:	d1dc      	bne.n	2418e <mayer_fht+0x486>
   241d4:	2300      	movs	r3, #0
   241d6:	9301      	str	r3, [sp, #4]
   241d8:	e635      	b.n	23e46 <mayer_fht+0x13e>
         TRIG_NEXT(k,c1,s1);
   241da:	2300      	movs	r3, #0
   241dc:	e7a0      	b.n	24120 <mayer_fht+0x418>
   241de:	bf00      	nop

000241e0 <mayer_realfft>:
  real[i] = (q-t)*0.5;  real[j] = (q+t)*0.5;
 }
}

void mayer_realfft(int n, REAL *real)
{
   241e0:	b538      	push	{r3, r4, r5, lr}
   241e2:	460c      	mov	r4, r1
   241e4:	4605      	mov	r5, r0
    REAL a,b;
 int i,j,k;
 mayer_fht(real,n);
   241e6:	4601      	mov	r1, r0
   241e8:	4620      	mov	r0, r4
   241ea:	f7ff fd8d 	bl	23d08 <mayer_fht>
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   241ee:	2d00      	cmp	r5, #0
   241f0:	bfb4      	ite	lt
   241f2:	1c6b      	addlt	r3, r5, #1
   241f4:	462b      	movge	r3, r5
   241f6:	105b      	asrs	r3, r3, #1
   241f8:	2b01      	cmp	r3, #1
   241fa:	dd18      	ble.n	2422e <mayer_realfft+0x4e>
  a = real[i];
  b = real[j];
  real[j] = (a-b)*0.5;
   241fc:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   24200:	eb04 0085 	add.w	r0, r4, r5, lsl #2
   24204:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   24208:	1d21      	adds	r1, r4, #4
  a = real[i];
   2420a:	edd1 7a00 	vldr	s15, [r1]
  b = real[j];
   2420e:	ed70 6a01 	vldmdb	r0!, {s13}
  real[j] = (a-b)*0.5;
   24212:	ee37 7ae6 	vsub.f32	s14, s15, s13
  real[i] = (a+b)*0.5;
   24216:	ee77 7aa6 	vadd.f32	s15, s15, s13
  real[j] = (a-b)*0.5;
   2421a:	ee27 7a06 	vmul.f32	s14, s14, s12
  real[i] = (a+b)*0.5;
   2421e:	ee67 7a86 	vmul.f32	s15, s15, s12
  real[j] = (a-b)*0.5;
   24222:	ed80 7a00 	vstr	s14, [r0]
  real[i] = (a+b)*0.5;
   24226:	ece1 7a01 	vstmia	r1!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   2422a:	428b      	cmp	r3, r1
   2422c:	d1ed      	bne.n	2420a <mayer_realfft+0x2a>
 }
}
   2422e:	bd38      	pop	{r3, r4, r5, pc}

00024230 <mayer_realifft>:

void mayer_realifft(int n, REAL *real)
{
    REAL a,b;
 int i,j,k;
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   24230:	2800      	cmp	r0, #0
{
   24232:	b410      	push	{r4}
   24234:	460c      	mov	r4, r1
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   24236:	bfb4      	ite	lt
   24238:	1c41      	addlt	r1, r0, #1
   2423a:	4601      	movge	r1, r0
   2423c:	1049      	asrs	r1, r1, #1
   2423e:	2901      	cmp	r1, #1
   24240:	dd12      	ble.n	24268 <mayer_realifft+0x38>
   24242:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   24246:	1d23      	adds	r3, r4, #4
   24248:	eb04 0280 	add.w	r2, r4, r0, lsl #2
  a = real[i];
   2424c:	edd3 7a00 	vldr	s15, [r3]
  b = real[j];
   24250:	ed32 7a01 	vldmdb	r2!, {s14}
  real[j] = (a-b);
   24254:	ee77 6ac7 	vsub.f32	s13, s15, s14
  real[i] = (a+b);
   24258:	ee77 7a87 	vadd.f32	s15, s15, s14
  real[j] = (a-b);
   2425c:	edc2 6a00 	vstr	s13, [r2]
  real[i] = (a+b);
   24260:	ece3 7a01 	vstmia	r3!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
   24264:	4299      	cmp	r1, r3
   24266:	d1f1      	bne.n	2424c <mayer_realifft+0x1c>
 }
 mayer_fht(real,n);
   24268:	4601      	mov	r1, r0
   2426a:	4620      	mov	r0, r4
}
   2426c:	f85d 4b04 	ldr.w	r4, [sp], #4
 mayer_fht(real,n);
   24270:	f7ff bd4a 	b.w	23d08 <mayer_fht>

00024274 <tEnvelopeFollower_init>:
//===========================================================================
/* Envelope Follower */
//===========================================================================

void    tEnvelopeFollower_init(tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff)
{
   24274:	b538      	push	{r3, r4, r5, lr}
    tEnvelopeFollower_initToPool(ef, attackThreshold, decayCoeff, &leaf.mempool);
}

void    tEnvelopeFollower_initToPool    (tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff, tMempool* const mp)
{
    _tMempool* m = *mp;
   24276:	4b0c      	ldr	r3, [pc, #48]	; (242a8 <tEnvelopeFollower_init+0x34>)
{
   24278:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   2427a:	2010      	movs	r0, #16
{
   2427c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24280:	699c      	ldr	r4, [r3, #24]
{
   24282:	eef0 8a40 	vmov.f32	s17, s0
   24286:	eeb0 8a60 	vmov.f32	s16, s1
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   2428a:	4621      	mov	r1, r4
   2428c:	f005 fcfc 	bl	29c88 <mpool_alloc>
    e->mempool = m;
    
    e->y = 0.0f;
   24290:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   24292:	6028      	str	r0, [r5, #0]
    e->mempool = m;
   24294:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
   24296:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
   2429a:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
   2429e:	6043      	str	r3, [r0, #4]
}
   242a0:	ecbd 8b02 	vpop	{d8}
   242a4:	bd38      	pop	{r3, r4, r5, pc}
   242a6:	bf00      	nop
   242a8:	020fc0a8 	.word	0x020fc0a8

000242ac <tEnvelopeFollower_initToPool>:
{
   242ac:	b538      	push	{r3, r4, r5, lr}
   242ae:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   242b2:	680c      	ldr	r4, [r1, #0]
{
   242b4:	eef0 8a40 	vmov.f32	s17, s0
   242b8:	eeb0 8a60 	vmov.f32	s16, s1
   242bc:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   242be:	4621      	mov	r1, r4
   242c0:	2010      	movs	r0, #16
   242c2:	f005 fce1 	bl	29c88 <mpool_alloc>
    e->y = 0.0f;
   242c6:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
   242c8:	6028      	str	r0, [r5, #0]
    e->mempool = m;
   242ca:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
   242cc:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
   242d0:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
   242d4:	6043      	str	r3, [r0, #4]
}
   242d6:	ecbd 8b02 	vpop	{d8}
   242da:	bd38      	pop	{r3, r4, r5, pc}

000242dc <tEnvelopeFollower_free>:

void    tEnvelopeFollower_free  (tEnvelopeFollower* const ef)
{
    _tEnvelopeFollower* e = *ef;
   242dc:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)e, e->mempool);
   242de:	6801      	ldr	r1, [r0, #0]
   242e0:	f005 bd7a 	b.w	29dd8 <mpool_free>

000242e4 <tEnvelopeFollower_tick>:
}

float   tEnvelopeFollower_tick(tEnvelopeFollower* const ef, float x)
{
    _tEnvelopeFollower* e = *ef;
   242e4:	6803      	ldr	r3, [r0, #0]
   242e6:	eeb0 0ac0 	vabs.f32	s0, s0
    
    if (x < 0.0f ) x = -x;  /* Absolute value. */
    
    if ((x >= e->y) && (x > e->a_thresh)) e->y = x;                      /* If we hit a peak, ride the peak to the top. */
   242ea:	edd3 7a01 	vldr	s15, [r3, #4]
   242ee:	eef4 7ac0 	vcmpe.f32	s15, s0
   242f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   242f6:	d814      	bhi.n	24322 <tEnvelopeFollower_tick+0x3e>
   242f8:	ed93 7a02 	vldr	s14, [r3, #8]
   242fc:	eeb4 7ac0 	vcmpe.f32	s14, s0
   24300:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24304:	d50d      	bpl.n	24322 <tEnvelopeFollower_tick+0x3e>
    //ef->y = envelope_pow[(uint16_t)(ef->y * (float)UINT16_MAX)] * ef->d_coeff; //not quite the right behavior - too much loss of precision?
    //ef->y = powf(ef->y, 1.000009f) * ef->d_coeff;  // too expensive
    
#ifdef NO_DENORMAL_CHECK
#else
    if( e->y < VSF)   e->y = 0.0f;
   24306:	eddf 7a0e 	vldr	s15, [pc, #56]	; 24340 <tEnvelopeFollower_tick+0x5c>
   2430a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2430e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24312:	d511      	bpl.n	24338 <tEnvelopeFollower_tick+0x54>
   24314:	eddf 7a0b 	vldr	s15, [pc, #44]	; 24344 <tEnvelopeFollower_tick+0x60>
   24318:	eeb0 0a67 	vmov.f32	s0, s15
   2431c:	edc3 7a01 	vstr	s15, [r3, #4]
#endif
    return e->y;
}
   24320:	4770      	bx	lr
    else                                    e->y = e->y * e->d_coeff;    /* Else, exponential decay of output. */
   24322:	ed93 0a03 	vldr	s0, [r3, #12]
   24326:	ee27 0a80 	vmul.f32	s0, s15, s0
    if( e->y < VSF)   e->y = 0.0f;
   2432a:	eddf 7a05 	vldr	s15, [pc, #20]	; 24340 <tEnvelopeFollower_tick+0x5c>
   2432e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   24332:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24336:	d4ed      	bmi.n	24314 <tEnvelopeFollower_tick+0x30>
   24338:	ed83 0a01 	vstr	s0, [r3, #4]
   2433c:	4770      	bx	lr
   2433e:	bf00      	nop
   24340:	006ce3ee 	.word	0x006ce3ee
   24344:	00000000 	.word	0x00000000

00024348 <tZeroCrossing_initToPool>:
{
    tZeroCrossing_initToPool   (zc, maxWindowSize, &leaf.mempool);
}

void    tZeroCrossing_initToPool   (tZeroCrossing* const zc, int maxWindowSize, tMempool* const mp)
{
   24348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2434a:	6816      	ldr	r6, [r2, #0]
{
   2434c:	460d      	mov	r5, r1
   2434e:	4607      	mov	r7, r0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   24350:	2024      	movs	r0, #36	; 0x24
   24352:	4631      	mov	r1, r6
   24354:	f005 fc98 	bl	29c88 <mpool_alloc>
    z->mempool = m;

    z->count = 0;
    z->maxWindowSize = maxWindowSize;
    z->currentWindowSize = maxWindowSize;
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   24358:	ee07 5a90 	vmov	s15, r5
   2435c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   24360:	4604      	mov	r4, r0
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   24362:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    z->count = 0;
   24366:	2300      	movs	r3, #0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
   24368:	6038      	str	r0, [r7, #0]
    z->position = 0;
    z->prevPosition = maxWindowSize;
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   2436a:	4631      	mov	r1, r6
    z->mempool = m;
   2436c:	6006      	str	r6, [r0, #0]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   2436e:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z->maxWindowSize = maxWindowSize;
   24372:	6085      	str	r5, [r0, #8]
    z->count = 0;
   24374:	6063      	str	r3, [r4, #4]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   24376:	00a8      	lsls	r0, r5, #2
    z->position = 0;
   24378:	6223      	str	r3, [r4, #32]
    z->currentWindowSize = maxWindowSize;
   2437a:	60e5      	str	r5, [r4, #12]
    z->prevPosition = maxWindowSize;
   2437c:	61e5      	str	r5, [r4, #28]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
   2437e:	edc4 7a04 	vstr	s15, [r4, #16]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   24382:	f005 fcd7 	bl	29d34 <mpool_calloc>
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
   24386:	4631      	mov	r1, r6
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
   24388:	6160      	str	r0, [r4, #20]
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
   2438a:	0068      	lsls	r0, r5, #1
   2438c:	f005 fcd2 	bl	29d34 <mpool_calloc>
   24390:	61a0      	str	r0, [r4, #24]
}
   24392:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00024394 <tZeroCrossing_free>:

void    tZeroCrossing_free (tZeroCrossing* const zc)
{
   24394:	b510      	push	{r4, lr}
    _tZeroCrossing* z = *zc;
   24396:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)z->inBuffer, z->mempool);
   24398:	6821      	ldr	r1, [r4, #0]
   2439a:	6960      	ldr	r0, [r4, #20]
   2439c:	f005 fd1c 	bl	29dd8 <mpool_free>
    mpool_free((char*)z->countBuffer, z->mempool);
   243a0:	6821      	ldr	r1, [r4, #0]
   243a2:	69a0      	ldr	r0, [r4, #24]
   243a4:	f005 fd18 	bl	29dd8 <mpool_free>
    mpool_free((char*)z, z->mempool);
   243a8:	6821      	ldr	r1, [r4, #0]
   243aa:	4620      	mov	r0, r4
}
   243ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)z, z->mempool);
   243b0:	f005 bd12 	b.w	29dd8 <mpool_free>

000243b4 <tZeroCrossing_tick>:

//returns proportion of zero crossings within window size (0.0 would be none in window, 1.0 would be all zero crossings)
float   tZeroCrossing_tick         (tZeroCrossing* const zc, float input)
{
   243b4:	b430      	push	{r4, r5}
    _tZeroCrossing* z = *zc;
   243b6:	6803      	ldr	r3, [r0, #0]

    z->inBuffer[z->position] = input;
   243b8:	6a19      	ldr	r1, [r3, #32]
   243ba:	695a      	ldr	r2, [r3, #20]
   243bc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   243c0:	ed82 0a00 	vstr	s0, [r2]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   243c4:	6a18      	ldr	r0, [r3, #32]
    float output = 0.0f;

    //add new value to count
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   243c6:	695a      	ldr	r2, [r3, #20]
   243c8:	69dc      	ldr	r4, [r3, #28]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   243ca:	1c45      	adds	r5, r0, #1
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   243cc:	eb02 0180 	add.w	r1, r2, r0, lsl #2
   243d0:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   243d4:	68dc      	ldr	r4, [r3, #12]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   243d6:	ed91 7a00 	vldr	s14, [r1]
   243da:	edd2 7a00 	vldr	s15, [r2]
    {
        //zero crossing happened, add it to the count array
        z->countBuffer[z->position] = 1;
   243de:	699a      	ldr	r2, [r3, #24]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   243e0:	ee67 7a87 	vmul.f32	s15, s15, s14
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   243e4:	fb95 f1f4 	sdiv	r1, r5, r4
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   243e8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
   243ec:	fb04 5111 	mls	r1, r4, r1, r5
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
   243f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   243f4:	d41c      	bmi.n	24430 <tZeroCrossing_tick+0x7c>
        z->count++;
    }
    else
    {
        z->countBuffer[z->position] = 0;
   243f6:	2400      	movs	r4, #0
   243f8:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
   243fc:	685a      	ldr	r2, [r3, #4]
    }

    //remove oldest value from count
    if (z->countBuffer[futurePosition] > 0)
   243fe:	6998      	ldr	r0, [r3, #24]
   24400:	f830 0011 	ldrh.w	r0, [r0, r1, lsl #1]
   24404:	b110      	cbz	r0, 2440c <tZeroCrossing_tick+0x58>
    {
        z->count--;
        if (z->count < 0)
   24406:	3a01      	subs	r2, #1
   24408:	d40d      	bmi.n	24426 <tZeroCrossing_tick+0x72>
        z->count--;
   2440a:	605a      	str	r2, [r3, #4]
   2440c:	ee07 2a90 	vmov	s15, r2
   24410:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        {
            z->count = 0;
        }
    }

    z->prevPosition = z->position;
   24414:	6a1a      	ldr	r2, [r3, #32]
    z->position = futurePosition;

    output = z->count * z->invCurrentWindowSize;
   24416:	ed93 0a04 	vldr	s0, [r3, #16]
    z->position = futurePosition;
   2441a:	e9c3 2107 	strd	r2, r1, [r3, #28]

    return output;
}
   2441e:	ee27 0a80 	vmul.f32	s0, s15, s0
   24422:	bc30      	pop	{r4, r5}
   24424:	4770      	bx	lr
            z->count = 0;
   24426:	2200      	movs	r2, #0
   24428:	eddf 7a05 	vldr	s15, [pc, #20]	; 24440 <tZeroCrossing_tick+0x8c>
   2442c:	605a      	str	r2, [r3, #4]
   2442e:	e7f1      	b.n	24414 <tZeroCrossing_tick+0x60>
        z->countBuffer[z->position] = 1;
   24430:	2401      	movs	r4, #1
   24432:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
        z->count++;
   24436:	685a      	ldr	r2, [r3, #4]
   24438:	4422      	add	r2, r4
   2443a:	605a      	str	r2, [r3, #4]
   2443c:	e7df      	b.n	243fe <tZeroCrossing_tick+0x4a>
   2443e:	bf00      	nop
   24440:	00000000 	.word	0x00000000

00024444 <tPowerFollower_initToPool>:
{
    tPowerFollower_initToPool(pf, factor, &leaf.mempool);
}

void    tPowerFollower_initToPool   (tPowerFollower* const pf, float factor, tMempool* const mp)
{
   24444:	b538      	push	{r3, r4, r5, lr}
   24446:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2444a:	680c      	ldr	r4, [r1, #0]
{
   2444c:	4605      	mov	r5, r0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   2444e:	2010      	movs	r0, #16
{
   24450:	eeb0 8a40 	vmov.f32	s16, s0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   24454:	4621      	mov	r1, r4
   24456:	f005 fc17 	bl	29c88 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
    p->factor=factor;
    p->oneminusfactor=1.0f-factor;
   2445a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    p->curr=0.0f;
   2445e:	2300      	movs	r3, #0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
   24460:	6028      	str	r0, [r5, #0]
    p->mempool = m;
   24462:	6004      	str	r4, [r0, #0]
    p->oneminusfactor=1.0f-factor;
   24464:	ee77 7ac8 	vsub.f32	s15, s15, s16
    p->factor=factor;
   24468:	ed80 8a01 	vstr	s16, [r0, #4]
    p->curr=0.0f;
   2446c:	60c3      	str	r3, [r0, #12]
    p->oneminusfactor=1.0f-factor;
   2446e:	edc0 7a02 	vstr	s15, [r0, #8]
}
   24472:	ecbd 8b02 	vpop	{d8}
   24476:	bd38      	pop	{r3, r4, r5, pc}

00024478 <tPowerFollower_free>:

void    tPowerFollower_free (tPowerFollower* const pf)
{
    _tPowerFollower* p = *pf;
   24478:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)p, p->mempool);
   2447a:	6801      	ldr	r1, [r0, #0]
   2447c:	f005 bcac 	b.w	29dd8 <mpool_free>

00024480 <tPowerFollower_tick>:
    return 0;
}

float   tPowerFollower_tick(tPowerFollower* const pf, float input)
{
    _tPowerFollower* p = *pf;
   24480:	6803      	ldr	r3, [r0, #0]
    p->curr = p->factor*input*input+p->oneminusfactor*p->curr;
   24482:	ee20 7a00 	vmul.f32	s14, s0, s0
   24486:	edd3 7a02 	vldr	s15, [r3, #8]
   2448a:	ed93 0a03 	vldr	s0, [r3, #12]
   2448e:	edd3 6a01 	vldr	s13, [r3, #4]
   24492:	ee27 0a80 	vmul.f32	s0, s15, s0
   24496:	eea6 0a87 	vfma.f32	s0, s13, s14
   2449a:	ed83 0a03 	vstr	s0, [r3, #12]
    return p->curr;
}
   2449e:	4770      	bx	lr

000244a0 <tEnvPD_initToPool>:
{
    tEnvPD_initToPool(xpd, ws, hs, bs, &leaf.mempool);
}

void    tEnvPD_initToPool       (tEnvPD* const xpd, int ws, int hs, int bs, tMempool* const mp)
{
   244a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   244a4:	ed2d 8b04 	vpush	{d8-d9}
   244a8:	b083      	sub	sp, #12
   244aa:	4688      	mov	r8, r1
   244ac:	4605      	mov	r5, r0
    _tMempool* m = *mp;
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   244ae:	f241 109c 	movw	r0, #4508	; 0x119c
{
   244b2:	9c10      	ldr	r4, [sp, #64]	; 0x40
   244b4:	4616      	mov	r6, r2
   244b6:	461f      	mov	r7, r3
    _tMempool* m = *mp;
   244b8:	6824      	ldr	r4, [r4, #0]
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   244ba:	4621      	mov	r1, r4
   244bc:	f005 fc3a 	bl	29d34 <mpool_calloc>
    
    int period = hs, npoints = ws;
    
    int i;
    
    if (npoints < 1) npoints = 1024;
   244c0:	f1b8 0f00 	cmp.w	r8, #0
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
   244c4:	6028      	str	r0, [r5, #0]
   244c6:	4682      	mov	sl, r0
    x->mempool = m;
   244c8:	6004      	str	r4, [r0, #0]
    if (npoints < 1) npoints = 1024;
   244ca:	f340 8081 	ble.w	245d0 <tEnvPD_initToPool+0x130>
   244ce:	ee07 8a90 	vmov	s15, r8
   244d2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   244d6:	f108 033f 	add.w	r3, r8, #63	; 0x3f
   244da:	ea4f 1168 	mov.w	r1, r8, asr #5
   244de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   244e2:	fa1f f288 	uxth.w	r2, r8
   244e6:	9301      	str	r3, [sp, #4]
   244e8:	ee87 8a27 	vdiv.f32	s16, s14, s15
    if (period < 1) period = npoints/2;
   244ec:	2e00      	cmp	r6, #0
    if (period < npoints / MAXOVERLAP + 1)
        period = npoints / MAXOVERLAP + 1;
    
    x->x_npoints = npoints;
    x->x_phase = 0;
    x->x_period = period;
   244ee:	f241 1506 	movw	r5, #4358	; 0x1106
    
    x->windowSize = npoints;
    x->hopSize = period;
    x->blockSize = bs;
   244f2:	f241 1498 	movw	r4, #4504	; 0x1198
    x->x_npoints = npoints;
   244f6:	f241 100a 	movw	r0, #4362	; 0x110a
    if (period < 1) period = npoints/2;
   244fa:	bfd8      	it	le
   244fc:	ea4f 0668 	movle.w	r6, r8, asr #1
   24500:	ed9f 9a38 	vldr	s18, [pc, #224]	; 245e4 <tEnvPD_initToPool+0x144>
    x->blockSize = bs;
   24504:	b2bf      	uxth	r7, r7
    if (period < npoints / MAXOVERLAP + 1)
   24506:	428e      	cmp	r6, r1
   24508:	ea4f 0b88 	mov.w	fp, r8, lsl #2
        period = npoints / MAXOVERLAP + 1;
   2450c:	bfd8      	it	le
   2450e:	1c4e      	addle	r6, r1, #1
    x->hopSize = period;
   24510:	f241 1196 	movw	r1, #4502	; 0x1196
    x->x_period = period;
   24514:	b2b6      	uxth	r6, r6
   24516:	f82a 6005 	strh.w	r6, [sl, r5]
    x->x_phase = 0;
   2451a:	f241 1504 	movw	r5, #4356	; 0x1104
    x->hopSize = period;
   2451e:	f82a 6001 	strh.w	r6, [sl, r1]
    x->x_phase = 0;
   24522:	2100      	movs	r1, #0
    x->blockSize = bs;
   24524:	f82a 7004 	strh.w	r7, [sl, r4]
    x->windowSize = npoints;
   24528:	f241 1494 	movw	r4, #4500	; 0x1194
    x->x_npoints = npoints;
   2452c:	f82a 2000 	strh.w	r2, [sl, r0]
   24530:	f241 1010 	movw	r0, #4368	; 0x1110
    x->x_phase = 0;
   24534:	f82a 1005 	strh.w	r1, [sl, r5]
    
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
    for (i = 0; i < npoints; i++)
   24538:	460d      	mov	r5, r1
    x->windowSize = npoints;
   2453a:	f82a 2004 	strh.w	r2, [sl, r4]
   2453e:	4450      	add	r0, sl
   24540:	2280      	movs	r2, #128	; 0x80
   24542:	f10a 0404 	add.w	r4, sl, #4
   24546:	f008 fa7c 	bl	2ca42 <memset>
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
   2454a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2454e:	eb04 090b 	add.w	r9, r4, fp
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
   24552:	eef0 8a40 	vmov.f32	s17, s0
   24556:	e001      	b.n	2455c <tEnvPD_initToPool+0xbc>
   24558:	f008 fb9c 	bl	2cc94 <cosf>
    for (i = 0; i < npoints; i++)
   2455c:	3501      	adds	r5, #1
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
   2455e:	ee38 0ac0 	vsub.f32	s0, s17, s0
   24562:	ee07 5a90 	vmov	s15, r5
   24566:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2456a:	ee60 7a08 	vmul.f32	s15, s0, s16
   2456e:	ee27 0a09 	vmul.f32	s0, s14, s18
   24572:	ece4 7a01 	vstmia	r4!, {s15}
    for (i = 0; i < npoints; i++)
   24576:	45a1      	cmp	r9, r4
   24578:	ee20 0a08 	vmul.f32	s0, s0, s16
   2457c:	d1ec      	bne.n	24558 <tEnvPD_initToPool+0xb8>
    for (; i < npoints+INITVSTAKEN; i++) x->buf[i] = 0;
   2457e:	9b01      	ldr	r3, [sp, #4]
   24580:	4598      	cmp	r8, r3
   24582:	dc09      	bgt.n	24598 <tEnvPD_initToPool+0xf8>
   24584:	3301      	adds	r3, #1
   24586:	f10b 0004 	add.w	r0, fp, #4
   2458a:	2100      	movs	r1, #0
   2458c:	eba3 0208 	sub.w	r2, r3, r8
   24590:	4450      	add	r0, sl
   24592:	0092      	lsls	r2, r2, #2
   24594:	f008 fa55 	bl	2ca42 <memset>
    
    x->x_f = 0;
   24598:	f241 1190 	movw	r1, #4496	; 0x1190
   2459c:	2500      	movs	r5, #0
    
    x->x_allocforvs = INITVSTAKEN;
   2459e:	f241 109a 	movw	r0, #4506	; 0x119a
   245a2:	2440      	movs	r4, #64	; 0x40
    x->x_f = 0;
   245a4:	4451      	add	r1, sl
    
    // ~ ~ ~ dsp ~ ~ ~
    if (x->x_period % x->blockSize)
   245a6:	fbb6 f2f7 	udiv	r2, r6, r7
   245aa:	fb07 6212 	mls	r2, r7, r2, r6
    x->x_f = 0;
   245ae:	600d      	str	r5, [r1, #0]
    if (x->x_period % x->blockSize)
   245b0:	b292      	uxth	r2, r2
    x->x_allocforvs = INITVSTAKEN;
   245b2:	f82a 4000 	strh.w	r4, [sl, r0]
    if (x->x_period % x->blockSize)
   245b6:	b112      	cbz	r2, 245be <tEnvPD_initToPool+0x11e>
    {
        x->x_realperiod = x->x_period + x->blockSize - (x->x_period % x->blockSize);
   245b8:	443e      	add	r6, r7
   245ba:	1ab2      	subs	r2, r6, r2
   245bc:	b296      	uxth	r6, r2
   245be:	f241 1208 	movw	r2, #4360	; 0x1108
   245c2:	f82a 6002 	strh.w	r6, [sl, r2]
    else
    {
        x->x_realperiod = x->x_period;
    }
    // ~ ~ ~ ~ ~ ~ ~ ~
}
   245c6:	b003      	add	sp, #12
   245c8:	ecbd 8b04 	vpop	{d8-d9}
   245cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   245d0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   245d4:	f240 433f 	movw	r3, #1087	; 0x43f
   245d8:	ed9f 8a03 	vldr	s16, [pc, #12]	; 245e8 <tEnvPD_initToPool+0x148>
   245dc:	2120      	movs	r1, #32
   245de:	9301      	str	r3, [sp, #4]
    if (npoints < 1) npoints = 1024;
   245e0:	4690      	mov	r8, r2
   245e2:	e783      	b.n	244ec <tEnvPD_initToPool+0x4c>
   245e4:	40c90fdb 	.word	0x40c90fdb
   245e8:	3a800000 	.word	0x3a800000

000245ec <tEnvPD_tick>:
}

float tEnvPD_tick (tEnvPD* const xpd)
{
    _tEnvPD* x = *xpd;
    return powtodb(x->x_result);
   245ec:	6802      	ldr	r2, [r0, #0]
   245ee:	f241 130c 	movw	r3, #4364	; 0x110c
   245f2:	4413      	add	r3, r2
   245f4:	ed93 0a00 	vldr	s0, [r3]
   245f8:	f005 bada 	b.w	29bb0 <powtodb>

000245fc <tSNAC_initToPool>:
{
    tSNAC_initToPool(snac, overlaparg, &leaf.mempool);
}

void    tSNAC_initToPool    (tSNAC* const snac, int overlaparg, tMempool* const mp)
{
   245fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24600:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   24604:	6815      	ldr	r5, [r2, #0]
{
   24606:	4680      	mov	r8, r0
   24608:	460f      	mov	r7, r1
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   2460a:	202c      	movs	r0, #44	; 0x2c
   2460c:	4629      	mov	r1, r5
    s->mempool = m;
    
    s->biasfactor = DEFBIAS;
    s->timeindex = 0;
    s->periodindex = 0;
    s->periodlength = 0.;
   2460e:	ed9f 8a40 	vldr	s16, [pc, #256]	; 24710 <tSNAC_initToPool+0x114>
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   24612:	f005 fb39 	bl	29c88 <mpool_alloc>
    s->fidelity = 0.;
    s->minrms = DEFMINRMS;
   24616:	4a3f      	ldr	r2, [pc, #252]	; (24714 <tSNAC_initToPool+0x118>)
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   24618:	4604      	mov	r4, r0
    s->timeindex = 0;
   2461a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    s->biasfactor = DEFBIAS;
   2461e:	483e      	ldr	r0, [pc, #248]	; (24718 <tSNAC_initToPool+0x11c>)
    s->periodindex = 0;
   24620:	2100      	movs	r1, #0
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
   24622:	f8c8 4000 	str.w	r4, [r8]
    s->minrms = DEFMINRMS;
   24626:	62a2      	str	r2, [r4, #40]	; 0x28
    s->timeindex = 0;
   24628:	6163      	str	r3, [r4, #20]
    s->biasfactor = DEFBIAS;
   2462a:	6260      	str	r0, [r4, #36]	; 0x24
    s->framesize = SNAC_FRAME_SIZE;

    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   2462c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    s->periodindex = 0;
   24630:	8361      	strh	r1, [r4, #26]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   24632:	4629      	mov	r1, r5
    s->mempool = m;
   24634:	6025      	str	r5, [r4, #0]
    s->periodlength = 0.;
   24636:	ed84 8a07 	vstr	s16, [r4, #28]
    s->fidelity = 0.;
   2463a:	ed84 8a08 	vstr	s16, [r4, #32]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   2463e:	f005 fb79 	bl	29d34 <mpool_calloc>
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   24642:	4629      	mov	r1, r5
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   24644:	6060      	str	r0, [r4, #4]
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   24646:	f44f 5000 	mov.w	r0, #8192	; 0x2000
   2464a:	f005 fb73 	bl	29d34 <mpool_calloc>
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   2464e:	4629      	mov	r1, r5
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
   24650:	60a0      	str	r0, [r4, #8]
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   24652:	f44f 6000 	mov.w	r0, #2048	; 0x800
   24656:	f005 fb6d 	bl	29d34 <mpool_calloc>
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   2465a:	4629      	mov	r1, r5
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
   2465c:	60e0      	str	r0, [r4, #12]
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
   2465e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   24662:	f005 fb67 	bl	29d34 <mpool_calloc>
   24666:	6120      	str	r0, [r4, #16]
    
    snac_biasbuf(snac);
   24668:	f8d8 4000 	ldr.w	r4, [r8]
static void snac_biasbuf(tSNAC* const snac)
{
    _tSNAC* s = *snac;
    
    int n;
    int maxperiod = (int)(s->framesize * (float)SEEK);
   2466c:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 2471c <tSNAC_initToPool+0x120>
   24670:	8ae3      	ldrh	r3, [r4, #22]
   24672:	ee07 3a90 	vmov	s15, r3
   24676:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2467a:	ee67 7a87 	vmul.f32	s15, s15, s14
   2467e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   24682:	ee17 6a90 	vmov	r6, s15
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
   24686:	1f33      	subs	r3, r6, #4
   24688:	ee00 3a10 	vmov	s0, r3
   2468c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   24690:	f008 fbc6 	bl	2ce20 <logf>
   24694:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    for(n=0; n<5; n++)    // periods < 5 samples can't be tracked
    {
        biasbuf[n] = 0.0f;
    }
    
    for(n=5; n<maxperiod; n++)
   24698:	2e05      	cmp	r6, #5
    float *biasbuf = s->biasbuf;
   2469a:	6924      	ldr	r4, [r4, #16]
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
   2469c:	eec7 8a80 	vdiv.f32	s17, s15, s0
        biasbuf[n] = 0.0f;
   246a0:	ed84 8a00 	vstr	s16, [r4]
   246a4:	ed84 8a01 	vstr	s16, [r4, #4]
   246a8:	ed84 8a02 	vstr	s16, [r4, #8]
   246ac:	ed84 8a03 	vstr	s16, [r4, #12]
   246b0:	ed84 8a04 	vstr	s16, [r4, #16]
    for(n=5; n<maxperiod; n++)
   246b4:	dd17      	ble.n	246e6 <tSNAC_initToPool+0xea>
   246b6:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    {
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
   246ba:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   246be:	3414      	adds	r4, #20
    for(n=5; n<maxperiod; n++)
   246c0:	eeb0 0a48 	vmov.f32	s0, s16
   246c4:	2502      	movs	r5, #2
   246c6:	e001      	b.n	246cc <tSNAC_initToPool+0xd0>
   246c8:	f008 fbaa 	bl	2ce20 <logf>
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
   246cc:	eef0 7a49 	vmov.f32	s15, s18
   246d0:	ee07 5a10 	vmov	s14, r5
   246d4:	3501      	adds	r5, #1
   246d6:	eee0 7a68 	vfms.f32	s15, s0, s17
   246da:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
   246de:	ece4 7a01 	vstmia	r4!, {s15}
    for(n=5; n<maxperiod; n++)
   246e2:	42b4      	cmp	r4, r6
   246e4:	d1f0      	bne.n	246c8 <tSNAC_initToPool+0xcc>
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   246e6:	2f08      	cmp	r7, #8
    _tSNAC* s = *snac;
   246e8:	f8d8 2000 	ldr.w	r2, [r8]
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   246ec:	d905      	bls.n	246fa <tSNAC_initToPool+0xfe>
   246ee:	2701      	movs	r7, #1
    s->overlap = lap;
   246f0:	8317      	strh	r7, [r2, #24]
}
   246f2:	ecbd 8b04 	vpop	{d8-d9}
   246f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
   246fa:	f44f 738b 	mov.w	r3, #278	; 0x116
   246fe:	40fb      	lsrs	r3, r7
   24700:	07db      	lsls	r3, r3, #31
   24702:	d5f4      	bpl.n	246ee <tSNAC_initToPool+0xf2>
   24704:	b2bf      	uxth	r7, r7
    s->overlap = lap;
   24706:	8317      	strh	r7, [r2, #24]
}
   24708:	ecbd 8b04 	vpop	{d8-d9}
   2470c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   24710:	00000000 	.word	0x00000000
   24714:	3b449ba6 	.word	0x3b449ba6
   24718:	3e4ccccd 	.word	0x3e4ccccd
   2471c:	3f59999a 	.word	0x3f59999a

00024720 <tSNAC_ioSamples>:
{
   24720:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24724:	ed2d 8b02 	vpush	{d8}
   24728:	b08b      	sub	sp, #44	; 0x2c
   2472a:	460d      	mov	r5, r1
   2472c:	9204      	str	r2, [sp, #16]
    _tSNAC* s = *snac;
   2472e:	6802      	ldr	r2, [r0, #0]
{
   24730:	9002      	str	r0, [sp, #8]
   24732:	9301      	str	r3, [sp, #4]
    int mask = s->framesize - 1;
   24734:	8ad0      	ldrh	r0, [r2, #22]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   24736:	8b13      	ldrh	r3, [r2, #24]
    int timeindex = s->timeindex;
   24738:	8a94      	ldrh	r4, [r2, #20]
    int mask = s->framesize - 1;
   2473a:	1e46      	subs	r6, r0, #1
    _tSNAC* s = *snac;
   2473c:	9203      	str	r2, [sp, #12]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   2473e:	fbb0 f3f3 	udiv	r3, r0, r3
   24742:	3b01      	subs	r3, #1
   24744:	4023      	ands	r3, r4
    float *processbuf = s->processbuf;
   24746:	e9d2 7801 	ldrd	r7, r8, [r2, #4]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
   2474a:	9305      	str	r3, [sp, #20]
   2474c:	d019      	beq.n	24782 <tSNAC_ioSamples+0x62>
    while(size--)
   2474e:	9b01      	ldr	r3, [sp, #4]
   24750:	b183      	cbz	r3, 24774 <tSNAC_ioSamples+0x54>
   24752:	9a04      	ldr	r2, [sp, #16]
   24754:	eb05 0c83 	add.w	ip, r5, r3, lsl #2
        inputbuf[timeindex] = *in++;
   24758:	00a3      	lsls	r3, r4, #2
   2475a:	f855 0b04 	ldr.w	r0, [r5], #4
        out[outindex++] = processbuf[timeindex++];
   2475e:	3401      	adds	r4, #1
        inputbuf[timeindex] = *in++;
   24760:	18f9      	adds	r1, r7, r3
        out[outindex++] = processbuf[timeindex++];
   24762:	4443      	add	r3, r8
    while(size--)
   24764:	4565      	cmp	r5, ip
        timeindex &= mask;
   24766:	ea04 0406 	and.w	r4, r4, r6
        inputbuf[timeindex] = *in++;
   2476a:	6008      	str	r0, [r1, #0]
        out[outindex++] = processbuf[timeindex++];
   2476c:	681b      	ldr	r3, [r3, #0]
   2476e:	f842 3b04 	str.w	r3, [r2], #4
    while(size--)
   24772:	d1f1      	bne.n	24758 <tSNAC_ioSamples+0x38>
    s->timeindex = timeindex;
   24774:	9b03      	ldr	r3, [sp, #12]
   24776:	829c      	strh	r4, [r3, #20]
}
   24778:	b00b      	add	sp, #44	; 0x2c
   2477a:	ecbd 8b02 	vpop	{d8}
   2477e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    float norm = 1. / sqrt((float)(framesize * 2));
   24782:	ea4f 0e40 	mov.w	lr, r0, lsl #1
   24786:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
   2478a:	ee07 ea90 	vmov	s15, lr
   2478e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   24792:	eeb1 6bc7 	vsqrt.f64	d6, d7
   24796:	ee85 7b06 	vdiv.f64	d7, d5, d6
   2479a:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    for(n=0; n<framesize; n++)
   2479e:	b178      	cbz	r0, 247c0 <tSNAC_ioSamples+0xa0>
   247a0:	4642      	mov	r2, r8
   247a2:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
    int timeindex = s->timeindex;
   247a6:	4623      	mov	r3, r4
        processbuf[n] = inputbuf[tindex] * norm;
   247a8:	eb07 0183 	add.w	r1, r7, r3, lsl #2
        tindex++;
   247ac:	3301      	adds	r3, #1
        processbuf[n] = inputbuf[tindex] * norm;
   247ae:	edd1 7a00 	vldr	s15, [r1]
        tindex &= mask;
   247b2:	4033      	ands	r3, r6
        processbuf[n] = inputbuf[tindex] * norm;
   247b4:	ee67 7a87 	vmul.f32	s15, s15, s14
   247b8:	ece2 7a01 	vstmia	r2!, {s15}
    for(n=0; n<framesize; n++)
   247bc:	4594      	cmp	ip, r2
   247be:	d1f3      	bne.n	247a8 <tSNAC_ioSamples+0x88>
    for(n=framesize; n<(framesize<<1); n++) processbuf[n] = 0.;
   247c0:	4570      	cmp	r0, lr
   247c2:	da07      	bge.n	247d4 <tSNAC_ioSamples+0xb4>
   247c4:	ebae 0200 	sub.w	r2, lr, r0
   247c8:	2100      	movs	r1, #0
   247ca:	eb08 0080 	add.w	r0, r8, r0, lsl #2
   247ce:	0092      	lsls	r2, r2, #2
   247d0:	f008 f937 	bl	2ca42 <memset>
    snac_autocorrelation(snac);
   247d4:	9b02      	ldr	r3, [sp, #8]
   247d6:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
   247d8:	f8b3 9016 	ldrh.w	r9, [r3, #22]
    float *processbuf = s->processbuf;
   247dc:	f8d3 a008 	ldr.w	sl, [r3, #8]
    int fftsize = framesize * 2;
   247e0:	ea4f 0b49 	mov.w	fp, r9, lsl #1
    float *spectrumbuf = s->spectrumbuf;
   247e4:	68db      	ldr	r3, [r3, #12]
    REALFFT(fftsize, processbuf);
   247e6:	4651      	mov	r1, sl
   247e8:	4658      	mov	r0, fp
    float *spectrumbuf = s->spectrumbuf;
   247ea:	9306      	str	r3, [sp, #24]
    REALFFT(fftsize, processbuf);
   247ec:	f7ff fcf8 	bl	241e0 <mayer_realfft>
    processbuf[0] *= processbuf[0];                      // DC
   247f0:	edda 7a00 	vldr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
   247f4:	eb0a 0189 	add.w	r1, sl, r9, lsl #2
    for(n=1; n<framesize; n++)
   247f8:	f1b9 0f01 	cmp.w	r9, #1
    processbuf[0] *= processbuf[0];                      // DC
   247fc:	ee67 7aa7 	vmul.f32	s15, s15, s15
   24800:	edca 7a00 	vstr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
   24804:	edd1 7a00 	vldr	s15, [r1]
   24808:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2480c:	edc1 7a00 	vstr	s15, [r1]
    for(n=1; n<framesize; n++)
   24810:	dd11      	ble.n	24836 <tSNAC_ioSamples+0x116>
   24812:	f10a 0304 	add.w	r3, sl, #4
   24816:	eb0a 02c9 	add.w	r2, sl, r9, lsl #3
        processbuf[fftsize-n] = 0.;
   2481a:	2000      	movs	r0, #0
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
   2481c:	ed72 7a01 	vldmdb	r2!, {s15}
        processbuf[n] = processbuf[n] * processbuf[n]
   24820:	ed93 7a00 	vldr	s14, [r3]
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
   24824:	ee67 7aa7 	vmul.f32	s15, s15, s15
   24828:	eee7 7a07 	vfma.f32	s15, s14, s14
        processbuf[n] = processbuf[n] * processbuf[n]
   2482c:	ece3 7a01 	vstmia	r3!, {s15}
    for(n=1; n<framesize; n++)
   24830:	4299      	cmp	r1, r3
        processbuf[fftsize-n] = 0.;
   24832:	6010      	str	r0, [r2, #0]
    for(n=1; n<framesize; n++)
   24834:	d1f2      	bne.n	2481c <tSNAC_ioSamples+0xfc>
    for(m=0; m<(framesize>>1); m++)
   24836:	ea5f 0969 	movs.w	r9, r9, asr #1
   2483a:	d009      	beq.n	24850 <tSNAC_ioSamples+0x130>
   2483c:	9a06      	ldr	r2, [sp, #24]
   2483e:	eb0a 0989 	add.w	r9, sl, r9, lsl #2
   24842:	4653      	mov	r3, sl
        spectrumbuf[m] = processbuf[m];
   24844:	f853 1b04 	ldr.w	r1, [r3], #4
    for(m=0; m<(framesize>>1); m++)
   24848:	4599      	cmp	r9, r3
        spectrumbuf[m] = processbuf[m];
   2484a:	f842 1b04 	str.w	r1, [r2], #4
    for(m=0; m<(framesize>>1); m++)
   2484e:	d1f9      	bne.n	24844 <tSNAC_ioSamples+0x124>
    REALIFFT(fftsize, processbuf);
   24850:	4651      	mov	r1, sl
   24852:	4658      	mov	r0, fp
   24854:	f7ff fcec 	bl	24230 <mayer_realifft>
    snac_normalize(snac);
   24858:	9b02      	ldr	r3, [sp, #8]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   2485a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    int seek = framesize * SEEK;
   2485e:	eddf 4ade 	vldr	s9, [pc, #888]	; 24bd8 <tSNAC_ioSamples+0x4b8>
    snac_normalize(snac);
   24862:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
   24864:	8ada      	ldrh	r2, [r3, #22]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24866:	ed93 5a0a 	vldr	s10, [r3, #40]	; 0x28
    int seek = framesize * SEEK;
   2486a:	ee07 2a90 	vmov	s15, r2
    int framesize = s->framesize;
   2486e:	9206      	str	r2, [sp, #24]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24870:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
    float *processbuf= s->processbuf;
   24874:	689a      	ldr	r2, [r3, #8]
    int seek = framesize * SEEK;
   24876:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    int framesizeplustimeindex = s->framesize + s->timeindex;
   2487a:	f8b3 a014 	ldrh.w	sl, [r3, #20]
    float rzero = processbuf[0];
   2487e:	ed92 6a00 	vldr	s12, [r2]
    float *inputbuf = s->inputbuf;
   24882:	f8d3 9004 	ldr.w	r9, [r3, #4]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   24886:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    processbuf[0] = 1;
   2488a:	edc2 6a00 	vstr	s13, [r2]
    int mask = framesize - 1;
   2488e:	9906      	ldr	r1, [sp, #24]
    float *processbuf= s->processbuf;
   24890:	9207      	str	r2, [sp, #28]
    int mask = framesize - 1;
   24892:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
    int framesizeplustimeindex = s->framesize + s->timeindex;
   24896:	eb0a 0b01 	add.w	fp, sl, r1
    int seek = framesize * SEEK;
   2489a:	ee67 7aa4 	vmul.f32	s15, s15, s9
   2489e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   248a2:	ee17 0a90 	vmov	r0, s15
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   248a6:	2801      	cmp	r0, #1
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
   248a8:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   248ac:	eeb1 4bc7 	vsqrt.f64	d4, d7
   248b0:	ee85 7b04 	vdiv.f64	d7, d5, d4
   248b4:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    float minrzero = rms * rms;
   248b8:	ee27 7a07 	vmul.f32	s14, s14, s14
    double normintegral = (double)rzero * 2.;
   248bc:	fe87 6a06 	vmaxnm.f32	s12, s14, s12
   248c0:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
   248c4:	ee36 6b06 	vadd.f64	d6, d6, d6
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   248c8:	dd2b      	ble.n	24922 <tSNAC_ioSamples+0x202>
        processbuf[n] /= (float)normintegral * 0.5f;
   248ca:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
   248ce:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   248d2:	f102 0c04 	add.w	ip, r2, #4
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   248d6:	2101      	movs	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   248d8:	ebab 0201 	sub.w	r2, fp, r1
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   248dc:	eb0a 0301 	add.w	r3, sl, r1
        processbuf[n] /= (float)normintegral * 0.5f;
   248e0:	eddc 5a00 	vldr	s11, [ip]
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   248e4:	3101      	adds	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   248e6:	ea02 020e 	and.w	r2, r2, lr
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   248ea:	ea03 030e 	and.w	r3, r3, lr
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   248ee:	4288      	cmp	r0, r1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   248f0:	eb09 0282 	add.w	r2, r9, r2, lsl #2
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   248f4:	eb09 0383 	add.w	r3, r9, r3, lsl #2
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
   248f8:	ed92 7a00 	vldr	s14, [r2]
        signal1 = inputbuf[(n + timeindexminusone)&mask];
   248fc:	edd3 7a00 	vldr	s15, [r3]
        normintegral -= (double)(signal1 * signal1 + signal2 * signal2);
   24900:	ee27 7a07 	vmul.f32	s14, s14, s14
   24904:	eea7 7aa7 	vfma.f32	s14, s15, s15
   24908:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2490c:	ee36 6b47 	vsub.f64	d6, d6, d7
        processbuf[n] /= (float)normintegral * 0.5f;
   24910:	eef7 7bc6 	vcvt.f32.f64	s15, d6
   24914:	ee67 7a85 	vmul.f32	s15, s15, s10
   24918:	ee85 7aa7 	vdiv.f32	s14, s11, s15
   2491c:	ecac 7a01 	vstmia	ip!, {s14}
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
   24920:	d1da      	bne.n	248d8 <tSNAC_ioSamples+0x1b8>
    for(n = seek; n<framesize; n++) processbuf[n] = 0.;
   24922:	9b06      	ldr	r3, [sp, #24]
   24924:	4283      	cmp	r3, r0
   24926:	dd07      	ble.n	24938 <tSNAC_ioSamples+0x218>
   24928:	1a1a      	subs	r2, r3, r0
   2492a:	9b07      	ldr	r3, [sp, #28]
   2492c:	2100      	movs	r1, #0
   2492e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   24932:	0092      	lsls	r2, r2, #2
   24934:	f008 f885 	bl	2ca42 <memset>
    snac_pickpeak(snac);
   24938:	9b02      	ldr	r3, [sp, #8]
    int seek = s->framesize * SEEK;
   2493a:	ed9f 7aa7 	vldr	s14, [pc, #668]	; 24bd8 <tSNAC_ioSamples+0x4b8>
    snac_pickpeak(snac);
   2493e:	681b      	ldr	r3, [r3, #0]
    int seek = s->framesize * SEEK;
   24940:	8ada      	ldrh	r2, [r3, #22]
    snac_pickpeak(snac);
   24942:	9307      	str	r3, [sp, #28]
    int seek = s->framesize * SEEK;
   24944:	ee07 2a90 	vmov	s15, r2
    float *biasbuf = s->biasbuf;
   24948:	6918      	ldr	r0, [r3, #16]
    float *processbuf= s->processbuf;
   2494a:	689a      	ldr	r2, [r3, #8]
    int seek = s->framesize * SEEK;
   2494c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   24950:	ee67 7a87 	vmul.f32	s15, s15, s14
   24954:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   24958:	ee17 aa90 	vmov	sl, s15
    for(n=1; n<seek; n++)
   2495c:	f1ba 0f01 	cmp.w	sl, #1
   24960:	f340 808b 	ble.w	24a7a <tSNAC_ioSamples+0x35a>
        if(processbuf[n] < 0.) break;
   24964:	edd2 7a01 	vldr	s15, [r2, #4]
   24968:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2496c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24970:	f100 8083 	bmi.w	24a7a <tSNAC_ioSamples+0x35a>
   24974:	f102 0108 	add.w	r1, r2, #8
    for(n=1; n<seek; n++)
   24978:	f04f 0901 	mov.w	r9, #1
   2497c:	e006      	b.n	2498c <tSNAC_ioSamples+0x26c>
        if(processbuf[n] < 0.) break;
   2497e:	ecf1 7a01 	vldmia	r1!, {s15}
   24982:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   24986:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2498a:	d404      	bmi.n	24996 <tSNAC_ioSamples+0x276>
    for(n=1; n<seek; n++)
   2498c:	f109 0901 	add.w	r9, r9, #1
   24990:	45ca      	cmp	sl, r9
   24992:	d1f4      	bne.n	2497e <tSNAC_ioSamples+0x25e>
   24994:	46d1      	mov	r9, sl
    for(; n<seek-1; n++)
   24996:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   2499a:	45ca      	cmp	sl, r9
   2499c:	dd6b      	ble.n	24a76 <tSNAC_ioSamples+0x356>
   2499e:	ea4f 0389 	mov.w	r3, r9, lsl #2
   249a2:	2100      	movs	r1, #0
   249a4:	9408      	str	r4, [sp, #32]
   249a6:	4614      	mov	r4, r2
   249a8:	f1a3 0b04 	sub.w	fp, r3, #4
   249ac:	4403      	add	r3, r0
   249ae:	9509      	str	r5, [sp, #36]	; 0x24
   249b0:	4655      	mov	r5, sl
   249b2:	9106      	str	r1, [sp, #24]
   249b4:	4493      	add	fp, r2
   249b6:	ed9f 8a89 	vldr	s16, [pc, #548]	; 24bdc <tSNAC_ioSamples+0x4bc>
   249ba:	469a      	mov	sl, r3
   249bc:	e005      	b.n	249ca <tSNAC_ioSamples+0x2aa>
   249be:	f109 0901 	add.w	r9, r9, #1
   249c2:	f10a 0a04 	add.w	sl, sl, #4
   249c6:	45a9      	cmp	r9, r5
   249c8:	d029      	beq.n	24a1e <tSNAC_ioSamples+0x2fe>
   249ca:	4659      	mov	r1, fp
        if(processbuf[n] >= processbuf[n-1])
   249cc:	f10b 0b04 	add.w	fp, fp, #4
   249d0:	ed91 7a00 	vldr	s14, [r1]
   249d4:	eddb 7a00 	vldr	s15, [fp]
   249d8:	eef4 7ac7 	vcmpe.f32	s15, s14
   249dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   249e0:	dbed      	blt.n	249be <tSNAC_ioSamples+0x29e>
            if(processbuf[n] > processbuf[n+1])     // we have a local peak
   249e2:	ed9b 7a01 	vldr	s14, [fp, #4]
   249e6:	eef4 7ac7 	vcmpe.f32	s15, s14
   249ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   249ee:	dde6      	ble.n	249be <tSNAC_ioSamples+0x29e>
                biasedpeak = interpolate3max(processbuf, n) * biasbuf[n];
   249f0:	4649      	mov	r1, r9
   249f2:	4620      	mov	r0, r4
   249f4:	f004 fe22 	bl	2963c <interpolate3max>
   249f8:	edda 7a00 	vldr	s15, [sl]
   249fc:	ee20 0a27 	vmul.f32	s0, s0, s15
                if(biasedpeak > maxvalue)
   24a00:	eeb4 0ac8 	vcmpe.f32	s0, s16
   24a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24a08:	ddd9      	ble.n	249be <tSNAC_ioSamples+0x29e>
   24a0a:	f8cd 9018 	str.w	r9, [sp, #24]
    for(; n<seek-1; n++)
   24a0e:	f109 0901 	add.w	r9, r9, #1
                    maxvalue = biasedpeak;
   24a12:	eeb0 8a40 	vmov.f32	s16, s0
   24a16:	f10a 0a04 	add.w	sl, sl, #4
    for(; n<seek-1; n++)
   24a1a:	45a9      	cmp	r9, r5
   24a1c:	d1d5      	bne.n	249ca <tSNAC_ioSamples+0x2aa>
   24a1e:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   24a22:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    s->periodindex = peakindex;
   24a26:	9a07      	ldr	r2, [sp, #28]
   24a28:	8353      	strh	r3, [r2, #26]
    _tSNAC* s = *snac;
   24a2a:	9b02      	ldr	r3, [sp, #8]
   24a2c:	f8d3 a000 	ldr.w	sl, [r3]
    if(s->periodindex)
   24a30:	f8ba 901a 	ldrh.w	r9, [sl, #26]
   24a34:	f1b9 0f00 	cmp.w	r9, #0
   24a38:	f43f ae89 	beq.w	2474e <tSNAC_ioSamples+0x2e>
        interpolate3phase(s->processbuf, s->periodindex);
   24a3c:	4649      	mov	r1, r9
   24a3e:	f8da 0008 	ldr.w	r0, [sl, #8]
   24a42:	f004 fe19 	bl	29678 <interpolate3phase>
        periodlength = (float)s->periodindex +
   24a46:	ee07 9a90 	vmov	s15, r9
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   24a4a:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
        periodlength = (float)s->periodindex +
   24a4e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   24a52:	ee37 0a80 	vadd.f32	s0, s15, s0
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   24a56:	eeb4 0ac7 	vcmpe.f32	s0, s14
   24a5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24a5e:	d40f      	bmi.n	24a80 <tSNAC_ioSamples+0x360>
        s->periodlength = periodlength;
   24a60:	ed8a 0a07 	vstr	s0, [sl, #28]
        s->fidelity = interpolate3max(s->processbuf, s->periodindex);
   24a64:	f8ba 101a 	ldrh.w	r1, [sl, #26]
   24a68:	f8da 0008 	ldr.w	r0, [sl, #8]
   24a6c:	f004 fde6 	bl	2963c <interpolate3max>
   24a70:	ed8a 0a08 	vstr	s0, [sl, #32]
   24a74:	e66b      	b.n	2474e <tSNAC_ioSamples+0x2e>
    for(; n<seek-1; n++)
   24a76:	2300      	movs	r3, #0
   24a78:	e7d5      	b.n	24a26 <tSNAC_ioSamples+0x306>
    for(n=1; n<seek; n++)
   24a7a:	f04f 0901 	mov.w	r9, #1
   24a7e:	e78a      	b.n	24996 <tSNAC_ioSamples+0x276>
    if(periodlength < 4.0f) return periodlength;
   24a80:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
   24a84:	eeb4 0ae7 	vcmpe.f32	s0, s15
   24a88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24a8c:	d4e8      	bmi.n	24a60 <tSNAC_ioSamples+0x340>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   24a8e:	9b02      	ldr	r3, [sp, #8]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24a90:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24a94:	eef7 5a04 	vmov.f32	s11, #116	; 0x3fa00000  1.250
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24a98:	ed9f 6a51 	vldr	s12, [pc, #324]	; 24be0 <tSNAC_ioSamples+0x4c0>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
   24a9c:	f8d3 9000 	ldr.w	r9, [r3]
    int spectrumsize = s->framesize>>1;
   24aa0:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    float *spectrumbuf = s->spectrumbuf;
   24aa4:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   24aa8:	ee07 3a10 	vmov	s14, r3
    int spectrumsize = s->framesize>>1;
   24aac:	085b      	lsrs	r3, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   24aae:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    if(stopbin >= spectrumsize - 1) stopbin = spectrumsize - 1;
   24ab2:	1e5a      	subs	r2, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
   24ab4:	ee37 7a07 	vadd.f32	s14, s14, s14
   24ab8:	eec7 6a00 	vdiv.f32	s13, s14, s0
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24abc:	eeb0 7a67 	vmov.f32	s14, s15
   24ac0:	eea6 7aa5 	vfma.f32	s14, s13, s11
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24ac4:	eee6 7a86 	vfma.f32	s15, s13, s12
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24ac8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24acc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
   24ad0:	ee17 1a10 	vmov	r1, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
   24ad4:	ee17 3a90 	vmov	r3, s15
   24ad8:	4291      	cmp	r1, r2
   24ada:	bfa8      	it	ge
   24adc:	4611      	movge	r1, r2
   24ade:	2b01      	cmp	r3, #1
   24ae0:	bfb8      	it	lt
   24ae2:	2301      	movlt	r3, #1
    for(n=startbin; n<stopbin; n++)
   24ae4:	4299      	cmp	r1, r3
   24ae6:	dd64      	ble.n	24bb2 <tSNAC_ioSamples+0x492>
   24ae8:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float max = 0.;
   24aec:	eddf 6a3b 	vldr	s13, [pc, #236]	; 24bdc <tSNAC_ioSamples+0x4bc>
   24af0:	441a      	add	r2, r3
   24af2:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
   24af6:	4610      	mov	r0, r2
        if(spectrumbuf[n] >= spectrumbuf[n-1])
   24af8:	3204      	adds	r2, #4
   24afa:	ed90 7a00 	vldr	s14, [r0]
   24afe:	edd2 7a00 	vldr	s15, [r2]
   24b02:	eef4 7ac7 	vcmpe.f32	s15, s14
   24b06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24b0a:	db0e      	blt.n	24b2a <tSNAC_ioSamples+0x40a>
            if(spectrumbuf[n] > spectrumbuf[n+1])
   24b0c:	ed92 7a01 	vldr	s14, [r2, #4]
                if(spectrumbuf[n] > max)
   24b10:	eef4 7a47 	vcmp.f32	s15, s14
   24b14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24b18:	dd07      	ble.n	24b2a <tSNAC_ioSamples+0x40a>
   24b1a:	eef4 7a66 	vcmp.f32	s15, s13
   24b1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24b22:	dd02      	ble.n	24b2a <tSNAC_ioSamples+0x40a>
                    max = spectrumbuf[n];
   24b24:	eef0 6a67 	vmov.f32	s13, s15
                if(spectrumbuf[n] > max)
   24b28:	9305      	str	r3, [sp, #20]
    for(n=startbin; n<stopbin; n++)
   24b2a:	3301      	adds	r3, #1
   24b2c:	4299      	cmp	r1, r3
   24b2e:	d1e2      	bne.n	24af6 <tSNAC_ioSamples+0x3d6>
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24b30:	9b05      	ldr	r3, [sp, #20]
   24b32:	461a      	mov	r2, r3
   24b34:	1e58      	subs	r0, r3, #1
   24b36:	3301      	adds	r3, #1
   24b38:	ee07 2a90 	vmov	s15, r2
   24b3c:	4283      	cmp	r3, r0
   24b3e:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   24b42:	db25      	blt.n	24b90 <tSNAC_ioSamples+0x470>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24b44:	0080      	lsls	r0, r0, #2
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24b46:	469e      	mov	lr, r3
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24b48:	eb0c 0100 	add.w	r1, ip, r0
   24b4c:	3004      	adds	r0, #4
   24b4e:	ed91 7a00 	vldr	s14, [r1]
   24b52:	eb0c 0200 	add.w	r2, ip, r0
   24b56:	eef1 7ac7 	vsqrt.f32	s15, s14
   24b5a:	edc1 7a00 	vstr	s15, [r1]
   24b5e:	ed92 7a00 	vldr	s14, [r2]
   24b62:	eef1 7ac7 	vsqrt.f32	s15, s14
   24b66:	edc2 7a00 	vstr	s15, [r2]
   24b6a:	1d02      	adds	r2, r0, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24b6c:	459e      	cmp	lr, r3
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24b6e:	4462      	add	r2, ip
   24b70:	ed92 7a00 	vldr	s14, [r2]
   24b74:	eef1 7ac7 	vsqrt.f32	s15, s14
   24b78:	edc2 7a00 	vstr	s15, [r2]
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24b7c:	da08      	bge.n	24b90 <tSNAC_ioSamples+0x470>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24b7e:	f100 0308 	add.w	r3, r0, #8
   24b82:	4463      	add	r3, ip
   24b84:	ed93 7a00 	vldr	s14, [r3]
   24b88:	eef1 7ac7 	vsqrt.f32	s15, s14
   24b8c:	edc3 7a00 	vstr	s15, [r3]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
   24b90:	9905      	ldr	r1, [sp, #20]
   24b92:	4660      	mov	r0, ip
   24b94:	f004 fd70 	bl	29678 <interpolate3phase>
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
   24b98:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
   24b9c:	ee30 8a08 	vadd.f32	s16, s0, s16
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
   24ba0:	ee07 3a90 	vmov	s15, r3
   24ba4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   24ba8:	ee77 7aa7 	vadd.f32	s15, s15, s15
   24bac:	ee87 0a88 	vdiv.f32	s0, s15, s16
   24bb0:	e756      	b.n	24a60 <tSNAC_ioSamples+0x340>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24bb2:	ed5c 7a01 	vldr	s15, [ip, #-4]
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24bb6:	f04f 0e01 	mov.w	lr, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24bba:	eddc 6a00 	vldr	s13, [ip]
   24bbe:	2000      	movs	r0, #0
   24bc0:	eeb1 7ae7 	vsqrt.f32	s14, s15
    for(n=(peakbin-1); n<(peakbin+2); n++)
   24bc4:	4673      	mov	r3, lr
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
   24bc6:	ed9f 8a05 	vldr	s16, [pc, #20]	; 24bdc <tSNAC_ioSamples+0x4bc>
   24bca:	eef1 7ae6 	vsqrt.f32	s15, s13
   24bce:	ed0c 7a01 	vstr	s14, [ip, #-4]
   24bd2:	edcc 7a00 	vstr	s15, [ip]
   24bd6:	e7c8      	b.n	24b6a <tSNAC_ioSamples+0x44a>
   24bd8:	3f59999a 	.word	0x3f59999a
   24bdc:	00000000 	.word	0x00000000
   24be0:	3f4ccccd 	.word	0x3f4ccccd

00024be4 <tPeriodDetection_initToPool>:
{
    tPeriodDetection_initToPool(pd, in, out, bufSize, frameSize, &leaf.mempool);
}

void tPeriodDetection_initToPool (tPeriodDetection* const pd, float* in, float* out, int bufSize, int frameSize, tMempool* const mp)
{
   24be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24be8:	b085      	sub	sp, #20
   24bea:	4682      	mov	sl, r0
   24bec:	468b      	mov	fp, r1
    _tMempool* m = *mp;
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   24bee:	2068      	movs	r0, #104	; 0x68
{
   24bf0:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
   24bf2:	461d      	mov	r5, r3
   24bf4:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    p->inBuffer = in;
    p->outBuffer = out;
    p->bufSize = bufSize;
    p->frameSize = frameSize;
    p->framesPerBuffer = p->bufSize / p->frameSize;
    p->curBlock = 1;
   24bf6:	f04f 0801 	mov.w	r8, #1
    _tMempool* m = *mp;
   24bfa:	f8d6 9000 	ldr.w	r9, [r6]
{
   24bfe:	9203      	str	r2, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   24c00:	4649      	mov	r1, r9
   24c02:	f005 f897 	bl	29d34 <mpool_calloc>
   24c06:	4604      	mov	r4, r0
    p->lastBlock = 0;
   24c08:	f04f 0c00 	mov.w	ip, #0
    p->outBuffer = out;
   24c0c:	9b03      	ldr	r3, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
   24c0e:	f8ca 4000 	str.w	r4, [sl]
    
    p->hopSize = DEFHOPSIZE;
    p->windowSize = DEFWINDOWSIZE;
    p->fba = FBA;
    
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24c12:	2240      	movs	r2, #64	; 0x40
    p->hopSize = DEFHOPSIZE;
   24c14:	f04f 1040 	mov.w	r0, #4194368	; 0x400040
    p->fba = FBA;
   24c18:	2114      	movs	r1, #20
    p->index = 0;
   24c1a:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
    p->outBuffer = out;
   24c1e:	6123      	str	r3, [r4, #16]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24c20:	463b      	mov	r3, r7
    p->hopSize = DEFHOPSIZE;
   24c22:	63e0      	str	r0, [r4, #60]	; 0x3c
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24c24:	1d20      	adds	r0, r4, #4
    p->fba = FBA;
   24c26:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24c2a:	4611      	mov	r1, r2
    p->mempool = m;
   24c2c:	f8c4 9000 	str.w	r9, [r4]
    p->inBuffer = in;
   24c30:	f8c4 b00c 	str.w	fp, [r4, #12]
    p->frameSize = frameSize;
   24c34:	e9c4 7505 	strd	r7, r5, [r4, #20]
    p->framesPerBuffer = p->bufSize / p->frameSize;
   24c38:	fb95 f5f7 	sdiv	r5, r5, r7
    p->lastBlock = 0;
   24c3c:	e9c4 8c08 	strd	r8, ip, [r4, #32]
    p->framesPerBuffer = p->bufSize / p->frameSize;
   24c40:	61e5      	str	r5, [r4, #28]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
   24c42:	9600      	str	r6, [sp, #0]
   24c44:	f7ff fc2c 	bl	244a0 <tEnvPD_initToPool>
    
    tSNAC_initToPool(&p->snac, DEFOVERLAP, mp);
   24c48:	4632      	mov	r2, r6
   24c4a:	4641      	mov	r1, r8
   24c4c:	f104 0008 	add.w	r0, r4, #8
   24c50:	f7ff fcd4 	bl	245fc <tSNAC_initToPool>

    p->history = 0.0f;
    p->alpha = 1.0f;
    p->tolerance = 1.0f;
    p->timeConstant = DEFTIMECONSTANT;
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24c54:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
   24c56:	4b0f      	ldr	r3, [pc, #60]	; (24c94 <tPeriodDetection_initToPool+0xb0>)
   24c58:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
   24c5c:	ee00 2a10 	vmov	s0, r2
    p->history = 0.0f;
   24c60:	2100      	movs	r1, #0
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24c62:	edd3 7a01 	vldr	s15, [r3, #4]
    p->alpha = 1.0f;
   24c66:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24c6a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    p->timeConstant = DEFTIMECONSTANT;
   24c6e:	4a0a      	ldr	r2, [pc, #40]	; (24c98 <tPeriodDetection_initToPool+0xb4>)
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24c70:	ee67 7a87 	vmul.f32	s15, s15, s14
    p->alpha = 1.0f;
   24c74:	6623      	str	r3, [r4, #96]	; 0x60
    p->tolerance = 1.0f;
   24c76:	6663      	str	r3, [r4, #100]	; 0x64
    p->history = 0.0f;
   24c78:	65e1      	str	r1, [r4, #92]	; 0x5c
    p->timeConstant = DEFTIMECONSTANT;
   24c7a:	6462      	str	r2, [r4, #68]	; 0x44
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24c7c:	ee20 0a27 	vmul.f32	s0, s0, s15
   24c80:	f008 f848 	bl	2cd14 <expf>
    p->fidelityThreshold = 0.95;
   24c84:	4b05      	ldr	r3, [pc, #20]	; (24c9c <tPeriodDetection_initToPool+0xb8>)
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
   24c86:	ed84 0a12 	vstr	s0, [r4, #72]	; 0x48
    p->fidelityThreshold = 0.95;
   24c8a:	65a3      	str	r3, [r4, #88]	; 0x58
}
   24c8c:	b005      	add	sp, #20
   24c8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24c92:	bf00      	nop
   24c94:	020fc0a8 	.word	0x020fc0a8
   24c98:	42c80000 	.word	0x42c80000
   24c9c:	3f733333 	.word	0x3f733333

00024ca0 <tPeriodDetection_free>:

void tPeriodDetection_free (tPeriodDetection* const pd)
{
   24ca0:	b538      	push	{r3, r4, r5, lr}
    _tPeriodDetection* p = *pd;
   24ca2:	6805      	ldr	r5, [r0, #0]
    _tEnvPD* x = *xpd;
   24ca4:	6868      	ldr	r0, [r5, #4]
    mpool_free((char*)x, x->mempool);
   24ca6:	6801      	ldr	r1, [r0, #0]
   24ca8:	f005 f896 	bl	29dd8 <mpool_free>
    _tSNAC* s = *snac;
   24cac:	68ac      	ldr	r4, [r5, #8]
    mpool_free((char*)s->inputbuf, s->mempool);
   24cae:	e9d4 1000 	ldrd	r1, r0, [r4]
   24cb2:	f005 f891 	bl	29dd8 <mpool_free>
    mpool_free((char*)s->processbuf, s->mempool);
   24cb6:	6821      	ldr	r1, [r4, #0]
   24cb8:	68a0      	ldr	r0, [r4, #8]
   24cba:	f005 f88d 	bl	29dd8 <mpool_free>
    mpool_free((char*)s->spectrumbuf, s->mempool);
   24cbe:	6821      	ldr	r1, [r4, #0]
   24cc0:	68e0      	ldr	r0, [r4, #12]
   24cc2:	f005 f889 	bl	29dd8 <mpool_free>
    mpool_free((char*)s->biasbuf, s->mempool);
   24cc6:	6821      	ldr	r1, [r4, #0]
   24cc8:	6920      	ldr	r0, [r4, #16]
   24cca:	f005 f885 	bl	29dd8 <mpool_free>
    mpool_free((char*)s, s->mempool);
   24cce:	6821      	ldr	r1, [r4, #0]
   24cd0:	4620      	mov	r0, r4
   24cd2:	f005 f881 	bl	29dd8 <mpool_free>
    
    tEnvPD_free(&p->env);
    tSNAC_free(&p->snac);
    mpool_free((char*)p, p->mempool);
   24cd6:	6829      	ldr	r1, [r5, #0]
   24cd8:	4628      	mov	r0, r5
}
   24cda:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mpool_free((char*)p, p->mempool);
   24cde:	f005 b87b 	b.w	29dd8 <mpool_free>
   24ce2:	bf00      	nop

00024ce4 <tPeriodDetection_tick>:

float tPeriodDetection_tick (tPeriodDetection* pd, float sample)
{
   24ce4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    _tPeriodDetection* p = *pd;
   24ce8:	6804      	ldr	r4, [r0, #0]
    
    int i, iLast;
    
    i = (p->curBlock*p->frameSize);
   24cea:	6963      	ldr	r3, [r4, #20]
   24cec:	6a21      	ldr	r1, [r4, #32]
    iLast = (p->lastBlock*p->frameSize)+p->index;
   24cee:	6b62      	ldr	r2, [r4, #52]	; 0x34
    i = (p->curBlock*p->frameSize);
   24cf0:	fb01 f103 	mul.w	r1, r1, r3
    iLast = (p->lastBlock*p->frameSize)+p->index;
   24cf4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    
    p->i = i;
    p->iLast = iLast;
    
    p->inBuffer[i+p->index] = sample;
   24cf6:	68e0      	ldr	r0, [r4, #12]
    iLast = (p->lastBlock*p->frameSize)+p->index;
   24cf8:	fb05 2303 	mla	r3, r5, r3, r2
    p->inBuffer[i+p->index] = sample;
   24cfc:	440a      	add	r2, r1
    p->i = i;
   24cfe:	62a1      	str	r1, [r4, #40]	; 0x28
    p->inBuffer[i+p->index] = sample;
   24d00:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    p->iLast = iLast;
   24d04:	6323      	str	r3, [r4, #48]	; 0x30
    p->inBuffer[i+p->index] = sample;
   24d06:	ed82 0a00 	vstr	s0, [r2]
    
    p->index++;
   24d0a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
    if (p->index >= p->frameSize)
   24d0c:	6962      	ldr	r2, [r4, #20]
    p->index++;
   24d0e:	3301      	adds	r3, #1
    if (p->index >= p->frameSize)
   24d10:	4293      	cmp	r3, r2
    p->index++;
   24d12:	6363      	str	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
   24d14:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (p->index >= p->frameSize)
   24d16:	da03      	bge.n	24d20 <tPeriodDetection_tick+0x3c>
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
        p->lastBlock++;
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
    }
    return p->period;
}
   24d18:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
   24d1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    _tEnvPD* x = *xpd;
   24d20:	f8d4 c004 	ldr.w	ip, [r4, #4]
        p->index = 0;
   24d24:	2200      	movs	r2, #0
    int n = x->blockSize;
   24d26:	f241 1398 	movw	r3, #4504	; 0x1198
    for (count = x->x_phase, sump = x->x_sumbuf;
   24d2a:	f241 1604 	movw	r6, #4356	; 0x1104
        p->index = 0;
   24d2e:	6362      	str	r2, [r4, #52]	; 0x34
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
   24d30:	0089      	lsls	r1, r1, #2
    int n = x->blockSize;
   24d32:	f83c 5003 	ldrh.w	r5, [ip, r3]
         count < x->x_npoints; count += x->x_realperiod, sump++)
   24d36:	f241 130a 	movw	r3, #4362	; 0x110a
    for (count = x->x_phase, sump = x->x_sumbuf;
   24d3a:	f83c 6006 	ldrh.w	r6, [ip, r6]
   24d3e:	f241 1010 	movw	r0, #4368	; 0x1110
   24d42:	f83c 3003 	ldrh.w	r3, [ip, r3]
    in += n;
   24d46:	eb01 0985 	add.w	r9, r1, r5, lsl #2
   24d4a:	68e2      	ldr	r2, [r4, #12]
    for (count = x->x_phase, sump = x->x_sumbuf;
   24d4c:	4460      	add	r0, ip
   24d4e:	42b3      	cmp	r3, r6
    in += n;
   24d50:	4491      	add	r9, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
   24d52:	d924      	bls.n	24d9e <tPeriodDetection_tick+0xba>
   24d54:	f241 1808 	movw	r8, #4360	; 0x1108
   24d58:	f241 1e0a 	movw	lr, #4362	; 0x110a
   24d5c:	4607      	mov	r7, r0
   24d5e:	f10c 0a04 	add.w	sl, ip, #4
   24d62:	44e0      	add	r8, ip
   24d64:	44e6      	add	lr, ip
        t_sample *hp = x->buf + count;
   24d66:	eb0a 0286 	add.w	r2, sl, r6, lsl #2
        t_sample sum = *sump;
   24d6a:	ecb7 7a01 	vldmia	r7!, {s14}
        for (i = 0; i < n; i++)
   24d6e:	b165      	cbz	r5, 24d8a <tPeriodDetection_tick+0xa6>
   24d70:	4648      	mov	r0, r9
   24d72:	2300      	movs	r3, #0
            sum += *hp++ * (*fp * *fp);
   24d74:	ed70 7a01 	vldmdb	r0!, {s15}
        for (i = 0; i < n; i++)
   24d78:	3301      	adds	r3, #1
            sum += *hp++ * (*fp * *fp);
   24d7a:	ecf2 6a01 	vldmia	r2!, {s13}
   24d7e:	ee67 7aa7 	vmul.f32	s15, s15, s15
        for (i = 0; i < n; i++)
   24d82:	429d      	cmp	r5, r3
            sum += *hp++ * (*fp * *fp);
   24d84:	eea6 7aa7 	vfma.f32	s14, s13, s15
        for (i = 0; i < n; i++)
   24d88:	d1f4      	bne.n	24d74 <tPeriodDetection_tick+0x90>
        *sump = sum;
   24d8a:	ed07 7a01 	vstr	s14, [r7, #-4]
   24d8e:	4638      	mov	r0, r7
         count < x->x_npoints; count += x->x_realperiod, sump++)
   24d90:	f8b8 2000 	ldrh.w	r2, [r8]
   24d94:	f8be 3000 	ldrh.w	r3, [lr]
   24d98:	4416      	add	r6, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
   24d9a:	429e      	cmp	r6, r3
   24d9c:	dbe3      	blt.n	24d66 <tPeriodDetection_tick+0x82>
    x->x_phase -= n;
   24d9e:	f241 1204 	movw	r2, #4356	; 0x1104
    sump[0] = 0;
   24da2:	2300      	movs	r3, #0
   24da4:	6003      	str	r3, [r0, #0]
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
   24da6:	f104 0008 	add.w	r0, r4, #8
    x->x_phase -= n;
   24daa:	f83c 3002 	ldrh.w	r3, [ip, r2]
   24dae:	1b5d      	subs	r5, r3, r5
   24db0:	f82c 5002 	strh.w	r5, [ip, r2]
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
   24db4:	6963      	ldr	r3, [r4, #20]
   24db6:	e9d4 5203 	ldrd	r5, r2, [r4, #12]
   24dba:	440a      	add	r2, r1
   24dbc:	4429      	add	r1, r5
   24dbe:	f7ff fcaf 	bl	24720 <tSNAC_ioSamples>
    _tSNAC* s = *snac;
   24dc2:	68a3      	ldr	r3, [r4, #8]
        if (fidelity > p->fidelityThreshold)
   24dc4:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
   24dc8:	edd3 7a08 	vldr	s15, [r3, #32]
   24dcc:	eeb4 7ae7 	vcmpe.f32	s14, s15
   24dd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24dd4:	d501      	bpl.n	24dda <tPeriodDetection_tick+0xf6>
    return(s->periodlength);
   24dd6:	69db      	ldr	r3, [r3, #28]
        	p->period = tSNAC_getPeriod(&p->snac);
   24dd8:	63a3      	str	r3, [r4, #56]	; 0x38
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   24dda:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
        p->curBlock++;
   24dde:	3301      	adds	r3, #1
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   24de0:	4293      	cmp	r3, r2
        p->curBlock++;
   24de2:	6223      	str	r3, [r4, #32]
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
   24de4:	db01      	blt.n	24dea <tPeriodDetection_tick+0x106>
   24de6:	2300      	movs	r3, #0
   24de8:	6223      	str	r3, [r4, #32]
        p->lastBlock++;
   24dea:	6a63      	ldr	r3, [r4, #36]	; 0x24
}
   24dec:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
        p->lastBlock++;
   24df0:	3301      	adds	r3, #1
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
   24df2:	429a      	cmp	r2, r3
   24df4:	bfd8      	it	le
   24df6:	2300      	movle	r3, #0
   24df8:	6263      	str	r3, [r4, #36]	; 0x24
}
   24dfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24dfe:	bf00      	nop

00024e00 <tPeriodDetection_getPeriod>:

float tPeriodDetection_getPeriod(tPeriodDetection* pd)
{
    _tPeriodDetection* p = *pd;
    return p->period;
   24e00:	6803      	ldr	r3, [r0, #0]
}
   24e02:	ed93 0a0e 	vldr	s0, [r3, #56]	; 0x38
   24e06:	4770      	bx	lr

00024e08 <tPeriodDetection_setFidelityThreshold>:
    p->windowSize = ws;
}

void tPeriodDetection_setFidelityThreshold(tPeriodDetection* pd, float threshold)
{
    _tPeriodDetection* p = *pd;
   24e08:	6803      	ldr	r3, [r0, #0]
    p->fidelityThreshold = threshold;
   24e0a:	ed83 0a16 	vstr	s0, [r3, #88]	; 0x58
}
   24e0e:	4770      	bx	lr

00024e10 <tLinearDelay_initToPool>:
{
    tLinearDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tLinearDelay_initToPool  (tLinearDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
   24e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24e12:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   24e16:	6816      	ldr	r6, [r2, #0]
{
   24e18:	460d      	mov	r5, r1
   24e1a:	4607      	mov	r7, r0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   24e1c:	202c      	movs	r0, #44	; 0x2c
   24e1e:	4631      	mov	r1, r6
{
   24e20:	eeb0 8a40 	vmov.f32	s16, s0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   24e24:	f004 ff30 	bl	29c88 <mpool_alloc>
    d->mempool = m;

    d->maxDelay = maxDelay;

    if (delay > maxDelay)   d->delay = maxDelay;
   24e28:	ee07 5a90 	vmov	s15, r5
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
   24e2c:	6038      	str	r0, [r7, #0]
   24e2e:	4604      	mov	r4, r0
    if (delay > maxDelay)   d->delay = maxDelay;
   24e30:	eef8 7a67 	vcvt.f32.u32	s15, s15
    d->mempool = m;
   24e34:	6006      	str	r6, [r0, #0]
    d->maxDelay = maxDelay;
   24e36:	61c5      	str	r5, [r0, #28]
    if (delay > maxDelay)   d->delay = maxDelay;
   24e38:	eef4 7ac8 	vcmpe.f32	s15, s16
   24e3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24e40:	d457      	bmi.n	24ef2 <tLinearDelay_initToPool+0xe2>
    else if (delay < 0.0f)  d->delay = 0.0f;
   24e42:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   24e46:	2300      	movs	r3, #0
   24e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24e4c:	bf4c      	ite	mi
   24e4e:	6203      	strmi	r3, [r0, #32]
    else                    d->delay = delay;
   24e50:	ed80 8a08 	vstrpl	s16, [r0, #32]

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24e54:	4631      	mov	r1, r6
   24e56:	00a8      	lsls	r0, r5, #2
   24e58:	f004 ff16 	bl	29c88 <mpool_alloc>

    d->gain = 1.0f;

    d->lastIn = 0.0f;
   24e5c:	eddf 7a26 	vldr	s15, [pc, #152]	; 24ef8 <tLinearDelay_initToPool+0xe8>
    d->gain = 1.0f;
   24e60:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
    d->lastOut = 0.0f;
    
    d->inPoint = 0;
   24e64:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   24e66:	60a0      	str	r0, [r4, #8]

int     tLinearDelay_setDelay (tLinearDelay* const dl, float delay)
{
    _tLinearDelay* d = *dl;

    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24e68:	eeb0 0a67 	vmov.f32	s0, s15
    d->gain = 1.0f;
   24e6c:	6062      	str	r2, [r4, #4]
    d->lastIn = 0.0f;
   24e6e:	edc4 7a04 	vstr	s15, [r4, #16]
    d->lastOut = 0.0f;
   24e72:	edc4 7a03 	vstr	s15, [r4, #12]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24e76:	edd4 0a08 	vldr	s1, [r4, #32]
    d->outPoint = 0;
   24e7a:	e9c4 3305 	strd	r3, r3, [r4, #20]
    _tLinearDelay* d = *dl;
   24e7e:	683d      	ldr	r5, [r7, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24e80:	edd5 7a07 	vldr	s15, [r5, #28]
   24e84:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   24e88:	f004 fcfe 	bl	29888 <LEAF_clip>

    float outPointer = d->inPoint - d->delay;
   24e8c:	edd5 7a05 	vldr	s15, [r5, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   24e90:	ed85 0a08 	vstr	s0, [r5, #32]
    float outPointer = d->inPoint - d->delay;
   24e94:	eef8 7a67 	vcvt.f32.u32	s15, s15

    while ( outPointer < 0 )
        outPointer += d->maxDelay; // modulo maximum length
   24e98:	69ea      	ldr	r2, [r5, #28]
    float outPointer = d->inPoint - d->delay;
   24e9a:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
   24e9e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   24ea2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24ea6:	d50a      	bpl.n	24ebe <tLinearDelay_initToPool+0xae>
        outPointer += d->maxDelay; // modulo maximum length
   24ea8:	ee07 2a90 	vmov	s15, r2
   24eac:	eef8 7a67 	vcvt.f32.u32	s15, s15
   24eb0:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
   24eb4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   24eb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   24ebc:	d4f8      	bmi.n	24eb0 <tLinearDelay_initToPool+0xa0>

    d->outPoint = (uint32_t) outPointer;   // integer part
   24ebe:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   24ec2:	ee17 3a90 	vmov	r3, s15

    d->alpha = outPointer - d->outPoint; // fractional part
    d->omAlpha = 1.0f - d->alpha;
   24ec6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
   24eca:	ee07 3a10 	vmov	s14, r3

    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   24ece:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
   24ed0:	61ab      	str	r3, [r5, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
   24ed2:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   24ed6:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
   24eda:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
   24ede:	ed85 0a09 	vstr	s0, [r5, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
   24ee2:	edc5 7a0a 	vstr	s15, [r5, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   24ee6:	d101      	bne.n	24eec <tLinearDelay_initToPool+0xdc>
   24ee8:	2300      	movs	r3, #0
   24eea:	61ab      	str	r3, [r5, #24]
}
   24eec:	ecbd 8b02 	vpop	{d8}
   24ef0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (delay > maxDelay)   d->delay = maxDelay;
   24ef2:	edc0 7a08 	vstr	s15, [r0, #32]
   24ef6:	e7ad      	b.n	24e54 <tLinearDelay_initToPool+0x44>
   24ef8:	00000000 	.word	0x00000000

00024efc <tLinearDelay_free>:
{
   24efc:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
   24efe:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
   24f00:	6821      	ldr	r1, [r4, #0]
   24f02:	68a0      	ldr	r0, [r4, #8]
   24f04:	f004 ff68 	bl	29dd8 <mpool_free>
    mpool_free((char*)d, d->mempool);
   24f08:	6821      	ldr	r1, [r4, #0]
   24f0a:	4620      	mov	r0, r4
}
   24f0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
   24f10:	f004 bf62 	b.w	29dd8 <mpool_free>

00024f14 <tLinearDelay_clear>:
	_tLinearDelay* d = *dl;
   24f14:	6801      	ldr	r1, [r0, #0]
	for (int i = 0; i < d->maxDelay; i++)
   24f16:	69cb      	ldr	r3, [r1, #28]
   24f18:	b14b      	cbz	r3, 24f2e <tLinearDelay_clear+0x1a>
   24f1a:	2300      	movs	r3, #0
		d->buff[i] = 0;
   24f1c:	2000      	movs	r0, #0
   24f1e:	688a      	ldr	r2, [r1, #8]
   24f20:	eb02 0283 	add.w	r2, r2, r3, lsl #2
	for (int i = 0; i < d->maxDelay; i++)
   24f24:	3301      	adds	r3, #1
		d->buff[i] = 0;
   24f26:	6010      	str	r0, [r2, #0]
	for (int i = 0; i < d->maxDelay; i++)
   24f28:	69ca      	ldr	r2, [r1, #28]
   24f2a:	429a      	cmp	r2, r3
   24f2c:	d8f7      	bhi.n	24f1e <tLinearDelay_clear+0xa>
}
   24f2e:	4770      	bx	lr

00024f30 <tLinearDelay_tick>:
{
   24f30:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
   24f32:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   24f34:	edd3 7a01 	vldr	s15, [r3, #4]
   24f38:	6959      	ldr	r1, [r3, #20]
   24f3a:	689a      	ldr	r2, [r3, #8]
   24f3c:	ee27 0a80 	vmul.f32	s0, s15, s0
   24f40:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   24f44:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   24f48:	695a      	ldr	r2, [r3, #20]
   24f4a:	69d9      	ldr	r1, [r3, #28]
   24f4c:	3201      	adds	r2, #1
   24f4e:	428a      	cmp	r2, r1
   24f50:	615a      	str	r2, [r3, #20]
   24f52:	d101      	bne.n	24f58 <tLinearDelay_tick+0x28>
   24f54:	2200      	movs	r2, #0
   24f56:	615a      	str	r2, [r3, #20]
    uint32_t idx = (uint32_t) d->outPoint;
   24f58:	699a      	ldr	r2, [r3, #24]
    d->lastOut = d->buff[idx] * d->omAlpha;
   24f5a:	6898      	ldr	r0, [r3, #8]
    if ((idx + 1) < d->maxDelay)
   24f5c:	1c54      	adds	r4, r2, #1
    d->lastOut = d->buff[idx] * d->omAlpha;
   24f5e:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
   24f62:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   24f66:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    if ((idx + 1) < d->maxDelay)
   24f6a:	42a1      	cmp	r1, r4
    d->lastOut = d->buff[idx] * d->omAlpha;
   24f6c:	ed92 0a00 	vldr	s0, [r2]
   24f70:	ee20 0a07 	vmul.f32	s0, s0, s14
   24f74:	ed83 0a03 	vstr	s0, [r3, #12]
    if ((idx + 1) < d->maxDelay)
   24f78:	d909      	bls.n	24f8e <tLinearDelay_tick+0x5e>
        d->lastOut += d->buff[idx+1] * d->alpha;
   24f7a:	ed92 7a01 	vldr	s14, [r2, #4]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24f7e:	619c      	str	r4, [r3, #24]
        d->lastOut += d->buff[idx+1] * d->alpha;
   24f80:	eea7 0a27 	vfma.f32	s0, s14, s15
   24f84:	ed83 0a03 	vstr	s0, [r3, #12]
}
   24f88:	f85d 4b04 	ldr.w	r4, [sp], #4
   24f8c:	4770      	bx	lr
        d->lastOut += d->buff[0] * d->alpha;
   24f8e:	ed90 7a00 	vldr	s14, [r0]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24f92:	2200      	movs	r2, #0
        d->lastOut += d->buff[0] * d->alpha;
   24f94:	eea7 0a27 	vfma.f32	s0, s14, s15
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24f98:	619a      	str	r2, [r3, #24]
        d->lastOut += d->buff[0] * d->alpha;
   24f9a:	ed83 0a03 	vstr	s0, [r3, #12]
}
   24f9e:	f85d 4b04 	ldr.w	r4, [sp], #4
   24fa2:	4770      	bx	lr

00024fa4 <tLinearDelay_tickIn>:
    _tLinearDelay* d = *dl;
   24fa4:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   24fa6:	edd3 7a01 	vldr	s15, [r3, #4]
   24faa:	6959      	ldr	r1, [r3, #20]
   24fac:	689a      	ldr	r2, [r3, #8]
   24fae:	ee27 0a80 	vmul.f32	s0, s15, s0
   24fb2:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   24fb6:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   24fba:	695a      	ldr	r2, [r3, #20]
   24fbc:	69d9      	ldr	r1, [r3, #28]
   24fbe:	3201      	adds	r2, #1
   24fc0:	428a      	cmp	r2, r1
   24fc2:	615a      	str	r2, [r3, #20]
   24fc4:	d101      	bne.n	24fca <tLinearDelay_tickIn+0x26>
   24fc6:	2200      	movs	r2, #0
   24fc8:	615a      	str	r2, [r3, #20]
}
   24fca:	4770      	bx	lr

00024fcc <tLinearDelay_tickOut>:
{
   24fcc:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
   24fce:	6803      	ldr	r3, [r0, #0]
	uint32_t idx = (uint32_t) d->outPoint;
   24fd0:	699a      	ldr	r2, [r3, #24]
	d->lastOut = d->buff[idx] * d->omAlpha;
   24fd2:	6899      	ldr	r1, [r3, #8]
	if ((idx + 1) < d->maxDelay)
   24fd4:	1c50      	adds	r0, r2, #1
	d->lastOut = d->buff[idx] * d->omAlpha;
   24fd6:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
   24fda:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	if ((idx + 1) < d->maxDelay)
   24fde:	69dc      	ldr	r4, [r3, #28]
   24fe0:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
	d->lastOut = d->buff[idx] * d->omAlpha;
   24fe4:	ed92 0a00 	vldr	s0, [r2]
	if ((idx + 1) < d->maxDelay)
   24fe8:	42a0      	cmp	r0, r4
	d->lastOut = d->buff[idx] * d->omAlpha;
   24fea:	ee20 0a07 	vmul.f32	s0, s0, s14
   24fee:	ed83 0a03 	vstr	s0, [r3, #12]
	if ((idx + 1) < d->maxDelay)
   24ff2:	d209      	bcs.n	25008 <tLinearDelay_tickOut+0x3c>
		d->lastOut += d->buff[idx+1] * d->alpha;
   24ff4:	ed92 7a01 	vldr	s14, [r2, #4]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   24ff8:	6198      	str	r0, [r3, #24]
		d->lastOut += d->buff[idx+1] * d->alpha;
   24ffa:	eea7 0a27 	vfma.f32	s0, s14, s15
   24ffe:	ed83 0a03 	vstr	s0, [r3, #12]
}
   25002:	f85d 4b04 	ldr.w	r4, [sp], #4
   25006:	4770      	bx	lr
		d->lastOut += d->buff[0] * d->alpha;
   25008:	ed91 7a00 	vldr	s14, [r1]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   2500c:	2200      	movs	r2, #0
		d->lastOut += d->buff[0] * d->alpha;
   2500e:	eea7 0a27 	vfma.f32	s0, s14, s15
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
   25012:	619a      	str	r2, [r3, #24]
		d->lastOut += d->buff[0] * d->alpha;
   25014:	ed83 0a03 	vstr	s0, [r3, #12]
}
   25018:	f85d 4b04 	ldr.w	r4, [sp], #4
   2501c:	4770      	bx	lr
   2501e:	bf00      	nop

00025020 <tLinearDelay_setDelay>:
{
   25020:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
   25022:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   25024:	eef0 0a40 	vmov.f32	s1, s0
   25028:	ed9f 0a1c 	vldr	s0, [pc, #112]	; 2509c <tLinearDelay_setDelay+0x7c>
   2502c:	edd4 7a07 	vldr	s15, [r4, #28]
   25030:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   25034:	f004 fc28 	bl	29888 <LEAF_clip>
    float outPointer = d->inPoint - d->delay;
   25038:	edd4 7a05 	vldr	s15, [r4, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
   2503c:	ed84 0a08 	vstr	s0, [r4, #32]
    float outPointer = d->inPoint - d->delay;
   25040:	eef8 7a67 	vcvt.f32.u32	s15, s15
        outPointer += d->maxDelay; // modulo maximum length
   25044:	69e2      	ldr	r2, [r4, #28]
    float outPointer = d->inPoint - d->delay;
   25046:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
   2504a:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2504e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25052:	d50a      	bpl.n	2506a <tLinearDelay_setDelay+0x4a>
        outPointer += d->maxDelay; // modulo maximum length
   25054:	ee07 2a90 	vmov	s15, r2
   25058:	eef8 7a67 	vcvt.f32.u32	s15, s15
   2505c:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
   25060:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   25064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25068:	d4f8      	bmi.n	2505c <tLinearDelay_setDelay+0x3c>
    d->outPoint = (uint32_t) outPointer;   // integer part
   2506a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   2506e:	ee17 3a90 	vmov	r3, s15
    d->omAlpha = 1.0f - d->alpha;
   25072:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
   25076:	ee07 3a10 	vmov	s14, r3
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   2507a:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
   2507c:	61a3      	str	r3, [r4, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
   2507e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   25082:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
   25086:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
   2508a:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
   2508e:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
   25092:	d101      	bne.n	25098 <tLinearDelay_setDelay+0x78>
   25094:	2300      	movs	r3, #0
   25096:	61a3      	str	r3, [r4, #24]

    return 0;
}
   25098:	2000      	movs	r0, #0
   2509a:	bd10      	pop	{r4, pc}
   2509c:	00000000 	.word	0x00000000

000250a0 <tLinearDelay_getDelay>:
}

float   tLinearDelay_getDelay (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->delay;
   250a0:	6803      	ldr	r3, [r0, #0]
}
   250a2:	ed93 0a08 	vldr	s0, [r3, #32]
   250a6:	4770      	bx	lr

000250a8 <tLinearDelay_getLastOut>:

float   tLinearDelay_getLastOut (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->lastOut;
   250a8:	6803      	ldr	r3, [r0, #0]
}
   250aa:	ed93 0a03 	vldr	s0, [r3, #12]
   250ae:	4770      	bx	lr

000250b0 <tTapeDelay_init>:
    return d->gain;
}

// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ TapeDelay ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ //
void tTapeDelay_init (tTapeDelay* const dl, float delay, uint32_t maxDelay)
{
   250b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tTapeDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tTapeDelay_initToPool (tTapeDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
    _tMempool* m = *mp;
   250b2:	4b18      	ldr	r3, [pc, #96]	; (25114 <tTapeDelay_init+0x64>)
{
   250b4:	4606      	mov	r6, r0
   250b6:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   250b8:	202c      	movs	r0, #44	; 0x2c
{
   250ba:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   250be:	699d      	ldr	r5, [r3, #24]
{
   250c0:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   250c4:	4629      	mov	r1, r5
   250c6:	f004 fddf 	bl	29c88 <mpool_alloc>
   250ca:	4604      	mov	r4, r0
    d->mempool = m;

    d->maxDelay = maxDelay;

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   250cc:	4629      	mov	r1, r5
   250ce:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   250d0:	6034      	str	r4, [r6, #0]
    d->mempool = m;
   250d2:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
   250d4:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   250d6:	f004 fdd7 	bl	29c88 <mpool_alloc>

    d->gain = 1.0f;
   250da:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

    d->lastIn = 0.0f;
   250de:	2300      	movs	r3, #0
    d->lastOut = 0.0f;

    d->idx = 0.0f;
    d->inc = 1.0f;
    d->inPoint = 0;
   250e0:	2200      	movs	r2, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   250e2:	60a0      	str	r0, [r4, #8]
}

void     tTapeDelay_setDelay (tTapeDelay* const dl, float delay)
{
    _tTapeDelay* d = *dl;
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   250e4:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
   250e8:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   250ec:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
   250f0:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
   250f4:	6162      	str	r2, [r4, #20]
    d->lastIn = 0.0f;
   250f6:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   250f8:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
   250fa:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
   250fc:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   250fe:	edd4 7a06 	vldr	s15, [r4, #24]
   25102:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   25106:	f004 fbbf 	bl	29888 <LEAF_clip>
   2510a:	ed84 0a07 	vstr	s0, [r4, #28]
}
   2510e:	ecbd 8b02 	vpop	{d8}
   25112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   25114:	020fc0a8 	.word	0x020fc0a8

00025118 <tTapeDelay_initToPool>:
{
   25118:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2511a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2511e:	6815      	ldr	r5, [r2, #0]
{
   25120:	4606      	mov	r6, r0
   25122:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   25124:	202c      	movs	r0, #44	; 0x2c
   25126:	4629      	mov	r1, r5
{
   25128:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   2512c:	f004 fdac 	bl	29c88 <mpool_alloc>
   25130:	4604      	mov	r4, r0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   25132:	4629      	mov	r1, r5
   25134:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
   25136:	6034      	str	r4, [r6, #0]
    d->mempool = m;
   25138:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
   2513a:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   2513c:	f004 fda4 	bl	29c88 <mpool_alloc>
    d->gain = 1.0f;
   25140:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->lastIn = 0.0f;
   25144:	2300      	movs	r3, #0
    d->inPoint = 0;
   25146:	2200      	movs	r2, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
   25148:	60a0      	str	r0, [r4, #8]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   2514a:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
   2514e:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   25152:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
   25156:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
   2515a:	6162      	str	r2, [r4, #20]
    d->lastIn = 0.0f;
   2515c:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
   2515e:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
   25160:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
   25162:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   25164:	edd4 7a06 	vldr	s15, [r4, #24]
   25168:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   2516c:	f004 fb8c 	bl	29888 <LEAF_clip>
   25170:	ed84 0a07 	vstr	s0, [r4, #28]
}
   25174:	ecbd 8b02 	vpop	{d8}
   25178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2517a:	bf00      	nop

0002517c <tTapeDelay_free>:
{
   2517c:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
   2517e:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
   25180:	6821      	ldr	r1, [r4, #0]
   25182:	68a0      	ldr	r0, [r4, #8]
   25184:	f004 fe28 	bl	29dd8 <mpool_free>
    mpool_free((char*)d, d->mempool);
   25188:	6821      	ldr	r1, [r4, #0]
   2518a:	4620      	mov	r0, r4
}
   2518c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
   25190:	f004 be22 	b.w	29dd8 <mpool_free>

00025194 <tTapeDelay_tick>:
{
   25194:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tTapeDelay* d = *dl;
   25196:	6804      	ldr	r4, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
   25198:	edd4 7a01 	vldr	s15, [r4, #4]
   2519c:	6962      	ldr	r2, [r4, #20]
   2519e:	68a3      	ldr	r3, [r4, #8]
   251a0:	ee27 0a80 	vmul.f32	s0, s15, s0
   251a4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   251a8:	ed83 0a00 	vstr	s0, [r3]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
   251ac:	e9d4 2305 	ldrd	r2, r3, [r4, #20]
   251b0:	3201      	adds	r2, #1
   251b2:	429a      	cmp	r2, r3
   251b4:	6162      	str	r2, [r4, #20]
   251b6:	d101      	bne.n	251bc <tTapeDelay_tick+0x28>
   251b8:	2200      	movs	r2, #0
   251ba:	6162      	str	r2, [r4, #20]
    int idx =  (int) d->idx;
   251bc:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251c0:	1e5e      	subs	r6, r3, #1
   251c2:	68a1      	ldr	r1, [r4, #8]
    int idx =  (int) d->idx;
   251c4:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   251c8:	ee17 2a10 	vmov	r2, s14
    float alpha = d->idx - idx;
   251cc:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[(idx + 1) % d->maxDelay],
   251d0:	1c57      	adds	r7, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
   251d2:	f102 0c02 	add.w	ip, r2, #2
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251d6:	4416      	add	r6, r2
   251d8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   251dc:	ee37 2ac2 	vsub.f32	s4, s15, s4
   251e0:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
   251e4:	fbb7 f0f3 	udiv	r0, r7, r3
   251e8:	fb03 7010 	mls	r0, r3, r0, r7
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251ec:	eb01 0280 	add.w	r2, r1, r0, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
   251f0:	fbbc f5f3 	udiv	r5, ip, r3
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251f4:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
   251f8:	fb03 c515 	mls	r5, r3, r5, ip
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   251fc:	fbb6 f2f3 	udiv	r2, r6, r3
   25200:	fb03 6312 	mls	r3, r3, r2, r6
   25204:	eb01 0585 	add.w	r5, r1, r5, lsl #2
   25208:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   2520c:	edd5 1a00 	vldr	s3, [r5]
   25210:	ed91 0a00 	vldr	s0, [r1]
   25214:	f004 fc50 	bl	29ab8 <LEAF_interpolate_hermite_x>
    float diff = (d->inPoint - d->idx);
   25218:	edd4 7a05 	vldr	s15, [r4, #20]
   2521c:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
   25220:	eef8 7a67 	vcvt.f32.u32	s15, s15
    while (diff < 0.f) diff += d->maxDelay;
   25224:	ed94 7a06 	vldr	s14, [r4, #24]
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   25228:	ed84 0a03 	vstr	s0, [r4, #12]
    while (diff < 0.f) diff += d->maxDelay;
   2522c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    float diff = (d->inPoint - d->idx);
   25230:	ee77 7ae6 	vsub.f32	s15, s15, s13
    while (diff < 0.f) diff += d->maxDelay;
   25234:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   25238:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2523c:	d506      	bpl.n	2524c <tTapeDelay_tick+0xb8>
   2523e:	ee77 7a87 	vadd.f32	s15, s15, s14
   25242:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   25246:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2524a:	d4f8      	bmi.n	2523e <tTapeDelay_tick+0xaa>
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
   2524c:	edd4 5a07 	vldr	s11, [r4, #28]
   25250:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
   25254:	ee77 7ae5 	vsub.f32	s15, s15, s11
   25258:	ee87 6aa5 	vdiv.f32	s12, s15, s11
   2525c:	ee76 7a05 	vadd.f32	s15, s12, s10
    d->idx += d->inc;
   25260:	ee76 6aa7 	vadd.f32	s13, s13, s15
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
   25264:	edc4 7a08 	vstr	s15, [r4, #32]
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
   25268:	eef4 6ac7 	vcmpe.f32	s13, s14
   2526c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25270:	da02      	bge.n	25278 <tTapeDelay_tick+0xe4>
    d->idx += d->inc;
   25272:	edc4 6a09 	vstr	s13, [r4, #36]	; 0x24
}
   25276:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
   25278:	2300      	movs	r3, #0
   2527a:	6263      	str	r3, [r4, #36]	; 0x24
}
   2527c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2527e:	bf00      	nop

00025280 <tTapeDelay_setDelay>:
{
   25280:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
   25282:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
   25284:	eef0 0a40 	vmov.f32	s1, s0
   25288:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2528c:	edd4 7a06 	vldr	s15, [r4, #24]
   25290:	eeb8 1a67 	vcvt.f32.u32	s2, s15
   25294:	f004 faf8 	bl	29888 <LEAF_clip>
   25298:	ed84 0a07 	vstr	s0, [r4, #28]
}
   2529c:	bd10      	pop	{r4, pc}
   2529e:	bf00      	nop

000252a0 <tTapeDelay_tapOut>:

float tTapeDelay_tapOut (tTapeDelay* const dl, float tapDelay)
{
   252a0:	b4f0      	push	{r4, r5, r6, r7}
    _tTapeDelay* d = *dl;
   252a2:	6801      	ldr	r1, [r0, #0]

    float tap = (float) d->inPoint - tapDelay - 1.f;
   252a4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   252a8:	edd1 7a05 	vldr	s15, [r1, #20]
   252ac:	698b      	ldr	r3, [r1, #24]
   252ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
   252b2:	ee37 0ac0 	vsub.f32	s0, s15, s0

    // Check for wraparound.
    while ( tap < 0.f )   tap += (float)d->maxDelay;
   252b6:	eeb4 0ac7 	vcmpe.f32	s0, s14
    float tap = (float) d->inPoint - tapDelay - 1.f;
   252ba:	ee70 7a47 	vsub.f32	s15, s0, s14
    while ( tap < 0.f )   tap += (float)d->maxDelay;
   252be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   252c2:	d50a      	bpl.n	252da <tTapeDelay_tapOut+0x3a>
   252c4:	ee07 3a10 	vmov	s14, r3
   252c8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   252cc:	ee77 7a87 	vadd.f32	s15, s15, s14
   252d0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   252d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   252d8:	d4f8      	bmi.n	252cc <tTapeDelay_tapOut+0x2c>

    int idx =  (int) tap;
   252da:	eebd 7ae7 	vcvt.s32.f32	s14, s15

    float alpha = tap - idx;

    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   252de:	6889      	ldr	r1, [r1, #8]
   252e0:	1e5d      	subs	r5, r3, #1
    int idx =  (int) tap;
   252e2:	ee17 2a10 	vmov	r2, s14
    float alpha = tap - idx;
   252e6:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[idx],
                                              d->buff[(idx + 1) % d->maxDelay],
   252ea:	1c56      	adds	r6, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
   252ec:	1c97      	adds	r7, r2, #2
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   252ee:	4415      	add	r5, r2
   252f0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   252f4:	ee37 2ac2 	vsub.f32	s4, s15, s4
   252f8:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
   252fc:	fbb6 f0f3 	udiv	r0, r6, r3
   25300:	fb03 6210 	mls	r2, r3, r0, r6
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   25304:	eb01 0282 	add.w	r2, r1, r2, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
   25308:	fbb7 f4f3 	udiv	r4, r7, r3
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2530c:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
   25310:	fb03 7414 	mls	r4, r3, r4, r7
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   25314:	fbb5 f2f3 	udiv	r2, r5, r3
   25318:	fb03 5312 	mls	r3, r3, r2, r5
   2531c:	eb01 0084 	add.w	r0, r1, r4, lsl #2
   25320:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   25324:	edd0 1a00 	vldr	s3, [r0]
   25328:	ed91 0a00 	vldr	s0, [r1]
                                              alpha);

    return samp;

}
   2532c:	bcf0      	pop	{r4, r5, r6, r7}
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
   2532e:	f004 bbc3 	b.w	29ab8 <LEAF_interpolate_hermite_x>
   25332:	bf00      	nop

00025334 <tOversampler_initToPool>:
{
    tOversampler_initToPool(osr, ratio, extraQuality, &leaf.mempool);
}

void tOversampler_initToPool (tOversampler* const osr, int ratio, int extraQuality, tMempool* const mp)
{
   25334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
   25338:	681e      	ldr	r6, [r3, #0]
{
   2533a:	4617      	mov	r7, r2
   2533c:	460d      	mov	r5, r1
   2533e:	4680      	mov	r8, r0
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   25340:	4631      	mov	r1, r6
   25342:	201c      	movs	r0, #28
   25344:	f004 fca0 	bl	29c88 <mpool_alloc>
   25348:	2f00      	cmp	r7, #0
    os->mempool = m;
    
    uint8_t offset = 0;
    if (extraQuality) offset = 6;
    if (ratio == 2 || ratio == 4  ||
   2534a:	f1a5 0202 	sub.w	r2, r5, #2
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
   2534e:	f8c8 0000 	str.w	r0, [r8]
   25352:	bf18      	it	ne
   25354:	2706      	movne	r7, #6
   25356:	4604      	mov	r4, r0
    if (ratio == 2 || ratio == 4  ||
   25358:	2a1e      	cmp	r2, #30
    os->mempool = m;
   2535a:	6006      	str	r6, [r0, #0]
    if (ratio == 2 || ratio == 4  ||
   2535c:	d92d      	bls.n	253ba <tOversampler_initToPool+0x86>
        ratio == 8 || ratio == 16 ||
        ratio == 32 || ratio == 64) {
   2535e:	2d40      	cmp	r5, #64	; 0x40
   25360:	d129      	bne.n	253b6 <tOversampler_initToPool+0x82>
        os->ratio = ratio;
        int idx = (int)(log2f(os->ratio))-1+offset;
   25362:	ee07 5a90 	vmov	s15, r5
        os->ratio = ratio;
   25366:	6065      	str	r5, [r4, #4]
        int idx = (int)(log2f(os->ratio))-1+offset;
   25368:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   2536c:	f007 fdc0 	bl	2cef0 <log2f>
   25370:	eebd 0ac0 	vcvt.s32.f32	s0, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   25374:	4814      	ldr	r0, [pc, #80]	; (253c8 <tOversampler_initToPool+0x94>)
        os->phaseLength = os->numTaps / os->ratio;
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   25376:	4631      	mov	r1, r6
        int idx = (int)(log2f(os->ratio))-1+offset;
   25378:	ee10 3a10 	vmov	r3, s0
   2537c:	3b01      	subs	r3, #1
   2537e:	19da      	adds	r2, r3, r7
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   25380:	4f12      	ldr	r7, [pc, #72]	; (253cc <tOversampler_initToPool+0x98>)
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
   25382:	eb00 0382 	add.w	r3, r0, r2, lsl #2
   25386:	edd3 7a00 	vldr	s15, [r3]
   2538a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2538e:	ee17 0a90 	vmov	r0, s15
   25392:	edc4 7a05 	vstr	s15, [r4, #20]
        os->phaseLength = os->numTaps / os->ratio;
   25396:	fb90 f5f5 	sdiv	r5, r0, r5
   2539a:	61a5      	str	r5, [r4, #24]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   2539c:	00c0      	lsls	r0, r0, #3
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
   2539e:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   253a2:	60a3      	str	r3, [r4, #8]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   253a4:	f004 fc70 	bl	29c88 <mpool_alloc>
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   253a8:	6963      	ldr	r3, [r4, #20]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   253aa:	60e0      	str	r0, [r4, #12]
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
   253ac:	4631      	mov	r1, r6
   253ae:	00d8      	lsls	r0, r3, #3
   253b0:	f004 fc6a 	bl	29c88 <mpool_alloc>
   253b4:	6120      	str	r0, [r4, #16]
    }
}
   253b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (ratio == 2 || ratio == 4  ||
   253ba:	4b05      	ldr	r3, [pc, #20]	; (253d0 <tOversampler_initToPool+0x9c>)
   253bc:	40d3      	lsrs	r3, r2
   253be:	07db      	lsls	r3, r3, #31
   253c0:	d4cf      	bmi.n	25362 <tOversampler_initToPool+0x2e>
}
   253c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   253c6:	bf00      	nop
   253c8:	00051e9c 	.word	0x00051e9c
   253cc:	00062c48 	.word	0x00062c48
   253d0:	40004045 	.word	0x40004045

000253d4 <tOversampler_free>:

void tOversampler_free (tOversampler* const osr)
{
   253d4:	b510      	push	{r4, lr}
    _tOversampler* os = *osr;
   253d6:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)os->upState, os->mempool);
   253d8:	6821      	ldr	r1, [r4, #0]
   253da:	68e0      	ldr	r0, [r4, #12]
   253dc:	f004 fcfc 	bl	29dd8 <mpool_free>
    mpool_free((char*)os->downState, os->mempool);
   253e0:	6821      	ldr	r1, [r4, #0]
   253e2:	6920      	ldr	r0, [r4, #16]
   253e4:	f004 fcf8 	bl	29dd8 <mpool_free>
    mpool_free((char*)os, os->mempool);
   253e8:	6821      	ldr	r1, [r4, #0]
   253ea:	4620      	mov	r0, r4
}
   253ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)os, os->mempool);
   253f0:	f004 bcf2 	b.w	29dd8 <mpool_free>

000253f4 <tOversampler_tick>:

float tOversampler_tick(tOversampler* const osr, float input, float* oversample, float (*effectTick)(float))
{
   253f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tOversampler* os = *osr;
   253f8:	f8d0 9000 	ldr.w	r9, [r0]
{
   253fc:	4680      	mov	r8, r0
   253fe:	468a      	mov	sl, r1
   25400:	4617      	mov	r7, r2
// From CMSIS DSP Library
void tOversampler_upsample(tOversampler* const osr, float input, float* output)
{
    _tOversampler* os = *osr;
    
    float *pState = os->upState;                 /* State pointer */
   25402:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float *pStateCur;
    float *ptr1;                               /* Temporary pointer for state buffer */
    float *ptr2;                               /* Temporary pointer for coefficient buffer */
    float sum0;                                /* Accumulators */
    uint32_t i, tapCnt;                    /* Loop counters */
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
   25406:	f8d9 5018 	ldr.w	r5, [r9, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
   2540a:	f8d9 e008 	ldr.w	lr, [r9, #8]
    /* os->pState buffer contains previous frame (phaseLen - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->upState + (phaseLen - 1U);
    
    /* Copy new input sample into the state buffer */
    *pStateCur = input;
   2540e:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
   25412:	ed03 0a01 	vstr	s0, [r3, #-4]
    
    /* Address modifier index of coefficient buffer */
    j = 1U;
    
    /* Loop over the Interpolation factor. */
    i = os->ratio;
   25416:	f8d9 4004 	ldr.w	r4, [r9, #4]
    
    while (i > 0U)
   2541a:	b32c      	cbz	r4, 25468 <tOversampler_tick+0x74>
   2541c:	f104 0b01 	add.w	fp, r4, #1
    j = 1U;
   25420:	2601      	movs	r6, #1
         Repeat until we've computed numTaps-(4*os->L) coefficients. */
        
        /* Initialize tapCnt with number of samples */
        tapCnt = phaseLen;
        
        while (tapCnt > 0U)
   25422:	eddf 5a38 	vldr	s11, [pc, #224]	; 25504 <tOversampler_tick+0x110>
        ptr2 = pCoeffs + (os->ratio - j);
   25426:	1ba3      	subs	r3, r4, r6
   25428:	ee07 4a90 	vmov	s15, r4
   2542c:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
   25430:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
   25434:	2d00      	cmp	r5, #0
   25436:	d061      	beq.n	254fc <tOversampler_tick+0x108>
            sum0 += *ptr1++ * *ptr2;
            
            /* Upsampling is done by stuffing L-1 zeros between each sample.
             * So instead of multiplying zeros with coefficients,
             * Increment the coefficient pointer by interpolation factor times. */
            ptr2 += os->ratio;
   25438:	00a4      	lsls	r4, r4, #2
   2543a:	462a      	mov	r2, r5
        ptr1 = pState;
   2543c:	4660      	mov	r0, ip
        sum0 = 0.0f;
   2543e:	eddf 7a31 	vldr	s15, [pc, #196]	; 25504 <tOversampler_tick+0x110>
            sum0 += *ptr1++ * *ptr2;
   25442:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
   25446:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
   25448:	ecf0 6a01 	vldmia	r0!, {s13}
            ptr2 += os->ratio;
   2544c:	4423      	add	r3, r4
            sum0 += *ptr1++ * *ptr2;
   2544e:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
   25452:	d1f6      	bne.n	25442 <tOversampler_tick+0x4e>
   25454:	ee67 7a86 	vmul.f32	s15, s15, s12
        
        /* The result is in the accumulator, store in the destination buffer. */
        *output++ = sum0 * os->ratio;
        
        /* Increment the address modifier index of coefficient buffer */
        j++;
   25458:	3601      	adds	r6, #1
        *output++ = sum0 * os->ratio;
   2545a:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
   2545e:	455e      	cmp	r6, fp
   25460:	d002      	beq.n	25468 <tOversampler_tick+0x74>
   25462:	f8d9 4004 	ldr.w	r4, [r9, #4]
   25466:	e7de      	b.n	25426 <tOversampler_tick+0x32>
    
    /* Initialize tapCnt with number of samples */
    tapCnt = (phaseLen - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
   25468:	3d01      	subs	r5, #1
    pState = pState + 1;
   2546a:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
   2546e:	f8d9 300c 	ldr.w	r3, [r9, #12]
    while (tapCnt > 0U)
   25472:	d005      	beq.n	25480 <tOversampler_tick+0x8c>
    {
        *pStateCur++ = *pState++;
   25474:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
   25478:	3d01      	subs	r5, #1
        *pStateCur++ = *pState++;
   2547a:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
   2547e:	d1f9      	bne.n	25474 <tOversampler_tick+0x80>
    for (int i = 0; i < os->ratio; ++i) {
   25480:	f8d9 3004 	ldr.w	r3, [r9, #4]
   25484:	2b00      	cmp	r3, #0
   25486:	dd0b      	ble.n	254a0 <tOversampler_tick+0xac>
   25488:	4655      	mov	r5, sl
   2548a:	2400      	movs	r4, #0
        oversample[i] = effectTick(oversample[i]);
   2548c:	ed95 0a00 	vldr	s0, [r5]
    for (int i = 0; i < os->ratio; ++i) {
   25490:	3401      	adds	r4, #1
        oversample[i] = effectTick(oversample[i]);
   25492:	47b8      	blx	r7
   25494:	eca5 0a01 	vstmia	r5!, {s0}
    for (int i = 0; i < os->ratio; ++i) {
   25498:	f8d9 3004 	ldr.w	r3, [r9, #4]
   2549c:	42a3      	cmp	r3, r4
   2549e:	dcf5      	bgt.n	2548c <tOversampler_tick+0x98>
}

// From CMSIS DSP Library
float tOversampler_downsample(tOversampler *const osr, float* input)
{
    _tOversampler* os = *osr;
   254a0:	f8d8 4000 	ldr.w	r4, [r8]
    uint32_t i, tapCnt;
    float output;
    
    /* os->pState buffer contains previous frame (numTaps - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->downState + (numTaps - 1U);
   254a4:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float *pState = os->downState;                 /* State pointer */
   254a8:	e9d4 0604 	ldrd	r0, r6, [r4, #16]
    
    /* Copy decimation factor number of new input samples into the state buffer */
    i = os->ratio;
   254ac:	e9d4 3501 	ldrd	r3, r5, [r4, #4]
    pStateCur = os->downState + (numTaps - 1U);
   254b0:	4432      	add	r2, r6
   254b2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    
    do
    {
        *pStateCur++ = *input++;
   254b6:	f85a 1b04 	ldr.w	r1, [sl], #4
        
    } while (--i);
   254ba:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
   254bc:	f842 1b04 	str.w	r1, [r2], #4
    } while (--i);
   254c0:	d1f9      	bne.n	254b6 <tOversampler_tick+0xc2>
   254c2:	6861      	ldr	r1, [r4, #4]
   254c4:	1e73      	subs	r3, r6, #1
   254c6:	6924      	ldr	r4, [r4, #16]
   254c8:	461a      	mov	r2, r3
   254ca:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    
    /* Set accumulator to zero */
    acc0 = 0.0f;
   254ce:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 25504 <tOversampler_tick+0x110>
    pb = pCoeffs;
    
    /* Initialize tapCnt with number of taps */
    tapCnt = numTaps;
    
    while (tapCnt > 0U)
   254d2:	b90e      	cbnz	r6, 254d8 <tOversampler_tick+0xe4>
   254d4:	e009      	b.n	254ea <tOversampler_tick+0xf6>
   254d6:	3a01      	subs	r2, #1
        
        /* Fetch 1 state variable */
        x0 = *px0++;
        
        /* Perform the multiply-accumulate */
        acc0 += x0 * c0;
   254d8:	ecb5 7a01 	vldmia	r5!, {s14}
   254dc:	ecf0 7a01 	vldmia	r0!, {s15}
   254e0:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
   254e4:	2a00      	cmp	r2, #0
   254e6:	d1f6      	bne.n	254d6 <tOversampler_tick+0xe2>
    
    /* Initialize tapCnt with number of taps */
    tapCnt = (numTaps - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
   254e8:	b133      	cbz	r3, 254f8 <tOversampler_tick+0x104>
   254ea:	4622      	mov	r2, r4
    {
        *pStateCur++ = *pState++;
   254ec:	f851 0b04 	ldr.w	r0, [r1], #4
    while (tapCnt > 0U)
   254f0:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   254f2:	f842 0b04 	str.w	r0, [r2], #4
    while (tapCnt > 0U)
   254f6:	d1f9      	bne.n	254ec <tOversampler_tick+0xf8>
}
   254f8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (tapCnt > 0U)
   254fc:	eef0 7a65 	vmov.f32	s15, s11
   25500:	e7aa      	b.n	25458 <tOversampler_tick+0x64>
   25502:	bf00      	nop
   25504:	00000000 	.word	0x00000000

00025508 <tOversampler_upsample>:
{
   25508:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tOversampler* os = *osr;
   2550c:	f8d0 c000 	ldr.w	ip, [r0]
    float *pState = os->upState;                 /* State pointer */
   25510:	f8dc 700c 	ldr.w	r7, [ip, #12]
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
   25514:	f8dc 5018 	ldr.w	r5, [ip, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
   25518:	f8dc e008 	ldr.w	lr, [ip, #8]
    *pStateCur = input;
   2551c:	eb07 0385 	add.w	r3, r7, r5, lsl #2
   25520:	ed03 0a01 	vstr	s0, [r3, #-4]
    i = os->ratio;
   25524:	f8dc 4004 	ldr.w	r4, [ip, #4]
    while (i > 0U)
   25528:	b324      	cbz	r4, 25574 <tOversampler_upsample+0x6c>
   2552a:	f104 0801 	add.w	r8, r4, #1
    j = 1U;
   2552e:	2601      	movs	r6, #1
        while (tapCnt > 0U)
   25530:	eddf 5a19 	vldr	s11, [pc, #100]	; 25598 <tOversampler_upsample+0x90>
        ptr2 = pCoeffs + (os->ratio - j);
   25534:	1ba3      	subs	r3, r4, r6
   25536:	ee07 4a90 	vmov	s15, r4
   2553a:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
   2553e:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
   25542:	b32d      	cbz	r5, 25590 <tOversampler_upsample+0x88>
            ptr2 += os->ratio;
   25544:	00a4      	lsls	r4, r4, #2
   25546:	462a      	mov	r2, r5
        ptr1 = pState;
   25548:	4638      	mov	r0, r7
        sum0 = 0.0f;
   2554a:	eddf 7a13 	vldr	s15, [pc, #76]	; 25598 <tOversampler_upsample+0x90>
            sum0 += *ptr1++ * *ptr2;
   2554e:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
   25552:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
   25554:	ecf0 6a01 	vldmia	r0!, {s13}
            ptr2 += os->ratio;
   25558:	4423      	add	r3, r4
            sum0 += *ptr1++ * *ptr2;
   2555a:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
   2555e:	d1f6      	bne.n	2554e <tOversampler_upsample+0x46>
   25560:	ee67 7a86 	vmul.f32	s15, s15, s12
        j++;
   25564:	3601      	adds	r6, #1
        *output++ = sum0 * os->ratio;
   25566:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
   2556a:	4546      	cmp	r6, r8
   2556c:	d002      	beq.n	25574 <tOversampler_upsample+0x6c>
   2556e:	f8dc 4004 	ldr.w	r4, [ip, #4]
   25572:	e7df      	b.n	25534 <tOversampler_upsample+0x2c>
    while (tapCnt > 0U)
   25574:	1e6b      	subs	r3, r5, #1
    pState = pState + 1;
   25576:	f107 0204 	add.w	r2, r7, #4
    pStateCur = os->upState;
   2557a:	f8dc 100c 	ldr.w	r1, [ip, #12]
    while (tapCnt > 0U)
   2557e:	d005      	beq.n	2558c <tOversampler_upsample+0x84>
        *pStateCur++ = *pState++;
   25580:	f852 0b04 	ldr.w	r0, [r2], #4
    while (tapCnt > 0U)
   25584:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   25586:	f841 0b04 	str.w	r0, [r1], #4
    while (tapCnt > 0U)
   2558a:	d1f9      	bne.n	25580 <tOversampler_upsample+0x78>
}
   2558c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (tapCnt > 0U)
   25590:	eef0 7a65 	vmov.f32	s15, s11
   25594:	e7e6      	b.n	25564 <tOversampler_upsample+0x5c>
   25596:	bf00      	nop
   25598:	00000000 	.word	0x00000000

0002559c <tOversampler_downsample>:
{
   2559c:	b4f0      	push	{r4, r5, r6, r7}
    _tOversampler* os = *osr;
   2559e:	6806      	ldr	r6, [r0, #0]
    pStateCur = os->downState + (numTaps - 1U);
   255a0:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    float *pState = os->downState;                 /* State pointer */
   255a4:	e9d6 0704 	ldrd	r0, r7, [r6, #16]
    i = os->ratio;
   255a8:	e9d6 3501 	ldrd	r3, r5, [r6, #4]
    pStateCur = os->downState + (numTaps - 1U);
   255ac:	443a      	add	r2, r7
   255ae:	eb00 0282 	add.w	r2, r0, r2, lsl #2
        *pStateCur++ = *input++;
   255b2:	f851 4b04 	ldr.w	r4, [r1], #4
    } while (--i);
   255b6:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
   255b8:	f842 4b04 	str.w	r4, [r2], #4
    } while (--i);
   255bc:	d1f9      	bne.n	255b2 <tOversampler_downsample+0x16>
   255be:	1e7b      	subs	r3, r7, #1
   255c0:	6871      	ldr	r1, [r6, #4]
   255c2:	6934      	ldr	r4, [r6, #16]
   255c4:	461a      	mov	r2, r3
   255c6:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    acc0 = 0.0f;
   255ca:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 255f8 <tOversampler_downsample+0x5c>
    while (tapCnt > 0U)
   255ce:	b90f      	cbnz	r7, 255d4 <tOversampler_downsample+0x38>
   255d0:	e009      	b.n	255e6 <tOversampler_downsample+0x4a>
   255d2:	3a01      	subs	r2, #1
        acc0 += x0 * c0;
   255d4:	ecb5 7a01 	vldmia	r5!, {s14}
   255d8:	ecf0 7a01 	vldmia	r0!, {s15}
   255dc:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
   255e0:	2a00      	cmp	r2, #0
   255e2:	d1f6      	bne.n	255d2 <tOversampler_downsample+0x36>
    while (tapCnt > 0U)
   255e4:	b133      	cbz	r3, 255f4 <tOversampler_downsample+0x58>
   255e6:	4622      	mov	r2, r4
        *pStateCur++ = *pState++;
   255e8:	f851 0b04 	ldr.w	r0, [r1], #4
    while (tapCnt > 0U)
   255ec:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
   255ee:	f842 0b04 	str.w	r0, [r2], #4
    while (tapCnt > 0U)
   255f2:	d1f9      	bne.n	255e8 <tOversampler_downsample+0x4c>
        /* Decrement loop counter */
        tapCnt--;
    }
    
    return output;
}
   255f4:	bcf0      	pop	{r4, r5, r6, r7}
   255f6:	4770      	bx	lr
	...

00025600 <tLockhartWavefolder_initToPool>:
{
	tLockhartWavefolder_initToPool   (wf,  &leaf.mempool);
}

void tLockhartWavefolder_initToPool (tLockhartWavefolder* const wf, tMempool* const mp)
{
   25600:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   25604:	680c      	ldr	r4, [r1, #0]
{
   25606:	4605      	mov	r5, r0
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   25608:	20e0      	movs	r0, #224	; 0xe0
    w->Is = 10e-16;
    
    w->a = 2.0*w->RL/w->R;
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
    w->d = (w->RL*w->Is)/w->VT;
    w->half_a = 0.5 * w->a;
   2560a:	f04f 0800 	mov.w	r8, #0
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   2560e:	4621      	mov	r1, r4
    w->half_a = 0.5 * w->a;
   25610:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 2570c <tLockhartWavefolder_initToPool+0x10c>
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   25614:	f004 fb38 	bl	29c88 <mpool_alloc>
    w->a = 2.0*w->RL/w->R;
   25618:	2200      	movs	r2, #0
   2561a:	4b3b      	ldr	r3, [pc, #236]	; (25708 <tLockhartWavefolder_initToPool+0x108>)
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
   2561c:	6028      	str	r0, [r5, #0]
    w->mempool = m;
   2561e:	6004      	str	r4, [r0, #0]
    w->a = 2.0*w->RL/w->R;
   25620:	e9c0 2310 	strd	r2, r3, [r0, #64]	; 0x40
    w->RL = 7.5e3;
   25624:	a528      	add	r5, pc, #160	; (adr r5, 256c8 <tLockhartWavefolder_initToPool+0xc8>)
   25626:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->R = 15e3;
   2562a:	a329      	add	r3, pc, #164	; (adr r3, 256d0 <tLockhartWavefolder_initToPool+0xd0>)
   2562c:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->RL = 7.5e3;
   25630:	e9c0 4508 	strd	r4, r5, [r0, #32]
    w->R = 15e3;
   25634:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    w->VT = 26e-3;
   25638:	a527      	add	r5, pc, #156	; (adr r5, 256d8 <tLockhartWavefolder_initToPool+0xd8>)
   2563a:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->Is = 10e-16;
   2563e:	a328      	add	r3, pc, #160	; (adr r3, 256e0 <tLockhartWavefolder_initToPool+0xe0>)
   25640:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->VT = 26e-3;
   25644:	e9c0 450c 	strd	r4, r5, [r0, #48]	; 0x30
    w->Is = 10e-16;
   25648:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   2564c:	a526      	add	r5, pc, #152	; (adr r5, 256e8 <tLockhartWavefolder_initToPool+0xe8>)
   2564e:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->d = (w->RL*w->Is)/w->VT;
   25652:	a327      	add	r3, pc, #156	; (adr r3, 256f0 <tLockhartWavefolder_initToPool+0xf0>)
   25654:	e9d3 2300 	ldrd	r2, r3, [r3]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
   25658:	e9c0 4512 	strd	r4, r5, [r0, #72]	; 0x48
    w->d = (w->RL*w->Is)/w->VT;
   2565c:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
    w->longthing = (0.5*w->VT/w->b);
    
    
    // Antialiasing error threshold
    w->AAthresh = 10e-10; //10
   25660:	a525      	add	r5, pc, #148	; (adr r5, 256f8 <tLockhartWavefolder_initToPool+0xf8>)
   25662:	e9d5 4500 	ldrd	r4, r5, [r5]
    w->Ln1 = 0.0;
   25666:	2200      	movs	r2, #0
   25668:	2300      	movs	r3, #0
    w->longthing = (0.5*w->VT/w->b);
   2566a:	a725      	add	r7, pc, #148	; (adr r7, 25700 <tLockhartWavefolder_initToPool+0x100>)
   2566c:	e9d7 6700 	ldrd	r6, r7, [r7]
    w->half_a = 0.5 * w->a;
   25670:	e9c0 8918 	strd	r8, r9, [r0, #96]	; 0x60
    w->longthing = (0.5*w->VT/w->b);
   25674:	e9c0 671a 	strd	r6, r7, [r0, #104]	; 0x68
    w->Ln1 = 0.0;
   25678:	e9c0 2302 	strd	r2, r3, [r0, #8]
    w->Fn1 = 0.0;
   2567c:	e9c0 2304 	strd	r2, r3, [r0, #16]
    w->xn1 = 0.0;
   25680:	e9c0 2306 	strd	r2, r3, [r0, #24]

	w->LambertThresh = 10e-10; //12  //was 8


    w->w = 0.0f;
   25684:	e9c0 231e 	strd	r2, r3, [r0, #120]	; 0x78
    w->expw = 0.0f;
   25688:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    w->p = 0.0f;
   2568c:	e9c0 2322 	strd	r2, r3, [r0, #136]	; 0x88
    w->r = 0.0f;
   25690:	e9c0 2324 	strd	r2, r3, [r0, #144]	; 0x90
    w->s= 0.0f;
   25694:	e9c0 2326 	strd	r2, r3, [r0, #152]	; 0x98
    w->myerr = 0.0f;
   25698:	e9c0 2328 	strd	r2, r3, [r0, #160]	; 0xa0
    w->l = 0.0f;
   2569c:	e9c0 232a 	strd	r2, r3, [r0, #168]	; 0xa8
    w->u = 0.0f;
   256a0:	e9c0 232c 	strd	r2, r3, [r0, #176]	; 0xb0
    w->Ln = 0.0f;
   256a4:	e9c0 232e 	strd	r2, r3, [r0, #184]	; 0xb8
	w->Fn = 0.0f;
   256a8:	e9c0 2330 	strd	r2, r3, [r0, #192]	; 0xc0
    w->tempsDenom = 0.0f;
   256ac:	e9c0 2332 	strd	r2, r3, [r0, #200]	; 0xc8
    w->tempErrDenom = 0.0f;
   256b0:	e9c0 2334 	strd	r2, r3, [r0, #208]	; 0xd0
    w->tempOutDenom = 0.0f;
   256b4:	e9c0 2336 	strd	r2, r3, [r0, #216]	; 0xd8
    w->AAthresh = 10e-10; //10
   256b8:	e9c0 4516 	strd	r4, r5, [r0, #88]	; 0x58
	w->LambertThresh = 10e-10; //12  //was 8
   256bc:	e9c0 451c 	strd	r4, r5, [r0, #112]	; 0x70


}
   256c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   256c4:	f3af 8000 	nop.w
   256c8:	00000000 	.word	0x00000000
   256cc:	40bd4c00 	.word	0x40bd4c00
   256d0:	00000000 	.word	0x00000000
   256d4:	40cd4c00 	.word	0x40cd4c00
   256d8:	76c8b439 	.word	0x76c8b439
   256dc:	3f9a9fbe 	.word	0x3f9a9fbe
   256e0:	9ee75616 	.word	0x9ee75616
   256e4:	3cd203af 	.word	0x3cd203af
   256e8:	b13b13b1 	.word	0xb13b13b1
   256ec:	40533b13 	.word	0x40533b13
   256f0:	46f1bc84 	.word	0x46f1bc84
   256f4:	3df3d2ab 	.word	0x3df3d2ab
   256f8:	e826d695 	.word	0xe826d695
   256fc:	3e112e0b 	.word	0x3e112e0b
   25700:	f23033a4 	.word	0xf23033a4
   25704:	3f2626b2 	.word	0x3f2626b2
   25708:	3ff00000 	.word	0x3ff00000
   2570c:	3fe00000 	.word	0x3fe00000

00025710 <tLockhartWavefolder_free>:

void tLockhartWavefolder_free (tLockhartWavefolder* const wf)
{
    _tLockhartWavefolder* w = *wf;
   25710:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)w, w->mempool);
   25712:	6801      	ldr	r1, [r0, #0]
   25714:	f004 bb60 	b.w	29dd8 <mpool_free>

00025718 <tLockhartWavefolder_tick>:
    _tLockhartWavefolder* w = *wf;

    float out = 0.0f;
    
    // Compute Antiderivative
    w->l = (in > 0.0) - (in < 0.0);
   25718:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   2571c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    w->l = (in > 0.0) - (in < 0.0);
   2571e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    _tLockhartWavefolder* w = *wf;
   25722:	6806      	ldr	r6, [r0, #0]
{
   25724:	4607      	mov	r7, r0
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   25726:	f640 34b8 	movw	r4, #3000	; 0xbb8
{
   2572a:	ed2d 8b0e 	vpush	{d8-d14}
    w->l = (in > 0.0) - (in < 0.0);
   2572e:	bfc8      	it	gt
   25730:	2301      	movgt	r3, #1
    w->u = w->d*exp(w->l*w->b*in);
   25732:	eeb7 eac0 	vcvt.f64.f32	d14, s0
    w->l = (in > 0.0) - (in < 0.0);
   25736:	bfd8      	it	le
   25738:	2300      	movle	r3, #0
   2573a:	bf4c      	ite	mi
   2573c:	2201      	movmi	r2, #1
   2573e:	2200      	movpl	r2, #0
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   25740:	eeb7 bb00 	vmov.f64	d11, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   25744:	eeb0 9b00 	vmov.f64	d9, #0	; 0x40000000  2.0
    w->l = (in > 0.0) - (in < 0.0);
   25748:	1a9b      	subs	r3, r3, r2
    w->u = w->d*exp(w->l*w->b*in);
   2574a:	ed96 0b12 	vldr	d0, [r6, #72]	; 0x48
    w->l = (in > 0.0) - (in < 0.0);
   2574e:	ee07 3a90 	vmov	s15, r3
    w->u = w->d*exp(w->l*w->b*in);
   25752:	ee2e 0b00 	vmul.f64	d0, d14, d0
    w->l = (in > 0.0) - (in < 0.0);
   25756:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2575a:	ed86 7b2a 	vstr	d7, [r6, #168]	; 0xa8
    w->u = w->d*exp(w->l*w->b*in);
   2575e:	ee20 0b07 	vmul.f64	d0, d0, d7
   25762:	f007 fdfd 	bl	2d360 <exp>
   25766:	ed96 cb14 	vldr	d12, [r6, #80]	; 0x50
    	w->u = 10e-5;
    	LEAF_error();
    }
    */

    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   2576a:	ed96 8b02 	vldr	d8, [r6, #8]
    w->u = w->d*exp(w->l*w->b*in);
   2576e:	ee20 cb0c 	vmul.f64	d12, d0, d12
   25772:	ed86 cb2c 	vstr	d12, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
   25776:	683d      	ldr	r5, [r7, #0]
   25778:	eeb1 cb4c 	vneg.f64	d12, d12
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   2577c:	ed95 db1c 	vldr	d13, [r5, #112]	; 0x70
	mwf->w = ln;
   25780:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
   25784:	e006      	b.n	25794 <tLockhartWavefolder_tick+0x7c>
        mwf->w = mwf->w - mwf->myerr;
   25786:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
   2578a:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
   2578c:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
   25790:	f000 80c9 	beq.w	25926 <tLockhartWavefolder_tick+0x20e>
    	mwf->expw = exp(mwf->w);
   25794:	eeb0 0b48 	vmov.f64	d0, d8
   25798:	f007 fde2 	bl	2d360 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   2579c:	ee38 7b0b 	vadd.f64	d7, d8, d11
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   257a0:	ee38 4b09 	vadd.f64	d4, d8, d9
    	mwf->p = mwf->w*mwf->expw - x;
   257a4:	eeb0 6b4c 	vmov.f64	d6, d12
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
   257a8:	ee37 1b07 	vadd.f64	d1, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   257ac:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   257b0:	ee84 2b01 	vdiv.f64	d2, d4, d1
    	mwf->p = mwf->w*mwf->expw - x;
   257b4:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
   257b8:	eeb0 3b47 	vmov.f64	d3, d7
   257bc:	eea6 3b42 	vfms.f64	d3, d6, d2
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
   257c0:	ee86 5b03 	vdiv.f64	d5, d6, d3
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   257c4:	eeb0 abc5 	vabs.f64	d10, d5
   257c8:	eeb4 abcd 	vcmpe.f64	d10, d13
   257cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   257d0:	d5d9      	bpl.n	25786 <tLockhartWavefolder_tick+0x6e>
   257d2:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   257d6:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   257da:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   257de:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
   257e2:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
   257e6:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
   257ea:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
	{
		w->Ln = 10e-5;
		LEAF_error();
	}
*/
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   257ee:	ee2e 5b0e 	vmul.f64	d5, d14, d14
   257f2:	ee24 4b08 	vmul.f64	d4, d4, d8
   257f6:	ed96 7b18 	vldr	d7, [r6, #96]	; 0x60
		LEAF_error();
	}
	*/
    // Check for ill-conditioning

    if (fabs(in-w->xn1)<w->AAthresh)
   257fa:	ed96 db06 	vldr	d13, [r6, #24]
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   257fe:	ed96 6b1a 	vldr	d6, [r6, #104]	; 0x68
   25802:	ee27 5b45 	vnmul.f64	d5, d7, d5
    if (fabs(in-w->xn1)<w->AAthresh)
   25806:	ee3e 3b4d 	vsub.f64	d3, d14, d13
   2580a:	ed96 7b16 	vldr	d7, [r6, #88]	; 0x58
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   2580e:	eea6 5b04 	vfma.f64	d5, d6, d4
    if (fabs(in-w->xn1)<w->AAthresh)
   25812:	eeb0 6bc3 	vabs.f64	d6, d3
    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   25816:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
    if (fabs(in-w->xn1)<w->AAthresh)
   2581a:	eeb4 6bc7 	vcmpe.f64	d6, d7
   2581e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
   25822:	ed86 5b30 	vstr	d5, [r6, #192]	; 0xc0
    if (fabs(in-w->xn1)<w->AAthresh)
   25826:	d412      	bmi.n	2584e <tLockhartWavefolder_tick+0x136>
    	{
    		w->tempOutDenom = 10e-5;
    		LEAF_error();
    	}
    	*/
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
   25828:	ed96 7b04 	vldr	d7, [r6, #16]
    	w->tempOutDenom = (in-w->xn1);
   2582c:	ed86 3b36 	vstr	d3, [r6, #216]	; 0xd8
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
   25830:	ee35 7b47 	vsub.f64	d7, d5, d7
   25834:	ee87 0b03 	vdiv.f64	d0, d7, d3
   25838:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
		*/

    }

    // Update States
    w->Ln1 = w->Ln;
   2583c:	ed86 8b02 	vstr	d8, [r6, #8]
    w->Fn1 = w->Fn;
   25840:	ed86 5b04 	vstr	d5, [r6, #16]
    w->xn1 = (double)in;
   25844:	ed86 eb06 	vstr	d14, [r6, #24]
    
    return out;
}
   25848:	ecbd 8b0e 	vpop	{d8-d14}
   2584c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    	double xn = 0.5*(in+w->xn1);
   2584e:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   25852:	f640 34b8 	movw	r4, #3000	; 0xbb8
    	double xn = 0.5*(in+w->xn1);
   25856:	ee3e db0d 	vadd.f64	d13, d14, d13
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   2585a:	eeb7 9b00 	vmov.f64	d9, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   2585e:	eeb0 ab00 	vmov.f64	d10, #0	; 0x40000000  2.0
    	double xn = 0.5*(in+w->xn1);
   25862:	ee2d db07 	vmul.f64	d13, d13, d7
    	w->u = w->d*exp(w->l*w->b*xn);
   25866:	ed96 0b2a 	vldr	d0, [r6, #168]	; 0xa8
   2586a:	ed96 7b12 	vldr	d7, [r6, #72]	; 0x48
   2586e:	ee20 0b07 	vmul.f64	d0, d0, d7
   25872:	ee20 0b0d 	vmul.f64	d0, d0, d13
   25876:	f007 fd73 	bl	2d360 <exp>
   2587a:	ed96 bb14 	vldr	d11, [r6, #80]	; 0x50
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   2587e:	ed96 8b02 	vldr	d8, [r6, #8]
    	w->u = w->d*exp(w->l*w->b*xn);
   25882:	ee20 bb0b 	vmul.f64	d11, d0, d11
   25886:	ed86 bb2c 	vstr	d11, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
   2588a:	683d      	ldr	r5, [r7, #0]
   2588c:	eeb1 bb4b 	vneg.f64	d11, d11
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   25890:	ed95 cb1c 	vldr	d12, [r5, #112]	; 0x70
	mwf->w = ln;
   25894:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
   25898:	e005      	b.n	258a6 <tLockhartWavefolder_tick+0x18e>
        mwf->w = mwf->w - mwf->myerr;
   2589a:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
   2589e:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
   258a0:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
   258a4:	d01e      	beq.n	258e4 <tLockhartWavefolder_tick+0x1cc>
    	mwf->expw = exp(mwf->w);
   258a6:	eeb0 0b48 	vmov.f64	d0, d8
   258aa:	f007 fd59 	bl	2d360 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   258ae:	ee38 7b09 	vadd.f64	d7, d8, d9
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   258b2:	ee38 5b0a 	vadd.f64	d5, d8, d10
    	mwf->p = mwf->w*mwf->expw - x;
   258b6:	eeb0 6b4b 	vmov.f64	d6, d11
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
   258ba:	ee37 2b07 	vadd.f64	d2, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
   258be:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
   258c2:	ee85 3b02 	vdiv.f64	d3, d5, d2
    	mwf->p = mwf->w*mwf->expw - x;
   258c6:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
   258ca:	eeb0 4b47 	vmov.f64	d4, d7
   258ce:	eea6 4b43 	vfms.f64	d4, d6, d3
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
   258d2:	ee86 5b04 	vdiv.f64	d5, d6, d4
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
   258d6:	eeb0 1bc5 	vabs.f64	d1, d5
   258da:	eeb4 1bcc 	vcmpe.f64	d1, d12
   258de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   258e2:	d5da      	bpl.n	2589a <tLockhartWavefolder_tick+0x182>
   258e4:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   258e8:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   258ec:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   258f0:	ed85 2b32 	vstr	d2, [r5, #200]	; 0xc8
   258f4:	ed85 3b26 	vstr	d3, [r5, #152]	; 0x98
   258f8:	ed85 4b34 	vstr	d4, [r5, #208]	; 0xd0
   258fc:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
   25900:	ed96 5b10 	vldr	d5, [r6, #64]	; 0x40
   25904:	ed96 7b2a 	vldr	d7, [r6, #168]	; 0xa8
   25908:	ed96 6b0c 	vldr	d6, [r6, #48]	; 0x30
   2590c:	ee25 db4d 	vnmul.f64	d13, d5, d13
   25910:	ee27 7b06 	vmul.f64	d7, d7, d6
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
   25914:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
   25918:	ed96 5b30 	vldr	d5, [r6, #192]	; 0xc0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
   2591c:	eea7 db08 	vfma.f64	d13, d7, d8
   25920:	eeb7 0bcd 	vcvt.f32.f64	s0, d13
   25924:	e78a      	b.n	2583c <tLockhartWavefolder_tick+0x124>
   25926:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
   2592a:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
   2592e:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
   25932:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
   25936:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
   2593a:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
   2593e:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
   25942:	ee38 4b09 	vadd.f64	d4, d8, d9
   25946:	e752      	b.n	257ee <tLockhartWavefolder_tick+0xd6>

00025948 <tCrusher_initToPool>:
{
    tCrusher_initToPool(cr, &leaf.mempool);
}

void tCrusher_initToPool (tCrusher* const cr, tMempool* const mp)
{
   25948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2594a:	680e      	ldr	r6, [r1, #0]
{
   2594c:	460d      	mov	r5, r1
   2594e:	4607      	mov	r7, r0
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   25950:	2020      	movs	r0, #32
   25952:	4631      	mov	r1, r6
   25954:	f004 f998 	bl	29c88 <mpool_alloc>
    c->mempool = m;
    
    c->op = 4;
    c->div = SCALAR;
    c->rnd = 0.25f;
   25958:	f04f 537a 	mov.w	r3, #1048576000	; 0x3e800000
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   2595c:	4604      	mov	r4, r0
    c->div = SCALAR;
   2595e:	4a10      	ldr	r2, [pc, #64]	; (259a0 <tCrusher_initToPool+0x58>)
    c->op = 4;
   25960:	2104      	movs	r1, #4
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
   25962:	6038      	str	r0, [r7, #0]
    c->div = SCALAR;
   25964:	60e2      	str	r2, [r4, #12]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   25966:	2010      	movs	r0, #16
    c->op = 4;
   25968:	6161      	str	r1, [r4, #20]
    c->rnd = 0.25f;
   2596a:	6123      	str	r3, [r4, #16]
    c->srr = 0.25f;
   2596c:	6063      	str	r3, [r4, #4]
    c->mempool = m;
   2596e:	6026      	str	r6, [r4, #0]
    _tMempool* m = *mp;
   25970:	682d      	ldr	r5, [r5, #0]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   25972:	4629      	mov	r1, r5
   25974:	f004 f988 	bl	29c88 <mpool_alloc>
    s->invRatio = 1.0f;
   25978:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    s->hold = 0.0f;
   2597c:	2200      	movs	r2, #0
    s->count = 0;
   2597e:	2300      	movs	r3, #0
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
   25980:	61e0      	str	r0, [r4, #28]
    tSampleReducer_initToPool(&c->sReducer, mp);
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25982:	ed9f 7a08 	vldr	s14, [pc, #32]	; 259a4 <tCrusher_initToPool+0x5c>
    s->mempool = m;
   25986:	6005      	str	r5, [r0, #0]
    s->invRatio = 1.0f;
   25988:	6041      	str	r1, [r0, #4]
    s->hold = 0.0f;
   2598a:	6082      	str	r2, [r0, #8]
    s->count = 0;
   2598c:	60c3      	str	r3, [r0, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   2598e:	eddf 7a06 	vldr	s15, [pc, #24]	; 259a8 <tCrusher_initToPool+0x60>
   25992:	edd4 6a03 	vldr	s13, [r4, #12]
   25996:	eee6 7a87 	vfma.f32	s15, s13, s14
   2599a:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2599e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   259a0:	459c4000 	.word	0x459c4000
   259a4:	3912ccf6 	.word	0x3912ccf6
   259a8:	3e99999a 	.word	0x3e99999a

000259ac <tCrusher_free>:

void tCrusher_free (tCrusher* const cr)
{
   259ac:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
   259ae:	6804      	ldr	r4, [r0, #0]
    _tSampleReducer* s = *sr;
   259b0:	69e0      	ldr	r0, [r4, #28]
    mpool_free((char*)s, s->mempool);
   259b2:	6801      	ldr	r1, [r0, #0]
   259b4:	f004 fa10 	bl	29dd8 <mpool_free>
    
    tSampleReducer_free(&c->sReducer);
    mpool_free((char*)c, c->mempool);
   259b8:	6821      	ldr	r1, [r4, #0]
   259ba:	4620      	mov	r0, r4
}
   259bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)c, c->mempool);
   259c0:	f004 ba0a 	b.w	29dd8 <mpool_free>

000259c4 <tCrusher_tick>:
{
    _tCrusher* c = *cr;
    
    float sample = input;
    
    sample *= SCALAR; // SCALAR is 5000 by default
   259c4:	eddf 7a1e 	vldr	s15, [pc, #120]	; 25a40 <tCrusher_tick+0x7c>
   259c8:	ee20 0a27 	vmul.f32	s0, s0, s15
{
   259cc:	b510      	push	{r4, lr}
    
    sample = (int32_t) sample;
   259ce:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tCrusher* c = *cr;
   259d2:	6804      	ldr	r4, [r0, #0]
    
    sample /= c->div;
   259d4:	edd4 7a03 	vldr	s15, [r4, #12]
    sample = (int32_t) sample;
   259d8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    
    sample = LEAF_bitwise_xor(sample, c->op << 23);
   259dc:	6960      	ldr	r0, [r4, #20]
   259de:	05c0      	lsls	r0, r0, #23
   259e0:	ee80 0a27 	vdiv.f32	s0, s0, s15
   259e4:	f003 ff4a 	bl	2987c <LEAF_bitwise_xor>
    
    sample = LEAF_clip(-1.f, sample, 1.f);
   259e8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   259ec:	eef0 0a40 	vmov.f32	s1, s0
   259f0:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   259f4:	f003 ff48 	bl	29888 <LEAF_clip>
    
    sample = LEAF_round(sample, c->rnd);
   259f8:	edd4 0a04 	vldr	s1, [r4, #16]
   259fc:	f003 ff2c 	bl	29858 <LEAF_round>
    _tSampleReducer* s = *sr;
   25a00:	69e3      	ldr	r3, [r4, #28]
    if (s->count > s->invRatio)
   25a02:	68da      	ldr	r2, [r3, #12]
   25a04:	edd3 7a01 	vldr	s15, [r3, #4]
   25a08:	ee07 2a10 	vmov	s14, r2
   25a0c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   25a10:	eeb4 7ae7 	vcmpe.f32	s14, s15
   25a14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25a18:	dd08      	ble.n	25a2c <tCrusher_tick+0x68>
        s->hold = input;
   25a1a:	2201      	movs	r2, #1
   25a1c:	ed83 0a02 	vstr	s0, [r3, #8]
    s->count++;
   25a20:	60da      	str	r2, [r3, #12]
    
    sample = tSampleReducer_tick(&c->sReducer, sample);
    
    return sample * c->gain;
   25a22:	edd4 7a06 	vldr	s15, [r4, #24]
    
}
   25a26:	ee20 0a27 	vmul.f32	s0, s0, s15
   25a2a:	bd10      	pop	{r4, pc}
   25a2c:	3201      	adds	r2, #1
   25a2e:	ed93 0a02 	vldr	s0, [r3, #8]
    s->count++;
   25a32:	60da      	str	r2, [r3, #12]
    return sample * c->gain;
   25a34:	edd4 7a06 	vldr	s15, [r4, #24]
}
   25a38:	ee20 0a27 	vmul.f32	s0, s0, s15
   25a3c:	bd10      	pop	{r4, pc}
   25a3e:	bf00      	nop
   25a40:	459c4000 	.word	0x459c4000

00025a44 <tCrusher_setOperation>:

void    tCrusher_setOperation (tCrusher* const cr, float op)
{
    _tCrusher* c = *cr;
    c->op = (uint32_t) (op * 8.0f);
   25a44:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    _tCrusher* c = *cr;
   25a48:	6803      	ldr	r3, [r0, #0]
    c->op = (uint32_t) (op * 8.0f);
   25a4a:	ee20 0a27 	vmul.f32	s0, s0, s15
   25a4e:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   25a52:	ed83 0a05 	vstr	s0, [r3, #20]
}
   25a56:	4770      	bx	lr

00025a58 <tCrusher_setQuality>:

// 0.0 - 1.0
void    tCrusher_setQuality (tCrusher* const cr, float val)
{
   25a58:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
    
    val = LEAF_clip(0.0f, val, 1.0f);
   25a5a:	eef0 0a40 	vmov.f32	s1, s0
   25a5e:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 25a90 <tCrusher_setQuality+0x38>
   25a62:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    _tCrusher* c = *cr;
   25a66:	6804      	ldr	r4, [r0, #0]
    val = LEAF_clip(0.0f, val, 1.0f);
   25a68:	f003 ff0e 	bl	29888 <LEAF_clip>
    
    c->div = 0.01f + val * SCALAR;
   25a6c:	ed9f 7a09 	vldr	s14, [pc, #36]	; 25a94 <tCrusher_setQuality+0x3c>
   25a70:	eddf 7a09 	vldr	s15, [pc, #36]	; 25a98 <tCrusher_setQuality+0x40>
    
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25a74:	eddf 6a09 	vldr	s13, [pc, #36]	; 25a9c <tCrusher_setQuality+0x44>
    c->div = 0.01f + val * SCALAR;
   25a78:	eee0 7a07 	vfma.f32	s15, s0, s14
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25a7c:	ed9f 7a08 	vldr	s14, [pc, #32]	; 25aa0 <tCrusher_setQuality+0x48>
   25a80:	eea7 7aa6 	vfma.f32	s14, s15, s13
    c->div = 0.01f + val * SCALAR;
   25a84:	edc4 7a03 	vstr	s15, [r4, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
   25a88:	ed84 7a06 	vstr	s14, [r4, #24]
}
   25a8c:	bd10      	pop	{r4, pc}
   25a8e:	bf00      	nop
   25a90:	00000000 	.word	0x00000000
   25a94:	459c4000 	.word	0x459c4000
   25a98:	3c23d70a 	.word	0x3c23d70a
   25a9c:	3912ccf6 	.word	0x3912ccf6
   25aa0:	3e99999a 	.word	0x3e99999a

00025aa4 <tCrusher_setRound>:

// what decimal to round to
void    tCrusher_setRound (tCrusher* const cr, float rnd)
{
    _tCrusher* c = *cr;
    c->rnd = fabsf(rnd);
   25aa4:	eeb0 0ac0 	vabs.f32	s0, s0
    _tCrusher* c = *cr;
   25aa8:	6803      	ldr	r3, [r0, #0]
    c->rnd = fabsf(rnd);
   25aaa:	ed83 0a04 	vstr	s0, [r3, #16]
}
   25aae:	4770      	bx	lr

00025ab0 <tCrusher_setSamplingRatio>:
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
   25ab0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

void    tCrusher_setSamplingRatio (tCrusher* const cr, float ratio)
{
    _tCrusher* c = *cr;
   25ab4:	6803      	ldr	r3, [r0, #0]
    c->srr = ratio;
   25ab6:	ed83 0a01 	vstr	s0, [r3, #4]
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
   25aba:	eeb4 0a67 	vcmp.f32	s0, s15
   25abe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25ac2:	d809      	bhi.n	25ad8 <tCrusher_setSamplingRatio+0x28>
   25ac4:	eeb5 0a40 	vcmp.f32	s0, #0.0
   25ac8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25acc:	db04      	blt.n	25ad8 <tCrusher_setSamplingRatio+0x28>
        s->invRatio = 1.0f / ratio;
   25ace:	ee87 7a80 	vdiv.f32	s14, s15, s0
    _tSampleReducer* s = *sr;
   25ad2:	69db      	ldr	r3, [r3, #28]
        s->invRatio = 1.0f / ratio;
   25ad4:	ed83 7a01 	vstr	s14, [r3, #4]
    tSampleReducer_setRatio(&c->sReducer, ratio);

}
   25ad8:	4770      	bx	lr
   25ada:	bf00      	nop

00025adc <tFeedbackLeveler_init>:
}

/* Feedback Leveler */

void tFeedbackLeveler_init (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode)
{
   25adc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tFeedbackLeveler_initToPool(fb, targetLevel, factor, strength, mode, &leaf.mempool);
}

void tFeedbackLeveler_initToPool (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode, tMempool* const mp)
{
    _tMempool* m = *mp;
   25ae0:	4d12      	ldr	r5, [pc, #72]	; (25b2c <tFeedbackLeveler_init+0x50>)
{
   25ae2:	4680      	mov	r8, r0
   25ae4:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25ae6:	2018      	movs	r0, #24
    _tMempool* m = *mp;
   25ae8:	f855 6f18 	ldr.w	r6, [r5, #24]!
{
   25aec:	ed2d 8b04 	vpush	{d8-d9}
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25af0:	4631      	mov	r1, r6
{
   25af2:	eef0 8a40 	vmov.f32	s17, s0
   25af6:	eeb0 9a60 	vmov.f32	s18, s1
   25afa:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25afe:	f004 f8c3 	bl	29c88 <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
   25b02:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25b04:	4604      	mov	r4, r0
   25b06:	f8c8 0000 	str.w	r0, [r8]
    p->targetLevel=targetLevel;
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b0a:	eeb0 0a49 	vmov.f32	s0, s18
    p->mempool = m;
   25b0e:	6006      	str	r6, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b10:	4629      	mov	r1, r5
    p->targetLevel=targetLevel;
   25b12:	edc4 8a01 	vstr	s17, [r4, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b16:	3014      	adds	r0, #20
    p->curr=0.0f;
   25b18:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b1a:	f7fe fc93 	bl	24444 <tPowerFollower_initToPool>
    p->mode=mode;
   25b1e:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
   25b20:	ed84 8a02 	vstr	s16, [r4, #8]
}
   25b24:	ecbd 8b04 	vpop	{d8-d9}
   25b28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25b2c:	020fc0a8 	.word	0x020fc0a8

00025b30 <tFeedbackLeveler_initToPool>:
{
   25b30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
   25b34:	6815      	ldr	r5, [r2, #0]
{
   25b36:	4680      	mov	r8, r0
   25b38:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25b3a:	2018      	movs	r0, #24
   25b3c:	4629      	mov	r1, r5
{
   25b3e:	4616      	mov	r6, r2
   25b40:	ed2d 8b04 	vpush	{d8-d9}
   25b44:	eef0 8a40 	vmov.f32	s17, s0
   25b48:	eeb0 9a60 	vmov.f32	s18, s1
   25b4c:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25b50:	f004 f89a 	bl	29c88 <mpool_alloc>
    p->curr=0.0f;
   25b54:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
   25b56:	4604      	mov	r4, r0
   25b58:	f8c8 0000 	str.w	r0, [r8]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b5c:	eeb0 0a49 	vmov.f32	s0, s18
    p->mempool = m;
   25b60:	6005      	str	r5, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b62:	4631      	mov	r1, r6
    p->targetLevel=targetLevel;
   25b64:	edc4 8a01 	vstr	s17, [r4, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b68:	3014      	adds	r0, #20
    p->curr=0.0f;
   25b6a:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
   25b6c:	f7fe fc6a 	bl	24444 <tPowerFollower_initToPool>
    p->mode=mode;
   25b70:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
   25b72:	ed84 8a02 	vstr	s16, [r4, #8]
}
   25b76:	ecbd 8b04 	vpop	{d8-d9}
   25b7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25b7e:	bf00      	nop

00025b80 <tFeedbackLeveler_free>:

void tFeedbackLeveler_free (tFeedbackLeveler* const fb)
{
   25b80:	b510      	push	{r4, lr}
    _tFeedbackLeveler* p = *fb;
   25b82:	6804      	ldr	r4, [r0, #0]
    
    tPowerFollower_free(&p->pwrFlw);
   25b84:	f104 0014 	add.w	r0, r4, #20
   25b88:	f7fe fc76 	bl	24478 <tPowerFollower_free>
    mpool_free((char*)p, p->mempool);
   25b8c:	6821      	ldr	r1, [r4, #0]
   25b8e:	4620      	mov	r0, r4
}
   25b90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   25b94:	f004 b920 	b.w	29dd8 <mpool_free>

00025b98 <tFeedbackLeveler_setMode>:
    tPowerFollower_setFactor(&p->pwrFlw,factor);
}

void     tFeedbackLeveler_setMode(tFeedbackLeveler* const fb, int mode)
{    // 0 for decaying with upwards lev limiting, 1 for constrained absolute level (also downwards limiting)
    _tFeedbackLeveler* p = *fb;
   25b98:	6803      	ldr	r3, [r0, #0]
    p->mode=mode;
   25b9a:	60d9      	str	r1, [r3, #12]
}
   25b9c:	4770      	bx	lr
   25b9e:	bf00      	nop

00025ba0 <tFeedbackLeveler_tick>:

float   tFeedbackLeveler_tick(tFeedbackLeveler* const fb, float input)
{
   25ba0:	b510      	push	{r4, lr}
   25ba2:	ed2d 8b02 	vpush	{d8}
    _tFeedbackLeveler* p = *fb;
   25ba6:	6804      	ldr	r4, [r0, #0]
{
   25ba8:	eeb0 8a40 	vmov.f32	s16, s0
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
   25bac:	f104 0014 	add.w	r0, r4, #20
   25bb0:	f7fe fc66 	bl	24480 <tPowerFollower_tick>
   25bb4:	edd4 7a01 	vldr	s15, [r4, #4]
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
   25bb8:	68e3      	ldr	r3, [r4, #12]
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
   25bba:	ee70 7a67 	vsub.f32	s15, s0, s15
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
   25bbe:	b943      	cbnz	r3, 25bd2 <tFeedbackLeveler_tick+0x32>
   25bc0:	eef5 7a40 	vcmp.f32	s15, #0.0
   25bc4:	ed9f 7a09 	vldr	s14, [pc, #36]	; 25bec <tFeedbackLeveler_tick+0x4c>
   25bc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25bcc:	bf48      	it	mi
   25bce:	eef0 7a47 	vmovmi.f32	s15, s14
    p->curr=input*(1.0f-p->strength*levdiff);
   25bd2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   25bd6:	ed94 7a02 	vldr	s14, [r4, #8]
   25bda:	eea7 0a67 	vfms.f32	s0, s14, s15
   25bde:	ee20 0a08 	vmul.f32	s0, s0, s16
   25be2:	ed84 0a04 	vstr	s0, [r4, #16]
    return p->curr;
}
   25be6:	ecbd 8b02 	vpop	{d8}
   25bea:	bd10      	pop	{r4, pc}
   25bec:	00000000 	.word	0x00000000

00025bf0 <tFeedbackLeveler_setTargetLevel>:
}


void     tFeedbackLeveler_setTargetLevel   (tFeedbackLeveler* const fb, float TargetLevel)
{
    _tFeedbackLeveler* p = *fb;
   25bf0:	6803      	ldr	r3, [r0, #0]
    p->targetLevel=TargetLevel;
   25bf2:	ed83 0a01 	vstr	s0, [r3, #4]
}
   25bf6:	4770      	bx	lr

00025bf8 <tTalkbox_lpcDurbin>:
    }

}

void tTalkbox_lpcDurbin(float *r, int p, float *k, float *g)
{
   25bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i, j;
    float a[ORD_MAX], at[ORD_MAX], e=r[0];

    for(i=0; i<=p; i++)
   25bfc:	f1b1 0900 	subs.w	r9, r1, #0
{
   25c00:	4615      	mov	r5, r2
   25c02:	ed2d 8b04 	vpush	{d8-d9}
   25c06:	b0c7      	sub	sp, #284	; 0x11c
    float a[ORD_MAX], at[ORD_MAX], e=r[0];
   25c08:	edd0 8a00 	vldr	s17, [r0]
{
   25c0c:	9301      	str	r3, [sp, #4]
    for(i=0; i<=p; i++)
   25c0e:	db7e      	blt.n	25d0e <tTalkbox_lpcDurbin+0x116>
    {
    	a[i] = 0.0f; //probably don't need to clear at[] or k[]
   25c10:	f109 0201 	add.w	r2, r9, #1
   25c14:	4607      	mov	r7, r0
   25c16:	2100      	movs	r1, #0
   25c18:	a802      	add	r0, sp, #8
   25c1a:	0092      	lsls	r2, r2, #2
   25c1c:	f006 ff11 	bl	2ca42 <memset>
    }
	k[0] = 0.0f;
   25c20:	2300      	movs	r3, #0
    at[0] = 0.0f;
    for(i=1; i<=p; i++)
   25c22:	f1b9 0f00 	cmp.w	r9, #0
	k[0] = 0.0f;
   25c26:	602b      	str	r3, [r5, #0]
    at[0] = 0.0f;
   25c28:	9324      	str	r3, [sp, #144]	; 0x90
    for(i=1; i<=p; i++)
   25c2a:	dd50      	ble.n	25cce <tTalkbox_lpcDurbin+0xd6>
   25c2c:	1d3e      	adds	r6, r7, #4
   25c2e:	f06f 0a07 	mvn.w	sl, #7
   25c32:	3504      	adds	r5, #4
   25c34:	f10d 0808 	add.w	r8, sp, #8
   25c38:	ebaa 0a07 	sub.w	sl, sl, r7
   25c3c:	4634      	mov	r4, r6
   25c3e:	2701      	movs	r7, #1
        for(j=1; j<i; j++)
        {
            at[j] = a[j];
            k[i] -= a[j] * r[i-j];
        }
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   25c40:	eddf 9a38 	vldr	s19, [pc, #224]	; 25d24 <tTalkbox_lpcDurbin+0x12c>
        k[i] = -r[i];
   25c44:	ed94 8a00 	vldr	s16, [r4]
        for(j=1; j<i; j++)
   25c48:	2f01      	cmp	r7, #1
   25c4a:	f104 0b04 	add.w	fp, r4, #4
   25c4e:	eeb0 9ae8 	vabs.f32	s18, s17
        k[i] = -r[i];
   25c52:	eeb1 8a48 	vneg.f32	s16, s16
   25c56:	eca5 8a01 	vstmia	r5!, {s16}
        for(j=1; j<i; j++)
   25c5a:	d04c      	beq.n	25cf6 <tTalkbox_lpcDurbin+0xfe>
   25c5c:	ab25      	add	r3, sp, #148	; 0x94
   25c5e:	eb0a 020b 	add.w	r2, sl, fp
   25c62:	a903      	add	r1, sp, #12
   25c64:	4618      	mov	r0, r3
   25c66:	f006 fee1 	bl	2ca2c <memcpy>
   25c6a:	a903      	add	r1, sp, #12
   25c6c:	4603      	mov	r3, r0
   25c6e:	460a      	mov	r2, r1
            k[i] -= a[j] * r[i-j];
   25c70:	ed74 7a01 	vldmdb	r4!, {s15}
            at[j] = a[j];
   25c74:	ecb2 7a01 	vldmia	r2!, {s14}
        for(j=1; j<i; j++)
   25c78:	42a6      	cmp	r6, r4
            k[i] -= a[j] * r[i-j];
   25c7a:	eea7 8a67 	vfms.f32	s16, s14, s15
   25c7e:	ed05 8a01 	vstr	s16, [r5, #-4]
        for(j=1; j<i; j++)
   25c82:	d1f5      	bne.n	25c70 <tTalkbox_lpcDurbin+0x78>
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   25c84:	eeb4 9ae9 	vcmpe.f32	s18, s19
   25c88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25c8c:	d429      	bmi.n	25ce2 <tTalkbox_lpcDurbin+0xea>
        k[i] /= e;
   25c8e:	eec8 6a28 	vdiv.f32	s13, s16, s17
   25c92:	aa24      	add	r2, sp, #144	; 0x90
   25c94:	4618      	mov	r0, r3
   25c96:	eb02 0287 	add.w	r2, r2, r7, lsl #2
   25c9a:	ed45 6a01 	vstr	s13, [r5, #-4]

        a[i] = k[i];
   25c9e:	edc8 6a01 	vstr	s13, [r8, #4]
        for(j=1; j<i; j++) a[j] = at[j] + k[i] * at[i-j];
   25ca2:	ed32 7a01 	vldmdb	r2!, {s14}
   25ca6:	ecf0 7a01 	vldmia	r0!, {s15}
   25caa:	4293      	cmp	r3, r2
   25cac:	eee7 7a26 	vfma.f32	s15, s14, s13
   25cb0:	ece1 7a01 	vstmia	r1!, {s15}
   25cb4:	d1f5      	bne.n	25ca2 <tTalkbox_lpcDurbin+0xaa>

        e *= 1.0f - k[i] * k[i];
   25cb6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    for(i=1; i<=p; i++)
   25cba:	3701      	adds	r7, #1
   25cbc:	f108 0804 	add.w	r8, r8, #4
   25cc0:	465c      	mov	r4, fp
   25cc2:	45b9      	cmp	r9, r7
        e *= 1.0f - k[i] * k[i];
   25cc4:	eee6 7ae6 	vfms.f32	s15, s13, s13
   25cc8:	ee68 8aa7 	vmul.f32	s17, s17, s15
    for(i=1; i<=p; i++)
   25ccc:	daba      	bge.n	25c44 <tTalkbox_lpcDurbin+0x4c>
    }

    if(e < 1.0e-20f) e = 0.0f;
   25cce:	eddf 7a15 	vldr	s15, [pc, #84]	; 25d24 <tTalkbox_lpcDurbin+0x12c>
   25cd2:	eef4 8ae7 	vcmpe.f32	s17, s15
   25cd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25cda:	d402      	bmi.n	25ce2 <tTalkbox_lpcDurbin+0xea>
   25cdc:	eef1 7ae8 	vsqrt.f32	s15, s17
   25ce0:	e001      	b.n	25ce6 <tTalkbox_lpcDurbin+0xee>
        for(j=1; j<i; j++)
   25ce2:	eddf 7a11 	vldr	s15, [pc, #68]	; 25d28 <tTalkbox_lpcDurbin+0x130>
    *g = sqrtf(e);
   25ce6:	9b01      	ldr	r3, [sp, #4]
   25ce8:	edc3 7a00 	vstr	s15, [r3]
}
   25cec:	b047      	add	sp, #284	; 0x11c
   25cee:	ecbd 8b04 	vpop	{d8-d9}
   25cf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
   25cf6:	eeb4 9ae9 	vcmpe.f32	s18, s19
   25cfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25cfe:	d4f0      	bmi.n	25ce2 <tTalkbox_lpcDurbin+0xea>
        k[i] /= e;
   25d00:	eec8 6a28 	vdiv.f32	s13, s16, s17
   25d04:	ed45 6a01 	vstr	s13, [r5, #-4]
        a[i] = k[i];
   25d08:	edc8 6a01 	vstr	s13, [r8, #4]
   25d0c:	e7d3      	b.n	25cb6 <tTalkbox_lpcDurbin+0xbe>
    if(e < 1.0e-20f) e = 0.0f;
   25d0e:	eddf 7a05 	vldr	s15, [pc, #20]	; 25d24 <tTalkbox_lpcDurbin+0x12c>
	k[0] = 0.0f;
   25d12:	2300      	movs	r3, #0
    if(e < 1.0e-20f) e = 0.0f;
   25d14:	eef4 8ae7 	vcmpe.f32	s17, s15
	k[0] = 0.0f;
   25d18:	6013      	str	r3, [r2, #0]
    if(e < 1.0e-20f) e = 0.0f;
   25d1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   25d1e:	d5dd      	bpl.n	25cdc <tTalkbox_lpcDurbin+0xe4>
   25d20:	e7df      	b.n	25ce2 <tTalkbox_lpcDurbin+0xea>
   25d22:	bf00      	nop
   25d24:	1e3ce508 	.word	0x1e3ce508
   25d28:	00000000 	.word	0x00000000

00025d2c <tTalkboxFloat_free>:
    tTalkboxFloat_update(voc);
    tTalkboxFloat_suspend(voc);
}

void tTalkboxFloat_free (tTalkboxFloat* const voc)
{
   25d2c:	b510      	push	{r4, lr}
    _tTalkboxFloat* v = *voc;
   25d2e:	6804      	ldr	r4, [r0, #0]

    mpool_free((char*)v->buf1, v->mempool);
   25d30:	6821      	ldr	r1, [r4, #0]
   25d32:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   25d34:	f004 f850 	bl	29dd8 <mpool_free>
    mpool_free((char*)v->buf0, v->mempool);
   25d38:	6821      	ldr	r1, [r4, #0]
   25d3a:	6a60      	ldr	r0, [r4, #36]	; 0x24
   25d3c:	f004 f84c 	bl	29dd8 <mpool_free>
    mpool_free((char*)v->window, v->mempool);
   25d40:	6821      	ldr	r1, [r4, #0]
   25d42:	6a20      	ldr	r0, [r4, #32]
   25d44:	f004 f848 	bl	29dd8 <mpool_free>
    mpool_free((char*)v->car1, v->mempool);
   25d48:	6821      	ldr	r1, [r4, #0]
   25d4a:	69e0      	ldr	r0, [r4, #28]
   25d4c:	f004 f844 	bl	29dd8 <mpool_free>
    mpool_free((char*)v->car0, v->mempool);
   25d50:	6821      	ldr	r1, [r4, #0]
   25d52:	69a0      	ldr	r0, [r4, #24]
   25d54:	f004 f840 	bl	29dd8 <mpool_free>

    mpool_free((char*)v->dl, v->mempool);
   25d58:	6821      	ldr	r1, [r4, #0]
   25d5a:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   25d5e:	f004 f83b 	bl	29dd8 <mpool_free>
    mpool_free((char*)v->Rt, v->mempool);
   25d62:	6821      	ldr	r1, [r4, #0]
   25d64:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   25d68:	f004 f836 	bl	29dd8 <mpool_free>
    mpool_free((char*)v->k, v->mempool);
   25d6c:	6821      	ldr	r1, [r4, #0]
   25d6e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   25d70:	f004 f832 	bl	29dd8 <mpool_free>
    mpool_free((char*)v, v->mempool);
   25d74:	6821      	ldr	r1, [r4, #0]
   25d76:	4620      	mov	r0, r4
}
   25d78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)v, v->mempool);
   25d7c:	f004 b82c 	b.w	29dd8 <mpool_free>

00025d80 <tTalkboxFloat_update>:

void tTalkboxFloat_update(tTalkboxFloat* const voc) ///update internal parameters...
{
   25d80:	b538      	push	{r3, r4, r5, lr}
    _tTalkboxFloat* v = *voc;
   25d82:	6804      	ldr	r4, [r0, #0]

    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
    if(n > v->bufsize) n = v->bufsize;

    //O = (VstInt32)(0.0005f * fs);
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25d84:	eddf 7a33 	vldr	s15, [pc, #204]	; 25e54 <tTalkboxFloat_update+0xd4>
    float fs = leaf.sampleRate;
   25d88:	4b33      	ldr	r3, [pc, #204]	; (25e58 <tTalkboxFloat_update+0xd8>)
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25d8a:	ed9f 7a34 	vldr	s14, [pc, #208]	; 25e5c <tTalkboxFloat_update+0xdc>
   25d8e:	eddf 5a34 	vldr	s11, [pc, #208]	; 25e60 <tTalkboxFloat_update+0xe0>
   25d92:	ed9f 6a34 	vldr	s12, [pc, #208]	; 25e64 <tTalkboxFloat_update+0xe4>
{
   25d96:	ed2d 8b04 	vpush	{d8-d9}
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25d9a:	edd4 6a04 	vldr	s13, [r4, #16]
   25d9e:	6961      	ldr	r1, [r4, #20]
   25da0:	eea6 7aa7 	vfma.f32	s14, s13, s15
   25da4:	edd3 6a00 	vldr	s13, [r3]
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   25da8:	eddf 7a2f 	vldr	s15, [pc, #188]	; 25e68 <tTalkboxFloat_update+0xe8>
   25dac:	fec6 6ae5 	vminnm.f32	s13, s13, s11
   25db0:	fec6 6a86 	vmaxnm.f32	s13, s13, s12
   25db4:	ee66 7aa7 	vmul.f32	s15, s13, s15

    if(n != v->N) //recalc hanning window
   25db8:	6c62      	ldr	r2, [r4, #68]	; 0x44
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   25dba:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25dbe:	ee27 7a26 	vmul.f32	s14, s14, s13
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
   25dc2:	ee17 3a90 	vmov	r3, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
   25dc6:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   25dca:	428b      	cmp	r3, r1
   25dcc:	bfa8      	it	ge
   25dce:	460b      	movge	r3, r1
   25dd0:	ed84 7a12 	vstr	s14, [r4, #72]	; 0x48
    if(n != v->N) //recalc hanning window
   25dd4:	429a      	cmp	r2, r3
   25dd6:	d027      	beq.n	25e28 <tTalkboxFloat_update+0xa8>
    {
        v->N = n;
        float dp = TWO_PI / v->N;
   25dd8:	ee07 3a90 	vmov	s15, r3
   25ddc:	ed9f 7a23 	vldr	s14, [pc, #140]	; 25e6c <tTalkboxFloat_update+0xec>
        float p = 0.0f;
        for(n=0; n<v->N; n++)
   25de0:	2b00      	cmp	r3, #0
        v->N = n;
   25de2:	6463      	str	r3, [r4, #68]	; 0x44
        float dp = TWO_PI / v->N;
   25de4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   25de8:	eec7 8a27 	vdiv.f32	s17, s14, s15
        for(n=0; n<v->N; n++)
   25dec:	dd1c      	ble.n	25e28 <tTalkboxFloat_update+0xa8>
        float p = 0.0f;
   25dee:	ed9f 8a20 	vldr	s16, [pc, #128]	; 25e70 <tTalkboxFloat_update+0xf0>
        for(n=0; n<v->N; n++)
   25df2:	2500      	movs	r5, #0
   25df4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        {
            v->window[n] = 0.5f - 0.5f * cosf(p);
   25df8:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
   25dfc:	eeb0 9a40 	vmov.f32	s18, s0
   25e00:	e001      	b.n	25e06 <tTalkboxFloat_update+0x86>
   25e02:	f006 ff47 	bl	2cc94 <cosf>
   25e06:	ee39 0a40 	vsub.f32	s0, s18, s0
   25e0a:	6a23      	ldr	r3, [r4, #32]
            p += dp;
   25e0c:	ee38 8a28 	vadd.f32	s16, s16, s17
            v->window[n] = 0.5f - 0.5f * cosf(p);
   25e10:	eb03 0385 	add.w	r3, r3, r5, lsl #2
        for(n=0; n<v->N; n++)
   25e14:	3501      	adds	r5, #1
            v->window[n] = 0.5f - 0.5f * cosf(p);
   25e16:	ee60 7a29 	vmul.f32	s15, s0, s19
   25e1a:	eeb0 0a48 	vmov.f32	s0, s16
   25e1e:	edc3 7a00 	vstr	s15, [r3]
        for(n=0; n<v->N; n++)
   25e22:	6c63      	ldr	r3, [r4, #68]	; 0x44
   25e24:	42ab      	cmp	r3, r5
   25e26:	dcec      	bgt.n	25e02 <tTalkboxFloat_update+0x82>
        }
    }
    v->wet = 0.5f * v->param[0] * v->param[0];
   25e28:	ed94 7a01 	vldr	s14, [r4, #4]
   25e2c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    v->dry = 2.0f * v->param[1] * v->param[1];
   25e30:	edd4 7a02 	vldr	s15, [r4, #8]
    v->wet = 0.5f * v->param[0] * v->param[0];
   25e34:	ee27 7a07 	vmul.f32	s14, s14, s14
    v->dry = 2.0f * v->param[1] * v->param[1];
   25e38:	ee67 7aa7 	vmul.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
   25e3c:	ee27 7a26 	vmul.f32	s14, s14, s13
    v->dry = 2.0f * v->param[1] * v->param[1];
   25e40:	ee77 7aa7 	vadd.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
   25e44:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
    v->dry = 2.0f * v->param[1] * v->param[1];
   25e48:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
   25e4c:	ecbd 8b04 	vpop	{d8-d9}
   25e50:	bd38      	pop	{r3, r4, r5, pc}
   25e52:	bf00      	nop
   25e54:	39d1b717 	.word	0x39d1b717
   25e58:	020fc0a8 	.word	0x020fc0a8
   25e5c:	38d1b717 	.word	0x38d1b717
   25e60:	47bb8000 	.word	0x47bb8000
   25e64:	45fa0000 	.word	0x45fa0000
   25e68:	3c85c67e 	.word	0x3c85c67e
   25e6c:	40c90fdb 	.word	0x40c90fdb
   25e70:	00000000 	.word	0x00000000

00025e74 <tTalkboxFloat_initToPool>:
{
   25e74:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   25e78:	6817      	ldr	r7, [r2, #0]
{
   25e7a:	4680      	mov	r8, r0
   25e7c:	4689      	mov	r9, r1
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25e7e:	2090      	movs	r0, #144	; 0x90
   25e80:	4639      	mov	r1, r7
    v->param[1] = 0.0f;  //dry
   25e82:	2400      	movs	r4, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25e84:	f003 ff00 	bl	29c88 <mpool_alloc>
    v->warpOn = 0;
   25e88:	2500      	movs	r5, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25e8a:	4606      	mov	r6, r0
    v->param[0] = 0.5f;  //wet
   25e8c:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
    v->param[3] = 1.0f;  //quality
   25e90:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
   25e94:	f8c8 0000 	str.w	r0, [r8]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25e98:	4639      	mov	r1, r7
    v->mempool = m;
   25e9a:	6007      	str	r7, [r0, #0]
    v->bufsize = bufsize;
   25e9c:	f8c0 9014 	str.w	r9, [r0, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ea0:	ea4f 0089 	mov.w	r0, r9, lsl #2
    v->param[0] = 0.5f;  //wet
   25ea4:	6072      	str	r2, [r6, #4]
    v->param[3] = 1.0f;  //quality
   25ea6:	6133      	str	r3, [r6, #16]
    v->param[1] = 0.0f;  //dry
   25ea8:	60b4      	str	r4, [r6, #8]
    v->param[2] = 0; // Swap
   25eaa:	60f4      	str	r4, [r6, #12]
    v->warpFactor = 0.0f;
   25eac:	6334      	str	r4, [r6, #48]	; 0x30
    v->G = 0.0f;
   25eae:	f8c6 4084 	str.w	r4, [r6, #132]	; 0x84
    v->freeze = 0;
   25eb2:	e9c6 550d 	strd	r5, r5, [r6, #52]	; 0x34
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25eb6:	f003 fee7 	bl	29c88 <mpool_alloc>
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25eba:	6973      	ldr	r3, [r6, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ebc:	61b0      	str	r0, [r6, #24]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ebe:	4639      	mov	r1, r7
   25ec0:	0098      	lsls	r0, r3, #2
   25ec2:	f003 fee1 	bl	29c88 <mpool_alloc>
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ec6:	6973      	ldr	r3, [r6, #20]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ec8:	61f0      	str	r0, [r6, #28]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25eca:	4639      	mov	r1, r7
   25ecc:	0098      	lsls	r0, r3, #2
   25ece:	f003 fedb 	bl	29c88 <mpool_alloc>
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ed2:	6973      	ldr	r3, [r6, #20]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ed4:	6230      	str	r0, [r6, #32]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ed6:	4639      	mov	r1, r7
   25ed8:	0098      	lsls	r0, r3, #2
   25eda:	f003 fed5 	bl	29c88 <mpool_alloc>
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ede:	6973      	ldr	r3, [r6, #20]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ee0:	6270      	str	r0, [r6, #36]	; 0x24
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ee2:	4639      	mov	r1, r7
   25ee4:	0098      	lsls	r0, r3, #2
   25ee6:	f003 fecf 	bl	29c88 <mpool_alloc>
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25eea:	6973      	ldr	r3, [r6, #20]
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25eec:	62b0      	str	r0, [r6, #40]	; 0x28
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25eee:	4639      	mov	r1, r7
   25ef0:	0098      	lsls	r0, r3, #2
   25ef2:	f003 fec9 	bl	29c88 <mpool_alloc>
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ef6:	6973      	ldr	r3, [r6, #20]
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25ef8:	f8c6 0088 	str.w	r0, [r6, #136]	; 0x88
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25efc:	4639      	mov	r1, r7
   25efe:	0098      	lsls	r0, r3, #2
   25f00:	f003 fec2 	bl	29c88 <mpool_alloc>
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
   25f04:	4639      	mov	r1, r7
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
   25f06:	f8c6 008c 	str.w	r0, [r6, #140]	; 0x8c
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
   25f0a:	2088      	movs	r0, #136	; 0x88
   25f0c:	f003 febc 	bl	29c88 <mpool_alloc>
   25f10:	62f0      	str	r0, [r6, #44]	; 0x2c
    tTalkboxFloat_update(voc);
   25f12:	4640      	mov	r0, r8
   25f14:	f7ff ff34 	bl	25d80 <tTalkboxFloat_update>

void tTalkboxFloat_suspend(tTalkboxFloat* const voc) ///clear any buffers...
{
    _tTalkboxFloat* v = *voc;
   25f18:	f8d8 3000 	ldr.w	r3, [r8]
    v->FX = 0;

    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;

    for (int32_t i = 0; i < v->bufsize; i++)
   25f1c:	695a      	ldr	r2, [r3, #20]
    v->pos = v->K = 0;
   25f1e:	641d      	str	r5, [r3, #64]	; 0x40
    for (int32_t i = 0; i < v->bufsize; i++)
   25f20:	42aa      	cmp	r2, r5
    v->pos = v->K = 0;
   25f22:	64dd      	str	r5, [r3, #76]	; 0x4c
    v->emphasis = 0.0f;
   25f24:	63dc      	str	r4, [r3, #60]	; 0x3c
    v->FX = 0;
   25f26:	659c      	str	r4, [r3, #88]	; 0x58
    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
   25f28:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
   25f2c:	67dc      	str	r4, [r3, #124]	; 0x7c
   25f2e:	679c      	str	r4, [r3, #120]	; 0x78
   25f30:	675c      	str	r4, [r3, #116]	; 0x74
   25f32:	671c      	str	r4, [r3, #112]	; 0x70
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;
   25f34:	66dc      	str	r4, [r3, #108]	; 0x6c
   25f36:	669c      	str	r4, [r3, #104]	; 0x68
   25f38:	665c      	str	r4, [r3, #100]	; 0x64
   25f3a:	661c      	str	r4, [r3, #96]	; 0x60
   25f3c:	65dc      	str	r4, [r3, #92]	; 0x5c
    for (int32_t i = 0; i < v->bufsize; i++)
   25f3e:	dd12      	ble.n	25f66 <tTalkboxFloat_initToPool+0xf2>
   25f40:	4629      	mov	r1, r5
    {
        v->buf0[i] = 0;
   25f42:	4622      	mov	r2, r4
   25f44:	0088      	lsls	r0, r1, #2
   25f46:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    for (int32_t i = 0; i < v->bufsize; i++)
   25f48:	3101      	adds	r1, #1
        v->buf0[i] = 0;
   25f4a:	4404      	add	r4, r0
   25f4c:	6022      	str	r2, [r4, #0]
        v->buf1[i] = 0;
   25f4e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   25f50:	4404      	add	r4, r0
   25f52:	6022      	str	r2, [r4, #0]
        v->car0[i] = 0;
   25f54:	699c      	ldr	r4, [r3, #24]
   25f56:	4404      	add	r4, r0
   25f58:	6022      	str	r2, [r4, #0]
        v->car1[i] = 0;
   25f5a:	69dc      	ldr	r4, [r3, #28]
   25f5c:	4420      	add	r0, r4
   25f5e:	6002      	str	r2, [r0, #0]
    for (int32_t i = 0; i < v->bufsize; i++)
   25f60:	6958      	ldr	r0, [r3, #20]
   25f62:	4281      	cmp	r1, r0
   25f64:	dbee      	blt.n	25f44 <tTalkboxFloat_initToPool+0xd0>
}
   25f66:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   25f6a:	bf00      	nop

00025f6c <tTalkboxFloat_warpedAutocorrelate>:

// warped autocorrelation adapted from ten.enegatum@liam's post on music-dsp 2004-04-07 09:37:51
//find the order-P autocorrelation array, R, for the sequence x of length L and warping of lambda
//wAutocorrelate(&pfSrc[stIndex],siglen,R,P,0);
void tTalkboxFloat_warpedAutocorrelate(float * x, float* dl, float* Rt, unsigned int L, float * R, unsigned int P, float lambda)
{
   25f6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    float r1,r2,r1t;
    R[0]=0;
   25f70:	ed9f 7a34 	vldr	s14, [pc, #208]	; 26044 <tTalkboxFloat_warpedAutocorrelate+0xd8>
{
   25f74:	f8dd e01c 	ldr.w	lr, [sp, #28]
   25f78:	9d08      	ldr	r5, [sp, #32]
    R[0]=0;
   25f7a:	ed8e 7a00 	vstr	s14, [lr]
    Rt[0]=0;
   25f7e:	ed82 7a00 	vstr	s14, [r2]
    r1=0;
    r2=0;
    r1t=0;
    for(uint32_t m=0; m<L;m++)
   25f82:	b1f3      	cbz	r3, 25fc2 <tTalkboxFloat_warpedAutocorrelate+0x56>
   25f84:	4604      	mov	r4, r0
   25f86:	460e      	mov	r6, r1
   25f88:	eb00 0783 	add.w	r7, r0, r3, lsl #2
    r2=0;
   25f8c:	eef0 7a47 	vmov.f32	s15, s14
    r1=0;
   25f90:	eeb0 6a47 	vmov.f32	s12, s14
   25f94:	e001      	b.n	25f9a <tTalkboxFloat_warpedAutocorrelate+0x2e>
   25f96:	ed92 7a00 	vldr	s14, [r2]
    {
                    Rt[0] += (x[m]) * (x[m]);
   25f9a:	edd4 6a00 	vldr	s13, [r4]
   25f9e:	eea6 7aa6 	vfma.f32	s14, s13, s13
   25fa2:	ed82 7a00 	vstr	s14, [r2]

                    dl[m]= r1 - lambda * (x[m]-r2);
   25fa6:	ecb4 7a01 	vldmia	r4!, {s14}
   25faa:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for(uint32_t m=0; m<L;m++)
   25fae:	42bc      	cmp	r4, r7
                    dl[m]= r1 - lambda * (x[m]-r2);
   25fb0:	eea7 6a80 	vfma.f32	s12, s15, s0
   25fb4:	eef0 7a46 	vmov.f32	s15, s12
   25fb8:	eca6 6a01 	vstmia	r6!, {s12}
                    r1 = x[m];
   25fbc:	ed14 6a01 	vldr	s12, [r4, #-4]
    for(uint32_t m=0; m<L;m++)
   25fc0:	d1e9      	bne.n	25f96 <tTalkboxFloat_warpedAutocorrelate+0x2a>
                    r2 = dl[m];
    }
    for(uint32_t i=1; i<=P; i++)
   25fc2:	b3d5      	cbz	r5, 2603a <tTalkboxFloat_warpedAutocorrelate+0xce>
   25fc4:	ea4f 0885 	mov.w	r8, r5, lsl #2
   25fc8:	4694      	mov	ip, r2
   25fca:	1d15      	adds	r5, r2, #4
   25fcc:	eb01 0783 	add.w	r7, r1, r3, lsl #2
   25fd0:	f108 0804 	add.w	r8, r8, #4
    {
            Rt[i]=0;
   25fd4:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 26044 <tTalkboxFloat_warpedAutocorrelate+0xd8>
   25fd8:	eb02 0908 	add.w	r9, r2, r8
   25fdc:	eca5 5a01 	vstmia	r5!, {s10}
            r1=0;
            r2=0;
            for(unsigned int m=0; m<L;m++)
   25fe0:	b303      	cbz	r3, 26024 <tTalkboxFloat_warpedAutocorrelate+0xb8>
   25fe2:	4606      	mov	r6, r0
   25fe4:	460c      	mov	r4, r1
   25fe6:	eeb0 7a45 	vmov.f32	s14, s10
            r2=0;
   25fea:	eef0 7a45 	vmov.f32	s15, s10
            r1=0;
   25fee:	eef0 6a45 	vmov.f32	s13, s10
   25ff2:	e001      	b.n	25ff8 <tTalkboxFloat_warpedAutocorrelate+0x8c>
   25ff4:	ed15 7a01 	vldr	s14, [r5, #-4]
            {
                    Rt[i] +=  (dl[m]) * (x[m]);
   25ff8:	edd4 5a00 	vldr	s11, [r4]
   25ffc:	ecb6 6a01 	vldmia	r6!, {s12}
   26000:	eea5 7a86 	vfma.f32	s14, s11, s12
   26004:	ed05 7a01 	vstr	s14, [r5, #-4]

                    r1t = dl[m];
   26008:	ecb4 7a01 	vldmia	r4!, {s14}
                    dl[m]= r1 - lambda * (r1t-r2);
   2600c:	ee77 7ac7 	vsub.f32	s15, s15, s14
            for(unsigned int m=0; m<L;m++)
   26010:	42a7      	cmp	r7, r4
                    dl[m]= r1 - lambda * (r1t-r2);
   26012:	eee7 6a80 	vfma.f32	s13, s15, s0
   26016:	eef0 7a66 	vmov.f32	s15, s13
                    r1 = r1t;
   2601a:	eef0 6a47 	vmov.f32	s13, s14
                    dl[m]= r1 - lambda * (r1t-r2);
   2601e:	ed44 7a01 	vstr	s15, [r4, #-4]
            for(unsigned int m=0; m<L;m++)
   26022:	d1e7      	bne.n	25ff4 <tTalkboxFloat_warpedAutocorrelate+0x88>
    for(uint32_t i=1; i<=P; i++)
   26024:	45a9      	cmp	r9, r5
   26026:	d1d9      	bne.n	25fdc <tTalkboxFloat_warpedAutocorrelate+0x70>
   26028:	4442      	add	r2, r8
                    r2 = dl[m];
            }
    }
    for(uint32_t i=0; i<=P; i++)
    {
            R[i]=Rt[i];
   2602a:	f85c 3b04 	ldr.w	r3, [ip], #4
    for(uint32_t i=0; i<=P; i++)
   2602e:	4562      	cmp	r2, ip
            R[i]=Rt[i];
   26030:	f84e 3b04 	str.w	r3, [lr], #4
    for(uint32_t i=0; i<=P; i++)
   26034:	d1f9      	bne.n	2602a <tTalkboxFloat_warpedAutocorrelate+0xbe>
    }

}
   26036:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            R[i]=Rt[i];
   2603a:	6813      	ldr	r3, [r2, #0]
   2603c:	f8ce 3000 	str.w	r3, [lr]
}
   26040:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   26044:	00000000 	.word	0x00000000

00026048 <tTalkboxFloat_lpc>:
    return o;
}


void tTalkboxFloat_lpc(float *buf, float *car, float* dl, float* Rt, int32_t n, int32_t o, float warp, int warpOn, float *k, int freeze, float *G)
{
   26048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2604c:	ed2d 8b02 	vpush	{d8}
   26050:	b0c9      	sub	sp, #292	; 0x124
   26052:	4604      	mov	r4, r0
   26054:	468b      	mov	fp, r1
   26056:	9f56      	ldr	r7, [sp, #344]	; 0x158
   26058:	9d54      	ldr	r5, [sp, #336]	; 0x150
   2605a:	9e55      	ldr	r6, [sp, #340]	; 0x154
   2605c:	f8dd 8164 	ldr.w	r8, [sp, #356]	; 0x164
    float z[ORD_MAX], r[ORD_MAX], x;
    int32_t i, j, nn=n;


	if (warpOn == 0)
   26060:	2f00      	cmp	r7, #0
   26062:	d03a      	beq.n	260da <tTalkboxFloat_lpc+0x92>
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
		}
	}
	else
	{
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   26064:	2e00      	cmp	r6, #0
   26066:	4692      	mov	sl, r2
   26068:	eeb0 8a40 	vmov.f32	s16, s0
   2606c:	f2c0 80b7 	blt.w	261de <tTalkboxFloat_lpc+0x196>
		{
			z[j] = r[j] = 0.0f;
   26070:	1c77      	adds	r7, r6, #1
   26072:	a826      	add	r0, sp, #152	; 0x98
   26074:	2100      	movs	r1, #0
   26076:	9303      	str	r3, [sp, #12]
   26078:	00bf      	lsls	r7, r7, #2
   2607a:	9002      	str	r0, [sp, #8]
   2607c:	463a      	mov	r2, r7
   2607e:	f006 fce0 	bl	2ca42 <memset>
   26082:	463a      	mov	r2, r7
   26084:	2100      	movs	r1, #0
   26086:	a804      	add	r0, sp, #16
   26088:	f006 fcdb 	bl	2ca42 <memset>
   2608c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
		}
		tTalkboxFloat_warpedAutocorrelate(buf, dl, Rt, n, r, o, warp);
   26090:	9200      	str	r2, [sp, #0]
   26092:	eeb0 0a48 	vmov.f32	s0, s16
   26096:	461a      	mov	r2, r3
   26098:	9601      	str	r6, [sp, #4]
   2609a:	4651      	mov	r1, sl
   2609c:	462b      	mov	r3, r5
   2609e:	4620      	mov	r0, r4
   260a0:	f7ff ff64 	bl	25f6c <tTalkboxFloat_warpedAutocorrelate>
	}

	r[0] *= 1.001f;  //stability fix
   260a4:	eddd 7a26 	vldr	s15, [sp, #152]	; 0x98
   260a8:	ed9f 7a4e 	vldr	s14, [pc, #312]	; 261e4 <tTalkboxFloat_lpc+0x19c>

	float min = 0.000001f;
	if (!freeze)
   260ac:	9b58      	ldr	r3, [sp, #352]	; 0x160
	r[0] *= 1.001f;  //stability fix
   260ae:	ee67 7a87 	vmul.f32	s15, s15, s14
   260b2:	edcd 7a26 	vstr	s15, [sp, #152]	; 0x98
	if (!freeze)
   260b6:	2b00      	cmp	r3, #0
   260b8:	d13f      	bne.n	2613a <tTalkboxFloat_lpc+0xf2>
	{
		if(r[0] < min)
   260ba:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 261e8 <tTalkboxFloat_lpc+0x1a0>
   260be:	eef4 7ac7 	vcmpe.f32	s15, s14
   260c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   260c6:	d566      	bpl.n	26196 <tTalkboxFloat_lpc+0x14e>
		{
//            for(i=0; i<n; i++)
//            {
				buf[i] = 0.0f;
   260c8:	eb04 0489 	add.w	r4, r4, r9, lsl #2
   260cc:	2300      	movs	r3, #0
   260ce:	6023      	str	r3, [r4, #0]
            x -= k[j] * z[j-1];
            z[j] = z[j-1] + k[j] * x;
        }
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
    }
}
   260d0:	b049      	add	sp, #292	; 0x124
   260d2:	ecbd 8b02 	vpop	{d8}
   260d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   260da:	2e00      	cmp	r6, #0
   260dc:	dbe2      	blt.n	260a4 <tTalkboxFloat_lpc+0x5c>
   260de:	4629      	mov	r1, r5
			z[j] = r[j] = 0.0f;
   260e0:	f04f 0a00 	mov.w	sl, #0
   260e4:	ea6f 0e06 	mvn.w	lr, r6
   260e8:	af26      	add	r7, sp, #152	; 0x98
   260ea:	f10d 0c10 	add.w	ip, sp, #16
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   260ee:	2900      	cmp	r1, #0
   260f0:	eb00 0285 	add.w	r2, r0, r5, lsl #2
   260f4:	44ae      	add	lr, r5
			z[j] = r[j] = 0.0f;
   260f6:	f847 ab04 	str.w	sl, [r7], #4
   260fa:	f84c ab04 	str.w	sl, [ip], #4
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   260fe:	dd19      	ble.n	26134 <tTalkboxFloat_lpc+0xec>
   26100:	4681      	mov	r9, r0
   26102:	4623      	mov	r3, r4
   26104:	eddf 7a39 	vldr	s15, [pc, #228]	; 261ec <tTalkboxFloat_lpc+0x1a4>
   26108:	ecf3 6a01 	vldmia	r3!, {s13}
   2610c:	ecb9 7a01 	vldmia	r9!, {s14}
   26110:	429a      	cmp	r2, r3
   26112:	eee6 7a87 	vfma.f32	s15, s13, s14
   26116:	d1f7      	bne.n	26108 <tTalkboxFloat_lpc+0xc0>
   26118:	4689      	mov	r9, r1
   2611a:	ed47 7a01 	vstr	s15, [r7, #-4]
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
   2611e:	3901      	subs	r1, #1
   26120:	3004      	adds	r0, #4
   26122:	3a04      	subs	r2, #4
   26124:	458e      	cmp	lr, r1
   26126:	d0bd      	beq.n	260a4 <tTalkboxFloat_lpc+0x5c>
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   26128:	2900      	cmp	r1, #0
			z[j] = r[j] = 0.0f;
   2612a:	f847 ab04 	str.w	sl, [r7], #4
   2612e:	f84c ab04 	str.w	sl, [ip], #4
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
   26132:	dce5      	bgt.n	26100 <tTalkboxFloat_lpc+0xb8>
   26134:	f04f 0900 	mov.w	r9, #0
   26138:	e7f1      	b.n	2611e <tTalkboxFloat_lpc+0xd6>
    for(i=0; i<n; i++)
   2613a:	2d00      	cmp	r5, #0
   2613c:	ddc8      	ble.n	260d0 <tTalkboxFloat_lpc+0x88>
   2613e:	1c77      	adds	r7, r6, #1
   26140:	9b57      	ldr	r3, [sp, #348]	; 0x15c
   26142:	4658      	mov	r0, fp
   26144:	eb0b 0585 	add.w	r5, fp, r5, lsl #2
   26148:	00bf      	lsls	r7, r7, #2
   2614a:	1d19      	adds	r1, r3, #4
   2614c:	eb03 0c07 	add.w	ip, r3, r7
   26150:	ab04      	add	r3, sp, #16
   26152:	441f      	add	r7, r3
        x = G[0] * car[i];
   26154:	ecb0 7a01 	vldmia	r0!, {s14}
        for(j=o; j>0; j--)  //lattice filter
   26158:	2e00      	cmp	r6, #0
        x = G[0] * car[i];
   2615a:	edd8 7a00 	vldr	s15, [r8]
   2615e:	ee27 7a27 	vmul.f32	s14, s14, s15
        for(j=o; j>0; j--)  //lattice filter
   26162:	dd0d      	ble.n	26180 <tTalkboxFloat_lpc+0x138>
   26164:	463a      	mov	r2, r7
   26166:	4663      	mov	r3, ip
            x -= k[j] * z[j-1];
   26168:	ed73 6a01 	vldmdb	r3!, {s13}
   2616c:	ed52 7a02 	vldr	s15, [r2, #-8]
        for(j=o; j>0; j--)  //lattice filter
   26170:	4299      	cmp	r1, r3
            x -= k[j] * z[j-1];
   26172:	eea6 7ae7 	vfms.f32	s14, s13, s15
            z[j] = z[j-1] + k[j] * x;
   26176:	eee6 7a87 	vfma.f32	s15, s13, s14
   2617a:	ed62 7a01 	vstmdb	r2!, {s15}
        for(j=o; j>0; j--)  //lattice filter
   2617e:	d1f3      	bne.n	26168 <tTalkboxFloat_lpc+0x120>
    for(i=0; i<n; i++)
   26180:	4285      	cmp	r5, r0
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
   26182:	ed8d 7a04 	vstr	s14, [sp, #16]
   26186:	eca4 7a01 	vstmia	r4!, {s14}
    for(i=0; i<n; i++)
   2618a:	d1e3      	bne.n	26154 <tTalkboxFloat_lpc+0x10c>
}
   2618c:	b049      	add	sp, #292	; 0x124
   2618e:	ecbd 8b02 	vpop	{d8}
   26192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tTalkbox_lpcDurbin(r, o, k, G);  //calc reflection coeffs
   26196:	4643      	mov	r3, r8
   26198:	9a57      	ldr	r2, [sp, #348]	; 0x15c
   2619a:	4631      	mov	r1, r6
   2619c:	a826      	add	r0, sp, #152	; 0x98
   2619e:	f7ff fd2b 	bl	25bf8 <tTalkbox_lpcDurbin>
		for(i=0; i<=o; i++)
   261a2:	2e00      	cmp	r6, #0
   261a4:	dbc9      	blt.n	2613a <tTalkboxFloat_lpc+0xf2>
   261a6:	9b57      	ldr	r3, [sp, #348]	; 0x15c
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
   261a8:	ed9f 7a11 	vldr	s14, [pc, #68]	; 261f0 <tTalkboxFloat_lpc+0x1a8>
   261ac:	1d1a      	adds	r2, r3, #4
   261ae:	eddf 6a11 	vldr	s13, [pc, #68]	; 261f4 <tTalkboxFloat_lpc+0x1ac>
   261b2:	eb02 0286 	add.w	r2, r2, r6, lsl #2
   261b6:	e003      	b.n	261c0 <tTalkboxFloat_lpc+0x178>
   261b8:	ed03 7a01 	vstr	s14, [r3, #-4]
		for(i=0; i<=o; i++)
   261bc:	429a      	cmp	r2, r3
   261be:	d0bc      	beq.n	2613a <tTalkboxFloat_lpc+0xf2>
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
   261c0:	ecf3 7a01 	vldmia	r3!, {s15}
   261c4:	eef4 7ac7 	vcmpe.f32	s15, s14
   261c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   261cc:	dcf4      	bgt.n	261b8 <tTalkboxFloat_lpc+0x170>
   261ce:	eef4 7ae6 	vcmpe.f32	s15, s13
   261d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   261d6:	bf48      	it	mi
   261d8:	ed43 6a01 	vstrmi	s13, [r3, #-4]
   261dc:	e7ee      	b.n	261bc <tTalkboxFloat_lpc+0x174>
   261de:	aa26      	add	r2, sp, #152	; 0x98
   261e0:	9202      	str	r2, [sp, #8]
   261e2:	e755      	b.n	26090 <tTalkboxFloat_lpc+0x48>
   261e4:	3f8020c5 	.word	0x3f8020c5
   261e8:	358637bd 	.word	0x358637bd
   261ec:	00000000 	.word	0x00000000
   261f0:	3f7f7cee 	.word	0x3f7f7cee
   261f4:	bf7f7cee 	.word	0xbf7f7cee

000261f8 <tTalkboxFloat_tick>:
{
   261f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   261fc:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
   26200:	6804      	ldr	r4, [r0, #0]
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   26202:	eeb0 5a40 	vmov.f32	s10, s0
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   26206:	eddf 6a62 	vldr	s13, [pc, #392]	; 26390 <tTalkboxFloat_tick+0x198>
{
   2620a:	b086      	sub	sp, #24
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   2620c:	ed94 7a1b 	vldr	s14, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   26210:	eddf 5a60 	vldr	s11, [pc, #384]	; 26394 <tTalkboxFloat_tick+0x19c>
   26214:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   26218:	ed94 6a19 	vldr	s12, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   2621c:	eee0 7a25 	vfma.f32	s15, s0, s11
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   26220:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   26222:	eea7 6a26 	vfma.f32	s12, s14, s13
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   26226:	6e21      	ldr	r1, [r4, #96]	; 0x60
    if(v->K++)
   26228:	6c22      	ldr	r2, [r4, #64]	; 0x40
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   2622a:	6663      	str	r3, [r4, #100]	; 0x64
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   2622c:	65e1      	str	r1, [r4, #92]	; 0x5c
    v->d4 = x;
   2622e:	ed84 0a1b 	vstr	s0, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   26232:	eea7 5ae5 	vfms.f32	s10, s15, s11
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   26236:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   26238:	eea6 7a66 	vfms.f32	s14, s12, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   2623c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    float e=v->emphasis, w, o, x, fx=v->FX;
   2623e:	edd4 6a0f 	vldr	s13, [r4, #60]	; 0x3c
   26242:	ed94 8a16 	vldr	s16, [r4, #88]	; 0x58
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
   26246:	ed84 5a18 	vstr	s10, [r4, #96]	; 0x60
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
   2624a:	ed84 7a1a 	vstr	s14, [r4, #104]	; 0x68
    if(v->K++)
   2624e:	2a00      	cmp	r2, #0
   26250:	d06b      	beq.n	2632a <tTalkboxFloat_tick+0x132>
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   26252:	2b00      	cmp	r3, #0
   26254:	461e      	mov	r6, r3
        v->car0[p0] = v->car1[p1] = x; //carrier input
   26256:	69e0      	ldr	r0, [r4, #28]
    x = p + q;
   26258:	ee77 7a86 	vadd.f32	s15, s15, s12
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   2625c:	bfb8      	it	lt
   2625e:	1c5e      	addlt	r6, r3, #1
        v->K = 0;
   26260:	2700      	movs	r7, #0
        v->car0[p0] = v->car1[p1] = x; //carrier input
   26262:	00a9      	lsls	r1, r5, #2
        x = o - e;  e = o;  //6dB/oct pre-emphasis
   26264:	ee70 8ae6 	vsub.f32	s17, s1, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   26268:	eb05 0266 	add.w	r2, r5, r6, asr #1
        v->K = 0;
   2626c:	6427      	str	r7, [r4, #64]	; 0x40
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   2626e:	3501      	adds	r5, #1
   26270:	eeb0 9a60 	vmov.f32	s18, s1
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
   26274:	fb92 f6f3 	sdiv	r6, r2, r3
   26278:	fb03 2616 	mls	r6, r3, r6, r2
        v->car0[p0] = v->car1[p1] = x; //carrier input
   2627c:	ea4f 0886 	mov.w	r8, r6, lsl #2
   26280:	4440      	add	r0, r8
   26282:	edc0 7a00 	vstr	s15, [r0]
   26286:	69a3      	ldr	r3, [r4, #24]
   26288:	440b      	add	r3, r1
   2628a:	edc3 7a00 	vstr	s15, [r3]
        w = v->window[p0]; fx = v->buf0[p0] * w;  v->buf0[p0] = x * w;  //50% overlapping hanning windows
   2628e:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
   26292:	440a      	add	r2, r1
   26294:	440b      	add	r3, r1
   26296:	edd2 9a00 	vldr	s19, [r2]
   2629a:	ed93 8a00 	vldr	s16, [r3]
   2629e:	ee68 7aa9 	vmul.f32	s15, s17, s19
   262a2:	ee29 8a88 	vmul.f32	s16, s19, s16
   262a6:	edc3 7a00 	vstr	s15, [r3]
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   262aa:	f8d4 c044 	ldr.w	ip, [r4, #68]	; 0x44
   262ae:	45ac      	cmp	ip, r5
   262b0:	dd55      	ble.n	2635e <tTalkboxFloat_tick+0x166>
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
   262b2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   262b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   262b8:	3601      	adds	r6, #1
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
   262ba:	4498      	add	r8, r3
   262bc:	ee77 7ae9 	vsub.f32	s15, s15, s19
   262c0:	ed98 7a00 	vldr	s14, [r8]
   262c4:	ee68 6aa7 	vmul.f32	s13, s17, s15
   262c8:	eea7 8a27 	vfma.f32	s16, s14, s15
   262cc:	edc8 6a00 	vstr	s13, [r8]
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   262d0:	6c67      	ldr	r7, [r4, #68]	; 0x44
   262d2:	42b7      	cmp	r7, r6
   262d4:	dd2e      	ble.n	26334 <tTalkboxFloat_tick+0x13c>
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   262d6:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   262da:	eef0 5a48 	vmov.f32	s11, s16
   262de:	ed9f 6a2d 	vldr	s12, [pc, #180]	; 26394 <tTalkboxFloat_tick+0x19c>
   262e2:	ed94 0a1c 	vldr	s0, [r4, #112]	; 0x70
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   262e6:	eddf 6a2a 	vldr	s13, [pc, #168]	; 26390 <tTalkboxFloat_tick+0x198>
   262ea:	ed94 7a1e 	vldr	s14, [r4, #120]	; 0x78
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   262ee:	eea8 0a06 	vfma.f32	s0, s16, s12
   262f2:	6f62      	ldr	r2, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   262f4:	eea7 7aa6 	vfma.f32	s14, s15, s13
   262f8:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    v->emphasis = e;
   262fa:	ed84 9a0f 	vstr	s18, [r4, #60]	; 0x3c
    v->pos = p0;
   262fe:	64e5      	str	r5, [r4, #76]	; 0x4c
    v->FX = fx;
   26300:	ed84 8a16 	vstr	s16, [r4, #88]	; 0x58
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   26304:	eee0 5a46 	vfms.f32	s11, s0, s12
   26308:	6722      	str	r2, [r4, #112]	; 0x70
    v->u4 = fx;
   2630a:	ed84 8a20 	vstr	s16, [r4, #128]	; 0x80
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   2630e:	eee7 7a66 	vfms.f32	s15, s14, s13
   26312:	67a3      	str	r3, [r4, #120]	; 0x78
}
   26314:	ee30 0a07 	vadd.f32	s0, s0, s14
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
   26318:	edc4 5a1d 	vstr	s11, [r4, #116]	; 0x74
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
   2631c:	edc4 7a1f 	vstr	s15, [r4, #124]	; 0x7c
}
   26320:	b006      	add	sp, #24
   26322:	ecbd 8b04 	vpop	{d8-d9}
   26326:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(v->K++)
   2632a:	2301      	movs	r3, #1
    float e=v->emphasis, w, o, x, fx=v->FX;
   2632c:	eeb0 9a66 	vmov.f32	s18, s13
    if(v->K++)
   26330:	6423      	str	r3, [r4, #64]	; 0x40
   26332:	e7d0      	b.n	262d6 <tTalkboxFloat_tick+0xde>
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p1 = 0; }
   26334:	f104 0684 	add.w	r6, r4, #132	; 0x84
   26338:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   2633c:	69e1      	ldr	r1, [r4, #28]
   2633e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   26340:	e9d4 2322 	ldrd	r2, r3, [r4, #136]	; 0x88
   26344:	9605      	str	r6, [sp, #20]
   26346:	6ba6      	ldr	r6, [r4, #56]	; 0x38
   26348:	9604      	str	r6, [sp, #16]
   2634a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   2634c:	9603      	str	r6, [sp, #12]
   2634e:	6b66      	ldr	r6, [r4, #52]	; 0x34
   26350:	9602      	str	r6, [sp, #8]
   26352:	6ca6      	ldr	r6, [r4, #72]	; 0x48
   26354:	e9cd 7600 	strd	r7, r6, [sp]
   26358:	f7ff fe76 	bl	26048 <tTalkboxFloat_lpc>
   2635c:	e7bb      	b.n	262d6 <tTalkboxFloat_tick+0xde>
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->freeze, &v->G);  p0 = 0; }
   2635e:	f104 0e84 	add.w	lr, r4, #132	; 0x84
   26362:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   26366:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   2636a:	463d      	mov	r5, r7
   2636c:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
   26370:	69a1      	ldr	r1, [r4, #24]
   26372:	6a60      	ldr	r0, [r4, #36]	; 0x24
   26374:	f8cd e014 	str.w	lr, [sp, #20]
   26378:	6ba7      	ldr	r7, [r4, #56]	; 0x38
   2637a:	9704      	str	r7, [sp, #16]
   2637c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   2637e:	9703      	str	r7, [sp, #12]
   26380:	6b67      	ldr	r7, [r4, #52]	; 0x34
   26382:	9702      	str	r7, [sp, #8]
   26384:	6ca7      	ldr	r7, [r4, #72]	; 0x48
   26386:	e9cd c700 	strd	ip, r7, [sp]
   2638a:	f7ff fe5d 	bl	26048 <tTalkboxFloat_lpc>
   2638e:	e790      	b.n	262b2 <tTalkboxFloat_tick+0xba>
   26390:	3f451eb8 	.word	0x3f451eb8
   26394:	3e99999a 	.word	0x3e99999a

00026398 <tTalkboxFloat_setQuality>:

void tTalkboxFloat_setQuality(tTalkboxFloat* const voc, float quality)
{
    _tTalkboxFloat* v = *voc;
    v->param[3] = quality;
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   26398:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 263c8 <tTalkboxFloat_setQuality+0x30>
   2639c:	eddf 7a0b 	vldr	s15, [pc, #44]	; 263cc <tTalkboxFloat_setQuality+0x34>
   263a0:	4b0b      	ldr	r3, [pc, #44]	; (263d0 <tTalkboxFloat_setQuality+0x38>)
   263a2:	eee0 7a07 	vfma.f32	s15, s0, s14
    _tTalkboxFloat* v = *voc;
   263a6:	6802      	ldr	r2, [r0, #0]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   263a8:	ed93 7a00 	vldr	s14, [r3]
    v->param[3] = quality;
   263ac:	ed82 0a04 	vstr	s0, [r2, #16]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
   263b0:	ee67 7a87 	vmul.f32	s15, s15, s14
   263b4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   263b8:	ee17 3a90 	vmov	r3, s15
    if (v->O >= ORD_MAX)
   263bc:	2b21      	cmp	r3, #33	; 0x21
    {
    	v->O = ORD_MAX-1;
   263be:	bfc8      	it	gt
   263c0:	2321      	movgt	r3, #33	; 0x21
   263c2:	6493      	str	r3, [r2, #72]	; 0x48
    }
}
   263c4:	4770      	bx	lr
   263c6:	bf00      	nop
   263c8:	39d1b717 	.word	0x39d1b717
   263cc:	38d1b717 	.word	0x38d1b717
   263d0:	020fc0a8 	.word	0x020fc0a8

000263d4 <tTalkboxFloat_setWarpFactor>:

void tTalkboxFloat_setWarpFactor(tTalkboxFloat* const voc, float warpFactor)
{
    _tTalkboxFloat* v = *voc;
   263d4:	6803      	ldr	r3, [r0, #0]

    v->warpFactor = warpFactor;
   263d6:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
}
   263da:	4770      	bx	lr

000263dc <tTalkboxFloat_setWarpOn>:

void tTalkboxFloat_setWarpOn(tTalkboxFloat* const voc, float warpOn)
{
    _tTalkboxFloat* v = *voc;

    v->warpOn = warpOn;
   263dc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
   263e0:	6803      	ldr	r3, [r0, #0]
    v->warpOn = warpOn;
   263e2:	ed83 0a0d 	vstr	s0, [r3, #52]	; 0x34
}
   263e6:	4770      	bx	lr

000263e8 <tTalkboxFloat_setFreeze>:

void tTalkboxFloat_setFreeze(tTalkboxFloat* const voc, float freeze)
{
    _tTalkboxFloat* v = *voc;

    v->freeze = freeze;
   263e8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
   263ec:	6803      	ldr	r3, [r0, #0]
    v->freeze = freeze;
   263ee:	ed83 0a0e 	vstr	s0, [r3, #56]	; 0x38
}
   263f2:	4770      	bx	lr

000263f4 <tRosenbergGlottalPulse_initToPool>:
{
    tRosenbergGlottalPulse_initToPool(gp, &leaf.mempool);
}

void tRosenbergGlottalPulse_initToPool (tRosenbergGlottalPulse* const gp, tMempool* const mp)
{
   263f4:	b538      	push	{r3, r4, r5, lr}
     _tMempool* m = *mp;
   263f6:	680c      	ldr	r4, [r1, #0]
{
   263f8:	4605      	mov	r5, r0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
   263fa:	201c      	movs	r0, #28
   263fc:	4621      	mov	r1, r4
   263fe:	f003 fc43 	bl	29c88 <mpool_alloc>
    g->mempool = m;

    g->phase  = 0.0f;
   26402:	2300      	movs	r3, #0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
   26404:	6028      	str	r0, [r5, #0]
    g->mempool = m;
   26406:	6004      	str	r4, [r0, #0]
    g->phase  = 0.0f;
   26408:	6043      	str	r3, [r0, #4]
    g->openLength = 0.0f;
   2640a:	6083      	str	r3, [r0, #8]
    g->pulseLength = 0.0f;
   2640c:	60c3      	str	r3, [r0, #12]
    g->freq = 0.0f;
   2640e:	6143      	str	r3, [r0, #20]
    g->inc = 0.0f;
   26410:	6183      	str	r3, [r0, #24]


}
   26412:	bd38      	pop	{r3, r4, r5, pc}

00026414 <tRosenbergGlottalPulse_free>:
void tRosenbergGlottalPulse_free (tRosenbergGlottalPulse* const gp)
{
    _tRosenbergGlottalPulse* g = *gp;
   26414:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)g, g->mempool);
   26416:	6801      	ldr	r1, [r0, #0]
   26418:	f003 bcde 	b.w	29dd8 <mpool_free>

0002641c <tRosenbergGlottalPulse_tick>:
}

float   tRosenbergGlottalPulse_tick           (tRosenbergGlottalPulse* const gp)
{
   2641c:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
   2641e:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26420:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
   26424:	ed93 7a01 	vldr	s14, [r3, #4]
   26428:	edd3 7a06 	vldr	s15, [r3, #24]
   2642c:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26430:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
   26434:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26438:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2643c:	db51      	blt.n	264e2 <tRosenbergGlottalPulse_tick+0xc6>
   2643e:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   26442:	eeb4 7ac6 	vcmpe.f32	s14, s12
   26446:	ee77 7a66 	vsub.f32	s15, s14, s13
   2644a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2644e:	eeb0 7a67 	vmov.f32	s14, s15
   26452:	daf6      	bge.n	26442 <tRosenbergGlottalPulse_tick+0x26>
   26454:	edc3 7a01 	vstr	s15, [r3, #4]
    while (g->phase < 0.0f) g->phase += 1.0f;
   26458:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2645c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26460:	d53c      	bpl.n	264dc <tRosenbergGlottalPulse_tick+0xc0>
   26462:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   26466:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2646a:	eef4 7ac7 	vcmpe.f32	s15, s14
   2646e:	ee37 0aa6 	vadd.f32	s0, s15, s13
   26472:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26476:	eef0 7a40 	vmov.f32	s15, s0
   2647a:	d4f6      	bmi.n	2646a <tRosenbergGlottalPulse_tick+0x4e>
   2647c:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
   26480:	edd3 7a02 	vldr	s15, [r3, #8]
   26484:	eef4 7ac0 	vcmpe.f32	s15, s0
   26488:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2648c:	dc17      	bgt.n	264be <tRosenbergGlottalPulse_tick+0xa2>
    {
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
   2648e:	ed93 7a03 	vldr	s14, [r3, #12]
   26492:	eeb4 7ac0 	vcmpe.f32	s14, s0
   26496:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2649a:	dc02      	bgt.n	264a2 <tRosenbergGlottalPulse_tick+0x86>
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
    }

    else
    {
        output = 0.0f;
   2649c:	ed9f 0a12 	vldr	s0, [pc, #72]	; 264e8 <tRosenbergGlottalPulse_tick+0xcc>
    }
    return output;
}
   264a0:	bd08      	pop	{r3, pc}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   264a2:	ed93 7a04 	vldr	s14, [r3, #16]
   264a6:	ee30 0a67 	vsub.f32	s0, s0, s15
   264aa:	eddf 7a10 	vldr	s15, [pc, #64]	; 264ec <tRosenbergGlottalPulse_tick+0xd0>
   264ae:	ee67 7a27 	vmul.f32	s15, s14, s15
}
   264b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   264b6:	ee27 0a80 	vmul.f32	s0, s15, s0
   264ba:	f003 b8f9 	b.w	296b0 <fastercosf>
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
   264be:	eddf 7a0c 	vldr	s15, [pc, #48]	; 264f0 <tRosenbergGlottalPulse_tick+0xd4>
   264c2:	ee20 0a27 	vmul.f32	s0, s0, s15
   264c6:	f003 f8f3 	bl	296b0 <fastercosf>
   264ca:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   264ce:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   264d2:	ee37 0ac0 	vsub.f32	s0, s15, s0
   264d6:	ee20 0a07 	vmul.f32	s0, s0, s14
}
   264da:	bd08      	pop	{r3, pc}
    while (g->phase < 0.0f) g->phase += 1.0f;
   264dc:	eeb0 0a67 	vmov.f32	s0, s15
   264e0:	e7ce      	b.n	26480 <tRosenbergGlottalPulse_tick+0x64>
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   264e2:	eef0 7a47 	vmov.f32	s15, s14
   264e6:	e7b7      	b.n	26458 <tRosenbergGlottalPulse_tick+0x3c>
   264e8:	00000000 	.word	0x00000000
   264ec:	3fc90fdb 	.word	0x3fc90fdb
   264f0:	40490fdb 	.word	0x40490fdb

000264f4 <tRosenbergGlottalPulse_tickHQ>:


float   tRosenbergGlottalPulse_tickHQ           (tRosenbergGlottalPulse* const gp)
{
   264f4:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
   264f6:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   264f8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
   264fc:	ed93 7a01 	vldr	s14, [r3, #4]
   26500:	edd3 7a06 	vldr	s15, [r3, #24]
   26504:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26508:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
   2650c:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   26510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26514:	db4e      	blt.n	265b4 <tRosenbergGlottalPulse_tickHQ+0xc0>
   26516:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2651a:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2651e:	ee77 7a66 	vsub.f32	s15, s14, s13
   26522:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26526:	eeb0 7a67 	vmov.f32	s14, s15
   2652a:	daf6      	bge.n	2651a <tRosenbergGlottalPulse_tickHQ+0x26>
    while (g->phase < 0.0f) g->phase += 1.0f;
   2652c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   26530:	edc3 7a01 	vstr	s15, [r3, #4]
   26534:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26538:	d543      	bpl.n	265c2 <tRosenbergGlottalPulse_tickHQ+0xce>
   2653a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2653e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   26542:	eef4 7ac7 	vcmpe.f32	s15, s14
   26546:	ee37 0aa6 	vadd.f32	s0, s15, s13
   2654a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2654e:	eef0 7a40 	vmov.f32	s15, s0
   26552:	d4f6      	bmi.n	26542 <tRosenbergGlottalPulse_tickHQ+0x4e>
   26554:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
   26558:	edd3 7a02 	vldr	s15, [r3, #8]
   2655c:	eef4 7ac0 	vcmpe.f32	s15, s0
   26560:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26564:	dc17      	bgt.n	26596 <tRosenbergGlottalPulse_tickHQ+0xa2>
    {
        output = 0.5f*(1.0f-cosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
   26566:	ed93 7a03 	vldr	s14, [r3, #12]
   2656a:	eeb4 7ac0 	vcmpe.f32	s14, s0
   2656e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26572:	dd0d      	ble.n	26590 <tRosenbergGlottalPulse_tickHQ+0x9c>
    {
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   26574:	ed93 7a04 	vldr	s14, [r3, #16]
   26578:	ee30 0a67 	vsub.f32	s0, s0, s15
   2657c:	eddf 7a12 	vldr	s15, [pc, #72]	; 265c8 <tRosenbergGlottalPulse_tickHQ+0xd4>
   26580:	ee67 7a27 	vmul.f32	s15, s14, s15
    else
    {
        output = 0.0f;
    }
    return output;
}
   26584:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
   26588:	ee27 0a80 	vmul.f32	s0, s15, s0
   2658c:	f006 bb82 	b.w	2cc94 <cosf>
        output = 0.0f;
   26590:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 265cc <tRosenbergGlottalPulse_tickHQ+0xd8>
}
   26594:	bd08      	pop	{r3, pc}
        output = 0.5f*(1.0f-cosf(PI * g->phase));
   26596:	eddf 7a0e 	vldr	s15, [pc, #56]	; 265d0 <tRosenbergGlottalPulse_tickHQ+0xdc>
   2659a:	ee20 0a27 	vmul.f32	s0, s0, s15
   2659e:	f006 fb79 	bl	2cc94 <cosf>
   265a2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   265a6:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   265aa:	ee37 0ac0 	vsub.f32	s0, s15, s0
   265ae:	ee20 0a07 	vmul.f32	s0, s0, s14
}
   265b2:	bd08      	pop	{r3, pc}
    while (g->phase >= 1.0f) g->phase -= 1.0f;
   265b4:	eef0 7a47 	vmov.f32	s15, s14
    while (g->phase < 0.0f) g->phase += 1.0f;
   265b8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   265bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   265c0:	d4bb      	bmi.n	2653a <tRosenbergGlottalPulse_tickHQ+0x46>
   265c2:	eeb0 0a67 	vmov.f32	s0, s15
   265c6:	e7c7      	b.n	26558 <tRosenbergGlottalPulse_tickHQ+0x64>
   265c8:	3fc90fdb 	.word	0x3fc90fdb
   265cc:	00000000 	.word	0x00000000
   265d0:	40490fdb 	.word	0x40490fdb

000265d4 <tRosenbergGlottalPulse_setFreq>:

void   tRosenbergGlottalPulse_setFreq           (tRosenbergGlottalPulse* const gp, float freq)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->freq = freq;
    g->inc = freq * leaf.invSampleRate;
   265d4:	4a05      	ldr	r2, [pc, #20]	; (265ec <tRosenbergGlottalPulse_setFreq+0x18>)
    _tRosenbergGlottalPulse* g = *gp;
   265d6:	6803      	ldr	r3, [r0, #0]
    g->inc = freq * leaf.invSampleRate;
   265d8:	edd2 7a01 	vldr	s15, [r2, #4]
    g->freq = freq;
   265dc:	ed83 0a05 	vstr	s0, [r3, #20]
    g->inc = freq * leaf.invSampleRate;
   265e0:	ee27 0a80 	vmul.f32	s0, s15, s0
   265e4:	ed83 0a06 	vstr	s0, [r3, #24]
}
   265e8:	4770      	bx	lr
   265ea:	bf00      	nop
   265ec:	020fc0a8 	.word	0x020fc0a8

000265f0 <tRosenbergGlottalPulse_setOpenLength>:

void   tRosenbergGlottalPulse_setOpenLength           (tRosenbergGlottalPulse* const gp, float openLength)
{
    _tRosenbergGlottalPulse* g = *gp;
   265f0:	6803      	ldr	r3, [r0, #0]
    g->openLength = openLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   265f2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   265f6:	edd3 7a03 	vldr	s15, [r3, #12]
    g->openLength = openLength;
   265fa:	ed83 0a02 	vstr	s0, [r3, #8]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   265fe:	ee37 0ac0 	vsub.f32	s0, s15, s0
   26602:	eec7 7a00 	vdiv.f32	s15, s14, s0
   26606:	edc3 7a04 	vstr	s15, [r3, #16]
}
   2660a:	4770      	bx	lr

0002660c <tRosenbergGlottalPulse_setPulseLength>:

void   tRosenbergGlottalPulse_setPulseLength           (tRosenbergGlottalPulse* const gp, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
   2660c:	6803      	ldr	r3, [r0, #0]
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   2660e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   26612:	edd3 7a02 	vldr	s15, [r3, #8]
    g->pulseLength = pulseLength;
   26616:	ed83 0a03 	vstr	s0, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   2661a:	ee30 0a67 	vsub.f32	s0, s0, s15
   2661e:	eec7 7a00 	vdiv.f32	s15, s14, s0
   26622:	edc3 7a04 	vstr	s15, [r3, #16]
}
   26626:	4770      	bx	lr

00026628 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>:
void   tRosenbergGlottalPulse_setOpenLengthAndPulseLength           (tRosenbergGlottalPulse* const gp, float openLength, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->openLength = openLength;
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   26628:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tRosenbergGlottalPulse* g = *gp;
   2662c:	6803      	ldr	r3, [r0, #0]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   2662e:	ee30 7ac0 	vsub.f32	s14, s1, s0
    g->openLength = openLength;
   26632:	ed83 0a02 	vstr	s0, [r3, #8]
    g->pulseLength = pulseLength;
   26636:	edc3 0a03 	vstr	s1, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
   2663a:	eec6 7a87 	vdiv.f32	s15, s13, s14
   2663e:	edc3 7a04 	vstr	s15, [r3, #16]
}
   26642:	4770      	bx	lr

00026644 <tSOLAD_ioSamples>:
    mpool_free((char*)w, w->mempool);
}

// send one block of input samples, receive one block of output samples
void tSOLAD_ioSamples(tSOLAD* const wp, float* in, float* out, int blocksize)
{
   26644:	b4f0      	push	{r4, r5, r6, r7}
   26646:	ed2d 8b02 	vpush	{d8}
    _tSOLAD* w = *wp;
   2664a:	6800      	ldr	r0, [r0, #0]
    
    int i = w->timeindex;
    int n = w->blocksize = blocksize;
   2664c:	b29d      	uxth	r5, r3
    int i = w->timeindex;
   2664e:	8886      	ldrh	r6, [r0, #4]
   26650:	462b      	mov	r3, r5
    int n = w->blocksize = blocksize;
   26652:	80c5      	strh	r5, [r0, #6]
    
    if(!i) w->delaybuf[LOOPSIZE] = in[0];   // copy one sample for interpolation
   26654:	b926      	cbnz	r6, 26660 <tSOLAD_ioSamples+0x1c>
   26656:	6a04      	ldr	r4, [r0, #32]
   26658:	680f      	ldr	r7, [r1, #0]
   2665a:	f504 4480 	add.w	r4, r4, #16384	; 0x4000
   2665e:	6027      	str	r7, [r4, #0]
    while(n--) w->delaybuf[i++] = *in++;    // copy one input block to delay buffer
   26660:	b163      	cbz	r3, 2667c <tSOLAD_ioSamples+0x38>
   26662:	eb01 0483 	add.w	r4, r1, r3, lsl #2
   26666:	ebc1 0c86 	rsb	ip, r1, r6, lsl #2
   2666a:	eb0c 0701 	add.w	r7, ip, r1
   2666e:	6a03      	ldr	r3, [r0, #32]
   26670:	f851 6b04 	ldr.w	r6, [r1], #4
   26674:	443b      	add	r3, r7
   26676:	428c      	cmp	r4, r1
   26678:	601e      	str	r6, [r3, #0]
   2667a:	d1f6      	bne.n	2666a <tSOLAD_ioSamples+0x26>
    
    if(w->pitchfactor > 1) pitchup(w, out);
   2667c:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
   26680:	edd0 6a02 	vldr	s13, [r0, #8]
   26684:	8883      	ldrh	r3, [r0, #4]
   26686:	edd0 3a04 	vldr	s7, [r0, #16]
   2668a:	eef4 6ac2 	vcmpe.f32	s13, s4
   2668e:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
   26692:	edd0 7a03 	vldr	s15, [r0, #12]
   26696:	ee06 1a10 	vmov	s12, r1
   2669a:	edd0 5a05 	vldr	s11, [r0, #20]
   2669e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   266a2:	88c1      	ldrh	r1, [r0, #6]
   266a4:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
   266a8:	ed90 7a07 	vldr	s14, [r0, #28]
   266ac:	ed90 3a06 	vldr	s6, [r0, #24]
   266b0:	f340 80b8 	ble.w	26824 <tSOLAD_ioSamples+0x1e0>
    float xfadelength = w->xfadelength;
    
    float readlagstep = pitchfactor - 1;
    float xfadespeed = pitchfactor * pitchfactor;
    float xfadestep = xfadespeed / xfadelength;
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
   266b4:	ed9f 5aa1 	vldr	s10, [pc, #644]	; 2693c <tSOLAD_ioSamples+0x2f8>
    float xfadespeed = pitchfactor * pitchfactor;
   266b8:	ee66 1aa6 	vmul.f32	s3, s13, s13
    float readlagstep = pitchfactor - 1;
   266bc:	ee36 2ac2 	vsub.f32	s4, s13, s4
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
   266c0:	ee76 6ac5 	vsub.f32	s13, s13, s10
   266c4:	ee86 5aa1 	vdiv.f32	s10, s13, s3
    float limit = period * limitfactor;
   266c8:	ee25 1a23 	vmul.f32	s2, s10, s7
    float readindex, outputsample;
    
    if((readlag > (period + 2 * limit)) & (xfadevalue < 0))
   266cc:	ee71 6a01 	vadd.f32	s13, s2, s2
   266d0:	ee76 4aa3 	vadd.f32	s9, s13, s7
   266d4:	eef4 4a67 	vcmp.f32	s9, s15
   266d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   266dc:	f140 808a 	bpl.w	267f4 <tSOLAD_ioSamples+0x1b0>
   266e0:	eeb5 7a40 	vcmp.f32	s14, #0.0
   266e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   266e8:	f140 8084 	bpl.w	267f4 <tSOLAD_ioSamples+0x1b0>
   266ec:	ee77 6ae6 	vsub.f32	s13, s15, s13
    {
        jump = period;                                        // jump forward
   266f0:	eef0 5a63 	vmov.f32	s11, s7
   266f4:	e001      	b.n	266fa <tSOLAD_ioSamples+0xb6>
        while((jump * 2) < (readlag - 2 * limit)) jump *= 2;  // use available space
   266f6:	eef0 5a47 	vmov.f32	s11, s14
   266fa:	ee35 7aa5 	vadd.f32	s14, s11, s11
   266fe:	eeb4 7ae6 	vcmpe.f32	s14, s13
   26702:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26706:	d4f6      	bmi.n	266f6 <tSOLAD_ioSamples+0xb2>
        readlag -= jump;                                      // reduce read pointer lag
        xfadevalue = 1;                                       // start crossfade
        xfadelength = period - 1;
   26708:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        readlag -= jump;                                      // reduce read pointer lag
   2670c:	ee77 7ae5 	vsub.f32	s15, s15, s11
        xfadelength = period - 1;
   26710:	ee33 3ac7 	vsub.f32	s6, s7, s14
        xfadestep = xfadespeed / xfadelength;
   26714:	eec1 0a83 	vdiv.f32	s1, s3, s6
    }
    
    while(n--)
   26718:	1e4c      	subs	r4, r1, #1
   2671a:	2900      	cmp	r1, #0
   2671c:	d05a      	beq.n	267d4 <tSOLAD_ioSamples+0x190>
   2671e:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
            {
                xfadelength = readlag / limitfactor;
                if(xfadelength < 1) xfadelength = 1;
                xfadestep = xfadespeed / xfadelength;
                
                jump = -period;         // jump backward
   26722:	eeb1 8a63 	vneg.f32	s16, s7
   26726:	ee82 0a85 	vdiv.f32	s0, s5, s10
        if(readlag < limit)  // check if read pointer should jump backward...
   2672a:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2672e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26732:	dd0b      	ble.n	2674c <tSOLAD_ioSamples+0x108>
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
   26734:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
                xfadelength = readlag / limitfactor;
   26738:	ee60 6a27 	vmul.f32	s13, s0, s15
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
   2673c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26740:	d465      	bmi.n	2680e <tSOLAD_ioSamples+0x1ca>
   26742:	eef5 7a40 	vcmp.f32	s15, #0.0
   26746:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2674a:	d460      	bmi.n	2680e <tSOLAD_ioSamples+0x1ca>
                readlag += period;      // increase read pointer lag
                xfadevalue = 1;         // start crossfade
            }
        }
        
        readindex = refindex - readlag;
   2674c:	ee76 6a67 	vsub.f32	s13, s12, s15
        outputsample = read_sample(w, readindex);
   26750:	6a03      	ldr	r3, [r0, #32]
        
        if(xfadevalue > 0)
   26752:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
        {
            outputsample *= (1 - xfadevalue);
   26756:	ee72 8ac7 	vsub.f32	s17, s5, s14
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   2675a:	ee36 4ae5 	vsub.f32	s8, s13, s11
}

// read one sample from delay buffer, with linear interpolation
static inline float read_sample(_tSOLAD* const w, float floatindex)
{
    int index = (int)floatindex;
   2675e:	eefd 4ae6 	vcvt.s32.f32	s9, s13
        if(xfadevalue > 0)
   26762:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    int index = (int)floatindex;
   26766:	eebd 5ac4 	vcvt.s32.f32	s10, s8
    float fraction = floatindex - (float)index;
    float *buf = w->delaybuf;
    index &= LOOPMASK;
   2676a:	ee14 1a90 	vmov	r1, s9
    float fraction = floatindex - (float)index;
   2676e:	eef8 4ae4 	vcvt.f32.s32	s9, s9
    index &= LOOPMASK;
   26772:	f3c1 010b 	ubfx	r1, r1, #0, #12
   26776:	ee15 6a10 	vmov	r6, s10
    float fraction = floatindex - (float)index;
   2677a:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
    
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   2677e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    float fraction = floatindex - (float)index;
   26782:	ee76 6ae4 	vsub.f32	s13, s13, s9
    index &= LOOPMASK;
   26786:	f3c6 060b 	ubfx	r6, r6, #0, #12
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   2678a:	edd1 4a00 	vldr	s9, [r1]
    float fraction = floatindex - (float)index;
   2678e:	ee34 5a45 	vsub.f32	s10, s8, s10
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26792:	ed91 4a01 	vldr	s8, [r1, #4]
   26796:	eb03 0386 	add.w	r3, r3, r6, lsl #2
   2679a:	ee34 4a64 	vsub.f32	s8, s8, s9
   2679e:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
   267a2:	dd2a      	ble.n	267fa <tSOLAD_ioSamples+0x1b6>
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   267a4:	edd3 6a00 	vldr	s13, [r3]
    while(n--)
   267a8:	3c01      	subs	r4, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   267aa:	ed93 4a01 	vldr	s8, [r3, #4]
        refindex += 1;
   267ae:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   267b2:	1c67      	adds	r7, r4, #1
        readlag -= readlagstep;
   267b4:	ee77 7ac2 	vsub.f32	s15, s15, s4
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   267b8:	ee34 4a66 	vsub.f32	s8, s8, s13
   267bc:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   267c0:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
   267c4:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
   267c8:	eee4 6aa8 	vfma.f32	s13, s9, s17
        *out++ = outputsample;
   267cc:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
   267d0:	d1ab      	bne.n	2672a <tSOLAD_ioSamples+0xe6>
   267d2:	8883      	ldrh	r3, [r0, #4]
    w->readlag = readlag;               // state variables
   267d4:	edc0 7a03 	vstr	s15, [r0, #12]
    w->jump = jump;
   267d8:	edc0 5a05 	vstr	s11, [r0, #20]
    w->xfadelength = xfadelength;
   267dc:	ed80 3a06 	vstr	s6, [r0, #24]
    w->xfadevalue = xfadevalue;
   267e0:	ed80 7a07 	vstr	s14, [r0, #28]
    w->timeindex += blocksize;
   267e4:	441d      	add	r5, r3
    w->timeindex &= LOOPMASK;
   267e6:	f3c5 050b 	ubfx	r5, r5, #0, #12
   267ea:	8085      	strh	r5, [r0, #4]
}
   267ec:	ecbd 8b02 	vpop	{d8}
   267f0:	bcf0      	pop	{r4, r5, r6, r7}
   267f2:	4770      	bx	lr
    float xfadestep = xfadespeed / xfadelength;
   267f4:	eec1 0a83 	vdiv.f32	s1, s3, s6
   267f8:	e78e      	b.n	26718 <tSOLAD_ioSamples+0xd4>
    while(n--)
   267fa:	3c01      	subs	r4, #1
        *out++ = outputsample;
   267fc:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
   26800:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   26804:	1c66      	adds	r6, r4, #1
        readlag -= readlagstep;
   26806:	ee77 7ac2 	vsub.f32	s15, s15, s4
    while(n--)
   2680a:	d18e      	bne.n	2672a <tSOLAD_ioSamples+0xe6>
   2680c:	e7e1      	b.n	267d2 <tSOLAD_ioSamples+0x18e>
   2680e:	fe86 3aa2 	vmaxnm.f32	s6, s13, s5
                jump = -period;         // jump backward
   26812:	eef0 5a48 	vmov.f32	s11, s16
                xfadestep = xfadespeed / xfadelength;
   26816:	eec1 0a83 	vdiv.f32	s1, s3, s6
                readlag += period;      // increase read pointer lag
   2681a:	ee77 7aa3 	vadd.f32	s15, s15, s7
                xfadevalue = 1;         // start crossfade
   2681e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   26822:	e793      	b.n	2674c <tSOLAD_ioSamples+0x108>
    if(pitchfactor > 0.5) xfadespeed = pitchfactor;
   26824:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
    while(n--)
   26828:	1e4c      	subs	r4, r1, #1
    float readlagstep = 1 - pitchfactor;
   2682a:	ee72 1a66 	vsub.f32	s3, s4, s13
    else xfadespeed = 1 - pitchfactor;
   2682e:	eef4 6ac5 	vcmpe.f32	s13, s10
   26832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26836:	fe76 6aa1 	vselgt.f32	s13, s13, s3
    xfadestep = xfadespeed / xfadelength;
   2683a:	eec6 0a83 	vdiv.f32	s1, s13, s6
    while(n--)
   2683e:	2900      	cmp	r1, #0
   26840:	d053      	beq.n	268ea <tSOLAD_ioSamples+0x2a6>
        refindex += 1;
   26842:	eef0 2a42 	vmov.f32	s5, s4
                xfadelength = period - 1;
   26846:	ee33 2ac2 	vsub.f32	s4, s7, s4
                xfadestep = xfadespeed / xfadelength;
   2684a:	ee86 0a82 	vdiv.f32	s0, s13, s4
            if(xfadevalue <= 0)      // ...but do not interrupt crossfade
   2684e:	eeb5 7a40 	vcmp.f32	s14, #0.0
   26852:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26856:	d804      	bhi.n	26862 <tSOLAD_ioSamples+0x21e>
   26858:	eef4 7a63 	vcmp.f32	s15, s7
   2685c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26860:	dc56      	bgt.n	26910 <tSOLAD_ioSamples+0x2cc>
        readindex = refindex - readlag;
   26862:	ee36 5a67 	vsub.f32	s10, s12, s15
        outputsample = read_sample(w, readindex);
   26866:	6a01      	ldr	r1, [r0, #32]
        if(xfadevalue > 0)
   26868:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
    int index = (int)floatindex;
   2686c:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        if(xfadevalue > 0)
   26870:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    index &= LOOPMASK;
   26874:	ee16 3a90 	vmov	r3, s13
    float fraction = floatindex - (float)index;
   26878:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
   2687c:	f3c3 030b 	ubfx	r3, r3, #0, #12
    float fraction = floatindex - (float)index;
   26880:	ee75 6a66 	vsub.f32	s13, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   26884:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   26888:	edd3 4a00 	vldr	s9, [r3]
   2688c:	ed93 4a01 	vldr	s8, [r3, #4]
   26890:	ee34 4a64 	vsub.f32	s8, s8, s9
   26894:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
   26898:	dd30      	ble.n	268fc <tSOLAD_ioSamples+0x2b8>
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   2689a:	ee35 5a65 	vsub.f32	s10, s10, s11
    while(n--)
   2689e:	3c01      	subs	r4, #1
            outputsample *= (1 - xfadevalue);                               // fadein
   268a0:	ee32 1ac7 	vsub.f32	s2, s5, s14
        refindex += 1;
   268a4:	ee36 6a22 	vadd.f32	s12, s12, s5
    int index = (int)floatindex;
   268a8:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        readlag += readlagstep;
   268ac:	ee77 7aa1 	vadd.f32	s15, s15, s3
    index &= LOOPMASK;
   268b0:	ee16 3a90 	vmov	r3, s13
    float fraction = floatindex - (float)index;
   268b4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
   268b8:	f3c3 030b 	ubfx	r3, r3, #0, #12
    float fraction = floatindex - (float)index;
   268bc:	ee35 5a66 	vsub.f32	s10, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   268c0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   268c4:	edd1 6a00 	vldr	s13, [r1]
   268c8:	ed91 4a01 	vldr	s8, [r1, #4]
    while(n--)
   268cc:	1c61      	adds	r1, r4, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
   268ce:	ee34 4a66 	vsub.f32	s8, s8, s13
   268d2:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   268d6:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
   268da:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
   268de:	eee4 6a81 	vfma.f32	s13, s9, s2
        *out++ = outputsample;
   268e2:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
   268e6:	d1b2      	bne.n	2684e <tSOLAD_ioSamples+0x20a>
   268e8:	8883      	ldrh	r3, [r0, #4]
    w->jump = jump;                 // state variables
   268ea:	edc0 5a05 	vstr	s11, [r0, #20]
    w->readlag = readlag;
   268ee:	edc0 7a03 	vstr	s15, [r0, #12]
    w->xfadevalue = xfadevalue;
   268f2:	ed80 7a07 	vstr	s14, [r0, #28]
    w->xfadelength = xfadelength;
   268f6:	ed80 3a06 	vstr	s6, [r0, #24]
   268fa:	e773      	b.n	267e4 <tSOLAD_ioSamples+0x1a0>
    while(n--)
   268fc:	3c01      	subs	r4, #1
        *out++ = outputsample;
   268fe:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
   26902:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
   26906:	1c63      	adds	r3, r4, #1
        readlag += readlagstep;
   26908:	ee77 7aa1 	vadd.f32	s15, s15, s3
    while(n--)
   2690c:	d19f      	bne.n	2684e <tSOLAD_ioSamples+0x20a>
   2690e:	e7eb      	b.n	268e8 <tSOLAD_ioSamples+0x2a4>
                jump = period;                           // jump forward
   26910:	eef0 5a63 	vmov.f32	s11, s7
   26914:	e001      	b.n	2691a <tSOLAD_ioSamples+0x2d6>
                while((jump * 2) < readlag) jump *= 2;   // use available space
   26916:	eef0 5a47 	vmov.f32	s11, s14
   2691a:	ee35 7aa5 	vadd.f32	s14, s11, s11
   2691e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   26922:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26926:	d4f6      	bmi.n	26916 <tSOLAD_ioSamples+0x2d2>
                readlag -= jump;                         // reduce read pointer lag
   26928:	ee77 7ae5 	vsub.f32	s15, s15, s11
                xfadestep = xfadespeed / xfadelength;
   2692c:	eef0 0a40 	vmov.f32	s1, s0
                xfadevalue = 1;                          // start crossfade
   26930:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
                xfadelength = period - 1;
   26934:	eeb0 3a42 	vmov.f32	s6, s4
   26938:	e793      	b.n	26862 <tSOLAD_ioSamples+0x21e>
   2693a:	bf00      	nop
   2693c:	3f7d70a4 	.word	0x3f7d70a4

00026940 <tRetune_initToPool>:
{
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tRetune_initToPool (tRetune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
   26940:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26944:	ed2d 8b02 	vpush	{d8}
   26948:	b085      	sub	sp, #20
   2694a:	4604      	mov	r4, r0
   2694c:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
   2694e:	203c      	movs	r0, #60	; 0x3c
{
   26950:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   26954:	4617      	mov	r7, r2
   26956:	469a      	mov	sl, r3
    _tMempool* m = *mp;
   26958:	f8d8 6000 	ldr.w	r6, [r8]
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
   2695c:	4631      	mov	r1, r6
   2695e:	f003 f993 	bl	29c88 <mpool_alloc>
   26962:	4605      	mov	r5, r0
   26964:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26966:	4631      	mov	r1, r6
    r->mempool = *mp;
   26968:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
   2696c:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26970:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
   26972:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
   26974:	61ef      	str	r7, [r5, #28]
    r->numVoices = numVoices;
   26976:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   2697a:	f003 f9db 	bl	29d34 <mpool_calloc>
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   2697e:	6bab      	ldr	r3, [r5, #56]	; 0x38
   26980:	4631      	mov	r1, r6
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   26982:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   26984:	0098      	lsls	r0, r3, #2
   26986:	f003 f9d5 	bl	29d34 <mpool_calloc>
    
    r->hopSize = DEFHOPSIZE;
   2698a:	f04f 1240 	mov.w	r2, #4194368	; 0x400040
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
   2698e:	2314      	movs	r3, #20
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
   26990:	6128      	str	r0, [r5, #16]
    r->hopSize = DEFHOPSIZE;
   26992:	622a      	str	r2, [r5, #32]
void tRetune_setTimeConstant(tRetune* const rt, float tc)
{
    _tRetune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26994:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->fba = FBA;
   26998:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   2699c:	4b50      	ldr	r3, [pc, #320]	; (26ae0 <tRetune_initToPool+0x1a0>)
    _tRetune* r = *rt;
   2699e:	6824      	ldr	r4, [r4, #0]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   269a0:	ed93 0a01 	vldr	s0, [r3, #4]
   269a4:	8c23      	ldrh	r3, [r4, #32]
   269a6:	ee20 0a07 	vmul.f32	s0, s0, s14
   269aa:	ee07 3a90 	vmov	s15, r3
    r->timeConstant = tc;
   269ae:	4b4d      	ldr	r3, [pc, #308]	; (26ae4 <tRetune_initToPool+0x1a4>)
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   269b0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    r->timeConstant = tc;
   269b4:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   269b6:	ee20 0a27 	vmul.f32	s0, s0, s15
   269ba:	f006 f9ab 	bl	2cd14 <expf>
    r->inputPeriod = 0.0f;
   269be:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   269c0:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   269c4:	4631      	mov	r1, r6
   269c6:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
   269c8:	636b      	str	r3, [r5, #52]	; 0x34
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   269ca:	0080      	lsls	r0, r0, #2
   269cc:	f003 f9b2 	bl	29d34 <mpool_calloc>
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   269d0:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
   269d2:	60a8      	str	r0, [r5, #8]
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   269d4:	4631      	mov	r1, r6
   269d6:	0098      	lsls	r0, r3, #2
   269d8:	f003 f9ac 	bl	29d34 <mpool_calloc>
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   269dc:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   269de:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   269e0:	4631      	mov	r1, r6
   269e2:	0098      	lsls	r0, r3, #2
   269e4:	f003 f9a6 	bl	29d34 <mpool_calloc>
    for (int i = 0; i < r->numVoices; ++i)
   269e8:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
   269ea:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
   269ec:	2b00      	cmp	r3, #0
   269ee:	dd0c      	ble.n	26a0a <tRetune_initToPool+0xca>
   269f0:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
   269f2:	69e8      	ldr	r0, [r5, #28]
   269f4:	4631      	mov	r1, r6
   269f6:	692f      	ldr	r7, [r5, #16]
   269f8:	0080      	lsls	r0, r0, #2
   269fa:	f003 f99b 	bl	29d34 <mpool_calloc>
   269fe:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   26a02:	3401      	adds	r4, #1
   26a04:	6bab      	ldr	r3, [r5, #56]	; 0x38
   26a06:	42a3      	cmp	r3, r4
   26a08:	dcf3      	bgt.n	269f2 <tRetune_initToPool+0xb2>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
   26a0a:	692a      	ldr	r2, [r5, #16]
   26a0c:	1d28      	adds	r0, r5, #4
   26a0e:	69eb      	ldr	r3, [r5, #28]
   26a10:	6812      	ldr	r2, [r2, #0]
   26a12:	68e9      	ldr	r1, [r5, #12]
   26a14:	f8cd 8004 	str.w	r8, [sp, #4]
   26a18:	69ac      	ldr	r4, [r5, #24]
   26a1a:	9003      	str	r0, [sp, #12]
   26a1c:	9400      	str	r4, [sp, #0]
   26a1e:	f7fe f8e1 	bl	24be4 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
   26a22:	6bab      	ldr	r3, [r5, #56]	; 0x38
   26a24:	2b00      	cmp	r3, #0
   26a26:	dd56      	ble.n	26ad6 <tRetune_initToPool+0x196>
   26a28:	2700      	movs	r7, #0
    w->period = INITPERIOD;
   26a2a:	ed9f 8a2f 	vldr	s16, [pc, #188]	; 26ae8 <tRetune_initToPool+0x1a8>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26a2e:	eddf 8a2f 	vldr	s17, [pc, #188]	; 26aec <tRetune_initToPool+0x1ac>
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26a32:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26a34:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
   26a36:	f8d8 a000 	ldr.w	sl, [r8]
    ps->pitchFactor = 1.0f;
   26a3a:	f04f 5b7e 	mov.w	fp, #1065353216	; 0x3f800000
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26a3e:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26a42:	4651      	mov	r1, sl
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26a44:	69ee      	ldr	r6, [r5, #28]
   26a46:	f8d5 9008 	ldr.w	r9, [r5, #8]
   26a4a:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26a4c:	f003 f972 	bl	29d34 <mpool_calloc>
    ps->outBuffer = out;
   26a50:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26a52:	4604      	mov	r4, r0
    ps->curBlock = 1;
   26a54:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
   26a58:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26a5a:	f849 4027 	str.w	r4, [r9, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26a5e:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
   26a60:	f8c4 a000 	str.w	sl, [r4]
    for (int i = 0; i < r->numVoices; ++i)
   26a64:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
   26a66:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
   26a68:	6121      	str	r1, [r4, #16]
    ps->p = pd;
   26a6a:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
   26a6c:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
   26a6e:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
   26a70:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
   26a72:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
   26a76:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
   26a78:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26a7c:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
   26a80:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26a84:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
   26a86:	f8d8 a000 	ldr.w	sl, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26a8a:	4651      	mov	r1, sl
   26a8c:	f003 f952 	bl	29d34 <mpool_calloc>
   26a90:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26a92:	4651      	mov	r1, sl
   26a94:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26a98:	6066      	str	r6, [r4, #4]
    w->mempool = m;
   26a9a:	f8c6 a000 	str.w	sl, [r6]
    w->pitchfactor = 1.;
   26a9e:	f8c6 b008 	str.w	fp, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26aa2:	f003 f947 	bl	29d34 <mpool_calloc>
    w->xfadevalue = -1;
   26aa6:	4a12      	ldr	r2, [pc, #72]	; (26af0 <tRetune_initToPool+0x1b0>)
    w->timeindex = 0;
   26aa8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26aac:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
   26aae:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26ab0:	f104 0008 	add.w	r0, r4, #8
    w->timeindex = 0;
   26ab4:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26ab6:	4641      	mov	r1, r8
    w->period = INITPERIOD;
   26ab8:	ed86 8a04 	vstr	s16, [r6, #16]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26abc:	eeb0 0a68 	vmov.f32	s0, s17
    w->readlag = INITPERIOD;
   26ac0:	ed86 8a03 	vstr	s16, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26ac4:	f001 fd5a 	bl	2857c <tHighpass_initToPool>
    _tSOLAD* w = *wp;
   26ac8:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
   26aca:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   26ace:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
   26ad0:	6bab      	ldr	r3, [r5, #56]	; 0x38
   26ad2:	42bb      	cmp	r3, r7
   26ad4:	dcad      	bgt.n	26a32 <tRetune_initToPool+0xf2>
}
   26ad6:	b005      	add	sp, #20
   26ad8:	ecbd 8b02 	vpop	{d8}
   26adc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26ae0:	020fc0a8 	.word	0x020fc0a8
   26ae4:	42c80000 	.word	0x42c80000
   26ae8:	42800000 	.word	0x42800000
   26aec:	42200000 	.word	0x42200000
   26af0:	bf800000 	.word	0xbf800000

00026af4 <tRetune_init>:
{
   26af4:	b510      	push	{r4, lr}
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26af6:	4c03      	ldr	r4, [pc, #12]	; (26b04 <tRetune_init+0x10>)
{
   26af8:	b082      	sub	sp, #8
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26afa:	9400      	str	r4, [sp, #0]
   26afc:	f7ff ff20 	bl	26940 <tRetune_initToPool>
}
   26b00:	b002      	add	sp, #8
   26b02:	bd10      	pop	{r4, pc}
   26b04:	020fc0c0 	.word	0x020fc0c0

00026b08 <tRetune_free>:
{
   26b08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tRetune* r = *rt;
   26b0a:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
   26b0c:	1d20      	adds	r0, r4, #4
   26b0e:	f7fe f8c7 	bl	24ca0 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
   26b12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   26b14:	2b00      	cmp	r3, #0
   26b16:	dd1e      	ble.n	26b56 <tRetune_free+0x4e>
   26b18:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
   26b1a:	68a3      	ldr	r3, [r4, #8]
   26b1c:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
   26b20:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
   26b22:	6839      	ldr	r1, [r7, #0]
   26b24:	6a38      	ldr	r0, [r7, #32]
   26b26:	f003 f957 	bl	29dd8 <mpool_free>
    mpool_free((char*)w, w->mempool);
   26b2a:	6839      	ldr	r1, [r7, #0]
   26b2c:	4638      	mov	r0, r7
   26b2e:	f003 f953 	bl	29dd8 <mpool_free>
    tHighpass_free(&ps->hp);
   26b32:	f106 0008 	add.w	r0, r6, #8
   26b36:	f001 fd41 	bl	285bc <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
   26b3a:	6831      	ldr	r1, [r6, #0]
   26b3c:	4630      	mov	r0, r6
   26b3e:	f003 f94b 	bl	29dd8 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
   26b42:	6923      	ldr	r3, [r4, #16]
   26b44:	6821      	ldr	r1, [r4, #0]
   26b46:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   26b4a:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
   26b4c:	f003 f944 	bl	29dd8 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
   26b50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   26b52:	42ab      	cmp	r3, r5
   26b54:	dce1      	bgt.n	26b1a <tRetune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
   26b56:	6821      	ldr	r1, [r4, #0]
   26b58:	6960      	ldr	r0, [r4, #20]
   26b5a:	f003 f93d 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->pitchFactor, r->mempool);
   26b5e:	6821      	ldr	r1, [r4, #0]
   26b60:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   26b62:	f003 f939 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
   26b66:	6821      	ldr	r1, [r4, #0]
   26b68:	68a0      	ldr	r0, [r4, #8]
   26b6a:	f003 f935 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
   26b6e:	6821      	ldr	r1, [r4, #0]
   26b70:	68e0      	ldr	r0, [r4, #12]
   26b72:	f003 f931 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
   26b76:	6821      	ldr	r1, [r4, #0]
   26b78:	6920      	ldr	r0, [r4, #16]
   26b7a:	f003 f92d 	bl	29dd8 <mpool_free>
    mpool_free((char*)r, r->mempool);
   26b7e:	6821      	ldr	r1, [r4, #0]
   26b80:	4620      	mov	r0, r4
}
   26b82:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   26b86:	f003 b927 	b.w	29dd8 <mpool_free>
   26b8a:	bf00      	nop

00026b8c <tRetune_tick>:
{
   26b8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   26b90:	ed2d 8b04 	vpush	{d8-d9}
    _tRetune* r = *rt;
   26b94:	6807      	ldr	r7, [r0, #0]
{
   26b96:	b083      	sub	sp, #12
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
   26b98:	1d38      	adds	r0, r7, #4
   26b9a:	f7fe f8a3 	bl	24ce4 <tPeriodDetection_tick>
    for (int v = 0; v < r->numVoices; ++v)
   26b9e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
   26ba0:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    for (int v = 0; v < r->numVoices; ++v)
   26ba4:	2b00      	cmp	r3, #0
   26ba6:	f340 8083 	ble.w	26cb0 <tRetune_tick+0x124>
   26baa:	2500      	movs	r5, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26bac:	ed9f 9a5f 	vldr	s18, [pc, #380]	; 26d2c <tRetune_tick+0x1a0>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26bb0:	eddf 9a5f 	vldr	s19, [pc, #380]	; 26d30 <tRetune_tick+0x1a4>
   26bb4:	e005      	b.n	26bc2 <tRetune_tick+0x36>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26bb6:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
   26bba:	3501      	adds	r5, #1
   26bbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26bbe:	42ab      	cmp	r3, r5
   26bc0:	dd76      	ble.n	26cb0 <tRetune_tick+0x124>
    _tPitchShift* ps = *psr;
   26bc2:	68bb      	ldr	r3, [r7, #8]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26bc4:	697e      	ldr	r6, [r7, #20]
    _tPitchShift* ps = *psr;
   26bc6:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26bca:	eb06 0685 	add.w	r6, r6, r5, lsl #2
    _tPeriodDetection* p = *ps->p;
   26bce:	68e2      	ldr	r2, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26bd0:	f104 0008 	add.w	r0, r4, #8
   26bd4:	6923      	ldr	r3, [r4, #16]
    _tPeriodDetection* p = *ps->p;
   26bd6:	6812      	ldr	r2, [r2, #0]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26bd8:	6b11      	ldr	r1, [r2, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
   26bda:	9201      	str	r2, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26bdc:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    i = p->i;
   26be0:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26be4:	ed93 0a00 	vldr	s0, [r3]
   26be8:	f001 fcfc 	bl	285e4 <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
   26bec:	9a01      	ldr	r2, [sp, #4]
   26bee:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   26bf0:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->indexstore >= ps->frameSize)
   26bf4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   26bf6:	429a      	cmp	r2, r3
   26bf8:	dbdd      	blt.n	26bb6 <tRetune_tick+0x2a>
        period = tPeriodDetection_getPeriod(&p);
   26bfa:	a801      	add	r0, sp, #4
   26bfc:	f7fe f900 	bl	24e00 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
   26c00:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
   26c02:	eef0 8a40 	vmov.f32	s17, s0
    _tPeriodDetection* p = *ps->p;
   26c06:	f8d3 9000 	ldr.w	r9, [r3]
    envout = tEnvPD_tick(&p->env);
   26c0a:	f109 0004 	add.w	r0, r9, #4
   26c0e:	f7fd fced 	bl	245ec <tEnvPD_tick>
    if (envout >= 1.0f)
   26c12:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   26c16:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26c1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26c1e:	db0e      	blt.n	26c3e <tRetune_tick+0xb2>
        p->lastmax = p->max;
   26c20:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
        if (envout > p->max)
   26c24:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
   26c28:	edc9 7a14 	vstr	s15, [r9, #80]	; 0x50
   26c2c:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
   26c30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26c34:	dd6e      	ble.n	26d14 <tRetune_tick+0x188>
            p->max = envout;
   26c36:	ed89 0a13 	vstr	s0, [r9, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
   26c3a:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
   26c3e:	f899 3040 	ldrb.w	r3, [r9, #64]	; 0x40
   26c42:	9901      	ldr	r1, [sp, #4]
   26c44:	2b00      	cmp	r3, #0
   26c46:	d039      	beq.n	26cbc <tRetune_tick+0x130>
   26c48:	3b01      	subs	r3, #1
   26c4a:	b2db      	uxtb	r3, r3
   26c4c:	f889 3040 	strb.w	r3, [r9, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26c50:	b3a3      	cbz	r3, 26cbc <tRetune_tick+0x130>
   26c52:	6862      	ldr	r2, [r4, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
   26c54:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   26c56:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26c5a:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   26c5e:	ee00 3a10 	vmov	s0, r3
   26c62:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   26c66:	ee20 0a09 	vmul.f32	s0, s0, s18
   26c6a:	fe80 0a68 	vminnm.f32	s0, s0, s17
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   26c6e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26c72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26c76:	dd02      	ble.n	26c7e <tRetune_tick+0xf2>
   26c78:	ed82 0a04 	vstr	s0, [r2, #16]
   26c7c:	6862      	ldr	r2, [r4, #4]
        tSOLAD_setPitchFactor(&ps->sola, ps->pitchFactor);
   26c7e:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   26c82:	ea4f 0888 	mov.w	r8, r8, lsl #2
   26c86:	1d20      	adds	r0, r4, #4
    for (int v = 0; v < r->numVoices; ++v)
   26c88:	3501      	adds	r5, #1
    if (pitchfactor <= 0.0f) return;
   26c8a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   26c8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->pitchfactor = pitchfactor;
   26c92:	bf88      	it	hi
   26c94:	edc2 7a02 	vstrhi	s15, [r2, #8]
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   26c98:	68c9      	ldr	r1, [r1, #12]
   26c9a:	6922      	ldr	r2, [r4, #16]
   26c9c:	6963      	ldr	r3, [r4, #20]
   26c9e:	4441      	add	r1, r8
   26ca0:	4442      	add	r2, r8
   26ca2:	f7ff fccf 	bl	26644 <tSOLAD_ioSamples>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
   26ca6:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
   26caa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26cac:	42ab      	cmp	r3, r5
   26cae:	dc88      	bgt.n	26bc2 <tRetune_tick+0x36>
}
   26cb0:	6978      	ldr	r0, [r7, #20]
   26cb2:	b003      	add	sp, #12
   26cb4:	ecbd 8b04 	vpop	{d8-d9}
   26cb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26cbc:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
   26cc0:	eef4 7ae9 	vcmpe.f32	s15, s19
   26cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26cc8:	ddc3      	ble.n	26c52 <tRetune_tick+0xc6>
   26cca:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
   26cce:	ed99 7a15 	vldr	s14, [r9, #84]	; 0x54
   26cd2:	eeb4 7ae7 	vcmpe.f32	s14, s15
   26cd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26cda:	ddba      	ble.n	26c52 <tRetune_tick+0xc6>
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   26cdc:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
   26cde:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   26ce0:	ee07 2a90 	vmov	s15, r2
            p->fba = 5;
   26ce4:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
    _tSOLAD* w = *wp;
   26ce8:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   26cea:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
   26cee:	ed92 7a03 	vldr	s14, [r2, #12]
   26cf2:	eef4 7ac7 	vcmpe.f32	s15, s14
   26cf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26cfa:	d5ab      	bpl.n	26c54 <tRetune_tick+0xc8>
        w->jump = w->readlag - readlag;
   26cfc:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
   26d00:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
   26d04:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
   26d08:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
   26d0c:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
   26d10:	61d3      	str	r3, [r2, #28]
   26d12:	e79e      	b.n	26c52 <tRetune_tick+0xc6>
            p->deltamax = envout - p->max;
   26d14:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
            p->max = p->max * ps->radius;
   26d18:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
   26d1c:	ee67 6aa6 	vmul.f32	s13, s15, s13
   26d20:	ee36 7ae7 	vsub.f32	s14, s13, s15
   26d24:	edc9 6a13 	vstr	s13, [r9, #76]	; 0x4c
   26d28:	e787      	b.n	26c3a <tRetune_tick+0xae>
   26d2a:	bf00      	nop
   26d2c:	3f4ccccd 	.word	0x3f4ccccd
   26d30:	42700000 	.word	0x42700000

00026d34 <tRetune_setPitchFactor>:
{
   26d34:	b410      	push	{r4}
    _tRetune* r = *rt;
   26d36:	6802      	ldr	r2, [r0, #0]
    r->pitchFactor[voice] = pf;
   26d38:	008c      	lsls	r4, r1, #2
   26d3a:	6a90      	ldr	r0, [r2, #40]	; 0x28
   26d3c:	4420      	add	r0, r4
   26d3e:	ed80 0a00 	vstr	s0, [r0]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   26d42:	6a93      	ldr	r3, [r2, #40]	; 0x28
    _tPitchShift* ps = *psr;
   26d44:	6892      	ldr	r2, [r2, #8]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   26d46:	4423      	add	r3, r4
    _tPitchShift* ps = *psr;
   26d48:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
   26d4c:	681b      	ldr	r3, [r3, #0]
    ps->pitchFactor = pf;
   26d4e:	62d3      	str	r3, [r2, #44]	; 0x2c
}
   26d50:	f85d 4b04 	ldr.w	r4, [sp], #4
   26d54:	4770      	bx	lr
   26d56:	bf00      	nop

00026d58 <tRetune_setFidelityThreshold>:

void tRetune_setFidelityThreshold(tRetune* const rt, float threshold)
{
    _tRetune* r = *rt;
    
    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
   26d58:	6800      	ldr	r0, [r0, #0]
   26d5a:	3004      	adds	r0, #4
   26d5c:	f7fe b854 	b.w	24e08 <tPeriodDetection_setFidelityThreshold>

00026d60 <tRetune_getInputPeriod>:

float tRetune_getInputPeriod(tRetune* const rt)
{
    _tRetune* r = *rt;
    
    return (r->inputPeriod * leaf.invSampleRate);
   26d60:	6802      	ldr	r2, [r0, #0]
   26d62:	4b04      	ldr	r3, [pc, #16]	; (26d74 <tRetune_getInputPeriod+0x14>)
   26d64:	ed92 0a0d 	vldr	s0, [r2, #52]	; 0x34
   26d68:	edd3 7a01 	vldr	s15, [r3, #4]
}
   26d6c:	ee20 0a27 	vmul.f32	s0, s0, s15
   26d70:	4770      	bx	lr
   26d72:	bf00      	nop
   26d74:	020fc0a8 	.word	0x020fc0a8

00026d78 <tAutotune_initToPool>:
{
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tAutotune_initToPool (tAutotune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
   26d78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26d7c:	ed2d 8b02 	vpush	{d8}
   26d80:	b085      	sub	sp, #20
   26d82:	4604      	mov	r4, r0
   26d84:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
   26d86:	2040      	movs	r0, #64	; 0x40
{
   26d88:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   26d8c:	4617      	mov	r7, r2
   26d8e:	469a      	mov	sl, r3
    _tMempool* m = *mp;
   26d90:	f8d8 6000 	ldr.w	r6, [r8]
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
   26d94:	4631      	mov	r1, r6
   26d96:	f002 ff77 	bl	29c88 <mpool_alloc>
   26d9a:	4605      	mov	r5, r0
   26d9c:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26d9e:	4631      	mov	r1, r6
    r->mempool = *mp;
   26da0:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
   26da4:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26da8:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
   26daa:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
   26dac:	61ef      	str	r7, [r5, #28]
    r->numVoices = numVoices;
   26dae:	f8c5 903c 	str.w	r9, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26db2:	f002 ff69 	bl	29c88 <mpool_alloc>
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   26db6:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26db8:	4631      	mov	r1, r6
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26dba:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   26dbc:	0098      	lsls	r0, r3, #2
   26dbe:	f002 ff63 	bl	29c88 <mpool_alloc>
    
    r->hopSize = DEFHOPSIZE;
   26dc2:	f04f 1240 	mov.w	r2, #4194368	; 0x400040
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
   26dc6:	2314      	movs	r3, #20
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
   26dc8:	6128      	str	r0, [r5, #16]
    r->hopSize = DEFHOPSIZE;
   26dca:	622a      	str	r2, [r5, #32]
void tAutotune_setTimeConstant(tAutotune* const rt, float tc)
{
    _tAutotune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26dcc:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->fba = FBA;
   26dd0:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26dd4:	4b51      	ldr	r3, [pc, #324]	; (26f1c <tAutotune_initToPool+0x1a4>)
    _tAutotune* r = *rt;
   26dd6:	6824      	ldr	r4, [r4, #0]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26dd8:	ed93 0a01 	vldr	s0, [r3, #4]
   26ddc:	8c23      	ldrh	r3, [r4, #32]
   26dde:	ee20 0a07 	vmul.f32	s0, s0, s14
   26de2:	ee07 3a90 	vmov	s15, r3
    r->timeConstant = tc;
   26de6:	4b4e      	ldr	r3, [pc, #312]	; (26f20 <tAutotune_initToPool+0x1a8>)
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26de8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    r->timeConstant = tc;
   26dec:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
   26dee:	ee20 0a27 	vmul.f32	s0, s0, s15
   26df2:	f005 ff8f 	bl	2cd14 <expf>
   26df6:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
   26dfa:	6be8      	ldr	r0, [r5, #60]	; 0x3c
   26dfc:	4631      	mov	r1, r6
   26dfe:	0080      	lsls	r0, r0, #2
   26e00:	f002 ff42 	bl	29c88 <mpool_alloc>
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26e04:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
   26e06:	60a8      	str	r0, [r5, #8]
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26e08:	4631      	mov	r1, r6
   26e0a:	0098      	lsls	r0, r3, #2
   26e0c:	f002 ff3c 	bl	29c88 <mpool_alloc>
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26e10:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26e12:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26e14:	4631      	mov	r1, r6
   26e16:	0098      	lsls	r0, r3, #2
   26e18:	f002 ff36 	bl	29c88 <mpool_alloc>
    for (int i = 0; i < r->numVoices; ++i)
   26e1c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
   26e1e:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
   26e20:	2b00      	cmp	r3, #0
   26e22:	dd0c      	ble.n	26e3e <tAutotune_initToPool+0xc6>
   26e24:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
   26e26:	69e8      	ldr	r0, [r5, #28]
   26e28:	4631      	mov	r1, r6
   26e2a:	692f      	ldr	r7, [r5, #16]
   26e2c:	0080      	lsls	r0, r0, #2
   26e2e:	f002 ff2b 	bl	29c88 <mpool_alloc>
   26e32:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   26e36:	3401      	adds	r4, #1
   26e38:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26e3a:	42a3      	cmp	r3, r4
   26e3c:	dcf3      	bgt.n	26e26 <tAutotune_initToPool+0xae>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
   26e3e:	692a      	ldr	r2, [r5, #16]
   26e40:	1d28      	adds	r0, r5, #4
   26e42:	69eb      	ldr	r3, [r5, #28]
   26e44:	6812      	ldr	r2, [r2, #0]
   26e46:	68e9      	ldr	r1, [r5, #12]
   26e48:	f8cd 8004 	str.w	r8, [sp, #4]
   26e4c:	69ac      	ldr	r4, [r5, #24]
   26e4e:	9003      	str	r0, [sp, #12]
   26e50:	9400      	str	r4, [sp, #0]
   26e52:	f7fd fec7 	bl	24be4 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
   26e56:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26e58:	2b00      	cmp	r3, #0
   26e5a:	dd56      	ble.n	26f0a <tAutotune_initToPool+0x192>
   26e5c:	2700      	movs	r7, #0
    w->period = INITPERIOD;
   26e5e:	ed9f 8a31 	vldr	s16, [pc, #196]	; 26f24 <tAutotune_initToPool+0x1ac>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26e62:	eddf 8a31 	vldr	s17, [pc, #196]	; 26f28 <tAutotune_initToPool+0x1b0>
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26e66:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26e68:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
   26e6a:	f8d8 a000 	ldr.w	sl, [r8]
    ps->pitchFactor = 1.0f;
   26e6e:	f04f 5b7e 	mov.w	fp, #1065353216	; 0x3f800000
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26e72:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26e76:	4651      	mov	r1, sl
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
   26e78:	69ee      	ldr	r6, [r5, #28]
   26e7a:	f8d5 9008 	ldr.w	r9, [r5, #8]
   26e7e:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26e80:	f002 ff58 	bl	29d34 <mpool_calloc>
    ps->outBuffer = out;
   26e84:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26e86:	4604      	mov	r4, r0
    ps->curBlock = 1;
   26e88:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
   26e8c:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
   26e8e:	f849 4027 	str.w	r4, [r9, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26e92:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
   26e94:	f8c4 a000 	str.w	sl, [r4]
    for (int i = 0; i < r->numVoices; ++i)
   26e98:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
   26e9a:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
   26e9c:	6121      	str	r1, [r4, #16]
    ps->p = pd;
   26e9e:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
   26ea0:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
   26ea2:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
   26ea4:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
   26ea6:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
   26eaa:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
   26eac:	f8c4 b02c 	str.w	fp, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26eb0:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
   26eb4:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
   26eb8:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
   26eba:	f8d8 a000 	ldr.w	sl, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26ebe:	4651      	mov	r1, sl
   26ec0:	f002 ff38 	bl	29d34 <mpool_calloc>
   26ec4:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26ec6:	4651      	mov	r1, sl
   26ec8:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
   26ecc:	6066      	str	r6, [r4, #4]
    w->mempool = m;
   26ece:	f8c6 a000 	str.w	sl, [r6]
    w->pitchfactor = 1.;
   26ed2:	f8c6 b008 	str.w	fp, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26ed6:	f002 ff2d 	bl	29d34 <mpool_calloc>
    w->xfadevalue = -1;
   26eda:	4a14      	ldr	r2, [pc, #80]	; (26f2c <tAutotune_initToPool+0x1b4>)
    w->timeindex = 0;
   26edc:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
   26ee0:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
   26ee2:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26ee4:	f104 0008 	add.w	r0, r4, #8
    w->timeindex = 0;
   26ee8:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26eea:	4641      	mov	r1, r8
    w->period = INITPERIOD;
   26eec:	ed86 8a04 	vstr	s16, [r6, #16]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26ef0:	eeb0 0a68 	vmov.f32	s0, s17
    w->readlag = INITPERIOD;
   26ef4:	ed86 8a03 	vstr	s16, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
   26ef8:	f001 fb40 	bl	2857c <tHighpass_initToPool>
    _tSOLAD* w = *wp;
   26efc:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
   26efe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   26f02:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
   26f04:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   26f06:	42bb      	cmp	r3, r7
   26f08:	dcad      	bgt.n	26e66 <tAutotune_initToPool+0xee>
    r->inputPeriod = 0.0f;
   26f0a:	2200      	movs	r2, #0
    r->shiftOn = 0;
   26f0c:	2300      	movs	r3, #0
    r->inputPeriod = 0.0f;
   26f0e:	636a      	str	r2, [r5, #52]	; 0x34
    r->shiftOn = 0;
   26f10:	63ab      	str	r3, [r5, #56]	; 0x38
}
   26f12:	b005      	add	sp, #20
   26f14:	ecbd 8b02 	vpop	{d8}
   26f18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26f1c:	020fc0a8 	.word	0x020fc0a8
   26f20:	42c80000 	.word	0x42c80000
   26f24:	42800000 	.word	0x42800000
   26f28:	42200000 	.word	0x42200000
   26f2c:	bf800000 	.word	0xbf800000

00026f30 <tAutotune_init>:
{
   26f30:	b510      	push	{r4, lr}
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26f32:	4c03      	ldr	r4, [pc, #12]	; (26f40 <tAutotune_init+0x10>)
{
   26f34:	b082      	sub	sp, #8
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
   26f36:	9400      	str	r4, [sp, #0]
   26f38:	f7ff ff1e 	bl	26d78 <tAutotune_initToPool>
}
   26f3c:	b002      	add	sp, #8
   26f3e:	bd10      	pop	{r4, pc}
   26f40:	020fc0c0 	.word	0x020fc0c0

00026f44 <tAutotune_free>:
{
   26f44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tAutotune* r = *rt;
   26f46:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
   26f48:	1d20      	adds	r0, r4, #4
   26f4a:	f7fd fea9 	bl	24ca0 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
   26f4e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   26f50:	2b00      	cmp	r3, #0
   26f52:	dd1e      	ble.n	26f92 <tAutotune_free+0x4e>
   26f54:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
   26f56:	68a3      	ldr	r3, [r4, #8]
   26f58:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
   26f5c:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
   26f5e:	6839      	ldr	r1, [r7, #0]
   26f60:	6a38      	ldr	r0, [r7, #32]
   26f62:	f002 ff39 	bl	29dd8 <mpool_free>
    mpool_free((char*)w, w->mempool);
   26f66:	6839      	ldr	r1, [r7, #0]
   26f68:	4638      	mov	r0, r7
   26f6a:	f002 ff35 	bl	29dd8 <mpool_free>
    tHighpass_free(&ps->hp);
   26f6e:	f106 0008 	add.w	r0, r6, #8
   26f72:	f001 fb23 	bl	285bc <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
   26f76:	6831      	ldr	r1, [r6, #0]
   26f78:	4630      	mov	r0, r6
   26f7a:	f002 ff2d 	bl	29dd8 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
   26f7e:	6923      	ldr	r3, [r4, #16]
   26f80:	6821      	ldr	r1, [r4, #0]
   26f82:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
   26f86:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
   26f88:	f002 ff26 	bl	29dd8 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
   26f8c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   26f8e:	42ab      	cmp	r3, r5
   26f90:	dce1      	bgt.n	26f56 <tAutotune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
   26f92:	6821      	ldr	r1, [r4, #0]
   26f94:	6960      	ldr	r0, [r4, #20]
   26f96:	f002 ff1f 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->freq, r->mempool);
   26f9a:	6821      	ldr	r1, [r4, #0]
   26f9c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   26f9e:	f002 ff1b 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
   26fa2:	6821      	ldr	r1, [r4, #0]
   26fa4:	68a0      	ldr	r0, [r4, #8]
   26fa6:	f002 ff17 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
   26faa:	6821      	ldr	r1, [r4, #0]
   26fac:	68e0      	ldr	r0, [r4, #12]
   26fae:	f002 ff13 	bl	29dd8 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
   26fb2:	6821      	ldr	r1, [r4, #0]
   26fb4:	6920      	ldr	r0, [r4, #16]
   26fb6:	f002 ff0f 	bl	29dd8 <mpool_free>
    mpool_free((char*)r, r->mempool);
   26fba:	6821      	ldr	r1, [r4, #0]
   26fbc:	4620      	mov	r0, r4
}
   26fbe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   26fc2:	f002 bf09 	b.w	29dd8 <mpool_free>
   26fc6:	bf00      	nop

00026fc8 <tAutotune_tick>:
{
   26fc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26fcc:	ed2d 8b06 	vpush	{d8-d10}
    _tAutotune* r = *rt;
   26fd0:	6806      	ldr	r6, [r0, #0]
{
   26fd2:	b082      	sub	sp, #8
    float tempPeriod = tPeriodDetection_tick(&r->pd, sample);
   26fd4:	1d30      	adds	r0, r6, #4
   26fd6:	f7fd fe85 	bl	24ce4 <tPeriodDetection_tick>
    if (tempPeriod < 1000.0f) //to avoid trying to follow consonants JS
   26fda:	eddf 7a75 	vldr	s15, [pc, #468]	; 271b0 <tAutotune_tick+0x1e8>
   26fde:	eeb4 0ae7 	vcmpe.f32	s0, s15
   26fe2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   26fe6:	d501      	bpl.n	26fec <tAutotune_tick+0x24>
		r->inputPeriod = tempPeriod;
   26fe8:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
	for (int v = 0; v < r->numVoices; ++v)
   26fec:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   26fee:	2b00      	cmp	r3, #0
   26ff0:	f340 8097 	ble.w	27122 <tAutotune_tick+0x15a>
   26ff4:	2500      	movs	r5, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
   26ff6:	eddf 9a6f 	vldr	s19, [pc, #444]	; 271b4 <tAutotune_tick+0x1ec>
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   26ffa:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 271bc <tAutotune_tick+0x1f4>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   26ffe:	ed9f aa6e 	vldr	s20, [pc, #440]	; 271b8 <tAutotune_tick+0x1f0>
   27002:	e006      	b.n	27012 <tAutotune_tick+0x4a>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   27004:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
   27008:	3501      	adds	r5, #1
   2700a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   2700c:	42ab      	cmp	r3, r5
   2700e:	f340 8088 	ble.w	27122 <tAutotune_tick+0x15a>
    _tPitchShift* ps = *psr;
   27012:	68b1      	ldr	r1, [r6, #8]
   27014:	00ab      	lsls	r3, r5, #2
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   27016:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    _tPitchShift* ps = *psr;
   27018:	f851 4025 	ldr.w	r4, [r1, r5, lsl #2]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2701c:	6977      	ldr	r7, [r6, #20]
   2701e:	eb02 0c03 	add.w	ip, r2, r3
    _tPeriodDetection* p = *ps->p;
   27022:	68e1      	ldr	r1, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   27024:	f104 0008 	add.w	r0, r4, #8
   27028:	6922      	ldr	r2, [r4, #16]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2702a:	441f      	add	r7, r3
    _tPeriodDetection* p = *ps->p;
   2702c:	6809      	ldr	r1, [r1, #0]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   2702e:	ed9c 8a00 	vldr	s16, [ip]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   27032:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
   27034:	9101      	str	r1, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   27036:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    i = p->i;
   2703a:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2703e:	ed92 0a00 	vldr	s0, [r2]
   27042:	f001 facf 	bl	285e4 <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
   27046:	9a01      	ldr	r2, [sp, #4]
   27048:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
   2704a:	eef0 8a40 	vmov.f32	s17, s0
    if (p->indexstore >= ps->frameSize)
   2704e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   27050:	429a      	cmp	r2, r3
   27052:	dbd7      	blt.n	27004 <tAutotune_tick+0x3c>
        period = tPeriodDetection_getPeriod(&p);
   27054:	a801      	add	r0, sp, #4
   27056:	f7fd fed3 	bl	24e00 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
   2705a:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
   2705c:	eeb0 9a40 	vmov.f32	s18, s0
    _tPeriodDetection* p = *ps->p;
   27060:	f8d3 a000 	ldr.w	sl, [r3]
    envout = tEnvPD_tick(&p->env);
   27064:	f10a 0004 	add.w	r0, sl, #4
   27068:	f7fd fac0 	bl	245ec <tEnvPD_tick>
    if (envout >= 1.0f)
   2706c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27070:	eeb4 0ae7 	vcmpe.f32	s0, s15
   27074:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27078:	db0f      	blt.n	2709a <tAutotune_tick+0xd2>
        p->lastmax = p->max;
   2707a:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
        if (envout > p->max)
   2707e:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
   27082:	edca 7a14 	vstr	s15, [sl, #80]	; 0x50
   27086:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
   2708a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2708e:	f340 8083 	ble.w	27198 <tAutotune_tick+0x1d0>
            p->max = envout;
   27092:	ed8a 0a13 	vstr	s0, [sl, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
   27096:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
   2709a:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
   2709e:	2b00      	cmp	r3, #0
   270a0:	d04c      	beq.n	2713c <tAutotune_tick+0x174>
   270a2:	3b01      	subs	r3, #1
   270a4:	b2db      	uxtb	r3, r3
   270a6:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   270aa:	2b00      	cmp	r3, #0
   270ac:	d046      	beq.n	2713c <tAutotune_tick+0x174>
   270ae:	6862      	ldr	r2, [r4, #4]
   270b0:	9901      	ldr	r1, [sp, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
   270b2:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   270b4:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
   270b8:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
   270bc:	ee07 3a90 	vmov	s15, r3
   270c0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   270c4:	ee67 7aa9 	vmul.f32	s15, s15, s19
   270c8:	fec7 7ac9 	vminnm.f32	s15, s15, s18
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
   270cc:	eef4 7ac7 	vcmpe.f32	s15, s14
   270d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   270d4:	dd02      	ble.n	270dc <tAutotune_tick+0x114>
   270d6:	edc2 7a04 	vstr	s15, [r2, #16]
   270da:	6862      	ldr	r2, [r4, #4]
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
   270dc:	eeb5 9a40 	vcmp.f32	s18, #0.0
   270e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   270e4:	d023      	beq.n	2712e <tAutotune_tick+0x166>
   270e6:	edd8 7a01 	vldr	s15, [r8, #4]
   270ea:	ee28 8a27 	vmul.f32	s16, s16, s15
   270ee:	ee28 8a09 	vmul.f32	s16, s16, s18
    if (pitchfactor <= 0.0f) return;
   270f2:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   270f6:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
   270fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   270fe:	d81a      	bhi.n	27136 <tAutotune_tick+0x16e>
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   27100:	ea4f 0989 	mov.w	r9, r9, lsl #2
   27104:	68c9      	ldr	r1, [r1, #12]
   27106:	6922      	ldr	r2, [r4, #16]
   27108:	1d20      	adds	r0, r4, #4
   2710a:	6963      	ldr	r3, [r4, #20]
   2710c:	4449      	add	r1, r9
   2710e:	444a      	add	r2, r9
	for (int v = 0; v < r->numVoices; ++v)
   27110:	3501      	adds	r5, #1
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
   27112:	f7ff fa97 	bl	26644 <tSOLAD_ioSamples>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
   27116:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
   2711a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   2711c:	42ab      	cmp	r3, r5
   2711e:	f73f af78 	bgt.w	27012 <tAutotune_tick+0x4a>
    return r->tickOutput;
   27122:	6970      	ldr	r0, [r6, #20]
}
   27124:	b002      	add	sp, #8
   27126:	ecbd 8b06 	vpop	{d8-d10}
   2712a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2712e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
   27132:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    w->pitchfactor = pitchfactor;
   27136:	ed82 8a02 	vstr	s16, [r2, #8]
   2713a:	e7e1      	b.n	27100 <tAutotune_tick+0x138>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
   2713c:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
   27140:	eef4 7aca 	vcmpe.f32	s15, s20
   27144:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27148:	ddb1      	ble.n	270ae <tAutotune_tick+0xe6>
   2714a:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
   2714e:	ed9a 7a15 	vldr	s14, [sl, #84]	; 0x54
   27152:	eeb4 7ae7 	vcmpe.f32	s14, s15
   27156:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2715a:	dda8      	ble.n	270ae <tAutotune_tick+0xe6>
            p->fba = 5;
   2715c:	9901      	ldr	r1, [sp, #4]
   2715e:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   27160:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
   27162:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   27166:	ee07 2a90 	vmov	s15, r2
    _tSOLAD* w = *wp;
   2716a:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
   2716c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
   27170:	ed92 7a03 	vldr	s14, [r2, #12]
   27174:	eef4 7ac7 	vcmpe.f32	s15, s14
   27178:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2717c:	d599      	bpl.n	270b2 <tAutotune_tick+0xea>
        w->jump = w->readlag - readlag;
   2717e:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
   27182:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
   27186:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
   2718a:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
   2718e:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
   27192:	61d3      	str	r3, [r2, #28]
   27194:	6862      	ldr	r2, [r4, #4]
   27196:	e78c      	b.n	270b2 <tAutotune_tick+0xea>
            p->deltamax = envout - p->max;
   27198:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
            p->max = p->max * ps->radius;
   2719c:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
   271a0:	ee67 6aa6 	vmul.f32	s13, s15, s13
   271a4:	ee36 7ae7 	vsub.f32	s14, s13, s15
   271a8:	edca 6a13 	vstr	s13, [sl, #76]	; 0x4c
   271ac:	e773      	b.n	27096 <tAutotune_tick+0xce>
   271ae:	bf00      	nop
   271b0:	447a0000 	.word	0x447a0000
   271b4:	3f4ccccd 	.word	0x3f4ccccd
   271b8:	42700000 	.word	0x42700000
   271bc:	020fc0a8 	.word	0x020fc0a8

000271c0 <tAutotune_setFreq>:
    r->freq[voice] = f;
   271c0:	6803      	ldr	r3, [r0, #0]
   271c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   271c4:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   271c8:	ed81 0a00 	vstr	s0, [r1]
}
   271cc:	4770      	bx	lr
   271ce:	bf00      	nop

000271d0 <tAutotune_setFidelityThreshold>:

void tAutotune_setFidelityThreshold(tAutotune* const rt, float threshold)
{
    _tAutotune* r = *rt;

    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
   271d0:	6800      	ldr	r0, [r0, #0]
   271d2:	3004      	adds	r0, #4
   271d4:	f7fd be18 	b.w	24e08 <tPeriodDetection_setFidelityThreshold>

000271d8 <tFormantShifter_initToPool>:
{
    tFormantShifter_initToPool(fsr, order, &leaf.mempool);
}

void tFormantShifter_initToPool (tFormantShifter* const fsr, int order, tMempool* const mp)
{
   271d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   271dc:	ed2d 8b06 	vpush	{d8-d10}
    _tMempool* m = *mp;
   271e0:	6815      	ldr	r5, [r2, #0]
{
   271e2:	4688      	mov	r8, r1
   271e4:	4681      	mov	r9, r0
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
   271e6:	2068      	movs	r0, #104	; 0x68
   271e8:	4629      	mov	r1, r5
{
   271ea:	4616      	mov	r6, r2
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
   271ec:	f002 fd4c 	bl	29c88 <mpool_alloc>
   271f0:	4604      	mov	r4, r0
   271f2:	f8c9 0000 	str.w	r0, [r9]
    fs->mempool = m;
    
    fs->ford = order;
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   271f6:	4629      	mov	r1, r5
   271f8:	ea4f 0088 	mov.w	r0, r8, lsl #2
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
    
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);

    
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   271fc:	eddf 9a4d 	vldr	s19, [pc, #308]	; 27334 <tFormantShifter_initToPool+0x15c>
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
    fs->fhp = 0.0f;
    fs->flp = 0.0f;
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
    fs->fmute = 1.0f;
   27200:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
    fs->cbi = 0;
    fs->intensity = 1.0f;
    fs->invIntensity = 1.0f;
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
   27204:	eddf 8a4c 	vldr	s17, [pc, #304]	; 27338 <tFormantShifter_initToPool+0x160>
   27208:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 2733c <tFormantShifter_initToPool+0x164>
    fs->ford = order;
   2720c:	e9c4 5800 	strd	r5, r8, [r4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27210:	f002 fd90 	bl	29d34 <mpool_calloc>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27214:	6863      	ldr	r3, [r4, #4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27216:	6120      	str	r0, [r4, #16]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27218:	4629      	mov	r1, r5
   2721a:	0098      	lsls	r0, r3, #2
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2721c:	f8df 812c 	ldr.w	r8, [pc, #300]	; 2734c <tFormantShifter_initToPool+0x174>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27220:	f002 fd88 	bl	29d34 <mpool_calloc>
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27224:	6863      	ldr	r3, [r4, #4]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27226:	6160      	str	r0, [r4, #20]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27228:	4629      	mov	r1, r5
   2722a:	0098      	lsls	r0, r3, #2
   2722c:	f002 fd82 	bl	29d34 <mpool_calloc>
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27230:	6863      	ldr	r3, [r4, #4]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27232:	61a0      	str	r0, [r4, #24]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27234:	4629      	mov	r1, r5
   27236:	0098      	lsls	r0, r3, #2
   27238:	f002 fd7c 	bl	29d34 <mpool_calloc>
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2723c:	6863      	ldr	r3, [r4, #4]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2723e:	61e0      	str	r0, [r4, #28]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27240:	4629      	mov	r1, r5
   27242:	0098      	lsls	r0, r3, #2
   27244:	f002 fd76 	bl	29d34 <mpool_calloc>
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27248:	6863      	ldr	r3, [r4, #4]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2724a:	6220      	str	r0, [r4, #32]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   2724c:	4629      	mov	r1, r5
   2724e:	0098      	lsls	r0, r3, #2
   27250:	f002 fd70 	bl	29d34 <mpool_calloc>
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27254:	6863      	ldr	r3, [r4, #4]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27256:	6260      	str	r0, [r4, #36]	; 0x24
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27258:	4629      	mov	r1, r5
   2725a:	0098      	lsls	r0, r3, #2
   2725c:	f002 fd6a 	bl	29d34 <mpool_calloc>
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27260:	6863      	ldr	r3, [r4, #4]
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27262:	62a0      	str	r0, [r4, #40]	; 0x28
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27264:	4629      	mov	r1, r5
   27266:	0098      	lsls	r0, r3, #2
   27268:	f002 fd64 	bl	29d34 <mpool_calloc>
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   2726c:	6863      	ldr	r3, [r4, #4]
   2726e:	4629      	mov	r1, r5
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
   27270:	63e0      	str	r0, [r4, #60]	; 0x3c
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   27272:	0098      	lsls	r0, r3, #2
   27274:	f002 fd5e 	bl	29d34 <mpool_calloc>
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   27278:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
   2727c:	ed98 aa01 	vldr	s20, [r8, #4]
   27280:	eeb0 0a69 	vmov.f32	s0, s19
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
   27284:	63a0      	str	r0, [r4, #56]	; 0x38
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   27286:	ee6a 0a20 	vmul.f32	s1, s20, s1
   2728a:	f005 feb1 	bl	2cff0 <powf>
   2728e:	eeb0 9a40 	vmov.f32	s18, s0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   27292:	eddf 7a2b 	vldr	s15, [pc, #172]	; 27340 <tFormantShifter_initToPool+0x168>
   27296:	ed98 0a00 	vldr	s0, [r8]
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
   2729a:	ed84 9a02 	vstr	s18, [r4, #8]
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   2729e:	ee20 0a27 	vmul.f32	s0, s0, s15
   272a2:	f005 fc25 	bl	2caf0 <atanf>
   272a6:	eef1 6ac0 	vsqrt.f32	s13, s0
   272aa:	ed9f 7a26 	vldr	s14, [pc, #152]	; 27344 <tFormantShifter_initToPool+0x16c>
    fs->fhp = 0.0f;
   272ae:	2300      	movs	r3, #0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   272b0:	eddf 7a25 	vldr	s15, [pc, #148]	; 27348 <tFormantShifter_initToPool+0x170>
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
   272b4:	ed84 9a0d 	vstr	s18, [r4, #52]	; 0x34
    fs->fhp = 0.0f;
   272b8:	62e3      	str	r3, [r4, #44]	; 0x2c
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   272ba:	eef0 0a4a 	vmov.f32	s1, s20
    fs->flp = 0.0f;
   272be:	6323      	str	r3, [r4, #48]	; 0x30
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   272c0:	eeb0 0a69 	vmov.f32	s0, s19
    fs->fmute = 1.0f;
   272c4:	6427      	str	r7, [r4, #64]	; 0x40
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
   272c6:	eee6 7ac7 	vfms.f32	s15, s13, s14
   272ca:	edc4 7a03 	vstr	s15, [r4, #12]
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   272ce:	f005 fe8f 	bl	2cff0 <powf>
    fs->cbi = 0;
   272d2:	2300      	movs	r3, #0
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
   272d4:	ed84 0a11 	vstr	s0, [r4, #68]	; 0x44
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   272d8:	4631      	mov	r1, r6
    fs->cbi = 0;
   272da:	64a3      	str	r3, [r4, #72]	; 0x48
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   272dc:	f104 0058 	add.w	r0, r4, #88	; 0x58
    fs->intensity = 1.0f;
   272e0:	6527      	str	r7, [r4, #80]	; 0x50
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   272e2:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
    fs->invIntensity = 1.0f;
   272e6:	6567      	str	r7, [r4, #84]	; 0x54
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
   272e8:	f001 f948 	bl	2857c <tHighpass_initToPool>
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
   272ec:	4631      	mov	r1, r6
   272ee:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   272f2:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   272f6:	f001 f941 	bl	2857c <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
   272fa:	4632      	mov	r2, r6
   272fc:	f104 0060 	add.w	r0, r4, #96	; 0x60
   27300:	eef0 0a68 	vmov.f32	s1, s17
   27304:	eeb0 0a48 	vmov.f32	s0, s16
   27308:	2101      	movs	r1, #1
   2730a:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
   2730e:	f7fe fc0f 	bl	25b30 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
   27312:	eef0 0a68 	vmov.f32	s1, s17
   27316:	eeb0 0a48 	vmov.f32	s0, s16
   2731a:	4632      	mov	r2, r6
   2731c:	f104 0064 	add.w	r0, r4, #100	; 0x64
   27320:	2101      	movs	r1, #1
   27322:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
}
   27326:	ecbd 8b06 	vpop	{d8-d10}
   2732a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
   2732e:	f7fe bbff 	b.w	25b30 <tFeedbackLeveler_initToPool>
   27332:	bf00      	nop
   27334:	3a83126f 	.word	0x3a83126f
   27338:	3ba3d70a 	.word	0x3ba3d70a
   2733c:	3f4ccccd 	.word	0x3f4ccccd
   27340:	3d86d1e1 	.word	0x3d86d1e1
   27344:	3f5a0903 	.word	0x3f5a0903
   27348:	3e4432ca 	.word	0x3e4432ca
   2734c:	020fc0a8 	.word	0x020fc0a8

00027350 <tFormantShifter_free>:

void tFormantShifter_free (tFormantShifter* const fsr)
{
   27350:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
   27352:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)fs->fk, fs->mempool);
   27354:	6821      	ldr	r1, [r4, #0]
   27356:	6920      	ldr	r0, [r4, #16]
   27358:	f002 fd3e 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->fb, fs->mempool);
   2735c:	6821      	ldr	r1, [r4, #0]
   2735e:	6960      	ldr	r0, [r4, #20]
   27360:	f002 fd3a 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->fc, fs->mempool);
   27364:	6821      	ldr	r1, [r4, #0]
   27366:	69a0      	ldr	r0, [r4, #24]
   27368:	f002 fd36 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->frb, fs->mempool);
   2736c:	6821      	ldr	r1, [r4, #0]
   2736e:	69e0      	ldr	r0, [r4, #28]
   27370:	f002 fd32 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->frc, fs->mempool);
   27374:	6821      	ldr	r1, [r4, #0]
   27376:	6a20      	ldr	r0, [r4, #32]
   27378:	f002 fd2e 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->fsig, fs->mempool);
   2737c:	6821      	ldr	r1, [r4, #0]
   2737e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   27380:	f002 fd2a 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->fsmooth, fs->mempool);
   27384:	6821      	ldr	r1, [r4, #0]
   27386:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   27388:	f002 fd26 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->ftvec, fs->mempool);
   2738c:	6821      	ldr	r1, [r4, #0]
   2738e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   27390:	f002 fd22 	bl	29dd8 <mpool_free>
    mpool_free((char*)fs->fbuff, fs->mempool);
   27394:	6821      	ldr	r1, [r4, #0]
   27396:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   27398:	f002 fd1e 	bl	29dd8 <mpool_free>
    tHighpass_free(&fs->hp);
   2739c:	f104 0058 	add.w	r0, r4, #88	; 0x58
   273a0:	f001 f90c 	bl	285bc <tHighpass_free>
    tHighpass_free(&fs->hp2);
   273a4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   273a8:	f001 f908 	bl	285bc <tHighpass_free>
    tFeedbackLeveler_free(&fs->fbl1);
   273ac:	f104 0060 	add.w	r0, r4, #96	; 0x60
   273b0:	f7fe fbe6 	bl	25b80 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&fs->fbl2);
   273b4:	f104 0064 	add.w	r0, r4, #100	; 0x64
   273b8:	f7fe fbe2 	bl	25b80 <tFeedbackLeveler_free>
    mpool_free((char*)fs, fs->mempool);
   273bc:	6821      	ldr	r1, [r4, #0]
   273be:	4620      	mov	r0, r4
}
   273c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)fs, fs->mempool);
   273c4:	f002 bd08 	b.w	29dd8 <mpool_free>

000273c8 <tFormantShifter_remove>:
{
    return tFormantShifter_add(fsr, tFormantShifter_remove(fsr, in));
}

float tFormantShifter_remove(tFormantShifter* const fsr, float in)
{
   273c8:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
   273ca:	6804      	ldr	r4, [r0, #0]
    in = tFeedbackLeveler_tick(&fs->fbl1, in);
   273cc:	f104 0060 	add.w	r0, r4, #96	; 0x60
   273d0:	f7fe fbe6 	bl	25ba0 <tFeedbackLeveler_tick>
    in = tHighpass_tick(&fs->hp, in * fs->intensity);
   273d4:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
   273d8:	f104 0058 	add.w	r0, r4, #88	; 0x58
   273dc:	ee20 0a27 	vmul.f32	s0, s0, s15
   273e0:	f001 f900 	bl	285e4 <tHighpass_tick>
    

    float fa, fb, fc, foma, falph, ford, flamb, tf, fk;

    ford = fs->ford;
   273e4:	edd4 7a01 	vldr	s15, [r4, #4]
    foma = (1.0f - falph);
    flamb = fs->flamb;
    
    tf = in;
    
    fa = tf - fs->fhp;
   273e8:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c
    foma = (1.0f - falph);
   273ec:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    ford = fs->ford;
   273f0:	eef8 3ae7 	vcvt.f32.s32	s7, s15
    falph = fs->falph;
   273f4:	ed94 5a02 	vldr	s10, [r4, #8]
    fa = tf - fs->fhp;
   273f8:	ee70 6a66 	vsub.f32	s13, s0, s13
    fs->fhp = tf;
   273fc:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
    foma = (1.0f - falph);
   27400:	ee75 5ac5 	vsub.f32	s11, s11, s10
    flamb = fs->flamb;
   27404:	ed94 3a03 	vldr	s6, [r4, #12]
    fb = fa;
    for(int i = 0; i < ford; i++)
   27408:	eef5 3ac0 	vcmpe.f32	s7, #0.0
    fa = tf - fs->fhp;
   2740c:	eeb0 0a66 	vmov.f32	s0, s13
    for(int i = 0; i < ford; i++)
   27410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27414:	dd53      	ble.n	274be <tFormantShifter_remove+0xf6>
   27416:	2100      	movs	r1, #0
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
        fs->fc[i] = fc;
        fs->fb[i] = fb;
        fk = fa*fc*foma + fs->fk[i]*falph;
        fs->fk[i] = fk;
        tf = fk/(fs->fsig[i] + 0.000001f);
   27418:	eddf 2a29 	vldr	s5, [pc, #164]	; 274c0 <tFormantShifter_remove+0xf8>
   2741c:	008b      	lsls	r3, r1, #2
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   2741e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    for(int i = 0; i < ford; i++)
   27420:	3101      	adds	r1, #1
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   27422:	ee20 7a00 	vmul.f32	s14, s0, s0
   27426:	441a      	add	r2, r3
        fk = fa*fc*foma + fs->fk[i]*falph;
   27428:	ee25 6a80 	vmul.f32	s12, s11, s0
    for(int i = 0; i < ford; i++)
   2742c:	ee07 1a90 	vmov	s15, r1
   27430:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   27434:	edd2 7a00 	vldr	s15, [r2]
   27438:	ee65 7a27 	vmul.f32	s15, s10, s15
    for(int i = 0; i < ford; i++)
   2743c:	eef4 4ae3 	vcmpe.f32	s9, s7
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   27440:	eee5 7a87 	vfma.f32	s15, s11, s14
    for(int i = 0; i < ford; i++)
   27444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
   27448:	edc2 7a00 	vstr	s15, [r2]
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
   2744c:	e9d4 0205 	ldrd	r0, r2, [r4, #20]
   27450:	441a      	add	r2, r3
   27452:	4418      	add	r0, r3
   27454:	edd2 7a00 	vldr	s15, [r2]
   27458:	ed90 7a00 	vldr	s14, [r0]
   2745c:	ee76 7ae7 	vsub.f32	s15, s13, s15
   27460:	eea7 7a83 	vfma.f32	s14, s15, s6
        fs->fc[i] = fc;
   27464:	ed82 7a00 	vstr	s14, [r2]
        fs->fb[i] = fb;
   27468:	6962      	ldr	r2, [r4, #20]
   2746a:	441a      	add	r2, r3
   2746c:	edc2 6a00 	vstr	s13, [r2]
        fk = fa*fc*foma + fs->fk[i]*falph;
   27470:	6922      	ldr	r2, [r4, #16]
   27472:	441a      	add	r2, r3
   27474:	edd2 6a00 	vldr	s13, [r2]
   27478:	ee65 6a26 	vmul.f32	s13, s10, s13
   2747c:	eee6 6a07 	vfma.f32	s13, s12, s14
        fs->fk[i] = fk;
   27480:	edc2 6a00 	vstr	s13, [r2]
        tf = tf*foma + fs->fsmooth[i]*falph;
   27484:	e9d4 0209 	ldrd	r0, r2, [r4, #36]	; 0x24
        tf = fk/(fs->fsig[i] + 0.000001f);
   27488:	4418      	add	r0, r3
        tf = tf*foma + fs->fsmooth[i]*falph;
   2748a:	441a      	add	r2, r3
        tf = fk/(fs->fsig[i] + 0.000001f);
   2748c:	ed90 6a00 	vldr	s12, [r0]
        tf = tf*foma + fs->fsmooth[i]*falph;
   27490:	edd2 7a00 	vldr	s15, [r2]
        tf = fk/(fs->fsig[i] + 0.000001f);
   27494:	ee36 6a22 	vadd.f32	s12, s12, s5
        tf = tf*foma + fs->fsmooth[i]*falph;
   27498:	ee65 7a27 	vmul.f32	s15, s10, s15
        tf = fk/(fs->fsig[i] + 0.000001f);
   2749c:	ee86 4a86 	vdiv.f32	s8, s13, s12
        fs->fsmooth[i] = tf;
        fs->fbuff[i] = tf;
        fb = fc - tf*fa;
   274a0:	eef0 6a47 	vmov.f32	s13, s14
        tf = tf*foma + fs->fsmooth[i]*falph;
   274a4:	eee5 7a84 	vfma.f32	s15, s11, s8
        fs->fsmooth[i] = tf;
   274a8:	edc2 7a00 	vstr	s15, [r2]
        fb = fc - tf*fa;
   274ac:	eee7 6ac0 	vfms.f32	s13, s15, s0
        fs->fbuff[i] = tf;
   274b0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        fa = fa - tf*fc;
   274b2:	eea7 0a67 	vfms.f32	s0, s14, s15
        fs->fbuff[i] = tf;
   274b6:	4413      	add	r3, r2
   274b8:	edc3 7a00 	vstr	s15, [r3]
    for(int i = 0; i < ford; i++)
   274bc:	d4ae      	bmi.n	2741c <tFormantShifter_remove+0x54>
    }

    //return fa * 0.1f;
    return fa;
}
   274be:	bd10      	pop	{r4, pc}
   274c0:	358637bd 	.word	0x358637bd

000274c4 <tFormantShifter_add>:

float tFormantShifter_add(tFormantShifter* const fsr, float in)
{
   274c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   274c6:	ed2d 8b02 	vpush	{d8}
    _tFormantShifter* fs = *fsr;
   274ca:	6804      	ldr	r4, [r0, #0]
    float fa, fb, fc, ford, flpa, flamb, tf, tf2, f0resp, f1resp, frlamb;
    ford = fs->ford;

    flpa = fs->flpa;
    flamb = fs->flamb;
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   274cc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    flamb = fs->flamb;
   274d0:	edd4 7a03 	vldr	s15, [r4, #12]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   274d4:	ed94 5a13 	vldr	s10, [r4, #76]	; 0x4c
   274d8:	ee37 6a87 	vadd.f32	s12, s15, s14
    flpa = fs->flpa;
   274dc:	ed94 3a0d 	vldr	s6, [r4, #52]	; 0x34
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   274e0:	ee77 6a67 	vsub.f32	s13, s14, s15
    ford = fs->ford;
   274e4:	edd4 7a01 	vldr	s15, [r4, #4]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   274e8:	ee26 6a05 	vmul.f32	s12, s12, s10
    ford = fs->ford;
   274ec:	eef8 5ae7 	vcvt.f32.s32	s11, s15
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
   274f0:	eec6 7a26 	vdiv.f32	s15, s12, s13
    frlamb = (tf-1.0f)/(tf+1.0f);
    
    tf2 = in;
    fa = 0.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
   274f4:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   274f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    frlamb = (tf-1.0f)/(tf+1.0f);
   274fc:	ee77 6ac7 	vsub.f32	s13, s15, s14
   27500:	ee77 7a87 	vadd.f32	s15, s15, s14
   27504:	ee86 5aa7 	vdiv.f32	s10, s13, s15
    for (int i=0; i<ford; i++)
   27508:	f340 8107 	ble.w	2771a <tFormantShifter_add+0x256>
    fb = fa;
   2750c:	eddf 6a87 	vldr	s13, [pc, #540]	; 2772c <tFormantShifter_add+0x268>
    for (int i=0; i<ford; i++)
   27510:	2100      	movs	r1, #0
   27512:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    fa = 0.0f;
   27514:	eef0 7a66 	vmov.f32	s15, s13
   27518:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   2751a:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2751c:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
   27520:	ee04 1a90 	vmov	s9, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
   27524:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27526:	18c6      	adds	r6, r0, r3
   27528:	441d      	add	r5, r3
        tf = fs->fbuff[i];
   2752a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
   2752c:	eef8 4ae4 	vcvt.f32.s32	s9, s9
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27530:	ed96 6a00 	vldr	s12, [r6]
   27534:	ed95 7a00 	vldr	s14, [r5]
        tf = fs->fbuff[i];
   27538:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2753a:	ee76 6ac6 	vsub.f32	s13, s13, s12
        tf = fs->fbuff[i];
   2753e:	ed90 6a00 	vldr	s12, [r0]
    for (int i=0; i<ford; i++)
   27542:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27546:	eea6 7a85 	vfma.f32	s14, s13, s10
    for (int i=0; i<ford; i++)
   2754a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
   2754e:	ee27 4a06 	vmul.f32	s8, s14, s12
        fb = fc - tf*fa;
   27552:	eea6 7a67 	vfms.f32	s14, s12, s15
        fs->ftvec[i] = tf*fc;
   27556:	ed82 4a00 	vstr	s8, [r2]
        fa = fa - fs->ftvec[i];
   2755a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2755c:	4413      	add	r3, r2
        fb = fc - tf*fa;
   2755e:	eef0 6a47 	vmov.f32	s13, s14
        fa = fa - fs->ftvec[i];
   27562:	ed93 7a00 	vldr	s14, [r3]
   27566:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for (int i=0; i<ford; i++)
   2756a:	d4d5      	bmi.n	27518 <tFormantShifter_add+0x54>
   2756c:	eeb1 7a67 	vneg.f32	s14, s15
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
   27570:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27574:	ee75 7ae7 	vsub.f32	s15, s11, s15
   27578:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2757c:	ee17 7a90 	vmov	r7, s15
   27580:	2f00      	cmp	r7, #0
   27582:	f2c0 80c2 	blt.w	2770a <tFormantShifter_add+0x246>
    {
        tf = tf + fs->ftvec[i];
   27586:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   27588:	1c7b      	adds	r3, r7, #1
   2758a:	eb02 0183 	add.w	r1, r2, r3, lsl #2
   2758e:	ed71 7a01 	vldmdb	r1!, {s15}
    for (int i=ford-1; i>=0; i--)
   27592:	428a      	cmp	r2, r1
        tf = tf + fs->ftvec[i];
   27594:	ee37 7a27 	vadd.f32	s14, s14, s15
    for (int i=ford-1; i>=0; i--)
   27598:	d1f9      	bne.n	2758e <tFormantShifter_add+0xca>
    f0resp = tf;
    
    //  second time: compute 1-response
    fa = 1.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
   2759a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2759e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   275a2:	f340 80bf 	ble.w	27724 <tFormantShifter_add+0x260>
    fb = fa;
   275a6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    for (int i=0; i<ford; i++)
   275aa:	2100      	movs	r1, #0
    fa = 1.0f;
   275ac:	eef0 7a46 	vmov.f32	s15, s12
   275b0:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   275b2:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   275b4:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
   275b8:	ee04 1a10 	vmov	s8, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
   275bc:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   275be:	18c6      	adds	r6, r0, r3
   275c0:	441d      	add	r5, r3
        tf = fs->fbuff[i];
   275c2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
   275c4:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   275c8:	edd6 4a00 	vldr	s9, [r6]
   275cc:	edd5 6a00 	vldr	s13, [r5]
        tf = fs->fbuff[i];
   275d0:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   275d2:	ee36 6a64 	vsub.f32	s12, s12, s9
        tf = fs->fbuff[i];
   275d6:	edd0 4a00 	vldr	s9, [r0]
    for (int i=0; i<ford; i++)
   275da:	eeb4 4ae5 	vcmpe.f32	s8, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   275de:	eee6 6a05 	vfma.f32	s13, s12, s10
    for (int i=0; i<ford; i++)
   275e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
   275e6:	ee66 3aa4 	vmul.f32	s7, s13, s9
        fb = fc - tf*fa;
   275ea:	eee4 6ae7 	vfms.f32	s13, s9, s15
        fs->ftvec[i] = tf*fc;
   275ee:	edc2 3a00 	vstr	s7, [r2]
        fa = fa - fs->ftvec[i];
   275f2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   275f4:	4413      	add	r3, r2
        fb = fc - tf*fa;
   275f6:	eeb0 6a66 	vmov.f32	s12, s13
        fa = fa - fs->ftvec[i];
   275fa:	edd3 6a00 	vldr	s13, [r3]
   275fe:	ee77 7ae6 	vsub.f32	s15, s15, s13
    for (int i=0; i<ford; i++)
   27602:	d4d5      	bmi.n	275b0 <tFormantShifter_add+0xec>
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
   27604:	2f00      	cmp	r7, #0
   27606:	eef1 7a67 	vneg.f32	s15, s15
   2760a:	db08      	blt.n	2761e <tFormantShifter_add+0x15a>
   2760c:	1c7b      	adds	r3, r7, #1
   2760e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    {
        tf = tf + fs->ftvec[i];
   27612:	ed73 6a01 	vldmdb	r3!, {s13}
    for (int i=ford-1; i>=0; i--)
   27616:	429a      	cmp	r2, r3
        tf = tf + fs->ftvec[i];
   27618:	ee77 7aa6 	vadd.f32	s15, s15, s13
    for (int i=ford-1; i>=0; i--)
   2761c:	d1f9      	bne.n	27612 <tFormantShifter_add+0x14e>
    f1resp = tf;
    
    //  now solve equations for output, based on 0-response and 1-response
    tf = 2.0f*tf2;
    tf2 = tf;
    tf = (1.0f - f1resp + f0resp);
   2761e:	ee77 7a67 	vsub.f32	s15, s14, s15
    if (tf!=0.0f)
   27622:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   27626:	eef4 7a66 	vcmp.f32	s15, s13
   2762a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2762e:	d066      	beq.n	276fe <tFormantShifter_add+0x23a>
    {
        tf2 = (tf2 + f0resp) / tf;
   27630:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
    tf = (1.0f - f1resp + f0resp);
   27634:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
        tf2 = (tf2 + f0resp) / tf;
   27638:	eea0 7a06 	vfma.f32	s14, s0, s12
    tf = (1.0f - f1resp + f0resp);
   2763c:	ee77 7aa6 	vadd.f32	s15, s15, s13
        tf2 = (tf2 + f0resp) / tf;
   27640:	ee87 0a27 	vdiv.f32	s0, s14, s15
    }
    
    //  third time: update delay registers
    fa = tf2;
    fb = fa;
    for (int i=0; i<ford; i++)
   27644:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   27648:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2764c:	dd2b      	ble.n	276a6 <tFormantShifter_add+0x1e2>
    fb = fa;
   2764e:	eeb0 6a40 	vmov.f32	s12, s0
    for (int i=0; i<ford; i++)
   27652:	2100      	movs	r1, #0
    fa = tf2;
   27654:	eef0 6a40 	vmov.f32	s13, s0
   27658:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
   2765a:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2765c:	e9d4 0207 	ldrd	r0, r2, [r4, #28]
    for (int i=0; i<ford; i++)
   27660:	ee07 1a90 	vmov	s15, r1
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   27664:	441a      	add	r2, r3
   27666:	4418      	add	r0, r3
    for (int i=0; i<ford; i++)
   27668:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2766c:	ed92 7a00 	vldr	s14, [r2]
   27670:	edd0 7a00 	vldr	s15, [r0]
   27674:	ee36 7a47 	vsub.f32	s14, s12, s14
    for (int i=0; i<ford; i++)
   27678:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
   2767c:	eee7 7a05 	vfma.f32	s15, s14, s10
    for (int i=0; i<ford; i++)
   27680:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->frc[i] = fc;
   27684:	edc2 7a00 	vstr	s15, [r2]
        fs->frb[i] = fb;
   27688:	69e2      	ldr	r2, [r4, #28]
   2768a:	441a      	add	r2, r3
   2768c:	ed82 6a00 	vstr	s12, [r2]
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
   27690:	eeb0 6a67 	vmov.f32	s12, s15
        tf = fs->fbuff[i];
   27694:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   27696:	4413      	add	r3, r2
   27698:	ed93 7a00 	vldr	s14, [r3]
        fb = fc - tf*fa;
   2769c:	eea7 6a66 	vfms.f32	s12, s14, s13
        fa = fa - tf*fc;
   276a0:	eee7 6ac7 	vfms.f32	s13, s15, s14
    for (int i=0; i<ford; i++)
   276a4:	d4d8      	bmi.n	27658 <tFormantShifter_add+0x194>
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
    fs->flp = tf;
    
    // Bring up the gain slowly when formant correction goes from disabled
    // to enabled, while things stabilize.
    if (fs->fmute>0.5f)
   276a6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
   276aa:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
   276ae:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
   276b2:	eea7 0a03 	vfma.f32	s0, s14, s6
    if (fs->fmute>0.5f)
   276b6:	eeb4 8ae7 	vcmpe.f32	s16, s15
   276ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    fs->flp = tf;
   276be:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
   276c2:	dd1f      	ble.n	27704 <tFormantShifter_add+0x240>
    {
        tf = tf*(fs->fmute - 0.5f)*2.0f;
   276c4:	ee78 7a67 	vsub.f32	s15, s16, s15
   276c8:	ee77 7aa7 	vadd.f32	s15, s15, s15
   276cc:	ee27 0a80 	vmul.f32	s0, s15, s0
   276d0:	f005 fdf4 	bl	2d2bc <tanhf>
    else
    {
        tf = 0.0f;
    }
    tf2 = fs->fmutealph;
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
   276d4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   276d8:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
    // now tf is signal output
    // ...and we're done messing with formants
    //tf = tFeedbackLeveler_tick(&fs->fbl2, tf);
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
   276dc:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
   276e0:	ee38 8a67 	vsub.f32	s16, s16, s15
   276e4:	eee8 7a07 	vfma.f32	s15, s16, s14
   276e8:	edc4 7a10 	vstr	s15, [r4, #64]	; 0x40
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
   276ec:	f000 ff7a 	bl	285e4 <tHighpass_tick>

    return tf * fs->invIntensity;
   276f0:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
}
   276f4:	ecbd 8b02 	vpop	{d8}
    return tf * fs->invIntensity;
   276f8:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   276fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tf2 = 0.0f;
   276fe:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 2772c <tFormantShifter_add+0x268>
   27702:	e79f      	b.n	27644 <tFormantShifter_add+0x180>
   27704:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2772c <tFormantShifter_add+0x268>
   27708:	e7e4      	b.n	276d4 <tFormantShifter_add+0x210>
    for (int i=0; i<ford; i++)
   2770a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
   2770e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27712:	dc05      	bgt.n	27720 <tFormantShifter_add+0x25c>
   27714:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   27718:	e781      	b.n	2761e <tFormantShifter_add+0x15a>
    for (int i=0; i<ford; i++)
   2771a:	ed9f 7a04 	vldr	s14, [pc, #16]	; 2772c <tFormantShifter_add+0x268>
   2771e:	e727      	b.n	27570 <tFormantShifter_add+0xac>
   27720:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   27722:	e740      	b.n	275a6 <tFormantShifter_add+0xe2>
    for (int i=0; i<ford; i++)
   27724:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   27728:	e771      	b.n	2760e <tFormantShifter_add+0x14a>
   2772a:	bf00      	nop
   2772c:	00000000 	.word	0x00000000

00027730 <tFormantShifter_setShiftFactor>:

// 1.0f is no change, 2.0f is an octave up, 0.5f is an octave down
void tFormantShifter_setShiftFactor(tFormantShifter* const fsr, float shiftFactor)
{
    _tFormantShifter* fs = *fsr;
   27730:	6803      	ldr	r3, [r0, #0]
    fs->shiftFactor = shiftFactor;
   27732:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
   27736:	4770      	bx	lr

00027738 <tFormantShifter_setIntensity>:

void tFormantShifter_setIntensity(tFormantShifter* const fsr, float intensity)
{
   27738:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;



    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   2773a:	eef0 0a40 	vmov.f32	s1, s0
   2773e:	ed9f 1a0d 	vldr	s2, [pc, #52]	; 27774 <tFormantShifter_setIntensity+0x3c>
   27742:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    _tFormantShifter* fs = *fsr;
   27746:	6804      	ldr	r4, [r0, #0]
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   27748:	f002 f89e 	bl	29888 <LEAF_clip>

   // tFeedbackLeveler_setTargetLevel(&fs->fbl1, fs->intensity);
    //tFeedbackLeveler_setTargetLevel(&fs->fbl2, fs->intensity);
    //make sure you don't divide by zero, doofies
    if (fs->intensity != 0.0f)
   2774c:	eeb5 0a40 	vcmp.f32	s0, #0.0
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
   27750:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
    if (fs->intensity != 0.0f)
   27754:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27758:	d104      	bne.n	27764 <tFormantShifter_setIntensity+0x2c>
    {
    	fs->invIntensity = 1.0f/fs->intensity;
    }
    else
    {
    	fs->invIntensity = 1.0f;
   2775a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2775e:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
    }

}
   27762:	bd10      	pop	{r4, pc}
    	fs->invIntensity = 1.0f/fs->intensity;
   27764:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27768:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2776c:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
   27770:	bd10      	pop	{r4, pc}
   27772:	bf00      	nop
   27774:	42c80000 	.word	0x42c80000

00027778 <tADSR4_initToPool>:
}

//initialize with an exponential function that decays -- i.e. a call to LEAF_generate_exp(expBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, EXP_BUFFER_SIZE);
//times are in ms
void    tADSR4_initToPool    (tADSR4* const adsrenv, float attack, float decay, float sustain, float release, float* expBuffer, int bufferSize, tMempool* const mp)
{
   27778:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2777a:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2777e:	681d      	ldr	r5, [r3, #0]
{
   27780:	4614      	mov	r4, r2
   27782:	4607      	mov	r7, r0
   27784:	460e      	mov	r6, r1
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   27786:	2050      	movs	r0, #80	; 0x50
   27788:	4629      	mov	r1, r5
{
   2778a:	eef0 8a61 	vmov.f32	s17, s3
   2778e:	eef0 9a40 	vmov.f32	s19, s0
   27792:	eeb0 9a60 	vmov.f32	s18, s1
   27796:	eeb0 8a41 	vmov.f32	s16, s2
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   2779a:	f002 fa75 	bl	29c88 <mpool_alloc>

    adsr->exp_buff = expBuffer;
    adsr->buff_size = bufferSize;
    adsr->buff_sizeMinusOne = bufferSize - 1;

    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   2779e:	4b20      	ldr	r3, [pc, #128]	; (27820 <tADSR4_initToPool+0xa8>)
   277a0:	ee07 4a90 	vmov	s15, r4
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
   277a4:	6038      	str	r0, [r7, #0]

    adsr->next = 0.0f;

    adsr->whichStage = env_idle;

    adsr->sustain = sustain;
   277a6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   277aa:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
    adsr->mempool = m;
   277ae:	6005      	str	r5, [r0, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   277b0:	eddf 7a1c 	vldr	s15, [pc, #112]	; 27824 <tADSR4_initToPool+0xac>

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   277b4:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   277b8:	edd3 6a00 	vldr	s13, [r3]
    adsr->buff_sizeMinusOne = bufferSize - 1;
   277bc:	1e62      	subs	r2, r4, #1
   277be:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 27828 <tADSR4_initToPool+0xb0>
    adsr->whichStage = env_idle;
   277c2:	2300      	movs	r3, #0
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   277c4:	ee66 6aa7 	vmul.f32	s13, s13, s15

    adsr->leakFactor = 1.0f;
   277c8:	ed80 6a13 	vstr	s12, [r0, #76]	; 0x4c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   277cc:	fec9 9a87 	vmaxnm.f32	s19, s19, s14
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   277d0:	fe89 9a07 	vmaxnm.f32	s18, s18, s14
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   277d4:	fec8 1a87 	vmaxnm.f32	s3, s17, s14
   277d8:	fe88 8a07 	vmaxnm.f32	s16, s16, s14
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   277dc:	eec5 7a26 	vdiv.f32	s15, s10, s13
    adsr->sustain = sustain;
   277e0:	fe88 8a46 	vminnm.f32	s16, s16, s12
    adsr->next = 0.0f;
   277e4:	ed80 7a05 	vstr	s14, [r0, #20]
    adsr->exp_buff = expBuffer;
   277e8:	6046      	str	r6, [r0, #4]
    adsr->buff_size = bufferSize;
   277ea:	6084      	str	r4, [r0, #8]
    adsr->buff_sizeMinusOne = bufferSize - 1;
   277ec:	60c2      	str	r2, [r0, #12]
    adsr->whichStage = env_idle;
   277ee:	6283      	str	r3, [r0, #40]	; 0x28
    adsr->sustain = sustain;
   277f0:	ed80 8a0b 	vstr	s16, [r0, #44]	; 0x2c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   277f4:	ee87 6aa9 	vdiv.f32	s12, s15, s19
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
   277f8:	edc0 7a04 	vstr	s15, [r0, #16]
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   277fc:	eec7 6a89 	vdiv.f32	s13, s15, s18
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   27800:	ee87 7aa1 	vdiv.f32	s14, s15, s3
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   27804:	ee67 7aa5 	vmul.f32	s15, s15, s11
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   27808:	ed80 6a06 	vstr	s12, [r0, #24]
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
   2780c:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   27810:	edc0 6a07 	vstr	s13, [r0, #28]
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   27814:	ed80 7a08 	vstr	s14, [r0, #32]
}
   27818:	ecbd 8b04 	vpop	{d8-d9}
   2781c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2781e:	bf00      	nop
   27820:	020fc0a8 	.word	0x020fc0a8
   27824:	3a83126f 	.word	0x3a83126f
   27828:	00000000 	.word	0x00000000

0002782c <tADSR4_free>:

void    tADSR4_free  (tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   2782c:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)adsr, adsr->mempool);
   2782e:	6801      	ldr	r1, [r0, #0]
   27830:	f002 bad2 	b.w	29dd8 <mpool_free>

00027834 <tADSR4_setAttack>:
}

void     tADSR4_setAttack(tADSR4* const adsrenv, float attack)
{
    _tADSR4* adsr = *adsrenv;
   27834:	6803      	ldr	r3, [r0, #0]
    if (attack < 0.0f)
    {
        attack = 0.0f;
    }

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
   27836:	eddf 7a05 	vldr	s15, [pc, #20]	; 2784c <tADSR4_setAttack+0x18>
   2783a:	ed93 7a04 	vldr	s14, [r3, #16]
   2783e:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   27842:	eec7 7a00 	vdiv.f32	s15, s14, s0
   27846:	edc3 7a06 	vstr	s15, [r3, #24]
}
   2784a:	4770      	bx	lr
   2784c:	00000000 	.word	0x00000000

00027850 <tADSR4_setDecay>:

void     tADSR4_setDecay(tADSR4* const adsrenv, float decay)
{
    _tADSR4* adsr = *adsrenv;
   27850:	6803      	ldr	r3, [r0, #0]

    if (decay < 0.0f)
    {
        decay = 0.0f;
    }
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
   27852:	eddf 7a05 	vldr	s15, [pc, #20]	; 27868 <tADSR4_setDecay+0x18>
   27856:	ed93 7a04 	vldr	s14, [r3, #16]
   2785a:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   2785e:	eec7 7a00 	vdiv.f32	s15, s14, s0
   27862:	edc3 7a07 	vstr	s15, [r3, #28]
}
   27866:	4770      	bx	lr
   27868:	00000000 	.word	0x00000000

0002786c <tADSR4_setSustain>:

void     tADSR4_setSustain(tADSR4* const adsrenv, float sustain)
{
    _tADSR4* adsr = *adsrenv;

    if (sustain > 1.0f)      adsr->sustain = 1.0f;
   2786c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tADSR4* adsr = *adsrenv;
   27870:	6803      	ldr	r3, [r0, #0]
    if (sustain > 1.0f)      adsr->sustain = 1.0f;
   27872:	eeb4 0ae7 	vcmpe.f32	s0, s15
   27876:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2787a:	dd02      	ble.n	27882 <tADSR4_setSustain+0x16>
   2787c:	edc3 7a0b 	vstr	s15, [r3, #44]	; 0x2c
   27880:	4770      	bx	lr
    else if (sustain < 0.0f) adsr->sustain = 0.0f;
   27882:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   27886:	2200      	movs	r2, #0
   27888:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2788c:	bf4c      	ite	mi
   2788e:	62da      	strmi	r2, [r3, #44]	; 0x2c
    else                     adsr->sustain = sustain;
   27890:	ed83 0a0b 	vstrpl	s0, [r3, #44]	; 0x2c
}
   27894:	4770      	bx	lr
   27896:	bf00      	nop

00027898 <tADSR4_setRelease>:

void     tADSR4_setRelease(tADSR4* const adsrenv, float release)
{
    _tADSR4* adsr = *adsrenv;
   27898:	6803      	ldr	r3, [r0, #0]

    if (release < 0.0f)
    {
        release = 0.0f;
    }
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
   2789a:	eddf 7a05 	vldr	s15, [pc, #20]	; 278b0 <tADSR4_setRelease+0x18>
   2789e:	ed93 7a04 	vldr	s14, [r3, #16]
   278a2:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
   278a6:	eec7 7a00 	vdiv.f32	s15, s14, s0
   278aa:	edc3 7a08 	vstr	s15, [r3, #32]
}
   278ae:	4770      	bx	lr
   278b0:	00000000 	.word	0x00000000

000278b4 <tADSR4_setLeakFactor>:

// 0.999999 is slow leak, 0.9 is fast leak
void     tADSR4_setLeakFactor(tADSR4* const adsrenv, float leakFactor)
{
    _tADSR4* adsr = *adsrenv;
   278b4:	6803      	ldr	r3, [r0, #0]


    adsr->leakFactor = leakFactor;
   278b6:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
   278ba:	4770      	bx	lr

000278bc <tADSR4_on>:

void tADSR4_on(tADSR4* const adsrenv, float velocity)
{
    _tADSR4* adsr = *adsrenv;
   278bc:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage != env_idle) // In case ADSR retriggered while it is still happening.
   278be:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   278c0:	b942      	cbnz	r2, 278d4 <tADSR4_on+0x18>
        adsr->whichStage = env_ramp;
        adsr->rampPeak = adsr->next;
    }
    else // Normal start.
    {
        adsr->whichStage = env_attack;
   278c2:	2101      	movs	r1, #1
    }

    adsr->attackPhase = 0;
   278c4:	2200      	movs	r2, #0
   278c6:	6299      	str	r1, [r3, #40]	; 0x28
    adsr->decayPhase = 0;
    adsr->releasePhase = 0;
    adsr->gain = velocity;
   278c8:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
    adsr->attackPhase = 0;
   278cc:	63da      	str	r2, [r3, #60]	; 0x3c
    adsr->decayPhase = 0;
   278ce:	641a      	str	r2, [r3, #64]	; 0x40
    adsr->releasePhase = 0;
   278d0:	645a      	str	r2, [r3, #68]	; 0x44
}
   278d2:	4770      	bx	lr
        adsr->rampPhase = 0;
   278d4:	2000      	movs	r0, #0
        adsr->rampPeak = adsr->next;
   278d6:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_ramp;
   278d8:	2105      	movs	r1, #5
        adsr->rampPhase = 0;
   278da:	6498      	str	r0, [r3, #72]	; 0x48
        adsr->rampPeak = adsr->next;
   278dc:	635a      	str	r2, [r3, #52]	; 0x34
   278de:	e7f1      	b.n	278c4 <tADSR4_on+0x8>

000278e0 <tADSR4_off>:

void tADSR4_off(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   278e0:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage == env_idle)
   278e2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   278e4:	b11a      	cbz	r2, 278ee <tADSR4_off+0xe>
    {
        return;
    }
    else
    {
        adsr->whichStage = env_release;
   278e6:	2104      	movs	r1, #4
        adsr->releasePeak = adsr->next;
   278e8:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_release;
   278ea:	6299      	str	r1, [r3, #40]	; 0x28
        adsr->releasePeak = adsr->next;
   278ec:	639a      	str	r2, [r3, #56]	; 0x38
    }
}
   278ee:	4770      	bx	lr

000278f0 <tADSR4_tick>:

float   tADSR4_tick(tADSR4* const adsrenv)
{
   278f0:	b510      	push	{r4, lr}
    _tADSR4* adsr = *adsrenv;
   278f2:	6804      	ldr	r4, [r0, #0]
{
   278f4:	ed2d 8b02 	vpush	{d8}

    switch (adsr->whichStage)
   278f8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   278fa:	3b01      	subs	r3, #1
   278fc:	2b04      	cmp	r3, #4
   278fe:	f200 808c 	bhi.w	27a1a <tADSR4_tick+0x12a>
   27902:	e8df f003 	tbb	[pc, r3]
   27906:	4b22      	.short	0x4b22
   27908:	6b3e      	.short	0x6b3e
   2790a:	03          	.byte	0x03
   2790b:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
   2790c:	edd4 7a03 	vldr	s15, [r4, #12]
   27910:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
   27914:	eef8 7a67 	vcvt.f32.u32	s15, s15
   27918:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2791c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27920:	f340 80e3 	ble.w	27aea <tADSR4_tick+0x1fa>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
   27924:	eddf 7aa0 	vldr	s15, [pc, #640]	; 27ba8 <tADSR4_tick+0x2b8>
                adsr->whichStage = env_attack;
   27928:	2301      	movs	r3, #1
   2792a:	eeb0 8a67 	vmov.f32	s16, s15
   2792e:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
   27930:	edc4 7a05 	vstr	s15, [r4, #20]
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
                }
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
            }

            adsr->rampPhase += adsr->rampInc;
   27934:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
            break;
    }
    return adsr->next;
}
   27938:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->rampPhase += adsr->rampInc;
   2793c:	ee37 1a81 	vadd.f32	s2, s15, s2
   27940:	ed84 1a12 	vstr	s2, [r4, #72]	; 0x48
}
   27944:	ecbd 8b02 	vpop	{d8}
   27948:	bd10      	pop	{r4, pc}
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
   2794a:	edd4 7a03 	vldr	s15, [r4, #12]
   2794e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
   27952:	eef8 7a67 	vcvt.f32.u32	s15, s15
   27956:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
   2795a:	eeb4 1ae7 	vcmpe.f32	s2, s15
   2795e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27962:	dd61      	ble.n	27a28 <tADSR4_tick+0x138>
                adsr->whichStage = env_decay;
   27964:	2302      	movs	r3, #2
                adsr->next = adsr->gain;
   27966:	ed84 8a05 	vstr	s16, [r4, #20]
                adsr->whichStage = env_decay;
   2796a:	62a3      	str	r3, [r4, #40]	; 0x28
            adsr->attackPhase += adsr->attackInc;
   2796c:	edd4 7a06 	vldr	s15, [r4, #24]
}
   27970:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->attackPhase += adsr->attackInc;
   27974:	ee37 1a81 	vadd.f32	s2, s15, s2
   27978:	ed84 1a0f 	vstr	s2, [r4, #60]	; 0x3c
}
   2797c:	ecbd 8b02 	vpop	{d8}
   27980:	bd10      	pop	{r4, pc}
            adsr->next = adsr->next * adsr->leakFactor;
   27982:	ed94 8a05 	vldr	s16, [r4, #20]
   27986:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2798a:	ee28 8a27 	vmul.f32	s16, s16, s15
}
   2798e:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->next = adsr->next * adsr->leakFactor;
   27992:	ed84 8a05 	vstr	s16, [r4, #20]
}
   27996:	ecbd 8b02 	vpop	{d8}
   2799a:	bd10      	pop	{r4, pc}
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
   2799c:	edd4 7a03 	vldr	s15, [r4, #12]
   279a0:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
   279a4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   279a8:	eeb4 1ae7 	vcmpe.f32	s2, s15
   279ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   279b0:	dd66      	ble.n	27a80 <tADSR4_tick+0x190>
                adsr->next = adsr->gain * adsr->sustain;
   279b2:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
                adsr->whichStage = env_sustain;
   279b6:	2303      	movs	r3, #3
                adsr->next = adsr->gain * adsr->sustain;
   279b8:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
                adsr->whichStage = env_sustain;
   279bc:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = adsr->gain * adsr->sustain;
   279be:	ee28 8a27 	vmul.f32	s16, s16, s15
   279c2:	ed84 8a05 	vstr	s16, [r4, #20]
            adsr->decayPhase += adsr->decayInc;
   279c6:	edd4 7a07 	vldr	s15, [r4, #28]
}
   279ca:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->decayPhase += adsr->decayInc;
   279ce:	ee37 1a81 	vadd.f32	s2, s15, s2
   279d2:	ed84 1a10 	vstr	s2, [r4, #64]	; 0x40
}
   279d6:	ecbd 8b02 	vpop	{d8}
   279da:	bd10      	pop	{r4, pc}
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
   279dc:	edd4 7a03 	vldr	s15, [r4, #12]
   279e0:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
   279e4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   279e8:	eeb4 1ae7 	vcmpe.f32	s2, s15
   279ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   279f0:	f340 80a4 	ble.w	27b3c <tADSR4_tick+0x24c>
                adsr->next = 0.0f;
   279f4:	eddf 7a6c 	vldr	s15, [pc, #432]	; 27ba8 <tADSR4_tick+0x2b8>
                adsr->whichStage = env_idle;
   279f8:	2300      	movs	r3, #0
   279fa:	eeb0 8a67 	vmov.f32	s16, s15
   279fe:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
   27a00:	edc4 7a05 	vstr	s15, [r4, #20]
            adsr->releasePhase += adsr->releaseInc;
   27a04:	edd4 7a08 	vldr	s15, [r4, #32]
}
   27a08:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->releasePhase += adsr->releaseInc;
   27a0c:	ee37 1a81 	vadd.f32	s2, s15, s2
   27a10:	ed84 1a11 	vstr	s2, [r4, #68]	; 0x44
}
   27a14:	ecbd 8b02 	vpop	{d8}
   27a18:	bd10      	pop	{r4, pc}
   27a1a:	ed94 8a05 	vldr	s16, [r4, #20]
   27a1e:	eeb0 0a48 	vmov.f32	s0, s16
   27a22:	ecbd 8b02 	vpop	{d8}
   27a26:	bd10      	pop	{r4, pc}
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a28:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27a2c:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->attackPhase;
   27a2e:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a32:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->attackPhase - intPart;
   27a36:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a3a:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->attackPhase - intPart;
   27a3e:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27a46:	f100 80ab 	bmi.w	27ba0 <tADSR4_tick+0x2b0>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->attackPhase)+1)];
   27a4a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   27a4e:	ee17 3a90 	vmov	r3, s15
   27a52:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   27a56:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->gain * (1.0f - LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // inverted and backwards to get proper rising exponential shape/perception
   27a5a:	ee16 3a90 	vmov	r3, s13
   27a5e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27a62:	ed92 0a00 	vldr	s0, [r2]
   27a66:	f002 f845 	bl	29af4 <LEAF_interpolation_linear>
   27a6a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27a6e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
   27a72:	ee37 0ac0 	vsub.f32	s0, s15, s0
   27a76:	ee28 8a00 	vmul.f32	s16, s16, s0
   27a7a:	ed84 8a05 	vstr	s16, [r4, #20]
   27a7e:	e775      	b.n	2796c <tADSR4_tick+0x7c>
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a80:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27a84:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->decayPhase;
   27a86:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a8a:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->decayPhase - intPart;
   27a8e:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a92:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->decayPhase - intPart;
   27a96:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
   27a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27a9e:	d47c      	bmi.n	27b9a <tADSR4_tick+0x2aa>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->decayPhase)+1)];
   27aa0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   27aa4:	ee17 3a90 	vmov	r3, s15
   27aa8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   27aac:	edd3 0a00 	vldr	s1, [r3]
                float interpValue = (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart));
   27ab0:	ee16 3a90 	vmov	r3, s13
   27ab4:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27ab8:	ed92 0a00 	vldr	s0, [r2]
   27abc:	f002 f81a 	bl	29af4 <LEAF_interpolation_linear>
                adsr->next = (adsr->gain * (adsr->sustain + (interpValue * (1.0f - adsr->sustain)))) * adsr->leakFactor; // do interpolation !
   27ac0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27ac4:	ed94 8a0b 	vldr	s16, [r4, #44]	; 0x2c
   27ac8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   27acc:	ee37 7a48 	vsub.f32	s14, s14, s16
   27ad0:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
   27ad4:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
   27ad8:	ee67 7aa6 	vmul.f32	s15, s15, s13
   27adc:	eea7 8a00 	vfma.f32	s16, s14, s0
   27ae0:	ee27 8a88 	vmul.f32	s16, s15, s16
   27ae4:	ed84 8a05 	vstr	s16, [r4, #20]
   27ae8:	e76d      	b.n	279c6 <tADSR4_tick+0xd6>
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   27aea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27aee:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->rampPhase;
   27af0:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   27af4:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->rampPhase - intPart;
   27af8:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   27afc:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->rampPhase - intPart;
   27b00:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
   27b04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27b08:	d444      	bmi.n	27b94 <tADSR4_tick+0x2a4>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
   27b0a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   27b0e:	ee17 3a90 	vmov	r3, s15
   27b12:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   27b16:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
   27b1a:	ee16 3a90 	vmov	r3, s13
   27b1e:	ed94 8a0d 	vldr	s16, [r4, #52]	; 0x34
   27b22:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27b26:	ed92 0a00 	vldr	s0, [r2]
   27b2a:	f001 ffe3 	bl	29af4 <LEAF_interpolation_linear>
   27b2e:	ee28 8a00 	vmul.f32	s16, s16, s0
   27b32:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
   27b36:	ed84 8a05 	vstr	s16, [r4, #20]
   27b3a:	e6fb      	b.n	27934 <tADSR4_tick+0x44>
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   27b3c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27b40:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->releasePhase;
   27b42:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   27b46:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->releasePhase - intPart;
   27b4a:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   27b4e:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->releasePhase - intPart;
   27b52:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
   27b56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27b5a:	d418      	bmi.n	27b8e <tADSR4_tick+0x29e>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->releasePhase)+1)];
   27b5c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   27b60:	ee17 3a90 	vmov	r3, s15
   27b64:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   27b68:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->releasePeak * (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // do interpolation !
   27b6c:	ee16 3a90 	vmov	r3, s13
   27b70:	ed94 8a0e 	vldr	s16, [r4, #56]	; 0x38
   27b74:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   27b78:	ed92 0a00 	vldr	s0, [r2]
   27b7c:	f001 ffba 	bl	29af4 <LEAF_interpolation_linear>
   27b80:	ee28 8a00 	vmul.f32	s16, s16, s0
   27b84:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
   27b88:	ed84 8a05 	vstr	s16, [r4, #20]
   27b8c:	e73a      	b.n	27a04 <tADSR4_tick+0x114>
                    secondValue = 0.0f;
   27b8e:	eddf 0a06 	vldr	s1, [pc, #24]	; 27ba8 <tADSR4_tick+0x2b8>
   27b92:	e7eb      	b.n	27b6c <tADSR4_tick+0x27c>
                    secondValue = 0.0f;
   27b94:	eddf 0a04 	vldr	s1, [pc, #16]	; 27ba8 <tADSR4_tick+0x2b8>
   27b98:	e7bf      	b.n	27b1a <tADSR4_tick+0x22a>
                    secondValue = 0.0f;
   27b9a:	eddf 0a03 	vldr	s1, [pc, #12]	; 27ba8 <tADSR4_tick+0x2b8>
   27b9e:	e787      	b.n	27ab0 <tADSR4_tick+0x1c0>
                    secondValue = 0.0f;
   27ba0:	eddf 0a01 	vldr	s1, [pc, #4]	; 27ba8 <tADSR4_tick+0x2b8>
   27ba4:	e759      	b.n	27a5a <tADSR4_tick+0x16a>
   27ba6:	bf00      	nop
   27ba8:	00000000 	.word	0x00000000

00027bac <tADSR4_tickNoInterp>:

float   tADSR4_tickNoInterp(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
   27bac:	6803      	ldr	r3, [r0, #0]

    switch (adsr->whichStage)
   27bae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   27bb0:	3a01      	subs	r2, #1
   27bb2:	2a04      	cmp	r2, #4
   27bb4:	d872      	bhi.n	27c9c <tADSR4_tickNoInterp+0xf0>
   27bb6:	e8df f002 	tbb	[pc, r2]
   27bba:	3d1c      	.short	0x3d1c
   27bbc:	5934      	.short	0x5934
   27bbe:	03          	.byte	0x03
   27bbf:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
   27bc0:	edd3 7a03 	vldr	s15, [r3, #12]
   27bc4:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
   27bc8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27bcc:	eef4 6ac7 	vcmpe.f32	s13, s14
   27bd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27bd4:	f340 808b 	ble.w	27cee <tADSR4_tickNoInterp+0x142>
            {
                adsr->whichStage = env_attack;
   27bd8:	2201      	movs	r2, #1
                adsr->next = 0.0f;
   27bda:	ed9f 0a53 	vldr	s0, [pc, #332]	; 27d28 <tADSR4_tickNoInterp+0x17c>
                adsr->whichStage = env_attack;
   27bde:	629a      	str	r2, [r3, #40]	; 0x28
            else
            {
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
            }

            adsr->rampPhase += adsr->rampInc;
   27be0:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
   27be4:	ed83 0a05 	vstr	s0, [r3, #20]
   27be8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27bec:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
            break;
   27bf0:	4770      	bx	lr


        case env_attack:

            // If attack done, time to turn around.
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
   27bf2:	edd3 7a03 	vldr	s15, [r3, #12]
   27bf6:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
   27bfa:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27bfe:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
   27c02:	eef4 6ac7 	vcmpe.f32	s13, s14
   27c06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27c0a:	dd4a      	ble.n	27ca2 <tADSR4_tickNoInterp+0xf6>
            {
                adsr->whichStage = env_decay;
   27c0c:	2202      	movs	r2, #2
   27c0e:	629a      	str	r2, [r3, #40]	; 0x28
            {
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
            }

            // Increment ADSR attack.
            adsr->attackPhase += adsr->attackInc;
   27c10:	edd3 7a06 	vldr	s15, [r3, #24]
   27c14:	ed83 0a05 	vstr	s0, [r3, #20]
   27c18:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27c1c:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
            break;
   27c20:	4770      	bx	lr
            // Increment ADSR decay.
            adsr->decayPhase += adsr->decayInc;
            break;

        case env_sustain:
            adsr->next = adsr->next * adsr->leakFactor;
   27c22:	ed93 0a05 	vldr	s0, [r3, #20]
   27c26:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
   27c2a:	ee20 0a27 	vmul.f32	s0, s0, s15
   27c2e:	ed83 0a05 	vstr	s0, [r3, #20]
            break;
   27c32:	4770      	bx	lr
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
   27c34:	edd3 7a03 	vldr	s15, [r3, #12]
   27c38:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
   27c3c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27c40:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
   27c44:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
   27c48:	eef4 6ac7 	vcmpe.f32	s13, s14
   27c4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27c50:	dd37      	ble.n	27cc2 <tADSR4_tickNoInterp+0x116>
                adsr->next = adsr->gain * adsr->sustain;
   27c52:	ee20 0a27 	vmul.f32	s0, s0, s15
                adsr->whichStage = env_sustain;
   27c56:	2203      	movs	r2, #3
   27c58:	629a      	str	r2, [r3, #40]	; 0x28
            adsr->decayPhase += adsr->decayInc;
   27c5a:	edd3 7a07 	vldr	s15, [r3, #28]
   27c5e:	ed83 0a05 	vstr	s0, [r3, #20]
   27c62:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27c66:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
            break;
   27c6a:	4770      	bx	lr

        case env_release:
            // If release done, finish.
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
   27c6c:	edd3 7a03 	vldr	s15, [r3, #12]
   27c70:	edd3 6a11 	vldr	s13, [r3, #68]	; 0x44
   27c74:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   27c78:	eef4 6ac7 	vcmpe.f32	s13, s14
   27c7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27c80:	dd43      	ble.n	27d0a <tADSR4_tickNoInterp+0x15e>
            {
                adsr->whichStage = env_idle;
   27c82:	2200      	movs	r2, #0
                adsr->next = 0.0f;
   27c84:	ed9f 0a28 	vldr	s0, [pc, #160]	; 27d28 <tADSR4_tickNoInterp+0x17c>
                adsr->whichStage = env_idle;
   27c88:	629a      	str	r2, [r3, #40]	; 0x28
            else {
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
            }

            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
   27c8a:	edd3 7a08 	vldr	s15, [r3, #32]
   27c8e:	ed83 0a05 	vstr	s0, [r3, #20]
   27c92:	ee77 7aa6 	vadd.f32	s15, s15, s13
   27c96:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
            break;
    }
    return adsr->next;
}
   27c9a:	4770      	bx	lr
   27c9c:	ed93 0a05 	vldr	s0, [r3, #20]
   27ca0:	4770      	bx	lr
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
   27ca2:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   27ca6:	685a      	ldr	r2, [r3, #4]
   27ca8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27cac:	ee17 1a10 	vmov	r1, s14
   27cb0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27cb4:	ed92 7a00 	vldr	s14, [r2]
   27cb8:	ee77 7ac7 	vsub.f32	s15, s15, s14
   27cbc:	ee20 0a27 	vmul.f32	s0, s0, s15
   27cc0:	e7a6      	b.n	27c10 <tADSR4_tickNoInterp+0x64>
                adsr->next = (adsr->gain * (adsr->sustain + (adsr->exp_buff[(uint32_t)adsr->decayPhase] * (1.0f - adsr->sustain)))) * adsr->leakFactor;
   27cc2:	eefc 5ae6 	vcvt.u32.f32	s11, s13
   27cc6:	685a      	ldr	r2, [r3, #4]
   27cc8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   27ccc:	ed93 6a13 	vldr	s12, [r3, #76]	; 0x4c
   27cd0:	ee15 1a90 	vmov	r1, s11
   27cd4:	ee67 7a86 	vmul.f32	s15, s15, s12
   27cd8:	ee37 7a40 	vsub.f32	s14, s14, s0
   27cdc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27ce0:	ed92 6a00 	vldr	s12, [r2]
   27ce4:	eea6 0a07 	vfma.f32	s0, s12, s14
   27ce8:	ee20 0a27 	vmul.f32	s0, s0, s15
   27cec:	e7b5      	b.n	27c5a <tADSR4_tickNoInterp+0xae>
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
   27cee:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   27cf2:	685a      	ldr	r2, [r3, #4]
   27cf4:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
   27cf8:	ee17 1a10 	vmov	r1, s14
   27cfc:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27d00:	ed92 0a00 	vldr	s0, [r2]
   27d04:	ee20 0a27 	vmul.f32	s0, s0, s15
   27d08:	e76a      	b.n	27be0 <tADSR4_tickNoInterp+0x34>
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
   27d0a:	eebc 7ae6 	vcvt.u32.f32	s14, s13
   27d0e:	685a      	ldr	r2, [r3, #4]
   27d10:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
   27d14:	ee17 1a10 	vmov	r1, s14
   27d18:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   27d1c:	ed92 0a00 	vldr	s0, [r2]
   27d20:	ee20 0a27 	vmul.f32	s0, s0, s15
   27d24:	e7b1      	b.n	27c8a <tADSR4_tickNoInterp+0xde>
   27d26:	bf00      	nop
   27d28:	00000000 	.word	0x00000000

00027d2c <tRamp_init>:


/////-----------------
/* Ramp */
void    tRamp_init(tRamp* const r, float time, int samples_per_tick)
{
   27d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tRamp_initToPool(r, time, samples_per_tick, &leaf.mempool);
}

void    tRamp_initToPool    (tRamp* const r, float time, int samples_per_tick, tMempool* const mp)
{
    _tMempool* m = *mp;
   27d2e:	4d17      	ldr	r5, [pc, #92]	; (27d8c <tRamp_init+0x60>)
{
   27d30:	4607      	mov	r7, r0
   27d32:	460c      	mov	r4, r1
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27d34:	2024      	movs	r0, #36	; 0x24
    _tMempool* m = *mp;
   27d36:	69ae      	ldr	r6, [r5, #24]
{
   27d38:	ed2d 8b02 	vpush	{d8}
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27d3c:	4631      	mov	r1, r6
{
   27d3e:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27d42:	f001 ffa1 	bl	29c88 <mpool_alloc>
    ramp->mempool = m;
    
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27d46:	ed9f 6a12 	vldr	s12, [pc, #72]	; 27d90 <tRamp_init+0x64>
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27d4a:	6038      	str	r0, [r7, #0]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27d4c:	ee07 4a90 	vmov	s15, r4
    ramp->mempool = m;
   27d50:	6006      	str	r6, [r0, #0]
    ramp->curr = 0.0f;
   27d52:	2300      	movs	r3, #0
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27d54:	edd5 6a00 	vldr	s13, [r5]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27d58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    }
    else
    {
        ramp->time = time;
    }
    ramp->samples_per_tick = samples_per_tick;
   27d5c:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27d5e:	ee86 7a26 	vdiv.f32	s14, s12, s13
    ramp->curr = 0.0f;
   27d62:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
   27d64:	6143      	str	r3, [r0, #20]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
   27d66:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27d68:	ee67 7a87 	vmul.f32	s15, s15, s14
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27d6c:	ed80 7a02 	vstr	s14, [r0, #8]
   27d70:	fe88 0a27 	vmaxnm.f32	s0, s16, s15
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27d74:	ee87 7a80 	vdiv.f32	s14, s15, s0
   27d78:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27d7c:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27d80:	ed80 7a07 	vstr	s14, [r0, #28]
}
   27d84:	ecbd 8b02 	vpop	{d8}
   27d88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   27d8a:	bf00      	nop
   27d8c:	020fc0a8 	.word	0x020fc0a8
   27d90:	4479ffff 	.word	0x4479ffff

00027d94 <tRamp_initToPool>:
{
   27d94:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   27d96:	6815      	ldr	r5, [r2, #0]
{
   27d98:	460c      	mov	r4, r1
   27d9a:	4606      	mov	r6, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27d9c:	2024      	movs	r0, #36	; 0x24
   27d9e:	4629      	mov	r1, r5
{
   27da0:	ed2d 8b02 	vpush	{d8}
   27da4:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27da8:	f001 ff6e 	bl	29c88 <mpool_alloc>
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27dac:	4b11      	ldr	r3, [pc, #68]	; (27df4 <tRamp_initToPool+0x60>)
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27dae:	ee07 4a90 	vmov	s15, r4
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
   27db2:	6030      	str	r0, [r6, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27db4:	ed9f 6a10 	vldr	s12, [pc, #64]	; 27df8 <tRamp_initToPool+0x64>
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27db8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->mempool = m;
   27dbc:	6005      	str	r5, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27dbe:	edd3 6a00 	vldr	s13, [r3]
    ramp->curr = 0.0f;
   27dc2:	2300      	movs	r3, #0
    ramp->samples_per_tick = samples_per_tick;
   27dc4:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27dc6:	ee86 7a26 	vdiv.f32	s14, s12, s13
    ramp->curr = 0.0f;
   27dca:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
   27dcc:	6143      	str	r3, [r0, #20]
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
   27dce:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27dd0:	ee67 7a87 	vmul.f32	s15, s15, s14
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
   27dd4:	ed80 7a02 	vstr	s14, [r0, #8]
   27dd8:	fe87 0a88 	vmaxnm.f32	s0, s15, s16
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27ddc:	ee87 7a80 	vdiv.f32	s14, s15, s0
   27de0:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
   27de4:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
   27de8:	ed80 7a07 	vstr	s14, [r0, #28]
}
   27dec:	ecbd 8b02 	vpop	{d8}
   27df0:	bd70      	pop	{r4, r5, r6, pc}
   27df2:	bf00      	nop
   27df4:	020fc0a8 	.word	0x020fc0a8
   27df8:	4479ffff 	.word	0x4479ffff

00027dfc <tRamp_free>:

void    tRamp_free (tRamp* const r)
{
    _tRamp* ramp = *r;
   27dfc:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)ramp, ramp->mempool);
   27dfe:	6801      	ldr	r1, [r0, #0]
   27e00:	f001 bfea 	b.w	29dd8 <mpool_free>

00027e04 <tRamp_setDest>:

}

void     tRamp_setDest(tRamp* const ramp, float dest)
{
    _tRamp* r = *ramp;
   27e04:	6803      	ldr	r3, [r0, #0]
    r->dest = dest;
    r->inc = (r->dest - r->curr) * r->factor;
   27e06:	edd3 7a04 	vldr	s15, [r3, #16]
   27e0a:	ed93 7a07 	vldr	s14, [r3, #28]
   27e0e:	ee70 7a67 	vsub.f32	s15, s0, s15
    r->dest = dest;
   27e12:	ed83 0a05 	vstr	s0, [r3, #20]
    r->inc = (r->dest - r->curr) * r->factor;
   27e16:	ee67 7a87 	vmul.f32	s15, s15, s14
   27e1a:	edc3 7a01 	vstr	s15, [r3, #4]
}
   27e1e:	4770      	bx	lr

00027e20 <tRamp_setVal>:

void     tRamp_setVal(tRamp* const ramp, float val)
{
    _tRamp* r = *ramp;
   27e20:	6803      	ldr	r3, [r0, #0]
    r->curr = val;
    r->inc = (r->dest - r->curr) * r->factor;
   27e22:	edd3 7a05 	vldr	s15, [r3, #20]
   27e26:	ed93 7a07 	vldr	s14, [r3, #28]
   27e2a:	ee77 7ac0 	vsub.f32	s15, s15, s0
    r->curr = val;
   27e2e:	ed83 0a04 	vstr	s0, [r3, #16]
    r->inc = (r->dest - r->curr) * r->factor;
   27e32:	ee67 7a87 	vmul.f32	s15, s15, s14
   27e36:	edc3 7a01 	vstr	s15, [r3, #4]
}
   27e3a:	4770      	bx	lr

00027e3c <tRamp_tick>:

float   tRamp_tick(tRamp* const ramp)
{
    _tRamp* r = *ramp;
   27e3c:	6803      	ldr	r3, [r0, #0]
    
    r->curr += r->inc;
   27e3e:	edd3 7a01 	vldr	s15, [r3, #4]
   27e42:	ed93 0a04 	vldr	s0, [r3, #16]
    
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   27e46:	eef5 7a40 	vcmp.f32	s15, #0.0
   27e4a:	ed93 7a05 	vldr	s14, [r3, #20]
    r->curr += r->inc;
   27e4e:	ee37 0a80 	vadd.f32	s0, s15, s0
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   27e52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    r->curr += r->inc;
   27e56:	ed83 0a04 	vstr	s0, [r3, #16]
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
   27e5a:	dd04      	ble.n	27e66 <tRamp_tick+0x2a>
   27e5c:	eeb4 0ac7 	vcmpe.f32	s0, s14
   27e60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27e64:	da0a      	bge.n	27e7c <tRamp_tick+0x40>
   27e66:	eef5 7a40 	vcmp.f32	s15, #0.0
   27e6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27e6e:	d504      	bpl.n	27e7a <tRamp_tick+0x3e>
   27e70:	eeb4 0a47 	vcmp.f32	s0, s14
   27e74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   27e78:	d900      	bls.n	27e7c <tRamp_tick+0x40>
		r->inc = 0.0f;
		r->curr=r->dest;
	}
    
    return r->curr;
}
   27e7a:	4770      	bx	lr
		r->inc = 0.0f;
   27e7c:	2200      	movs	r2, #0
		r->curr=r->dest;
   27e7e:	eeb0 0a47 	vmov.f32	s0, s14
   27e82:	ed83 7a04 	vstr	s14, [r3, #16]
		r->inc = 0.0f;
   27e86:	605a      	str	r2, [r3, #4]
}
   27e88:	4770      	bx	lr
   27e8a:	bf00      	nop

00027e8c <tRamp_sample>:

float   tRamp_sample(tRamp* const ramp)
{
    _tRamp* r = *ramp;
    return r->curr;
   27e8c:	6803      	ldr	r3, [r0, #0]
}
   27e8e:	ed93 0a04 	vldr	s0, [r3, #16]
   27e92:	4770      	bx	lr

00027e94 <tExpSmooth_init>:



/* Exponential Smoother */
void    tExpSmooth_init(tExpSmooth* const expsmooth, float val, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27e94:	b538      	push	{r3, r4, r5, lr}
    tExpSmooth_initToPool(expsmooth, val, factor, &leaf.mempool);
}

void    tExpSmooth_initToPool   (tExpSmooth* const expsmooth, float val, float factor, tMempool* const mp)
{
    _tMempool* m = *mp;
   27e96:	4b12      	ldr	r3, [pc, #72]	; (27ee0 <tExpSmooth_init+0x4c>)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27e98:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27e9a:	2014      	movs	r0, #20
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27e9c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27ea0:	699c      	ldr	r4, [r3, #24]
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27ea2:	eef0 8a40 	vmov.f32	s17, s0
   27ea6:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27eaa:	4621      	mov	r1, r4
   27eac:	f001 feec 	bl	29c88 <mpool_alloc>
   27eb0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27eb4:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 27ee4 <tExpSmooth_init+0x50>
   27eb8:	6028      	str	r0, [r5, #0]
   27eba:	fec8 0a67 	vminnm.f32	s1, s16, s15
   27ebe:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->curr=val;
    smooth->dest=val;
    if (factor<0) factor=0;
    if (factor>1) factor=1;
    smooth->factor=factor;
    smooth->oneminusfactor=1.0f-factor;
   27ec2:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->mempool = m;
   27ec6:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
   27ec8:	edc0 8a03 	vstr	s17, [r0, #12]
    smooth->dest=val;
   27ecc:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
   27ed0:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
   27ed4:	edc0 7a02 	vstr	s15, [r0, #8]
}
   27ed8:	ecbd 8b02 	vpop	{d8}
   27edc:	bd38      	pop	{r3, r4, r5, pc}
   27ede:	bf00      	nop
   27ee0:	020fc0a8 	.word	0x020fc0a8
   27ee4:	00000000 	.word	0x00000000

00027ee8 <tExpSmooth_initToPool>:
{
   27ee8:	b538      	push	{r3, r4, r5, lr}
   27eea:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27eee:	680c      	ldr	r4, [r1, #0]
{
   27ef0:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27ef2:	2014      	movs	r0, #20
{
   27ef4:	eef0 8a40 	vmov.f32	s17, s0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27ef8:	4621      	mov	r1, r4
{
   27efa:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
   27efe:	f001 fec3 	bl	29c88 <mpool_alloc>
   27f02:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27f06:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 27f30 <tExpSmooth_initToPool+0x48>
   27f0a:	6028      	str	r0, [r5, #0]
   27f0c:	fec8 0a67 	vminnm.f32	s1, s16, s15
   27f10:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->oneminusfactor=1.0f-factor;
   27f14:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->mempool = m;
   27f18:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
   27f1a:	edc0 8a03 	vstr	s17, [r0, #12]
    smooth->dest=val;
   27f1e:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
   27f22:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
   27f26:	edc0 7a02 	vstr	s15, [r0, #8]
}
   27f2a:	ecbd 8b02 	vpop	{d8}
   27f2e:	bd38      	pop	{r3, r4, r5, pc}
   27f30:	00000000 	.word	0x00000000

00027f34 <tExpSmooth_free>:

void    tExpSmooth_free (tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
   27f34:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)smooth, smooth->mempool);
   27f36:	6801      	ldr	r1, [r0, #0]
   27f38:	f001 bf4e 	b.w	29dd8 <mpool_free>

00027f3c <tExpSmooth_setFactor>:
}

void     tExpSmooth_setFactor(tExpSmooth* const expsmooth, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
   27f3c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   27f40:	ed9f 7a06 	vldr	s14, [pc, #24]	; 27f5c <tExpSmooth_setFactor+0x20>
    _tExpSmooth* smooth = *expsmooth;
   27f44:	6803      	ldr	r3, [r0, #0]
   27f46:	fe80 0a67 	vminnm.f32	s0, s0, s15
   27f4a:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
	if (factor<0)
		factor=0;
	else
		if (factor>1) factor=1;
	smooth->factor=factor;
	smooth->oneminusfactor=1.0f-factor;
   27f4e:	ee77 7ac0 	vsub.f32	s15, s15, s0
	smooth->factor=factor;
   27f52:	ed83 0a01 	vstr	s0, [r3, #4]
	smooth->oneminusfactor=1.0f-factor;
   27f56:	edc3 7a02 	vstr	s15, [r3, #8]
}
   27f5a:	4770      	bx	lr
   27f5c:	00000000 	.word	0x00000000

00027f60 <tExpSmooth_setDest>:

void     tExpSmooth_setDest(tExpSmooth* const expsmooth, float dest)
{
    _tExpSmooth* smooth = *expsmooth;
   27f60:	6803      	ldr	r3, [r0, #0]
	smooth->dest=dest;
   27f62:	ed83 0a04 	vstr	s0, [r3, #16]
}
   27f66:	4770      	bx	lr

00027f68 <tExpSmooth_setValAndDest>:
	smooth->curr=val;
}

void     tExpSmooth_setValAndDest(tExpSmooth* const expsmooth, float val)
{
    _tExpSmooth* smooth = *expsmooth;
   27f68:	6803      	ldr	r3, [r0, #0]
	smooth->curr=val;
   27f6a:	ed83 0a03 	vstr	s0, [r3, #12]
	smooth->dest=val;
   27f6e:	ed83 0a04 	vstr	s0, [r3, #16]
}
   27f72:	4770      	bx	lr

00027f74 <tExpSmooth_tick>:

float   tExpSmooth_tick(tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
   27f74:	6803      	ldr	r3, [r0, #0]
    smooth->curr = smooth->factor*smooth->dest+smooth->oneminusfactor*smooth->curr;
   27f76:	edd3 7a03 	vldr	s15, [r3, #12]
   27f7a:	ed93 0a02 	vldr	s0, [r3, #8]
   27f7e:	ed93 7a01 	vldr	s14, [r3, #4]
   27f82:	ee20 0a27 	vmul.f32	s0, s0, s15
   27f86:	edd3 7a04 	vldr	s15, [r3, #16]
   27f8a:	eea7 0a27 	vfma.f32	s0, s14, s15
   27f8e:	ed83 0a03 	vstr	s0, [r3, #12]
    return smooth->curr;
}
   27f92:	4770      	bx	lr

00027f94 <tSlide_initToPool>:
{
	tSlide_initToPool    (sl, upSlide, downSlide, &leaf.mempool);
}

void    tSlide_initToPool    (tSlide* const sl, float upSlide, float downSlide, tMempool* const mp)
{
   27f94:	b538      	push	{r3, r4, r5, lr}
   27f96:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   27f9a:	680c      	ldr	r4, [r1, #0]
{
   27f9c:	4605      	mov	r5, r0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27f9e:	201c      	movs	r0, #28
{
   27fa0:	eeb0 8a60 	vmov.f32	s16, s1
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27fa4:	4621      	mov	r1, r4
{
   27fa6:	eef0 8a40 	vmov.f32	s17, s0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27faa:	f001 fe6d 	bl	29c88 <mpool_alloc>

    if (downSlide < 1.0f)
    {
    	downSlide = 1.0f;
    }
    s->invUpSlide = 1.0f / upSlide;
   27fae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    s->prevIn = 0.0f;
   27fb2:	2300      	movs	r3, #0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
   27fb4:	6028      	str	r0, [r5, #0]
    s->mempool = m;
   27fb6:	6004      	str	r4, [r0, #0]
    s->invUpSlide = 1.0f / upSlide;
   27fb8:	fec8 8aa7 	vmaxnm.f32	s17, s17, s15
    s->invDownSlide = 1.0f / downSlide;
   27fbc:	fec8 0a27 	vmaxnm.f32	s1, s16, s15
    s->invUpSlide = 1.0f / upSlide;
   27fc0:	eec7 6aa8 	vdiv.f32	s13, s15, s17
    s->prevIn = 0.0f;
   27fc4:	60c3      	str	r3, [r0, #12]
    s->currentOut = 0.0f;
   27fc6:	6083      	str	r3, [r0, #8]
    s->prevOut = 0.0f;
   27fc8:	6043      	str	r3, [r0, #4]
    s->dest = 0.0f;
   27fca:	6183      	str	r3, [r0, #24]
    s->invDownSlide = 1.0f / downSlide;
   27fcc:	ee87 7aa0 	vdiv.f32	s14, s15, s1
    s->invUpSlide = 1.0f / upSlide;
   27fd0:	edc0 6a04 	vstr	s13, [r0, #16]
    s->invDownSlide = 1.0f / downSlide;
   27fd4:	ed80 7a05 	vstr	s14, [r0, #20]
}
   27fd8:	ecbd 8b02 	vpop	{d8}
   27fdc:	bd38      	pop	{r3, r4, r5, pc}
   27fde:	bf00      	nop

00027fe0 <tSlide_free>:

void    tSlide_free  (tSlide* const sl)
{
    _tSlide* s = *sl;
   27fe0:	6800      	ldr	r0, [r0, #0]

    mpool_free((char*)s, s->mempool);
   27fe2:	6801      	ldr	r1, [r0, #0]
   27fe4:	f001 bef8 	b.w	29dd8 <mpool_free>

00027fe8 <tSlide_setDownSlide>:
}

void tSlide_setDownSlide(tSlide* const sl, float downSlide)
{
	_tSlide* s = *sl;
	s->invDownSlide = 1.0f / downSlide;
   27fe8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	_tSlide* s = *sl;
   27fec:	6803      	ldr	r3, [r0, #0]
	s->invDownSlide = 1.0f / downSlide;
   27fee:	ee87 0a80 	vdiv.f32	s0, s15, s0
   27ff2:	ed83 0a05 	vstr	s0, [r3, #20]
}
   27ff6:	4770      	bx	lr

00027ff8 <tSlide_setDest>:

void tSlide_setDest(tSlide* const sl, float dest)
{
	_tSlide* s = *sl;
   27ff8:	6803      	ldr	r3, [r0, #0]
	s->dest = dest;
   27ffa:	ed83 0a06 	vstr	s0, [r3, #24]
}
   27ffe:	4770      	bx	lr

00028000 <tSlide_tickNoInput>:

float tSlide_tickNoInput(tSlide* const sl)
{
	_tSlide* s = *sl;
   28000:	6803      	ldr	r3, [r0, #0]
	float in = s->dest;

	if (in >= s->prevOut)
   28002:	edd3 7a01 	vldr	s15, [r3, #4]
	float in = s->dest;
   28006:	ed93 7a06 	vldr	s14, [r3, #24]
	if (in >= s->prevOut)
   2800a:	eef4 7ac7 	vcmpe.f32	s15, s14
   2800e:	ee77 6a67 	vsub.f32	s13, s14, s15
   28012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	{
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invUpSlide);
   28016:	bf94      	ite	ls
   28018:	ed93 6a04 	vldrls	s12, [r3, #16]
	}
	else
	{
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
   2801c:	ed93 6a05 	vldrhi	s12, [r3, #20]
   28020:	eee6 7a26 	vfma.f32	s15, s12, s13
	}
#ifdef NO_DENORMAL_CHECK
#else
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   28024:	eddf 6a0e 	vldr	s13, [pc, #56]	; 28060 <tSlide_tickNoInput+0x60>
   28028:	eef4 7ae6 	vcmpe.f32	s15, s13
   2802c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   28030:	d50c      	bpl.n	2804c <tSlide_tickNoInput+0x4c>
   28032:	eddf 6a0c 	vldr	s13, [pc, #48]	; 28064 <tSlide_tickNoInput+0x64>
#endif
	s->prevIn = in;
   28036:	ed83 7a03 	vstr	s14, [r3, #12]
	if (s->currentOut < VSF) s->currentOut = 0.0f;
   2803a:	eef0 7a66 	vmov.f32	s15, s13
   2803e:	edc3 6a02 	vstr	s13, [r3, #8]
	s->prevOut = s->currentOut;
	return s->currentOut;
}
   28042:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevOut = s->currentOut;
   28046:	edc3 7a01 	vstr	s15, [r3, #4]
}
   2804a:	4770      	bx	lr
   2804c:	edc3 7a02 	vstr	s15, [r3, #8]
   28050:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevIn = in;
   28054:	ed83 7a03 	vstr	s14, [r3, #12]
	s->prevOut = s->currentOut;
   28058:	edc3 7a01 	vstr	s15, [r3, #4]
}
   2805c:	4770      	bx	lr
   2805e:	bf00      	nop
   28060:	006ce3ee 	.word	0x006ce3ee
   28064:	00000000 	.word	0x00000000

00028068 <tAllpass_initToPool>:
{
    tAllpass_initToPool(ft, initDelay, maxDelay, &leaf.mempool);
}

void    tAllpass_initToPool     (tAllpass* const ft, float initDelay, uint32_t maxDelay, tMempool* const mp)
{
   28068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2806c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   28070:	6814      	ldr	r4, [r2, #0]
{
   28072:	4615      	mov	r5, r2
   28074:	4607      	mov	r7, r0
   28076:	4688      	mov	r8, r1
   28078:	eeb0 8a40 	vmov.f32	s16, s0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   2807c:	4621      	mov	r1, r4
   2807e:	2010      	movs	r0, #16
    f->mempool = m;
    
    f->gain = 0.7f;
   28080:	4e09      	ldr	r6, [pc, #36]	; (280a8 <tAllpass_initToPool+0x40>)
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   28082:	f001 fe01 	bl	29c88 <mpool_alloc>
    
    f->lastOut = 0.0f;
    
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   28086:	462a      	mov	r2, r5
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   28088:	4603      	mov	r3, r0
    f->lastOut = 0.0f;
   2808a:	2500      	movs	r5, #0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
   2808c:	6038      	str	r0, [r7, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   2808e:	eeb0 0a48 	vmov.f32	s0, s16
    f->mempool = m;
   28092:	6004      	str	r4, [r0, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   28094:	4641      	mov	r1, r8
    f->gain = 0.7f;
   28096:	605e      	str	r6, [r3, #4]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   28098:	3008      	adds	r0, #8
    f->lastOut = 0.0f;
   2809a:	60dd      	str	r5, [r3, #12]
}
   2809c:	ecbd 8b02 	vpop	{d8}
   280a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
   280a4:	f7fc beb4 	b.w	24e10 <tLinearDelay_initToPool>
   280a8:	3f333333 	.word	0x3f333333

000280ac <tAllpass_free>:

void    tAllpass_free  (tAllpass* const ft)
{
   280ac:	b510      	push	{r4, lr}
    _tAllpass* f = *ft;
   280ae:	6804      	ldr	r4, [r0, #0]
    
    tLinearDelay_free(&f->delay);
   280b0:	f104 0008 	add.w	r0, r4, #8
   280b4:	f7fc ff22 	bl	24efc <tLinearDelay_free>
    mpool_free((char*)f, f->mempool);
   280b8:	6821      	ldr	r1, [r4, #0]
   280ba:	4620      	mov	r0, r4
}
   280bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)f, f->mempool);
   280c0:	f001 be8a 	b.w	29dd8 <mpool_free>

000280c4 <tAllpass_setDelay>:

void    tAllpass_setDelay(tAllpass* const ft, float delay)
{
    _tAllpass* f = *ft;
    
    tLinearDelay_setDelay(&f->delay, delay);
   280c4:	6800      	ldr	r0, [r0, #0]
   280c6:	3008      	adds	r0, #8
   280c8:	f7fc bfaa 	b.w	25020 <tLinearDelay_setDelay>

000280cc <tAllpass_setGain>:
}

void    tAllpass_setGain(tAllpass* const ft, float gain)
{
    _tAllpass* f = *ft;
   280cc:	6803      	ldr	r3, [r0, #0]
    
    f->gain = gain;
   280ce:	ed83 0a01 	vstr	s0, [r3, #4]
}
   280d2:	4770      	bx	lr

000280d4 <tAllpass_tick>:

float   tAllpass_tick(tAllpass* const ft, float input)
{
   280d4:	b510      	push	{r4, lr}
   280d6:	ed2d 8b02 	vpush	{d8}
    _tAllpass* f = *ft;
   280da:	6804      	ldr	r4, [r0, #0]
{
   280dc:	eeb0 8a40 	vmov.f32	s16, s0
    
    float s1 = (-f->gain) * f->lastOut + input;
    
    float s2 = tLinearDelay_tick(&f->delay, s1) + (f->gain) * input;
   280e0:	edd4 7a03 	vldr	s15, [r4, #12]
   280e4:	f104 0008 	add.w	r0, r4, #8
   280e8:	ed94 7a01 	vldr	s14, [r4, #4]
   280ec:	eea7 0a67 	vfms.f32	s0, s14, s15
   280f0:	f7fc ff1e 	bl	24f30 <tLinearDelay_tick>
   280f4:	edd4 7a01 	vldr	s15, [r4, #4]
   280f8:	eea7 0a88 	vfma.f32	s0, s15, s16
    
    f->lastOut = s2;
   280fc:	ed84 0a03 	vstr	s0, [r4, #12]
    
    return f->lastOut;
}
   28100:	ecbd 8b02 	vpop	{d8}
   28104:	bd10      	pop	{r4, pc}
   28106:	bf00      	nop

00028108 <tOnePole_initToPool>:
{
    tOnePole_initToPool(ft, freq, &leaf.mempool);
}

void    tOnePole_initToPool     (tOnePole* const ft, float freq, tMempool* const mp)
{
   28108:	b570      	push	{r4, r5, r6, lr}
   2810a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2810e:	680e      	ldr	r6, [r1, #0]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
    f->mempool = m;
    
    f->gain = 1.0f;
   28110:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
{
   28114:	4605      	mov	r5, r0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   28116:	2020      	movs	r0, #32
   28118:	4631      	mov	r1, r6
{
   2811a:	eef0 8a40 	vmov.f32	s17, s0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2811e:	f001 fdb3 	bl	29c88 <mpool_alloc>
}

void        tOnePole_setFreq        (tOnePole* const ft, float freq)
{
    _tOnePole* f = *ft;
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28122:	4b12      	ldr	r3, [pc, #72]	; (2816c <tOnePole_initToPool+0x64>)
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   28124:	6028      	str	r0, [r5, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   28126:	eeb0 1a48 	vmov.f32	s2, s16
    f->gain = 1.0f;
   2812a:	ed80 8a01 	vstr	s16, [r0, #4]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
   2812e:	4604      	mov	r4, r0
    f->a0 = 1.0;
   28130:	ed80 8a02 	vstr	s16, [r0, #8]
    f->mempool = m;
   28134:	6006      	str	r6, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28136:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
   2813a:	682d      	ldr	r5, [r5, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2813c:	ee68 0aa0 	vmul.f32	s1, s17, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   28140:	eddf 8a0b 	vldr	s17, [pc, #44]	; 28170 <tOnePole_initToPool+0x68>
   28144:	eeb0 0a68 	vmov.f32	s0, s17
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28148:	edc5 0a04 	vstr	s1, [r5, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2814c:	f001 fb9c 	bl	29888 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
   28150:	ee38 8a40 	vsub.f32	s16, s16, s0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   28154:	ed85 0a04 	vstr	s0, [r5, #16]
    f->a1 = 1.0f - f->b0;
   28158:	ed85 8a03 	vstr	s16, [r5, #12]
    f->lastIn = 0.0f;
   2815c:	edc4 8a06 	vstr	s17, [r4, #24]
    f->lastOut = 0.0f;
   28160:	edc4 8a07 	vstr	s17, [r4, #28]
}
   28164:	ecbd 8b02 	vpop	{d8}
   28168:	bd70      	pop	{r4, r5, r6, pc}
   2816a:	bf00      	nop
   2816c:	020fc0a8 	.word	0x020fc0a8
   28170:	00000000 	.word	0x00000000

00028174 <tOnePole_free>:
    _tOnePole* f = *ft;
   28174:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
   28176:	6801      	ldr	r1, [r0, #0]
   28178:	f001 be2e 	b.w	29dd8 <mpool_free>

0002817c <tOnePole_setFreq>:
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2817c:	4b0b      	ldr	r3, [pc, #44]	; (281ac <tOnePole_setFreq+0x30>)
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2817e:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
{
   28182:	b510      	push	{r4, lr}
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28184:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
   28188:	6804      	ldr	r4, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   2818a:	ee60 0a20 	vmul.f32	s1, s0, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2818e:	ed9f 0a08 	vldr	s0, [pc, #32]	; 281b0 <tOnePole_setFreq+0x34>
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
   28192:	edc4 0a04 	vstr	s1, [r4, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   28196:	f001 fb77 	bl	29888 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
   2819a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
   2819e:	ed84 0a04 	vstr	s0, [r4, #16]
    f->a1 = 1.0f - f->b0;
   281a2:	ee37 0ac0 	vsub.f32	s0, s15, s0
   281a6:	ed84 0a03 	vstr	s0, [r4, #12]
}
   281aa:	bd10      	pop	{r4, pc}
   281ac:	020fc0a8 	.word	0x020fc0a8
   281b0:	00000000 	.word	0x00000000

000281b4 <tOnePole_tick>:
    f->gain = gain;
}

float   tOnePole_tick(tOnePole* const ft, float input)
{
    _tOnePole* f = *ft;
   281b4:	6803      	ldr	r3, [r0, #0]
    
    float in = input * f->gain;
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   281b6:	ed93 6a07 	vldr	s12, [r3, #28]
    float in = input * f->gain;
   281ba:	ed93 7a01 	vldr	s14, [r3, #4]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   281be:	edd3 7a03 	vldr	s15, [r3, #12]
    float in = input * f->gain;
   281c2:	ee20 7a07 	vmul.f32	s14, s0, s14
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   281c6:	edd3 6a04 	vldr	s13, [r3, #16]
   281ca:	ee27 0a86 	vmul.f32	s0, s15, s12
    
    f->lastIn = in;
   281ce:	ed83 7a06 	vstr	s14, [r3, #24]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
   281d2:	eea6 0a87 	vfma.f32	s0, s13, s14
    f->lastOut = out;
   281d6:	ed83 0a07 	vstr	s0, [r3, #28]
    
    return out;
}
   281da:	4770      	bx	lr

000281dc <tSVF_init>:
}

// Less efficient, more accurate version of SVF, in which cutoff frequency is taken as floating point Hz value and tanf
// is calculated when frequency changes.
void tSVF_init(tSVF* const svff, SVFType type, float freq, float Q)
{
   281dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

}

void    tSVF_initToPool     (tSVF* const svff, SVFType type, float freq, float Q, tMempool* const mp)
{
    _tMempool* m = *mp;
   281e0:	4f38      	ldr	r7, [pc, #224]	; (282c4 <tSVF_init+0xe8>)
{
   281e2:	460e      	mov	r6, r1
   281e4:	4681      	mov	r9, r0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   281e6:	203c      	movs	r0, #60	; 0x3c
    svf->mempool = m;

    svf->type = type;

    svf->ic1eq = 0;
   281e8:	2500      	movs	r5, #0
{
   281ea:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   281ee:	f8d7 8018 	ldr.w	r8, [r7, #24]
{
   281f2:	eef0 8a40 	vmov.f32	s17, s0
   281f6:	eeb0 8a60 	vmov.f32	s16, s1
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   281fa:	4641      	mov	r1, r8
   281fc:	f001 fd44 	bl	29c88 <mpool_alloc>
   28200:	f8c9 0000 	str.w	r0, [r9]
    svf->mempool = m;
   28204:	f8c0 8000 	str.w	r8, [r0]
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
   28208:	4604      	mov	r4, r0
    svf->type = type;
   2820a:	7106      	strb	r6, [r0, #4]
    svf->ic2eq = 0;
    svf->Q = Q;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2820c:	edd7 7a01 	vldr	s15, [r7, #4]
   28210:	ed9f 0a2d 	vldr	s0, [pc, #180]	; 282c8 <tSVF_init+0xec>
    svf->Q = Q;
   28214:	ed80 8a03 	vstr	s16, [r0, #12]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   28218:	ee27 0a80 	vmul.f32	s0, s15, s0
    svf->cutoff = freq;
   2821c:	edc0 8a02 	vstr	s17, [r0, #8]
    svf->ic1eq = 0;
   28220:	6105      	str	r5, [r0, #16]
    svf->ic2eq = 0;
   28222:	6145      	str	r5, [r0, #20]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   28224:	ee20 0a28 	vmul.f32	s0, s0, s17
   28228:	f005 f820 	bl	2d26c <tanf>
    svf->k = 1.0f/Q;
   2822c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   28230:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a3 = svf->g*svf->a2;
    svf->cH = 0.0f;
    svf->cB = 0.0f;
    svf->cL = 1.0f;

    if (type == SVFTypeLowpass)
   28234:	2e01      	cmp	r6, #1
    svf->cH = 0.0f;
   28236:	62e5      	str	r5, [r4, #44]	; 0x2c
    svf->k = 1.0f/Q;
   28238:	ee87 7a88 	vdiv.f32	s14, s15, s16
    svf->cB = 0.0f;
   2823c:	6325      	str	r5, [r4, #48]	; 0x30
    svf->cL = 1.0f;
   2823e:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28242:	ee70 6a07 	vadd.f32	s13, s0, s14
    svf->k = 1.0f/Q;
   28246:	ed84 7a07 	vstr	s14, [r4, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2824a:	eeb0 7a67 	vmov.f32	s14, s15
   2824e:	eea0 7a26 	vfma.f32	s14, s0, s13
   28252:	eec7 6a87 	vdiv.f32	s13, s15, s14
    svf->a2 = svf->g*svf->a1;
   28256:	ee20 7a26 	vmul.f32	s14, s0, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2825a:	edc4 6a08 	vstr	s13, [r4, #32]
    svf->a3 = svf->g*svf->a2;
   2825e:	ee20 0a07 	vmul.f32	s0, s0, s14
    svf->a2 = svf->g*svf->a1;
   28262:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
   28266:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    if (type == SVFTypeLowpass)
   2826a:	d016      	beq.n	2829a <tSVF_init+0xbe>
        svf->cH = 0.0f;
        svf->cB = 0.0f;
        svf->cBK = 0.0f;
        svf->cL = 1.0f;
    }
    else if (type == SVFTypeBandpass)
   2826c:	2e02      	cmp	r6, #2
   2826e:	d00c      	beq.n	2828a <tSVF_init+0xae>
        svf->cB = 1.0f;
        svf->cBK = 0.0f;
        svf->cL = 0.0f;
    }

    else if (type == SVFTypeHighpass)
   28270:	b1c6      	cbz	r6, 282a4 <tSVF_init+0xc8>
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
        svf->cL = -1.0f;
    }

    else if (type == SVFTypeNotch)
   28272:	2e03      	cmp	r6, #3
   28274:	d01f      	beq.n	282b6 <tSVF_init+0xda>
        svf->cBK = -1.0f;
        svf->cL = 0.0f;
    }


    else if (type == SVFTypePeak)
   28276:	2e04      	cmp	r6, #4
   28278:	d10b      	bne.n	28292 <tSVF_init+0xb6>
    {
        svf->cH = 1.0f;
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
   2827a:	4a14      	ldr	r2, [pc, #80]	; (282cc <tSVF_init+0xf0>)
        svf->cL = -2.0f;
   2827c:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
        svf->cH = 1.0f;
   28280:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
   28284:	63a2      	str	r2, [r4, #56]	; 0x38
        svf->cL = -2.0f;
   28286:	6363      	str	r3, [r4, #52]	; 0x34
}
   28288:	e003      	b.n	28292 <tSVF_init+0xb6>
        svf->cB = 1.0f;
   2828a:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
        svf->cBK = 0.0f;
   2828e:	63a5      	str	r5, [r4, #56]	; 0x38
        svf->cL = 0.0f;
   28290:	6365      	str	r5, [r4, #52]	; 0x34
}
   28292:	ecbd 8b02 	vpop	{d8}
   28296:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = 0.0f;
   2829a:	63a5      	str	r5, [r4, #56]	; 0x38
}
   2829c:	ecbd 8b02 	vpop	{d8}
   282a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
   282a4:	4b09      	ldr	r3, [pc, #36]	; (282cc <tSVF_init+0xf0>)
        svf->cH = 1.0f;
   282a6:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
   282aa:	63a3      	str	r3, [r4, #56]	; 0x38
        svf->cL = -1.0f;
   282ac:	6363      	str	r3, [r4, #52]	; 0x34
}
   282ae:	ecbd 8b02 	vpop	{d8}
   282b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
   282b6:	4b05      	ldr	r3, [pc, #20]	; (282cc <tSVF_init+0xf0>)
        svf->cH = 1.0f;
   282b8:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cL = 0.0f;
   282bc:	6365      	str	r5, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
   282be:	63a3      	str	r3, [r4, #56]	; 0x38
   282c0:	e7e7      	b.n	28292 <tSVF_init+0xb6>
   282c2:	bf00      	nop
   282c4:	020fc0a8 	.word	0x020fc0a8
   282c8:	40490fdb 	.word	0x40490fdb
   282cc:	bf800000 	.word	0xbf800000

000282d0 <tSVF_free>:
    }
}

void    tSVF_free   (tSVF* const svff)
{
    _tSVF* svf = *svff;
   282d0:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
   282d2:	6801      	ldr	r1, [r0, #0]
   282d4:	f001 bd80 	b.w	29dd8 <mpool_free>

000282d8 <tSVF_tick>:
}

float   tSVF_tick(tSVF* const svff, float v0)
{
    _tSVF* svf = *svff;
   282d8:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   282da:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
   282de:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282e2:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   282e6:	eef0 5a66 	vmov.f32	s11, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282ea:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
   282ee:	ee30 4a66 	vsub.f32	s8, s0, s13
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   282f2:	edd3 2a0a 	vldr	s5, [r3, #40]	; 0x28
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   282f6:	edd3 3a0e 	vldr	s7, [r3, #56]	; 0x38
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   282fa:	eee6 5a27 	vfma.f32	s11, s12, s15
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   282fe:	ed93 3a08 	vldr	s6, [r3, #32]
   28302:	ee67 7a84 	vmul.f32	s15, s15, s8
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   28306:	ed93 2a07 	vldr	s4, [r3, #28]
   2830a:	ed93 5a0c 	vldr	s10, [r3, #48]	; 0x30
   2830e:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
   28312:	eea2 5a23 	vfma.f32	s10, s4, s7
   28316:	edd3 3a0b 	vldr	s7, [r3, #44]	; 0x2c
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2831a:	eee3 7a06 	vfma.f32	s15, s6, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2831e:	eee2 5a84 	vfma.f32	s11, s5, s8
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   28322:	ee97 6aa4 	vfnms.f32	s12, s15, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   28326:	ee25 7a87 	vmul.f32	s14, s11, s14
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   2832a:	eed5 6aa4 	vfnms.f32	s13, s11, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
   2832e:	eea7 7a85 	vfma.f32	s14, s15, s10
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   28332:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   28336:	edc3 6a05 	vstr	s13, [r3, #20]
}
   2833a:	eea3 7a80 	vfma.f32	s14, s7, s0
   2833e:	eeb0 0a47 	vmov.f32	s0, s14
   28342:	4770      	bx	lr

00028344 <tSVF_setFreq>:

void     tSVF_setFreq(tSVF* const svff, float freq)
{
    _tSVF* svf = *svff;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   28344:	4b14      	ldr	r3, [pc, #80]	; (28398 <tSVF_setFreq+0x54>)
   28346:	ed9f 7a15 	vldr	s14, [pc, #84]	; 2839c <tSVF_setFreq+0x58>
{
   2834a:	b510      	push	{r4, lr}
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2834c:	edd3 7a01 	vldr	s15, [r3, #4]
    _tSVF* svf = *svff;
   28350:	6804      	ldr	r4, [r0, #0]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   28352:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->cutoff = freq;
   28356:	ed84 0a02 	vstr	s0, [r4, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2835a:	ee27 0a80 	vmul.f32	s0, s15, s0
   2835e:	f004 ff85 	bl	2d26c <tanf>
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28362:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   28366:	edd4 7a07 	vldr	s15, [r4, #28]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
   2836a:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2836e:	ee70 7a27 	vadd.f32	s15, s0, s15
   28372:	eeb0 7a66 	vmov.f32	s14, s13
   28376:	eea0 7a27 	vfma.f32	s14, s0, s15
   2837a:	eef0 7a47 	vmov.f32	s15, s14
   2837e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    svf->a2 = svf->g * svf->a1;
   28382:	ee60 7a07 	vmul.f32	s15, s0, s14
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28386:	ed84 7a08 	vstr	s14, [r4, #32]
    svf->a3 = svf->g * svf->a2;
   2838a:	ee20 0a27 	vmul.f32	s0, s0, s15
    svf->a2 = svf->g * svf->a1;
   2838e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   28392:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
}
   28396:	bd10      	pop	{r4, pc}
   28398:	020fc0a8 	.word	0x020fc0a8
   2839c:	40490fdb 	.word	0x40490fdb

000283a0 <tEfficientSVF_initToPool>:
{
    tEfficientSVF_initToPool(svff, type, input, Q, &leaf.mempool);
}

void    tEfficientSVF_initToPool    (tEfficientSVF* const svff, SVFType type, uint16_t input, float Q, tMempool* const mp)
{
   283a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   283a2:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   283a6:	681c      	ldr	r4, [r3, #0]
{
   283a8:	4607      	mov	r7, r0
   283aa:	460d      	mov	r5, r1
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   283ac:	202c      	movs	r0, #44	; 0x2c
   283ae:	4621      	mov	r1, r4
{
   283b0:	4616      	mov	r6, r2
   283b2:	eeb0 8a40 	vmov.f32	s16, s0
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   283b6:	f001 fc67 	bl	29c88 <mpool_alloc>
    
    svf->ic1eq = 0;
    svf->ic2eq = 0;
    
    svf->g = __leaf_table_filtertan[input];
    svf->k = 1.0f/Q;
   283ba:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
   283be:	4a14      	ldr	r2, [pc, #80]	; (28410 <tEfficientSVF_initToPool+0x70>)
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
   283c0:	6038      	str	r0, [r7, #0]
    svf->ic1eq = 0;
   283c2:	2300      	movs	r3, #0
    svf->g = __leaf_table_filtertan[input];
   283c4:	eb02 0286 	add.w	r2, r2, r6, lsl #2
    svf->mempool = m;
   283c8:	6004      	str	r4, [r0, #0]
    svf->k = 1.0f/Q;
   283ca:	eec7 6a08 	vdiv.f32	s13, s14, s16
    svf->type = type;
   283ce:	7105      	strb	r5, [r0, #4]
    svf->g = __leaf_table_filtertan[input];
   283d0:	edd2 7a00 	vldr	s15, [r2]
    svf->ic1eq = 0;
   283d4:	6103      	str	r3, [r0, #16]
    svf->g = __leaf_table_filtertan[input];
   283d6:	edc0 7a06 	vstr	s15, [r0, #24]
    svf->ic2eq = 0;
   283da:	6143      	str	r3, [r0, #20]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   283dc:	ee37 6aa6 	vadd.f32	s12, s15, s13
    svf->k = 1.0f/Q;
   283e0:	edc0 6a07 	vstr	s13, [r0, #28]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   283e4:	eef0 6a47 	vmov.f32	s13, s14
   283e8:	eee7 6a86 	vfma.f32	s13, s15, s12
   283ec:	eeb0 6a66 	vmov.f32	s12, s13
   283f0:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g*svf->a1;
   283f4:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
   283f8:	edc0 6a08 	vstr	s13, [r0, #32]
    svf->a3 = svf->g*svf->a2;
   283fc:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g*svf->a1;
   28400:	ed80 7a09 	vstr	s14, [r0, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
   28404:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
}
   28408:	ecbd 8b02 	vpop	{d8}
   2840c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2840e:	bf00      	nop
   28410:	0003281c 	.word	0x0003281c

00028414 <tEfficientSVF_free>:

void    tEfficientSVF_free (tEfficientSVF* const svff)
{
    _tEfficientSVF* svf = *svff;
   28414:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
   28416:	6801      	ldr	r1, [r0, #0]
   28418:	f001 bcde 	b.w	29dd8 <mpool_free>

0002841c <tEfficientSVF_tick>:
}

float   tEfficientSVF_tick(tEfficientSVF* const svff, float v0)
{
    _tEfficientSVF* svf = *svff;
   2841c:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2841e:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
   28422:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   28426:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2842a:	eeb0 7a66 	vmov.f32	s14, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2842e:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
   28432:	ee70 5a66 	vsub.f32	s11, s0, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   28436:	ed93 4a08 	vldr	s8, [r3, #32]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2843a:	edd3 4a0a 	vldr	s9, [r3, #40]	; 0x28
   2843e:	eea6 7a27 	vfma.f32	s14, s12, s15
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    if (svf->type == SVFTypeLowpass)        return v2;
   28442:	791a      	ldrb	r2, [r3, #4]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   28444:	ee67 7aa5 	vmul.f32	s15, s15, s11
    if (svf->type == SVFTypeLowpass)        return v2;
   28448:	2a01      	cmp	r2, #1
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
   2844a:	eee4 7a06 	vfma.f32	s15, s8, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
   2844e:	eea4 7aa5 	vfma.f32	s14, s9, s11
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   28452:	ee97 6a85 	vfnms.f32	s12, s15, s10
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   28456:	ee77 5a07 	vadd.f32	s11, s14, s14
   2845a:	ee75 6ae6 	vsub.f32	s13, s11, s13
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
   2845e:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
   28462:	edc3 6a05 	vstr	s13, [r3, #20]
    if (svf->type == SVFTypeLowpass)        return v2;
   28466:	d008      	beq.n	2847a <tEfficientSVF_tick+0x5e>
    else if (svf->type == SVFTypeBandpass)  return v1;
   28468:	2a02      	cmp	r2, #2
   2846a:	d009      	beq.n	28480 <tEfficientSVF_tick+0x64>
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
   2846c:	b16a      	cbz	r2, 2848a <tEfficientSVF_tick+0x6e>
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
   2846e:	2a03      	cmp	r2, #3
   28470:	d014      	beq.n	2849c <tEfficientSVF_tick+0x80>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
   28472:	2a04      	cmp	r2, #4
   28474:	d019      	beq.n	284aa <tEfficientSVF_tick+0x8e>
    else                                    return 0.0f;
   28476:	ed9f 7a10 	vldr	s14, [pc, #64]	; 284b8 <tEfficientSVF_tick+0x9c>
    
}
   2847a:	eeb0 0a47 	vmov.f32	s0, s14
   2847e:	4770      	bx	lr
    else if (svf->type == SVFTypeBandpass)  return v1;
   28480:	eeb0 7a67 	vmov.f32	s14, s15
}
   28484:	eeb0 0a47 	vmov.f32	s0, s14
   28488:	4770      	bx	lr
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
   2848a:	edd3 6a07 	vldr	s13, [r3, #28]
   2848e:	eea6 0ae7 	vfms.f32	s0, s13, s15
   28492:	ee30 7a47 	vsub.f32	s14, s0, s14
}
   28496:	eeb0 0a47 	vmov.f32	s0, s14
   2849a:	4770      	bx	lr
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
   2849c:	ed93 7a07 	vldr	s14, [r3, #28]
   284a0:	eea7 0a67 	vfms.f32	s0, s14, s15
   284a4:	eeb0 7a40 	vmov.f32	s14, s0
   284a8:	e7e7      	b.n	2847a <tEfficientSVF_tick+0x5e>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
   284aa:	ed93 7a07 	vldr	s14, [r3, #28]
   284ae:	eea7 0a67 	vfms.f32	s0, s14, s15
   284b2:	ee30 7a65 	vsub.f32	s14, s0, s11
   284b6:	e7e0      	b.n	2847a <tEfficientSVF_tick+0x5e>
   284b8:	00000000 	.word	0x00000000

000284bc <tEfficientSVF_setFreq>:

void     tEfficientSVF_setFreq(tEfficientSVF* const svff, uint16_t input)
{
    _tEfficientSVF* svf = *svff;
    
    svf->g = __leaf_table_filtertan[input];
   284bc:	4a10      	ldr	r2, [pc, #64]	; (28500 <tEfficientSVF_setFreq+0x44>)
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   284be:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
   284c2:	6803      	ldr	r3, [r0, #0]
    svf->g = __leaf_table_filtertan[input];
   284c4:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   284c8:	ed93 7a07 	vldr	s14, [r3, #28]
   284cc:	eef0 6a46 	vmov.f32	s13, s12
    svf->g = __leaf_table_filtertan[input];
   284d0:	edd1 7a00 	vldr	s15, [r1]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   284d4:	ee37 7a87 	vadd.f32	s14, s15, s14
    svf->g = __leaf_table_filtertan[input];
   284d8:	edc3 7a06 	vstr	s15, [r3, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   284dc:	eee7 6a87 	vfma.f32	s13, s15, s14
   284e0:	eeb0 7a66 	vmov.f32	s14, s13
   284e4:	eec6 6a07 	vdiv.f32	s13, s12, s14
    svf->a2 = svf->g * svf->a1;
   284e8:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   284ec:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
   284f0:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
   284f4:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   284f8:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
   284fc:	4770      	bx	lr
   284fe:	bf00      	nop
   28500:	0003281c 	.word	0x0003281c

00028504 <tEfficientSVF_setQ>:

void     tEfficientSVF_setQ(tEfficientSVF* const svff, float Q)
{
    _tEfficientSVF* svf = *svff;
    
    svf->k = 1.0f/Q;
   28504:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
   28508:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2850a:	edd3 7a06 	vldr	s15, [r3, #24]
    svf->k = 1.0f/Q;
   2850e:	ee87 0a00 	vdiv.f32	s0, s14, s0
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   28512:	eeb0 6a47 	vmov.f32	s12, s14
   28516:	ee70 6a27 	vadd.f32	s13, s0, s15
    svf->k = 1.0f/Q;
   2851a:	ed83 0a07 	vstr	s0, [r3, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2851e:	eea7 6aa6 	vfma.f32	s12, s15, s13
   28522:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g * svf->a1;
   28526:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
   2852a:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
   2852e:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
   28532:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
   28536:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
   2853a:	4770      	bx	lr

0002853c <tHighpass_init>:

/* Highpass */
void    tHighpass_init(tHighpass* const ft, float freq)
{
   2853c:	b570      	push	{r4, r5, r6, lr}
    tHighpass_initToPool(ft, freq, &leaf.mempool);
}

void    tHighpass_initToPool    (tHighpass* const ft, float freq, tMempool* const mp)
{
    _tMempool* m = *mp;
   2853e:	4c0e      	ldr	r4, [pc, #56]	; (28578 <tHighpass_init+0x3c>)
{
   28540:	4606      	mov	r6, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28542:	2014      	movs	r0, #20
    _tMempool* m = *mp;
   28544:	69a5      	ldr	r5, [r4, #24]
{
   28546:	ed2d 8b02 	vpush	{d8}
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2854a:	4629      	mov	r1, r5
{
   2854c:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28550:	f001 fbf0 	bl	29d34 <mpool_calloc>
    f->mempool = m;
    
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28554:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28558:	6030      	str	r0, [r6, #0]
    f->ys = 0.0f;
   2855a:	2300      	movs	r3, #0
    f->mempool = m;
   2855c:	6005      	str	r5, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2855e:	ed94 7a03 	vldr	s14, [r4, #12]
    f->xs = 0.0f;
    
    f->frequency = freq;
   28562:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28566:	eee8 7a47 	vfms.f32	s15, s16, s14
    f->ys = 0.0f;
   2856a:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
   2856c:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2856e:	edc0 7a03 	vstr	s15, [r0, #12]
}
   28572:	ecbd 8b02 	vpop	{d8}
   28576:	bd70      	pop	{r4, r5, r6, pc}
   28578:	020fc0a8 	.word	0x020fc0a8

0002857c <tHighpass_initToPool>:
{
   2857c:	b538      	push	{r3, r4, r5, lr}
   2857e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   28582:	680c      	ldr	r4, [r1, #0]
{
   28584:	4605      	mov	r5, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28586:	2014      	movs	r0, #20
{
   28588:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   2858c:	4621      	mov	r1, r4
   2858e:	f001 fbd1 	bl	29d34 <mpool_calloc>
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   28592:	4b09      	ldr	r3, [pc, #36]	; (285b8 <tHighpass_initToPool+0x3c>)
   28594:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
   28598:	6028      	str	r0, [r5, #0]
    f->mempool = m;
   2859a:	6004      	str	r4, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   2859c:	ed93 7a03 	vldr	s14, [r3, #12]
    f->ys = 0.0f;
   285a0:	2300      	movs	r3, #0
    f->frequency = freq;
   285a2:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   285a6:	eee7 7a48 	vfms.f32	s15, s14, s16
    f->ys = 0.0f;
   285aa:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
   285ac:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   285ae:	edc0 7a03 	vstr	s15, [r0, #12]
}
   285b2:	ecbd 8b02 	vpop	{d8}
   285b6:	bd38      	pop	{r3, r4, r5, pc}
   285b8:	020fc0a8 	.word	0x020fc0a8

000285bc <tHighpass_free>:

void    tHighpass_free  (tHighpass* const ft)
{
    _tHighpass* f = *ft;
   285bc:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)f, f->mempool);
   285be:	6801      	ldr	r1, [r0, #0]
   285c0:	f001 bc0a 	b.w	29dd8 <mpool_free>

000285c4 <tHighpass_setFreq>:

void     tHighpass_setFreq(tHighpass* const ft, float freq)
{
    _tHighpass* f = *ft;
    f->frequency = freq;
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   285c4:	4a06      	ldr	r2, [pc, #24]	; (285e0 <tHighpass_setFreq+0x1c>)
   285c6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft;
   285ca:	6803      	ldr	r3, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   285cc:	ed92 7a03 	vldr	s14, [r2, #12]
    f->frequency = freq;
   285d0:	ed83 0a04 	vstr	s0, [r3, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
   285d4:	eee7 7a40 	vfms.f32	s15, s14, s0
   285d8:	edc3 7a03 	vstr	s15, [r3, #12]
    
}
   285dc:	4770      	bx	lr
   285de:	bf00      	nop
   285e0:	020fc0a8 	.word	0x020fc0a8

000285e4 <tHighpass_tick>:
}

// From JOS DC Blocker
float   tHighpass_tick(tHighpass* const ft, float x)
{
    _tHighpass* f = *ft;
   285e4:	6803      	ldr	r3, [r0, #0]
    f->ys = x - f->xs + f->R * f->ys;
   285e6:	edd3 7a01 	vldr	s15, [r3, #4]
   285ea:	ed93 7a02 	vldr	s14, [r3, #8]
   285ee:	edd3 6a03 	vldr	s13, [r3, #12]
    f->xs = x;
   285f2:	ed83 0a01 	vstr	s0, [r3, #4]
    f->ys = x - f->xs + f->R * f->ys;
   285f6:	eed6 7a87 	vfnms.f32	s15, s13, s14
   285fa:	ee37 0a80 	vadd.f32	s0, s15, s0
   285fe:	ed83 0a02 	vstr	s0, [r3, #8]
    return f->ys;
}
   28602:	4770      	bx	lr

00028604 <tVZFilter_initToPool>:
{
	tVZFilter_initToPool(vf, type, freq, bandWidth, &leaf.mempool);
}

void    tVZFilter_initToPool     (tVZFilter* const vf, VZFilterType type, float freq, float bandWidth, tMempool* const mp)
{
   28604:	b570      	push	{r4, r5, r6, lr}
   28606:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2860a:	6814      	ldr	r4, [r2, #0]
{
   2860c:	4605      	mov	r5, r0
   2860e:	460e      	mov	r6, r1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   28610:	2044      	movs	r0, #68	; 0x44
   28612:	4621      	mov	r1, r4
{
   28614:	eef0 8a40 	vmov.f32	s17, s0
   28618:	eeb0 8a60 	vmov.f32	s16, s1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   2861c:	f001 fb34 	bl	29c88 <mpool_alloc>
	f->invG    = 1.0f/ONE_OVER_SQRT2;
	f->B    = bandWidth;
	f->m    = 0.0f;
	f->s1 = 0.0f;
	f->s2 = 0.0f;
	f->sr = leaf.sampleRate;
   28620:	4bc1      	ldr	r3, [pc, #772]	; (28928 <tVZFilter_initToPool+0x324>)
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
   28622:	6028      	str	r0, [r5, #0]
    f->mempool = m;
   28624:	6004      	str	r4, [r0, #0]
	f->type = type;
   28626:	7106      	strb	r6, [r0, #4]
	f->sr = leaf.sampleRate;
   28628:	6819      	ldr	r1, [r3, #0]
	f->inv_sr = leaf.invSampleRate;
   2862a:	685a      	ldr	r2, [r3, #4]
	f->m    = 0.0f;
   2862c:	2300      	movs	r3, #0
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   2862e:	4cbf      	ldr	r4, [pc, #764]	; (2892c <tVZFilter_initToPool+0x328>)
	f->G    = ONE_OVER_SQRT2;
   28630:	4ebf      	ldr	r6, [pc, #764]	; (28930 <tVZFilter_initToPool+0x32c>)
	f->fc   = freq;
   28632:	edc0 8a0a 	vstr	s17, [r0, #40]	; 0x28
	f->m    = 0.0f;
   28636:	6383      	str	r3, [r0, #56]	; 0x38
	f->s1 = 0.0f;
   28638:	6083      	str	r3, [r0, #8]
	f->s2 = 0.0f;
   2863a:	60c3      	str	r3, [r0, #12]
	f->B    = bandWidth;
   2863c:	ed80 8a0d 	vstr	s16, [r0, #52]	; 0x34
	f->G    = ONE_OVER_SQRT2;
   28640:	62c6      	str	r6, [r0, #44]	; 0x2c
	f->invG    = 1.0f/ONE_OVER_SQRT2;
   28642:	6304      	str	r4, [r0, #48]	; 0x30
	f->sr = leaf.sampleRate;
   28644:	63c1      	str	r1, [r0, #60]	; 0x3c
	f->inv_sr = leaf.invSampleRate;
   28646:	6402      	str	r2, [r0, #64]	; 0x40


void   tVZFilter_calcCoeffs           (tVZFilter* const vf)
{

	_tVZFilter* f = *vf;
   28648:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2864a:	eddf 7aba 	vldr	s15, [pc, #744]	; 28934 <tVZFilter_initToPool+0x330>
   2864e:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   28652:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   28656:	ee28 8a07 	vmul.f32	s16, s16, s14
   2865a:	ee28 8a27 	vmul.f32	s16, s16, s15
   2865e:	eeb0 0a48 	vmov.f32	s0, s16
   28662:	f004 fe03 	bl	2d26c <tanf>

	  switch( f->type )
   28666:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28668:	eef0 8a40 	vmov.f32	s17, s0
   2866c:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   28670:	2b0a      	cmp	r3, #10
   28672:	f200 81b5 	bhi.w	289e0 <tVZFilter_initToPool+0x3dc>
   28676:	e8df f013 	tbh	[pc, r3, lsl #1]
   2867a:	0053      	.short	0x0053
   2867c:	0069005e 	.word	0x0069005e
   28680:	00ab0074 	.word	0x00ab0074
   28684:	011600e3 	.word	0x011600e3
   28688:	01630136 	.word	0x01630136
   2868c:	000b01a8 	.word	0x000b01a8
}

float tVZFilter_BandwidthToR(tVZFilter* const vf, float B)
{
	_tVZFilter* f = *vf;
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28690:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28694:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28698:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2869a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2869e:	ee60 0aa7 	vmul.f32	s1, s1, s15
   286a2:	f004 fca5 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   286a6:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   286aa:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   286ae:	ed9f 7aa1 	vldr	s14, [pc, #644]	; 28934 <tVZFilter_initToPool+0x330>
   286b2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   286b6:	ee67 7a87 	vmul.f32	s15, s15, s14
   286ba:	ee27 0a80 	vmul.f32	s0, s15, s0
   286be:	f004 fdd5 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   286c2:	ed95 7a04 	vldr	s14, [r5, #16]
							   // unwarped: r = pow(2, -B/2) -> approximation for low
							   // center-frequencies
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   286c6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   286ca:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   286ce:	edc4 7a07 	vstr	s15, [r4, #28]
   286d2:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   286d6:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   286da:	ee20 0a00 	vmul.f32	s0, s0, s0
   286de:	ee77 7ac0 	vsub.f32	s15, s15, s0
   286e2:	ee20 0a07 	vmul.f32	s0, s0, s14
   286e6:	ee67 7aa7 	vmul.f32	s15, s15, s15
   286ea:	ee87 7a80 	vdiv.f32	s14, s15, s0
   286ee:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   286f2:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   286f6:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   286fa:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   286fe:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   28702:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   28706:	ee77 7aa8 	vadd.f32	s15, s15, s17
   2870a:	eef0 6a47 	vmov.f32	s13, s14
   2870e:	eee7 6aa8 	vfma.f32	s13, s15, s17
   28712:	eec7 7a26 	vdiv.f32	s15, s14, s13
   28716:	edc4 7a06 	vstr	s15, [r4, #24]
}
   2871a:	ecbd 8b04 	vpop	{d8-d9}
   2871e:	bd70      	pop	{r4, r5, r6, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28720:	2300      	movs	r3, #0
   28722:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28726:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2872a:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   2872c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28730:	61e3      	str	r3, [r4, #28]
   28732:	6223      	str	r3, [r4, #32]
   28734:	e7e5      	b.n	28702 <tVZFilter_initToPool+0xfe>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28736:	2300      	movs	r3, #0
   28738:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   2873c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28740:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   28742:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28746:	6223      	str	r3, [r4, #32]
   28748:	6263      	str	r3, [r4, #36]	; 0x24
   2874a:	e7da      	b.n	28702 <tVZFilter_initToPool+0xfe>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2874c:	2300      	movs	r3, #0
   2874e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28752:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28756:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   28758:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   2875c:	61e3      	str	r3, [r4, #28]
   2875e:	6263      	str	r3, [r4, #36]	; 0x24
   28760:	e7cf      	b.n	28702 <tVZFilter_initToPool+0xfe>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28762:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28766:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2876a:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2876c:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28770:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28774:	f004 fc3c 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28778:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   2877c:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28780:	ed9f 7a6c 	vldr	s14, [pc, #432]	; 28934 <tVZFilter_initToPool+0x330>
   28784:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28788:	ee67 7a87 	vmul.f32	s15, s15, s14
   2878c:	ee27 0a80 	vmul.f32	s0, s15, s0
   28790:	f004 fd6c 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28794:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28798:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2879c:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2879e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   287a2:	61e3      	str	r3, [r4, #28]
   287a4:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   287a6:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   287aa:	ee20 0a00 	vmul.f32	s0, s0, s0
   287ae:	ee77 7ac0 	vsub.f32	s15, s15, s0
   287b2:	ee20 0a07 	vmul.f32	s0, s0, s14
   287b6:	ee67 7aa7 	vmul.f32	s15, s15, s15
   287ba:	ee87 7a80 	vdiv.f32	s14, s15, s0
   287be:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   287c2:	ee77 7aa7 	vadd.f32	s15, s15, s15
   287c6:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   287ca:	edc4 7a08 	vstr	s15, [r4, #32]
   287ce:	e798      	b.n	28702 <tVZFilter_initToPool+0xfe>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   287d0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   287d4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   287d8:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   287da:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   287de:	ee60 0aa7 	vmul.f32	s1, s1, s15
   287e2:	f004 fc05 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   287e6:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   287ea:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   287ee:	ed9f 7a51 	vldr	s14, [pc, #324]	; 28934 <tVZFilter_initToPool+0x330>
   287f2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   287f6:	ee67 7a87 	vmul.f32	s15, s15, s14
   287fa:	ee27 0a80 	vmul.f32	s0, s15, s0
   287fe:	f004 fd35 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28802:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28806:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2880a:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2880c:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28810:	6223      	str	r3, [r4, #32]
   28812:	edc4 7a07 	vstr	s15, [r4, #28]
   28816:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2881a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2881e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28822:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28826:	ee20 0a07 	vmul.f32	s0, s0, s14
   2882a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2882e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28832:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28836:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2883a:	edc4 7a05 	vstr	s15, [r4, #20]
   2883e:	e760      	b.n	28702 <tVZFilter_initToPool+0xfe>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   28840:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28844:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   28848:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   2884c:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28850:	f004 fbce 	bl	2cff0 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28854:	ee28 0a00 	vmul.f32	s0, s16, s0
   28858:	f004 fd08 	bl	2d26c <tanf>
			float r  = f->g/wl;
   2885c:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28860:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   28864:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   28868:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   2886c:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28870:	edc4 7a07 	vstr	s15, [r4, #28]
   28874:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28878:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   2887c:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28880:	eee0 7a00 	vfma.f32	s15, s0, s0
   28884:	ee87 6a80 	vdiv.f32	s12, s15, s0
   28888:	ee76 7a65 	vsub.f32	s15, s12, s11
   2888c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   28890:	eef1 7ac6 	vsqrt.f32	s15, s12
   28894:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28898:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2889c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   288a0:	ed84 7a08 	vstr	s14, [r4, #32]
   288a4:	e72d      	b.n	28702 <tVZFilter_initToPool+0xfe>
			float A = sqrtf(f->G);
   288a6:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   288aa:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   288ae:	eddf 7a22 	vldr	s15, [pc, #136]	; 28938 <tVZFilter_initToPool+0x334>
			float A = sqrtf(f->G);
   288b2:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   288b6:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   288ba:	ee20 0a27 	vmul.f32	s0, s0, s15
   288be:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   288c2:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   288c6:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   288ca:	f004 ffb9 	bl	2d840 <sinhf>
   288ce:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   288d2:	ed84 9a07 	vstr	s18, [r4, #28]
   288d6:	6265      	str	r5, [r4, #36]	; 0x24
   288d8:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   288dc:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   288e0:	ed84 8a08 	vstr	s16, [r4, #32]
   288e4:	e70d      	b.n	28702 <tVZFilter_initToPool+0xfe>
		  float A = sqrtf(f->G);
   288e6:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   288ea:	eddf 7a13 	vldr	s15, [pc, #76]	; 28938 <tVZFilter_initToPool+0x334>
		  float A = sqrtf(f->G);
   288ee:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   288f2:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   288f6:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   288fa:	eef1 7ac8 	vsqrt.f32	s15, s16
   288fe:	ee68 8aa7 	vmul.f32	s17, s17, s15
   28902:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28906:	f004 ff9b 	bl	2d840 <sinhf>
   2890a:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2890e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   28912:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   28916:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2891a:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   2891e:	61e3      	str	r3, [r4, #28]
   28920:	ed84 8a08 	vstr	s16, [r4, #32]
   28924:	e6ed      	b.n	28702 <tVZFilter_initToPool+0xfe>
   28926:	bf00      	nop
   28928:	020fc0a8 	.word	0x020fc0a8
   2892c:	3fb504f3 	.word	0x3fb504f3
   28930:	3f3504f3 	.word	0x3f3504f3
   28934:	40490fdb 	.word	0x40490fdb
   28938:	3eb17218 	.word	0x3eb17218
   2893c:	00000000 	.word	0x00000000
		  float x  = 2.0f*f->m-1.0f;
   28940:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   28944:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   28948:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2894c:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2894e:	ed5f 0a05 	vldr	s1, [pc, #-20]	; 2893c <tVZFilter_initToPool+0x338>
			f->R2 = f->invG;
   28952:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   28954:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28958:	eef1 8a48 	vneg.f32	s17, s16
   2895c:	eeb0 0a68 	vmov.f32	s0, s17
   28960:	f001 f972 	bl	29c48 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   28964:	ed5f 0a0b 	vldr	s1, [pc, #-44]	; 2893c <tVZFilter_initToPool+0x338>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28968:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   2896c:	eeb0 0a48 	vmov.f32	s0, s16
   28970:	f001 f96e 	bl	29c50 <minimum>
		  f->cB = 1.0f-x*x;
   28974:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28978:	edd4 6a07 	vldr	s13, [r4, #28]
   2897c:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   28980:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28984:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   28988:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2898c:	edd4 8a04 	vldr	s17, [r4, #16]
   28990:	ee67 4aa7 	vmul.f32	s9, s15, s15
   28994:	ee27 6a07 	vmul.f32	s12, s14, s14
   28998:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2899c:	eea0 6a00 	vfma.f32	s12, s0, s0
   289a0:	eea0 6a45 	vfms.f32	s12, s0, s10
   289a4:	ee84 5a86 	vdiv.f32	s10, s9, s12
   289a8:	eeb1 6ac5 	vsqrt.f32	s12, s10
   289ac:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   289b0:	ee66 6a86 	vmul.f32	s13, s13, s12
   289b4:	ee27 7a06 	vmul.f32	s14, s14, s12
   289b8:	ee20 0a06 	vmul.f32	s0, s0, s12
   289bc:	edc4 6a07 	vstr	s13, [r4, #28]
   289c0:	ed84 7a08 	vstr	s14, [r4, #32]
   289c4:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   289c8:	e69b      	b.n	28702 <tVZFilter_initToPool+0xfe>
		  f->cL = 1.0f;
   289ca:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   289ce:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   289d2:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   289d4:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   289d8:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   289da:	edc4 7a08 	vstr	s15, [r4, #32]
   289de:	e690      	b.n	28702 <tVZFilter_initToPool+0xfe>
   289e0:	edd4 7a05 	vldr	s15, [r4, #20]
   289e4:	e68d      	b.n	28702 <tVZFilter_initToPool+0xfe>
   289e6:	bf00      	nop

000289e8 <tVZFilter_free>:
    _tVZFilter* f = *vf;
   289e8:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
   289ea:	6801      	ldr	r1, [r0, #0]
   289ec:	f001 b9f4 	b.w	29dd8 <mpool_free>

000289f0 <tVZFilter_setSampleRate>:
	f->inv_sr = 1.0f/sampleRate;
   289f0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	_tVZFilter* f = *vf;
   289f4:	6803      	ldr	r3, [r0, #0]
	f->sr = sampleRate;
   289f6:	ed83 0a0f 	vstr	s0, [r3, #60]	; 0x3c
	f->inv_sr = 1.0f/sampleRate;
   289fa:	eec7 7a00 	vdiv.f32	s15, s14, s0
   289fe:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
}
   28a02:	4770      	bx	lr

00028a04 <tVZFilter_tick>:
{
   28a04:	b510      	push	{r4, lr}
	_tVZFilter* f = *vf;
   28a06:	6804      	ldr	r4, [r0, #0]
{
   28a08:	ed2d 8b06 	vpush	{d8-d10}
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   28a0c:	ed94 8a02 	vldr	s16, [r4, #8]
   28a10:	edd4 7a05 	vldr	s15, [r4, #20]
   28a14:	ed94 9a04 	vldr	s18, [r4, #16]
   28a18:	eea7 0ac8 	vfms.f32	s0, s15, s16
   28a1c:	edd4 9a03 	vldr	s19, [r4, #12]
   28a20:	edd4 7a06 	vldr	s15, [r4, #24]
   28a24:	eea8 0a49 	vfms.f32	s0, s16, s18
   28a28:	ee70 8a69 	vsub.f32	s17, s0, s19
   28a2c:	ee68 8aa7 	vmul.f32	s17, s17, s15
	yB = tanhf(f->g*yH) + f->s1;
   28a30:	ee29 aa28 	vmul.f32	s20, s18, s17
   28a34:	eeb0 0a4a 	vmov.f32	s0, s20
   28a38:	f004 fc40 	bl	2d2bc <tanhf>
   28a3c:	ee38 8a00 	vadd.f32	s16, s16, s0
	yL = tanhf(f->g*yB) + f->s2;
   28a40:	ee29 9a08 	vmul.f32	s18, s18, s16
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   28a44:	ee3a aa08 	vadd.f32	s20, s20, s16
	yL = tanhf(f->g*yB) + f->s2;
   28a48:	eeb0 0a49 	vmov.f32	s0, s18
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   28a4c:	ed84 aa02 	vstr	s20, [r4, #8]
	yL = tanhf(f->g*yB) + f->s2;
   28a50:	f004 fc34 	bl	2d2bc <tanhf>
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28a54:	edd4 7a08 	vldr	s15, [r4, #32]
	yL = tanhf(f->g*yB) + f->s2;
   28a58:	ee79 9a80 	vadd.f32	s19, s19, s0
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28a5c:	ed94 7a07 	vldr	s14, [r4, #28]
   28a60:	ee28 0a27 	vmul.f32	s0, s16, s15
   28a64:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28a68:	ee39 9a29 	vadd.f32	s18, s18, s19
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28a6c:	eea7 0a29 	vfma.f32	s0, s14, s19
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28a70:	ed84 9a03 	vstr	s18, [r4, #12]
}
   28a74:	eea7 0aa8 	vfma.f32	s0, s15, s17
   28a78:	ecbd 8b06 	vpop	{d8-d10}
   28a7c:	bd10      	pop	{r4, pc}
   28a7e:	bf00      	nop

00028a80 <tVZFilter_tickEfficient>:
	_tVZFilter* f = *vf;
   28a80:	6803      	ldr	r3, [r0, #0]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   28a82:	ed93 7a02 	vldr	s14, [r3, #8]
   28a86:	edd3 7a05 	vldr	s15, [r3, #20]
   28a8a:	edd3 5a04 	vldr	s11, [r3, #16]
   28a8e:	eea7 0ac7 	vfms.f32	s0, s15, s14
   28a92:	ed93 6a03 	vldr	s12, [r3, #12]
   28a96:	ed93 4a06 	vldr	s8, [r3, #24]
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28a9a:	edd3 6a09 	vldr	s13, [r3, #36]	; 0x24
   28a9e:	edd3 4a08 	vldr	s9, [r3, #32]
   28aa2:	ed93 5a07 	vldr	s10, [r3, #28]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
   28aa6:	eea7 0a65 	vfms.f32	s0, s14, s11
   28aaa:	ee70 7a46 	vsub.f32	s15, s0, s12
   28aae:	ee67 7a84 	vmul.f32	s15, s15, s8
	yB = (f->g*yH) + f->s1;
   28ab2:	eea5 7aa7 	vfma.f32	s14, s11, s15
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28ab6:	ee27 0aa6 	vmul.f32	s0, s15, s13
	yL = (f->g*yB) + f->s2;
   28aba:	eef0 6a46 	vmov.f32	s13, s12
   28abe:	eee5 6a87 	vfma.f32	s13, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   28ac2:	eeb0 6a47 	vmov.f32	s12, s14
	return f->cL*yL + f->cB*yB + f->cH*yH;
   28ac6:	eea4 0a87 	vfma.f32	s0, s9, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   28aca:	eea5 6aa7 	vfma.f32	s12, s11, s15
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28ace:	eef0 7a66 	vmov.f32	s15, s13
}
   28ad2:	eea5 0a26 	vfma.f32	s0, s10, s13
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28ad6:	eee5 7a87 	vfma.f32	s15, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
   28ada:	ed83 6a02 	vstr	s12, [r3, #8]
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
   28ade:	edc3 7a03 	vstr	s15, [r3, #12]
}
   28ae2:	4770      	bx	lr

00028ae4 <tVZFilter_setFreq>:
{
   28ae4:	b538      	push	{r3, r4, r5, lr}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28ae6:	4be3      	ldr	r3, [pc, #908]	; (28e74 <tVZFilter_setFreq+0x390>)
   28ae8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	_tVZFilter* f = *vf;
   28aec:	6804      	ldr	r4, [r0, #0]
{
   28aee:	4605      	mov	r5, r0
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28af0:	eef0 0a40 	vmov.f32	s1, s0
   28af4:	ed9f 0ae0 	vldr	s0, [pc, #896]	; 28e78 <tVZFilter_setFreq+0x394>
{
   28af8:	ed2d 8b04 	vpush	{d8-d9}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28afc:	ed93 1a00 	vldr	s2, [r3]
   28b00:	ee21 1a27 	vmul.f32	s2, s2, s15
   28b04:	f000 fec0 	bl	29888 <LEAF_clip>
   28b08:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
   28b0c:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28b0e:	eddf 7adb 	vldr	s15, [pc, #876]	; 28e7c <tVZFilter_setFreq+0x398>
   28b12:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   28b16:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   28b1a:	ee28 8a07 	vmul.f32	s16, s16, s14
   28b1e:	ee28 8a27 	vmul.f32	s16, s16, s15
   28b22:	eeb0 0a48 	vmov.f32	s0, s16
   28b26:	f004 fba1 	bl	2d26c <tanf>
	  switch( f->type )
   28b2a:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28b2c:	eef0 8a40 	vmov.f32	s17, s0
   28b30:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   28b34:	2b0a      	cmp	r3, #10
   28b36:	f200 81b0 	bhi.w	28e9a <tVZFilter_setFreq+0x3b6>
   28b3a:	e8df f013 	tbh	[pc, r3, lsl #1]
   28b3e:	0053      	.short	0x0053
   28b40:	0069005e 	.word	0x0069005e
   28b44:	00ab0074 	.word	0x00ab0074
   28b48:	011600e3 	.word	0x011600e3
   28b4c:	01560136 	.word	0x01560136
   28b50:	000b01a3 	.word	0x000b01a3
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28b54:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28b58:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28b5c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28b5e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28b62:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28b66:	f004 fa43 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28b6a:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28b6e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28b72:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 28e7c <tVZFilter_setFreq+0x398>
   28b76:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28b7a:	ee67 7a87 	vmul.f32	s15, s15, s14
   28b7e:	ee27 0a80 	vmul.f32	s0, s15, s0
   28b82:	f004 fb73 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28b86:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28b8a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28b8e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28b92:	edc4 7a07 	vstr	s15, [r4, #28]
   28b96:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28b9a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28b9e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28ba2:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28ba6:	ee20 0a07 	vmul.f32	s0, s0, s14
   28baa:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28bae:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28bb2:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28bb6:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28bba:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28bbe:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28bc2:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   28bc6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   28bca:	ee77 7aa8 	vadd.f32	s15, s15, s17
   28bce:	eef0 6a47 	vmov.f32	s13, s14
   28bd2:	eee7 6aa8 	vfma.f32	s13, s15, s17
   28bd6:	eec7 7a26 	vdiv.f32	s15, s14, s13
   28bda:	edc4 7a06 	vstr	s15, [r4, #24]
}
   28bde:	ecbd 8b04 	vpop	{d8-d9}
   28be2:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28be4:	2300      	movs	r3, #0
   28be6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28bea:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28bee:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   28bf0:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28bf4:	61e3      	str	r3, [r4, #28]
   28bf6:	6223      	str	r3, [r4, #32]
   28bf8:	e7e5      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28bfa:	2300      	movs	r3, #0
   28bfc:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28c00:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28c04:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   28c06:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28c0a:	6223      	str	r3, [r4, #32]
   28c0c:	6263      	str	r3, [r4, #36]	; 0x24
   28c0e:	e7da      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28c10:	2300      	movs	r3, #0
   28c12:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28c16:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28c1a:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   28c1c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28c20:	61e3      	str	r3, [r4, #28]
   28c22:	6263      	str	r3, [r4, #36]	; 0x24
   28c24:	e7cf      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28c26:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28c2a:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28c2e:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28c30:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28c34:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28c38:	f004 f9da 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28c3c:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28c40:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28c44:	ed9f 7a8d 	vldr	s14, [pc, #564]	; 28e7c <tVZFilter_setFreq+0x398>
   28c48:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28c4c:	ee67 7a87 	vmul.f32	s15, s15, s14
   28c50:	ee27 0a80 	vmul.f32	s0, s15, s0
   28c54:	f004 fb0a 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28c58:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28c5c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28c60:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28c62:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28c66:	61e3      	str	r3, [r4, #28]
   28c68:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28c6a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28c6e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28c72:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28c76:	ee20 0a07 	vmul.f32	s0, s0, s14
   28c7a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28c7e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28c82:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28c86:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28c8a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   28c8e:	edc4 7a08 	vstr	s15, [r4, #32]
   28c92:	e798      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28c94:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28c98:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28c9c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28c9e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28ca2:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28ca6:	f004 f9a3 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28caa:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28cae:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28cb2:	ed9f 7a72 	vldr	s14, [pc, #456]	; 28e7c <tVZFilter_setFreq+0x398>
   28cb6:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28cba:	ee67 7a87 	vmul.f32	s15, s15, s14
   28cbe:	ee27 0a80 	vmul.f32	s0, s15, s0
   28cc2:	f004 fad3 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28cc6:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28cca:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28cce:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28cd0:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   28cd4:	6223      	str	r3, [r4, #32]
   28cd6:	edc4 7a07 	vstr	s15, [r4, #28]
   28cda:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28cde:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28ce2:	ee20 0a00 	vmul.f32	s0, s0, s0
   28ce6:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28cea:	ee20 0a07 	vmul.f32	s0, s0, s14
   28cee:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28cf2:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28cf6:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28cfa:	ee77 7aa7 	vadd.f32	s15, s15, s15
   28cfe:	edc4 7a05 	vstr	s15, [r4, #20]
   28d02:	e760      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   28d04:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28d08:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   28d0c:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28d10:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28d14:	f004 f96c 	bl	2cff0 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28d18:	ee28 0a00 	vmul.f32	s0, s16, s0
   28d1c:	f004 faa6 	bl	2d26c <tanf>
			float r  = f->g/wl;
   28d20:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28d24:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   28d28:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   28d2c:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   28d30:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28d34:	edc4 7a07 	vstr	s15, [r4, #28]
   28d38:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28d3c:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   28d40:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28d44:	eee0 7a00 	vfma.f32	s15, s0, s0
   28d48:	ee87 6a80 	vdiv.f32	s12, s15, s0
   28d4c:	ee76 7a65 	vsub.f32	s15, s12, s11
   28d50:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   28d54:	eef1 7ac6 	vsqrt.f32	s15, s12
   28d58:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28d5c:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   28d60:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   28d64:	ed84 7a08 	vstr	s14, [r4, #32]
   28d68:	e72d      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
			float A = sqrtf(f->G);
   28d6a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28d6e:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28d72:	eddf 7a43 	vldr	s15, [pc, #268]	; 28e80 <tVZFilter_setFreq+0x39c>
			float A = sqrtf(f->G);
   28d76:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28d7a:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   28d7e:	ee20 0a27 	vmul.f32	s0, s0, s15
   28d82:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28d86:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   28d8a:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28d8e:	f004 fd57 	bl	2d840 <sinhf>
   28d92:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   28d96:	ed84 9a07 	vstr	s18, [r4, #28]
   28d9a:	6265      	str	r5, [r4, #36]	; 0x24
   28d9c:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   28da0:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   28da4:	ed84 8a08 	vstr	s16, [r4, #32]
   28da8:	e70d      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
		  float A = sqrtf(f->G);
   28daa:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28dae:	eddf 7a34 	vldr	s15, [pc, #208]	; 28e80 <tVZFilter_setFreq+0x39c>
		  float A = sqrtf(f->G);
   28db2:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28db6:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   28dba:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   28dbe:	eef1 7ac8 	vsqrt.f32	s15, s16
   28dc2:	ee68 8aa7 	vmul.f32	s17, s17, s15
   28dc6:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28dca:	f004 fd39 	bl	2d840 <sinhf>
   28dce:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   28dd2:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   28dd6:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   28dda:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   28dde:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   28de2:	61e3      	str	r3, [r4, #28]
   28de4:	ed84 8a08 	vstr	s16, [r4, #32]
   28de8:	e6ed      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
		  float x  = 2.0f*f->m-1.0f;
   28dea:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   28dee:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   28df2:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   28df6:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28df8:	eddf 0a1f 	vldr	s1, [pc, #124]	; 28e78 <tVZFilter_setFreq+0x394>
			f->R2 = f->invG;
   28dfc:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   28dfe:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28e02:	eef1 8a48 	vneg.f32	s17, s16
   28e06:	eeb0 0a68 	vmov.f32	s0, s17
   28e0a:	f000 ff1d 	bl	29c48 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   28e0e:	eddf 0a1a 	vldr	s1, [pc, #104]	; 28e78 <tVZFilter_setFreq+0x394>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   28e12:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   28e16:	eeb0 0a48 	vmov.f32	s0, s16
   28e1a:	f000 ff19 	bl	29c50 <minimum>
		  f->cB = 1.0f-x*x;
   28e1e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28e22:	edd4 6a07 	vldr	s13, [r4, #28]
   28e26:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   28e2a:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   28e2e:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   28e32:	ee36 5aa6 	vadd.f32	s10, s13, s13
   28e36:	edd4 8a04 	vldr	s17, [r4, #16]
   28e3a:	ee67 4aa7 	vmul.f32	s9, s15, s15
   28e3e:	ee27 6a07 	vmul.f32	s12, s14, s14
   28e42:	eea6 6aa6 	vfma.f32	s12, s13, s13
   28e46:	eea0 6a00 	vfma.f32	s12, s0, s0
   28e4a:	eea0 6a45 	vfms.f32	s12, s0, s10
   28e4e:	ee84 5a86 	vdiv.f32	s10, s9, s12
   28e52:	eeb1 6ac5 	vsqrt.f32	s12, s10
   28e56:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   28e5a:	ee66 6a86 	vmul.f32	s13, s13, s12
   28e5e:	ee27 7a06 	vmul.f32	s14, s14, s12
   28e62:	ee20 0a06 	vmul.f32	s0, s0, s12
   28e66:	edc4 6a07 	vstr	s13, [r4, #28]
   28e6a:	ed84 7a08 	vstr	s14, [r4, #32]
   28e6e:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   28e72:	e6a8      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
   28e74:	020fc0a8 	.word	0x020fc0a8
   28e78:	00000000 	.word	0x00000000
   28e7c:	40490fdb 	.word	0x40490fdb
   28e80:	3eb17218 	.word	0x3eb17218
		  f->cL = 1.0f;
   28e84:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   28e88:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   28e8c:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   28e8e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   28e92:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   28e94:	edc4 7a08 	vstr	s15, [r4, #32]
   28e98:	e695      	b.n	28bc6 <tVZFilter_setFreq+0xe2>
   28e9a:	edd4 7a05 	vldr	s15, [r4, #20]
   28e9e:	e692      	b.n	28bc6 <tVZFilter_setFreq+0xe2>

00028ea0 <tVZFilter_setFreqAndBandwidth>:
{
   28ea0:	b538      	push	{r3, r4, r5, lr}
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   28ea2:	ed9f 1ac6 	vldr	s2, [pc, #792]	; 291bc <tVZFilter_setFreqAndBandwidth+0x31c>
{
   28ea6:	4605      	mov	r5, r0
	_tVZFilter* f = *vf;
   28ea8:	6804      	ldr	r4, [r0, #0]
{
   28eaa:	ed2d 8b04 	vpush	{d8-d9}
   28eae:	eeb0 8a40 	vmov.f32	s16, s0
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   28eb2:	ed9f 0ac6 	vldr	s0, [pc, #792]	; 291cc <tVZFilter_setFreqAndBandwidth+0x32c>
   28eb6:	f000 fce7 	bl	29888 <LEAF_clip>
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28eba:	4bc1      	ldr	r3, [pc, #772]	; (291c0 <tVZFilter_setFreqAndBandwidth+0x320>)
   28ebc:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	f->B = LEAF_clip(0.0f,bw, 100.0f);
   28ec0:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
   28ec4:	ed93 1a00 	vldr	s2, [r3]
   28ec8:	eef0 0a48 	vmov.f32	s1, s16
   28ecc:	ed9f 0abf 	vldr	s0, [pc, #764]	; 291cc <tVZFilter_setFreqAndBandwidth+0x32c>
   28ed0:	ee21 1a27 	vmul.f32	s2, s2, s15
   28ed4:	f000 fcd8 	bl	29888 <LEAF_clip>
   28ed8:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
   28edc:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28ede:	eddf 7ab9 	vldr	s15, [pc, #740]	; 291c4 <tVZFilter_setFreqAndBandwidth+0x324>
   28ee2:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   28ee6:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   28eea:	ee28 8a07 	vmul.f32	s16, s16, s14
   28eee:	ee28 8a27 	vmul.f32	s16, s16, s15
   28ef2:	eeb0 0a48 	vmov.f32	s0, s16
   28ef6:	f004 f9b9 	bl	2d26c <tanf>
	  switch( f->type )
   28efa:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   28efc:	eef0 8a40 	vmov.f32	s17, s0
   28f00:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   28f04:	2b0a      	cmp	r3, #10
   28f06:	f200 81b3 	bhi.w	29270 <tVZFilter_setFreqAndBandwidth+0x3d0>
   28f0a:	e8df f013 	tbh	[pc, r3, lsl #1]
   28f0e:	0053      	.short	0x0053
   28f10:	0069005e 	.word	0x0069005e
   28f14:	00ab0074 	.word	0x00ab0074
   28f18:	011600e3 	.word	0x011600e3
   28f1c:	01610136 	.word	0x01610136
   28f20:	000b01a6 	.word	0x000b01a6
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28f24:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28f28:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28f2c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28f2e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   28f32:	ee60 0aa7 	vmul.f32	s1, s1, s15
   28f36:	f004 f85b 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   28f3a:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   28f3e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   28f42:	ed9f 7aa0 	vldr	s14, [pc, #640]	; 291c4 <tVZFilter_setFreqAndBandwidth+0x324>
   28f46:	ee67 7aa6 	vmul.f32	s15, s15, s13
   28f4a:	ee67 7a87 	vmul.f32	s15, s15, s14
   28f4e:	ee27 0a80 	vmul.f32	s0, s15, s0
   28f52:	f004 f98b 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28f56:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28f5a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   28f5e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28f62:	edc4 7a07 	vstr	s15, [r4, #28]
   28f66:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   28f6a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   28f6e:	ee20 0a00 	vmul.f32	s0, s0, s0
   28f72:	ee77 7ac0 	vsub.f32	s15, s15, s0
   28f76:	ee20 0a07 	vmul.f32	s0, s0, s14
   28f7a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   28f7e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   28f82:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28f86:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28f8a:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   28f8e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   28f92:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   28f96:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   28f9a:	ee77 7aa8 	vadd.f32	s15, s15, s17
   28f9e:	eef0 6a47 	vmov.f32	s13, s14
   28fa2:	eee7 6aa8 	vfma.f32	s13, s15, s17
   28fa6:	eec7 7a26 	vdiv.f32	s15, s14, s13
   28faa:	edc4 7a06 	vstr	s15, [r4, #24]
}
   28fae:	ecbd 8b04 	vpop	{d8-d9}
   28fb2:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28fb4:	2300      	movs	r3, #0
   28fb6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28fba:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28fbe:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   28fc0:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   28fc4:	61e3      	str	r3, [r4, #28]
   28fc6:	6223      	str	r3, [r4, #32]
   28fc8:	e7e5      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28fca:	2300      	movs	r3, #0
   28fcc:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28fd0:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28fd4:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   28fd6:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   28fda:	6223      	str	r3, [r4, #32]
   28fdc:	6263      	str	r3, [r4, #36]	; 0x24
   28fde:	e7da      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28fe0:	2300      	movs	r3, #0
   28fe2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   28fe6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28fea:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   28fec:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   28ff0:	61e3      	str	r3, [r4, #28]
   28ff2:	6263      	str	r3, [r4, #36]	; 0x24
   28ff4:	e7cf      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   28ff6:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   28ffa:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   28ffe:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   29000:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   29004:	ee60 0aa7 	vmul.f32	s1, s1, s15
   29008:	f003 fff2 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2900c:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   29010:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   29014:	ed9f 7a6b 	vldr	s14, [pc, #428]	; 291c4 <tVZFilter_setFreqAndBandwidth+0x324>
   29018:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2901c:	ee67 7a87 	vmul.f32	s15, s15, s14
   29020:	ee27 0a80 	vmul.f32	s0, s15, s0
   29024:	f004 f922 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29028:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2902c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   29030:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29032:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   29036:	61e3      	str	r3, [r4, #28]
   29038:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2903a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   2903e:	ee20 0a00 	vmul.f32	s0, s0, s0
   29042:	ee77 7ac0 	vsub.f32	s15, s15, s0
   29046:	ee20 0a07 	vmul.f32	s0, s0, s14
   2904a:	ee67 7aa7 	vmul.f32	s15, s15, s15
   2904e:	ee87 7a80 	vdiv.f32	s14, s15, s0
   29052:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   29056:	ee77 7aa7 	vadd.f32	s15, s15, s15
   2905a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   2905e:	edc4 7a08 	vstr	s15, [r4, #32]
   29062:	e798      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   29064:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   29068:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   2906c:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2906e:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   29072:	ee60 0aa7 	vmul.f32	s1, s1, s15
   29076:	f003 ffbb 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   2907a:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   2907e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   29082:	ed9f 7a50 	vldr	s14, [pc, #320]	; 291c4 <tVZFilter_setFreqAndBandwidth+0x324>
   29086:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2908a:	ee67 7a87 	vmul.f32	s15, s15, s14
   2908e:	ee27 0a80 	vmul.f32	s0, s15, s0
   29092:	f004 f8eb 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29096:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   2909a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2909e:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   290a0:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   290a4:	6223      	str	r3, [r4, #32]
   290a6:	edc4 7a07 	vstr	s15, [r4, #28]
   290aa:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   290ae:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   290b2:	ee20 0a00 	vmul.f32	s0, s0, s0
   290b6:	ee77 7ac0 	vsub.f32	s15, s15, s0
   290ba:	ee20 0a07 	vmul.f32	s0, s0, s14
   290be:	ee67 7aa7 	vmul.f32	s15, s15, s15
   290c2:	ee87 7a80 	vdiv.f32	s14, s15, s0
   290c6:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   290ca:	ee77 7aa7 	vadd.f32	s15, s15, s15
   290ce:	edc4 7a05 	vstr	s15, [r4, #20]
   290d2:	e760      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   290d4:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   290d8:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   290dc:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   290e0:	ee60 0aa7 	vmul.f32	s1, s1, s15
   290e4:	f003 ff84 	bl	2cff0 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   290e8:	ee28 0a00 	vmul.f32	s0, s16, s0
   290ec:	f004 f8be 	bl	2d26c <tanf>
			float r  = f->g/wl;
   290f0:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   290f4:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   290f8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   290fc:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   29100:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   29104:	edc4 7a07 	vstr	s15, [r4, #28]
   29108:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   2910c:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   29110:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   29114:	eee0 7a00 	vfma.f32	s15, s0, s0
   29118:	ee87 6a80 	vdiv.f32	s12, s15, s0
   2911c:	ee76 7a65 	vsub.f32	s15, s12, s11
   29120:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   29124:	eef1 7ac6 	vsqrt.f32	s15, s12
   29128:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   2912c:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   29130:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   29134:	ed84 7a08 	vstr	s14, [r4, #32]
   29138:	e72d      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
			float A = sqrtf(f->G);
   2913a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2913e:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29142:	eddf 7a21 	vldr	s15, [pc, #132]	; 291c8 <tVZFilter_setFreqAndBandwidth+0x328>
			float A = sqrtf(f->G);
   29146:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2914a:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   2914e:	ee20 0a27 	vmul.f32	s0, s0, s15
   29152:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   29156:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   2915a:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   2915e:	f004 fb6f 	bl	2d840 <sinhf>
   29162:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   29166:	ed84 9a07 	vstr	s18, [r4, #28]
   2916a:	6265      	str	r5, [r4, #36]	; 0x24
   2916c:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29170:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   29174:	ed84 8a08 	vstr	s16, [r4, #32]
   29178:	e70d      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
		  float A = sqrtf(f->G);
   2917a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2917e:	eddf 7a12 	vldr	s15, [pc, #72]	; 291c8 <tVZFilter_setFreqAndBandwidth+0x328>
		  float A = sqrtf(f->G);
   29182:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29186:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   2918a:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2918e:	eef1 7ac8 	vsqrt.f32	s15, s16
   29192:	ee68 8aa7 	vmul.f32	s17, s17, s15
   29196:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2919a:	f004 fb51 	bl	2d840 <sinhf>
   2919e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   291a2:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   291a6:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   291aa:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   291ae:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   291b2:	61e3      	str	r3, [r4, #28]
   291b4:	ed84 8a08 	vstr	s16, [r4, #32]
   291b8:	e6ed      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
   291ba:	bf00      	nop
   291bc:	42c80000 	.word	0x42c80000
   291c0:	020fc0a8 	.word	0x020fc0a8
   291c4:	40490fdb 	.word	0x40490fdb
   291c8:	3eb17218 	.word	0x3eb17218
   291cc:	00000000 	.word	0x00000000
		  float x  = 2.0f*f->m-1.0f;
   291d0:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   291d4:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   291d8:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   291dc:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   291de:	ed5f 0a05 	vldr	s1, [pc, #-20]	; 291cc <tVZFilter_setFreqAndBandwidth+0x32c>
			f->R2 = f->invG;
   291e2:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   291e4:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   291e8:	eef1 8a48 	vneg.f32	s17, s16
   291ec:	eeb0 0a68 	vmov.f32	s0, s17
   291f0:	f000 fd2a 	bl	29c48 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   291f4:	ed5f 0a0b 	vldr	s1, [pc, #-44]	; 291cc <tVZFilter_setFreqAndBandwidth+0x32c>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   291f8:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   291fc:	eeb0 0a48 	vmov.f32	s0, s16
   29200:	f000 fd26 	bl	29c50 <minimum>
		  f->cB = 1.0f-x*x;
   29204:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   29208:	edd4 6a07 	vldr	s13, [r4, #28]
   2920c:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   29210:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   29214:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   29218:	ee36 5aa6 	vadd.f32	s10, s13, s13
   2921c:	edd4 8a04 	vldr	s17, [r4, #16]
   29220:	ee67 4aa7 	vmul.f32	s9, s15, s15
   29224:	ee27 6a07 	vmul.f32	s12, s14, s14
   29228:	eea6 6aa6 	vfma.f32	s12, s13, s13
   2922c:	eea0 6a00 	vfma.f32	s12, s0, s0
   29230:	eea0 6a45 	vfms.f32	s12, s0, s10
   29234:	ee84 5a86 	vdiv.f32	s10, s9, s12
   29238:	eeb1 6ac5 	vsqrt.f32	s12, s10
   2923c:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   29240:	ee66 6a86 	vmul.f32	s13, s13, s12
   29244:	ee27 7a06 	vmul.f32	s14, s14, s12
   29248:	ee20 0a06 	vmul.f32	s0, s0, s12
   2924c:	edc4 6a07 	vstr	s13, [r4, #28]
   29250:	ed84 7a08 	vstr	s14, [r4, #32]
   29254:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   29258:	e69d      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
		  f->cL = 1.0f;
   2925a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2925e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   29262:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   29264:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   29268:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   2926a:	edc4 7a08 	vstr	s15, [r4, #32]
   2926e:	e692      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
   29270:	edd4 7a05 	vldr	s15, [r4, #20]
   29274:	e68f      	b.n	28f96 <tVZFilter_setFreqAndBandwidth+0xf6>
   29276:	bf00      	nop

00029278 <tVZFilter_setGain>:
{
   29278:	b538      	push	{r3, r4, r5, lr}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2927a:	eef0 0a40 	vmov.f32	s1, s0
   2927e:	ed9f 1ae3 	vldr	s2, [pc, #908]	; 2960c <tVZFilter_setGain+0x394>
   29282:	ed9f 0ae3 	vldr	s0, [pc, #908]	; 29610 <tVZFilter_setGain+0x398>
{
   29286:	4605      	mov	r5, r0
	_tVZFilter* f = *vf;
   29288:	6804      	ldr	r4, [r0, #0]
{
   2928a:	ed2d 8b04 	vpush	{d8-d9}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   2928e:	f000 fafb 	bl	29888 <LEAF_clip>
	f->invG = 1.0f/f->G;
   29292:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
   29296:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   2929a:	eddf 7ade 	vldr	s15, [pc, #888]	; 29614 <tVZFilter_setGain+0x39c>
	f->invG = 1.0f/f->G;
   2929e:	ee86 7a80 	vdiv.f32	s14, s13, s0
   292a2:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
	_tVZFilter* f = *vf;
   292a6:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   292a8:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
   292ac:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
   292b0:	ee28 8a07 	vmul.f32	s16, s16, s14
   292b4:	ee28 8a27 	vmul.f32	s16, s16, s15
   292b8:	eeb0 0a48 	vmov.f32	s0, s16
   292bc:	f003 ffd6 	bl	2d26c <tanf>
	  switch( f->type )
   292c0:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
   292c2:	eef0 8a40 	vmov.f32	s17, s0
   292c6:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
   292ca:	2b0a      	cmp	r3, #10
   292cc:	f200 81b3 	bhi.w	29636 <tVZFilter_setGain+0x3be>
   292d0:	e8df f013 	tbh	[pc, r3, lsl #1]
   292d4:	005e0053 	.word	0x005e0053
   292d8:	00740069 	.word	0x00740069
   292dc:	00e300ab 	.word	0x00e300ab
   292e0:	01360116 	.word	0x01360116
   292e4:	01a60156 	.word	0x01a60156
   292e8:	000b      	.short	0x000b
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   292ea:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   292ee:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   292f2:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   292f4:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   292f8:	ee60 0aa7 	vmul.f32	s1, s1, s15
   292fc:	f003 fe78 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   29300:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   29304:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   29308:	ed9f 7ac2 	vldr	s14, [pc, #776]	; 29614 <tVZFilter_setGain+0x39c>
   2930c:	ee67 7aa6 	vmul.f32	s15, s15, s13
   29310:	ee67 7a87 	vmul.f32	s15, s15, s14
   29314:	ee27 0a80 	vmul.f32	s0, s15, s0
   29318:	f003 ffa8 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2931c:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29320:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29324:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   29328:	edc4 7a07 	vstr	s15, [r4, #28]
   2932c:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29330:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   29334:	ee20 0a00 	vmul.f32	s0, s0, s0
   29338:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2933c:	ee20 0a07 	vmul.f32	s0, s0, s14
   29340:	ee67 7aa7 	vmul.f32	s15, s15, s15
   29344:	ee87 7a80 	vdiv.f32	s14, s15, s0
   29348:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2934c:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   29350:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   29354:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
   29358:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
   2935c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   29360:	ee77 7aa8 	vadd.f32	s15, s15, s17
   29364:	eef0 6a47 	vmov.f32	s13, s14
   29368:	eee7 6aa8 	vfma.f32	s13, s15, s17
   2936c:	eec7 7a26 	vdiv.f32	s15, s14, s13
   29370:	edc4 7a06 	vstr	s15, [r4, #24]
}
   29374:	ecbd 8b04 	vpop	{d8-d9}
   29378:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2937a:	2300      	movs	r3, #0
   2937c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   29380:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   29384:	6262      	str	r2, [r4, #36]	; 0x24
			f->R2 = f->invG;
   29386:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
   2938a:	61e3      	str	r3, [r4, #28]
   2938c:	6223      	str	r3, [r4, #32]
   2938e:	e7e5      	b.n	2935c <tVZFilter_setGain+0xe4>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   29390:	2300      	movs	r3, #0
   29392:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   29396:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   2939a:	61e2      	str	r2, [r4, #28]
			f->R2 = f->invG;
   2939c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
   293a0:	6223      	str	r3, [r4, #32]
   293a2:	6263      	str	r3, [r4, #36]	; 0x24
   293a4:	e7da      	b.n	2935c <tVZFilter_setGain+0xe4>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   293a6:	2300      	movs	r3, #0
   293a8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
   293ac:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   293b0:	6222      	str	r2, [r4, #32]
			f->R2 = f->invG;
   293b2:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
   293b6:	61e3      	str	r3, [r4, #28]
   293b8:	6263      	str	r3, [r4, #36]	; 0x24
   293ba:	e7cf      	b.n	2935c <tVZFilter_setGain+0xe4>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   293bc:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   293c0:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   293c4:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   293c6:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   293ca:	ee60 0aa7 	vmul.f32	s1, s1, s15
   293ce:	f003 fe0f 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   293d2:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   293d6:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   293da:	ed9f 7a8e 	vldr	s14, [pc, #568]	; 29614 <tVZFilter_setGain+0x39c>
   293de:	ee67 7aa6 	vmul.f32	s15, s15, s13
   293e2:	ee67 7a87 	vmul.f32	s15, s15, s14
   293e6:	ee27 0a80 	vmul.f32	s0, s15, s0
   293ea:	f003 ff3f 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   293ee:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   293f2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   293f6:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   293f8:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   293fc:	61e3      	str	r3, [r4, #28]
   293fe:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29400:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   29404:	ee20 0a00 	vmul.f32	s0, s0, s0
   29408:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2940c:	ee20 0a07 	vmul.f32	s0, s0, s14
   29410:	ee67 7aa7 	vmul.f32	s15, s15, s15
   29414:	ee87 7a80 	vdiv.f32	s14, s15, s0
   29418:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   2941c:	ee77 7aa7 	vadd.f32	s15, s15, s15
   29420:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
   29424:	edc4 7a08 	vstr	s15, [r4, #32]
   29428:	e798      	b.n	2935c <tVZFilter_setGain+0xe4>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   2942a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2942e:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
   29432:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
   29434:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   29438:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2943c:	f003 fdd8 	bl	2cff0 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   29440:	edd5 6a10 	vldr	s13, [r5, #64]	; 0x40
   29444:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
   29448:	ed9f 7a72 	vldr	s14, [pc, #456]	; 29614 <tVZFilter_setGain+0x39c>
   2944c:	ee67 7aa6 	vmul.f32	s15, s15, s13
   29450:	ee67 7a87 	vmul.f32	s15, s15, s14
   29454:	ee27 0a80 	vmul.f32	s0, s15, s0
   29458:	f003 ff08 	bl	2d26c <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   2945c:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29460:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   29464:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
   29466:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
   2946a:	6223      	str	r3, [r4, #32]
   2946c:	edc4 7a07 	vstr	s15, [r4, #28]
   29470:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
   29474:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
   29478:	ee20 0a00 	vmul.f32	s0, s0, s0
   2947c:	ee77 7ac0 	vsub.f32	s15, s15, s0
   29480:	ee20 0a07 	vmul.f32	s0, s0, s14
   29484:	ee67 7aa7 	vmul.f32	s15, s15, s15
   29488:	ee87 7a80 	vdiv.f32	s14, s15, s0
   2948c:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
   29490:	ee77 7aa7 	vadd.f32	s15, s15, s15
   29494:	edc4 7a05 	vstr	s15, [r4, #20]
   29498:	e760      	b.n	2935c <tVZFilter_setGain+0xe4>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
   2949a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2949e:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
   294a2:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   294a6:	ee60 0aa7 	vmul.f32	s1, s1, s15
   294aa:	f003 fda1 	bl	2cff0 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
   294ae:	ee28 0a00 	vmul.f32	s0, s16, s0
   294b2:	f003 fedb 	bl	2d26c <tanf>
			float r  = f->g/wl;
   294b6:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   294ba:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
   294be:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   294c2:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
   294c6:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   294ca:	edc4 7a07 	vstr	s15, [r4, #28]
   294ce:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   294d2:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
   294d6:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   294da:	eee0 7a00 	vfma.f32	s15, s0, s0
   294de:	ee87 6a80 	vdiv.f32	s12, s15, s0
   294e2:	ee76 7a65 	vsub.f32	s15, s12, s11
   294e6:	ee87 6aa6 	vdiv.f32	s12, s15, s13
   294ea:	eef1 7ac6 	vsqrt.f32	s15, s12
   294ee:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   294f2:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
   294f6:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
   294fa:	ed84 7a08 	vstr	s14, [r4, #32]
   294fe:	e72d      	b.n	2935c <tVZFilter_setGain+0xe4>
			float A = sqrtf(f->G);
   29500:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   29504:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29508:	eddf 7a43 	vldr	s15, [pc, #268]	; 29618 <tVZFilter_setGain+0x3a0>
			float A = sqrtf(f->G);
   2950c:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29510:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   29514:	ee20 0a27 	vmul.f32	s0, s0, s15
   29518:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   2951c:	eec8 8aa7 	vdiv.f32	s17, s17, s15
   29520:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29524:	f004 f98c 	bl	2d840 <sinhf>
   29528:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2952c:	ed84 9a07 	vstr	s18, [r4, #28]
   29530:	6265      	str	r5, [r4, #36]	; 0x24
   29532:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
   29536:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
   2953a:	ed84 8a08 	vstr	s16, [r4, #32]
   2953e:	e70d      	b.n	2935c <tVZFilter_setGain+0xe4>
		  float A = sqrtf(f->G);
   29540:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29544:	eddf 7a34 	vldr	s15, [pc, #208]	; 29618 <tVZFilter_setGain+0x3a0>
		  float A = sqrtf(f->G);
   29548:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   2954c:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   29550:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
   29554:	eef1 7ac8 	vsqrt.f32	s15, s16
   29558:	ee68 8aa7 	vmul.f32	s17, s17, s15
   2955c:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29560:	f004 f96e 	bl	2d840 <sinhf>
   29564:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   29568:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2956c:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
   29570:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
   29574:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
   29578:	61e3      	str	r3, [r4, #28]
   2957a:	ed84 8a08 	vstr	s16, [r4, #32]
   2957e:	e6ed      	b.n	2935c <tVZFilter_setGain+0xe4>
		  float x  = 2.0f*f->m-1.0f;
   29580:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   29584:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
   29588:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
   2958c:	6b23      	ldr	r3, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   2958e:	eddf 0a23 	vldr	s1, [pc, #140]	; 2961c <tVZFilter_setGain+0x3a4>
			f->R2 = f->invG;
   29592:	6163      	str	r3, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
   29594:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   29598:	eef1 8a48 	vneg.f32	s17, s16
   2959c:	eeb0 0a68 	vmov.f32	s0, s17
   295a0:	f000 fb52 	bl	29c48 <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   295a4:	eddf 0a1d 	vldr	s1, [pc, #116]	; 2961c <tVZFilter_setGain+0x3a4>
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
   295a8:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
   295ac:	eeb0 0a48 	vmov.f32	s0, s16
   295b0:	f000 fb4e 	bl	29c50 <minimum>
		  f->cB = 1.0f-x*x;
   295b4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   295b8:	edd4 6a07 	vldr	s13, [r4, #28]
   295bc:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
   295c0:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
   295c4:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
   295c8:	ee36 5aa6 	vadd.f32	s10, s13, s13
   295cc:	edd4 8a04 	vldr	s17, [r4, #16]
   295d0:	ee67 4aa7 	vmul.f32	s9, s15, s15
   295d4:	ee27 6a07 	vmul.f32	s12, s14, s14
   295d8:	eea6 6aa6 	vfma.f32	s12, s13, s13
   295dc:	eea0 6a00 	vfma.f32	s12, s0, s0
   295e0:	eea0 6a45 	vfms.f32	s12, s0, s10
   295e4:	ee84 5a86 	vdiv.f32	s10, s9, s12
   295e8:	eeb1 6ac5 	vsqrt.f32	s12, s10
   295ec:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
   295f0:	ee66 6a86 	vmul.f32	s13, s13, s12
   295f4:	ee27 7a06 	vmul.f32	s14, s14, s12
   295f8:	ee20 0a06 	vmul.f32	s0, s0, s12
   295fc:	edc4 6a07 	vstr	s13, [r4, #28]
   29600:	ed84 7a08 	vstr	s14, [r4, #32]
   29604:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
   29608:	e6a8      	b.n	2935c <tVZFilter_setGain+0xe4>
   2960a:	bf00      	nop
   2960c:	42c80000 	.word	0x42c80000
   29610:	358637bd 	.word	0x358637bd
   29614:	40490fdb 	.word	0x40490fdb
   29618:	3eb17218 	.word	0x3eb17218
   2961c:	00000000 	.word	0x00000000
		  f->cL = 1.0f;
   29620:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   29624:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
   29628:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
   2962a:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
   2962e:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
   29630:	edc4 7a08 	vstr	s15, [r4, #32]
   29634:	e692      	b.n	2935c <tVZFilter_setGain+0xe4>
   29636:	edd4 7a05 	vldr	s15, [r4, #20]
   2963a:	e68f      	b.n	2935c <tVZFilter_setGain+0xe4>

0002963c <interpolate3max>:
    return(Y);
}

float interpolate3max(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
   2963c:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float realpeak;
    
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
   29640:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
   29644:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    float a = buf[peakindex-1];
   29648:	440b      	add	r3, r1
   2964a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2964e:	edd0 7a00 	vldr	s15, [r0]
    float c = buf[peakindex+1];
   29652:	ed90 6a02 	vldr	s12, [r0, #8]
    float b = buf[peakindex];
   29656:	edd0 6a01 	vldr	s13, [r0, #4]
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
   2965a:	ee36 7a67 	vsub.f32	s14, s12, s15
   2965e:	eed6 7a85 	vfnms.f32	s15, s13, s10
   29662:	ee27 7a07 	vmul.f32	s14, s14, s14
   29666:	ee27 7a25 	vmul.f32	s14, s14, s11
   2966a:	ee77 7ac6 	vsub.f32	s15, s15, s12
   2966e:	ee87 0a27 	vdiv.f32	s0, s14, s15
    
    return(realpeak);
}
   29672:	ee30 0a26 	vadd.f32	s0, s0, s13
   29676:	4770      	bx	lr

00029678 <interpolate3phase>:

float interpolate3phase(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
   29678:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float fraction;
    
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2967c:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   29680:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    float a = buf[peakindex-1];
   29684:	440b      	add	r3, r1
   29686:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2968a:	edd0 7a00 	vldr	s15, [r0]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2968e:	edd0 5a01 	vldr	s11, [r0, #4]
   29692:	eeb0 0a67 	vmov.f32	s0, s15
    float c = buf[peakindex+1];
   29696:	ed90 7a02 	vldr	s14, [r0, #8]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
   2969a:	ee77 7a67 	vsub.f32	s15, s14, s15
   2969e:	ee95 0a86 	vfnms.f32	s0, s11, s12
   296a2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   296a6:	ee30 0a47 	vsub.f32	s0, s0, s14
    
    return(fraction);
}
   296aa:	ee87 0a80 	vdiv.f32	s0, s15, s0
   296ae:	4770      	bx	lr

000296b0 <fastercosf>:
    return fResult;
}

float fastercosf(float fAngle)
{
    float fASqr = fAngle*fAngle;
   296b0:	ee20 7a00 	vmul.f32	s14, s0, s0
    float fResult = 3.705e-02f;
    fResult *= fASqr;
    fResult -= 4.967e-01f;
   296b4:	eddf 6a05 	vldr	s13, [pc, #20]	; 296cc <fastercosf+0x1c>
   296b8:	eddf 7a05 	vldr	s15, [pc, #20]	; 296d0 <fastercosf+0x20>
    fResult *= fASqr;
    fResult += 1.0f;
   296bc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fResult -= 4.967e-01f;
   296c0:	eee7 7a26 	vfma.f32	s15, s14, s13
    return fResult;
}
   296c4:	eea7 0a27 	vfma.f32	s0, s14, s15
   296c8:	4770      	bx	lr
   296ca:	bf00      	nop
   296cc:	3d17c1be 	.word	0x3d17c1be
   296d0:	befe4f76 	.word	0xbefe4f76

000296d4 <fastabsf>:
        unsigned int ui;
    }alias;
    
    alias.f = f;
    alias.ui &= 0x7fffffff;
    return alias.f;
   296d4:	ee10 3a10 	vmov	r3, s0
   296d8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
}
   296dc:	ee00 3a10 	vmov	s0, r3
   296e0:	4770      	bx	lr
   296e2:	bf00      	nop

000296e4 <fastexp2f>:

// fast floating-point exp2 function taken from Robert Bristow Johnson's
// post in the music-dsp list on Date: Tue, 02 Sep 2014 16:50:11 -0400
float fastexp2f(float x)
{
    if (x >= -127.0)
   296e4:	eddf 7a1f 	vldr	s15, [pc, #124]	; 29764 <fastexp2f+0x80>
   296e8:	eeb4 0ae7 	vcmpe.f32	s0, s15
   296ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   296f0:	db34      	blt.n	2975c <fastexp2f+0x78>
    {
        float accumulator, xPower;
        union {float f; int32_t i;} xBits;
        
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   296f2:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 29768 <fastexp2f+0x84>
        xPower = x*x;
        accumulator += 0.24137976293709f*xPower;
        xPower *= x;
        accumulator += 0.05203236900844f*xPower;
        xPower *= x;
        accumulator += 0.01355574723481f*xPower;
   296f6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   296fa:	eddf 4a1c 	vldr	s9, [pc, #112]	; 2976c <fastexp2f+0x88>
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   296fe:	ee30 7a07 	vadd.f32	s14, s0, s14
        accumulator += 0.01355574723481f*xPower;
   29702:	eddf 5a1b 	vldr	s11, [pc, #108]	; 29770 <fastexp2f+0x8c>
   29706:	ed9f 6a1b 	vldr	s12, [pc, #108]	; 29774 <fastexp2f+0x90>
   2970a:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 29778 <fastexp2f+0x94>
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
   2970e:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   29712:	ee17 3a10 	vmov	r3, s14
   29716:	f5a3 5280 	sub.w	r2, r3, #4096	; 0x1000
   2971a:	ee07 2a10 	vmov	s14, r2
        
        xBits.i += 127;                                                    /* bias integer part */
   2971e:	f46f 6278 	mvn.w	r2, #3968	; 0xf80
        x -= (float)(xBits.i);                                             /* fractional part */
   29722:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
        xBits.i += 127;                                                    /* bias integer part */
   29726:	4413      	add	r3, r2
        xBits.i<<= 23;                                                     /* move biased int part into exponent bits */
   29728:	05db      	lsls	r3, r3, #23
        x -= (float)(xBits.i);                                             /* fractional part */
   2972a:	ee30 7a47 	vsub.f32	s14, s0, s14
        xPower = x*x;
   2972e:	ee67 6a07 	vmul.f32	s13, s14, s14
        accumulator += 0.01355574723481f*xPower;
   29732:	eee6 7aa4 	vfma.f32	s15, s13, s9
   29736:	eeb0 0a67 	vmov.f32	s0, s15
        xPower *= x;
   2973a:	ee67 7a26 	vmul.f32	s15, s14, s13
        accumulator += 0.01355574723481f*xPower;
   2973e:	eef0 6a46 	vmov.f32	s13, s12
   29742:	eea7 0aa5 	vfma.f32	s0, s15, s11
   29746:	eee7 6a85 	vfma.f32	s13, s15, s10
   2974a:	eef0 7a40 	vmov.f32	s15, s0
   2974e:	eee7 7a26 	vfma.f32	s15, s14, s13
        
        return accumulator * xBits.f;
   29752:	ee07 3a10 	vmov	s14, r3
   29756:	ee27 0a87 	vmul.f32	s0, s15, s14
   2975a:	4770      	bx	lr
    }
    else
    {
        return 0.0f;
   2975c:	ed9f 0a07 	vldr	s0, [pc, #28]	; 2977c <fastexp2f+0x98>
    }
}
   29760:	4770      	bx	lr
   29762:	bf00      	nop
   29764:	c2fe0000 	.word	0xc2fe0000
   29768:	45800000 	.word	0x45800000
   2976c:	3e772c42 	.word	0x3e772c42
   29770:	3d551fe5 	.word	0x3d551fe5
   29774:	3f316a8e 	.word	0x3f316a8e
   29778:	3c5e18ed 	.word	0x3c5e18ed
   2977c:	00000000 	.word	0x00000000

00029780 <LEAF_crossfade>:
 when t = 0, volumes[0] = 0.707, volumes[1] = 0.707 (equal-power cross fade)
 when t = 1, volumes[0] = 1, volumes[1] = 0
 */

void LEAF_crossfade(float fade, float* volumes) {
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29780:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29784:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   29788:	ee30 7a27 	vadd.f32	s14, s0, s15
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2978c:	ee77 7ac0 	vsub.f32	s15, s15, s0
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29790:	ee27 7a26 	vmul.f32	s14, s14, s13
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   29794:	ee67 7aa6 	vmul.f32	s15, s15, s13
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   29798:	eef1 6ac7 	vsqrt.f32	s13, s14
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   2979c:	eeb1 7ae7 	vsqrt.f32	s14, s15
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
   297a0:	edc0 6a00 	vstr	s13, [r0]
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
   297a4:	ed80 7a01 	vstr	s14, [r0, #4]
}
   297a8:	4770      	bx	lr
   297aa:	bf00      	nop

000297ac <LEAF_frequencyToMidi>:
}
#endif

float LEAF_frequencyToMidi(float f)
{
    return (69.0f + 12.0f * log2f(f * INV_440));
   297ac:	eddf 7a07 	vldr	s15, [pc, #28]	; 297cc <LEAF_frequencyToMidi+0x20>
{
   297b0:	b508      	push	{r3, lr}
    return (69.0f + 12.0f * log2f(f * INV_440));
   297b2:	ee20 0a27 	vmul.f32	s0, s0, s15
   297b6:	f003 fb9b 	bl	2cef0 <log2f>
   297ba:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
   297be:	eddf 7a04 	vldr	s15, [pc, #16]	; 297d0 <LEAF_frequencyToMidi+0x24>
}
   297c2:	eee0 7a07 	vfma.f32	s15, s0, s14
   297c6:	eeb0 0a67 	vmov.f32	s0, s15
   297ca:	bd08      	pop	{r3, pc}
   297cc:	3b14f209 	.word	0x3b14f209
   297d0:	428a0000 	.word	0x428a0000

000297d4 <LEAF_shaper>:

// Jones shaper
float LEAF_shaper(float input, float m_drive)
{
    float fx = input * 2.0f;    // prescale
   297d4:	ee30 0a00 	vadd.f32	s0, s0, s0
   297d8:	eddf 6a1a 	vldr	s13, [pc, #104]	; 29844 <LEAF_shaper+0x70>
   297dc:	eddf 7a1a 	vldr	s15, [pc, #104]	; 29848 <LEAF_shaper+0x74>
    
    xc = LEAF_clip(-SQRT8, fx, SQRT8);
    xc2 = xc*xc;
    c = 0.5f*fx*(3.0f - (xc2));
    xc4 = xc2 * xc2;
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   297e0:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   297e4:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   297e8:	ed9f 4a18 	vldr	s8, [pc, #96]	; 2984c <LEAF_shaper+0x78>
   297ec:	fec0 7a67 	vminnm.f32	s15, s0, s15
   297f0:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
    xc2 = xc*xc;
   297f4:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   297f8:	eddf 4a15 	vldr	s9, [pc, #84]	; 29850 <LEAF_shaper+0x7c>
   297fc:	ee20 6a06 	vmul.f32	s12, s0, s12
    shaperOut *= 0.5f;    // post_scale
   29800:	ed9f 5a14 	vldr	s10, [pc, #80]	; 29854 <LEAF_shaper+0x80>
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   29804:	eef6 6a08 	vmov.f32	s13, #104	; 0x3f400000  0.750
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   29808:	ee67 3aa7 	vmul.f32	s7, s15, s15
   2980c:	ee27 7a67 	vnmul.f32	s14, s14, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   29810:	ee27 0aa4 	vmul.f32	s0, s15, s9
    c = 0.5f*fx*(3.0f - (xc2));
   29814:	eef0 5a08 	vmov.f32	s11, #8	; 0x40400000  3.0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   29818:	eea3 7a84 	vfma.f32	s14, s7, s8
   2981c:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    c = 0.5f*fx*(3.0f - (xc2));
   29820:	ee75 5ae7 	vsub.f32	s11, s11, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   29824:	ee70 0aa6 	vadd.f32	s1, s1, s13
   29828:	eef0 7a40 	vmov.f32	s15, s0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
   2982c:	ee37 7a24 	vadd.f32	s14, s14, s9
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
   29830:	eee5 7a86 	vfma.f32	s15, s11, s12
    shaperOut *= 0.5f;    // post_scale
   29834:	ee20 0a85 	vmul.f32	s0, s1, s10
   29838:	ee27 0a00 	vmul.f32	s0, s14, s0
    return shaperOut;
}
   2983c:	ee20 0a27 	vmul.f32	s0, s0, s15
   29840:	4770      	bx	lr
   29842:	bf00      	nop
   29844:	c03504f3 	.word	0xc03504f3
   29848:	403504f3 	.word	0x403504f3
   2984c:	3c800000 	.word	0x3c800000
   29850:	3d4ccccd 	.word	0x3d4ccccd
   29854:	3f272f05 	.word	0x3f272f05

00029858 <LEAF_round>:

// round input to nearest rnd
float LEAF_round (float input, float rnd)
{
    rnd = fabsf(rnd);
   29858:	eef0 0ae0 	vabs.f32	s1, s1
    
    if (rnd <= 0.0000001f) return input;
   2985c:	eddf 7a06 	vldr	s15, [pc, #24]	; 29878 <LEAF_round+0x20>
   29860:	eef4 0ae7 	vcmpe.f32	s1, s15
   29864:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29868:	d905      	bls.n	29876 <LEAF_round+0x1e>
    
    float scale = 1.f / rnd;
    
    return roundf(input * scale) / scale;
   2986a:	eec0 7a20 	vdiv.f32	s15, s0, s1
   2986e:	feb8 0a67 	vrinta.f32	s0, s15
   29872:	ee20 0a20 	vmul.f32	s0, s0, s1
}
   29876:	4770      	bx	lr
   29878:	33d6bf95 	.word	0x33d6bf95

0002987c <LEAF_bitwise_xor>:
{
    union unholy_t unholy;
    unholy.f = input;
    unholy.i = (unholy.i ^ op);
    
    return unholy.f;
   2987c:	ee10 3a10 	vmov	r3, s0
   29880:	4058      	eors	r0, r3
}
   29882:	ee00 0a10 	vmov	s0, r0
   29886:	4770      	bx	lr

00029888 <LEAF_clip>:

float   LEAF_clip(float min, float val, float max)
{
    float tempmin = min;
    float tempmax = max;
    if (min > max)
   29888:	eeb4 0ac1 	vcmpe.f32	s0, s2
   2988c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29890:	dd05      	ble.n	2989e <LEAF_clip+0x16>
   29892:	eef0 7a40 	vmov.f32	s15, s0
    {
        tempmin = max;
   29896:	eeb0 0a41 	vmov.f32	s0, s2
        tempmax = min;
   2989a:	eeb0 1a67 	vmov.f32	s2, s15
    }
    if (val < tempmin)
   2989e:	eeb4 0ae0 	vcmpe.f32	s0, s1
   298a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   298a6:	dc01      	bgt.n	298ac <LEAF_clip+0x24>
   298a8:	fe81 0a60 	vminnm.f32	s0, s2, s1
    }
    else
    {
        return val;
    }
}
   298ac:	4770      	bx	lr
   298ae:	bf00      	nop

000298b0 <LEAF_clipInt>:

int   LEAF_clipInt(int min, int val, int max)
{
    int tempmin = min;
    int tempmax = max;
    if (min > max)
   298b0:	4290      	cmp	r0, r2
   298b2:	dd02      	ble.n	298ba <LEAF_clipInt+0xa>
   298b4:	4603      	mov	r3, r0
   298b6:	4610      	mov	r0, r2
   298b8:	461a      	mov	r2, r3
    {
        tempmin = max;
        tempmax = min;
    }
    if (val < tempmin) {
   298ba:	4288      	cmp	r0, r1
   298bc:	dc03      	bgt.n	298c6 <LEAF_clipInt+0x16>
   298be:	428a      	cmp	r2, r1
   298c0:	bfa8      	it	ge
   298c2:	460a      	movge	r2, r1
   298c4:	4610      	mov	r0, r2
    } else if (val > tempmax) {
        return tempmax;
    } else {
        return val;
    }
}
   298c6:	4770      	bx	lr

000298c8 <LEAF_isPrime>:

int     LEAF_isPrime(uint64_t number )
{
    if ( number == 2 ) return 1;
   298c8:	2900      	cmp	r1, #0
   298ca:	bf08      	it	eq
   298cc:	2802      	cmpeq	r0, #2
   298ce:	d029      	beq.n	29924 <LEAF_isPrime+0x5c>
{
   298d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if ( number & 1 ) {
   298d4:	f000 0401 	and.w	r4, r0, #1
   298d8:	2500      	movs	r5, #0
   298da:	4606      	mov	r6, r0
   298dc:	ea54 0305 	orrs.w	r3, r4, r5
   298e0:	d01d      	beq.n	2991e <LEAF_isPrime+0x56>
   298e2:	460f      	mov	r7, r1
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   298e4:	f006 f816 	bl	2f914 <__aeabi_ul2d>
   298e8:	2403      	movs	r4, #3
   298ea:	2500      	movs	r5, #0
   298ec:	ec41 0b17 	vmov	d7, r0, r1
   298f0:	eeb1 7bc7 	vsqrt.f64	d7, d7
   298f4:	eefd 7bc7 	vcvt.s32.f64	s15, d7
   298f8:	ee17 8a90 	vmov	r8, s15
   298fc:	e006      	b.n	2990c <LEAF_isPrime+0x44>
            if ( (number % i) == 0 ) return 0;
   298fe:	f006 f94d 	bl	2fb9c <__aeabi_uldivmod>
   29902:	3402      	adds	r4, #2
   29904:	f145 0500 	adc.w	r5, r5, #0
   29908:	4313      	orrs	r3, r2
   2990a:	d008      	beq.n	2991e <LEAF_isPrime+0x56>
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   2990c:	45a0      	cmp	r8, r4
            if ( (number % i) == 0 ) return 0;
   2990e:	4622      	mov	r2, r4
   29910:	462b      	mov	r3, r5
   29912:	4630      	mov	r0, r6
   29914:	4639      	mov	r1, r7
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
   29916:	daf2      	bge.n	298fe <LEAF_isPrime+0x36>
    if ( number == 2 ) return 1;
   29918:	2001      	movs	r0, #1
        return 1; // prime
    }
    else return 0; // even
}
   2991a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else return 0; // even
   2991e:	2000      	movs	r0, #0
}
   29920:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( number == 2 ) return 1;
   29924:	2001      	movs	r0, #1
}
   29926:	4770      	bx	lr

00029928 <LEAF_tanh>:

// Adapted from MusicDSP: http://www.musicdsp.org/showone.php?id=238
float LEAF_tanh(float x)
{
    
    if( x < -3.0f )
   29928:	eef8 7a08 	vmov.f32	s15, #136	; 0xc0400000 -3.0
   2992c:	eeb4 0ae7 	vcmpe.f32	s0, s15
   29930:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29934:	d418      	bmi.n	29968 <LEAF_tanh+0x40>
        return -1.0f;
    else if( x > 3.0f )
   29936:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   2993a:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2993e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29942:	dc0e      	bgt.n	29962 <LEAF_tanh+0x3a>
        return 1.0f;
    else
        return x * ( 27.0f + x * x ) / ( 27.0f + 9.0f * x * x );
   29944:	ee60 6a00 	vmul.f32	s13, s0, s0
   29948:	eef3 7a0b 	vmov.f32	s15, #59	; 0x41d80000  27.0
   2994c:	eeb2 6a02 	vmov.f32	s12, #34	; 0x41100000  9.0
   29950:	ee36 7aa7 	vadd.f32	s14, s13, s15
   29954:	eee6 7a86 	vfma.f32	s15, s13, s12
   29958:	ee27 7a00 	vmul.f32	s14, s14, s0
   2995c:	ee87 0a27 	vdiv.f32	s0, s14, s15
   29960:	4770      	bx	lr
        return 1.0f;
   29962:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
}
   29966:	4770      	bx	lr
        return -1.0f;
   29968:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   2996c:	4770      	bx	lr
   2996e:	bf00      	nop

00029970 <LEAF_generate_exp>:


//0.001 base gives a good curve that goes from 1 to near zero
void LEAF_generate_exp(float* buffer, float base, float start, float end, float offset, int size)
{
	float increment = (end - start) / (float)size;
   29970:	ee07 1a90 	vmov	s15, r1
   29974:	ee31 1a60 	vsub.f32	s2, s2, s1
	float x = start;
	for (int i = 0; i < size; i++)
   29978:	2900      	cmp	r1, #0
	float increment = (end - start) / (float)size;
   2997a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
{
   2997e:	b538      	push	{r3, r4, r5, lr}
   29980:	ed2d 8b04 	vpush	{d8-d9}
	float increment = (end - start) / (float)size;
   29984:	eec1 8a27 	vdiv.f32	s17, s2, s15
	for (int i = 0; i < size; i++)
   29988:	dd16      	ble.n	299b8 <LEAF_generate_exp+0x48>
   2998a:	4604      	mov	r4, r0
   2998c:	eb00 0581 	add.w	r5, r0, r1, lsl #2
   29990:	eeb0 8a60 	vmov.f32	s16, s1
   29994:	eeb0 9a40 	vmov.f32	s18, s0
   29998:	eef0 9a61 	vmov.f32	s19, s3
	{
		buffer[i] = powf(base, x) + offset;
   2999c:	eef0 0a48 	vmov.f32	s1, s16
   299a0:	eeb0 0a49 	vmov.f32	s0, s18
   299a4:	f003 fb24 	bl	2cff0 <powf>
   299a8:	ee30 0a29 	vadd.f32	s0, s0, s19
		x += increment;
   299ac:	ee38 8a28 	vadd.f32	s16, s16, s17
		buffer[i] = powf(base, x) + offset;
   299b0:	eca4 0a01 	vstmia	r4!, {s0}
	for (int i = 0; i < size; i++)
   299b4:	42a5      	cmp	r5, r4
   299b6:	d1f1      	bne.n	2999c <LEAF_generate_exp+0x2c>
    }
}
   299b8:	ecbd 8b04 	vpop	{d8-d9}
   299bc:	bd38      	pop	{r3, r4, r5, pc}
   299be:	bf00      	nop

000299c0 <LEAF_generate_atodbPositiveClipped>:
    }
}


void LEAF_generate_atodbPositiveClipped(float* buffer, float lowerThreshold, float range, int size)
{
   299c0:	b538      	push	{r3, r4, r5, lr}
    alias.ui &= 0x7fffffff;
   299c2:	ee10 3a10 	vmov	r3, s0
    float increment = 1.0f / (float)size;
   299c6:	ee07 1a90 	vmov	s15, r1
   299ca:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    float x = 0.0f;
    float scalar = range / fastabsf(lowerThreshold);
    for (int i = 0; i < size; i++)
   299ce:	2900      	cmp	r1, #0
    alias.ui &= 0x7fffffff;
   299d0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    float increment = 1.0f / (float)size;
   299d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float scalar = range / fastabsf(lowerThreshold);
   299d8:	ee06 3a90 	vmov	s13, r3
{
   299dc:	ed2d 8b08 	vpush	{d8-d11}
    float scalar = range / fastabsf(lowerThreshold);
   299e0:	eec0 9aa6 	vdiv.f32	s19, s1, s13
    float increment = 1.0f / (float)size;
   299e4:	eec7 aa27 	vdiv.f32	s21, s14, s15
    for (int i = 0; i < size; i++)
   299e8:	dd29      	ble.n	29a3e <LEAF_generate_atodbPositiveClipped+0x7e>
   299ea:	ed9f 9a1b 	vldr	s18, [pc, #108]	; 29a58 <LEAF_generate_atodbPositiveClipped+0x98>
   299ee:	4604      	mov	r4, r0
   299f0:	eb00 0581 	add.w	r5, r0, r1, lsl #2
   299f4:	fe80 aa49 	vminnm.f32	s20, s0, s18
    {
        float temp = atodb(x);
        temp = LEAF_clip(lowerThreshold, temp, 0.0f);
        buffer[i] = (temp-lowerThreshold) * scalar;
   299f8:	ee7a ba40 	vsub.f32	s23, s20, s0
   299fc:	eef0 8a40 	vmov.f32	s17, s0
}


float atodb(float a)
{
    return 20.0f*log10f(a);
   29a00:	eeb3 ba04 	vmov.f32	s22, #52	; 0x41a00000  20.0
        buffer[i] = (temp-lowerThreshold) * scalar;
   29a04:	ee6b baa9 	vmul.f32	s23, s23, s19
    float x = 0.0f;
   29a08:	eeb0 8a49 	vmov.f32	s16, s18
   29a0c:	fe80 9a09 	vmaxnm.f32	s18, s0, s18
    return 20.0f*log10f(a);
   29a10:	eeb0 0a48 	vmov.f32	s0, s16
   29a14:	f003 fea0 	bl	2d758 <log10f>
   29a18:	ee20 0a0b 	vmul.f32	s0, s0, s22
    if (val < tempmin)
   29a1c:	eeb4 aac0 	vcmpe.f32	s20, s0
        buffer[i] = (temp-lowerThreshold) * scalar;
   29a20:	fec9 7a40 	vminnm.f32	s15, s18, s0
   29a24:	ee77 7ae8 	vsub.f32	s15, s15, s17
    if (val < tempmin)
   29a28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        buffer[i] = (temp-lowerThreshold) * scalar;
   29a2c:	ee67 7aa9 	vmul.f32	s15, s15, s19
    if (val < tempmin)
   29a30:	dc08      	bgt.n	29a44 <LEAF_generate_atodbPositiveClipped+0x84>
        buffer[i] = (temp-lowerThreshold) * scalar;
   29a32:	ece4 7a01 	vstmia	r4!, {s15}
    for (int i = 0; i < size; i++)
   29a36:	42ac      	cmp	r4, r5
        x += increment;
   29a38:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
   29a3c:	d1e8      	bne.n	29a10 <LEAF_generate_atodbPositiveClipped+0x50>
}
   29a3e:	ecbd 8b08 	vpop	{d8-d11}
   29a42:	bd38      	pop	{r3, r4, r5, pc}
        buffer[i] = (temp-lowerThreshold) * scalar;
   29a44:	ece4 ba01 	vstmia	r4!, {s23}
    for (int i = 0; i < size; i++)
   29a48:	42a5      	cmp	r5, r4
        x += increment;
   29a4a:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
   29a4e:	d1df      	bne.n	29a10 <LEAF_generate_atodbPositiveClipped+0x50>
}
   29a50:	ecbd 8b08 	vpop	{d8-d11}
   29a54:	bd38      	pop	{r3, r4, r5, pc}
   29a56:	bf00      	nop
   29a58:	00000000 	.word	0x00000000

00029a5c <LEAF_midiToFrequency>:
    if( f <= -1500.0f ) return (0);
   29a5c:	eddf 7a10 	vldr	s15, [pc, #64]	; 29aa0 <LEAF_midiToFrequency+0x44>
   29a60:	eeb4 0ae7 	vcmpe.f32	s0, s15
   29a64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29a68:	d917      	bls.n	29a9a <LEAF_midiToFrequency+0x3e>
   29a6a:	eef0 7a40 	vmov.f32	s15, s0
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
   29a6e:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 29aa4 <LEAF_midiToFrequency+0x48>
   29a72:	eddf 0a0d 	vldr	s1, [pc, #52]	; 29aa8 <LEAF_midiToFrequency+0x4c>
   29a76:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
   29a7a:	fec7 7ae0 	vminnm.f32	s15, s15, s1
   29a7e:	ee77 7ac7 	vsub.f32	s15, s15, s14
   29a82:	eddf 0a0a 	vldr	s1, [pc, #40]	; 29aac <LEAF_midiToFrequency+0x50>
{
   29a86:	b508      	push	{r3, lr}
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
   29a88:	ee67 0aa0 	vmul.f32	s1, s15, s1
   29a8c:	f003 fab0 	bl	2cff0 <powf>
   29a90:	eddf 7a07 	vldr	s15, [pc, #28]	; 29ab0 <LEAF_midiToFrequency+0x54>
   29a94:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   29a98:	bd08      	pop	{r3, pc}
    if( f <= -1500.0f ) return (0);
   29a9a:	ed9f 0a06 	vldr	s0, [pc, #24]	; 29ab4 <LEAF_midiToFrequency+0x58>
}
   29a9e:	4770      	bx	lr
   29aa0:	c4bb8000 	.word	0xc4bb8000
   29aa4:	428a0000 	.word	0x428a0000
   29aa8:	44bb6000 	.word	0x44bb6000
   29aac:	3daaaaab 	.word	0x3daaaaab
   29ab0:	43dc0000 	.word	0x43dc0000
   29ab4:	00000000 	.word	0x00000000

00029ab8 <LEAF_interpolate_hermite_x>:
    float y0my1 = yy0 - yy1;
   29ab8:	ee70 7a60 	vsub.f32	s15, s0, s1
    float c1 = 0.5f * (yy2 - yy0);
   29abc:	ee31 7a40 	vsub.f32	s14, s2, s0
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
   29ac0:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   29ac4:	ee71 1ae7 	vsub.f32	s3, s3, s15
   29ac8:	ee70 6ac1 	vsub.f32	s13, s1, s2
    float c2 = y0my1 + c1 - c3;
   29acc:	eee7 7a06 	vfma.f32	s15, s14, s12
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
   29ad0:	ee31 1ac1 	vsub.f32	s2, s3, s2
   29ad4:	eee1 6a06 	vfma.f32	s13, s2, s12
    float c2 = y0my1 + c1 - c3;
   29ad8:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return ((c3 * xx + c2) * xx + c1) * xx + c0;
   29adc:	eee6 7a82 	vfma.f32	s15, s13, s4
   29ae0:	ee67 7a82 	vmul.f32	s15, s15, s4
   29ae4:	eee7 7a06 	vfma.f32	s15, s14, s12
}
   29ae8:	eee7 0a82 	vfma.f32	s1, s15, s4
   29aec:	eeb0 0a60 	vmov.f32	s0, s1
   29af0:	4770      	bx	lr
   29af2:	bf00      	nop

00029af4 <LEAF_interpolation_linear>:
{
   29af4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29af8:	ed9f 7a07 	vldr	s14, [pc, #28]	; 29b18 <LEAF_interpolation_linear+0x24>
   29afc:	fe81 1a67 	vminnm.f32	s2, s2, s15
   29b00:	fe81 1a07 	vmaxnm.f32	s2, s2, s14
    float omAlpha = 1.0f - alpha;
   29b04:	ee77 7ac1 	vsub.f32	s15, s15, s2
    out += B * alpha;
   29b08:	ee20 1a81 	vmul.f32	s2, s1, s2
}
   29b0c:	eea7 1a80 	vfma.f32	s2, s15, s0
   29b10:	eeb0 0a41 	vmov.f32	s0, s2
   29b14:	4770      	bx	lr
   29b16:	bf00      	nop
   29b18:	00000000 	.word	0x00000000

00029b1c <mtof>:
    if (f <= -1500.0f) return(0);
   29b1c:	eddf 7a0c 	vldr	s15, [pc, #48]	; 29b50 <mtof+0x34>
   29b20:	eeb4 0ae7 	vcmpe.f32	s0, s15
   29b24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29b28:	d90f      	bls.n	29b4a <mtof+0x2e>
    else return (8.17579891564f * expf(0.0577622650f * f));
   29b2a:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 29b54 <mtof+0x38>
   29b2e:	eddf 7a0a 	vldr	s15, [pc, #40]	; 29b58 <mtof+0x3c>
   29b32:	fe80 0a47 	vminnm.f32	s0, s0, s14
{
   29b36:	b508      	push	{r3, lr}
    else return (8.17579891564f * expf(0.0577622650f * f));
   29b38:	ee20 0a27 	vmul.f32	s0, s0, s15
   29b3c:	f003 f8ea 	bl	2cd14 <expf>
   29b40:	eddf 7a06 	vldr	s15, [pc, #24]	; 29b5c <mtof+0x40>
   29b44:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   29b48:	bd08      	pop	{r3, pc}
    if (f <= -1500.0f) return(0);
   29b4a:	ed9f 0a05 	vldr	s0, [pc, #20]	; 29b60 <mtof+0x44>
}
   29b4e:	4770      	bx	lr
   29b50:	c4bb8000 	.word	0xc4bb8000
   29b54:	44bb6000 	.word	0x44bb6000
   29b58:	3d6c9820 	.word	0x3d6c9820
   29b5c:	4102d013 	.word	0x4102d013
   29b60:	00000000 	.word	0x00000000

00029b64 <faster_mtof>:
   29b64:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29b68:	eddf 6a0e 	vldr	s13, [pc, #56]	; 29ba4 <faster_mtof+0x40>
   29b6c:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 29ba8 <faster_mtof+0x44>
   29b70:	eee0 7a26 	vfma.f32	s15, s0, s13
   29b74:	ee27 0aa7 	vmul.f32	s0, s15, s15
   29b78:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b7c:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b80:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b84:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b88:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b8c:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b90:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b94:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b98:	ee20 0a00 	vmul.f32	s0, s0, s0
   29b9c:	ee20 0a07 	vmul.f32	s0, s0, s14
   29ba0:	4770      	bx	lr
   29ba2:	bf00      	nop
   29ba4:	386c9820 	.word	0x386c9820
   29ba8:	4102d013 	.word	0x4102d013
   29bac:	00000000 	.word	0x00000000

00029bb0 <powtodb>:
{
   29bb0:	b508      	push	{r3, lr}
   29bb2:	ed2d 8b02 	vpush	{d8}
    if (f <= 0) return (0);
   29bb6:	ed9f 8a12 	vldr	s16, [pc, #72]	; 29c00 <powtodb+0x50>
   29bba:	eeb4 0ac8 	vcmpe.f32	s0, s16
   29bbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   29bc2:	d910      	bls.n	29be6 <powtodb+0x36>
        float val = 100.0f + 10.0f/LOGTEN * logf(f);
   29bc4:	f003 f92c 	bl	2ce20 <logf>
   29bc8:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
   29bcc:	ed9f 7b08 	vldr	d7, [pc, #32]	; 29bf0 <powtodb+0x40>
   29bd0:	ed9f 0b09 	vldr	d0, [pc, #36]	; 29bf8 <powtodb+0x48>
   29bd4:	eea6 0b07 	vfma.f64	d0, d6, d7
   29bd8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
        return (val < 0.0f ? 0.0f : val);
   29bdc:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
}
   29be0:	ecbd 8b02 	vpop	{d8}
   29be4:	bd08      	pop	{r3, pc}
    if (f <= 0) return (0);
   29be6:	eeb0 0a48 	vmov.f32	s0, s16
}
   29bea:	ecbd 8b02 	vpop	{d8}
   29bee:	bd08      	pop	{r3, pc}
   29bf0:	ed384f8a 	.word	0xed384f8a
   29bf4:	40115f2c 	.word	0x40115f2c
   29bf8:	00000000 	.word	0x00000000
   29bfc:	40590000 	.word	0x40590000
   29c00:	00000000 	.word	0x00000000

00029c04 <fastdbtoa>:


float fastdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return expf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
   29c04:	eddf 7a02 	vldr	s15, [pc, #8]	; 29c10 <fastdbtoa+0xc>
   29c08:	ee20 0a27 	vmul.f32	s0, s0, s15
   29c0c:	f003 b882 	b.w	2cd14 <expf>
   29c10:	3debc8e3 	.word	0x3debc8e3

00029c14 <fasterdbtoa>:
    x = 1.0f + (x * 0.00390625f);
   29c14:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   29c18:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 29c44 <fasterdbtoa+0x30>
   29c1c:	eee0 7a07 	vfma.f32	s15, s0, s14
    x *= x; x *= x; x *= x; x *= x;
   29c20:	ee27 0aa7 	vmul.f32	s0, s15, s15
   29c24:	ee20 0a00 	vmul.f32	s0, s0, s0
   29c28:	ee20 0a00 	vmul.f32	s0, s0, s0
   29c2c:	ee20 0a00 	vmul.f32	s0, s0, s0
    x *= x; x *= x; x *= x; x *= x;
   29c30:	ee20 0a00 	vmul.f32	s0, s0, s0
   29c34:	ee20 0a00 	vmul.f32	s0, s0, s0
   29c38:	ee20 0a00 	vmul.f32	s0, s0, s0

float fasterdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return fasterexpf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
}
   29c3c:	ee20 0a00 	vmul.f32	s0, s0, s0
   29c40:	4770      	bx	lr
   29c42:	bf00      	nop
   29c44:	39ebc8e3 	.word	0x39ebc8e3

00029c48 <maximum>:


float maximum (float num1, float num2)
{
    return (num1 > num2 ) ? num1 : num2;
}
   29c48:	fe80 0a80 	vmaxnm.f32	s0, s1, s0
   29c4c:	4770      	bx	lr
   29c4e:	bf00      	nop

00029c50 <minimum>:

float minimum (float num1, float num2)
{
    return (num1 < num2 ) ? num1 : num2;
}
   29c50:	fe80 0ac0 	vminnm.f32	s0, s1, s0
   29c54:	4770      	bx	lr
   29c56:	bf00      	nop

00029c58 <leaf_pool_init>:
    */
    //is zeroing out the memory necessary? This takes a long time on large pools - JS
}

void leaf_pool_init(char* memory, size_t size)
{
   29c58:	b470      	push	{r4, r5, r6}
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29c5a:	4b0a      	ldr	r3, [pc, #40]	; (29c84 <leaf_pool_init+0x2c>)
   29c5c:	2610      	movs	r6, #16
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29c5e:	f1a1 0410 	sub.w	r4, r1, #16
    pool->usize  = 0;
   29c62:	2200      	movs	r2, #0
    pool->msize  = size;
   29c64:	6259      	str	r1, [r3, #36]	; 0x24
}

static inline mpool_node_t* create_node(char* block_location, mpool_node_t* next, mpool_node_t* prev, size_t size)
{
    mpool_node_t* node = (mpool_node_t*)block_location;
    node->pool = block_location + leaf.header_size;
   29c66:	1985      	adds	r5, r0, r6
    leaf.mempool = &leaf._mempool;
   29c68:	f103 011c 	add.w	r1, r3, #28
    pool->mpool = (char*)memory;
   29c6c:	61d8      	str	r0, [r3, #28]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29c6e:	62de      	str	r6, [r3, #44]	; 0x2c
    pool->usize  = 0;
   29c70:	621a      	str	r2, [r3, #32]
    node->pool = block_location + leaf.header_size;
   29c72:	6005      	str	r5, [r0, #0]
    node->next = next;
    node->prev = prev;
    node->size = size;
   29c74:	60c4      	str	r4, [r0, #12]
    node->prev = prev;
   29c76:	e9c0 2201 	strd	r2, r2, [r0, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29c7a:	6298      	str	r0, [r3, #40]	; 0x28
    leaf.mempool = &leaf._mempool;
   29c7c:	6199      	str	r1, [r3, #24]
}
   29c7e:	bc70      	pop	{r4, r5, r6}
   29c80:	4770      	bx	lr
   29c82:	bf00      	nop
   29c84:	020fc0a8 	.word	0x020fc0a8

00029c88 <mpool_alloc>:
{
   29c88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
   29c8a:	68cb      	ldr	r3, [r1, #12]
   29c8c:	2b00      	cmp	r3, #0
   29c8e:	d049      	beq.n	29d24 <mpool_alloc+0x9c>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
   29c90:	3007      	adds	r0, #7
   29c92:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
   29c96:	e002      	b.n	29c9e <mpool_alloc+0x16>
        if (node_to_alloc == NULL)
   29c98:	4623      	mov	r3, r4
   29c9a:	2c00      	cmp	r4, #0
   29c9c:	d042      	beq.n	29d24 <mpool_alloc+0x9c>
    while (node_to_alloc->size < size_to_alloc)
   29c9e:	68da      	ldr	r2, [r3, #12]
   29ca0:	685c      	ldr	r4, [r3, #4]
   29ca2:	4282      	cmp	r2, r0
   29ca4:	d3f8      	bcc.n	29c98 <mpool_alloc+0x10>
    if (leftover > leaf.header_size)
   29ca6:	4e22      	ldr	r6, [pc, #136]	; (29d30 <mpool_alloc+0xa8>)
    size_t leftover = node_to_alloc->size - size_to_alloc;
   29ca8:	1a17      	subs	r7, r2, r0
    node_to_alloc->size = size_to_alloc;
   29caa:	60d8      	str	r0, [r3, #12]
    if (leftover > leaf.header_size)
   29cac:	6af5      	ldr	r5, [r6, #44]	; 0x2c
   29cae:	42bd      	cmp	r5, r7
   29cb0:	d327      	bcc.n	29d02 <mpool_alloc+0x7a>
        node_to_alloc->size += leftover;
   29cb2:	46a4      	mov	ip, r4
   29cb4:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
   29cb6:	68ca      	ldr	r2, [r1, #12]
   29cb8:	429a      	cmp	r2, r3
        pool->head = new_node;
   29cba:	bf08      	it	eq
   29cbc:	f8c1 c00c 	streq.w	ip, [r1, #12]
   29cc0:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
}

static inline void delink_node(mpool_node_t* node)
{
    // If there is a node after the node to remove
    if (node->next != NULL)
   29cc4:	b108      	cbz	r0, 29cca <mpool_alloc+0x42>
    {
        // Close the link
        node->next->prev = node->prev;
   29cc6:	6082      	str	r2, [r0, #8]
   29cc8:	689a      	ldr	r2, [r3, #8]
    }
    // If there is a node before the node to remove
    if (node->prev != NULL)
   29cca:	b10a      	cbz	r2, 29cd0 <mpool_alloc+0x48>
    {
        // Close the link
        node->prev->next = node->next;
   29ccc:	6858      	ldr	r0, [r3, #4]
   29cce:	6050      	str	r0, [r2, #4]
    }
    
    node->next = NULL;
   29cd0:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   29cd2:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
   29cd4:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29cd8:	6848      	ldr	r0, [r1, #4]
   29cda:	6af5      	ldr	r5, [r6, #44]	; 0x2c
   29cdc:	4428      	add	r0, r5
   29cde:	4420      	add	r0, r4
   29ce0:	6048      	str	r0, [r1, #4]
    if (leaf.clearOnAllocation > 0)
   29ce2:	6971      	ldr	r1, [r6, #20]
   29ce4:	4291      	cmp	r1, r2
   29ce6:	dd0a      	ble.n	29cfe <mpool_alloc+0x76>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29ce8:	68d9      	ldr	r1, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
   29cea:	6818      	ldr	r0, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29cec:	b141      	cbz	r1, 29d00 <mpool_alloc+0x78>
   29cee:	3801      	subs	r0, #1
   29cf0:	4614      	mov	r4, r2
   29cf2:	f800 4f01 	strb.w	r4, [r0, #1]!
   29cf6:	3201      	adds	r2, #1
   29cf8:	68d9      	ldr	r1, [r3, #12]
   29cfa:	4291      	cmp	r1, r2
   29cfc:	d8f9      	bhi.n	29cf2 <mpool_alloc+0x6a>
   29cfe:	6818      	ldr	r0, [r3, #0]
}
   29d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29d02:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
   29d04:	4428      	add	r0, r5
                               node_to_alloc->prev,
   29d06:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
   29d0a:	1b7f      	subs	r7, r7, r5
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29d0c:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
   29d10:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
   29d12:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
   29d16:	4465      	add	r5, ip
   29d18:	5015      	str	r5, [r2, r0]
    node->size = size;
   29d1a:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
   29d1e:	e9cc 4e01 	strd	r4, lr, [ip, #4]
   29d22:	e7c8      	b.n	29cb6 <mpool_alloc+0x2e>
}

void leaf_mempool_overrun(void)
{
    LEAF_error(1);
   29d24:	2001      	movs	r0, #1
   29d26:	f002 fe3b 	bl	2c9a0 <LEAF_error>
        return NULL;
   29d2a:	2000      	movs	r0, #0
}
   29d2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29d2e:	bf00      	nop
   29d30:	020fc0a8 	.word	0x020fc0a8

00029d34 <mpool_calloc>:
{
   29d34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
   29d36:	68cb      	ldr	r3, [r1, #12]
   29d38:	2b00      	cmp	r3, #0
   29d3a:	d046      	beq.n	29dca <mpool_calloc+0x96>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
   29d3c:	3007      	adds	r0, #7
   29d3e:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
   29d42:	e002      	b.n	29d4a <mpool_calloc+0x16>
        if (node_to_alloc == NULL)
   29d44:	4623      	mov	r3, r4
   29d46:	2c00      	cmp	r4, #0
   29d48:	d03f      	beq.n	29dca <mpool_calloc+0x96>
    while (node_to_alloc->size < size_to_alloc)
   29d4a:	68da      	ldr	r2, [r3, #12]
   29d4c:	685c      	ldr	r4, [r3, #4]
   29d4e:	4282      	cmp	r2, r0
   29d50:	d3f8      	bcc.n	29d44 <mpool_calloc+0x10>
    if (leftover > leaf.header_size)
   29d52:	4f20      	ldr	r7, [pc, #128]	; (29dd4 <mpool_calloc+0xa0>)
    size_t leftover = node_to_alloc->size - size_to_alloc;
   29d54:	1a16      	subs	r6, r2, r0
    node_to_alloc->size = size_to_alloc;
   29d56:	60d8      	str	r0, [r3, #12]
    if (leftover > leaf.header_size)
   29d58:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   29d5a:	42b5      	cmp	r5, r6
   29d5c:	d324      	bcc.n	29da8 <mpool_calloc+0x74>
        node_to_alloc->size += leftover;
   29d5e:	46a4      	mov	ip, r4
   29d60:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
   29d62:	68ca      	ldr	r2, [r1, #12]
   29d64:	429a      	cmp	r2, r3
        pool->head = new_node;
   29d66:	bf08      	it	eq
   29d68:	f8c1 c00c 	streq.w	ip, [r1, #12]
   29d6c:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
    if (node->next != NULL)
   29d70:	b108      	cbz	r0, 29d76 <mpool_calloc+0x42>
        node->next->prev = node->prev;
   29d72:	6082      	str	r2, [r0, #8]
   29d74:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   29d76:	b10a      	cbz	r2, 29d7c <mpool_calloc+0x48>
        node->prev->next = node->next;
   29d78:	6858      	ldr	r0, [r3, #4]
   29d7a:	6050      	str	r0, [r2, #4]
    node->next = NULL;
   29d7c:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   29d7e:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
   29d80:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29d84:	6848      	ldr	r0, [r1, #4]
   29d86:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   29d88:	4428      	add	r0, r5
   29d8a:	4420      	add	r0, r4
   29d8c:	6048      	str	r0, [r1, #4]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29d8e:	68d9      	ldr	r1, [r3, #12]
    char* new_pool = (char*)node_to_alloc->pool;
   29d90:	6818      	ldr	r0, [r3, #0]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29d92:	b141      	cbz	r1, 29da6 <mpool_calloc+0x72>
   29d94:	3801      	subs	r0, #1
   29d96:	4614      	mov	r4, r2
   29d98:	f800 4f01 	strb.w	r4, [r0, #1]!
   29d9c:	3201      	adds	r2, #1
   29d9e:	68d9      	ldr	r1, [r3, #12]
   29da0:	4291      	cmp	r1, r2
   29da2:	d8f9      	bhi.n	29d98 <mpool_calloc+0x64>
   29da4:	6818      	ldr	r0, [r3, #0]
}
   29da6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29da8:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
   29daa:	4428      	add	r0, r5
                               node_to_alloc->prev,
   29dac:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
   29db0:	1b76      	subs	r6, r6, r5
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29db2:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
   29db6:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
   29db8:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
   29dbc:	4465      	add	r5, ip
   29dbe:	5015      	str	r5, [r2, r0]
    node->size = size;
   29dc0:	f8cc 600c 	str.w	r6, [ip, #12]
    node->prev = prev;
   29dc4:	e9cc 4e01 	strd	r4, lr, [ip, #4]
   29dc8:	e7cb      	b.n	29d62 <mpool_calloc+0x2e>
    LEAF_error(1);
   29dca:	2001      	movs	r0, #1
   29dcc:	f002 fde8 	bl	2c9a0 <LEAF_error>
        return NULL;
   29dd0:	2000      	movs	r0, #0
}
   29dd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29dd4:	020fc0a8 	.word	0x020fc0a8

00029dd8 <mpool_free>:
{
   29dd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   29ddc:	4f33      	ldr	r7, [pc, #204]	; (29eac <mpool_free+0xd4>)
    pool->usize -= leaf.header_size + freed_node->size;
   29dde:	684a      	ldr	r2, [r1, #4]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   29de0:	6afc      	ldr	r4, [r7, #44]	; 0x2c
    mpool_node_t* other_node = pool->head;
   29de2:	68cb      	ldr	r3, [r1, #12]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
   29de4:	1b00      	subs	r0, r0, r4
    pool->usize -= leaf.header_size + freed_node->size;
   29de6:	1b12      	subs	r2, r2, r4
   29de8:	68c4      	ldr	r4, [r0, #12]
   29dea:	1b12      	subs	r2, r2, r4
   29dec:	604a      	str	r2, [r1, #4]
    while (other_node != NULL)
   29dee:	2b00      	cmp	r3, #0
   29df0:	d03e      	beq.n	29e70 <mpool_free+0x98>
        if ((long) other_node < (long) pool->mpool ||
   29df2:	680a      	ldr	r2, [r1, #0]
   29df4:	4293      	cmp	r3, r2
   29df6:	db1f      	blt.n	29e38 <mpool_free+0x60>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
   29df8:	688c      	ldr	r4, [r1, #8]
   29dfa:	461d      	mov	r5, r3
   29dfc:	4422      	add	r2, r4
        if ((long) other_node < (long) pool->mpool ||
   29dfe:	429a      	cmp	r2, r3
   29e00:	d91a      	bls.n	29e38 <mpool_free+0x60>
    node->next = NULL;
   29e02:	f04f 0c00 	mov.w	ip, #0
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
   29e06:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   29e08:	68c4      	ldr	r4, [r0, #12]
        next_node = other_node->next;
   29e0a:	685e      	ldr	r6, [r3, #4]
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
   29e0c:	eb02 0e04 	add.w	lr, r2, r4
   29e10:	f8d3 800c 	ldr.w	r8, [r3, #12]
   29e14:	eb0e 0900 	add.w	r9, lr, r0
   29e18:	45a9      	cmp	r9, r5
   29e1a:	d030      	beq.n	29e7e <mpool_free+0xa6>
        else if (((long) other_node) + (leaf.header_size + other_node->size) == (long) freed_node)
   29e1c:	442a      	add	r2, r5
   29e1e:	4442      	add	r2, r8
   29e20:	4290      	cmp	r0, r2
   29e22:	d00e      	beq.n	29e42 <mpool_free+0x6a>
    while (other_node != NULL)
   29e24:	b31e      	cbz	r6, 29e6e <mpool_free+0x96>
        if ((long) other_node < (long) pool->mpool ||
   29e26:	680b      	ldr	r3, [r1, #0]
   29e28:	42b3      	cmp	r3, r6
   29e2a:	dc05      	bgt.n	29e38 <mpool_free+0x60>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
   29e2c:	688c      	ldr	r4, [r1, #8]
   29e2e:	4635      	mov	r5, r6
   29e30:	441c      	add	r4, r3
   29e32:	4633      	mov	r3, r6
        if ((long) other_node < (long) pool->mpool ||
   29e34:	42b4      	cmp	r4, r6
   29e36:	d8e6      	bhi.n	29e06 <mpool_free+0x2e>
            LEAF_error(2);
   29e38:	2002      	movs	r0, #2
}
   29e3a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            LEAF_error(2);
   29e3e:	f002 bdaf 	b.w	2c9a0 <LEAF_error>
            other_node->size += leaf.header_size + freed_node->size;
   29e42:	eb0e 0408 	add.w	r4, lr, r8
   29e46:	60dc      	str	r4, [r3, #12]
            if (other_node != pool->head)
   29e48:	68ca      	ldr	r2, [r1, #12]
   29e4a:	429a      	cmp	r2, r3
   29e4c:	d02b      	beq.n	29ea6 <mpool_free+0xce>
   29e4e:	689a      	ldr	r2, [r3, #8]
    if (node->next != NULL)
   29e50:	b10e      	cbz	r6, 29e56 <mpool_free+0x7e>
        node->next->prev = node->prev;
   29e52:	60b2      	str	r2, [r6, #8]
   29e54:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   29e56:	b10a      	cbz	r2, 29e5c <mpool_free+0x84>
        node->prev->next = node->next;
   29e58:	6858      	ldr	r0, [r3, #4]
   29e5a:	6050      	str	r0, [r2, #4]
    node->next = NULL;
   29e5c:	f8c3 c004 	str.w	ip, [r3, #4]
   29e60:	4618      	mov	r0, r3
    node->prev = NULL;
   29e62:	f8c3 c008 	str.w	ip, [r3, #8]
                other_node->next = pool->head;
   29e66:	68ca      	ldr	r2, [r1, #12]
   29e68:	605a      	str	r2, [r3, #4]
    while (other_node != NULL)
   29e6a:	2e00      	cmp	r6, #0
   29e6c:	d1db      	bne.n	29e26 <mpool_free+0x4e>
   29e6e:	68cb      	ldr	r3, [r1, #12]
    freed_node->next = pool->head;
   29e70:	6043      	str	r3, [r0, #4]
    if (pool->head != NULL) pool->head->prev = freed_node;
   29e72:	68cb      	ldr	r3, [r1, #12]
   29e74:	b103      	cbz	r3, 29e78 <mpool_free+0xa0>
   29e76:	6098      	str	r0, [r3, #8]
    pool->head = freed_node;
   29e78:	60c8      	str	r0, [r1, #12]
}
   29e7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            freed_node->size += leaf.header_size + other_node->size;
   29e7e:	4444      	add	r4, r8
   29e80:	4422      	add	r2, r4
   29e82:	60c2      	str	r2, [r0, #12]
            if (other_node == pool->head) pool->head = pool->head->next;
   29e84:	68ca      	ldr	r2, [r1, #12]
   29e86:	429a      	cmp	r2, r3
   29e88:	d00a      	beq.n	29ea0 <mpool_free+0xc8>
   29e8a:	e9d3 4201 	ldrd	r4, r2, [r3, #4]
    if (node->next != NULL)
   29e8e:	b10c      	cbz	r4, 29e94 <mpool_free+0xbc>
        node->next->prev = node->prev;
   29e90:	60a2      	str	r2, [r4, #8]
   29e92:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
   29e94:	b10a      	cbz	r2, 29e9a <mpool_free+0xc2>
        node->prev->next = node->next;
   29e96:	685c      	ldr	r4, [r3, #4]
   29e98:	6054      	str	r4, [r2, #4]
    node->prev = NULL;
   29e9a:	e9c3 cc01 	strd	ip, ip, [r3, #4]
   29e9e:	e7c1      	b.n	29e24 <mpool_free+0x4c>
            if (other_node == pool->head) pool->head = pool->head->next;
   29ea0:	685a      	ldr	r2, [r3, #4]
   29ea2:	60ca      	str	r2, [r1, #12]
   29ea4:	e7f1      	b.n	29e8a <mpool_free+0xb2>
                pool->head = pool->head->next;
   29ea6:	4618      	mov	r0, r3
   29ea8:	60ce      	str	r6, [r1, #12]
   29eaa:	e7bb      	b.n	29e24 <mpool_free+0x4c>
   29eac:	020fc0a8 	.word	0x020fc0a8

00029eb0 <tMempool_init>:
    //TODO: we should make a set of real error codes that are in an enum type
}

void tMempool_init(tMempool* const mp, char* memory, size_t size)
{
   29eb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    tMempool_freeFromPool(mp, &leaf.mempool);
}

void    tMempool_initToPool     (tMempool* const mp, char* memory, size_t size, tMempool* const mem)
{
    _tMempool* mm = *mem;
   29eb4:	4e3a      	ldr	r6, [pc, #232]	; (29fa0 <tMempool_init+0xf0>)
{
   29eb6:	b082      	sub	sp, #8
    _tMempool* mm = *mem;
   29eb8:	f8d6 c018 	ldr.w	ip, [r6, #24]
    if (pool->head == NULL)
   29ebc:	f8dc 300c 	ldr.w	r3, [ip, #12]
   29ec0:	b91b      	cbnz	r3, 29eca <tMempool_init+0x1a>
   29ec2:	e04c      	b.n	29f5e <tMempool_init+0xae>
        if (node_to_alloc == NULL)
   29ec4:	462b      	mov	r3, r5
   29ec6:	2d00      	cmp	r5, #0
   29ec8:	d049      	beq.n	29f5e <tMempool_init+0xae>
    while (node_to_alloc->size < size_to_alloc)
   29eca:	68dc      	ldr	r4, [r3, #12]
   29ecc:	685d      	ldr	r5, [r3, #4]
   29ece:	2c0f      	cmp	r4, #15
   29ed0:	d9f8      	bls.n	29ec4 <tMempool_init+0x14>
    node_to_alloc->size = size_to_alloc;
   29ed2:	2710      	movs	r7, #16
    size_t leftover = node_to_alloc->size - size_to_alloc;
   29ed4:	f1a4 0e10 	sub.w	lr, r4, #16
    node_to_alloc->size = size_to_alloc;
   29ed8:	60df      	str	r7, [r3, #12]
    if (leftover > leaf.header_size)
   29eda:	6af7      	ldr	r7, [r6, #44]	; 0x2c
   29edc:	45be      	cmp	lr, r7
   29ede:	d849      	bhi.n	29f74 <tMempool_init+0xc4>
        node_to_alloc->size += leftover;
   29ee0:	46ae      	mov	lr, r5
   29ee2:	60dc      	str	r4, [r3, #12]
    if (pool->head == node_to_alloc)
   29ee4:	f8dc 400c 	ldr.w	r4, [ip, #12]
   29ee8:	42a3      	cmp	r3, r4
        pool->head = new_node;
   29eea:	bf08      	it	eq
   29eec:	f8cc e00c 	streq.w	lr, [ip, #12]
   29ef0:	e9d3 5401 	ldrd	r5, r4, [r3, #4]
    if (node->next != NULL)
   29ef4:	b10d      	cbz	r5, 29efa <tMempool_init+0x4a>
        node->next->prev = node->prev;
   29ef6:	60ac      	str	r4, [r5, #8]
   29ef8:	689c      	ldr	r4, [r3, #8]
    if (node->prev != NULL)
   29efa:	b10c      	cbz	r4, 29f00 <tMempool_init+0x50>
        node->prev->next = node->next;
   29efc:	685d      	ldr	r5, [r3, #4]
   29efe:	6065      	str	r5, [r4, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29f00:	68dc      	ldr	r4, [r3, #12]
    node->next = NULL;
   29f02:	2500      	movs	r5, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
   29f04:	9401      	str	r4, [sp, #4]
    node->prev = NULL;
   29f06:	e9c3 5501 	strd	r5, r5, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
   29f0a:	6af4      	ldr	r4, [r6, #44]	; 0x2c
   29f0c:	f8dc 7004 	ldr.w	r7, [ip, #4]
   29f10:	4427      	add	r7, r4
   29f12:	463c      	mov	r4, r7
   29f14:	9f01      	ldr	r7, [sp, #4]
   29f16:	4427      	add	r7, r4
   29f18:	f8cc 7004 	str.w	r7, [ip, #4]
    if (leaf.clearOnAllocation > 0)
   29f1c:	6974      	ldr	r4, [r6, #20]
   29f1e:	42ac      	cmp	r4, r5
   29f20:	dd0a      	ble.n	29f38 <tMempool_init+0x88>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29f22:	68df      	ldr	r7, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
   29f24:	681c      	ldr	r4, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
   29f26:	b147      	cbz	r7, 29f3a <tMempool_init+0x8a>
   29f28:	3c01      	subs	r4, #1
   29f2a:	46ac      	mov	ip, r5
   29f2c:	f804 cf01 	strb.w	ip, [r4, #1]!
   29f30:	3501      	adds	r5, #1
   29f32:	68df      	ldr	r7, [r3, #12]
   29f34:	42bd      	cmp	r5, r7
   29f36:	d3f9      	bcc.n	29f2c <tMempool_init+0x7c>
   29f38:	681c      	ldr	r4, [r3, #0]
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   29f3a:	6004      	str	r4, [r0, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29f3c:	2310      	movs	r3, #16
    pool->usize  = 0;
   29f3e:	2000      	movs	r0, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29f40:	62f3      	str	r3, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
   29f42:	6021      	str	r1, [r4, #0]
    pool->usize  = 0;
   29f44:	e9c4 0201 	strd	r0, r2, [r4, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29f48:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    node->next = next;
   29f4a:	6048      	str	r0, [r1, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29f4c:	1ad2      	subs	r2, r2, r3
    node->pool = block_location + leaf.header_size;
   29f4e:	440b      	add	r3, r1
    node->size = size;
   29f50:	e9c1 0202 	strd	r0, r2, [r1, #8]
    node->pool = block_location + leaf.header_size;
   29f54:	600b      	str	r3, [r1, #0]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
   29f56:	60e1      	str	r1, [r4, #12]
}
   29f58:	b002      	add	sp, #8
   29f5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   29f5e:	4605      	mov	r5, r0
    LEAF_error(1);
   29f60:	2001      	movs	r0, #1
   29f62:	460c      	mov	r4, r1
   29f64:	f002 fd1c 	bl	2c9a0 <LEAF_error>
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   29f68:	2300      	movs	r3, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29f6a:	2210      	movs	r2, #16
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
   29f6c:	602b      	str	r3, [r5, #0]
    pool->mpool = (char*)memory;
   29f6e:	601c      	str	r4, [r3, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
   29f70:	62f2      	str	r2, [r6, #44]	; 0x2c
   29f72:	deff      	udf	#255	; 0xff
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29f74:	f8dc 9000 	ldr.w	r9, [ip]
        new_node = create_node(&pool->mpool[offset],
   29f78:	ebae 0407 	sub.w	r4, lr, r7
        offset += leaf.header_size + node_to_alloc->size;
   29f7c:	f107 0810 	add.w	r8, r7, #16
                               node_to_alloc->prev,
   29f80:	f8d3 a008 	ldr.w	sl, [r3, #8]
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
   29f84:	eba3 0e09 	sub.w	lr, r3, r9
        offset += leaf.header_size + node_to_alloc->size;
   29f88:	44f0      	add	r8, lr
        new_node = create_node(&pool->mpool[offset],
   29f8a:	eb09 0e08 	add.w	lr, r9, r8
    node->pool = block_location + leaf.header_size;
   29f8e:	4477      	add	r7, lr
   29f90:	f849 7008 	str.w	r7, [r9, r8]
    node->size = size;
   29f94:	f8ce 400c 	str.w	r4, [lr, #12]
    node->prev = prev;
   29f98:	e9ce 5a01 	strd	r5, sl, [lr, #4]
   29f9c:	e7a2      	b.n	29ee4 <tMempool_init+0x34>
   29f9e:	bf00      	nop
   29fa0:	020fc0a8 	.word	0x020fc0a8

00029fa4 <tSimplePoly_initToPool>:
{
    tSimplePoly_initToPool(polyh, maxNumVoices, &leaf.mempool);
}

void    tSimplePoly_initToPool            (tSimplePoly* const polyh, int maxNumVoices, tMempool* const mp)
{
   29fa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
   29fa8:	6816      	ldr	r6, [r2, #0]
{
   29faa:	4680      	mov	r8, r0
   29fac:	460c      	mov	r4, r1
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   29fae:	f240 401c 	movw	r0, #1052	; 0x41c
   29fb2:	4631      	mov	r1, r6
{
   29fb4:	4617      	mov	r7, r2
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   29fb6:	f7ff fe67 	bl	29c88 <mpool_alloc>
   29fba:	4605      	mov	r5, r0
    poly->maxNumVoices = maxNumVoices;

    for (int i = 0; i < 128; i++)
    {
        poly->notes[i][0] = -1;
        poly->notes[i][1] = 0;
   29fbc:	2100      	movs	r1, #0
        poly->notes[i][0] = -1;
   29fbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29fc2:	462b      	mov	r3, r5
   29fc4:	f505 6280 	add.w	r2, r5, #1024	; 0x400
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
   29fc8:	f8c8 5000 	str.w	r5, [r8]
    poly->mempool = m;
   29fcc:	602e      	str	r6, [r5, #0]
    poly->maxNumVoices = maxNumVoices;
   29fce:	e9c5 4402 	strd	r4, r4, [r5, #8]
        poly->notes[i][1] = 0;
   29fd2:	e9c3 0107 	strd	r0, r1, [r3, #28]
   29fd6:	3308      	adds	r3, #8
    for (int i = 0; i < 128; i++)
   29fd8:	4293      	cmp	r3, r2
   29fda:	d1fa      	bne.n	29fd2 <tSimplePoly_initToPool+0x2e>
    }
    poly->stealing_on = 1;
   29fdc:	2301      	movs	r3, #1
    poly->recover_stolen = 1;
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   29fde:	00a0      	lsls	r0, r4, #2
   29fe0:	4631      	mov	r1, r6
    poly->recover_stolen = 1;
   29fe2:	e9c5 3305 	strd	r3, r3, [r5, #20]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   29fe6:	f7ff fe4f 	bl	29c88 <mpool_alloc>

    for (int i = 0; i < poly->maxNumVoices; ++i)
   29fea:	68eb      	ldr	r3, [r5, #12]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
   29fec:	4680      	mov	r8, r0
   29fee:	6128      	str	r0, [r5, #16]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   29ff0:	2b00      	cmp	r3, #0
   29ff2:	dd14      	ble.n	2a01e <tSimplePoly_initToPool+0x7a>
   29ff4:	2400      	movs	r4, #0
    {
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
        poly->voices[i][0] = -1;
   29ff6:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   29ffa:	e001      	b.n	2a000 <tSimplePoly_initToPool+0x5c>
   29ffc:	f8d5 8010 	ldr.w	r8, [r5, #16]
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
   2a000:	4631      	mov	r1, r6
   2a002:	200c      	movs	r0, #12
   2a004:	f7ff fe40 	bl	29c88 <mpool_alloc>
   2a008:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
        poly->voices[i][0] = -1;
   2a00c:	692b      	ldr	r3, [r5, #16]
   2a00e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   2a012:	3401      	adds	r4, #1
        poly->voices[i][0] = -1;
   2a014:	f8c3 9000 	str.w	r9, [r3]
    for (int i = 0; i < poly->maxNumVoices; ++i)
   2a018:	68eb      	ldr	r3, [r5, #12]
   2a01a:	42a3      	cmp	r3, r4
   2a01c:	dcee      	bgt.n	29ffc <tSimplePoly_initToPool+0x58>
    _tMempool* m = *mp;
   2a01e:	683e      	ldr	r6, [r7, #0]
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   2a020:	f44f 7004 	mov.w	r0, #528	; 0x210
    ns->ordered = 0;
   2a024:	2400      	movs	r4, #0
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   2a026:	4631      	mov	r1, r6
   2a028:	f7ff fe2e 	bl	29c88 <mpool_alloc>
    ns->capacity = STACK_SIZE;
   2a02c:	2180      	movs	r1, #128	; 0x80
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
   2a02e:	4603      	mov	r3, r0
   2a030:	6068      	str	r0, [r5, #4]
   2a032:	f44f 7200 	mov.w	r2, #512	; 0x200
   2a036:	3004      	adds	r0, #4
    ns->capacity = STACK_SIZE;
   2a038:	f8a3 1208 	strh.w	r1, [r3, #520]	; 0x208
   2a03c:	21ff      	movs	r1, #255	; 0xff
    ns->mempool = m;
   2a03e:	601e      	str	r6, [r3, #0]
    ns->ordered = 0;
   2a040:	f8c3 420c 	str.w	r4, [r3, #524]	; 0x20c
    ns->pos = 0;
   2a044:	f8c3 4204 	str.w	r4, [r3, #516]	; 0x204
    }
    tStack_initToPool(&poly->stack, mp);

}
   2a048:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2a04c:	f002 bcf9 	b.w	2ca42 <memset>

0002a050 <tSimplePoly_noteOn>:
    mpool_free((char*)poly->voices, poly->mempool);
    mpool_free((char*)poly, poly->mempool);
}

int tSimplePoly_noteOn(tSimplePoly* const polyh, int note, uint8_t vel)
{
   2a050:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tSimplePoly* poly = *polyh;
   2a054:	6806      	ldr	r6, [r0, #0]
    _tStack* ns = *stack;
   2a056:	f8d6 c004 	ldr.w	ip, [r6, #4]
    for (int i = 0; i < ns->size; i++)
   2a05a:	f8bc 7206 	ldrh.w	r7, [ip, #518]	; 0x206
   2a05e:	b18f      	cbz	r7, 2a084 <tSimplePoly_noteOn+0x34>
   2a060:	b28d      	uxth	r5, r1
        if (ns->data[i] == noteVal)    return i;
   2a062:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2a066:	429d      	cmp	r5, r3
   2a068:	f000 809f 	beq.w	2a1aa <tSimplePoly_noteOn+0x15a>
   2a06c:	f10c 0004 	add.w	r0, ip, #4
    for (int i = 0; i < ns->size; i++)
   2a070:	2300      	movs	r3, #0
   2a072:	e004      	b.n	2a07e <tSimplePoly_noteOn+0x2e>
        if (ns->data[i] == noteVal)    return i;
   2a074:	f850 4f04 	ldr.w	r4, [r0, #4]!
   2a078:	42ac      	cmp	r4, r5
   2a07a:	f000 8096 	beq.w	2a1aa <tSimplePoly_noteOn+0x15a>
    for (int i = 0; i < ns->size; i++)
   2a07e:	3301      	adds	r3, #1
   2a080:	42bb      	cmp	r3, r7
   2a082:	d1f7      	bne.n	2a074 <tSimplePoly_noteOn+0x24>
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
    else
    {
        alteredVoice = -1;
        int found = 0;
        for (int i = 0; i < poly->numVoices; i++)
   2a084:	f8d6 8008 	ldr.w	r8, [r6, #8]
   2a088:	f1b8 0f00 	cmp.w	r8, #0
   2a08c:	dd29      	ble.n	2a0e2 <tSimplePoly_noteOn+0x92>
        {
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2a08e:	6933      	ldr	r3, [r6, #16]
   2a090:	f8d3 9000 	ldr.w	r9, [r3]
   2a094:	f8d9 b000 	ldr.w	fp, [r9]
   2a098:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
   2a09c:	f000 8089 	beq.w	2a1b2 <tSimplePoly_noteOn+0x162>
   2a0a0:	469e      	mov	lr, r3
        for (int i = 0; i < poly->numVoices; i++)
   2a0a2:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2a0a4:	461c      	mov	r4, r3
   2a0a6:	e005      	b.n	2a0b4 <tSimplePoly_noteOn+0x64>
   2a0a8:	f854 3f04 	ldr.w	r3, [r4, #4]!
   2a0ac:	681d      	ldr	r5, [r3, #0]
   2a0ae:	3501      	adds	r5, #1
   2a0b0:	f000 8082 	beq.w	2a1b8 <tSimplePoly_noteOn+0x168>
        for (int i = 0; i < poly->numVoices; i++)
   2a0b4:	3001      	adds	r0, #1
   2a0b6:	4540      	cmp	r0, r8
   2a0b8:	ea4f 0a80 	mov.w	sl, r0, lsl #2
   2a0bc:	d1f4      	bne.n	2a0a8 <tSimplePoly_noteOn+0x58>
        if (!found)
        {
            //second preference is grabbing one that is in release phase but not finished sounding yet
            for (int i = 0 ; i < poly->numVoices; i++)
            {
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2a0be:	f11b 0f02 	cmn.w	fp, #2
            for (int i = 0 ; i < poly->numVoices; i++)
   2a0c2:	f04f 0300 	mov.w	r3, #0
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2a0c6:	d107      	bne.n	2a0d8 <tSimplePoly_noteOn+0x88>
   2a0c8:	e0b4      	b.n	2a234 <tSimplePoly_noteOn+0x1e4>
   2a0ca:	f85e 9f04 	ldr.w	r9, [lr, #4]!
   2a0ce:	f8d9 4000 	ldr.w	r4, [r9]
   2a0d2:	3402      	adds	r4, #2
   2a0d4:	f000 80af 	beq.w	2a236 <tSimplePoly_noteOn+0x1e6>
            for (int i = 0 ; i < poly->numVoices; i++)
   2a0d8:	3301      	adds	r3, #1
   2a0da:	4298      	cmp	r0, r3
   2a0dc:	ea4f 0583 	mov.w	r5, r3, lsl #2
   2a0e0:	d1f3      	bne.n	2a0ca <tSimplePoly_noteOn+0x7a>
                    tStack_add(&poly->stack, note);
                    break;
                }
            }
        }
        if ((!found) && (poly->stealing_on)) //steal
   2a0e2:	6973      	ldr	r3, [r6, #20]
   2a0e4:	2b00      	cmp	r3, #0
   2a0e6:	d060      	beq.n	2a1aa <tSimplePoly_noteOn+0x15a>
        {
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
   2a0e8:	1e78      	subs	r0, r7, #1
   2a0ea:	2f00      	cmp	r7, #0
   2a0ec:	d05f      	beq.n	2a1ae <tSimplePoly_noteOn+0x15e>
    return ns->data[which];
   2a0ee:	eb0c 0380 	add.w	r3, ip, r0, lsl #2
            {
                whichNote = tStack_get(&poly->stack, j);
                whichVoice = poly->notes[whichNote][0];
   2a0f2:	685b      	ldr	r3, [r3, #4]
   2a0f4:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
   2a0f8:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
   2a0fa:	2b00      	cmp	r3, #0
   2a0fc:	da0b      	bge.n	2a116 <tSimplePoly_noteOn+0xc6>
   2a0fe:	eb0c 0787 	add.w	r7, ip, r7, lsl #2
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
   2a102:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
   2a106:	d352      	bcc.n	2a1ae <tSimplePoly_noteOn+0x15e>
                whichVoice = poly->notes[whichNote][0];
   2a108:	f857 3d04 	ldr.w	r3, [r7, #-4]!
   2a10c:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
   2a110:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
   2a112:	2b00      	cmp	r3, #0
   2a114:	dbf5      	blt.n	2a102 <tSimplePoly_noteOn+0xb2>
                {
                    oldNote = poly->voices[whichVoice][0];
   2a116:	6930      	ldr	r0, [r6, #16]
                    poly->voices[whichVoice][0] = note;
                    poly->voices[whichVoice][1] = vel;
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
                    poly->notes[note][0] = whichVoice;
   2a118:	eb06 05c1 	add.w	r5, r6, r1, lsl #3
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   2a11c:	f06f 0702 	mvn.w	r7, #2
                    oldNote = poly->voices[whichVoice][0];
   2a120:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   2a124:	6820      	ldr	r0, [r4, #0]
                    poly->voices[whichVoice][0] = note;
   2a126:	6021      	str	r1, [r4, #0]
                    poly->voices[whichVoice][1] = vel;
   2a128:	6934      	ldr	r4, [r6, #16]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   2a12a:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
                    poly->voices[whichVoice][1] = vel;
   2a12e:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
   2a132:	f8cc 2004 	str.w	r2, [ip, #4]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
   2a136:	61c7      	str	r7, [r0, #28]
   2a138:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = whichVoice;
   2a13a:	61eb      	str	r3, [r5, #28]
                    poly->notes[note][1] = vel;
   2a13c:	622a      	str	r2, [r5, #32]

                    poly->voices[whichVoice][2] = note;
   2a13e:	6932      	ldr	r2, [r6, #16]
   2a140:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2a144:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
   2a146:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
   2a148:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
   2a14c:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
   2a150:	b1a4      	cbz	r4, 2a17c <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
   2a152:	f1bc 0f00 	cmp.w	ip, #0
   2a156:	f000 80a3 	beq.w	2a2a0 <tSimplePoly_noteOn+0x250>
   2a15a:	2200      	movs	r2, #0
   2a15c:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a160:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
   2a162:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a164:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
   2a166:	42be      	cmp	r6, r7
   2a168:	da04      	bge.n	2a174 <tSimplePoly_noteOn+0x124>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a16a:	68aa      	ldr	r2, [r5, #8]
   2a16c:	1c55      	adds	r5, r2, #1
   2a16e:	d005      	beq.n	2a17c <tSimplePoly_noteOn+0x12c>
   2a170:	42ba      	cmp	r2, r7
   2a172:	dc03      	bgt.n	2a17c <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
   2a174:	b2c2      	uxtb	r2, r0
   2a176:	4562      	cmp	r2, ip
   2a178:	d3f0      	bcc.n	2a15c <tSimplePoly_noteOn+0x10c>
    int whereToInsert = 0;
   2a17a:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
   2a17c:	fa5f f28c 	uxtb.w	r2, ip
   2a180:	4294      	cmp	r4, r2
   2a182:	da08      	bge.n	2a196 <tSimplePoly_noteOn+0x146>
   2a184:	1e56      	subs	r6, r2, #1
   2a186:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2a18a:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2a18e:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
   2a190:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2a192:	42a2      	cmp	r2, r4
   2a194:	dcf6      	bgt.n	2a184 <tSimplePoly_noteOn+0x134>
    ns->data[whereToInsert] = noteVal;
   2a196:	eb01 0484 	add.w	r4, r1, r4, lsl #2
    ns->size++;
   2a19a:	f10c 0c01 	add.w	ip, ip, #1
   2a19e:	4618      	mov	r0, r3
    ns->data[whereToInsert] = noteVal;
   2a1a0:	6067      	str	r7, [r4, #4]
    ns->size++;
   2a1a2:	f8a1 c206 	strh.w	ip, [r1, #518]	; 0x206
                }
            }
        }
        return alteredVoice;
    }
}
   2a1a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
   2a1aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   2a1ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (int i = 0; i < poly->numVoices; i++)
   2a1b2:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
   2a1b4:	464b      	mov	r3, r9
   2a1b6:	4682      	mov	sl, r0
                poly->voices[i][0] = note;
   2a1b8:	6019      	str	r1, [r3, #0]
                poly->notes[note][0] = i;
   2a1ba:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                poly->voices[i][1] = vel;
   2a1be:	6935      	ldr	r5, [r6, #16]
   2a1c0:	b28f      	uxth	r7, r1
   2a1c2:	f855 500a 	ldr.w	r5, [r5, sl]
   2a1c6:	606a      	str	r2, [r5, #4]
                poly->notes[note][0] = i;
   2a1c8:	61e0      	str	r0, [r4, #28]
                poly->notes[note][1] = vel;
   2a1ca:	6222      	str	r2, [r4, #32]
                poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
   2a1cc:	6933      	ldr	r3, [r6, #16]
   2a1ce:	f853 300a 	ldr.w	r3, [r3, sl]
   2a1d2:	6099      	str	r1, [r3, #8]
    _tStack* ns = *stack;
   2a1d4:	6872      	ldr	r2, [r6, #4]
    if (ns->ordered)
   2a1d6:	f8d2 420c 	ldr.w	r4, [r2, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
   2a1da:	f8b2 c206 	ldrh.w	ip, [r2, #518]	; 0x206
    if (ns->ordered)
   2a1de:	b19c      	cbz	r4, 2a208 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
   2a1e0:	f1bc 0f00 	cmp.w	ip, #0
   2a1e4:	d05e      	beq.n	2a2a4 <tSimplePoly_noteOn+0x254>
   2a1e6:	2300      	movs	r3, #0
   2a1e8:	eb02 0583 	add.w	r5, r2, r3, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a1ec:	1c59      	adds	r1, r3, #1
            if (noteVal > ns->data[j])
   2a1ee:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a1f0:	460c      	mov	r4, r1
            if (noteVal > ns->data[j])
   2a1f2:	42be      	cmp	r6, r7
   2a1f4:	da04      	bge.n	2a200 <tSimplePoly_noteOn+0x1b0>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a1f6:	68ab      	ldr	r3, [r5, #8]
   2a1f8:	1c5d      	adds	r5, r3, #1
   2a1fa:	d005      	beq.n	2a208 <tSimplePoly_noteOn+0x1b8>
   2a1fc:	42bb      	cmp	r3, r7
   2a1fe:	dc03      	bgt.n	2a208 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
   2a200:	b2cb      	uxtb	r3, r1
   2a202:	459c      	cmp	ip, r3
   2a204:	d8f0      	bhi.n	2a1e8 <tSimplePoly_noteOn+0x198>
    int whereToInsert = 0;
   2a206:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
   2a208:	fa5f f38c 	uxtb.w	r3, ip
   2a20c:	42a3      	cmp	r3, r4
   2a20e:	dd08      	ble.n	2a222 <tSimplePoly_noteOn+0x1d2>
   2a210:	1e5e      	subs	r6, r3, #1
   2a212:	eb02 0183 	add.w	r1, r2, r3, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2a216:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2a21a:	b2f3      	uxtb	r3, r6
        ns->data[j] = ns->data[(j - 1)];
   2a21c:	604d      	str	r5, [r1, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2a21e:	42a3      	cmp	r3, r4
   2a220:	dcf6      	bgt.n	2a210 <tSimplePoly_noteOn+0x1c0>
    ns->data[whereToInsert] = noteVal;
   2a222:	eb02 0484 	add.w	r4, r2, r4, lsl #2
    ns->size++;
   2a226:	f10c 0c01 	add.w	ip, ip, #1
    ns->data[whereToInsert] = noteVal;
   2a22a:	6067      	str	r7, [r4, #4]
    ns->size++;
   2a22c:	f8a2 c206 	strh.w	ip, [r2, #518]	; 0x206
}
   2a230:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
   2a234:	461d      	mov	r5, r3
                    poly->voices[i][0] = note;
   2a236:	f8c9 1000 	str.w	r1, [r9]
                    poly->notes[note][0] = i;
   2a23a:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                    poly->voices[i][1] = vel;
   2a23e:	6937      	ldr	r7, [r6, #16]
   2a240:	597f      	ldr	r7, [r7, r5]
   2a242:	607a      	str	r2, [r7, #4]
   2a244:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = i;
   2a246:	61e3      	str	r3, [r4, #28]
                    poly->notes[note][1] = vel;
   2a248:	6222      	str	r2, [r4, #32]
                    poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
   2a24a:	6932      	ldr	r2, [r6, #16]
   2a24c:	5952      	ldr	r2, [r2, r5]
   2a24e:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
   2a250:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
   2a252:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
   2a256:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
   2a25a:	b19c      	cbz	r4, 2a284 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
   2a25c:	f1bc 0f00 	cmp.w	ip, #0
   2a260:	d01e      	beq.n	2a2a0 <tSimplePoly_noteOn+0x250>
   2a262:	2200      	movs	r2, #0
   2a264:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a268:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
   2a26a:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a26c:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
   2a26e:	42be      	cmp	r6, r7
   2a270:	da04      	bge.n	2a27c <tSimplePoly_noteOn+0x22c>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
   2a272:	68aa      	ldr	r2, [r5, #8]
   2a274:	1c56      	adds	r6, r2, #1
   2a276:	d005      	beq.n	2a284 <tSimplePoly_noteOn+0x234>
   2a278:	42ba      	cmp	r2, r7
   2a27a:	dc03      	bgt.n	2a284 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
   2a27c:	b2c2      	uxtb	r2, r0
   2a27e:	4562      	cmp	r2, ip
   2a280:	d3f0      	bcc.n	2a264 <tSimplePoly_noteOn+0x214>
    int whereToInsert = 0;
   2a282:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
   2a284:	fa5f f28c 	uxtb.w	r2, ip
   2a288:	4294      	cmp	r4, r2
   2a28a:	da84      	bge.n	2a196 <tSimplePoly_noteOn+0x146>
   2a28c:	1e56      	subs	r6, r2, #1
   2a28e:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
   2a292:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
   2a296:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
   2a298:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
   2a29a:	42a2      	cmp	r2, r4
   2a29c:	dcf6      	bgt.n	2a28c <tSimplePoly_noteOn+0x23c>
   2a29e:	e77a      	b.n	2a196 <tSimplePoly_noteOn+0x146>
    int whereToInsert = 0;
   2a2a0:	4664      	mov	r4, ip
   2a2a2:	e778      	b.n	2a196 <tSimplePoly_noteOn+0x146>
   2a2a4:	4664      	mov	r4, ip
   2a2a6:	e7bc      	b.n	2a222 <tSimplePoly_noteOn+0x1d2>

0002a2a8 <tSimplePoly_noteOff>:



int tSimplePoly_noteOff(tSimplePoly* const polyh, uint8_t note)
{
   2a2a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
   2a2ac:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
   2a2ae:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
   2a2b2:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
   2a2b6:	b178      	cbz	r0, 2a2d8 <tSimplePoly_noteOff+0x30>
        if (ns->data[i] == noteVal)    return i;
   2a2b8:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2a2bc:	428b      	cmp	r3, r1
   2a2be:	f000 808a 	beq.w	2a3d6 <tSimplePoly_noteOff+0x12e>
   2a2c2:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
   2a2c6:	2600      	movs	r6, #0
   2a2c8:	e003      	b.n	2a2d2 <tSimplePoly_noteOff+0x2a>
        if (ns->data[i] == noteVal)    return i;
   2a2ca:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a2ce:	428a      	cmp	r2, r1
   2a2d0:	d057      	beq.n	2a382 <tSimplePoly_noteOff+0xda>
    for (int i = 0; i < ns->size; i++)
   2a2d2:	3601      	adds	r6, #1
   2a2d4:	4286      	cmp	r6, r0
   2a2d6:	d1f8      	bne.n	2a2ca <tSimplePoly_noteOff+0x22>
    int16_t noteToTest = -1;

    tStack_remove(&poly->stack, note);
    poly->notes[note][0] = -1;
   2a2d8:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
   2a2dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a2e0:	61d8      	str	r0, [r3, #28]

    int deactivatedVoice = -1;
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a2e2:	68ee      	ldr	r6, [r5, #12]
   2a2e4:	2e00      	cmp	r6, #0
   2a2e6:	dd12      	ble.n	2a30e <tSimplePoly_noteOff+0x66>
    {
        if (poly->voices[i][0] == note)
   2a2e8:	692b      	ldr	r3, [r5, #16]
   2a2ea:	681a      	ldr	r2, [r3, #0]
   2a2ec:	6810      	ldr	r0, [r2, #0]
   2a2ee:	4288      	cmp	r0, r1
   2a2f0:	d00f      	beq.n	2a312 <tSimplePoly_noteOff+0x6a>
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a2f2:	2000      	movs	r0, #0
   2a2f4:	e004      	b.n	2a300 <tSimplePoly_noteOff+0x58>
        if (poly->voices[i][0] == note)
   2a2f6:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a2fa:	6814      	ldr	r4, [r2, #0]
   2a2fc:	428c      	cmp	r4, r1
   2a2fe:	d00a      	beq.n	2a316 <tSimplePoly_noteOff+0x6e>
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a300:	3001      	adds	r0, #1
   2a302:	42b0      	cmp	r0, r6
   2a304:	ea4f 0780 	mov.w	r7, r0, lsl #2
   2a308:	d1f5      	bne.n	2a2f6 <tSimplePoly_noteOff+0x4e>
                {
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
                    poly->voices[deactivatedVoice][2] = noteToTest;
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
                    return -1;
   2a30a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                }
            }
        }
    }
    return deactivatedVoice;
}
   2a30e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    for (int i = 0; i < poly->maxNumVoices; i++)
   2a312:	2000      	movs	r0, #0
        if (poly->voices[i][0] == note)
   2a314:	4607      	mov	r7, r0
            poly->voices[i][0] = -1;
   2a316:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
            poly->voices[i][1] = 0;
   2a31a:	2600      	movs	r6, #0
            poly->voices[i][0] = -1;
   2a31c:	6013      	str	r3, [r2, #0]
            poly->voices[i][1] = 0;
   2a31e:	692b      	ldr	r3, [r5, #16]
   2a320:	59db      	ldr	r3, [r3, r7]
   2a322:	605e      	str	r6, [r3, #4]
    if (poly->recover_stolen)
   2a324:	69ab      	ldr	r3, [r5, #24]
   2a326:	2b00      	cmp	r3, #0
   2a328:	d0f1      	beq.n	2a30e <tSimplePoly_noteOff+0x66>
    _tStack* ns = *stack;
   2a32a:	6869      	ldr	r1, [r5, #4]
    return ns->size;
   2a32c:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a330:	f1bc 0f00 	cmp.w	ip, #0
   2a334:	d0eb      	beq.n	2a30e <tSimplePoly_noteOff+0x66>
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a336:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   2a33a:	1cdc      	adds	r4, r3, #3
   2a33c:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   2a340:	6852      	ldr	r2, [r2, #4]
   2a342:	3203      	adds	r2, #3
   2a344:	d00d      	beq.n	2a362 <tSimplePoly_noteOff+0xba>
   2a346:	3104      	adds	r1, #4
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a348:	4632      	mov	r2, r6
   2a34a:	3201      	adds	r2, #1
   2a34c:	4562      	cmp	r2, ip
   2a34e:	d0de      	beq.n	2a30e <tSimplePoly_noteOff+0x66>
                noteToTest = tStack_get(&poly->stack, j);
   2a350:	f851 3f04 	ldr.w	r3, [r1, #4]!
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a354:	b21b      	sxth	r3, r3
   2a356:	1cdc      	adds	r4, r3, #3
   2a358:	eb05 06c4 	add.w	r6, r5, r4, lsl #3
   2a35c:	6876      	ldr	r6, [r6, #4]
   2a35e:	3603      	adds	r6, #3
   2a360:	d1f3      	bne.n	2a34a <tSimplePoly_noteOff+0xa2>
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a362:	692a      	ldr	r2, [r5, #16]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a364:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
   2a368:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a36c:	59d2      	ldr	r2, [r2, r7]
   2a36e:	6013      	str	r3, [r2, #0]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a370:	692a      	ldr	r2, [r5, #16]
   2a372:	6a09      	ldr	r1, [r1, #32]
   2a374:	59d2      	ldr	r2, [r2, r7]
   2a376:	6051      	str	r1, [r2, #4]
                    poly->voices[deactivatedVoice][2] = noteToTest;
   2a378:	692a      	ldr	r2, [r5, #16]
   2a37a:	59d2      	ldr	r2, [r2, r7]
   2a37c:	6093      	str	r3, [r2, #8]
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
   2a37e:	6060      	str	r0, [r4, #4]
   2a380:	e7c3      	b.n	2a30a <tSimplePoly_noteOff+0x62>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a382:	eba0 0806 	sub.w	r8, r0, r6
   2a386:	f1b8 0f00 	cmp.w	r8, #0
   2a38a:	dd22      	ble.n	2a3d2 <tSimplePoly_noteOff+0x12a>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a38c:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
   2a390:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
   2a392:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2a396:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a398:	4613      	mov	r3, r2
   2a39a:	44ce      	add	lr, r9
   2a39c:	e006      	b.n	2a3ac <tSimplePoly_noteOff+0x104>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a39e:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
   2a3a0:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a3a4:	b2d2      	uxtb	r2, r2
   2a3a6:	4590      	cmp	r8, r2
   2a3a8:	4613      	mov	r3, r2
   2a3aa:	dd0f      	ble.n	2a3cc <tSimplePoly_noteOff+0x124>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a3ac:	4433      	add	r3, r6
   2a3ae:	4573      	cmp	r3, lr
   2a3b0:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
   2a3b4:	daf3      	bge.n	2a39e <tSimplePoly_noteOff+0xf6>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a3b6:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
   2a3b8:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a3ba:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a3bc:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
   2a3be:	bf08      	it	eq
   2a3c0:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a3c4:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a3c6:	4590      	cmp	r8, r2
   2a3c8:	4613      	mov	r3, r2
   2a3ca:	dcef      	bgt.n	2a3ac <tSimplePoly_noteOff+0x104>
        ns->size--;
   2a3cc:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
   2a3d0:	e782      	b.n	2a2d8 <tSimplePoly_noteOff+0x30>
   2a3d2:	3801      	subs	r0, #1
   2a3d4:	e7fa      	b.n	2a3cc <tSimplePoly_noteOff+0x124>
        if (ns->data[i] == noteVal)    return i;
   2a3d6:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
   2a3d8:	2600      	movs	r6, #0
   2a3da:	e7d7      	b.n	2a38c <tSimplePoly_noteOff+0xe4>

0002a3dc <tSimplePoly_deactivateVoice>:


void tSimplePoly_deactivateVoice(tSimplePoly* const polyh, uint8_t voice)
{
   2a3dc:	b4f0      	push	{r4, r5, r6, r7}
    _tSimplePoly* poly = *polyh;
   2a3de:	6803      	ldr	r3, [r0, #0]

    if (poly->voices[voice][0] == -2) //only do this if the voice is waiting for deactivation (not already reassigned while waiting)
   2a3e0:	b208      	sxth	r0, r1
   2a3e2:	691a      	ldr	r2, [r3, #16]
   2a3e4:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
   2a3e8:	6822      	ldr	r2, [r4, #0]
   2a3ea:	3202      	adds	r2, #2
   2a3ec:	d001      	beq.n	2a3f2 <tSimplePoly_deactivateVoice+0x16>
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
                }
            }
        }
    }
}
   2a3ee:	bcf0      	pop	{r4, r5, r6, r7}
   2a3f0:	4770      	bx	lr
        poly->voices[voice][0] = -1;
   2a3f2:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2a3f6:	0085      	lsls	r5, r0, #2
        poly->voices[voice][1] = 0;
   2a3f8:	2200      	movs	r2, #0
        poly->voices[voice][0] = -1;
   2a3fa:	6026      	str	r6, [r4, #0]
        poly->voices[voice][1] = 0;
   2a3fc:	691c      	ldr	r4, [r3, #16]
   2a3fe:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
   2a402:	6042      	str	r2, [r0, #4]
        if (poly->recover_stolen)
   2a404:	6998      	ldr	r0, [r3, #24]
   2a406:	2800      	cmp	r0, #0
   2a408:	d0f1      	beq.n	2a3ee <tSimplePoly_deactivateVoice+0x12>
    _tStack* ns = *stack;
   2a40a:	6858      	ldr	r0, [r3, #4]
    return ns->size;
   2a40c:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a410:	2e00      	cmp	r6, #0
   2a412:	d0ec      	beq.n	2a3ee <tSimplePoly_deactivateVoice+0x12>
   2a414:	4607      	mov	r7, r0
   2a416:	f8df c054 	ldr.w	ip, [pc, #84]	; 2a46c <tSimplePoly_deactivateVoice+0x90>
    return ns->data[which];
   2a41a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
                noteToTest = tStack_get(&poly->stack, j);
   2a41e:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a422:	eb03 04c0 	add.w	r4, r3, r0, lsl #3
                noteToTest = tStack_get(&poly->stack, j);
   2a426:	f8ac 0000 	strh.w	r0, [ip]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
   2a42a:	69e4      	ldr	r4, [r4, #28]
   2a42c:	3403      	adds	r4, #3
   2a42e:	d004      	beq.n	2a43a <tSimplePoly_deactivateVoice+0x5e>
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a430:	3201      	adds	r2, #1
   2a432:	42b2      	cmp	r2, r6
   2a434:	dadb      	bge.n	2a3ee <tSimplePoly_deactivateVoice+0x12>
{
   2a436:	4638      	mov	r0, r7
   2a438:	e7ef      	b.n	2a41a <tSimplePoly_deactivateVoice+0x3e>
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a43a:	691c      	ldr	r4, [r3, #16]
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a43c:	3201      	adds	r2, #1
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
   2a43e:	5964      	ldr	r4, [r4, r5]
   2a440:	6020      	str	r0, [r4, #0]
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a442:	f9bc 0000 	ldrsh.w	r0, [ip]
   2a446:	691c      	ldr	r4, [r3, #16]
   2a448:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
   2a44c:	5967      	ldr	r7, [r4, r5]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
   2a44e:	4634      	mov	r4, r6
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
   2a450:	6a36      	ldr	r6, [r6, #32]
   2a452:	607e      	str	r6, [r7, #4]
                    poly->voices[voice][2] = noteToTest;
   2a454:	691e      	ldr	r6, [r3, #16]
   2a456:	5976      	ldr	r6, [r6, r5]
   2a458:	60b0      	str	r0, [r6, #8]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
   2a45a:	61e1      	str	r1, [r4, #28]
   2a45c:	685f      	ldr	r7, [r3, #4]
   2a45e:	f8b7 6206 	ldrh.w	r6, [r7, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
   2a462:	4296      	cmp	r6, r2
   2a464:	ddc3      	ble.n	2a3ee <tSimplePoly_deactivateVoice+0x12>
{
   2a466:	4638      	mov	r0, r7
   2a468:	e7d7      	b.n	2a41a <tSimplePoly_deactivateVoice+0x3e>
   2a46a:	bf00      	nop
   2a46c:	00062c24 	.word	0x00062c24

0002a470 <tSimplePoly_markPendingNoteOff>:
    return voiceWithThatNote;
}


int tSimplePoly_markPendingNoteOff(tSimplePoly* const polyh, uint8_t note)
{
   2a470:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
   2a474:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
   2a476:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
   2a47a:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
   2a47e:	b170      	cbz	r0, 2a49e <tSimplePoly_markPendingNoteOff+0x2e>
        if (ns->data[i] == noteVal)    return i;
   2a480:	f8dc 3004 	ldr.w	r3, [ip, #4]
   2a484:	428b      	cmp	r3, r1
   2a486:	d05c      	beq.n	2a542 <tSimplePoly_markPendingNoteOff+0xd2>
   2a488:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
   2a48c:	2600      	movs	r6, #0
   2a48e:	e003      	b.n	2a498 <tSimplePoly_markPendingNoteOff+0x28>
        if (ns->data[i] == noteVal)    return i;
   2a490:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a494:	4291      	cmp	r1, r2
   2a496:	d006      	beq.n	2a4a6 <tSimplePoly_markPendingNoteOff+0x36>
    for (int i = 0; i < ns->size; i++)
   2a498:	3601      	adds	r6, #1
   2a49a:	42b0      	cmp	r0, r6
   2a49c:	d1f8      	bne.n	2a490 <tSimplePoly_markPendingNoteOff+0x20>
    int deactivatedVoice = -1;
   2a49e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }


    }
    return deactivatedVoice;
}
   2a4a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a4a6:	eba0 0806 	sub.w	r8, r0, r6
   2a4aa:	f1b8 0f00 	cmp.w	r8, #0
   2a4ae:	dd46      	ble.n	2a53e <tSimplePoly_markPendingNoteOff+0xce>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a4b0:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
   2a4b4:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
   2a4b6:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   2a4ba:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a4bc:	4613      	mov	r3, r2
   2a4be:	44ce      	add	lr, r9
   2a4c0:	e006      	b.n	2a4d0 <tSimplePoly_markPendingNoteOff+0x60>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a4c2:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
   2a4c4:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a4c8:	b2d2      	uxtb	r2, r2
   2a4ca:	4590      	cmp	r8, r2
   2a4cc:	4613      	mov	r3, r2
   2a4ce:	dd0f      	ble.n	2a4f0 <tSimplePoly_markPendingNoteOff+0x80>
            if ((k+foundIndex) >= (ns->capacity - 1))
   2a4d0:	4433      	add	r3, r6
   2a4d2:	4573      	cmp	r3, lr
   2a4d4:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
   2a4d8:	daf3      	bge.n	2a4c2 <tSimplePoly_markPendingNoteOff+0x52>
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a4da:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
   2a4dc:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a4de:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a4e0:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
   2a4e2:	bf08      	it	eq
   2a4e4:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
   2a4e8:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
   2a4ea:	4590      	cmp	r8, r2
   2a4ec:	4613      	mov	r3, r2
   2a4ee:	dcef      	bgt.n	2a4d0 <tSimplePoly_markPendingNoteOff+0x60>
        poly->notes[note][0] = -2;
   2a4f0:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
   2a4f4:	f06f 0201 	mvn.w	r2, #1
        ns->size--;
   2a4f8:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
        poly->notes[note][0] = -2;
   2a4fc:	61da      	str	r2, [r3, #28]
        for (int i = 0; i < poly->maxNumVoices; i++)
   2a4fe:	68ee      	ldr	r6, [r5, #12]
   2a500:	2e00      	cmp	r6, #0
   2a502:	ddcc      	ble.n	2a49e <tSimplePoly_markPendingNoteOff+0x2e>
            if (poly->voices[i][0] == note)
   2a504:	692b      	ldr	r3, [r5, #16]
   2a506:	681a      	ldr	r2, [r3, #0]
   2a508:	6810      	ldr	r0, [r2, #0]
   2a50a:	4281      	cmp	r1, r0
   2a50c:	d00c      	beq.n	2a528 <tSimplePoly_markPendingNoteOff+0xb8>
        for (int i = 0; i < poly->maxNumVoices; i++)
   2a50e:	2000      	movs	r0, #0
   2a510:	e004      	b.n	2a51c <tSimplePoly_markPendingNoteOff+0xac>
            if (poly->voices[i][0] == note)
   2a512:	f853 2f04 	ldr.w	r2, [r3, #4]!
   2a516:	6814      	ldr	r4, [r2, #0]
   2a518:	428c      	cmp	r4, r1
   2a51a:	d007      	beq.n	2a52c <tSimplePoly_markPendingNoteOff+0xbc>
        for (int i = 0; i < poly->maxNumVoices; i++)
   2a51c:	3001      	adds	r0, #1
   2a51e:	42b0      	cmp	r0, r6
   2a520:	ea4f 0780 	mov.w	r7, r0, lsl #2
   2a524:	d1f5      	bne.n	2a512 <tSimplePoly_markPendingNoteOff+0xa2>
   2a526:	e7ba      	b.n	2a49e <tSimplePoly_markPendingNoteOff+0x2e>
   2a528:	2000      	movs	r0, #0
            if (poly->voices[i][0] == note)
   2a52a:	4607      	mov	r7, r0
                poly->voices[i][0] = -2;
   2a52c:	f06f 0301 	mvn.w	r3, #1
                poly->voices[i][1] = 0;
   2a530:	2100      	movs	r1, #0
                poly->voices[i][0] = -2;
   2a532:	6013      	str	r3, [r2, #0]
                poly->voices[i][1] = 0;
   2a534:	692b      	ldr	r3, [r5, #16]
   2a536:	59db      	ldr	r3, [r3, r7]
   2a538:	6059      	str	r1, [r3, #4]
}
   2a53a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2a53e:	3801      	subs	r0, #1
   2a540:	e7d6      	b.n	2a4f0 <tSimplePoly_markPendingNoteOff+0x80>
        if (ns->data[i] == noteVal)    return i;
   2a542:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
   2a544:	2600      	movs	r6, #0
   2a546:	e7b3      	b.n	2a4b0 <tSimplePoly_markPendingNoteOff+0x40>

0002a548 <tSimplePoly_setNumVoices>:

void tSimplePoly_setNumVoices(tSimplePoly* const polyh, uint8_t numVoices)
{
    _tSimplePoly* poly = *polyh;
   2a548:	6802      	ldr	r2, [r0, #0]
    poly->numVoices = (numVoices > poly->maxNumVoices) ? poly->maxNumVoices : numVoices;
   2a54a:	68d3      	ldr	r3, [r2, #12]
   2a54c:	4299      	cmp	r1, r3
   2a54e:	bfa8      	it	ge
   2a550:	4619      	movge	r1, r3
   2a552:	6091      	str	r1, [r2, #8]
}
   2a554:	4770      	bx	lr
   2a556:	bf00      	nop

0002a558 <tSimplePoly_getNumVoices>:


int tSimplePoly_getNumVoices(tSimplePoly* const polyh)
{
    _tSimplePoly* poly = *polyh;
    return poly->numVoices;
   2a558:	6803      	ldr	r3, [r0, #0]
}
   2a55a:	6898      	ldr	r0, [r3, #8]
   2a55c:	4770      	bx	lr
   2a55e:	bf00      	nop

0002a560 <tSimplePoly_getNumActiveVoices>:

int tSimplePoly_getNumActiveVoices(tSimplePoly* const polyh)
{
   2a560:	b508      	push	{r3, lr}
    _tSimplePoly* poly = *polyh;
   2a562:	6803      	ldr	r3, [r0, #0]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a564:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2a58c <tSimplePoly_getNumActiveVoices+0x2c>
    return ns->size;
   2a568:	685a      	ldr	r2, [r3, #4]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a56a:	ed93 1a02 	vldr	s2, [r3, #8]
    return ns->size;
   2a56e:	f8b2 3206 	ldrh.w	r3, [r2, #518]	; 0x206
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a572:	eeb8 1ac1 	vcvt.f32.s32	s2, s2
    return ns->size;
   2a576:	ee00 3a90 	vmov	s1, r3
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
   2a57a:	eef8 0ae0 	vcvt.f32.s32	s1, s1
   2a57e:	f7ff f983 	bl	29888 <LEAF_clip>
}
   2a582:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2a586:	ee17 0a90 	vmov	r0, s15
   2a58a:	bd08      	pop	{r3, pc}
   2a58c:	00000000 	.word	0x00000000

0002a590 <tSimplePoly_getPitch>:


int tSimplePoly_getPitch(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][2];
   2a590:	6803      	ldr	r3, [r0, #0]
   2a592:	691b      	ldr	r3, [r3, #16]
   2a594:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2a598:	6898      	ldr	r0, [r3, #8]
   2a59a:	4770      	bx	lr

0002a59c <tSimplePoly_getPitchAndCheckActive>:

//this one returns negative one if the voice is inactive
int tSimplePoly_getPitchAndCheckActive(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][0];
   2a59c:	6803      	ldr	r3, [r0, #0]
   2a59e:	691b      	ldr	r3, [r3, #16]
   2a5a0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2a5a4:	6818      	ldr	r0, [r3, #0]
   2a5a6:	4770      	bx	lr

0002a5a8 <tSimplePoly_getVelocity>:

int tSimplePoly_getVelocity(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][1];
   2a5a8:	6803      	ldr	r3, [r0, #0]
   2a5aa:	691b      	ldr	r3, [r3, #16]
   2a5ac:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
   2a5b0:	6858      	ldr	r0, [r3, #4]
   2a5b2:	4770      	bx	lr

0002a5b4 <tSimplePoly_isOn>:

int tSimplePoly_isOn(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return (poly->voices[voice][0] > 0) ? 1 : 0;
   2a5b4:	6803      	ldr	r3, [r0, #0]
   2a5b6:	691b      	ldr	r3, [r3, #16]
   2a5b8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   2a5bc:	6818      	ldr	r0, [r3, #0]
}
   2a5be:	2800      	cmp	r0, #0
   2a5c0:	bfd4      	ite	le
   2a5c2:	2000      	movle	r0, #0
   2a5c4:	2001      	movgt	r0, #1
   2a5c6:	4770      	bx	lr

0002a5c8 <tCycle_initToPool>:
{
    tCycle_initToPool(cy, &leaf.mempool);
}

void    tCycle_initToPool   (tCycle* const cy, tMempool* const mp)
{
   2a5c8:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
   2a5ca:	680c      	ldr	r4, [r1, #0]
{
   2a5cc:	4605      	mov	r5, r0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
   2a5ce:	2010      	movs	r0, #16
   2a5d0:	4621      	mov	r1, r4
   2a5d2:	f7ff fb59 	bl	29c88 <mpool_alloc>
    c->mempool = m;
    
    c->inc      =  0.0f;
   2a5d6:	2300      	movs	r3, #0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
   2a5d8:	6028      	str	r0, [r5, #0]
    c->mempool = m;
   2a5da:	6004      	str	r4, [r0, #0]
    c->inc      =  0.0f;
   2a5dc:	6083      	str	r3, [r0, #8]
    c->phase    =  0.0f;
   2a5de:	6043      	str	r3, [r0, #4]
}
   2a5e0:	bd38      	pop	{r3, r4, r5, pc}
   2a5e2:	bf00      	nop

0002a5e4 <tCycle_free>:

void    tCycle_free (tCycle* const cy)
{
    _tCycle* c = *cy;
   2a5e4:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)c, c->mempool);
   2a5e6:	6801      	ldr	r1, [r0, #0]
   2a5e8:	f7ff bbf6 	b.w	29dd8 <mpool_free>

0002a5ec <tCycle_setFreq>:
{
    _tCycle* c = *cy;
    
    c->freq  = freq;

    c->inc = freq * leaf.invSampleRate;
   2a5ec:	4a05      	ldr	r2, [pc, #20]	; (2a604 <tCycle_setFreq+0x18>)
    _tCycle* c = *cy;
   2a5ee:	6803      	ldr	r3, [r0, #0]
    c->inc = freq * leaf.invSampleRate;
   2a5f0:	edd2 7a01 	vldr	s15, [r2, #4]
    c->freq  = freq;
   2a5f4:	ed83 0a03 	vstr	s0, [r3, #12]
    c->inc = freq * leaf.invSampleRate;
   2a5f8:	ee27 0a80 	vmul.f32	s0, s15, s0
   2a5fc:	ed83 0a02 	vstr	s0, [r3, #8]
}
   2a600:	4770      	bx	lr
   2a602:	bf00      	nop
   2a604:	020fc0a8 	.word	0x020fc0a8

0002a608 <tCycle_tick>:

//need to check bounds and wrap table properly to allow through-zero FM
float   tCycle_tick(tCycle* const cy)
{
    _tCycle* c = *cy;
   2a608:	6803      	ldr	r3, [r0, #0]
    float samp0;
    float samp1;
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a60a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
   2a60e:	ed93 7a01 	vldr	s14, [r3, #4]
   2a612:	edd3 7a02 	vldr	s15, [r3, #8]
   2a616:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a61a:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
   2a61e:	ed83 7a01 	vstr	s14, [r3, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a622:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a626:	db3f      	blt.n	2a6a8 <tCycle_tick+0xa0>
   2a628:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2a62c:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2a630:	ee77 7a66 	vsub.f32	s15, s14, s13
   2a634:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a638:	eeb0 7a67 	vmov.f32	s14, s15
   2a63c:	daf6      	bge.n	2a62c <tCycle_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a63e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a642:	edc3 7a01 	vstr	s15, [r3, #4]
   2a646:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a64a:	d534      	bpl.n	2a6b6 <tCycle_tick+0xae>
   2a64c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2a650:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2a654:	eef4 7ae6 	vcmpe.f32	s15, s13
   2a658:	ee37 7a86 	vadd.f32	s14, s15, s12
   2a65c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a660:	eef0 7a47 	vmov.f32	s15, s14
   2a664:	d4f6      	bmi.n	2a654 <tCycle_tick+0x4c>
   2a666:	ed83 7a01 	vstr	s14, [r3, #4]

    // Wavetable synthesis

	temp = SINE_TABLE_SIZE * c->phase;
   2a66a:	eddf 7a14 	vldr	s15, [pc, #80]	; 2a6bc <tCycle_tick+0xb4>
	intPart = (int)temp;
	fracPart = temp - (float)intPart;
	samp0 = __leaf_table_sinewave[intPart];
   2a66e:	4a14      	ldr	r2, [pc, #80]	; (2a6c0 <tCycle_tick+0xb8>)
	temp = SINE_TABLE_SIZE * c->phase;
   2a670:	ee27 7a27 	vmul.f32	s14, s14, s15
	intPart = (int)temp;
   2a674:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   2a678:	ee17 3a90 	vmov	r3, s15
	fracPart = temp - (float)intPart;
   2a67c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2a680:	1c59      	adds	r1, r3, #1
	samp0 = __leaf_table_sinewave[intPart];
   2a682:	eb02 0083 	add.w	r0, r2, r3, lsl #2
	fracPart = temp - (float)intPart;
   2a686:	ee37 7a67 	vsub.f32	s14, s14, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2a68a:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
	samp0 = __leaf_table_sinewave[intPart];
   2a68e:	ed90 0a00 	vldr	s0, [r0]
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
   2a692:	bfa8      	it	ge
   2a694:	2100      	movge	r1, #0
	samp1 = __leaf_table_sinewave[intPart];
   2a696:	eb02 0281 	add.w	r2, r2, r1, lsl #2

    return (samp0 + (samp1 - samp0) * fracPart);
   2a69a:	edd2 7a00 	vldr	s15, [r2]
   2a69e:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
   2a6a2:	eea7 0a87 	vfma.f32	s0, s15, s14
   2a6a6:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a6a8:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a6ac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a6b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a6b4:	d4ca      	bmi.n	2a64c <tCycle_tick+0x44>
   2a6b6:	eeb0 7a67 	vmov.f32	s14, s15
   2a6ba:	e7d6      	b.n	2a66a <tCycle_tick+0x62>
   2a6bc:	45000000 	.word	0x45000000
   2a6c0:	0004fe9c 	.word	0x0004fe9c

0002a6c4 <tSawtooth_initToPool>:
{
    tSawtooth_initToPool(cy, &leaf.mempool);
}

void    tSawtooth_initToPool    (tSawtooth* const cy, tMempool* const mp)
{
   2a6c4:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   2a6c6:	680d      	ldr	r5, [r1, #0]
{
   2a6c8:	4604      	mov	r4, r0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2a6ca:	2018      	movs	r0, #24
{
    _tSawtooth* c = *cy;
    
    c->freq  = freq;
    
    c->inc = c->freq * leaf.invSampleRate;
   2a6cc:	4e0c      	ldr	r6, [pc, #48]	; (2a700 <tSawtooth_initToPool+0x3c>)
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2a6ce:	4629      	mov	r1, r5
   2a6d0:	f7ff fada 	bl	29c88 <mpool_alloc>
    c->inc      = 0.0f;
   2a6d4:	2300      	movs	r3, #0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
   2a6d6:	6020      	str	r0, [r4, #0]
   2a6d8:	2103      	movs	r1, #3
    c->mempool = m;
   2a6da:	6005      	str	r5, [r0, #0]
    c->phase    = 0.0f;
   2a6dc:	6043      	str	r3, [r0, #4]
    c->freq  = freq;
   2a6de:	ed9f 7a09 	vldr	s14, [pc, #36]	; 2a704 <tSawtooth_initToPool+0x40>
    c->inc = c->freq * leaf.invSampleRate;
   2a6e2:	edd6 7a01 	vldr	s15, [r6, #4]
    c->inc      = 0.0f;
   2a6e6:	6083      	str	r3, [r0, #8]
    c->inc = c->freq * leaf.invSampleRate;
   2a6e8:	ee67 7a87 	vmul.f32	s15, s15, s14
    _tSawtooth* c = *cy;
   2a6ec:	6823      	ldr	r3, [r4, #0]
    c->w = c->freq * INV_20;
    for (c->oct = 0; c->w > 2.0f; c->oct++)
    {
        c->w = 0.5f * c->w;
    }
    c->w = 2.0f - c->w;
   2a6ee:	4a06      	ldr	r2, [pc, #24]	; (2a708 <tSawtooth_initToPool+0x44>)
    c->freq  = freq;
   2a6f0:	ed83 7a03 	vstr	s14, [r3, #12]
    c->inc = c->freq * leaf.invSampleRate;
   2a6f4:	edc3 7a02 	vstr	s15, [r3, #8]
   2a6f8:	6119      	str	r1, [r3, #16]
    c->w = 2.0f - c->w;
   2a6fa:	615a      	str	r2, [r3, #20]
}
   2a6fc:	bd70      	pop	{r4, r5, r6, pc}
   2a6fe:	bf00      	nop
   2a700:	020fc0a8 	.word	0x020fc0a8
   2a704:	435c0000 	.word	0x435c0000
   2a708:	3f200000 	.word	0x3f200000

0002a70c <tSawtooth_free>:
    _tSawtooth* c = *cy;
   2a70c:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)c, c->mempool);
   2a70e:	6801      	ldr	r1, [r0, #0]
   2a710:	f7ff bb62 	b.w	29dd8 <mpool_free>

0002a714 <tSawtooth_setFreq>:
    c->w = c->freq * INV_20;
   2a714:	eddf 7a16 	vldr	s15, [pc, #88]	; 2a770 <tSawtooth_setFreq+0x5c>
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a718:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
    c->inc = c->freq * leaf.invSampleRate;
   2a71c:	4b15      	ldr	r3, [pc, #84]	; (2a774 <tSawtooth_setFreq+0x60>)
    c->w = c->freq * INV_20;
   2a71e:	ee60 7a27 	vmul.f32	s15, s0, s15
    _tSawtooth* c = *cy;
   2a722:	6802      	ldr	r2, [r0, #0]
    c->inc = c->freq * leaf.invSampleRate;
   2a724:	edd3 6a01 	vldr	s13, [r3, #4]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a728:	2300      	movs	r3, #0
    c->freq  = freq;
   2a72a:	ed82 0a03 	vstr	s0, [r2, #12]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a72e:	eef4 7ac7 	vcmpe.f32	s15, s14
    c->w = c->freq * INV_20;
   2a732:	edc2 7a05 	vstr	s15, [r2, #20]
    c->inc = c->freq * leaf.invSampleRate;
   2a736:	ee66 6a80 	vmul.f32	s13, s13, s0
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a73a:	6113      	str	r3, [r2, #16]
   2a73c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c->inc = c->freq * leaf.invSampleRate;
   2a740:	edc2 6a02 	vstr	s13, [r2, #8]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a744:	dd0c      	ble.n	2a760 <tSawtooth_setFreq+0x4c>
        c->w = 0.5f * c->w;
   2a746:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a74a:	2301      	movs	r3, #1
        c->w = 0.5f * c->w;
   2a74c:	ee67 7aa6 	vmul.f32	s15, s15, s13
    for (c->oct = 0; c->w > 2.0f; c->oct++)
   2a750:	4619      	mov	r1, r3
   2a752:	3301      	adds	r3, #1
   2a754:	eef4 7ac7 	vcmpe.f32	s15, s14
   2a758:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a75c:	dcf6      	bgt.n	2a74c <tSawtooth_setFreq+0x38>
   2a75e:	6111      	str	r1, [r2, #16]
    c->w = 2.0f - c->w;
   2a760:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   2a764:	ee77 7a67 	vsub.f32	s15, s14, s15
   2a768:	edc2 7a05 	vstr	s15, [r2, #20]
}
   2a76c:	4770      	bx	lr
   2a76e:	bf00      	nop
   2a770:	3d4ccccd 	.word	0x3d4ccccd
   2a774:	020fc0a8 	.word	0x020fc0a8

0002a778 <tSawtooth_tick>:

float   tSawtooth_tick(tSawtooth* const cy)
{
   2a778:	b410      	push	{r4}
    _tSawtooth* c = *cy;
   2a77a:	6802      	ldr	r2, [r0, #0]
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a77c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
   2a780:	ed92 7a01 	vldr	s14, [r2, #4]
   2a784:	edd2 7a02 	vldr	s15, [r2, #8]
   2a788:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a78c:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
   2a790:	ed82 7a01 	vstr	s14, [r2, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a798:	db3e      	blt.n	2a818 <tSawtooth_tick+0xa0>
   2a79a:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2a79e:	eeb4 7ac6 	vcmpe.f32	s14, s12
   2a7a2:	ee77 7a66 	vsub.f32	s15, s14, s13
   2a7a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a7aa:	eeb0 7a67 	vmov.f32	s14, s15
   2a7ae:	daf6      	bge.n	2a79e <tSawtooth_tick+0x26>
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a7b0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a7b4:	edc2 7a01 	vstr	s15, [r2, #4]
   2a7b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a7bc:	d533      	bpl.n	2a826 <tSawtooth_tick+0xae>
   2a7be:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2a7c2:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2a7c6:	eef4 7ae6 	vcmpe.f32	s15, s13
   2a7ca:	ee37 7a86 	vadd.f32	s14, s15, s12
   2a7ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a7d2:	eef0 7a47 	vmov.f32	s15, s14
   2a7d6:	d4f6      	bmi.n	2a7c6 <tSawtooth_tick+0x4e>
   2a7d8:	ed82 7a01 	vstr	s14, [r2, #4]
    
    float out = 0.0f;
    
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2a7dc:	eef0 7a47 	vmov.f32	s15, s14
    
    // Wavetable synthesis
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a7e0:	6911      	ldr	r1, [r2, #16]
   2a7e2:	4812      	ldr	r0, [pc, #72]	; (2a82c <tSawtooth_tick+0xb4>)
   2a7e4:	1c4c      	adds	r4, r1, #1
   2a7e6:	ed92 7a05 	vldr	s14, [r2, #20]
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
   2a7ea:	eefe 7aea 	vcvt.s32.f32	s15, s15, #11
   2a7ee:	ee17 3a90 	vmov	r3, s15
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a7f2:	eb03 21c1 	add.w	r1, r3, r1, lsl #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a7f6:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
    
    return out;
}
   2a7fa:	f85d 4b04 	ldr.w	r4, [sp], #4
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a7fe:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a802:	eb00 0383 	add.w	r3, r0, r3, lsl #2
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a806:	edd1 7a00 	vldr	s15, [r1]
    out = __leaf_table_sawtooth[c->oct+1][idx] +
   2a80a:	ed93 0a00 	vldr	s0, [r3]
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
   2a80e:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
   2a812:	eea7 0a87 	vfma.f32	s0, s15, s14
   2a816:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
   2a818:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
   2a81c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2a820:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2a824:	d4cb      	bmi.n	2a7be <tSawtooth_tick+0x46>
   2a826:	eeb0 7a67 	vmov.f32	s14, s15
   2a82a:	e7d7      	b.n	2a7dc <tSawtooth_tick+0x64>
   2a82c:	00039e9c 	.word	0x00039e9c

0002a830 <tNoise_initToPool>:
{
    tNoise_initToPool(ns, type, &leaf.mempool);
}

void    tNoise_initToPool   (tNoise* const ns, NoiseType type, tMempool* const mp)
{
   2a830:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
   2a832:	6814      	ldr	r4, [r2, #0]
{
   2a834:	4606      	mov	r6, r0
   2a836:	460d      	mov	r5, r1
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
   2a838:	2018      	movs	r0, #24
   2a83a:	4621      	mov	r1, r4
   2a83c:	f7ff fa24 	bl	29c88 <mpool_alloc>
    n->mempool = m;
    
    n->type = type;
    n->rand = leaf.random;
   2a840:	4b03      	ldr	r3, [pc, #12]	; (2a850 <tNoise_initToPool+0x20>)
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
   2a842:	6030      	str	r0, [r6, #0]
    n->mempool = m;
   2a844:	6004      	str	r4, [r0, #0]
    n->type = type;
   2a846:	7105      	strb	r5, [r0, #4]
    n->rand = leaf.random;
   2a848:	691b      	ldr	r3, [r3, #16]
   2a84a:	6143      	str	r3, [r0, #20]
}
   2a84c:	bd70      	pop	{r4, r5, r6, pc}
   2a84e:	bf00      	nop
   2a850:	020fc0a8 	.word	0x020fc0a8

0002a854 <tNoise_free>:

void    tNoise_free (tNoise* const ns)
{
    _tNoise* n = *ns;
   2a854:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)n, n->mempool);
   2a856:	6801      	ldr	r1, [r0, #0]
   2a858:	f7ff babe 	b.w	29dd8 <mpool_free>

0002a85c <tNoise_tick>:
}

float   tNoise_tick(tNoise* const ns)
{
   2a85c:	b510      	push	{r4, lr}
    _tNoise* n = *ns;
   2a85e:	6804      	ldr	r4, [r0, #0]
    
    float rand = (n->rand() * 2.0f) - 1.0f;
   2a860:	6963      	ldr	r3, [r4, #20]
   2a862:	4798      	blx	r3
   2a864:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
   2a868:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    
    if (n->type == PinkNoise)
   2a86c:	7923      	ldrb	r3, [r4, #4]
   2a86e:	2b01      	cmp	r3, #1
    float rand = (n->rand() * 2.0f) - 1.0f;
   2a870:	eee0 7a07 	vfma.f32	s15, s0, s14
   2a874:	eeb0 0a67 	vmov.f32	s0, s15
    if (n->type == PinkNoise)
   2a878:	d000      	beq.n	2a87c <tNoise_tick+0x20>
    }
    else // WhiteNoise
    {
        return rand;
    }
}
   2a87a:	bd10      	pop	{r4, pc}
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a87c:	eddf 7a18 	vldr	s15, [pc, #96]	; 2a8e0 <tNoise_tick+0x84>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a880:	eddf 6a18 	vldr	s13, [pc, #96]	; 2a8e4 <tNoise_tick+0x88>
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a884:	ee60 7a27 	vmul.f32	s15, s0, s15
   2a888:	ed94 5a02 	vldr	s10, [r4, #8]
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a88c:	ee60 6a26 	vmul.f32	s13, s0, s13
   2a890:	edd4 5a03 	vldr	s11, [r4, #12]
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a894:	ed9f 7a14 	vldr	s14, [pc, #80]	; 2a8e8 <tNoise_tick+0x8c>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a898:	ed9f 6a14 	vldr	s12, [pc, #80]	; 2a8ec <tNoise_tick+0x90>
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a89c:	eee5 7a07 	vfma.f32	s15, s10, s14
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a8a0:	ed9f 7a13 	vldr	s14, [pc, #76]	; 2a8f0 <tNoise_tick+0x94>
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a8a4:	eee5 6a86 	vfma.f32	s13, s11, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a8a8:	edd4 4a04 	vldr	s9, [r4, #16]
   2a8ac:	ee20 7a07 	vmul.f32	s14, s0, s14
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a8b0:	eddf 5a10 	vldr	s11, [pc, #64]	; 2a8f4 <tNoise_tick+0x98>
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a8b4:	ed9f 5a10 	vldr	s10, [pc, #64]	; 2a8f8 <tNoise_tick+0x9c>
        return (tmp * 0.05f);
   2a8b8:	ed9f 6a10 	vldr	s12, [pc, #64]	; 2a8fc <tNoise_tick+0xa0>
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a8bc:	eea4 7a85 	vfma.f32	s14, s9, s10
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
   2a8c0:	edc4 7a02 	vstr	s15, [r4, #8]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a8c4:	ee77 7aa6 	vadd.f32	s15, s15, s13
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
   2a8c8:	edc4 6a03 	vstr	s13, [r4, #12]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a8cc:	eee0 7a25 	vfma.f32	s15, s0, s11
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
   2a8d0:	ed84 7a04 	vstr	s14, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
   2a8d4:	ee37 0a87 	vadd.f32	s0, s15, s14
        return (tmp * 0.05f);
   2a8d8:	ee20 0a06 	vmul.f32	s0, s0, s12
}
   2a8dc:	bd10      	pop	{r4, pc}
   2a8de:	bf00      	nop
   2a8e0:	3dcad8a1 	.word	0x3dcad8a1
   2a8e4:	3e97d0ff 	.word	0x3e97d0ff
   2a8e8:	3f7f65fe 	.word	0x3f7f65fe
   2a8ec:	3f76872b 	.word	0x3f76872b
   2a8f0:	3f86be97 	.word	0x3f86be97
   2a8f4:	3e3d3c36 	.word	0x3e3d3c36
   2a8f8:	3f11eb85 	.word	0x3f11eb85
   2a8fc:	3d4ccccd 	.word	0x3d4ccccd

0002a900 <tComplexLivingString_initToPool>:
}

void    tComplexLivingString_initToPool    (tComplexLivingString* const pl, float freq, float pickPos, float prepPos, float prepIndex,
                                     float dampFreq, float decay, float targetLev, float levSmoothFactor,
                                     float levStrength, int levMode, tMempool* const mp)
{
   2a900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a904:	ed2d 8b0c 	vpush	{d8-d13}
   2a908:	b083      	sub	sp, #12
    _tMempool* m = *mp;
   2a90a:	f8d2 8000 	ldr.w	r8, [r2]
{
   2a90e:	4606      	mov	r6, r0
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2a910:	2070      	movs	r0, #112	; 0x70
{
   2a912:	9100      	str	r1, [sp, #0]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2a914:	4641      	mov	r1, r8
{
   2a916:	eef0 8a42 	vmov.f32	s17, s4
   2a91a:	4615      	mov	r5, r2
   2a91c:	eef0 9a41 	vmov.f32	s19, s2
    p->mempool = m;

    p->curr=0.0f;
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a920:	4f86      	ldr	r7, [pc, #536]	; (2ab3c <tComplexLivingString_initToPool+0x23c>)
{
   2a922:	eeb0 ba43 	vmov.f32	s22, s6
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a926:	ed9f aa86 	vldr	s20, [pc, #536]	; 2ab40 <tComplexLivingString_initToPool+0x240>
{
   2a92a:	eef0 ba63 	vmov.f32	s23, s7
    p->curr=0.0f;
   2a92e:	eddf ca85 	vldr	s25, [pc, #532]	; 2ab44 <tComplexLivingString_initToPool+0x244>
{
   2a932:	eeb0 ca44 	vmov.f32	s24, s8
   2a936:	eeb0 da61 	vmov.f32	s26, s3
   2a93a:	eef0 da62 	vmov.f32	s27, s5
   2a93e:	eef0 aa40 	vmov.f32	s21, s0
   2a942:	eeb0 9a60 	vmov.f32	s18, s1
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
   2a946:	f7ff f99f 	bl	29c88 <mpool_alloc>
   2a94a:	4604      	mov	r4, r0
   2a94c:	6030      	str	r0, [r6, #0]
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a94e:	4629      	mov	r1, r5
   2a950:	eef0 0a4a 	vmov.f32	s1, s20
    p->mempool = m;
   2a954:	f8c4 8000 	str.w	r8, [r4]
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a958:	3064      	adds	r0, #100	; 0x64
   2a95a:	ed97 0a00 	vldr	s0, [r7]
   2a95e:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
    p->curr=0.0f;
   2a962:	edc4 ca0a 	vstr	s25, [r4, #40]	; 0x28
    tComplexLivingString_setPickPos(pl, pickPos);
    tComplexLivingString_setPrepPos(pl, prepPos);

    p->prepPos=prepPos;
    p->pickPos=pickPos;
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2a966:	f104 0b2c 	add.w	fp, r4, #44	; 0x2c
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a96a:	ee80 0a2a 	vdiv.f32	s0, s0, s21
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
   2a96e:	f104 0a34 	add.w	sl, r4, #52	; 0x34
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
   2a972:	f7fd fab9 	bl	27ee8 <tExpSmooth_initToPool>
void     tComplexLivingString_setFreq(tComplexLivingString* const pl, float freq)
{    // NOTE: It is faster to set wavelength in samples directly
    _tComplexLivingString* p = *pl;
    if (freq<20.0f) freq=20.0f;
    else if (freq>10000.0f) freq=10000.0f;
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a976:	ed97 7a00 	vldr	s14, [r7]
   2a97a:	eddf 7a73 	vldr	s15, [pc, #460]	; 2ab48 <tComplexLivingString_initToPool+0x248>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2a97e:	f104 0240 	add.w	r2, r4, #64	; 0x40
    _tComplexLivingString* p = *pl;
   2a982:	6833      	ldr	r3, [r6, #0]
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
   2a984:	f104 0930 	add.w	r9, r4, #48	; 0x30
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a988:	feca 7ae7 	vminnm.f32	s15, s21, s15
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2a98c:	9201      	str	r2, [sp, #4]
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a98e:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2a992:	f103 0064 	add.w	r0, r3, #100	; 0x64
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
   2a996:	f104 083c 	add.w	r8, r4, #60	; 0x3c
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
   2a99a:	f104 0738 	add.w	r7, r4, #56	; 0x38
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2a99e:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
   2a9a2:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2a9a6:	ed83 0a02 	vstr	s0, [r3, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2a9aa:	f7fd fad9 	bl	27f60 <tExpSmooth_setDest>
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
   2a9ae:	4629      	mov	r1, r5
   2a9b0:	eef0 0a4a 	vmov.f32	s1, s20
   2a9b4:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2a9b8:	eeb0 0a49 	vmov.f32	s0, s18
    p->freq = freq;
   2a9bc:	edc4 aa01 	vstr	s21, [r4, #4]
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
   2a9c0:	f7fd fa92 	bl	27ee8 <tExpSmooth_initToPool>
    tExpSmooth_initToPool(&p->prepPosSmooth, prepPos, 0.01f, mp); // smoother for pick position
   2a9c4:	eef0 0a4a 	vmov.f32	s1, s20
   2a9c8:	4629      	mov	r1, r5
   2a9ca:	eeb0 0a69 	vmov.f32	s0, s19
   2a9ce:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2a9d2:	f7fd fa89 	bl	27ee8 <tExpSmooth_initToPool>
   2a9d6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
}

void     tComplexLivingString_setPickPos(tComplexLivingString* const pl, float pickPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
   2a9da:	6833      	ldr	r3, [r6, #0]
   2a9dc:	fe89 0a40 	vminnm.f32	s0, s18, s0
    if (pickPos<0.5f) pickPos=0.5f;
    else if (pickPos>1.f) pickPos=1.f;
    p->pickPos = pickPos;
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2a9e0:	f103 0068 	add.w	r0, r3, #104	; 0x68
   2a9e4:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
    p->pickPos = pickPos;
   2a9e8:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2a9ec:	f7fd fab8 	bl	27f60 <tExpSmooth_setDest>
}

void     tComplexLivingString_setPrepPos(tComplexLivingString* const pl, float prepPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
   2a9f0:	6833      	ldr	r3, [r6, #0]
   2a9f2:	fe89 0ac8 	vminnm.f32	s0, s19, s16
   2a9f6:	fe80 0a2c 	vmaxnm.f32	s0, s0, s25
    if (prepPos<0.f) prepPos=0.f;
    else if (prepPos>0.5f) prepPos=0.5f;
    p->prepPos = prepPos;
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2a9fa:	f103 006c 	add.w	r0, r3, #108	; 0x6c
    p->prepPos = prepPos;
   2a9fe:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2aa02:	f7fd faad 	bl	27f60 <tExpSmooth_setDest>
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2aa06:	4658      	mov	r0, fp
   2aa08:	462a      	mov	r2, r5
   2aa0a:	ed94 0a02 	vldr	s0, [r4, #8]
    p->prepPos=prepPos;
   2aa0e:	edc4 9a04 	vstr	s19, [r4, #16]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2aa12:	f44f 6116 	mov.w	r1, #2400	; 0x960
    p->pickPos=pickPos;
   2aa16:	ed84 9a03 	vstr	s18, [r4, #12]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
   2aa1a:	f7fa f9f9 	bl	24e10 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
   2aa1e:	4650      	mov	r0, sl
   2aa20:	462a      	mov	r2, r5
   2aa22:	ed94 0a02 	vldr	s0, [r4, #8]
   2aa26:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2aa2a:	f7fa f9f1 	bl	24e10 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
   2aa2e:	4648      	mov	r0, r9
   2aa30:	462a      	mov	r2, r5
   2aa32:	ed94 0a02 	vldr	s0, [r4, #8]
   2aa36:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2aa3a:	f7fa f9e9 	bl	24e10 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
   2aa3e:	4640      	mov	r0, r8
   2aa40:	462a      	mov	r2, r5
   2aa42:	ed94 0a02 	vldr	s0, [r4, #8]
   2aa46:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2aa4a:	f7fa f9e1 	bl	24e10 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
   2aa4e:	4638      	mov	r0, r7
   2aa50:	462a      	mov	r2, r5
   2aa52:	ed94 0a02 	vldr	s0, [r4, #8]
   2aa56:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2aa5a:	f7fa f9d9 	bl	24e10 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
   2aa5e:	9e01      	ldr	r6, [sp, #4]
   2aa60:	462a      	mov	r2, r5
   2aa62:	ed94 0a02 	vldr	s0, [r4, #8]
   2aa66:	f44f 6116 	mov.w	r1, #2400	; 0x960
   2aa6a:	4630      	mov	r0, r6
   2aa6c:	f7fa f9d0 	bl	24e10 <tLinearDelay_initToPool>
    tLinearDelay_clear(&p->delLF);
   2aa70:	4658      	mov	r0, fp
   2aa72:	f7fa fa4f 	bl	24f14 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMF);
   2aa76:	4650      	mov	r0, sl
   2aa78:	f7fa fa4c 	bl	24f14 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUF);
   2aa7c:	4648      	mov	r0, r9
   2aa7e:	f7fa fa49 	bl	24f14 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUB);
   2aa82:	4640      	mov	r0, r8
   2aa84:	f7fa fa46 	bl	24f14 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMB);
   2aa88:	4638      	mov	r0, r7
   2aa8a:	f7fa fa43 	bl	24f14 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delLB);
   2aa8e:	4630      	mov	r0, r6
   2aa90:	f7fa fa40 	bl	24f14 <tLinearDelay_clear>
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
   2aa94:	4629      	mov	r1, r5
   2aa96:	eeb0 0a68 	vmov.f32	s0, s17
   2aa9a:	f104 0044 	add.w	r0, r4, #68	; 0x44
    p->dampFreq = dampFreq;
   2aa9e:	edc4 8a07 	vstr	s17, [r4, #28]
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
   2aaa2:	f7fd fb31 	bl	28108 <tOnePole_initToPool>
    tOnePole_initToPool(&p->nutFilter, dampFreq, mp);
   2aaa6:	4629      	mov	r1, r5
   2aaa8:	eeb0 0a68 	vmov.f32	s0, s17
   2aaac:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2aab0:	f7fd fb2a 	bl	28108 <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterU, dampFreq, mp);
   2aab4:	4629      	mov	r1, r5
   2aab6:	eeb0 0a68 	vmov.f32	s0, s17
   2aaba:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2aabe:	f7fd fb23 	bl	28108 <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterL, dampFreq, mp);
   2aac2:	4629      	mov	r1, r5
   2aac4:	eeb0 0a68 	vmov.f32	s0, s17
   2aac8:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2aacc:	f7fd fb1c 	bl	28108 <tOnePole_initToPool>
    tHighpass_initToPool(&p->DCblockerU,13, mp);
   2aad0:	4629      	mov	r1, r5
   2aad2:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2aad6:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
   2aada:	f7fd fd4f 	bl	2857c <tHighpass_initToPool>
    tHighpass_initToPool(&p->DCblockerL,13, mp);
   2aade:	4629      	mov	r1, r5
   2aae0:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2aae4:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
   2aae8:	f7fd fd48 	bl	2857c <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2aaec:	462a      	mov	r2, r5
   2aaee:	9900      	ldr	r1, [sp, #0]
   2aaf0:	eeb0 1a4c 	vmov.f32	s2, s24
   2aaf4:	eef0 0a6b 	vmov.f32	s1, s23
   2aaf8:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2aafc:	eeb0 0a4b 	vmov.f32	s0, s22
    p->decay=decay;
   2ab00:	edc4 da08 	vstr	s27, [r4, #32]
    p->prepIndex = prepIndex;
   2ab04:	ed84 da06 	vstr	s26, [r4, #24]
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2ab08:	f7fb f812 	bl	25b30 <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevL, targetLev, levSmoothFactor, levStrength, levMode, mp);
   2ab0c:	462a      	mov	r2, r5
   2ab0e:	9900      	ldr	r1, [sp, #0]
   2ab10:	eeb0 1a4c 	vmov.f32	s2, s24
   2ab14:	eef0 0a6b 	vmov.f32	s1, s23
   2ab18:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2ab1c:	eeb0 0a4b 	vmov.f32	s0, s22
   2ab20:	f7fb f806 	bl	25b30 <tFeedbackLeveler_initToPool>
    p->levMode=levMode;
   2ab24:	eddd 7a00 	vldr	s15, [sp]
   2ab28:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2ab2c:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
   2ab30:	b003      	add	sp, #12
   2ab32:	ecbd 8b0c 	vpop	{d8-d13}
   2ab36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ab3a:	bf00      	nop
   2ab3c:	020fc0a8 	.word	0x020fc0a8
   2ab40:	3c23d70a 	.word	0x3c23d70a
   2ab44:	00000000 	.word	0x00000000
   2ab48:	461c4000 	.word	0x461c4000

0002ab4c <tComplexLivingString_init>:
    tComplexLivingString_initToPool(pl, freq, pickPos, prepPos, prepIndex, dampFreq, decay, targetLev, levSmoothFactor, levStrength, levMode, &leaf.mempool);
   2ab4c:	4a01      	ldr	r2, [pc, #4]	; (2ab54 <tComplexLivingString_init+0x8>)
   2ab4e:	f7ff bed7 	b.w	2a900 <tComplexLivingString_initToPool>
   2ab52:	bf00      	nop
   2ab54:	020fc0c0 	.word	0x020fc0c0

0002ab58 <tComplexLivingString_free>:
{
   2ab58:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
   2ab5a:	6804      	ldr	r4, [r0, #0]
    tExpSmooth_free(&p->wlSmooth);
   2ab5c:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2ab60:	f7fd f9e8 	bl	27f34 <tExpSmooth_free>
    tExpSmooth_free(&p->pickPosSmooth);
   2ab64:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2ab68:	f7fd f9e4 	bl	27f34 <tExpSmooth_free>
    tExpSmooth_free(&p->prepPosSmooth);
   2ab6c:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2ab70:	f7fd f9e0 	bl	27f34 <tExpSmooth_free>
    tLinearDelay_free(&p->delLF);
   2ab74:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   2ab78:	f7fa f9c0 	bl	24efc <tLinearDelay_free>
    tLinearDelay_free(&p->delMF);
   2ab7c:	f104 0034 	add.w	r0, r4, #52	; 0x34
   2ab80:	f7fa f9bc 	bl	24efc <tLinearDelay_free>
    tLinearDelay_free(&p->delUF);
   2ab84:	f104 0030 	add.w	r0, r4, #48	; 0x30
   2ab88:	f7fa f9b8 	bl	24efc <tLinearDelay_free>
    tLinearDelay_free(&p->delUB);
   2ab8c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2ab90:	f7fa f9b4 	bl	24efc <tLinearDelay_free>
    tLinearDelay_free(&p->delMB);
   2ab94:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2ab98:	f7fa f9b0 	bl	24efc <tLinearDelay_free>
    tLinearDelay_free(&p->delLB);
   2ab9c:	f104 0040 	add.w	r0, r4, #64	; 0x40
   2aba0:	f7fa f9ac 	bl	24efc <tLinearDelay_free>
    tOnePole_free(&p->bridgeFilter);
   2aba4:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2aba8:	f7fd fae4 	bl	28174 <tOnePole_free>
    tOnePole_free(&p->nutFilter);
   2abac:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2abb0:	f7fd fae0 	bl	28174 <tOnePole_free>
    tOnePole_free(&p->prepFilterU);
   2abb4:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2abb8:	f7fd fadc 	bl	28174 <tOnePole_free>
    tOnePole_free(&p->prepFilterL);
   2abbc:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2abc0:	f7fd fad8 	bl	28174 <tOnePole_free>
    tHighpass_free(&p->DCblockerU);
   2abc4:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2abc8:	f7fd fcf8 	bl	285bc <tHighpass_free>
    tHighpass_free(&p->DCblockerL);
   2abcc:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2abd0:	f7fd fcf4 	bl	285bc <tHighpass_free>
    tFeedbackLeveler_free(&p->fbLevU);
   2abd4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2abd8:	f7fa ffd2 	bl	25b80 <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&p->fbLevL);
   2abdc:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2abe0:	f7fa ffce 	bl	25b80 <tFeedbackLeveler_free>
    mpool_free((char*)p, p->mempool);
   2abe4:	6821      	ldr	r1, [r4, #0]
   2abe6:	4620      	mov	r0, r4
}
   2abe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   2abec:	f7ff b8f4 	b.w	29dd8 <mpool_free>

0002abf0 <tComplexLivingString_setFreq>:
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2abf0:	4b09      	ldr	r3, [pc, #36]	; (2ac18 <tComplexLivingString_setFreq+0x28>)
   2abf2:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
   2abf6:	eddf 7a09 	vldr	s15, [pc, #36]	; 2ac1c <tComplexLivingString_setFreq+0x2c>
   2abfa:	ed93 7a00 	vldr	s14, [r3]
   2abfe:	fec0 7a67 	vminnm.f32	s15, s0, s15
   2ac02:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
   2ac06:	ee87 0a27 	vdiv.f32	s0, s14, s15
    _tComplexLivingString* p = *pl;
   2ac0a:	6803      	ldr	r3, [r0, #0]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2ac0c:	f103 0064 	add.w	r0, r3, #100	; 0x64
    p->waveLengthInSamples = leaf.sampleRate/freq;
   2ac10:	ed83 0a02 	vstr	s0, [r3, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
   2ac14:	f7fd b9a4 	b.w	27f60 <tExpSmooth_setDest>
   2ac18:	020fc0a8 	.word	0x020fc0a8
   2ac1c:	461c4000 	.word	0x461c4000

0002ac20 <tComplexLivingString_setPickPos>:
{    // between 0 and 1
   2ac20:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
   2ac24:	6803      	ldr	r3, [r0, #0]
   2ac26:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2ac2a:	f103 0068 	add.w	r0, r3, #104	; 0x68
   2ac2e:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2ac32:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->pickPos = pickPos;
   2ac36:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
   2ac3a:	f7fd b991 	b.w	27f60 <tExpSmooth_setDest>
   2ac3e:	bf00      	nop

0002ac40 <tComplexLivingString_setPrepPos>:
{    // between 0 and 1
   2ac40:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    _tComplexLivingString* p = *pl;
   2ac44:	6803      	ldr	r3, [r0, #0]
   2ac46:	ed9f 7a06 	vldr	s14, [pc, #24]	; 2ac60 <tComplexLivingString_setPrepPos+0x20>
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2ac4a:	f103 006c 	add.w	r0, r3, #108	; 0x6c
   2ac4e:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2ac52:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->prepPos = prepPos;
   2ac56:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
   2ac5a:	f7fd b981 	b.w	27f60 <tExpSmooth_setDest>
   2ac5e:	bf00      	nop
   2ac60:	00000000 	.word	0x00000000

0002ac64 <tComplexLivingString_setPrepIndex>:
}

void     tComplexLivingString_setPrepIndex(tComplexLivingString* const pl, float prepIndex)
{    // between 0 and 1
   2ac64:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
   2ac68:	6803      	ldr	r3, [r0, #0]
    if (prepIndex<0.f) prepIndex=0.f;
    else if (prepIndex>1.f) prepIndex=1.f;
    p->prepIndex = prepIndex;
   2ac6a:	ed9f 7a04 	vldr	s14, [pc, #16]	; 2ac7c <tComplexLivingString_setPrepIndex+0x18>
   2ac6e:	fe80 0a67 	vminnm.f32	s0, s0, s15
   2ac72:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
   2ac76:	ed83 0a06 	vstr	s0, [r3, #24]
}
   2ac7a:	4770      	bx	lr
   2ac7c:	00000000 	.word	0x00000000

0002ac80 <tComplexLivingString_setDampFreq>:

void     tComplexLivingString_setDampFreq(tComplexLivingString* const pl, float dampFreq)
{
   2ac80:	b510      	push	{r4, lr}
   2ac82:	ed2d 8b02 	vpush	{d8}
   2ac86:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
   2ac8a:	6804      	ldr	r4, [r0, #0]
    tOnePole_setFreq(&p->bridgeFilter, dampFreq);
   2ac8c:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2ac90:	f7fd fa74 	bl	2817c <tOnePole_setFreq>
    tOnePole_setFreq(&p->nutFilter, dampFreq);
   2ac94:	eeb0 0a48 	vmov.f32	s0, s16
   2ac98:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2ac9c:	f7fd fa6e 	bl	2817c <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterU, dampFreq);
   2aca0:	eeb0 0a48 	vmov.f32	s0, s16
   2aca4:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2aca8:	f7fd fa68 	bl	2817c <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
   2acac:	eeb0 0a48 	vmov.f32	s0, s16
   2acb0:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
   2acb4:	ecbd 8b02 	vpop	{d8}
   2acb8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
   2acbc:	f7fd ba5e 	b.w	2817c <tOnePole_setFreq>

0002acc0 <tComplexLivingString_setDecay>:

void     tComplexLivingString_setDecay(tComplexLivingString* const pl, float decay)
{
    _tComplexLivingString* p = *pl;
   2acc0:	6803      	ldr	r3, [r0, #0]
    p->decay=decay;
   2acc2:	ed83 0a08 	vstr	s0, [r3, #32]
}
   2acc6:	4770      	bx	lr

0002acc8 <tComplexLivingString_setTargetLev>:

void     tComplexLivingString_setTargetLev(tComplexLivingString* const pl, float targetLev)
{
   2acc8:	b510      	push	{r4, lr}
   2acca:	ed2d 8b02 	vpush	{d8}
   2acce:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
   2acd2:	6804      	ldr	r4, [r0, #0]
    tFeedbackLeveler_setTargetLevel(&p->fbLevU, targetLev);
   2acd4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2acd8:	f7fa ff8a 	bl	25bf0 <tFeedbackLeveler_setTargetLevel>
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
   2acdc:	eeb0 0a48 	vmov.f32	s0, s16
   2ace0:	f104 0060 	add.w	r0, r4, #96	; 0x60
}
   2ace4:	ecbd 8b02 	vpop	{d8}
   2ace8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
   2acec:	f7fa bf80 	b.w	25bf0 <tFeedbackLeveler_setTargetLevel>

0002acf0 <tComplexLivingString_setLevMode>:
    tFeedbackLeveler_setStrength(&p->fbLevU, levStrength);
    tFeedbackLeveler_setStrength(&p->fbLevL, levStrength);
}

void     tComplexLivingString_setLevMode(tComplexLivingString* const pl, int levMode)
{
   2acf0:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
   2acf2:	6804      	ldr	r4, [r0, #0]
{
   2acf4:	b082      	sub	sp, #8
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
   2acf6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
{
   2acfa:	9101      	str	r1, [sp, #4]
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
   2acfc:	f7fa ff4c 	bl	25b98 <tFeedbackLeveler_setMode>
    tFeedbackLeveler_setMode(&p->fbLevL, levMode);
   2ad00:	9901      	ldr	r1, [sp, #4]
   2ad02:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2ad06:	f7fa ff47 	bl	25b98 <tFeedbackLeveler_setMode>
    p->levMode=levMode;
   2ad0a:	eddd 7a01 	vldr	s15, [sp, #4]
   2ad0e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2ad12:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
   2ad16:	b002      	add	sp, #8
   2ad18:	bd10      	pop	{r4, pc}
   2ad1a:	bf00      	nop

0002ad1c <tComplexLivingString_tick>:

float   tComplexLivingString_tick(tComplexLivingString* const pl, float input)
{
   2ad1c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ad20:	ed2d 8b08 	vpush	{d8-d11}
    _tComplexLivingString* p = *pl;
   2ad24:	6804      	ldr	r4, [r0, #0]
{
   2ad26:	eef0 8a40 	vmov.f32	s17, s0

    // from pickPos upwards=forwards
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2ad2a:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2ad2e:	f104 0834 	add.w	r8, r4, #52	; 0x34
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2ad32:	f104 0630 	add.w	r6, r4, #48	; 0x30
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2ad36:	f104 053c 	add.w	r5, r4, #60	; 0x3c
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2ad3a:	4650      	mov	r0, sl
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ad3c:	f104 0738 	add.w	r7, r4, #56	; 0x38
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2ad40:	f7fa f944 	bl	24fcc <tLinearDelay_tickOut>
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2ad44:	4640      	mov	r0, r8
    float fromLF=tLinearDelay_tickOut(&p->delLF);
   2ad46:	eeb0 9a40 	vmov.f32	s18, s0
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2ad4a:	f7fa f93f 	bl	24fcc <tLinearDelay_tickOut>
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2ad4e:	4630      	mov	r0, r6
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ad50:	f104 0940 	add.w	r9, r4, #64	; 0x40
    float fromMF=tLinearDelay_tickOut(&p->delMF);
   2ad54:	eef0 aa40 	vmov.f32	s21, s0
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2ad58:	f7fa f938 	bl	24fcc <tLinearDelay_tickOut>
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2ad5c:	4628      	mov	r0, r5
    float fromUF=tLinearDelay_tickOut(&p->delUF);
   2ad5e:	eef0 9a40 	vmov.f32	s19, s0
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2ad62:	f7fa f933 	bl	24fcc <tLinearDelay_tickOut>
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ad66:	4638      	mov	r0, r7
    float fromUB=tLinearDelay_tickOut(&p->delUB);
   2ad68:	eeb0 aa40 	vmov.f32	s20, s0
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ad6c:	f7fa f92e 	bl	24fcc <tLinearDelay_tickOut>
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ad70:	4648      	mov	r0, r9
    float fromMB=tLinearDelay_tickOut(&p->delMB);
   2ad72:	eef0 ba40 	vmov.f32	s23, s0
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ad76:	f7fa f929 	bl	24fcc <tLinearDelay_tickOut>

    // into upper part of string, from bridge, going backwards
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2ad7a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    float fromLB=tLinearDelay_tickOut(&p->delLB);
   2ad7e:	eeb0 ba40 	vmov.f32	s22, s0
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2ad82:	f104 0b5c 	add.w	fp, r4, #92	; 0x5c
   2ad86:	eef5 7a40 	vcmp.f32	s15, #0.0
   2ad8a:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2ad8e:	eeb0 0a69 	vmov.f32	s0, s19
   2ad92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ad96:	bf14      	ite	ne
   2ad98:	eeb7 8a00 	vmovne.f32	s16, #112	; 0x3f800000  1.0
   2ad9c:	ed94 8a08 	vldreq	s16, [r4, #32]
   2ada0:	f7fd fa08 	bl	281b4 <tOnePole_tick>
   2ada4:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2ada8:	f7fd fc1c 	bl	285e4 <tHighpass_tick>
   2adac:	4658      	mov	r0, fp
   2adae:	ee20 0a08 	vmul.f32	s0, s0, s16
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
    tLinearDelay_tickIn(&p->delLB, intoLower);

    // into lower part of string, from nut, going forwards toward prep position
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
   2adb2:	f104 0b60 	add.w	fp, r4, #96	; 0x60
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
   2adb6:	f7fa fef3 	bl	25ba0 <tFeedbackLeveler_tick>
   2adba:	eef1 9a40 	vneg.f32	s19, s0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
   2adbe:	4628      	mov	r0, r5
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2adc0:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
   2adc4:	eeb0 0a69 	vmov.f32	s0, s19
   2adc8:	f7fa f8ec 	bl	24fa4 <tLinearDelay_tickIn>
    tLinearDelay_tickIn(&p->delMB, fromUB+input);
   2adcc:	ee3a 0a28 	vadd.f32	s0, s20, s17
   2add0:	4638      	mov	r0, r7
   2add2:	f7fa f8e7 	bl	24fa4 <tLinearDelay_tickIn>
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
   2add6:	eeb0 0a49 	vmov.f32	s0, s18
   2adda:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2adde:	f7fd f9e9 	bl	281b4 <tOnePole_tick>
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2ade2:	ed94 7a06 	vldr	s14, [r4, #24]
    tLinearDelay_tickIn(&p->delLB, intoLower);
   2ade6:	4648      	mov	r0, r9
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
   2ade8:	ee78 7a47 	vsub.f32	s15, s16, s14
   2adec:	ee67 7aab 	vmul.f32	s15, s15, s23
    tLinearDelay_tickIn(&p->delLB, intoLower);
   2adf0:	eee0 7a47 	vfms.f32	s15, s0, s14
   2adf4:	eeb0 0a67 	vmov.f32	s0, s15
   2adf8:	f7fa f8d4 	bl	24fa4 <tLinearDelay_tickIn>
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
   2adfc:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2ae00:	eeb0 0a4b 	vmov.f32	s0, s22
   2ae04:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2ae08:	eef5 7a40 	vcmp.f32	s15, #0.0
   2ae0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ae10:	bf08      	it	eq
   2ae12:	ed94 8a08 	vldreq	s16, [r4, #32]
   2ae16:	f7fd f9cd 	bl	281b4 <tOnePole_tick>
   2ae1a:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2ae1e:	f7fd fbe1 	bl	285e4 <tHighpass_tick>
   2ae22:	4658      	mov	r0, fp
   2ae24:	ee20 0a08 	vmul.f32	s0, s0, s16
   2ae28:	f7fa feba 	bl	25ba0 <tFeedbackLeveler_tick>
    tLinearDelay_tickIn(&p->delLF, fromNut);
   2ae2c:	4650      	mov	r0, sl
   2ae2e:	eeb1 0a40 	vneg.f32	s0, s0
   2ae32:	f7fa f8b7 	bl	24fa4 <tLinearDelay_tickIn>

    // into middle part of string, from prep going toward pick position
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2ae36:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
   2ae3a:	eeb0 0a4a 	vmov.f32	s0, s20
   2ae3e:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2ae42:	f7fd f9b7 	bl	281b4 <tOnePole_tick>
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2ae46:	edd4 7a06 	vldr	s15, [r4, #24]

    //pick position, take input and add it into the waveguide, going to come out of middle segment
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
   2ae4a:	4640      	mov	r0, r8
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
   2ae4c:	ee38 7a67 	vsub.f32	s14, s16, s15
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
   2ae50:	eee7 8a09 	vfma.f32	s17, s14, s18
   2ae54:	eee0 8a67 	vfms.f32	s17, s0, s15
   2ae58:	eeb0 0a68 	vmov.f32	s0, s17
   2ae5c:	f7fa f8a2 	bl	24fa4 <tLinearDelay_tickIn>

    //take output of middle segment and put it into upper segment connecting to the bridge
    tLinearDelay_tickIn(&p->delUF, fromMF);
   2ae60:	eeb0 0a6a 	vmov.f32	s0, s21
   2ae64:	4630      	mov	r0, r6
   2ae66:	f7fa f89d 	bl	24fa4 <tLinearDelay_tickIn>

    // update all delay lengths
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
   2ae6a:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2ae6e:	f7fd f881 	bl	27f74 <tExpSmooth_tick>
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
   2ae72:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
   2ae76:	eeb0 9a40 	vmov.f32	s18, s0
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
   2ae7a:	f7fd f87b 	bl	27f74 <tExpSmooth_tick>
   2ae7e:	eef0 8a40 	vmov.f32	s17, s0
    float wLen=tExpSmooth_tick(&p->wlSmooth);
   2ae82:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2ae86:	f7fd f875 	bl	27f74 <tExpSmooth_tick>
   2ae8a:	eef0 7a40 	vmov.f32	s15, s0

    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
    float lowLen = prepP*wLen; // the length from prep to nut
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
   2ae8e:	ee38 8a49 	vsub.f32	s16, s16, s18


    tLinearDelay_setDelay(&p->delLF, lowLen);
   2ae92:	4650      	mov	r0, sl
    float lowLen = prepP*wLen; // the length from prep to nut
   2ae94:	ee28 aa80 	vmul.f32	s20, s17, s0
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
   2ae98:	ee79 8a68 	vsub.f32	s17, s18, s17
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
   2ae9c:	ee28 8a00 	vmul.f32	s16, s16, s0
    tLinearDelay_setDelay(&p->delLF, lowLen);
   2aea0:	eeb0 0a4a 	vmov.f32	s0, s20
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
   2aea4:	ee68 8aa7 	vmul.f32	s17, s17, s15
    tLinearDelay_setDelay(&p->delLF, lowLen);
   2aea8:	f7fa f8ba 	bl	25020 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delLB, lowLen);
   2aeac:	eeb0 0a4a 	vmov.f32	s0, s20
   2aeb0:	4648      	mov	r0, r9
   2aeb2:	f7fa f8b5 	bl	25020 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delMF, midLen);
   2aeb6:	4640      	mov	r0, r8
   2aeb8:	eeb0 0a68 	vmov.f32	s0, s17
   2aebc:	f7fa f8b0 	bl	25020 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delMB, midLen);
   2aec0:	eeb0 0a68 	vmov.f32	s0, s17
   2aec4:	4638      	mov	r0, r7
   2aec6:	f7fa f8ab 	bl	25020 <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delUF, upLen);
   2aeca:	eeb0 0a48 	vmov.f32	s0, s16
   2aece:	4630      	mov	r0, r6
   2aed0:	f7fa f8a6 	bl	25020 <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delUB, upLen);
   2aed4:	eeb0 0a48 	vmov.f32	s0, s16
   2aed8:	4628      	mov	r0, r5
   2aeda:	f7fa f8a1 	bl	25020 <tLinearDelay_setDelay>

    //update this to allow pickup position variation
    p->curr = fromBridge;
    return p->curr;
}
   2aede:	eeb0 0a69 	vmov.f32	s0, s19
    p->curr = fromBridge;
   2aee2:	edc4 9a0a 	vstr	s19, [r4, #40]	; 0x28
}
   2aee6:	ecbd 8b08 	vpop	{d8-d11}
   2aeea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2aeee:	bf00      	nop

0002aef0 <tNReverb_initToPool>:
{
    tNReverb_initToPool(rev, t60, &leaf.mempool);
}

void    tNReverb_initToPool     (tNReverb* const rev, float t60, tMempool* const mp)
{
   2aef0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2aef4:	ed2d 8b06 	vpush	{d8-d10}
   2aef8:	eeb0 aa40 	vmov.f32	s20, s0
   2aefc:	b095      	sub	sp, #84	; 0x54
    _tMempool* m = *mp;
   2aefe:	680c      	ldr	r4, [r1, #0]
{
   2af00:	4605      	mov	r5, r0
   2af02:	9101      	str	r1, [sp, #4]
   2af04:	9002      	str	r0, [sp, #8]
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2af06:	4621      	mov	r1, r4
   2af08:	2074      	movs	r0, #116	; 0x74
   2af0a:	f7fe febd 	bl	29c88 <mpool_alloc>
    r->mempool = m;
    
    if (t60 <= 0.0f) t60 = 0.001f;
   2af0e:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
   2af12:	6028      	str	r0, [r5, #0]
   2af14:	4682      	mov	sl, r0
    r->mempool = m;
   2af16:	6004      	str	r4, [r0, #0]
    if (t60 <= 0.0f) t60 = 0.001f;
   2af18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2af1c:	f240 80c6 	bls.w	2b0ac <tNReverb_initToPool+0x1bc>
   2af20:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2af24:	ee87 8a8a 	vdiv.f32	s16, s15, s20
    
    r->inv_441 = 1.0f/44100.0f;
    
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
    double scaler = leaf.sampleRate / 25641.0f;
   2af28:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 2b0e0 <tNReverb_initToPool+0x1f0>
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2af2c:	af05      	add	r7, sp, #20
   2af2e:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 2b0e4 <tNReverb_initToPool+0x1f4>
   2af32:	ac04      	add	r4, sp, #16
    double scaler = leaf.sampleRate / 25641.0f;
   2af34:	ed9f 7a64 	vldr	s14, [pc, #400]	; 2b0c8 <tNReverb_initToPool+0x1d8>
   2af38:	f10d 0914 	add.w	r9, sp, #20
   2af3c:	edd8 7a00 	vldr	s15, [r8]
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2af40:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    double scaler = leaf.sampleRate / 25641.0f;
   2af44:	ee67 7a87 	vmul.f32	s15, s15, s14
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2af48:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   2af4a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2af4e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2af52:	c70f      	stmia	r7!, {r0, r1, r2, r3}
   2af54:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   2af58:	ee17 ba90 	vmov	fp, s15
   2af5c:	c70f      	stmia	r7!, {r0, r1, r2, r3}
    r->inv_441 = 1.0f/44100.0f;
   2af5e:	4b5b      	ldr	r3, [pc, #364]	; (2b0cc <tNReverb_initToPool+0x1dc>)
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2af60:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
    r->inv_441 = 1.0f/44100.0f;
   2af64:	f8ca 3010 	str.w	r3, [sl, #16]
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
   2af68:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    
    int delay, i;
    
    for (i=0; i < 15; i++)
    {
        delay = (int) scaler * lengths[i];
   2af6c:	f854 5f04 	ldr.w	r5, [r4, #4]!
   2af70:	fb05 f50b 	mul.w	r5, r5, fp
        if ( (delay & 1) == 0)
   2af74:	07eb      	lsls	r3, r5, #31
            delay++;
   2af76:	bf58      	it	pl
   2af78:	3501      	addpl	r5, #1
   2af7a:	462e      	mov	r6, r5
   2af7c:	17ef      	asrs	r7, r5, #31
   2af7e:	e000      	b.n	2af82 <tNReverb_initToPool+0x92>
        while ( !LEAF_isPrime(delay) )
            delay += 2;
   2af80:	3502      	adds	r5, #2
        while ( !LEAF_isPrime(delay) )
   2af82:	4630      	mov	r0, r6
   2af84:	3602      	adds	r6, #2
   2af86:	4639      	mov	r1, r7
   2af88:	f147 0700 	adc.w	r7, r7, #0
   2af8c:	f7fe fc9c 	bl	298c8 <LEAF_isPrime>
   2af90:	2800      	cmp	r0, #0
   2af92:	d0f5      	beq.n	2af80 <tNReverb_initToPool+0x90>
    for (i=0; i < 15; i++)
   2af94:	ab13      	add	r3, sp, #76	; 0x4c
        lengths[i] = delay;
   2af96:	6025      	str	r5, [r4, #0]
    for (i=0; i < 15; i++)
   2af98:	429c      	cmp	r4, r3
   2af9a:	d1e7      	bne.n	2af6c <tNReverb_initToPool+0x7c>
   2af9c:	f10a 0750 	add.w	r7, sl, #80	; 0x50
   2afa0:	f10a 0668 	add.w	r6, sl, #104	; 0x68
   2afa4:	f8dd b004 	ldr.w	fp, [sp, #4]
   2afa8:	9403      	str	r4, [sp, #12]
    }
    
    for ( i=0; i<6; i++ )
    {
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
   2afaa:	f859 5b04 	ldr.w	r5, [r9], #4
   2afae:	f1a7 041c 	sub.w	r4, r7, #28
   2afb2:	465a      	mov	r2, fp
   2afb4:	ee07 5a90 	vmov	s15, r5
   2afb8:	4620      	mov	r0, r4
        tLinearDelay_clear(&r->combDelays[i]);
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
   2afba:	eba5 0585 	sub.w	r5, r5, r5, lsl #2
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
   2afbe:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   2afc2:	ee70 7a00 	vadd.f32	s15, s0, s0
   2afc6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2afca:	ee17 1a90 	vmov	r1, s15
   2afce:	f7f9 ff1f 	bl	24e10 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->combDelays[i]);
   2afd2:	4620      	mov	r0, r4
   2afd4:	f7f9 ff9e 	bl	24f14 <tLinearDelay_clear>
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
   2afd8:	edd8 7a01 	vldr	s15, [r8, #4]
   2afdc:	ee07 5a10 	vmov	s14, r5
   2afe0:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2afe4:	ee68 7a27 	vmul.f32	s15, s16, s15
   2afe8:	eeb8 1ac7 	vcvt.f32.s32	s2, s14
   2afec:	ee21 1a27 	vmul.f32	s2, s2, s15
   2aff0:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
   2aff4:	f002 fa28 	bl	2d448 <pow>
   2aff8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2affc:	eca7 0a01 	vstmia	r7!, {s0}
    for ( i=0; i<6; i++ )
   2b000:	42be      	cmp	r6, r7
   2b002:	d1d2      	bne.n	2afaa <tNReverb_initToPool+0xba>
   2b004:	9c03      	ldr	r4, [sp, #12]
   2b006:	af0b      	add	r7, sp, #44	; 0x2c
   2b008:	f10a 0514 	add.w	r5, sl, #20
   2b00c:	9e01      	ldr	r6, [sp, #4]
    }
    
    for ( i=0; i<8; i++ )
    {
        tLinearDelay_initToPool(&r->allpassDelays[i], lengths[i+6], lengths[i+6] * 2.0f, mp);
   2b00e:	ecb7 0a01 	vldmia	r7!, {s0}
   2b012:	4628      	mov	r0, r5
   2b014:	4632      	mov	r2, r6
   2b016:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
   2b01a:	ee70 7a00 	vadd.f32	s15, s0, s0
   2b01e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2b022:	ee17 1a90 	vmov	r1, s15
   2b026:	f7f9 fef3 	bl	24e10 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->allpassDelays[i]);
   2b02a:	4628      	mov	r0, r5
   2b02c:	f7f9 ff72 	bl	24f14 <tLinearDelay_clear>
    for ( i=0; i<8; i++ )
   2b030:	42bc      	cmp	r4, r7
   2b032:	f105 0504 	add.w	r5, r5, #4
   2b036:	d1ea      	bne.n	2b00e <tNReverb_initToPool+0x11e>

void    tNReverb_setT60(tNReverb* const rev, float t60)
{
    _tNReverb* r = *rev;
    
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b038:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev;
   2b03c:	9b02      	ldr	r3, [sp, #8]
   2b03e:	681b      	ldr	r3, [r3, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b044:	d937      	bls.n	2b0b6 <tNReverb_initToPool+0x1c6>
   2b046:	eeb7 7aca 	vcvt.f64.f32	d7, s20
   2b04a:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2b04e:	ee86 9b07 	vdiv.f64	d9, d6, d7
   2b052:	f103 0450 	add.w	r4, r3, #80	; 0x50
   2b056:	f103 0568 	add.w	r5, r3, #104	; 0x68
    
    r->t60 = t60;
   2b05a:	ed83 aa02 	vstr	s20, [r3, #8]
    
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
   2b05e:	eeb8 8b08 	vmov.f64	d8, #136	; 0xc0400000 -3.0
   2b062:	f1a4 001c 	sub.w	r0, r4, #28
   2b066:	f7fa f81b 	bl	250a0 <tLinearDelay_getDelay>
   2b06a:	ed98 7a01 	vldr	s14, [r8, #4]
   2b06e:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
   2b072:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2b076:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2b07a:	ee27 7b08 	vmul.f64	d7, d7, d8
   2b07e:	ee27 7b09 	vmul.f64	d7, d7, d9
   2b082:	ee27 1b01 	vmul.f64	d1, d7, d1
   2b086:	f002 f9df 	bl	2d448 <pow>
   2b08a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2b08e:	eca4 0a01 	vstmia	r4!, {s0}
   2b092:	42a5      	cmp	r5, r4
   2b094:	d1e5      	bne.n	2b062 <tNReverb_initToPool+0x172>
    r->allpassCoeff = 0.7f;
   2b096:	4a0e      	ldr	r2, [pc, #56]	; (2b0d0 <tNReverb_initToPool+0x1e0>)
    r->mix = 0.3f;
   2b098:	4b0e      	ldr	r3, [pc, #56]	; (2b0d4 <tNReverb_initToPool+0x1e4>)
    r->allpassCoeff = 0.7f;
   2b09a:	f8ca 204c 	str.w	r2, [sl, #76]	; 0x4c
    r->mix = 0.3f;
   2b09e:	f8ca 3004 	str.w	r3, [sl, #4]
}
   2b0a2:	b015      	add	sp, #84	; 0x54
   2b0a4:	ecbd 8b06 	vpop	{d8-d10}
   2b0a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2b0ac:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 2b0d8 <tNReverb_initToPool+0x1e8>
    if (t60 <= 0.0f) t60 = 0.001f;
   2b0b0:	ed9f aa0a 	vldr	s20, [pc, #40]	; 2b0dc <tNReverb_initToPool+0x1ec>
   2b0b4:	e738      	b.n	2af28 <tNReverb_initToPool+0x38>
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b0b6:	ed9f 9b02 	vldr	d9, [pc, #8]	; 2b0c0 <tNReverb_initToPool+0x1d0>
   2b0ba:	ed9f aa08 	vldr	s20, [pc, #32]	; 2b0dc <tNReverb_initToPool+0x1ec>
   2b0be:	e7c8      	b.n	2b052 <tNReverb_initToPool+0x162>
   2b0c0:	e7190014 	.word	0xe7190014
   2b0c4:	408f3fff 	.word	0x408f3fff
   2b0c8:	382393f9 	.word	0x382393f9
   2b0cc:	37be37c6 	.word	0x37be37c6
   2b0d0:	3f333333 	.word	0x3f333333
   2b0d4:	3e99999a 	.word	0x3e99999a
   2b0d8:	4479ffff 	.word	0x4479ffff
   2b0dc:	3a83126f 	.word	0x3a83126f
   2b0e0:	020fc0a8 	.word	0x020fc0a8
   2b0e4:	000327e0 	.word	0x000327e0

0002b0e8 <tNReverb_init>:
    tNReverb_initToPool(rev, t60, &leaf.mempool);
   2b0e8:	4901      	ldr	r1, [pc, #4]	; (2b0f0 <tNReverb_init+0x8>)
   2b0ea:	f7ff bf01 	b.w	2aef0 <tNReverb_initToPool>
   2b0ee:	bf00      	nop
   2b0f0:	020fc0c0 	.word	0x020fc0c0

0002b0f4 <tNReverb_free>:
{
   2b0f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tNReverb* r = *rev;
   2b0f6:	6807      	ldr	r7, [r0, #0]
   2b0f8:	f107 0534 	add.w	r5, r7, #52	; 0x34
   2b0fc:	f107 064c 	add.w	r6, r7, #76	; 0x4c
   2b100:	462c      	mov	r4, r5
        tLinearDelay_free(&r->combDelays[i]);
   2b102:	4620      	mov	r0, r4
   2b104:	3404      	adds	r4, #4
   2b106:	f7f9 fef9 	bl	24efc <tLinearDelay_free>
    for (int i = 0; i < 6; i++)
   2b10a:	42b4      	cmp	r4, r6
   2b10c:	d1f9      	bne.n	2b102 <tNReverb_free+0xe>
   2b10e:	f107 0414 	add.w	r4, r7, #20
        tLinearDelay_free(&r->allpassDelays[i]);
   2b112:	4620      	mov	r0, r4
   2b114:	3404      	adds	r4, #4
   2b116:	f7f9 fef1 	bl	24efc <tLinearDelay_free>
    for (int i = 0; i < 8; i++)
   2b11a:	42a5      	cmp	r5, r4
   2b11c:	d1f9      	bne.n	2b112 <tNReverb_free+0x1e>
    mpool_free((char*)r, r->mempool);
   2b11e:	6839      	ldr	r1, [r7, #0]
   2b120:	4638      	mov	r0, r7
}
   2b122:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
   2b126:	f7fe be57 	b.w	29dd8 <mpool_free>
   2b12a:	bf00      	nop
   2b12c:	0000      	movs	r0, r0
	...

0002b130 <tNReverb_setT60>:
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b130:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
   2b134:	b570      	push	{r4, r5, r6, lr}
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b136:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
   2b13a:	ed2d 8b04 	vpush	{d8-d9}
    _tNReverb* r = *rev;
   2b13e:	6803      	ldr	r3, [r0, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b140:	d92b      	bls.n	2b19a <tNReverb_setT60+0x6a>
   2b142:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
   2b146:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2b14a:	ee86 9b07 	vdiv.f64	d9, d6, d7
   2b14e:	f103 0450 	add.w	r4, r3, #80	; 0x50
   2b152:	f103 0668 	add.w	r6, r3, #104	; 0x68
   2b156:	4d16      	ldr	r5, [pc, #88]	; (2b1b0 <tNReverb_setT60+0x80>)
    r->t60 = t60;
   2b158:	ed83 0a02 	vstr	s0, [r3, #8]
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
   2b15c:	eeb8 8b08 	vmov.f64	d8, #136	; 0xc0400000 -3.0
   2b160:	f1a4 001c 	sub.w	r0, r4, #28
   2b164:	f7f9 ff9c 	bl	250a0 <tLinearDelay_getDelay>
   2b168:	ed95 7a01 	vldr	s14, [r5, #4]
   2b16c:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
   2b170:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
   2b174:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
   2b178:	ee27 7b08 	vmul.f64	d7, d7, d8
   2b17c:	ee27 7b09 	vmul.f64	d7, d7, d9
   2b180:	ee27 1b01 	vmul.f64	d1, d7, d1
   2b184:	f002 f960 	bl	2d448 <pow>
   2b188:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2b18c:	eca4 0a01 	vstmia	r4!, {s0}
   2b190:	42b4      	cmp	r4, r6
   2b192:	d1e5      	bne.n	2b160 <tNReverb_setT60+0x30>
    
}
   2b194:	ecbd 8b04 	vpop	{d8-d9}
   2b198:	bd70      	pop	{r4, r5, r6, pc}
   2b19a:	ed9f 9b03 	vldr	d9, [pc, #12]	; 2b1a8 <tNReverb_setT60+0x78>
    if (t60 <= 0.0f)           t60 = 0.001f;
   2b19e:	ed9f 0a05 	vldr	s0, [pc, #20]	; 2b1b4 <tNReverb_setT60+0x84>
   2b1a2:	e7d4      	b.n	2b14e <tNReverb_setT60+0x1e>
   2b1a4:	f3af 8000 	nop.w
   2b1a8:	e7190014 	.word	0xe7190014
   2b1ac:	408f3fff 	.word	0x408f3fff
   2b1b0:	020fc0a8 	.word	0x020fc0a8
   2b1b4:	3a83126f 	.word	0x3a83126f

0002b1b8 <tNReverb_setMix>:

void    tNReverb_setMix(tNReverb* const rev, float mix)
{
    _tNReverb* r = *rev;
   2b1b8:	6803      	ldr	r3, [r0, #0]
    r->mix = mix;
   2b1ba:	ed83 0a01 	vstr	s0, [r3, #4]
}
   2b1be:	4770      	bx	lr

0002b1c0 <tNReverb_tickStereo>:

    return out;
}

void   tNReverb_tickStereo(tNReverb* const rev, float input, float* output)
{
   2b1c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b1c4:	ed2d 8b06 	vpush	{d8-d10}
    _tNReverb* r = *rev;
   2b1c8:	6805      	ldr	r5, [r0, #0]
{
   2b1ca:	eeb0 9a40 	vmov.f32	s18, s0
   2b1ce:	4688      	mov	r8, r1
    r->lastIn = input;

    float temp, temp0, temp1, temp2, temp3, out;
    int i;

    temp0 = 0.0;
   2b1d0:	ed9f 8a4c 	vldr	s16, [pc, #304]	; 2b304 <tNReverb_tickStereo+0x144>
   2b1d4:	f105 0450 	add.w	r4, r5, #80	; 0x50
   2b1d8:	f105 0768 	add.w	r7, r5, #104	; 0x68
    r->lastIn = input;
   2b1dc:	ed85 0a1b 	vstr	s0, [r5, #108]	; 0x6c
   2b1e0:	f1a4 061c 	sub.w	r6, r4, #28
    for ( i=0; i<6; i++ )
    {
        temp = input + (r->combCoeffs[i] * tLinearDelay_getLastOut(&r->combDelays[i]));
   2b1e4:	ecf4 8a01 	vldmia	r4!, {s17}
   2b1e8:	4630      	mov	r0, r6
   2b1ea:	f7f9 ff5d 	bl	250a8 <tLinearDelay_getLastOut>
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
   2b1ee:	eef0 7a49 	vmov.f32	s15, s18
   2b1f2:	4630      	mov	r0, r6
   2b1f4:	eee8 7a80 	vfma.f32	s15, s17, s0
   2b1f8:	eeb0 0a67 	vmov.f32	s0, s15
   2b1fc:	f7f9 fe98 	bl	24f30 <tLinearDelay_tick>
    for ( i=0; i<6; i++ )
   2b200:	42bc      	cmp	r4, r7
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
   2b202:	ee38 8a00 	vadd.f32	s16, s16, s0
    for ( i=0; i<6; i++ )
   2b206:	d1eb      	bne.n	2b1e0 <tNReverb_tickStereo+0x20>
   2b208:	f105 0414 	add.w	r4, r5, #20
   2b20c:	f105 0620 	add.w	r6, r5, #32
    }

    for ( i=0; i<3; i++ )
    {
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
   2b210:	4620      	mov	r0, r4
   2b212:	f7f9 ff49 	bl	250a8 <tLinearDelay_getLastOut>
        temp1 = r->allpassCoeff * temp;
        temp1 += temp0;
   2b216:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
   2b21a:	eef0 8a40 	vmov.f32	s17, s0
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
   2b21e:	4620      	mov	r0, r4
        temp1 += temp0;
   2b220:	eea7 8a80 	vfma.f32	s16, s15, s0
   2b224:	3404      	adds	r4, #4
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
   2b226:	eeb0 0a48 	vmov.f32	s0, s16
   2b22a:	f7f9 fe81 	bl	24f30 <tLinearDelay_tick>
        temp0 = -(r->allpassCoeff * temp1) + temp;
   2b22e:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    for ( i=0; i<3; i++ )
   2b232:	42a6      	cmp	r6, r4
        temp0 = -(r->allpassCoeff * temp1) + temp;
   2b234:	eee7 8ac8 	vfms.f32	s17, s15, s16
   2b238:	eeb0 8a68 	vmov.f32	s16, s17
    for ( i=0; i<3; i++ )
   2b23c:	d1e8      	bne.n	2b210 <tNReverb_tickStereo+0x50>
    }

    // One-pole lowpass filter.
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b23e:	eddf 7a32 	vldr	s15, [pc, #200]	; 2b308 <tNReverb_tickStereo+0x148>

    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2b242:	4630      	mov	r0, r6
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b244:	ed95 7a1a 	vldr	s14, [r5, #104]	; 0x68
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
    temp1 = -(r->allpassCoeff * temp1) + temp;

    float drymix = ( 1.0f - r->mix ) * input;

    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b248:	f105 0724 	add.w	r7, r5, #36	; 0x24
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b24c:	ee28 8aa7 	vmul.f32	s16, s17, s15
   2b250:	eddf 7a2e 	vldr	s15, [pc, #184]	; 2b30c <tNReverb_tickStereo+0x14c>
    float drymix = ( 1.0f - r->mix ) * input;
   2b254:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
    out = output[0];


    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b258:	f105 0428 	add.w	r4, r5, #40	; 0x28
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
   2b25c:	eea7 8a27 	vfma.f32	s16, s14, s15
   2b260:	ed85 8a1a 	vstr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2b264:	f7f9 ff20 	bl	250a8 <tLinearDelay_getLastOut>
    temp1 += r->lowpassState;
   2b268:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
   2b26c:	ed95 8a1a 	vldr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
   2b270:	eef0 8a40 	vmov.f32	s17, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
   2b274:	4630      	mov	r0, r6
    temp1 += r->lowpassState;
   2b276:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
   2b27a:	eeb0 0a48 	vmov.f32	s0, s16
   2b27e:	f7f9 fe57 	bl	24f30 <tLinearDelay_tick>
    temp1 = -(r->allpassCoeff * temp1) + temp;
   2b282:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
    float drymix = ( 1.0f - r->mix ) * input;
   2b286:	edd5 7a01 	vldr	s15, [r5, #4]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b28a:	4638      	mov	r0, r7
    temp1 = -(r->allpassCoeff * temp1) + temp;
   2b28c:	eee7 8a48 	vfms.f32	s17, s14, s16
    float drymix = ( 1.0f - r->mix ) * input;
   2b290:	ee3a aa67 	vsub.f32	s20, s20, s15
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b294:	f7f9 ff08 	bl	250a8 <tLinearDelay_getLastOut>
    temp2 += temp1;
   2b298:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
   2b29c:	eef0 9a40 	vmov.f32	s19, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
   2b2a0:	4638      	mov	r0, r7
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2b2a2:	eeea 9a09 	vfma.f32	s19, s20, s18
    temp2 += temp1;
   2b2a6:	eeb0 8a68 	vmov.f32	s16, s17
   2b2aa:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
   2b2ae:	eeb0 0a48 	vmov.f32	s0, s16
   2b2b2:	f7f9 fe3d 	bl	24f30 <tLinearDelay_tick>
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2b2b6:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b2ba:	4620      	mov	r0, r4
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
   2b2bc:	eee7 9ac8 	vfms.f32	s19, s15, s16
   2b2c0:	edc8 9a00 	vstr	s19, [r8]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b2c4:	f7f9 fef0 	bl	250a8 <tLinearDelay_getLastOut>
    temp3 = r->allpassCoeff * temp;
    temp3 += temp1;
   2b2c8:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
   2b2cc:	eeb0 8a40 	vmov.f32	s16, s0
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
   2b2d0:	4620      	mov	r0, r4
    temp3 += temp1;
   2b2d2:	eee7 8a80 	vfma.f32	s17, s15, s0
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
   2b2d6:	eeaa 8a09 	vfma.f32	s16, s20, s18
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
   2b2da:	eeb0 0a68 	vmov.f32	s0, s17
   2b2de:	f7f9 fe27 	bl	24f30 <tLinearDelay_tick>
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
   2b2e2:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
   2b2e6:	edd5 7a01 	vldr	s15, [r5, #4]
   2b2ea:	eea7 8a68 	vfms.f32	s16, s14, s17
   2b2ee:	ee28 8a27 	vmul.f32	s16, s16, s15
   2b2f2:	ed88 8a01 	vstr	s16, [r8, #4]

    r->lastOut = out;
   2b2f6:	edc5 9a1c 	vstr	s19, [r5, #112]	; 0x70
}
   2b2fa:	ecbd 8b06 	vpop	{d8-d10}
   2b2fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b302:	bf00      	nop
   2b304:	00000000 	.word	0x00000000
   2b308:	3e99999a 	.word	0x3e99999a
   2b30c:	3f333333 	.word	0x3f333333

0002b310 <tDattorroReverb_initToPool>:
{
    tDattorroReverb_initToPool(rev, &leaf.mempool);
}

void    tDattorroReverb_initToPool        (tDattorroReverb* const rev, tMempool* const mp)
{
   2b310:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b314:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
   2b318:	680d      	ldr	r5, [r1, #0]
{
   2b31a:	460e      	mov	r6, r1
   2b31c:	4681      	mov	r9, r0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2b31e:	2088      	movs	r0, #136	; 0x88
   2b320:	4629      	mov	r1, r5
    r->mempool = m;
    
    r->size_max = 2.0f;
    r->size = 1.f;
   2b322:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2b326:	f7fe fcaf 	bl	29c88 <mpool_alloc>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b32a:	4ac4      	ldr	r2, [pc, #784]	; (2b63c <tDattorroReverb_initToPool+0x32c>)
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
   2b32c:	f8c9 0000 	str.w	r0, [r9]
   2b330:	4604      	mov	r4, r0
    r->mempool = m;
   2b332:	6005      	str	r5, [r0, #0]
    r->size_max = 2.0f;
   2b334:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b338:	edd2 7a00 	vldr	s15, [r2]
    r->frozen = 0;
   2b33c:	2300      	movs	r3, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b33e:	eddf 6ac0 	vldr	s13, [pc, #768]	; 2b640 <tDattorroReverb_initToPool+0x330>
    // INPUT
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2b342:	3038      	adds	r0, #56	; 0x38
   2b344:	ed9f 7abf 	vldr	s14, [pc, #764]	; 2b644 <tDattorroReverb_initToPool+0x334>
   2b348:	4632      	mov	r2, r6
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b34a:	ee67 7aa6 	vmul.f32	s15, s15, s13
    r->size_max = 2.0f;
   2b34e:	f840 1c18 	str.w	r1, [r0, #-24]
    r->frozen = 0;
   2b352:	f840 3c20 	str.w	r3, [r0, #-32]
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
    
    for (int i = 0; i < 4; i++)
    {
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
   2b356:	eeb3 8a04 	vmov.f32	s16, #52	; 0x41a00000  20.0
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2b35a:	ed9f 0abb 	vldr	s0, [pc, #748]	; 2b648 <tDattorroReverb_initToPool+0x338>
   2b35e:	f104 0540 	add.w	r5, r4, #64	; 0x40
   2b362:	ee27 7a87 	vmul.f32	s14, s15, s14
    r->t = r->size * leaf.sampleRate * 0.001f;
   2b366:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    r->size = 1.f;
   2b36a:	edc4 8a07 	vstr	s17, [r4, #28]
   2b36e:	f104 0a50 	add.w	sl, r4, #80	; 0x50
   2b372:	f8df 831c 	ldr.w	r8, [pc, #796]	; 2b690 <tDattorroReverb_initToPool+0x380>
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
   2b376:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b37a:	4fb4      	ldr	r7, [pc, #720]	; (2b64c <tDattorroReverb_initToPool+0x33c>)
   2b37c:	ee17 1a90 	vmov	r1, s15
   2b380:	f7f9 feca 	bl	25118 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
   2b384:	4631      	mov	r1, r6
   2b386:	eeb0 0a68 	vmov.f32	s0, s17
   2b38a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2b38e:	f7fc febb 	bl	28108 <tOnePole_initToPool>
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
   2b392:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b396:	4628      	mov	r0, r5
   2b398:	ecb8 0a01 	vldmia	r8!, {s0}
   2b39c:	4632      	mov	r2, r6
   2b39e:	ee27 7a88 	vmul.f32	s14, s15, s16
   2b3a2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b3a6:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b3aa:	ee17 1a90 	vmov	r1, s15
   2b3ae:	f7fc fe5b 	bl	28068 <tAllpass_initToPool>
        tAllpass_setGain(&r->in_allpass[i], in_allpass_gains[i]);
   2b3b2:	4628      	mov	r0, r5
   2b3b4:	3504      	adds	r5, #4
   2b3b6:	ecb7 0a01 	vldmia	r7!, {s0}
   2b3ba:	f7fc fe87 	bl	280cc <tAllpass_setGain>
    for (int i = 0; i < 4; i++)
   2b3be:	4555      	cmp	r5, sl
   2b3c0:	d1e7      	bne.n	2b392 <tDattorroReverb_initToPool+0x82>
    }
    
    // FEEDBACK 1
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b3c2:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b3c6:	4632      	mov	r2, r6
   2b3c8:	ed9f 9aa1 	vldr	s18, [pc, #644]	; 2b650 <tDattorroReverb_initToPool+0x340>
   2b3cc:	4628      	mov	r0, r5
   2b3ce:	ed9f 0aa1 	vldr	s0, [pc, #644]	; 2b654 <tDattorroReverb_initToPool+0x344>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
    
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2b3d2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b3d6:	ee27 7a89 	vmul.f32	s14, s15, s18
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2b3da:	eddf 8a9a 	vldr	s17, [pc, #616]	; 2b644 <tDattorroReverb_initToPool+0x334>
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b3de:	ee27 0a80 	vmul.f32	s0, s15, s0
    
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f1_lfo, mp);
   2b3e2:	f104 0868 	add.w	r8, r4, #104	; 0x68
    tCycle_setFreq(&r->f1_lfo, 0.1f);
    
    // FEEDBACK 2
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
   2b3e6:	f104 076c 	add.w	r7, r4, #108	; 0x6c
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
   2b3ea:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b3ee:	ee17 1a90 	vmov	r1, s15
   2b3f2:	f7fc fe39 	bl	28068 <tAllpass_initToPool>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
   2b3f6:	4628      	mov	r0, r5
   2b3f8:	ed9f 0a97 	vldr	s0, [pc, #604]	; 2b658 <tDattorroReverb_initToPool+0x348>
    
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f2_lfo, mp);
   2b3fc:	f104 0584 	add.w	r5, r4, #132	; 0x84
    tAllpass_setGain(&r->f1_allpass, 0.7f);
   2b400:	f7fc fe64 	bl	280cc <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
   2b404:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b408:	edd4 7a08 	vldr	s15, [r4, #32]
   2b40c:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2b410:	ed9f 0a92 	vldr	s0, [pc, #584]	; 2b65c <tDattorroReverb_initToPool+0x34c>
   2b414:	4632      	mov	r2, r6
   2b416:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b41a:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b41e:	eeb0 7a48 	vmov.f32	s14, s16
   2b422:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b426:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b42a:	ee17 1a90 	vmov	r1, s15
   2b42e:	f7f9 fe73 	bl	25118 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_2, SAMP(89.24f), SAMP(100.0f) * r->size_max + 1, mp);
   2b432:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b436:	edd4 7a08 	vldr	s15, [r4, #32]
   2b43a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2b43e:	ed9f 0a88 	vldr	s0, [pc, #544]	; 2b660 <tDattorroReverb_initToPool+0x350>
   2b442:	4632      	mov	r2, r6
   2b444:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b448:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b44c:	eeb0 7a48 	vmov.f32	s14, s16
   2b450:	eea7 7a89 	vfma.f32	s14, s15, s18
   2b454:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b458:	ee17 1a90 	vmov	r1, s15
   2b45c:	f7f9 fe5c 	bl	25118 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_3, SAMP(125.f), SAMP(200.0f) * r->size_max + 1, mp);
   2b460:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b464:	edd4 7a08 	vldr	s15, [r4, #32]
   2b468:	4632      	mov	r2, r6
   2b46a:	ed9f 0a7e 	vldr	s0, [pc, #504]	; 2b664 <tDattorroReverb_initToPool+0x354>
   2b46e:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2b472:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b476:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b47a:	eeb0 7a48 	vmov.f32	s14, s16
   2b47e:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b482:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b486:	ee17 1a90 	vmov	r1, s15
   2b48a:	f7f9 fe45 	bl	25118 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
   2b48e:	eeb0 0a48 	vmov.f32	s0, s16
   2b492:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2b496:	4631      	mov	r1, r6
   2b498:	f7fc fe36 	bl	28108 <tOnePole_initToPool>
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
   2b49c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2b4a0:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b4a4:	4631      	mov	r1, r6
   2b4a6:	f7fd f869 	bl	2857c <tHighpass_initToPool>
    tCycle_initToPool(&r->f1_lfo, mp);
   2b4aa:	4631      	mov	r1, r6
   2b4ac:	4640      	mov	r0, r8
   2b4ae:	f7ff f88b 	bl	2a5c8 <tCycle_initToPool>
    tCycle_setFreq(&r->f1_lfo, 0.1f);
   2b4b2:	4640      	mov	r0, r8
   2b4b4:	ed9f 0a6c 	vldr	s0, [pc, #432]	; 2b668 <tDattorroReverb_initToPool+0x358>
   2b4b8:	f7ff f898 	bl	2a5ec <tCycle_setFreq>
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
   2b4bc:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b4c0:	ed9f 0a6a 	vldr	s0, [pc, #424]	; 2b66c <tDattorroReverb_initToPool+0x35c>
   2b4c4:	4632      	mov	r2, r6
   2b4c6:	ee27 7a89 	vmul.f32	s14, s15, s18
   2b4ca:	4638      	mov	r0, r7
   2b4cc:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b4d0:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b4d4:	ee17 1a90 	vmov	r1, s15
   2b4d8:	f7fc fdc6 	bl	28068 <tAllpass_initToPool>
    tAllpass_setGain(&r->f2_allpass, 0.7f);
   2b4dc:	4638      	mov	r0, r7
   2b4de:	ed9f 0a5e 	vldr	s0, [pc, #376]	; 2b658 <tDattorroReverb_initToPool+0x348>
   2b4e2:	f7fc fdf3 	bl	280cc <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f2_delay_1, SAMP(149.62f), SAMP(200.f) * r->size_max + 1, mp);
   2b4e6:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b4ea:	edd4 7a08 	vldr	s15, [r4, #32]
   2b4ee:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2b4f2:	ed9f 0a5f 	vldr	s0, [pc, #380]	; 2b670 <tDattorroReverb_initToPool+0x360>
   2b4f6:	4632      	mov	r2, r6
   2b4f8:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b4fc:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b500:	eeb0 7a48 	vmov.f32	s14, s16
   2b504:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b508:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b50c:	ee17 1a90 	vmov	r1, s15
   2b510:	f7f9 fe02 	bl	25118 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_2, SAMP(60.48f), SAMP(100.f) * r->size_max + 1, mp);
   2b514:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b518:	edd4 7a08 	vldr	s15, [r4, #32]
   2b51c:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2b520:	ed9f 0a54 	vldr	s0, [pc, #336]	; 2b674 <tDattorroReverb_initToPool+0x364>
   2b524:	4632      	mov	r2, r6
   2b526:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b52a:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b52e:	eeb0 7a48 	vmov.f32	s14, s16
   2b532:	eea7 7a89 	vfma.f32	s14, s15, s18
   2b536:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b53a:	ee17 1a90 	vmov	r1, s15
   2b53e:	f7f9 fdeb 	bl	25118 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_3, SAMP(106.28f), SAMP(200.f) * r->size_max + 1, mp);
   2b542:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b546:	edd4 7a08 	vldr	s15, [r4, #32]
   2b54a:	4632      	mov	r2, r6
   2b54c:	ed9f 0a4a 	vldr	s0, [pc, #296]	; 2b678 <tDattorroReverb_initToPool+0x368>
   2b550:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2b554:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b558:	ee27 0a00 	vmul.f32	s0, s14, s0
   2b55c:	eeb0 7a48 	vmov.f32	s14, s16
   2b560:	eea7 7aa8 	vfma.f32	s14, s15, s17
   2b564:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2b568:	ee17 1a90 	vmov	r1, s15
   2b56c:	f7f9 fdd4 	bl	25118 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
   2b570:	eeb0 0a48 	vmov.f32	s0, s16
   2b574:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b578:	4631      	mov	r1, r6
   2b57a:	f7fc fdc5 	bl	28108 <tOnePole_initToPool>
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
   2b57e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
   2b582:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2b586:	4631      	mov	r1, r6
   2b588:	f7fc fff8 	bl	2857c <tHighpass_initToPool>
    tCycle_initToPool(&r->f2_lfo, mp);
   2b58c:	4631      	mov	r1, r6
   2b58e:	4628      	mov	r0, r5
   2b590:	f7ff f81a 	bl	2a5c8 <tCycle_initToPool>
    tCycle_setFreq(&r->f2_lfo, 0.07f);
   2b594:	4628      	mov	r0, r5
   2b596:	ed9f 0a39 	vldr	s0, [pc, #228]	; 2b67c <tDattorroReverb_initToPool+0x36c>
   2b59a:	f7ff f827 	bl	2a5ec <tCycle_setFreq>
}

void    tDattorroReverb_setMix            (tDattorroReverb* const rev, float mix)
{
    _tDattorroReverb* r = *rev;
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b59e:	eeb0 1a48 	vmov.f32	s2, s16
    _tDattorroReverb* r = *rev;
   2b5a2:	f8d9 4000 	ldr.w	r4, [r9]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b5a6:	eef6 0a00 	vmov.f32	s1, #96	; 0x3f000000  0.5
   2b5aa:	ed9f 0a27 	vldr	s0, [pc, #156]	; 2b648 <tDattorroReverb_initToPool+0x338>
   2b5ae:	f7fe f96b 	bl	29888 <LEAF_clip>

void    tDattorroReverb_setInputDelay     (tDattorroReverb* const rev, float preDelay)
{
    _tDattorroReverb* r = *rev;
    
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b5b2:	eddf 0a25 	vldr	s1, [pc, #148]	; 2b648 <tDattorroReverb_initToPool+0x338>
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2b5b6:	ed84 0a05 	vstr	s0, [r4, #20]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b5ba:	eeb0 1a68 	vmov.f32	s2, s17
    _tDattorroReverb* r = *rev;
   2b5be:	f8d9 4000 	ldr.w	r4, [r9]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b5c2:	eeb0 0a60 	vmov.f32	s0, s1
   2b5c6:	f7fe f95f 	bl	29888 <LEAF_clip>
    
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
   2b5ca:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b5ce:	f104 0038 	add.w	r0, r4, #56	; 0x38
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
   2b5d2:	ed84 0a01 	vstr	s0, [r4, #4]
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
   2b5d6:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b5da:	f7f9 fe51 	bl	25280 <tTapeDelay_setDelay>
}

void    tDattorroReverb_setInputFilter    (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
   2b5de:	f8d9 4000 	ldr.w	r4, [r9]
    
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b5e2:	ed9f 1a27 	vldr	s2, [pc, #156]	; 2b680 <tDattorroReverb_initToPool+0x370>
   2b5e6:	eddf 0a27 	vldr	s1, [pc, #156]	; 2b684 <tDattorroReverb_initToPool+0x374>
   2b5ea:	ed9f 0a17 	vldr	s0, [pc, #92]	; 2b648 <tDattorroReverb_initToPool+0x338>
   2b5ee:	f7fe f94b 	bl	29888 <LEAF_clip>
    
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2b5f2:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b5f6:	ed84 0a02 	vstr	s0, [r4, #8]
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2b5fa:	f7fc fdbf 	bl	2817c <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackFilter (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
   2b5fe:	f8d9 4000 	ldr.w	r4, [r9]
    
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b602:	ed9f 1a1f 	vldr	s2, [pc, #124]	; 2b680 <tDattorroReverb_initToPool+0x370>
   2b606:	eddf 0a20 	vldr	s1, [pc, #128]	; 2b688 <tDattorroReverb_initToPool+0x378>
   2b60a:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 2b648 <tDattorroReverb_initToPool+0x338>
   2b60e:	f7fe f93b 	bl	29888 <LEAF_clip>
    
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2b612:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2b616:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2b61a:	f7fc fdaf 	bl	2817c <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2b61e:	ed94 0a03 	vldr	s0, [r4, #12]
   2b622:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b626:	f7fc fda9 	bl	2817c <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackGain   (tDattorroReverb* const rev, float gain)
{
    _tDattorroReverb* r = *rev;
   2b62a:	f8d9 3000 	ldr.w	r3, [r9]
    r->feedback_gain = gain;
   2b62e:	4a17      	ldr	r2, [pc, #92]	; (2b68c <tDattorroReverb_initToPool+0x37c>)
   2b630:	611a      	str	r2, [r3, #16]
}
   2b632:	ecbd 8b04 	vpop	{d8-d9}
   2b636:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b63a:	bf00      	nop
   2b63c:	020fc0a8 	.word	0x020fc0a8
   2b640:	3a83126f 	.word	0x3a83126f
   2b644:	43480000 	.word	0x43480000
   2b648:	00000000 	.word	0x00000000
   2b64c:	00062c38 	.word	0x00062c38
   2b650:	42c80000 	.word	0x42c80000
   2b654:	41f4147b 	.word	0x41f4147b
   2b658:	3f333333 	.word	0x3f333333
   2b65c:	430db0a4 	.word	0x430db0a4
   2b660:	42b27ae1 	.word	0x42b27ae1
   2b664:	42fa0000 	.word	0x42fa0000
   2b668:	3dcccccd 	.word	0x3dcccccd
   2b66c:	41b4a3d7 	.word	0x41b4a3d7
   2b670:	43159eb8 	.word	0x43159eb8
   2b674:	4271eb85 	.word	0x4271eb85
   2b678:	42d48f5c 	.word	0x42d48f5c
   2b67c:	3d8f5c29 	.word	0x3d8f5c29
   2b680:	469c4000 	.word	0x469c4000
   2b684:	461c4000 	.word	0x461c4000
   2b688:	459c4000 	.word	0x459c4000
   2b68c:	3ecccccd 	.word	0x3ecccccd
   2b690:	00062c28 	.word	0x00062c28

0002b694 <tDattorroReverb_init>:
    tDattorroReverb_initToPool(rev, &leaf.mempool);
   2b694:	4901      	ldr	r1, [pc, #4]	; (2b69c <tDattorroReverb_init+0x8>)
   2b696:	f7ff be3b 	b.w	2b310 <tDattorroReverb_initToPool>
   2b69a:	bf00      	nop
   2b69c:	020fc0c0 	.word	0x020fc0c0

0002b6a0 <tDattorroReverb_free>:
{
   2b6a0:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2b6a2:	6804      	ldr	r4, [r0, #0]
    tTapeDelay_free(&r->in_delay);
   2b6a4:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2b6a8:	f7f9 fd68 	bl	2517c <tTapeDelay_free>
    tOnePole_free(&r->in_filter);
   2b6ac:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2b6b0:	f7fc fd60 	bl	28174 <tOnePole_free>
        tAllpass_free(&r->in_allpass[i]);
   2b6b4:	f104 0040 	add.w	r0, r4, #64	; 0x40
   2b6b8:	f7fc fcf8 	bl	280ac <tAllpass_free>
   2b6bc:	f104 0044 	add.w	r0, r4, #68	; 0x44
   2b6c0:	f7fc fcf4 	bl	280ac <tAllpass_free>
   2b6c4:	f104 0048 	add.w	r0, r4, #72	; 0x48
   2b6c8:	f7fc fcf0 	bl	280ac <tAllpass_free>
   2b6cc:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   2b6d0:	f7fc fcec 	bl	280ac <tAllpass_free>
    tAllpass_free(&r->f1_allpass);
   2b6d4:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2b6d8:	f7fc fce8 	bl	280ac <tAllpass_free>
    tTapeDelay_free(&r->f1_delay_1);
   2b6dc:	f104 0054 	add.w	r0, r4, #84	; 0x54
   2b6e0:	f7f9 fd4c 	bl	2517c <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_2);
   2b6e4:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2b6e8:	f7f9 fd48 	bl	2517c <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_3);
   2b6ec:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2b6f0:	f7f9 fd44 	bl	2517c <tTapeDelay_free>
    tOnePole_free(&r->f1_filter);
   2b6f4:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2b6f8:	f7fc fd3c 	bl	28174 <tOnePole_free>
    tHighpass_free(&r->f1_hp);
   2b6fc:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b700:	f7fc ff5c 	bl	285bc <tHighpass_free>
    tCycle_free(&r->f1_lfo);
   2b704:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2b708:	f7fe ff6c 	bl	2a5e4 <tCycle_free>
    tAllpass_free(&r->f2_allpass);
   2b70c:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2b710:	f7fc fccc 	bl	280ac <tAllpass_free>
    tTapeDelay_free(&r->f2_delay_1);
   2b714:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2b718:	f7f9 fd30 	bl	2517c <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_2);
   2b71c:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2b720:	f7f9 fd2c 	bl	2517c <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_3);
   2b724:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2b728:	f7f9 fd28 	bl	2517c <tTapeDelay_free>
    tOnePole_free(&r->f2_filter);
   2b72c:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b730:	f7fc fd20 	bl	28174 <tOnePole_free>
    tHighpass_free(&r->f2_hp);
   2b734:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2b738:	f7fc ff40 	bl	285bc <tHighpass_free>
    tCycle_free(&r->f2_lfo);
   2b73c:	f104 0084 	add.w	r0, r4, #132	; 0x84
   2b740:	f7fe ff50 	bl	2a5e4 <tCycle_free>
    mpool_free((char*)r, r->mempool);
   2b744:	6821      	ldr	r1, [r4, #0]
   2b746:	4620      	mov	r0, r4
}
   2b748:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)r, r->mempool);
   2b74c:	f7fe bb44 	b.w	29dd8 <mpool_free>

0002b750 <tDattorroReverb_tickStereo>:
{
   2b750:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b754:	ed2d 8b06 	vpush	{d8-d10}
    _tDattorroReverb* r = *rev;
   2b758:	6804      	ldr	r4, [r0, #0]
{
   2b75a:	468a      	mov	sl, r1
    	input = 0.0f;
   2b75c:	eddf 9abf 	vldr	s19, [pc, #764]	; 2ba5c <tDattorroReverb_tickStereo+0x30c>
    if (r->frozen)
   2b760:	69a3      	ldr	r3, [r4, #24]
	in_sample = tTapeDelay_tick(&r->in_delay, input);
   2b762:	f104 0038 	add.w	r0, r4, #56	; 0x38
   2b766:	f104 0540 	add.w	r5, r4, #64	; 0x40
   2b76a:	f104 0650 	add.w	r6, r4, #80	; 0x50
    	input = 0.0f;
   2b76e:	2b00      	cmp	r3, #0
   2b770:	fe40 9a29 	vseleq.f32	s19, s0, s19
	in_sample = tTapeDelay_tick(&r->in_delay, input);
   2b774:	eeb0 0a69 	vmov.f32	s0, s19
   2b778:	f7f9 fd0c 	bl	25194 <tTapeDelay_tick>
	in_sample = tOnePole_tick(&r->in_filter, in_sample);
   2b77c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2b780:	f7fc fd18 	bl	281b4 <tOnePole_tick>
   2b784:	eeb0 8a40 	vmov.f32	s16, s0
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
   2b788:	4628      	mov	r0, r5
   2b78a:	3504      	adds	r5, #4
   2b78c:	eeb0 0a48 	vmov.f32	s0, s16
   2b790:	f7fc fca0 	bl	280d4 <tAllpass_tick>
	for (int i = 0; i < 4; i++)
   2b794:	42b5      	cmp	r5, r6
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
   2b796:	eeb0 8a40 	vmov.f32	s16, s0
	for (int i = 0; i < 4; i++)
   2b79a:	d1f5      	bne.n	2b788 <tDattorroReverb_tickStereo+0x38>
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
   2b79c:	edd4 8a0d 	vldr	s17, [r4, #52]	; 0x34
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2b7a0:	f104 0068 	add.w	r0, r4, #104	; 0x68
   2b7a4:	ed94 9a09 	vldr	s18, [r4, #36]	; 0x24
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
   2b7a8:	f104 0654 	add.w	r6, r4, #84	; 0x54
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
   2b7ac:	ee70 8a28 	vadd.f32	s17, s0, s17
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2b7b0:	f7fe ff2a 	bl	2a608 <tCycle_tick>
   2b7b4:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
   2b7b8:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b7bc:	ed9f 7aa8 	vldr	s14, [pc, #672]	; 2ba60 <tDattorroReverb_tickStereo+0x310>
   2b7c0:	4628      	mov	r0, r5
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2b7c2:	f104 095c 	add.w	r9, r4, #92	; 0x5c
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
   2b7c6:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2b7ca:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b7ce:	eea9 0a07 	vfma.f32	s0, s18, s14
   2b7d2:	f7fc fc77 	bl	280c4 <tAllpass_setDelay>
		f1_sample = tAllpass_tick(&r->f1_allpass, f1_sample);
   2b7d6:	eeb0 0a68 	vmov.f32	s0, s17
   2b7da:	4628      	mov	r0, r5
   2b7dc:	f7fc fc7a 	bl	280d4 <tAllpass_tick>
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
   2b7e0:	4630      	mov	r0, r6
   2b7e2:	f7f9 fcd7 	bl	25194 <tTapeDelay_tick>
		f1_sample = tOnePole_tick(&r->f1_filter, f1_sample);
   2b7e6:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2b7ea:	f7fc fce3 	bl	281b4 <tOnePole_tick>
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
   2b7ee:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2b7f2:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2b7f6:	4648      	mov	r0, r9
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
   2b7f8:	eea7 0a27 	vfma.f32	s0, s14, s15
   2b7fc:	eef0 8a40 	vmov.f32	s17, s0
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
   2b800:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b804:	f7f9 fcc6 	bl	25194 <tTapeDelay_tick>
   2b808:	eef0 7a40 	vmov.f32	s15, s0
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
   2b80c:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2b810:	ee38 0a80 	vadd.f32	s0, s17, s0
		r->f1_delay_2_last = f1_delay_2_sample;
   2b814:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
   2b818:	f7fc fee4 	bl	285e4 <tHighpass_tick>
		if (r->frozen)
   2b81c:	69a3      	ldr	r3, [r4, #24]
		f1_sample *= r->feedback_gain;
   2b81e:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
   2b822:	2b00      	cmp	r3, #0
   2b824:	f040 8114 	bne.w	2ba50 <tDattorroReverb_tickStereo+0x300>
		f1_sample *= r->feedback_gain;
   2b828:	ee27 0a80 	vmul.f32	s0, s15, s0
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2b82c:	f104 0860 	add.w	r8, r4, #96	; 0x60
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2b830:	f104 076c 	add.w	r7, r4, #108	; 0x6c
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
   2b834:	f104 0570 	add.w	r5, r4, #112	; 0x70
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2b838:	f104 0b78 	add.w	fp, r4, #120	; 0x78
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2b83c:	4640      	mov	r0, r8
   2b83e:	f7f9 fca9 	bl	25194 <tTapeDelay_tick>
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2b842:	f104 0084 	add.w	r0, r4, #132	; 0x84
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
   2b846:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
		f2_sample = in_sample + r->f1_last;
   2b84a:	ee30 8a08 	vadd.f32	s16, s0, s16
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
   2b84e:	edd4 8a09 	vldr	s17, [r4, #36]	; 0x24
   2b852:	f7fe fed9 	bl	2a608 <tCycle_tick>
   2b856:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
   2b85a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b85e:	ed9f 7a81 	vldr	s14, [pc, #516]	; 2ba64 <tDattorroReverb_tickStereo+0x314>
   2b862:	4638      	mov	r0, r7
   2b864:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2b868:	ee27 0a80 	vmul.f32	s0, s15, s0
   2b86c:	eea8 0a87 	vfma.f32	s0, s17, s14
   2b870:	f7fc fc28 	bl	280c4 <tAllpass_setDelay>
		f2_sample = tAllpass_tick(&r->f2_allpass, f2_sample);
   2b874:	eeb0 0a48 	vmov.f32	s0, s16
   2b878:	4638      	mov	r0, r7
   2b87a:	f7fc fc2b 	bl	280d4 <tAllpass_tick>
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
   2b87e:	4628      	mov	r0, r5
   2b880:	f7f9 fc88 	bl	25194 <tTapeDelay_tick>
		f2_sample = tOnePole_tick(&r->f2_filter, f2_sample);
   2b884:	f104 0074 	add.w	r0, r4, #116	; 0x74
   2b888:	f7fc fc94 	bl	281b4 <tOnePole_tick>
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
   2b88c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2b890:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2b894:	4658      	mov	r0, fp
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
   2b896:	eea7 0a27 	vfma.f32	s0, s14, s15
   2b89a:	eeb0 8a40 	vmov.f32	s16, s0
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
   2b89e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b8a2:	f7f9 fc77 	bl	25194 <tTapeDelay_tick>
   2b8a6:	eef0 7a40 	vmov.f32	s15, s0
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
   2b8aa:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2b8ae:	ee38 0a00 	vadd.f32	s0, s16, s0
		r->f2_delay_2_last = f2_delay_2_sample;
   2b8b2:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
   2b8b6:	f7fc fe95 	bl	285e4 <tHighpass_tick>
		if (r->frozen)
   2b8ba:	69a3      	ldr	r3, [r4, #24]
		f2_sample *= r->feedback_gain;
   2b8bc:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
   2b8c0:	2b00      	cmp	r3, #0
   2b8c2:	f000 80c8 	beq.w	2ba56 <tDattorroReverb_tickStereo+0x306>
			f2_sample = 0.0f;
   2b8c6:	ed9f 0a65 	vldr	s0, [pc, #404]	; 2ba5c <tDattorroReverb_tickStereo+0x30c>
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2b8ca:	f104 077c 	add.w	r7, r4, #124	; 0x7c
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b8ce:	ed9f aa66 	vldr	s20, [pc, #408]	; 2ba68 <tDattorroReverb_tickStereo+0x318>
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2b8d2:	4638      	mov	r0, r7
   2b8d4:	f7f9 fc5e 	bl	25194 <tTapeDelay_tick>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2b8d8:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b8dc:	eddf 7a63 	vldr	s15, [pc, #396]	; 2ba6c <tDattorroReverb_tickStereo+0x31c>
   2b8e0:	4630      	mov	r0, r6
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
   2b8e2:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2b8e6:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b8ea:	f7f9 fcd9 	bl	252a0 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
   2b8ee:	eddf 7a60 	vldr	s15, [pc, #384]	; 2ba70 <tDattorroReverb_tickStereo+0x320>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
   2b8f2:	eeb0 8a40 	vmov.f32	s16, s0
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
   2b8f6:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b8fa:	4630      	mov	r0, r6
   2b8fc:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b900:	f7f9 fcce 	bl	252a0 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
   2b904:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b908:	eddf 7a5a 	vldr	s15, [pc, #360]	; 2ba74 <tDattorroReverb_tickStereo+0x324>
   2b90c:	ee38 8a00 	vadd.f32	s16, s16, s0
   2b910:	4648      	mov	r0, r9
   2b912:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b916:	f7f9 fcc3 	bl	252a0 <tTapeDelay_tapOut>
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2b91a:	eddf 7a57 	vldr	s15, [pc, #348]	; 2ba78 <tDattorroReverb_tickStereo+0x328>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
   2b91e:	eef0 8a40 	vmov.f32	s17, s0
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2b922:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b926:	4640      	mov	r0, r8
   2b928:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b92c:	f7f9 fcb8 	bl	252a0 <tTapeDelay_tapOut>
   2b930:	ee30 9a08 	vadd.f32	s18, s0, s16
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2b934:	eddf 7a51 	vldr	s15, [pc, #324]	; 2ba7c <tDattorroReverb_tickStereo+0x32c>
   2b938:	4628      	mov	r0, r5
   2b93a:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
   2b93e:	ee39 9a68 	vsub.f32	s18, s18, s17
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2b942:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b946:	f7f9 fcab 	bl	252a0 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b94a:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
   2b94e:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b952:	4658      	mov	r0, fp
   2b954:	ee27 0a8a 	vmul.f32	s0, s15, s20
   2b958:	f7f9 fca2 	bl	252a0 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2b95c:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b960:	eddf 7a47 	vldr	s15, [pc, #284]	; 2ba80 <tDattorroReverb_tickStereo+0x330>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b964:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2b968:	4638      	mov	r0, r7
   2b96a:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b96e:	f7f9 fc97 	bl	252a0 <tTapeDelay_tapOut>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2b972:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b976:	eddf 7a43 	vldr	s15, [pc, #268]	; 2ba84 <tDattorroReverb_tickStereo+0x334>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
   2b97a:	ee39 9a40 	vsub.f32	s18, s18, s0
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2b97e:	4628      	mov	r0, r5
   2b980:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b984:	f7f9 fc8c 	bl	252a0 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
   2b988:	eddf 7a3f 	vldr	s15, [pc, #252]	; 2ba88 <tDattorroReverb_tickStereo+0x338>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
   2b98c:	eef0 8a40 	vmov.f32	s17, s0
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
   2b990:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b994:	4628      	mov	r0, r5
   2b996:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b99a:	f7f9 fc81 	bl	252a0 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b99e:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
   2b9a2:	ee78 8a80 	vadd.f32	s17, s17, s0
   2b9a6:	4658      	mov	r0, fp
   2b9a8:	ee27 0a8a 	vmul.f32	s0, s15, s20
   2b9ac:	f7f9 fc78 	bl	252a0 <tTapeDelay_tapOut>
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2b9b0:	eddf 7a36 	vldr	s15, [pc, #216]	; 2ba8c <tDattorroReverb_tickStereo+0x33c>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
   2b9b4:	eeb0 aa40 	vmov.f32	s20, s0
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2b9b8:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2b9bc:	4638      	mov	r0, r7
   2b9be:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b9c2:	f7f9 fc6d 	bl	252a0 <tTapeDelay_tapOut>
   2b9c6:	ee30 8a28 	vadd.f32	s16, s0, s17
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2b9ca:	eddf 7a31 	vldr	s15, [pc, #196]	; 2ba90 <tDattorroReverb_tickStereo+0x340>
   2b9ce:	4630      	mov	r0, r6
   2b9d0:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
   2b9d4:	ee38 8a4a 	vsub.f32	s16, s16, s20
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2b9d8:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b9dc:	f7f9 fc60 	bl	252a0 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2b9e0:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b9e4:	eddf 7a2b 	vldr	s15, [pc, #172]	; 2ba94 <tDattorroReverb_tickStereo+0x344>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
   2b9e8:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2b9ec:	4648      	mov	r0, r9
   2b9ee:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b9f2:	f7f9 fc55 	bl	252a0 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2b9f6:	ed94 7a09 	vldr	s14, [r4, #36]	; 0x24
   2b9fa:	eddf 7a27 	vldr	s15, [pc, #156]	; 2ba98 <tDattorroReverb_tickStereo+0x348>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
   2b9fe:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2ba02:	4640      	mov	r0, r8
   2ba04:	ee27 0a27 	vmul.f32	s0, s14, s15
   2ba08:	f7f9 fc4a 	bl	252a0 <tTapeDelay_tapOut>
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
   2ba0c:	ed94 6a05 	vldr	s12, [r4, #20]
   2ba10:	eddf 6a22 	vldr	s13, [pc, #136]	; 2ba9c <tDattorroReverb_tickStereo+0x34c>
   2ba14:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
   2ba18:	ee38 0a40 	vsub.f32	s0, s16, s0
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
   2ba1c:	ee66 7a26 	vmul.f32	s15, s12, s13
   2ba20:	ee37 6a46 	vsub.f32	s12, s14, s12
   2ba24:	ee27 9a89 	vmul.f32	s18, s15, s18
   2ba28:	eea6 9a29 	vfma.f32	s18, s12, s19
   2ba2c:	ed8a 9a00 	vstr	s18, [sl]
    output[1] = input * (1.0f - r->mix) + f2_sample * r->mix;
   2ba30:	edd4 7a05 	vldr	s15, [r4, #20]
   2ba34:	ee67 6aa6 	vmul.f32	s13, s15, s13
   2ba38:	ee37 7a67 	vsub.f32	s14, s14, s15
   2ba3c:	ee20 0a26 	vmul.f32	s0, s0, s13
   2ba40:	eea7 0a29 	vfma.f32	s0, s14, s19
   2ba44:	ed8a 0a01 	vstr	s0, [sl, #4]
}
   2ba48:	ecbd 8b06 	vpop	{d8-d10}
   2ba4c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			f1_sample = 0.0f;
   2ba50:	ed9f 0a02 	vldr	s0, [pc, #8]	; 2ba5c <tDattorroReverb_tickStereo+0x30c>
   2ba54:	e6ea      	b.n	2b82c <tDattorroReverb_tickStereo+0xdc>
		f2_sample *= r->feedback_gain;
   2ba56:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ba5a:	e736      	b.n	2b8ca <tDattorroReverb_tickStereo+0x17a>
   2ba5c:	00000000 	.word	0x00000000
   2ba60:	41f4147b 	.word	0x41f4147b
   2ba64:	41b4a3d7 	.word	0x41b4a3d7
   2ba68:	40c9999a 	.word	0x40c9999a
   2ba6c:	410e6666 	.word	0x410e6666
   2ba70:	42c7999a 	.word	0x42c7999a
   2ba74:	42806666 	.word	0x42806666
   2ba78:	42860000 	.word	0x42860000
   2ba7c:	4285999a 	.word	0x4285999a
   2ba80:	420f3333 	.word	0x420f3333
   2ba84:	413ccccd 	.word	0x413ccccd
   2ba88:	42f36666 	.word	0x42f36666
   2ba8c:	42b36666 	.word	0x42b36666
   2ba90:	428d999a 	.word	0x428d999a
   2ba94:	41333333 	.word	0x41333333
   2ba98:	40833333 	.word	0x40833333
   2ba9c:	3e0f5c29 	.word	0x3e0f5c29

0002baa0 <tDattorroReverb_setMix>:
{
   2baa0:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2baa2:	6804      	ldr	r4, [r0, #0]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
   2baa4:	eef0 0a40 	vmov.f32	s1, s0
   2baa8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
   2baac:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2babc <tDattorroReverb_setMix+0x1c>
   2bab0:	f7fd feea 	bl	29888 <LEAF_clip>
   2bab4:	ed84 0a05 	vstr	s0, [r4, #20]
}
   2bab8:	bd10      	pop	{r4, pc}
   2baba:	bf00      	nop
   2babc:	00000000 	.word	0x00000000

0002bac0 <tDattorroReverb_setFreeze>:
{
   2bac0:	b570      	push	{r4, r5, r6, lr}
    _tDattorroReverb* r = *rev;
   2bac2:	6804      	ldr	r4, [r0, #0]
    r->frozen = freeze;
   2bac4:	61a1      	str	r1, [r4, #24]
   2bac6:	f104 006c 	add.w	r0, r4, #108	; 0x6c
   2baca:	f104 0650 	add.w	r6, r4, #80	; 0x50
   2bace:	f104 0568 	add.w	r5, r4, #104	; 0x68
   2bad2:	3484      	adds	r4, #132	; 0x84
    if (freeze)
   2bad4:	b9a1      	cbnz	r1, 2bb00 <tDattorroReverb_setFreeze+0x40>
    	tAllpass_setGain(&r->f2_allpass, 0.7f);
   2bad6:	ed9f 0a15 	vldr	s0, [pc, #84]	; 2bb2c <tDattorroReverb_setFreeze+0x6c>
   2bada:	f7fc faf7 	bl	280cc <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 0.7f);
   2bade:	4630      	mov	r0, r6
   2bae0:	ed9f 0a12 	vldr	s0, [pc, #72]	; 2bb2c <tDattorroReverb_setFreeze+0x6c>
   2bae4:	f7fc faf2 	bl	280cc <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.1f);
   2bae8:	4628      	mov	r0, r5
   2baea:	ed9f 0a11 	vldr	s0, [pc, #68]	; 2bb30 <tDattorroReverb_setFreeze+0x70>
   2baee:	f7fe fd7d 	bl	2a5ec <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
   2baf2:	4620      	mov	r0, r4
   2baf4:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 2bb34 <tDattorroReverb_setFreeze+0x74>
}
   2baf8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
   2bafc:	f7fe bd76 	b.w	2a5ec <tCycle_setFreq>
    	tAllpass_setGain(&r->f2_allpass, 1.0f);
   2bb00:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2bb04:	f7fc fae2 	bl	280cc <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 1.0f);
   2bb08:	4630      	mov	r0, r6
   2bb0a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2bb0e:	f7fc fadd 	bl	280cc <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.0f);
   2bb12:	4628      	mov	r0, r5
   2bb14:	ed9f 0a08 	vldr	s0, [pc, #32]	; 2bb38 <tDattorroReverb_setFreeze+0x78>
   2bb18:	f7fe fd68 	bl	2a5ec <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
   2bb1c:	4620      	mov	r0, r4
   2bb1e:	ed9f 0a06 	vldr	s0, [pc, #24]	; 2bb38 <tDattorroReverb_setFreeze+0x78>
}
   2bb22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
   2bb26:	f7fe bd61 	b.w	2a5ec <tCycle_setFreq>
   2bb2a:	bf00      	nop
   2bb2c:	3f333333 	.word	0x3f333333
   2bb30:	3dcccccd 	.word	0x3dcccccd
   2bb34:	3d8f5c29 	.word	0x3d8f5c29
   2bb38:	00000000 	.word	0x00000000

0002bb3c <tDattorroReverb_setHP>:
{
   2bb3c:	b510      	push	{r4, lr}
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2bb3e:	eef0 0a40 	vmov.f32	s1, s0
   2bb42:	ed9f 1a0c 	vldr	s2, [pc, #48]	; 2bb74 <tDattorroReverb_setHP+0x38>
   2bb46:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
{
   2bb4a:	ed2d 8b02 	vpush	{d8}
    _tDattorroReverb* r = *rev;
   2bb4e:	6804      	ldr	r4, [r0, #0]
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
   2bb50:	f7fd fe9a 	bl	29888 <LEAF_clip>
   2bb54:	eeb0 8a40 	vmov.f32	s16, s0
    tHighpass_setFreq(&r->f1_hp, newFreq);
   2bb58:	f104 0064 	add.w	r0, r4, #100	; 0x64
   2bb5c:	f7fc fd32 	bl	285c4 <tHighpass_setFreq>
    tHighpass_setFreq(&r->f2_hp, newFreq);
   2bb60:	f104 0080 	add.w	r0, r4, #128	; 0x80
   2bb64:	eeb0 0a48 	vmov.f32	s0, s16
}
   2bb68:	ecbd 8b02 	vpop	{d8}
   2bb6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tHighpass_setFreq(&r->f2_hp, newFreq);
   2bb70:	f7fc bd28 	b.w	285c4 <tHighpass_setFreq>
   2bb74:	469c4000 	.word	0x469c4000

0002bb78 <tDattorroReverb_setSize>:
{
   2bb78:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2bb7a:	6804      	ldr	r4, [r0, #0]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2bb7c:	ed94 1a08 	vldr	s2, [r4, #32]
   2bb80:	ee61 0a00 	vmul.f32	s1, s2, s0
   2bb84:	ed9f 0a26 	vldr	s0, [pc, #152]	; 2bc20 <tDattorroReverb_setSize+0xa8>
   2bb88:	f7fd fe7e 	bl	29888 <LEAF_clip>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2bb8c:	4b25      	ldr	r3, [pc, #148]	; (2bc24 <tDattorroReverb_setSize+0xac>)
   2bb8e:	eddf 6a26 	vldr	s13, [pc, #152]	; 2bc28 <tDattorroReverb_setSize+0xb0>
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2bb92:	f104 0054 	add.w	r0, r4, #84	; 0x54
    r->t = r->size * leaf.sampleRate * 0.001f;
   2bb96:	edd3 7a00 	vldr	s15, [r3]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
   2bb9a:	ed84 0a07 	vstr	s0, [r4, #28]
    r->t = r->size * leaf.sampleRate * 0.001f;
   2bb9e:	ee67 7aa6 	vmul.f32	s15, s15, s13
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2bba2:	ed9f 7a22 	vldr	s14, [pc, #136]	; 2bc2c <tDattorroReverb_setSize+0xb4>
    r->t = r->size * leaf.sampleRate * 0.001f;
   2bba6:	ee27 0a80 	vmul.f32	s0, s15, s0
   2bbaa:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
   2bbae:	ee20 0a07 	vmul.f32	s0, s0, s14
   2bbb2:	f7f9 fb65 	bl	25280 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_2, SAMP(89.24f));
   2bbb6:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2bbba:	eddf 7a1d 	vldr	s15, [pc, #116]	; 2bc30 <tDattorroReverb_setSize+0xb8>
   2bbbe:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2bbc2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2bbc6:	f7f9 fb5b 	bl	25280 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_3, SAMP(125.f));
   2bbca:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2bbce:	eddf 7a19 	vldr	s15, [pc, #100]	; 2bc34 <tDattorroReverb_setSize+0xbc>
   2bbd2:	f104 0060 	add.w	r0, r4, #96	; 0x60
   2bbd6:	ee20 0a27 	vmul.f32	s0, s0, s15
   2bbda:	f7f9 fb51 	bl	25280 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_1, SAMP(149.62f));
   2bbde:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2bbe2:	eddf 7a15 	vldr	s15, [pc, #84]	; 2bc38 <tDattorroReverb_setSize+0xc0>
   2bbe6:	f104 0070 	add.w	r0, r4, #112	; 0x70
   2bbea:	ee20 0a27 	vmul.f32	s0, s0, s15
   2bbee:	f7f9 fb47 	bl	25280 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_2, SAMP(60.48f));
   2bbf2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2bbf6:	eddf 7a11 	vldr	s15, [pc, #68]	; 2bc3c <tDattorroReverb_setSize+0xc4>
   2bbfa:	f104 0078 	add.w	r0, r4, #120	; 0x78
   2bbfe:	ee20 0a27 	vmul.f32	s0, s0, s15
   2bc02:	f7f9 fb3d 	bl	25280 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
   2bc06:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
   2bc0a:	eddf 7a0d 	vldr	s15, [pc, #52]	; 2bc40 <tDattorroReverb_setSize+0xc8>
   2bc0e:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   2bc12:	ee20 0a27 	vmul.f32	s0, s0, s15
}
   2bc16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
   2bc1a:	f7f9 bb31 	b.w	25280 <tTapeDelay_setDelay>
   2bc1e:	bf00      	nop
   2bc20:	3c23d70a 	.word	0x3c23d70a
   2bc24:	020fc0a8 	.word	0x020fc0a8
   2bc28:	3a83126f 	.word	0x3a83126f
   2bc2c:	430db0a4 	.word	0x430db0a4
   2bc30:	42b27ae1 	.word	0x42b27ae1
   2bc34:	42fa0000 	.word	0x42fa0000
   2bc38:	43159eb8 	.word	0x43159eb8
   2bc3c:	4271eb85 	.word	0x4271eb85
   2bc40:	42d48f5c 	.word	0x42d48f5c

0002bc44 <tDattorroReverb_setInputFilter>:
{
   2bc44:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2bc46:	6804      	ldr	r4, [r0, #0]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bc48:	eef0 0a40 	vmov.f32	s1, s0
   2bc4c:	ed9f 1a06 	vldr	s2, [pc, #24]	; 2bc68 <tDattorroReverb_setInputFilter+0x24>
   2bc50:	ed9f 0a06 	vldr	s0, [pc, #24]	; 2bc6c <tDattorroReverb_setInputFilter+0x28>
   2bc54:	f7fd fe18 	bl	29888 <LEAF_clip>
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2bc58:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bc5c:	ed84 0a02 	vstr	s0, [r4, #8]
}
   2bc60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->in_filter, r->input_filter);
   2bc64:	f7fc ba8a 	b.w	2817c <tOnePole_setFreq>
   2bc68:	469c4000 	.word	0x469c4000
   2bc6c:	00000000 	.word	0x00000000

0002bc70 <tDattorroReverb_setFeedbackFilter>:
{
   2bc70:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
   2bc72:	6804      	ldr	r4, [r0, #0]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bc74:	eef0 0a40 	vmov.f32	s1, s0
   2bc78:	ed9f 1a09 	vldr	s2, [pc, #36]	; 2bca0 <tDattorroReverb_setFeedbackFilter+0x30>
   2bc7c:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2bca4 <tDattorroReverb_setFeedbackFilter+0x34>
   2bc80:	f7fd fe02 	bl	29888 <LEAF_clip>
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2bc84:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
   2bc88:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
   2bc8c:	f7fc fa76 	bl	2817c <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2bc90:	ed94 0a03 	vldr	s0, [r4, #12]
   2bc94:	f104 0074 	add.w	r0, r4, #116	; 0x74
}
   2bc98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
   2bc9c:	f7fc ba6e 	b.w	2817c <tOnePole_setFreq>
   2bca0:	469c4000 	.word	0x469c4000
   2bca4:	00000000 	.word	0x00000000

0002bca8 <tDattorroReverb_setFeedbackGain>:
    _tDattorroReverb* r = *rev;
   2bca8:	6803      	ldr	r3, [r0, #0]
    r->feedback_gain = gain;
   2bcaa:	ed83 0a04 	vstr	s0, [r3, #16]
}
   2bcae:	4770      	bx	lr

0002bcb0 <tBuffer_initToPool>:
{
    tBuffer_initToPool(sb, length, &leaf.mempool);
}

void  tBuffer_initToPool (tBuffer* const sb, uint32_t length, tMempool* const mp)
{
   2bcb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
   2bcb2:	6815      	ldr	r5, [r2, #0]
{
   2bcb4:	460e      	mov	r6, r1
   2bcb6:	4607      	mov	r7, r0
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
   2bcb8:	201c      	movs	r0, #28
   2bcba:	4629      	mov	r1, r5
   2bcbc:	f7fd ffe4 	bl	29c88 <mpool_alloc>
   2bcc0:	4604      	mov	r4, r0
    s->mempool = m;
    
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2bcc2:	4629      	mov	r1, r5
   2bcc4:	00b0      	lsls	r0, r6, #2
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
   2bcc6:	603c      	str	r4, [r7, #0]
    s->mempool = m;
   2bcc8:	6025      	str	r5, [r4, #0]
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2bcca:	f7fd ffdd 	bl	29c88 <mpool_alloc>
    
    s->bufferLength = length;
    s->recordedLength = 0;
   2bcce:	2300      	movs	r3, #0
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
   2bcd0:	6060      	str	r0, [r4, #4]
    s->active = 0;
   2bcd2:	61a3      	str	r3, [r4, #24]
    s->idx = 0;
   2bcd4:	60a3      	str	r3, [r4, #8]
    s->mode = RecordOneShot;
   2bcd6:	7523      	strb	r3, [r4, #20]
    s->recordedLength = 0;
   2bcd8:	e9c4 6303 	strd	r6, r3, [r4, #12]
}
   2bcdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2bcde:	bf00      	nop

0002bce0 <tBuffer_free>:

void  tBuffer_free (tBuffer* const sb)
{
   2bce0:	b510      	push	{r4, lr}
    _tBuffer* s = *sb;
   2bce2:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)s->buff, s->mempool);
   2bce4:	e9d4 1000 	ldrd	r1, r0, [r4]
   2bce8:	f7fe f876 	bl	29dd8 <mpool_free>
    mpool_free((char*)s, s->mempool);
   2bcec:	6821      	ldr	r1, [r4, #0]
   2bcee:	4620      	mov	r0, r4
}
   2bcf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)s, s->mempool);
   2bcf4:	f7fe b870 	b.w	29dd8 <mpool_free>

0002bcf8 <tBuffer_tick>:

void tBuffer_tick (tBuffer* const sb, float sample)
{
    _tBuffer* s = *sb;
   2bcf8:	6803      	ldr	r3, [r0, #0]
    
    if (s->active == 1)
   2bcfa:	699a      	ldr	r2, [r3, #24]
   2bcfc:	2a01      	cmp	r2, #1
   2bcfe:	d000      	beq.n	2bd02 <tBuffer_tick+0xa>
                s->idx = 0;
            }
        }
        s->recordedLength = s->idx;
    }
}
   2bd00:	4770      	bx	lr
        s->buff[s->idx] = sample;
   2bd02:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   2bd06:	eb02 0281 	add.w	r2, r2, r1, lsl #2
   2bd0a:	ed82 0a00 	vstr	s0, [r2]
        if (s->idx >= s->bufferLength)
   2bd0e:	e9d3 2102 	ldrd	r2, r1, [r3, #8]
        s->idx += 1;
   2bd12:	3201      	adds	r2, #1
        if (s->idx >= s->bufferLength)
   2bd14:	428a      	cmp	r2, r1
        s->idx += 1;
   2bd16:	609a      	str	r2, [r3, #8]
        if (s->idx >= s->bufferLength)
   2bd18:	d304      	bcc.n	2bd24 <tBuffer_tick+0x2c>
            if (s->mode == RecordOneShot)
   2bd1a:	7d19      	ldrb	r1, [r3, #20]
   2bd1c:	b921      	cbnz	r1, 2bd28 <tBuffer_tick+0x30>
    s->idx = 0;
}

void  tBuffer_stop(tBuffer* const sb)
{
    _tBuffer* s = *sb;
   2bd1e:	6802      	ldr	r2, [r0, #0]
    s->active = 0;
   2bd20:	6191      	str	r1, [r2, #24]
   2bd22:	689a      	ldr	r2, [r3, #8]
        s->recordedLength = s->idx;
   2bd24:	611a      	str	r2, [r3, #16]
}
   2bd26:	4770      	bx	lr
            else if (s->mode == RecordLoop)
   2bd28:	2901      	cmp	r1, #1
   2bd2a:	d1fb      	bne.n	2bd24 <tBuffer_tick+0x2c>
                s->idx = 0;
   2bd2c:	2100      	movs	r1, #0
   2bd2e:	460a      	mov	r2, r1
   2bd30:	6099      	str	r1, [r3, #8]
   2bd32:	e7f7      	b.n	2bd24 <tBuffer_tick+0x2c>

0002bd34 <tBuffer_get>:
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2bd34:	2900      	cmp	r1, #0
   2bd36:	db09      	blt.n	2bd4c <tBuffer_get+0x18>
    _tBuffer* s = *sb;
   2bd38:	6803      	ldr	r3, [r0, #0]
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2bd3a:	68da      	ldr	r2, [r3, #12]
   2bd3c:	428a      	cmp	r2, r1
   2bd3e:	d905      	bls.n	2bd4c <tBuffer_get+0x18>
    return s->buff[idx];
   2bd40:	685b      	ldr	r3, [r3, #4]
   2bd42:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2bd46:	ed91 0a00 	vldr	s0, [r1]
   2bd4a:	4770      	bx	lr
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
   2bd4c:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2bd54 <tBuffer_get+0x20>
}
   2bd50:	4770      	bx	lr
   2bd52:	bf00      	nop
   2bd54:	00000000 	.word	0x00000000

0002bd58 <tBuffer_record>:
    _tBuffer* s = *sb;
   2bd58:	6803      	ldr	r3, [r0, #0]
    s->active = 1;
   2bd5a:	2101      	movs	r1, #1
    s->idx = 0;
   2bd5c:	2200      	movs	r2, #0
    s->active = 1;
   2bd5e:	6199      	str	r1, [r3, #24]
    s->idx = 0;
   2bd60:	609a      	str	r2, [r3, #8]
}
   2bd62:	4770      	bx	lr

0002bd64 <tBuffer_stop>:
    _tBuffer* s = *sb;
   2bd64:	6803      	ldr	r3, [r0, #0]
    s->active = 0;
   2bd66:	2200      	movs	r2, #0
   2bd68:	619a      	str	r2, [r3, #24]
}
   2bd6a:	4770      	bx	lr

0002bd6c <tBuffer_getRecordPosition>:

int   tBuffer_getRecordPosition(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->idx;
   2bd6c:	6803      	ldr	r3, [r0, #0]
}
   2bd6e:	6898      	ldr	r0, [r3, #8]
   2bd70:	4770      	bx	lr
   2bd72:	bf00      	nop

0002bd74 <tBuffer_setRecordPosition>:

void   tBuffer_setRecordPosition(tBuffer* const sb, int pos)
{
    _tBuffer* s = *sb;
   2bd74:	6803      	ldr	r3, [r0, #0]
    s->idx = pos;
   2bd76:	6099      	str	r1, [r3, #8]
}
   2bd78:	4770      	bx	lr
   2bd7a:	bf00      	nop

0002bd7c <tBuffer_setRecordMode>:

void  tBuffer_setRecordMode (tBuffer* const sb, RecordMode mode)
{
    _tBuffer* s = *sb;
   2bd7c:	6803      	ldr	r3, [r0, #0]
    s->mode = mode;
   2bd7e:	7519      	strb	r1, [r3, #20]
}
   2bd80:	4770      	bx	lr
   2bd82:	bf00      	nop

0002bd84 <tBuffer_getRecordedLength>:
}

uint32_t tBuffer_getRecordedLength(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->recordedLength;
   2bd84:	6803      	ldr	r3, [r0, #0]
}
   2bd86:	6918      	ldr	r0, [r3, #16]
   2bd88:	4770      	bx	lr
   2bd8a:	bf00      	nop

0002bd8c <tBuffer_setRecordedLength>:

void tBuffer_setRecordedLength(tBuffer* const sb, int length)
{
    _tBuffer* s = *sb;
   2bd8c:	6803      	ldr	r3, [r0, #0]
    s->recordedLength = length;
   2bd8e:	6119      	str	r1, [r3, #16]
}
   2bd90:	4770      	bx	lr
   2bd92:	bf00      	nop

0002bd94 <tBuffer_isActive>:

int tBuffer_isActive(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->active;
   2bd94:	6803      	ldr	r3, [r0, #0]
}
   2bd96:	6998      	ldr	r0, [r3, #24]
   2bd98:	4770      	bx	lr
   2bd9a:	bf00      	nop

0002bd9c <tSampler_init>:
static void handleStartEndChange(tSampler* const sp);

static void attemptStartEndChange(tSampler* const sp);

void tSampler_init(tSampler* const sp, tBuffer* const b)
{
   2bd9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tSampler_initToPool(sp, b, &leaf.mempool);
}

void tSampler_initToPool(tSampler* const sp, tBuffer* const b, tMempool* const mp)
{
    _tMempool* m = *mp;
   2bda0:	4e23      	ldr	r6, [pc, #140]	; (2be30 <tSampler_init+0x94>)
{
   2bda2:	4681      	mov	r9, r0
   2bda4:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2bda6:	2054      	movs	r0, #84	; 0x54
    
    _tBuffer* s = *b;
    
    p->samp = s;
    
    p->active = 0;
   2bda8:	2500      	movs	r5, #0
{
   2bdaa:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2bdae:	f856 7f18 	ldr.w	r7, [r6, #24]!
    p->start = 0;
    p->end = 0;
    
    p->len = p->end - p->start;
    
    p->idx = 0.f;
   2bdb2:	ed9f 8a20 	vldr	s16, [pc, #128]	; 2be34 <tSampler_init+0x98>
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2bdb6:	4639      	mov	r1, r7
   2bdb8:	f7fd ff66 	bl	29c88 <mpool_alloc>
   2bdbc:	4604      	mov	r4, r0
   2bdbe:	f8c9 0000 	str.w	r0, [r9]
    
    p->mode = PlayNormal;
    
    p->cfxlen = 500; // default 300 sample crossfade
    
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bdc2:	4632      	mov	r2, r6
    p->mempool = m;
   2bdc4:	6007      	str	r7, [r0, #0]
    p->inc = 1.f;
   2bdc6:	f04f 5e7e 	mov.w	lr, #1065353216	; 0x3f800000
    _tBuffer* s = *b;
   2bdca:	f8d8 3000 	ldr.w	r3, [r8]
    p->iinc = 1.f;
   2bdce:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
   2bdd2:	f240 1001 	movw	r0, #257	; 0x101
    p->cfxlen = 500; // default 300 sample crossfade
   2bdd6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bdda:	f104 0608 	add.w	r6, r4, #8
    p->samp = s;
   2bdde:	6063      	str	r3, [r4, #4]
    p->flip = 1;
   2bde0:	2301      	movs	r3, #1
    p->inc = 1.f;
   2bde2:	f8c4 e010 	str.w	lr, [r4, #16]
    p->iinc = 1.f;
   2bde6:	f8c4 c018 	str.w	ip, [r4, #24]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bdea:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->flip = 1;
   2bdee:	77a3      	strb	r3, [r4, #30]
    p->iinc = 1.f;
   2bdf0:	83a0      	strh	r0, [r4, #28]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bdf2:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
   2bdf4:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bdf6:	4619      	mov	r1, r3
    p->idx = 0.f;
   2bdf8:	ed84 8a03 	vstr	s16, [r4, #12]
    p->active = 0;
   2bdfc:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
   2bdfe:	6225      	str	r5, [r4, #32]
    p->end = 0;
   2be00:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
   2be02:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
   2be04:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2be08:	f7fb ffc4 	bl	27d94 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
   2be0c:	eeb0 0a48 	vmov.f32	s0, s16
   2be10:	4630      	mov	r0, r6
   2be12:	f7fc f805 	bl	27e20 <tRamp_setVal>
    
    p->targetstart = -1;
    p->targetend = -1;
    
    p->inCrossfade = 0;
    p->flipStart = -1;
   2be16:	4b08      	ldr	r3, [pc, #32]	; (2be38 <tSampler_init+0x9c>)
    p->targetstart = -1;
   2be18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
   2be1c:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
   2be20:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->targetstart = -1;
   2be22:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
   2be24:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipIdx = -1;
   2be26:	6523      	str	r3, [r4, #80]	; 0x50
}
   2be28:	ecbd 8b02 	vpop	{d8}
   2be2c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2be30:	020fc0a8 	.word	0x020fc0a8
   2be34:	00000000 	.word	0x00000000
   2be38:	bf800000 	.word	0xbf800000

0002be3c <tSampler_initToPool>:
{
   2be3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2be40:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
   2be44:	6816      	ldr	r6, [r2, #0]
{
   2be46:	4681      	mov	r9, r0
   2be48:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2be4a:	2054      	movs	r0, #84	; 0x54
   2be4c:	4631      	mov	r1, r6
{
   2be4e:	4617      	mov	r7, r2
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
   2be50:	f7fd ff1a 	bl	29c88 <mpool_alloc>
   2be54:	4604      	mov	r4, r0
   2be56:	f8c9 0000 	str.w	r0, [r9]
    p->active = 0;
   2be5a:	2500      	movs	r5, #0
    p->mempool = m;
   2be5c:	6006      	str	r6, [r0, #0]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2be5e:	463a      	mov	r2, r7
    _tBuffer* s = *b;
   2be60:	f8d8 3000 	ldr.w	r3, [r8]
    p->inc = 1.f;
   2be64:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
    p->idx = 0.f;
   2be68:	ed9f 8a18 	vldr	s16, [pc, #96]	; 2becc <tSampler_initToPool+0x90>
    p->iinc = 1.f;
   2be6c:	f240 1001 	movw	r0, #257	; 0x101
    p->cfxlen = 500; // default 300 sample crossfade
   2be70:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2be74:	f104 0608 	add.w	r6, r4, #8
    p->samp = s;
   2be78:	6063      	str	r3, [r4, #4]
    p->iinc = 1.f;
   2be7a:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
    p->flip = 1;
   2be7e:	2301      	movs	r3, #1
    p->inc = 1.f;
   2be80:	f8c4 c010 	str.w	ip, [r4, #16]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2be84:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->iinc = 1.f;
   2be88:	83a0      	strh	r0, [r4, #28]
    p->flip = 1;
   2be8a:	77a3      	strb	r3, [r4, #30]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2be8c:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
   2be8e:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2be90:	4619      	mov	r1, r3
    p->idx = 0.f;
   2be92:	ed84 8a03 	vstr	s16, [r4, #12]
    p->iinc = 1.f;
   2be96:	61a7      	str	r7, [r4, #24]
    p->active = 0;
   2be98:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
   2be9a:	6225      	str	r5, [r4, #32]
    p->end = 0;
   2be9c:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
   2be9e:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
   2bea0:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
   2bea4:	f7fb ff76 	bl	27d94 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
   2bea8:	eeb0 0a48 	vmov.f32	s0, s16
   2beac:	4630      	mov	r0, r6
   2beae:	f7fb ffb7 	bl	27e20 <tRamp_setVal>
    p->flipStart = -1;
   2beb2:	4b07      	ldr	r3, [pc, #28]	; (2bed0 <tSampler_initToPool+0x94>)
    p->targetstart = -1;
   2beb4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
   2beb8:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
   2bebc:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->targetstart = -1;
   2bebe:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
   2bec0:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipIdx = -1;
   2bec2:	6523      	str	r3, [r4, #80]	; 0x50
}
   2bec4:	ecbd 8b02 	vpop	{d8}
   2bec8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2becc:	00000000 	.word	0x00000000
   2bed0:	bf800000 	.word	0xbf800000

0002bed4 <tSampler_free>:

void tSampler_free (tSampler* const sp)
{
   2bed4:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2bed6:	6804      	ldr	r4, [r0, #0]
    tRamp_free(&p->gain);
   2bed8:	f104 0008 	add.w	r0, r4, #8
   2bedc:	f7fb ff8e 	bl	27dfc <tRamp_free>
    
    mpool_free((char*)p, p->mempool);
   2bee0:	6821      	ldr	r1, [r4, #0]
   2bee2:	4620      	mov	r0, r4
}
   2bee4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
   2bee8:	f7fd bf76 	b.w	29dd8 <mpool_free>

0002beec <tSampler_setMode>:
    return p->last;
}

void tSampler_setMode      (tSampler* const sp, PlayMode mode)
{
    _tSampler* p = *sp;
   2beec:	6803      	ldr	r3, [r0, #0]
    p->mode = mode;
   2beee:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
}
   2bef2:	4770      	bx	lr

0002bef4 <tSampler_setCrossfadeLength>:

void tSampler_setCrossfadeLength  (tSampler* const sp, uint32_t length)
{
   2bef4:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2bef6:	6804      	ldr	r4, [r0, #0]
    
    uint32_t cfxlen = LEAF_clip(0, length, p->len * 0.25f);
   2bef8:	ee07 1a90 	vmov	s15, r1
   2befc:	ed9f 0a07 	vldr	s0, [pc, #28]	; 2bf1c <tSampler_setCrossfadeLength+0x28>
   2bf00:	ed94 1a0c 	vldr	s2, [r4, #48]	; 0x30
   2bf04:	eef8 0a67 	vcvt.f32.u32	s1, s15
   2bf08:	eebb 1acf 	vcvt.f32.u32	s2, s2, #2
   2bf0c:	f7fd fcbc 	bl	29888 <LEAF_clip>
   2bf10:	eebc 0ac0 	vcvt.u32.f32	s0, s0
   2bf14:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    
    p->cfxlen = cfxlen;
}
   2bf18:	bd10      	pop	{r4, pc}
   2bf1a:	bf00      	nop
   2bf1c:	00000000 	.word	0x00000000

0002bf20 <tSampler_play>:

void tSampler_play         (tSampler* const sp)
{
   2bf20:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
   2bf22:	6804      	ldr	r4, [r0, #0]
    
    if (p->active != 0)
   2bf24:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2bf26:	f104 0008 	add.w	r0, r4, #8
   2bf2a:	bb93      	cbnz	r3, 2bf92 <tSampler_play+0x72>
        
        tRamp_setDest(&p->gain, 0.f);
    }
    else
    {
        p->active = 1;
   2bf2c:	2201      	movs	r2, #1
        p->retrigger = 0;
   2bf2e:	6423      	str	r3, [r4, #64]	; 0x40
        
        tRamp_setDest(&p->gain, 1.f);
   2bf30:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        p->active = 1;
   2bf34:	6462      	str	r2, [r4, #68]	; 0x44
        tRamp_setDest(&p->gain, 1.f);
   2bf36:	f7fb ff65 	bl	27e04 <tRamp_setDest>
        
        if (p->dir > 0)
   2bf3a:	f994 301c 	ldrsb.w	r3, [r4, #28]
   2bf3e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   2bf40:	2b00      	cmp	r3, #0
   2bf42:	6a22      	ldr	r2, [r4, #32]
        {
            if (p->flip > 0)    p->idx = p->start;
   2bf44:	f994 301d 	ldrsb.w	r3, [r4, #29]
        if (p->dir > 0)
   2bf48:	dd2e      	ble.n	2bfa8 <tSampler_play+0x88>
            if (p->flip > 0)    p->idx = p->start;
   2bf4a:	2b00      	cmp	r3, #0
   2bf4c:	dd2e      	ble.n	2bfac <tSampler_play+0x8c>
            else                p->idx = p->end;
        }
        else
        {
            if (p->flip > 0)    p->idx = p->end;
            else                p->idx = p->start;
   2bf4e:	ee07 2a90 	vmov	s15, r2
   2bf52:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2bf56:	edc4 7a03 	vstr	s15, [r4, #12]

static void handleStartEndChange(tSampler* const sp)
{
    _tSampler* p = *sp;
    
    p->len = abs(p->end - p->start);
   2bf5a:	1a8b      	subs	r3, r1, r2
    
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf5c:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2bf60:	2b00      	cmp	r3, #0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf62:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2bf66:	bfb8      	it	lt
   2bf68:	425b      	neglt	r3, r3
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf6a:	ee07 3a10 	vmov	s14, r3
    p->len = abs(p->end - p->start);
   2bf6e:	6323      	str	r3, [r4, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2bf70:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2bf74:	eef4 7ac7 	vcmpe.f32	s15, s14
   2bf78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2bf7c:	dd03      	ble.n	2bf86 <tSampler_play+0x66>
   2bf7e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2bf82:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
    
    if (p->start > p->end)
   2bf86:	4291      	cmp	r1, r2
    {
        p->flip = -1;
   2bf88:	bfb4      	ite	lt
   2bf8a:	23ff      	movlt	r3, #255	; 0xff
    }
    else
    {
        p->flip = 1;
   2bf8c:	2301      	movge	r3, #1
   2bf8e:	7763      	strb	r3, [r4, #29]
}
   2bf90:	bd10      	pop	{r4, pc}
        p->active = -1;
   2bf92:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        p->retrigger = 1;
   2bf96:	2301      	movs	r3, #1
        tRamp_setDest(&p->gain, 0.f);
   2bf98:	ed9f 0a08 	vldr	s0, [pc, #32]	; 2bfbc <tSampler_play+0x9c>
        p->retrigger = 1;
   2bf9c:	e9c4 3210 	strd	r3, r2, [r4, #64]	; 0x40
}
   2bfa0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        tRamp_setDest(&p->gain, 0.f);
   2bfa4:	f7fb bf2e 	b.w	27e04 <tRamp_setDest>
            if (p->flip > 0)    p->idx = p->end;
   2bfa8:	2b00      	cmp	r3, #0
   2bfaa:	ddd0      	ble.n	2bf4e <tSampler_play+0x2e>
   2bfac:	ee07 1a90 	vmov	s15, r1
   2bfb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2bfb4:	edc4 7a03 	vstr	s15, [r4, #12]
   2bfb8:	e7cf      	b.n	2bf5a <tSampler_play+0x3a>
   2bfba:	bf00      	nop
   2bfbc:	00000000 	.word	0x00000000

0002bfc0 <tSampler_stop>:
    _tSampler* p = *sp;
   2bfc0:	6800      	ldr	r0, [r0, #0]
    p->active = -1;
   2bfc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    tRamp_setDest(&p->gain, 0.f);
   2bfc6:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2bfd4 <tSampler_stop+0x14>
    p->active = -1;
   2bfca:	6443      	str	r3, [r0, #68]	; 0x44
    tRamp_setDest(&p->gain, 0.f);
   2bfcc:	3008      	adds	r0, #8
   2bfce:	f7fb bf19 	b.w	27e04 <tRamp_setDest>
   2bfd2:	bf00      	nop
   2bfd4:	00000000 	.word	0x00000000

0002bfd8 <tSampler_setStart>:
        tSampler_setEnd(sp, p->targetend);
    }
}

void tSampler_setStart     (tSampler* const sp, int32_t start)
{
   2bfd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2bfda:	6804      	ldr	r4, [r0, #0]
    if (start == p->end)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
   2bfdc:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2bfde:	2b00      	cmp	r3, #0
   2bfe0:	d042      	beq.n	2c068 <tSampler_setStart+0x90>
    {
        if (start > p->end)
   2bfe2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   2bfe4:	428b      	cmp	r3, r1
   2bfe6:	db1d      	blt.n	2c024 <tSampler_setStart+0x4c>
   2bfe8:	2501      	movs	r5, #1
   2bfea:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
   2bfec:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
   2bfee:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2bff2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2bff6:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
   2bffa:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2bffe:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2c002:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c006:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c00a:	bf48      	it	mi
   2c00c:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2c010:	b932      	cbnz	r2, 2c020 <tSampler_setStart+0x48>
   2c012:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2c016:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2c01a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c01e:	db06      	blt.n	2c02e <tSampler_setStart+0x56>
        }
    }
    
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetstart = -1;
   2c020:	6261      	str	r1, [r4, #36]	; 0x24
    
}
   2c022:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (start > p->end)
   2c024:	2701      	movs	r7, #1
   2c026:	2500      	movs	r5, #0
            tempflip = -1;
   2c028:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2c02c:	e7df      	b.n	2bfee <tSampler_setStart+0x16>
        int dir = p->bnf * p->dir * tempflip;
   2c02e:	f994 201e 	ldrsb.w	r2, [r4, #30]
   2c032:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2c036:	fb12 f20c 	smulbb	r2, r2, ip
   2c03a:	fb06 f202 	mul.w	r2, r6, r2
        if ((tempflip > 0) && (dir > 0)) // start is start and we're playing forward
   2c03e:	2a00      	cmp	r2, #0
   2c040:	dd3c      	ble.n	2c0bc <tSampler_setStart+0xe4>
   2c042:	2d00      	cmp	r5, #0
   2c044:	d03a      	beq.n	2c0bc <tSampler_setStart+0xe4>
            if (start > p->idx)// start given is after current index or we're in a crossfade
   2c046:	ee07 1a90 	vmov	s15, r1
   2c04a:	edd4 6a03 	vldr	s13, [r4, #12]
   2c04e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c052:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c056:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c05a:	dc3e      	bgt.n	2c0da <tSampler_setStart+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
   2c05c:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2c060:	42b3      	cmp	r3, r6
   2c062:	d001      	beq.n	2c068 <tSampler_setStart+0x90>
            p->flipIdx = 0;
   2c064:	2300      	movs	r3, #0
   2c066:	6523      	str	r3, [r4, #80]	; 0x50
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
   2c068:	6863      	ldr	r3, [r4, #4]
   2c06a:	4605      	mov	r5, r0
   2c06c:	2000      	movs	r0, #0
   2c06e:	691a      	ldr	r2, [r3, #16]
   2c070:	3a01      	subs	r2, #1
   2c072:	f7fd fc1d 	bl	298b0 <LEAF_clipInt>
   2c076:	6220      	str	r0, [r4, #32]
    handleStartEndChange(sp);
   2c078:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2c07a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2c07c:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c07e:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2c082:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c084:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2c088:	2900      	cmp	r1, #0
   2c08a:	bfb8      	it	lt
   2c08c:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c08e:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2c092:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c094:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2c098:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c09c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c0a0:	dd03      	ble.n	2c0aa <tSampler_setStart+0xd2>
   2c0a2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2c0a6:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2c0aa:	4282      	cmp	r2, r0
   2c0ac:	bfac      	ite	ge
   2c0ae:	2201      	movge	r2, #1
   2c0b0:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetstart = -1;
   2c0b4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2c0b8:	775a      	strb	r2, [r3, #29]
   2c0ba:	e7b1      	b.n	2c020 <tSampler_setStart+0x48>
        else if ((tempflip < 0) && (dir < 0)) // start is end and we're playing in reverse
   2c0bc:	2a00      	cmp	r2, #0
   2c0be:	dacd      	bge.n	2c05c <tSampler_setStart+0x84>
   2c0c0:	2f00      	cmp	r7, #0
   2c0c2:	d0cb      	beq.n	2c05c <tSampler_setStart+0x84>
            if (start < p->idx)// start given is before current index or we're in a crossfade
   2c0c4:	ee07 1a90 	vmov	s15, r1
   2c0c8:	edd4 6a03 	vldr	s13, [r4, #12]
   2c0cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c0d0:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c0d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c0d8:	d5c0      	bpl.n	2c05c <tSampler_setStart+0x84>
                float tempLen = abs(p->end - start) * 0.25f;
   2c0da:	1a5b      	subs	r3, r3, r1
                if (cfxlen > tempLen)
   2c0dc:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetstart = start;
   2c0e0:	6261      	str	r1, [r4, #36]	; 0x24
                float tempLen = abs(p->end - start) * 0.25f;
   2c0e2:	2b00      	cmp	r3, #0
   2c0e4:	bfb8      	it	lt
   2c0e6:	425b      	neglt	r3, r3
   2c0e8:	ee07 3a90 	vmov	s15, r3
   2c0ec:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2c0f0:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c0f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c0f8:	dd93      	ble.n	2c022 <tSampler_setStart+0x4a>
                    p->cfxlen = tempLen;
   2c0fa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2c0fe:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2c102:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002c104 <tSampler_setEnd>:

void tSampler_setEnd       (tSampler* const sp, int32_t end)
{
   2c104:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2c106:	6804      	ldr	r4, [r0, #0]
    if (end == p->start)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
   2c108:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2c10a:	2b00      	cmp	r3, #0
   2c10c:	d042      	beq.n	2c194 <tSampler_setEnd+0x90>
    {
        if (p->start > end)
   2c10e:	6a23      	ldr	r3, [r4, #32]
   2c110:	428b      	cmp	r3, r1
   2c112:	dc1d      	bgt.n	2c150 <tSampler_setEnd+0x4c>
   2c114:	2501      	movs	r5, #1
   2c116:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
   2c118:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
   2c11a:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c11e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c122:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
   2c126:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c12a:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2c12e:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c132:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c136:	bf48      	it	mi
   2c138:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2c13c:	b932      	cbnz	r2, 2c14c <tSampler_setEnd+0x48>
   2c13e:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2c142:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2c146:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c14a:	db06      	blt.n	2c15a <tSampler_setEnd+0x56>
        }
    }
    
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetend = -1;
   2c14c:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   2c14e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
   2c150:	2701      	movs	r7, #1
   2c152:	2500      	movs	r5, #0
            tempflip = -1;
   2c154:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2c158:	e7df      	b.n	2c11a <tSampler_setEnd+0x16>
        int dir = p->bnf * p->dir * tempflip;
   2c15a:	f994 201e 	ldrsb.w	r2, [r4, #30]
   2c15e:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2c162:	fb12 f20c 	smulbb	r2, r2, ip
   2c166:	fb06 f202 	mul.w	r2, r6, r2
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
   2c16a:	2a00      	cmp	r2, #0
   2c16c:	da3c      	bge.n	2c1e8 <tSampler_setEnd+0xe4>
   2c16e:	2d00      	cmp	r5, #0
   2c170:	d03a      	beq.n	2c1e8 <tSampler_setEnd+0xe4>
            if (end < p->idx) // end given is before current index or we're in a crossfade
   2c172:	ee07 1a90 	vmov	s15, r1
   2c176:	edd4 6a03 	vldr	s13, [r4, #12]
   2c17a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c17e:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c182:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c186:	d43e      	bmi.n	2c206 <tSampler_setEnd+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
   2c188:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2c18c:	42b3      	cmp	r3, r6
   2c18e:	d001      	beq.n	2c194 <tSampler_setEnd+0x90>
            p->flipIdx = 0;
   2c190:	2300      	movs	r3, #0
   2c192:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
   2c194:	6863      	ldr	r3, [r4, #4]
   2c196:	4605      	mov	r5, r0
   2c198:	2000      	movs	r0, #0
   2c19a:	691a      	ldr	r2, [r3, #16]
   2c19c:	3a01      	subs	r2, #1
   2c19e:	f7fd fb87 	bl	298b0 <LEAF_clipInt>
   2c1a2:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   2c1a4:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2c1a6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2c1a8:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c1aa:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2c1ae:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c1b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2c1b4:	2900      	cmp	r1, #0
   2c1b6:	bfb8      	it	lt
   2c1b8:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c1ba:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2c1be:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c1c0:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2c1c4:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c1c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c1cc:	dd03      	ble.n	2c1d6 <tSampler_setEnd+0xd2>
   2c1ce:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2c1d2:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2c1d6:	4282      	cmp	r2, r0
   2c1d8:	bfac      	ite	ge
   2c1da:	2201      	movge	r2, #1
   2c1dc:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
   2c1e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2c1e4:	775a      	strb	r2, [r3, #29]
   2c1e6:	e7b1      	b.n	2c14c <tSampler_setEnd+0x48>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
   2c1e8:	2a00      	cmp	r2, #0
   2c1ea:	ddcd      	ble.n	2c188 <tSampler_setEnd+0x84>
   2c1ec:	2f00      	cmp	r7, #0
   2c1ee:	d0cb      	beq.n	2c188 <tSampler_setEnd+0x84>
            if (end > p->idx) // end given is after current index or we're in a crossfade
   2c1f0:	ee07 1a90 	vmov	s15, r1
   2c1f4:	edd4 6a03 	vldr	s13, [r4, #12]
   2c1f8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c1fc:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c200:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c204:	ddc0      	ble.n	2c188 <tSampler_setEnd+0x84>
                float tempLen = abs(end - p->start) * 0.25f;
   2c206:	1acb      	subs	r3, r1, r3
                if (cfxlen > tempLen)
   2c208:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
   2c20c:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
   2c20e:	2b00      	cmp	r3, #0
   2c210:	bfb8      	it	lt
   2c212:	425b      	neglt	r3, r3
   2c214:	ee07 3a90 	vmov	s15, r3
   2c218:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2c21c:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c220:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c224:	dd93      	ble.n	2c14e <tSampler_setEnd+0x4a>
                    p->cfxlen = tempLen;
   2c226:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2c22a:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2c22e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002c230 <tSampler_tick>:
{
   2c230:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c234:	ed2d 8b04 	vpush	{d8-d9}
    _tSampler* p = *sp;
   2c238:	6804      	ldr	r4, [r0, #0]
{
   2c23a:	b087      	sub	sp, #28
   2c23c:	4605      	mov	r5, r0
    if (p->targetstart >= 0)
   2c23e:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2c240:	2900      	cmp	r1, #0
   2c242:	db01      	blt.n	2c248 <tSampler_tick+0x18>
        tSampler_setStart(sp, p->targetstart);
   2c244:	f7ff fec8 	bl	2bfd8 <tSampler_setStart>
    if (p->targetend >= 0)
   2c248:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   2c24a:	2900      	cmp	r1, #0
   2c24c:	db02      	blt.n	2c254 <tSampler_tick+0x24>
        tSampler_setEnd(sp, p->targetend);
   2c24e:	4628      	mov	r0, r5
   2c250:	f7ff ff58 	bl	2c104 <tSampler_setEnd>
    if (p->active == 0)         return 0.f;
   2c254:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2c256:	2b00      	cmp	r3, #0
   2c258:	f000 812f 	beq.w	2c4ba <tSampler_tick+0x28a>
    if ((p->inc == 0.0f) || (p->len < 2))
   2c25c:	edd4 7a04 	vldr	s15, [r4, #16]
   2c260:	eef5 7a40 	vcmp.f32	s15, #0.0
   2c264:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c268:	f000 811e 	beq.w	2c4a8 <tSampler_tick+0x278>
   2c26c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2c26e:	2b01      	cmp	r3, #1
   2c270:	f240 811a 	bls.w	2c4a8 <tSampler_tick+0x278>
    if (p->flip < 0)
   2c274:	f994 801d 	ldrsb.w	r8, [r4, #29]
    float* buff = p->samp->buff;
   2c278:	6862      	ldr	r2, [r4, #4]
    if (p->flip < 0)
   2c27a:	f1b8 0f00 	cmp.w	r8, #0
    int myStart = p->start;
   2c27e:	f8d4 a020 	ldr.w	sl, [r4, #32]
    float* buff = p->samp->buff;
   2c282:	6851      	ldr	r1, [r2, #4]
    int myEnd = p->end;
   2c284:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
    if (p->flip < 0)
   2c288:	db02      	blt.n	2c290 <tSampler_tick+0x60>
   2c28a:	464b      	mov	r3, r9
    int myStart = p->start;
   2c28c:	46d1      	mov	r9, sl
    int myEnd = p->end;
   2c28e:	469a      	mov	sl, r3
    int dir = p->bnf * p->dir * p->flip;
   2c290:	f994 001c 	ldrsb.w	r0, [r4, #28]
   2c294:	f994 301e 	ldrsb.w	r3, [r4, #30]
    int idx = (int) p->idx;
   2c298:	edd4 7a03 	vldr	s15, [r4, #12]
    int dir = p->bnf * p->dir * p->flip;
   2c29c:	fb13 f300 	smulbb	r3, r3, r0
    int length = p->samp->recordedLength;
   2c2a0:	f8d2 b010 	ldr.w	fp, [r2, #16]
    int idx = (int) p->idx;
   2c2a4:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c2a8:	9101      	str	r1, [sp, #4]
    int dir = p->bnf * p->dir * p->flip;
   2c2aa:	fb08 f803 	mul.w	r8, r8, r3
    idx += rev;
   2c2ae:	ee17 6a10 	vmov	r6, s14
    if (dir < 0) rev = 1;
   2c2b2:	ea4f 77d8 	mov.w	r7, r8, lsr #31
    float alpha = rev + (p->idx - idx) * dir;
   2c2b6:	eef8 6ac7 	vcvt.f32.s32	s13, s14
   2c2ba:	ee06 8a10 	vmov	s12, r8
    idx += rev;
   2c2be:	443e      	add	r6, r7
    float alpha = rev + (p->idx - idx) * dir;
   2c2c0:	ee07 7a10 	vmov	s14, r7
   2c2c4:	f1c7 0001 	rsb	r0, r7, #1
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2c2c8:	fb07 f70b 	mul.w	r7, r7, fp
    int i1 = idx-(1*dir);
   2c2cc:	eba6 0208 	sub.w	r2, r6, r8
    int i3 = idx+(1*dir);
   2c2d0:	eb08 0306 	add.w	r3, r8, r6
   2c2d4:	9003      	str	r0, [sp, #12]
    float alpha = rev + (p->idx - idx) * dir;
   2c2d6:	eef8 8ac7 	vcvt.f32.s32	s17, s14
   2c2da:	fb00 f00b 	mul.w	r0, r0, fp
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2c2de:	4297      	cmp	r7, r2
    float alpha = rev + (p->idx - idx) * dir;
   2c2e0:	ee77 7ae6 	vsub.f32	s15, s15, s13
    int i4 = idx+(2*dir);
   2c2e4:	eb08 0c03 	add.w	ip, r8, r3
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
   2c2e8:	bfcc      	ite	gt
   2c2ea:	1812      	addgt	r2, r2, r0
   2c2ec:	1bd2      	suble	r2, r2, r7
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
   2c2ee:	42b7      	cmp	r7, r6
    float alpha = rev + (p->idx - idx) * dir;
   2c2f0:	eeb8 9ac6 	vcvt.f32.s32	s18, s12
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c2f4:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   2c2f8:	9002      	str	r0, [sp, #8]
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
   2c2fa:	bfcc      	ite	gt
   2c2fc:	eb06 0e00 	addgt.w	lr, r6, r0
   2c300:	eba6 0e07 	suble.w	lr, r6, r7
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
   2c304:	4283      	cmp	r3, r0
    float alpha = rev + (p->idx - idx) * dir;
   2c306:	eee7 8a89 	vfma.f32	s17, s15, s18
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c30a:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
   2c30e:	ed92 0a00 	vldr	s0, [r2]
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
   2c312:	bfac      	ite	ge
   2c314:	1a1b      	subge	r3, r3, r0
   2c316:	19db      	addlt	r3, r3, r7
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
   2c318:	4584      	cmp	ip, r0
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c31a:	edde 0a00 	vldr	s1, [lr]
   2c31e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
   2c322:	bfac      	ite	ge
   2c324:	ebac 0c00 	subge.w	ip, ip, r0
   2c328:	44bc      	addlt	ip, r7
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c32a:	eeb0 2a68 	vmov.f32	s4, s17
   2c32e:	ed93 1a00 	vldr	s2, [r3]
   2c332:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
   2c336:	eddc 1a00 	vldr	s3, [ip]
   2c33a:	f7fd fbbd 	bl	29ab8 <LEAF_interpolate_hermite_x>
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c33e:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    int32_t cfxlen = p->cfxlen;
   2c342:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c346:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
   2c34a:	eef8 0a47 	vcvt.f32.u32	s1, s14
   2c34e:	ee07 ca10 	vmov	s14, ip
    sample = LEAF_interpolate_hermite_x (buff[i1],
   2c352:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c356:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c35a:	ee60 7aa7 	vmul.f32	s15, s1, s15
   2c35e:	e9dd 1001 	ldrd	r1, r0, [sp, #4]
   2c362:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c366:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c36a:	d503      	bpl.n	2c374 <tSampler_tick+0x144>
   2c36c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2c370:	ee17 ca90 	vmov	ip, s15
    if (myStart >= cfxlen) fadeLeftStart = myStart - cfxlen;
   2c374:	45e1      	cmp	r9, ip
   2c376:	f2c0 80a9 	blt.w	2c4cc <tSampler_tick+0x29c>
   2c37a:	eba9 0e0c 	sub.w	lr, r9, ip
   2c37e:	f8cd 9004 	str.w	r9, [sp, #4]
    if (p->mode == PlayLoop)
   2c382:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
   2c386:	2a01      	cmp	r2, #1
   2c388:	f000 80ca 	beq.w	2c520 <tSampler_tick+0x2f0>
   2c38c:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
    float inc = fmodf(p->inc, (float)p->len);
   2c390:	ed94 0a04 	vldr	s0, [r4, #16]
   2c394:	f001 f988 	bl	2d6a8 <fmodf>
    p->idx += (dir * inc);
   2c398:	edd4 7a03 	vldr	s15, [r4, #12]
    if (p->flipStart >= 0)
   2c39c:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    p->idx += (dir * inc);
   2c3a0:	eee9 7a00 	vfma.f32	s15, s18, s0
    if (p->flipStart >= 0)
   2c3a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    p->idx += (dir * inc);
   2c3a8:	edc4 7a03 	vstr	s15, [r4, #12]
    if (p->flipStart >= 0)
   2c3ac:	db29      	blt.n	2c402 <tSampler_tick+0x1d2>
        p->flipIdx += (-dir * inc);
   2c3ae:	f1c8 0300 	rsb	r3, r8, #0
   2c3b2:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
   2c3b6:	ee07 3a10 	vmov	s14, r3
   2c3ba:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c3be:	eee7 6a00 	vfma.f32	s13, s14, s0
   2c3c2:	eeb0 7a66 	vmov.f32	s14, s13
        if((int)p->flipIdx < 0)
   2c3c6:	eefd 6ae6 	vcvt.s32.f32	s13, s13
        p->flipIdx += (-dir * inc);
   2c3ca:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
        if((int)p->flipIdx < 0)
   2c3ce:	ee16 3a90 	vmov	r3, s13
   2c3d2:	2b00      	cmp	r3, #0
   2c3d4:	da07      	bge.n	2c3e6 <tSampler_tick+0x1b6>
            p->idx += (float)length;
   2c3d6:	ee07 ba10 	vmov	s14, fp
   2c3da:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c3de:	ee77 7a87 	vadd.f32	s15, s15, s14
   2c3e2:	edc4 7a03 	vstr	s15, [r4, #12]
        if((int)p->idx >= length)
   2c3e6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2c3ea:	ee17 3a10 	vmov	r3, s14
   2c3ee:	455b      	cmp	r3, fp
   2c3f0:	db07      	blt.n	2c402 <tSampler_tick+0x1d2>
            p->idx -= (float)length;
   2c3f2:	ee07 ba10 	vmov	s14, fp
   2c3f6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c3fa:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2c3fe:	edc4 7a03 	vstr	s15, [r4, #12]
    _tSampler* p = *sp;
   2c402:	682f      	ldr	r7, [r5, #0]
    if (p->targetstart >= 0)
   2c404:	6a79      	ldr	r1, [r7, #36]	; 0x24
   2c406:	2900      	cmp	r1, #0
   2c408:	db02      	blt.n	2c410 <tSampler_tick+0x1e0>
        tSampler_setStart(sp, p->targetstart);
   2c40a:	4628      	mov	r0, r5
   2c40c:	f7ff fde4 	bl	2bfd8 <tSampler_setStart>
    if (p->targetend >= 0)
   2c410:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2c412:	2900      	cmp	r1, #0
   2c414:	db02      	blt.n	2c41c <tSampler_tick+0x1ec>
        tSampler_setEnd(sp, p->targetend);
   2c416:	4628      	mov	r0, r5
   2c418:	f7ff fe74 	bl	2c104 <tSampler_setEnd>
    if (p->mode == PlayLoop)
   2c41c:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   2c420:	f104 0508 	add.w	r5, r4, #8
   2c424:	2b01      	cmp	r3, #1
   2c426:	d056      	beq.n	2c4d6 <tSampler_tick+0x2a6>
    else if (p->mode == PlayBackAndForth)
   2c428:	2b02      	cmp	r3, #2
   2c42a:	f000 8100 	beq.w	2c62e <tSampler_tick+0x3fe>
    if (p->mode == PlayNormal)
   2c42e:	bb4b      	cbnz	r3, 2c484 <tSampler_tick+0x254>
    	if (p->idx < myStart)
   2c430:	ee07 9a90 	vmov	s15, r9
   2c434:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2c438:	edd4 7a03 	vldr	s15, [r4, #12]
   2c43c:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c440:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c444:	f140 80d8 	bpl.w	2c5f8 <tSampler_tick+0x3c8>
    		p->idx = myEnd;
   2c448:	ed84 7a03 	vstr	s14, [r4, #12]
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2c44c:	f1b8 0f00 	cmp.w	r8, #0
   2c450:	ed94 7a06 	vldr	s14, [r4, #24]
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2c454:	eddf 6add 	vldr	s13, [pc, #884]	; 2c7cc <tSampler_tick+0x59c>
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2c458:	bfb4      	ite	lt
   2c45a:	eba6 0309 	sublt.w	r3, r6, r9
   2c45e:	ebaa 0306 	subge.w	r3, sl, r6
   2c462:	ee07 3a90 	vmov	s15, r3
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2c466:	4bda      	ldr	r3, [pc, #872]	; (2c7d0 <tSampler_tick+0x5a0>)
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
   2c468:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c46c:	ee67 7a87 	vmul.f32	s15, s15, s14
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
   2c470:	ed93 7a00 	vldr	s14, [r3]
   2c474:	ee27 7a26 	vmul.f32	s14, s14, s13
   2c478:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c47c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c480:	f300 8159 	bgt.w	2c736 <tSampler_tick+0x506>
    sample = sample * tRamp_tick(&p->gain);
   2c484:	4628      	mov	r0, r5
   2c486:	f7fb fcd9 	bl	27e3c <tRamp_tick>
    if (p->active < 0)
   2c48a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
   2c48c:	ee20 8a08 	vmul.f32	s16, s0, s16
    if (p->active < 0)
   2c490:	2b00      	cmp	r3, #0
   2c492:	f2c0 80e4 	blt.w	2c65e <tSampler_tick+0x42e>
}
   2c496:	eeb0 0a48 	vmov.f32	s0, s16
    p->last = sample;
   2c49a:	ed84 8a05 	vstr	s16, [r4, #20]
}
   2c49e:	b007      	add	sp, #28
   2c4a0:	ecbd 8b04 	vpop	{d8-d9}
   2c4a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return p->last;
   2c4a8:	ed94 8a05 	vldr	s16, [r4, #20]
}
   2c4ac:	eeb0 0a48 	vmov.f32	s0, s16
   2c4b0:	b007      	add	sp, #28
   2c4b2:	ecbd 8b04 	vpop	{d8-d9}
   2c4b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p->active == 0)         return 0.f;
   2c4ba:	ed9f 8ac6 	vldr	s16, [pc, #792]	; 2c7d4 <tSampler_tick+0x5a4>
}
   2c4be:	eeb0 0a48 	vmov.f32	s0, s16
   2c4c2:	b007      	add	sp, #28
   2c4c4:	ecbd 8b04 	vpop	{d8-d9}
   2c4c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c4cc:	f8cd c004 	str.w	ip, [sp, #4]
    int32_t fadeLeftStart = 0;
   2c4d0:	f04f 0e00 	mov.w	lr, #0
   2c4d4:	e755      	b.n	2c382 <tSampler_tick+0x152>
        if((int)p->idx < myStart)
   2c4d6:	edd4 7a03 	vldr	s15, [r4, #12]
   2c4da:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2c4de:	ee17 3a10 	vmov	r3, s14
   2c4e2:	454b      	cmp	r3, r9
   2c4e4:	da0e      	bge.n	2c504 <tSampler_tick+0x2d4>
            p->idx += (float)(fadeRightEnd - fadeLeftEnd);
   2c4e6:	9b01      	ldr	r3, [sp, #4]
   2c4e8:	ebaa 0303 	sub.w	r3, sl, r3
   2c4ec:	ee07 3a10 	vmov	s14, r3
   2c4f0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c4f4:	ee77 7a87 	vadd.f32	s15, s15, s14
   2c4f8:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2c4fc:	edc4 7a03 	vstr	s15, [r4, #12]
   2c500:	ee17 3a10 	vmov	r3, s14
        if((int)p->idx > myEnd)
   2c504:	459a      	cmp	sl, r3
   2c506:	dabd      	bge.n	2c484 <tSampler_tick+0x254>
            p->idx -= (float)(fadeRightEnd - fadeLeftEnd);
   2c508:	9b01      	ldr	r3, [sp, #4]
   2c50a:	ebaa 0a03 	sub.w	sl, sl, r3
   2c50e:	ee07 aa10 	vmov	s14, sl
   2c512:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c516:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2c51a:	edc4 7a03 	vstr	s15, [r4, #12]
   2c51e:	e7b1      	b.n	2c484 <tSampler_tick+0x254>
   2c520:	ee07 ca90 	vmov	s15, ip
        if ((fadeLeftStart <= idx) && (idx <= fadeLeftEnd))
   2c524:	45b6      	cmp	lr, r6
   2c526:	eef8 9ae7 	vcvt.f32.s32	s19, s15
   2c52a:	dc70      	bgt.n	2c60e <tSampler_tick+0x3de>
   2c52c:	9b01      	ldr	r3, [sp, #4]
   2c52e:	429e      	cmp	r6, r3
   2c530:	dc6d      	bgt.n	2c60e <tSampler_tick+0x3de>
            offset = fadeLeftEnd - idx;
   2c532:	1b9b      	subs	r3, r3, r6
            p->inCrossfade = 1;
   2c534:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
            offset = fadeLeftEnd - idx;
   2c538:	9302      	str	r3, [sp, #8]
            cdx = fadeRightEnd - offset;
   2c53a:	ebaa 0303 	sub.w	r3, sl, r3
            int c1 = cdx-(1*dir);
   2c53e:	eba3 0e08 	sub.w	lr, r3, r8
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
   2c542:	4577      	cmp	r7, lr
   2c544:	f340 8127 	ble.w	2c796 <tSampler_tick+0x566>
   2c548:	4486      	add	lr, r0
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
   2c54a:	429f      	cmp	r7, r3
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c54c:	eeb0 2a68 	vmov.f32	s4, s17
   2c550:	9005      	str	r0, [sp, #20]
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
   2c552:	bfcc      	ite	gt
   2c554:	eb03 0c00 	addgt.w	ip, r3, r0
   2c558:	eba3 0c07 	suble.w	ip, r3, r7
            int c3 = cdx+(1*dir);
   2c55c:	4443      	add	r3, r8
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c55e:	9104      	str	r1, [sp, #16]
   2c560:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
   2c564:	4283      	cmp	r3, r0
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c566:	eddc 0a00 	vldr	s1, [ip]
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
   2c56a:	bfac      	ite	ge
   2c56c:	1a1a      	subge	r2, r3, r0
   2c56e:	18fa      	addlt	r2, r7, r3
            int c4 = cdx+(2*dir);
   2c570:	4443      	add	r3, r8
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c572:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
   2c576:	4283      	cmp	r3, r0
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c578:	ed92 1a00 	vldr	s2, [r2]
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
   2c57c:	bfac      	ite	ge
   2c57e:	1a1b      	subge	r3, r3, r0
   2c580:	19db      	addlt	r3, r3, r7
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
   2c582:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   2c586:	edd3 1a00 	vldr	s3, [r3]
   2c58a:	eb01 038e 	add.w	r3, r1, lr, lsl #2
   2c58e:	ed93 0a00 	vldr	s0, [r3]
   2c592:	f7fd fa91 	bl	29ab8 <LEAF_interpolate_hermite_x>
            crossfadeMix = (float) offset / (float) cfxlen;
   2c596:	eddd 7a02 	vldr	s15, [sp, #8]
   2c59a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
   2c59e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2c5a2:	ee86 7aa9 	vdiv.f32	s14, s13, s19
   2c5a6:	e9dd 1004 	ldrd	r1, r0, [sp, #16]
   2c5aa:	ee20 0a07 	vmul.f32	s0, s0, s14
   2c5ae:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2c5b2:	eea8 0a27 	vfma.f32	s0, s16, s15
   2c5b6:	eeb0 8a40 	vmov.f32	s16, s0
        float flipLength = fabsf(p->flipIdx - p->flipStart);
   2c5ba:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
   2c5be:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
   2c5c2:	ee77 7a68 	vsub.f32	s15, s14, s17
   2c5c6:	eef0 7ae7 	vabs.f32	s15, s15
        if (flipLength > cfxlen)
   2c5ca:	eef4 7ae9 	vcmpe.f32	s15, s19
   2c5ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c5d2:	dd56      	ble.n	2c682 <tSampler_tick+0x452>
            p->flipStart = -1;
   2c5d4:	4b80      	ldr	r3, [pc, #512]	; (2c7d8 <tSampler_tick+0x5a8>)
    float inc = fmodf(p->inc, (float)p->len);
   2c5d6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c5da:	ed94 0a04 	vldr	s0, [r4, #16]
   2c5de:	eef8 0a67 	vcvt.f32.u32	s1, s15
            p->flipStart = -1;
   2c5e2:	64e3      	str	r3, [r4, #76]	; 0x4c
            p->flipIdx = -1;
   2c5e4:	6523      	str	r3, [r4, #80]	; 0x50
    float inc = fmodf(p->inc, (float)p->len);
   2c5e6:	f001 f85f 	bl	2d6a8 <fmodf>
    p->idx += (dir * inc);
   2c5ea:	edd4 7a03 	vldr	s15, [r4, #12]
   2c5ee:	eee9 7a00 	vfma.f32	s15, s18, s0
   2c5f2:	edc4 7a03 	vstr	s15, [r4, #12]
   2c5f6:	e704      	b.n	2c402 <tSampler_tick+0x1d2>
    	else if (p->idx > myEnd)
   2c5f8:	ee07 aa10 	vmov	s14, sl
   2c5fc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2c600:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c604:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c608:	f77f af20 	ble.w	2c44c <tSampler_tick+0x21c>
   2c60c:	e71c      	b.n	2c448 <tSampler_tick+0x218>
    int32_t fadeRightStart = fadeRightEnd - cfxlen;
   2c60e:	ebaa 0c0c 	sub.w	ip, sl, ip
        else if ((fadeRightStart <= idx) && (idx <= fadeRightEnd))
   2c612:	4566      	cmp	r6, ip
   2c614:	f2c0 80bb 	blt.w	2c78e <tSampler_tick+0x55e>
   2c618:	45b2      	cmp	sl, r6
   2c61a:	f2c0 80b8 	blt.w	2c78e <tSampler_tick+0x55e>
            offset = idx - fadeRightStart;
   2c61e:	eba6 030c 	sub.w	r3, r6, ip
            p->inCrossfade = 1;
   2c622:	2201      	movs	r2, #1
            offset = idx - fadeRightStart;
   2c624:	9302      	str	r3, [sp, #8]
            cdx = fadeLeftStart + offset;
   2c626:	4473      	add	r3, lr
            p->inCrossfade = 1;
   2c628:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
   2c62c:	e787      	b.n	2c53e <tSampler_tick+0x30e>
        if (p->idx < myStart)
   2c62e:	ee07 9a90 	vmov	s15, r9
   2c632:	ed94 7a03 	vldr	s14, [r4, #12]
   2c636:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c63a:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c63e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c642:	f140 8081 	bpl.w	2c748 <tSampler_tick+0x518>
            p->idx = myStart + 1;
   2c646:	f109 0901 	add.w	r9, r9, #1
            p->bnf = -p->bnf;
   2c64a:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myStart + 1;
   2c64c:	ee07 9a90 	vmov	s15, r9
            p->bnf = -p->bnf;
   2c650:	425b      	negs	r3, r3
            p->idx = myStart + 1;
   2c652:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
   2c656:	77a3      	strb	r3, [r4, #30]
            p->idx = myStart + 1;
   2c658:	edc4 7a03 	vstr	s15, [r4, #12]
   2c65c:	e712      	b.n	2c484 <tSampler_tick+0x254>
        if (tRamp_sample(&p->gain) <= 0.00001f)
   2c65e:	4628      	mov	r0, r5
   2c660:	f7fb fc14 	bl	27e8c <tRamp_sample>
   2c664:	eddf 7a5d 	vldr	s15, [pc, #372]	; 2c7dc <tSampler_tick+0x5ac>
   2c668:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2c66c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c670:	f63f af11 	bhi.w	2c496 <tSampler_tick+0x266>
            if (p->retrigger == 1)
   2c674:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2c676:	2b01      	cmp	r3, #1
   2c678:	f000 8090 	beq.w	2c79c <tSampler_tick+0x56c>
                p->active = 0;
   2c67c:	2300      	movs	r3, #0
   2c67e:	6463      	str	r3, [r4, #68]	; 0x44
   2c680:	e709      	b.n	2c496 <tSampler_tick+0x266>
        if (p->flipIdx >= 0)
   2c682:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
   2c686:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c68a:	db4f      	blt.n	2c72c <tSampler_tick+0x4fc>
            if (p->flipStart == -1)
   2c68c:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
   2c690:	eef4 8a66 	vcmp.f32	s17, s13
   2c694:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c698:	d06e      	beq.n	2c778 <tSampler_tick+0x548>
   2c69a:	ee79 7ae7 	vsub.f32	s15, s19, s15
   2c69e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2c6a2:	eec7 8aa9 	vdiv.f32	s17, s15, s19
   2c6a6:	ee76 7ae8 	vsub.f32	s15, s13, s17
   2c6aa:	ee27 8a88 	vmul.f32	s16, s15, s16
            int fdx = (int) p->flipIdx;
   2c6ae:	eefd 7ac7 	vcvt.s32.f32	s15, s14
            idx += (1-rev);
   2c6b2:	9a03      	ldr	r2, [sp, #12]
   2c6b4:	4416      	add	r6, r2
            int fdx = (int) p->flipIdx;
   2c6b6:	eef0 6a67 	vmov.f32	s13, s15
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c6ba:	ee07 2a90 	vmov	s15, r2
   2c6be:	eeb8 2ae7 	vcvt.f32.s32	s4, s15
            int f3 = fdx-(1*dir);
   2c6c2:	ee16 3a90 	vmov	r3, s13
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c6c6:	eef8 7ae6 	vcvt.f32.s32	s15, s13
            int f1 = fdx+(1*dir);
   2c6ca:	eb08 0e03 	add.w	lr, r8, r3
            int f3 = fdx-(1*dir);
   2c6ce:	eba3 0208 	sub.w	r2, r3, r8
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c6d2:	ee37 7ac7 	vsub.f32	s14, s15, s14
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
   2c6d6:	4586      	cmp	lr, r0
            int f4 = fdx-(2*dir);
   2c6d8:	eba2 0c08 	sub.w	ip, r2, r8
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
   2c6dc:	bfb4      	ite	lt
   2c6de:	44be      	addlt	lr, r7
   2c6e0:	ebae 0e00 	subge.w	lr, lr, r0
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2c6e4:	4283      	cmp	r3, r0
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
   2c6e6:	eea9 2a07 	vfma.f32	s4, s18, s14
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2c6ea:	da43      	bge.n	2c774 <tSampler_tick+0x544>
   2c6ec:	443b      	add	r3, r7
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
   2c6ee:	4297      	cmp	r7, r2
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2c6f0:	eb01 0383 	add.w	r3, r1, r3, lsl #2
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
   2c6f4:	bfcc      	ite	gt
   2c6f6:	1812      	addgt	r2, r2, r0
   2c6f8:	1bd2      	suble	r2, r2, r7
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
   2c6fa:	4567      	cmp	r7, ip
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2c6fc:	edd3 0a00 	vldr	s1, [r3]
   2c700:	eb01 0282 	add.w	r2, r1, r2, lsl #2
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
   2c704:	bfcc      	ite	gt
   2c706:	4460      	addgt	r0, ip
   2c708:	ebac 0007 	suble.w	r0, ip, r7
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
   2c70c:	ed92 1a00 	vldr	s2, [r2]
   2c710:	eb01 0080 	add.w	r0, r1, r0, lsl #2
   2c714:	eb01 018e 	add.w	r1, r1, lr, lsl #2
   2c718:	edd0 1a00 	vldr	s3, [r0]
   2c71c:	ed91 0a00 	vldr	s0, [r1]
   2c720:	f7fd f9ca 	bl	29ab8 <LEAF_interpolate_hermite_x>
   2c724:	eea0 8a28 	vfma.f32	s16, s0, s17
   2c728:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
   2c72c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c730:	eef8 0a67 	vcvt.f32.u32	s1, s15
   2c734:	e62c      	b.n	2c390 <tSampler_tick+0x160>
            tRamp_setDest(&p->gain, 0.f);
   2c736:	ed9f 0a27 	vldr	s0, [pc, #156]	; 2c7d4 <tSampler_tick+0x5a4>
   2c73a:	4628      	mov	r0, r5
   2c73c:	f7fb fb62 	bl	27e04 <tRamp_setDest>
            p->active = -1;
   2c740:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c744:	6463      	str	r3, [r4, #68]	; 0x44
   2c746:	e69d      	b.n	2c484 <tSampler_tick+0x254>
        else if (p->idx > myEnd)
   2c748:	ee07 aa90 	vmov	s15, sl
   2c74c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c750:	eeb4 7ae7 	vcmpe.f32	s14, s15
   2c754:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c758:	f77f ae94 	ble.w	2c484 <tSampler_tick+0x254>
            p->idx = myEnd - 1;
   2c75c:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
            p->bnf = -p->bnf;
   2c760:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myEnd - 1;
   2c762:	ee07 aa90 	vmov	s15, sl
            p->bnf = -p->bnf;
   2c766:	425b      	negs	r3, r3
            p->idx = myEnd - 1;
   2c768:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
   2c76c:	77a3      	strb	r3, [r4, #30]
            p->idx = myEnd - 1;
   2c76e:	edc4 7a03 	vstr	s15, [r4, #12]
   2c772:	e687      	b.n	2c484 <tSampler_tick+0x254>
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
   2c774:	1a1b      	subs	r3, r3, r0
   2c776:	e7ba      	b.n	2c6ee <tSampler_tick+0x4be>
                p->flipStart = p->idx;
   2c778:	ed94 7a03 	vldr	s14, [r4, #12]
                p->flipIdx = p->idx;
   2c77c:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   2c780:	ed9f 8a14 	vldr	s16, [pc, #80]	; 2c7d4 <tSampler_tick+0x5a4>
                p->flipStart = p->idx;
   2c784:	ed84 7a13 	vstr	s14, [r4, #76]	; 0x4c
                p->flipIdx = p->idx;
   2c788:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
   2c78c:	e78f      	b.n	2c6ae <tSampler_tick+0x47e>
        else p->inCrossfade = 0;
   2c78e:	2300      	movs	r3, #0
   2c790:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
   2c794:	e711      	b.n	2c5ba <tSampler_tick+0x38a>
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
   2c796:	ebae 0e07 	sub.w	lr, lr, r7
   2c79a:	e6d6      	b.n	2c54a <tSampler_tick+0x31a>
                p->retrigger = 0;
   2c79c:	2200      	movs	r2, #0
                p->active = 1;
   2c79e:	6463      	str	r3, [r4, #68]	; 0x44
                tRamp_setDest(&p->gain, 1.f);
   2c7a0:	4628      	mov	r0, r5
   2c7a2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
                p->retrigger = 0;
   2c7a6:	6422      	str	r2, [r4, #64]	; 0x40
                tRamp_setDest(&p->gain, 1.f);
   2c7a8:	f7fb fb2c 	bl	27e04 <tRamp_setDest>
                if (p->dir > 0)
   2c7ac:	f994 301c 	ldrsb.w	r3, [r4, #28]
   2c7b0:	2b00      	cmp	r3, #0
                    if (p->flip > 0)    p->idx = p->start;
   2c7b2:	f994 301d 	ldrsb.w	r3, [r4, #29]
                if (p->dir > 0)
   2c7b6:	dd13      	ble.n	2c7e0 <tSampler_tick+0x5b0>
                    if (p->flip > 0)    p->idx = p->start;
   2c7b8:	2b00      	cmp	r3, #0
   2c7ba:	dd13      	ble.n	2c7e4 <tSampler_tick+0x5b4>
                    else                p->idx = p->start;
   2c7bc:	edd4 7a08 	vldr	s15, [r4, #32]
   2c7c0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c7c4:	edc4 7a03 	vstr	s15, [r4, #12]
   2c7c8:	e665      	b.n	2c496 <tSampler_tick+0x266>
   2c7ca:	bf00      	nop
   2c7cc:	3be56042 	.word	0x3be56042
   2c7d0:	020fc0a8 	.word	0x020fc0a8
   2c7d4:	00000000 	.word	0x00000000
   2c7d8:	bf800000 	.word	0xbf800000
   2c7dc:	3727c5ac 	.word	0x3727c5ac
                    if (p->flip > 0)    p->idx = p->end;
   2c7e0:	2b00      	cmp	r3, #0
   2c7e2:	ddeb      	ble.n	2c7bc <tSampler_tick+0x58c>
   2c7e4:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
   2c7e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c7ec:	edc4 7a03 	vstr	s15, [r4, #12]
   2c7f0:	e651      	b.n	2c496 <tSampler_tick+0x266>
   2c7f2:	bf00      	nop

0002c7f4 <tSampler_setLength>:

void    tSampler_setLength    (tSampler* const sp, int32_t length)
{
   2c7f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
   2c7f6:	6804      	ldr	r4, [r0, #0]
    if (length == 0) length = 1;
   2c7f8:	2900      	cmp	r1, #0
   2c7fa:	bf14      	ite	ne
   2c7fc:	460a      	movne	r2, r1
   2c7fe:	2201      	moveq	r2, #1
    tSampler_setEnd(sp, p->start + length);
   2c800:	6a23      	ldr	r3, [r4, #32]
    if (p->active) // only bother with these checks if we're actually playing
   2c802:	6c65      	ldr	r5, [r4, #68]	; 0x44
    tSampler_setEnd(sp, p->start + length);
   2c804:	1899      	adds	r1, r3, r2
    if (p->active) // only bother with these checks if we're actually playing
   2c806:	2d00      	cmp	r5, #0
   2c808:	d041      	beq.n	2c88e <tSampler_setLength+0x9a>
        if (p->start > end)
   2c80a:	428b      	cmp	r3, r1
   2c80c:	dc1d      	bgt.n	2c84a <tSampler_setLength+0x56>
   2c80e:	2501      	movs	r5, #1
   2c810:	2700      	movs	r7, #0
            tempflip = 1;
   2c812:	462e      	mov	r6, r5
        uint32_t cfxlen = p->cfxlen;
   2c814:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c818:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   2c81c:	eef8 6a47 	vcvt.f32.u32	s13, s14
        if (p->inCrossfade || p->flipStart >= 0)
   2c820:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
   2c824:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
   2c828:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c82c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c830:	bf48      	it	mi
   2c832:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
   2c836:	b933      	cbnz	r3, 2c846 <tSampler_setLength+0x52>
   2c838:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
   2c83c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2c840:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c844:	db06      	blt.n	2c854 <tSampler_setLength+0x60>
    p->targetend = -1;
   2c846:	62e1      	str	r1, [r4, #44]	; 0x2c
}
   2c848:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
   2c84a:	2701      	movs	r7, #1
   2c84c:	2500      	movs	r5, #0
            tempflip = -1;
   2c84e:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2c852:	e7df      	b.n	2c814 <tSampler_setLength+0x20>
        int dir = p->bnf * p->dir * tempflip;
   2c854:	f994 301e 	ldrsb.w	r3, [r4, #30]
   2c858:	f994 c01c 	ldrsb.w	ip, [r4, #28]
   2c85c:	fb13 f30c 	smulbb	r3, r3, ip
   2c860:	fb06 f303 	mul.w	r3, r6, r3
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
   2c864:	2b00      	cmp	r3, #0
   2c866:	da3c      	bge.n	2c8e2 <tSampler_setLength+0xee>
   2c868:	2d00      	cmp	r5, #0
   2c86a:	d03a      	beq.n	2c8e2 <tSampler_setLength+0xee>
            if (end < p->idx) // end given is before current index or we're in a crossfade
   2c86c:	ee07 1a90 	vmov	s15, r1
   2c870:	edd4 6a03 	vldr	s13, [r4, #12]
   2c874:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c878:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c87c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c880:	d43e      	bmi.n	2c900 <tSampler_setLength+0x10c>
        if (tempflip != p->flip && p->flipStart < 0)
   2c882:	f994 301d 	ldrsb.w	r3, [r4, #29]
   2c886:	429e      	cmp	r6, r3
   2c888:	d001      	beq.n	2c88e <tSampler_setLength+0x9a>
            p->flipIdx = 0;
   2c88a:	2300      	movs	r3, #0
   2c88c:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
   2c88e:	6863      	ldr	r3, [r4, #4]
   2c890:	4605      	mov	r5, r0
   2c892:	2000      	movs	r0, #0
   2c894:	691a      	ldr	r2, [r3, #16]
   2c896:	3a01      	subs	r2, #1
   2c898:	f7fd f80a 	bl	298b0 <LEAF_clipInt>
   2c89c:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
   2c89e:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
   2c8a0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2c8a2:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c8a4:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
   2c8a8:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c8aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
   2c8ae:	2900      	cmp	r1, #0
   2c8b0:	bfb8      	it	lt
   2c8b2:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c8b4:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
   2c8b8:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
   2c8ba:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
   2c8be:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c8c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c8c6:	dd03      	ble.n	2c8d0 <tSampler_setLength+0xdc>
   2c8c8:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   2c8cc:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
   2c8d0:	4282      	cmp	r2, r0
   2c8d2:	bfac      	ite	ge
   2c8d4:	2201      	movge	r2, #1
   2c8d6:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
   2c8da:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2c8de:	775a      	strb	r2, [r3, #29]
   2c8e0:	e7b1      	b.n	2c846 <tSampler_setLength+0x52>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
   2c8e2:	2b00      	cmp	r3, #0
   2c8e4:	ddcd      	ble.n	2c882 <tSampler_setLength+0x8e>
   2c8e6:	2f00      	cmp	r7, #0
   2c8e8:	d0cb      	beq.n	2c882 <tSampler_setLength+0x8e>
            if (end > p->idx) // end given is after current index or we're in a crossfade
   2c8ea:	ee07 1a90 	vmov	s15, r1
   2c8ee:	edd4 6a03 	vldr	s13, [r4, #12]
   2c8f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2c8f6:	eef4 7ae6 	vcmpe.f32	s15, s13
   2c8fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c8fe:	ddc0      	ble.n	2c882 <tSampler_setLength+0x8e>
                float tempLen = abs(end - p->start) * 0.25f;
   2c900:	2a00      	cmp	r2, #0
                if (cfxlen > tempLen)
   2c902:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
   2c906:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
   2c908:	bfb8      	it	lt
   2c90a:	4252      	neglt	r2, r2
   2c90c:	ee07 2a90 	vmov	s15, r2
   2c910:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
   2c914:	eef4 7ac7 	vcmpe.f32	s15, s14
   2c918:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c91c:	d594      	bpl.n	2c848 <tSampler_setLength+0x54>
                    p->cfxlen = tempLen;
   2c91e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   2c922:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
   2c926:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002c928 <tSampler_setRate>:

void tSampler_setRate      (tSampler* const sp, float rate)
{
    _tSampler* p = *sp;
    
    if (rate < 0.f)
   2c928:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    _tSampler* p = *sp;
   2c92c:	6803      	ldr	r3, [r0, #0]
    if (rate < 0.f)
   2c92e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2c932:	d40a      	bmi.n	2c94a <tSampler_setRate+0x22>
        rate = -rate;
        p->dir = -1;
    }
    else
    {
        p->dir = 1;
   2c934:	2201      	movs	r2, #1
    }
    
    p->inc = rate;
    p->iinc = 1.f / p->inc;
   2c936:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2c93a:	771a      	strb	r2, [r3, #28]
    p->inc = rate;
   2c93c:	ed83 0a04 	vstr	s0, [r3, #16]
    p->iinc = 1.f / p->inc;
   2c940:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2c944:	edc3 7a06 	vstr	s15, [r3, #24]
}
   2c948:	4770      	bx	lr
        rate = -rate;
   2c94a:	eeb1 0a40 	vneg.f32	s0, s0
        p->dir = -1;
   2c94e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c952:	e7f0      	b.n	2c936 <tSampler_setRate+0xe>

0002c954 <LEAF_init>:

LEAF leaf;

void LEAF_init(float sr, int blocksize, char* memory, size_t memorysize, float(*random)(void))

{
   2c954:	b538      	push	{r3, r4, r5, lr}
   2c956:	460c      	mov	r4, r1
   2c958:	4605      	mov	r5, r0
    leaf_pool_init(memory, memorysize);
   2c95a:	4611      	mov	r1, r2
   2c95c:	4620      	mov	r0, r4
{
   2c95e:	461c      	mov	r4, r3
   2c960:	ed2d 8b02 	vpush	{d8}
   2c964:	eeb0 8a40 	vmov.f32	s16, s0
    leaf_pool_init(memory, memorysize);
   2c968:	f7fd f976 	bl	29c58 <leaf_pool_init>
    
    leaf.sampleRate = sr;

    leaf.blockSize = blocksize;
    
    leaf.invSampleRate = 1.0f/sr;
   2c96c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   2c970:	eddf 7a09 	vldr	s15, [pc, #36]	; 2c998 <LEAF_init+0x44>
    leaf.sampleRate = sr;
   2c974:	4a09      	ldr	r2, [pc, #36]	; (2c99c <LEAF_init+0x48>)

    leaf.random = random;
    
    leaf.clearOnAllocation = 0;
   2c976:	2100      	movs	r1, #0
    leaf.invSampleRate = 1.0f/sr;
   2c978:	ee86 7a88 	vdiv.f32	s14, s13, s16
    leaf.blockSize = blocksize;
   2c97c:	6095      	str	r5, [r2, #8]
    leaf.sampleRate = sr;
   2c97e:	ed82 8a00 	vstr	s16, [r2]
    leaf.clearOnAllocation = 0;
   2c982:	e9c2 4104 	strd	r4, r1, [r2, #16]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   2c986:	ee67 7a27 	vmul.f32	s15, s14, s15
    leaf.invSampleRate = 1.0f/sr;
   2c98a:	ed82 7a01 	vstr	s14, [r2, #4]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
   2c98e:	edc2 7a03 	vstr	s15, [r2, #12]
}
   2c992:	ecbd 8b02 	vpop	{d8}
   2c996:	bd38      	pop	{r3, r4, r5, pc}
   2c998:	40c90fdb 	.word	0x40c90fdb
   2c99c:	020fc0a8 	.word	0x020fc0a8

0002c9a0 <LEAF_error>:
//implement a function called this in your user code to catch errors
//__attribute__((weak))
uint8_t LEAF_error(uint8_t whichone)
{
    return whichone;
}
   2c9a0:	4770      	bx	lr
   2c9a2:	bf00      	nop

0002c9a4 <__errno>:
   2c9a4:	4b01      	ldr	r3, [pc, #4]	; (2c9ac <__errno+0x8>)
   2c9a6:	6818      	ldr	r0, [r3, #0]
   2c9a8:	4770      	bx	lr
   2c9aa:	bf00      	nop
   2c9ac:	00062cc8 	.word	0x00062cc8

0002c9b0 <__libc_init_array>:
   2c9b0:	b570      	push	{r4, r5, r6, lr}
   2c9b2:	4e0d      	ldr	r6, [pc, #52]	; (2c9e8 <__libc_init_array+0x38>)
   2c9b4:	4c0d      	ldr	r4, [pc, #52]	; (2c9ec <__libc_init_array+0x3c>)
   2c9b6:	1ba4      	subs	r4, r4, r6
   2c9b8:	10a4      	asrs	r4, r4, #2
   2c9ba:	2500      	movs	r5, #0
   2c9bc:	42a5      	cmp	r5, r4
   2c9be:	d109      	bne.n	2c9d4 <__libc_init_array+0x24>
   2c9c0:	4e0b      	ldr	r6, [pc, #44]	; (2c9f0 <__libc_init_array+0x40>)
   2c9c2:	4c0c      	ldr	r4, [pc, #48]	; (2c9f4 <__libc_init_array+0x44>)
   2c9c4:	f7db fb1c 	bl	8000 <_init>
   2c9c8:	1ba4      	subs	r4, r4, r6
   2c9ca:	10a4      	asrs	r4, r4, #2
   2c9cc:	2500      	movs	r5, #0
   2c9ce:	42a5      	cmp	r5, r4
   2c9d0:	d105      	bne.n	2c9de <__libc_init_array+0x2e>
   2c9d2:	bd70      	pop	{r4, r5, r6, pc}
   2c9d4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   2c9d8:	4798      	blx	r3
   2c9da:	3501      	adds	r5, #1
   2c9dc:	e7ee      	b.n	2c9bc <__libc_init_array+0xc>
   2c9de:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   2c9e2:	4798      	blx	r3
   2c9e4:	3501      	adds	r5, #1
   2c9e6:	e7f2      	b.n	2c9ce <__libc_init_array+0x1e>
   2c9e8:	0006288c 	.word	0x0006288c
   2c9ec:	0006288c 	.word	0x0006288c
   2c9f0:	0006288c 	.word	0x0006288c
   2c9f4:	00062890 	.word	0x00062890

0002c9f8 <__itoa>:
   2c9f8:	1e93      	subs	r3, r2, #2
   2c9fa:	2b22      	cmp	r3, #34	; 0x22
   2c9fc:	b510      	push	{r4, lr}
   2c9fe:	460c      	mov	r4, r1
   2ca00:	d904      	bls.n	2ca0c <__itoa+0x14>
   2ca02:	2300      	movs	r3, #0
   2ca04:	700b      	strb	r3, [r1, #0]
   2ca06:	461c      	mov	r4, r3
   2ca08:	4620      	mov	r0, r4
   2ca0a:	bd10      	pop	{r4, pc}
   2ca0c:	2a0a      	cmp	r2, #10
   2ca0e:	d109      	bne.n	2ca24 <__itoa+0x2c>
   2ca10:	2800      	cmp	r0, #0
   2ca12:	da07      	bge.n	2ca24 <__itoa+0x2c>
   2ca14:	232d      	movs	r3, #45	; 0x2d
   2ca16:	700b      	strb	r3, [r1, #0]
   2ca18:	4240      	negs	r0, r0
   2ca1a:	2101      	movs	r1, #1
   2ca1c:	4421      	add	r1, r4
   2ca1e:	f000 f829 	bl	2ca74 <__utoa>
   2ca22:	e7f1      	b.n	2ca08 <__itoa+0x10>
   2ca24:	2100      	movs	r1, #0
   2ca26:	e7f9      	b.n	2ca1c <__itoa+0x24>

0002ca28 <itoa>:
   2ca28:	f7ff bfe6 	b.w	2c9f8 <__itoa>

0002ca2c <memcpy>:
   2ca2c:	b510      	push	{r4, lr}
   2ca2e:	1e43      	subs	r3, r0, #1
   2ca30:	440a      	add	r2, r1
   2ca32:	4291      	cmp	r1, r2
   2ca34:	d100      	bne.n	2ca38 <memcpy+0xc>
   2ca36:	bd10      	pop	{r4, pc}
   2ca38:	f811 4b01 	ldrb.w	r4, [r1], #1
   2ca3c:	f803 4f01 	strb.w	r4, [r3, #1]!
   2ca40:	e7f7      	b.n	2ca32 <memcpy+0x6>

0002ca42 <memset>:
   2ca42:	4402      	add	r2, r0
   2ca44:	4603      	mov	r3, r0
   2ca46:	4293      	cmp	r3, r2
   2ca48:	d100      	bne.n	2ca4c <memset+0xa>
   2ca4a:	4770      	bx	lr
   2ca4c:	f803 1b01 	strb.w	r1, [r3], #1
   2ca50:	e7f9      	b.n	2ca46 <memset+0x4>

0002ca52 <stpcpy>:
   2ca52:	4603      	mov	r3, r0
   2ca54:	f811 2b01 	ldrb.w	r2, [r1], #1
   2ca58:	4618      	mov	r0, r3
   2ca5a:	f803 2b01 	strb.w	r2, [r3], #1
   2ca5e:	2a00      	cmp	r2, #0
   2ca60:	d1f8      	bne.n	2ca54 <stpcpy+0x2>
   2ca62:	4770      	bx	lr

0002ca64 <strlen>:
   2ca64:	4603      	mov	r3, r0
   2ca66:	f813 2b01 	ldrb.w	r2, [r3], #1
   2ca6a:	2a00      	cmp	r2, #0
   2ca6c:	d1fb      	bne.n	2ca66 <strlen+0x2>
   2ca6e:	1a18      	subs	r0, r3, r0
   2ca70:	3801      	subs	r0, #1
   2ca72:	4770      	bx	lr

0002ca74 <__utoa>:
   2ca74:	b5f0      	push	{r4, r5, r6, r7, lr}
   2ca76:	4b1d      	ldr	r3, [pc, #116]	; (2caec <__utoa+0x78>)
   2ca78:	b08b      	sub	sp, #44	; 0x2c
   2ca7a:	4605      	mov	r5, r0
   2ca7c:	460c      	mov	r4, r1
   2ca7e:	466e      	mov	r6, sp
   2ca80:	f103 0c20 	add.w	ip, r3, #32
   2ca84:	6818      	ldr	r0, [r3, #0]
   2ca86:	6859      	ldr	r1, [r3, #4]
   2ca88:	4637      	mov	r7, r6
   2ca8a:	c703      	stmia	r7!, {r0, r1}
   2ca8c:	3308      	adds	r3, #8
   2ca8e:	4563      	cmp	r3, ip
   2ca90:	463e      	mov	r6, r7
   2ca92:	d1f7      	bne.n	2ca84 <__utoa+0x10>
   2ca94:	6818      	ldr	r0, [r3, #0]
   2ca96:	791b      	ldrb	r3, [r3, #4]
   2ca98:	713b      	strb	r3, [r7, #4]
   2ca9a:	1e93      	subs	r3, r2, #2
   2ca9c:	2b22      	cmp	r3, #34	; 0x22
   2ca9e:	6038      	str	r0, [r7, #0]
   2caa0:	f04f 0300 	mov.w	r3, #0
   2caa4:	d904      	bls.n	2cab0 <__utoa+0x3c>
   2caa6:	7023      	strb	r3, [r4, #0]
   2caa8:	461c      	mov	r4, r3
   2caaa:	4620      	mov	r0, r4
   2caac:	b00b      	add	sp, #44	; 0x2c
   2caae:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2cab0:	1e66      	subs	r6, r4, #1
   2cab2:	fbb5 f0f2 	udiv	r0, r5, r2
   2cab6:	af0a      	add	r7, sp, #40	; 0x28
   2cab8:	fb02 5510 	mls	r5, r2, r0, r5
   2cabc:	443d      	add	r5, r7
   2cabe:	1c59      	adds	r1, r3, #1
   2cac0:	f815 5c28 	ldrb.w	r5, [r5, #-40]
   2cac4:	f806 5f01 	strb.w	r5, [r6, #1]!
   2cac8:	4605      	mov	r5, r0
   2caca:	b968      	cbnz	r0, 2cae8 <__utoa+0x74>
   2cacc:	5460      	strb	r0, [r4, r1]
   2cace:	4423      	add	r3, r4
   2cad0:	4622      	mov	r2, r4
   2cad2:	1b19      	subs	r1, r3, r4
   2cad4:	1b10      	subs	r0, r2, r4
   2cad6:	4281      	cmp	r1, r0
   2cad8:	dde7      	ble.n	2caaa <__utoa+0x36>
   2cada:	7811      	ldrb	r1, [r2, #0]
   2cadc:	7818      	ldrb	r0, [r3, #0]
   2cade:	f802 0b01 	strb.w	r0, [r2], #1
   2cae2:	f803 1901 	strb.w	r1, [r3], #-1
   2cae6:	e7f4      	b.n	2cad2 <__utoa+0x5e>
   2cae8:	460b      	mov	r3, r1
   2caea:	e7e2      	b.n	2cab2 <__utoa+0x3e>
   2caec:	00051f20 	.word	0x00051f20

0002caf0 <atanf>:
   2caf0:	b538      	push	{r3, r4, r5, lr}
   2caf2:	ee10 5a10 	vmov	r5, s0
   2caf6:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
   2cafa:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
   2cafe:	eef0 7a40 	vmov.f32	s15, s0
   2cb02:	db0f      	blt.n	2cb24 <atanf+0x34>
   2cb04:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   2cb08:	dd04      	ble.n	2cb14 <atanf+0x24>
   2cb0a:	ee70 7a00 	vadd.f32	s15, s0, s0
   2cb0e:	eeb0 0a67 	vmov.f32	s0, s15
   2cb12:	bd38      	pop	{r3, r4, r5, pc}
   2cb14:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 2cc48 <atanf+0x158>
   2cb18:	eddf 7a4c 	vldr	s15, [pc, #304]	; 2cc4c <atanf+0x15c>
   2cb1c:	2d00      	cmp	r5, #0
   2cb1e:	fe77 7a87 	vselgt.f32	s15, s15, s14
   2cb22:	e7f4      	b.n	2cb0e <atanf+0x1e>
   2cb24:	4b4a      	ldr	r3, [pc, #296]	; (2cc50 <atanf+0x160>)
   2cb26:	429c      	cmp	r4, r3
   2cb28:	dc10      	bgt.n	2cb4c <atanf+0x5c>
   2cb2a:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
   2cb2e:	da0a      	bge.n	2cb46 <atanf+0x56>
   2cb30:	ed9f 7a48 	vldr	s14, [pc, #288]	; 2cc54 <atanf+0x164>
   2cb34:	ee30 7a07 	vadd.f32	s14, s0, s14
   2cb38:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2cb3c:	eeb4 7ae6 	vcmpe.f32	s14, s13
   2cb40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cb44:	dce3      	bgt.n	2cb0e <atanf+0x1e>
   2cb46:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2cb4a:	e013      	b.n	2cb74 <atanf+0x84>
   2cb4c:	f000 f960 	bl	2ce10 <fabsf>
   2cb50:	4b41      	ldr	r3, [pc, #260]	; (2cc58 <atanf+0x168>)
   2cb52:	429c      	cmp	r4, r3
   2cb54:	dc4f      	bgt.n	2cbf6 <atanf+0x106>
   2cb56:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
   2cb5a:	429c      	cmp	r4, r3
   2cb5c:	dc41      	bgt.n	2cbe2 <atanf+0xf2>
   2cb5e:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2cb62:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2cb66:	eea0 7a27 	vfma.f32	s14, s0, s15
   2cb6a:	2300      	movs	r3, #0
   2cb6c:	ee30 0a27 	vadd.f32	s0, s0, s15
   2cb70:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2cb74:	1c5a      	adds	r2, r3, #1
   2cb76:	ee27 6aa7 	vmul.f32	s12, s15, s15
   2cb7a:	ed9f 7a38 	vldr	s14, [pc, #224]	; 2cc5c <atanf+0x16c>
   2cb7e:	eddf 5a38 	vldr	s11, [pc, #224]	; 2cc60 <atanf+0x170>
   2cb82:	ed9f 5a38 	vldr	s10, [pc, #224]	; 2cc64 <atanf+0x174>
   2cb86:	ee66 6a06 	vmul.f32	s13, s12, s12
   2cb8a:	eee6 5a87 	vfma.f32	s11, s13, s14
   2cb8e:	ed9f 7a36 	vldr	s14, [pc, #216]	; 2cc68 <atanf+0x178>
   2cb92:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2cb96:	eddf 5a35 	vldr	s11, [pc, #212]	; 2cc6c <atanf+0x17c>
   2cb9a:	eee7 5a26 	vfma.f32	s11, s14, s13
   2cb9e:	ed9f 7a34 	vldr	s14, [pc, #208]	; 2cc70 <atanf+0x180>
   2cba2:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2cba6:	eddf 5a33 	vldr	s11, [pc, #204]	; 2cc74 <atanf+0x184>
   2cbaa:	eee7 5a26 	vfma.f32	s11, s14, s13
   2cbae:	ed9f 7a32 	vldr	s14, [pc, #200]	; 2cc78 <atanf+0x188>
   2cbb2:	eea6 5a87 	vfma.f32	s10, s13, s14
   2cbb6:	ed9f 7a31 	vldr	s14, [pc, #196]	; 2cc7c <atanf+0x18c>
   2cbba:	eea5 7a26 	vfma.f32	s14, s10, s13
   2cbbe:	ed9f 5a30 	vldr	s10, [pc, #192]	; 2cc80 <atanf+0x190>
   2cbc2:	eea7 5a26 	vfma.f32	s10, s14, s13
   2cbc6:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 2cc84 <atanf+0x194>
   2cbca:	eea5 7a26 	vfma.f32	s14, s10, s13
   2cbce:	ee27 7a26 	vmul.f32	s14, s14, s13
   2cbd2:	eea5 7a86 	vfma.f32	s14, s11, s12
   2cbd6:	ee27 7a27 	vmul.f32	s14, s14, s15
   2cbda:	d121      	bne.n	2cc20 <atanf+0x130>
   2cbdc:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2cbe0:	e795      	b.n	2cb0e <atanf+0x1e>
   2cbe2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2cbe6:	ee30 7a67 	vsub.f32	s14, s0, s15
   2cbea:	ee30 0a27 	vadd.f32	s0, s0, s15
   2cbee:	2301      	movs	r3, #1
   2cbf0:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2cbf4:	e7be      	b.n	2cb74 <atanf+0x84>
   2cbf6:	4b24      	ldr	r3, [pc, #144]	; (2cc88 <atanf+0x198>)
   2cbf8:	429c      	cmp	r4, r3
   2cbfa:	dc0b      	bgt.n	2cc14 <atanf+0x124>
   2cbfc:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
   2cc00:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2cc04:	eea0 7a27 	vfma.f32	s14, s0, s15
   2cc08:	2302      	movs	r3, #2
   2cc0a:	ee70 6a67 	vsub.f32	s13, s0, s15
   2cc0e:	eec6 7a87 	vdiv.f32	s15, s13, s14
   2cc12:	e7af      	b.n	2cb74 <atanf+0x84>
   2cc14:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2cc18:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2cc1c:	2303      	movs	r3, #3
   2cc1e:	e7a9      	b.n	2cb74 <atanf+0x84>
   2cc20:	4a1a      	ldr	r2, [pc, #104]	; (2cc8c <atanf+0x19c>)
   2cc22:	491b      	ldr	r1, [pc, #108]	; (2cc90 <atanf+0x1a0>)
   2cc24:	009b      	lsls	r3, r3, #2
   2cc26:	441a      	add	r2, r3
   2cc28:	440b      	add	r3, r1
   2cc2a:	edd3 6a00 	vldr	s13, [r3]
   2cc2e:	ee37 7a66 	vsub.f32	s14, s14, s13
   2cc32:	2d00      	cmp	r5, #0
   2cc34:	ee77 7a67 	vsub.f32	s15, s14, s15
   2cc38:	ed92 7a00 	vldr	s14, [r2]
   2cc3c:	ee77 7a67 	vsub.f32	s15, s14, s15
   2cc40:	bfb8      	it	lt
   2cc42:	eef1 7a67 	vneglt.f32	s15, s15
   2cc46:	e762      	b.n	2cb0e <atanf+0x1e>
   2cc48:	bfc90fdb 	.word	0xbfc90fdb
   2cc4c:	3fc90fdb 	.word	0x3fc90fdb
   2cc50:	3edfffff 	.word	0x3edfffff
   2cc54:	7149f2ca 	.word	0x7149f2ca
   2cc58:	3f97ffff 	.word	0x3f97ffff
   2cc5c:	3c8569d7 	.word	0x3c8569d7
   2cc60:	3d4bda59 	.word	0x3d4bda59
   2cc64:	bd6ef16b 	.word	0xbd6ef16b
   2cc68:	3d886b35 	.word	0x3d886b35
   2cc6c:	3dba2e6e 	.word	0x3dba2e6e
   2cc70:	3e124925 	.word	0x3e124925
   2cc74:	3eaaaaab 	.word	0x3eaaaaab
   2cc78:	bd15a221 	.word	0xbd15a221
   2cc7c:	bd9d8795 	.word	0xbd9d8795
   2cc80:	bde38e38 	.word	0xbde38e38
   2cc84:	be4ccccd 	.word	0xbe4ccccd
   2cc88:	401bffff 	.word	0x401bffff
   2cc8c:	00051f48 	.word	0x00051f48
   2cc90:	00051f58 	.word	0x00051f58

0002cc94 <cosf>:
   2cc94:	ee10 3a10 	vmov	r3, s0
   2cc98:	b507      	push	{r0, r1, r2, lr}
   2cc9a:	4a1c      	ldr	r2, [pc, #112]	; (2cd0c <cosf+0x78>)
   2cc9c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2cca0:	4293      	cmp	r3, r2
   2cca2:	dc04      	bgt.n	2ccae <cosf+0x1a>
   2cca4:	eddf 0a1a 	vldr	s1, [pc, #104]	; 2cd10 <cosf+0x7c>
   2cca8:	f001 fd40 	bl	2e72c <__kernel_cosf>
   2ccac:	e004      	b.n	2ccb8 <cosf+0x24>
   2ccae:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2ccb2:	db04      	blt.n	2ccbe <cosf+0x2a>
   2ccb4:	ee30 0a40 	vsub.f32	s0, s0, s0
   2ccb8:	b003      	add	sp, #12
   2ccba:	f85d fb04 	ldr.w	pc, [sp], #4
   2ccbe:	4668      	mov	r0, sp
   2ccc0:	f001 fb9a 	bl	2e3f8 <__ieee754_rem_pio2f>
   2ccc4:	f000 0003 	and.w	r0, r0, #3
   2ccc8:	2801      	cmp	r0, #1
   2ccca:	d007      	beq.n	2ccdc <cosf+0x48>
   2cccc:	2802      	cmp	r0, #2
   2ccce:	d00e      	beq.n	2ccee <cosf+0x5a>
   2ccd0:	b9a0      	cbnz	r0, 2ccfc <cosf+0x68>
   2ccd2:	eddd 0a01 	vldr	s1, [sp, #4]
   2ccd6:	ed9d 0a00 	vldr	s0, [sp]
   2ccda:	e7e5      	b.n	2cca8 <cosf+0x14>
   2ccdc:	eddd 0a01 	vldr	s1, [sp, #4]
   2cce0:	ed9d 0a00 	vldr	s0, [sp]
   2cce4:	f002 f802 	bl	2ecec <__kernel_sinf>
   2cce8:	eeb1 0a40 	vneg.f32	s0, s0
   2ccec:	e7e4      	b.n	2ccb8 <cosf+0x24>
   2ccee:	eddd 0a01 	vldr	s1, [sp, #4]
   2ccf2:	ed9d 0a00 	vldr	s0, [sp]
   2ccf6:	f001 fd19 	bl	2e72c <__kernel_cosf>
   2ccfa:	e7f5      	b.n	2cce8 <cosf+0x54>
   2ccfc:	2001      	movs	r0, #1
   2ccfe:	eddd 0a01 	vldr	s1, [sp, #4]
   2cd02:	ed9d 0a00 	vldr	s0, [sp]
   2cd06:	f001 fff1 	bl	2ecec <__kernel_sinf>
   2cd0a:	e7d5      	b.n	2ccb8 <cosf+0x24>
   2cd0c:	3f490fd8 	.word	0x3f490fd8
   2cd10:	00000000 	.word	0x00000000

0002cd14 <expf>:
   2cd14:	ee10 2a10 	vmov	r2, s0
   2cd18:	f240 412a 	movw	r1, #1066	; 0x42a
   2cd1c:	f3c2 530a 	ubfx	r3, r2, #20, #11
   2cd20:	428b      	cmp	r3, r1
   2cd22:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
   2cd26:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
   2cd2a:	d92e      	bls.n	2cd8a <expf+0x76>
   2cd2c:	f512 0f00 	cmn.w	r2, #8388608	; 0x800000
   2cd30:	d061      	beq.n	2cdf6 <expf+0xe2>
   2cd32:	f5b3 6fff 	cmp.w	r3, #2040	; 0x7f8
   2cd36:	d304      	bcc.n	2cd42 <expf+0x2e>
   2cd38:	ee30 0a00 	vadd.f32	s0, s0, s0
   2cd3c:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cd40:	4770      	bx	lr
   2cd42:	eddf 7a2e 	vldr	s15, [pc, #184]	; 2cdfc <expf+0xe8>
   2cd46:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cd4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cd4e:	dd04      	ble.n	2cd5a <expf+0x46>
   2cd50:	2000      	movs	r0, #0
   2cd52:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cd56:	f002 b91b 	b.w	2ef90 <__math_oflowf>
   2cd5a:	eddf 7a29 	vldr	s15, [pc, #164]	; 2ce00 <expf+0xec>
   2cd5e:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cd62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cd66:	d504      	bpl.n	2cd72 <expf+0x5e>
   2cd68:	2000      	movs	r0, #0
   2cd6a:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cd6e:	f002 b903 	b.w	2ef78 <__math_uflowf>
   2cd72:	eddf 7a24 	vldr	s15, [pc, #144]	; 2ce04 <expf+0xf0>
   2cd76:	eeb4 0ae7 	vcmpe.f32	s0, s15
   2cd7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2cd7e:	d504      	bpl.n	2cd8a <expf+0x76>
   2cd80:	2000      	movs	r0, #0
   2cd82:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
   2cd86:	f002 b8fd 	b.w	2ef84 <__math_may_uflowf>
   2cd8a:	491f      	ldr	r1, [pc, #124]	; (2ce08 <expf+0xf4>)
   2cd8c:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
   2cd90:	ed91 5b4a 	vldr	d5, [r1, #296]	; 0x128
   2cd94:	ed91 7b48 	vldr	d7, [r1, #288]	; 0x120
   2cd98:	eeb0 4b47 	vmov.f64	d4, d7
   2cd9c:	eea5 4b06 	vfma.f64	d4, d5, d6
   2cda0:	ec55 4b14 	vmov	r4, r5, d4
   2cda4:	ee34 7b47 	vsub.f64	d7, d4, d7
   2cda8:	f004 021f 	and.w	r2, r4, #31
   2cdac:	ee95 7b06 	vfnms.f64	d7, d5, d6
   2cdb0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   2cdb4:	ed91 6b50 	vldr	d6, [r1, #320]	; 0x140
   2cdb8:	e9d2 4500 	ldrd	r4, r5, [r2]
   2cdbc:	eea6 0b07 	vfma.f64	d0, d6, d7
   2cdc0:	ee14 0a10 	vmov	r0, s8
   2cdc4:	ed91 5b4c 	vldr	d5, [r1, #304]	; 0x130
   2cdc8:	ed91 6b4e 	vldr	d6, [r1, #312]	; 0x138
   2cdcc:	f04f 0b00 	mov.w	fp, #0
   2cdd0:	eb1b 0204 	adds.w	r2, fp, r4
   2cdd4:	ea4f 3cc0 	mov.w	ip, r0, lsl #15
   2cdd8:	eb4c 0305 	adc.w	r3, ip, r5
   2cddc:	eea5 6b07 	vfma.f64	d6, d5, d7
   2cde0:	ee27 7b07 	vmul.f64	d7, d7, d7
   2cde4:	eea6 0b07 	vfma.f64	d0, d6, d7
   2cde8:	ec43 2b17 	vmov	d7, r2, r3
   2cdec:	ee20 0b07 	vmul.f64	d0, d0, d7
   2cdf0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2cdf4:	e7a2      	b.n	2cd3c <expf+0x28>
   2cdf6:	ed9f 0a05 	vldr	s0, [pc, #20]	; 2ce0c <expf+0xf8>
   2cdfa:	e79f      	b.n	2cd3c <expf+0x28>
   2cdfc:	42b17217 	.word	0x42b17217
   2ce00:	c2cff1b4 	.word	0xc2cff1b4
   2ce04:	c2ce8ecf 	.word	0xc2ce8ecf
   2ce08:	00051f68 	.word	0x00051f68
   2ce0c:	00000000 	.word	0x00000000

0002ce10 <fabsf>:
   2ce10:	ee10 3a10 	vmov	r3, s0
   2ce14:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2ce18:	ee00 3a10 	vmov	s0, r3
   2ce1c:	4770      	bx	lr
	...

0002ce20 <logf>:
   2ce20:	ee10 3a10 	vmov	r3, s0
   2ce24:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   2ce28:	b410      	push	{r4}
   2ce2a:	d057      	beq.n	2cedc <logf+0xbc>
   2ce2c:	f5a3 0200 	sub.w	r2, r3, #8388608	; 0x800000
   2ce30:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   2ce34:	d31a      	bcc.n	2ce6c <logf+0x4c>
   2ce36:	005a      	lsls	r2, r3, #1
   2ce38:	d104      	bne.n	2ce44 <logf+0x24>
   2ce3a:	2001      	movs	r0, #1
   2ce3c:	f85d 4b04 	ldr.w	r4, [sp], #4
   2ce40:	f002 b8ac 	b.w	2ef9c <__math_divzerof>
   2ce44:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2ce48:	d045      	beq.n	2ced6 <logf+0xb6>
   2ce4a:	2b00      	cmp	r3, #0
   2ce4c:	db02      	blt.n	2ce54 <logf+0x34>
   2ce4e:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
   2ce52:	d303      	bcc.n	2ce5c <logf+0x3c>
   2ce54:	f85d 4b04 	ldr.w	r4, [sp], #4
   2ce58:	f002 b8b0 	b.w	2efbc <__math_invalidf>
   2ce5c:	eddf 7a21 	vldr	s15, [pc, #132]	; 2cee4 <logf+0xc4>
   2ce60:	ee20 0a27 	vmul.f32	s0, s0, s15
   2ce64:	ee10 3a10 	vmov	r3, s0
   2ce68:	f1a3 6338 	sub.w	r3, r3, #192937984	; 0xb800000
   2ce6c:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
   2ce70:	491d      	ldr	r1, [pc, #116]	; (2cee8 <logf+0xc8>)
   2ce72:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   2ce76:	f502 024d 	add.w	r2, r2, #13434880	; 0xcd0000
   2ce7a:	f3c2 40c3 	ubfx	r0, r2, #19, #4
   2ce7e:	0dd4      	lsrs	r4, r2, #23
   2ce80:	eb01 1000 	add.w	r0, r1, r0, lsl #4
   2ce84:	05e4      	lsls	r4, r4, #23
   2ce86:	ed90 5b00 	vldr	d5, [r0]
   2ce8a:	1b1b      	subs	r3, r3, r4
   2ce8c:	ee07 3a90 	vmov	s15, r3
   2ce90:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   2ce94:	eea5 6b07 	vfma.f64	d6, d5, d7
   2ce98:	ed91 5b44 	vldr	d5, [r1, #272]	; 0x110
   2ce9c:	ee26 3b06 	vmul.f64	d3, d6, d6
   2cea0:	ed91 7b46 	vldr	d7, [r1, #280]	; 0x118
   2cea4:	eea5 7b06 	vfma.f64	d7, d5, d6
   2cea8:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
   2ceac:	15d2      	asrs	r2, r2, #23
   2ceae:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
   2ceb2:	eea5 7b03 	vfma.f64	d7, d5, d3
   2ceb6:	eeb0 5b47 	vmov.f64	d5, d7
   2ceba:	ed90 0b02 	vldr	d0, [r0, #8]
   2cebe:	ee07 2a90 	vmov	s15, r2
   2cec2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2cec6:	eea7 0b04 	vfma.f64	d0, d7, d4
   2ceca:	ee30 0b06 	vadd.f64	d0, d0, d6
   2cece:	eea3 0b05 	vfma.f64	d0, d3, d5
   2ced2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2ced6:	f85d 4b04 	ldr.w	r4, [sp], #4
   2ceda:	4770      	bx	lr
   2cedc:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2ceec <logf+0xcc>
   2cee0:	e7f9      	b.n	2ced6 <logf+0xb6>
   2cee2:	bf00      	nop
   2cee4:	4b000000 	.word	0x4b000000
   2cee8:	000521d0 	.word	0x000521d0
   2ceec:	00000000 	.word	0x00000000

0002cef0 <log2f>:
   2cef0:	ee10 2a10 	vmov	r2, s0
   2cef4:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
   2cef8:	b410      	push	{r4}
   2cefa:	d057      	beq.n	2cfac <log2f+0xbc>
   2cefc:	f5a2 0300 	sub.w	r3, r2, #8388608	; 0x800000
   2cf00:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2cf04:	d31a      	bcc.n	2cf3c <log2f+0x4c>
   2cf06:	0053      	lsls	r3, r2, #1
   2cf08:	d104      	bne.n	2cf14 <log2f+0x24>
   2cf0a:	2001      	movs	r0, #1
   2cf0c:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cf10:	f002 b844 	b.w	2ef9c <__math_divzerof>
   2cf14:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2cf18:	d045      	beq.n	2cfa6 <log2f+0xb6>
   2cf1a:	2a00      	cmp	r2, #0
   2cf1c:	db02      	blt.n	2cf24 <log2f+0x34>
   2cf1e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   2cf22:	d303      	bcc.n	2cf2c <log2f+0x3c>
   2cf24:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cf28:	f002 b848 	b.w	2efbc <__math_invalidf>
   2cf2c:	eddf 7a21 	vldr	s15, [pc, #132]	; 2cfb4 <log2f+0xc4>
   2cf30:	ee20 0a27 	vmul.f32	s0, s0, s15
   2cf34:	ee10 3a10 	vmov	r3, s0
   2cf38:	f1a3 6238 	sub.w	r2, r3, #192937984	; 0xb800000
   2cf3c:	f102 4340 	add.w	r3, r2, #3221225472	; 0xc0000000
   2cf40:	491d      	ldr	r1, [pc, #116]	; (2cfb8 <log2f+0xc8>)
   2cf42:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   2cf46:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
   2cf4a:	f3c3 40c3 	ubfx	r0, r3, #19, #4
   2cf4e:	0ddc      	lsrs	r4, r3, #23
   2cf50:	eb01 1000 	add.w	r0, r1, r0, lsl #4
   2cf54:	05e4      	lsls	r4, r4, #23
   2cf56:	ed90 5b00 	vldr	d5, [r0]
   2cf5a:	1b12      	subs	r2, r2, r4
   2cf5c:	ee07 2a90 	vmov	s15, r2
   2cf60:	ed91 4b42 	vldr	d4, [r1, #264]	; 0x108
   2cf64:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   2cf68:	eea5 6b07 	vfma.f64	d6, d5, d7
   2cf6c:	eeb0 7b46 	vmov.f64	d7, d6
   2cf70:	ee26 5b06 	vmul.f64	d5, d6, d6
   2cf74:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
   2cf78:	eea4 6b07 	vfma.f64	d6, d4, d7
   2cf7c:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
   2cf80:	15db      	asrs	r3, r3, #23
   2cf82:	eea4 6b05 	vfma.f64	d6, d4, d5
   2cf86:	ed90 4b02 	vldr	d4, [r0, #8]
   2cf8a:	ee00 3a10 	vmov	s0, r3
   2cf8e:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
   2cf92:	ee30 0b04 	vadd.f64	d0, d0, d4
   2cf96:	ed91 4b46 	vldr	d4, [r1, #280]	; 0x118
   2cf9a:	eea4 0b07 	vfma.f64	d0, d4, d7
   2cf9e:	eea5 0b06 	vfma.f64	d0, d5, d6
   2cfa2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2cfa6:	f85d 4b04 	ldr.w	r4, [sp], #4
   2cfaa:	4770      	bx	lr
   2cfac:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2cfbc <log2f+0xcc>
   2cfb0:	e7f9      	b.n	2cfa6 <log2f+0xb6>
   2cfb2:	bf00      	nop
   2cfb4:	4b000000 	.word	0x4b000000
   2cfb8:	000520b0 	.word	0x000520b0
   2cfbc:	00000000 	.word	0x00000000

0002cfc0 <checkint>:
   2cfc0:	f3c0 53c7 	ubfx	r3, r0, #23, #8
   2cfc4:	2b7e      	cmp	r3, #126	; 0x7e
   2cfc6:	dd10      	ble.n	2cfea <checkint+0x2a>
   2cfc8:	2b96      	cmp	r3, #150	; 0x96
   2cfca:	dc0c      	bgt.n	2cfe6 <checkint+0x26>
   2cfcc:	2201      	movs	r2, #1
   2cfce:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
   2cfd2:	fa02 f303 	lsl.w	r3, r2, r3
   2cfd6:	1e5a      	subs	r2, r3, #1
   2cfd8:	4202      	tst	r2, r0
   2cfda:	d106      	bne.n	2cfea <checkint+0x2a>
   2cfdc:	4203      	tst	r3, r0
   2cfde:	bf0c      	ite	eq
   2cfe0:	2002      	moveq	r0, #2
   2cfe2:	2001      	movne	r0, #1
   2cfe4:	4770      	bx	lr
   2cfe6:	2002      	movs	r0, #2
   2cfe8:	4770      	bx	lr
   2cfea:	2000      	movs	r0, #0
   2cfec:	4770      	bx	lr
	...

0002cff0 <powf>:
   2cff0:	ee10 1a10 	vmov	r1, s0
   2cff4:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
   2cff8:	ee10 4a90 	vmov	r4, s1
   2cffc:	f5a1 0300 	sub.w	r3, r1, #8388608	; 0x800000
   2d000:	0062      	lsls	r2, r4, #1
   2d002:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2d006:	eef0 4a60 	vmov.f32	s9, s1
   2d00a:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
   2d00e:	4b92      	ldr	r3, [pc, #584]	; (2d258 <powf+0x268>)
   2d010:	d255      	bcs.n	2d0be <powf+0xce>
   2d012:	4298      	cmp	r0, r3
   2d014:	d855      	bhi.n	2d0c2 <powf+0xd2>
   2d016:	2000      	movs	r0, #0
   2d018:	f101 4340 	add.w	r3, r1, #3221225472	; 0xc0000000
   2d01c:	4a8f      	ldr	r2, [pc, #572]	; (2d25c <powf+0x26c>)
   2d01e:	eebf 2b00 	vmov.f64	d2, #240	; 0xbf800000 -1.0
   2d022:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
   2d026:	f3c3 44c3 	ubfx	r4, r3, #19, #4
   2d02a:	0ddb      	lsrs	r3, r3, #23
   2d02c:	eb02 1404 	add.w	r4, r2, r4, lsl #4
   2d030:	05db      	lsls	r3, r3, #23
   2d032:	ed94 6b00 	vldr	d6, [r4]
   2d036:	1ac9      	subs	r1, r1, r3
   2d038:	ee07 1a90 	vmov	s15, r1
   2d03c:	ed92 5b40 	vldr	d5, [r2, #256]	; 0x100
   2d040:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
   2d044:	eea6 2b07 	vfma.f64	d2, d6, d7
   2d048:	ed92 7b42 	vldr	d7, [r2, #264]	; 0x108
   2d04c:	ee22 6b02 	vmul.f64	d6, d2, d2
   2d050:	eea2 7b05 	vfma.f64	d7, d2, d5
   2d054:	15db      	asrs	r3, r3, #23
   2d056:	ed94 5b02 	vldr	d5, [r4, #8]
   2d05a:	ee00 3a10 	vmov	s0, r3
   2d05e:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
   2d062:	ee30 0b05 	vadd.f64	d0, d0, d5
   2d066:	ed92 5b48 	vldr	d5, [r2, #288]	; 0x120
   2d06a:	ed92 3b44 	vldr	d3, [r2, #272]	; 0x110
   2d06e:	eea2 0b05 	vfma.f64	d0, d2, d5
   2d072:	ed92 5b46 	vldr	d5, [r2, #280]	; 0x118
   2d076:	eea2 5b03 	vfma.f64	d5, d2, d3
   2d07a:	eea6 0b05 	vfma.f64	d0, d6, d5
   2d07e:	ee26 6b06 	vmul.f64	d6, d6, d6
   2d082:	eea7 0b06 	vfma.f64	d0, d7, d6
   2d086:	eeb7 7ae4 	vcvt.f64.f32	d7, s9
   2d08a:	ee20 0b07 	vmul.f64	d0, d0, d7
   2d08e:	ee10 3a90 	vmov	r3, s1
   2d092:	2500      	movs	r5, #0
   2d094:	0bda      	lsrs	r2, r3, #15
   2d096:	2300      	movs	r3, #0
   2d098:	b292      	uxth	r2, r2
   2d09a:	f248 04be 	movw	r4, #32958	; 0x80be
   2d09e:	429d      	cmp	r5, r3
   2d0a0:	bf08      	it	eq
   2d0a2:	4294      	cmpeq	r4, r2
   2d0a4:	f080 8094 	bcs.w	2d1d0 <powf+0x1e0>
   2d0a8:	ed9f 7b65 	vldr	d7, [pc, #404]	; 2d240 <powf+0x250>
   2d0ac:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d0b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d0b4:	dd76      	ble.n	2d1a4 <powf+0x1b4>
   2d0b6:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d0ba:	f001 bf69 	b.w	2ef90 <__math_oflowf>
   2d0be:	4298      	cmp	r0, r3
   2d0c0:	d92d      	bls.n	2d11e <powf+0x12e>
   2d0c2:	b952      	cbnz	r2, 2d0da <powf+0xea>
   2d0c4:	f481 0380 	eor.w	r3, r1, #4194304	; 0x400000
   2d0c8:	005b      	lsls	r3, r3, #1
   2d0ca:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
   2d0ce:	f240 80ae 	bls.w	2d22e <powf+0x23e>
   2d0d2:	ee30 0a24 	vadd.f32	s0, s0, s9
   2d0d6:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
   2d0da:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
   2d0de:	d105      	bne.n	2d0ec <powf+0xfc>
   2d0e0:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
   2d0e4:	0064      	lsls	r4, r4, #1
   2d0e6:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
   2d0ea:	e7f0      	b.n	2d0ce <powf+0xde>
   2d0ec:	004b      	lsls	r3, r1, #1
   2d0ee:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   2d0f2:	d8ee      	bhi.n	2d0d2 <powf+0xe2>
   2d0f4:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
   2d0f8:	d1eb      	bne.n	2d0d2 <powf+0xe2>
   2d0fa:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2d0fe:	f000 8096 	beq.w	2d22e <powf+0x23e>
   2d102:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2d106:	ea6f 0404 	mvn.w	r4, r4
   2d10a:	bf34      	ite	cc
   2d10c:	2300      	movcc	r3, #0
   2d10e:	2301      	movcs	r3, #1
   2d110:	0fe4      	lsrs	r4, r4, #31
   2d112:	42a3      	cmp	r3, r4
   2d114:	f040 808e 	bne.w	2d234 <powf+0x244>
   2d118:	ee24 0aa4 	vmul.f32	s0, s9, s9
   2d11c:	e7db      	b.n	2d0d6 <powf+0xe6>
   2d11e:	004d      	lsls	r5, r1, #1
   2d120:	1e6a      	subs	r2, r5, #1
   2d122:	429a      	cmp	r2, r3
   2d124:	d91b      	bls.n	2d15e <powf+0x16e>
   2d126:	2900      	cmp	r1, #0
   2d128:	ee20 0a00 	vmul.f32	s0, s0, s0
   2d12c:	da0e      	bge.n	2d14c <powf+0x15c>
   2d12e:	ee10 0a90 	vmov	r0, s1
   2d132:	f7ff ff45 	bl	2cfc0 <checkint>
   2d136:	2801      	cmp	r0, #1
   2d138:	d108      	bne.n	2d14c <powf+0x15c>
   2d13a:	eeb1 0a40 	vneg.f32	s0, s0
   2d13e:	b93d      	cbnz	r5, 2d150 <powf+0x160>
   2d140:	2c00      	cmp	r4, #0
   2d142:	dac8      	bge.n	2d0d6 <powf+0xe6>
   2d144:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d148:	f001 bf28 	b.w	2ef9c <__math_divzerof>
   2d14c:	2000      	movs	r0, #0
   2d14e:	e7f6      	b.n	2d13e <powf+0x14e>
   2d150:	2c00      	cmp	r4, #0
   2d152:	dac0      	bge.n	2d0d6 <powf+0xe6>
   2d154:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2d158:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2d15c:	e7bb      	b.n	2d0d6 <powf+0xe6>
   2d15e:	2900      	cmp	r1, #0
   2d160:	da1e      	bge.n	2d1a0 <powf+0x1b0>
   2d162:	ee10 0a90 	vmov	r0, s1
   2d166:	f7ff ff2b 	bl	2cfc0 <checkint>
   2d16a:	b918      	cbnz	r0, 2d174 <powf+0x184>
   2d16c:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d170:	f001 bf24 	b.w	2efbc <__math_invalidf>
   2d174:	2801      	cmp	r0, #1
   2d176:	bf0c      	ite	eq
   2d178:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
   2d17c:	2000      	movne	r0, #0
   2d17e:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2d182:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   2d186:	f4bf af47 	bcs.w	2d018 <powf+0x28>
   2d18a:	eddf 0a35 	vldr	s1, [pc, #212]	; 2d260 <powf+0x270>
   2d18e:	ee20 0a20 	vmul.f32	s0, s0, s1
   2d192:	ee10 3a10 	vmov	r3, s0
   2d196:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2d19a:	f1a3 6138 	sub.w	r1, r3, #192937984	; 0xb800000
   2d19e:	e73b      	b.n	2d018 <powf+0x28>
   2d1a0:	2000      	movs	r0, #0
   2d1a2:	e7ee      	b.n	2d182 <powf+0x192>
   2d1a4:	ed9f 7b28 	vldr	d7, [pc, #160]	; 2d248 <powf+0x258>
   2d1a8:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d1ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d1b0:	d803      	bhi.n	2d1ba <powf+0x1ca>
   2d1b2:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d1b6:	f001 bedf 	b.w	2ef78 <__math_uflowf>
   2d1ba:	ed9f 7b25 	vldr	d7, [pc, #148]	; 2d250 <powf+0x260>
   2d1be:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d1c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d1c6:	d503      	bpl.n	2d1d0 <powf+0x1e0>
   2d1c8:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
   2d1cc:	f001 beda 	b.w	2ef84 <__math_may_uflowf>
   2d1d0:	4924      	ldr	r1, [pc, #144]	; (2d264 <powf+0x274>)
   2d1d2:	ed91 7b40 	vldr	d7, [r1, #256]	; 0x100
   2d1d6:	ee30 6b07 	vadd.f64	d6, d0, d7
   2d1da:	ec55 4b16 	vmov	r4, r5, d6
   2d1de:	ee36 7b47 	vsub.f64	d7, d6, d7
   2d1e2:	f004 021f 	and.w	r2, r4, #31
   2d1e6:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   2d1ea:	ed91 6b46 	vldr	d6, [r1, #280]	; 0x118
   2d1ee:	ee30 0b47 	vsub.f64	d0, d0, d7
   2d1f2:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2d1f6:	e9d2 6700 	ldrd	r6, r7, [r2]
   2d1fa:	eea0 7b06 	vfma.f64	d7, d0, d6
   2d1fe:	1824      	adds	r4, r4, r0
   2d200:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
   2d204:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
   2d208:	2000      	movs	r0, #0
   2d20a:	1982      	adds	r2, r0, r6
   2d20c:	ea4f 31c4 	mov.w	r1, r4, lsl #15
   2d210:	eb41 0307 	adc.w	r3, r1, r7
   2d214:	eea0 6b05 	vfma.f64	d6, d0, d5
   2d218:	ee20 0b00 	vmul.f64	d0, d0, d0
   2d21c:	eea6 7b00 	vfma.f64	d7, d6, d0
   2d220:	ec43 2b16 	vmov	d6, r2, r3
   2d224:	ee27 0b06 	vmul.f64	d0, d7, d6
   2d228:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2d22c:	e753      	b.n	2d0d6 <powf+0xe6>
   2d22e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d232:	e750      	b.n	2d0d6 <powf+0xe6>
   2d234:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 2d268 <powf+0x278>
   2d238:	e74d      	b.n	2d0d6 <powf+0xe6>
   2d23a:	bf00      	nop
   2d23c:	f3af 8000 	nop.w
   2d240:	ffd1d571 	.word	0xffd1d571
   2d244:	405fffff 	.word	0x405fffff
   2d248:	00000000 	.word	0x00000000
   2d24c:	c062c000 	.word	0xc062c000
   2d250:	00000000 	.word	0x00000000
   2d254:	c062a000 	.word	0xc062a000
   2d258:	fefffffe 	.word	0xfefffffe
   2d25c:	000522f0 	.word	0x000522f0
   2d260:	4b000000 	.word	0x4b000000
   2d264:	00051f68 	.word	0x00051f68
   2d268:	00000000 	.word	0x00000000

0002d26c <tanf>:
   2d26c:	ee10 3a10 	vmov	r3, s0
   2d270:	b507      	push	{r0, r1, r2, lr}
   2d272:	4a10      	ldr	r2, [pc, #64]	; (2d2b4 <tanf+0x48>)
   2d274:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2d278:	4293      	cmp	r3, r2
   2d27a:	dc05      	bgt.n	2d288 <tanf+0x1c>
   2d27c:	eddf 0a0e 	vldr	s1, [pc, #56]	; 2d2b8 <tanf+0x4c>
   2d280:	2001      	movs	r0, #1
   2d282:	f001 fd7b 	bl	2ed7c <__kernel_tanf>
   2d286:	e004      	b.n	2d292 <tanf+0x26>
   2d288:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2d28c:	db04      	blt.n	2d298 <tanf+0x2c>
   2d28e:	ee30 0a40 	vsub.f32	s0, s0, s0
   2d292:	b003      	add	sp, #12
   2d294:	f85d fb04 	ldr.w	pc, [sp], #4
   2d298:	4668      	mov	r0, sp
   2d29a:	f001 f8ad 	bl	2e3f8 <__ieee754_rem_pio2f>
   2d29e:	0040      	lsls	r0, r0, #1
   2d2a0:	f000 0002 	and.w	r0, r0, #2
   2d2a4:	f1c0 0001 	rsb	r0, r0, #1
   2d2a8:	eddd 0a01 	vldr	s1, [sp, #4]
   2d2ac:	ed9d 0a00 	vldr	s0, [sp]
   2d2b0:	e7e7      	b.n	2d282 <tanf+0x16>
   2d2b2:	bf00      	nop
   2d2b4:	3f490fda 	.word	0x3f490fda
   2d2b8:	00000000 	.word	0x00000000

0002d2bc <tanhf>:
   2d2bc:	b510      	push	{r4, lr}
   2d2be:	ee10 4a10 	vmov	r4, s0
   2d2c2:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
   2d2c6:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2d2ca:	ed2d 8b02 	vpush	{d8}
   2d2ce:	eef0 7a40 	vmov.f32	s15, s0
   2d2d2:	db0c      	blt.n	2d2ee <tanhf+0x32>
   2d2d4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2d2d8:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2d2dc:	2c00      	cmp	r4, #0
   2d2de:	bfac      	ite	ge
   2d2e0:	ee30 0a07 	vaddge.f32	s0, s0, s14
   2d2e4:	ee30 0a47 	vsublt.f32	s0, s0, s14
   2d2e8:	ecbd 8b02 	vpop	{d8}
   2d2ec:	bd10      	pop	{r4, pc}
   2d2ee:	4a1b      	ldr	r2, [pc, #108]	; (2d35c <tanhf+0xa0>)
   2d2f0:	4293      	cmp	r3, r2
   2d2f2:	dc30      	bgt.n	2d356 <tanhf+0x9a>
   2d2f4:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
   2d2f8:	da06      	bge.n	2d308 <tanhf+0x4c>
   2d2fa:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d2fe:	ee37 0a80 	vadd.f32	s0, s15, s0
   2d302:	ee20 0a27 	vmul.f32	s0, s0, s15
   2d306:	e7ef      	b.n	2d2e8 <tanhf+0x2c>
   2d308:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   2d30c:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
   2d310:	db12      	blt.n	2d338 <tanhf+0x7c>
   2d312:	f7ff fd7d 	bl	2ce10 <fabsf>
   2d316:	ee30 0a00 	vadd.f32	s0, s0, s0
   2d31a:	f001 ff83 	bl	2f224 <expm1f>
   2d31e:	ee30 0a08 	vadd.f32	s0, s0, s16
   2d322:	eec8 7a00 	vdiv.f32	s15, s16, s0
   2d326:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d32a:	ee30 0a67 	vsub.f32	s0, s0, s15
   2d32e:	2c00      	cmp	r4, #0
   2d330:	bfb8      	it	lt
   2d332:	eeb1 0a40 	vneglt.f32	s0, s0
   2d336:	e7d7      	b.n	2d2e8 <tanhf+0x2c>
   2d338:	f7ff fd6a 	bl	2ce10 <fabsf>
   2d33c:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
   2d340:	ee20 0a27 	vmul.f32	s0, s0, s15
   2d344:	f001 ff6e 	bl	2f224 <expm1f>
   2d348:	ee70 7a08 	vadd.f32	s15, s0, s16
   2d34c:	eeb1 7a40 	vneg.f32	s14, s0
   2d350:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2d354:	e7eb      	b.n	2d32e <tanhf+0x72>
   2d356:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2d35a:	e7e8      	b.n	2d32e <tanhf+0x72>
   2d35c:	41afffff 	.word	0x41afffff

0002d360 <exp>:
   2d360:	b510      	push	{r4, lr}
   2d362:	ed2d 8b04 	vpush	{d8-d9}
   2d366:	eeb0 8b40 	vmov.f64	d8, d0
   2d36a:	4c33      	ldr	r4, [pc, #204]	; (2d438 <exp+0xd8>)
   2d36c:	b08a      	sub	sp, #40	; 0x28
   2d36e:	f000 fad3 	bl	2d918 <__ieee754_exp>
   2d372:	f994 3000 	ldrsb.w	r3, [r4]
   2d376:	eeb0 9b40 	vmov.f64	d9, d0
   2d37a:	3301      	adds	r3, #1
   2d37c:	d029      	beq.n	2d3d2 <exp+0x72>
   2d37e:	eeb0 0b48 	vmov.f64	d0, d8
   2d382:	f001 fe33 	bl	2efec <finite>
   2d386:	b320      	cbz	r0, 2d3d2 <exp+0x72>
   2d388:	ed9f 7b27 	vldr	d7, [pc, #156]	; 2d428 <exp+0xc8>
   2d38c:	eeb4 8bc7 	vcmpe.f64	d8, d7
   2d390:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d394:	dd2e      	ble.n	2d3f4 <exp+0x94>
   2d396:	2303      	movs	r3, #3
   2d398:	9300      	str	r3, [sp, #0]
   2d39a:	4b28      	ldr	r3, [pc, #160]	; (2d43c <exp+0xdc>)
   2d39c:	9301      	str	r3, [sp, #4]
   2d39e:	2300      	movs	r3, #0
   2d3a0:	9308      	str	r3, [sp, #32]
   2d3a2:	f994 3000 	ldrsb.w	r3, [r4]
   2d3a6:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d3aa:	ed8d 8b02 	vstr	d8, [sp, #8]
   2d3ae:	b9b3      	cbnz	r3, 2d3de <exp+0x7e>
   2d3b0:	4b23      	ldr	r3, [pc, #140]	; (2d440 <exp+0xe0>)
   2d3b2:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   2d3b6:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d3ba:	4668      	mov	r0, sp
   2d3bc:	f001 fe1e 	bl	2effc <matherr>
   2d3c0:	b198      	cbz	r0, 2d3ea <exp+0x8a>
   2d3c2:	9b08      	ldr	r3, [sp, #32]
   2d3c4:	b11b      	cbz	r3, 2d3ce <exp+0x6e>
   2d3c6:	f7ff faed 	bl	2c9a4 <__errno>
   2d3ca:	9b08      	ldr	r3, [sp, #32]
   2d3cc:	6003      	str	r3, [r0, #0]
   2d3ce:	ed9d 9b06 	vldr	d9, [sp, #24]
   2d3d2:	eeb0 0b49 	vmov.f64	d0, d9
   2d3d6:	b00a      	add	sp, #40	; 0x28
   2d3d8:	ecbd 8b04 	vpop	{d8-d9}
   2d3dc:	bd10      	pop	{r4, pc}
   2d3de:	4919      	ldr	r1, [pc, #100]	; (2d444 <exp+0xe4>)
   2d3e0:	2000      	movs	r0, #0
   2d3e2:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d3e6:	2b02      	cmp	r3, #2
   2d3e8:	d1e7      	bne.n	2d3ba <exp+0x5a>
   2d3ea:	f7ff fadb 	bl	2c9a4 <__errno>
   2d3ee:	2322      	movs	r3, #34	; 0x22
   2d3f0:	6003      	str	r3, [r0, #0]
   2d3f2:	e7e6      	b.n	2d3c2 <exp+0x62>
   2d3f4:	ed9f 7b0e 	vldr	d7, [pc, #56]	; 2d430 <exp+0xd0>
   2d3f8:	eeb4 8bc7 	vcmpe.f64	d8, d7
   2d3fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d400:	d5e7      	bpl.n	2d3d2 <exp+0x72>
   2d402:	2304      	movs	r3, #4
   2d404:	9300      	str	r3, [sp, #0]
   2d406:	4b0d      	ldr	r3, [pc, #52]	; (2d43c <exp+0xdc>)
   2d408:	9301      	str	r3, [sp, #4]
   2d40a:	2300      	movs	r3, #0
   2d40c:	9308      	str	r3, [sp, #32]
   2d40e:	2200      	movs	r2, #0
   2d410:	2300      	movs	r3, #0
   2d412:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d416:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d41a:	ed8d 8b02 	vstr	d8, [sp, #8]
   2d41e:	f994 3000 	ldrsb.w	r3, [r4]
   2d422:	e7e0      	b.n	2d3e6 <exp+0x86>
   2d424:	f3af 8000 	nop.w
   2d428:	fefa39ef 	.word	0xfefa39ef
   2d42c:	40862e42 	.word	0x40862e42
   2d430:	d52d3051 	.word	0xd52d3051
   2d434:	c0874910 	.word	0xc0874910
   2d438:	00062d2c 	.word	0x00062d2c
   2d43c:	00052418 	.word	0x00052418
   2d440:	47efffff 	.word	0x47efffff
   2d444:	7ff00000 	.word	0x7ff00000

0002d448 <pow>:
   2d448:	b570      	push	{r4, r5, r6, lr}
   2d44a:	ed2d 8b0a 	vpush	{d8-d12}
   2d44e:	eeb0 9b40 	vmov.f64	d9, d0
   2d452:	eeb0 8b41 	vmov.f64	d8, d1
   2d456:	4c8c      	ldr	r4, [pc, #560]	; (2d688 <pow+0x240>)
   2d458:	b08a      	sub	sp, #40	; 0x28
   2d45a:	f000 fb65 	bl	2db28 <__ieee754_pow>
   2d45e:	f994 3000 	ldrsb.w	r3, [r4]
   2d462:	eeb0 ab40 	vmov.f64	d10, d0
   2d466:	1c5a      	adds	r2, r3, #1
   2d468:	4626      	mov	r6, r4
   2d46a:	d04b      	beq.n	2d504 <pow+0xbc>
   2d46c:	eeb4 8b48 	vcmp.f64	d8, d8
   2d470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d474:	d646      	bvs.n	2d504 <pow+0xbc>
   2d476:	eeb4 9b49 	vcmp.f64	d9, d9
   2d47a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d47e:	d719      	bvc.n	2d4b4 <pow+0x6c>
   2d480:	eeb5 8b40 	vcmp.f64	d8, #0.0
   2d484:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d488:	d13c      	bne.n	2d504 <pow+0xbc>
   2d48a:	2201      	movs	r2, #1
   2d48c:	9200      	str	r2, [sp, #0]
   2d48e:	497f      	ldr	r1, [pc, #508]	; (2d68c <pow+0x244>)
   2d490:	4a7f      	ldr	r2, [pc, #508]	; (2d690 <pow+0x248>)
   2d492:	9201      	str	r2, [sp, #4]
   2d494:	2000      	movs	r0, #0
   2d496:	2200      	movs	r2, #0
   2d498:	2b02      	cmp	r3, #2
   2d49a:	9208      	str	r2, [sp, #32]
   2d49c:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d4a0:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d4a4:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d4a8:	d02a      	beq.n	2d500 <pow+0xb8>
   2d4aa:	4668      	mov	r0, sp
   2d4ac:	f001 fda6 	bl	2effc <matherr>
   2d4b0:	bb00      	cbnz	r0, 2d4f4 <pow+0xac>
   2d4b2:	e04e      	b.n	2d552 <pow+0x10a>
   2d4b4:	ed9f bb72 	vldr	d11, [pc, #456]	; 2d680 <pow+0x238>
   2d4b8:	eeb4 9b4b 	vcmp.f64	d9, d11
   2d4bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d4c0:	eeb0 cb4b 	vmov.f64	d12, d11
   2d4c4:	d14a      	bne.n	2d55c <pow+0x114>
   2d4c6:	eeb4 8b4b 	vcmp.f64	d8, d11
   2d4ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d4ce:	d11f      	bne.n	2d510 <pow+0xc8>
   2d4d0:	2201      	movs	r2, #1
   2d4d2:	9200      	str	r2, [sp, #0]
   2d4d4:	4a6e      	ldr	r2, [pc, #440]	; (2d690 <pow+0x248>)
   2d4d6:	9201      	str	r2, [sp, #4]
   2d4d8:	2200      	movs	r2, #0
   2d4da:	9208      	str	r2, [sp, #32]
   2d4dc:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d4e0:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d4e4:	ed8d bb06 	vstr	d11, [sp, #24]
   2d4e8:	2b00      	cmp	r3, #0
   2d4ea:	d0de      	beq.n	2d4aa <pow+0x62>
   2d4ec:	4b67      	ldr	r3, [pc, #412]	; (2d68c <pow+0x244>)
   2d4ee:	2200      	movs	r2, #0
   2d4f0:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d4f4:	9b08      	ldr	r3, [sp, #32]
   2d4f6:	b11b      	cbz	r3, 2d500 <pow+0xb8>
   2d4f8:	f7ff fa54 	bl	2c9a4 <__errno>
   2d4fc:	9b08      	ldr	r3, [sp, #32]
   2d4fe:	6003      	str	r3, [r0, #0]
   2d500:	ed9d ab06 	vldr	d10, [sp, #24]
   2d504:	eeb0 0b4a 	vmov.f64	d0, d10
   2d508:	b00a      	add	sp, #40	; 0x28
   2d50a:	ecbd 8b0a 	vpop	{d8-d12}
   2d50e:	bd70      	pop	{r4, r5, r6, pc}
   2d510:	eeb0 0b48 	vmov.f64	d0, d8
   2d514:	f001 fd6a 	bl	2efec <finite>
   2d518:	2800      	cmp	r0, #0
   2d51a:	d0f3      	beq.n	2d504 <pow+0xbc>
   2d51c:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
   2d520:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d524:	d5ee      	bpl.n	2d504 <pow+0xbc>
   2d526:	2301      	movs	r3, #1
   2d528:	9300      	str	r3, [sp, #0]
   2d52a:	4b59      	ldr	r3, [pc, #356]	; (2d690 <pow+0x248>)
   2d52c:	9301      	str	r3, [sp, #4]
   2d52e:	2300      	movs	r3, #0
   2d530:	9308      	str	r3, [sp, #32]
   2d532:	f994 3000 	ldrsb.w	r3, [r4]
   2d536:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d53a:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d53e:	b913      	cbnz	r3, 2d546 <pow+0xfe>
   2d540:	ed8d bb06 	vstr	d11, [sp, #24]
   2d544:	e7b1      	b.n	2d4aa <pow+0x62>
   2d546:	4953      	ldr	r1, [pc, #332]	; (2d694 <pow+0x24c>)
   2d548:	2000      	movs	r0, #0
   2d54a:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d54e:	2b02      	cmp	r3, #2
   2d550:	d1ab      	bne.n	2d4aa <pow+0x62>
   2d552:	f7ff fa27 	bl	2c9a4 <__errno>
   2d556:	2321      	movs	r3, #33	; 0x21
   2d558:	6003      	str	r3, [r0, #0]
   2d55a:	e7cb      	b.n	2d4f4 <pow+0xac>
   2d55c:	f001 fd46 	bl	2efec <finite>
   2d560:	4605      	mov	r5, r0
   2d562:	2800      	cmp	r0, #0
   2d564:	d164      	bne.n	2d630 <pow+0x1e8>
   2d566:	eeb0 0b49 	vmov.f64	d0, d9
   2d56a:	f001 fd3f 	bl	2efec <finite>
   2d56e:	2800      	cmp	r0, #0
   2d570:	d05e      	beq.n	2d630 <pow+0x1e8>
   2d572:	eeb0 0b48 	vmov.f64	d0, d8
   2d576:	f001 fd39 	bl	2efec <finite>
   2d57a:	2800      	cmp	r0, #0
   2d57c:	d058      	beq.n	2d630 <pow+0x1e8>
   2d57e:	eeb4 ab4a 	vcmp.f64	d10, d10
   2d582:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d586:	f994 3000 	ldrsb.w	r3, [r4]
   2d58a:	4a41      	ldr	r2, [pc, #260]	; (2d690 <pow+0x248>)
   2d58c:	d70e      	bvc.n	2d5ac <pow+0x164>
   2d58e:	2101      	movs	r1, #1
   2d590:	e9cd 1200 	strd	r1, r2, [sp]
   2d594:	9508      	str	r5, [sp, #32]
   2d596:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d59a:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d59e:	2b00      	cmp	r3, #0
   2d5a0:	d0ce      	beq.n	2d540 <pow+0xf8>
   2d5a2:	ee8b 7b0b 	vdiv.f64	d7, d11, d11
   2d5a6:	ed8d 7b06 	vstr	d7, [sp, #24]
   2d5aa:	e7d0      	b.n	2d54e <pow+0x106>
   2d5ac:	2103      	movs	r1, #3
   2d5ae:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d5b2:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
   2d5b6:	ee28 8b07 	vmul.f64	d8, d8, d7
   2d5ba:	e9cd 1200 	strd	r1, r2, [sp]
   2d5be:	9508      	str	r5, [sp, #32]
   2d5c0:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d5c4:	b9fb      	cbnz	r3, 2d606 <pow+0x1be>
   2d5c6:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
   2d5ca:	4b33      	ldr	r3, [pc, #204]	; (2d698 <pow+0x250>)
   2d5cc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   2d5d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d5d4:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d5d8:	d54b      	bpl.n	2d672 <pow+0x22a>
   2d5da:	eeb0 0b48 	vmov.f64	d0, d8
   2d5de:	f001 fd17 	bl	2f010 <rint>
   2d5e2:	eeb4 0b48 	vcmp.f64	d0, d8
   2d5e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d5ea:	d004      	beq.n	2d5f6 <pow+0x1ae>
   2d5ec:	4b2b      	ldr	r3, [pc, #172]	; (2d69c <pow+0x254>)
   2d5ee:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   2d5f2:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d5f6:	f996 3000 	ldrsb.w	r3, [r6]
   2d5fa:	2b02      	cmp	r3, #2
   2d5fc:	d139      	bne.n	2d672 <pow+0x22a>
   2d5fe:	f7ff f9d1 	bl	2c9a4 <__errno>
   2d602:	2322      	movs	r3, #34	; 0x22
   2d604:	e7a8      	b.n	2d558 <pow+0x110>
   2d606:	4b26      	ldr	r3, [pc, #152]	; (2d6a0 <pow+0x258>)
   2d608:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
   2d60c:	2200      	movs	r2, #0
   2d60e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d612:	e9cd 2306 	strd	r2, r3, [sp, #24]
   2d616:	d5ee      	bpl.n	2d5f6 <pow+0x1ae>
   2d618:	eeb0 0b48 	vmov.f64	d0, d8
   2d61c:	f001 fcf8 	bl	2f010 <rint>
   2d620:	eeb4 0b48 	vcmp.f64	d0, d8
   2d624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d628:	d0e5      	beq.n	2d5f6 <pow+0x1ae>
   2d62a:	2200      	movs	r2, #0
   2d62c:	4b19      	ldr	r3, [pc, #100]	; (2d694 <pow+0x24c>)
   2d62e:	e7e0      	b.n	2d5f2 <pow+0x1aa>
   2d630:	eeb5 ab40 	vcmp.f64	d10, #0.0
   2d634:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d638:	f47f af64 	bne.w	2d504 <pow+0xbc>
   2d63c:	eeb0 0b49 	vmov.f64	d0, d9
   2d640:	f001 fcd4 	bl	2efec <finite>
   2d644:	2800      	cmp	r0, #0
   2d646:	f43f af5d 	beq.w	2d504 <pow+0xbc>
   2d64a:	eeb0 0b48 	vmov.f64	d0, d8
   2d64e:	f001 fccd 	bl	2efec <finite>
   2d652:	2800      	cmp	r0, #0
   2d654:	f43f af56 	beq.w	2d504 <pow+0xbc>
   2d658:	2304      	movs	r3, #4
   2d65a:	9300      	str	r3, [sp, #0]
   2d65c:	4b0c      	ldr	r3, [pc, #48]	; (2d690 <pow+0x248>)
   2d65e:	9301      	str	r3, [sp, #4]
   2d660:	2300      	movs	r3, #0
   2d662:	9308      	str	r3, [sp, #32]
   2d664:	ed8d 9b02 	vstr	d9, [sp, #8]
   2d668:	ed8d 8b04 	vstr	d8, [sp, #16]
   2d66c:	ed8d cb06 	vstr	d12, [sp, #24]
   2d670:	e7c1      	b.n	2d5f6 <pow+0x1ae>
   2d672:	4668      	mov	r0, sp
   2d674:	f001 fcc2 	bl	2effc <matherr>
   2d678:	2800      	cmp	r0, #0
   2d67a:	f47f af3b 	bne.w	2d4f4 <pow+0xac>
   2d67e:	e7be      	b.n	2d5fe <pow+0x1b6>
	...
   2d688:	00062d2c 	.word	0x00062d2c
   2d68c:	3ff00000 	.word	0x3ff00000
   2d690:	0005241c 	.word	0x0005241c
   2d694:	fff00000 	.word	0xfff00000
   2d698:	47efffff 	.word	0x47efffff
   2d69c:	c7efffff 	.word	0xc7efffff
   2d6a0:	7ff00000 	.word	0x7ff00000
   2d6a4:	00000000 	.word	0x00000000

0002d6a8 <fmodf>:
   2d6a8:	b500      	push	{lr}
   2d6aa:	ed2d 8b02 	vpush	{d8}
   2d6ae:	b08b      	sub	sp, #44	; 0x2c
   2d6b0:	eeb0 8a40 	vmov.f32	s16, s0
   2d6b4:	eef0 8a60 	vmov.f32	s17, s1
   2d6b8:	f000 fdc0 	bl	2e23c <__ieee754_fmodf>
   2d6bc:	4b24      	ldr	r3, [pc, #144]	; (2d750 <fmodf+0xa8>)
   2d6be:	f993 3000 	ldrsb.w	r3, [r3]
   2d6c2:	1c5a      	adds	r2, r3, #1
   2d6c4:	d02d      	beq.n	2d722 <fmodf+0x7a>
   2d6c6:	eef4 8a68 	vcmp.f32	s17, s17
   2d6ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d6ce:	d628      	bvs.n	2d722 <fmodf+0x7a>
   2d6d0:	eeb4 8a48 	vcmp.f32	s16, s16
   2d6d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d6d8:	d623      	bvs.n	2d722 <fmodf+0x7a>
   2d6da:	eef5 8a40 	vcmp.f32	s17, #0.0
   2d6de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d6e2:	d11e      	bne.n	2d722 <fmodf+0x7a>
   2d6e4:	2201      	movs	r2, #1
   2d6e6:	9200      	str	r2, [sp, #0]
   2d6e8:	eeb7 0ac8 	vcvt.f64.f32	d0, s16
   2d6ec:	4a19      	ldr	r2, [pc, #100]	; (2d754 <fmodf+0xac>)
   2d6ee:	9201      	str	r2, [sp, #4]
   2d6f0:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
   2d6f4:	2200      	movs	r2, #0
   2d6f6:	9208      	str	r2, [sp, #32]
   2d6f8:	ed8d 0b02 	vstr	d0, [sp, #8]
   2d6fc:	ed8d 7b04 	vstr	d7, [sp, #16]
   2d700:	b9a3      	cbnz	r3, 2d72c <fmodf+0x84>
   2d702:	ed8d 0b06 	vstr	d0, [sp, #24]
   2d706:	4668      	mov	r0, sp
   2d708:	f001 fc78 	bl	2effc <matherr>
   2d70c:	b1b0      	cbz	r0, 2d73c <fmodf+0x94>
   2d70e:	9b08      	ldr	r3, [sp, #32]
   2d710:	b11b      	cbz	r3, 2d71a <fmodf+0x72>
   2d712:	f7ff f947 	bl	2c9a4 <__errno>
   2d716:	9b08      	ldr	r3, [sp, #32]
   2d718:	6003      	str	r3, [r0, #0]
   2d71a:	ed9d 0b06 	vldr	d0, [sp, #24]
   2d71e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2d722:	b00b      	add	sp, #44	; 0x2c
   2d724:	ecbd 8b02 	vpop	{d8}
   2d728:	f85d fb04 	ldr.w	pc, [sp], #4
   2d72c:	ed9f 7b06 	vldr	d7, [pc, #24]	; 2d748 <fmodf+0xa0>
   2d730:	2b02      	cmp	r3, #2
   2d732:	ee87 6b07 	vdiv.f64	d6, d7, d7
   2d736:	ed8d 6b06 	vstr	d6, [sp, #24]
   2d73a:	d1e4      	bne.n	2d706 <fmodf+0x5e>
   2d73c:	f7ff f932 	bl	2c9a4 <__errno>
   2d740:	2321      	movs	r3, #33	; 0x21
   2d742:	6003      	str	r3, [r0, #0]
   2d744:	e7e3      	b.n	2d70e <fmodf+0x66>
   2d746:	bf00      	nop
	...
   2d750:	00062d2c 	.word	0x00062d2c
   2d754:	00052420 	.word	0x00052420

0002d758 <log10f>:
   2d758:	b500      	push	{lr}
   2d75a:	ed2d 8b02 	vpush	{d8}
   2d75e:	b08b      	sub	sp, #44	; 0x2c
   2d760:	eeb0 8a40 	vmov.f32	s16, s0
   2d764:	f000 fdf2 	bl	2e34c <__ieee754_log10f>
   2d768:	4b2f      	ldr	r3, [pc, #188]	; (2d828 <log10f+0xd0>)
   2d76a:	f993 3000 	ldrsb.w	r3, [r3]
   2d76e:	1c5a      	adds	r2, r3, #1
   2d770:	d055      	beq.n	2d81e <log10f+0xc6>
   2d772:	eeb4 8a48 	vcmp.f32	s16, s16
   2d776:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d77a:	d650      	bvs.n	2d81e <log10f+0xc6>
   2d77c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   2d780:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d784:	d84b      	bhi.n	2d81e <log10f+0xc6>
   2d786:	4a29      	ldr	r2, [pc, #164]	; (2d82c <log10f+0xd4>)
   2d788:	9201      	str	r2, [sp, #4]
   2d78a:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
   2d78e:	2200      	movs	r2, #0
   2d790:	9208      	str	r2, [sp, #32]
   2d792:	ed8d 7b04 	vstr	d7, [sp, #16]
   2d796:	ed8d 7b02 	vstr	d7, [sp, #8]
   2d79a:	b993      	cbnz	r3, 2d7c2 <log10f+0x6a>
   2d79c:	4924      	ldr	r1, [pc, #144]	; (2d830 <log10f+0xd8>)
   2d79e:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2d7a2:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
   2d7a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d7aa:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d7ae:	d025      	beq.n	2d7fc <log10f+0xa4>
   2d7b0:	2201      	movs	r2, #1
   2d7b2:	2b02      	cmp	r3, #2
   2d7b4:	9200      	str	r2, [sp, #0]
   2d7b6:	d116      	bne.n	2d7e6 <log10f+0x8e>
   2d7b8:	f7ff f8f4 	bl	2c9a4 <__errno>
   2d7bc:	2321      	movs	r3, #33	; 0x21
   2d7be:	6003      	str	r3, [r0, #0]
   2d7c0:	e016      	b.n	2d7f0 <log10f+0x98>
   2d7c2:	491c      	ldr	r1, [pc, #112]	; (2d834 <log10f+0xdc>)
   2d7c4:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2d7c8:	2000      	movs	r0, #0
   2d7ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d7ce:	e9cd 0106 	strd	r0, r1, [sp, #24]
   2d7d2:	d1ed      	bne.n	2d7b0 <log10f+0x58>
   2d7d4:	2202      	movs	r2, #2
   2d7d6:	4293      	cmp	r3, r2
   2d7d8:	9200      	str	r2, [sp, #0]
   2d7da:	d111      	bne.n	2d800 <log10f+0xa8>
   2d7dc:	f7ff f8e2 	bl	2c9a4 <__errno>
   2d7e0:	2322      	movs	r3, #34	; 0x22
   2d7e2:	6003      	str	r3, [r0, #0]
   2d7e4:	e011      	b.n	2d80a <log10f+0xb2>
   2d7e6:	4668      	mov	r0, sp
   2d7e8:	f001 fc08 	bl	2effc <matherr>
   2d7ec:	2800      	cmp	r0, #0
   2d7ee:	d0e3      	beq.n	2d7b8 <log10f+0x60>
   2d7f0:	4811      	ldr	r0, [pc, #68]	; (2d838 <log10f+0xe0>)
   2d7f2:	f001 fc05 	bl	2f000 <nan>
   2d7f6:	ed8d 0b06 	vstr	d0, [sp, #24]
   2d7fa:	e006      	b.n	2d80a <log10f+0xb2>
   2d7fc:	2302      	movs	r3, #2
   2d7fe:	9300      	str	r3, [sp, #0]
   2d800:	4668      	mov	r0, sp
   2d802:	f001 fbfb 	bl	2effc <matherr>
   2d806:	2800      	cmp	r0, #0
   2d808:	d0e8      	beq.n	2d7dc <log10f+0x84>
   2d80a:	9b08      	ldr	r3, [sp, #32]
   2d80c:	b11b      	cbz	r3, 2d816 <log10f+0xbe>
   2d80e:	f7ff f8c9 	bl	2c9a4 <__errno>
   2d812:	9b08      	ldr	r3, [sp, #32]
   2d814:	6003      	str	r3, [r0, #0]
   2d816:	ed9d 0b06 	vldr	d0, [sp, #24]
   2d81a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
   2d81e:	b00b      	add	sp, #44	; 0x2c
   2d820:	ecbd 8b02 	vpop	{d8}
   2d824:	f85d fb04 	ldr.w	pc, [sp], #4
   2d828:	00062d2c 	.word	0x00062d2c
   2d82c:	00052426 	.word	0x00052426
   2d830:	c7efffff 	.word	0xc7efffff
   2d834:	fff00000 	.word	0xfff00000
   2d838:	0005242c 	.word	0x0005242c
   2d83c:	00000000 	.word	0x00000000

0002d840 <sinhf>:
   2d840:	b530      	push	{r4, r5, lr}
   2d842:	ed2d 8b02 	vpush	{d8}
   2d846:	4c32      	ldr	r4, [pc, #200]	; (2d910 <sinhf+0xd0>)
   2d848:	b08b      	sub	sp, #44	; 0x2c
   2d84a:	eef0 8a40 	vmov.f32	s17, s0
   2d84e:	f000 feff 	bl	2e650 <__ieee754_sinhf>
   2d852:	f994 3000 	ldrsb.w	r3, [r4]
   2d856:	3301      	adds	r3, #1
   2d858:	eeb0 8a40 	vmov.f32	s16, s0
   2d85c:	d030      	beq.n	2d8c0 <sinhf+0x80>
   2d85e:	f001 fe0b 	bl	2f478 <finitef>
   2d862:	4605      	mov	r5, r0
   2d864:	bb60      	cbnz	r0, 2d8c0 <sinhf+0x80>
   2d866:	eeb0 0a68 	vmov.f32	s0, s17
   2d86a:	f001 fe05 	bl	2f478 <finitef>
   2d86e:	b338      	cbz	r0, 2d8c0 <sinhf+0x80>
   2d870:	2303      	movs	r3, #3
   2d872:	9300      	str	r3, [sp, #0]
   2d874:	4b27      	ldr	r3, [pc, #156]	; (2d914 <sinhf+0xd4>)
   2d876:	9301      	str	r3, [sp, #4]
   2d878:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
   2d87c:	f994 3000 	ldrsb.w	r3, [r4]
   2d880:	9508      	str	r5, [sp, #32]
   2d882:	ed8d 7b04 	vstr	d7, [sp, #16]
   2d886:	ed8d 7b02 	vstr	d7, [sp, #8]
   2d88a:	eef5 8ac0 	vcmpe.f32	s17, #0.0
   2d88e:	b9eb      	cbnz	r3, 2d8cc <sinhf+0x8c>
   2d890:	ed9f 7b17 	vldr	d7, [pc, #92]	; 2d8f0 <sinhf+0xb0>
   2d894:	ed9f 6b18 	vldr	d6, [pc, #96]	; 2d8f8 <sinhf+0xb8>
   2d898:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d89c:	fe37 7b06 	vselgt.f64	d7, d7, d6
   2d8a0:	ed8d 7b06 	vstr	d7, [sp, #24]
   2d8a4:	4668      	mov	r0, sp
   2d8a6:	f001 fba9 	bl	2effc <matherr>
   2d8aa:	b1d8      	cbz	r0, 2d8e4 <sinhf+0xa4>
   2d8ac:	9b08      	ldr	r3, [sp, #32]
   2d8ae:	b11b      	cbz	r3, 2d8b8 <sinhf+0x78>
   2d8b0:	f7ff f878 	bl	2c9a4 <__errno>
   2d8b4:	9b08      	ldr	r3, [sp, #32]
   2d8b6:	6003      	str	r3, [r0, #0]
   2d8b8:	ed9d 8b06 	vldr	d8, [sp, #24]
   2d8bc:	eeb7 8bc8 	vcvt.f32.f64	s16, d8
   2d8c0:	eeb0 0a48 	vmov.f32	s0, s16
   2d8c4:	b00b      	add	sp, #44	; 0x2c
   2d8c6:	ecbd 8b02 	vpop	{d8}
   2d8ca:	bd30      	pop	{r4, r5, pc}
   2d8cc:	ed9f 7b0c 	vldr	d7, [pc, #48]	; 2d900 <sinhf+0xc0>
   2d8d0:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 2d908 <sinhf+0xc8>
   2d8d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d8d8:	fe37 7b06 	vselgt.f64	d7, d7, d6
   2d8dc:	2b02      	cmp	r3, #2
   2d8de:	ed8d 7b06 	vstr	d7, [sp, #24]
   2d8e2:	d1df      	bne.n	2d8a4 <sinhf+0x64>
   2d8e4:	f7ff f85e 	bl	2c9a4 <__errno>
   2d8e8:	2322      	movs	r3, #34	; 0x22
   2d8ea:	6003      	str	r3, [r0, #0]
   2d8ec:	e7de      	b.n	2d8ac <sinhf+0x6c>
   2d8ee:	bf00      	nop
   2d8f0:	e0000000 	.word	0xe0000000
   2d8f4:	47efffff 	.word	0x47efffff
   2d8f8:	e0000000 	.word	0xe0000000
   2d8fc:	c7efffff 	.word	0xc7efffff
   2d900:	00000000 	.word	0x00000000
   2d904:	7ff00000 	.word	0x7ff00000
   2d908:	00000000 	.word	0x00000000
   2d90c:	fff00000 	.word	0xfff00000
   2d910:	00062d2c 	.word	0x00062d2c
   2d914:	0005242d 	.word	0x0005242d

0002d918 <__ieee754_exp>:
   2d918:	ee10 1a90 	vmov	r1, s1
   2d91c:	4b7a      	ldr	r3, [pc, #488]	; (2db08 <__ieee754_exp+0x1f0>)
   2d91e:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   2d922:	429a      	cmp	r2, r3
   2d924:	b082      	sub	sp, #8
   2d926:	ea4f 70d1 	mov.w	r0, r1, lsr #31
   2d92a:	d928      	bls.n	2d97e <__ieee754_exp+0x66>
   2d92c:	4b77      	ldr	r3, [pc, #476]	; (2db0c <__ieee754_exp+0x1f4>)
   2d92e:	429a      	cmp	r2, r3
   2d930:	d90f      	bls.n	2d952 <__ieee754_exp+0x3a>
   2d932:	ee10 3a10 	vmov	r3, s0
   2d936:	f3c1 0113 	ubfx	r1, r1, #0, #20
   2d93a:	430b      	orrs	r3, r1
   2d93c:	d003      	beq.n	2d946 <__ieee754_exp+0x2e>
   2d93e:	ee30 0b00 	vadd.f64	d0, d0, d0
   2d942:	b002      	add	sp, #8
   2d944:	4770      	bx	lr
   2d946:	ed9f 7b56 	vldr	d7, [pc, #344]	; 2daa0 <__ieee754_exp+0x188>
   2d94a:	2800      	cmp	r0, #0
   2d94c:	fe00 0b07 	vseleq.f64	d0, d0, d7
   2d950:	e7f7      	b.n	2d942 <__ieee754_exp+0x2a>
   2d952:	ed9f 7b55 	vldr	d7, [pc, #340]	; 2daa8 <__ieee754_exp+0x190>
   2d956:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d95a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d95e:	dd04      	ble.n	2d96a <__ieee754_exp+0x52>
   2d960:	ed9f 0b53 	vldr	d0, [pc, #332]	; 2dab0 <__ieee754_exp+0x198>
   2d964:	ee20 0b00 	vmul.f64	d0, d0, d0
   2d968:	e7eb      	b.n	2d942 <__ieee754_exp+0x2a>
   2d96a:	ed9f 7b53 	vldr	d7, [pc, #332]	; 2dab8 <__ieee754_exp+0x1a0>
   2d96e:	eeb4 0bc7 	vcmpe.f64	d0, d7
   2d972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2d976:	d505      	bpl.n	2d984 <__ieee754_exp+0x6c>
   2d978:	ed9f 0b49 	vldr	d0, [pc, #292]	; 2daa0 <__ieee754_exp+0x188>
   2d97c:	e7e1      	b.n	2d942 <__ieee754_exp+0x2a>
   2d97e:	4b64      	ldr	r3, [pc, #400]	; (2db10 <__ieee754_exp+0x1f8>)
   2d980:	429a      	cmp	r2, r3
   2d982:	d956      	bls.n	2da32 <__ieee754_exp+0x11a>
   2d984:	4b63      	ldr	r3, [pc, #396]	; (2db14 <__ieee754_exp+0x1fc>)
   2d986:	429a      	cmp	r2, r3
   2d988:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   2d98c:	d838      	bhi.n	2da00 <__ieee754_exp+0xe8>
   2d98e:	4b62      	ldr	r3, [pc, #392]	; (2db18 <__ieee754_exp+0x200>)
   2d990:	4413      	add	r3, r2
   2d992:	ed93 6b00 	vldr	d6, [r3]
   2d996:	4b61      	ldr	r3, [pc, #388]	; (2db1c <__ieee754_exp+0x204>)
   2d998:	ee30 6b46 	vsub.f64	d6, d0, d6
   2d99c:	4413      	add	r3, r2
   2d99e:	ed93 7b00 	vldr	d7, [r3]
   2d9a2:	f1c0 0301 	rsb	r3, r0, #1
   2d9a6:	1a1b      	subs	r3, r3, r0
   2d9a8:	ee36 0b47 	vsub.f64	d0, d6, d7
   2d9ac:	ed9f 4b44 	vldr	d4, [pc, #272]	; 2dac0 <__ieee754_exp+0x1a8>
   2d9b0:	ee20 5b00 	vmul.f64	d5, d0, d0
   2d9b4:	ed9f 3b44 	vldr	d3, [pc, #272]	; 2dac8 <__ieee754_exp+0x1b0>
   2d9b8:	eea5 3b04 	vfma.f64	d3, d5, d4
   2d9bc:	ed9f 4b44 	vldr	d4, [pc, #272]	; 2dad0 <__ieee754_exp+0x1b8>
   2d9c0:	eea3 4b05 	vfma.f64	d4, d3, d5
   2d9c4:	ed9f 3b44 	vldr	d3, [pc, #272]	; 2dad8 <__ieee754_exp+0x1c0>
   2d9c8:	eea4 3b05 	vfma.f64	d3, d4, d5
   2d9cc:	ed9f 4b44 	vldr	d4, [pc, #272]	; 2dae0 <__ieee754_exp+0x1c8>
   2d9d0:	eea3 4b05 	vfma.f64	d4, d3, d5
   2d9d4:	eeb0 3b40 	vmov.f64	d3, d0
   2d9d8:	eea4 3b45 	vfms.f64	d3, d4, d5
   2d9dc:	eeb0 4b00 	vmov.f64	d4, #0	; 0x40000000  2.0
   2d9e0:	eeb0 5b43 	vmov.f64	d5, d3
   2d9e4:	ee20 2b03 	vmul.f64	d2, d0, d3
   2d9e8:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
   2d9ec:	bba3      	cbnz	r3, 2da58 <__ieee754_exp+0x140>
   2d9ee:	ee35 5b44 	vsub.f64	d5, d5, d4
   2d9f2:	ee82 7b05 	vdiv.f64	d7, d2, d5
   2d9f6:	ee37 0b40 	vsub.f64	d0, d7, d0
   2d9fa:	ee33 0b40 	vsub.f64	d0, d3, d0
   2d9fe:	e7a0      	b.n	2d942 <__ieee754_exp+0x2a>
   2da00:	4b47      	ldr	r3, [pc, #284]	; (2db20 <__ieee754_exp+0x208>)
   2da02:	4413      	add	r3, r2
   2da04:	ed93 7b00 	vldr	d7, [r3]
   2da08:	ed9f 6b37 	vldr	d6, [pc, #220]	; 2dae8 <__ieee754_exp+0x1d0>
   2da0c:	ed9f 5b38 	vldr	d5, [pc, #224]	; 2daf0 <__ieee754_exp+0x1d8>
   2da10:	eea0 7b06 	vfma.f64	d7, d0, d6
   2da14:	ed9f 6b38 	vldr	d6, [pc, #224]	; 2daf8 <__ieee754_exp+0x1e0>
   2da18:	eefd 7bc7 	vcvt.s32.f64	s15, d7
   2da1c:	ee17 3a90 	vmov	r3, s15
   2da20:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2da24:	eea7 0b46 	vfms.f64	d0, d7, d6
   2da28:	ee27 7b05 	vmul.f64	d7, d7, d5
   2da2c:	eeb0 6b40 	vmov.f64	d6, d0
   2da30:	e7ba      	b.n	2d9a8 <__ieee754_exp+0x90>
   2da32:	4b3c      	ldr	r3, [pc, #240]	; (2db24 <__ieee754_exp+0x20c>)
   2da34:	429a      	cmp	r2, r3
   2da36:	d80d      	bhi.n	2da54 <__ieee754_exp+0x13c>
   2da38:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
   2da3c:	ed9f 5b1c 	vldr	d5, [pc, #112]	; 2dab0 <__ieee754_exp+0x198>
   2da40:	ee30 5b05 	vadd.f64	d5, d0, d5
   2da44:	eeb4 5bc4 	vcmpe.f64	d5, d4
   2da48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2da4c:	dd02      	ble.n	2da54 <__ieee754_exp+0x13c>
   2da4e:	ee30 0b04 	vadd.f64	d0, d0, d4
   2da52:	e776      	b.n	2d942 <__ieee754_exp+0x2a>
   2da54:	2300      	movs	r3, #0
   2da56:	e7a9      	b.n	2d9ac <__ieee754_exp+0x94>
   2da58:	f46f 717f 	mvn.w	r1, #1020	; 0x3fc
   2da5c:	ee34 5b45 	vsub.f64	d5, d4, d5
   2da60:	428b      	cmp	r3, r1
   2da62:	ee82 4b05 	vdiv.f64	d4, d2, d5
   2da66:	ee37 7b44 	vsub.f64	d7, d7, d4
   2da6a:	ee37 7b46 	vsub.f64	d7, d7, d6
   2da6e:	ee33 7b47 	vsub.f64	d7, d3, d7
   2da72:	ed8d 7b00 	vstr	d7, [sp]
   2da76:	9a01      	ldr	r2, [sp, #4]
   2da78:	e9dd 0100 	ldrd	r0, r1, [sp]
   2da7c:	db04      	blt.n	2da88 <__ieee754_exp+0x170>
   2da7e:	eb02 5103 	add.w	r1, r2, r3, lsl #20
   2da82:	ec41 0b10 	vmov	d0, r0, r1
   2da86:	e75c      	b.n	2d942 <__ieee754_exp+0x2a>
   2da88:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
   2da8c:	eb02 5103 	add.w	r1, r2, r3, lsl #20
   2da90:	ed9f 7b1b 	vldr	d7, [pc, #108]	; 2db00 <__ieee754_exp+0x1e8>
   2da94:	ec41 0b10 	vmov	d0, r0, r1
   2da98:	ee20 0b07 	vmul.f64	d0, d0, d7
   2da9c:	e751      	b.n	2d942 <__ieee754_exp+0x2a>
   2da9e:	bf00      	nop
	...
   2daa8:	fefa39ef 	.word	0xfefa39ef
   2daac:	40862e42 	.word	0x40862e42
   2dab0:	8800759c 	.word	0x8800759c
   2dab4:	7e37e43c 	.word	0x7e37e43c
   2dab8:	d52d3051 	.word	0xd52d3051
   2dabc:	c0874910 	.word	0xc0874910
   2dac0:	72bea4d0 	.word	0x72bea4d0
   2dac4:	3e663769 	.word	0x3e663769
   2dac8:	c5d26bf1 	.word	0xc5d26bf1
   2dacc:	bebbbd41 	.word	0xbebbbd41
   2dad0:	af25de2c 	.word	0xaf25de2c
   2dad4:	3f11566a 	.word	0x3f11566a
   2dad8:	16bebd93 	.word	0x16bebd93
   2dadc:	bf66c16c 	.word	0xbf66c16c
   2dae0:	5555553e 	.word	0x5555553e
   2dae4:	3fc55555 	.word	0x3fc55555
   2dae8:	652b82fe 	.word	0x652b82fe
   2daec:	3ff71547 	.word	0x3ff71547
   2daf0:	35793c76 	.word	0x35793c76
   2daf4:	3dea39ef 	.word	0x3dea39ef
   2daf8:	fee00000 	.word	0xfee00000
   2dafc:	3fe62e42 	.word	0x3fe62e42
   2db00:	00000000 	.word	0x00000000
   2db04:	01700000 	.word	0x01700000
   2db08:	40862e41 	.word	0x40862e41
   2db0c:	7fefffff 	.word	0x7fefffff
   2db10:	3fd62e42 	.word	0x3fd62e42
   2db14:	3ff0a2b1 	.word	0x3ff0a2b1
   2db18:	00052448 	.word	0x00052448
   2db1c:	00052458 	.word	0x00052458
   2db20:	00052438 	.word	0x00052438
   2db24:	3e2fffff 	.word	0x3e2fffff

0002db28 <__ieee754_pow>:
   2db28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2db2c:	ec57 6b11 	vmov	r6, r7, d1
   2db30:	ed2d 8b02 	vpush	{d8}
   2db34:	eeb0 8b40 	vmov.f64	d8, d0
   2db38:	f027 4800 	bic.w	r8, r7, #2147483648	; 0x80000000
   2db3c:	ea58 0306 	orrs.w	r3, r8, r6
   2db40:	b085      	sub	sp, #20
   2db42:	46b9      	mov	r9, r7
   2db44:	ee11 2a10 	vmov	r2, s2
   2db48:	f000 8306 	beq.w	2e158 <__ieee754_pow+0x630>
   2db4c:	ee18 aa90 	vmov	sl, s17
   2db50:	4bb9      	ldr	r3, [pc, #740]	; (2de38 <__ieee754_pow+0x310>)
   2db52:	f02a 4400 	bic.w	r4, sl, #2147483648	; 0x80000000
   2db56:	429c      	cmp	r4, r3
   2db58:	ee10 ba10 	vmov	fp, s0
   2db5c:	dc0b      	bgt.n	2db76 <__ieee754_pow+0x4e>
   2db5e:	d105      	bne.n	2db6c <__ieee754_pow+0x44>
   2db60:	f1bb 0f00 	cmp.w	fp, #0
   2db64:	d107      	bne.n	2db76 <__ieee754_pow+0x4e>
   2db66:	45a0      	cmp	r8, r4
   2db68:	dc0d      	bgt.n	2db86 <__ieee754_pow+0x5e>
   2db6a:	e001      	b.n	2db70 <__ieee754_pow+0x48>
   2db6c:	4598      	cmp	r8, r3
   2db6e:	dc02      	bgt.n	2db76 <__ieee754_pow+0x4e>
   2db70:	4598      	cmp	r8, r3
   2db72:	d110      	bne.n	2db96 <__ieee754_pow+0x6e>
   2db74:	b17a      	cbz	r2, 2db96 <__ieee754_pow+0x6e>
   2db76:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
   2db7a:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   2db7e:	ea54 030b 	orrs.w	r3, r4, fp
   2db82:	f000 82e9 	beq.w	2e158 <__ieee754_pow+0x630>
   2db86:	48ad      	ldr	r0, [pc, #692]	; (2de3c <__ieee754_pow+0x314>)
   2db88:	b005      	add	sp, #20
   2db8a:	ecbd 8b02 	vpop	{d8}
   2db8e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2db92:	f001 ba35 	b.w	2f000 <nan>
   2db96:	f1ba 0f00 	cmp.w	sl, #0
   2db9a:	da4e      	bge.n	2dc3a <__ieee754_pow+0x112>
   2db9c:	4ba8      	ldr	r3, [pc, #672]	; (2de40 <__ieee754_pow+0x318>)
   2db9e:	4598      	cmp	r8, r3
   2dba0:	dc49      	bgt.n	2dc36 <__ieee754_pow+0x10e>
   2dba2:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
   2dba6:	4598      	cmp	r8, r3
   2dba8:	dd47      	ble.n	2dc3a <__ieee754_pow+0x112>
   2dbaa:	ea4f 5328 	mov.w	r3, r8, asr #20
   2dbae:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   2dbb2:	2b14      	cmp	r3, #20
   2dbb4:	dd24      	ble.n	2dc00 <__ieee754_pow+0xd8>
   2dbb6:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
   2dbba:	fa22 f503 	lsr.w	r5, r2, r3
   2dbbe:	fa05 f303 	lsl.w	r3, r5, r3
   2dbc2:	4293      	cmp	r3, r2
   2dbc4:	d139      	bne.n	2dc3a <__ieee754_pow+0x112>
   2dbc6:	f005 0501 	and.w	r5, r5, #1
   2dbca:	f1c5 0502 	rsb	r5, r5, #2
   2dbce:	2a00      	cmp	r2, #0
   2dbd0:	d15a      	bne.n	2dc88 <__ieee754_pow+0x160>
   2dbd2:	4b99      	ldr	r3, [pc, #612]	; (2de38 <__ieee754_pow+0x310>)
   2dbd4:	4598      	cmp	r8, r3
   2dbd6:	d122      	bne.n	2dc1e <__ieee754_pow+0xf6>
   2dbd8:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
   2dbdc:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
   2dbe0:	ea53 030b 	orrs.w	r3, r3, fp
   2dbe4:	f000 82b8 	beq.w	2e158 <__ieee754_pow+0x630>
   2dbe8:	4b96      	ldr	r3, [pc, #600]	; (2de44 <__ieee754_pow+0x31c>)
   2dbea:	429c      	cmp	r4, r3
   2dbec:	dd27      	ble.n	2dc3e <__ieee754_pow+0x116>
   2dbee:	f1b9 0f00 	cmp.w	r9, #0
   2dbf2:	f280 82b4 	bge.w	2e15e <__ieee754_pow+0x636>
   2dbf6:	ed9f 7b84 	vldr	d7, [pc, #528]	; 2de08 <__ieee754_pow+0x2e0>
   2dbfa:	ed8d 7b00 	vstr	d7, [sp]
   2dbfe:	e026      	b.n	2dc4e <__ieee754_pow+0x126>
   2dc00:	2a00      	cmp	r2, #0
   2dc02:	d140      	bne.n	2dc86 <__ieee754_pow+0x15e>
   2dc04:	f1c3 0314 	rsb	r3, r3, #20
   2dc08:	fa48 f503 	asr.w	r5, r8, r3
   2dc0c:	fa05 f303 	lsl.w	r3, r5, r3
   2dc10:	4543      	cmp	r3, r8
   2dc12:	f040 82aa 	bne.w	2e16a <__ieee754_pow+0x642>
   2dc16:	f005 0501 	and.w	r5, r5, #1
   2dc1a:	f1c5 0502 	rsb	r5, r5, #2
   2dc1e:	4b8a      	ldr	r3, [pc, #552]	; (2de48 <__ieee754_pow+0x320>)
   2dc20:	4598      	cmp	r8, r3
   2dc22:	d11b      	bne.n	2dc5c <__ieee754_pow+0x134>
   2dc24:	f1b9 0f00 	cmp.w	r9, #0
   2dc28:	f280 829c 	bge.w	2e164 <__ieee754_pow+0x63c>
   2dc2c:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2dc30:	ee87 7b08 	vdiv.f64	d7, d7, d8
   2dc34:	e7e1      	b.n	2dbfa <__ieee754_pow+0xd2>
   2dc36:	2502      	movs	r5, #2
   2dc38:	e7c9      	b.n	2dbce <__ieee754_pow+0xa6>
   2dc3a:	2500      	movs	r5, #0
   2dc3c:	e7c7      	b.n	2dbce <__ieee754_pow+0xa6>
   2dc3e:	f1b9 0f00 	cmp.w	r9, #0
   2dc42:	dad8      	bge.n	2dbf6 <__ieee754_pow+0xce>
   2dc44:	f087 4400 	eor.w	r4, r7, #2147483648	; 0x80000000
   2dc48:	4633      	mov	r3, r6
   2dc4a:	e9cd 3400 	strd	r3, r4, [sp]
   2dc4e:	ed9d 0b00 	vldr	d0, [sp]
   2dc52:	b005      	add	sp, #20
   2dc54:	ecbd 8b02 	vpop	{d8}
   2dc58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2dc5c:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
   2dc60:	d102      	bne.n	2dc68 <__ieee754_pow+0x140>
   2dc62:	ee28 7b08 	vmul.f64	d7, d8, d8
   2dc66:	e7c8      	b.n	2dbfa <__ieee754_pow+0xd2>
   2dc68:	4b78      	ldr	r3, [pc, #480]	; (2de4c <__ieee754_pow+0x324>)
   2dc6a:	4599      	cmp	r9, r3
   2dc6c:	d10c      	bne.n	2dc88 <__ieee754_pow+0x160>
   2dc6e:	f1ba 0f00 	cmp.w	sl, #0
   2dc72:	db09      	blt.n	2dc88 <__ieee754_pow+0x160>
   2dc74:	eeb0 0b48 	vmov.f64	d0, d8
   2dc78:	b005      	add	sp, #20
   2dc7a:	ecbd 8b02 	vpop	{d8}
   2dc7e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2dc82:	f000 bad7 	b.w	2e234 <__ieee754_sqrt>
   2dc86:	2500      	movs	r5, #0
   2dc88:	eeb0 0b48 	vmov.f64	d0, d8
   2dc8c:	f001 f9a5 	bl	2efda <fabs>
   2dc90:	ed8d 0b00 	vstr	d0, [sp]
   2dc94:	f1bb 0f00 	cmp.w	fp, #0
   2dc98:	d128      	bne.n	2dcec <__ieee754_pow+0x1c4>
   2dc9a:	b124      	cbz	r4, 2dca6 <__ieee754_pow+0x17e>
   2dc9c:	4b6a      	ldr	r3, [pc, #424]	; (2de48 <__ieee754_pow+0x320>)
   2dc9e:	f02a 4240 	bic.w	r2, sl, #3221225472	; 0xc0000000
   2dca2:	429a      	cmp	r2, r3
   2dca4:	d122      	bne.n	2dcec <__ieee754_pow+0x1c4>
   2dca6:	f1b9 0f00 	cmp.w	r9, #0
   2dcaa:	da07      	bge.n	2dcbc <__ieee754_pow+0x194>
   2dcac:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2dcb0:	ed9d 6b00 	vldr	d6, [sp]
   2dcb4:	ee87 7b06 	vdiv.f64	d7, d7, d6
   2dcb8:	ed8d 7b00 	vstr	d7, [sp]
   2dcbc:	f1ba 0f00 	cmp.w	sl, #0
   2dcc0:	dac5      	bge.n	2dc4e <__ieee754_pow+0x126>
   2dcc2:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
   2dcc6:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   2dcca:	ea54 0305 	orrs.w	r3, r4, r5
   2dcce:	d106      	bne.n	2dcde <__ieee754_pow+0x1b6>
   2dcd0:	ed9d 7b00 	vldr	d7, [sp]
   2dcd4:	ee37 7b47 	vsub.f64	d7, d7, d7
   2dcd8:	ee87 7b07 	vdiv.f64	d7, d7, d7
   2dcdc:	e78d      	b.n	2dbfa <__ieee754_pow+0xd2>
   2dcde:	2d01      	cmp	r5, #1
   2dce0:	d1b5      	bne.n	2dc4e <__ieee754_pow+0x126>
   2dce2:	ed9d 7b00 	vldr	d7, [sp]
   2dce6:	eeb1 7b47 	vneg.f64	d7, d7
   2dcea:	e786      	b.n	2dbfa <__ieee754_pow+0xd2>
   2dcec:	ea4f 7ada 	mov.w	sl, sl, lsr #31
   2dcf0:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   2dcf4:	ea55 030a 	orrs.w	r3, r5, sl
   2dcf8:	d104      	bne.n	2dd04 <__ieee754_pow+0x1dc>
   2dcfa:	ee38 8b48 	vsub.f64	d8, d8, d8
   2dcfe:	ee88 7b08 	vdiv.f64	d7, d8, d8
   2dd02:	e77a      	b.n	2dbfa <__ieee754_pow+0xd2>
   2dd04:	4b52      	ldr	r3, [pc, #328]	; (2de50 <__ieee754_pow+0x328>)
   2dd06:	4598      	cmp	r8, r3
   2dd08:	f340 80a8 	ble.w	2de5c <__ieee754_pow+0x334>
   2dd0c:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
   2dd10:	4598      	cmp	r8, r3
   2dd12:	dd0b      	ble.n	2dd2c <__ieee754_pow+0x204>
   2dd14:	4b4b      	ldr	r3, [pc, #300]	; (2de44 <__ieee754_pow+0x31c>)
   2dd16:	429c      	cmp	r4, r3
   2dd18:	dc0e      	bgt.n	2dd38 <__ieee754_pow+0x210>
   2dd1a:	f1b9 0f00 	cmp.w	r9, #0
   2dd1e:	f6bf af6a 	bge.w	2dbf6 <__ieee754_pow+0xce>
   2dd22:	ed9f 7b3b 	vldr	d7, [pc, #236]	; 2de10 <__ieee754_pow+0x2e8>
   2dd26:	ee27 7b07 	vmul.f64	d7, d7, d7
   2dd2a:	e766      	b.n	2dbfa <__ieee754_pow+0xd2>
   2dd2c:	4b49      	ldr	r3, [pc, #292]	; (2de54 <__ieee754_pow+0x32c>)
   2dd2e:	429c      	cmp	r4, r3
   2dd30:	ddf3      	ble.n	2dd1a <__ieee754_pow+0x1f2>
   2dd32:	4b45      	ldr	r3, [pc, #276]	; (2de48 <__ieee754_pow+0x320>)
   2dd34:	429c      	cmp	r4, r3
   2dd36:	dd03      	ble.n	2dd40 <__ieee754_pow+0x218>
   2dd38:	f1b9 0f00 	cmp.w	r9, #0
   2dd3c:	dcf1      	bgt.n	2dd22 <__ieee754_pow+0x1fa>
   2dd3e:	e75a      	b.n	2dbf6 <__ieee754_pow+0xce>
   2dd40:	ed9d 7b00 	vldr	d7, [sp]
   2dd44:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2dd48:	ed9f 5b33 	vldr	d5, [pc, #204]	; 2de18 <__ieee754_pow+0x2f0>
   2dd4c:	ee37 6b46 	vsub.f64	d6, d7, d6
   2dd50:	eeb5 7b00 	vmov.f64	d7, #80	; 0x3e800000  0.250
   2dd54:	eeb1 3b46 	vneg.f64	d3, d6
   2dd58:	eea3 5b07 	vfma.f64	d5, d3, d7
   2dd5c:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
   2dd60:	eea5 7b46 	vfms.f64	d7, d5, d6
   2dd64:	ee26 5b06 	vmul.f64	d5, d6, d6
   2dd68:	ee27 5b05 	vmul.f64	d5, d7, d5
   2dd6c:	ed9f 7b2c 	vldr	d7, [pc, #176]	; 2de20 <__ieee754_pow+0x2f8>
   2dd70:	ee27 7b45 	vnmul.f64	d7, d7, d5
   2dd74:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 2de28 <__ieee754_pow+0x300>
   2dd78:	eea6 7b05 	vfma.f64	d7, d6, d5
   2dd7c:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 2de30 <__ieee754_pow+0x308>
   2dd80:	eeb0 4b47 	vmov.f64	d4, d7
   2dd84:	eea6 4b05 	vfma.f64	d4, d6, d5
   2dd88:	ec53 2b14 	vmov	r2, r3, d4
   2dd8c:	2200      	movs	r2, #0
   2dd8e:	ec43 2b14 	vmov	d4, r2, r3
   2dd92:	eeb0 6b44 	vmov.f64	d6, d4
   2dd96:	eea3 6b05 	vfma.f64	d6, d3, d5
   2dd9a:	ee37 7b46 	vsub.f64	d7, d7, d6
   2dd9e:	3d01      	subs	r5, #1
   2dda0:	ea55 030a 	orrs.w	r3, r5, sl
   2dda4:	f04f 0200 	mov.w	r2, #0
   2dda8:	463b      	mov	r3, r7
   2ddaa:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
   2ddae:	eeb7 8b00 	vmov.f64	d8, #112	; 0x3f800000  1.0
   2ddb2:	ec47 6b15 	vmov	d5, r6, r7
   2ddb6:	fe06 8b08 	vseleq.f64	d8, d6, d8
   2ddba:	ec47 6b13 	vmov	d3, r6, r7
   2ddbe:	ec43 2b16 	vmov	d6, r2, r3
   2ddc2:	ee27 7b03 	vmul.f64	d7, d7, d3
   2ddc6:	ee35 5b46 	vsub.f64	d5, d5, d6
   2ddca:	4b23      	ldr	r3, [pc, #140]	; (2de58 <__ieee754_pow+0x330>)
   2ddcc:	eea5 7b04 	vfma.f64	d7, d5, d4
   2ddd0:	ee24 6b06 	vmul.f64	d6, d4, d6
   2ddd4:	ee37 5b06 	vadd.f64	d5, d7, d6
   2ddd8:	ee15 1a90 	vmov	r1, s11
   2dddc:	4299      	cmp	r1, r3
   2ddde:	ee15 2a10 	vmov	r2, s10
   2dde2:	f340 819b 	ble.w	2e11c <__ieee754_pow+0x5f4>
   2dde6:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
   2ddea:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
   2ddee:	4313      	orrs	r3, r2
   2ddf0:	f000 810a 	beq.w	2e008 <__ieee754_pow+0x4e0>
   2ddf4:	ed9f 7b06 	vldr	d7, [pc, #24]	; 2de10 <__ieee754_pow+0x2e8>
   2ddf8:	ee28 8b07 	vmul.f64	d8, d8, d7
   2ddfc:	ee28 7b07 	vmul.f64	d7, d8, d7
   2de00:	e6fb      	b.n	2dbfa <__ieee754_pow+0xd2>
   2de02:	bf00      	nop
   2de04:	f3af 8000 	nop.w
	...
   2de10:	8800759c 	.word	0x8800759c
   2de14:	7e37e43c 	.word	0x7e37e43c
   2de18:	55555555 	.word	0x55555555
   2de1c:	3fd55555 	.word	0x3fd55555
   2de20:	652b82fe 	.word	0x652b82fe
   2de24:	3ff71547 	.word	0x3ff71547
   2de28:	f85ddf44 	.word	0xf85ddf44
   2de2c:	3e54ae0b 	.word	0x3e54ae0b
   2de30:	60000000 	.word	0x60000000
   2de34:	3ff71547 	.word	0x3ff71547
   2de38:	7ff00000 	.word	0x7ff00000
   2de3c:	0005242c 	.word	0x0005242c
   2de40:	433fffff 	.word	0x433fffff
   2de44:	3fefffff 	.word	0x3fefffff
   2de48:	3ff00000 	.word	0x3ff00000
   2de4c:	3fe00000 	.word	0x3fe00000
   2de50:	41e00000 	.word	0x41e00000
   2de54:	3feffffe 	.word	0x3feffffe
   2de58:	408fffff 	.word	0x408fffff
   2de5c:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
   2de60:	f280 80ce 	bge.w	2e000 <__ieee754_pow+0x4d8>
   2de64:	ed9d 6b00 	vldr	d6, [sp]
   2de68:	ed9f 7bc1 	vldr	d7, [pc, #772]	; 2e170 <__ieee754_pow+0x648>
   2de6c:	ee26 7b07 	vmul.f64	d7, d6, d7
   2de70:	ed8d 7b00 	vstr	d7, [sp]
   2de74:	9c01      	ldr	r4, [sp, #4]
   2de76:	f06f 0334 	mvn.w	r3, #52	; 0x34
   2de7a:	1521      	asrs	r1, r4, #20
   2de7c:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
   2de80:	4419      	add	r1, r3
   2de82:	4be3      	ldr	r3, [pc, #908]	; (2e210 <__ieee754_pow+0x6e8>)
   2de84:	f3c4 0413 	ubfx	r4, r4, #0, #20
   2de88:	f044 507f 	orr.w	r0, r4, #1069547520	; 0x3fc00000
   2de8c:	429c      	cmp	r4, r3
   2de8e:	f440 1040 	orr.w	r0, r0, #3145728	; 0x300000
   2de92:	dd06      	ble.n	2dea2 <__ieee754_pow+0x37a>
   2de94:	4bdf      	ldr	r3, [pc, #892]	; (2e214 <__ieee754_pow+0x6ec>)
   2de96:	429c      	cmp	r4, r3
   2de98:	f340 80b4 	ble.w	2e004 <__ieee754_pow+0x4dc>
   2de9c:	3101      	adds	r1, #1
   2de9e:	f5a0 1080 	sub.w	r0, r0, #1048576	; 0x100000
   2dea2:	2400      	movs	r4, #0
   2dea4:	e9dd 2300 	ldrd	r2, r3, [sp]
   2dea8:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
   2deac:	4603      	mov	r3, r0
   2deae:	ec43 2b17 	vmov	d7, r2, r3
   2deb2:	4bd9      	ldr	r3, [pc, #868]	; (2e218 <__ieee754_pow+0x6f0>)
   2deb4:	ea4f 0cc4 	mov.w	ip, r4, lsl #3
   2deb8:	4463      	add	r3, ip
   2deba:	ed93 5b00 	vldr	d5, [r3]
   2debe:	1040      	asrs	r0, r0, #1
   2dec0:	ee37 2b45 	vsub.f64	d2, d7, d5
   2dec4:	ee35 6b07 	vadd.f64	d6, d5, d7
   2dec8:	ee84 1b06 	vdiv.f64	d1, d4, d6
   2decc:	ee22 6b01 	vmul.f64	d6, d2, d1
   2ded0:	ed8d 6b00 	vstr	d6, [sp]
   2ded4:	e9dd 8900 	ldrd	r8, r9, [sp]
   2ded8:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
   2dedc:	f500 2000 	add.w	r0, r0, #524288	; 0x80000
   2dee0:	f04f 0800 	mov.w	r8, #0
   2dee4:	eb00 4384 	add.w	r3, r0, r4, lsl #18
   2dee8:	2200      	movs	r2, #0
   2deea:	ec49 8b14 	vmov	d4, r8, r9
   2deee:	ec43 2b16 	vmov	d6, r2, r3
   2def2:	eeb1 3b44 	vneg.f64	d3, d4
   2def6:	eea3 2b06 	vfma.f64	d2, d3, d6
   2defa:	ee36 6b45 	vsub.f64	d6, d6, d5
   2defe:	ee37 7b46 	vsub.f64	d7, d7, d6
   2df02:	eea3 2b07 	vfma.f64	d2, d3, d7
   2df06:	ed9d 7b00 	vldr	d7, [sp]
   2df0a:	ee22 2b01 	vmul.f64	d2, d2, d1
   2df0e:	ee27 5b07 	vmul.f64	d5, d7, d7
   2df12:	ee37 6b04 	vadd.f64	d6, d7, d4
   2df16:	ed9f 1b98 	vldr	d1, [pc, #608]	; 2e178 <__ieee754_pow+0x650>
   2df1a:	ee25 0b05 	vmul.f64	d0, d5, d5
   2df1e:	ee26 6b02 	vmul.f64	d6, d6, d2
   2df22:	ed9f 7b97 	vldr	d7, [pc, #604]	; 2e180 <__ieee754_pow+0x658>
   2df26:	eea5 7b01 	vfma.f64	d7, d5, d1
   2df2a:	ed9f 1b97 	vldr	d1, [pc, #604]	; 2e188 <__ieee754_pow+0x660>
   2df2e:	eea7 1b05 	vfma.f64	d1, d7, d5
   2df32:	ed9f 7b97 	vldr	d7, [pc, #604]	; 2e190 <__ieee754_pow+0x668>
   2df36:	eea1 7b05 	vfma.f64	d7, d1, d5
   2df3a:	ed9f 1b97 	vldr	d1, [pc, #604]	; 2e198 <__ieee754_pow+0x670>
   2df3e:	eea7 1b05 	vfma.f64	d1, d7, d5
   2df42:	ed9f 7b97 	vldr	d7, [pc, #604]	; 2e1a0 <__ieee754_pow+0x678>
   2df46:	eea1 7b05 	vfma.f64	d7, d1, d5
   2df4a:	eea0 6b07 	vfma.f64	d6, d0, d7
   2df4e:	eeb0 7b08 	vmov.f64	d7, #8	; 0x40400000  3.0
   2df52:	eeb0 5b47 	vmov.f64	d5, d7
   2df56:	eea4 5b04 	vfma.f64	d5, d4, d4
   2df5a:	ee35 5b06 	vadd.f64	d5, d5, d6
   2df5e:	ed8d 5b02 	vstr	d5, [sp, #8]
   2df62:	f8cd 8008 	str.w	r8, [sp, #8]
   2df66:	ed9d 5b02 	vldr	d5, [sp, #8]
   2df6a:	ee35 7b47 	vsub.f64	d7, d5, d7
   2df6e:	eea3 7b04 	vfma.f64	d7, d3, d4
   2df72:	ee36 7b47 	vsub.f64	d7, d6, d7
   2df76:	ed9d 6b00 	vldr	d6, [sp]
   2df7a:	ee27 7b06 	vmul.f64	d7, d7, d6
   2df7e:	eea2 7b05 	vfma.f64	d7, d2, d5
   2df82:	eeb0 6b47 	vmov.f64	d6, d7
   2df86:	eea4 6b05 	vfma.f64	d6, d4, d5
   2df8a:	ed8d 6b00 	vstr	d6, [sp]
   2df8e:	f8cd 8000 	str.w	r8, [sp]
   2df92:	ed9d 2b00 	vldr	d2, [sp]
   2df96:	eeb0 6b42 	vmov.f64	d6, d2
   2df9a:	eea3 6b05 	vfma.f64	d6, d3, d5
   2df9e:	ee37 7b46 	vsub.f64	d7, d7, d6
   2dfa2:	ed9f 6b81 	vldr	d6, [pc, #516]	; 2e1a8 <__ieee754_pow+0x680>
   2dfa6:	4b9d      	ldr	r3, [pc, #628]	; (2e21c <__ieee754_pow+0x6f4>)
   2dfa8:	ee27 7b06 	vmul.f64	d7, d7, d6
   2dfac:	ed9f 6b80 	vldr	d6, [pc, #512]	; 2e1b0 <__ieee754_pow+0x688>
   2dfb0:	4463      	add	r3, ip
   2dfb2:	eea2 7b06 	vfma.f64	d7, d2, d6
   2dfb6:	ed93 6b00 	vldr	d6, [r3]
   2dfba:	4b99      	ldr	r3, [pc, #612]	; (2e220 <__ieee754_pow+0x6f8>)
   2dfbc:	ee37 6b06 	vadd.f64	d6, d7, d6
   2dfc0:	449c      	add	ip, r3
   2dfc2:	ed9c 1b00 	vldr	d1, [ip]
   2dfc6:	eeb0 4b46 	vmov.f64	d4, d6
   2dfca:	ed9f 3b7b 	vldr	d3, [pc, #492]	; 2e1b8 <__ieee754_pow+0x690>
   2dfce:	ee07 1a90 	vmov	s15, r1
   2dfd2:	eea2 4b03 	vfma.f64	d4, d2, d3
   2dfd6:	eeb8 7be7 	vcvt.f64.s32	d7, s15
   2dfda:	ee34 4b01 	vadd.f64	d4, d4, d1
   2dfde:	ee34 5b07 	vadd.f64	d5, d4, d7
   2dfe2:	ed8d 5b00 	vstr	d5, [sp]
   2dfe6:	f8cd 8000 	str.w	r8, [sp]
   2dfea:	ed9d 4b00 	vldr	d4, [sp]
   2dfee:	ee34 7b47 	vsub.f64	d7, d4, d7
   2dff2:	ee37 7b41 	vsub.f64	d7, d7, d1
   2dff6:	eea2 7b43 	vfms.f64	d7, d2, d3
   2dffa:	ee36 7b47 	vsub.f64	d7, d6, d7
   2dffe:	e6ce      	b.n	2dd9e <__ieee754_pow+0x276>
   2e000:	2300      	movs	r3, #0
   2e002:	e73a      	b.n	2de7a <__ieee754_pow+0x352>
   2e004:	2401      	movs	r4, #1
   2e006:	e74d      	b.n	2dea4 <__ieee754_pow+0x37c>
   2e008:	ed9f 4b6d 	vldr	d4, [pc, #436]	; 2e1c0 <__ieee754_pow+0x698>
   2e00c:	ee35 5b46 	vsub.f64	d5, d5, d6
   2e010:	ee37 4b04 	vadd.f64	d4, d7, d4
   2e014:	eeb4 4bc5 	vcmpe.f64	d4, d5
   2e018:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e01c:	f73f aeea 	bgt.w	2ddf4 <__ieee754_pow+0x2cc>
   2e020:	4a80      	ldr	r2, [pc, #512]	; (2e224 <__ieee754_pow+0x6fc>)
   2e022:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   2e026:	4293      	cmp	r3, r2
   2e028:	f340 808e 	ble.w	2e148 <__ieee754_pow+0x620>
   2e02c:	151b      	asrs	r3, r3, #20
   2e02e:	f2a3 30fe 	subw	r0, r3, #1022	; 0x3fe
   2e032:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   2e036:	4103      	asrs	r3, r0
   2e038:	440b      	add	r3, r1
   2e03a:	f3c3 520a 	ubfx	r2, r3, #20, #11
   2e03e:	487a      	ldr	r0, [pc, #488]	; (2e228 <__ieee754_pow+0x700>)
   2e040:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
   2e044:	4110      	asrs	r0, r2
   2e046:	ea23 0500 	bic.w	r5, r3, r0
   2e04a:	f3c3 0013 	ubfx	r0, r3, #0, #20
   2e04e:	2400      	movs	r4, #0
   2e050:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
   2e054:	f1c2 0214 	rsb	r2, r2, #20
   2e058:	ec45 4b15 	vmov	d5, r4, r5
   2e05c:	4110      	asrs	r0, r2
   2e05e:	2900      	cmp	r1, #0
   2e060:	bfb8      	it	lt
   2e062:	4240      	neglt	r0, r0
   2e064:	ee36 6b45 	vsub.f64	d6, d6, d5
   2e068:	ee36 5b07 	vadd.f64	d5, d6, d7
   2e06c:	ec53 2b15 	vmov	r2, r3, d5
   2e070:	2200      	movs	r2, #0
   2e072:	ec43 2b15 	vmov	d5, r2, r3
   2e076:	ed9f 4b54 	vldr	d4, [pc, #336]	; 2e1c8 <__ieee754_pow+0x6a0>
   2e07a:	ee35 6b46 	vsub.f64	d6, d5, d6
   2e07e:	ee37 6b46 	vsub.f64	d6, d7, d6
   2e082:	ed9f 7b53 	vldr	d7, [pc, #332]	; 2e1d0 <__ieee754_pow+0x6a8>
   2e086:	ee25 7b07 	vmul.f64	d7, d5, d7
   2e08a:	eea6 7b04 	vfma.f64	d7, d6, d4
   2e08e:	ed9f 6b52 	vldr	d6, [pc, #328]	; 2e1d8 <__ieee754_pow+0x6b0>
   2e092:	eeb0 4b47 	vmov.f64	d4, d7
   2e096:	eea5 4b06 	vfma.f64	d4, d5, d6
   2e09a:	eeb0 3b44 	vmov.f64	d3, d4
   2e09e:	eea5 3b46 	vfms.f64	d3, d5, d6
   2e0a2:	ed9f 5b4f 	vldr	d5, [pc, #316]	; 2e1e0 <__ieee754_pow+0x6b8>
   2e0a6:	ee37 7b43 	vsub.f64	d7, d7, d3
   2e0aa:	ee24 6b04 	vmul.f64	d6, d4, d4
   2e0ae:	ed9f 3b4e 	vldr	d3, [pc, #312]	; 2e1e8 <__ieee754_pow+0x6c0>
   2e0b2:	eea4 7b07 	vfma.f64	d7, d4, d7
   2e0b6:	eea6 3b05 	vfma.f64	d3, d6, d5
   2e0ba:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 2e1f0 <__ieee754_pow+0x6c8>
   2e0be:	eea3 5b06 	vfma.f64	d5, d3, d6
   2e0c2:	ed9f 3b4d 	vldr	d3, [pc, #308]	; 2e1f8 <__ieee754_pow+0x6d0>
   2e0c6:	eea5 3b06 	vfma.f64	d3, d5, d6
   2e0ca:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 2e200 <__ieee754_pow+0x6d8>
   2e0ce:	eea3 5b06 	vfma.f64	d5, d3, d6
   2e0d2:	eeb0 3b44 	vmov.f64	d3, d4
   2e0d6:	eea5 3b46 	vfms.f64	d3, d5, d6
   2e0da:	eeb0 5b00 	vmov.f64	d5, #0	; 0x40000000  2.0
   2e0de:	eeb0 6b43 	vmov.f64	d6, d3
   2e0e2:	ee24 3b03 	vmul.f64	d3, d4, d3
   2e0e6:	ee36 5b45 	vsub.f64	d5, d6, d5
   2e0ea:	ee83 6b05 	vdiv.f64	d6, d3, d5
   2e0ee:	ee36 7b47 	vsub.f64	d7, d6, d7
   2e0f2:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
   2e0f6:	ee37 7b44 	vsub.f64	d7, d7, d4
   2e0fa:	ee36 7b47 	vsub.f64	d7, d6, d7
   2e0fe:	ed8d 7b00 	vstr	d7, [sp]
   2e102:	9901      	ldr	r1, [sp, #4]
   2e104:	eb01 5100 	add.w	r1, r1, r0, lsl #20
   2e108:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   2e10c:	da1e      	bge.n	2e14c <__ieee754_pow+0x624>
   2e10e:	eeb0 0b47 	vmov.f64	d0, d7
   2e112:	f001 f809 	bl	2f128 <scalbn>
   2e116:	ee20 7b08 	vmul.f64	d7, d0, d8
   2e11a:	e56e      	b.n	2dbfa <__ieee754_pow+0xd2>
   2e11c:	4b43      	ldr	r3, [pc, #268]	; (2e22c <__ieee754_pow+0x704>)
   2e11e:	f021 4000 	bic.w	r0, r1, #2147483648	; 0x80000000
   2e122:	4298      	cmp	r0, r3
   2e124:	f77f af7c 	ble.w	2e020 <__ieee754_pow+0x4f8>
   2e128:	4b41      	ldr	r3, [pc, #260]	; (2e230 <__ieee754_pow+0x708>)
   2e12a:	440b      	add	r3, r1
   2e12c:	4313      	orrs	r3, r2
   2e12e:	d002      	beq.n	2e136 <__ieee754_pow+0x60e>
   2e130:	ed9f 7b35 	vldr	d7, [pc, #212]	; 2e208 <__ieee754_pow+0x6e0>
   2e134:	e660      	b.n	2ddf8 <__ieee754_pow+0x2d0>
   2e136:	ee35 5b46 	vsub.f64	d5, d5, d6
   2e13a:	eeb4 5bc7 	vcmpe.f64	d5, d7
   2e13e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e142:	f6ff af6d 	blt.w	2e020 <__ieee754_pow+0x4f8>
   2e146:	e7f3      	b.n	2e130 <__ieee754_pow+0x608>
   2e148:	2000      	movs	r0, #0
   2e14a:	e78d      	b.n	2e068 <__ieee754_pow+0x540>
   2e14c:	e9dd 2300 	ldrd	r2, r3, [sp]
   2e150:	460b      	mov	r3, r1
   2e152:	ec43 2b10 	vmov	d0, r2, r3
   2e156:	e7de      	b.n	2e116 <__ieee754_pow+0x5ee>
   2e158:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
   2e15c:	e54d      	b.n	2dbfa <__ieee754_pow+0xd2>
   2e15e:	e9cd 6700 	strd	r6, r7, [sp]
   2e162:	e574      	b.n	2dc4e <__ieee754_pow+0x126>
   2e164:	ed8d 8b00 	vstr	d8, [sp]
   2e168:	e571      	b.n	2dc4e <__ieee754_pow+0x126>
   2e16a:	4615      	mov	r5, r2
   2e16c:	e557      	b.n	2dc1e <__ieee754_pow+0xf6>
   2e16e:	bf00      	nop
   2e170:	00000000 	.word	0x00000000
   2e174:	43400000 	.word	0x43400000
   2e178:	4a454eef 	.word	0x4a454eef
   2e17c:	3fca7e28 	.word	0x3fca7e28
   2e180:	93c9db65 	.word	0x93c9db65
   2e184:	3fcd864a 	.word	0x3fcd864a
   2e188:	a91d4101 	.word	0xa91d4101
   2e18c:	3fd17460 	.word	0x3fd17460
   2e190:	518f264d 	.word	0x518f264d
   2e194:	3fd55555 	.word	0x3fd55555
   2e198:	db6fabff 	.word	0xdb6fabff
   2e19c:	3fdb6db6 	.word	0x3fdb6db6
   2e1a0:	33333303 	.word	0x33333303
   2e1a4:	3fe33333 	.word	0x3fe33333
   2e1a8:	dc3a03fd 	.word	0xdc3a03fd
   2e1ac:	3feec709 	.word	0x3feec709
   2e1b0:	145b01f5 	.word	0x145b01f5
   2e1b4:	be3e2fe0 	.word	0xbe3e2fe0
   2e1b8:	e0000000 	.word	0xe0000000
   2e1bc:	3feec709 	.word	0x3feec709
   2e1c0:	652b82fe 	.word	0x652b82fe
   2e1c4:	3c971547 	.word	0x3c971547
   2e1c8:	fefa39ef 	.word	0xfefa39ef
   2e1cc:	3fe62e42 	.word	0x3fe62e42
   2e1d0:	0ca86c39 	.word	0x0ca86c39
   2e1d4:	be205c61 	.word	0xbe205c61
   2e1d8:	00000000 	.word	0x00000000
   2e1dc:	3fe62e43 	.word	0x3fe62e43
   2e1e0:	72bea4d0 	.word	0x72bea4d0
   2e1e4:	3e663769 	.word	0x3e663769
   2e1e8:	c5d26bf1 	.word	0xc5d26bf1
   2e1ec:	bebbbd41 	.word	0xbebbbd41
   2e1f0:	af25de2c 	.word	0xaf25de2c
   2e1f4:	3f11566a 	.word	0x3f11566a
   2e1f8:	16bebd93 	.word	0x16bebd93
   2e1fc:	bf66c16c 	.word	0xbf66c16c
   2e200:	5555553e 	.word	0x5555553e
   2e204:	3fc55555 	.word	0x3fc55555
   2e208:	c2f8f359 	.word	0xc2f8f359
   2e20c:	01a56e1f 	.word	0x01a56e1f
   2e210:	0003988e 	.word	0x0003988e
   2e214:	000bb679 	.word	0x000bb679
   2e218:	00052468 	.word	0x00052468
   2e21c:	00052488 	.word	0x00052488
   2e220:	00052478 	.word	0x00052478
   2e224:	3fe00000 	.word	0x3fe00000
   2e228:	000fffff 	.word	0x000fffff
   2e22c:	4090cbff 	.word	0x4090cbff
   2e230:	3f6f3400 	.word	0x3f6f3400

0002e234 <__ieee754_sqrt>:
   2e234:	eeb1 0bc0 	vsqrt.f64	d0, d0
   2e238:	4770      	bx	lr
	...

0002e23c <__ieee754_fmodf>:
   2e23c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e23e:	ee10 6a90 	vmov	r6, s1
   2e242:	f036 4500 	bics.w	r5, r6, #2147483648	; 0x80000000
   2e246:	ee10 3a10 	vmov	r3, s0
   2e24a:	d009      	beq.n	2e260 <__ieee754_fmodf+0x24>
   2e24c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2e250:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   2e254:	ee10 7a10 	vmov	r7, s0
   2e258:	da02      	bge.n	2e260 <__ieee754_fmodf+0x24>
   2e25a:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
   2e25e:	dd0a      	ble.n	2e276 <__ieee754_fmodf+0x3a>
   2e260:	ee07 3a90 	vmov	s15, r3
   2e264:	ee67 0aa0 	vmul.f32	s1, s15, s1
   2e268:	eec0 7aa0 	vdiv.f32	s15, s1, s1
   2e26c:	ee17 3a90 	vmov	r3, s15
   2e270:	ee00 3a10 	vmov	s0, r3
   2e274:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e276:	42a9      	cmp	r1, r5
   2e278:	dbfa      	blt.n	2e270 <__ieee754_fmodf+0x34>
   2e27a:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
   2e27e:	d105      	bne.n	2e28c <__ieee754_fmodf+0x50>
   2e280:	4a30      	ldr	r2, [pc, #192]	; (2e344 <__ieee754_fmodf+0x108>)
   2e282:	0fe3      	lsrs	r3, r4, #31
   2e284:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2e288:	681b      	ldr	r3, [r3, #0]
   2e28a:	e7f1      	b.n	2e270 <__ieee754_fmodf+0x34>
   2e28c:	4b2e      	ldr	r3, [pc, #184]	; (2e348 <__ieee754_fmodf+0x10c>)
   2e28e:	4299      	cmp	r1, r3
   2e290:	dc3e      	bgt.n	2e310 <__ieee754_fmodf+0xd4>
   2e292:	020a      	lsls	r2, r1, #8
   2e294:	f06f 007d 	mvn.w	r0, #125	; 0x7d
   2e298:	2a00      	cmp	r2, #0
   2e29a:	dc36      	bgt.n	2e30a <__ieee754_fmodf+0xce>
   2e29c:	429d      	cmp	r5, r3
   2e29e:	dc3a      	bgt.n	2e316 <__ieee754_fmodf+0xda>
   2e2a0:	022b      	lsls	r3, r5, #8
   2e2a2:	f06f 027d 	mvn.w	r2, #125	; 0x7d
   2e2a6:	005b      	lsls	r3, r3, #1
   2e2a8:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
   2e2ac:	d5fb      	bpl.n	2e2a6 <__ieee754_fmodf+0x6a>
   2e2ae:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
   2e2b2:	bfbb      	ittet	lt
   2e2b4:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
   2e2b8:	1a1b      	sublt	r3, r3, r0
   2e2ba:	f3c7 0116 	ubfxge	r1, r7, #0, #23
   2e2be:	4099      	lsllt	r1, r3
   2e2c0:	bfa8      	it	ge
   2e2c2:	f441 0100 	orrge.w	r1, r1, #8388608	; 0x800000
   2e2c6:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
   2e2ca:	bfb5      	itete	lt
   2e2cc:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
   2e2d0:	f3c6 0516 	ubfxge	r5, r6, #0, #23
   2e2d4:	1a9b      	sublt	r3, r3, r2
   2e2d6:	f445 0500 	orrge.w	r5, r5, #8388608	; 0x800000
   2e2da:	bfb8      	it	lt
   2e2dc:	409d      	lsllt	r5, r3
   2e2de:	1a80      	subs	r0, r0, r2
   2e2e0:	1b4b      	subs	r3, r1, r5
   2e2e2:	b9d8      	cbnz	r0, 2e31c <__ieee754_fmodf+0xe0>
   2e2e4:	ea33 0323 	bics.w	r3, r3, r3, asr #32
   2e2e8:	bf28      	it	cs
   2e2ea:	460b      	movcs	r3, r1
   2e2ec:	2b00      	cmp	r3, #0
   2e2ee:	d0c7      	beq.n	2e280 <__ieee754_fmodf+0x44>
   2e2f0:	4915      	ldr	r1, [pc, #84]	; (2e348 <__ieee754_fmodf+0x10c>)
   2e2f2:	428b      	cmp	r3, r1
   2e2f4:	dd1a      	ble.n	2e32c <__ieee754_fmodf+0xf0>
   2e2f6:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
   2e2fa:	db1a      	blt.n	2e332 <__ieee754_fmodf+0xf6>
   2e2fc:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   2e300:	4323      	orrs	r3, r4
   2e302:	327f      	adds	r2, #127	; 0x7f
   2e304:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   2e308:	e7b2      	b.n	2e270 <__ieee754_fmodf+0x34>
   2e30a:	3801      	subs	r0, #1
   2e30c:	0052      	lsls	r2, r2, #1
   2e30e:	e7c3      	b.n	2e298 <__ieee754_fmodf+0x5c>
   2e310:	15c8      	asrs	r0, r1, #23
   2e312:	387f      	subs	r0, #127	; 0x7f
   2e314:	e7c2      	b.n	2e29c <__ieee754_fmodf+0x60>
   2e316:	15ea      	asrs	r2, r5, #23
   2e318:	3a7f      	subs	r2, #127	; 0x7f
   2e31a:	e7c8      	b.n	2e2ae <__ieee754_fmodf+0x72>
   2e31c:	2b00      	cmp	r3, #0
   2e31e:	da02      	bge.n	2e326 <__ieee754_fmodf+0xea>
   2e320:	0049      	lsls	r1, r1, #1
   2e322:	3801      	subs	r0, #1
   2e324:	e7dc      	b.n	2e2e0 <__ieee754_fmodf+0xa4>
   2e326:	d0ab      	beq.n	2e280 <__ieee754_fmodf+0x44>
   2e328:	0059      	lsls	r1, r3, #1
   2e32a:	e7fa      	b.n	2e322 <__ieee754_fmodf+0xe6>
   2e32c:	005b      	lsls	r3, r3, #1
   2e32e:	3a01      	subs	r2, #1
   2e330:	e7df      	b.n	2e2f2 <__ieee754_fmodf+0xb6>
   2e332:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
   2e336:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
   2e33a:	3282      	adds	r2, #130	; 0x82
   2e33c:	4113      	asrs	r3, r2
   2e33e:	4323      	orrs	r3, r4
   2e340:	e796      	b.n	2e270 <__ieee754_fmodf+0x34>
   2e342:	bf00      	nop
   2e344:	00052498 	.word	0x00052498
   2e348:	007fffff 	.word	0x007fffff

0002e34c <__ieee754_log10f>:
   2e34c:	b508      	push	{r3, lr}
   2e34e:	ee10 2a10 	vmov	r2, s0
   2e352:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
   2e356:	ed2d 8b02 	vpush	{d8}
   2e35a:	d108      	bne.n	2e36e <__ieee754_log10f+0x22>
   2e35c:	ed9f 7a20 	vldr	s14, [pc, #128]	; 2e3e0 <__ieee754_log10f+0x94>
   2e360:	eddf 7a20 	vldr	s15, [pc, #128]	; 2e3e4 <__ieee754_log10f+0x98>
   2e364:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2e368:	ecbd 8b02 	vpop	{d8}
   2e36c:	bd08      	pop	{r3, pc}
   2e36e:	2a00      	cmp	r2, #0
   2e370:	da02      	bge.n	2e378 <__ieee754_log10f+0x2c>
   2e372:	ee30 7a40 	vsub.f32	s14, s0, s0
   2e376:	e7f3      	b.n	2e360 <__ieee754_log10f+0x14>
   2e378:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2e37c:	db02      	blt.n	2e384 <__ieee754_log10f+0x38>
   2e37e:	ee30 0a00 	vadd.f32	s0, s0, s0
   2e382:	e7f1      	b.n	2e368 <__ieee754_log10f+0x1c>
   2e384:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   2e388:	bfbf      	itttt	lt
   2e38a:	eddf 7a17 	vldrlt	s15, [pc, #92]	; 2e3e8 <__ieee754_log10f+0x9c>
   2e38e:	ee60 7a27 	vmullt.f32	s15, s0, s15
   2e392:	f06f 0118 	mvnlt.w	r1, #24
   2e396:	ee17 2a90 	vmovlt	r2, s15
   2e39a:	ea4f 53e2 	mov.w	r3, r2, asr #23
   2e39e:	bfa8      	it	ge
   2e3a0:	2100      	movge	r1, #0
   2e3a2:	3b7f      	subs	r3, #127	; 0x7f
   2e3a4:	440b      	add	r3, r1
   2e3a6:	0fd9      	lsrs	r1, r3, #31
   2e3a8:	440b      	add	r3, r1
   2e3aa:	f3c2 0216 	ubfx	r2, r2, #0, #23
   2e3ae:	f1c1 017f 	rsb	r1, r1, #127	; 0x7f
   2e3b2:	ee07 3a90 	vmov	s15, r3
   2e3b6:	ea42 53c1 	orr.w	r3, r2, r1, lsl #23
   2e3ba:	ee00 3a10 	vmov	s0, r3
   2e3be:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   2e3c2:	f7fe fd2d 	bl	2ce20 <logf>
   2e3c6:	eddf 7a09 	vldr	s15, [pc, #36]	; 2e3ec <__ieee754_log10f+0xa0>
   2e3ca:	ee20 0a27 	vmul.f32	s0, s0, s15
   2e3ce:	eddf 7a08 	vldr	s15, [pc, #32]	; 2e3f0 <__ieee754_log10f+0xa4>
   2e3d2:	eea8 0a27 	vfma.f32	s0, s16, s15
   2e3d6:	eddf 7a07 	vldr	s15, [pc, #28]	; 2e3f4 <__ieee754_log10f+0xa8>
   2e3da:	eea8 0a27 	vfma.f32	s0, s16, s15
   2e3de:	e7c3      	b.n	2e368 <__ieee754_log10f+0x1c>
   2e3e0:	cc000000 	.word	0xcc000000
   2e3e4:	00000000 	.word	0x00000000
   2e3e8:	4c000000 	.word	0x4c000000
   2e3ec:	3ede5bd9 	.word	0x3ede5bd9
   2e3f0:	355427db 	.word	0x355427db
   2e3f4:	3e9a2080 	.word	0x3e9a2080

0002e3f8 <__ieee754_rem_pio2f>:
   2e3f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e3fa:	ee10 6a10 	vmov	r6, s0
   2e3fe:	4b86      	ldr	r3, [pc, #536]	; (2e618 <__ieee754_rem_pio2f+0x220>)
   2e400:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
   2e404:	429c      	cmp	r4, r3
   2e406:	b087      	sub	sp, #28
   2e408:	4605      	mov	r5, r0
   2e40a:	dc05      	bgt.n	2e418 <__ieee754_rem_pio2f+0x20>
   2e40c:	2300      	movs	r3, #0
   2e40e:	ed85 0a00 	vstr	s0, [r5]
   2e412:	6043      	str	r3, [r0, #4]
   2e414:	2000      	movs	r0, #0
   2e416:	e020      	b.n	2e45a <__ieee754_rem_pio2f+0x62>
   2e418:	4b80      	ldr	r3, [pc, #512]	; (2e61c <__ieee754_rem_pio2f+0x224>)
   2e41a:	429c      	cmp	r4, r3
   2e41c:	dc38      	bgt.n	2e490 <__ieee754_rem_pio2f+0x98>
   2e41e:	2e00      	cmp	r6, #0
   2e420:	f024 040f 	bic.w	r4, r4, #15
   2e424:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 2e620 <__ieee754_rem_pio2f+0x228>
   2e428:	4b7e      	ldr	r3, [pc, #504]	; (2e624 <__ieee754_rem_pio2f+0x22c>)
   2e42a:	dd18      	ble.n	2e45e <__ieee754_rem_pio2f+0x66>
   2e42c:	429c      	cmp	r4, r3
   2e42e:	ee70 7a47 	vsub.f32	s15, s0, s14
   2e432:	bf09      	itett	eq
   2e434:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 2e628 <__ieee754_rem_pio2f+0x230>
   2e438:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 2e62c <__ieee754_rem_pio2f+0x234>
   2e43c:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
   2e440:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 2e630 <__ieee754_rem_pio2f+0x238>
   2e444:	ee77 6ac7 	vsub.f32	s13, s15, s14
   2e448:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2e44c:	edc0 6a00 	vstr	s13, [r0]
   2e450:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e454:	edc0 7a01 	vstr	s15, [r0, #4]
   2e458:	2001      	movs	r0, #1
   2e45a:	b007      	add	sp, #28
   2e45c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e45e:	429c      	cmp	r4, r3
   2e460:	ee70 7a07 	vadd.f32	s15, s0, s14
   2e464:	bf09      	itett	eq
   2e466:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 2e628 <__ieee754_rem_pio2f+0x230>
   2e46a:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 2e62c <__ieee754_rem_pio2f+0x234>
   2e46e:	ee77 7a87 	vaddeq.f32	s15, s15, s14
   2e472:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 2e630 <__ieee754_rem_pio2f+0x238>
   2e476:	ee77 6a87 	vadd.f32	s13, s15, s14
   2e47a:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2e47e:	edc0 6a00 	vstr	s13, [r0]
   2e482:	ee77 7a87 	vadd.f32	s15, s15, s14
   2e486:	edc0 7a01 	vstr	s15, [r0, #4]
   2e48a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2e48e:	e7e4      	b.n	2e45a <__ieee754_rem_pio2f+0x62>
   2e490:	4b68      	ldr	r3, [pc, #416]	; (2e634 <__ieee754_rem_pio2f+0x23c>)
   2e492:	429c      	cmp	r4, r3
   2e494:	dc71      	bgt.n	2e57a <__ieee754_rem_pio2f+0x182>
   2e496:	f7fe fcbb 	bl	2ce10 <fabsf>
   2e49a:	ed9f 7a67 	vldr	s14, [pc, #412]	; 2e638 <__ieee754_rem_pio2f+0x240>
   2e49e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2e4a2:	eee0 7a07 	vfma.f32	s15, s0, s14
   2e4a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2e4aa:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
   2e4ae:	ee17 0a90 	vmov	r0, s15
   2e4b2:	eddf 7a5b 	vldr	s15, [pc, #364]	; 2e620 <__ieee754_rem_pio2f+0x228>
   2e4b6:	eeb1 7a46 	vneg.f32	s14, s12
   2e4ba:	eea7 0a27 	vfma.f32	s0, s14, s15
   2e4be:	281f      	cmp	r0, #31
   2e4c0:	eddf 7a5a 	vldr	s15, [pc, #360]	; 2e62c <__ieee754_rem_pio2f+0x234>
   2e4c4:	ee66 7a27 	vmul.f32	s15, s12, s15
   2e4c8:	ee70 6a67 	vsub.f32	s13, s0, s15
   2e4cc:	ee16 3a90 	vmov	r3, s13
   2e4d0:	dc1c      	bgt.n	2e50c <__ieee754_rem_pio2f+0x114>
   2e4d2:	1e47      	subs	r7, r0, #1
   2e4d4:	4959      	ldr	r1, [pc, #356]	; (2e63c <__ieee754_rem_pio2f+0x244>)
   2e4d6:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
   2e4da:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
   2e4de:	428a      	cmp	r2, r1
   2e4e0:	d014      	beq.n	2e50c <__ieee754_rem_pio2f+0x114>
   2e4e2:	602b      	str	r3, [r5, #0]
   2e4e4:	ed95 7a00 	vldr	s14, [r5]
   2e4e8:	ee30 0a47 	vsub.f32	s0, s0, s14
   2e4ec:	2e00      	cmp	r6, #0
   2e4ee:	ee30 0a67 	vsub.f32	s0, s0, s15
   2e4f2:	ed85 0a01 	vstr	s0, [r5, #4]
   2e4f6:	dab0      	bge.n	2e45a <__ieee754_rem_pio2f+0x62>
   2e4f8:	eeb1 7a47 	vneg.f32	s14, s14
   2e4fc:	eeb1 0a40 	vneg.f32	s0, s0
   2e500:	ed85 7a00 	vstr	s14, [r5]
   2e504:	ed85 0a01 	vstr	s0, [r5, #4]
   2e508:	4240      	negs	r0, r0
   2e50a:	e7a6      	b.n	2e45a <__ieee754_rem_pio2f+0x62>
   2e50c:	15e4      	asrs	r4, r4, #23
   2e50e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   2e512:	1aa2      	subs	r2, r4, r2
   2e514:	2a08      	cmp	r2, #8
   2e516:	dde4      	ble.n	2e4e2 <__ieee754_rem_pio2f+0xea>
   2e518:	eddf 7a43 	vldr	s15, [pc, #268]	; 2e628 <__ieee754_rem_pio2f+0x230>
   2e51c:	eef0 6a40 	vmov.f32	s13, s0
   2e520:	eee7 6a27 	vfma.f32	s13, s14, s15
   2e524:	ee30 0a66 	vsub.f32	s0, s0, s13
   2e528:	eea7 0a27 	vfma.f32	s0, s14, s15
   2e52c:	eddf 7a40 	vldr	s15, [pc, #256]	; 2e630 <__ieee754_rem_pio2f+0x238>
   2e530:	ee96 0a27 	vfnms.f32	s0, s12, s15
   2e534:	ee76 5ac0 	vsub.f32	s11, s13, s0
   2e538:	eef0 7a40 	vmov.f32	s15, s0
   2e53c:	ee15 3a90 	vmov	r3, s11
   2e540:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   2e544:	1aa4      	subs	r4, r4, r2
   2e546:	2c19      	cmp	r4, #25
   2e548:	dc04      	bgt.n	2e554 <__ieee754_rem_pio2f+0x15c>
   2e54a:	edc5 5a00 	vstr	s11, [r5]
   2e54e:	eeb0 0a66 	vmov.f32	s0, s13
   2e552:	e7c7      	b.n	2e4e4 <__ieee754_rem_pio2f+0xec>
   2e554:	eddf 5a3a 	vldr	s11, [pc, #232]	; 2e640 <__ieee754_rem_pio2f+0x248>
   2e558:	eeb0 0a66 	vmov.f32	s0, s13
   2e55c:	eea7 0a25 	vfma.f32	s0, s14, s11
   2e560:	ee76 7ac0 	vsub.f32	s15, s13, s0
   2e564:	eee7 7a25 	vfma.f32	s15, s14, s11
   2e568:	ed9f 7a36 	vldr	s14, [pc, #216]	; 2e644 <__ieee754_rem_pio2f+0x24c>
   2e56c:	eed6 7a07 	vfnms.f32	s15, s12, s14
   2e570:	ee30 7a67 	vsub.f32	s14, s0, s15
   2e574:	ed85 7a00 	vstr	s14, [r5]
   2e578:	e7b4      	b.n	2e4e4 <__ieee754_rem_pio2f+0xec>
   2e57a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   2e57e:	db06      	blt.n	2e58e <__ieee754_rem_pio2f+0x196>
   2e580:	ee70 7a40 	vsub.f32	s15, s0, s0
   2e584:	edc0 7a01 	vstr	s15, [r0, #4]
   2e588:	edc0 7a00 	vstr	s15, [r0]
   2e58c:	e742      	b.n	2e414 <__ieee754_rem_pio2f+0x1c>
   2e58e:	15e2      	asrs	r2, r4, #23
   2e590:	3a86      	subs	r2, #134	; 0x86
   2e592:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
   2e596:	ee07 3a90 	vmov	s15, r3
   2e59a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2e59e:	eddf 6a2a 	vldr	s13, [pc, #168]	; 2e648 <__ieee754_rem_pio2f+0x250>
   2e5a2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2e5a6:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e5aa:	ed8d 7a03 	vstr	s14, [sp, #12]
   2e5ae:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2e5b2:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2e5b6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2e5ba:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e5be:	ed8d 7a04 	vstr	s14, [sp, #16]
   2e5c2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2e5c6:	eef5 7a40 	vcmp.f32	s15, #0.0
   2e5ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e5ce:	edcd 7a05 	vstr	s15, [sp, #20]
   2e5d2:	d11e      	bne.n	2e612 <__ieee754_rem_pio2f+0x21a>
   2e5d4:	eeb5 7a40 	vcmp.f32	s14, #0.0
   2e5d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e5dc:	bf0c      	ite	eq
   2e5de:	2301      	moveq	r3, #1
   2e5e0:	2302      	movne	r3, #2
   2e5e2:	491a      	ldr	r1, [pc, #104]	; (2e64c <__ieee754_rem_pio2f+0x254>)
   2e5e4:	9101      	str	r1, [sp, #4]
   2e5e6:	2102      	movs	r1, #2
   2e5e8:	9100      	str	r1, [sp, #0]
   2e5ea:	a803      	add	r0, sp, #12
   2e5ec:	4629      	mov	r1, r5
   2e5ee:	f000 f8fb 	bl	2e7e8 <__kernel_rem_pio2f>
   2e5f2:	2e00      	cmp	r6, #0
   2e5f4:	f6bf af31 	bge.w	2e45a <__ieee754_rem_pio2f+0x62>
   2e5f8:	edd5 7a00 	vldr	s15, [r5]
   2e5fc:	eef1 7a67 	vneg.f32	s15, s15
   2e600:	edc5 7a00 	vstr	s15, [r5]
   2e604:	edd5 7a01 	vldr	s15, [r5, #4]
   2e608:	eef1 7a67 	vneg.f32	s15, s15
   2e60c:	edc5 7a01 	vstr	s15, [r5, #4]
   2e610:	e77a      	b.n	2e508 <__ieee754_rem_pio2f+0x110>
   2e612:	2303      	movs	r3, #3
   2e614:	e7e5      	b.n	2e5e2 <__ieee754_rem_pio2f+0x1ea>
   2e616:	bf00      	nop
   2e618:	3f490fd8 	.word	0x3f490fd8
   2e61c:	4016cbe3 	.word	0x4016cbe3
   2e620:	3fc90f80 	.word	0x3fc90f80
   2e624:	3fc90fd0 	.word	0x3fc90fd0
   2e628:	37354400 	.word	0x37354400
   2e62c:	37354443 	.word	0x37354443
   2e630:	2e85a308 	.word	0x2e85a308
   2e634:	43490f80 	.word	0x43490f80
   2e638:	3f22f984 	.word	0x3f22f984
   2e63c:	000524a0 	.word	0x000524a0
   2e640:	2e85a300 	.word	0x2e85a300
   2e644:	248d3132 	.word	0x248d3132
   2e648:	43800000 	.word	0x43800000
   2e64c:	00052520 	.word	0x00052520

0002e650 <__ieee754_sinhf>:
   2e650:	b510      	push	{r4, lr}
   2e652:	ee10 3a10 	vmov	r3, s0
   2e656:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   2e65a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   2e65e:	ed2d 8b02 	vpush	{d8}
   2e662:	eef0 7a40 	vmov.f32	s15, s0
   2e666:	db06      	blt.n	2e676 <__ieee754_sinhf+0x26>
   2e668:	ee70 7a00 	vadd.f32	s15, s0, s0
   2e66c:	ecbd 8b02 	vpop	{d8}
   2e670:	eeb0 0a67 	vmov.f32	s0, s15
   2e674:	bd10      	pop	{r4, pc}
   2e676:	2b00      	cmp	r3, #0
   2e678:	4b28      	ldr	r3, [pc, #160]	; (2e71c <__ieee754_sinhf+0xcc>)
   2e67a:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
   2e67e:	eebe 8a00 	vmov.f32	s16, #224	; 0xbf000000 -0.5
   2e682:	fe28 8a88 	vselge.f32	s16, s17, s16
   2e686:	429c      	cmp	r4, r3
   2e688:	dc2a      	bgt.n	2e6e0 <__ieee754_sinhf+0x90>
   2e68a:	f1b4 5f46 	cmp.w	r4, #830472192	; 0x31800000
   2e68e:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
   2e692:	da08      	bge.n	2e6a6 <__ieee754_sinhf+0x56>
   2e694:	ed9f 7a22 	vldr	s14, [pc, #136]	; 2e720 <__ieee754_sinhf+0xd0>
   2e698:	ee30 7a07 	vadd.f32	s14, s0, s14
   2e69c:	eeb4 7ae8 	vcmpe.f32	s14, s17
   2e6a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e6a4:	dce2      	bgt.n	2e66c <__ieee754_sinhf+0x1c>
   2e6a6:	eeb0 0a67 	vmov.f32	s0, s15
   2e6aa:	f7fe fbb1 	bl	2ce10 <fabsf>
   2e6ae:	f000 fdb9 	bl	2f224 <expm1f>
   2e6b2:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
   2e6b6:	bfbb      	ittet	lt
   2e6b8:	ee20 7a00 	vmullt.f32	s14, s0, s0
   2e6bc:	ee70 8a28 	vaddlt.f32	s17, s0, s17
   2e6c0:	ee70 8a28 	vaddge.f32	s17, s0, s17
   2e6c4:	eec7 7a28 	vdivlt.f32	s15, s14, s17
   2e6c8:	bfad      	iteet	ge
   2e6ca:	eec0 7a28 	vdivge.f32	s15, s0, s17
   2e6ce:	eeb0 7a00 	vmovlt.f32	s14, #0	; 0x40000000  2.0
   2e6d2:	eed0 7a07 	vfnmslt.f32	s15, s0, s14
   2e6d6:	ee77 7a80 	vaddge.f32	s15, s15, s0
   2e6da:	ee67 7a88 	vmul.f32	s15, s15, s16
   2e6de:	e7c5      	b.n	2e66c <__ieee754_sinhf+0x1c>
   2e6e0:	4b10      	ldr	r3, [pc, #64]	; (2e724 <__ieee754_sinhf+0xd4>)
   2e6e2:	429c      	cmp	r4, r3
   2e6e4:	dc06      	bgt.n	2e6f4 <__ieee754_sinhf+0xa4>
   2e6e6:	f7fe fb93 	bl	2ce10 <fabsf>
   2e6ea:	f7fe fb13 	bl	2cd14 <expf>
   2e6ee:	ee60 7a08 	vmul.f32	s15, s0, s16
   2e6f2:	e7bb      	b.n	2e66c <__ieee754_sinhf+0x1c>
   2e6f4:	4b0c      	ldr	r3, [pc, #48]	; (2e728 <__ieee754_sinhf+0xd8>)
   2e6f6:	429c      	cmp	r4, r3
   2e6f8:	dc0a      	bgt.n	2e710 <__ieee754_sinhf+0xc0>
   2e6fa:	f7fe fb89 	bl	2ce10 <fabsf>
   2e6fe:	ee20 0a28 	vmul.f32	s0, s0, s17
   2e702:	f7fe fb07 	bl	2cd14 <expf>
   2e706:	ee68 7a00 	vmul.f32	s15, s16, s0
   2e70a:	ee67 7a80 	vmul.f32	s15, s15, s0
   2e70e:	e7ad      	b.n	2e66c <__ieee754_sinhf+0x1c>
   2e710:	ed9f 7a03 	vldr	s14, [pc, #12]	; 2e720 <__ieee754_sinhf+0xd0>
   2e714:	ee60 7a07 	vmul.f32	s15, s0, s14
   2e718:	e7a8      	b.n	2e66c <__ieee754_sinhf+0x1c>
   2e71a:	bf00      	nop
   2e71c:	41afffff 	.word	0x41afffff
   2e720:	7cf0bdc2 	.word	0x7cf0bdc2
   2e724:	42b17217 	.word	0x42b17217
   2e728:	42b2d4fc 	.word	0x42b2d4fc

0002e72c <__kernel_cosf>:
   2e72c:	ee10 3a10 	vmov	r3, s0
   2e730:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2e734:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   2e738:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2e73c:	da05      	bge.n	2e74a <__kernel_cosf+0x1e>
   2e73e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2e742:	ee17 2a90 	vmov	r2, s15
   2e746:	2a00      	cmp	r2, #0
   2e748:	d03b      	beq.n	2e7c2 <__kernel_cosf+0x96>
   2e74a:	ee20 6a00 	vmul.f32	s12, s0, s0
   2e74e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   2e752:	eddf 5a1d 	vldr	s11, [pc, #116]	; 2e7c8 <__kernel_cosf+0x9c>
   2e756:	4a1d      	ldr	r2, [pc, #116]	; (2e7cc <__kernel_cosf+0xa0>)
   2e758:	ee66 7a07 	vmul.f32	s15, s12, s14
   2e75c:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 2e7d0 <__kernel_cosf+0xa4>
   2e760:	eea6 7a25 	vfma.f32	s14, s12, s11
   2e764:	4293      	cmp	r3, r2
   2e766:	eddf 5a1b 	vldr	s11, [pc, #108]	; 2e7d4 <__kernel_cosf+0xa8>
   2e76a:	eee7 5a06 	vfma.f32	s11, s14, s12
   2e76e:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 2e7d8 <__kernel_cosf+0xac>
   2e772:	eea5 7a86 	vfma.f32	s14, s11, s12
   2e776:	eddf 5a19 	vldr	s11, [pc, #100]	; 2e7dc <__kernel_cosf+0xb0>
   2e77a:	eee7 5a06 	vfma.f32	s11, s14, s12
   2e77e:	ed9f 7a18 	vldr	s14, [pc, #96]	; 2e7e0 <__kernel_cosf+0xb4>
   2e782:	eea5 7a86 	vfma.f32	s14, s11, s12
   2e786:	ee60 0ac0 	vnmul.f32	s1, s1, s0
   2e78a:	ee27 7a06 	vmul.f32	s14, s14, s12
   2e78e:	eee6 0a07 	vfma.f32	s1, s12, s14
   2e792:	dc04      	bgt.n	2e79e <__kernel_cosf+0x72>
   2e794:	ee77 0ae0 	vsub.f32	s1, s15, s1
   2e798:	ee36 0ae0 	vsub.f32	s0, s13, s1
   2e79c:	4770      	bx	lr
   2e79e:	4a11      	ldr	r2, [pc, #68]	; (2e7e4 <__kernel_cosf+0xb8>)
   2e7a0:	4293      	cmp	r3, r2
   2e7a2:	bfda      	itte	le
   2e7a4:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
   2e7a8:	ee07 3a10 	vmovle	s14, r3
   2e7ac:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
   2e7b0:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2e7b4:	ee36 0ac7 	vsub.f32	s0, s13, s14
   2e7b8:	ee77 7ae0 	vsub.f32	s15, s15, s1
   2e7bc:	ee30 0a67 	vsub.f32	s0, s0, s15
   2e7c0:	4770      	bx	lr
   2e7c2:	eeb0 0a66 	vmov.f32	s0, s13
   2e7c6:	4770      	bx	lr
   2e7c8:	ad47d74e 	.word	0xad47d74e
   2e7cc:	3e999999 	.word	0x3e999999
   2e7d0:	310f74f6 	.word	0x310f74f6
   2e7d4:	b493f27c 	.word	0xb493f27c
   2e7d8:	37d00d01 	.word	0x37d00d01
   2e7dc:	bab60b61 	.word	0xbab60b61
   2e7e0:	3d2aaaab 	.word	0x3d2aaaab
   2e7e4:	3f480000 	.word	0x3f480000

0002e7e8 <__kernel_rem_pio2f>:
   2e7e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e7ec:	ed2d 8b04 	vpush	{d8-d9}
   2e7f0:	b0d7      	sub	sp, #348	; 0x15c
   2e7f2:	469b      	mov	fp, r3
   2e7f4:	460e      	mov	r6, r1
   2e7f6:	4bbe      	ldr	r3, [pc, #760]	; (2eaf0 <__kernel_rem_pio2f+0x308>)
   2e7f8:	9964      	ldr	r1, [sp, #400]	; 0x190
   2e7fa:	9002      	str	r0, [sp, #8]
   2e7fc:	f853 9021 	ldr.w	r9, [r3, r1, lsl #2]
   2e800:	9865      	ldr	r0, [sp, #404]	; 0x194
   2e802:	ed9f 7abf 	vldr	s14, [pc, #764]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2e806:	1ed1      	subs	r1, r2, #3
   2e808:	2308      	movs	r3, #8
   2e80a:	fb91 f1f3 	sdiv	r1, r1, r3
   2e80e:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   2e812:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
   2e816:	1c4c      	adds	r4, r1, #1
   2e818:	eba2 04c4 	sub.w	r4, r2, r4, lsl #3
   2e81c:	eba1 050a 	sub.w	r5, r1, sl
   2e820:	aa1a      	add	r2, sp, #104	; 0x68
   2e822:	eb09 070a 	add.w	r7, r9, sl
   2e826:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
   2e82a:	4696      	mov	lr, r2
   2e82c:	2300      	movs	r3, #0
   2e82e:	42bb      	cmp	r3, r7
   2e830:	dd0f      	ble.n	2e852 <__kernel_rem_pio2f+0x6a>
   2e832:	af42      	add	r7, sp, #264	; 0x108
   2e834:	2200      	movs	r2, #0
   2e836:	454a      	cmp	r2, r9
   2e838:	dc27      	bgt.n	2e88a <__kernel_rem_pio2f+0xa2>
   2e83a:	f10d 0c68 	add.w	ip, sp, #104	; 0x68
   2e83e:	eb0b 0302 	add.w	r3, fp, r2
   2e842:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
   2e846:	9d02      	ldr	r5, [sp, #8]
   2e848:	eddf 7aad 	vldr	s15, [pc, #692]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2e84c:	f04f 0c00 	mov.w	ip, #0
   2e850:	e015      	b.n	2e87e <__kernel_rem_pio2f+0x96>
   2e852:	42dd      	cmn	r5, r3
   2e854:	bf5d      	ittte	pl
   2e856:	f85c 2023 	ldrpl.w	r2, [ip, r3, lsl #2]
   2e85a:	ee07 2a90 	vmovpl	s15, r2
   2e85e:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
   2e862:	eef0 7a47 	vmovmi.f32	s15, s14
   2e866:	ecee 7a01 	vstmia	lr!, {s15}
   2e86a:	3301      	adds	r3, #1
   2e86c:	e7df      	b.n	2e82e <__kernel_rem_pio2f+0x46>
   2e86e:	ecf5 6a01 	vldmia	r5!, {s13}
   2e872:	ed33 7a01 	vldmdb	r3!, {s14}
   2e876:	eee6 7a87 	vfma.f32	s15, s13, s14
   2e87a:	f10c 0c01 	add.w	ip, ip, #1
   2e87e:	45d4      	cmp	ip, sl
   2e880:	ddf5      	ble.n	2e86e <__kernel_rem_pio2f+0x86>
   2e882:	ece7 7a01 	vstmia	r7!, {s15}
   2e886:	3201      	adds	r2, #1
   2e888:	e7d5      	b.n	2e836 <__kernel_rem_pio2f+0x4e>
   2e88a:	ab06      	add	r3, sp, #24
   2e88c:	eb03 0389 	add.w	r3, r3, r9, lsl #2
   2e890:	9304      	str	r3, [sp, #16]
   2e892:	eddf 8a9a 	vldr	s17, [pc, #616]	; 2eafc <__kernel_rem_pio2f+0x314>
   2e896:	ed9f 9a98 	vldr	s18, [pc, #608]	; 2eaf8 <__kernel_rem_pio2f+0x310>
   2e89a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
   2e89e:	9303      	str	r3, [sp, #12]
   2e8a0:	464d      	mov	r5, r9
   2e8a2:	ab56      	add	r3, sp, #344	; 0x158
   2e8a4:	f105 4780 	add.w	r7, r5, #1073741824	; 0x40000000
   2e8a8:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   2e8ac:	3f01      	subs	r7, #1
   2e8ae:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
   2e8b2:	00bf      	lsls	r7, r7, #2
   2e8b4:	ab56      	add	r3, sp, #344	; 0x158
   2e8b6:	19da      	adds	r2, r3, r7
   2e8b8:	3a4c      	subs	r2, #76	; 0x4c
   2e8ba:	2300      	movs	r3, #0
   2e8bc:	1ae9      	subs	r1, r5, r3
   2e8be:	2900      	cmp	r1, #0
   2e8c0:	dc4c      	bgt.n	2e95c <__kernel_rem_pio2f+0x174>
   2e8c2:	4620      	mov	r0, r4
   2e8c4:	f000 fe24 	bl	2f510 <scalbnf>
   2e8c8:	eeb0 8a40 	vmov.f32	s16, s0
   2e8cc:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
   2e8d0:	ee28 0a00 	vmul.f32	s0, s16, s0
   2e8d4:	f000 fdda 	bl	2f48c <floorf>
   2e8d8:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   2e8dc:	eea0 8a67 	vfms.f32	s16, s0, s15
   2e8e0:	2c00      	cmp	r4, #0
   2e8e2:	eefd 7ac8 	vcvt.s32.f32	s15, s16
   2e8e6:	edcd 7a01 	vstr	s15, [sp, #4]
   2e8ea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e8ee:	ee38 8a67 	vsub.f32	s16, s16, s15
   2e8f2:	dd48      	ble.n	2e986 <__kernel_rem_pio2f+0x19e>
   2e8f4:	1e69      	subs	r1, r5, #1
   2e8f6:	ab06      	add	r3, sp, #24
   2e8f8:	f1c4 0008 	rsb	r0, r4, #8
   2e8fc:	f853 c021 	ldr.w	ip, [r3, r1, lsl #2]
   2e900:	9a01      	ldr	r2, [sp, #4]
   2e902:	fa4c f300 	asr.w	r3, ip, r0
   2e906:	441a      	add	r2, r3
   2e908:	4083      	lsls	r3, r0
   2e90a:	9201      	str	r2, [sp, #4]
   2e90c:	ebac 0203 	sub.w	r2, ip, r3
   2e910:	ab06      	add	r3, sp, #24
   2e912:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   2e916:	f1c4 0307 	rsb	r3, r4, #7
   2e91a:	fa42 f803 	asr.w	r8, r2, r3
   2e91e:	f1b8 0f00 	cmp.w	r8, #0
   2e922:	dd41      	ble.n	2e9a8 <__kernel_rem_pio2f+0x1c0>
   2e924:	9b01      	ldr	r3, [sp, #4]
   2e926:	2000      	movs	r0, #0
   2e928:	3301      	adds	r3, #1
   2e92a:	9301      	str	r3, [sp, #4]
   2e92c:	4601      	mov	r1, r0
   2e92e:	4285      	cmp	r5, r0
   2e930:	dc6d      	bgt.n	2ea0e <__kernel_rem_pio2f+0x226>
   2e932:	2c00      	cmp	r4, #0
   2e934:	dd04      	ble.n	2e940 <__kernel_rem_pio2f+0x158>
   2e936:	2c01      	cmp	r4, #1
   2e938:	d07e      	beq.n	2ea38 <__kernel_rem_pio2f+0x250>
   2e93a:	2c02      	cmp	r4, #2
   2e93c:	f000 8086 	beq.w	2ea4c <__kernel_rem_pio2f+0x264>
   2e940:	f1b8 0f02 	cmp.w	r8, #2
   2e944:	d130      	bne.n	2e9a8 <__kernel_rem_pio2f+0x1c0>
   2e946:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2e94a:	ee30 8a48 	vsub.f32	s16, s0, s16
   2e94e:	b359      	cbz	r1, 2e9a8 <__kernel_rem_pio2f+0x1c0>
   2e950:	4620      	mov	r0, r4
   2e952:	f000 fddd 	bl	2f510 <scalbnf>
   2e956:	ee38 8a40 	vsub.f32	s16, s16, s0
   2e95a:	e025      	b.n	2e9a8 <__kernel_rem_pio2f+0x1c0>
   2e95c:	ee60 7a28 	vmul.f32	s15, s0, s17
   2e960:	a806      	add	r0, sp, #24
   2e962:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2e966:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2e96a:	eea7 0ac9 	vfms.f32	s0, s15, s18
   2e96e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2e972:	ee10 1a10 	vmov	r1, s0
   2e976:	ed32 0a01 	vldmdb	r2!, {s0}
   2e97a:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
   2e97e:	ee37 0a80 	vadd.f32	s0, s15, s0
   2e982:	3301      	adds	r3, #1
   2e984:	e79a      	b.n	2e8bc <__kernel_rem_pio2f+0xd4>
   2e986:	d106      	bne.n	2e996 <__kernel_rem_pio2f+0x1ae>
   2e988:	1e6b      	subs	r3, r5, #1
   2e98a:	aa06      	add	r2, sp, #24
   2e98c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2e990:	ea4f 2822 	mov.w	r8, r2, asr #8
   2e994:	e7c3      	b.n	2e91e <__kernel_rem_pio2f+0x136>
   2e996:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2e99a:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2e99e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e9a2:	da31      	bge.n	2ea08 <__kernel_rem_pio2f+0x220>
   2e9a4:	f04f 0800 	mov.w	r8, #0
   2e9a8:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2e9ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2e9b0:	f040 80a8 	bne.w	2eb04 <__kernel_rem_pio2f+0x31c>
   2e9b4:	1e6b      	subs	r3, r5, #1
   2e9b6:	4618      	mov	r0, r3
   2e9b8:	2200      	movs	r2, #0
   2e9ba:	4548      	cmp	r0, r9
   2e9bc:	da4d      	bge.n	2ea5a <__kernel_rem_pio2f+0x272>
   2e9be:	2a00      	cmp	r2, #0
   2e9c0:	f000 8087 	beq.w	2ead2 <__kernel_rem_pio2f+0x2ea>
   2e9c4:	aa06      	add	r2, sp, #24
   2e9c6:	3c08      	subs	r4, #8
   2e9c8:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
   2e9cc:	2900      	cmp	r1, #0
   2e9ce:	f000 808d 	beq.w	2eaec <__kernel_rem_pio2f+0x304>
   2e9d2:	4620      	mov	r0, r4
   2e9d4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2e9d8:	9302      	str	r3, [sp, #8]
   2e9da:	f000 fd99 	bl	2f510 <scalbnf>
   2e9de:	9b02      	ldr	r3, [sp, #8]
   2e9e0:	ed9f 7a46 	vldr	s14, [pc, #280]	; 2eafc <__kernel_rem_pio2f+0x314>
   2e9e4:	0099      	lsls	r1, r3, #2
   2e9e6:	aa42      	add	r2, sp, #264	; 0x108
   2e9e8:	1850      	adds	r0, r2, r1
   2e9ea:	1d05      	adds	r5, r0, #4
   2e9ec:	461c      	mov	r4, r3
   2e9ee:	2c00      	cmp	r4, #0
   2e9f0:	f280 80b8 	bge.w	2eb64 <__kernel_rem_pio2f+0x37c>
   2e9f4:	2500      	movs	r5, #0
   2e9f6:	1b5c      	subs	r4, r3, r5
   2e9f8:	2c00      	cmp	r4, #0
   2e9fa:	f2c0 80d8 	blt.w	2ebae <__kernel_rem_pio2f+0x3c6>
   2e9fe:	4f3d      	ldr	r7, [pc, #244]	; (2eaf4 <__kernel_rem_pio2f+0x30c>)
   2ea00:	eddf 7a3f 	vldr	s15, [pc, #252]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2ea04:	2400      	movs	r4, #0
   2ea06:	e0c6      	b.n	2eb96 <__kernel_rem_pio2f+0x3ae>
   2ea08:	f04f 0802 	mov.w	r8, #2
   2ea0c:	e78a      	b.n	2e924 <__kernel_rem_pio2f+0x13c>
   2ea0e:	ab06      	add	r3, sp, #24
   2ea10:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2ea14:	b949      	cbnz	r1, 2ea2a <__kernel_rem_pio2f+0x242>
   2ea16:	b12b      	cbz	r3, 2ea24 <__kernel_rem_pio2f+0x23c>
   2ea18:	aa06      	add	r2, sp, #24
   2ea1a:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
   2ea1e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   2ea22:	2301      	movs	r3, #1
   2ea24:	3001      	adds	r0, #1
   2ea26:	4619      	mov	r1, r3
   2ea28:	e781      	b.n	2e92e <__kernel_rem_pio2f+0x146>
   2ea2a:	aa06      	add	r2, sp, #24
   2ea2c:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
   2ea30:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   2ea34:	460b      	mov	r3, r1
   2ea36:	e7f5      	b.n	2ea24 <__kernel_rem_pio2f+0x23c>
   2ea38:	1e68      	subs	r0, r5, #1
   2ea3a:	ab06      	add	r3, sp, #24
   2ea3c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2ea40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2ea44:	aa06      	add	r2, sp, #24
   2ea46:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   2ea4a:	e779      	b.n	2e940 <__kernel_rem_pio2f+0x158>
   2ea4c:	1e68      	subs	r0, r5, #1
   2ea4e:	ab06      	add	r3, sp, #24
   2ea50:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2ea54:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   2ea58:	e7f4      	b.n	2ea44 <__kernel_rem_pio2f+0x25c>
   2ea5a:	a906      	add	r1, sp, #24
   2ea5c:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   2ea60:	3801      	subs	r0, #1
   2ea62:	430a      	orrs	r2, r1
   2ea64:	e7a9      	b.n	2e9ba <__kernel_rem_pio2f+0x1d2>
   2ea66:	f10c 0c01 	add.w	ip, ip, #1
   2ea6a:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   2ea6e:	2a00      	cmp	r2, #0
   2ea70:	d0f9      	beq.n	2ea66 <__kernel_rem_pio2f+0x27e>
   2ea72:	eb0b 0305 	add.w	r3, fp, r5
   2ea76:	aa1a      	add	r2, sp, #104	; 0x68
   2ea78:	009b      	lsls	r3, r3, #2
   2ea7a:	1898      	adds	r0, r3, r2
   2ea7c:	3004      	adds	r0, #4
   2ea7e:	1c69      	adds	r1, r5, #1
   2ea80:	3704      	adds	r7, #4
   2ea82:	2200      	movs	r2, #0
   2ea84:	4465      	add	r5, ip
   2ea86:	9005      	str	r0, [sp, #20]
   2ea88:	428d      	cmp	r5, r1
   2ea8a:	f6ff af0a 	blt.w	2e8a2 <__kernel_rem_pio2f+0xba>
   2ea8e:	a81a      	add	r0, sp, #104	; 0x68
   2ea90:	eb02 0c03 	add.w	ip, r2, r3
   2ea94:	4484      	add	ip, r0
   2ea96:	9803      	ldr	r0, [sp, #12]
   2ea98:	f8dd e008 	ldr.w	lr, [sp, #8]
   2ea9c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
   2eaa0:	9001      	str	r0, [sp, #4]
   2eaa2:	ee07 0a90 	vmov	s15, r0
   2eaa6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2eaaa:	9805      	ldr	r0, [sp, #20]
   2eaac:	edcc 7a00 	vstr	s15, [ip]
   2eab0:	eddf 7a13 	vldr	s15, [pc, #76]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2eab4:	eb00 0802 	add.w	r8, r0, r2
   2eab8:	f04f 0c00 	mov.w	ip, #0
   2eabc:	45d4      	cmp	ip, sl
   2eabe:	dd0c      	ble.n	2eada <__kernel_rem_pio2f+0x2f2>
   2eac0:	eb02 0c07 	add.w	ip, r2, r7
   2eac4:	a842      	add	r0, sp, #264	; 0x108
   2eac6:	4484      	add	ip, r0
   2eac8:	edcc 7a01 	vstr	s15, [ip, #4]
   2eacc:	3101      	adds	r1, #1
   2eace:	3204      	adds	r2, #4
   2ead0:	e7da      	b.n	2ea88 <__kernel_rem_pio2f+0x2a0>
   2ead2:	9b04      	ldr	r3, [sp, #16]
   2ead4:	f04f 0c01 	mov.w	ip, #1
   2ead8:	e7c7      	b.n	2ea6a <__kernel_rem_pio2f+0x282>
   2eada:	ecfe 6a01 	vldmia	lr!, {s13}
   2eade:	ed38 7a01 	vldmdb	r8!, {s14}
   2eae2:	f10c 0c01 	add.w	ip, ip, #1
   2eae6:	eee6 7a87 	vfma.f32	s15, s13, s14
   2eaea:	e7e7      	b.n	2eabc <__kernel_rem_pio2f+0x2d4>
   2eaec:	3b01      	subs	r3, #1
   2eaee:	e769      	b.n	2e9c4 <__kernel_rem_pio2f+0x1dc>
   2eaf0:	00052864 	.word	0x00052864
   2eaf4:	00052838 	.word	0x00052838
   2eaf8:	43800000 	.word	0x43800000
   2eafc:	3b800000 	.word	0x3b800000
   2eb00:	00000000 	.word	0x00000000
   2eb04:	4260      	negs	r0, r4
   2eb06:	eeb0 0a48 	vmov.f32	s0, s16
   2eb0a:	f000 fd01 	bl	2f510 <scalbnf>
   2eb0e:	ed1f 7a06 	vldr	s14, [pc, #-24]	; 2eaf8 <__kernel_rem_pio2f+0x310>
   2eb12:	eeb4 0ac7 	vcmpe.f32	s0, s14
   2eb16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2eb1a:	db1a      	blt.n	2eb52 <__kernel_rem_pio2f+0x36a>
   2eb1c:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 2eafc <__kernel_rem_pio2f+0x314>
   2eb20:	ee60 7a27 	vmul.f32	s15, s0, s15
   2eb24:	aa06      	add	r2, sp, #24
   2eb26:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2eb2a:	a906      	add	r1, sp, #24
   2eb2c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2eb30:	3408      	adds	r4, #8
   2eb32:	eea7 0ac7 	vfms.f32	s0, s15, s14
   2eb36:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2eb3a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2eb3e:	ee10 3a10 	vmov	r3, s0
   2eb42:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
   2eb46:	1c6b      	adds	r3, r5, #1
   2eb48:	ee17 2a90 	vmov	r2, s15
   2eb4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   2eb50:	e73f      	b.n	2e9d2 <__kernel_rem_pio2f+0x1ea>
   2eb52:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2eb56:	aa06      	add	r2, sp, #24
   2eb58:	ee10 3a10 	vmov	r3, s0
   2eb5c:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
   2eb60:	462b      	mov	r3, r5
   2eb62:	e736      	b.n	2e9d2 <__kernel_rem_pio2f+0x1ea>
   2eb64:	aa06      	add	r2, sp, #24
   2eb66:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
   2eb6a:	9202      	str	r2, [sp, #8]
   2eb6c:	ee07 2a90 	vmov	s15, r2
   2eb70:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2eb74:	3c01      	subs	r4, #1
   2eb76:	ee67 7a80 	vmul.f32	s15, s15, s0
   2eb7a:	ee20 0a07 	vmul.f32	s0, s0, s14
   2eb7e:	ed65 7a01 	vstmdb	r5!, {s15}
   2eb82:	e734      	b.n	2e9ee <__kernel_rem_pio2f+0x206>
   2eb84:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
   2eb88:	ecf7 6a01 	vldmia	r7!, {s13}
   2eb8c:	ed9c 7a00 	vldr	s14, [ip]
   2eb90:	eee6 7a87 	vfma.f32	s15, s13, s14
   2eb94:	3401      	adds	r4, #1
   2eb96:	454c      	cmp	r4, r9
   2eb98:	dc01      	bgt.n	2eb9e <__kernel_rem_pio2f+0x3b6>
   2eb9a:	42a5      	cmp	r5, r4
   2eb9c:	daf2      	bge.n	2eb84 <__kernel_rem_pio2f+0x39c>
   2eb9e:	aa56      	add	r2, sp, #344	; 0x158
   2eba0:	eb02 0485 	add.w	r4, r2, r5, lsl #2
   2eba4:	ed44 7a28 	vstr	s15, [r4, #-160]	; 0xffffff60
   2eba8:	3501      	adds	r5, #1
   2ebaa:	3804      	subs	r0, #4
   2ebac:	e723      	b.n	2e9f6 <__kernel_rem_pio2f+0x20e>
   2ebae:	9a64      	ldr	r2, [sp, #400]	; 0x190
   2ebb0:	2a03      	cmp	r2, #3
   2ebb2:	d84d      	bhi.n	2ec50 <__kernel_rem_pio2f+0x468>
   2ebb4:	e8df f002 	tbb	[pc, r2]
   2ebb8:	021f1f3e 	.word	0x021f1f3e
   2ebbc:	aa56      	add	r2, sp, #344	; 0x158
   2ebbe:	4411      	add	r1, r2
   2ebc0:	399c      	subs	r1, #156	; 0x9c
   2ebc2:	4608      	mov	r0, r1
   2ebc4:	461c      	mov	r4, r3
   2ebc6:	2c00      	cmp	r4, #0
   2ebc8:	dc5f      	bgt.n	2ec8a <__kernel_rem_pio2f+0x4a2>
   2ebca:	4608      	mov	r0, r1
   2ebcc:	461c      	mov	r4, r3
   2ebce:	2c01      	cmp	r4, #1
   2ebd0:	dc6b      	bgt.n	2ecaa <__kernel_rem_pio2f+0x4c2>
   2ebd2:	ed5f 7a35 	vldr	s15, [pc, #-212]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2ebd6:	2b01      	cmp	r3, #1
   2ebd8:	dc77      	bgt.n	2ecca <__kernel_rem_pio2f+0x4e2>
   2ebda:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
   2ebde:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
   2ebe2:	f1b8 0f00 	cmp.w	r8, #0
   2ebe6:	d176      	bne.n	2ecd6 <__kernel_rem_pio2f+0x4ee>
   2ebe8:	edc6 6a00 	vstr	s13, [r6]
   2ebec:	ed86 7a01 	vstr	s14, [r6, #4]
   2ebf0:	edc6 7a02 	vstr	s15, [r6, #8]
   2ebf4:	e02c      	b.n	2ec50 <__kernel_rem_pio2f+0x468>
   2ebf6:	aa56      	add	r2, sp, #344	; 0x158
   2ebf8:	4411      	add	r1, r2
   2ebfa:	ed1f 7a3f 	vldr	s14, [pc, #-252]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2ebfe:	399c      	subs	r1, #156	; 0x9c
   2ec00:	4618      	mov	r0, r3
   2ec02:	2800      	cmp	r0, #0
   2ec04:	da32      	bge.n	2ec6c <__kernel_rem_pio2f+0x484>
   2ec06:	f1b8 0f00 	cmp.w	r8, #0
   2ec0a:	d035      	beq.n	2ec78 <__kernel_rem_pio2f+0x490>
   2ec0c:	eef1 7a47 	vneg.f32	s15, s14
   2ec10:	edc6 7a00 	vstr	s15, [r6]
   2ec14:	eddd 7a2e 	vldr	s15, [sp, #184]	; 0xb8
   2ec18:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2ec1c:	a82f      	add	r0, sp, #188	; 0xbc
   2ec1e:	2101      	movs	r1, #1
   2ec20:	428b      	cmp	r3, r1
   2ec22:	da2c      	bge.n	2ec7e <__kernel_rem_pio2f+0x496>
   2ec24:	f1b8 0f00 	cmp.w	r8, #0
   2ec28:	d001      	beq.n	2ec2e <__kernel_rem_pio2f+0x446>
   2ec2a:	eef1 7a67 	vneg.f32	s15, s15
   2ec2e:	edc6 7a01 	vstr	s15, [r6, #4]
   2ec32:	e00d      	b.n	2ec50 <__kernel_rem_pio2f+0x468>
   2ec34:	aa56      	add	r2, sp, #344	; 0x158
   2ec36:	4411      	add	r1, r2
   2ec38:	ed5f 7a4f 	vldr	s15, [pc, #-316]	; 2eb00 <__kernel_rem_pio2f+0x318>
   2ec3c:	399c      	subs	r1, #156	; 0x9c
   2ec3e:	2b00      	cmp	r3, #0
   2ec40:	da0e      	bge.n	2ec60 <__kernel_rem_pio2f+0x478>
   2ec42:	f1b8 0f00 	cmp.w	r8, #0
   2ec46:	d001      	beq.n	2ec4c <__kernel_rem_pio2f+0x464>
   2ec48:	eef1 7a67 	vneg.f32	s15, s15
   2ec4c:	edc6 7a00 	vstr	s15, [r6]
   2ec50:	9b01      	ldr	r3, [sp, #4]
   2ec52:	f003 0007 	and.w	r0, r3, #7
   2ec56:	b057      	add	sp, #348	; 0x15c
   2ec58:	ecbd 8b04 	vpop	{d8-d9}
   2ec5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ec60:	ed31 7a01 	vldmdb	r1!, {s14}
   2ec64:	3b01      	subs	r3, #1
   2ec66:	ee77 7a87 	vadd.f32	s15, s15, s14
   2ec6a:	e7e8      	b.n	2ec3e <__kernel_rem_pio2f+0x456>
   2ec6c:	ed71 7a01 	vldmdb	r1!, {s15}
   2ec70:	3801      	subs	r0, #1
   2ec72:	ee37 7a27 	vadd.f32	s14, s14, s15
   2ec76:	e7c4      	b.n	2ec02 <__kernel_rem_pio2f+0x41a>
   2ec78:	eef0 7a47 	vmov.f32	s15, s14
   2ec7c:	e7c8      	b.n	2ec10 <__kernel_rem_pio2f+0x428>
   2ec7e:	ecb0 7a01 	vldmia	r0!, {s14}
   2ec82:	3101      	adds	r1, #1
   2ec84:	ee77 7a87 	vadd.f32	s15, s15, s14
   2ec88:	e7ca      	b.n	2ec20 <__kernel_rem_pio2f+0x438>
   2ec8a:	ed50 7a02 	vldr	s15, [r0, #-8]
   2ec8e:	ed70 6a01 	vldmdb	r0!, {s13}
   2ec92:	ee37 7aa6 	vadd.f32	s14, s15, s13
   2ec96:	3c01      	subs	r4, #1
   2ec98:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2ec9c:	ed00 7a01 	vstr	s14, [r0, #-4]
   2eca0:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2eca4:	edc0 7a00 	vstr	s15, [r0]
   2eca8:	e78d      	b.n	2ebc6 <__kernel_rem_pio2f+0x3de>
   2ecaa:	ed50 7a02 	vldr	s15, [r0, #-8]
   2ecae:	ed70 6a01 	vldmdb	r0!, {s13}
   2ecb2:	ee37 7aa6 	vadd.f32	s14, s15, s13
   2ecb6:	3c01      	subs	r4, #1
   2ecb8:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2ecbc:	ed00 7a01 	vstr	s14, [r0, #-4]
   2ecc0:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2ecc4:	edc0 7a00 	vstr	s15, [r0]
   2ecc8:	e781      	b.n	2ebce <__kernel_rem_pio2f+0x3e6>
   2ecca:	ed31 7a01 	vldmdb	r1!, {s14}
   2ecce:	3b01      	subs	r3, #1
   2ecd0:	ee77 7a87 	vadd.f32	s15, s15, s14
   2ecd4:	e77f      	b.n	2ebd6 <__kernel_rem_pio2f+0x3ee>
   2ecd6:	eef1 6a66 	vneg.f32	s13, s13
   2ecda:	eeb1 7a47 	vneg.f32	s14, s14
   2ecde:	edc6 6a00 	vstr	s13, [r6]
   2ece2:	ed86 7a01 	vstr	s14, [r6, #4]
   2ece6:	eef1 7a67 	vneg.f32	s15, s15
   2ecea:	e781      	b.n	2ebf0 <__kernel_rem_pio2f+0x408>

0002ecec <__kernel_sinf>:
   2ecec:	ee10 3a10 	vmov	r3, s0
   2ecf0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2ecf4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   2ecf8:	da04      	bge.n	2ed04 <__kernel_sinf+0x18>
   2ecfa:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2ecfe:	ee17 3a90 	vmov	r3, s15
   2ed02:	b35b      	cbz	r3, 2ed5c <__kernel_sinf+0x70>
   2ed04:	ee20 7a00 	vmul.f32	s14, s0, s0
   2ed08:	eddf 7a15 	vldr	s15, [pc, #84]	; 2ed60 <__kernel_sinf+0x74>
   2ed0c:	ed9f 6a15 	vldr	s12, [pc, #84]	; 2ed64 <__kernel_sinf+0x78>
   2ed10:	eea7 6a27 	vfma.f32	s12, s14, s15
   2ed14:	eddf 7a14 	vldr	s15, [pc, #80]	; 2ed68 <__kernel_sinf+0x7c>
   2ed18:	eee6 7a07 	vfma.f32	s15, s12, s14
   2ed1c:	ed9f 6a13 	vldr	s12, [pc, #76]	; 2ed6c <__kernel_sinf+0x80>
   2ed20:	eea7 6a87 	vfma.f32	s12, s15, s14
   2ed24:	eddf 7a12 	vldr	s15, [pc, #72]	; 2ed70 <__kernel_sinf+0x84>
   2ed28:	ee60 6a07 	vmul.f32	s13, s0, s14
   2ed2c:	eee6 7a07 	vfma.f32	s15, s12, s14
   2ed30:	b930      	cbnz	r0, 2ed40 <__kernel_sinf+0x54>
   2ed32:	ed9f 6a10 	vldr	s12, [pc, #64]	; 2ed74 <__kernel_sinf+0x88>
   2ed36:	eea7 6a27 	vfma.f32	s12, s14, s15
   2ed3a:	eea6 0a26 	vfma.f32	s0, s12, s13
   2ed3e:	4770      	bx	lr
   2ed40:	ee67 7ae6 	vnmul.f32	s15, s15, s13
   2ed44:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   2ed48:	eee0 7a86 	vfma.f32	s15, s1, s12
   2ed4c:	eed7 0a87 	vfnms.f32	s1, s15, s14
   2ed50:	eddf 7a09 	vldr	s15, [pc, #36]	; 2ed78 <__kernel_sinf+0x8c>
   2ed54:	eee6 0aa7 	vfma.f32	s1, s13, s15
   2ed58:	ee30 0a60 	vsub.f32	s0, s0, s1
   2ed5c:	4770      	bx	lr
   2ed5e:	bf00      	nop
   2ed60:	2f2ec9d3 	.word	0x2f2ec9d3
   2ed64:	b2d72f34 	.word	0xb2d72f34
   2ed68:	3638ef1b 	.word	0x3638ef1b
   2ed6c:	b9500d01 	.word	0xb9500d01
   2ed70:	3c088889 	.word	0x3c088889
   2ed74:	be2aaaab 	.word	0xbe2aaaab
   2ed78:	3e2aaaab 	.word	0x3e2aaaab

0002ed7c <__kernel_tanf>:
   2ed7c:	b508      	push	{r3, lr}
   2ed7e:	ee10 3a10 	vmov	r3, s0
   2ed82:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
   2ed86:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
   2ed8a:	eef0 7a40 	vmov.f32	s15, s0
   2ed8e:	da17      	bge.n	2edc0 <__kernel_tanf+0x44>
   2ed90:	eebd 7ac0 	vcvt.s32.f32	s14, s0
   2ed94:	ee17 1a10 	vmov	r1, s14
   2ed98:	bb41      	cbnz	r1, 2edec <__kernel_tanf+0x70>
   2ed9a:	1c43      	adds	r3, r0, #1
   2ed9c:	4313      	orrs	r3, r2
   2ed9e:	d108      	bne.n	2edb2 <__kernel_tanf+0x36>
   2eda0:	f7fe f836 	bl	2ce10 <fabsf>
   2eda4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2eda8:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2edac:	eeb0 0a67 	vmov.f32	s0, s15
   2edb0:	bd08      	pop	{r3, pc}
   2edb2:	2801      	cmp	r0, #1
   2edb4:	d0fa      	beq.n	2edac <__kernel_tanf+0x30>
   2edb6:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2edba:	eec7 7a00 	vdiv.f32	s15, s14, s0
   2edbe:	e7f5      	b.n	2edac <__kernel_tanf+0x30>
   2edc0:	494e      	ldr	r1, [pc, #312]	; (2eefc <__kernel_tanf+0x180>)
   2edc2:	428a      	cmp	r2, r1
   2edc4:	dd12      	ble.n	2edec <__kernel_tanf+0x70>
   2edc6:	2b00      	cmp	r3, #0
   2edc8:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 2ef00 <__kernel_tanf+0x184>
   2edcc:	bfb8      	it	lt
   2edce:	eef1 7a40 	vneglt.f32	s15, s0
   2edd2:	ee77 7a67 	vsub.f32	s15, s14, s15
   2edd6:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 2ef04 <__kernel_tanf+0x188>
   2edda:	bfb8      	it	lt
   2eddc:	eef1 0a60 	vneglt.f32	s1, s1
   2ede0:	ee77 0a60 	vsub.f32	s1, s14, s1
   2ede4:	ee70 7aa7 	vadd.f32	s15, s1, s15
   2ede8:	eddf 0a47 	vldr	s1, [pc, #284]	; 2ef08 <__kernel_tanf+0x18c>
   2edec:	ed9f 6a47 	vldr	s12, [pc, #284]	; 2ef0c <__kernel_tanf+0x190>
   2edf0:	eddf 5a47 	vldr	s11, [pc, #284]	; 2ef10 <__kernel_tanf+0x194>
   2edf4:	ed9f 5a47 	vldr	s10, [pc, #284]	; 2ef14 <__kernel_tanf+0x198>
   2edf8:	4940      	ldr	r1, [pc, #256]	; (2eefc <__kernel_tanf+0x180>)
   2edfa:	ee67 6aa7 	vmul.f32	s13, s15, s15
   2edfe:	428a      	cmp	r2, r1
   2ee00:	ee26 7aa6 	vmul.f32	s14, s13, s13
   2ee04:	ee67 4aa6 	vmul.f32	s9, s15, s13
   2ee08:	eee7 5a06 	vfma.f32	s11, s14, s12
   2ee0c:	ed9f 6a42 	vldr	s12, [pc, #264]	; 2ef18 <__kernel_tanf+0x19c>
   2ee10:	eea5 6a87 	vfma.f32	s12, s11, s14
   2ee14:	eddf 5a41 	vldr	s11, [pc, #260]	; 2ef1c <__kernel_tanf+0x1a0>
   2ee18:	eee6 5a07 	vfma.f32	s11, s12, s14
   2ee1c:	ed9f 6a40 	vldr	s12, [pc, #256]	; 2ef20 <__kernel_tanf+0x1a4>
   2ee20:	eea5 6a87 	vfma.f32	s12, s11, s14
   2ee24:	eddf 5a3f 	vldr	s11, [pc, #252]	; 2ef24 <__kernel_tanf+0x1a8>
   2ee28:	eee6 5a07 	vfma.f32	s11, s12, s14
   2ee2c:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 2ef28 <__kernel_tanf+0x1ac>
   2ee30:	eea7 6a05 	vfma.f32	s12, s14, s10
   2ee34:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 2ef2c <__kernel_tanf+0x1b0>
   2ee38:	eea6 5a07 	vfma.f32	s10, s12, s14
   2ee3c:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 2ef30 <__kernel_tanf+0x1b4>
   2ee40:	eea5 6a07 	vfma.f32	s12, s10, s14
   2ee44:	ed9f 5a3b 	vldr	s10, [pc, #236]	; 2ef34 <__kernel_tanf+0x1b8>
   2ee48:	eea6 5a07 	vfma.f32	s10, s12, s14
   2ee4c:	ed9f 6a3a 	vldr	s12, [pc, #232]	; 2ef38 <__kernel_tanf+0x1bc>
   2ee50:	eea5 6a07 	vfma.f32	s12, s10, s14
   2ee54:	eeb0 7a46 	vmov.f32	s14, s12
   2ee58:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2ee5c:	eeb0 6a60 	vmov.f32	s12, s1
   2ee60:	eea7 6a24 	vfma.f32	s12, s14, s9
   2ee64:	ed9f 7a35 	vldr	s14, [pc, #212]	; 2ef3c <__kernel_tanf+0x1c0>
   2ee68:	eee6 0a26 	vfma.f32	s1, s12, s13
   2ee6c:	eee4 0a87 	vfma.f32	s1, s9, s14
   2ee70:	ee77 6aa0 	vadd.f32	s13, s15, s1
   2ee74:	dd1d      	ble.n	2eeb2 <__kernel_tanf+0x136>
   2ee76:	ee07 0a10 	vmov	s14, r0
   2ee7a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2ee7e:	ee66 5aa6 	vmul.f32	s11, s13, s13
   2ee82:	ee76 6a87 	vadd.f32	s13, s13, s14
   2ee86:	179b      	asrs	r3, r3, #30
   2ee88:	ee85 6aa6 	vdiv.f32	s12, s11, s13
   2ee8c:	f003 0302 	and.w	r3, r3, #2
   2ee90:	f1c3 0301 	rsb	r3, r3, #1
   2ee94:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
   2ee98:	ee76 0a60 	vsub.f32	s1, s12, s1
   2ee9c:	ee77 7ae0 	vsub.f32	s15, s15, s1
   2eea0:	eea7 7ae6 	vfms.f32	s14, s15, s13
   2eea4:	ee07 3a90 	vmov	s15, r3
   2eea8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2eeac:	ee67 7a27 	vmul.f32	s15, s14, s15
   2eeb0:	e77c      	b.n	2edac <__kernel_tanf+0x30>
   2eeb2:	2801      	cmp	r0, #1
   2eeb4:	d01f      	beq.n	2eef6 <__kernel_tanf+0x17a>
   2eeb6:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
   2eeba:	eec7 5a26 	vdiv.f32	s11, s14, s13
   2eebe:	4b20      	ldr	r3, [pc, #128]	; (2ef40 <__kernel_tanf+0x1c4>)
   2eec0:	ee16 2a90 	vmov	r2, s13
   2eec4:	401a      	ands	r2, r3
   2eec6:	ee06 2a10 	vmov	s12, r2
   2eeca:	ee15 2a90 	vmov	r2, s11
   2eece:	4013      	ands	r3, r2
   2eed0:	ee07 3a10 	vmov	s14, r3
   2eed4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2eed8:	eee6 6a07 	vfma.f32	s13, s12, s14
   2eedc:	ee76 7a67 	vsub.f32	s15, s12, s15
   2eee0:	ee70 0ae7 	vsub.f32	s1, s1, s15
   2eee4:	eef0 7a66 	vmov.f32	s15, s13
   2eee8:	eee7 7a20 	vfma.f32	s15, s14, s1
   2eeec:	eea7 7aa5 	vfma.f32	s14, s15, s11
   2eef0:	eef0 7a47 	vmov.f32	s15, s14
   2eef4:	e75a      	b.n	2edac <__kernel_tanf+0x30>
   2eef6:	eef0 7a66 	vmov.f32	s15, s13
   2eefa:	e757      	b.n	2edac <__kernel_tanf+0x30>
   2eefc:	3f2ca13f 	.word	0x3f2ca13f
   2ef00:	3f490fda 	.word	0x3f490fda
   2ef04:	33222168 	.word	0x33222168
   2ef08:	00000000 	.word	0x00000000
   2ef0c:	37d95384 	.word	0x37d95384
   2ef10:	3895c07a 	.word	0x3895c07a
   2ef14:	b79bae5f 	.word	0xb79bae5f
   2ef18:	398137b9 	.word	0x398137b9
   2ef1c:	3abede48 	.word	0x3abede48
   2ef20:	3c11371f 	.word	0x3c11371f
   2ef24:	3d5d0dd1 	.word	0x3d5d0dd1
   2ef28:	38a3f445 	.word	0x38a3f445
   2ef2c:	3a1a26c8 	.word	0x3a1a26c8
   2ef30:	3b6b6916 	.word	0x3b6b6916
   2ef34:	3cb327a4 	.word	0x3cb327a4
   2ef38:	3e088889 	.word	0x3e088889
   2ef3c:	3eaaaaab 	.word	0x3eaaaaab
   2ef40:	fffff000 	.word	0xfffff000

0002ef44 <with_errnof>:
   2ef44:	b510      	push	{r4, lr}
   2ef46:	ed2d 8b02 	vpush	{d8}
   2ef4a:	eeb0 8a40 	vmov.f32	s16, s0
   2ef4e:	4604      	mov	r4, r0
   2ef50:	f7fd fd28 	bl	2c9a4 <__errno>
   2ef54:	eeb0 0a48 	vmov.f32	s0, s16
   2ef58:	ecbd 8b02 	vpop	{d8}
   2ef5c:	6004      	str	r4, [r0, #0]
   2ef5e:	bd10      	pop	{r4, pc}

0002ef60 <xflowf>:
   2ef60:	b130      	cbz	r0, 2ef70 <xflowf+0x10>
   2ef62:	eef1 7a40 	vneg.f32	s15, s0
   2ef66:	2022      	movs	r0, #34	; 0x22
   2ef68:	ee27 0a80 	vmul.f32	s0, s15, s0
   2ef6c:	f7ff bfea 	b.w	2ef44 <with_errnof>
   2ef70:	eef0 7a40 	vmov.f32	s15, s0
   2ef74:	e7f7      	b.n	2ef66 <xflowf+0x6>
	...

0002ef78 <__math_uflowf>:
   2ef78:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2ef80 <__math_uflowf+0x8>
   2ef7c:	f7ff bff0 	b.w	2ef60 <xflowf>
   2ef80:	10000000 	.word	0x10000000

0002ef84 <__math_may_uflowf>:
   2ef84:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2ef8c <__math_may_uflowf+0x8>
   2ef88:	f7ff bfea 	b.w	2ef60 <xflowf>
   2ef8c:	1a200000 	.word	0x1a200000

0002ef90 <__math_oflowf>:
   2ef90:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2ef98 <__math_oflowf+0x8>
   2ef94:	f7ff bfe4 	b.w	2ef60 <xflowf>
   2ef98:	70000000 	.word	0x70000000

0002ef9c <__math_divzerof>:
   2ef9c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2efa0:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   2efa4:	2800      	cmp	r0, #0
   2efa6:	fe40 7a27 	vseleq.f32	s15, s0, s15
   2efaa:	ed9f 0a03 	vldr	s0, [pc, #12]	; 2efb8 <__math_divzerof+0x1c>
   2efae:	2022      	movs	r0, #34	; 0x22
   2efb0:	ee87 0a80 	vdiv.f32	s0, s15, s0
   2efb4:	f7ff bfc6 	b.w	2ef44 <with_errnof>
   2efb8:	00000000 	.word	0x00000000

0002efbc <__math_invalidf>:
   2efbc:	eef0 7a40 	vmov.f32	s15, s0
   2efc0:	ee30 7a40 	vsub.f32	s14, s0, s0
   2efc4:	eef4 7a67 	vcmp.f32	s15, s15
   2efc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2efcc:	ee87 0a07 	vdiv.f32	s0, s14, s14
   2efd0:	d602      	bvs.n	2efd8 <__math_invalidf+0x1c>
   2efd2:	2021      	movs	r0, #33	; 0x21
   2efd4:	f7ff bfb6 	b.w	2ef44 <with_errnof>
   2efd8:	4770      	bx	lr

0002efda <fabs>:
   2efda:	ec51 0b10 	vmov	r0, r1, d0
   2efde:	ee10 2a10 	vmov	r2, s0
   2efe2:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   2efe6:	ec43 2b10 	vmov	d0, r2, r3
   2efea:	4770      	bx	lr

0002efec <finite>:
   2efec:	ee10 3a90 	vmov	r3, s1
   2eff0:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
   2eff4:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
   2eff8:	0fc0      	lsrs	r0, r0, #31
   2effa:	4770      	bx	lr

0002effc <matherr>:
   2effc:	2000      	movs	r0, #0
   2effe:	4770      	bx	lr

0002f000 <nan>:
   2f000:	ed9f 0b01 	vldr	d0, [pc, #4]	; 2f008 <nan+0x8>
   2f004:	4770      	bx	lr
   2f006:	bf00      	nop
   2f008:	00000000 	.word	0x00000000
   2f00c:	7ff80000 	.word	0x7ff80000

0002f010 <rint>:
   2f010:	b530      	push	{r4, r5, lr}
   2f012:	b085      	sub	sp, #20
   2f014:	ed8d 0b00 	vstr	d0, [sp]
   2f018:	e9dd 2300 	ldrd	r2, r3, [sp]
   2f01c:	f3c3 510a 	ubfx	r1, r3, #20, #11
   2f020:	f2a1 30ff 	subw	r0, r1, #1023	; 0x3ff
   2f024:	2813      	cmp	r0, #19
   2f026:	ea4f 74d3 	mov.w	r4, r3, lsr #31
   2f02a:	dc5a      	bgt.n	2f0e2 <rint+0xd2>
   2f02c:	2800      	cmp	r0, #0
   2f02e:	da2f      	bge.n	2f090 <rint+0x80>
   2f030:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2f034:	4311      	orrs	r1, r2
   2f036:	d027      	beq.n	2f088 <rint+0x78>
   2f038:	f3c3 0513 	ubfx	r5, r3, #0, #20
   2f03c:	4315      	orrs	r5, r2
   2f03e:	426a      	negs	r2, r5
   2f040:	432a      	orrs	r2, r5
   2f042:	0b12      	lsrs	r2, r2, #12
   2f044:	0c5b      	lsrs	r3, r3, #17
   2f046:	045b      	lsls	r3, r3, #17
   2f048:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
   2f04c:	e9dd 0100 	ldrd	r0, r1, [sp]
   2f050:	ea42 0103 	orr.w	r1, r2, r3
   2f054:	4b31      	ldr	r3, [pc, #196]	; (2f11c <rint+0x10c>)
   2f056:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   2f05a:	ed93 6b00 	vldr	d6, [r3]
   2f05e:	ec41 0b17 	vmov	d7, r0, r1
   2f062:	ee36 7b07 	vadd.f64	d7, d6, d7
   2f066:	ed8d 7b02 	vstr	d7, [sp, #8]
   2f06a:	ed9d 7b02 	vldr	d7, [sp, #8]
   2f06e:	ee37 7b46 	vsub.f64	d7, d7, d6
   2f072:	ed8d 7b00 	vstr	d7, [sp]
   2f076:	9b01      	ldr	r3, [sp, #4]
   2f078:	e9dd 0100 	ldrd	r0, r1, [sp]
   2f07c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2f080:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
   2f084:	e9cd 0100 	strd	r0, r1, [sp]
   2f088:	ed9d 0b00 	vldr	d0, [sp]
   2f08c:	b005      	add	sp, #20
   2f08e:	bd30      	pop	{r4, r5, pc}
   2f090:	4923      	ldr	r1, [pc, #140]	; (2f120 <rint+0x110>)
   2f092:	4101      	asrs	r1, r0
   2f094:	ea03 0501 	and.w	r5, r3, r1
   2f098:	4315      	orrs	r5, r2
   2f09a:	d0f5      	beq.n	2f088 <rint+0x78>
   2f09c:	0849      	lsrs	r1, r1, #1
   2f09e:	ea03 0501 	and.w	r5, r3, r1
   2f0a2:	432a      	orrs	r2, r5
   2f0a4:	d00b      	beq.n	2f0be <rint+0xae>
   2f0a6:	ea23 0101 	bic.w	r1, r3, r1
   2f0aa:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   2f0ae:	2813      	cmp	r0, #19
   2f0b0:	fa43 f300 	asr.w	r3, r3, r0
   2f0b4:	bf0c      	ite	eq
   2f0b6:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
   2f0ba:	2200      	movne	r2, #0
   2f0bc:	430b      	orrs	r3, r1
   2f0be:	4619      	mov	r1, r3
   2f0c0:	4b16      	ldr	r3, [pc, #88]	; (2f11c <rint+0x10c>)
   2f0c2:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   2f0c6:	ed94 6b00 	vldr	d6, [r4]
   2f0ca:	4610      	mov	r0, r2
   2f0cc:	ec41 0b17 	vmov	d7, r0, r1
   2f0d0:	ee36 7b07 	vadd.f64	d7, d6, d7
   2f0d4:	ed8d 7b02 	vstr	d7, [sp, #8]
   2f0d8:	ed9d 7b02 	vldr	d7, [sp, #8]
   2f0dc:	ee37 7b46 	vsub.f64	d7, d7, d6
   2f0e0:	e008      	b.n	2f0f4 <rint+0xe4>
   2f0e2:	2833      	cmp	r0, #51	; 0x33
   2f0e4:	dd09      	ble.n	2f0fa <rint+0xea>
   2f0e6:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   2f0ea:	d1cd      	bne.n	2f088 <rint+0x78>
   2f0ec:	ed9d 7b00 	vldr	d7, [sp]
   2f0f0:	ee37 7b07 	vadd.f64	d7, d7, d7
   2f0f4:	ed8d 7b00 	vstr	d7, [sp]
   2f0f8:	e7c6      	b.n	2f088 <rint+0x78>
   2f0fa:	f2a1 4013 	subw	r0, r1, #1043	; 0x413
   2f0fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2f102:	40c1      	lsrs	r1, r0
   2f104:	420a      	tst	r2, r1
   2f106:	d0bf      	beq.n	2f088 <rint+0x78>
   2f108:	0849      	lsrs	r1, r1, #1
   2f10a:	420a      	tst	r2, r1
   2f10c:	bf1f      	itttt	ne
   2f10e:	ea22 0101 	bicne.w	r1, r2, r1
   2f112:	f04f 4280 	movne.w	r2, #1073741824	; 0x40000000
   2f116:	4102      	asrne	r2, r0
   2f118:	430a      	orrne	r2, r1
   2f11a:	e7d0      	b.n	2f0be <rint+0xae>
   2f11c:	00052870 	.word	0x00052870
   2f120:	000fffff 	.word	0x000fffff
   2f124:	00000000 	.word	0x00000000

0002f128 <scalbn>:
   2f128:	b500      	push	{lr}
   2f12a:	ed2d 8b02 	vpush	{d8}
   2f12e:	b083      	sub	sp, #12
   2f130:	ed8d 0b00 	vstr	d0, [sp]
   2f134:	9b01      	ldr	r3, [sp, #4]
   2f136:	f3c3 520a 	ubfx	r2, r3, #20, #11
   2f13a:	b9a2      	cbnz	r2, 2f166 <scalbn+0x3e>
   2f13c:	9a00      	ldr	r2, [sp, #0]
   2f13e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2f142:	4313      	orrs	r3, r2
   2f144:	d03a      	beq.n	2f1bc <scalbn+0x94>
   2f146:	ed9f 7b2e 	vldr	d7, [pc, #184]	; 2f200 <scalbn+0xd8>
   2f14a:	4b35      	ldr	r3, [pc, #212]	; (2f220 <scalbn+0xf8>)
   2f14c:	ee20 7b07 	vmul.f64	d7, d0, d7
   2f150:	4298      	cmp	r0, r3
   2f152:	ed8d 7b00 	vstr	d7, [sp]
   2f156:	da11      	bge.n	2f17c <scalbn+0x54>
   2f158:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 2f208 <scalbn+0xe0>
   2f15c:	ed9d 6b00 	vldr	d6, [sp]
   2f160:	ee27 7b06 	vmul.f64	d7, d7, d6
   2f164:	e007      	b.n	2f176 <scalbn+0x4e>
   2f166:	f240 71ff 	movw	r1, #2047	; 0x7ff
   2f16a:	428a      	cmp	r2, r1
   2f16c:	d10a      	bne.n	2f184 <scalbn+0x5c>
   2f16e:	ed9d 7b00 	vldr	d7, [sp]
   2f172:	ee37 7b07 	vadd.f64	d7, d7, d7
   2f176:	ed8d 7b00 	vstr	d7, [sp]
   2f17a:	e01f      	b.n	2f1bc <scalbn+0x94>
   2f17c:	9b01      	ldr	r3, [sp, #4]
   2f17e:	f3c3 520a 	ubfx	r2, r3, #20, #11
   2f182:	3a36      	subs	r2, #54	; 0x36
   2f184:	4402      	add	r2, r0
   2f186:	f240 71fe 	movw	r1, #2046	; 0x7fe
   2f18a:	428a      	cmp	r2, r1
   2f18c:	dd0a      	ble.n	2f1a4 <scalbn+0x7c>
   2f18e:	ed9f 8b20 	vldr	d8, [pc, #128]	; 2f210 <scalbn+0xe8>
   2f192:	eeb0 0b48 	vmov.f64	d0, d8
   2f196:	ed9d 1b00 	vldr	d1, [sp]
   2f19a:	f000 fa19 	bl	2f5d0 <copysign>
   2f19e:	ee20 7b08 	vmul.f64	d7, d0, d8
   2f1a2:	e7e8      	b.n	2f176 <scalbn+0x4e>
   2f1a4:	2a00      	cmp	r2, #0
   2f1a6:	dd10      	ble.n	2f1ca <scalbn+0xa2>
   2f1a8:	e9dd 0100 	ldrd	r0, r1, [sp]
   2f1ac:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   2f1b0:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   2f1b4:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
   2f1b8:	e9cd 0100 	strd	r0, r1, [sp]
   2f1bc:	ed9d 0b00 	vldr	d0, [sp]
   2f1c0:	b003      	add	sp, #12
   2f1c2:	ecbd 8b02 	vpop	{d8}
   2f1c6:	f85d fb04 	ldr.w	pc, [sp], #4
   2f1ca:	f112 0f35 	cmn.w	r2, #53	; 0x35
   2f1ce:	da06      	bge.n	2f1de <scalbn+0xb6>
   2f1d0:	f24c 3350 	movw	r3, #50000	; 0xc350
   2f1d4:	4298      	cmp	r0, r3
   2f1d6:	dcda      	bgt.n	2f18e <scalbn+0x66>
   2f1d8:	ed9f 8b0b 	vldr	d8, [pc, #44]	; 2f208 <scalbn+0xe0>
   2f1dc:	e7d9      	b.n	2f192 <scalbn+0x6a>
   2f1de:	e9dd 0100 	ldrd	r0, r1, [sp]
   2f1e2:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   2f1e6:	3236      	adds	r2, #54	; 0x36
   2f1e8:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   2f1ec:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
   2f1f0:	ec41 0b17 	vmov	d7, r0, r1
   2f1f4:	ed9f 6b08 	vldr	d6, [pc, #32]	; 2f218 <scalbn+0xf0>
   2f1f8:	e7b2      	b.n	2f160 <scalbn+0x38>
   2f1fa:	bf00      	nop
   2f1fc:	f3af 8000 	nop.w
   2f200:	00000000 	.word	0x00000000
   2f204:	43500000 	.word	0x43500000
   2f208:	c2f8f359 	.word	0xc2f8f359
   2f20c:	01a56e1f 	.word	0x01a56e1f
   2f210:	8800759c 	.word	0x8800759c
   2f214:	7e37e43c 	.word	0x7e37e43c
   2f218:	00000000 	.word	0x00000000
   2f21c:	3c900000 	.word	0x3c900000
   2f220:	ffff3cb0 	.word	0xffff3cb0

0002f224 <expm1f>:
   2f224:	ee10 2a10 	vmov	r2, s0
   2f228:	4984      	ldr	r1, [pc, #528]	; (2f43c <expm1f+0x218>)
   2f22a:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
   2f22e:	428b      	cmp	r3, r1
   2f230:	d923      	bls.n	2f27a <expm1f+0x56>
   2f232:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2f236:	d902      	bls.n	2f23e <expm1f+0x1a>
   2f238:	ee30 0a00 	vadd.f32	s0, s0, s0
   2f23c:	4770      	bx	lr
   2f23e:	d105      	bne.n	2f24c <expm1f+0x28>
   2f240:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
   2f244:	2a00      	cmp	r2, #0
   2f246:	fe20 0a27 	vselge.f32	s0, s0, s15
   2f24a:	4770      	bx	lr
   2f24c:	2a00      	cmp	r2, #0
   2f24e:	db08      	blt.n	2f262 <expm1f+0x3e>
   2f250:	4a7b      	ldr	r2, [pc, #492]	; (2f440 <expm1f+0x21c>)
   2f252:	4293      	cmp	r3, r2
   2f254:	f240 80ea 	bls.w	2f42c <expm1f+0x208>
   2f258:	ed9f 0a7a 	vldr	s0, [pc, #488]	; 2f444 <expm1f+0x220>
   2f25c:	ee20 0a00 	vmul.f32	s0, s0, s0
   2f260:	4770      	bx	lr
   2f262:	eddf 7a79 	vldr	s15, [pc, #484]	; 2f448 <expm1f+0x224>
   2f266:	ee70 7a27 	vadd.f32	s15, s0, s15
   2f26a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
   2f26e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f272:	d554      	bpl.n	2f31e <expm1f+0xfa>
   2f274:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
   2f278:	4770      	bx	lr
   2f27a:	4974      	ldr	r1, [pc, #464]	; (2f44c <expm1f+0x228>)
   2f27c:	428b      	cmp	r3, r1
   2f27e:	d96c      	bls.n	2f35a <expm1f+0x136>
   2f280:	4973      	ldr	r1, [pc, #460]	; (2f450 <expm1f+0x22c>)
   2f282:	428b      	cmp	r3, r1
   2f284:	d84b      	bhi.n	2f31e <expm1f+0xfa>
   2f286:	ed9f 7a73 	vldr	s14, [pc, #460]	; 2f454 <expm1f+0x230>
   2f28a:	2a00      	cmp	r2, #0
   2f28c:	bfa7      	ittee	ge
   2f28e:	ee30 7a47 	vsubge.f32	s14, s0, s14
   2f292:	eddf 7a71 	vldrge	s15, [pc, #452]	; 2f458 <expm1f+0x234>
   2f296:	eddf 7a71 	vldrlt	s15, [pc, #452]	; 2f45c <expm1f+0x238>
   2f29a:	ee30 7a07 	vaddlt.f32	s14, s0, s14
   2f29e:	bfac      	ite	ge
   2f2a0:	2301      	movge	r3, #1
   2f2a2:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   2f2a6:	ee37 0a67 	vsub.f32	s0, s14, s15
   2f2aa:	ee37 7a40 	vsub.f32	s14, s14, s0
   2f2ae:	ee77 7a67 	vsub.f32	s15, s14, s15
   2f2b2:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
   2f2b6:	ee20 5a25 	vmul.f32	s10, s0, s11
   2f2ba:	eddf 6a69 	vldr	s13, [pc, #420]	; 2f460 <expm1f+0x23c>
   2f2be:	ed9f 6a69 	vldr	s12, [pc, #420]	; 2f464 <expm1f+0x240>
   2f2c2:	ee20 7a05 	vmul.f32	s14, s0, s10
   2f2c6:	eea7 6a26 	vfma.f32	s12, s14, s13
   2f2ca:	eddf 6a67 	vldr	s13, [pc, #412]	; 2f468 <expm1f+0x244>
   2f2ce:	eee6 6a07 	vfma.f32	s13, s12, s14
   2f2d2:	ed9f 6a66 	vldr	s12, [pc, #408]	; 2f46c <expm1f+0x248>
   2f2d6:	eea6 6a87 	vfma.f32	s12, s13, s14
   2f2da:	eddf 6a65 	vldr	s13, [pc, #404]	; 2f470 <expm1f+0x24c>
   2f2de:	eee6 6a07 	vfma.f32	s13, s12, s14
   2f2e2:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2f2e6:	eef0 4a46 	vmov.f32	s9, s12
   2f2ea:	eee6 4a87 	vfma.f32	s9, s13, s14
   2f2ee:	eef0 6a64 	vmov.f32	s13, s9
   2f2f2:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
   2f2f6:	eee5 4a66 	vfms.f32	s9, s10, s13
   2f2fa:	ee36 5ae4 	vsub.f32	s10, s13, s9
   2f2fe:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
   2f302:	eee0 6a64 	vfms.f32	s13, s0, s9
   2f306:	eef0 4a66 	vmov.f32	s9, s13
   2f30a:	eec5 6a24 	vdiv.f32	s13, s10, s9
   2f30e:	ee66 6a87 	vmul.f32	s13, s13, s14
   2f312:	bb83      	cbnz	r3, 2f376 <expm1f+0x152>
   2f314:	eef0 7a47 	vmov.f32	s15, s14
   2f318:	eed0 7a26 	vfnms.f32	s15, s0, s13
   2f31c:	e026      	b.n	2f36c <expm1f+0x148>
   2f31e:	eddf 7a55 	vldr	s15, [pc, #340]	; 2f474 <expm1f+0x250>
   2f322:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   2f326:	ee20 7a27 	vmul.f32	s14, s0, s15
   2f32a:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
   2f32e:	2a00      	cmp	r2, #0
   2f330:	fe66 7aa7 	vselge.f32	s15, s13, s15
   2f334:	ee77 7a87 	vadd.f32	s15, s15, s14
   2f338:	ed9f 7a46 	vldr	s14, [pc, #280]	; 2f454 <expm1f+0x230>
   2f33c:	eddf 6a46 	vldr	s13, [pc, #280]	; 2f458 <expm1f+0x234>
   2f340:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2f344:	ee17 3a90 	vmov	r3, s15
   2f348:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2f34c:	eea7 0ac7 	vfms.f32	s0, s15, s14
   2f350:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2f354:	eeb0 7a40 	vmov.f32	s14, s0
   2f358:	e7a5      	b.n	2f2a6 <expm1f+0x82>
   2f35a:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
   2f35e:	d208      	bcs.n	2f372 <expm1f+0x14e>
   2f360:	eddf 7a38 	vldr	s15, [pc, #224]	; 2f444 <expm1f+0x220>
   2f364:	ee70 7a27 	vadd.f32	s15, s0, s15
   2f368:	ee77 7ae7 	vsub.f32	s15, s15, s15
   2f36c:	ee30 0a67 	vsub.f32	s0, s0, s15
   2f370:	4770      	bx	lr
   2f372:	2300      	movs	r3, #0
   2f374:	e79d      	b.n	2f2b2 <expm1f+0x8e>
   2f376:	ee76 6ae7 	vsub.f32	s13, s13, s15
   2f37a:	1c5a      	adds	r2, r3, #1
   2f37c:	eed6 7a80 	vfnms.f32	s15, s13, s0
   2f380:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2f384:	d106      	bne.n	2f394 <expm1f+0x170>
   2f386:	ee70 7a67 	vsub.f32	s15, s0, s15
   2f38a:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
   2f38e:	eea7 0aa5 	vfma.f32	s0, s15, s11
   2f392:	4770      	bx	lr
   2f394:	2b01      	cmp	r3, #1
   2f396:	d118      	bne.n	2f3ca <expm1f+0x1a6>
   2f398:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
   2f39c:	eeb4 0ac7 	vcmpe.f32	s0, s14
   2f3a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f3a4:	bf41      	itttt	mi
   2f3a6:	ee30 0a25 	vaddmi.f32	s0, s0, s11
   2f3aa:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
   2f3ae:	eef8 7a00 	vmovmi.f32	s15, #128	; 0xc0000000 -2.0
   2f3b2:	ee20 0a27 	vmulmi.f32	s0, s0, s15
   2f3b6:	bf5f      	itttt	pl
   2f3b8:	ee30 0a67 	vsubpl.f32	s0, s0, s15
   2f3bc:	eef0 7a00 	vmovpl.f32	s15, #0	; 0x40000000  2.0
   2f3c0:	eea0 6a27 	vfmapl.f32	s12, s0, s15
   2f3c4:	eeb0 0a46 	vmovpl.f32	s0, s12
   2f3c8:	4770      	bx	lr
   2f3ca:	1c5a      	adds	r2, r3, #1
   2f3cc:	2a39      	cmp	r2, #57	; 0x39
   2f3ce:	ea4f 51c3 	mov.w	r1, r3, lsl #23
   2f3d2:	d90b      	bls.n	2f3ec <expm1f+0x1c8>
   2f3d4:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2f3d8:	ee36 0a40 	vsub.f32	s0, s12, s0
   2f3dc:	ee10 3a10 	vmov	r3, s0
   2f3e0:	440b      	add	r3, r1
   2f3e2:	ee00 3a10 	vmov	s0, r3
   2f3e6:	ee30 0a46 	vsub.f32	s0, s0, s12
   2f3ea:	4770      	bx	lr
   2f3ec:	2b16      	cmp	r3, #22
   2f3ee:	dc11      	bgt.n	2f414 <expm1f+0x1f0>
   2f3f0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   2f3f4:	fa42 f303 	asr.w	r3, r2, r3
   2f3f8:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
   2f3fc:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2f400:	ee07 3a90 	vmov	s15, r3
   2f404:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2f408:	ee10 3a10 	vmov	r3, s0
   2f40c:	440b      	add	r3, r1
   2f40e:	ee00 3a10 	vmov	s0, r3
   2f412:	4770      	bx	lr
   2f414:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
   2f418:	05db      	lsls	r3, r3, #23
   2f41a:	ee07 3a10 	vmov	s14, r3
   2f41e:	ee77 7a87 	vadd.f32	s15, s15, s14
   2f422:	ee30 0a67 	vsub.f32	s0, s0, s15
   2f426:	ee30 0a06 	vadd.f32	s0, s0, s12
   2f42a:	e7ed      	b.n	2f408 <expm1f+0x1e4>
   2f42c:	eddf 7a11 	vldr	s15, [pc, #68]	; 2f474 <expm1f+0x250>
   2f430:	ee20 7a27 	vmul.f32	s14, s0, s15
   2f434:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2f438:	e77c      	b.n	2f334 <expm1f+0x110>
   2f43a:	bf00      	nop
   2f43c:	4195b843 	.word	0x4195b843
   2f440:	42b17217 	.word	0x42b17217
   2f444:	7149f2ca 	.word	0x7149f2ca
   2f448:	0da24260 	.word	0x0da24260
   2f44c:	3eb17218 	.word	0x3eb17218
   2f450:	3f851591 	.word	0x3f851591
   2f454:	3f317180 	.word	0x3f317180
   2f458:	3717f7d1 	.word	0x3717f7d1
   2f45c:	b717f7d1 	.word	0xb717f7d1
   2f460:	b457edbb 	.word	0xb457edbb
   2f464:	36867e54 	.word	0x36867e54
   2f468:	b8a670cd 	.word	0xb8a670cd
   2f46c:	3ad00d01 	.word	0x3ad00d01
   2f470:	bd088889 	.word	0xbd088889
   2f474:	3fb8aa3b 	.word	0x3fb8aa3b

0002f478 <finitef>:
   2f478:	ee10 3a10 	vmov	r3, s0
   2f47c:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   2f480:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
   2f484:	bfac      	ite	ge
   2f486:	2000      	movge	r0, #0
   2f488:	2001      	movlt	r0, #1
   2f48a:	4770      	bx	lr

0002f48c <floorf>:
   2f48c:	ee10 3a10 	vmov	r3, s0
   2f490:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2f494:	0dca      	lsrs	r2, r1, #23
   2f496:	3a7f      	subs	r2, #127	; 0x7f
   2f498:	2a16      	cmp	r2, #22
   2f49a:	dc2a      	bgt.n	2f4f2 <floorf+0x66>
   2f49c:	2a00      	cmp	r2, #0
   2f49e:	da11      	bge.n	2f4c4 <floorf+0x38>
   2f4a0:	eddf 7a18 	vldr	s15, [pc, #96]	; 2f504 <floorf+0x78>
   2f4a4:	ee30 0a27 	vadd.f32	s0, s0, s15
   2f4a8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2f4ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f4b0:	dd05      	ble.n	2f4be <floorf+0x32>
   2f4b2:	2b00      	cmp	r3, #0
   2f4b4:	da23      	bge.n	2f4fe <floorf+0x72>
   2f4b6:	4a14      	ldr	r2, [pc, #80]	; (2f508 <floorf+0x7c>)
   2f4b8:	2900      	cmp	r1, #0
   2f4ba:	bf18      	it	ne
   2f4bc:	4613      	movne	r3, r2
   2f4be:	ee00 3a10 	vmov	s0, r3
   2f4c2:	4770      	bx	lr
   2f4c4:	4911      	ldr	r1, [pc, #68]	; (2f50c <floorf+0x80>)
   2f4c6:	4111      	asrs	r1, r2
   2f4c8:	420b      	tst	r3, r1
   2f4ca:	d0fa      	beq.n	2f4c2 <floorf+0x36>
   2f4cc:	eddf 7a0d 	vldr	s15, [pc, #52]	; 2f504 <floorf+0x78>
   2f4d0:	ee30 0a27 	vadd.f32	s0, s0, s15
   2f4d4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2f4d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f4dc:	ddef      	ble.n	2f4be <floorf+0x32>
   2f4de:	2b00      	cmp	r3, #0
   2f4e0:	bfbe      	ittt	lt
   2f4e2:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
   2f4e6:	fa40 f202 	asrlt.w	r2, r0, r2
   2f4ea:	189b      	addlt	r3, r3, r2
   2f4ec:	ea23 0301 	bic.w	r3, r3, r1
   2f4f0:	e7e5      	b.n	2f4be <floorf+0x32>
   2f4f2:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   2f4f6:	d3e4      	bcc.n	2f4c2 <floorf+0x36>
   2f4f8:	ee30 0a00 	vadd.f32	s0, s0, s0
   2f4fc:	4770      	bx	lr
   2f4fe:	2300      	movs	r3, #0
   2f500:	e7dd      	b.n	2f4be <floorf+0x32>
   2f502:	bf00      	nop
   2f504:	7149f2ca 	.word	0x7149f2ca
   2f508:	bf800000 	.word	0xbf800000
   2f50c:	007fffff 	.word	0x007fffff

0002f510 <scalbnf>:
   2f510:	b508      	push	{r3, lr}
   2f512:	ee10 2a10 	vmov	r2, s0
   2f516:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
   2f51a:	ed2d 8b02 	vpush	{d8}
   2f51e:	eef0 0a40 	vmov.f32	s1, s0
   2f522:	d004      	beq.n	2f52e <scalbnf+0x1e>
   2f524:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2f528:	d306      	bcc.n	2f538 <scalbnf+0x28>
   2f52a:	ee70 0a00 	vadd.f32	s1, s0, s0
   2f52e:	ecbd 8b02 	vpop	{d8}
   2f532:	eeb0 0a60 	vmov.f32	s0, s1
   2f536:	bd08      	pop	{r3, pc}
   2f538:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   2f53c:	d21c      	bcs.n	2f578 <scalbnf+0x68>
   2f53e:	4b1f      	ldr	r3, [pc, #124]	; (2f5bc <scalbnf+0xac>)
   2f540:	eddf 7a1f 	vldr	s15, [pc, #124]	; 2f5c0 <scalbnf+0xb0>
   2f544:	4298      	cmp	r0, r3
   2f546:	ee60 0a27 	vmul.f32	s1, s0, s15
   2f54a:	db10      	blt.n	2f56e <scalbnf+0x5e>
   2f54c:	ee10 2a90 	vmov	r2, s1
   2f550:	f3c2 53c7 	ubfx	r3, r2, #23, #8
   2f554:	3b19      	subs	r3, #25
   2f556:	4403      	add	r3, r0
   2f558:	2bfe      	cmp	r3, #254	; 0xfe
   2f55a:	dd0f      	ble.n	2f57c <scalbnf+0x6c>
   2f55c:	ed9f 8a19 	vldr	s16, [pc, #100]	; 2f5c4 <scalbnf+0xb4>
   2f560:	eeb0 0a48 	vmov.f32	s0, s16
   2f564:	f000 f843 	bl	2f5ee <copysignf>
   2f568:	ee60 0a08 	vmul.f32	s1, s0, s16
   2f56c:	e7df      	b.n	2f52e <scalbnf+0x1e>
   2f56e:	eddf 7a16 	vldr	s15, [pc, #88]	; 2f5c8 <scalbnf+0xb8>
   2f572:	ee60 0aa7 	vmul.f32	s1, s1, s15
   2f576:	e7da      	b.n	2f52e <scalbnf+0x1e>
   2f578:	0ddb      	lsrs	r3, r3, #23
   2f57a:	e7ec      	b.n	2f556 <scalbnf+0x46>
   2f57c:	2b00      	cmp	r3, #0
   2f57e:	dd06      	ble.n	2f58e <scalbnf+0x7e>
   2f580:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   2f584:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
   2f588:	ee00 3a90 	vmov	s1, r3
   2f58c:	e7cf      	b.n	2f52e <scalbnf+0x1e>
   2f58e:	f113 0f16 	cmn.w	r3, #22
   2f592:	da06      	bge.n	2f5a2 <scalbnf+0x92>
   2f594:	f24c 3350 	movw	r3, #50000	; 0xc350
   2f598:	4298      	cmp	r0, r3
   2f59a:	dcdf      	bgt.n	2f55c <scalbnf+0x4c>
   2f59c:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 2f5c8 <scalbnf+0xb8>
   2f5a0:	e7de      	b.n	2f560 <scalbnf+0x50>
   2f5a2:	3319      	adds	r3, #25
   2f5a4:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
   2f5a8:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
   2f5ac:	eddf 7a07 	vldr	s15, [pc, #28]	; 2f5cc <scalbnf+0xbc>
   2f5b0:	ee07 3a10 	vmov	s14, r3
   2f5b4:	ee67 0a27 	vmul.f32	s1, s14, s15
   2f5b8:	e7b9      	b.n	2f52e <scalbnf+0x1e>
   2f5ba:	bf00      	nop
   2f5bc:	ffff3cb0 	.word	0xffff3cb0
   2f5c0:	4c000000 	.word	0x4c000000
   2f5c4:	7149f2ca 	.word	0x7149f2ca
   2f5c8:	0da24260 	.word	0x0da24260
   2f5cc:	33000000 	.word	0x33000000

0002f5d0 <copysign>:
   2f5d0:	ec51 0b10 	vmov	r0, r1, d0
   2f5d4:	ee11 0a90 	vmov	r0, s3
   2f5d8:	ee10 2a10 	vmov	r2, s0
   2f5dc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2f5e0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   2f5e4:	ea41 0300 	orr.w	r3, r1, r0
   2f5e8:	ec43 2b10 	vmov	d0, r2, r3
   2f5ec:	4770      	bx	lr

0002f5ee <copysignf>:
   2f5ee:	ee10 3a10 	vmov	r3, s0
   2f5f2:	ee10 2a90 	vmov	r2, s1
   2f5f6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2f5fa:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
   2f5fe:	4313      	orrs	r3, r2
   2f600:	ee00 3a10 	vmov	s0, r3
   2f604:	4770      	bx	lr
	...

0002f608 <__aeabi_drsub>:
   2f608:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   2f60c:	e002      	b.n	2f614 <__adddf3>
   2f60e:	bf00      	nop

0002f610 <__aeabi_dsub>:
   2f610:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0002f614 <__adddf3>:
   2f614:	b530      	push	{r4, r5, lr}
   2f616:	ea4f 0441 	mov.w	r4, r1, lsl #1
   2f61a:	ea4f 0543 	mov.w	r5, r3, lsl #1
   2f61e:	ea94 0f05 	teq	r4, r5
   2f622:	bf08      	it	eq
   2f624:	ea90 0f02 	teqeq	r0, r2
   2f628:	bf1f      	itttt	ne
   2f62a:	ea54 0c00 	orrsne.w	ip, r4, r0
   2f62e:	ea55 0c02 	orrsne.w	ip, r5, r2
   2f632:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   2f636:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   2f63a:	f000 80e2 	beq.w	2f802 <__adddf3+0x1ee>
   2f63e:	ea4f 5454 	mov.w	r4, r4, lsr #21
   2f642:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   2f646:	bfb8      	it	lt
   2f648:	426d      	neglt	r5, r5
   2f64a:	dd0c      	ble.n	2f666 <__adddf3+0x52>
   2f64c:	442c      	add	r4, r5
   2f64e:	ea80 0202 	eor.w	r2, r0, r2
   2f652:	ea81 0303 	eor.w	r3, r1, r3
   2f656:	ea82 0000 	eor.w	r0, r2, r0
   2f65a:	ea83 0101 	eor.w	r1, r3, r1
   2f65e:	ea80 0202 	eor.w	r2, r0, r2
   2f662:	ea81 0303 	eor.w	r3, r1, r3
   2f666:	2d36      	cmp	r5, #54	; 0x36
   2f668:	bf88      	it	hi
   2f66a:	bd30      	pophi	{r4, r5, pc}
   2f66c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   2f670:	ea4f 3101 	mov.w	r1, r1, lsl #12
   2f674:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   2f678:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   2f67c:	d002      	beq.n	2f684 <__adddf3+0x70>
   2f67e:	4240      	negs	r0, r0
   2f680:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2f684:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   2f688:	ea4f 3303 	mov.w	r3, r3, lsl #12
   2f68c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   2f690:	d002      	beq.n	2f698 <__adddf3+0x84>
   2f692:	4252      	negs	r2, r2
   2f694:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   2f698:	ea94 0f05 	teq	r4, r5
   2f69c:	f000 80a7 	beq.w	2f7ee <__adddf3+0x1da>
   2f6a0:	f1a4 0401 	sub.w	r4, r4, #1
   2f6a4:	f1d5 0e20 	rsbs	lr, r5, #32
   2f6a8:	db0d      	blt.n	2f6c6 <__adddf3+0xb2>
   2f6aa:	fa02 fc0e 	lsl.w	ip, r2, lr
   2f6ae:	fa22 f205 	lsr.w	r2, r2, r5
   2f6b2:	1880      	adds	r0, r0, r2
   2f6b4:	f141 0100 	adc.w	r1, r1, #0
   2f6b8:	fa03 f20e 	lsl.w	r2, r3, lr
   2f6bc:	1880      	adds	r0, r0, r2
   2f6be:	fa43 f305 	asr.w	r3, r3, r5
   2f6c2:	4159      	adcs	r1, r3
   2f6c4:	e00e      	b.n	2f6e4 <__adddf3+0xd0>
   2f6c6:	f1a5 0520 	sub.w	r5, r5, #32
   2f6ca:	f10e 0e20 	add.w	lr, lr, #32
   2f6ce:	2a01      	cmp	r2, #1
   2f6d0:	fa03 fc0e 	lsl.w	ip, r3, lr
   2f6d4:	bf28      	it	cs
   2f6d6:	f04c 0c02 	orrcs.w	ip, ip, #2
   2f6da:	fa43 f305 	asr.w	r3, r3, r5
   2f6de:	18c0      	adds	r0, r0, r3
   2f6e0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   2f6e4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2f6e8:	d507      	bpl.n	2f6fa <__adddf3+0xe6>
   2f6ea:	f04f 0e00 	mov.w	lr, #0
   2f6ee:	f1dc 0c00 	rsbs	ip, ip, #0
   2f6f2:	eb7e 0000 	sbcs.w	r0, lr, r0
   2f6f6:	eb6e 0101 	sbc.w	r1, lr, r1
   2f6fa:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   2f6fe:	d31b      	bcc.n	2f738 <__adddf3+0x124>
   2f700:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   2f704:	d30c      	bcc.n	2f720 <__adddf3+0x10c>
   2f706:	0849      	lsrs	r1, r1, #1
   2f708:	ea5f 0030 	movs.w	r0, r0, rrx
   2f70c:	ea4f 0c3c 	mov.w	ip, ip, rrx
   2f710:	f104 0401 	add.w	r4, r4, #1
   2f714:	ea4f 5244 	mov.w	r2, r4, lsl #21
   2f718:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   2f71c:	f080 809a 	bcs.w	2f854 <__adddf3+0x240>
   2f720:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   2f724:	bf08      	it	eq
   2f726:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   2f72a:	f150 0000 	adcs.w	r0, r0, #0
   2f72e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   2f732:	ea41 0105 	orr.w	r1, r1, r5
   2f736:	bd30      	pop	{r4, r5, pc}
   2f738:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   2f73c:	4140      	adcs	r0, r0
   2f73e:	eb41 0101 	adc.w	r1, r1, r1
   2f742:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   2f746:	f1a4 0401 	sub.w	r4, r4, #1
   2f74a:	d1e9      	bne.n	2f720 <__adddf3+0x10c>
   2f74c:	f091 0f00 	teq	r1, #0
   2f750:	bf04      	itt	eq
   2f752:	4601      	moveq	r1, r0
   2f754:	2000      	moveq	r0, #0
   2f756:	fab1 f381 	clz	r3, r1
   2f75a:	bf08      	it	eq
   2f75c:	3320      	addeq	r3, #32
   2f75e:	f1a3 030b 	sub.w	r3, r3, #11
   2f762:	f1b3 0220 	subs.w	r2, r3, #32
   2f766:	da0c      	bge.n	2f782 <__adddf3+0x16e>
   2f768:	320c      	adds	r2, #12
   2f76a:	dd08      	ble.n	2f77e <__adddf3+0x16a>
   2f76c:	f102 0c14 	add.w	ip, r2, #20
   2f770:	f1c2 020c 	rsb	r2, r2, #12
   2f774:	fa01 f00c 	lsl.w	r0, r1, ip
   2f778:	fa21 f102 	lsr.w	r1, r1, r2
   2f77c:	e00c      	b.n	2f798 <__adddf3+0x184>
   2f77e:	f102 0214 	add.w	r2, r2, #20
   2f782:	bfd8      	it	le
   2f784:	f1c2 0c20 	rsble	ip, r2, #32
   2f788:	fa01 f102 	lsl.w	r1, r1, r2
   2f78c:	fa20 fc0c 	lsr.w	ip, r0, ip
   2f790:	bfdc      	itt	le
   2f792:	ea41 010c 	orrle.w	r1, r1, ip
   2f796:	4090      	lslle	r0, r2
   2f798:	1ae4      	subs	r4, r4, r3
   2f79a:	bfa2      	ittt	ge
   2f79c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   2f7a0:	4329      	orrge	r1, r5
   2f7a2:	bd30      	popge	{r4, r5, pc}
   2f7a4:	ea6f 0404 	mvn.w	r4, r4
   2f7a8:	3c1f      	subs	r4, #31
   2f7aa:	da1c      	bge.n	2f7e6 <__adddf3+0x1d2>
   2f7ac:	340c      	adds	r4, #12
   2f7ae:	dc0e      	bgt.n	2f7ce <__adddf3+0x1ba>
   2f7b0:	f104 0414 	add.w	r4, r4, #20
   2f7b4:	f1c4 0220 	rsb	r2, r4, #32
   2f7b8:	fa20 f004 	lsr.w	r0, r0, r4
   2f7bc:	fa01 f302 	lsl.w	r3, r1, r2
   2f7c0:	ea40 0003 	orr.w	r0, r0, r3
   2f7c4:	fa21 f304 	lsr.w	r3, r1, r4
   2f7c8:	ea45 0103 	orr.w	r1, r5, r3
   2f7cc:	bd30      	pop	{r4, r5, pc}
   2f7ce:	f1c4 040c 	rsb	r4, r4, #12
   2f7d2:	f1c4 0220 	rsb	r2, r4, #32
   2f7d6:	fa20 f002 	lsr.w	r0, r0, r2
   2f7da:	fa01 f304 	lsl.w	r3, r1, r4
   2f7de:	ea40 0003 	orr.w	r0, r0, r3
   2f7e2:	4629      	mov	r1, r5
   2f7e4:	bd30      	pop	{r4, r5, pc}
   2f7e6:	fa21 f004 	lsr.w	r0, r1, r4
   2f7ea:	4629      	mov	r1, r5
   2f7ec:	bd30      	pop	{r4, r5, pc}
   2f7ee:	f094 0f00 	teq	r4, #0
   2f7f2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   2f7f6:	bf06      	itte	eq
   2f7f8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   2f7fc:	3401      	addeq	r4, #1
   2f7fe:	3d01      	subne	r5, #1
   2f800:	e74e      	b.n	2f6a0 <__adddf3+0x8c>
   2f802:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   2f806:	bf18      	it	ne
   2f808:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   2f80c:	d029      	beq.n	2f862 <__adddf3+0x24e>
   2f80e:	ea94 0f05 	teq	r4, r5
   2f812:	bf08      	it	eq
   2f814:	ea90 0f02 	teqeq	r0, r2
   2f818:	d005      	beq.n	2f826 <__adddf3+0x212>
   2f81a:	ea54 0c00 	orrs.w	ip, r4, r0
   2f81e:	bf04      	itt	eq
   2f820:	4619      	moveq	r1, r3
   2f822:	4610      	moveq	r0, r2
   2f824:	bd30      	pop	{r4, r5, pc}
   2f826:	ea91 0f03 	teq	r1, r3
   2f82a:	bf1e      	ittt	ne
   2f82c:	2100      	movne	r1, #0
   2f82e:	2000      	movne	r0, #0
   2f830:	bd30      	popne	{r4, r5, pc}
   2f832:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   2f836:	d105      	bne.n	2f844 <__adddf3+0x230>
   2f838:	0040      	lsls	r0, r0, #1
   2f83a:	4149      	adcs	r1, r1
   2f83c:	bf28      	it	cs
   2f83e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   2f842:	bd30      	pop	{r4, r5, pc}
   2f844:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   2f848:	bf3c      	itt	cc
   2f84a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   2f84e:	bd30      	popcc	{r4, r5, pc}
   2f850:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2f854:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   2f858:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   2f85c:	f04f 0000 	mov.w	r0, #0
   2f860:	bd30      	pop	{r4, r5, pc}
   2f862:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   2f866:	bf1a      	itte	ne
   2f868:	4619      	movne	r1, r3
   2f86a:	4610      	movne	r0, r2
   2f86c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   2f870:	bf1c      	itt	ne
   2f872:	460b      	movne	r3, r1
   2f874:	4602      	movne	r2, r0
   2f876:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   2f87a:	bf06      	itte	eq
   2f87c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   2f880:	ea91 0f03 	teqeq	r1, r3
   2f884:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   2f888:	bd30      	pop	{r4, r5, pc}
   2f88a:	bf00      	nop

0002f88c <__aeabi_ui2d>:
   2f88c:	f090 0f00 	teq	r0, #0
   2f890:	bf04      	itt	eq
   2f892:	2100      	moveq	r1, #0
   2f894:	4770      	bxeq	lr
   2f896:	b530      	push	{r4, r5, lr}
   2f898:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2f89c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2f8a0:	f04f 0500 	mov.w	r5, #0
   2f8a4:	f04f 0100 	mov.w	r1, #0
   2f8a8:	e750      	b.n	2f74c <__adddf3+0x138>
   2f8aa:	bf00      	nop

0002f8ac <__aeabi_i2d>:
   2f8ac:	f090 0f00 	teq	r0, #0
   2f8b0:	bf04      	itt	eq
   2f8b2:	2100      	moveq	r1, #0
   2f8b4:	4770      	bxeq	lr
   2f8b6:	b530      	push	{r4, r5, lr}
   2f8b8:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2f8bc:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2f8c0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   2f8c4:	bf48      	it	mi
   2f8c6:	4240      	negmi	r0, r0
   2f8c8:	f04f 0100 	mov.w	r1, #0
   2f8cc:	e73e      	b.n	2f74c <__adddf3+0x138>
   2f8ce:	bf00      	nop

0002f8d0 <__aeabi_f2d>:
   2f8d0:	0042      	lsls	r2, r0, #1
   2f8d2:	ea4f 01e2 	mov.w	r1, r2, asr #3
   2f8d6:	ea4f 0131 	mov.w	r1, r1, rrx
   2f8da:	ea4f 7002 	mov.w	r0, r2, lsl #28
   2f8de:	bf1f      	itttt	ne
   2f8e0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   2f8e4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   2f8e8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   2f8ec:	4770      	bxne	lr
   2f8ee:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   2f8f2:	bf08      	it	eq
   2f8f4:	4770      	bxeq	lr
   2f8f6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   2f8fa:	bf04      	itt	eq
   2f8fc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   2f900:	4770      	bxeq	lr
   2f902:	b530      	push	{r4, r5, lr}
   2f904:	f44f 7460 	mov.w	r4, #896	; 0x380
   2f908:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   2f90c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   2f910:	e71c      	b.n	2f74c <__adddf3+0x138>
   2f912:	bf00      	nop

0002f914 <__aeabi_ul2d>:
   2f914:	ea50 0201 	orrs.w	r2, r0, r1
   2f918:	bf08      	it	eq
   2f91a:	4770      	bxeq	lr
   2f91c:	b530      	push	{r4, r5, lr}
   2f91e:	f04f 0500 	mov.w	r5, #0
   2f922:	e00a      	b.n	2f93a <__aeabi_l2d+0x16>

0002f924 <__aeabi_l2d>:
   2f924:	ea50 0201 	orrs.w	r2, r0, r1
   2f928:	bf08      	it	eq
   2f92a:	4770      	bxeq	lr
   2f92c:	b530      	push	{r4, r5, lr}
   2f92e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   2f932:	d502      	bpl.n	2f93a <__aeabi_l2d+0x16>
   2f934:	4240      	negs	r0, r0
   2f936:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2f93a:	f44f 6480 	mov.w	r4, #1024	; 0x400
   2f93e:	f104 0432 	add.w	r4, r4, #50	; 0x32
   2f942:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   2f946:	f43f aed8 	beq.w	2f6fa <__adddf3+0xe6>
   2f94a:	f04f 0203 	mov.w	r2, #3
   2f94e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   2f952:	bf18      	it	ne
   2f954:	3203      	addne	r2, #3
   2f956:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   2f95a:	bf18      	it	ne
   2f95c:	3203      	addne	r2, #3
   2f95e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   2f962:	f1c2 0320 	rsb	r3, r2, #32
   2f966:	fa00 fc03 	lsl.w	ip, r0, r3
   2f96a:	fa20 f002 	lsr.w	r0, r0, r2
   2f96e:	fa01 fe03 	lsl.w	lr, r1, r3
   2f972:	ea40 000e 	orr.w	r0, r0, lr
   2f976:	fa21 f102 	lsr.w	r1, r1, r2
   2f97a:	4414      	add	r4, r2
   2f97c:	e6bd      	b.n	2f6fa <__adddf3+0xe6>
   2f97e:	bf00      	nop

0002f980 <__aeabi_frsub>:
   2f980:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   2f984:	e002      	b.n	2f98c <__addsf3>
   2f986:	bf00      	nop

0002f988 <__aeabi_fsub>:
   2f988:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0002f98c <__addsf3>:
   2f98c:	0042      	lsls	r2, r0, #1
   2f98e:	bf1f      	itttt	ne
   2f990:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   2f994:	ea92 0f03 	teqne	r2, r3
   2f998:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   2f99c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   2f9a0:	d06a      	beq.n	2fa78 <__addsf3+0xec>
   2f9a2:	ea4f 6212 	mov.w	r2, r2, lsr #24
   2f9a6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   2f9aa:	bfc1      	itttt	gt
   2f9ac:	18d2      	addgt	r2, r2, r3
   2f9ae:	4041      	eorgt	r1, r0
   2f9b0:	4048      	eorgt	r0, r1
   2f9b2:	4041      	eorgt	r1, r0
   2f9b4:	bfb8      	it	lt
   2f9b6:	425b      	neglt	r3, r3
   2f9b8:	2b19      	cmp	r3, #25
   2f9ba:	bf88      	it	hi
   2f9bc:	4770      	bxhi	lr
   2f9be:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   2f9c2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   2f9c6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   2f9ca:	bf18      	it	ne
   2f9cc:	4240      	negne	r0, r0
   2f9ce:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   2f9d2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   2f9d6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   2f9da:	bf18      	it	ne
   2f9dc:	4249      	negne	r1, r1
   2f9de:	ea92 0f03 	teq	r2, r3
   2f9e2:	d03f      	beq.n	2fa64 <__addsf3+0xd8>
   2f9e4:	f1a2 0201 	sub.w	r2, r2, #1
   2f9e8:	fa41 fc03 	asr.w	ip, r1, r3
   2f9ec:	eb10 000c 	adds.w	r0, r0, ip
   2f9f0:	f1c3 0320 	rsb	r3, r3, #32
   2f9f4:	fa01 f103 	lsl.w	r1, r1, r3
   2f9f8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   2f9fc:	d502      	bpl.n	2fa04 <__addsf3+0x78>
   2f9fe:	4249      	negs	r1, r1
   2fa00:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   2fa04:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   2fa08:	d313      	bcc.n	2fa32 <__addsf3+0xa6>
   2fa0a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   2fa0e:	d306      	bcc.n	2fa1e <__addsf3+0x92>
   2fa10:	0840      	lsrs	r0, r0, #1
   2fa12:	ea4f 0131 	mov.w	r1, r1, rrx
   2fa16:	f102 0201 	add.w	r2, r2, #1
   2fa1a:	2afe      	cmp	r2, #254	; 0xfe
   2fa1c:	d251      	bcs.n	2fac2 <__addsf3+0x136>
   2fa1e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   2fa22:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   2fa26:	bf08      	it	eq
   2fa28:	f020 0001 	biceq.w	r0, r0, #1
   2fa2c:	ea40 0003 	orr.w	r0, r0, r3
   2fa30:	4770      	bx	lr
   2fa32:	0049      	lsls	r1, r1, #1
   2fa34:	eb40 0000 	adc.w	r0, r0, r0
   2fa38:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   2fa3c:	f1a2 0201 	sub.w	r2, r2, #1
   2fa40:	d1ed      	bne.n	2fa1e <__addsf3+0x92>
   2fa42:	fab0 fc80 	clz	ip, r0
   2fa46:	f1ac 0c08 	sub.w	ip, ip, #8
   2fa4a:	ebb2 020c 	subs.w	r2, r2, ip
   2fa4e:	fa00 f00c 	lsl.w	r0, r0, ip
   2fa52:	bfaa      	itet	ge
   2fa54:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   2fa58:	4252      	neglt	r2, r2
   2fa5a:	4318      	orrge	r0, r3
   2fa5c:	bfbc      	itt	lt
   2fa5e:	40d0      	lsrlt	r0, r2
   2fa60:	4318      	orrlt	r0, r3
   2fa62:	4770      	bx	lr
   2fa64:	f092 0f00 	teq	r2, #0
   2fa68:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   2fa6c:	bf06      	itte	eq
   2fa6e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   2fa72:	3201      	addeq	r2, #1
   2fa74:	3b01      	subne	r3, #1
   2fa76:	e7b5      	b.n	2f9e4 <__addsf3+0x58>
   2fa78:	ea4f 0341 	mov.w	r3, r1, lsl #1
   2fa7c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   2fa80:	bf18      	it	ne
   2fa82:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   2fa86:	d021      	beq.n	2facc <__addsf3+0x140>
   2fa88:	ea92 0f03 	teq	r2, r3
   2fa8c:	d004      	beq.n	2fa98 <__addsf3+0x10c>
   2fa8e:	f092 0f00 	teq	r2, #0
   2fa92:	bf08      	it	eq
   2fa94:	4608      	moveq	r0, r1
   2fa96:	4770      	bx	lr
   2fa98:	ea90 0f01 	teq	r0, r1
   2fa9c:	bf1c      	itt	ne
   2fa9e:	2000      	movne	r0, #0
   2faa0:	4770      	bxne	lr
   2faa2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   2faa6:	d104      	bne.n	2fab2 <__addsf3+0x126>
   2faa8:	0040      	lsls	r0, r0, #1
   2faaa:	bf28      	it	cs
   2faac:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   2fab0:	4770      	bx	lr
   2fab2:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   2fab6:	bf3c      	itt	cc
   2fab8:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   2fabc:	4770      	bxcc	lr
   2fabe:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   2fac2:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   2fac6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   2faca:	4770      	bx	lr
   2facc:	ea7f 6222 	mvns.w	r2, r2, asr #24
   2fad0:	bf16      	itet	ne
   2fad2:	4608      	movne	r0, r1
   2fad4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   2fad8:	4601      	movne	r1, r0
   2fada:	0242      	lsls	r2, r0, #9
   2fadc:	bf06      	itte	eq
   2fade:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   2fae2:	ea90 0f01 	teqeq	r0, r1
   2fae6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   2faea:	4770      	bx	lr

0002faec <__aeabi_ui2f>:
   2faec:	f04f 0300 	mov.w	r3, #0
   2faf0:	e004      	b.n	2fafc <__aeabi_i2f+0x8>
   2faf2:	bf00      	nop

0002faf4 <__aeabi_i2f>:
   2faf4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   2faf8:	bf48      	it	mi
   2fafa:	4240      	negmi	r0, r0
   2fafc:	ea5f 0c00 	movs.w	ip, r0
   2fb00:	bf08      	it	eq
   2fb02:	4770      	bxeq	lr
   2fb04:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   2fb08:	4601      	mov	r1, r0
   2fb0a:	f04f 0000 	mov.w	r0, #0
   2fb0e:	e01c      	b.n	2fb4a <__aeabi_l2f+0x2a>

0002fb10 <__aeabi_ul2f>:
   2fb10:	ea50 0201 	orrs.w	r2, r0, r1
   2fb14:	bf08      	it	eq
   2fb16:	4770      	bxeq	lr
   2fb18:	f04f 0300 	mov.w	r3, #0
   2fb1c:	e00a      	b.n	2fb34 <__aeabi_l2f+0x14>
   2fb1e:	bf00      	nop

0002fb20 <__aeabi_l2f>:
   2fb20:	ea50 0201 	orrs.w	r2, r0, r1
   2fb24:	bf08      	it	eq
   2fb26:	4770      	bxeq	lr
   2fb28:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   2fb2c:	d502      	bpl.n	2fb34 <__aeabi_l2f+0x14>
   2fb2e:	4240      	negs	r0, r0
   2fb30:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   2fb34:	ea5f 0c01 	movs.w	ip, r1
   2fb38:	bf02      	ittt	eq
   2fb3a:	4684      	moveq	ip, r0
   2fb3c:	4601      	moveq	r1, r0
   2fb3e:	2000      	moveq	r0, #0
   2fb40:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   2fb44:	bf08      	it	eq
   2fb46:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   2fb4a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   2fb4e:	fabc f28c 	clz	r2, ip
   2fb52:	3a08      	subs	r2, #8
   2fb54:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   2fb58:	db10      	blt.n	2fb7c <__aeabi_l2f+0x5c>
   2fb5a:	fa01 fc02 	lsl.w	ip, r1, r2
   2fb5e:	4463      	add	r3, ip
   2fb60:	fa00 fc02 	lsl.w	ip, r0, r2
   2fb64:	f1c2 0220 	rsb	r2, r2, #32
   2fb68:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   2fb6c:	fa20 f202 	lsr.w	r2, r0, r2
   2fb70:	eb43 0002 	adc.w	r0, r3, r2
   2fb74:	bf08      	it	eq
   2fb76:	f020 0001 	biceq.w	r0, r0, #1
   2fb7a:	4770      	bx	lr
   2fb7c:	f102 0220 	add.w	r2, r2, #32
   2fb80:	fa01 fc02 	lsl.w	ip, r1, r2
   2fb84:	f1c2 0220 	rsb	r2, r2, #32
   2fb88:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   2fb8c:	fa21 f202 	lsr.w	r2, r1, r2
   2fb90:	eb43 0002 	adc.w	r0, r3, r2
   2fb94:	bf08      	it	eq
   2fb96:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   2fb9a:	4770      	bx	lr

0002fb9c <__aeabi_uldivmod>:
   2fb9c:	b953      	cbnz	r3, 2fbb4 <__aeabi_uldivmod+0x18>
   2fb9e:	b94a      	cbnz	r2, 2fbb4 <__aeabi_uldivmod+0x18>
   2fba0:	2900      	cmp	r1, #0
   2fba2:	bf08      	it	eq
   2fba4:	2800      	cmpeq	r0, #0
   2fba6:	bf1c      	itt	ne
   2fba8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   2fbac:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   2fbb0:	f000 b972 	b.w	2fe98 <__aeabi_idiv0>
   2fbb4:	f1ad 0c08 	sub.w	ip, sp, #8
   2fbb8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   2fbbc:	f000 f806 	bl	2fbcc <__udivmoddi4>
   2fbc0:	f8dd e004 	ldr.w	lr, [sp, #4]
   2fbc4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   2fbc8:	b004      	add	sp, #16
   2fbca:	4770      	bx	lr

0002fbcc <__udivmoddi4>:
   2fbcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2fbd0:	9e08      	ldr	r6, [sp, #32]
   2fbd2:	4604      	mov	r4, r0
   2fbd4:	4688      	mov	r8, r1
   2fbd6:	2b00      	cmp	r3, #0
   2fbd8:	d14b      	bne.n	2fc72 <__udivmoddi4+0xa6>
   2fbda:	428a      	cmp	r2, r1
   2fbdc:	4615      	mov	r5, r2
   2fbde:	d967      	bls.n	2fcb0 <__udivmoddi4+0xe4>
   2fbe0:	fab2 f282 	clz	r2, r2
   2fbe4:	b14a      	cbz	r2, 2fbfa <__udivmoddi4+0x2e>
   2fbe6:	f1c2 0720 	rsb	r7, r2, #32
   2fbea:	fa01 f302 	lsl.w	r3, r1, r2
   2fbee:	fa20 f707 	lsr.w	r7, r0, r7
   2fbf2:	4095      	lsls	r5, r2
   2fbf4:	ea47 0803 	orr.w	r8, r7, r3
   2fbf8:	4094      	lsls	r4, r2
   2fbfa:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2fbfe:	0c23      	lsrs	r3, r4, #16
   2fc00:	fbb8 f7fe 	udiv	r7, r8, lr
   2fc04:	fa1f fc85 	uxth.w	ip, r5
   2fc08:	fb0e 8817 	mls	r8, lr, r7, r8
   2fc0c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   2fc10:	fb07 f10c 	mul.w	r1, r7, ip
   2fc14:	4299      	cmp	r1, r3
   2fc16:	d909      	bls.n	2fc2c <__udivmoddi4+0x60>
   2fc18:	18eb      	adds	r3, r5, r3
   2fc1a:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
   2fc1e:	f080 811b 	bcs.w	2fe58 <__udivmoddi4+0x28c>
   2fc22:	4299      	cmp	r1, r3
   2fc24:	f240 8118 	bls.w	2fe58 <__udivmoddi4+0x28c>
   2fc28:	3f02      	subs	r7, #2
   2fc2a:	442b      	add	r3, r5
   2fc2c:	1a5b      	subs	r3, r3, r1
   2fc2e:	b2a4      	uxth	r4, r4
   2fc30:	fbb3 f0fe 	udiv	r0, r3, lr
   2fc34:	fb0e 3310 	mls	r3, lr, r0, r3
   2fc38:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   2fc3c:	fb00 fc0c 	mul.w	ip, r0, ip
   2fc40:	45a4      	cmp	ip, r4
   2fc42:	d909      	bls.n	2fc58 <__udivmoddi4+0x8c>
   2fc44:	192c      	adds	r4, r5, r4
   2fc46:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   2fc4a:	f080 8107 	bcs.w	2fe5c <__udivmoddi4+0x290>
   2fc4e:	45a4      	cmp	ip, r4
   2fc50:	f240 8104 	bls.w	2fe5c <__udivmoddi4+0x290>
   2fc54:	3802      	subs	r0, #2
   2fc56:	442c      	add	r4, r5
   2fc58:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
   2fc5c:	eba4 040c 	sub.w	r4, r4, ip
   2fc60:	2700      	movs	r7, #0
   2fc62:	b11e      	cbz	r6, 2fc6c <__udivmoddi4+0xa0>
   2fc64:	40d4      	lsrs	r4, r2
   2fc66:	2300      	movs	r3, #0
   2fc68:	e9c6 4300 	strd	r4, r3, [r6]
   2fc6c:	4639      	mov	r1, r7
   2fc6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fc72:	428b      	cmp	r3, r1
   2fc74:	d909      	bls.n	2fc8a <__udivmoddi4+0xbe>
   2fc76:	2e00      	cmp	r6, #0
   2fc78:	f000 80eb 	beq.w	2fe52 <__udivmoddi4+0x286>
   2fc7c:	2700      	movs	r7, #0
   2fc7e:	e9c6 0100 	strd	r0, r1, [r6]
   2fc82:	4638      	mov	r0, r7
   2fc84:	4639      	mov	r1, r7
   2fc86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fc8a:	fab3 f783 	clz	r7, r3
   2fc8e:	2f00      	cmp	r7, #0
   2fc90:	d147      	bne.n	2fd22 <__udivmoddi4+0x156>
   2fc92:	428b      	cmp	r3, r1
   2fc94:	d302      	bcc.n	2fc9c <__udivmoddi4+0xd0>
   2fc96:	4282      	cmp	r2, r0
   2fc98:	f200 80fa 	bhi.w	2fe90 <__udivmoddi4+0x2c4>
   2fc9c:	1a84      	subs	r4, r0, r2
   2fc9e:	eb61 0303 	sbc.w	r3, r1, r3
   2fca2:	2001      	movs	r0, #1
   2fca4:	4698      	mov	r8, r3
   2fca6:	2e00      	cmp	r6, #0
   2fca8:	d0e0      	beq.n	2fc6c <__udivmoddi4+0xa0>
   2fcaa:	e9c6 4800 	strd	r4, r8, [r6]
   2fcae:	e7dd      	b.n	2fc6c <__udivmoddi4+0xa0>
   2fcb0:	b902      	cbnz	r2, 2fcb4 <__udivmoddi4+0xe8>
   2fcb2:	deff      	udf	#255	; 0xff
   2fcb4:	fab2 f282 	clz	r2, r2
   2fcb8:	2a00      	cmp	r2, #0
   2fcba:	f040 808f 	bne.w	2fddc <__udivmoddi4+0x210>
   2fcbe:	1b49      	subs	r1, r1, r5
   2fcc0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2fcc4:	fa1f f885 	uxth.w	r8, r5
   2fcc8:	2701      	movs	r7, #1
   2fcca:	fbb1 fcfe 	udiv	ip, r1, lr
   2fcce:	0c23      	lsrs	r3, r4, #16
   2fcd0:	fb0e 111c 	mls	r1, lr, ip, r1
   2fcd4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   2fcd8:	fb08 f10c 	mul.w	r1, r8, ip
   2fcdc:	4299      	cmp	r1, r3
   2fcde:	d907      	bls.n	2fcf0 <__udivmoddi4+0x124>
   2fce0:	18eb      	adds	r3, r5, r3
   2fce2:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   2fce6:	d202      	bcs.n	2fcee <__udivmoddi4+0x122>
   2fce8:	4299      	cmp	r1, r3
   2fcea:	f200 80cd 	bhi.w	2fe88 <__udivmoddi4+0x2bc>
   2fcee:	4684      	mov	ip, r0
   2fcf0:	1a59      	subs	r1, r3, r1
   2fcf2:	b2a3      	uxth	r3, r4
   2fcf4:	fbb1 f0fe 	udiv	r0, r1, lr
   2fcf8:	fb0e 1410 	mls	r4, lr, r0, r1
   2fcfc:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   2fd00:	fb08 f800 	mul.w	r8, r8, r0
   2fd04:	45a0      	cmp	r8, r4
   2fd06:	d907      	bls.n	2fd18 <__udivmoddi4+0x14c>
   2fd08:	192c      	adds	r4, r5, r4
   2fd0a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   2fd0e:	d202      	bcs.n	2fd16 <__udivmoddi4+0x14a>
   2fd10:	45a0      	cmp	r8, r4
   2fd12:	f200 80b6 	bhi.w	2fe82 <__udivmoddi4+0x2b6>
   2fd16:	4618      	mov	r0, r3
   2fd18:	eba4 0408 	sub.w	r4, r4, r8
   2fd1c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   2fd20:	e79f      	b.n	2fc62 <__udivmoddi4+0x96>
   2fd22:	f1c7 0c20 	rsb	ip, r7, #32
   2fd26:	40bb      	lsls	r3, r7
   2fd28:	fa22 fe0c 	lsr.w	lr, r2, ip
   2fd2c:	ea4e 0e03 	orr.w	lr, lr, r3
   2fd30:	fa01 f407 	lsl.w	r4, r1, r7
   2fd34:	fa20 f50c 	lsr.w	r5, r0, ip
   2fd38:	fa21 f30c 	lsr.w	r3, r1, ip
   2fd3c:	ea4f 481e 	mov.w	r8, lr, lsr #16
   2fd40:	4325      	orrs	r5, r4
   2fd42:	fbb3 f9f8 	udiv	r9, r3, r8
   2fd46:	0c2c      	lsrs	r4, r5, #16
   2fd48:	fb08 3319 	mls	r3, r8, r9, r3
   2fd4c:	fa1f fa8e 	uxth.w	sl, lr
   2fd50:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
   2fd54:	fb09 f40a 	mul.w	r4, r9, sl
   2fd58:	429c      	cmp	r4, r3
   2fd5a:	fa02 f207 	lsl.w	r2, r2, r7
   2fd5e:	fa00 f107 	lsl.w	r1, r0, r7
   2fd62:	d90b      	bls.n	2fd7c <__udivmoddi4+0x1b0>
   2fd64:	eb1e 0303 	adds.w	r3, lr, r3
   2fd68:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   2fd6c:	f080 8087 	bcs.w	2fe7e <__udivmoddi4+0x2b2>
   2fd70:	429c      	cmp	r4, r3
   2fd72:	f240 8084 	bls.w	2fe7e <__udivmoddi4+0x2b2>
   2fd76:	f1a9 0902 	sub.w	r9, r9, #2
   2fd7a:	4473      	add	r3, lr
   2fd7c:	1b1b      	subs	r3, r3, r4
   2fd7e:	b2ad      	uxth	r5, r5
   2fd80:	fbb3 f0f8 	udiv	r0, r3, r8
   2fd84:	fb08 3310 	mls	r3, r8, r0, r3
   2fd88:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
   2fd8c:	fb00 fa0a 	mul.w	sl, r0, sl
   2fd90:	45a2      	cmp	sl, r4
   2fd92:	d908      	bls.n	2fda6 <__udivmoddi4+0x1da>
   2fd94:	eb1e 0404 	adds.w	r4, lr, r4
   2fd98:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   2fd9c:	d26b      	bcs.n	2fe76 <__udivmoddi4+0x2aa>
   2fd9e:	45a2      	cmp	sl, r4
   2fda0:	d969      	bls.n	2fe76 <__udivmoddi4+0x2aa>
   2fda2:	3802      	subs	r0, #2
   2fda4:	4474      	add	r4, lr
   2fda6:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   2fdaa:	fba0 8902 	umull	r8, r9, r0, r2
   2fdae:	eba4 040a 	sub.w	r4, r4, sl
   2fdb2:	454c      	cmp	r4, r9
   2fdb4:	46c2      	mov	sl, r8
   2fdb6:	464b      	mov	r3, r9
   2fdb8:	d354      	bcc.n	2fe64 <__udivmoddi4+0x298>
   2fdba:	d051      	beq.n	2fe60 <__udivmoddi4+0x294>
   2fdbc:	2e00      	cmp	r6, #0
   2fdbe:	d069      	beq.n	2fe94 <__udivmoddi4+0x2c8>
   2fdc0:	ebb1 050a 	subs.w	r5, r1, sl
   2fdc4:	eb64 0403 	sbc.w	r4, r4, r3
   2fdc8:	fa04 fc0c 	lsl.w	ip, r4, ip
   2fdcc:	40fd      	lsrs	r5, r7
   2fdce:	40fc      	lsrs	r4, r7
   2fdd0:	ea4c 0505 	orr.w	r5, ip, r5
   2fdd4:	e9c6 5400 	strd	r5, r4, [r6]
   2fdd8:	2700      	movs	r7, #0
   2fdda:	e747      	b.n	2fc6c <__udivmoddi4+0xa0>
   2fddc:	f1c2 0320 	rsb	r3, r2, #32
   2fde0:	fa20 f703 	lsr.w	r7, r0, r3
   2fde4:	4095      	lsls	r5, r2
   2fde6:	fa01 f002 	lsl.w	r0, r1, r2
   2fdea:	fa21 f303 	lsr.w	r3, r1, r3
   2fdee:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   2fdf2:	4338      	orrs	r0, r7
   2fdf4:	0c01      	lsrs	r1, r0, #16
   2fdf6:	fbb3 f7fe 	udiv	r7, r3, lr
   2fdfa:	fa1f f885 	uxth.w	r8, r5
   2fdfe:	fb0e 3317 	mls	r3, lr, r7, r3
   2fe02:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   2fe06:	fb07 f308 	mul.w	r3, r7, r8
   2fe0a:	428b      	cmp	r3, r1
   2fe0c:	fa04 f402 	lsl.w	r4, r4, r2
   2fe10:	d907      	bls.n	2fe22 <__udivmoddi4+0x256>
   2fe12:	1869      	adds	r1, r5, r1
   2fe14:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
   2fe18:	d22f      	bcs.n	2fe7a <__udivmoddi4+0x2ae>
   2fe1a:	428b      	cmp	r3, r1
   2fe1c:	d92d      	bls.n	2fe7a <__udivmoddi4+0x2ae>
   2fe1e:	3f02      	subs	r7, #2
   2fe20:	4429      	add	r1, r5
   2fe22:	1acb      	subs	r3, r1, r3
   2fe24:	b281      	uxth	r1, r0
   2fe26:	fbb3 f0fe 	udiv	r0, r3, lr
   2fe2a:	fb0e 3310 	mls	r3, lr, r0, r3
   2fe2e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   2fe32:	fb00 f308 	mul.w	r3, r0, r8
   2fe36:	428b      	cmp	r3, r1
   2fe38:	d907      	bls.n	2fe4a <__udivmoddi4+0x27e>
   2fe3a:	1869      	adds	r1, r5, r1
   2fe3c:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   2fe40:	d217      	bcs.n	2fe72 <__udivmoddi4+0x2a6>
   2fe42:	428b      	cmp	r3, r1
   2fe44:	d915      	bls.n	2fe72 <__udivmoddi4+0x2a6>
   2fe46:	3802      	subs	r0, #2
   2fe48:	4429      	add	r1, r5
   2fe4a:	1ac9      	subs	r1, r1, r3
   2fe4c:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
   2fe50:	e73b      	b.n	2fcca <__udivmoddi4+0xfe>
   2fe52:	4637      	mov	r7, r6
   2fe54:	4630      	mov	r0, r6
   2fe56:	e709      	b.n	2fc6c <__udivmoddi4+0xa0>
   2fe58:	4607      	mov	r7, r0
   2fe5a:	e6e7      	b.n	2fc2c <__udivmoddi4+0x60>
   2fe5c:	4618      	mov	r0, r3
   2fe5e:	e6fb      	b.n	2fc58 <__udivmoddi4+0x8c>
   2fe60:	4541      	cmp	r1, r8
   2fe62:	d2ab      	bcs.n	2fdbc <__udivmoddi4+0x1f0>
   2fe64:	ebb8 0a02 	subs.w	sl, r8, r2
   2fe68:	eb69 020e 	sbc.w	r2, r9, lr
   2fe6c:	3801      	subs	r0, #1
   2fe6e:	4613      	mov	r3, r2
   2fe70:	e7a4      	b.n	2fdbc <__udivmoddi4+0x1f0>
   2fe72:	4660      	mov	r0, ip
   2fe74:	e7e9      	b.n	2fe4a <__udivmoddi4+0x27e>
   2fe76:	4618      	mov	r0, r3
   2fe78:	e795      	b.n	2fda6 <__udivmoddi4+0x1da>
   2fe7a:	4667      	mov	r7, ip
   2fe7c:	e7d1      	b.n	2fe22 <__udivmoddi4+0x256>
   2fe7e:	4681      	mov	r9, r0
   2fe80:	e77c      	b.n	2fd7c <__udivmoddi4+0x1b0>
   2fe82:	3802      	subs	r0, #2
   2fe84:	442c      	add	r4, r5
   2fe86:	e747      	b.n	2fd18 <__udivmoddi4+0x14c>
   2fe88:	f1ac 0c02 	sub.w	ip, ip, #2
   2fe8c:	442b      	add	r3, r5
   2fe8e:	e72f      	b.n	2fcf0 <__udivmoddi4+0x124>
   2fe90:	4638      	mov	r0, r7
   2fe92:	e708      	b.n	2fca6 <__udivmoddi4+0xda>
   2fe94:	4637      	mov	r7, r6
   2fe96:	e6e9      	b.n	2fc6c <__udivmoddi4+0xa0>

0002fe98 <__aeabi_idiv0>:
   2fe98:	4770      	bx	lr
   2fe9a:	bf00      	nop

Disassembly of section .fini:

0002fe9c <_fini>:
   2fe9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2fe9e:	bf00      	nop
   2fea0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2fea2:	bc08      	pop	{r3}
   2fea4:	469e      	mov	lr, r3
   2fea6:	4770      	bx	lr
